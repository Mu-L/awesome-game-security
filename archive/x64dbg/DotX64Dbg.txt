Project Path: arc_x64dbg_DotX64Dbg_xjixisjp

Source Tree:

```txt
arc_x64dbg_DotX64Dbg_xjixisjp
├── CHANGELOG.md
├── CMakeLists.txt
├── LICENSE
├── README.md
├── bin
│   ├── dotplugins
│   │   └── example
│   │       ├── AssemblerTest.cs
│   │       ├── ExamplePlugin.Commands.cs
│   │       ├── ExamplePlugin.Disassembler.cs
│   │       ├── ExamplePlugin.EvaluateExpression.cs
│   │       ├── ExamplePlugin.Events.cs
│   │       ├── ExamplePlugin.Expressions.cs
│   │       ├── ExamplePlugin.Menus.cs
│   │       ├── ExamplePlugin.cs
│   │       ├── NestedClass.Commands.cs
│   │       ├── NestedClass.cs
│   │       └── plugin.json
│   ├── dotscripts
│   │   └── TestScript.cs
│   └── dotx64dbg.json
├── cmake.toml
├── cmkr.cmake
├── src
│   ├── Bindings
│   │   ├── AsmJitHelper.hpp
│   │   ├── Breakpoints.cpp
│   │   ├── Commands.cpp
│   │   ├── Debugger.cpp
│   │   ├── Decoder.Converter.hpp
│   │   ├── Encoder.Converter.hpp
│   │   ├── Expressions.cpp
│   │   ├── Instruction.Decoder.cpp
│   │   ├── Instruction.Decoder.hpp
│   │   ├── Instruction.EFlags.hpp
│   │   ├── Instruction.Encoder.cpp
│   │   ├── Instruction.Encoder.hpp
│   │   ├── Instruction.Generator.cpp
│   │   ├── Instruction.Generator.hpp
│   │   ├── Instruction.Meta.hpp
│   │   ├── Instruction.Operand.hpp
│   │   ├── Instruction.Operands.hpp
│   │   ├── Instruction.cpp
│   │   ├── Instruction.hpp
│   │   ├── Logging.cpp
│   │   ├── Marshal.hpp
│   │   ├── Memory.cpp
│   │   ├── Mnemonic.hpp
│   │   ├── Module.cpp
│   │   ├── Platform.cpp
│   │   ├── Plugin.cpp
│   │   ├── Process.cpp
│   │   ├── Register.hpp
│   │   ├── Settings.cpp
│   │   ├── Symbols.cpp
│   │   ├── Thread.cpp
│   │   └── UI.cpp
│   ├── Dotx64Dbg
│   │   ├── Loader.cpp
│   │   └── Plugin.cpp
│   ├── Dotx64DbgLoader
│   │   └── Loader.cpp
│   ├── Dotx64DbgTests
│   │   ├── Runner.cs
│   │   ├── Testing.cs
│   │   └── Tests
│   │       ├── Tests.Assembler.cs
│   │       ├── Tests.Decoder.cs
│   │       ├── Tests.Generator.cs
│   │       ├── Tests.Operands.cs
│   │       ├── Tests.RegisterMaskGp.cs
│   │       └── Tests.Registers.cs
│   ├── Dotx64Managed
│   │   ├── API
│   │   │   ├── Analysis
│   │   │   │   └── RegisterMask.cs
│   │   │   ├── Assembler.Instructions.cs
│   │   │   ├── Assembler.cs
│   │   │   ├── Breakpoints.cs
│   │   │   ├── Commands.cs
│   │   │   ├── Debugger.cs
│   │   │   ├── Expressions.cs
│   │   │   ├── Memory.Stream.cs
│   │   │   ├── Memory.cs
│   │   │   ├── Module.Exports.cs
│   │   │   ├── Module.Imports.cs
│   │   │   ├── Module.Sections.cs
│   │   │   ├── Module.cs
│   │   │   ├── Platform.cs
│   │   │   ├── Process.cs
│   │   │   ├── Thread.Register.cs
│   │   │   ├── Thread.cs
│   │   │   └── UI
│   │   │       ├── Disassembly.cs
│   │   │       ├── Dump.cs
│   │   │       ├── Log.cs
│   │   │       ├── MemoryMap.cs
│   │   │       ├── Menu.cs
│   │   │       ├── Stack.cs
│   │   │       ├── StatusBar.cs
│   │   │       ├── Types.cs
│   │   │       └── UI.cs
│   │   ├── AssemblyLoader.cs
│   │   ├── Compiler.cs
│   │   ├── Hotload
│   │   │   ├── Hotload.Adapter.Array.cs
│   │   │   ├── Hotload.Adapter.Class.cs
│   │   │   ├── Hotload.Adapter.GenericDictionary.cs
│   │   │   ├── Hotload.Adapter.GenericList.cs
│   │   │   ├── Hotload.Adapter.Object.cs
│   │   │   ├── Hotload.Adapter.Statics.cs
│   │   │   ├── Hotload.Adapter.cs
│   │   │   ├── Hotload.Context.cs
│   │   │   └── Hotload.cs
│   │   ├── IPlugin.cs
│   │   ├── Logging.cs
│   │   ├── Manager.Events.cs
│   │   ├── Manager.cs
│   │   ├── Menus.Main.cs
│   │   ├── Menus.cs
│   │   ├── NodeList.cs
│   │   ├── Plugins.Builder.cs
│   │   ├── Plugins.DependencyManager.cs
│   │   ├── Plugins.Hotload.cs
│   │   ├── Plugins.Watcher.cs
│   │   ├── Plugins.cs
│   │   ├── ProjectGenerator.cs
│   │   ├── Resources.cs
│   │   ├── ScriptLoader.cs
│   │   ├── Scripting
│   │   │   ├── Scripting.Register.cs
│   │   │   └── Scripting.cs
│   │   ├── Settings.cs
│   │   ├── Template
│   │   │   ├── plugin.cs
│   │   │   └── plugin.json
│   │   ├── Tests.cs
│   │   └── Utils.cs
│   └── Resources
│       ├── Dotx64DbgIcon.png
│       ├── NewScriptIcon.png
│       ├── RunIcon.png
│       └── Template
│           ├── plugin.cs
│           └── plugin.json
└── thirdparty
    ├── CMakeLists.txt
    └── cmake.toml

```

`CHANGELOG.md`:

```md
0.0.1
------------------------------------------------------------------------
- First release
```

`CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

cmake_minimum_required(VERSION 3.15)

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

set(CMKR_ROOT_PROJECT OFF)
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
	set(CMKR_ROOT_PROJECT ON)

	# Bootstrap cmkr and automatically regenerate CMakeLists.txt
	include(cmkr.cmake OPTIONAL RESULT_VARIABLE CMKR_INCLUDE_RESULT)
	if(CMKR_INCLUDE_RESULT)
		cmkr()
	endif()

	# Enable folder support
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)

	# Create a configure-time dependency on cmake.toml to improve IDE support
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

project(Dotx64Dbg
	LANGUAGES
		CSharp
		CXX
)

include(CSharpUtilities)

# Only have Release and Debug, there are configuration errors with managed otherwise.
SET(CMAKE_CONFIGURATION_TYPES "Debug;Release")
SET(CMAKE_VS_NUGET_PACKAGE_RESTORE ON)

# Workaround for CLR projects, there is a pending fix for this:
# https://gitlab.kitware.com/cmake/cmake/-/merge_requests/7807 which corrects the exception option in use of CLR
string(REPLACE "/EHsc" "" CMAKE_CXX_FLAGS_INIT "${CMAKE_CXX_FLAGS_INIT}")
string(REPLACE "/RTC1" "" CMAKE_CXX_FLAGS_DEBUG_INIT "${CMAKE_CXX_FLAGS_DEBUG_INIT}")
string(REPLACE "/EHsc" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
string(REPLACE "/RTC1" "" CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}")

if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(BUILD_OUTPUT_DIR ${CMAKE_SOURCE_DIR}/bin/x64)
elseif(CMAKE_SIZEOF_VOID_P EQUAL 4)
    set(BUILD_OUTPUT_DIR ${CMAKE_SOURCE_DIR}/bin/x32)
endif()

# Subdirectory: thirdparty
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/thirdparty")
else()
	set(CMAKE_FOLDER thirdparty)
endif()
add_subdirectory(thirdparty)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})

# Target: Dotx64DbgCommon
add_library(Dotx64DbgCommon INTERFACE)

add_library(dotx64dbg::common ALIAS Dotx64DbgCommon)
target_compile_features(Dotx64DbgCommon INTERFACE
	cxx_std_17
)

target_compile_options(Dotx64DbgCommon INTERFACE
	"/MP"
)

target_link_options(Dotx64DbgCommon INTERFACE
	"/DEBUG"
)

# Target: Dotx64DbgBindings
set(Dotx64DbgBindings_SOURCES
	"src/Bindings/Breakpoints.cpp"
	"src/Bindings/Commands.cpp"
	"src/Bindings/Debugger.cpp"
	"src/Bindings/Expressions.cpp"
	"src/Bindings/Instruction.cpp"
	"src/Bindings/Instruction.Decoder.cpp"
	"src/Bindings/Instruction.Encoder.cpp"
	"src/Bindings/Instruction.Generator.cpp"
	"src/Bindings/Logging.cpp"
	"src/Bindings/Memory.cpp"
	"src/Bindings/Module.cpp"
	"src/Bindings/Platform.cpp"
	"src/Bindings/Process.cpp"
	"src/Bindings/Settings.cpp"
	"src/Bindings/Symbols.cpp"
	"src/Bindings/Thread.cpp"
	"src/Bindings/UI.cpp"
	"src/Bindings/AsmJitHelper.hpp"
	"src/Bindings/Decoder.Converter.hpp"
	"src/Bindings/Encoder.Converter.hpp"
	"src/Bindings/Instruction.Decoder.hpp"
	"src/Bindings/Instruction.EFlags.hpp"
	"src/Bindings/Instruction.Encoder.hpp"
	"src/Bindings/Instruction.Generator.hpp"
	"src/Bindings/Instruction.Meta.hpp"
	"src/Bindings/Instruction.Operand.hpp"
	"src/Bindings/Instruction.Operands.hpp"
	"src/Bindings/Instruction.hpp"
	"src/Bindings/Marshal.hpp"
	"src/Bindings/Mnemonic.hpp"
	"src/Bindings/Register.hpp"
	cmake.toml
)

add_library(Dotx64DbgBindings SHARED)

target_sources(Dotx64DbgBindings PRIVATE ${Dotx64DbgBindings_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${Dotx64DbgBindings_SOURCES})

add_library(dotx64dbg::bindings ALIAS Dotx64DbgBindings)
target_link_libraries(Dotx64DbgBindings PRIVATE
	dotx64dbg::common
	x64dbg::pluginsdk
	asmjit::asmjit
	Zydis
)

set_target_properties(Dotx64DbgBindings PROPERTIES
	RUNTIME_OUTPUT_NAME
		Dotx64DbgBindings
	DOTNET_TARGET_FRAMEWORK
		net6.0
	DOTNET_TARGET_FRAMEWORK_VERSION
		6.0
	COMMON_LANGUAGE_RUNTIME
		netcore
	VS_GLOBAL_ResolveNuGetPackages
		false
)

if(CMAKE_SIZEOF_VOID_P EQUAL 8) # x64
	set_target_properties(Dotx64DbgBindings PROPERTIES
		RUNTIME_OUTPUT_DIRECTORY_RELEASE
			${BUILD_OUTPUT_DIR}
		RUNTIME_OUTPUT_DIRECTORY_DEBUG
			${BUILD_OUTPUT_DIR}
	)
endif()

if(CMAKE_SIZEOF_VOID_P EQUAL 4) # x32
	set_target_properties(Dotx64DbgBindings PROPERTIES
		RUNTIME_OUTPUT_DIRECTORY_RELEASE
			${BUILD_OUTPUT_DIR}
		RUNTIME_OUTPUT_DIRECTORY_DEBUG
			${BUILD_OUTPUT_DIR}
	)
endif()

set(CMKR_TARGET Dotx64DbgBindings)
if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    target_link_options(Dotx64DbgBindings PRIVATE "/DELAYLOAD:x64dbg.dll")
    target_link_options(Dotx64DbgBindings PRIVATE "/DELAYLOAD:x64bridge.dll")
elseif(CMAKE_SIZEOF_VOID_P EQUAL 4)
    target_link_options(Dotx64DbgBindings PRIVATE "/DELAYLOAD:x32dbg.dll")
    target_link_options(Dotx64DbgBindings PRIVATE "/DELAYLOAD:x32bridge.dll")
endif()
target_link_options(Dotx64DbgBindings PRIVATE "/DELAYLOAD:titanengine.dll")

# Target: Dotx64DbgManaged
set(Dotx64DbgManaged_SOURCES
	"src/Dotx64Managed/API/Analysis/RegisterMask.cs"
	"src/Dotx64Managed/API/Assembler.cs"
	"src/Dotx64Managed/API/Assembler.Instructions.cs"
	"src/Dotx64Managed/API/Breakpoints.cs"
	"src/Dotx64Managed/API/Commands.cs"
	"src/Dotx64Managed/API/Debugger.cs"
	"src/Dotx64Managed/API/Expressions.cs"
	"src/Dotx64Managed/API/Memory.cs"
	"src/Dotx64Managed/API/Memory.Stream.cs"
	"src/Dotx64Managed/API/Module.cs"
	"src/Dotx64Managed/API/Module.Exports.cs"
	"src/Dotx64Managed/API/Module.Imports.cs"
	"src/Dotx64Managed/API/Module.Sections.cs"
	"src/Dotx64Managed/API/Platform.cs"
	"src/Dotx64Managed/API/Process.cs"
	"src/Dotx64Managed/API/Thread.cs"
	"src/Dotx64Managed/API/Thread.Register.cs"
	"src/Dotx64Managed/API/UI/Disassembly.cs"
	"src/Dotx64Managed/API/UI/Dump.cs"
	"src/Dotx64Managed/API/UI/Log.cs"
	"src/Dotx64Managed/API/UI/MemoryMap.cs"
	"src/Dotx64Managed/API/UI/Menu.cs"
	"src/Dotx64Managed/API/UI/Stack.cs"
	"src/Dotx64Managed/API/UI/StatusBar.cs"
	"src/Dotx64Managed/API/UI/Types.cs"
	"src/Dotx64Managed/API/UI/UI.cs"
	"src/Dotx64Managed/AssemblyLoader.cs"
	"src/Dotx64Managed/Compiler.cs"
	"src/Dotx64Managed/Hotload/Hotload.Adapter.Array.cs"
	"src/Dotx64Managed/Hotload/Hotload.Adapter.Class.cs"
	"src/Dotx64Managed/Hotload/Hotload.Adapter.cs"
	"src/Dotx64Managed/Hotload/Hotload.Adapter.GenericDictionary.cs"
	"src/Dotx64Managed/Hotload/Hotload.Adapter.GenericList.cs"
	"src/Dotx64Managed/Hotload/Hotload.Adapter.Object.cs"
	"src/Dotx64Managed/Hotload/Hotload.Adapter.Statics.cs"
	"src/Dotx64Managed/Hotload/Hotload.Context.cs"
	"src/Dotx64Managed/Hotload/Hotload.cs"
	"src/Dotx64Managed/IPlugin.cs"
	"src/Dotx64Managed/Logging.cs"
	"src/Dotx64Managed/Manager.cs"
	"src/Dotx64Managed/Manager.Events.cs"
	"src/Dotx64Managed/Menus.cs"
	"src/Dotx64Managed/Menus.Main.cs"
	"src/Dotx64Managed/NodeList.cs"
	"src/Dotx64Managed/Plugins.Builder.cs"
	"src/Dotx64Managed/Plugins.cs"
	"src/Dotx64Managed/Plugins.DependencyManager.cs"
	"src/Dotx64Managed/Plugins.Hotload.cs"
	"src/Dotx64Managed/Plugins.Watcher.cs"
	"src/Dotx64Managed/ProjectGenerator.cs"
	"src/Dotx64Managed/Resources.cs"
	"src/Dotx64Managed/Scripting/Scripting.cs"
	"src/Dotx64Managed/Scripting/Scripting.Register.cs"
	"src/Dotx64Managed/ScriptLoader.cs"
	"src/Dotx64Managed/Settings.cs"
	"src/Dotx64Managed/Tests.cs"
	"src/Dotx64Managed/Utils.cs"
	cmake.toml
)

add_library(Dotx64DbgManaged SHARED)

target_sources(Dotx64DbgManaged PRIVATE ${Dotx64DbgManaged_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${Dotx64DbgManaged_SOURCES})

add_library(dotx64dbg::managed ALIAS Dotx64DbgManaged)
if(CMAKE_SIZEOF_VOID_P EQUAL 4) # x32
	target_compile_definitions(Dotx64DbgManaged PRIVATE
		_X86_
	)
endif()

if(CMAKE_SIZEOF_VOID_P EQUAL 8) # x64
	target_compile_definitions(Dotx64DbgManaged PRIVATE
		_X64_
	)
endif()

target_link_libraries(Dotx64DbgManaged PRIVATE
	dotx64dbg::bindings
)

set_target_properties(Dotx64DbgManaged PROPERTIES
	RUNTIME_OUTPUT_NAME
		Dotx64DbgManaged
	DOTNET_SDK
		Microsoft.NET.Sdk
	DOTNET_TARGET_FRAMEWORK
		net6.0
	VS_GLOBAL_ResolveNuGetPackages
		true
	VS_GLOBAL_ROOTNAMESPACE
		Dotx64Dbg
	VS_GLOBAL_AppendTargetFrameworkToOutputPath
		false
	VS_GLOBAL_AppendRuntimeIdentifierToOutputPath
		false
	VS_GLOBAL_ProduceReferenceAssembly
		false
	VS_GLOBAL_ProduceReferenceAssemblyInOutDir
		false
	VS_GLOBAL_CopyLocalLockFileAssemblies
		true
	VS_GLOBAL_SatelliteResourceLanguages
		neutral
	VS_PACKAGE_REFERENCES
		"Microsoft.CodeAnalysis.Compilers_3.10.0;NuGet.Configuration_5.11.5;NuGet.Frameworks_5.11.5;NuGet.Protocol_5.11.5;NuGet.Versioning_5.11.5"
	VS_DOTNET_REFERENCES_COPY_LOCAL
		false
)

if(CMAKE_SIZEOF_VOID_P EQUAL 4) # x32
	set_target_properties(Dotx64DbgManaged PROPERTIES
		VS_GLOBAL_PlatformTarget
			x86
		RUNTIME_OUTPUT_DIRECTORY_RELEASE
			${BUILD_OUTPUT_DIR}
		RUNTIME_OUTPUT_DIRECTORY_DEBUG
			${BUILD_OUTPUT_DIR}
	)
endif()

if(CMAKE_SIZEOF_VOID_P EQUAL 8) # x64
	set_target_properties(Dotx64DbgManaged PROPERTIES
		VS_GLOBAL_PlatformTarget
			x64
		RUNTIME_OUTPUT_DIRECTORY_RELEASE
			${BUILD_OUTPUT_DIR}
		RUNTIME_OUTPUT_DIRECTORY_DEBUG
			${BUILD_OUTPUT_DIR}
	)
endif()

# Target: Dotx64DbgTests
set(Dotx64DbgTests_SOURCES
	"src/Dotx64DbgTests/Testing.cs"
	"src/Dotx64DbgTests/Runner.cs"
	"src/Dotx64DbgTests/Tests/Tests.Assembler.cs"
	"src/Dotx64DbgTests/Tests/Tests.Decoder.cs"
	"src/Dotx64DbgTests/Tests/Tests.Generator.cs"
	"src/Dotx64DbgTests/Tests/Tests.Operands.cs"
	"src/Dotx64DbgTests/Tests/Tests.RegisterMaskGp.cs"
	"src/Dotx64DbgTests/Tests/Tests.Registers.cs"
	cmake.toml
)

add_executable(Dotx64DbgTests)

target_sources(Dotx64DbgTests PRIVATE ${Dotx64DbgTests_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${Dotx64DbgTests_SOURCES})

if(CMAKE_SIZEOF_VOID_P EQUAL 4) # x32
	target_compile_definitions(Dotx64DbgTests PRIVATE
		_X86_
	)
endif()

if(CMAKE_SIZEOF_VOID_P EQUAL 8) # x64
	target_compile_definitions(Dotx64DbgTests PRIVATE
		_X64_
	)
endif()

target_link_libraries(Dotx64DbgTests PRIVATE
	dotx64dbg::managed
	dotx64dbg::bindings
)

set_target_properties(Dotx64DbgTests PROPERTIES
	RUNTIME_OUTPUT_NAME
		Dotx64DbgTests
	DOTNET_SDK
		Microsoft.NET.Sdk
	DOTNET_TARGET_FRAMEWORK
		net6.0
	VS_GLOBAL_ROOTNAMESPACE
		Dotx64Dbg
	VS_GLOBAL_AppendTargetFrameworkToOutputPath
		false
	VS_GLOBAL_AppendRuntimeIdentifierToOutputPath
		false
	VS_GLOBAL_ProduceReferenceAssembly
		false
	VS_GLOBAL_ProduceReferenceAssemblyInOutDir
		false
	VS_GLOBAL_CopyLocalLockFileAssemblies
		true
	VS_GLOBAL_SatelliteResourceLanguages
		neutral
	VS_DOTNET_REFERENCES_COPY_LOCAL
		true
)

if(CMAKE_SIZEOF_VOID_P EQUAL 4) # x32
	set_target_properties(Dotx64DbgTests PROPERTIES
		VS_GLOBAL_PlatformTarget
			x86
		RUNTIME_OUTPUT_DIRECTORY_RELEASE
			"${BUILD_OUTPUT_DIR}/tests"
		RUNTIME_OUTPUT_DIRECTORY_DEBUG
			"${BUILD_OUTPUT_DIR}/tests"
	)
endif()

if(CMAKE_SIZEOF_VOID_P EQUAL 8) # x64
	set_target_properties(Dotx64DbgTests PROPERTIES
		VS_GLOBAL_PlatformTarget
			x64
		RUNTIME_OUTPUT_DIRECTORY_RELEASE
			"${BUILD_OUTPUT_DIR}/tests"
		RUNTIME_OUTPUT_DIRECTORY_DEBUG
			"${BUILD_OUTPUT_DIR}/tests"
	)
endif()

get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
if(NOT CMKR_VS_STARTUP_PROJECT)
	set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT Dotx64DbgTests)
endif()

# Target: Dotx64Dbg
set(Dotx64Dbg_SOURCES
	"src/Dotx64Dbg/Loader.cpp"
	"src/Dotx64Dbg/Plugin.cpp"
	cmake.toml
)

add_library(Dotx64Dbg SHARED)

target_sources(Dotx64Dbg PRIVATE ${Dotx64Dbg_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${Dotx64Dbg_SOURCES})

add_library(dotx64dbg::dotx64dbg ALIAS Dotx64Dbg)
target_link_libraries(Dotx64Dbg PRIVATE
	dotx64dbg::common
	x64dbg::pluginsdk
	dotx64dbg::managed
)

set_target_properties(Dotx64Dbg PROPERTIES
	DOTNET_TARGET_FRAMEWORK
		net6.0
	DOTNET_TARGET_FRAMEWORK_VERSION
		6.0
	COMMON_LANGUAGE_RUNTIME
		netcore
	VS_GLOBAL_ResolveNuGetPackages
		false
	VS_GLOBAL_SatelliteResourceLanguages
		neutral
)

if(CMAKE_SIZEOF_VOID_P EQUAL 8) # x64
	set_target_properties(Dotx64Dbg PROPERTIES
		RUNTIME_OUTPUT_DIRECTORY_RELEASE
			${BUILD_OUTPUT_DIR}
		RUNTIME_OUTPUT_DIRECTORY_DEBUG
			${BUILD_OUTPUT_DIR}
	)
endif()

if(CMAKE_SIZEOF_VOID_P EQUAL 4) # x32
	set_target_properties(Dotx64Dbg PROPERTIES
		RUNTIME_OUTPUT_DIRECTORY_RELEASE
			${BUILD_OUTPUT_DIR}
		RUNTIME_OUTPUT_DIRECTORY_DEBUG
			${BUILD_OUTPUT_DIR}
	)
endif()

# Target: Dotx64DbgLoader
set(Dotx64DbgLoader_SOURCES
	"src/Dotx64DbgLoader/Loader.cpp"
	cmake.toml
)

add_library(Dotx64DbgLoader SHARED)

target_sources(Dotx64DbgLoader PRIVATE ${Dotx64DbgLoader_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${Dotx64DbgLoader_SOURCES})

if(CMAKE_SIZEOF_VOID_P EQUAL 4) # x32
	target_compile_definitions(Dotx64DbgLoader PRIVATE
		_X86_
	)
endif()

if(CMAKE_SIZEOF_VOID_P EQUAL 8) # x64
	target_compile_definitions(Dotx64DbgLoader PRIVATE
		_X64_
	)
endif()

target_link_libraries(Dotx64DbgLoader PRIVATE
	dotx64dbg::common
	x64dbg::pluginsdk
)

set_target_properties(Dotx64DbgLoader PROPERTIES
	VS_GLOBAL_ResolveNuGetPackages
		false
	RUNTIME_OUTPUT_NAME
		Dotx64Dbg
)

if(CMAKE_SIZEOF_VOID_P EQUAL 8) # x64
	set_target_properties(Dotx64DbgLoader PROPERTIES
		SUFFIX
			.dp64
		RUNTIME_OUTPUT_DIRECTORY_RELEASE
			${BUILD_OUTPUT_DIR}
		RUNTIME_OUTPUT_DIRECTORY_DEBUG
			${BUILD_OUTPUT_DIR}
	)
endif()

if(CMAKE_SIZEOF_VOID_P EQUAL 4) # x32
	set_target_properties(Dotx64DbgLoader PROPERTIES
		SUFFIX
			.dp32
		RUNTIME_OUTPUT_DIRECTORY_RELEASE
			${BUILD_OUTPUT_DIR}
		RUNTIME_OUTPUT_DIRECTORY_DEBUG
			${BUILD_OUTPUT_DIR}
	)
endif()

# Target: Dotx64DbgResources
set(Dotx64DbgResources_SOURCES
	cmake.toml
)

add_custom_target(Dotx64DbgResources SOURCES)

target_sources(Dotx64DbgResources PRIVATE ${Dotx64DbgResources_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${Dotx64DbgResources_SOURCES})

set(CMKR_TARGET Dotx64DbgResources)
add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_directory
      ${CMAKE_SOURCE_DIR}/src/Resources
      ${BUILD_OUTPUT_DIR}/Resources
)

```

`LICENSE`:

```
MIT License

Copyright (c) 2018 ζeh Matt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# DotX64Dbg (EARLY ALPHA)
Plugins and Scripting with C# for x64Dbg.

# Create Plugins for X64Dbg with ease
DotX64Dbg aims to provide a seamless way to write and test plugins
for X64Dbg using .Net 6.0 and C#.

You can create/edit/debug plugins without ever restarting x64Dbg.
![Live Coding](.github/media/livecoding.gif?raw=true)

This gif showcases how you debug and edit your plugin at the same
time, this also showcases how you can register custom commands for
x64Dbg on the fly, the same works also for expressions.

## No more binaries
DotX64Dbg does not load the plugins as binaries instead it will
automatically compile your plugin code as soon something changes
and reloads it, this also means all plugins will be shipped as pure
code which means its a lot harder to hide malicious code in there.

# Installing
There is currently no official release. You can grab the latest artifacts
from the CI to try it out or build it yourself. Also older versions of
x64dbg are not supported by this plugin, we recommend to use the latest
builds.

# Your first Plugin
Creating new plugins is as easy as creating a new folder with two new files.
By default the DotX64Dbg plugins are located in the root directory of X64Dbg 
called ```dotplugins``` this can be however configured via ```dotx64dbg.json```.

Simply create a new folder in ```dotplugins``` called ```SamplePlugin```, plugins
are required to have a file called ```plugin.json``` which should look like
following:
```json
{
  "Name": "Sample Plugin",
  "Description": "My awesome plugin",
  "Version": "1.0.0",
  "Author": "Bob",
  "Website": "http://github.com/[youruser]/yourplugin",
}
```
Without the ```plugin.json``` file plugins will not load. The last thing
you need is some code that defines the plugin entry class, this is done by
deriving from ```IPlugin```, you can have only one class that derives from 
this interface. 
Create a file named ```SamplePlugin.cs```, you can choose any filename you like. 
To bootstrap the plugin you need at least following minimal example:
```csharp
using System;
using Dotx64Dbg;

public class SamplePlugin : IPlugin
{
    public SamplePlugin()
    {
        // Constructor, only called during first load
    }
    
    // Called as soon the plugin is fully initialized, this is called after
    // the constructor and only once the for the initial plugin load.
    public void Startup()
    {
        Console.WriteLine("Startup time!");
    }
    
    // Called before the plugin is about to be unloaded.
    public void Shutdown()
    {
        Console.WriteLine("We are about to go offline");
    }
}
```
After the two files are created DotX64Dbg will detect the changes
and immediately starts compiling/(re-)loading the plugin. DotX64Dbg
will also automatically generate a ```.csproj``` file with the correct
assembly references being setup. If you want to debug your plugins
simply attach Visual Studio to x64Dbg and place the breakpoints where
you would like to stop, its as simple as that.

There is also a comprehensive example plugin available [here](bin/dotplugins/example)

# Scripting
DotX64Dbg also provides a scripting interface, unlike plugins a script
will be without state and only executes once. Scripts can use the same
APIs as plugins. To execute scripts use following command:
```
dotscript <path to script file>
```
You can find an example script [here](bin/dotscripts/TestScript.cs)

# Building

## Requirements
- Net 6.0 SDK.
- Visual Studio 2019 Community or greater.

## Building
After everything is setup you should be open Dotx64Dbg.sln and be able
to build the entire solution.

# Documentation
The plan is to document all public API which also makes the documentation
available to Intellisense. A good starting point is to check the plugin
example, a lot of functions and classes already have minimal documentation, 
the best way to find out whats there is to explore the Assembly in Visual Studio 
with the Object Explorer.
![Object Explorer](.github/media/objectexplorer.png?raw=true)

```

`bin/dotplugins/example/AssemblerTest.cs`:

```cs
using System;
using Dotx64Dbg;
using static Dotx64Dbg.Operands;

public class AssemblerTest
{
    public AssemblerTest()
    {
    }

    [Command("TestAssembler")]
    public void BasicAssembly(string[] args)
    {
        nuint ip = Thread.Active != null ? Thread.Active.Nip : 0;
        using (var asm = new Assembler(ip))
        {
#if _X64_
            // Create some assembly.
            asm
                .Mov(R9, R10)
                .Shl(R9, Imm(1))
                .Push(Rax)
                .Pop(Rdx)
                .Lea(Rsp, QwordPtr(Rsp, -8))
                .Xchg(Rax, Rdx)
                .Ret()
                ;

            // Insert at the beginning.
            asm.Cursor = null;
            asm
                .Push(R9)
                .Pop(R10)
                ;

#else
            asm
                .Mov(Eax, Edx)
                .Shl(Edx, Imm(1))
                .Push(Eax)
                .Pop(Edx)
                .Lea(Esp, Ptr(Esp, -4))
                .Xchg(Eax, Edx)
                .Ret()
                ;
#endif
            // Serialize the nodes into x86.
            asm.Finalize();

            // Write into process.
            var bytes = asm.GetData();

            var bytesWritten = Memory.Write(ip, bytes);
            Console.WriteLine($"Wrote {bytesWritten} bytes");

            UI.Disassembly.Update();

        }
    }

    [Command("AssembleFromIP")]
    public void EncodeIntoAssembler(string[] args)
    {
        var decoder = Decoder.Create();
        nuint ip = Thread.Active.Nip;
        var asm = new Assembler(ip);

        var instr = decoder.Decode(ip);
        asm.Emit(instr);

        // Serialize the nodes into x86.
        asm.Finalize();

        // Write into process.
        var bytes = asm.GetData();

        var bytesWritten = Memory.Write(ip, bytes);
        Console.WriteLine($"Wrote {bytesWritten} bytes");

        UI.Disassembly.Update();
    }

    [Command("AssembleWithLabel")]
    public void AssemblerWithLabels(string[] args)
    {
        nuint ip = Thread.Active.Nip;

        var asm = new Assembler(ip);

        var myLabel = asm.CreateLabel();

        asm.Mov(Eax, Imm(12))
            .Xor(Edx, Edx)
            .Cmp(Eax, Edx)
            .Jmp(myLabel)
            .Nop()
            .Nop()
            .BindLabel(myLabel)
            .Ret()
            ;

        // Serialize the nodes into x86.
        asm.Finalize();

        // Write into process.
        var bytes = asm.GetData();

        var bytesWritten = Memory.Write(ip, bytes);
        Console.WriteLine($"Wrote {bytesWritten} bytes");

        UI.Disassembly.Update();
    }
	
}
```

`bin/dotplugins/example/ExamplePlugin.Commands.cs`:

```cs
using Dotx64Dbg;
using System;

public partial class ExamplePlugin
{
    // Works at any given time.
    [Command("Test1")]
    void MyCommand(string[] args)
    {
        Console.WriteLine($"Hello World: {args[0]}");
    }

    // Works only when the debugger is active.
    [Command("Test2", DebugOnly = true)]
    void MyCommand2(string[] args)
    {
        Console.WriteLine("Debugger active, lets go!");
    }

    // Allows to return a status
    [Command("Test3")]
    bool MyCommand3(string[] args)
    {
        Console.WriteLine("Oh no");
        return false; // Indicates failure.
    }
    
    [Command("SetStatusText")]
    void SetStatusBarText(string[] args)
    {
        UI.StatusBar.Text = args[1] ?? "";
    }

    [Command("Selection")]
    void PrintSelection(string[] args)
    {
        var sel = Dotx64Dbg.UI.Disassembly.GetSelection();
        if (sel == null)
        {
            Console.WriteLine("No selection");
            return;
        }
        Console.WriteLine($"Selection Start: {sel.Start:X}, End: {sel.End:X}");
    }
	
	[Command("CmdNoArgs")]
	void NoArgsCmd()
	{
		Console.WriteLine("Yup");
	}
	
	[Command("CmdNoArgs2")]
	bool NoArgsCmd2()
	{
		Console.WriteLine("Yup");
		return false;
	}
}

```

`bin/dotplugins/example/ExamplePlugin.Disassembler.cs`:

```cs
using System;
using Dotx64Dbg;

public partial class ExamplePlugin : IPlugin, IHotload
{

    [Command("DisassembleIP", DebugOnly = true)]
    public void DisassembleAtIP(string[] args)
    {
        var decoder = Decoder.Create();
        var ip = Thread.Main.Nip;

        var decodedInstr = decoder.Decode(ip);

        var instrText = $"Instruction {{\n"
            + $"  Text = {decodedInstr},\n"
            + $"  Info = {{\n"
            + $"    Flags Read = {decodedInstr.FlagsRead}\n"
            + $"    Flags Write = {decodedInstr.FlagsWrite}\n"
            + $"  }},\n"
            + $"  Operands = {{\n";

        for(int i = 0; i < 4 ;i++)
        {
            var op = decodedInstr.GetOperand(i);
            if (op.Type == OperandType.None)
                break;

            var visibility = decodedInstr.GetOperandVisibility(i);

            instrText += $"    Operand[{i}] = ";
            switch (op.Type)
            {
                case OperandType.Immediate:
                    var imm = op as Operand.Immediate;
                    instrText += $"{{ {visibility}, Imm({imm.Value:X}) }},\n";
                    break;
                case OperandType.Register:
                    var reg = op as Operand.Register;
                    instrText += $"{{ {visibility}, Reg({reg}) }},\n";
                    break;
                case OperandType.Memory:
                    var mem = op as Operand.Memory;
                    instrText += $"{{ {visibility}, Memory {{\n";
                    instrText += $"      Base = {mem.Base},\n";
                    instrText += $"      Index = {mem.Index},\n";
                    instrText += $"      Scale = {mem.Scale}\n";
                    instrText += $"      Disp = {mem.Displacement},\n";
                    instrText += $"   }} }},\n";
                    break;
            }
        }

        instrText += $"  }}\n";
        instrText += $"}}";

        Console.WriteLine(instrText);
    }
}

```

`bin/dotplugins/example/ExamplePlugin.EvaluateExpression.cs`:

```cs
using Dotx64Dbg;
using System;

public partial class ExamplePlugin
{
    [Command("EvaluateExpressions01", DebugOnly = true)]
    void EvalExpr01(string[] args)
    {
        // Evaluate the expression "cip"
        var result = Expressions.Evaluate("cip");
        System.Diagnostics.Debug.Assert(result == Dotx64Dbg.Thread.Active.Nip);
        Console.WriteLine($"cip = {result:X}");
    }

    [Command("EvaluateExpressions02", DebugOnly = true)]
    void EvalExpr02(string[] args)
    {
        // Get the address of NtQueryProcessInformation
        var result = Expressions.Evaluate("kernel32:LoadLibraryA");
        System.Diagnostics.Debug.Assert(result != 0);

        var mod = Module.FindByAddress(result);
        System.Diagnostics.Debug.Assert(mod != null);

        Console.WriteLine($"kernel32:LoadLibraryA = {result:X}");
    }

    [Command("EvaluateExpressions03", DebugOnly = true)]
    void EvalExpr03(string[] args)
    {
        // Evaluate the value of eax+5
        var result = Expressions.Evaluate("eax+5");
        System.Diagnostics.Debug.Assert(result == Thread.Active.Eax + 5);

        Console.WriteLine($"eax+5 = {result:X}");
    }

    [Command("EvaluateExpressions04", DebugOnly = true)]
    void EvalExpr04(string[] args)
    {
        // Use a sub expression like ReadPtr to read memory
        var result = Expressions.Evaluate("ReadPtr(csp)");
        System.Diagnostics.Debug.Assert(result == Memory.ReadPtr(Thread.Active.Nsp));

        Console.WriteLine($"ReadPtr(csp) = {result:X}");
    } 
}

```

`bin/dotplugins/example/ExamplePlugin.Events.cs`:

```cs
using Dotx64Dbg;
using System;

public partial class ExamplePlugin
{
    public void OnExceptionEvent(ExceptionEventInfo ev)
    {
        //Utils.PrintFields(ev);
    }

    public void OnThreadCreateEvent(ThreadCreateEventInfo ev)
    {
        //Utils.PrintFields(ev);
    }

    public void OnThreadExitEvent(ThreadExitEventInfo ev)
    {
        //Utils.PrintFields(ev);
    }

    public void OnProcessCreateEvent(ProcessCreateEventInfo ev)
    {
        //Utils.PrintFields(ev);
    }

    public void OnProcessExitEvent(ProcessExitEventInfo ev)
    {
        //Utils.PrintFields(ev);
    }

    public void OnBreakpointEvent(BreakpointEventInfo ev)
    {
        //Utils.PrintFields(ev);
    }
    
    public void OnSteppedEvent()
    {
    }
    
    public void OnDebuggerStart(string fileName)
    {
    }
    
    public void OnDebuggerStop()
    {
    }
    
    public void OnDebuggerResume()
    {
    }
    
    public void OnDebuggerPause()
    {
    }
    
    public void OnModuleLoadEvent(ModuleLoadEventInfo ev)
    {
        //Utils.PrintFields(ev);
    }
    
    public void OnModuleUnloadEvent(ModuleUnloadEventInfo ev)
    {
        //Utils.PrintFields(ev);
    } 
}

```

`bin/dotplugins/example/ExamplePlugin.Expressions.cs`:

```cs
using Dotx64Dbg;
using System;

public partial class ExamplePlugin
{
    [Expression("expr_no_input")]
    public nuint MyExpr1()
    {
        var th = Thread.Active;
        if (th != null)
        {
            return th.Nip;
        }
        else
            Console.WriteLine("No active thread");

        return 0;

    }

    [Expression("expr_one_input")]
    public nuint MyExpr2(nuint a)
    {
        return a;

    }

    [Expression("expr_two_inputs")]
    public nuint MyExpr3(nuint a, nuint b)
    {
        return a + b;

    }
}
```

`bin/dotplugins/example/ExamplePlugin.Menus.cs`:

```cs
using Dotx64Dbg;
using System;

using static Dotx64Dbg.UI;

public partial class ExamplePlugin
{
    [Menu(Disassembly.Menu, "Print selection")]
    public void TestMenu01()
    {
        var selection = Disassembly.GetSelection();
        Console.WriteLine($"{this} Disassembly selection, Start {selection.Start:X}, End {selection.End:X}, Len: {selection.Size:X}");
    }

    [Menu(Disassembly.Menu, "Another Menu/Sub Entry")]
    public void TestMenu02()
    {
        Console.WriteLine($"{this} Nesting Menus is easy.");
    }

    [Menu(MemoryMap.Menu, "Do something with selected memory")]
    public void TestMenu03()
    {
        Console.WriteLine("Do something with selected memory");

        var selection = MemoryMap.GetSelection();
        Console.WriteLine($"{this} Memory Map selection, Start {selection.Start:X}, End {selection.End:X}, Len: {selection.Size:X}");
    }

    [Menu(Stack.Menu, "Do something with selected stack")]
    public void TestMenu04()
    {
        Console.WriteLine("Do something with selected stack");

        var selection = Stack.GetSelection();
        Console.WriteLine($"{this} Stack selection, Start {selection.Start:X}, End {selection.End:X}, Len: {selection.Size:X}");
    }
    
    [Menu(Dump.Menu, "Do something with selected dump")]
    public void TestMenu05()
    {
        Console.WriteLine("Do something with selected dump");

        var selection = Dump.GetSelection();
        Console.WriteLine($"{this} Dump selection, Start {selection.Start:X}, End {selection.End:X}, Len: {selection.Size:X}");
    }
    
}


```

`bin/dotplugins/example/ExamplePlugin.cs`:

```cs
using Dotx64Dbg;
using System;

// Plugin Entry. 
// The hot-load system will try to preserve all members of all classes
// during the reload. All the assigned values will persist accross 
// compilations.
public partial class ExamplePlugin : IPlugin, IHotload
{
    private NestedClass Nested = new();
    private AssemblerTest Assembler = new AssemblerTest();

    public ExamplePlugin()
    {
        // Writes to x64Dbg log.
        Console.WriteLine("ExamplePlugin Constructor");
    }

    // Called as soon the plugin is fully initialized, this is called after
    // the constructor and only once the for the initial plugin load.
    public void Startup()
    {
        Console.WriteLine("ExamplePlugin Startup");

        Nested.TestFunc();
    }

    // Called whenever code changes are hot-loaded.
    public void OnHotload()
    {
        Console.WriteLine("Code got reloaded");
    }

    // Called before the plugin is about to be unloaded.
    public void Shutdown()
    {
        Console.WriteLine("ExamplePlugin Shutdown");
    }
}

```

`bin/dotplugins/example/NestedClass.Commands.cs`:

```cs
using Dotx64Dbg;
using System;

public partial class NestedClass
{
    int x = 0;
    
    [Command("Test5")]
    void NestedCommand(string[] args)
    {
        Console.WriteLine($"Yup {x}");
    }
}

```

`bin/dotplugins/example/NestedClass.cs`:

```cs
using Dotx64Dbg;
using System;

public class DataClass
{
    public int Value = 0;

    public DataClass(int val)
    {
        Value = val;
    }

    public override string ToString()
    {
        return $"{Value}";
    }
}

// All classes that have the interface IHotload will fire the OnHotload event
// when the code is compiled and loaded.
public partial class NestedClass : IHotload
{
    public static int MyNestedStatic = 0;

    private int XY = 100;

    private System.Collections.Generic.List<int> IntegerList = new() { 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    private System.Collections.Generic.HashSet<string> StringSet = new() { "Hello", "World", "foo", "foo", "Bar", "Foo" };

    DataClass[] ClassArray = new DataClass[10] {
        new DataClass(1),
        new DataClass(1),
        new DataClass(1),
        new DataClass(1),
        new DataClass(1),
        new DataClass(1),
        new DataClass(1),
        new DataClass(1),
        new DataClass(1),
        new DataClass(1)
    };

    private string NestedStringVar = "hello world";


    public void TestFunc()
    {
        Console.WriteLine("NestedClass::TestFunc()");
        Console.WriteLine("Test::IntegerList = {0}", string.Join(",", IntegerList));
        Console.WriteLine("Test::StringSet = {0}", string.Join(",", StringSet));
        Console.WriteLine("Test::NestedStringVar = {0}", NestedStringVar);

        NestedStringVar = "I changed my string";
        IntegerList.Add(500);
        StringSet.Add("Test");

        int i = 0;
        foreach (var data in ClassArray)
        {
            data.Value = ++i;
        }
    }

    public void OnHotload()
    {
        Console.WriteLine("Test::XY = {0}", XY);
        Console.WriteLine("Test::MyNestedStatic = {0}", ++MyNestedStatic);
        Console.WriteLine("Test::IntegerList = {0}", string.Join(",", IntegerList));
        Console.WriteLine("Test::StringSet = {0}", string.Join(",", StringSet));
        Console.WriteLine("Test::NestedStringVar = {0}", NestedStringVar);
        int i = 0;
        foreach (var data in ClassArray)
        {
            Console.WriteLine("Test::ClassArray[{0}] = {1}", i++, data);
        }
    }
}

```

`bin/dotplugins/example/plugin.json`:

```json
{
  "Name": "Example Plugin",
  "Description": "Basic example plugin.",
  "Version": "1.0.0",
  "Author": "x64Dbg",
  "Website": "http://github.com/x64Dbg",
  "Dependencies": [
    "System.Console.dll"
  ],
  "Settings": {
    "Test": true
  }
}

```

`bin/dotscripts/TestScript.cs`:

```cs
using System;
using Dotx64Dbg;
using static Dotx64Dbg.Scripting;

using(var suppress = new UI.UpdateSuppressor())
{
	for(int i = 0; i < 100; i++)
	{
		Sti();
		Print($"{Rip:X}");
		Sti();
		Print($"{Rip:X}");
		Sti();
		Print($"{Rip:X}");
	}
}

Sti();
```

`bin/dotx64dbg.json`:

```json
{
  "PluginsPath": ".\\dotplugins",
  "EnableTests": false,
  "EnableHotloading": false
}

```

`cmake.toml`:

```toml
# Reference: https://build-cpp.github.io/cmkr/cmake-toml
[project]
name = "Dotx64Dbg"
languages = ["CSharp", "CXX"]
cmake-after = '''
# Only have Release and Debug, there are configuration errors with managed otherwise.
SET(CMAKE_CONFIGURATION_TYPES "Debug;Release")
SET(CMAKE_VS_NUGET_PACKAGE_RESTORE ON)

# Workaround for CLR projects, there is a pending fix for this:
# https://gitlab.kitware.com/cmake/cmake/-/merge_requests/7807 which corrects the exception option in use of CLR
string(REPLACE "/EHsc" "" CMAKE_CXX_FLAGS_INIT "${CMAKE_CXX_FLAGS_INIT}")
string(REPLACE "/RTC1" "" CMAKE_CXX_FLAGS_DEBUG_INIT "${CMAKE_CXX_FLAGS_DEBUG_INIT}")
string(REPLACE "/EHsc" "" CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}")
string(REPLACE "/RTC1" "" CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG}")

if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    set(BUILD_OUTPUT_DIR ${CMAKE_SOURCE_DIR}/bin/x64)
elseif(CMAKE_SIZEOF_VOID_P EQUAL 4)
    set(BUILD_OUTPUT_DIR ${CMAKE_SOURCE_DIR}/bin/x32)
endif()
'''

[subdir.thirdparty]

### Dotx64DbgCommon
[target.Dotx64DbgCommon]
type = "interface"
alias = "dotx64dbg::common"
compile-features = ["cxx_std_17"]
compile-options = ["/MP"]
link-options = ["/DEBUG"]

### Dotx64DbgBindings
[target.Dotx64DbgBindings]
type = "shared"
alias = "dotx64dbg::bindings"
sources = [
    "src/Bindings/Breakpoints.cpp",
    "src/Bindings/Commands.cpp",
    "src/Bindings/Debugger.cpp",
    "src/Bindings/Expressions.cpp",
    "src/Bindings/Instruction.cpp",
    "src/Bindings/Instruction.Decoder.cpp",
    "src/Bindings/Instruction.Encoder.cpp",
    "src/Bindings/Instruction.Generator.cpp",
    "src/Bindings/Logging.cpp",
    "src/Bindings/Memory.cpp",
    "src/Bindings/Module.cpp",
    "src/Bindings/Platform.cpp",
    "src/Bindings/Process.cpp",
    "src/Bindings/Settings.cpp",
    "src/Bindings/Symbols.cpp",
    "src/Bindings/Thread.cpp",
    "src/Bindings/UI.cpp",
]
headers = [
    "src/Bindings/AsmJitHelper.hpp",
    "src/Bindings/Decoder.Converter.hpp",
    "src/Bindings/Encoder.Converter.hpp",
    "src/Bindings/Instruction.Decoder.hpp",
    "src/Bindings/Instruction.EFlags.hpp",
    "src/Bindings/Instruction.Encoder.hpp",
    "src/Bindings/Instruction.Generator.hpp",
    "src/Bindings/Instruction.Meta.hpp",
    "src/Bindings/Instruction.Operand.hpp",
    "src/Bindings/Instruction.Operands.hpp",
    "src/Bindings/Instruction.hpp",
    "src/Bindings/Marshal.hpp",
    "src/Bindings/Mnemonic.hpp",
    "src/Bindings/Register.hpp",
]
private-link-libraries = [
    "dotx64dbg::common",
    "x64dbg::pluginsdk",
    "asmjit::asmjit",
    "Zydis",
]
cmake-after = '''
if(CMAKE_SIZEOF_VOID_P EQUAL 8)
    target_link_options(Dotx64DbgBindings PRIVATE "/DELAYLOAD:x64dbg.dll")
    target_link_options(Dotx64DbgBindings PRIVATE "/DELAYLOAD:x64bridge.dll")
elseif(CMAKE_SIZEOF_VOID_P EQUAL 4)
    target_link_options(Dotx64DbgBindings PRIVATE "/DELAYLOAD:x32dbg.dll")
    target_link_options(Dotx64DbgBindings PRIVATE "/DELAYLOAD:x32bridge.dll")
endif()
target_link_options(Dotx64DbgBindings PRIVATE "/DELAYLOAD:titanengine.dll")
'''

[target.Dotx64DbgBindings.properties]
RUNTIME_OUTPUT_NAME = "Dotx64DbgBindings"
DOTNET_TARGET_FRAMEWORK = "net6.0"
DOTNET_TARGET_FRAMEWORK_VERSION = "6.0"
COMMON_LANGUAGE_RUNTIME = "netcore"
VS_GLOBAL_ResolveNuGetPackages = "false"
x64.RUNTIME_OUTPUT_DIRECTORY_RELEASE = "${BUILD_OUTPUT_DIR}"
x64.RUNTIME_OUTPUT_DIRECTORY_DEBUG = "${BUILD_OUTPUT_DIR}"
x32.RUNTIME_OUTPUT_DIRECTORY_RELEASE = "${BUILD_OUTPUT_DIR}"
x32.RUNTIME_OUTPUT_DIRECTORY_DEBUG = "${BUILD_OUTPUT_DIR}"

### Dotx64DbgManaged
[target.Dotx64DbgManaged]
type = "shared"
alias = "dotx64dbg::managed"
sources = [
    "src/Dotx64Managed/API/Analysis/RegisterMask.cs",
    "src/Dotx64Managed/API/Assembler.cs",
    "src/Dotx64Managed/API/Assembler.Instructions.cs",
    "src/Dotx64Managed/API/Breakpoints.cs",
    "src/Dotx64Managed/API/Commands.cs",
    "src/Dotx64Managed/API/Debugger.cs",
    "src/Dotx64Managed/API/Expressions.cs",
    "src/Dotx64Managed/API/Memory.cs",
    "src/Dotx64Managed/API/Memory.Stream.cs",
    "src/Dotx64Managed/API/Module.cs",
    "src/Dotx64Managed/API/Module.Exports.cs",
    "src/Dotx64Managed/API/Module.Imports.cs",
    "src/Dotx64Managed/API/Module.Sections.cs",
    "src/Dotx64Managed/API/Platform.cs",
    "src/Dotx64Managed/API/Process.cs",
    "src/Dotx64Managed/API/Thread.cs",
    "src/Dotx64Managed/API/Thread.Register.cs",
    "src/Dotx64Managed/API/UI/Disassembly.cs",
    "src/Dotx64Managed/API/UI/Dump.cs",
    "src/Dotx64Managed/API/UI/Log.cs",
    "src/Dotx64Managed/API/UI/MemoryMap.cs",
    "src/Dotx64Managed/API/UI/Menu.cs",
    "src/Dotx64Managed/API/UI/Stack.cs",
    "src/Dotx64Managed/API/UI/StatusBar.cs",
    "src/Dotx64Managed/API/UI/Types.cs",
    "src/Dotx64Managed/API/UI/UI.cs",
    "src/Dotx64Managed/AssemblyLoader.cs",
    "src/Dotx64Managed/Compiler.cs",
    "src/Dotx64Managed/Hotload/Hotload.Adapter.Array.cs",
    "src/Dotx64Managed/Hotload/Hotload.Adapter.Class.cs",
    "src/Dotx64Managed/Hotload/Hotload.Adapter.cs",
    "src/Dotx64Managed/Hotload/Hotload.Adapter.GenericDictionary.cs",
    "src/Dotx64Managed/Hotload/Hotload.Adapter.GenericList.cs",
    "src/Dotx64Managed/Hotload/Hotload.Adapter.Object.cs",
    "src/Dotx64Managed/Hotload/Hotload.Adapter.Statics.cs",
    "src/Dotx64Managed/Hotload/Hotload.Context.cs",
    "src/Dotx64Managed/Hotload/Hotload.cs",
    "src/Dotx64Managed/IPlugin.cs",
    "src/Dotx64Managed/Logging.cs",
    "src/Dotx64Managed/Manager.cs",
    "src/Dotx64Managed/Manager.Events.cs",
    "src/Dotx64Managed/Menus.cs",
    "src/Dotx64Managed/Menus.Main.cs",
    "src/Dotx64Managed/NodeList.cs",
    "src/Dotx64Managed/Plugins.Builder.cs",
    "src/Dotx64Managed/Plugins.cs",
    "src/Dotx64Managed/Plugins.DependencyManager.cs",
    "src/Dotx64Managed/Plugins.Hotload.cs",
    "src/Dotx64Managed/Plugins.Watcher.cs",
    "src/Dotx64Managed/ProjectGenerator.cs",
    "src/Dotx64Managed/Resources.cs",
    "src/Dotx64Managed/Scripting/Scripting.cs",
    "src/Dotx64Managed/Scripting/Scripting.Register.cs",
    "src/Dotx64Managed/ScriptLoader.cs",
    "src/Dotx64Managed/Settings.cs",
    "src/Dotx64Managed/Tests.cs",
    "src/Dotx64Managed/Utils.cs",
]
private-link-libraries = [
    "dotx64dbg::bindings",
]
x32.private-compile-definitions = ["_X86_"]
x64.private-compile-definitions = ["_X64_"]

[target.Dotx64DbgManaged.properties]
RUNTIME_OUTPUT_NAME = "Dotx64DbgManaged"
x32.VS_GLOBAL_PlatformTarget = "x86"
x64.VS_GLOBAL_PlatformTarget = "x64"
DOTNET_SDK = "Microsoft.NET.Sdk"
DOTNET_TARGET_FRAMEWORK = "net6.0"
VS_GLOBAL_ResolveNuGetPackages = "true"
VS_GLOBAL_ROOTNAMESPACE = "Dotx64Dbg"
VS_GLOBAL_AppendTargetFrameworkToOutputPath = "false"
VS_GLOBAL_AppendRuntimeIdentifierToOutputPath = "false"
VS_GLOBAL_ProduceReferenceAssembly = "false"
VS_GLOBAL_ProduceReferenceAssemblyInOutDir = "false"
VS_GLOBAL_CopyLocalLockFileAssemblies = "true"
VS_GLOBAL_SatelliteResourceLanguages = "neutral"
VS_PACKAGE_REFERENCES = [
    "Microsoft.CodeAnalysis.Compilers_3.10.0",
    "NuGet.Configuration_5.11.5",
    "NuGet.Frameworks_5.11.5",
    "NuGet.Protocol_5.11.5",
    "NuGet.Versioning_5.11.5"
]
VS_DOTNET_REFERENCES_COPY_LOCAL = "false"
x64.RUNTIME_OUTPUT_DIRECTORY_RELEASE = "${BUILD_OUTPUT_DIR}"
x64.RUNTIME_OUTPUT_DIRECTORY_DEBUG = "${BUILD_OUTPUT_DIR}"
x32.RUNTIME_OUTPUT_DIRECTORY_RELEASE = "${BUILD_OUTPUT_DIR}"
x32.RUNTIME_OUTPUT_DIRECTORY_DEBUG = "${BUILD_OUTPUT_DIR}"

[target.Dotx64DbgTests]
type = "executable"
sources = [
    "src/Dotx64DbgTests/Testing.cs",
    "src/Dotx64DbgTests/Runner.cs",
    "src/Dotx64DbgTests/Tests/Tests.Assembler.cs",
    "src/Dotx64DbgTests/Tests/Tests.Decoder.cs",
    "src/Dotx64DbgTests/Tests/Tests.Generator.cs",
    "src/Dotx64DbgTests/Tests/Tests.Operands.cs",
    "src/Dotx64DbgTests/Tests/Tests.RegisterMaskGp.cs",
    "src/Dotx64DbgTests/Tests/Tests.Registers.cs",
]
private-link-libraries = [
    "dotx64dbg::managed",
    "dotx64dbg::bindings",
]
x32.private-compile-definitions = ["_X86_"]
x64.private-compile-definitions = ["_X64_"]

[target.Dotx64DbgTests.properties]
RUNTIME_OUTPUT_NAME = "Dotx64DbgTests"
x32.VS_GLOBAL_PlatformTarget = "x86"
x64.VS_GLOBAL_PlatformTarget = "x64"
DOTNET_SDK = "Microsoft.NET.Sdk"
DOTNET_TARGET_FRAMEWORK = "net6.0"
VS_GLOBAL_ROOTNAMESPACE = "Dotx64Dbg"
VS_GLOBAL_AppendTargetFrameworkToOutputPath = "false"
VS_GLOBAL_AppendRuntimeIdentifierToOutputPath = "false"
VS_GLOBAL_ProduceReferenceAssembly = "false"
VS_GLOBAL_ProduceReferenceAssemblyInOutDir = "false"
VS_GLOBAL_CopyLocalLockFileAssemblies = "true"
VS_GLOBAL_SatelliteResourceLanguages = "neutral"
VS_DOTNET_REFERENCES_COPY_LOCAL = "true"
x64.RUNTIME_OUTPUT_DIRECTORY_RELEASE = "${BUILD_OUTPUT_DIR}/tests"
x64.RUNTIME_OUTPUT_DIRECTORY_DEBUG = "${BUILD_OUTPUT_DIR}/tests"
x32.RUNTIME_OUTPUT_DIRECTORY_RELEASE = "${BUILD_OUTPUT_DIR}/tests"
x32.RUNTIME_OUTPUT_DIRECTORY_DEBUG = "${BUILD_OUTPUT_DIR}/tests"

### Dotx64Dbg
[target.Dotx64Dbg]
type = "shared"
alias = "dotx64dbg::dotx64dbg"
sources = [
    "src/Dotx64Dbg/Loader.cpp",
    "src/Dotx64Dbg/Plugin.cpp",
]
headers = []
private-link-libraries = [
    "dotx64dbg::common",
    "x64dbg::pluginsdk",
    "dotx64dbg::managed",
]
[target.Dotx64Dbg.properties]
DOTNET_TARGET_FRAMEWORK = "net6.0"
DOTNET_TARGET_FRAMEWORK_VERSION = "6.0"
COMMON_LANGUAGE_RUNTIME = "netcore"
VS_GLOBAL_ResolveNuGetPackages = "false"
VS_GLOBAL_SatelliteResourceLanguages = "neutral"
x64.RUNTIME_OUTPUT_DIRECTORY_RELEASE = "${BUILD_OUTPUT_DIR}"
x64.RUNTIME_OUTPUT_DIRECTORY_DEBUG = "${BUILD_OUTPUT_DIR}"
x32.RUNTIME_OUTPUT_DIRECTORY_RELEASE = "${BUILD_OUTPUT_DIR}"
x32.RUNTIME_OUTPUT_DIRECTORY_DEBUG = "${BUILD_OUTPUT_DIR}"

### Dotx64DbgLoader
[target.Dotx64DbgLoader]
type = "shared"
sources = ["src/Dotx64DbgLoader/Loader.cpp"]
private-link-libraries = [
    "dotx64dbg::common",
    "x64dbg::pluginsdk",
]
x32.private-compile-definitions = ["_X86_"]
x64.private-compile-definitions = ["_X64_"]
[target.Dotx64DbgLoader.properties]
VS_GLOBAL_ResolveNuGetPackages = "false"
x64.SUFFIX = ".dp64"
x32.SUFFIX = ".dp32"
RUNTIME_OUTPUT_NAME = "Dotx64Dbg"
x64.RUNTIME_OUTPUT_DIRECTORY_RELEASE = "${BUILD_OUTPUT_DIR}"
x64.RUNTIME_OUTPUT_DIRECTORY_DEBUG = "${BUILD_OUTPUT_DIR}"
x32.RUNTIME_OUTPUT_DIRECTORY_RELEASE = "${BUILD_OUTPUT_DIR}"
x32.RUNTIME_OUTPUT_DIRECTORY_DEBUG = "${BUILD_OUTPUT_DIR}"

[target.Dotx64DbgResources]
type = "custom"
cmake-after = '''
add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_directory
      ${CMAKE_SOURCE_DIR}/src/Resources
      ${BUILD_OUTPUT_DIR}/Resources
)
'''
```

`cmkr.cmake`:

```cmake
include_guard()

# Change these defaults to point to your infrastructure if desired
set(CMKR_REPO "https://github.com/build-cpp/cmkr" CACHE STRING "cmkr git repository" FORCE)
set(CMKR_TAG "v0.2.26" CACHE STRING "cmkr git tag (this needs to be available forever)" FORCE)
set(CMKR_COMMIT_HASH "" CACHE STRING "cmkr git commit hash (optional)" FORCE)

# To bootstrap/generate a cmkr project: cmake -P cmkr.cmake
if(CMAKE_SCRIPT_MODE_FILE)
    set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/build")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}")
endif()

# Set these from the command line to customize for development/debugging purposes
set(CMKR_EXECUTABLE "" CACHE FILEPATH "cmkr executable")
set(CMKR_SKIP_GENERATION OFF CACHE BOOL "skip automatic cmkr generation")
set(CMKR_BUILD_TYPE "Debug" CACHE STRING "cmkr build configuration")
mark_as_advanced(CMKR_REPO CMKR_TAG CMKR_COMMIT_HASH CMKR_EXECUTABLE CMKR_SKIP_GENERATION CMKR_BUILD_TYPE)

# Disable cmkr if generation is disabled
if(DEFINED ENV{CI} OR CMKR_SKIP_GENERATION OR CMKR_BUILD_SKIP_GENERATION)
    message(STATUS "[cmkr] Skipping automatic cmkr generation")
    unset(CMKR_BUILD_SKIP_GENERATION CACHE)
    macro(cmkr)
    endmacro()
    return()
endif()

# Disable cmkr if no cmake.toml file is found
if(NOT CMAKE_SCRIPT_MODE_FILE AND NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    message(AUTHOR_WARNING "[cmkr] Not found: ${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    macro(cmkr)
    endmacro()
    return()
endif()

# Convert a Windows native path to CMake path
if(CMKR_EXECUTABLE MATCHES "\\\\")
    string(REPLACE "\\" "/" CMKR_EXECUTABLE_CMAKE "${CMKR_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_EXECUTABLE_CMAKE}" CACHE FILEPATH "" FORCE)
    unset(CMKR_EXECUTABLE_CMAKE)
endif()

# Helper macro to execute a process (COMMAND_ERROR_IS_FATAL ANY is 3.19 and higher)
function(cmkr_exec)
    execute_process(COMMAND ${ARGV} RESULT_VARIABLE CMKR_EXEC_RESULT)
    if(NOT CMKR_EXEC_RESULT EQUAL 0)
        message(FATAL_ERROR "cmkr_exec(${ARGV}) failed (exit code ${CMKR_EXEC_RESULT})")
    endif()
endfunction()

# Windows-specific hack (CMAKE_EXECUTABLE_PREFIX is not set at the moment)
if(WIN32)
    set(CMKR_EXECUTABLE_NAME "cmkr.exe")
else()
    set(CMKR_EXECUTABLE_NAME "cmkr")
endif()

# Use cached cmkr if found
if(DEFINED ENV{CMKR_CACHE})
    set(CMKR_DIRECTORY_PREFIX "$ENV{CMKR_CACHE}")
    string(REPLACE "\\" "/" CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}")
    if(NOT CMKR_DIRECTORY_PREFIX MATCHES "\\/$")
        set(CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}/")
    endif()
    # Build in release mode for the cache
    set(CMKR_BUILD_TYPE "Release")
else()
    set(CMKR_DIRECTORY_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/_cmkr_")
endif()
set(CMKR_DIRECTORY "${CMKR_DIRECTORY_PREFIX}${CMKR_TAG}")
set(CMKR_CACHED_EXECUTABLE "${CMKR_DIRECTORY}/bin/${CMKR_EXECUTABLE_NAME}")

# Helper function to check if a string starts with a prefix
# Cannot use MATCHES, see: https://github.com/build-cpp/cmkr/issues/61
function(cmkr_startswith str prefix result)
    string(LENGTH "${prefix}" prefix_length)
    string(LENGTH "${str}" str_length)
    if(prefix_length LESS_EQUAL str_length)
        string(SUBSTRING "${str}" 0 ${prefix_length} str_prefix)
        if(prefix STREQUAL str_prefix)
            set("${result}" ON PARENT_SCOPE)
            return()
        endif()
    endif()
    set("${result}" OFF PARENT_SCOPE)
endfunction()

# Handle upgrading logic
if(CMKR_EXECUTABLE AND NOT CMKR_CACHED_EXECUTABLE STREQUAL CMKR_EXECUTABLE)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMAKE_CURRENT_BINARY_DIR}/_cmkr" CMKR_STARTSWITH_BUILD)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMKR_DIRECTORY_PREFIX}" CMKR_STARTSWITH_CACHE)
    if(CMKR_STARTSWITH_BUILD)
        if(DEFINED ENV{CMKR_CACHE})
            message(AUTHOR_WARNING "[cmkr] Switching to cached cmkr: '${CMKR_CACHED_EXECUTABLE}'")
            if(EXISTS "${CMKR_CACHED_EXECUTABLE}")
                set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
            else()
                unset(CMKR_EXECUTABLE CACHE)
            endif()
        else()
            message(AUTHOR_WARNING "[cmkr] Upgrading '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
            unset(CMKR_EXECUTABLE CACHE)
        endif()
    elseif(DEFINED ENV{CMKR_CACHE} AND CMKR_STARTSWITH_CACHE)
        message(AUTHOR_WARNING "[cmkr] Upgrading cached '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
        unset(CMKR_EXECUTABLE CACHE)
    endif()
endif()

if(CMKR_EXECUTABLE AND EXISTS "${CMKR_EXECUTABLE}")
    message(VERBOSE "[cmkr] Found cmkr: '${CMKR_EXECUTABLE}'")
elseif(CMKR_EXECUTABLE AND NOT CMKR_EXECUTABLE STREQUAL CMKR_CACHED_EXECUTABLE)
    message(FATAL_ERROR "[cmkr] '${CMKR_EXECUTABLE}' not found")
elseif(NOT CMKR_EXECUTABLE AND EXISTS "${CMKR_CACHED_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(STATUS "[cmkr] Found cached cmkr: '${CMKR_EXECUTABLE}'")
else()
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(VERBOSE "[cmkr] Bootstrapping '${CMKR_EXECUTABLE}'")

    message(STATUS "[cmkr] Fetching cmkr...")
    if(EXISTS "${CMKR_DIRECTORY}")
        cmkr_exec("${CMAKE_COMMAND}" -E rm -rf "${CMKR_DIRECTORY}")
    endif()
    find_package(Git QUIET REQUIRED)
    cmkr_exec("${GIT_EXECUTABLE}"
        clone
        --config advice.detachedHead=false
        --branch ${CMKR_TAG}
        --depth 1
        ${CMKR_REPO}
        "${CMKR_DIRECTORY}"
    )
    if(CMKR_COMMIT_HASH)
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" checkout -q "${CMKR_COMMIT_HASH}"
            RESULT_VARIABLE CMKR_EXEC_RESULT
            WORKING_DIRECTORY "${CMKR_DIRECTORY}"
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "Tag '${CMKR_TAG}' hash is not '${CMKR_COMMIT_HASH}'")
        endif()
    endif()
    message(STATUS "[cmkr] Building cmkr (using system compiler)...")
    cmkr_exec("${CMAKE_COMMAND}"
        --no-warn-unused-cli
        "${CMKR_DIRECTORY}"
        "-B${CMKR_DIRECTORY}/build"
        "-DCMAKE_BUILD_TYPE=${CMKR_BUILD_TYPE}"
        "-DCMAKE_UNITY_BUILD=ON"
        "-DCMAKE_INSTALL_PREFIX=${CMKR_DIRECTORY}"
        "-DCMKR_GENERATE_DOCUMENTATION=OFF"
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --build "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --parallel
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --install "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --prefix "${CMKR_DIRECTORY}"
        --component cmkr
    )
    if(NOT EXISTS ${CMKR_EXECUTABLE})
        message(FATAL_ERROR "[cmkr] Failed to bootstrap '${CMKR_EXECUTABLE}'")
    endif()
    cmkr_exec("${CMKR_EXECUTABLE}" version)
    message(STATUS "[cmkr] Bootstrapped ${CMKR_EXECUTABLE}")
endif()
execute_process(COMMAND "${CMKR_EXECUTABLE}" version
    RESULT_VARIABLE CMKR_EXEC_RESULT
)
if(NOT CMKR_EXEC_RESULT EQUAL 0)
    message(FATAL_ERROR "[cmkr] Failed to get version, try clearing the cache and rebuilding")
endif()

# Use cmkr.cmake as a script
if(CMAKE_SCRIPT_MODE_FILE)
    if(NOT EXISTS "${CMAKE_SOURCE_DIR}/cmake.toml")
        execute_process(COMMAND "${CMKR_EXECUTABLE}" init
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to bootstrap cmkr project. Please report an issue: https://github.com/build-cpp/cmkr/issues/new")
        else()
            message(STATUS "[cmkr] Modify cmake.toml and then configure using: cmake -B build")
        endif()
    else()
        execute_process(COMMAND "${CMKR_EXECUTABLE}" gen
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to generate project.")
        else()
            message(STATUS "[cmkr] Configure using: cmake -B build")
        endif()
    endif()
endif()

# This is the macro that contains black magic
macro(cmkr)
    # When this macro is called from the generated file, fake some internal CMake variables
    get_source_file_property(CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}" CMKR_CURRENT_LIST_FILE)
    if(CMKR_CURRENT_LIST_FILE)
        set(CMAKE_CURRENT_LIST_FILE "${CMKR_CURRENT_LIST_FILE}")
        get_filename_component(CMAKE_CURRENT_LIST_DIR "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
    endif()

    # File-based include guard (include_guard is not documented to work)
    get_source_file_property(CMKR_INCLUDE_GUARD "${CMAKE_CURRENT_LIST_FILE}" CMKR_INCLUDE_GUARD)
    if(NOT CMKR_INCLUDE_GUARD)
        set_source_files_properties("${CMAKE_CURRENT_LIST_FILE}" PROPERTIES CMKR_INCLUDE_GUARD TRUE)

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_PRE)

        # Generate CMakeLists.txt
        cmkr_exec("${CMKR_EXECUTABLE}" gen
            WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        )

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_POST)

        # Delete the temporary file if it was left for some reason
        set(CMKR_TEMP_FILE "${CMAKE_CURRENT_SOURCE_DIR}/CMakerLists.txt")
        if(EXISTS "${CMKR_TEMP_FILE}")
            file(REMOVE "${CMKR_TEMP_FILE}")
        endif()

        if(NOT CMKR_LIST_FILE_SHA256_PRE STREQUAL CMKR_LIST_FILE_SHA256_POST)
            # Copy the now-generated CMakeLists.txt to CMakerLists.txt
            # This is done because you cannot include() a file you are currently in
            configure_file(CMakeLists.txt "${CMKR_TEMP_FILE}" COPYONLY)

            # Add the macro required for the hack at the start of the cmkr macro
            set_source_files_properties("${CMKR_TEMP_FILE}" PROPERTIES
                CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}"
            )

            # 'Execute' the newly-generated CMakeLists.txt
            include("${CMKR_TEMP_FILE}")

            # Delete the generated file
            file(REMOVE "${CMKR_TEMP_FILE}")

            # Do not execute the rest of the original CMakeLists.txt
            return()
        endif()
        # Resume executing the unmodified CMakeLists.txt
    endif()
endmacro()

```

`src/Bindings/AsmJitHelper.hpp`:

```hpp
#pragma once

#include <string>
#include <optional>
#include <asmjit/asmjit.h>

namespace Dotx64Dbg
{
    inline std::optional<std::string> getAsmjitErrorString(asmjit::Error err)
    {
        auto code = static_cast<asmjit::ErrorCode>(err);
        switch (code)
        {
        case asmjit::ErrorCode::kErrorOk:
            return std::nullopt;
        case asmjit::ErrorCode::kErrorOutOfMemory:
            return "Out of Memory";
        case asmjit::ErrorCode::kErrorInvalidArgument:
            return "Invalid Argument";
        case asmjit::ErrorCode::kErrorInvalidState:
            return "Invalid State";
        case asmjit::ErrorCode::kErrorInvalidArch:
            return "Invalid Arch";
        case asmjit::ErrorCode::kErrorNotInitialized:
            return "Not Initialized";
        case asmjit::ErrorCode::kErrorAlreadyInitialized:
            return "Already Initialized";
        case asmjit::ErrorCode::kErrorFeatureNotEnabled:
            return "Feature not enabled";
        case asmjit::ErrorCode::kErrorTooManyHandles:
            return "Too many handles";
        case asmjit::ErrorCode::kErrorTooLarge:
            return "Too large";
        case asmjit::ErrorCode::kErrorNoCodeGenerated:
            return "No Code Generated";
        case asmjit::ErrorCode::kErrorInvalidDirective:
            return "Invalid Directive";
        case asmjit::ErrorCode::kErrorInvalidLabel:
            return "Invalid Label";
        case asmjit::ErrorCode::kErrorTooManyLabels:
            return "Too Many Labels";
        case asmjit::ErrorCode::kErrorLabelAlreadyBound:
            return "Label already bound";
        case asmjit::ErrorCode::kErrorLabelAlreadyDefined:
            return "Label already defined";
        case asmjit::ErrorCode::kErrorLabelNameTooLong:
            return "Label Name too long";
        case asmjit::ErrorCode::kErrorInvalidLabelName:
            return "Invalid Label name";
        case asmjit::ErrorCode::kErrorInvalidParentLabel:
            return "Invalid parent Label";
        case asmjit::ErrorCode::kErrorInvalidSection:
            return "Invalid Section";
        case asmjit::ErrorCode::kErrorTooManySections:
            return "Too Many Sections";
        case asmjit::ErrorCode::kErrorInvalidSectionName:
            return "Invalid Section Name";
        case asmjit::ErrorCode::kErrorTooManyRelocations:
            return "Too Many Relocations";
        case asmjit::ErrorCode::kErrorInvalidRelocEntry:
            return "Invalid Relocation Entry";
        case asmjit::ErrorCode::kErrorRelocOffsetOutOfRange:
            return "Relocatopm Offset Out Of Range";
        case asmjit::ErrorCode::kErrorInvalidAssignment:
            return "Invalid assignment";
        case asmjit::ErrorCode::kErrorInvalidInstruction:
            return "Invalid Instruction";
        case asmjit::ErrorCode::kErrorInvalidRegType:
            return "Invalid Reg Type";
        case asmjit::ErrorCode::kErrorInvalidRegGroup:
            return "Invalid Reg Group";
        case asmjit::ErrorCode::kErrorInvalidPhysId:
            return "Invalid Phys Id";
        case asmjit::ErrorCode::kErrorInvalidVirtId:
            return "Invalid Virt Id";
        case asmjit::ErrorCode::kErrorInvalidElementIndex:
            return "Invalid Element Index";
        case asmjit::ErrorCode::kErrorInvalidPrefixCombination:
            return "Invalid Prefix Combination";
        case asmjit::ErrorCode::kErrorInvalidLockPrefix:
            return "Invalid Lock Prefix";
        case asmjit::ErrorCode::kErrorInvalidXAcquirePrefix:
            return "Invalid XAcquire Prefix";
        case asmjit::ErrorCode::kErrorInvalidXReleasePrefix:
            return "Invalid XRelease Prefix";
        case asmjit::ErrorCode::kErrorInvalidRepPrefix:
            return "Invalid Rep Prefix";
        case asmjit::ErrorCode::kErrorInvalidRexPrefix:
            return "Invalid Rex Prefix";
        case asmjit::ErrorCode::kErrorInvalidExtraReg:
            return "Invalid Extra Reg";
        case asmjit::ErrorCode::kErrorInvalidKMaskUse:
            return "Invalid K Mask use";
        case asmjit::ErrorCode::kErrorInvalidKZeroUse:
            return "Invalid K Zero use";
        case asmjit::ErrorCode::kErrorInvalidBroadcast:
            return "Invalid Broadcast";
        case asmjit::ErrorCode::kErrorInvalidEROrSAE:
            return "Invalid ER or SAE";
        case asmjit::ErrorCode::kErrorInvalidAddress:
            return "Invalid Address";
        case asmjit::ErrorCode::kErrorInvalidAddressIndex:
            return "Invalid Address Index";
        case asmjit::ErrorCode::kErrorInvalidAddressScale:
            return "Invalid Address Scale";
        case asmjit::ErrorCode::kErrorInvalidAddress64Bit:
            return "InvalidAddress64Bit";
        case asmjit::ErrorCode::kErrorInvalidAddress64BitZeroExtension:
            return "Invalid Address 64 Bit Zero Extension";
        case asmjit::ErrorCode::kErrorInvalidDisplacement:
            return "Invalid Displacement";
        case asmjit::ErrorCode::kErrorInvalidSegment:
            return "Invalid Segment";
        case asmjit::ErrorCode::kErrorInvalidImmediate:
            return "Invalid Immediate";
        case asmjit::ErrorCode::kErrorInvalidOperandSize:
            return "Invalid Operand Size";
        case asmjit::ErrorCode::kErrorAmbiguousOperandSize:
            return "Ambiguous Operand Size";
        case asmjit::ErrorCode::kErrorOperandSizeMismatch:
            return "Operand Size mismatch";
        case asmjit::ErrorCode::kErrorInvalidOption:
            return "Invalid Option";
        case asmjit::ErrorCode::kErrorOptionAlreadyDefined:
            return "Option already defined";
        case asmjit::ErrorCode::kErrorInvalidTypeId:
            return "Invalid Type Id";
        case asmjit::ErrorCode::kErrorInvalidUseOfGpbHi:
            return "Invalid use Of GpbHi";
        case asmjit::ErrorCode::kErrorInvalidUseOfGpq:
            return "Invalid use Of Gpq";
        case asmjit::ErrorCode::kErrorInvalidUseOfF80:
            return "Invalid use Of F80";
        case asmjit::ErrorCode::kErrorNotConsecutiveRegs:
            return "Not Consecutive Regs";
        case asmjit::ErrorCode::kErrorIllegalVirtReg:
            return "Illegal Virt Reg";
        case asmjit::ErrorCode::kErrorTooManyVirtRegs:
            return "Too Many Virt Regs";
        case asmjit::ErrorCode::kErrorNoMorePhysRegs:
            return "No More Phys Regs";
        case asmjit::ErrorCode::kErrorOverlappedRegs:
            return "Overlapped Regs";
        case asmjit::ErrorCode::kErrorOverlappingStackRegWithRegArg:
            return "Overlapping Stack Reg With Reg Arg";
        case asmjit::ErrorCode::kErrorExpressionLabelNotBound:
            return "Expression Label Not Bound";
        case asmjit::ErrorCode::kErrorExpressionOverflow:
            return "Expression Overflow";
        case asmjit::ErrorCode::kErrorFailedToOpenAnonymousMemory:
            return "Failed to open anonymous Memory";
        }
        return std::nullopt;
    }
}

```

`src/Bindings/Breakpoints.cpp`:

```cpp
#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_debug.h"

namespace Dotx64Dbg::Native
{
    public ref class Breakpoints
    {
    public:
        enum class BreakpointType
        {
            None = 0,
            Normal = (1 << 0),
            Hardware = (1 << 1),
            Memory = (1 << 2),
            Dll = (1 << 3),
            Exception = (1 << 4),
            System = (1 << 5),
        };

        enum class HardwareType
        {
            HardwareAccess = 0,
            HardwareWrite,
            HardwareExecute
        };

        static bool SetBreakpoint(System::UIntPtr address)
        {
            return Script::Debug::SetBreakpoint(static_cast<duint>(address.ToUInt64()));
        }

        static bool DeleteBreakpoint(System::UIntPtr address)
        {
            return Script::Debug::DeleteBreakpoint(static_cast<duint>(address.ToUInt64()));
        }

        static bool DisableBreakpoint(System::UIntPtr address)
        {
            return Script::Debug::DisableBreakpoint(static_cast<duint>(address.ToUInt64()));
        }

        static bool SetHardwareBreakpoint(System::UIntPtr address, HardwareType type)
        {
            auto va = static_cast<duint>(address.ToUInt64());
            switch (type)
            {
            case HardwareType::HardwareAccess:
                return Script::Debug::SetHardwareBreakpoint(va, Script::Debug::HardwareType::HardwareAccess);
            case HardwareType::HardwareWrite:
                return Script::Debug::SetHardwareBreakpoint(va, Script::Debug::HardwareType::HardwareWrite);
            case HardwareType::HardwareExecute:
                return Script::Debug::SetHardwareBreakpoint(va, Script::Debug::HardwareType::HardwareExecute);
            default:
                break;
            }
            return false;
        }

        static bool DeleteHardwareBreakpoint(System::UIntPtr address)
        {
            return Script::Debug::DeleteHardwareBreakpoint(static_cast<duint>(address.ToUInt64()));
        }
    };
}

```

`src/Bindings/Commands.cpp`:

```cpp
#include <vector>
#include <cstdint>

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_memory.h"

#include "Marshal.hpp"

namespace Dotx64Dbg::Native
{
    using namespace System;
    using namespace System::Runtime::InteropServices;

    [UnmanagedFunctionPointer(CallingConvention::Cdecl)]
    public delegate bool CommandCallback(int argc, System::IntPtr);

    public ref class Commands
    {
    public:
        static bool RegisterCommand(int pluginHandle, System::String^ cmd, bool debugOnly, CommandCallback^ cb)
        {
            GCHandle gcCb = GCHandle::Alloc(cb);

            IntPtr ip = Marshal::GetFunctionPointerForDelegate(cb);
            auto* fn = static_cast<CBPLUGINCOMMAND>(ip.ToPointer());

            auto cmdStr = interop::toUTF8(cmd);
            return _plugin_registercommand(pluginHandle, cmdStr.c_str(), fn, debugOnly);
        }

        static bool UnregisterCommand(int pluginHandle, System::String^ cmd)
        {
            auto cmdStr = interop::toUTF8(cmd);
            return _plugin_unregistercommand(pluginHandle, cmdStr.c_str());
        }
    };
}

```

`src/Bindings/Debugger.cpp`:

```cpp
#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_debug.h"

#include "Marshal.hpp"

namespace Dotx64Dbg::Native
{
    public ref class Debugger
    {
    public:
        static void Wait()
        {
            Script::Debug::Wait();
        }

        static void Run()
        {
            Script::Debug::Run();
        }

        static void Pause()
        {
            Script::Debug::Pause();
        }

        static void Stop()
        {
            Script::Debug::Stop();
        }

        static void StepIn()
        {
            Script::Debug::StepIn();
        }

        static void StepOver()
        {
            Script::Debug::StepOver();
        }

        static void StepOut()
        {
            Script::Debug::StepOut();
        }

        static bool IsActive()
        {
            return DbgIsDebugging();
        }

        static bool RunCommand(System::String^ cmd)
        {
            auto cmdStr = interop::toUTF8(cmd);
            return DbgCmdExecDirect(cmdStr.c_str());
        }

        static bool RunCommandAsync(System::String^ cmd)
        {
            auto cmdStr = interop::toUTF8(cmd);
            return DbgCmdExec(cmdStr.c_str());
        }
    };
}

```

`src/Bindings/Decoder.Converter.hpp`:

```hpp
#pragma once

#include "Register.hpp"
#include "Mnemonic.hpp"

#include <zydis/zydis.h>

namespace Dotx64Dbg
{

    constexpr Registers::Id convertZydisRegister(ZydisRegister reg)
    {
        switch (reg)
        {
        case ZYDIS_REGISTER_NONE:
            return Registers::Id::None;
        case ZYDIS_REGISTER_AL:
            return Registers::Id::Al;
        case ZYDIS_REGISTER_CL:
            return Registers::Id::Cl;
        case ZYDIS_REGISTER_DL:
            return Registers::Id::Dl;
        case ZYDIS_REGISTER_BL:
            return Registers::Id::Bl;
        case ZYDIS_REGISTER_AH:
            return Registers::Id::Ah;
        case ZYDIS_REGISTER_CH:
            return Registers::Id::Ch;
        case ZYDIS_REGISTER_DH:
            return Registers::Id::Dh;
        case ZYDIS_REGISTER_BH:
            return Registers::Id::Bh;
        case ZYDIS_REGISTER_SPL:
            return Registers::Id::Spl;
        case ZYDIS_REGISTER_BPL:
            return Registers::Id::Bpl;
        case ZYDIS_REGISTER_SIL:
            return Registers::Id::Sil;
        case ZYDIS_REGISTER_DIL:
            return Registers::Id::Dil;
        case ZYDIS_REGISTER_R8B:
            return Registers::Id::R8b;
        case ZYDIS_REGISTER_R9B:
            return Registers::Id::R9b;
        case ZYDIS_REGISTER_R10B:
            return Registers::Id::R10b;
        case ZYDIS_REGISTER_R11B:
            return Registers::Id::R11b;
        case ZYDIS_REGISTER_R12B:
            return Registers::Id::R12b;
        case ZYDIS_REGISTER_R13B:
            return Registers::Id::R13b;
        case ZYDIS_REGISTER_R14B:
            return Registers::Id::R14b;
        case ZYDIS_REGISTER_R15B:
            return Registers::Id::R15b;
        case ZYDIS_REGISTER_AX:
            return Registers::Id::Ax;
        case ZYDIS_REGISTER_CX:
            return Registers::Id::Cx;
        case ZYDIS_REGISTER_DX:
            return Registers::Id::Dx;
        case ZYDIS_REGISTER_BX:
            return Registers::Id::Bx;
        case ZYDIS_REGISTER_SP:
            return Registers::Id::Sp;
        case ZYDIS_REGISTER_BP:
            return Registers::Id::Bp;
        case ZYDIS_REGISTER_SI:
            return Registers::Id::Si;
        case ZYDIS_REGISTER_DI:
            return Registers::Id::Di;
        case ZYDIS_REGISTER_R8W:
            return Registers::Id::R8w;
        case ZYDIS_REGISTER_R9W:
            return Registers::Id::R9w;
        case ZYDIS_REGISTER_R10W:
            return Registers::Id::R10w;
        case ZYDIS_REGISTER_R11W:
            return Registers::Id::R11w;
        case ZYDIS_REGISTER_R12W:
            return Registers::Id::R12w;
        case ZYDIS_REGISTER_R13W:
            return Registers::Id::R13w;
        case ZYDIS_REGISTER_R14W:
            return Registers::Id::R14w;
        case ZYDIS_REGISTER_R15W:
            return Registers::Id::R15w;
        case ZYDIS_REGISTER_EAX:
            return Registers::Id::Eax;
        case ZYDIS_REGISTER_ECX:
            return Registers::Id::Ecx;
        case ZYDIS_REGISTER_EDX:
            return Registers::Id::Edx;
        case ZYDIS_REGISTER_EBX:
            return Registers::Id::Ebx;
        case ZYDIS_REGISTER_ESP:
            return Registers::Id::Esp;
        case ZYDIS_REGISTER_EBP:
            return Registers::Id::Ebp;
        case ZYDIS_REGISTER_ESI:
            return Registers::Id::Esi;
        case ZYDIS_REGISTER_EDI:
            return Registers::Id::Edi;
        case ZYDIS_REGISTER_R8D:
            return Registers::Id::R8d;
        case ZYDIS_REGISTER_R9D:
            return Registers::Id::R9d;
        case ZYDIS_REGISTER_R10D:
            return Registers::Id::R10d;
        case ZYDIS_REGISTER_R11D:
            return Registers::Id::R11d;
        case ZYDIS_REGISTER_R12D:
            return Registers::Id::R12d;
        case ZYDIS_REGISTER_R13D:
            return Registers::Id::R13d;
        case ZYDIS_REGISTER_R14D:
            return Registers::Id::R14d;
        case ZYDIS_REGISTER_R15D:
            return Registers::Id::R15d;
        case ZYDIS_REGISTER_RAX:
            return Registers::Id::Rax;
        case ZYDIS_REGISTER_RCX:
            return Registers::Id::Rcx;
        case ZYDIS_REGISTER_RDX:
            return Registers::Id::Rdx;
        case ZYDIS_REGISTER_RBX:
            return Registers::Id::Rbx;
        case ZYDIS_REGISTER_RSP:
            return Registers::Id::Rsp;
        case ZYDIS_REGISTER_RBP:
            return Registers::Id::Rbp;
        case ZYDIS_REGISTER_RSI:
            return Registers::Id::Rsi;
        case ZYDIS_REGISTER_RDI:
            return Registers::Id::Rdi;
        case ZYDIS_REGISTER_R8:
            return Registers::Id::R8;
        case ZYDIS_REGISTER_R9:
            return Registers::Id::R9;
        case ZYDIS_REGISTER_R10:
            return Registers::Id::R10;
        case ZYDIS_REGISTER_R11:
            return Registers::Id::R11;
        case ZYDIS_REGISTER_R12:
            return Registers::Id::R12;
        case ZYDIS_REGISTER_R13:
            return Registers::Id::R13;
        case ZYDIS_REGISTER_R14:
            return Registers::Id::R14;
        case ZYDIS_REGISTER_R15:
            return Registers::Id::R15;
        case ZYDIS_REGISTER_ST0:
            return Registers::Id::St0;
        case ZYDIS_REGISTER_ST1:
            return Registers::Id::St1;
        case ZYDIS_REGISTER_ST2:
            return Registers::Id::St2;
        case ZYDIS_REGISTER_ST3:
            return Registers::Id::St3;
        case ZYDIS_REGISTER_ST4:
            return Registers::Id::St4;
        case ZYDIS_REGISTER_ST5:
            return Registers::Id::St5;
        case ZYDIS_REGISTER_ST6:
            return Registers::Id::St6;
        case ZYDIS_REGISTER_ST7:
            return Registers::Id::St7;
        case ZYDIS_REGISTER_X87CONTROL:
            return Registers::Id::X87Control;
        case ZYDIS_REGISTER_X87STATUS:
            return Registers::Id::X87Status;
        case ZYDIS_REGISTER_X87TAG:
            return Registers::Id::X87Tag;
        case ZYDIS_REGISTER_MM0:
            return Registers::Id::Mm0;
        case ZYDIS_REGISTER_MM1:
            return Registers::Id::Mm1;
        case ZYDIS_REGISTER_MM2:
            return Registers::Id::Mm2;
        case ZYDIS_REGISTER_MM3:
            return Registers::Id::Mm3;
        case ZYDIS_REGISTER_MM4:
            return Registers::Id::Mm4;
        case ZYDIS_REGISTER_MM5:
            return Registers::Id::Mm5;
        case ZYDIS_REGISTER_MM6:
            return Registers::Id::Mm6;
        case ZYDIS_REGISTER_MM7:
            return Registers::Id::Mm7;
        case ZYDIS_REGISTER_XMM0:
            return Registers::Id::Xmm0;
        case ZYDIS_REGISTER_XMM1:
            return Registers::Id::Xmm1;
        case ZYDIS_REGISTER_XMM2:
            return Registers::Id::Xmm2;
        case ZYDIS_REGISTER_XMM3:
            return Registers::Id::Xmm3;
        case ZYDIS_REGISTER_XMM4:
            return Registers::Id::Xmm4;
        case ZYDIS_REGISTER_XMM5:
            return Registers::Id::Xmm5;
        case ZYDIS_REGISTER_XMM6:
            return Registers::Id::Xmm6;
        case ZYDIS_REGISTER_XMM7:
            return Registers::Id::Xmm7;
        case ZYDIS_REGISTER_XMM8:
            return Registers::Id::Xmm8;
        case ZYDIS_REGISTER_XMM9:
            return Registers::Id::Xmm9;
        case ZYDIS_REGISTER_XMM10:
            return Registers::Id::Xmm10;
        case ZYDIS_REGISTER_XMM11:
            return Registers::Id::Xmm11;
        case ZYDIS_REGISTER_XMM12:
            return Registers::Id::Xmm12;
        case ZYDIS_REGISTER_XMM13:
            return Registers::Id::Xmm13;
        case ZYDIS_REGISTER_XMM14:
            return Registers::Id::Xmm14;
        case ZYDIS_REGISTER_XMM15:
            return Registers::Id::Xmm15;
        case ZYDIS_REGISTER_XMM16:
            return Registers::Id::Xmm16;
        case ZYDIS_REGISTER_XMM17:
            return Registers::Id::Xmm17;
        case ZYDIS_REGISTER_XMM18:
            return Registers::Id::Xmm18;
        case ZYDIS_REGISTER_XMM19:
            return Registers::Id::Xmm19;
        case ZYDIS_REGISTER_XMM20:
            return Registers::Id::Xmm20;
        case ZYDIS_REGISTER_XMM21:
            return Registers::Id::Xmm21;
        case ZYDIS_REGISTER_XMM22:
            return Registers::Id::Xmm22;
        case ZYDIS_REGISTER_XMM23:
            return Registers::Id::Xmm23;
        case ZYDIS_REGISTER_XMM24:
            return Registers::Id::Xmm24;
        case ZYDIS_REGISTER_XMM25:
            return Registers::Id::Xmm25;
        case ZYDIS_REGISTER_XMM26:
            return Registers::Id::Xmm26;
        case ZYDIS_REGISTER_XMM27:
            return Registers::Id::Xmm27;
        case ZYDIS_REGISTER_XMM28:
            return Registers::Id::Xmm28;
        case ZYDIS_REGISTER_XMM29:
            return Registers::Id::Xmm29;
        case ZYDIS_REGISTER_XMM30:
            return Registers::Id::Xmm30;
        case ZYDIS_REGISTER_XMM31:
            return Registers::Id::Xmm31;
        case ZYDIS_REGISTER_YMM0:
            return Registers::Id::Ymm0;
        case ZYDIS_REGISTER_YMM1:
            return Registers::Id::Ymm1;
        case ZYDIS_REGISTER_YMM2:
            return Registers::Id::Ymm2;
        case ZYDIS_REGISTER_YMM3:
            return Registers::Id::Ymm3;
        case ZYDIS_REGISTER_YMM4:
            return Registers::Id::Ymm4;
        case ZYDIS_REGISTER_YMM5:
            return Registers::Id::Ymm5;
        case ZYDIS_REGISTER_YMM6:
            return Registers::Id::Ymm6;
        case ZYDIS_REGISTER_YMM7:
            return Registers::Id::Ymm7;
        case ZYDIS_REGISTER_YMM8:
            return Registers::Id::Ymm8;
        case ZYDIS_REGISTER_YMM9:
            return Registers::Id::Ymm9;
        case ZYDIS_REGISTER_YMM10:
            return Registers::Id::Ymm10;
        case ZYDIS_REGISTER_YMM11:
            return Registers::Id::Ymm11;
        case ZYDIS_REGISTER_YMM12:
            return Registers::Id::Ymm12;
        case ZYDIS_REGISTER_YMM13:
            return Registers::Id::Ymm13;
        case ZYDIS_REGISTER_YMM14:
            return Registers::Id::Ymm14;
        case ZYDIS_REGISTER_YMM15:
            return Registers::Id::Ymm15;
        case ZYDIS_REGISTER_YMM16:
            return Registers::Id::Ymm16;
        case ZYDIS_REGISTER_YMM17:
            return Registers::Id::Ymm17;
        case ZYDIS_REGISTER_YMM18:
            return Registers::Id::Ymm18;
        case ZYDIS_REGISTER_YMM19:
            return Registers::Id::Ymm19;
        case ZYDIS_REGISTER_YMM20:
            return Registers::Id::Ymm20;
        case ZYDIS_REGISTER_YMM21:
            return Registers::Id::Ymm21;
        case ZYDIS_REGISTER_YMM22:
            return Registers::Id::Ymm22;
        case ZYDIS_REGISTER_YMM23:
            return Registers::Id::Ymm23;
        case ZYDIS_REGISTER_YMM24:
            return Registers::Id::Ymm24;
        case ZYDIS_REGISTER_YMM25:
            return Registers::Id::Ymm25;
        case ZYDIS_REGISTER_YMM26:
            return Registers::Id::Ymm26;
        case ZYDIS_REGISTER_YMM27:
            return Registers::Id::Ymm27;
        case ZYDIS_REGISTER_YMM28:
            return Registers::Id::Ymm28;
        case ZYDIS_REGISTER_YMM29:
            return Registers::Id::Ymm29;
        case ZYDIS_REGISTER_YMM30:
            return Registers::Id::Ymm30;
        case ZYDIS_REGISTER_YMM31:
            return Registers::Id::Ymm31;
        case ZYDIS_REGISTER_ZMM0:
            return Registers::Id::Zmm0;
        case ZYDIS_REGISTER_ZMM1:
            return Registers::Id::Zmm1;
        case ZYDIS_REGISTER_ZMM2:
            return Registers::Id::Zmm2;
        case ZYDIS_REGISTER_ZMM3:
            return Registers::Id::Zmm3;
        case ZYDIS_REGISTER_ZMM4:
            return Registers::Id::Zmm4;
        case ZYDIS_REGISTER_ZMM5:
            return Registers::Id::Zmm5;
        case ZYDIS_REGISTER_ZMM6:
            return Registers::Id::Zmm6;
        case ZYDIS_REGISTER_ZMM7:
            return Registers::Id::Zmm7;
        case ZYDIS_REGISTER_ZMM8:
            return Registers::Id::Zmm8;
        case ZYDIS_REGISTER_ZMM9:
            return Registers::Id::Zmm9;
        case ZYDIS_REGISTER_ZMM10:
            return Registers::Id::Zmm10;
        case ZYDIS_REGISTER_ZMM11:
            return Registers::Id::Zmm11;
        case ZYDIS_REGISTER_ZMM12:
            return Registers::Id::Zmm12;
        case ZYDIS_REGISTER_ZMM13:
            return Registers::Id::Zmm13;
        case ZYDIS_REGISTER_ZMM14:
            return Registers::Id::Zmm14;
        case ZYDIS_REGISTER_ZMM15:
            return Registers::Id::Zmm15;
        case ZYDIS_REGISTER_ZMM16:
            return Registers::Id::Zmm16;
        case ZYDIS_REGISTER_ZMM17:
            return Registers::Id::Zmm17;
        case ZYDIS_REGISTER_ZMM18:
            return Registers::Id::Zmm18;
        case ZYDIS_REGISTER_ZMM19:
            return Registers::Id::Zmm19;
        case ZYDIS_REGISTER_ZMM20:
            return Registers::Id::Zmm20;
        case ZYDIS_REGISTER_ZMM21:
            return Registers::Id::Zmm21;
        case ZYDIS_REGISTER_ZMM22:
            return Registers::Id::Zmm22;
        case ZYDIS_REGISTER_ZMM23:
            return Registers::Id::Zmm23;
        case ZYDIS_REGISTER_ZMM24:
            return Registers::Id::Zmm24;
        case ZYDIS_REGISTER_ZMM25:
            return Registers::Id::Zmm25;
        case ZYDIS_REGISTER_ZMM26:
            return Registers::Id::Zmm26;
        case ZYDIS_REGISTER_ZMM27:
            return Registers::Id::Zmm27;
        case ZYDIS_REGISTER_ZMM28:
            return Registers::Id::Zmm28;
        case ZYDIS_REGISTER_ZMM29:
            return Registers::Id::Zmm29;
        case ZYDIS_REGISTER_ZMM30:
            return Registers::Id::Zmm30;
        case ZYDIS_REGISTER_ZMM31:
            return Registers::Id::Zmm31;
        case ZYDIS_REGISTER_TMM0:
            return Registers::Id::Tmm0;
        case ZYDIS_REGISTER_TMM1:
            return Registers::Id::Tmm1;
        case ZYDIS_REGISTER_TMM2:
            return Registers::Id::Tmm2;
        case ZYDIS_REGISTER_TMM3:
            return Registers::Id::Tmm3;
        case ZYDIS_REGISTER_TMM4:
            return Registers::Id::Tmm4;
        case ZYDIS_REGISTER_TMM5:
            return Registers::Id::Tmm5;
        case ZYDIS_REGISTER_TMM6:
            return Registers::Id::Tmm6;
        case ZYDIS_REGISTER_TMM7:
            return Registers::Id::Tmm7;
        case ZYDIS_REGISTER_FLAGS:
            return Registers::Id::Flags;
        case ZYDIS_REGISTER_EFLAGS:
            return Registers::Id::EFlags;
        case ZYDIS_REGISTER_RFLAGS:
            return Registers::Id::RFlags;
        case ZYDIS_REGISTER_IP:
            return Registers::Id::Ip;
        case ZYDIS_REGISTER_EIP:
            return Registers::Id::Eip;
        case ZYDIS_REGISTER_RIP:
            return Registers::Id::Rip;
        case ZYDIS_REGISTER_ES:
            return Registers::Id::Es;
        case ZYDIS_REGISTER_CS:
            return Registers::Id::Cs;
        case ZYDIS_REGISTER_SS:
            return Registers::Id::Ss;
        case ZYDIS_REGISTER_DS:
            return Registers::Id::Ds;
        case ZYDIS_REGISTER_FS:
            return Registers::Id::Fs;
        case ZYDIS_REGISTER_GS:
            return Registers::Id::Gs;
        case ZYDIS_REGISTER_GDTR:
            return Registers::Id::Gdtr;
        case ZYDIS_REGISTER_LDTR:
            return Registers::Id::Ldtr;
        case ZYDIS_REGISTER_IDTR:
            return Registers::Id::Idtr;
        case ZYDIS_REGISTER_TR:
            return Registers::Id::Tr;
        case ZYDIS_REGISTER_TR0:
            return Registers::Id::Tr0;
        case ZYDIS_REGISTER_TR1:
            return Registers::Id::Tr1;
        case ZYDIS_REGISTER_TR2:
            return Registers::Id::Tr2;
        case ZYDIS_REGISTER_TR3:
            return Registers::Id::Tr3;
        case ZYDIS_REGISTER_TR4:
            return Registers::Id::Tr4;
        case ZYDIS_REGISTER_TR5:
            return Registers::Id::Tr5;
        case ZYDIS_REGISTER_TR6:
            return Registers::Id::Tr6;
        case ZYDIS_REGISTER_TR7:
            return Registers::Id::Tr7;
        case ZYDIS_REGISTER_CR0:
            return Registers::Id::Cr0;
        case ZYDIS_REGISTER_CR1:
            return Registers::Id::Cr1;
        case ZYDIS_REGISTER_CR2:
            return Registers::Id::Cr2;
        case ZYDIS_REGISTER_CR3:
            return Registers::Id::Cr3;
        case ZYDIS_REGISTER_CR4:
            return Registers::Id::Cr4;
        case ZYDIS_REGISTER_CR5:
            return Registers::Id::Cr5;
        case ZYDIS_REGISTER_CR6:
            return Registers::Id::Cr6;
        case ZYDIS_REGISTER_CR7:
            return Registers::Id::Cr7;
        case ZYDIS_REGISTER_CR8:
            return Registers::Id::Cr8;
        case ZYDIS_REGISTER_CR9:
            return Registers::Id::Cr9;
        case ZYDIS_REGISTER_CR10:
            return Registers::Id::Cr10;
        case ZYDIS_REGISTER_CR11:
            return Registers::Id::Cr11;
        case ZYDIS_REGISTER_CR12:
            return Registers::Id::Cr12;
        case ZYDIS_REGISTER_CR13:
            return Registers::Id::Cr13;
        case ZYDIS_REGISTER_CR14:
            return Registers::Id::Cr14;
        case ZYDIS_REGISTER_CR15:
            return Registers::Id::Cr15;
        case ZYDIS_REGISTER_DR0:
            return Registers::Id::Dr0;
        case ZYDIS_REGISTER_DR1:
            return Registers::Id::Dr1;
        case ZYDIS_REGISTER_DR2:
            return Registers::Id::Dr2;
        case ZYDIS_REGISTER_DR3:
            return Registers::Id::Dr3;
        case ZYDIS_REGISTER_DR4:
            return Registers::Id::Dr4;
        case ZYDIS_REGISTER_DR5:
            return Registers::Id::Dr5;
        case ZYDIS_REGISTER_DR6:
            return Registers::Id::Dr6;
        case ZYDIS_REGISTER_DR7:
            return Registers::Id::Dr7;
        case ZYDIS_REGISTER_DR8:
            return Registers::Id::Dr8;
        case ZYDIS_REGISTER_DR9:
            return Registers::Id::Dr9;
        case ZYDIS_REGISTER_DR10:
            return Registers::Id::Dr10;
        case ZYDIS_REGISTER_DR11:
            return Registers::Id::Dr11;
        case ZYDIS_REGISTER_DR12:
            return Registers::Id::Dr12;
        case ZYDIS_REGISTER_DR13:
            return Registers::Id::Dr13;
        case ZYDIS_REGISTER_DR14:
            return Registers::Id::Dr14;
        case ZYDIS_REGISTER_DR15:
            return Registers::Id::Dr15;
        case ZYDIS_REGISTER_K0:
            return Registers::Id::K0;
        case ZYDIS_REGISTER_K1:
            return Registers::Id::K1;
        case ZYDIS_REGISTER_K2:
            return Registers::Id::K2;
        case ZYDIS_REGISTER_K3:
            return Registers::Id::K3;
        case ZYDIS_REGISTER_K4:
            return Registers::Id::K4;
        case ZYDIS_REGISTER_K5:
            return Registers::Id::K5;
        case ZYDIS_REGISTER_K6:
            return Registers::Id::K6;
        case ZYDIS_REGISTER_K7:
            return Registers::Id::K7;
        case ZYDIS_REGISTER_BND0:
            return Registers::Id::Bnd0;
        case ZYDIS_REGISTER_BND1:
            return Registers::Id::Bnd1;
        case ZYDIS_REGISTER_BND2:
            return Registers::Id::Bnd2;
        case ZYDIS_REGISTER_BND3:
            return Registers::Id::Bnd3;
        case ZYDIS_REGISTER_BNDCFG:
            return Registers::Id::BndCfg;
        case ZYDIS_REGISTER_BNDSTATUS:
            return Registers::Id::BndStatus;
        case ZYDIS_REGISTER_MXCSR:
            return Registers::Id::Mxcsr;
        case ZYDIS_REGISTER_PKRU:
            return Registers::Id::Pkru;
        case ZYDIS_REGISTER_XCR0:
            return Registers::Id::Xcr0;
        }
        return Registers::Id::Invalid;
    }

    inline Mnemonic convertZydisMnemonic(ZydisMnemonic mnemonic)
    {
        switch (mnemonic)
        {
        case ZYDIS_MNEMONIC_INVALID:
            return Mnemonic::Invalid;
        case ZYDIS_MNEMONIC_AAA:
            return Mnemonic::Aaa;
        case ZYDIS_MNEMONIC_AAD:
            return Mnemonic::Aad;
        case ZYDIS_MNEMONIC_AAM:
            return Mnemonic::Aam;
        case ZYDIS_MNEMONIC_AAS:
            return Mnemonic::Aas;
        case ZYDIS_MNEMONIC_ADC:
            return Mnemonic::Adc;
        case ZYDIS_MNEMONIC_ADCX:
            return Mnemonic::Adcx;
        case ZYDIS_MNEMONIC_ADD:
            return Mnemonic::Add;
        case ZYDIS_MNEMONIC_ADDPD:
            return Mnemonic::Addpd;
        case ZYDIS_MNEMONIC_ADDPS:
            return Mnemonic::Addps;
        case ZYDIS_MNEMONIC_ADDSD:
            return Mnemonic::Addsd;
        case ZYDIS_MNEMONIC_ADDSS:
            return Mnemonic::Addss;
        case ZYDIS_MNEMONIC_ADDSUBPD:
            return Mnemonic::Addsubpd;
        case ZYDIS_MNEMONIC_ADDSUBPS:
            return Mnemonic::Addsubps;
        case ZYDIS_MNEMONIC_ADOX:
            return Mnemonic::Adox;
        case ZYDIS_MNEMONIC_AESDEC:
            return Mnemonic::Aesdec;
        case ZYDIS_MNEMONIC_AESDEC128KL:
            return Mnemonic::Aesdec128kl;
        case ZYDIS_MNEMONIC_AESDEC256KL:
            return Mnemonic::Aesdec256kl;
        case ZYDIS_MNEMONIC_AESDECLAST:
            return Mnemonic::Aesdeclast;
        case ZYDIS_MNEMONIC_AESDECWIDE128KL:
            return Mnemonic::Aesdecwide128kl;
        case ZYDIS_MNEMONIC_AESDECWIDE256KL:
            return Mnemonic::Aesdecwide256kl;
        case ZYDIS_MNEMONIC_AESENC:
            return Mnemonic::Aesenc;
        case ZYDIS_MNEMONIC_AESENC128KL:
            return Mnemonic::Aesenc128kl;
        case ZYDIS_MNEMONIC_AESENC256KL:
            return Mnemonic::Aesenc256kl;
        case ZYDIS_MNEMONIC_AESENCLAST:
            return Mnemonic::Aesenclast;
        case ZYDIS_MNEMONIC_AESENCWIDE128KL:
            return Mnemonic::Aesencwide128kl;
        case ZYDIS_MNEMONIC_AESENCWIDE256KL:
            return Mnemonic::Aesencwide256kl;
        case ZYDIS_MNEMONIC_AESIMC:
            return Mnemonic::Aesimc;
        case ZYDIS_MNEMONIC_AESKEYGENASSIST:
            return Mnemonic::Aeskeygenassist;
        case ZYDIS_MNEMONIC_AND:
            return Mnemonic::And;
        case ZYDIS_MNEMONIC_ANDN:
            return Mnemonic::Andn;
        case ZYDIS_MNEMONIC_ANDNPD:
            return Mnemonic::Andnpd;
        case ZYDIS_MNEMONIC_ANDNPS:
            return Mnemonic::Andnps;
        case ZYDIS_MNEMONIC_ANDPD:
            return Mnemonic::Andpd;
        case ZYDIS_MNEMONIC_ANDPS:
            return Mnemonic::Andps;
        case ZYDIS_MNEMONIC_ARPL:
            return Mnemonic::Arpl;
        case ZYDIS_MNEMONIC_BEXTR:
            return Mnemonic::Bextr;
        case ZYDIS_MNEMONIC_BLCFILL:
            return Mnemonic::Blcfill;
        case ZYDIS_MNEMONIC_BLCI:
            return Mnemonic::Blci;
        case ZYDIS_MNEMONIC_BLCIC:
            return Mnemonic::Blcic;
        case ZYDIS_MNEMONIC_BLCMSK:
            return Mnemonic::Blcmsk;
        case ZYDIS_MNEMONIC_BLCS:
            return Mnemonic::Blcs;
        case ZYDIS_MNEMONIC_BLENDPD:
            return Mnemonic::Blendpd;
        case ZYDIS_MNEMONIC_BLENDPS:
            return Mnemonic::Blendps;
        case ZYDIS_MNEMONIC_BLENDVPD:
            return Mnemonic::Blendvpd;
        case ZYDIS_MNEMONIC_BLENDVPS:
            return Mnemonic::Blendvps;
        case ZYDIS_MNEMONIC_BLSFILL:
            return Mnemonic::Blsfill;
        case ZYDIS_MNEMONIC_BLSI:
            return Mnemonic::Blsi;
        case ZYDIS_MNEMONIC_BLSIC:
            return Mnemonic::Blsic;
        case ZYDIS_MNEMONIC_BLSMSK:
            return Mnemonic::Blsmsk;
        case ZYDIS_MNEMONIC_BLSR:
            return Mnemonic::Blsr;
        case ZYDIS_MNEMONIC_BNDCL:
            return Mnemonic::Bndcl;
        case ZYDIS_MNEMONIC_BNDCN:
            return Mnemonic::Bndcn;
        case ZYDIS_MNEMONIC_BNDCU:
            return Mnemonic::Bndcu;
        case ZYDIS_MNEMONIC_BNDLDX:
            return Mnemonic::Bndldx;
        case ZYDIS_MNEMONIC_BNDMK:
            return Mnemonic::Bndmk;
        case ZYDIS_MNEMONIC_BNDMOV:
            return Mnemonic::Bndmov;
        case ZYDIS_MNEMONIC_BNDSTX:
            return Mnemonic::Bndstx;
        case ZYDIS_MNEMONIC_BOUND:
            return Mnemonic::Bound;
        case ZYDIS_MNEMONIC_BSF:
            return Mnemonic::Bsf;
        case ZYDIS_MNEMONIC_BSR:
            return Mnemonic::Bsr;
        case ZYDIS_MNEMONIC_BSWAP:
            return Mnemonic::Bswap;
        case ZYDIS_MNEMONIC_BT:
            return Mnemonic::Bt;
        case ZYDIS_MNEMONIC_BTC:
            return Mnemonic::Btc;
        case ZYDIS_MNEMONIC_BTR:
            return Mnemonic::Btr;
        case ZYDIS_MNEMONIC_BTS:
            return Mnemonic::Bts;
        case ZYDIS_MNEMONIC_BZHI:
            return Mnemonic::Bzhi;
        case ZYDIS_MNEMONIC_CALL:
            return Mnemonic::Call;
        case ZYDIS_MNEMONIC_CBW:
            return Mnemonic::Cbw;
        case ZYDIS_MNEMONIC_CDQ:
            return Mnemonic::Cdq;
        case ZYDIS_MNEMONIC_CDQE:
            return Mnemonic::Cdqe;
        case ZYDIS_MNEMONIC_CLAC:
            return Mnemonic::Clac;
        case ZYDIS_MNEMONIC_CLC:
            return Mnemonic::Clc;
        case ZYDIS_MNEMONIC_CLD:
            return Mnemonic::Cld;
        case ZYDIS_MNEMONIC_CLDEMOTE:
            return Mnemonic::Cldemote;
        case ZYDIS_MNEMONIC_CLEVICT0:
            return Mnemonic::Clevict0;
        case ZYDIS_MNEMONIC_CLEVICT1:
            return Mnemonic::Clevict1;
        case ZYDIS_MNEMONIC_CLFLUSH:
            return Mnemonic::Clflush;
        case ZYDIS_MNEMONIC_CLFLUSHOPT:
            return Mnemonic::Clflushopt;
        case ZYDIS_MNEMONIC_CLGI:
            return Mnemonic::Clgi;
        case ZYDIS_MNEMONIC_CLI:
            return Mnemonic::Cli;
        case ZYDIS_MNEMONIC_CLRSSBSY:
            return Mnemonic::Clrssbsy;
        case ZYDIS_MNEMONIC_CLTS:
            return Mnemonic::Clts;
        case ZYDIS_MNEMONIC_CLUI:
            return Mnemonic::Clui;
        case ZYDIS_MNEMONIC_CLWB:
            return Mnemonic::Clwb;
        case ZYDIS_MNEMONIC_CLZERO:
            return Mnemonic::Clzero;
        case ZYDIS_MNEMONIC_CMC:
            return Mnemonic::Cmc;
        case ZYDIS_MNEMONIC_CMOVB:
            return Mnemonic::Cmovb;
        case ZYDIS_MNEMONIC_CMOVBE:
            return Mnemonic::Cmovbe;
        case ZYDIS_MNEMONIC_CMOVL:
            return Mnemonic::Cmovl;
        case ZYDIS_MNEMONIC_CMOVLE:
            return Mnemonic::Cmovle;
        case ZYDIS_MNEMONIC_CMOVNB:
            return Mnemonic::Cmovnb;
        case ZYDIS_MNEMONIC_CMOVNBE:
            return Mnemonic::Cmovnbe;
        case ZYDIS_MNEMONIC_CMOVNL:
            return Mnemonic::Cmovnl;
        case ZYDIS_MNEMONIC_CMOVNLE:
            return Mnemonic::Cmovnle;
        case ZYDIS_MNEMONIC_CMOVNO:
            return Mnemonic::Cmovno;
        case ZYDIS_MNEMONIC_CMOVNP:
            return Mnemonic::Cmovnp;
        case ZYDIS_MNEMONIC_CMOVNS:
            return Mnemonic::Cmovns;
        case ZYDIS_MNEMONIC_CMOVNZ:
            return Mnemonic::Cmovnz;
        case ZYDIS_MNEMONIC_CMOVO:
            return Mnemonic::Cmovo;
        case ZYDIS_MNEMONIC_CMOVP:
            return Mnemonic::Cmovp;
        case ZYDIS_MNEMONIC_CMOVS:
            return Mnemonic::Cmovs;
        case ZYDIS_MNEMONIC_CMOVZ:
            return Mnemonic::Cmovz;
        case ZYDIS_MNEMONIC_CMP:
            return Mnemonic::Cmp;
        case ZYDIS_MNEMONIC_CMPPD:
            return Mnemonic::Cmppd;
        case ZYDIS_MNEMONIC_CMPPS:
            return Mnemonic::Cmpps;
        case ZYDIS_MNEMONIC_CMPSB:
            return Mnemonic::Cmpsb;
        case ZYDIS_MNEMONIC_CMPSD:
            return Mnemonic::Cmpsd;
        case ZYDIS_MNEMONIC_CMPSQ:
            return Mnemonic::Cmpsq;
        case ZYDIS_MNEMONIC_CMPSS:
            return Mnemonic::Cmpss;
        case ZYDIS_MNEMONIC_CMPSW:
            return Mnemonic::Cmpsw;
        case ZYDIS_MNEMONIC_CMPXCHG:
            return Mnemonic::Cmpxchg;
        case ZYDIS_MNEMONIC_CMPXCHG16B:
            return Mnemonic::Cmpxchg16b;
        case ZYDIS_MNEMONIC_CMPXCHG8B:
            return Mnemonic::Cmpxchg8b;
        case ZYDIS_MNEMONIC_COMISD:
            return Mnemonic::Comisd;
        case ZYDIS_MNEMONIC_COMISS:
            return Mnemonic::Comiss;
        case ZYDIS_MNEMONIC_CPUID:
            return Mnemonic::Cpuid;
        case ZYDIS_MNEMONIC_CQO:
            return Mnemonic::Cqo;
        case ZYDIS_MNEMONIC_CRC32:
            return Mnemonic::Crc32;
        case ZYDIS_MNEMONIC_CVTDQ2PD:
            return Mnemonic::Cvtdq2pd;
        case ZYDIS_MNEMONIC_CVTDQ2PS:
            return Mnemonic::Cvtdq2ps;
        case ZYDIS_MNEMONIC_CVTPD2DQ:
            return Mnemonic::Cvtpd2dq;
        case ZYDIS_MNEMONIC_CVTPD2PI:
            return Mnemonic::Cvtpd2pi;
        case ZYDIS_MNEMONIC_CVTPD2PS:
            return Mnemonic::Cvtpd2ps;
        case ZYDIS_MNEMONIC_CVTPI2PD:
            return Mnemonic::Cvtpi2pd;
        case ZYDIS_MNEMONIC_CVTPI2PS:
            return Mnemonic::Cvtpi2ps;
        case ZYDIS_MNEMONIC_CVTPS2DQ:
            return Mnemonic::Cvtps2dq;
        case ZYDIS_MNEMONIC_CVTPS2PD:
            return Mnemonic::Cvtps2pd;
        case ZYDIS_MNEMONIC_CVTPS2PI:
            return Mnemonic::Cvtps2pi;
        case ZYDIS_MNEMONIC_CVTSD2SI:
            return Mnemonic::Cvtsd2si;
        case ZYDIS_MNEMONIC_CVTSD2SS:
            return Mnemonic::Cvtsd2ss;
        case ZYDIS_MNEMONIC_CVTSI2SD:
            return Mnemonic::Cvtsi2sd;
        case ZYDIS_MNEMONIC_CVTSI2SS:
            return Mnemonic::Cvtsi2ss;
        case ZYDIS_MNEMONIC_CVTSS2SD:
            return Mnemonic::Cvtss2sd;
        case ZYDIS_MNEMONIC_CVTSS2SI:
            return Mnemonic::Cvtss2si;
        case ZYDIS_MNEMONIC_CVTTPD2DQ:
            return Mnemonic::Cvttpd2dq;
        case ZYDIS_MNEMONIC_CVTTPD2PI:
            return Mnemonic::Cvttpd2pi;
        case ZYDIS_MNEMONIC_CVTTPS2DQ:
            return Mnemonic::Cvttps2dq;
        case ZYDIS_MNEMONIC_CVTTPS2PI:
            return Mnemonic::Cvttps2pi;
        case ZYDIS_MNEMONIC_CVTTSD2SI:
            return Mnemonic::Cvttsd2si;
        case ZYDIS_MNEMONIC_CVTTSS2SI:
            return Mnemonic::Cvttss2si;
        case ZYDIS_MNEMONIC_CWD:
            return Mnemonic::Cwd;
        case ZYDIS_MNEMONIC_CWDE:
            return Mnemonic::Cwde;
        case ZYDIS_MNEMONIC_DAA:
            return Mnemonic::Daa;
        case ZYDIS_MNEMONIC_DAS:
            return Mnemonic::Das;
        case ZYDIS_MNEMONIC_DEC:
            return Mnemonic::Dec;
        case ZYDIS_MNEMONIC_DELAY:
            return Mnemonic::Delay;
        case ZYDIS_MNEMONIC_DIV:
            return Mnemonic::Div;
        case ZYDIS_MNEMONIC_DIVPD:
            return Mnemonic::Divpd;
        case ZYDIS_MNEMONIC_DIVPS:
            return Mnemonic::Divps;
        case ZYDIS_MNEMONIC_DIVSD:
            return Mnemonic::Divsd;
        case ZYDIS_MNEMONIC_DIVSS:
            return Mnemonic::Divss;
        case ZYDIS_MNEMONIC_DPPD:
            return Mnemonic::Dppd;
        case ZYDIS_MNEMONIC_DPPS:
            return Mnemonic::Dpps;
        case ZYDIS_MNEMONIC_EMMS:
            return Mnemonic::Emms;
        case ZYDIS_MNEMONIC_ENCLS:
            return Mnemonic::Encls;
        case ZYDIS_MNEMONIC_ENCLU:
            return Mnemonic::Enclu;
        case ZYDIS_MNEMONIC_ENCLV:
            return Mnemonic::Enclv;
        case ZYDIS_MNEMONIC_ENCODEKEY128:
            return Mnemonic::Encodekey128;
        case ZYDIS_MNEMONIC_ENCODEKEY256:
            return Mnemonic::Encodekey256;
        case ZYDIS_MNEMONIC_ENDBR32:
            return Mnemonic::Endbr32;
        case ZYDIS_MNEMONIC_ENDBR64:
            return Mnemonic::Endbr64;
        case ZYDIS_MNEMONIC_ENQCMD:
            return Mnemonic::Enqcmd;
        case ZYDIS_MNEMONIC_ENQCMDS:
            return Mnemonic::Enqcmds;
        case ZYDIS_MNEMONIC_ENTER:
            return Mnemonic::Enter;
        case ZYDIS_MNEMONIC_EXTRACTPS:
            return Mnemonic::Extractps;
        case ZYDIS_MNEMONIC_EXTRQ:
            return Mnemonic::Extrq;
        case ZYDIS_MNEMONIC_F2XM1:
            return Mnemonic::F2xm1;
        case ZYDIS_MNEMONIC_FABS:
            return Mnemonic::Fabs;
        case ZYDIS_MNEMONIC_FADD:
            return Mnemonic::Fadd;
        case ZYDIS_MNEMONIC_FADDP:
            return Mnemonic::Faddp;
        case ZYDIS_MNEMONIC_FBLD:
            return Mnemonic::Fbld;
        case ZYDIS_MNEMONIC_FBSTP:
            return Mnemonic::Fbstp;
        case ZYDIS_MNEMONIC_FCHS:
            return Mnemonic::Fchs;
        case ZYDIS_MNEMONIC_FCMOVB:
            return Mnemonic::Fcmovb;
        case ZYDIS_MNEMONIC_FCMOVBE:
            return Mnemonic::Fcmovbe;
        case ZYDIS_MNEMONIC_FCMOVE:
            return Mnemonic::Fcmove;
        case ZYDIS_MNEMONIC_FCMOVNB:
            return Mnemonic::Fcmovnb;
        case ZYDIS_MNEMONIC_FCMOVNBE:
            return Mnemonic::Fcmovnbe;
        case ZYDIS_MNEMONIC_FCMOVNE:
            return Mnemonic::Fcmovne;
        case ZYDIS_MNEMONIC_FCMOVNU:
            return Mnemonic::Fcmovnu;
        case ZYDIS_MNEMONIC_FCMOVU:
            return Mnemonic::Fcmovu;
        case ZYDIS_MNEMONIC_FCOM:
            return Mnemonic::Fcom;
        case ZYDIS_MNEMONIC_FCOMI:
            return Mnemonic::Fcomi;
        case ZYDIS_MNEMONIC_FCOMIP:
            return Mnemonic::Fcomip;
        case ZYDIS_MNEMONIC_FCOMP:
            return Mnemonic::Fcomp;
        case ZYDIS_MNEMONIC_FCOMPP:
            return Mnemonic::Fcompp;
        case ZYDIS_MNEMONIC_FCOS:
            return Mnemonic::Fcos;
        case ZYDIS_MNEMONIC_FDECSTP:
            return Mnemonic::Fdecstp;
        case ZYDIS_MNEMONIC_FDISI8087_NOP:
            return Mnemonic::Fdisi8087_nop;
        case ZYDIS_MNEMONIC_FDIV:
            return Mnemonic::Fdiv;
        case ZYDIS_MNEMONIC_FDIVP:
            return Mnemonic::Fdivp;
        case ZYDIS_MNEMONIC_FDIVR:
            return Mnemonic::Fdivr;
        case ZYDIS_MNEMONIC_FDIVRP:
            return Mnemonic::Fdivrp;
        case ZYDIS_MNEMONIC_FEMMS:
            return Mnemonic::Femms;
        case ZYDIS_MNEMONIC_FENI8087_NOP:
            return Mnemonic::Feni8087_nop;
        case ZYDIS_MNEMONIC_FFREE:
            return Mnemonic::Ffree;
        case ZYDIS_MNEMONIC_FFREEP:
            return Mnemonic::Ffreep;
        case ZYDIS_MNEMONIC_FIADD:
            return Mnemonic::Fiadd;
        case ZYDIS_MNEMONIC_FICOM:
            return Mnemonic::Ficom;
        case ZYDIS_MNEMONIC_FICOMP:
            return Mnemonic::Ficomp;
        case ZYDIS_MNEMONIC_FIDIV:
            return Mnemonic::Fidiv;
        case ZYDIS_MNEMONIC_FIDIVR:
            return Mnemonic::Fidivr;
        case ZYDIS_MNEMONIC_FILD:
            return Mnemonic::Fild;
        case ZYDIS_MNEMONIC_FIMUL:
            return Mnemonic::Fimul;
        case ZYDIS_MNEMONIC_FINCSTP:
            return Mnemonic::Fincstp;
        case ZYDIS_MNEMONIC_FIST:
            return Mnemonic::Fist;
        case ZYDIS_MNEMONIC_FISTP:
            return Mnemonic::Fistp;
        case ZYDIS_MNEMONIC_FISTTP:
            return Mnemonic::Fisttp;
        case ZYDIS_MNEMONIC_FISUB:
            return Mnemonic::Fisub;
        case ZYDIS_MNEMONIC_FISUBR:
            return Mnemonic::Fisubr;
        case ZYDIS_MNEMONIC_FLD:
            return Mnemonic::Fld;
        case ZYDIS_MNEMONIC_FLD1:
            return Mnemonic::Fld1;
        case ZYDIS_MNEMONIC_FLDCW:
            return Mnemonic::Fldcw;
        case ZYDIS_MNEMONIC_FLDENV:
            return Mnemonic::Fldenv;
        case ZYDIS_MNEMONIC_FLDL2E:
            return Mnemonic::Fldl2e;
        case ZYDIS_MNEMONIC_FLDL2T:
            return Mnemonic::Fldl2t;
        case ZYDIS_MNEMONIC_FLDLG2:
            return Mnemonic::Fldlg2;
        case ZYDIS_MNEMONIC_FLDLN2:
            return Mnemonic::Fldln2;
        case ZYDIS_MNEMONIC_FLDPI:
            return Mnemonic::Fldpi;
        case ZYDIS_MNEMONIC_FLDZ:
            return Mnemonic::Fldz;
        case ZYDIS_MNEMONIC_FMUL:
            return Mnemonic::Fmul;
        case ZYDIS_MNEMONIC_FMULP:
            return Mnemonic::Fmulp;
        case ZYDIS_MNEMONIC_FNCLEX:
            return Mnemonic::Fnclex;
        case ZYDIS_MNEMONIC_FNINIT:
            return Mnemonic::Fninit;
        case ZYDIS_MNEMONIC_FNOP:
            return Mnemonic::Fnop;
        case ZYDIS_MNEMONIC_FNSAVE:
            return Mnemonic::Fnsave;
        case ZYDIS_MNEMONIC_FNSTCW:
            return Mnemonic::Fnstcw;
        case ZYDIS_MNEMONIC_FNSTENV:
            return Mnemonic::Fnstenv;
        case ZYDIS_MNEMONIC_FNSTSW:
            return Mnemonic::Fnstsw;
        case ZYDIS_MNEMONIC_FPATAN:
            return Mnemonic::Fpatan;
        case ZYDIS_MNEMONIC_FPREM:
            return Mnemonic::Fprem;
        case ZYDIS_MNEMONIC_FPREM1:
            return Mnemonic::Fprem1;
        case ZYDIS_MNEMONIC_FPTAN:
            return Mnemonic::Fptan;
        case ZYDIS_MNEMONIC_FRNDINT:
            return Mnemonic::Frndint;
        case ZYDIS_MNEMONIC_FRSTOR:
            return Mnemonic::Frstor;
        case ZYDIS_MNEMONIC_FSCALE:
            return Mnemonic::Fscale;
        case ZYDIS_MNEMONIC_FSETPM287_NOP:
            return Mnemonic::Fsetpm287_nop;
        case ZYDIS_MNEMONIC_FSIN:
            return Mnemonic::Fsin;
        case ZYDIS_MNEMONIC_FSINCOS:
            return Mnemonic::Fsincos;
        case ZYDIS_MNEMONIC_FSQRT:
            return Mnemonic::Fsqrt;
        case ZYDIS_MNEMONIC_FST:
            return Mnemonic::Fst;
        case ZYDIS_MNEMONIC_FSTP:
            return Mnemonic::Fstp;
        case ZYDIS_MNEMONIC_FSTPNCE:
            return Mnemonic::Fstpnce;
        case ZYDIS_MNEMONIC_FSUB:
            return Mnemonic::Fsub;
        case ZYDIS_MNEMONIC_FSUBP:
            return Mnemonic::Fsubp;
        case ZYDIS_MNEMONIC_FSUBR:
            return Mnemonic::Fsubr;
        case ZYDIS_MNEMONIC_FSUBRP:
            return Mnemonic::Fsubrp;
        case ZYDIS_MNEMONIC_FTST:
            return Mnemonic::Ftst;
        case ZYDIS_MNEMONIC_FUCOM:
            return Mnemonic::Fucom;
        case ZYDIS_MNEMONIC_FUCOMI:
            return Mnemonic::Fucomi;
        case ZYDIS_MNEMONIC_FUCOMIP:
            return Mnemonic::Fucomip;
        case ZYDIS_MNEMONIC_FUCOMP:
            return Mnemonic::Fucomp;
        case ZYDIS_MNEMONIC_FUCOMPP:
            return Mnemonic::Fucompp;
        case ZYDIS_MNEMONIC_FWAIT:
            return Mnemonic::Fwait;
        case ZYDIS_MNEMONIC_FXAM:
            return Mnemonic::Fxam;
        case ZYDIS_MNEMONIC_FXCH:
            return Mnemonic::Fxch;
        case ZYDIS_MNEMONIC_FXRSTOR:
            return Mnemonic::Fxrstor;
        case ZYDIS_MNEMONIC_FXRSTOR64:
            return Mnemonic::Fxrstor64;
        case ZYDIS_MNEMONIC_FXSAVE:
            return Mnemonic::Fxsave;
        case ZYDIS_MNEMONIC_FXSAVE64:
            return Mnemonic::Fxsave64;
        case ZYDIS_MNEMONIC_FXTRACT:
            return Mnemonic::Fxtract;
        case ZYDIS_MNEMONIC_FYL2X:
            return Mnemonic::Fyl2x;
        case ZYDIS_MNEMONIC_FYL2XP1:
            return Mnemonic::Fyl2xp1;
        case ZYDIS_MNEMONIC_GETSEC:
            return Mnemonic::Getsec;
        case ZYDIS_MNEMONIC_GF2P8AFFINEINVQB:
            return Mnemonic::Gf2p8affineinvqb;
        case ZYDIS_MNEMONIC_GF2P8AFFINEQB:
            return Mnemonic::Gf2p8affineqb;
        case ZYDIS_MNEMONIC_GF2P8MULB:
            return Mnemonic::Gf2p8mulb;
        case ZYDIS_MNEMONIC_HADDPD:
            return Mnemonic::Haddpd;
        case ZYDIS_MNEMONIC_HADDPS:
            return Mnemonic::Haddps;
        case ZYDIS_MNEMONIC_HLT:
            return Mnemonic::Hlt;
        case ZYDIS_MNEMONIC_HRESET:
            return Mnemonic::Hreset;
        case ZYDIS_MNEMONIC_HSUBPD:
            return Mnemonic::Hsubpd;
        case ZYDIS_MNEMONIC_HSUBPS:
            return Mnemonic::Hsubps;
        case ZYDIS_MNEMONIC_IDIV:
            return Mnemonic::Idiv;
        case ZYDIS_MNEMONIC_IMUL:
            return Mnemonic::Imul;
        case ZYDIS_MNEMONIC_IN:
            return Mnemonic::In;
        case ZYDIS_MNEMONIC_INC:
            return Mnemonic::Inc;
        case ZYDIS_MNEMONIC_INCSSPD:
            return Mnemonic::Incsspd;
        case ZYDIS_MNEMONIC_INCSSPQ:
            return Mnemonic::Incsspq;
        case ZYDIS_MNEMONIC_INSB:
            return Mnemonic::Insb;
        case ZYDIS_MNEMONIC_INSD:
            return Mnemonic::Insd;
        case ZYDIS_MNEMONIC_INSERTPS:
            return Mnemonic::Insertps;
        case ZYDIS_MNEMONIC_INSERTQ:
            return Mnemonic::Insertq;
        case ZYDIS_MNEMONIC_INSW:
            return Mnemonic::Insw;
        case ZYDIS_MNEMONIC_INT:
            return Mnemonic::Int;
        case ZYDIS_MNEMONIC_INT1:
            return Mnemonic::Int1;
        case ZYDIS_MNEMONIC_INT3:
            return Mnemonic::Int3;
        case ZYDIS_MNEMONIC_INTO:
            return Mnemonic::Into;
        case ZYDIS_MNEMONIC_INVD:
            return Mnemonic::Invd;
        case ZYDIS_MNEMONIC_INVEPT:
            return Mnemonic::Invept;
        case ZYDIS_MNEMONIC_INVLPG:
            return Mnemonic::Invlpg;
        case ZYDIS_MNEMONIC_INVLPGA:
            return Mnemonic::Invlpga;
        case ZYDIS_MNEMONIC_INVLPGB:
            return Mnemonic::Invlpgb;
        case ZYDIS_MNEMONIC_INVPCID:
            return Mnemonic::Invpcid;
        case ZYDIS_MNEMONIC_INVVPID:
            return Mnemonic::Invvpid;
        case ZYDIS_MNEMONIC_IRET:
            return Mnemonic::Iret;
        case ZYDIS_MNEMONIC_IRETD:
            return Mnemonic::Iretd;
        case ZYDIS_MNEMONIC_IRETQ:
            return Mnemonic::Iretq;
        case ZYDIS_MNEMONIC_JB:
            return Mnemonic::Jb;
        case ZYDIS_MNEMONIC_JBE:
            return Mnemonic::Jbe;
        case ZYDIS_MNEMONIC_JCXZ:
            return Mnemonic::Jcxz;
        case ZYDIS_MNEMONIC_JECXZ:
            return Mnemonic::Jecxz;
        case ZYDIS_MNEMONIC_JKNZD:
            return Mnemonic::Jknzd;
        case ZYDIS_MNEMONIC_JKZD:
            return Mnemonic::Jkzd;
        case ZYDIS_MNEMONIC_JL:
            return Mnemonic::Jl;
        case ZYDIS_MNEMONIC_JLE:
            return Mnemonic::Jle;
        case ZYDIS_MNEMONIC_JMP:
            return Mnemonic::Jmp;
        case ZYDIS_MNEMONIC_JNB:
            return Mnemonic::Jnb;
        case ZYDIS_MNEMONIC_JNBE:
            return Mnemonic::Jnbe;
        case ZYDIS_MNEMONIC_JNL:
            return Mnemonic::Jnl;
        case ZYDIS_MNEMONIC_JNLE:
            return Mnemonic::Jnle;
        case ZYDIS_MNEMONIC_JNO:
            return Mnemonic::Jno;
        case ZYDIS_MNEMONIC_JNP:
            return Mnemonic::Jnp;
        case ZYDIS_MNEMONIC_JNS:
            return Mnemonic::Jns;
        case ZYDIS_MNEMONIC_JNZ:
            return Mnemonic::Jnz;
        case ZYDIS_MNEMONIC_JO:
            return Mnemonic::Jo;
        case ZYDIS_MNEMONIC_JP:
            return Mnemonic::Jp;
        case ZYDIS_MNEMONIC_JRCXZ:
            return Mnemonic::Jrcxz;
        case ZYDIS_MNEMONIC_JS:
            return Mnemonic::Js;
        case ZYDIS_MNEMONIC_JZ:
            return Mnemonic::Jz;
        case ZYDIS_MNEMONIC_KADDB:
            return Mnemonic::Kaddb;
        case ZYDIS_MNEMONIC_KADDD:
            return Mnemonic::Kaddd;
        case ZYDIS_MNEMONIC_KADDQ:
            return Mnemonic::Kaddq;
        case ZYDIS_MNEMONIC_KADDW:
            return Mnemonic::Kaddw;
        case ZYDIS_MNEMONIC_KAND:
            return Mnemonic::Kand;
        case ZYDIS_MNEMONIC_KANDB:
            return Mnemonic::Kandb;
        case ZYDIS_MNEMONIC_KANDD:
            return Mnemonic::Kandd;
        case ZYDIS_MNEMONIC_KANDN:
            return Mnemonic::Kandn;
        case ZYDIS_MNEMONIC_KANDNB:
            return Mnemonic::Kandnb;
        case ZYDIS_MNEMONIC_KANDND:
            return Mnemonic::Kandnd;
        case ZYDIS_MNEMONIC_KANDNQ:
            return Mnemonic::Kandnq;
        case ZYDIS_MNEMONIC_KANDNR:
            return Mnemonic::Kandnr;
        case ZYDIS_MNEMONIC_KANDNW:
            return Mnemonic::Kandnw;
        case ZYDIS_MNEMONIC_KANDQ:
            return Mnemonic::Kandq;
        case ZYDIS_MNEMONIC_KANDW:
            return Mnemonic::Kandw;
        case ZYDIS_MNEMONIC_KCONCATH:
            return Mnemonic::Kconcath;
        case ZYDIS_MNEMONIC_KCONCATL:
            return Mnemonic::Kconcatl;
        case ZYDIS_MNEMONIC_KEXTRACT:
            return Mnemonic::Kextract;
        case ZYDIS_MNEMONIC_KMERGE2L1H:
            return Mnemonic::Kmerge2l1h;
        case ZYDIS_MNEMONIC_KMERGE2L1L:
            return Mnemonic::Kmerge2l1l;
        case ZYDIS_MNEMONIC_KMOV:
            return Mnemonic::Kmov;
        case ZYDIS_MNEMONIC_KMOVB:
            return Mnemonic::Kmovb;
        case ZYDIS_MNEMONIC_KMOVD:
            return Mnemonic::Kmovd;
        case ZYDIS_MNEMONIC_KMOVQ:
            return Mnemonic::Kmovq;
        case ZYDIS_MNEMONIC_KMOVW:
            return Mnemonic::Kmovw;
        case ZYDIS_MNEMONIC_KNOT:
            return Mnemonic::Knot;
        case ZYDIS_MNEMONIC_KNOTB:
            return Mnemonic::Knotb;
        case ZYDIS_MNEMONIC_KNOTD:
            return Mnemonic::Knotd;
        case ZYDIS_MNEMONIC_KNOTQ:
            return Mnemonic::Knotq;
        case ZYDIS_MNEMONIC_KNOTW:
            return Mnemonic::Knotw;
        case ZYDIS_MNEMONIC_KOR:
            return Mnemonic::Kor;
        case ZYDIS_MNEMONIC_KORB:
            return Mnemonic::Korb;
        case ZYDIS_MNEMONIC_KORD:
            return Mnemonic::Kord;
        case ZYDIS_MNEMONIC_KORQ:
            return Mnemonic::Korq;
        case ZYDIS_MNEMONIC_KORTEST:
            return Mnemonic::Kortest;
        case ZYDIS_MNEMONIC_KORTESTB:
            return Mnemonic::Kortestb;
        case ZYDIS_MNEMONIC_KORTESTD:
            return Mnemonic::Kortestd;
        case ZYDIS_MNEMONIC_KORTESTQ:
            return Mnemonic::Kortestq;
        case ZYDIS_MNEMONIC_KORTESTW:
            return Mnemonic::Kortestw;
        case ZYDIS_MNEMONIC_KORW:
            return Mnemonic::Korw;
        case ZYDIS_MNEMONIC_KSHIFTLB:
            return Mnemonic::Kshiftlb;
        case ZYDIS_MNEMONIC_KSHIFTLD:
            return Mnemonic::Kshiftld;
        case ZYDIS_MNEMONIC_KSHIFTLQ:
            return Mnemonic::Kshiftlq;
        case ZYDIS_MNEMONIC_KSHIFTLW:
            return Mnemonic::Kshiftlw;
        case ZYDIS_MNEMONIC_KSHIFTRB:
            return Mnemonic::Kshiftrb;
        case ZYDIS_MNEMONIC_KSHIFTRD:
            return Mnemonic::Kshiftrd;
        case ZYDIS_MNEMONIC_KSHIFTRQ:
            return Mnemonic::Kshiftrq;
        case ZYDIS_MNEMONIC_KSHIFTRW:
            return Mnemonic::Kshiftrw;
        case ZYDIS_MNEMONIC_KTESTB:
            return Mnemonic::Ktestb;
        case ZYDIS_MNEMONIC_KTESTD:
            return Mnemonic::Ktestd;
        case ZYDIS_MNEMONIC_KTESTQ:
            return Mnemonic::Ktestq;
        case ZYDIS_MNEMONIC_KTESTW:
            return Mnemonic::Ktestw;
        case ZYDIS_MNEMONIC_KUNPCKBW:
            return Mnemonic::Kunpckbw;
        case ZYDIS_MNEMONIC_KUNPCKDQ:
            return Mnemonic::Kunpckdq;
        case ZYDIS_MNEMONIC_KUNPCKWD:
            return Mnemonic::Kunpckwd;
        case ZYDIS_MNEMONIC_KXNOR:
            return Mnemonic::Kxnor;
        case ZYDIS_MNEMONIC_KXNORB:
            return Mnemonic::Kxnorb;
        case ZYDIS_MNEMONIC_KXNORD:
            return Mnemonic::Kxnord;
        case ZYDIS_MNEMONIC_KXNORQ:
            return Mnemonic::Kxnorq;
        case ZYDIS_MNEMONIC_KXNORW:
            return Mnemonic::Kxnorw;
        case ZYDIS_MNEMONIC_KXOR:
            return Mnemonic::Kxor;
        case ZYDIS_MNEMONIC_KXORB:
            return Mnemonic::Kxorb;
        case ZYDIS_MNEMONIC_KXORD:
            return Mnemonic::Kxord;
        case ZYDIS_MNEMONIC_KXORQ:
            return Mnemonic::Kxorq;
        case ZYDIS_MNEMONIC_KXORW:
            return Mnemonic::Kxorw;
        case ZYDIS_MNEMONIC_LAHF:
            return Mnemonic::Lahf;
        case ZYDIS_MNEMONIC_LAR:
            return Mnemonic::Lar;
        case ZYDIS_MNEMONIC_LDDQU:
            return Mnemonic::Lddqu;
        case ZYDIS_MNEMONIC_LDMXCSR:
            return Mnemonic::Ldmxcsr;
        case ZYDIS_MNEMONIC_LDS:
            return Mnemonic::Lds;
        case ZYDIS_MNEMONIC_LDTILECFG:
            return Mnemonic::Ldtilecfg;
        case ZYDIS_MNEMONIC_LEA:
            return Mnemonic::Lea;
        case ZYDIS_MNEMONIC_LEAVE:
            return Mnemonic::Leave;
        case ZYDIS_MNEMONIC_LES:
            return Mnemonic::Les;
        case ZYDIS_MNEMONIC_LFENCE:
            return Mnemonic::Lfence;
        case ZYDIS_MNEMONIC_LFS:
            return Mnemonic::Lfs;
        case ZYDIS_MNEMONIC_LGDT:
            return Mnemonic::Lgdt;
        case ZYDIS_MNEMONIC_LGS:
            return Mnemonic::Lgs;
        case ZYDIS_MNEMONIC_LIDT:
            return Mnemonic::Lidt;
        case ZYDIS_MNEMONIC_LLDT:
            return Mnemonic::Lldt;
        case ZYDIS_MNEMONIC_LLWPCB:
            return Mnemonic::Llwpcb;
        case ZYDIS_MNEMONIC_LMSW:
            return Mnemonic::Lmsw;
        case ZYDIS_MNEMONIC_LOADIWKEY:
            return Mnemonic::Loadiwkey;
        case ZYDIS_MNEMONIC_LODSB:
            return Mnemonic::Lodsb;
        case ZYDIS_MNEMONIC_LODSD:
            return Mnemonic::Lodsd;
        case ZYDIS_MNEMONIC_LODSQ:
            return Mnemonic::Lodsq;
        case ZYDIS_MNEMONIC_LODSW:
            return Mnemonic::Lodsw;
        case ZYDIS_MNEMONIC_LOOP:
            return Mnemonic::Loop;
        case ZYDIS_MNEMONIC_LOOPE:
            return Mnemonic::Loope;
        case ZYDIS_MNEMONIC_LOOPNE:
            return Mnemonic::Loopne;
        case ZYDIS_MNEMONIC_LSL:
            return Mnemonic::Lsl;
        case ZYDIS_MNEMONIC_LSS:
            return Mnemonic::Lss;
        case ZYDIS_MNEMONIC_LTR:
            return Mnemonic::Ltr;
        case ZYDIS_MNEMONIC_LWPINS:
            return Mnemonic::Lwpins;
        case ZYDIS_MNEMONIC_LWPVAL:
            return Mnemonic::Lwpval;
        case ZYDIS_MNEMONIC_LZCNT:
            return Mnemonic::Lzcnt;
        case ZYDIS_MNEMONIC_MASKMOVDQU:
            return Mnemonic::Maskmovdqu;
        case ZYDIS_MNEMONIC_MASKMOVQ:
            return Mnemonic::Maskmovq;
        case ZYDIS_MNEMONIC_MAXPD:
            return Mnemonic::Maxpd;
        case ZYDIS_MNEMONIC_MAXPS:
            return Mnemonic::Maxps;
        case ZYDIS_MNEMONIC_MAXSD:
            return Mnemonic::Maxsd;
        case ZYDIS_MNEMONIC_MAXSS:
            return Mnemonic::Maxss;
        case ZYDIS_MNEMONIC_MCOMMIT:
            return Mnemonic::Mcommit;
        case ZYDIS_MNEMONIC_MFENCE:
            return Mnemonic::Mfence;
        case ZYDIS_MNEMONIC_MINPD:
            return Mnemonic::Minpd;
        case ZYDIS_MNEMONIC_MINPS:
            return Mnemonic::Minps;
        case ZYDIS_MNEMONIC_MINSD:
            return Mnemonic::Minsd;
        case ZYDIS_MNEMONIC_MINSS:
            return Mnemonic::Minss;
        case ZYDIS_MNEMONIC_MONITOR:
            return Mnemonic::Monitor;
        case ZYDIS_MNEMONIC_MONITORX:
            return Mnemonic::Monitorx;
        case ZYDIS_MNEMONIC_MONTMUL:
            return Mnemonic::Montmul;
        case ZYDIS_MNEMONIC_MOV:
            return Mnemonic::Mov;
        case ZYDIS_MNEMONIC_MOVAPD:
            return Mnemonic::Movapd;
        case ZYDIS_MNEMONIC_MOVAPS:
            return Mnemonic::Movaps;
        case ZYDIS_MNEMONIC_MOVBE:
            return Mnemonic::Movbe;
        case ZYDIS_MNEMONIC_MOVD:
            return Mnemonic::Movd;
        case ZYDIS_MNEMONIC_MOVDDUP:
            return Mnemonic::Movddup;
        case ZYDIS_MNEMONIC_MOVDIR64B:
            return Mnemonic::Movdir64b;
        case ZYDIS_MNEMONIC_MOVDIRI:
            return Mnemonic::Movdiri;
        case ZYDIS_MNEMONIC_MOVDQ2Q:
            return Mnemonic::Movdq2q;
        case ZYDIS_MNEMONIC_MOVDQA:
            return Mnemonic::Movdqa;
        case ZYDIS_MNEMONIC_MOVDQU:
            return Mnemonic::Movdqu;
        case ZYDIS_MNEMONIC_MOVHLPS:
            return Mnemonic::Movhlps;
        case ZYDIS_MNEMONIC_MOVHPD:
            return Mnemonic::Movhpd;
        case ZYDIS_MNEMONIC_MOVHPS:
            return Mnemonic::Movhps;
        case ZYDIS_MNEMONIC_MOVLHPS:
            return Mnemonic::Movlhps;
        case ZYDIS_MNEMONIC_MOVLPD:
            return Mnemonic::Movlpd;
        case ZYDIS_MNEMONIC_MOVLPS:
            return Mnemonic::Movlps;
        case ZYDIS_MNEMONIC_MOVMSKPD:
            return Mnemonic::Movmskpd;
        case ZYDIS_MNEMONIC_MOVMSKPS:
            return Mnemonic::Movmskps;
        case ZYDIS_MNEMONIC_MOVNTDQ:
            return Mnemonic::Movntdq;
        case ZYDIS_MNEMONIC_MOVNTDQA:
            return Mnemonic::Movntdqa;
        case ZYDIS_MNEMONIC_MOVNTI:
            return Mnemonic::Movnti;
        case ZYDIS_MNEMONIC_MOVNTPD:
            return Mnemonic::Movntpd;
        case ZYDIS_MNEMONIC_MOVNTPS:
            return Mnemonic::Movntps;
        case ZYDIS_MNEMONIC_MOVNTQ:
            return Mnemonic::Movntq;
        case ZYDIS_MNEMONIC_MOVNTSD:
            return Mnemonic::Movntsd;
        case ZYDIS_MNEMONIC_MOVNTSS:
            return Mnemonic::Movntss;
        case ZYDIS_MNEMONIC_MOVQ:
            return Mnemonic::Movq;
        case ZYDIS_MNEMONIC_MOVQ2DQ:
            return Mnemonic::Movq2dq;
        case ZYDIS_MNEMONIC_MOVSB:
            return Mnemonic::Movsb;
        case ZYDIS_MNEMONIC_MOVSD:
            return Mnemonic::Movsd;
        case ZYDIS_MNEMONIC_MOVSHDUP:
            return Mnemonic::Movshdup;
        case ZYDIS_MNEMONIC_MOVSLDUP:
            return Mnemonic::Movsldup;
        case ZYDIS_MNEMONIC_MOVSQ:
            return Mnemonic::Movsq;
        case ZYDIS_MNEMONIC_MOVSS:
            return Mnemonic::Movss;
        case ZYDIS_MNEMONIC_MOVSW:
            return Mnemonic::Movsw;
        case ZYDIS_MNEMONIC_MOVSX:
            return Mnemonic::Movsx;
        case ZYDIS_MNEMONIC_MOVSXD:
            return Mnemonic::Movsxd;
        case ZYDIS_MNEMONIC_MOVUPD:
            return Mnemonic::Movupd;
        case ZYDIS_MNEMONIC_MOVUPS:
            return Mnemonic::Movups;
        case ZYDIS_MNEMONIC_MOVZX:
            return Mnemonic::Movzx;
        case ZYDIS_MNEMONIC_MPSADBW:
            return Mnemonic::Mpsadbw;
        case ZYDIS_MNEMONIC_MUL:
            return Mnemonic::Mul;
        case ZYDIS_MNEMONIC_MULPD:
            return Mnemonic::Mulpd;
        case ZYDIS_MNEMONIC_MULPS:
            return Mnemonic::Mulps;
        case ZYDIS_MNEMONIC_MULSD:
            return Mnemonic::Mulsd;
        case ZYDIS_MNEMONIC_MULSS:
            return Mnemonic::Mulss;
        case ZYDIS_MNEMONIC_MULX:
            return Mnemonic::Mulx;
        case ZYDIS_MNEMONIC_MWAIT:
            return Mnemonic::Mwait;
        case ZYDIS_MNEMONIC_MWAITX:
            return Mnemonic::Mwaitx;
        case ZYDIS_MNEMONIC_NEG:
            return Mnemonic::Neg;
        case ZYDIS_MNEMONIC_NOP:
            return Mnemonic::Nop;
        case ZYDIS_MNEMONIC_NOT:
            return Mnemonic::Not;
        case ZYDIS_MNEMONIC_OR:
            return Mnemonic::Or;
        case ZYDIS_MNEMONIC_ORPD:
            return Mnemonic::Orpd;
        case ZYDIS_MNEMONIC_ORPS:
            return Mnemonic::Orps;
        case ZYDIS_MNEMONIC_OUT:
            return Mnemonic::Out;
        case ZYDIS_MNEMONIC_OUTSB:
            return Mnemonic::Outsb;
        case ZYDIS_MNEMONIC_OUTSD:
            return Mnemonic::Outsd;
        case ZYDIS_MNEMONIC_OUTSW:
            return Mnemonic::Outsw;
        case ZYDIS_MNEMONIC_PABSB:
            return Mnemonic::Pabsb;
        case ZYDIS_MNEMONIC_PABSD:
            return Mnemonic::Pabsd;
        case ZYDIS_MNEMONIC_PABSW:
            return Mnemonic::Pabsw;
        case ZYDIS_MNEMONIC_PACKSSDW:
            return Mnemonic::Packssdw;
        case ZYDIS_MNEMONIC_PACKSSWB:
            return Mnemonic::Packsswb;
        case ZYDIS_MNEMONIC_PACKUSDW:
            return Mnemonic::Packusdw;
        case ZYDIS_MNEMONIC_PACKUSWB:
            return Mnemonic::Packuswb;
        case ZYDIS_MNEMONIC_PADDB:
            return Mnemonic::Paddb;
        case ZYDIS_MNEMONIC_PADDD:
            return Mnemonic::Paddd;
        case ZYDIS_MNEMONIC_PADDQ:
            return Mnemonic::Paddq;
        case ZYDIS_MNEMONIC_PADDSB:
            return Mnemonic::Paddsb;
        case ZYDIS_MNEMONIC_PADDSW:
            return Mnemonic::Paddsw;
        case ZYDIS_MNEMONIC_PADDUSB:
            return Mnemonic::Paddusb;
        case ZYDIS_MNEMONIC_PADDUSW:
            return Mnemonic::Paddusw;
        case ZYDIS_MNEMONIC_PADDW:
            return Mnemonic::Paddw;
        case ZYDIS_MNEMONIC_PALIGNR:
            return Mnemonic::Palignr;
        case ZYDIS_MNEMONIC_PAND:
            return Mnemonic::Pand;
        case ZYDIS_MNEMONIC_PANDN:
            return Mnemonic::Pandn;
        case ZYDIS_MNEMONIC_PAUSE:
            return Mnemonic::Pause;
        case ZYDIS_MNEMONIC_PAVGB:
            return Mnemonic::Pavgb;
        case ZYDIS_MNEMONIC_PAVGUSB:
            return Mnemonic::Pavgusb;
        case ZYDIS_MNEMONIC_PAVGW:
            return Mnemonic::Pavgw;
        case ZYDIS_MNEMONIC_PBLENDVB:
            return Mnemonic::Pblendvb;
        case ZYDIS_MNEMONIC_PBLENDW:
            return Mnemonic::Pblendw;
        case ZYDIS_MNEMONIC_PCLMULQDQ:
            return Mnemonic::Pclmulqdq;
        case ZYDIS_MNEMONIC_PCMPEQB:
            return Mnemonic::Pcmpeqb;
        case ZYDIS_MNEMONIC_PCMPEQD:
            return Mnemonic::Pcmpeqd;
        case ZYDIS_MNEMONIC_PCMPEQQ:
            return Mnemonic::Pcmpeqq;
        case ZYDIS_MNEMONIC_PCMPEQW:
            return Mnemonic::Pcmpeqw;
        case ZYDIS_MNEMONIC_PCMPESTRI:
            return Mnemonic::Pcmpestri;
        case ZYDIS_MNEMONIC_PCMPESTRM:
            return Mnemonic::Pcmpestrm;
        case ZYDIS_MNEMONIC_PCMPGTB:
            return Mnemonic::Pcmpgtb;
        case ZYDIS_MNEMONIC_PCMPGTD:
            return Mnemonic::Pcmpgtd;
        case ZYDIS_MNEMONIC_PCMPGTQ:
            return Mnemonic::Pcmpgtq;
        case ZYDIS_MNEMONIC_PCMPGTW:
            return Mnemonic::Pcmpgtw;
        case ZYDIS_MNEMONIC_PCMPISTRI:
            return Mnemonic::Pcmpistri;
        case ZYDIS_MNEMONIC_PCMPISTRM:
            return Mnemonic::Pcmpistrm;
        case ZYDIS_MNEMONIC_PCONFIG:
            return Mnemonic::Pconfig;
        case ZYDIS_MNEMONIC_PDEP:
            return Mnemonic::Pdep;
        case ZYDIS_MNEMONIC_PEXT:
            return Mnemonic::Pext;
        case ZYDIS_MNEMONIC_PEXTRB:
            return Mnemonic::Pextrb;
        case ZYDIS_MNEMONIC_PEXTRD:
            return Mnemonic::Pextrd;
        case ZYDIS_MNEMONIC_PEXTRQ:
            return Mnemonic::Pextrq;
        case ZYDIS_MNEMONIC_PEXTRW:
            return Mnemonic::Pextrw;
        case ZYDIS_MNEMONIC_PF2ID:
            return Mnemonic::Pf2id;
        case ZYDIS_MNEMONIC_PF2IW:
            return Mnemonic::Pf2iw;
        case ZYDIS_MNEMONIC_PFACC:
            return Mnemonic::Pfacc;
        case ZYDIS_MNEMONIC_PFADD:
            return Mnemonic::Pfadd;
        case ZYDIS_MNEMONIC_PFCMPEQ:
            return Mnemonic::Pfcmpeq;
        case ZYDIS_MNEMONIC_PFCMPGE:
            return Mnemonic::Pfcmpge;
        case ZYDIS_MNEMONIC_PFCMPGT:
            return Mnemonic::Pfcmpgt;
        case ZYDIS_MNEMONIC_PFCPIT1:
            return Mnemonic::Pfcpit1;
        case ZYDIS_MNEMONIC_PFMAX:
            return Mnemonic::Pfmax;
        case ZYDIS_MNEMONIC_PFMIN:
            return Mnemonic::Pfmin;
        case ZYDIS_MNEMONIC_PFMUL:
            return Mnemonic::Pfmul;
        case ZYDIS_MNEMONIC_PFNACC:
            return Mnemonic::Pfnacc;
        case ZYDIS_MNEMONIC_PFPNACC:
            return Mnemonic::Pfpnacc;
        case ZYDIS_MNEMONIC_PFRCP:
            return Mnemonic::Pfrcp;
        case ZYDIS_MNEMONIC_PFRCPIT2:
            return Mnemonic::Pfrcpit2;
        case ZYDIS_MNEMONIC_PFRSQIT1:
            return Mnemonic::Pfrsqit1;
        case ZYDIS_MNEMONIC_PFSQRT:
            return Mnemonic::Pfsqrt;
        case ZYDIS_MNEMONIC_PFSUB:
            return Mnemonic::Pfsub;
        case ZYDIS_MNEMONIC_PFSUBR:
            return Mnemonic::Pfsubr;
        case ZYDIS_MNEMONIC_PHADDD:
            return Mnemonic::Phaddd;
        case ZYDIS_MNEMONIC_PHADDSW:
            return Mnemonic::Phaddsw;
        case ZYDIS_MNEMONIC_PHADDW:
            return Mnemonic::Phaddw;
        case ZYDIS_MNEMONIC_PHMINPOSUW:
            return Mnemonic::Phminposuw;
        case ZYDIS_MNEMONIC_PHSUBD:
            return Mnemonic::Phsubd;
        case ZYDIS_MNEMONIC_PHSUBSW:
            return Mnemonic::Phsubsw;
        case ZYDIS_MNEMONIC_PHSUBW:
            return Mnemonic::Phsubw;
        case ZYDIS_MNEMONIC_PI2FD:
            return Mnemonic::Pi2fd;
        case ZYDIS_MNEMONIC_PI2FW:
            return Mnemonic::Pi2fw;
        case ZYDIS_MNEMONIC_PINSRB:
            return Mnemonic::Pinsrb;
        case ZYDIS_MNEMONIC_PINSRD:
            return Mnemonic::Pinsrd;
        case ZYDIS_MNEMONIC_PINSRQ:
            return Mnemonic::Pinsrq;
        case ZYDIS_MNEMONIC_PINSRW:
            return Mnemonic::Pinsrw;
        case ZYDIS_MNEMONIC_PMADDUBSW:
            return Mnemonic::Pmaddubsw;
        case ZYDIS_MNEMONIC_PMADDWD:
            return Mnemonic::Pmaddwd;
        case ZYDIS_MNEMONIC_PMAXSB:
            return Mnemonic::Pmaxsb;
        case ZYDIS_MNEMONIC_PMAXSD:
            return Mnemonic::Pmaxsd;
        case ZYDIS_MNEMONIC_PMAXSW:
            return Mnemonic::Pmaxsw;
        case ZYDIS_MNEMONIC_PMAXUB:
            return Mnemonic::Pmaxub;
        case ZYDIS_MNEMONIC_PMAXUD:
            return Mnemonic::Pmaxud;
        case ZYDIS_MNEMONIC_PMAXUW:
            return Mnemonic::Pmaxuw;
        case ZYDIS_MNEMONIC_PMINSB:
            return Mnemonic::Pminsb;
        case ZYDIS_MNEMONIC_PMINSD:
            return Mnemonic::Pminsd;
        case ZYDIS_MNEMONIC_PMINSW:
            return Mnemonic::Pminsw;
        case ZYDIS_MNEMONIC_PMINUB:
            return Mnemonic::Pminub;
        case ZYDIS_MNEMONIC_PMINUD:
            return Mnemonic::Pminud;
        case ZYDIS_MNEMONIC_PMINUW:
            return Mnemonic::Pminuw;
        case ZYDIS_MNEMONIC_PMOVMSKB:
            return Mnemonic::Pmovmskb;
        case ZYDIS_MNEMONIC_PMOVSXBD:
            return Mnemonic::Pmovsxbd;
        case ZYDIS_MNEMONIC_PMOVSXBQ:
            return Mnemonic::Pmovsxbq;
        case ZYDIS_MNEMONIC_PMOVSXBW:
            return Mnemonic::Pmovsxbw;
        case ZYDIS_MNEMONIC_PMOVSXDQ:
            return Mnemonic::Pmovsxdq;
        case ZYDIS_MNEMONIC_PMOVSXWD:
            return Mnemonic::Pmovsxwd;
        case ZYDIS_MNEMONIC_PMOVSXWQ:
            return Mnemonic::Pmovsxwq;
        case ZYDIS_MNEMONIC_PMOVZXBD:
            return Mnemonic::Pmovzxbd;
        case ZYDIS_MNEMONIC_PMOVZXBQ:
            return Mnemonic::Pmovzxbq;
        case ZYDIS_MNEMONIC_PMOVZXBW:
            return Mnemonic::Pmovzxbw;
        case ZYDIS_MNEMONIC_PMOVZXDQ:
            return Mnemonic::Pmovzxdq;
        case ZYDIS_MNEMONIC_PMOVZXWD:
            return Mnemonic::Pmovzxwd;
        case ZYDIS_MNEMONIC_PMOVZXWQ:
            return Mnemonic::Pmovzxwq;
        case ZYDIS_MNEMONIC_PMULDQ:
            return Mnemonic::Pmuldq;
        case ZYDIS_MNEMONIC_PMULHRSW:
            return Mnemonic::Pmulhrsw;
        case ZYDIS_MNEMONIC_PMULHRW:
            return Mnemonic::Pmulhrw;
        case ZYDIS_MNEMONIC_PMULHUW:
            return Mnemonic::Pmulhuw;
        case ZYDIS_MNEMONIC_PMULHW:
            return Mnemonic::Pmulhw;
        case ZYDIS_MNEMONIC_PMULLD:
            return Mnemonic::Pmulld;
        case ZYDIS_MNEMONIC_PMULLW:
            return Mnemonic::Pmullw;
        case ZYDIS_MNEMONIC_PMULUDQ:
            return Mnemonic::Pmuludq;
        case ZYDIS_MNEMONIC_POP:
            return Mnemonic::Pop;
        case ZYDIS_MNEMONIC_POPA:
            return Mnemonic::Popa;
        case ZYDIS_MNEMONIC_POPAD:
            return Mnemonic::Popad;
        case ZYDIS_MNEMONIC_POPCNT:
            return Mnemonic::Popcnt;
        case ZYDIS_MNEMONIC_POPF:
            return Mnemonic::Popf;
        case ZYDIS_MNEMONIC_POPFD:
            return Mnemonic::Popfd;
        case ZYDIS_MNEMONIC_POPFQ:
            return Mnemonic::Popfq;
        case ZYDIS_MNEMONIC_POR:
            return Mnemonic::Por;
        case ZYDIS_MNEMONIC_PREFETCH:
            return Mnemonic::Prefetch;
        case ZYDIS_MNEMONIC_PREFETCHNTA:
            return Mnemonic::Prefetchnta;
        case ZYDIS_MNEMONIC_PREFETCHT0:
            return Mnemonic::Prefetcht0;
        case ZYDIS_MNEMONIC_PREFETCHT1:
            return Mnemonic::Prefetcht1;
        case ZYDIS_MNEMONIC_PREFETCHT2:
            return Mnemonic::Prefetcht2;
        case ZYDIS_MNEMONIC_PREFETCHW:
            return Mnemonic::Prefetchw;
        case ZYDIS_MNEMONIC_PREFETCHWT1:
            return Mnemonic::Prefetchwt1;
        case ZYDIS_MNEMONIC_PSADBW:
            return Mnemonic::Psadbw;
        case ZYDIS_MNEMONIC_PSHUFB:
            return Mnemonic::Pshufb;
        case ZYDIS_MNEMONIC_PSHUFD:
            return Mnemonic::Pshufd;
        case ZYDIS_MNEMONIC_PSHUFHW:
            return Mnemonic::Pshufhw;
        case ZYDIS_MNEMONIC_PSHUFLW:
            return Mnemonic::Pshuflw;
        case ZYDIS_MNEMONIC_PSHUFW:
            return Mnemonic::Pshufw;
        case ZYDIS_MNEMONIC_PSIGNB:
            return Mnemonic::Psignb;
        case ZYDIS_MNEMONIC_PSIGND:
            return Mnemonic::Psignd;
        case ZYDIS_MNEMONIC_PSIGNW:
            return Mnemonic::Psignw;
        case ZYDIS_MNEMONIC_PSLLD:
            return Mnemonic::Pslld;
        case ZYDIS_MNEMONIC_PSLLDQ:
            return Mnemonic::Pslldq;
        case ZYDIS_MNEMONIC_PSLLQ:
            return Mnemonic::Psllq;
        case ZYDIS_MNEMONIC_PSLLW:
            return Mnemonic::Psllw;
        case ZYDIS_MNEMONIC_PSMASH:
            return Mnemonic::Psmash;
        case ZYDIS_MNEMONIC_PSRAD:
            return Mnemonic::Psrad;
        case ZYDIS_MNEMONIC_PSRAW:
            return Mnemonic::Psraw;
        case ZYDIS_MNEMONIC_PSRLD:
            return Mnemonic::Psrld;
        case ZYDIS_MNEMONIC_PSRLDQ:
            return Mnemonic::Psrldq;
        case ZYDIS_MNEMONIC_PSRLQ:
            return Mnemonic::Psrlq;
        case ZYDIS_MNEMONIC_PSRLW:
            return Mnemonic::Psrlw;
        case ZYDIS_MNEMONIC_PSUBB:
            return Mnemonic::Psubb;
        case ZYDIS_MNEMONIC_PSUBD:
            return Mnemonic::Psubd;
        case ZYDIS_MNEMONIC_PSUBQ:
            return Mnemonic::Psubq;
        case ZYDIS_MNEMONIC_PSUBSB:
            return Mnemonic::Psubsb;
        case ZYDIS_MNEMONIC_PSUBSW:
            return Mnemonic::Psubsw;
        case ZYDIS_MNEMONIC_PSUBUSB:
            return Mnemonic::Psubusb;
        case ZYDIS_MNEMONIC_PSUBUSW:
            return Mnemonic::Psubusw;
        case ZYDIS_MNEMONIC_PSUBW:
            return Mnemonic::Psubw;
        case ZYDIS_MNEMONIC_PSWAPD:
            return Mnemonic::Pswapd;
        case ZYDIS_MNEMONIC_PTEST:
            return Mnemonic::Ptest;
        case ZYDIS_MNEMONIC_PTWRITE:
            return Mnemonic::Ptwrite;
        case ZYDIS_MNEMONIC_PUNPCKHBW:
            return Mnemonic::Punpckhbw;
        case ZYDIS_MNEMONIC_PUNPCKHDQ:
            return Mnemonic::Punpckhdq;
        case ZYDIS_MNEMONIC_PUNPCKHQDQ:
            return Mnemonic::Punpckhqdq;
        case ZYDIS_MNEMONIC_PUNPCKHWD:
            return Mnemonic::Punpckhwd;
        case ZYDIS_MNEMONIC_PUNPCKLBW:
            return Mnemonic::Punpcklbw;
        case ZYDIS_MNEMONIC_PUNPCKLDQ:
            return Mnemonic::Punpckldq;
        case ZYDIS_MNEMONIC_PUNPCKLQDQ:
            return Mnemonic::Punpcklqdq;
        case ZYDIS_MNEMONIC_PUNPCKLWD:
            return Mnemonic::Punpcklwd;
        case ZYDIS_MNEMONIC_PUSH:
            return Mnemonic::Push;
        case ZYDIS_MNEMONIC_PUSHA:
            return Mnemonic::Pusha;
        case ZYDIS_MNEMONIC_PUSHAD:
            return Mnemonic::Pushad;
        case ZYDIS_MNEMONIC_PUSHF:
            return Mnemonic::Pushf;
        case ZYDIS_MNEMONIC_PUSHFD:
            return Mnemonic::Pushfd;
        case ZYDIS_MNEMONIC_PUSHFQ:
            return Mnemonic::Pushfq;
        case ZYDIS_MNEMONIC_PVALIDATE:
            return Mnemonic::Pvalidate;
        case ZYDIS_MNEMONIC_PXOR:
            return Mnemonic::Pxor;
        case ZYDIS_MNEMONIC_RCL:
            return Mnemonic::Rcl;
        case ZYDIS_MNEMONIC_RCPPS:
            return Mnemonic::Rcpps;
        case ZYDIS_MNEMONIC_RCPSS:
            return Mnemonic::Rcpss;
        case ZYDIS_MNEMONIC_RCR:
            return Mnemonic::Rcr;
        case ZYDIS_MNEMONIC_RDFSBASE:
            return Mnemonic::Rdfsbase;
        case ZYDIS_MNEMONIC_RDGSBASE:
            return Mnemonic::Rdgsbase;
        case ZYDIS_MNEMONIC_RDMSR:
            return Mnemonic::Rdmsr;
        case ZYDIS_MNEMONIC_RDPID:
            return Mnemonic::Rdpid;
        case ZYDIS_MNEMONIC_RDPKRU:
            return Mnemonic::Rdpkru;
        case ZYDIS_MNEMONIC_RDPMC:
            return Mnemonic::Rdpmc;
        case ZYDIS_MNEMONIC_RDPRU:
            return Mnemonic::Rdpru;
        case ZYDIS_MNEMONIC_RDRAND:
            return Mnemonic::Rdrand;
        case ZYDIS_MNEMONIC_RDSEED:
            return Mnemonic::Rdseed;
        case ZYDIS_MNEMONIC_RDSSPD:
            return Mnemonic::Rdsspd;
        case ZYDIS_MNEMONIC_RDSSPQ:
            return Mnemonic::Rdsspq;
        case ZYDIS_MNEMONIC_RDTSC:
            return Mnemonic::Rdtsc;
        case ZYDIS_MNEMONIC_RDTSCP:
            return Mnemonic::Rdtscp;
        case ZYDIS_MNEMONIC_RET:
            return Mnemonic::Ret;
        case ZYDIS_MNEMONIC_RMPADJUST:
            return Mnemonic::Rmpadjust;
        case ZYDIS_MNEMONIC_RMPUPDATE:
            return Mnemonic::Rmpupdate;
        case ZYDIS_MNEMONIC_ROL:
            return Mnemonic::Rol;
        case ZYDIS_MNEMONIC_ROR:
            return Mnemonic::Ror;
        case ZYDIS_MNEMONIC_RORX:
            return Mnemonic::Rorx;
        case ZYDIS_MNEMONIC_ROUNDPD:
            return Mnemonic::Roundpd;
        case ZYDIS_MNEMONIC_ROUNDPS:
            return Mnemonic::Roundps;
        case ZYDIS_MNEMONIC_ROUNDSD:
            return Mnemonic::Roundsd;
        case ZYDIS_MNEMONIC_ROUNDSS:
            return Mnemonic::Roundss;
        case ZYDIS_MNEMONIC_RSM:
            return Mnemonic::Rsm;
        case ZYDIS_MNEMONIC_RSQRTPS:
            return Mnemonic::Rsqrtps;
        case ZYDIS_MNEMONIC_RSQRTSS:
            return Mnemonic::Rsqrtss;
        case ZYDIS_MNEMONIC_RSTORSSP:
            return Mnemonic::Rstorssp;
        case ZYDIS_MNEMONIC_SAHF:
            return Mnemonic::Sahf;
        case ZYDIS_MNEMONIC_SALC:
            return Mnemonic::Salc;
        case ZYDIS_MNEMONIC_SAR:
            return Mnemonic::Sar;
        case ZYDIS_MNEMONIC_SARX:
            return Mnemonic::Sarx;
        case ZYDIS_MNEMONIC_SAVEPREVSSP:
            return Mnemonic::Saveprevssp;
        case ZYDIS_MNEMONIC_SBB:
            return Mnemonic::Sbb;
        case ZYDIS_MNEMONIC_SCASB:
            return Mnemonic::Scasb;
        case ZYDIS_MNEMONIC_SCASD:
            return Mnemonic::Scasd;
        case ZYDIS_MNEMONIC_SCASQ:
            return Mnemonic::Scasq;
        case ZYDIS_MNEMONIC_SCASW:
            return Mnemonic::Scasw;
        case ZYDIS_MNEMONIC_SEAMCALL:
            return Mnemonic::Seamcall;
        case ZYDIS_MNEMONIC_SEAMOPS:
            return Mnemonic::Seamops;
        case ZYDIS_MNEMONIC_SEAMRET:
            return Mnemonic::Seamret;
        case ZYDIS_MNEMONIC_SENDUIPI:
            return Mnemonic::Senduipi;
        case ZYDIS_MNEMONIC_SERIALIZE:
            return Mnemonic::Serialize;
        case ZYDIS_MNEMONIC_SETB:
            return Mnemonic::Setb;
        case ZYDIS_MNEMONIC_SETBE:
            return Mnemonic::Setbe;
        case ZYDIS_MNEMONIC_SETL:
            return Mnemonic::Setl;
        case ZYDIS_MNEMONIC_SETLE:
            return Mnemonic::Setle;
        case ZYDIS_MNEMONIC_SETNB:
            return Mnemonic::Setnb;
        case ZYDIS_MNEMONIC_SETNBE:
            return Mnemonic::Setnbe;
        case ZYDIS_MNEMONIC_SETNL:
            return Mnemonic::Setnl;
        case ZYDIS_MNEMONIC_SETNLE:
            return Mnemonic::Setnle;
        case ZYDIS_MNEMONIC_SETNO:
            return Mnemonic::Setno;
        case ZYDIS_MNEMONIC_SETNP:
            return Mnemonic::Setnp;
        case ZYDIS_MNEMONIC_SETNS:
            return Mnemonic::Setns;
        case ZYDIS_MNEMONIC_SETNZ:
            return Mnemonic::Setnz;
        case ZYDIS_MNEMONIC_SETO:
            return Mnemonic::Seto;
        case ZYDIS_MNEMONIC_SETP:
            return Mnemonic::Setp;
        case ZYDIS_MNEMONIC_SETS:
            return Mnemonic::Sets;
        case ZYDIS_MNEMONIC_SETSSBSY:
            return Mnemonic::Setssbsy;
        case ZYDIS_MNEMONIC_SETZ:
            return Mnemonic::Setz;
        case ZYDIS_MNEMONIC_SFENCE:
            return Mnemonic::Sfence;
        case ZYDIS_MNEMONIC_SGDT:
            return Mnemonic::Sgdt;
        case ZYDIS_MNEMONIC_SHA1MSG1:
            return Mnemonic::Sha1msg1;
        case ZYDIS_MNEMONIC_SHA1MSG2:
            return Mnemonic::Sha1msg2;
        case ZYDIS_MNEMONIC_SHA1NEXTE:
            return Mnemonic::Sha1nexte;
        case ZYDIS_MNEMONIC_SHA1RNDS4:
            return Mnemonic::Sha1rnds4;
        case ZYDIS_MNEMONIC_SHA256MSG1:
            return Mnemonic::Sha256msg1;
        case ZYDIS_MNEMONIC_SHA256MSG2:
            return Mnemonic::Sha256msg2;
        case ZYDIS_MNEMONIC_SHA256RNDS2:
            return Mnemonic::Sha256rnds2;
        case ZYDIS_MNEMONIC_SHL:
            return Mnemonic::Shl;
        case ZYDIS_MNEMONIC_SHLD:
            return Mnemonic::Shld;
        case ZYDIS_MNEMONIC_SHLX:
            return Mnemonic::Shlx;
        case ZYDIS_MNEMONIC_SHR:
            return Mnemonic::Shr;
        case ZYDIS_MNEMONIC_SHRD:
            return Mnemonic::Shrd;
        case ZYDIS_MNEMONIC_SHRX:
            return Mnemonic::Shrx;
        case ZYDIS_MNEMONIC_SHUFPD:
            return Mnemonic::Shufpd;
        case ZYDIS_MNEMONIC_SHUFPS:
            return Mnemonic::Shufps;
        case ZYDIS_MNEMONIC_SIDT:
            return Mnemonic::Sidt;
        case ZYDIS_MNEMONIC_SKINIT:
            return Mnemonic::Skinit;
        case ZYDIS_MNEMONIC_SLDT:
            return Mnemonic::Sldt;
        case ZYDIS_MNEMONIC_SLWPCB:
            return Mnemonic::Slwpcb;
        case ZYDIS_MNEMONIC_SMSW:
            return Mnemonic::Smsw;
        case ZYDIS_MNEMONIC_SPFLT:
            return Mnemonic::Spflt;
        case ZYDIS_MNEMONIC_SQRTPD:
            return Mnemonic::Sqrtpd;
        case ZYDIS_MNEMONIC_SQRTPS:
            return Mnemonic::Sqrtps;
        case ZYDIS_MNEMONIC_SQRTSD:
            return Mnemonic::Sqrtsd;
        case ZYDIS_MNEMONIC_SQRTSS:
            return Mnemonic::Sqrtss;
        case ZYDIS_MNEMONIC_STAC:
            return Mnemonic::Stac;
        case ZYDIS_MNEMONIC_STC:
            return Mnemonic::Stc;
        case ZYDIS_MNEMONIC_STD:
            return Mnemonic::Std;
        case ZYDIS_MNEMONIC_STGI:
            return Mnemonic::Stgi;
        case ZYDIS_MNEMONIC_STI:
            return Mnemonic::Sti;
        case ZYDIS_MNEMONIC_STMXCSR:
            return Mnemonic::Stmxcsr;
        case ZYDIS_MNEMONIC_STOSB:
            return Mnemonic::Stosb;
        case ZYDIS_MNEMONIC_STOSD:
            return Mnemonic::Stosd;
        case ZYDIS_MNEMONIC_STOSQ:
            return Mnemonic::Stosq;
        case ZYDIS_MNEMONIC_STOSW:
            return Mnemonic::Stosw;
        case ZYDIS_MNEMONIC_STR:
            return Mnemonic::Str;
        case ZYDIS_MNEMONIC_STTILECFG:
            return Mnemonic::Sttilecfg;
        case ZYDIS_MNEMONIC_STUI:
            return Mnemonic::Stui;
        case ZYDIS_MNEMONIC_SUB:
            return Mnemonic::Sub;
        case ZYDIS_MNEMONIC_SUBPD:
            return Mnemonic::Subpd;
        case ZYDIS_MNEMONIC_SUBPS:
            return Mnemonic::Subps;
        case ZYDIS_MNEMONIC_SUBSD:
            return Mnemonic::Subsd;
        case ZYDIS_MNEMONIC_SUBSS:
            return Mnemonic::Subss;
        case ZYDIS_MNEMONIC_SWAPGS:
            return Mnemonic::Swapgs;
        case ZYDIS_MNEMONIC_SYSCALL:
            return Mnemonic::Syscall;
        case ZYDIS_MNEMONIC_SYSENTER:
            return Mnemonic::Sysenter;
        case ZYDIS_MNEMONIC_SYSEXIT:
            return Mnemonic::Sysexit;
        case ZYDIS_MNEMONIC_SYSRET:
            return Mnemonic::Sysret;
        case ZYDIS_MNEMONIC_T1MSKC:
            return Mnemonic::T1mskc;
        case ZYDIS_MNEMONIC_TDCALL:
            return Mnemonic::Tdcall;
        case ZYDIS_MNEMONIC_TDPBF16PS:
            return Mnemonic::Tdpbf16ps;
        case ZYDIS_MNEMONIC_TDPBSSD:
            return Mnemonic::Tdpbssd;
        case ZYDIS_MNEMONIC_TDPBSUD:
            return Mnemonic::Tdpbsud;
        case ZYDIS_MNEMONIC_TDPBUSD:
            return Mnemonic::Tdpbusd;
        case ZYDIS_MNEMONIC_TDPBUUD:
            return Mnemonic::Tdpbuud;
        case ZYDIS_MNEMONIC_TEST:
            return Mnemonic::Test;
        case ZYDIS_MNEMONIC_TESTUI:
            return Mnemonic::Testui;
        case ZYDIS_MNEMONIC_TILELOADD:
            return Mnemonic::Tileloadd;
        case ZYDIS_MNEMONIC_TILELOADDT1:
            return Mnemonic::Tileloaddt1;
        case ZYDIS_MNEMONIC_TILERELEASE:
            return Mnemonic::Tilerelease;
        case ZYDIS_MNEMONIC_TILESTORED:
            return Mnemonic::Tilestored;
        case ZYDIS_MNEMONIC_TILEZERO:
            return Mnemonic::Tilezero;
        case ZYDIS_MNEMONIC_TLBSYNC:
            return Mnemonic::Tlbsync;
        case ZYDIS_MNEMONIC_TPAUSE:
            return Mnemonic::Tpause;
        case ZYDIS_MNEMONIC_TZCNT:
            return Mnemonic::Tzcnt;
        case ZYDIS_MNEMONIC_TZCNTI:
            return Mnemonic::Tzcnti;
        case ZYDIS_MNEMONIC_TZMSK:
            return Mnemonic::Tzmsk;
        case ZYDIS_MNEMONIC_UCOMISD:
            return Mnemonic::Ucomisd;
        case ZYDIS_MNEMONIC_UCOMISS:
            return Mnemonic::Ucomiss;
        case ZYDIS_MNEMONIC_UD0:
            return Mnemonic::Ud0;
        case ZYDIS_MNEMONIC_UD1:
            return Mnemonic::Ud1;
        case ZYDIS_MNEMONIC_UD2:
            return Mnemonic::Ud2;
        case ZYDIS_MNEMONIC_UIRET:
            return Mnemonic::Uiret;
        case ZYDIS_MNEMONIC_UMONITOR:
            return Mnemonic::Umonitor;
        case ZYDIS_MNEMONIC_UMWAIT:
            return Mnemonic::Umwait;
        case ZYDIS_MNEMONIC_UNPCKHPD:
            return Mnemonic::Unpckhpd;
        case ZYDIS_MNEMONIC_UNPCKHPS:
            return Mnemonic::Unpckhps;
        case ZYDIS_MNEMONIC_UNPCKLPD:
            return Mnemonic::Unpcklpd;
        case ZYDIS_MNEMONIC_UNPCKLPS:
            return Mnemonic::Unpcklps;
        case ZYDIS_MNEMONIC_V4FMADDPS:
            return Mnemonic::V4fmaddps;
        case ZYDIS_MNEMONIC_V4FMADDSS:
            return Mnemonic::V4fmaddss;
        case ZYDIS_MNEMONIC_V4FNMADDPS:
            return Mnemonic::V4fnmaddps;
        case ZYDIS_MNEMONIC_V4FNMADDSS:
            return Mnemonic::V4fnmaddss;
        case ZYDIS_MNEMONIC_VADDNPD:
            return Mnemonic::Vaddnpd;
        case ZYDIS_MNEMONIC_VADDNPS:
            return Mnemonic::Vaddnps;
        case ZYDIS_MNEMONIC_VADDPD:
            return Mnemonic::Vaddpd;
        case ZYDIS_MNEMONIC_VADDPH:
            return Mnemonic::Vaddph;
        case ZYDIS_MNEMONIC_VADDPS:
            return Mnemonic::Vaddps;
        case ZYDIS_MNEMONIC_VADDSD:
            return Mnemonic::Vaddsd;
        case ZYDIS_MNEMONIC_VADDSETSPS:
            return Mnemonic::Vaddsetsps;
        case ZYDIS_MNEMONIC_VADDSH:
            return Mnemonic::Vaddsh;
        case ZYDIS_MNEMONIC_VADDSS:
            return Mnemonic::Vaddss;
        case ZYDIS_MNEMONIC_VADDSUBPD:
            return Mnemonic::Vaddsubpd;
        case ZYDIS_MNEMONIC_VADDSUBPS:
            return Mnemonic::Vaddsubps;
        case ZYDIS_MNEMONIC_VAESDEC:
            return Mnemonic::Vaesdec;
        case ZYDIS_MNEMONIC_VAESDECLAST:
            return Mnemonic::Vaesdeclast;
        case ZYDIS_MNEMONIC_VAESENC:
            return Mnemonic::Vaesenc;
        case ZYDIS_MNEMONIC_VAESENCLAST:
            return Mnemonic::Vaesenclast;
        case ZYDIS_MNEMONIC_VAESIMC:
            return Mnemonic::Vaesimc;
        case ZYDIS_MNEMONIC_VAESKEYGENASSIST:
            return Mnemonic::Vaeskeygenassist;
        case ZYDIS_MNEMONIC_VALIGND:
            return Mnemonic::Valignd;
        case ZYDIS_MNEMONIC_VALIGNQ:
            return Mnemonic::Valignq;
        case ZYDIS_MNEMONIC_VANDNPD:
            return Mnemonic::Vandnpd;
        case ZYDIS_MNEMONIC_VANDNPS:
            return Mnemonic::Vandnps;
        case ZYDIS_MNEMONIC_VANDPD:
            return Mnemonic::Vandpd;
        case ZYDIS_MNEMONIC_VANDPS:
            return Mnemonic::Vandps;
        case ZYDIS_MNEMONIC_VBLENDMPD:
            return Mnemonic::Vblendmpd;
        case ZYDIS_MNEMONIC_VBLENDMPS:
            return Mnemonic::Vblendmps;
        case ZYDIS_MNEMONIC_VBLENDPD:
            return Mnemonic::Vblendpd;
        case ZYDIS_MNEMONIC_VBLENDPS:
            return Mnemonic::Vblendps;
        case ZYDIS_MNEMONIC_VBLENDVPD:
            return Mnemonic::Vblendvpd;
        case ZYDIS_MNEMONIC_VBLENDVPS:
            return Mnemonic::Vblendvps;
        case ZYDIS_MNEMONIC_VBROADCASTF128:
            return Mnemonic::Vbroadcastf128;
        case ZYDIS_MNEMONIC_VBROADCASTF32X2:
            return Mnemonic::Vbroadcastf32x2;
        case ZYDIS_MNEMONIC_VBROADCASTF32X4:
            return Mnemonic::Vbroadcastf32x4;
        case ZYDIS_MNEMONIC_VBROADCASTF32X8:
            return Mnemonic::Vbroadcastf32x8;
        case ZYDIS_MNEMONIC_VBROADCASTF64X2:
            return Mnemonic::Vbroadcastf64x2;
        case ZYDIS_MNEMONIC_VBROADCASTF64X4:
            return Mnemonic::Vbroadcastf64x4;
        case ZYDIS_MNEMONIC_VBROADCASTI128:
            return Mnemonic::Vbroadcasti128;
        case ZYDIS_MNEMONIC_VBROADCASTI32X2:
            return Mnemonic::Vbroadcasti32x2;
        case ZYDIS_MNEMONIC_VBROADCASTI32X4:
            return Mnemonic::Vbroadcasti32x4;
        case ZYDIS_MNEMONIC_VBROADCASTI32X8:
            return Mnemonic::Vbroadcasti32x8;
        case ZYDIS_MNEMONIC_VBROADCASTI64X2:
            return Mnemonic::Vbroadcasti64x2;
        case ZYDIS_MNEMONIC_VBROADCASTI64X4:
            return Mnemonic::Vbroadcasti64x4;
        case ZYDIS_MNEMONIC_VBROADCASTSD:
            return Mnemonic::Vbroadcastsd;
        case ZYDIS_MNEMONIC_VBROADCASTSS:
            return Mnemonic::Vbroadcastss;
        case ZYDIS_MNEMONIC_VCMPPD:
            return Mnemonic::Vcmppd;
        case ZYDIS_MNEMONIC_VCMPPH:
            return Mnemonic::Vcmpph;
        case ZYDIS_MNEMONIC_VCMPPS:
            return Mnemonic::Vcmpps;
        case ZYDIS_MNEMONIC_VCMPSD:
            return Mnemonic::Vcmpsd;
        case ZYDIS_MNEMONIC_VCMPSH:
            return Mnemonic::Vcmpsh;
        case ZYDIS_MNEMONIC_VCMPSS:
            return Mnemonic::Vcmpss;
        case ZYDIS_MNEMONIC_VCOMISD:
            return Mnemonic::Vcomisd;
        case ZYDIS_MNEMONIC_VCOMISH:
            return Mnemonic::Vcomish;
        case ZYDIS_MNEMONIC_VCOMISS:
            return Mnemonic::Vcomiss;
        case ZYDIS_MNEMONIC_VCOMPRESSPD:
            return Mnemonic::Vcompresspd;
        case ZYDIS_MNEMONIC_VCOMPRESSPS:
            return Mnemonic::Vcompressps;
        case ZYDIS_MNEMONIC_VCVTDQ2PD:
            return Mnemonic::Vcvtdq2pd;
        case ZYDIS_MNEMONIC_VCVTDQ2PH:
            return Mnemonic::Vcvtdq2ph;
        case ZYDIS_MNEMONIC_VCVTDQ2PS:
            return Mnemonic::Vcvtdq2ps;
        case ZYDIS_MNEMONIC_VCVTFXPNTDQ2PS:
            return Mnemonic::Vcvtfxpntdq2ps;
        case ZYDIS_MNEMONIC_VCVTFXPNTPD2DQ:
            return Mnemonic::Vcvtfxpntpd2dq;
        case ZYDIS_MNEMONIC_VCVTFXPNTPD2UDQ:
            return Mnemonic::Vcvtfxpntpd2udq;
        case ZYDIS_MNEMONIC_VCVTFXPNTPS2DQ:
            return Mnemonic::Vcvtfxpntps2dq;
        case ZYDIS_MNEMONIC_VCVTFXPNTPS2UDQ:
            return Mnemonic::Vcvtfxpntps2udq;
        case ZYDIS_MNEMONIC_VCVTFXPNTUDQ2PS:
            return Mnemonic::Vcvtfxpntudq2ps;
        case ZYDIS_MNEMONIC_VCVTNE2PS2BF16:
            return Mnemonic::Vcvtne2ps2bf16;
        case ZYDIS_MNEMONIC_VCVTNEPS2BF16:
            return Mnemonic::Vcvtneps2bf16;
        case ZYDIS_MNEMONIC_VCVTPD2DQ:
            return Mnemonic::Vcvtpd2dq;
        case ZYDIS_MNEMONIC_VCVTPD2PH:
            return Mnemonic::Vcvtpd2ph;
        case ZYDIS_MNEMONIC_VCVTPD2PS:
            return Mnemonic::Vcvtpd2ps;
        case ZYDIS_MNEMONIC_VCVTPD2QQ:
            return Mnemonic::Vcvtpd2qq;
        case ZYDIS_MNEMONIC_VCVTPD2UDQ:
            return Mnemonic::Vcvtpd2udq;
        case ZYDIS_MNEMONIC_VCVTPD2UQQ:
            return Mnemonic::Vcvtpd2uqq;
        case ZYDIS_MNEMONIC_VCVTPH2DQ:
            return Mnemonic::Vcvtph2dq;
        case ZYDIS_MNEMONIC_VCVTPH2PD:
            return Mnemonic::Vcvtph2pd;
        case ZYDIS_MNEMONIC_VCVTPH2PS:
            return Mnemonic::Vcvtph2ps;
        case ZYDIS_MNEMONIC_VCVTPH2PSX:
            return Mnemonic::Vcvtph2psx;
        case ZYDIS_MNEMONIC_VCVTPH2QQ:
            return Mnemonic::Vcvtph2qq;
        case ZYDIS_MNEMONIC_VCVTPH2UDQ:
            return Mnemonic::Vcvtph2udq;
        case ZYDIS_MNEMONIC_VCVTPH2UQQ:
            return Mnemonic::Vcvtph2uqq;
        case ZYDIS_MNEMONIC_VCVTPH2UW:
            return Mnemonic::Vcvtph2uw;
        case ZYDIS_MNEMONIC_VCVTPH2W:
            return Mnemonic::Vcvtph2w;
        case ZYDIS_MNEMONIC_VCVTPS2DQ:
            return Mnemonic::Vcvtps2dq;
        case ZYDIS_MNEMONIC_VCVTPS2PD:
            return Mnemonic::Vcvtps2pd;
        case ZYDIS_MNEMONIC_VCVTPS2PH:
            return Mnemonic::Vcvtps2ph;
        case ZYDIS_MNEMONIC_VCVTPS2PHX:
            return Mnemonic::Vcvtps2phx;
        case ZYDIS_MNEMONIC_VCVTPS2QQ:
            return Mnemonic::Vcvtps2qq;
        case ZYDIS_MNEMONIC_VCVTPS2UDQ:
            return Mnemonic::Vcvtps2udq;
        case ZYDIS_MNEMONIC_VCVTPS2UQQ:
            return Mnemonic::Vcvtps2uqq;
        case ZYDIS_MNEMONIC_VCVTQQ2PD:
            return Mnemonic::Vcvtqq2pd;
        case ZYDIS_MNEMONIC_VCVTQQ2PH:
            return Mnemonic::Vcvtqq2ph;
        case ZYDIS_MNEMONIC_VCVTQQ2PS:
            return Mnemonic::Vcvtqq2ps;
        case ZYDIS_MNEMONIC_VCVTSD2SH:
            return Mnemonic::Vcvtsd2sh;
        case ZYDIS_MNEMONIC_VCVTSD2SI:
            return Mnemonic::Vcvtsd2si;
        case ZYDIS_MNEMONIC_VCVTSD2SS:
            return Mnemonic::Vcvtsd2ss;
        case ZYDIS_MNEMONIC_VCVTSD2USI:
            return Mnemonic::Vcvtsd2usi;
        case ZYDIS_MNEMONIC_VCVTSH2SD:
            return Mnemonic::Vcvtsh2sd;
        case ZYDIS_MNEMONIC_VCVTSH2SI:
            return Mnemonic::Vcvtsh2si;
        case ZYDIS_MNEMONIC_VCVTSH2SS:
            return Mnemonic::Vcvtsh2ss;
        case ZYDIS_MNEMONIC_VCVTSH2USI:
            return Mnemonic::Vcvtsh2usi;
        case ZYDIS_MNEMONIC_VCVTSI2SD:
            return Mnemonic::Vcvtsi2sd;
        case ZYDIS_MNEMONIC_VCVTSI2SH:
            return Mnemonic::Vcvtsi2sh;
        case ZYDIS_MNEMONIC_VCVTSI2SS:
            return Mnemonic::Vcvtsi2ss;
        case ZYDIS_MNEMONIC_VCVTSS2SD:
            return Mnemonic::Vcvtss2sd;
        case ZYDIS_MNEMONIC_VCVTSS2SH:
            return Mnemonic::Vcvtss2sh;
        case ZYDIS_MNEMONIC_VCVTSS2SI:
            return Mnemonic::Vcvtss2si;
        case ZYDIS_MNEMONIC_VCVTSS2USI:
            return Mnemonic::Vcvtss2usi;
        case ZYDIS_MNEMONIC_VCVTTPD2DQ:
            return Mnemonic::Vcvttpd2dq;
        case ZYDIS_MNEMONIC_VCVTTPD2QQ:
            return Mnemonic::Vcvttpd2qq;
        case ZYDIS_MNEMONIC_VCVTTPD2UDQ:
            return Mnemonic::Vcvttpd2udq;
        case ZYDIS_MNEMONIC_VCVTTPD2UQQ:
            return Mnemonic::Vcvttpd2uqq;
        case ZYDIS_MNEMONIC_VCVTTPH2DQ:
            return Mnemonic::Vcvttph2dq;
        case ZYDIS_MNEMONIC_VCVTTPH2QQ:
            return Mnemonic::Vcvttph2qq;
        case ZYDIS_MNEMONIC_VCVTTPH2UDQ:
            return Mnemonic::Vcvttph2udq;
        case ZYDIS_MNEMONIC_VCVTTPH2UQQ:
            return Mnemonic::Vcvttph2uqq;
        case ZYDIS_MNEMONIC_VCVTTPH2UW:
            return Mnemonic::Vcvttph2uw;
        case ZYDIS_MNEMONIC_VCVTTPH2W:
            return Mnemonic::Vcvttph2w;
        case ZYDIS_MNEMONIC_VCVTTPS2DQ:
            return Mnemonic::Vcvttps2dq;
        case ZYDIS_MNEMONIC_VCVTTPS2QQ:
            return Mnemonic::Vcvttps2qq;
        case ZYDIS_MNEMONIC_VCVTTPS2UDQ:
            return Mnemonic::Vcvttps2udq;
        case ZYDIS_MNEMONIC_VCVTTPS2UQQ:
            return Mnemonic::Vcvttps2uqq;
        case ZYDIS_MNEMONIC_VCVTTSD2SI:
            return Mnemonic::Vcvttsd2si;
        case ZYDIS_MNEMONIC_VCVTTSD2USI:
            return Mnemonic::Vcvttsd2usi;
        case ZYDIS_MNEMONIC_VCVTTSH2SI:
            return Mnemonic::Vcvttsh2si;
        case ZYDIS_MNEMONIC_VCVTTSH2USI:
            return Mnemonic::Vcvttsh2usi;
        case ZYDIS_MNEMONIC_VCVTTSS2SI:
            return Mnemonic::Vcvttss2si;
        case ZYDIS_MNEMONIC_VCVTTSS2USI:
            return Mnemonic::Vcvttss2usi;
        case ZYDIS_MNEMONIC_VCVTUDQ2PD:
            return Mnemonic::Vcvtudq2pd;
        case ZYDIS_MNEMONIC_VCVTUDQ2PH:
            return Mnemonic::Vcvtudq2ph;
        case ZYDIS_MNEMONIC_VCVTUDQ2PS:
            return Mnemonic::Vcvtudq2ps;
        case ZYDIS_MNEMONIC_VCVTUQQ2PD:
            return Mnemonic::Vcvtuqq2pd;
        case ZYDIS_MNEMONIC_VCVTUQQ2PH:
            return Mnemonic::Vcvtuqq2ph;
        case ZYDIS_MNEMONIC_VCVTUQQ2PS:
            return Mnemonic::Vcvtuqq2ps;
        case ZYDIS_MNEMONIC_VCVTUSI2SD:
            return Mnemonic::Vcvtusi2sd;
        case ZYDIS_MNEMONIC_VCVTUSI2SH:
            return Mnemonic::Vcvtusi2sh;
        case ZYDIS_MNEMONIC_VCVTUSI2SS:
            return Mnemonic::Vcvtusi2ss;
        case ZYDIS_MNEMONIC_VCVTUW2PH:
            return Mnemonic::Vcvtuw2ph;
        case ZYDIS_MNEMONIC_VCVTW2PH:
            return Mnemonic::Vcvtw2ph;
        case ZYDIS_MNEMONIC_VDBPSADBW:
            return Mnemonic::Vdbpsadbw;
        case ZYDIS_MNEMONIC_VDIVPD:
            return Mnemonic::Vdivpd;
        case ZYDIS_MNEMONIC_VDIVPH:
            return Mnemonic::Vdivph;
        case ZYDIS_MNEMONIC_VDIVPS:
            return Mnemonic::Vdivps;
        case ZYDIS_MNEMONIC_VDIVSD:
            return Mnemonic::Vdivsd;
        case ZYDIS_MNEMONIC_VDIVSH:
            return Mnemonic::Vdivsh;
        case ZYDIS_MNEMONIC_VDIVSS:
            return Mnemonic::Vdivss;
        case ZYDIS_MNEMONIC_VDPBF16PS:
            return Mnemonic::Vdpbf16ps;
        case ZYDIS_MNEMONIC_VDPPD:
            return Mnemonic::Vdppd;
        case ZYDIS_MNEMONIC_VDPPS:
            return Mnemonic::Vdpps;
        case ZYDIS_MNEMONIC_VERR:
            return Mnemonic::Verr;
        case ZYDIS_MNEMONIC_VERW:
            return Mnemonic::Verw;
        case ZYDIS_MNEMONIC_VEXP223PS:
            return Mnemonic::Vexp223ps;
        case ZYDIS_MNEMONIC_VEXP2PD:
            return Mnemonic::Vexp2pd;
        case ZYDIS_MNEMONIC_VEXP2PS:
            return Mnemonic::Vexp2ps;
        case ZYDIS_MNEMONIC_VEXPANDPD:
            return Mnemonic::Vexpandpd;
        case ZYDIS_MNEMONIC_VEXPANDPS:
            return Mnemonic::Vexpandps;
        case ZYDIS_MNEMONIC_VEXTRACTF128:
            return Mnemonic::Vextractf128;
        case ZYDIS_MNEMONIC_VEXTRACTF32X4:
            return Mnemonic::Vextractf32x4;
        case ZYDIS_MNEMONIC_VEXTRACTF32X8:
            return Mnemonic::Vextractf32x8;
        case ZYDIS_MNEMONIC_VEXTRACTF64X2:
            return Mnemonic::Vextractf64x2;
        case ZYDIS_MNEMONIC_VEXTRACTF64X4:
            return Mnemonic::Vextractf64x4;
        case ZYDIS_MNEMONIC_VEXTRACTI128:
            return Mnemonic::Vextracti128;
        case ZYDIS_MNEMONIC_VEXTRACTI32X4:
            return Mnemonic::Vextracti32x4;
        case ZYDIS_MNEMONIC_VEXTRACTI32X8:
            return Mnemonic::Vextracti32x8;
        case ZYDIS_MNEMONIC_VEXTRACTI64X2:
            return Mnemonic::Vextracti64x2;
        case ZYDIS_MNEMONIC_VEXTRACTI64X4:
            return Mnemonic::Vextracti64x4;
        case ZYDIS_MNEMONIC_VEXTRACTPS:
            return Mnemonic::Vextractps;
        case ZYDIS_MNEMONIC_VFCMADDCPH:
            return Mnemonic::Vfcmaddcph;
        case ZYDIS_MNEMONIC_VFCMADDCSH:
            return Mnemonic::Vfcmaddcsh;
        case ZYDIS_MNEMONIC_VFCMULCPH:
            return Mnemonic::Vfcmulcph;
        case ZYDIS_MNEMONIC_VFCMULCSH:
            return Mnemonic::Vfcmulcsh;
        case ZYDIS_MNEMONIC_VFIXUPIMMPD:
            return Mnemonic::Vfixupimmpd;
        case ZYDIS_MNEMONIC_VFIXUPIMMPS:
            return Mnemonic::Vfixupimmps;
        case ZYDIS_MNEMONIC_VFIXUPIMMSD:
            return Mnemonic::Vfixupimmsd;
        case ZYDIS_MNEMONIC_VFIXUPIMMSS:
            return Mnemonic::Vfixupimmss;
        case ZYDIS_MNEMONIC_VFIXUPNANPD:
            return Mnemonic::Vfixupnanpd;
        case ZYDIS_MNEMONIC_VFIXUPNANPS:
            return Mnemonic::Vfixupnanps;
        case ZYDIS_MNEMONIC_VFMADD132PD:
            return Mnemonic::Vfmadd132pd;
        case ZYDIS_MNEMONIC_VFMADD132PH:
            return Mnemonic::Vfmadd132ph;
        case ZYDIS_MNEMONIC_VFMADD132PS:
            return Mnemonic::Vfmadd132ps;
        case ZYDIS_MNEMONIC_VFMADD132SD:
            return Mnemonic::Vfmadd132sd;
        case ZYDIS_MNEMONIC_VFMADD132SH:
            return Mnemonic::Vfmadd132sh;
        case ZYDIS_MNEMONIC_VFMADD132SS:
            return Mnemonic::Vfmadd132ss;
        case ZYDIS_MNEMONIC_VFMADD213PD:
            return Mnemonic::Vfmadd213pd;
        case ZYDIS_MNEMONIC_VFMADD213PH:
            return Mnemonic::Vfmadd213ph;
        case ZYDIS_MNEMONIC_VFMADD213PS:
            return Mnemonic::Vfmadd213ps;
        case ZYDIS_MNEMONIC_VFMADD213SD:
            return Mnemonic::Vfmadd213sd;
        case ZYDIS_MNEMONIC_VFMADD213SH:
            return Mnemonic::Vfmadd213sh;
        case ZYDIS_MNEMONIC_VFMADD213SS:
            return Mnemonic::Vfmadd213ss;
        case ZYDIS_MNEMONIC_VFMADD231PD:
            return Mnemonic::Vfmadd231pd;
        case ZYDIS_MNEMONIC_VFMADD231PH:
            return Mnemonic::Vfmadd231ph;
        case ZYDIS_MNEMONIC_VFMADD231PS:
            return Mnemonic::Vfmadd231ps;
        case ZYDIS_MNEMONIC_VFMADD231SD:
            return Mnemonic::Vfmadd231sd;
        case ZYDIS_MNEMONIC_VFMADD231SH:
            return Mnemonic::Vfmadd231sh;
        case ZYDIS_MNEMONIC_VFMADD231SS:
            return Mnemonic::Vfmadd231ss;
        case ZYDIS_MNEMONIC_VFMADD233PS:
            return Mnemonic::Vfmadd233ps;
        case ZYDIS_MNEMONIC_VFMADDCPH:
            return Mnemonic::Vfmaddcph;
        case ZYDIS_MNEMONIC_VFMADDCSH:
            return Mnemonic::Vfmaddcsh;
        case ZYDIS_MNEMONIC_VFMADDPD:
            return Mnemonic::Vfmaddpd;
        case ZYDIS_MNEMONIC_VFMADDPS:
            return Mnemonic::Vfmaddps;
        case ZYDIS_MNEMONIC_VFMADDSD:
            return Mnemonic::Vfmaddsd;
        case ZYDIS_MNEMONIC_VFMADDSS:
            return Mnemonic::Vfmaddss;
        case ZYDIS_MNEMONIC_VFMADDSUB132PD:
            return Mnemonic::Vfmaddsub132pd;
        case ZYDIS_MNEMONIC_VFMADDSUB132PH:
            return Mnemonic::Vfmaddsub132ph;
        case ZYDIS_MNEMONIC_VFMADDSUB132PS:
            return Mnemonic::Vfmaddsub132ps;
        case ZYDIS_MNEMONIC_VFMADDSUB213PD:
            return Mnemonic::Vfmaddsub213pd;
        case ZYDIS_MNEMONIC_VFMADDSUB213PH:
            return Mnemonic::Vfmaddsub213ph;
        case ZYDIS_MNEMONIC_VFMADDSUB213PS:
            return Mnemonic::Vfmaddsub213ps;
        case ZYDIS_MNEMONIC_VFMADDSUB231PD:
            return Mnemonic::Vfmaddsub231pd;
        case ZYDIS_MNEMONIC_VFMADDSUB231PH:
            return Mnemonic::Vfmaddsub231ph;
        case ZYDIS_MNEMONIC_VFMADDSUB231PS:
            return Mnemonic::Vfmaddsub231ps;
        case ZYDIS_MNEMONIC_VFMADDSUBPD:
            return Mnemonic::Vfmaddsubpd;
        case ZYDIS_MNEMONIC_VFMADDSUBPS:
            return Mnemonic::Vfmaddsubps;
        case ZYDIS_MNEMONIC_VFMSUB132PD:
            return Mnemonic::Vfmsub132pd;
        case ZYDIS_MNEMONIC_VFMSUB132PH:
            return Mnemonic::Vfmsub132ph;
        case ZYDIS_MNEMONIC_VFMSUB132PS:
            return Mnemonic::Vfmsub132ps;
        case ZYDIS_MNEMONIC_VFMSUB132SD:
            return Mnemonic::Vfmsub132sd;
        case ZYDIS_MNEMONIC_VFMSUB132SH:
            return Mnemonic::Vfmsub132sh;
        case ZYDIS_MNEMONIC_VFMSUB132SS:
            return Mnemonic::Vfmsub132ss;
        case ZYDIS_MNEMONIC_VFMSUB213PD:
            return Mnemonic::Vfmsub213pd;
        case ZYDIS_MNEMONIC_VFMSUB213PH:
            return Mnemonic::Vfmsub213ph;
        case ZYDIS_MNEMONIC_VFMSUB213PS:
            return Mnemonic::Vfmsub213ps;
        case ZYDIS_MNEMONIC_VFMSUB213SD:
            return Mnemonic::Vfmsub213sd;
        case ZYDIS_MNEMONIC_VFMSUB213SH:
            return Mnemonic::Vfmsub213sh;
        case ZYDIS_MNEMONIC_VFMSUB213SS:
            return Mnemonic::Vfmsub213ss;
        case ZYDIS_MNEMONIC_VFMSUB231PD:
            return Mnemonic::Vfmsub231pd;
        case ZYDIS_MNEMONIC_VFMSUB231PH:
            return Mnemonic::Vfmsub231ph;
        case ZYDIS_MNEMONIC_VFMSUB231PS:
            return Mnemonic::Vfmsub231ps;
        case ZYDIS_MNEMONIC_VFMSUB231SD:
            return Mnemonic::Vfmsub231sd;
        case ZYDIS_MNEMONIC_VFMSUB231SH:
            return Mnemonic::Vfmsub231sh;
        case ZYDIS_MNEMONIC_VFMSUB231SS:
            return Mnemonic::Vfmsub231ss;
        case ZYDIS_MNEMONIC_VFMSUBADD132PD:
            return Mnemonic::Vfmsubadd132pd;
        case ZYDIS_MNEMONIC_VFMSUBADD132PH:
            return Mnemonic::Vfmsubadd132ph;
        case ZYDIS_MNEMONIC_VFMSUBADD132PS:
            return Mnemonic::Vfmsubadd132ps;
        case ZYDIS_MNEMONIC_VFMSUBADD213PD:
            return Mnemonic::Vfmsubadd213pd;
        case ZYDIS_MNEMONIC_VFMSUBADD213PH:
            return Mnemonic::Vfmsubadd213ph;
        case ZYDIS_MNEMONIC_VFMSUBADD213PS:
            return Mnemonic::Vfmsubadd213ps;
        case ZYDIS_MNEMONIC_VFMSUBADD231PD:
            return Mnemonic::Vfmsubadd231pd;
        case ZYDIS_MNEMONIC_VFMSUBADD231PH:
            return Mnemonic::Vfmsubadd231ph;
        case ZYDIS_MNEMONIC_VFMSUBADD231PS:
            return Mnemonic::Vfmsubadd231ps;
        case ZYDIS_MNEMONIC_VFMSUBADDPD:
            return Mnemonic::Vfmsubaddpd;
        case ZYDIS_MNEMONIC_VFMSUBADDPS:
            return Mnemonic::Vfmsubaddps;
        case ZYDIS_MNEMONIC_VFMSUBPD:
            return Mnemonic::Vfmsubpd;
        case ZYDIS_MNEMONIC_VFMSUBPS:
            return Mnemonic::Vfmsubps;
        case ZYDIS_MNEMONIC_VFMSUBSD:
            return Mnemonic::Vfmsubsd;
        case ZYDIS_MNEMONIC_VFMSUBSS:
            return Mnemonic::Vfmsubss;
        case ZYDIS_MNEMONIC_VFMULCPH:
            return Mnemonic::Vfmulcph;
        case ZYDIS_MNEMONIC_VFMULCSH:
            return Mnemonic::Vfmulcsh;
        case ZYDIS_MNEMONIC_VFNMADD132PD:
            return Mnemonic::Vfnmadd132pd;
        case ZYDIS_MNEMONIC_VFNMADD132PH:
            return Mnemonic::Vfnmadd132ph;
        case ZYDIS_MNEMONIC_VFNMADD132PS:
            return Mnemonic::Vfnmadd132ps;
        case ZYDIS_MNEMONIC_VFNMADD132SD:
            return Mnemonic::Vfnmadd132sd;
        case ZYDIS_MNEMONIC_VFNMADD132SH:
            return Mnemonic::Vfnmadd132sh;
        case ZYDIS_MNEMONIC_VFNMADD132SS:
            return Mnemonic::Vfnmadd132ss;
        case ZYDIS_MNEMONIC_VFNMADD213PD:
            return Mnemonic::Vfnmadd213pd;
        case ZYDIS_MNEMONIC_VFNMADD213PH:
            return Mnemonic::Vfnmadd213ph;
        case ZYDIS_MNEMONIC_VFNMADD213PS:
            return Mnemonic::Vfnmadd213ps;
        case ZYDIS_MNEMONIC_VFNMADD213SD:
            return Mnemonic::Vfnmadd213sd;
        case ZYDIS_MNEMONIC_VFNMADD213SH:
            return Mnemonic::Vfnmadd213sh;
        case ZYDIS_MNEMONIC_VFNMADD213SS:
            return Mnemonic::Vfnmadd213ss;
        case ZYDIS_MNEMONIC_VFNMADD231PD:
            return Mnemonic::Vfnmadd231pd;
        case ZYDIS_MNEMONIC_VFNMADD231PH:
            return Mnemonic::Vfnmadd231ph;
        case ZYDIS_MNEMONIC_VFNMADD231PS:
            return Mnemonic::Vfnmadd231ps;
        case ZYDIS_MNEMONIC_VFNMADD231SD:
            return Mnemonic::Vfnmadd231sd;
        case ZYDIS_MNEMONIC_VFNMADD231SH:
            return Mnemonic::Vfnmadd231sh;
        case ZYDIS_MNEMONIC_VFNMADD231SS:
            return Mnemonic::Vfnmadd231ss;
        case ZYDIS_MNEMONIC_VFNMADDPD:
            return Mnemonic::Vfnmaddpd;
        case ZYDIS_MNEMONIC_VFNMADDPS:
            return Mnemonic::Vfnmaddps;
        case ZYDIS_MNEMONIC_VFNMADDSD:
            return Mnemonic::Vfnmaddsd;
        case ZYDIS_MNEMONIC_VFNMADDSS:
            return Mnemonic::Vfnmaddss;
        case ZYDIS_MNEMONIC_VFNMSUB132PD:
            return Mnemonic::Vfnmsub132pd;
        case ZYDIS_MNEMONIC_VFNMSUB132PH:
            return Mnemonic::Vfnmsub132ph;
        case ZYDIS_MNEMONIC_VFNMSUB132PS:
            return Mnemonic::Vfnmsub132ps;
        case ZYDIS_MNEMONIC_VFNMSUB132SD:
            return Mnemonic::Vfnmsub132sd;
        case ZYDIS_MNEMONIC_VFNMSUB132SH:
            return Mnemonic::Vfnmsub132sh;
        case ZYDIS_MNEMONIC_VFNMSUB132SS:
            return Mnemonic::Vfnmsub132ss;
        case ZYDIS_MNEMONIC_VFNMSUB213PD:
            return Mnemonic::Vfnmsub213pd;
        case ZYDIS_MNEMONIC_VFNMSUB213PH:
            return Mnemonic::Vfnmsub213ph;
        case ZYDIS_MNEMONIC_VFNMSUB213PS:
            return Mnemonic::Vfnmsub213ps;
        case ZYDIS_MNEMONIC_VFNMSUB213SD:
            return Mnemonic::Vfnmsub213sd;
        case ZYDIS_MNEMONIC_VFNMSUB213SH:
            return Mnemonic::Vfnmsub213sh;
        case ZYDIS_MNEMONIC_VFNMSUB213SS:
            return Mnemonic::Vfnmsub213ss;
        case ZYDIS_MNEMONIC_VFNMSUB231PD:
            return Mnemonic::Vfnmsub231pd;
        case ZYDIS_MNEMONIC_VFNMSUB231PH:
            return Mnemonic::Vfnmsub231ph;
        case ZYDIS_MNEMONIC_VFNMSUB231PS:
            return Mnemonic::Vfnmsub231ps;
        case ZYDIS_MNEMONIC_VFNMSUB231SD:
            return Mnemonic::Vfnmsub231sd;
        case ZYDIS_MNEMONIC_VFNMSUB231SH:
            return Mnemonic::Vfnmsub231sh;
        case ZYDIS_MNEMONIC_VFNMSUB231SS:
            return Mnemonic::Vfnmsub231ss;
        case ZYDIS_MNEMONIC_VFNMSUBPD:
            return Mnemonic::Vfnmsubpd;
        case ZYDIS_MNEMONIC_VFNMSUBPS:
            return Mnemonic::Vfnmsubps;
        case ZYDIS_MNEMONIC_VFNMSUBSD:
            return Mnemonic::Vfnmsubsd;
        case ZYDIS_MNEMONIC_VFNMSUBSS:
            return Mnemonic::Vfnmsubss;
        case ZYDIS_MNEMONIC_VFPCLASSPD:
            return Mnemonic::Vfpclasspd;
        case ZYDIS_MNEMONIC_VFPCLASSPH:
            return Mnemonic::Vfpclassph;
        case ZYDIS_MNEMONIC_VFPCLASSPS:
            return Mnemonic::Vfpclassps;
        case ZYDIS_MNEMONIC_VFPCLASSSD:
            return Mnemonic::Vfpclasssd;
        case ZYDIS_MNEMONIC_VFPCLASSSH:
            return Mnemonic::Vfpclasssh;
        case ZYDIS_MNEMONIC_VFPCLASSSS:
            return Mnemonic::Vfpclassss;
        case ZYDIS_MNEMONIC_VFRCZPD:
            return Mnemonic::Vfrczpd;
        case ZYDIS_MNEMONIC_VFRCZPS:
            return Mnemonic::Vfrczps;
        case ZYDIS_MNEMONIC_VFRCZSD:
            return Mnemonic::Vfrczsd;
        case ZYDIS_MNEMONIC_VFRCZSS:
            return Mnemonic::Vfrczss;
        case ZYDIS_MNEMONIC_VGATHERDPD:
            return Mnemonic::Vgatherdpd;
        case ZYDIS_MNEMONIC_VGATHERDPS:
            return Mnemonic::Vgatherdps;
        case ZYDIS_MNEMONIC_VGATHERPF0DPD:
            return Mnemonic::Vgatherpf0dpd;
        case ZYDIS_MNEMONIC_VGATHERPF0DPS:
            return Mnemonic::Vgatherpf0dps;
        case ZYDIS_MNEMONIC_VGATHERPF0HINTDPD:
            return Mnemonic::Vgatherpf0hintdpd;
        case ZYDIS_MNEMONIC_VGATHERPF0HINTDPS:
            return Mnemonic::Vgatherpf0hintdps;
        case ZYDIS_MNEMONIC_VGATHERPF0QPD:
            return Mnemonic::Vgatherpf0qpd;
        case ZYDIS_MNEMONIC_VGATHERPF0QPS:
            return Mnemonic::Vgatherpf0qps;
        case ZYDIS_MNEMONIC_VGATHERPF1DPD:
            return Mnemonic::Vgatherpf1dpd;
        case ZYDIS_MNEMONIC_VGATHERPF1DPS:
            return Mnemonic::Vgatherpf1dps;
        case ZYDIS_MNEMONIC_VGATHERPF1QPD:
            return Mnemonic::Vgatherpf1qpd;
        case ZYDIS_MNEMONIC_VGATHERPF1QPS:
            return Mnemonic::Vgatherpf1qps;
        case ZYDIS_MNEMONIC_VGATHERQPD:
            return Mnemonic::Vgatherqpd;
        case ZYDIS_MNEMONIC_VGATHERQPS:
            return Mnemonic::Vgatherqps;
        case ZYDIS_MNEMONIC_VGETEXPPD:
            return Mnemonic::Vgetexppd;
        case ZYDIS_MNEMONIC_VGETEXPPH:
            return Mnemonic::Vgetexpph;
        case ZYDIS_MNEMONIC_VGETEXPPS:
            return Mnemonic::Vgetexpps;
        case ZYDIS_MNEMONIC_VGETEXPSD:
            return Mnemonic::Vgetexpsd;
        case ZYDIS_MNEMONIC_VGETEXPSH:
            return Mnemonic::Vgetexpsh;
        case ZYDIS_MNEMONIC_VGETEXPSS:
            return Mnemonic::Vgetexpss;
        case ZYDIS_MNEMONIC_VGETMANTPD:
            return Mnemonic::Vgetmantpd;
        case ZYDIS_MNEMONIC_VGETMANTPH:
            return Mnemonic::Vgetmantph;
        case ZYDIS_MNEMONIC_VGETMANTPS:
            return Mnemonic::Vgetmantps;
        case ZYDIS_MNEMONIC_VGETMANTSD:
            return Mnemonic::Vgetmantsd;
        case ZYDIS_MNEMONIC_VGETMANTSH:
            return Mnemonic::Vgetmantsh;
        case ZYDIS_MNEMONIC_VGETMANTSS:
            return Mnemonic::Vgetmantss;
        case ZYDIS_MNEMONIC_VGF2P8AFFINEINVQB:
            return Mnemonic::Vgf2p8affineinvqb;
        case ZYDIS_MNEMONIC_VGF2P8AFFINEQB:
            return Mnemonic::Vgf2p8affineqb;
        case ZYDIS_MNEMONIC_VGF2P8MULB:
            return Mnemonic::Vgf2p8mulb;
        case ZYDIS_MNEMONIC_VGMAXABSPS:
            return Mnemonic::Vgmaxabsps;
        case ZYDIS_MNEMONIC_VGMAXPD:
            return Mnemonic::Vgmaxpd;
        case ZYDIS_MNEMONIC_VGMAXPS:
            return Mnemonic::Vgmaxps;
        case ZYDIS_MNEMONIC_VGMINPD:
            return Mnemonic::Vgminpd;
        case ZYDIS_MNEMONIC_VGMINPS:
            return Mnemonic::Vgminps;
        case ZYDIS_MNEMONIC_VHADDPD:
            return Mnemonic::Vhaddpd;
        case ZYDIS_MNEMONIC_VHADDPS:
            return Mnemonic::Vhaddps;
        case ZYDIS_MNEMONIC_VHSUBPD:
            return Mnemonic::Vhsubpd;
        case ZYDIS_MNEMONIC_VHSUBPS:
            return Mnemonic::Vhsubps;
        case ZYDIS_MNEMONIC_VINSERTF128:
            return Mnemonic::Vinsertf128;
        case ZYDIS_MNEMONIC_VINSERTF32X4:
            return Mnemonic::Vinsertf32x4;
        case ZYDIS_MNEMONIC_VINSERTF32X8:
            return Mnemonic::Vinsertf32x8;
        case ZYDIS_MNEMONIC_VINSERTF64X2:
            return Mnemonic::Vinsertf64x2;
        case ZYDIS_MNEMONIC_VINSERTF64X4:
            return Mnemonic::Vinsertf64x4;
        case ZYDIS_MNEMONIC_VINSERTI128:
            return Mnemonic::Vinserti128;
        case ZYDIS_MNEMONIC_VINSERTI32X4:
            return Mnemonic::Vinserti32x4;
        case ZYDIS_MNEMONIC_VINSERTI32X8:
            return Mnemonic::Vinserti32x8;
        case ZYDIS_MNEMONIC_VINSERTI64X2:
            return Mnemonic::Vinserti64x2;
        case ZYDIS_MNEMONIC_VINSERTI64X4:
            return Mnemonic::Vinserti64x4;
        case ZYDIS_MNEMONIC_VINSERTPS:
            return Mnemonic::Vinsertps;
        case ZYDIS_MNEMONIC_VLDDQU:
            return Mnemonic::Vlddqu;
        case ZYDIS_MNEMONIC_VLDMXCSR:
            return Mnemonic::Vldmxcsr;
        case ZYDIS_MNEMONIC_VLOADUNPACKHD:
            return Mnemonic::Vloadunpackhd;
        case ZYDIS_MNEMONIC_VLOADUNPACKHPD:
            return Mnemonic::Vloadunpackhpd;
        case ZYDIS_MNEMONIC_VLOADUNPACKHPS:
            return Mnemonic::Vloadunpackhps;
        case ZYDIS_MNEMONIC_VLOADUNPACKHQ:
            return Mnemonic::Vloadunpackhq;
        case ZYDIS_MNEMONIC_VLOADUNPACKLD:
            return Mnemonic::Vloadunpackld;
        case ZYDIS_MNEMONIC_VLOADUNPACKLPD:
            return Mnemonic::Vloadunpacklpd;
        case ZYDIS_MNEMONIC_VLOADUNPACKLPS:
            return Mnemonic::Vloadunpacklps;
        case ZYDIS_MNEMONIC_VLOADUNPACKLQ:
            return Mnemonic::Vloadunpacklq;
        case ZYDIS_MNEMONIC_VLOG2PS:
            return Mnemonic::Vlog2ps;
        case ZYDIS_MNEMONIC_VMASKMOVDQU:
            return Mnemonic::Vmaskmovdqu;
        case ZYDIS_MNEMONIC_VMASKMOVPD:
            return Mnemonic::Vmaskmovpd;
        case ZYDIS_MNEMONIC_VMASKMOVPS:
            return Mnemonic::Vmaskmovps;
        case ZYDIS_MNEMONIC_VMAXPD:
            return Mnemonic::Vmaxpd;
        case ZYDIS_MNEMONIC_VMAXPH:
            return Mnemonic::Vmaxph;
        case ZYDIS_MNEMONIC_VMAXPS:
            return Mnemonic::Vmaxps;
        case ZYDIS_MNEMONIC_VMAXSD:
            return Mnemonic::Vmaxsd;
        case ZYDIS_MNEMONIC_VMAXSH:
            return Mnemonic::Vmaxsh;
        case ZYDIS_MNEMONIC_VMAXSS:
            return Mnemonic::Vmaxss;
        case ZYDIS_MNEMONIC_VMCALL:
            return Mnemonic::Vmcall;
        case ZYDIS_MNEMONIC_VMCLEAR:
            return Mnemonic::Vmclear;
        case ZYDIS_MNEMONIC_VMFUNC:
            return Mnemonic::Vmfunc;
        case ZYDIS_MNEMONIC_VMINPD:
            return Mnemonic::Vminpd;
        case ZYDIS_MNEMONIC_VMINPH:
            return Mnemonic::Vminph;
        case ZYDIS_MNEMONIC_VMINPS:
            return Mnemonic::Vminps;
        case ZYDIS_MNEMONIC_VMINSD:
            return Mnemonic::Vminsd;
        case ZYDIS_MNEMONIC_VMINSH:
            return Mnemonic::Vminsh;
        case ZYDIS_MNEMONIC_VMINSS:
            return Mnemonic::Vminss;
        case ZYDIS_MNEMONIC_VMLAUNCH:
            return Mnemonic::Vmlaunch;
        case ZYDIS_MNEMONIC_VMLOAD:
            return Mnemonic::Vmload;
        case ZYDIS_MNEMONIC_VMMCALL:
            return Mnemonic::Vmmcall;
        case ZYDIS_MNEMONIC_VMOVAPD:
            return Mnemonic::Vmovapd;
        case ZYDIS_MNEMONIC_VMOVAPS:
            return Mnemonic::Vmovaps;
        case ZYDIS_MNEMONIC_VMOVD:
            return Mnemonic::Vmovd;
        case ZYDIS_MNEMONIC_VMOVDDUP:
            return Mnemonic::Vmovddup;
        case ZYDIS_MNEMONIC_VMOVDQA:
            return Mnemonic::Vmovdqa;
        case ZYDIS_MNEMONIC_VMOVDQA32:
            return Mnemonic::Vmovdqa32;
        case ZYDIS_MNEMONIC_VMOVDQA64:
            return Mnemonic::Vmovdqa64;
        case ZYDIS_MNEMONIC_VMOVDQU:
            return Mnemonic::Vmovdqu;
        case ZYDIS_MNEMONIC_VMOVDQU16:
            return Mnemonic::Vmovdqu16;
        case ZYDIS_MNEMONIC_VMOVDQU32:
            return Mnemonic::Vmovdqu32;
        case ZYDIS_MNEMONIC_VMOVDQU64:
            return Mnemonic::Vmovdqu64;
        case ZYDIS_MNEMONIC_VMOVDQU8:
            return Mnemonic::Vmovdqu8;
        case ZYDIS_MNEMONIC_VMOVHLPS:
            return Mnemonic::Vmovhlps;
        case ZYDIS_MNEMONIC_VMOVHPD:
            return Mnemonic::Vmovhpd;
        case ZYDIS_MNEMONIC_VMOVHPS:
            return Mnemonic::Vmovhps;
        case ZYDIS_MNEMONIC_VMOVLHPS:
            return Mnemonic::Vmovlhps;
        case ZYDIS_MNEMONIC_VMOVLPD:
            return Mnemonic::Vmovlpd;
        case ZYDIS_MNEMONIC_VMOVLPS:
            return Mnemonic::Vmovlps;
        case ZYDIS_MNEMONIC_VMOVMSKPD:
            return Mnemonic::Vmovmskpd;
        case ZYDIS_MNEMONIC_VMOVMSKPS:
            return Mnemonic::Vmovmskps;
        case ZYDIS_MNEMONIC_VMOVNRAPD:
            return Mnemonic::Vmovnrapd;
        case ZYDIS_MNEMONIC_VMOVNRAPS:
            return Mnemonic::Vmovnraps;
        case ZYDIS_MNEMONIC_VMOVNRNGOAPD:
            return Mnemonic::Vmovnrngoapd;
        case ZYDIS_MNEMONIC_VMOVNRNGOAPS:
            return Mnemonic::Vmovnrngoaps;
        case ZYDIS_MNEMONIC_VMOVNTDQ:
            return Mnemonic::Vmovntdq;
        case ZYDIS_MNEMONIC_VMOVNTDQA:
            return Mnemonic::Vmovntdqa;
        case ZYDIS_MNEMONIC_VMOVNTPD:
            return Mnemonic::Vmovntpd;
        case ZYDIS_MNEMONIC_VMOVNTPS:
            return Mnemonic::Vmovntps;
        case ZYDIS_MNEMONIC_VMOVQ:
            return Mnemonic::Vmovq;
        case ZYDIS_MNEMONIC_VMOVSD:
            return Mnemonic::Vmovsd;
        case ZYDIS_MNEMONIC_VMOVSH:
            return Mnemonic::Vmovsh;
        case ZYDIS_MNEMONIC_VMOVSHDUP:
            return Mnemonic::Vmovshdup;
        case ZYDIS_MNEMONIC_VMOVSLDUP:
            return Mnemonic::Vmovsldup;
        case ZYDIS_MNEMONIC_VMOVSS:
            return Mnemonic::Vmovss;
        case ZYDIS_MNEMONIC_VMOVUPD:
            return Mnemonic::Vmovupd;
        case ZYDIS_MNEMONIC_VMOVUPS:
            return Mnemonic::Vmovups;
        case ZYDIS_MNEMONIC_VMOVW:
            return Mnemonic::Vmovw;
        case ZYDIS_MNEMONIC_VMPSADBW:
            return Mnemonic::Vmpsadbw;
        case ZYDIS_MNEMONIC_VMPTRLD:
            return Mnemonic::Vmptrld;
        case ZYDIS_MNEMONIC_VMPTRST:
            return Mnemonic::Vmptrst;
        case ZYDIS_MNEMONIC_VMREAD:
            return Mnemonic::Vmread;
        case ZYDIS_MNEMONIC_VMRESUME:
            return Mnemonic::Vmresume;
        case ZYDIS_MNEMONIC_VMRUN:
            return Mnemonic::Vmrun;
        case ZYDIS_MNEMONIC_VMSAVE:
            return Mnemonic::Vmsave;
        case ZYDIS_MNEMONIC_VMULPD:
            return Mnemonic::Vmulpd;
        case ZYDIS_MNEMONIC_VMULPH:
            return Mnemonic::Vmulph;
        case ZYDIS_MNEMONIC_VMULPS:
            return Mnemonic::Vmulps;
        case ZYDIS_MNEMONIC_VMULSD:
            return Mnemonic::Vmulsd;
        case ZYDIS_MNEMONIC_VMULSH:
            return Mnemonic::Vmulsh;
        case ZYDIS_MNEMONIC_VMULSS:
            return Mnemonic::Vmulss;
        case ZYDIS_MNEMONIC_VMWRITE:
            return Mnemonic::Vmwrite;
        case ZYDIS_MNEMONIC_VMXOFF:
            return Mnemonic::Vmxoff;
        case ZYDIS_MNEMONIC_VMXON:
            return Mnemonic::Vmxon;
        case ZYDIS_MNEMONIC_VORPD:
            return Mnemonic::Vorpd;
        case ZYDIS_MNEMONIC_VORPS:
            return Mnemonic::Vorps;
        case ZYDIS_MNEMONIC_VP2INTERSECTD:
            return Mnemonic::Vp2intersectd;
        case ZYDIS_MNEMONIC_VP2INTERSECTQ:
            return Mnemonic::Vp2intersectq;
        case ZYDIS_MNEMONIC_VP4DPWSSD:
            return Mnemonic::Vp4dpwssd;
        case ZYDIS_MNEMONIC_VP4DPWSSDS:
            return Mnemonic::Vp4dpwssds;
        case ZYDIS_MNEMONIC_VPABSB:
            return Mnemonic::Vpabsb;
        case ZYDIS_MNEMONIC_VPABSD:
            return Mnemonic::Vpabsd;
        case ZYDIS_MNEMONIC_VPABSQ:
            return Mnemonic::Vpabsq;
        case ZYDIS_MNEMONIC_VPABSW:
            return Mnemonic::Vpabsw;
        case ZYDIS_MNEMONIC_VPACKSSDW:
            return Mnemonic::Vpackssdw;
        case ZYDIS_MNEMONIC_VPACKSSWB:
            return Mnemonic::Vpacksswb;
        case ZYDIS_MNEMONIC_VPACKSTOREHD:
            return Mnemonic::Vpackstorehd;
        case ZYDIS_MNEMONIC_VPACKSTOREHPD:
            return Mnemonic::Vpackstorehpd;
        case ZYDIS_MNEMONIC_VPACKSTOREHPS:
            return Mnemonic::Vpackstorehps;
        case ZYDIS_MNEMONIC_VPACKSTOREHQ:
            return Mnemonic::Vpackstorehq;
        case ZYDIS_MNEMONIC_VPACKSTORELD:
            return Mnemonic::Vpackstoreld;
        case ZYDIS_MNEMONIC_VPACKSTORELPD:
            return Mnemonic::Vpackstorelpd;
        case ZYDIS_MNEMONIC_VPACKSTORELPS:
            return Mnemonic::Vpackstorelps;
        case ZYDIS_MNEMONIC_VPACKSTORELQ:
            return Mnemonic::Vpackstorelq;
        case ZYDIS_MNEMONIC_VPACKUSDW:
            return Mnemonic::Vpackusdw;
        case ZYDIS_MNEMONIC_VPACKUSWB:
            return Mnemonic::Vpackuswb;
        case ZYDIS_MNEMONIC_VPADCD:
            return Mnemonic::Vpadcd;
        case ZYDIS_MNEMONIC_VPADDB:
            return Mnemonic::Vpaddb;
        case ZYDIS_MNEMONIC_VPADDD:
            return Mnemonic::Vpaddd;
        case ZYDIS_MNEMONIC_VPADDQ:
            return Mnemonic::Vpaddq;
        case ZYDIS_MNEMONIC_VPADDSB:
            return Mnemonic::Vpaddsb;
        case ZYDIS_MNEMONIC_VPADDSETCD:
            return Mnemonic::Vpaddsetcd;
        case ZYDIS_MNEMONIC_VPADDSETSD:
            return Mnemonic::Vpaddsetsd;
        case ZYDIS_MNEMONIC_VPADDSW:
            return Mnemonic::Vpaddsw;
        case ZYDIS_MNEMONIC_VPADDUSB:
            return Mnemonic::Vpaddusb;
        case ZYDIS_MNEMONIC_VPADDUSW:
            return Mnemonic::Vpaddusw;
        case ZYDIS_MNEMONIC_VPADDW:
            return Mnemonic::Vpaddw;
        case ZYDIS_MNEMONIC_VPALIGNR:
            return Mnemonic::Vpalignr;
        case ZYDIS_MNEMONIC_VPAND:
            return Mnemonic::Vpand;
        case ZYDIS_MNEMONIC_VPANDD:
            return Mnemonic::Vpandd;
        case ZYDIS_MNEMONIC_VPANDN:
            return Mnemonic::Vpandn;
        case ZYDIS_MNEMONIC_VPANDND:
            return Mnemonic::Vpandnd;
        case ZYDIS_MNEMONIC_VPANDNQ:
            return Mnemonic::Vpandnq;
        case ZYDIS_MNEMONIC_VPANDQ:
            return Mnemonic::Vpandq;
        case ZYDIS_MNEMONIC_VPAVGB:
            return Mnemonic::Vpavgb;
        case ZYDIS_MNEMONIC_VPAVGW:
            return Mnemonic::Vpavgw;
        case ZYDIS_MNEMONIC_VPBLENDD:
            return Mnemonic::Vpblendd;
        case ZYDIS_MNEMONIC_VPBLENDMB:
            return Mnemonic::Vpblendmb;
        case ZYDIS_MNEMONIC_VPBLENDMD:
            return Mnemonic::Vpblendmd;
        case ZYDIS_MNEMONIC_VPBLENDMQ:
            return Mnemonic::Vpblendmq;
        case ZYDIS_MNEMONIC_VPBLENDMW:
            return Mnemonic::Vpblendmw;
        case ZYDIS_MNEMONIC_VPBLENDVB:
            return Mnemonic::Vpblendvb;
        case ZYDIS_MNEMONIC_VPBLENDW:
            return Mnemonic::Vpblendw;
        case ZYDIS_MNEMONIC_VPBROADCASTB:
            return Mnemonic::Vpbroadcastb;
        case ZYDIS_MNEMONIC_VPBROADCASTD:
            return Mnemonic::Vpbroadcastd;
        case ZYDIS_MNEMONIC_VPBROADCASTMB2Q:
            return Mnemonic::Vpbroadcastmb2q;
        case ZYDIS_MNEMONIC_VPBROADCASTMW2D:
            return Mnemonic::Vpbroadcastmw2d;
        case ZYDIS_MNEMONIC_VPBROADCASTQ:
            return Mnemonic::Vpbroadcastq;
        case ZYDIS_MNEMONIC_VPBROADCASTW:
            return Mnemonic::Vpbroadcastw;
        case ZYDIS_MNEMONIC_VPCLMULQDQ:
            return Mnemonic::Vpclmulqdq;
        case ZYDIS_MNEMONIC_VPCMOV:
            return Mnemonic::Vpcmov;
        case ZYDIS_MNEMONIC_VPCMPB:
            return Mnemonic::Vpcmpb;
        case ZYDIS_MNEMONIC_VPCMPD:
            return Mnemonic::Vpcmpd;
        case ZYDIS_MNEMONIC_VPCMPEQB:
            return Mnemonic::Vpcmpeqb;
        case ZYDIS_MNEMONIC_VPCMPEQD:
            return Mnemonic::Vpcmpeqd;
        case ZYDIS_MNEMONIC_VPCMPEQQ:
            return Mnemonic::Vpcmpeqq;
        case ZYDIS_MNEMONIC_VPCMPEQW:
            return Mnemonic::Vpcmpeqw;
        case ZYDIS_MNEMONIC_VPCMPESTRI:
            return Mnemonic::Vpcmpestri;
        case ZYDIS_MNEMONIC_VPCMPESTRM:
            return Mnemonic::Vpcmpestrm;
        case ZYDIS_MNEMONIC_VPCMPGTB:
            return Mnemonic::Vpcmpgtb;
        case ZYDIS_MNEMONIC_VPCMPGTD:
            return Mnemonic::Vpcmpgtd;
        case ZYDIS_MNEMONIC_VPCMPGTQ:
            return Mnemonic::Vpcmpgtq;
        case ZYDIS_MNEMONIC_VPCMPGTW:
            return Mnemonic::Vpcmpgtw;
        case ZYDIS_MNEMONIC_VPCMPISTRI:
            return Mnemonic::Vpcmpistri;
        case ZYDIS_MNEMONIC_VPCMPISTRM:
            return Mnemonic::Vpcmpistrm;
        case ZYDIS_MNEMONIC_VPCMPLTD:
            return Mnemonic::Vpcmpltd;
        case ZYDIS_MNEMONIC_VPCMPQ:
            return Mnemonic::Vpcmpq;
        case ZYDIS_MNEMONIC_VPCMPUB:
            return Mnemonic::Vpcmpub;
        case ZYDIS_MNEMONIC_VPCMPUD:
            return Mnemonic::Vpcmpud;
        case ZYDIS_MNEMONIC_VPCMPUQ:
            return Mnemonic::Vpcmpuq;
        case ZYDIS_MNEMONIC_VPCMPUW:
            return Mnemonic::Vpcmpuw;
        case ZYDIS_MNEMONIC_VPCMPW:
            return Mnemonic::Vpcmpw;
        case ZYDIS_MNEMONIC_VPCOMB:
            return Mnemonic::Vpcomb;
        case ZYDIS_MNEMONIC_VPCOMD:
            return Mnemonic::Vpcomd;
        case ZYDIS_MNEMONIC_VPCOMPRESSB:
            return Mnemonic::Vpcompressb;
        case ZYDIS_MNEMONIC_VPCOMPRESSD:
            return Mnemonic::Vpcompressd;
        case ZYDIS_MNEMONIC_VPCOMPRESSQ:
            return Mnemonic::Vpcompressq;
        case ZYDIS_MNEMONIC_VPCOMPRESSW:
            return Mnemonic::Vpcompressw;
        case ZYDIS_MNEMONIC_VPCOMQ:
            return Mnemonic::Vpcomq;
        case ZYDIS_MNEMONIC_VPCOMUB:
            return Mnemonic::Vpcomub;
        case ZYDIS_MNEMONIC_VPCOMUD:
            return Mnemonic::Vpcomud;
        case ZYDIS_MNEMONIC_VPCOMUQ:
            return Mnemonic::Vpcomuq;
        case ZYDIS_MNEMONIC_VPCOMUW:
            return Mnemonic::Vpcomuw;
        case ZYDIS_MNEMONIC_VPCOMW:
            return Mnemonic::Vpcomw;
        case ZYDIS_MNEMONIC_VPCONFLICTD:
            return Mnemonic::Vpconflictd;
        case ZYDIS_MNEMONIC_VPCONFLICTQ:
            return Mnemonic::Vpconflictq;
        case ZYDIS_MNEMONIC_VPDPBUSD:
            return Mnemonic::Vpdpbusd;
        case ZYDIS_MNEMONIC_VPDPBUSDS:
            return Mnemonic::Vpdpbusds;
        case ZYDIS_MNEMONIC_VPDPWSSD:
            return Mnemonic::Vpdpwssd;
        case ZYDIS_MNEMONIC_VPDPWSSDS:
            return Mnemonic::Vpdpwssds;
        case ZYDIS_MNEMONIC_VPERM2F128:
            return Mnemonic::Vperm2f128;
        case ZYDIS_MNEMONIC_VPERM2I128:
            return Mnemonic::Vperm2i128;
        case ZYDIS_MNEMONIC_VPERMB:
            return Mnemonic::Vpermb;
        case ZYDIS_MNEMONIC_VPERMD:
            return Mnemonic::Vpermd;
        case ZYDIS_MNEMONIC_VPERMF32X4:
            return Mnemonic::Vpermf32x4;
        case ZYDIS_MNEMONIC_VPERMI2B:
            return Mnemonic::Vpermi2b;
        case ZYDIS_MNEMONIC_VPERMI2D:
            return Mnemonic::Vpermi2d;
        case ZYDIS_MNEMONIC_VPERMI2PD:
            return Mnemonic::Vpermi2pd;
        case ZYDIS_MNEMONIC_VPERMI2PS:
            return Mnemonic::Vpermi2ps;
        case ZYDIS_MNEMONIC_VPERMI2Q:
            return Mnemonic::Vpermi2q;
        case ZYDIS_MNEMONIC_VPERMI2W:
            return Mnemonic::Vpermi2w;
        case ZYDIS_MNEMONIC_VPERMIL2PD:
            return Mnemonic::Vpermil2pd;
        case ZYDIS_MNEMONIC_VPERMIL2PS:
            return Mnemonic::Vpermil2ps;
        case ZYDIS_MNEMONIC_VPERMILPD:
            return Mnemonic::Vpermilpd;
        case ZYDIS_MNEMONIC_VPERMILPS:
            return Mnemonic::Vpermilps;
        case ZYDIS_MNEMONIC_VPERMPD:
            return Mnemonic::Vpermpd;
        case ZYDIS_MNEMONIC_VPERMPS:
            return Mnemonic::Vpermps;
        case ZYDIS_MNEMONIC_VPERMQ:
            return Mnemonic::Vpermq;
        case ZYDIS_MNEMONIC_VPERMT2B:
            return Mnemonic::Vpermt2b;
        case ZYDIS_MNEMONIC_VPERMT2D:
            return Mnemonic::Vpermt2d;
        case ZYDIS_MNEMONIC_VPERMT2PD:
            return Mnemonic::Vpermt2pd;
        case ZYDIS_MNEMONIC_VPERMT2PS:
            return Mnemonic::Vpermt2ps;
        case ZYDIS_MNEMONIC_VPERMT2Q:
            return Mnemonic::Vpermt2q;
        case ZYDIS_MNEMONIC_VPERMT2W:
            return Mnemonic::Vpermt2w;
        case ZYDIS_MNEMONIC_VPERMW:
            return Mnemonic::Vpermw;
        case ZYDIS_MNEMONIC_VPEXPANDB:
            return Mnemonic::Vpexpandb;
        case ZYDIS_MNEMONIC_VPEXPANDD:
            return Mnemonic::Vpexpandd;
        case ZYDIS_MNEMONIC_VPEXPANDQ:
            return Mnemonic::Vpexpandq;
        case ZYDIS_MNEMONIC_VPEXPANDW:
            return Mnemonic::Vpexpandw;
        case ZYDIS_MNEMONIC_VPEXTRB:
            return Mnemonic::Vpextrb;
        case ZYDIS_MNEMONIC_VPEXTRD:
            return Mnemonic::Vpextrd;
        case ZYDIS_MNEMONIC_VPEXTRQ:
            return Mnemonic::Vpextrq;
        case ZYDIS_MNEMONIC_VPEXTRW:
            return Mnemonic::Vpextrw;
        case ZYDIS_MNEMONIC_VPGATHERDD:
            return Mnemonic::Vpgatherdd;
        case ZYDIS_MNEMONIC_VPGATHERDQ:
            return Mnemonic::Vpgatherdq;
        case ZYDIS_MNEMONIC_VPGATHERQD:
            return Mnemonic::Vpgatherqd;
        case ZYDIS_MNEMONIC_VPGATHERQQ:
            return Mnemonic::Vpgatherqq;
        case ZYDIS_MNEMONIC_VPHADDBD:
            return Mnemonic::Vphaddbd;
        case ZYDIS_MNEMONIC_VPHADDBQ:
            return Mnemonic::Vphaddbq;
        case ZYDIS_MNEMONIC_VPHADDBW:
            return Mnemonic::Vphaddbw;
        case ZYDIS_MNEMONIC_VPHADDD:
            return Mnemonic::Vphaddd;
        case ZYDIS_MNEMONIC_VPHADDDQ:
            return Mnemonic::Vphadddq;
        case ZYDIS_MNEMONIC_VPHADDSW:
            return Mnemonic::Vphaddsw;
        case ZYDIS_MNEMONIC_VPHADDUBD:
            return Mnemonic::Vphaddubd;
        case ZYDIS_MNEMONIC_VPHADDUBQ:
            return Mnemonic::Vphaddubq;
        case ZYDIS_MNEMONIC_VPHADDUBW:
            return Mnemonic::Vphaddubw;
        case ZYDIS_MNEMONIC_VPHADDUDQ:
            return Mnemonic::Vphaddudq;
        case ZYDIS_MNEMONIC_VPHADDUWD:
            return Mnemonic::Vphadduwd;
        case ZYDIS_MNEMONIC_VPHADDUWQ:
            return Mnemonic::Vphadduwq;
        case ZYDIS_MNEMONIC_VPHADDW:
            return Mnemonic::Vphaddw;
        case ZYDIS_MNEMONIC_VPHADDWD:
            return Mnemonic::Vphaddwd;
        case ZYDIS_MNEMONIC_VPHADDWQ:
            return Mnemonic::Vphaddwq;
        case ZYDIS_MNEMONIC_VPHMINPOSUW:
            return Mnemonic::Vphminposuw;
        case ZYDIS_MNEMONIC_VPHSUBBW:
            return Mnemonic::Vphsubbw;
        case ZYDIS_MNEMONIC_VPHSUBD:
            return Mnemonic::Vphsubd;
        case ZYDIS_MNEMONIC_VPHSUBDQ:
            return Mnemonic::Vphsubdq;
        case ZYDIS_MNEMONIC_VPHSUBSW:
            return Mnemonic::Vphsubsw;
        case ZYDIS_MNEMONIC_VPHSUBW:
            return Mnemonic::Vphsubw;
        case ZYDIS_MNEMONIC_VPHSUBWD:
            return Mnemonic::Vphsubwd;
        case ZYDIS_MNEMONIC_VPINSRB:
            return Mnemonic::Vpinsrb;
        case ZYDIS_MNEMONIC_VPINSRD:
            return Mnemonic::Vpinsrd;
        case ZYDIS_MNEMONIC_VPINSRQ:
            return Mnemonic::Vpinsrq;
        case ZYDIS_MNEMONIC_VPINSRW:
            return Mnemonic::Vpinsrw;
        case ZYDIS_MNEMONIC_VPLZCNTD:
            return Mnemonic::Vplzcntd;
        case ZYDIS_MNEMONIC_VPLZCNTQ:
            return Mnemonic::Vplzcntq;
        case ZYDIS_MNEMONIC_VPMACSDD:
            return Mnemonic::Vpmacsdd;
        case ZYDIS_MNEMONIC_VPMACSDQH:
            return Mnemonic::Vpmacsdqh;
        case ZYDIS_MNEMONIC_VPMACSDQL:
            return Mnemonic::Vpmacsdql;
        case ZYDIS_MNEMONIC_VPMACSSDD:
            return Mnemonic::Vpmacssdd;
        case ZYDIS_MNEMONIC_VPMACSSDQH:
            return Mnemonic::Vpmacssdqh;
        case ZYDIS_MNEMONIC_VPMACSSDQL:
            return Mnemonic::Vpmacssdql;
        case ZYDIS_MNEMONIC_VPMACSSWD:
            return Mnemonic::Vpmacsswd;
        case ZYDIS_MNEMONIC_VPMACSSWW:
            return Mnemonic::Vpmacssww;
        case ZYDIS_MNEMONIC_VPMACSWD:
            return Mnemonic::Vpmacswd;
        case ZYDIS_MNEMONIC_VPMACSWW:
            return Mnemonic::Vpmacsww;
        case ZYDIS_MNEMONIC_VPMADCSSWD:
            return Mnemonic::Vpmadcsswd;
        case ZYDIS_MNEMONIC_VPMADCSWD:
            return Mnemonic::Vpmadcswd;
        case ZYDIS_MNEMONIC_VPMADD231D:
            return Mnemonic::Vpmadd231d;
        case ZYDIS_MNEMONIC_VPMADD233D:
            return Mnemonic::Vpmadd233d;
        case ZYDIS_MNEMONIC_VPMADD52HUQ:
            return Mnemonic::Vpmadd52huq;
        case ZYDIS_MNEMONIC_VPMADD52LUQ:
            return Mnemonic::Vpmadd52luq;
        case ZYDIS_MNEMONIC_VPMADDUBSW:
            return Mnemonic::Vpmaddubsw;
        case ZYDIS_MNEMONIC_VPMADDWD:
            return Mnemonic::Vpmaddwd;
        case ZYDIS_MNEMONIC_VPMASKMOVD:
            return Mnemonic::Vpmaskmovd;
        case ZYDIS_MNEMONIC_VPMASKMOVQ:
            return Mnemonic::Vpmaskmovq;
        case ZYDIS_MNEMONIC_VPMAXSB:
            return Mnemonic::Vpmaxsb;
        case ZYDIS_MNEMONIC_VPMAXSD:
            return Mnemonic::Vpmaxsd;
        case ZYDIS_MNEMONIC_VPMAXSQ:
            return Mnemonic::Vpmaxsq;
        case ZYDIS_MNEMONIC_VPMAXSW:
            return Mnemonic::Vpmaxsw;
        case ZYDIS_MNEMONIC_VPMAXUB:
            return Mnemonic::Vpmaxub;
        case ZYDIS_MNEMONIC_VPMAXUD:
            return Mnemonic::Vpmaxud;
        case ZYDIS_MNEMONIC_VPMAXUQ:
            return Mnemonic::Vpmaxuq;
        case ZYDIS_MNEMONIC_VPMAXUW:
            return Mnemonic::Vpmaxuw;
        case ZYDIS_MNEMONIC_VPMINSB:
            return Mnemonic::Vpminsb;
        case ZYDIS_MNEMONIC_VPMINSD:
            return Mnemonic::Vpminsd;
        case ZYDIS_MNEMONIC_VPMINSQ:
            return Mnemonic::Vpminsq;
        case ZYDIS_MNEMONIC_VPMINSW:
            return Mnemonic::Vpminsw;
        case ZYDIS_MNEMONIC_VPMINUB:
            return Mnemonic::Vpminub;
        case ZYDIS_MNEMONIC_VPMINUD:
            return Mnemonic::Vpminud;
        case ZYDIS_MNEMONIC_VPMINUQ:
            return Mnemonic::Vpminuq;
        case ZYDIS_MNEMONIC_VPMINUW:
            return Mnemonic::Vpminuw;
        case ZYDIS_MNEMONIC_VPMOVB2M:
            return Mnemonic::Vpmovb2m;
        case ZYDIS_MNEMONIC_VPMOVD2M:
            return Mnemonic::Vpmovd2m;
        case ZYDIS_MNEMONIC_VPMOVDB:
            return Mnemonic::Vpmovdb;
        case ZYDIS_MNEMONIC_VPMOVDW:
            return Mnemonic::Vpmovdw;
        case ZYDIS_MNEMONIC_VPMOVM2B:
            return Mnemonic::Vpmovm2b;
        case ZYDIS_MNEMONIC_VPMOVM2D:
            return Mnemonic::Vpmovm2d;
        case ZYDIS_MNEMONIC_VPMOVM2Q:
            return Mnemonic::Vpmovm2q;
        case ZYDIS_MNEMONIC_VPMOVM2W:
            return Mnemonic::Vpmovm2w;
        case ZYDIS_MNEMONIC_VPMOVMSKB:
            return Mnemonic::Vpmovmskb;
        case ZYDIS_MNEMONIC_VPMOVQ2M:
            return Mnemonic::Vpmovq2m;
        case ZYDIS_MNEMONIC_VPMOVQB:
            return Mnemonic::Vpmovqb;
        case ZYDIS_MNEMONIC_VPMOVQD:
            return Mnemonic::Vpmovqd;
        case ZYDIS_MNEMONIC_VPMOVQW:
            return Mnemonic::Vpmovqw;
        case ZYDIS_MNEMONIC_VPMOVSDB:
            return Mnemonic::Vpmovsdb;
        case ZYDIS_MNEMONIC_VPMOVSDW:
            return Mnemonic::Vpmovsdw;
        case ZYDIS_MNEMONIC_VPMOVSQB:
            return Mnemonic::Vpmovsqb;
        case ZYDIS_MNEMONIC_VPMOVSQD:
            return Mnemonic::Vpmovsqd;
        case ZYDIS_MNEMONIC_VPMOVSQW:
            return Mnemonic::Vpmovsqw;
        case ZYDIS_MNEMONIC_VPMOVSWB:
            return Mnemonic::Vpmovswb;
        case ZYDIS_MNEMONIC_VPMOVSXBD:
            return Mnemonic::Vpmovsxbd;
        case ZYDIS_MNEMONIC_VPMOVSXBQ:
            return Mnemonic::Vpmovsxbq;
        case ZYDIS_MNEMONIC_VPMOVSXBW:
            return Mnemonic::Vpmovsxbw;
        case ZYDIS_MNEMONIC_VPMOVSXDQ:
            return Mnemonic::Vpmovsxdq;
        case ZYDIS_MNEMONIC_VPMOVSXWD:
            return Mnemonic::Vpmovsxwd;
        case ZYDIS_MNEMONIC_VPMOVSXWQ:
            return Mnemonic::Vpmovsxwq;
        case ZYDIS_MNEMONIC_VPMOVUSDB:
            return Mnemonic::Vpmovusdb;
        case ZYDIS_MNEMONIC_VPMOVUSDW:
            return Mnemonic::Vpmovusdw;
        case ZYDIS_MNEMONIC_VPMOVUSQB:
            return Mnemonic::Vpmovusqb;
        case ZYDIS_MNEMONIC_VPMOVUSQD:
            return Mnemonic::Vpmovusqd;
        case ZYDIS_MNEMONIC_VPMOVUSQW:
            return Mnemonic::Vpmovusqw;
        case ZYDIS_MNEMONIC_VPMOVUSWB:
            return Mnemonic::Vpmovuswb;
        case ZYDIS_MNEMONIC_VPMOVW2M:
            return Mnemonic::Vpmovw2m;
        case ZYDIS_MNEMONIC_VPMOVWB:
            return Mnemonic::Vpmovwb;
        case ZYDIS_MNEMONIC_VPMOVZXBD:
            return Mnemonic::Vpmovzxbd;
        case ZYDIS_MNEMONIC_VPMOVZXBQ:
            return Mnemonic::Vpmovzxbq;
        case ZYDIS_MNEMONIC_VPMOVZXBW:
            return Mnemonic::Vpmovzxbw;
        case ZYDIS_MNEMONIC_VPMOVZXDQ:
            return Mnemonic::Vpmovzxdq;
        case ZYDIS_MNEMONIC_VPMOVZXWD:
            return Mnemonic::Vpmovzxwd;
        case ZYDIS_MNEMONIC_VPMOVZXWQ:
            return Mnemonic::Vpmovzxwq;
        case ZYDIS_MNEMONIC_VPMULDQ:
            return Mnemonic::Vpmuldq;
        case ZYDIS_MNEMONIC_VPMULHD:
            return Mnemonic::Vpmulhd;
        case ZYDIS_MNEMONIC_VPMULHRSW:
            return Mnemonic::Vpmulhrsw;
        case ZYDIS_MNEMONIC_VPMULHUD:
            return Mnemonic::Vpmulhud;
        case ZYDIS_MNEMONIC_VPMULHUW:
            return Mnemonic::Vpmulhuw;
        case ZYDIS_MNEMONIC_VPMULHW:
            return Mnemonic::Vpmulhw;
        case ZYDIS_MNEMONIC_VPMULLD:
            return Mnemonic::Vpmulld;
        case ZYDIS_MNEMONIC_VPMULLQ:
            return Mnemonic::Vpmullq;
        case ZYDIS_MNEMONIC_VPMULLW:
            return Mnemonic::Vpmullw;
        case ZYDIS_MNEMONIC_VPMULTISHIFTQB:
            return Mnemonic::Vpmultishiftqb;
        case ZYDIS_MNEMONIC_VPMULUDQ:
            return Mnemonic::Vpmuludq;
        case ZYDIS_MNEMONIC_VPOPCNTB:
            return Mnemonic::Vpopcntb;
        case ZYDIS_MNEMONIC_VPOPCNTD:
            return Mnemonic::Vpopcntd;
        case ZYDIS_MNEMONIC_VPOPCNTQ:
            return Mnemonic::Vpopcntq;
        case ZYDIS_MNEMONIC_VPOPCNTW:
            return Mnemonic::Vpopcntw;
        case ZYDIS_MNEMONIC_VPOR:
            return Mnemonic::Vpor;
        case ZYDIS_MNEMONIC_VPORD:
            return Mnemonic::Vpord;
        case ZYDIS_MNEMONIC_VPORQ:
            return Mnemonic::Vporq;
        case ZYDIS_MNEMONIC_VPPERM:
            return Mnemonic::Vpperm;
        case ZYDIS_MNEMONIC_VPREFETCH0:
            return Mnemonic::Vprefetch0;
        case ZYDIS_MNEMONIC_VPREFETCH1:
            return Mnemonic::Vprefetch1;
        case ZYDIS_MNEMONIC_VPREFETCH2:
            return Mnemonic::Vprefetch2;
        case ZYDIS_MNEMONIC_VPREFETCHE0:
            return Mnemonic::Vprefetche0;
        case ZYDIS_MNEMONIC_VPREFETCHE1:
            return Mnemonic::Vprefetche1;
        case ZYDIS_MNEMONIC_VPREFETCHE2:
            return Mnemonic::Vprefetche2;
        case ZYDIS_MNEMONIC_VPREFETCHENTA:
            return Mnemonic::Vprefetchenta;
        case ZYDIS_MNEMONIC_VPREFETCHNTA:
            return Mnemonic::Vprefetchnta;
        case ZYDIS_MNEMONIC_VPROLD:
            return Mnemonic::Vprold;
        case ZYDIS_MNEMONIC_VPROLQ:
            return Mnemonic::Vprolq;
        case ZYDIS_MNEMONIC_VPROLVD:
            return Mnemonic::Vprolvd;
        case ZYDIS_MNEMONIC_VPROLVQ:
            return Mnemonic::Vprolvq;
        case ZYDIS_MNEMONIC_VPRORD:
            return Mnemonic::Vprord;
        case ZYDIS_MNEMONIC_VPRORQ:
            return Mnemonic::Vprorq;
        case ZYDIS_MNEMONIC_VPRORVD:
            return Mnemonic::Vprorvd;
        case ZYDIS_MNEMONIC_VPRORVQ:
            return Mnemonic::Vprorvq;
        case ZYDIS_MNEMONIC_VPROTB:
            return Mnemonic::Vprotb;
        case ZYDIS_MNEMONIC_VPROTD:
            return Mnemonic::Vprotd;
        case ZYDIS_MNEMONIC_VPROTQ:
            return Mnemonic::Vprotq;
        case ZYDIS_MNEMONIC_VPROTW:
            return Mnemonic::Vprotw;
        case ZYDIS_MNEMONIC_VPSADBW:
            return Mnemonic::Vpsadbw;
        case ZYDIS_MNEMONIC_VPSBBD:
            return Mnemonic::Vpsbbd;
        case ZYDIS_MNEMONIC_VPSBBRD:
            return Mnemonic::Vpsbbrd;
        case ZYDIS_MNEMONIC_VPSCATTERDD:
            return Mnemonic::Vpscatterdd;
        case ZYDIS_MNEMONIC_VPSCATTERDQ:
            return Mnemonic::Vpscatterdq;
        case ZYDIS_MNEMONIC_VPSCATTERQD:
            return Mnemonic::Vpscatterqd;
        case ZYDIS_MNEMONIC_VPSCATTERQQ:
            return Mnemonic::Vpscatterqq;
        case ZYDIS_MNEMONIC_VPSHAB:
            return Mnemonic::Vpshab;
        case ZYDIS_MNEMONIC_VPSHAD:
            return Mnemonic::Vpshad;
        case ZYDIS_MNEMONIC_VPSHAQ:
            return Mnemonic::Vpshaq;
        case ZYDIS_MNEMONIC_VPSHAW:
            return Mnemonic::Vpshaw;
        case ZYDIS_MNEMONIC_VPSHLB:
            return Mnemonic::Vpshlb;
        case ZYDIS_MNEMONIC_VPSHLD:
            return Mnemonic::Vpshld;
        case ZYDIS_MNEMONIC_VPSHLDD:
            return Mnemonic::Vpshldd;
        case ZYDIS_MNEMONIC_VPSHLDQ:
            return Mnemonic::Vpshldq;
        case ZYDIS_MNEMONIC_VPSHLDVD:
            return Mnemonic::Vpshldvd;
        case ZYDIS_MNEMONIC_VPSHLDVQ:
            return Mnemonic::Vpshldvq;
        case ZYDIS_MNEMONIC_VPSHLDVW:
            return Mnemonic::Vpshldvw;
        case ZYDIS_MNEMONIC_VPSHLDW:
            return Mnemonic::Vpshldw;
        case ZYDIS_MNEMONIC_VPSHLQ:
            return Mnemonic::Vpshlq;
        case ZYDIS_MNEMONIC_VPSHLW:
            return Mnemonic::Vpshlw;
        case ZYDIS_MNEMONIC_VPSHRDD:
            return Mnemonic::Vpshrdd;
        case ZYDIS_MNEMONIC_VPSHRDQ:
            return Mnemonic::Vpshrdq;
        case ZYDIS_MNEMONIC_VPSHRDVD:
            return Mnemonic::Vpshrdvd;
        case ZYDIS_MNEMONIC_VPSHRDVQ:
            return Mnemonic::Vpshrdvq;
        case ZYDIS_MNEMONIC_VPSHRDVW:
            return Mnemonic::Vpshrdvw;
        case ZYDIS_MNEMONIC_VPSHRDW:
            return Mnemonic::Vpshrdw;
        case ZYDIS_MNEMONIC_VPSHUFB:
            return Mnemonic::Vpshufb;
        case ZYDIS_MNEMONIC_VPSHUFBITQMB:
            return Mnemonic::Vpshufbitqmb;
        case ZYDIS_MNEMONIC_VPSHUFD:
            return Mnemonic::Vpshufd;
        case ZYDIS_MNEMONIC_VPSHUFHW:
            return Mnemonic::Vpshufhw;
        case ZYDIS_MNEMONIC_VPSHUFLW:
            return Mnemonic::Vpshuflw;
        case ZYDIS_MNEMONIC_VPSIGNB:
            return Mnemonic::Vpsignb;
        case ZYDIS_MNEMONIC_VPSIGND:
            return Mnemonic::Vpsignd;
        case ZYDIS_MNEMONIC_VPSIGNW:
            return Mnemonic::Vpsignw;
        case ZYDIS_MNEMONIC_VPSLLD:
            return Mnemonic::Vpslld;
        case ZYDIS_MNEMONIC_VPSLLDQ:
            return Mnemonic::Vpslldq;
        case ZYDIS_MNEMONIC_VPSLLQ:
            return Mnemonic::Vpsllq;
        case ZYDIS_MNEMONIC_VPSLLVD:
            return Mnemonic::Vpsllvd;
        case ZYDIS_MNEMONIC_VPSLLVQ:
            return Mnemonic::Vpsllvq;
        case ZYDIS_MNEMONIC_VPSLLVW:
            return Mnemonic::Vpsllvw;
        case ZYDIS_MNEMONIC_VPSLLW:
            return Mnemonic::Vpsllw;
        case ZYDIS_MNEMONIC_VPSRAD:
            return Mnemonic::Vpsrad;
        case ZYDIS_MNEMONIC_VPSRAQ:
            return Mnemonic::Vpsraq;
        case ZYDIS_MNEMONIC_VPSRAVD:
            return Mnemonic::Vpsravd;
        case ZYDIS_MNEMONIC_VPSRAVQ:
            return Mnemonic::Vpsravq;
        case ZYDIS_MNEMONIC_VPSRAVW:
            return Mnemonic::Vpsravw;
        case ZYDIS_MNEMONIC_VPSRAW:
            return Mnemonic::Vpsraw;
        case ZYDIS_MNEMONIC_VPSRLD:
            return Mnemonic::Vpsrld;
        case ZYDIS_MNEMONIC_VPSRLDQ:
            return Mnemonic::Vpsrldq;
        case ZYDIS_MNEMONIC_VPSRLQ:
            return Mnemonic::Vpsrlq;
        case ZYDIS_MNEMONIC_VPSRLVD:
            return Mnemonic::Vpsrlvd;
        case ZYDIS_MNEMONIC_VPSRLVQ:
            return Mnemonic::Vpsrlvq;
        case ZYDIS_MNEMONIC_VPSRLVW:
            return Mnemonic::Vpsrlvw;
        case ZYDIS_MNEMONIC_VPSRLW:
            return Mnemonic::Vpsrlw;
        case ZYDIS_MNEMONIC_VPSUBB:
            return Mnemonic::Vpsubb;
        case ZYDIS_MNEMONIC_VPSUBD:
            return Mnemonic::Vpsubd;
        case ZYDIS_MNEMONIC_VPSUBQ:
            return Mnemonic::Vpsubq;
        case ZYDIS_MNEMONIC_VPSUBRD:
            return Mnemonic::Vpsubrd;
        case ZYDIS_MNEMONIC_VPSUBRSETBD:
            return Mnemonic::Vpsubrsetbd;
        case ZYDIS_MNEMONIC_VPSUBSB:
            return Mnemonic::Vpsubsb;
        case ZYDIS_MNEMONIC_VPSUBSETBD:
            return Mnemonic::Vpsubsetbd;
        case ZYDIS_MNEMONIC_VPSUBSW:
            return Mnemonic::Vpsubsw;
        case ZYDIS_MNEMONIC_VPSUBUSB:
            return Mnemonic::Vpsubusb;
        case ZYDIS_MNEMONIC_VPSUBUSW:
            return Mnemonic::Vpsubusw;
        case ZYDIS_MNEMONIC_VPSUBW:
            return Mnemonic::Vpsubw;
        case ZYDIS_MNEMONIC_VPTERNLOGD:
            return Mnemonic::Vpternlogd;
        case ZYDIS_MNEMONIC_VPTERNLOGQ:
            return Mnemonic::Vpternlogq;
        case ZYDIS_MNEMONIC_VPTEST:
            return Mnemonic::Vptest;
        case ZYDIS_MNEMONIC_VPTESTMB:
            return Mnemonic::Vptestmb;
        case ZYDIS_MNEMONIC_VPTESTMD:
            return Mnemonic::Vptestmd;
        case ZYDIS_MNEMONIC_VPTESTMQ:
            return Mnemonic::Vptestmq;
        case ZYDIS_MNEMONIC_VPTESTMW:
            return Mnemonic::Vptestmw;
        case ZYDIS_MNEMONIC_VPTESTNMB:
            return Mnemonic::Vptestnmb;
        case ZYDIS_MNEMONIC_VPTESTNMD:
            return Mnemonic::Vptestnmd;
        case ZYDIS_MNEMONIC_VPTESTNMQ:
            return Mnemonic::Vptestnmq;
        case ZYDIS_MNEMONIC_VPTESTNMW:
            return Mnemonic::Vptestnmw;
        case ZYDIS_MNEMONIC_VPUNPCKHBW:
            return Mnemonic::Vpunpckhbw;
        case ZYDIS_MNEMONIC_VPUNPCKHDQ:
            return Mnemonic::Vpunpckhdq;
        case ZYDIS_MNEMONIC_VPUNPCKHQDQ:
            return Mnemonic::Vpunpckhqdq;
        case ZYDIS_MNEMONIC_VPUNPCKHWD:
            return Mnemonic::Vpunpckhwd;
        case ZYDIS_MNEMONIC_VPUNPCKLBW:
            return Mnemonic::Vpunpcklbw;
        case ZYDIS_MNEMONIC_VPUNPCKLDQ:
            return Mnemonic::Vpunpckldq;
        case ZYDIS_MNEMONIC_VPUNPCKLQDQ:
            return Mnemonic::Vpunpcklqdq;
        case ZYDIS_MNEMONIC_VPUNPCKLWD:
            return Mnemonic::Vpunpcklwd;
        case ZYDIS_MNEMONIC_VPXOR:
            return Mnemonic::Vpxor;
        case ZYDIS_MNEMONIC_VPXORD:
            return Mnemonic::Vpxord;
        case ZYDIS_MNEMONIC_VPXORQ:
            return Mnemonic::Vpxorq;
        case ZYDIS_MNEMONIC_VRANGEPD:
            return Mnemonic::Vrangepd;
        case ZYDIS_MNEMONIC_VRANGEPS:
            return Mnemonic::Vrangeps;
        case ZYDIS_MNEMONIC_VRANGESD:
            return Mnemonic::Vrangesd;
        case ZYDIS_MNEMONIC_VRANGESS:
            return Mnemonic::Vrangess;
        case ZYDIS_MNEMONIC_VRCP14PD:
            return Mnemonic::Vrcp14pd;
        case ZYDIS_MNEMONIC_VRCP14PS:
            return Mnemonic::Vrcp14ps;
        case ZYDIS_MNEMONIC_VRCP14SD:
            return Mnemonic::Vrcp14sd;
        case ZYDIS_MNEMONIC_VRCP14SS:
            return Mnemonic::Vrcp14ss;
        case ZYDIS_MNEMONIC_VRCP23PS:
            return Mnemonic::Vrcp23ps;
        case ZYDIS_MNEMONIC_VRCP28PD:
            return Mnemonic::Vrcp28pd;
        case ZYDIS_MNEMONIC_VRCP28PS:
            return Mnemonic::Vrcp28ps;
        case ZYDIS_MNEMONIC_VRCP28SD:
            return Mnemonic::Vrcp28sd;
        case ZYDIS_MNEMONIC_VRCP28SS:
            return Mnemonic::Vrcp28ss;
        case ZYDIS_MNEMONIC_VRCPPH:
            return Mnemonic::Vrcpph;
        case ZYDIS_MNEMONIC_VRCPPS:
            return Mnemonic::Vrcpps;
        case ZYDIS_MNEMONIC_VRCPSH:
            return Mnemonic::Vrcpsh;
        case ZYDIS_MNEMONIC_VRCPSS:
            return Mnemonic::Vrcpss;
        case ZYDIS_MNEMONIC_VREDUCEPD:
            return Mnemonic::Vreducepd;
        case ZYDIS_MNEMONIC_VREDUCEPH:
            return Mnemonic::Vreduceph;
        case ZYDIS_MNEMONIC_VREDUCEPS:
            return Mnemonic::Vreduceps;
        case ZYDIS_MNEMONIC_VREDUCESD:
            return Mnemonic::Vreducesd;
        case ZYDIS_MNEMONIC_VREDUCESH:
            return Mnemonic::Vreducesh;
        case ZYDIS_MNEMONIC_VREDUCESS:
            return Mnemonic::Vreducess;
        case ZYDIS_MNEMONIC_VRNDFXPNTPD:
            return Mnemonic::Vrndfxpntpd;
        case ZYDIS_MNEMONIC_VRNDFXPNTPS:
            return Mnemonic::Vrndfxpntps;
        case ZYDIS_MNEMONIC_VRNDSCALEPD:
            return Mnemonic::Vrndscalepd;
        case ZYDIS_MNEMONIC_VRNDSCALEPH:
            return Mnemonic::Vrndscaleph;
        case ZYDIS_MNEMONIC_VRNDSCALEPS:
            return Mnemonic::Vrndscaleps;
        case ZYDIS_MNEMONIC_VRNDSCALESD:
            return Mnemonic::Vrndscalesd;
        case ZYDIS_MNEMONIC_VRNDSCALESH:
            return Mnemonic::Vrndscalesh;
        case ZYDIS_MNEMONIC_VRNDSCALESS:
            return Mnemonic::Vrndscaless;
        case ZYDIS_MNEMONIC_VROUNDPD:
            return Mnemonic::Vroundpd;
        case ZYDIS_MNEMONIC_VROUNDPS:
            return Mnemonic::Vroundps;
        case ZYDIS_MNEMONIC_VROUNDSD:
            return Mnemonic::Vroundsd;
        case ZYDIS_MNEMONIC_VROUNDSS:
            return Mnemonic::Vroundss;
        case ZYDIS_MNEMONIC_VRSQRT14PD:
            return Mnemonic::Vrsqrt14pd;
        case ZYDIS_MNEMONIC_VRSQRT14PS:
            return Mnemonic::Vrsqrt14ps;
        case ZYDIS_MNEMONIC_VRSQRT14SD:
            return Mnemonic::Vrsqrt14sd;
        case ZYDIS_MNEMONIC_VRSQRT14SS:
            return Mnemonic::Vrsqrt14ss;
        case ZYDIS_MNEMONIC_VRSQRT23PS:
            return Mnemonic::Vrsqrt23ps;
        case ZYDIS_MNEMONIC_VRSQRT28PD:
            return Mnemonic::Vrsqrt28pd;
        case ZYDIS_MNEMONIC_VRSQRT28PS:
            return Mnemonic::Vrsqrt28ps;
        case ZYDIS_MNEMONIC_VRSQRT28SD:
            return Mnemonic::Vrsqrt28sd;
        case ZYDIS_MNEMONIC_VRSQRT28SS:
            return Mnemonic::Vrsqrt28ss;
        case ZYDIS_MNEMONIC_VRSQRTPH:
            return Mnemonic::Vrsqrtph;
        case ZYDIS_MNEMONIC_VRSQRTPS:
            return Mnemonic::Vrsqrtps;
        case ZYDIS_MNEMONIC_VRSQRTSH:
            return Mnemonic::Vrsqrtsh;
        case ZYDIS_MNEMONIC_VRSQRTSS:
            return Mnemonic::Vrsqrtss;
        case ZYDIS_MNEMONIC_VSCALEFPD:
            return Mnemonic::Vscalefpd;
        case ZYDIS_MNEMONIC_VSCALEFPH:
            return Mnemonic::Vscalefph;
        case ZYDIS_MNEMONIC_VSCALEFPS:
            return Mnemonic::Vscalefps;
        case ZYDIS_MNEMONIC_VSCALEFSD:
            return Mnemonic::Vscalefsd;
        case ZYDIS_MNEMONIC_VSCALEFSH:
            return Mnemonic::Vscalefsh;
        case ZYDIS_MNEMONIC_VSCALEFSS:
            return Mnemonic::Vscalefss;
        case ZYDIS_MNEMONIC_VSCALEPS:
            return Mnemonic::Vscaleps;
        case ZYDIS_MNEMONIC_VSCATTERDPD:
            return Mnemonic::Vscatterdpd;
        case ZYDIS_MNEMONIC_VSCATTERDPS:
            return Mnemonic::Vscatterdps;
        case ZYDIS_MNEMONIC_VSCATTERPF0DPD:
            return Mnemonic::Vscatterpf0dpd;
        case ZYDIS_MNEMONIC_VSCATTERPF0DPS:
            return Mnemonic::Vscatterpf0dps;
        case ZYDIS_MNEMONIC_VSCATTERPF0HINTDPD:
            return Mnemonic::Vscatterpf0hintdpd;
        case ZYDIS_MNEMONIC_VSCATTERPF0HINTDPS:
            return Mnemonic::Vscatterpf0hintdps;
        case ZYDIS_MNEMONIC_VSCATTERPF0QPD:
            return Mnemonic::Vscatterpf0qpd;
        case ZYDIS_MNEMONIC_VSCATTERPF0QPS:
            return Mnemonic::Vscatterpf0qps;
        case ZYDIS_MNEMONIC_VSCATTERPF1DPD:
            return Mnemonic::Vscatterpf1dpd;
        case ZYDIS_MNEMONIC_VSCATTERPF1DPS:
            return Mnemonic::Vscatterpf1dps;
        case ZYDIS_MNEMONIC_VSCATTERPF1QPD:
            return Mnemonic::Vscatterpf1qpd;
        case ZYDIS_MNEMONIC_VSCATTERPF1QPS:
            return Mnemonic::Vscatterpf1qps;
        case ZYDIS_MNEMONIC_VSCATTERQPD:
            return Mnemonic::Vscatterqpd;
        case ZYDIS_MNEMONIC_VSCATTERQPS:
            return Mnemonic::Vscatterqps;
        case ZYDIS_MNEMONIC_VSHUFF32X4:
            return Mnemonic::Vshuff32x4;
        case ZYDIS_MNEMONIC_VSHUFF64X2:
            return Mnemonic::Vshuff64x2;
        case ZYDIS_MNEMONIC_VSHUFI32X4:
            return Mnemonic::Vshufi32x4;
        case ZYDIS_MNEMONIC_VSHUFI64X2:
            return Mnemonic::Vshufi64x2;
        case ZYDIS_MNEMONIC_VSHUFPD:
            return Mnemonic::Vshufpd;
        case ZYDIS_MNEMONIC_VSHUFPS:
            return Mnemonic::Vshufps;
        case ZYDIS_MNEMONIC_VSQRTPD:
            return Mnemonic::Vsqrtpd;
        case ZYDIS_MNEMONIC_VSQRTPH:
            return Mnemonic::Vsqrtph;
        case ZYDIS_MNEMONIC_VSQRTPS:
            return Mnemonic::Vsqrtps;
        case ZYDIS_MNEMONIC_VSQRTSD:
            return Mnemonic::Vsqrtsd;
        case ZYDIS_MNEMONIC_VSQRTSH:
            return Mnemonic::Vsqrtsh;
        case ZYDIS_MNEMONIC_VSQRTSS:
            return Mnemonic::Vsqrtss;
        case ZYDIS_MNEMONIC_VSTMXCSR:
            return Mnemonic::Vstmxcsr;
        case ZYDIS_MNEMONIC_VSUBPD:
            return Mnemonic::Vsubpd;
        case ZYDIS_MNEMONIC_VSUBPH:
            return Mnemonic::Vsubph;
        case ZYDIS_MNEMONIC_VSUBPS:
            return Mnemonic::Vsubps;
        case ZYDIS_MNEMONIC_VSUBRPD:
            return Mnemonic::Vsubrpd;
        case ZYDIS_MNEMONIC_VSUBRPS:
            return Mnemonic::Vsubrps;
        case ZYDIS_MNEMONIC_VSUBSD:
            return Mnemonic::Vsubsd;
        case ZYDIS_MNEMONIC_VSUBSH:
            return Mnemonic::Vsubsh;
        case ZYDIS_MNEMONIC_VSUBSS:
            return Mnemonic::Vsubss;
        case ZYDIS_MNEMONIC_VTESTPD:
            return Mnemonic::Vtestpd;
        case ZYDIS_MNEMONIC_VTESTPS:
            return Mnemonic::Vtestps;
        case ZYDIS_MNEMONIC_VUCOMISD:
            return Mnemonic::Vucomisd;
        case ZYDIS_MNEMONIC_VUCOMISH:
            return Mnemonic::Vucomish;
        case ZYDIS_MNEMONIC_VUCOMISS:
            return Mnemonic::Vucomiss;
        case ZYDIS_MNEMONIC_VUNPCKHPD:
            return Mnemonic::Vunpckhpd;
        case ZYDIS_MNEMONIC_VUNPCKHPS:
            return Mnemonic::Vunpckhps;
        case ZYDIS_MNEMONIC_VUNPCKLPD:
            return Mnemonic::Vunpcklpd;
        case ZYDIS_MNEMONIC_VUNPCKLPS:
            return Mnemonic::Vunpcklps;
        case ZYDIS_MNEMONIC_VXORPD:
            return Mnemonic::Vxorpd;
        case ZYDIS_MNEMONIC_VXORPS:
            return Mnemonic::Vxorps;
        case ZYDIS_MNEMONIC_VZEROALL:
            return Mnemonic::Vzeroall;
        case ZYDIS_MNEMONIC_VZEROUPPER:
            return Mnemonic::Vzeroupper;
        case ZYDIS_MNEMONIC_WBINVD:
            return Mnemonic::Wbinvd;
        case ZYDIS_MNEMONIC_WRFSBASE:
            return Mnemonic::Wrfsbase;
        case ZYDIS_MNEMONIC_WRGSBASE:
            return Mnemonic::Wrgsbase;
        case ZYDIS_MNEMONIC_WRMSR:
            return Mnemonic::Wrmsr;
        case ZYDIS_MNEMONIC_WRPKRU:
            return Mnemonic::Wrpkru;
        case ZYDIS_MNEMONIC_WRSSD:
            return Mnemonic::Wrssd;
        case ZYDIS_MNEMONIC_WRSSQ:
            return Mnemonic::Wrssq;
        case ZYDIS_MNEMONIC_WRUSSD:
            return Mnemonic::Wrussd;
        case ZYDIS_MNEMONIC_WRUSSQ:
            return Mnemonic::Wrussq;
        case ZYDIS_MNEMONIC_XABORT:
            return Mnemonic::Xabort;
        case ZYDIS_MNEMONIC_XADD:
            return Mnemonic::Xadd;
        case ZYDIS_MNEMONIC_XBEGIN:
            return Mnemonic::Xbegin;
        case ZYDIS_MNEMONIC_XCHG:
            return Mnemonic::Xchg;
        case ZYDIS_MNEMONIC_XCRYPT_CBC:
            return Mnemonic::Xcrypt_cbc;
        case ZYDIS_MNEMONIC_XCRYPT_CFB:
            return Mnemonic::Xcrypt_cfb;
        case ZYDIS_MNEMONIC_XCRYPT_CTR:
            return Mnemonic::Xcrypt_ctr;
        case ZYDIS_MNEMONIC_XCRYPT_ECB:
            return Mnemonic::Xcrypt_ecb;
        case ZYDIS_MNEMONIC_XCRYPT_OFB:
            return Mnemonic::Xcrypt_ofb;
        case ZYDIS_MNEMONIC_XEND:
            return Mnemonic::Xend;
        case ZYDIS_MNEMONIC_XGETBV:
            return Mnemonic::Xgetbv;
        case ZYDIS_MNEMONIC_XLAT:
            return Mnemonic::Xlat;
        case ZYDIS_MNEMONIC_XOR:
            return Mnemonic::Xor;
        case ZYDIS_MNEMONIC_XORPD:
            return Mnemonic::Xorpd;
        case ZYDIS_MNEMONIC_XORPS:
            return Mnemonic::Xorps;
        case ZYDIS_MNEMONIC_XRESLDTRK:
            return Mnemonic::Xresldtrk;
        case ZYDIS_MNEMONIC_XRSTOR:
            return Mnemonic::Xrstor;
        case ZYDIS_MNEMONIC_XRSTOR64:
            return Mnemonic::Xrstor64;
        case ZYDIS_MNEMONIC_XRSTORS:
            return Mnemonic::Xrstors;
        case ZYDIS_MNEMONIC_XRSTORS64:
            return Mnemonic::Xrstors64;
        case ZYDIS_MNEMONIC_XSAVE:
            return Mnemonic::Xsave;
        case ZYDIS_MNEMONIC_XSAVE64:
            return Mnemonic::Xsave64;
        case ZYDIS_MNEMONIC_XSAVEC:
            return Mnemonic::Xsavec;
        case ZYDIS_MNEMONIC_XSAVEC64:
            return Mnemonic::Xsavec64;
        case ZYDIS_MNEMONIC_XSAVEOPT:
            return Mnemonic::Xsaveopt;
        case ZYDIS_MNEMONIC_XSAVEOPT64:
            return Mnemonic::Xsaveopt64;
        case ZYDIS_MNEMONIC_XSAVES:
            return Mnemonic::Xsaves;
        case ZYDIS_MNEMONIC_XSAVES64:
            return Mnemonic::Xsaves64;
        case ZYDIS_MNEMONIC_XSETBV:
            return Mnemonic::Xsetbv;
        case ZYDIS_MNEMONIC_XSHA1:
            return Mnemonic::Xsha1;
        case ZYDIS_MNEMONIC_XSHA256:
            return Mnemonic::Xsha256;
        case ZYDIS_MNEMONIC_XSTORE:
            return Mnemonic::Xstore;
        case ZYDIS_MNEMONIC_XSUSLDTRK:
            return Mnemonic::Xsusldtrk;
        case ZYDIS_MNEMONIC_XTEST:
            return Mnemonic::Xtest;
        }
        return Mnemonic::Invalid;
    }

} // namespace Dotx64Dbg

```

`src/Bindings/Encoder.Converter.hpp`:

```hpp
#pragma once

#include "Instruction.hpp"

#include <asmjit/asmjit.h>
#include <optional>

namespace Dotx64Dbg
{

    inline uint32_t convertAsmJitMnemonic(Mnemonic mnemonic)
    {
        switch (mnemonic)
        {
        case Mnemonic::Movsd:
            return asmjit::x86::Inst::kIdMovsd;
        case Mnemonic::Aaa:
            return asmjit::x86::Inst::kIdAaa;
        case Mnemonic::Aad:
            return asmjit::x86::Inst::kIdAad;
        case Mnemonic::Aam:
            return asmjit::x86::Inst::kIdAam;
        case Mnemonic::Aas:
            return asmjit::x86::Inst::kIdAas;
        case Mnemonic::Adc:
            return asmjit::x86::Inst::kIdAdc;
        case Mnemonic::Adcx:
            return asmjit::x86::Inst::kIdAdcx;
        case Mnemonic::Add:
            return asmjit::x86::Inst::kIdAdd;
        case Mnemonic::Addpd:
            return asmjit::x86::Inst::kIdAddpd;
        case Mnemonic::Addps:
            return asmjit::x86::Inst::kIdAddps;
        case Mnemonic::Addsd:
            return asmjit::x86::Inst::kIdAddsd;
        case Mnemonic::Addss:
            return asmjit::x86::Inst::kIdAddss;
        case Mnemonic::Addsubpd:
            return asmjit::x86::Inst::kIdAddsubpd;
        case Mnemonic::Addsubps:
            return asmjit::x86::Inst::kIdAddsubps;
        case Mnemonic::Adox:
            return asmjit::x86::Inst::kIdAdox;
        case Mnemonic::Aesdec:
            return asmjit::x86::Inst::kIdAesdec;
        case Mnemonic::Aesdeclast:
            return asmjit::x86::Inst::kIdAesdeclast;
        case Mnemonic::Aesenc:
            return asmjit::x86::Inst::kIdAesenc;
        case Mnemonic::Aesenclast:
            return asmjit::x86::Inst::kIdAesenclast;
        case Mnemonic::Aesimc:
            return asmjit::x86::Inst::kIdAesimc;
        case Mnemonic::Aeskeygenassist:
            return asmjit::x86::Inst::kIdAeskeygenassist;
        case Mnemonic::And:
            return asmjit::x86::Inst::kIdAnd;
        case Mnemonic::Andn:
            return asmjit::x86::Inst::kIdAndn;
        case Mnemonic::Andnpd:
            return asmjit::x86::Inst::kIdAndnpd;
        case Mnemonic::Andnps:
            return asmjit::x86::Inst::kIdAndnps;
        case Mnemonic::Andpd:
            return asmjit::x86::Inst::kIdAndpd;
        case Mnemonic::Andps:
            return asmjit::x86::Inst::kIdAndps;
        case Mnemonic::Arpl:
            return asmjit::x86::Inst::kIdArpl;
        case Mnemonic::Bextr:
            return asmjit::x86::Inst::kIdBextr;
        case Mnemonic::Blcfill:
            return asmjit::x86::Inst::kIdBlcfill;
        case Mnemonic::Blci:
            return asmjit::x86::Inst::kIdBlci;
        case Mnemonic::Blcic:
            return asmjit::x86::Inst::kIdBlcic;
        case Mnemonic::Blcmsk:
            return asmjit::x86::Inst::kIdBlcmsk;
        case Mnemonic::Blcs:
            return asmjit::x86::Inst::kIdBlcs;
        case Mnemonic::Blendpd:
            return asmjit::x86::Inst::kIdBlendpd;
        case Mnemonic::Blendps:
            return asmjit::x86::Inst::kIdBlendps;
        case Mnemonic::Blendvpd:
            return asmjit::x86::Inst::kIdBlendvpd;
        case Mnemonic::Blendvps:
            return asmjit::x86::Inst::kIdBlendvps;
        case Mnemonic::Blsfill:
            return asmjit::x86::Inst::kIdBlsfill;
        case Mnemonic::Blsi:
            return asmjit::x86::Inst::kIdBlsi;
        case Mnemonic::Blsic:
            return asmjit::x86::Inst::kIdBlsic;
        case Mnemonic::Blsmsk:
            return asmjit::x86::Inst::kIdBlsmsk;
        case Mnemonic::Blsr:
            return asmjit::x86::Inst::kIdBlsr;
        case Mnemonic::Bndcl:
            return asmjit::x86::Inst::kIdBndcl;
        case Mnemonic::Bndcn:
            return asmjit::x86::Inst::kIdBndcn;
        case Mnemonic::Bndcu:
            return asmjit::x86::Inst::kIdBndcu;
        case Mnemonic::Bndldx:
            return asmjit::x86::Inst::kIdBndldx;
        case Mnemonic::Bndmk:
            return asmjit::x86::Inst::kIdBndmk;
        case Mnemonic::Bndmov:
            return asmjit::x86::Inst::kIdBndmov;
        case Mnemonic::Bndstx:
            return asmjit::x86::Inst::kIdBndstx;
        case Mnemonic::Bound:
            return asmjit::x86::Inst::kIdBound;
        case Mnemonic::Bsf:
            return asmjit::x86::Inst::kIdBsf;
        case Mnemonic::Bsr:
            return asmjit::x86::Inst::kIdBsr;
        case Mnemonic::Bswap:
            return asmjit::x86::Inst::kIdBswap;
        case Mnemonic::Bt:
            return asmjit::x86::Inst::kIdBt;
        case Mnemonic::Btc:
            return asmjit::x86::Inst::kIdBtc;
        case Mnemonic::Btr:
            return asmjit::x86::Inst::kIdBtr;
        case Mnemonic::Bts:
            return asmjit::x86::Inst::kIdBts;
        case Mnemonic::Bzhi:
            return asmjit::x86::Inst::kIdBzhi;
        case Mnemonic::Call:
            return asmjit::x86::Inst::kIdCall;
        case Mnemonic::Cbw:
            return asmjit::x86::Inst::kIdCbw;
        case Mnemonic::Cdq:
            return asmjit::x86::Inst::kIdCdq;
        case Mnemonic::Cdqe:
            return asmjit::x86::Inst::kIdCdqe;
        case Mnemonic::Clac:
            return asmjit::x86::Inst::kIdClac;
        case Mnemonic::Clc:
            return asmjit::x86::Inst::kIdClc;
        case Mnemonic::Cld:
            return asmjit::x86::Inst::kIdCld;
        case Mnemonic::Clflush:
            return asmjit::x86::Inst::kIdClflush;
        case Mnemonic::Clflushopt:
            return asmjit::x86::Inst::kIdClflushopt;
        case Mnemonic::Cli:
            return asmjit::x86::Inst::kIdCli;
        case Mnemonic::Clts:
            return asmjit::x86::Inst::kIdClts;
        case Mnemonic::Clwb:
            return asmjit::x86::Inst::kIdClwb;
        case Mnemonic::Clzero:
            return asmjit::x86::Inst::kIdClzero;
        case Mnemonic::Cmc:
            return asmjit::x86::Inst::kIdCmc;
        case Mnemonic::Cmovb:
            return asmjit::x86::Inst::kIdCmovb;
        case Mnemonic::Cmovbe:
            return asmjit::x86::Inst::kIdCmovbe;
        case Mnemonic::Cmovl:
            return asmjit::x86::Inst::kIdCmovl;
        case Mnemonic::Cmovle:
            return asmjit::x86::Inst::kIdCmovle;
        case Mnemonic::Cmovnb:
            return asmjit::x86::Inst::kIdCmovnb;
        case Mnemonic::Cmovnbe:
            return asmjit::x86::Inst::kIdCmovnbe;
        case Mnemonic::Cmovnl:
            return asmjit::x86::Inst::kIdCmovnl;
        case Mnemonic::Cmovnle:
            return asmjit::x86::Inst::kIdCmovnle;
        case Mnemonic::Cmovno:
            return asmjit::x86::Inst::kIdCmovno;
        case Mnemonic::Cmovnp:
            return asmjit::x86::Inst::kIdCmovnp;
        case Mnemonic::Cmovns:
            return asmjit::x86::Inst::kIdCmovns;
        case Mnemonic::Cmovnz:
            return asmjit::x86::Inst::kIdCmovnz;
        case Mnemonic::Cmovo:
            return asmjit::x86::Inst::kIdCmovo;
        case Mnemonic::Cmovp:
            return asmjit::x86::Inst::kIdCmovp;
        case Mnemonic::Cmovs:
            return asmjit::x86::Inst::kIdCmovs;
        case Mnemonic::Cmovz:
            return asmjit::x86::Inst::kIdCmovz;
        case Mnemonic::Cmp:
            return asmjit::x86::Inst::kIdCmp;
        case Mnemonic::Cmppd:
            return asmjit::x86::Inst::kIdCmppd;
        case Mnemonic::Cmpps:
            return asmjit::x86::Inst::kIdCmpps;
        case Mnemonic::Cmpsd:
            return asmjit::x86::Inst::kIdCmpsd;
        case Mnemonic::Cmpss:
            return asmjit::x86::Inst::kIdCmpss;
        case Mnemonic::Cmpxchg:
            return asmjit::x86::Inst::kIdCmpxchg;
        case Mnemonic::Cmpxchg16b:
            return asmjit::x86::Inst::kIdCmpxchg16b;
        case Mnemonic::Cmpxchg8b:
            return asmjit::x86::Inst::kIdCmpxchg8b;
        case Mnemonic::Comisd:
            return asmjit::x86::Inst::kIdComisd;
        case Mnemonic::Comiss:
            return asmjit::x86::Inst::kIdComiss;
        case Mnemonic::Cpuid:
            return asmjit::x86::Inst::kIdCpuid;
        case Mnemonic::Cqo:
            return asmjit::x86::Inst::kIdCqo;
        case Mnemonic::Crc32:
            return asmjit::x86::Inst::kIdCrc32;
        case Mnemonic::Cvtdq2pd:
            return asmjit::x86::Inst::kIdCvtdq2pd;
        case Mnemonic::Cvtdq2ps:
            return asmjit::x86::Inst::kIdCvtdq2ps;
        case Mnemonic::Cvtpd2dq:
            return asmjit::x86::Inst::kIdCvtpd2dq;
        case Mnemonic::Cvtpd2pi:
            return asmjit::x86::Inst::kIdCvtpd2pi;
        case Mnemonic::Cvtpd2ps:
            return asmjit::x86::Inst::kIdCvtpd2ps;
        case Mnemonic::Cvtpi2pd:
            return asmjit::x86::Inst::kIdCvtpi2pd;
        case Mnemonic::Cvtpi2ps:
            return asmjit::x86::Inst::kIdCvtpi2ps;
        case Mnemonic::Cvtps2dq:
            return asmjit::x86::Inst::kIdCvtps2dq;
        case Mnemonic::Cvtps2pd:
            return asmjit::x86::Inst::kIdCvtps2pd;
        case Mnemonic::Cvtps2pi:
            return asmjit::x86::Inst::kIdCvtps2pi;
        case Mnemonic::Cvtsd2si:
            return asmjit::x86::Inst::kIdCvtsd2si;
        case Mnemonic::Cvtsd2ss:
            return asmjit::x86::Inst::kIdCvtsd2ss;
        case Mnemonic::Cvtsi2sd:
            return asmjit::x86::Inst::kIdCvtsi2sd;
        case Mnemonic::Cvtsi2ss:
            return asmjit::x86::Inst::kIdCvtsi2ss;
        case Mnemonic::Cvtss2sd:
            return asmjit::x86::Inst::kIdCvtss2sd;
        case Mnemonic::Cvtss2si:
            return asmjit::x86::Inst::kIdCvtss2si;
        case Mnemonic::Cvttpd2dq:
            return asmjit::x86::Inst::kIdCvttpd2dq;
        case Mnemonic::Cvttpd2pi:
            return asmjit::x86::Inst::kIdCvttpd2pi;
        case Mnemonic::Cvttps2dq:
            return asmjit::x86::Inst::kIdCvttps2dq;
        case Mnemonic::Cvttps2pi:
            return asmjit::x86::Inst::kIdCvttps2pi;
        case Mnemonic::Cvttsd2si:
            return asmjit::x86::Inst::kIdCvttsd2si;
        case Mnemonic::Cvttss2si:
            return asmjit::x86::Inst::kIdCvttss2si;
        case Mnemonic::Cwd:
            return asmjit::x86::Inst::kIdCwd;
        case Mnemonic::Cwde:
            return asmjit::x86::Inst::kIdCwde;
        case Mnemonic::Daa:
            return asmjit::x86::Inst::kIdDaa;
        case Mnemonic::Das:
            return asmjit::x86::Inst::kIdDas;
        case Mnemonic::Dec:
            return asmjit::x86::Inst::kIdDec;
        case Mnemonic::Div:
            return asmjit::x86::Inst::kIdDiv;
        case Mnemonic::Divpd:
            return asmjit::x86::Inst::kIdDivpd;
        case Mnemonic::Divps:
            return asmjit::x86::Inst::kIdDivps;
        case Mnemonic::Divsd:
            return asmjit::x86::Inst::kIdDivsd;
        case Mnemonic::Divss:
            return asmjit::x86::Inst::kIdDivss;
        case Mnemonic::Dppd:
            return asmjit::x86::Inst::kIdDppd;
        case Mnemonic::Dpps:
            return asmjit::x86::Inst::kIdDpps;
        case Mnemonic::Emms:
            return asmjit::x86::Inst::kIdEmms;
        case Mnemonic::Enter:
            return asmjit::x86::Inst::kIdEnter;
        case Mnemonic::Extractps:
            return asmjit::x86::Inst::kIdExtractps;
        case Mnemonic::Extrq:
            return asmjit::x86::Inst::kIdExtrq;
        case Mnemonic::F2xm1:
            return asmjit::x86::Inst::kIdF2xm1;
        case Mnemonic::Fabs:
            return asmjit::x86::Inst::kIdFabs;
        case Mnemonic::Fadd:
            return asmjit::x86::Inst::kIdFadd;
        case Mnemonic::Faddp:
            return asmjit::x86::Inst::kIdFaddp;
        case Mnemonic::Fbld:
            return asmjit::x86::Inst::kIdFbld;
        case Mnemonic::Fbstp:
            return asmjit::x86::Inst::kIdFbstp;
        case Mnemonic::Fchs:
            return asmjit::x86::Inst::kIdFchs;
        case Mnemonic::Fcmovb:
            return asmjit::x86::Inst::kIdFcmovb;
        case Mnemonic::Fcmovbe:
            return asmjit::x86::Inst::kIdFcmovbe;
        case Mnemonic::Fcmove:
            return asmjit::x86::Inst::kIdFcmove;
        case Mnemonic::Fcmovnb:
            return asmjit::x86::Inst::kIdFcmovnb;
        case Mnemonic::Fcmovnbe:
            return asmjit::x86::Inst::kIdFcmovnbe;
        case Mnemonic::Fcmovne:
            return asmjit::x86::Inst::kIdFcmovne;
        case Mnemonic::Fcmovnu:
            return asmjit::x86::Inst::kIdFcmovnu;
        case Mnemonic::Fcmovu:
            return asmjit::x86::Inst::kIdFcmovu;
        case Mnemonic::Fcom:
            return asmjit::x86::Inst::kIdFcom;
        case Mnemonic::Fcomi:
            return asmjit::x86::Inst::kIdFcomi;
        case Mnemonic::Fcomip:
            return asmjit::x86::Inst::kIdFcomip;
        case Mnemonic::Fcomp:
            return asmjit::x86::Inst::kIdFcomp;
        case Mnemonic::Fcompp:
            return asmjit::x86::Inst::kIdFcompp;
        case Mnemonic::Fcos:
            return asmjit::x86::Inst::kIdFcos;
        case Mnemonic::Fdecstp:
            return asmjit::x86::Inst::kIdFdecstp;
        case Mnemonic::Fdiv:
            return asmjit::x86::Inst::kIdFdiv;
        case Mnemonic::Fdivp:
            return asmjit::x86::Inst::kIdFdivp;
        case Mnemonic::Fdivr:
            return asmjit::x86::Inst::kIdFdivr;
        case Mnemonic::Fdivrp:
            return asmjit::x86::Inst::kIdFdivrp;
        case Mnemonic::Femms:
            return asmjit::x86::Inst::kIdFemms;
        case Mnemonic::Ffree:
            return asmjit::x86::Inst::kIdFfree;
        case Mnemonic::Fiadd:
            return asmjit::x86::Inst::kIdFiadd;
        case Mnemonic::Ficom:
            return asmjit::x86::Inst::kIdFicom;
        case Mnemonic::Ficomp:
            return asmjit::x86::Inst::kIdFicomp;
        case Mnemonic::Fidiv:
            return asmjit::x86::Inst::kIdFidiv;
        case Mnemonic::Fidivr:
            return asmjit::x86::Inst::kIdFidivr;
        case Mnemonic::Fild:
            return asmjit::x86::Inst::kIdFild;
        case Mnemonic::Fimul:
            return asmjit::x86::Inst::kIdFimul;
        case Mnemonic::Fincstp:
            return asmjit::x86::Inst::kIdFincstp;
        case Mnemonic::Fist:
            return asmjit::x86::Inst::kIdFist;
        case Mnemonic::Fistp:
            return asmjit::x86::Inst::kIdFistp;
        case Mnemonic::Fisttp:
            return asmjit::x86::Inst::kIdFisttp;
        case Mnemonic::Fisub:
            return asmjit::x86::Inst::kIdFisub;
        case Mnemonic::Fisubr:
            return asmjit::x86::Inst::kIdFisubr;
        case Mnemonic::Fld:
            return asmjit::x86::Inst::kIdFld;
        case Mnemonic::Fld1:
            return asmjit::x86::Inst::kIdFld1;
        case Mnemonic::Fldcw:
            return asmjit::x86::Inst::kIdFldcw;
        case Mnemonic::Fldenv:
            return asmjit::x86::Inst::kIdFldenv;
        case Mnemonic::Fldl2e:
            return asmjit::x86::Inst::kIdFldl2e;
        case Mnemonic::Fldl2t:
            return asmjit::x86::Inst::kIdFldl2t;
        case Mnemonic::Fldlg2:
            return asmjit::x86::Inst::kIdFldlg2;
        case Mnemonic::Fldln2:
            return asmjit::x86::Inst::kIdFldln2;
        case Mnemonic::Fldpi:
            return asmjit::x86::Inst::kIdFldpi;
        case Mnemonic::Fldz:
            return asmjit::x86::Inst::kIdFldz;
        case Mnemonic::Fmul:
            return asmjit::x86::Inst::kIdFmul;
        case Mnemonic::Fmulp:
            return asmjit::x86::Inst::kIdFmulp;
        case Mnemonic::Fnclex:
            return asmjit::x86::Inst::kIdFnclex;
        case Mnemonic::Fninit:
            return asmjit::x86::Inst::kIdFninit;
        case Mnemonic::Fnop:
            return asmjit::x86::Inst::kIdFnop;
        case Mnemonic::Fnsave:
            return asmjit::x86::Inst::kIdFnsave;
        case Mnemonic::Fnstcw:
            return asmjit::x86::Inst::kIdFnstcw;
        case Mnemonic::Fnstenv:
            return asmjit::x86::Inst::kIdFnstenv;
        case Mnemonic::Fnstsw:
            return asmjit::x86::Inst::kIdFnstsw;
        case Mnemonic::Fpatan:
            return asmjit::x86::Inst::kIdFpatan;
        case Mnemonic::Fprem:
            return asmjit::x86::Inst::kIdFprem;
        case Mnemonic::Fprem1:
            return asmjit::x86::Inst::kIdFprem1;
        case Mnemonic::Fptan:
            return asmjit::x86::Inst::kIdFptan;
        case Mnemonic::Frndint:
            return asmjit::x86::Inst::kIdFrndint;
        case Mnemonic::Frstor:
            return asmjit::x86::Inst::kIdFrstor;
        case Mnemonic::Fscale:
            return asmjit::x86::Inst::kIdFscale;
        case Mnemonic::Fsin:
            return asmjit::x86::Inst::kIdFsin;
        case Mnemonic::Fsincos:
            return asmjit::x86::Inst::kIdFsincos;
        case Mnemonic::Fsqrt:
            return asmjit::x86::Inst::kIdFsqrt;
        case Mnemonic::Fst:
            return asmjit::x86::Inst::kIdFst;
        case Mnemonic::Fstp:
            return asmjit::x86::Inst::kIdFstp;
        case Mnemonic::Fsub:
            return asmjit::x86::Inst::kIdFsub;
        case Mnemonic::Fsubp:
            return asmjit::x86::Inst::kIdFsubp;
        case Mnemonic::Fsubr:
            return asmjit::x86::Inst::kIdFsubr;
        case Mnemonic::Fsubrp:
            return asmjit::x86::Inst::kIdFsubrp;
        case Mnemonic::Ftst:
            return asmjit::x86::Inst::kIdFtst;
        case Mnemonic::Fucom:
            return asmjit::x86::Inst::kIdFucom;
        case Mnemonic::Fucomi:
            return asmjit::x86::Inst::kIdFucomi;
        case Mnemonic::Fucomip:
            return asmjit::x86::Inst::kIdFucomip;
        case Mnemonic::Fucomp:
            return asmjit::x86::Inst::kIdFucomp;
        case Mnemonic::Fucompp:
            return asmjit::x86::Inst::kIdFucompp;
        case Mnemonic::Fwait:
            return asmjit::x86::Inst::kIdFwait;
        case Mnemonic::Fxam:
            return asmjit::x86::Inst::kIdFxam;
        case Mnemonic::Fxch:
            return asmjit::x86::Inst::kIdFxch;
        case Mnemonic::Fxrstor:
            return asmjit::x86::Inst::kIdFxrstor;
        case Mnemonic::Fxrstor64:
            return asmjit::x86::Inst::kIdFxrstor64;
        case Mnemonic::Fxsave:
            return asmjit::x86::Inst::kIdFxsave;
        case Mnemonic::Fxsave64:
            return asmjit::x86::Inst::kIdFxsave64;
        case Mnemonic::Fxtract:
            return asmjit::x86::Inst::kIdFxtract;
        case Mnemonic::Fyl2x:
            return asmjit::x86::Inst::kIdFyl2x;
        case Mnemonic::Fyl2xp1:
            return asmjit::x86::Inst::kIdFyl2xp1;
        case Mnemonic::Haddpd:
            return asmjit::x86::Inst::kIdHaddpd;
        case Mnemonic::Haddps:
            return asmjit::x86::Inst::kIdHaddps;
        case Mnemonic::Hlt:
            return asmjit::x86::Inst::kIdHlt;
        case Mnemonic::Hsubpd:
            return asmjit::x86::Inst::kIdHsubpd;
        case Mnemonic::Hsubps:
            return asmjit::x86::Inst::kIdHsubps;
        case Mnemonic::Idiv:
            return asmjit::x86::Inst::kIdIdiv;
        case Mnemonic::Imul:
            return asmjit::x86::Inst::kIdImul;
        case Mnemonic::In:
            return asmjit::x86::Inst::kIdIn;
        case Mnemonic::Inc:
            return asmjit::x86::Inst::kIdInc;
        case Mnemonic::Insertps:
            return asmjit::x86::Inst::kIdInsertps;
        case Mnemonic::Insertq:
            return asmjit::x86::Inst::kIdInsertq;
        case Mnemonic::Int:
            return asmjit::x86::Inst::kIdInt;
        case Mnemonic::Int3:
            return asmjit::x86::Inst::kIdInt3;
        case Mnemonic::Into:
            return asmjit::x86::Inst::kIdInto;
        case Mnemonic::Invd:
            return asmjit::x86::Inst::kIdInvd;
        case Mnemonic::Invlpg:
            return asmjit::x86::Inst::kIdInvlpg;
        case Mnemonic::Invpcid:
            return asmjit::x86::Inst::kIdInvpcid;
        case Mnemonic::Iret:
            return asmjit::x86::Inst::kIdIret;
        case Mnemonic::Iretd:
            return asmjit::x86::Inst::kIdIretd;
        case Mnemonic::Iretq:
            return asmjit::x86::Inst::kIdIretq;
        case Mnemonic::Jb:
            return asmjit::x86::Inst::kIdJb;
        case Mnemonic::Jbe:
            return asmjit::x86::Inst::kIdJbe;
        case Mnemonic::Jecxz:
            return asmjit::x86::Inst::kIdJecxz;
        case Mnemonic::Jl:
            return asmjit::x86::Inst::kIdJl;
        case Mnemonic::Jle:
            return asmjit::x86::Inst::kIdJle;
        case Mnemonic::Jmp:
            return asmjit::x86::Inst::kIdJmp;
        case Mnemonic::Jnb:
            return asmjit::x86::Inst::kIdJnb;
        case Mnemonic::Jnbe:
            return asmjit::x86::Inst::kIdJnbe;
        case Mnemonic::Jnl:
            return asmjit::x86::Inst::kIdJnl;
        case Mnemonic::Jnle:
            return asmjit::x86::Inst::kIdJnle;
        case Mnemonic::Jno:
            return asmjit::x86::Inst::kIdJno;
        case Mnemonic::Jnp:
            return asmjit::x86::Inst::kIdJnp;
        case Mnemonic::Jns:
            return asmjit::x86::Inst::kIdJns;
        case Mnemonic::Jnz:
            return asmjit::x86::Inst::kIdJnz;
        case Mnemonic::Jo:
            return asmjit::x86::Inst::kIdJo;
        case Mnemonic::Jp:
            return asmjit::x86::Inst::kIdJp;
        case Mnemonic::Js:
            return asmjit::x86::Inst::kIdJs;
        case Mnemonic::Jz:
            return asmjit::x86::Inst::kIdJz;
        case Mnemonic::Kaddb:
            return asmjit::x86::Inst::kIdKaddb;
        case Mnemonic::Kaddd:
            return asmjit::x86::Inst::kIdKaddd;
        case Mnemonic::Kaddq:
            return asmjit::x86::Inst::kIdKaddq;
        case Mnemonic::Kaddw:
            return asmjit::x86::Inst::kIdKaddw;
        case Mnemonic::Kandb:
            return asmjit::x86::Inst::kIdKandb;
        case Mnemonic::Kandd:
            return asmjit::x86::Inst::kIdKandd;
        case Mnemonic::Kandnb:
            return asmjit::x86::Inst::kIdKandnb;
        case Mnemonic::Kandnd:
            return asmjit::x86::Inst::kIdKandnd;
        case Mnemonic::Kandnq:
            return asmjit::x86::Inst::kIdKandnq;
        case Mnemonic::Kandnw:
            return asmjit::x86::Inst::kIdKandnw;
        case Mnemonic::Kandq:
            return asmjit::x86::Inst::kIdKandq;
        case Mnemonic::Kandw:
            return asmjit::x86::Inst::kIdKandw;
        case Mnemonic::Kmovb:
            return asmjit::x86::Inst::kIdKmovb;
        case Mnemonic::Kmovd:
            return asmjit::x86::Inst::kIdKmovd;
        case Mnemonic::Kmovq:
            return asmjit::x86::Inst::kIdKmovq;
        case Mnemonic::Kmovw:
            return asmjit::x86::Inst::kIdKmovw;
        case Mnemonic::Knotb:
            return asmjit::x86::Inst::kIdKnotb;
        case Mnemonic::Knotd:
            return asmjit::x86::Inst::kIdKnotd;
        case Mnemonic::Knotq:
            return asmjit::x86::Inst::kIdKnotq;
        case Mnemonic::Knotw:
            return asmjit::x86::Inst::kIdKnotw;
        case Mnemonic::Korb:
            return asmjit::x86::Inst::kIdKorb;
        case Mnemonic::Kord:
            return asmjit::x86::Inst::kIdKord;
        case Mnemonic::Korq:
            return asmjit::x86::Inst::kIdKorq;
        case Mnemonic::Kortestb:
            return asmjit::x86::Inst::kIdKortestb;
        case Mnemonic::Kortestd:
            return asmjit::x86::Inst::kIdKortestd;
        case Mnemonic::Kortestq:
            return asmjit::x86::Inst::kIdKortestq;
        case Mnemonic::Kortestw:
            return asmjit::x86::Inst::kIdKortestw;
        case Mnemonic::Korw:
            return asmjit::x86::Inst::kIdKorw;
        case Mnemonic::Kshiftlb:
            return asmjit::x86::Inst::kIdKshiftlb;
        case Mnemonic::Kshiftld:
            return asmjit::x86::Inst::kIdKshiftld;
        case Mnemonic::Kshiftlq:
            return asmjit::x86::Inst::kIdKshiftlq;
        case Mnemonic::Kshiftlw:
            return asmjit::x86::Inst::kIdKshiftlw;
        case Mnemonic::Kshiftrb:
            return asmjit::x86::Inst::kIdKshiftrb;
        case Mnemonic::Kshiftrd:
            return asmjit::x86::Inst::kIdKshiftrd;
        case Mnemonic::Kshiftrq:
            return asmjit::x86::Inst::kIdKshiftrq;
        case Mnemonic::Kshiftrw:
            return asmjit::x86::Inst::kIdKshiftrw;
        case Mnemonic::Ktestb:
            return asmjit::x86::Inst::kIdKtestb;
        case Mnemonic::Ktestd:
            return asmjit::x86::Inst::kIdKtestd;
        case Mnemonic::Ktestq:
            return asmjit::x86::Inst::kIdKtestq;
        case Mnemonic::Ktestw:
            return asmjit::x86::Inst::kIdKtestw;
        case Mnemonic::Kunpckbw:
            return asmjit::x86::Inst::kIdKunpckbw;
        case Mnemonic::Kunpckdq:
            return asmjit::x86::Inst::kIdKunpckdq;
        case Mnemonic::Kunpckwd:
            return asmjit::x86::Inst::kIdKunpckwd;
        case Mnemonic::Kxnorb:
            return asmjit::x86::Inst::kIdKxnorb;
        case Mnemonic::Kxnord:
            return asmjit::x86::Inst::kIdKxnord;
        case Mnemonic::Kxnorq:
            return asmjit::x86::Inst::kIdKxnorq;
        case Mnemonic::Kxnorw:
            return asmjit::x86::Inst::kIdKxnorw;
        case Mnemonic::Kxorb:
            return asmjit::x86::Inst::kIdKxorb;
        case Mnemonic::Kxord:
            return asmjit::x86::Inst::kIdKxord;
        case Mnemonic::Kxorq:
            return asmjit::x86::Inst::kIdKxorq;
        case Mnemonic::Kxorw:
            return asmjit::x86::Inst::kIdKxorw;
        case Mnemonic::Lahf:
            return asmjit::x86::Inst::kIdLahf;
        case Mnemonic::Lar:
            return asmjit::x86::Inst::kIdLar;
        case Mnemonic::Lddqu:
            return asmjit::x86::Inst::kIdLddqu;
        case Mnemonic::Ldmxcsr:
            return asmjit::x86::Inst::kIdLdmxcsr;
        case Mnemonic::Lds:
            return asmjit::x86::Inst::kIdLds;
        case Mnemonic::Lea:
            return asmjit::x86::Inst::kIdLea;
        case Mnemonic::Leave:
            return asmjit::x86::Inst::kIdLeave;
        case Mnemonic::Les:
            return asmjit::x86::Inst::kIdLes;
        case Mnemonic::Lfence:
            return asmjit::x86::Inst::kIdLfence;
        case Mnemonic::Lfs:
            return asmjit::x86::Inst::kIdLfs;
        case Mnemonic::Lgdt:
            return asmjit::x86::Inst::kIdLgdt;
        case Mnemonic::Lgs:
            return asmjit::x86::Inst::kIdLgs;
        case Mnemonic::Lidt:
            return asmjit::x86::Inst::kIdLidt;
        case Mnemonic::Lldt:
            return asmjit::x86::Inst::kIdLldt;
        case Mnemonic::Lmsw:
            return asmjit::x86::Inst::kIdLmsw;
        case Mnemonic::Loop:
            return asmjit::x86::Inst::kIdLoop;
        case Mnemonic::Loope:
            return asmjit::x86::Inst::kIdLoope;
        case Mnemonic::Loopne:
            return asmjit::x86::Inst::kIdLoopne;
        case Mnemonic::Lsl:
            return asmjit::x86::Inst::kIdLsl;
        case Mnemonic::Lss:
            return asmjit::x86::Inst::kIdLss;
        case Mnemonic::Ltr:
            return asmjit::x86::Inst::kIdLtr;
        case Mnemonic::Lzcnt:
            return asmjit::x86::Inst::kIdLzcnt;
        case Mnemonic::Maskmovdqu:
            return asmjit::x86::Inst::kIdMaskmovdqu;
        case Mnemonic::Maskmovq:
            return asmjit::x86::Inst::kIdMaskmovq;
        case Mnemonic::Maxpd:
            return asmjit::x86::Inst::kIdMaxpd;
        case Mnemonic::Maxps:
            return asmjit::x86::Inst::kIdMaxps;
        case Mnemonic::Maxsd:
            return asmjit::x86::Inst::kIdMaxsd;
        case Mnemonic::Maxss:
            return asmjit::x86::Inst::kIdMaxss;
        case Mnemonic::Mfence:
            return asmjit::x86::Inst::kIdMfence;
        case Mnemonic::Minpd:
            return asmjit::x86::Inst::kIdMinpd;
        case Mnemonic::Minps:
            return asmjit::x86::Inst::kIdMinps;
        case Mnemonic::Minsd:
            return asmjit::x86::Inst::kIdMinsd;
        case Mnemonic::Minss:
            return asmjit::x86::Inst::kIdMinss;
        case Mnemonic::Monitor:
            return asmjit::x86::Inst::kIdMonitor;
        case Mnemonic::Monitorx:
            return asmjit::x86::Inst::kIdMonitorx;
        case Mnemonic::Mov:
            return asmjit::x86::Inst::kIdMov;
        case Mnemonic::Movapd:
            return asmjit::x86::Inst::kIdMovapd;
        case Mnemonic::Movaps:
            return asmjit::x86::Inst::kIdMovaps;
        case Mnemonic::Movbe:
            return asmjit::x86::Inst::kIdMovbe;
        case Mnemonic::Movd:
            return asmjit::x86::Inst::kIdMovd;
        case Mnemonic::Movddup:
            return asmjit::x86::Inst::kIdMovddup;
        case Mnemonic::Movdq2q:
            return asmjit::x86::Inst::kIdMovdq2q;
        case Mnemonic::Movdqa:
            return asmjit::x86::Inst::kIdMovdqa;
        case Mnemonic::Movdqu:
            return asmjit::x86::Inst::kIdMovdqu;
        case Mnemonic::Movhlps:
            return asmjit::x86::Inst::kIdMovhlps;
        case Mnemonic::Movhpd:
            return asmjit::x86::Inst::kIdMovhpd;
        case Mnemonic::Movhps:
            return asmjit::x86::Inst::kIdMovhps;
        case Mnemonic::Movlhps:
            return asmjit::x86::Inst::kIdMovlhps;
        case Mnemonic::Movlpd:
            return asmjit::x86::Inst::kIdMovlpd;
        case Mnemonic::Movlps:
            return asmjit::x86::Inst::kIdMovlps;
        case Mnemonic::Movmskpd:
            return asmjit::x86::Inst::kIdMovmskpd;
        case Mnemonic::Movmskps:
            return asmjit::x86::Inst::kIdMovmskps;
        case Mnemonic::Movntdq:
            return asmjit::x86::Inst::kIdMovntdq;
        case Mnemonic::Movntdqa:
            return asmjit::x86::Inst::kIdMovntdqa;
        case Mnemonic::Movnti:
            return asmjit::x86::Inst::kIdMovnti;
        case Mnemonic::Movntpd:
            return asmjit::x86::Inst::kIdMovntpd;
        case Mnemonic::Movntps:
            return asmjit::x86::Inst::kIdMovntps;
        case Mnemonic::Movntq:
            return asmjit::x86::Inst::kIdMovntq;
        case Mnemonic::Movntsd:
            return asmjit::x86::Inst::kIdMovntsd;
        case Mnemonic::Movntss:
            return asmjit::x86::Inst::kIdMovntss;
        case Mnemonic::Movq:
            return asmjit::x86::Inst::kIdMovq;
        case Mnemonic::Movq2dq:
            return asmjit::x86::Inst::kIdMovq2dq;
        case Mnemonic::Movshdup:
            return asmjit::x86::Inst::kIdMovshdup;
        case Mnemonic::Movsldup:
            return asmjit::x86::Inst::kIdMovsldup;
        case Mnemonic::Movss:
            return asmjit::x86::Inst::kIdMovss;
        case Mnemonic::Movsx:
            return asmjit::x86::Inst::kIdMovsx;
        case Mnemonic::Movsxd:
            return asmjit::x86::Inst::kIdMovsxd;
        case Mnemonic::Movupd:
            return asmjit::x86::Inst::kIdMovupd;
        case Mnemonic::Movups:
            return asmjit::x86::Inst::kIdMovups;
        case Mnemonic::Movzx:
            return asmjit::x86::Inst::kIdMovzx;
        case Mnemonic::Mpsadbw:
            return asmjit::x86::Inst::kIdMpsadbw;
        case Mnemonic::Mul:
            return asmjit::x86::Inst::kIdMul;
        case Mnemonic::Mulpd:
            return asmjit::x86::Inst::kIdMulpd;
        case Mnemonic::Mulps:
            return asmjit::x86::Inst::kIdMulps;
        case Mnemonic::Mulsd:
            return asmjit::x86::Inst::kIdMulsd;
        case Mnemonic::Mulss:
            return asmjit::x86::Inst::kIdMulss;
        case Mnemonic::Mulx:
            return asmjit::x86::Inst::kIdMulx;
        case Mnemonic::Mwait:
            return asmjit::x86::Inst::kIdMwait;
        case Mnemonic::Mwaitx:
            return asmjit::x86::Inst::kIdMwaitx;
        case Mnemonic::Neg:
            return asmjit::x86::Inst::kIdNeg;
        case Mnemonic::Nop:
            return asmjit::x86::Inst::kIdNop;
        case Mnemonic::Not:
            return asmjit::x86::Inst::kIdNot;
        case Mnemonic::Or:
            return asmjit::x86::Inst::kIdOr;
        case Mnemonic::Orpd:
            return asmjit::x86::Inst::kIdOrpd;
        case Mnemonic::Orps:
            return asmjit::x86::Inst::kIdOrps;
        case Mnemonic::Out:
            return asmjit::x86::Inst::kIdOut;
        case Mnemonic::Pabsb:
            return asmjit::x86::Inst::kIdPabsb;
        case Mnemonic::Pabsd:
            return asmjit::x86::Inst::kIdPabsd;
        case Mnemonic::Pabsw:
            return asmjit::x86::Inst::kIdPabsw;
        case Mnemonic::Packssdw:
            return asmjit::x86::Inst::kIdPackssdw;
        case Mnemonic::Packsswb:
            return asmjit::x86::Inst::kIdPacksswb;
        case Mnemonic::Packusdw:
            return asmjit::x86::Inst::kIdPackusdw;
        case Mnemonic::Packuswb:
            return asmjit::x86::Inst::kIdPackuswb;
        case Mnemonic::Paddb:
            return asmjit::x86::Inst::kIdPaddb;
        case Mnemonic::Paddd:
            return asmjit::x86::Inst::kIdPaddd;
        case Mnemonic::Paddq:
            return asmjit::x86::Inst::kIdPaddq;
        case Mnemonic::Paddsb:
            return asmjit::x86::Inst::kIdPaddsb;
        case Mnemonic::Paddsw:
            return asmjit::x86::Inst::kIdPaddsw;
        case Mnemonic::Paddusb:
            return asmjit::x86::Inst::kIdPaddusb;
        case Mnemonic::Paddusw:
            return asmjit::x86::Inst::kIdPaddusw;
        case Mnemonic::Paddw:
            return asmjit::x86::Inst::kIdPaddw;
        case Mnemonic::Palignr:
            return asmjit::x86::Inst::kIdPalignr;
        case Mnemonic::Pand:
            return asmjit::x86::Inst::kIdPand;
        case Mnemonic::Pandn:
            return asmjit::x86::Inst::kIdPandn;
        case Mnemonic::Pause:
            return asmjit::x86::Inst::kIdPause;
        case Mnemonic::Pavgb:
            return asmjit::x86::Inst::kIdPavgb;
        case Mnemonic::Pavgusb:
            return asmjit::x86::Inst::kIdPavgusb;
        case Mnemonic::Pavgw:
            return asmjit::x86::Inst::kIdPavgw;
        case Mnemonic::Pblendvb:
            return asmjit::x86::Inst::kIdPblendvb;
        case Mnemonic::Pblendw:
            return asmjit::x86::Inst::kIdPblendw;
        case Mnemonic::Pclmulqdq:
            return asmjit::x86::Inst::kIdPclmulqdq;
        case Mnemonic::Pcmpeqb:
            return asmjit::x86::Inst::kIdPcmpeqb;
        case Mnemonic::Pcmpeqd:
            return asmjit::x86::Inst::kIdPcmpeqd;
        case Mnemonic::Pcmpeqq:
            return asmjit::x86::Inst::kIdPcmpeqq;
        case Mnemonic::Pcmpeqw:
            return asmjit::x86::Inst::kIdPcmpeqw;
        case Mnemonic::Pcmpestri:
            return asmjit::x86::Inst::kIdPcmpestri;
        case Mnemonic::Pcmpestrm:
            return asmjit::x86::Inst::kIdPcmpestrm;
        case Mnemonic::Pcmpgtb:
            return asmjit::x86::Inst::kIdPcmpgtb;
        case Mnemonic::Pcmpgtd:
            return asmjit::x86::Inst::kIdPcmpgtd;
        case Mnemonic::Pcmpgtq:
            return asmjit::x86::Inst::kIdPcmpgtq;
        case Mnemonic::Pcmpgtw:
            return asmjit::x86::Inst::kIdPcmpgtw;
        case Mnemonic::Pcmpistri:
            return asmjit::x86::Inst::kIdPcmpistri;
        case Mnemonic::Pcmpistrm:
            return asmjit::x86::Inst::kIdPcmpistrm;
        case Mnemonic::Pdep:
            return asmjit::x86::Inst::kIdPdep;
        case Mnemonic::Pext:
            return asmjit::x86::Inst::kIdPext;
        case Mnemonic::Pextrb:
            return asmjit::x86::Inst::kIdPextrb;
        case Mnemonic::Pextrd:
            return asmjit::x86::Inst::kIdPextrd;
        case Mnemonic::Pextrq:
            return asmjit::x86::Inst::kIdPextrq;
        case Mnemonic::Pextrw:
            return asmjit::x86::Inst::kIdPextrw;
        case Mnemonic::Pf2id:
            return asmjit::x86::Inst::kIdPf2id;
        case Mnemonic::Pf2iw:
            return asmjit::x86::Inst::kIdPf2iw;
        case Mnemonic::Pfacc:
            return asmjit::x86::Inst::kIdPfacc;
        case Mnemonic::Pfadd:
            return asmjit::x86::Inst::kIdPfadd;
        case Mnemonic::Pfcmpeq:
            return asmjit::x86::Inst::kIdPfcmpeq;
        case Mnemonic::Pfcmpge:
            return asmjit::x86::Inst::kIdPfcmpge;
        case Mnemonic::Pfcmpgt:
            return asmjit::x86::Inst::kIdPfcmpgt;
        case Mnemonic::Pfmax:
            return asmjit::x86::Inst::kIdPfmax;
        case Mnemonic::Pfmin:
            return asmjit::x86::Inst::kIdPfmin;
        case Mnemonic::Pfmul:
            return asmjit::x86::Inst::kIdPfmul;
        case Mnemonic::Pfnacc:
            return asmjit::x86::Inst::kIdPfnacc;
        case Mnemonic::Pfpnacc:
            return asmjit::x86::Inst::kIdPfpnacc;
        case Mnemonic::Pfrcp:
            return asmjit::x86::Inst::kIdPfrcp;
        case Mnemonic::Pfrcpit2:
            return asmjit::x86::Inst::kIdPfrcpit2;
        case Mnemonic::Pfrsqit1:
            return asmjit::x86::Inst::kIdPfrsqit1;
        case Mnemonic::Pfsub:
            return asmjit::x86::Inst::kIdPfsub;
        case Mnemonic::Pfsubr:
            return asmjit::x86::Inst::kIdPfsubr;
        case Mnemonic::Phaddd:
            return asmjit::x86::Inst::kIdPhaddd;
        case Mnemonic::Phaddsw:
            return asmjit::x86::Inst::kIdPhaddsw;
        case Mnemonic::Phaddw:
            return asmjit::x86::Inst::kIdPhaddw;
        case Mnemonic::Phminposuw:
            return asmjit::x86::Inst::kIdPhminposuw;
        case Mnemonic::Phsubd:
            return asmjit::x86::Inst::kIdPhsubd;
        case Mnemonic::Phsubsw:
            return asmjit::x86::Inst::kIdPhsubsw;
        case Mnemonic::Phsubw:
            return asmjit::x86::Inst::kIdPhsubw;
        case Mnemonic::Pi2fd:
            return asmjit::x86::Inst::kIdPi2fd;
        case Mnemonic::Pi2fw:
            return asmjit::x86::Inst::kIdPi2fw;
        case Mnemonic::Pinsrb:
            return asmjit::x86::Inst::kIdPinsrb;
        case Mnemonic::Pinsrd:
            return asmjit::x86::Inst::kIdPinsrd;
        case Mnemonic::Pinsrq:
            return asmjit::x86::Inst::kIdPinsrq;
        case Mnemonic::Pinsrw:
            return asmjit::x86::Inst::kIdPinsrw;
        case Mnemonic::Pmaddubsw:
            return asmjit::x86::Inst::kIdPmaddubsw;
        case Mnemonic::Pmaddwd:
            return asmjit::x86::Inst::kIdPmaddwd;
        case Mnemonic::Pmaxsb:
            return asmjit::x86::Inst::kIdPmaxsb;
        case Mnemonic::Pmaxsd:
            return asmjit::x86::Inst::kIdPmaxsd;
        case Mnemonic::Pmaxsw:
            return asmjit::x86::Inst::kIdPmaxsw;
        case Mnemonic::Pmaxub:
            return asmjit::x86::Inst::kIdPmaxub;
        case Mnemonic::Pmaxud:
            return asmjit::x86::Inst::kIdPmaxud;
        case Mnemonic::Pmaxuw:
            return asmjit::x86::Inst::kIdPmaxuw;
        case Mnemonic::Pminsb:
            return asmjit::x86::Inst::kIdPminsb;
        case Mnemonic::Pminsd:
            return asmjit::x86::Inst::kIdPminsd;
        case Mnemonic::Pminsw:
            return asmjit::x86::Inst::kIdPminsw;
        case Mnemonic::Pminub:
            return asmjit::x86::Inst::kIdPminub;
        case Mnemonic::Pminud:
            return asmjit::x86::Inst::kIdPminud;
        case Mnemonic::Pminuw:
            return asmjit::x86::Inst::kIdPminuw;
        case Mnemonic::Pmovmskb:
            return asmjit::x86::Inst::kIdPmovmskb;
        case Mnemonic::Pmovsxbd:
            return asmjit::x86::Inst::kIdPmovsxbd;
        case Mnemonic::Pmovsxbq:
            return asmjit::x86::Inst::kIdPmovsxbq;
        case Mnemonic::Pmovsxbw:
            return asmjit::x86::Inst::kIdPmovsxbw;
        case Mnemonic::Pmovsxdq:
            return asmjit::x86::Inst::kIdPmovsxdq;
        case Mnemonic::Pmovsxwd:
            return asmjit::x86::Inst::kIdPmovsxwd;
        case Mnemonic::Pmovsxwq:
            return asmjit::x86::Inst::kIdPmovsxwq;
        case Mnemonic::Pmovzxbd:
            return asmjit::x86::Inst::kIdPmovzxbd;
        case Mnemonic::Pmovzxbq:
            return asmjit::x86::Inst::kIdPmovzxbq;
        case Mnemonic::Pmovzxbw:
            return asmjit::x86::Inst::kIdPmovzxbw;
        case Mnemonic::Pmovzxdq:
            return asmjit::x86::Inst::kIdPmovzxdq;
        case Mnemonic::Pmovzxwd:
            return asmjit::x86::Inst::kIdPmovzxwd;
        case Mnemonic::Pmovzxwq:
            return asmjit::x86::Inst::kIdPmovzxwq;
        case Mnemonic::Pmuldq:
            return asmjit::x86::Inst::kIdPmuldq;
        case Mnemonic::Pmulhrsw:
            return asmjit::x86::Inst::kIdPmulhrsw;
        case Mnemonic::Pmulhrw:
            return asmjit::x86::Inst::kIdPmulhrw;
        case Mnemonic::Pmulhuw:
            return asmjit::x86::Inst::kIdPmulhuw;
        case Mnemonic::Pmulhw:
            return asmjit::x86::Inst::kIdPmulhw;
        case Mnemonic::Pmulld:
            return asmjit::x86::Inst::kIdPmulld;
        case Mnemonic::Pmullw:
            return asmjit::x86::Inst::kIdPmullw;
        case Mnemonic::Pmuludq:
            return asmjit::x86::Inst::kIdPmuludq;
        case Mnemonic::Pop:
            return asmjit::x86::Inst::kIdPop;
        case Mnemonic::Popa:
            return asmjit::x86::Inst::kIdPopa;
        case Mnemonic::Popad:
            return asmjit::x86::Inst::kIdPopad;
        case Mnemonic::Popcnt:
            return asmjit::x86::Inst::kIdPopcnt;
        case Mnemonic::Popf:
            return asmjit::x86::Inst::kIdPopf;
        case Mnemonic::Popfd:
            return asmjit::x86::Inst::kIdPopfd;
        case Mnemonic::Popfq:
            return asmjit::x86::Inst::kIdPopfq;
        case Mnemonic::Por:
            return asmjit::x86::Inst::kIdPor;
        case Mnemonic::Prefetch:
            return asmjit::x86::Inst::kIdPrefetch;
        case Mnemonic::Prefetchnta:
            return asmjit::x86::Inst::kIdPrefetchnta;
        case Mnemonic::Prefetcht0:
            return asmjit::x86::Inst::kIdPrefetcht0;
        case Mnemonic::Prefetcht1:
            return asmjit::x86::Inst::kIdPrefetcht1;
        case Mnemonic::Prefetcht2:
            return asmjit::x86::Inst::kIdPrefetcht2;
        case Mnemonic::Prefetchw:
            return asmjit::x86::Inst::kIdPrefetchw;
        case Mnemonic::Prefetchwt1:
            return asmjit::x86::Inst::kIdPrefetchwt1;
        case Mnemonic::Psadbw:
            return asmjit::x86::Inst::kIdPsadbw;
        case Mnemonic::Pshufb:
            return asmjit::x86::Inst::kIdPshufb;
        case Mnemonic::Pshufd:
            return asmjit::x86::Inst::kIdPshufd;
        case Mnemonic::Pshufhw:
            return asmjit::x86::Inst::kIdPshufhw;
        case Mnemonic::Pshuflw:
            return asmjit::x86::Inst::kIdPshuflw;
        case Mnemonic::Pshufw:
            return asmjit::x86::Inst::kIdPshufw;
        case Mnemonic::Psignb:
            return asmjit::x86::Inst::kIdPsignb;
        case Mnemonic::Psignd:
            return asmjit::x86::Inst::kIdPsignd;
        case Mnemonic::Psignw:
            return asmjit::x86::Inst::kIdPsignw;
        case Mnemonic::Pslld:
            return asmjit::x86::Inst::kIdPslld;
        case Mnemonic::Pslldq:
            return asmjit::x86::Inst::kIdPslldq;
        case Mnemonic::Psllq:
            return asmjit::x86::Inst::kIdPsllq;
        case Mnemonic::Psllw:
            return asmjit::x86::Inst::kIdPsllw;
        case Mnemonic::Psrad:
            return asmjit::x86::Inst::kIdPsrad;
        case Mnemonic::Psraw:
            return asmjit::x86::Inst::kIdPsraw;
        case Mnemonic::Psrld:
            return asmjit::x86::Inst::kIdPsrld;
        case Mnemonic::Psrldq:
            return asmjit::x86::Inst::kIdPsrldq;
        case Mnemonic::Psrlq:
            return asmjit::x86::Inst::kIdPsrlq;
        case Mnemonic::Psrlw:
            return asmjit::x86::Inst::kIdPsrlw;
        case Mnemonic::Psubb:
            return asmjit::x86::Inst::kIdPsubb;
        case Mnemonic::Psubd:
            return asmjit::x86::Inst::kIdPsubd;
        case Mnemonic::Psubq:
            return asmjit::x86::Inst::kIdPsubq;
        case Mnemonic::Psubsb:
            return asmjit::x86::Inst::kIdPsubsb;
        case Mnemonic::Psubsw:
            return asmjit::x86::Inst::kIdPsubsw;
        case Mnemonic::Psubusb:
            return asmjit::x86::Inst::kIdPsubusb;
        case Mnemonic::Psubusw:
            return asmjit::x86::Inst::kIdPsubusw;
        case Mnemonic::Psubw:
            return asmjit::x86::Inst::kIdPsubw;
        case Mnemonic::Pswapd:
            return asmjit::x86::Inst::kIdPswapd;
        case Mnemonic::Ptest:
            return asmjit::x86::Inst::kIdPtest;
        case Mnemonic::Punpckhbw:
            return asmjit::x86::Inst::kIdPunpckhbw;
        case Mnemonic::Punpckhdq:
            return asmjit::x86::Inst::kIdPunpckhdq;
        case Mnemonic::Punpckhqdq:
            return asmjit::x86::Inst::kIdPunpckhqdq;
        case Mnemonic::Punpckhwd:
            return asmjit::x86::Inst::kIdPunpckhwd;
        case Mnemonic::Punpcklbw:
            return asmjit::x86::Inst::kIdPunpcklbw;
        case Mnemonic::Punpckldq:
            return asmjit::x86::Inst::kIdPunpckldq;
        case Mnemonic::Punpcklqdq:
            return asmjit::x86::Inst::kIdPunpcklqdq;
        case Mnemonic::Punpcklwd:
            return asmjit::x86::Inst::kIdPunpcklwd;
        case Mnemonic::Push:
            return asmjit::x86::Inst::kIdPush;
        case Mnemonic::Pusha:
            return asmjit::x86::Inst::kIdPusha;
        case Mnemonic::Pushad:
            return asmjit::x86::Inst::kIdPushad;
        case Mnemonic::Pushf:
            return asmjit::x86::Inst::kIdPushf;
        case Mnemonic::Pushfd:
            return asmjit::x86::Inst::kIdPushfd;
        case Mnemonic::Pushfq:
            return asmjit::x86::Inst::kIdPushfq;
        case Mnemonic::Pxor:
            return asmjit::x86::Inst::kIdPxor;
        case Mnemonic::Rcl:
            return asmjit::x86::Inst::kIdRcl;
        case Mnemonic::Rcpps:
            return asmjit::x86::Inst::kIdRcpps;
        case Mnemonic::Rcpss:
            return asmjit::x86::Inst::kIdRcpss;
        case Mnemonic::Rcr:
            return asmjit::x86::Inst::kIdRcr;
        case Mnemonic::Rdfsbase:
            return asmjit::x86::Inst::kIdRdfsbase;
        case Mnemonic::Rdgsbase:
            return asmjit::x86::Inst::kIdRdgsbase;
        case Mnemonic::Rdmsr:
            return asmjit::x86::Inst::kIdRdmsr;
        case Mnemonic::Rdpmc:
            return asmjit::x86::Inst::kIdRdpmc;
        case Mnemonic::Rdrand:
            return asmjit::x86::Inst::kIdRdrand;
        case Mnemonic::Rdseed:
            return asmjit::x86::Inst::kIdRdseed;
        case Mnemonic::Rdtsc:
            return asmjit::x86::Inst::kIdRdtsc;
        case Mnemonic::Rdtscp:
            return asmjit::x86::Inst::kIdRdtscp;
        case Mnemonic::Ret:
            return asmjit::x86::Inst::kIdRet;
        case Mnemonic::Rol:
            return asmjit::x86::Inst::kIdRol;
        case Mnemonic::Ror:
            return asmjit::x86::Inst::kIdRor;
        case Mnemonic::Rorx:
            return asmjit::x86::Inst::kIdRorx;
        case Mnemonic::Roundpd:
            return asmjit::x86::Inst::kIdRoundpd;
        case Mnemonic::Roundps:
            return asmjit::x86::Inst::kIdRoundps;
        case Mnemonic::Roundsd:
            return asmjit::x86::Inst::kIdRoundsd;
        case Mnemonic::Roundss:
            return asmjit::x86::Inst::kIdRoundss;
        case Mnemonic::Rsm:
            return asmjit::x86::Inst::kIdRsm;
        case Mnemonic::Rsqrtps:
            return asmjit::x86::Inst::kIdRsqrtps;
        case Mnemonic::Rsqrtss:
            return asmjit::x86::Inst::kIdRsqrtss;
        case Mnemonic::Sahf:
            return asmjit::x86::Inst::kIdSahf;
        case Mnemonic::Sar:
            return asmjit::x86::Inst::kIdSar;
        case Mnemonic::Sarx:
            return asmjit::x86::Inst::kIdSarx;
        case Mnemonic::Sbb:
            return asmjit::x86::Inst::kIdSbb;
        case Mnemonic::Setb:
            return asmjit::x86::Inst::kIdSetb;
        case Mnemonic::Setbe:
            return asmjit::x86::Inst::kIdSetbe;
        case Mnemonic::Setl:
            return asmjit::x86::Inst::kIdSetl;
        case Mnemonic::Setle:
            return asmjit::x86::Inst::kIdSetle;
        case Mnemonic::Setnb:
            return asmjit::x86::Inst::kIdSetnb;
        case Mnemonic::Setnbe:
            return asmjit::x86::Inst::kIdSetnbe;
        case Mnemonic::Setnl:
            return asmjit::x86::Inst::kIdSetnl;
        case Mnemonic::Setnle:
            return asmjit::x86::Inst::kIdSetnle;
        case Mnemonic::Setno:
            return asmjit::x86::Inst::kIdSetno;
        case Mnemonic::Setnp:
            return asmjit::x86::Inst::kIdSetnp;
        case Mnemonic::Setns:
            return asmjit::x86::Inst::kIdSetns;
        case Mnemonic::Setnz:
            return asmjit::x86::Inst::kIdSetnz;
        case Mnemonic::Seto:
            return asmjit::x86::Inst::kIdSeto;
        case Mnemonic::Setp:
            return asmjit::x86::Inst::kIdSetp;
        case Mnemonic::Sets:
            return asmjit::x86::Inst::kIdSets;
        case Mnemonic::Setz:
            return asmjit::x86::Inst::kIdSetz;
        case Mnemonic::Sfence:
            return asmjit::x86::Inst::kIdSfence;
        case Mnemonic::Sgdt:
            return asmjit::x86::Inst::kIdSgdt;
        case Mnemonic::Sha1msg1:
            return asmjit::x86::Inst::kIdSha1msg1;
        case Mnemonic::Sha1msg2:
            return asmjit::x86::Inst::kIdSha1msg2;
        case Mnemonic::Sha1nexte:
            return asmjit::x86::Inst::kIdSha1nexte;
        case Mnemonic::Sha1rnds4:
            return asmjit::x86::Inst::kIdSha1rnds4;
        case Mnemonic::Sha256msg1:
            return asmjit::x86::Inst::kIdSha256msg1;
        case Mnemonic::Sha256msg2:
            return asmjit::x86::Inst::kIdSha256msg2;
        case Mnemonic::Sha256rnds2:
            return asmjit::x86::Inst::kIdSha256rnds2;
        case Mnemonic::Shl:
            return asmjit::x86::Inst::kIdShl;
        case Mnemonic::Shld:
            return asmjit::x86::Inst::kIdShld;
        case Mnemonic::Shlx:
            return asmjit::x86::Inst::kIdShlx;
        case Mnemonic::Shr:
            return asmjit::x86::Inst::kIdShr;
        case Mnemonic::Shrd:
            return asmjit::x86::Inst::kIdShrd;
        case Mnemonic::Shrx:
            return asmjit::x86::Inst::kIdShrx;
        case Mnemonic::Shufpd:
            return asmjit::x86::Inst::kIdShufpd;
        case Mnemonic::Shufps:
            return asmjit::x86::Inst::kIdShufps;
        case Mnemonic::Sidt:
            return asmjit::x86::Inst::kIdSidt;
        case Mnemonic::Sldt:
            return asmjit::x86::Inst::kIdSldt;
        case Mnemonic::Smsw:
            return asmjit::x86::Inst::kIdSmsw;
        case Mnemonic::Sqrtpd:
            return asmjit::x86::Inst::kIdSqrtpd;
        case Mnemonic::Sqrtps:
            return asmjit::x86::Inst::kIdSqrtps;
        case Mnemonic::Sqrtsd:
            return asmjit::x86::Inst::kIdSqrtsd;
        case Mnemonic::Sqrtss:
            return asmjit::x86::Inst::kIdSqrtss;
        case Mnemonic::Stac:
            return asmjit::x86::Inst::kIdStac;
        case Mnemonic::Stc:
            return asmjit::x86::Inst::kIdStc;
        case Mnemonic::Std:
            return asmjit::x86::Inst::kIdStd;
        case Mnemonic::Sti:
            return asmjit::x86::Inst::kIdSti;
        case Mnemonic::Stmxcsr:
            return asmjit::x86::Inst::kIdStmxcsr;
        case Mnemonic::Str:
            return asmjit::x86::Inst::kIdStr;
        case Mnemonic::Sub:
            return asmjit::x86::Inst::kIdSub;
        case Mnemonic::Subpd:
            return asmjit::x86::Inst::kIdSubpd;
        case Mnemonic::Subps:
            return asmjit::x86::Inst::kIdSubps;
        case Mnemonic::Subsd:
            return asmjit::x86::Inst::kIdSubsd;
        case Mnemonic::Subss:
            return asmjit::x86::Inst::kIdSubss;
        case Mnemonic::Swapgs:
            return asmjit::x86::Inst::kIdSwapgs;
        case Mnemonic::Syscall:
            return asmjit::x86::Inst::kIdSyscall;
        case Mnemonic::Sysenter:
            return asmjit::x86::Inst::kIdSysenter;
        case Mnemonic::Sysexit:
            return asmjit::x86::Inst::kIdSysexit;
        case Mnemonic::Sysret:
            return asmjit::x86::Inst::kIdSysret;
        case Mnemonic::T1mskc:
            return asmjit::x86::Inst::kIdT1mskc;
        case Mnemonic::Test:
            return asmjit::x86::Inst::kIdTest;
        case Mnemonic::Tzcnt:
            return asmjit::x86::Inst::kIdTzcnt;
        case Mnemonic::Tzmsk:
            return asmjit::x86::Inst::kIdTzmsk;
        case Mnemonic::Ucomisd:
            return asmjit::x86::Inst::kIdUcomisd;
        case Mnemonic::Ucomiss:
            return asmjit::x86::Inst::kIdUcomiss;
        case Mnemonic::Ud2:
            return asmjit::x86::Inst::kIdUd2;
        case Mnemonic::Unpckhpd:
            return asmjit::x86::Inst::kIdUnpckhpd;
        case Mnemonic::Unpckhps:
            return asmjit::x86::Inst::kIdUnpckhps;
        case Mnemonic::Unpcklpd:
            return asmjit::x86::Inst::kIdUnpcklpd;
        case Mnemonic::Unpcklps:
            return asmjit::x86::Inst::kIdUnpcklps;
        case Mnemonic::V4fmaddps:
            return asmjit::x86::Inst::kIdV4fmaddps;
        case Mnemonic::V4fmaddss:
            return asmjit::x86::Inst::kIdV4fmaddss;
        case Mnemonic::V4fnmaddps:
            return asmjit::x86::Inst::kIdV4fnmaddps;
        case Mnemonic::V4fnmaddss:
            return asmjit::x86::Inst::kIdV4fnmaddss;
        case Mnemonic::Vaddpd:
            return asmjit::x86::Inst::kIdVaddpd;
        case Mnemonic::Vaddps:
            return asmjit::x86::Inst::kIdVaddps;
        case Mnemonic::Vaddsd:
            return asmjit::x86::Inst::kIdVaddsd;
        case Mnemonic::Vaddss:
            return asmjit::x86::Inst::kIdVaddss;
        case Mnemonic::Vaddsubpd:
            return asmjit::x86::Inst::kIdVaddsubpd;
        case Mnemonic::Vaddsubps:
            return asmjit::x86::Inst::kIdVaddsubps;
        case Mnemonic::Vaesdec:
            return asmjit::x86::Inst::kIdVaesdec;
        case Mnemonic::Vaesdeclast:
            return asmjit::x86::Inst::kIdVaesdeclast;
        case Mnemonic::Vaesenc:
            return asmjit::x86::Inst::kIdVaesenc;
        case Mnemonic::Vaesenclast:
            return asmjit::x86::Inst::kIdVaesenclast;
        case Mnemonic::Vaesimc:
            return asmjit::x86::Inst::kIdVaesimc;
        case Mnemonic::Vaeskeygenassist:
            return asmjit::x86::Inst::kIdVaeskeygenassist;
        case Mnemonic::Valignd:
            return asmjit::x86::Inst::kIdValignd;
        case Mnemonic::Valignq:
            return asmjit::x86::Inst::kIdValignq;
        case Mnemonic::Vandnpd:
            return asmjit::x86::Inst::kIdVandnpd;
        case Mnemonic::Vandnps:
            return asmjit::x86::Inst::kIdVandnps;
        case Mnemonic::Vandpd:
            return asmjit::x86::Inst::kIdVandpd;
        case Mnemonic::Vandps:
            return asmjit::x86::Inst::kIdVandps;
        case Mnemonic::Vblendmpd:
            return asmjit::x86::Inst::kIdVblendmpd;
        case Mnemonic::Vblendmps:
            return asmjit::x86::Inst::kIdVblendmps;
        case Mnemonic::Vblendpd:
            return asmjit::x86::Inst::kIdVblendpd;
        case Mnemonic::Vblendps:
            return asmjit::x86::Inst::kIdVblendps;
        case Mnemonic::Vblendvpd:
            return asmjit::x86::Inst::kIdVblendvpd;
        case Mnemonic::Vblendvps:
            return asmjit::x86::Inst::kIdVblendvps;
        case Mnemonic::Vbroadcastf128:
            return asmjit::x86::Inst::kIdVbroadcastf128;
        case Mnemonic::Vbroadcastf32x2:
            return asmjit::x86::Inst::kIdVbroadcastf32x2;
        case Mnemonic::Vbroadcastf32x4:
            return asmjit::x86::Inst::kIdVbroadcastf32x4;
        case Mnemonic::Vbroadcastf32x8:
            return asmjit::x86::Inst::kIdVbroadcastf32x8;
        case Mnemonic::Vbroadcastf64x2:
            return asmjit::x86::Inst::kIdVbroadcastf64x2;
        case Mnemonic::Vbroadcastf64x4:
            return asmjit::x86::Inst::kIdVbroadcastf64x4;
        case Mnemonic::Vbroadcasti128:
            return asmjit::x86::Inst::kIdVbroadcasti128;
        case Mnemonic::Vbroadcasti32x2:
            return asmjit::x86::Inst::kIdVbroadcasti32x2;
        case Mnemonic::Vbroadcasti32x4:
            return asmjit::x86::Inst::kIdVbroadcasti32x4;
        case Mnemonic::Vbroadcasti32x8:
            return asmjit::x86::Inst::kIdVbroadcasti32x8;
        case Mnemonic::Vbroadcasti64x2:
            return asmjit::x86::Inst::kIdVbroadcasti64x2;
        case Mnemonic::Vbroadcasti64x4:
            return asmjit::x86::Inst::kIdVbroadcasti64x4;
        case Mnemonic::Vbroadcastsd:
            return asmjit::x86::Inst::kIdVbroadcastsd;
        case Mnemonic::Vbroadcastss:
            return asmjit::x86::Inst::kIdVbroadcastss;
        case Mnemonic::Vcmppd:
            return asmjit::x86::Inst::kIdVcmppd;
        case Mnemonic::Vcmpps:
            return asmjit::x86::Inst::kIdVcmpps;
        case Mnemonic::Vcmpsd:
            return asmjit::x86::Inst::kIdVcmpsd;
        case Mnemonic::Vcmpss:
            return asmjit::x86::Inst::kIdVcmpss;
        case Mnemonic::Vcomisd:
            return asmjit::x86::Inst::kIdVcomisd;
        case Mnemonic::Vcomiss:
            return asmjit::x86::Inst::kIdVcomiss;
        case Mnemonic::Vcompresspd:
            return asmjit::x86::Inst::kIdVcompresspd;
        case Mnemonic::Vcompressps:
            return asmjit::x86::Inst::kIdVcompressps;
        case Mnemonic::Vcvtdq2pd:
            return asmjit::x86::Inst::kIdVcvtdq2pd;
        case Mnemonic::Vcvtdq2ps:
            return asmjit::x86::Inst::kIdVcvtdq2ps;
        case Mnemonic::Vcvtpd2dq:
            return asmjit::x86::Inst::kIdVcvtpd2dq;
        case Mnemonic::Vcvtpd2ps:
            return asmjit::x86::Inst::kIdVcvtpd2ps;
        case Mnemonic::Vcvtpd2qq:
            return asmjit::x86::Inst::kIdVcvtpd2qq;
        case Mnemonic::Vcvtpd2udq:
            return asmjit::x86::Inst::kIdVcvtpd2udq;
        case Mnemonic::Vcvtpd2uqq:
            return asmjit::x86::Inst::kIdVcvtpd2uqq;
        case Mnemonic::Vcvtph2ps:
            return asmjit::x86::Inst::kIdVcvtph2ps;
        case Mnemonic::Vcvtps2dq:
            return asmjit::x86::Inst::kIdVcvtps2dq;
        case Mnemonic::Vcvtps2pd:
            return asmjit::x86::Inst::kIdVcvtps2pd;
        case Mnemonic::Vcvtps2ph:
            return asmjit::x86::Inst::kIdVcvtps2ph;
        case Mnemonic::Vcvtps2qq:
            return asmjit::x86::Inst::kIdVcvtps2qq;
        case Mnemonic::Vcvtps2udq:
            return asmjit::x86::Inst::kIdVcvtps2udq;
        case Mnemonic::Vcvtps2uqq:
            return asmjit::x86::Inst::kIdVcvtps2uqq;
        case Mnemonic::Vcvtqq2pd:
            return asmjit::x86::Inst::kIdVcvtqq2pd;
        case Mnemonic::Vcvtqq2ps:
            return asmjit::x86::Inst::kIdVcvtqq2ps;
        case Mnemonic::Vcvtsd2si:
            return asmjit::x86::Inst::kIdVcvtsd2si;
        case Mnemonic::Vcvtsd2ss:
            return asmjit::x86::Inst::kIdVcvtsd2ss;
        case Mnemonic::Vcvtsd2usi:
            return asmjit::x86::Inst::kIdVcvtsd2usi;
        case Mnemonic::Vcvtsi2sd:
            return asmjit::x86::Inst::kIdVcvtsi2sd;
        case Mnemonic::Vcvtsi2ss:
            return asmjit::x86::Inst::kIdVcvtsi2ss;
        case Mnemonic::Vcvtss2sd:
            return asmjit::x86::Inst::kIdVcvtss2sd;
        case Mnemonic::Vcvtss2si:
            return asmjit::x86::Inst::kIdVcvtss2si;
        case Mnemonic::Vcvtss2usi:
            return asmjit::x86::Inst::kIdVcvtss2usi;
        case Mnemonic::Vcvttpd2dq:
            return asmjit::x86::Inst::kIdVcvttpd2dq;
        case Mnemonic::Vcvttpd2qq:
            return asmjit::x86::Inst::kIdVcvttpd2qq;
        case Mnemonic::Vcvttpd2udq:
            return asmjit::x86::Inst::kIdVcvttpd2udq;
        case Mnemonic::Vcvttpd2uqq:
            return asmjit::x86::Inst::kIdVcvttpd2uqq;
        case Mnemonic::Vcvttps2dq:
            return asmjit::x86::Inst::kIdVcvttps2dq;
        case Mnemonic::Vcvttps2qq:
            return asmjit::x86::Inst::kIdVcvttps2qq;
        case Mnemonic::Vcvttps2udq:
            return asmjit::x86::Inst::kIdVcvttps2udq;
        case Mnemonic::Vcvttps2uqq:
            return asmjit::x86::Inst::kIdVcvttps2uqq;
        case Mnemonic::Vcvttsd2si:
            return asmjit::x86::Inst::kIdVcvttsd2si;
        case Mnemonic::Vcvttsd2usi:
            return asmjit::x86::Inst::kIdVcvttsd2usi;
        case Mnemonic::Vcvttss2si:
            return asmjit::x86::Inst::kIdVcvttss2si;
        case Mnemonic::Vcvttss2usi:
            return asmjit::x86::Inst::kIdVcvttss2usi;
        case Mnemonic::Vcvtudq2pd:
            return asmjit::x86::Inst::kIdVcvtudq2pd;
        case Mnemonic::Vcvtudq2ps:
            return asmjit::x86::Inst::kIdVcvtudq2ps;
        case Mnemonic::Vcvtuqq2pd:
            return asmjit::x86::Inst::kIdVcvtuqq2pd;
        case Mnemonic::Vcvtuqq2ps:
            return asmjit::x86::Inst::kIdVcvtuqq2ps;
        case Mnemonic::Vcvtusi2sd:
            return asmjit::x86::Inst::kIdVcvtusi2sd;
        case Mnemonic::Vcvtusi2ss:
            return asmjit::x86::Inst::kIdVcvtusi2ss;
        case Mnemonic::Vdbpsadbw:
            return asmjit::x86::Inst::kIdVdbpsadbw;
        case Mnemonic::Vdivpd:
            return asmjit::x86::Inst::kIdVdivpd;
        case Mnemonic::Vdivps:
            return asmjit::x86::Inst::kIdVdivps;
        case Mnemonic::Vdivsd:
            return asmjit::x86::Inst::kIdVdivsd;
        case Mnemonic::Vdivss:
            return asmjit::x86::Inst::kIdVdivss;
        case Mnemonic::Vdppd:
            return asmjit::x86::Inst::kIdVdppd;
        case Mnemonic::Vdpps:
            return asmjit::x86::Inst::kIdVdpps;
        case Mnemonic::Verr:
            return asmjit::x86::Inst::kIdVerr;
        case Mnemonic::Verw:
            return asmjit::x86::Inst::kIdVerw;
        case Mnemonic::Vexp2pd:
            return asmjit::x86::Inst::kIdVexp2pd;
        case Mnemonic::Vexp2ps:
            return asmjit::x86::Inst::kIdVexp2ps;
        case Mnemonic::Vexpandpd:
            return asmjit::x86::Inst::kIdVexpandpd;
        case Mnemonic::Vexpandps:
            return asmjit::x86::Inst::kIdVexpandps;
        case Mnemonic::Vextractf128:
            return asmjit::x86::Inst::kIdVextractf128;
        case Mnemonic::Vextractf32x4:
            return asmjit::x86::Inst::kIdVextractf32x4;
        case Mnemonic::Vextractf32x8:
            return asmjit::x86::Inst::kIdVextractf32x8;
        case Mnemonic::Vextractf64x2:
            return asmjit::x86::Inst::kIdVextractf64x2;
        case Mnemonic::Vextractf64x4:
            return asmjit::x86::Inst::kIdVextractf64x4;
        case Mnemonic::Vextracti128:
            return asmjit::x86::Inst::kIdVextracti128;
        case Mnemonic::Vextracti32x4:
            return asmjit::x86::Inst::kIdVextracti32x4;
        case Mnemonic::Vextracti32x8:
            return asmjit::x86::Inst::kIdVextracti32x8;
        case Mnemonic::Vextracti64x2:
            return asmjit::x86::Inst::kIdVextracti64x2;
        case Mnemonic::Vextracti64x4:
            return asmjit::x86::Inst::kIdVextracti64x4;
        case Mnemonic::Vextractps:
            return asmjit::x86::Inst::kIdVextractps;
        case Mnemonic::Vfixupimmpd:
            return asmjit::x86::Inst::kIdVfixupimmpd;
        case Mnemonic::Vfixupimmps:
            return asmjit::x86::Inst::kIdVfixupimmps;
        case Mnemonic::Vfixupimmsd:
            return asmjit::x86::Inst::kIdVfixupimmsd;
        case Mnemonic::Vfixupimmss:
            return asmjit::x86::Inst::kIdVfixupimmss;
        case Mnemonic::Vfmadd132pd:
            return asmjit::x86::Inst::kIdVfmadd132pd;
        case Mnemonic::Vfmadd132ps:
            return asmjit::x86::Inst::kIdVfmadd132ps;
        case Mnemonic::Vfmadd132sd:
            return asmjit::x86::Inst::kIdVfmadd132sd;
        case Mnemonic::Vfmadd132ss:
            return asmjit::x86::Inst::kIdVfmadd132ss;
        case Mnemonic::Vfmadd213pd:
            return asmjit::x86::Inst::kIdVfmadd213pd;
        case Mnemonic::Vfmadd213ps:
            return asmjit::x86::Inst::kIdVfmadd213ps;
        case Mnemonic::Vfmadd213sd:
            return asmjit::x86::Inst::kIdVfmadd213sd;
        case Mnemonic::Vfmadd213ss:
            return asmjit::x86::Inst::kIdVfmadd213ss;
        case Mnemonic::Vfmadd231pd:
            return asmjit::x86::Inst::kIdVfmadd231pd;
        case Mnemonic::Vfmadd231ps:
            return asmjit::x86::Inst::kIdVfmadd231ps;
        case Mnemonic::Vfmadd231sd:
            return asmjit::x86::Inst::kIdVfmadd231sd;
        case Mnemonic::Vfmadd231ss:
            return asmjit::x86::Inst::kIdVfmadd231ss;
        case Mnemonic::Vfmaddpd:
            return asmjit::x86::Inst::kIdVfmaddpd;
        case Mnemonic::Vfmaddps:
            return asmjit::x86::Inst::kIdVfmaddps;
        case Mnemonic::Vfmaddsd:
            return asmjit::x86::Inst::kIdVfmaddsd;
        case Mnemonic::Vfmaddss:
            return asmjit::x86::Inst::kIdVfmaddss;
        case Mnemonic::Vfmaddsub132pd:
            return asmjit::x86::Inst::kIdVfmaddsub132pd;
        case Mnemonic::Vfmaddsub132ps:
            return asmjit::x86::Inst::kIdVfmaddsub132ps;
        case Mnemonic::Vfmaddsub213pd:
            return asmjit::x86::Inst::kIdVfmaddsub213pd;
        case Mnemonic::Vfmaddsub213ps:
            return asmjit::x86::Inst::kIdVfmaddsub213ps;
        case Mnemonic::Vfmaddsub231pd:
            return asmjit::x86::Inst::kIdVfmaddsub231pd;
        case Mnemonic::Vfmaddsub231ps:
            return asmjit::x86::Inst::kIdVfmaddsub231ps;
        case Mnemonic::Vfmaddsubpd:
            return asmjit::x86::Inst::kIdVfmaddsubpd;
        case Mnemonic::Vfmaddsubps:
            return asmjit::x86::Inst::kIdVfmaddsubps;
        case Mnemonic::Vfmsub132pd:
            return asmjit::x86::Inst::kIdVfmsub132pd;
        case Mnemonic::Vfmsub132ps:
            return asmjit::x86::Inst::kIdVfmsub132ps;
        case Mnemonic::Vfmsub132sd:
            return asmjit::x86::Inst::kIdVfmsub132sd;
        case Mnemonic::Vfmsub132ss:
            return asmjit::x86::Inst::kIdVfmsub132ss;
        case Mnemonic::Vfmsub213pd:
            return asmjit::x86::Inst::kIdVfmsub213pd;
        case Mnemonic::Vfmsub213ps:
            return asmjit::x86::Inst::kIdVfmsub213ps;
        case Mnemonic::Vfmsub213sd:
            return asmjit::x86::Inst::kIdVfmsub213sd;
        case Mnemonic::Vfmsub213ss:
            return asmjit::x86::Inst::kIdVfmsub213ss;
        case Mnemonic::Vfmsub231pd:
            return asmjit::x86::Inst::kIdVfmsub231pd;
        case Mnemonic::Vfmsub231ps:
            return asmjit::x86::Inst::kIdVfmsub231ps;
        case Mnemonic::Vfmsub231sd:
            return asmjit::x86::Inst::kIdVfmsub231sd;
        case Mnemonic::Vfmsub231ss:
            return asmjit::x86::Inst::kIdVfmsub231ss;
        case Mnemonic::Vfmsubadd132pd:
            return asmjit::x86::Inst::kIdVfmsubadd132pd;
        case Mnemonic::Vfmsubadd132ps:
            return asmjit::x86::Inst::kIdVfmsubadd132ps;
        case Mnemonic::Vfmsubadd213pd:
            return asmjit::x86::Inst::kIdVfmsubadd213pd;
        case Mnemonic::Vfmsubadd213ps:
            return asmjit::x86::Inst::kIdVfmsubadd213ps;
        case Mnemonic::Vfmsubadd231pd:
            return asmjit::x86::Inst::kIdVfmsubadd231pd;
        case Mnemonic::Vfmsubadd231ps:
            return asmjit::x86::Inst::kIdVfmsubadd231ps;
        case Mnemonic::Vfmsubaddpd:
            return asmjit::x86::Inst::kIdVfmsubaddpd;
        case Mnemonic::Vfmsubaddps:
            return asmjit::x86::Inst::kIdVfmsubaddps;
        case Mnemonic::Vfmsubpd:
            return asmjit::x86::Inst::kIdVfmsubpd;
        case Mnemonic::Vfmsubps:
            return asmjit::x86::Inst::kIdVfmsubps;
        case Mnemonic::Vfmsubsd:
            return asmjit::x86::Inst::kIdVfmsubsd;
        case Mnemonic::Vfmsubss:
            return asmjit::x86::Inst::kIdVfmsubss;
        case Mnemonic::Vfnmadd132pd:
            return asmjit::x86::Inst::kIdVfnmadd132pd;
        case Mnemonic::Vfnmadd132ps:
            return asmjit::x86::Inst::kIdVfnmadd132ps;
        case Mnemonic::Vfnmadd132sd:
            return asmjit::x86::Inst::kIdVfnmadd132sd;
        case Mnemonic::Vfnmadd132ss:
            return asmjit::x86::Inst::kIdVfnmadd132ss;
        case Mnemonic::Vfnmadd213pd:
            return asmjit::x86::Inst::kIdVfnmadd213pd;
        case Mnemonic::Vfnmadd213ps:
            return asmjit::x86::Inst::kIdVfnmadd213ps;
        case Mnemonic::Vfnmadd213sd:
            return asmjit::x86::Inst::kIdVfnmadd213sd;
        case Mnemonic::Vfnmadd213ss:
            return asmjit::x86::Inst::kIdVfnmadd213ss;
        case Mnemonic::Vfnmadd231pd:
            return asmjit::x86::Inst::kIdVfnmadd231pd;
        case Mnemonic::Vfnmadd231ps:
            return asmjit::x86::Inst::kIdVfnmadd231ps;
        case Mnemonic::Vfnmadd231sd:
            return asmjit::x86::Inst::kIdVfnmadd231sd;
        case Mnemonic::Vfnmadd231ss:
            return asmjit::x86::Inst::kIdVfnmadd231ss;
        case Mnemonic::Vfnmaddpd:
            return asmjit::x86::Inst::kIdVfnmaddpd;
        case Mnemonic::Vfnmaddps:
            return asmjit::x86::Inst::kIdVfnmaddps;
        case Mnemonic::Vfnmaddsd:
            return asmjit::x86::Inst::kIdVfnmaddsd;
        case Mnemonic::Vfnmaddss:
            return asmjit::x86::Inst::kIdVfnmaddss;
        case Mnemonic::Vfnmsub132pd:
            return asmjit::x86::Inst::kIdVfnmsub132pd;
        case Mnemonic::Vfnmsub132ps:
            return asmjit::x86::Inst::kIdVfnmsub132ps;
        case Mnemonic::Vfnmsub132sd:
            return asmjit::x86::Inst::kIdVfnmsub132sd;
        case Mnemonic::Vfnmsub132ss:
            return asmjit::x86::Inst::kIdVfnmsub132ss;
        case Mnemonic::Vfnmsub213pd:
            return asmjit::x86::Inst::kIdVfnmsub213pd;
        case Mnemonic::Vfnmsub213ps:
            return asmjit::x86::Inst::kIdVfnmsub213ps;
        case Mnemonic::Vfnmsub213sd:
            return asmjit::x86::Inst::kIdVfnmsub213sd;
        case Mnemonic::Vfnmsub213ss:
            return asmjit::x86::Inst::kIdVfnmsub213ss;
        case Mnemonic::Vfnmsub231pd:
            return asmjit::x86::Inst::kIdVfnmsub231pd;
        case Mnemonic::Vfnmsub231ps:
            return asmjit::x86::Inst::kIdVfnmsub231ps;
        case Mnemonic::Vfnmsub231sd:
            return asmjit::x86::Inst::kIdVfnmsub231sd;
        case Mnemonic::Vfnmsub231ss:
            return asmjit::x86::Inst::kIdVfnmsub231ss;
        case Mnemonic::Vfnmsubpd:
            return asmjit::x86::Inst::kIdVfnmsubpd;
        case Mnemonic::Vfnmsubps:
            return asmjit::x86::Inst::kIdVfnmsubps;
        case Mnemonic::Vfnmsubsd:
            return asmjit::x86::Inst::kIdVfnmsubsd;
        case Mnemonic::Vfnmsubss:
            return asmjit::x86::Inst::kIdVfnmsubss;
        case Mnemonic::Vfpclasspd:
            return asmjit::x86::Inst::kIdVfpclasspd;
        case Mnemonic::Vfpclassps:
            return asmjit::x86::Inst::kIdVfpclassps;
        case Mnemonic::Vfpclasssd:
            return asmjit::x86::Inst::kIdVfpclasssd;
        case Mnemonic::Vfpclassss:
            return asmjit::x86::Inst::kIdVfpclassss;
        case Mnemonic::Vfrczpd:
            return asmjit::x86::Inst::kIdVfrczpd;
        case Mnemonic::Vfrczps:
            return asmjit::x86::Inst::kIdVfrczps;
        case Mnemonic::Vfrczsd:
            return asmjit::x86::Inst::kIdVfrczsd;
        case Mnemonic::Vfrczss:
            return asmjit::x86::Inst::kIdVfrczss;
        case Mnemonic::Vgatherdpd:
            return asmjit::x86::Inst::kIdVgatherdpd;
        case Mnemonic::Vgatherdps:
            return asmjit::x86::Inst::kIdVgatherdps;
        case Mnemonic::Vgatherpf0dpd:
            return asmjit::x86::Inst::kIdVgatherpf0dpd;
        case Mnemonic::Vgatherpf0dps:
            return asmjit::x86::Inst::kIdVgatherpf0dps;
        case Mnemonic::Vgatherpf0qpd:
            return asmjit::x86::Inst::kIdVgatherpf0qpd;
        case Mnemonic::Vgatherpf0qps:
            return asmjit::x86::Inst::kIdVgatherpf0qps;
        case Mnemonic::Vgatherpf1dpd:
            return asmjit::x86::Inst::kIdVgatherpf1dpd;
        case Mnemonic::Vgatherpf1dps:
            return asmjit::x86::Inst::kIdVgatherpf1dps;
        case Mnemonic::Vgatherpf1qpd:
            return asmjit::x86::Inst::kIdVgatherpf1qpd;
        case Mnemonic::Vgatherpf1qps:
            return asmjit::x86::Inst::kIdVgatherpf1qps;
        case Mnemonic::Vgatherqpd:
            return asmjit::x86::Inst::kIdVgatherqpd;
        case Mnemonic::Vgatherqps:
            return asmjit::x86::Inst::kIdVgatherqps;
        case Mnemonic::Vgetexppd:
            return asmjit::x86::Inst::kIdVgetexppd;
        case Mnemonic::Vgetexpps:
            return asmjit::x86::Inst::kIdVgetexpps;
        case Mnemonic::Vgetexpsd:
            return asmjit::x86::Inst::kIdVgetexpsd;
        case Mnemonic::Vgetexpss:
            return asmjit::x86::Inst::kIdVgetexpss;
        case Mnemonic::Vgetmantpd:
            return asmjit::x86::Inst::kIdVgetmantpd;
        case Mnemonic::Vgetmantps:
            return asmjit::x86::Inst::kIdVgetmantps;
        case Mnemonic::Vgetmantsd:
            return asmjit::x86::Inst::kIdVgetmantsd;
        case Mnemonic::Vgetmantss:
            return asmjit::x86::Inst::kIdVgetmantss;
        case Mnemonic::Vhaddpd:
            return asmjit::x86::Inst::kIdVhaddpd;
        case Mnemonic::Vhaddps:
            return asmjit::x86::Inst::kIdVhaddps;
        case Mnemonic::Vhsubpd:
            return asmjit::x86::Inst::kIdVhsubpd;
        case Mnemonic::Vhsubps:
            return asmjit::x86::Inst::kIdVhsubps;
        case Mnemonic::Vinsertf128:
            return asmjit::x86::Inst::kIdVinsertf128;
        case Mnemonic::Vinsertf32x4:
            return asmjit::x86::Inst::kIdVinsertf32x4;
        case Mnemonic::Vinsertf32x8:
            return asmjit::x86::Inst::kIdVinsertf32x8;
        case Mnemonic::Vinsertf64x2:
            return asmjit::x86::Inst::kIdVinsertf64x2;
        case Mnemonic::Vinsertf64x4:
            return asmjit::x86::Inst::kIdVinsertf64x4;
        case Mnemonic::Vinserti128:
            return asmjit::x86::Inst::kIdVinserti128;
        case Mnemonic::Vinserti32x4:
            return asmjit::x86::Inst::kIdVinserti32x4;
        case Mnemonic::Vinserti32x8:
            return asmjit::x86::Inst::kIdVinserti32x8;
        case Mnemonic::Vinserti64x2:
            return asmjit::x86::Inst::kIdVinserti64x2;
        case Mnemonic::Vinserti64x4:
            return asmjit::x86::Inst::kIdVinserti64x4;
        case Mnemonic::Vinsertps:
            return asmjit::x86::Inst::kIdVinsertps;
        case Mnemonic::Vlddqu:
            return asmjit::x86::Inst::kIdVlddqu;
        case Mnemonic::Vldmxcsr:
            return asmjit::x86::Inst::kIdVldmxcsr;
        case Mnemonic::Vmaskmovdqu:
            return asmjit::x86::Inst::kIdVmaskmovdqu;
        case Mnemonic::Vmaskmovpd:
            return asmjit::x86::Inst::kIdVmaskmovpd;
        case Mnemonic::Vmaskmovps:
            return asmjit::x86::Inst::kIdVmaskmovps;
        case Mnemonic::Vmaxpd:
            return asmjit::x86::Inst::kIdVmaxpd;
        case Mnemonic::Vmaxps:
            return asmjit::x86::Inst::kIdVmaxps;
        case Mnemonic::Vmaxsd:
            return asmjit::x86::Inst::kIdVmaxsd;
        case Mnemonic::Vmaxss:
            return asmjit::x86::Inst::kIdVmaxss;
        case Mnemonic::Vminpd:
            return asmjit::x86::Inst::kIdVminpd;
        case Mnemonic::Vminps:
            return asmjit::x86::Inst::kIdVminps;
        case Mnemonic::Vminsd:
            return asmjit::x86::Inst::kIdVminsd;
        case Mnemonic::Vminss:
            return asmjit::x86::Inst::kIdVminss;
        case Mnemonic::Vmovapd:
            return asmjit::x86::Inst::kIdVmovapd;
        case Mnemonic::Vmovaps:
            return asmjit::x86::Inst::kIdVmovaps;
        case Mnemonic::Vmovd:
            return asmjit::x86::Inst::kIdVmovd;
        case Mnemonic::Vmovddup:
            return asmjit::x86::Inst::kIdVmovddup;
        case Mnemonic::Vmovdqa:
            return asmjit::x86::Inst::kIdVmovdqa;
        case Mnemonic::Vmovdqa32:
            return asmjit::x86::Inst::kIdVmovdqa32;
        case Mnemonic::Vmovdqa64:
            return asmjit::x86::Inst::kIdVmovdqa64;
        case Mnemonic::Vmovdqu:
            return asmjit::x86::Inst::kIdVmovdqu;
        case Mnemonic::Vmovdqu16:
            return asmjit::x86::Inst::kIdVmovdqu16;
        case Mnemonic::Vmovdqu32:
            return asmjit::x86::Inst::kIdVmovdqu32;
        case Mnemonic::Vmovdqu64:
            return asmjit::x86::Inst::kIdVmovdqu64;
        case Mnemonic::Vmovdqu8:
            return asmjit::x86::Inst::kIdVmovdqu8;
        case Mnemonic::Vmovhlps:
            return asmjit::x86::Inst::kIdVmovhlps;
        case Mnemonic::Vmovhpd:
            return asmjit::x86::Inst::kIdVmovhpd;
        case Mnemonic::Vmovhps:
            return asmjit::x86::Inst::kIdVmovhps;
        case Mnemonic::Vmovlhps:
            return asmjit::x86::Inst::kIdVmovlhps;
        case Mnemonic::Vmovlpd:
            return asmjit::x86::Inst::kIdVmovlpd;
        case Mnemonic::Vmovlps:
            return asmjit::x86::Inst::kIdVmovlps;
        case Mnemonic::Vmovmskpd:
            return asmjit::x86::Inst::kIdVmovmskpd;
        case Mnemonic::Vmovmskps:
            return asmjit::x86::Inst::kIdVmovmskps;
        case Mnemonic::Vmovntdq:
            return asmjit::x86::Inst::kIdVmovntdq;
        case Mnemonic::Vmovntdqa:
            return asmjit::x86::Inst::kIdVmovntdqa;
        case Mnemonic::Vmovntpd:
            return asmjit::x86::Inst::kIdVmovntpd;
        case Mnemonic::Vmovntps:
            return asmjit::x86::Inst::kIdVmovntps;
        case Mnemonic::Vmovq:
            return asmjit::x86::Inst::kIdVmovq;
        case Mnemonic::Vmovsd:
            return asmjit::x86::Inst::kIdVmovsd;
        case Mnemonic::Vmovshdup:
            return asmjit::x86::Inst::kIdVmovshdup;
        case Mnemonic::Vmovsldup:
            return asmjit::x86::Inst::kIdVmovsldup;
        case Mnemonic::Vmovss:
            return asmjit::x86::Inst::kIdVmovss;
        case Mnemonic::Vmovupd:
            return asmjit::x86::Inst::kIdVmovupd;
        case Mnemonic::Vmovups:
            return asmjit::x86::Inst::kIdVmovups;
        case Mnemonic::Vmpsadbw:
            return asmjit::x86::Inst::kIdVmpsadbw;
        case Mnemonic::Vmulpd:
            return asmjit::x86::Inst::kIdVmulpd;
        case Mnemonic::Vmulps:
            return asmjit::x86::Inst::kIdVmulps;
        case Mnemonic::Vmulsd:
            return asmjit::x86::Inst::kIdVmulsd;
        case Mnemonic::Vmulss:
            return asmjit::x86::Inst::kIdVmulss;
        case Mnemonic::Vorpd:
            return asmjit::x86::Inst::kIdVorpd;
        case Mnemonic::Vorps:
            return asmjit::x86::Inst::kIdVorps;
        case Mnemonic::Vp4dpwssd:
            return asmjit::x86::Inst::kIdVp4dpwssd;
        case Mnemonic::Vp4dpwssds:
            return asmjit::x86::Inst::kIdVp4dpwssds;
        case Mnemonic::Vpabsb:
            return asmjit::x86::Inst::kIdVpabsb;
        case Mnemonic::Vpabsd:
            return asmjit::x86::Inst::kIdVpabsd;
        case Mnemonic::Vpabsq:
            return asmjit::x86::Inst::kIdVpabsq;
        case Mnemonic::Vpabsw:
            return asmjit::x86::Inst::kIdVpabsw;
        case Mnemonic::Vpackssdw:
            return asmjit::x86::Inst::kIdVpackssdw;
        case Mnemonic::Vpacksswb:
            return asmjit::x86::Inst::kIdVpacksswb;
        case Mnemonic::Vpackusdw:
            return asmjit::x86::Inst::kIdVpackusdw;
        case Mnemonic::Vpackuswb:
            return asmjit::x86::Inst::kIdVpackuswb;
        case Mnemonic::Vpaddb:
            return asmjit::x86::Inst::kIdVpaddb;
        case Mnemonic::Vpaddd:
            return asmjit::x86::Inst::kIdVpaddd;
        case Mnemonic::Vpaddq:
            return asmjit::x86::Inst::kIdVpaddq;
        case Mnemonic::Vpaddsb:
            return asmjit::x86::Inst::kIdVpaddsb;
        case Mnemonic::Vpaddsw:
            return asmjit::x86::Inst::kIdVpaddsw;
        case Mnemonic::Vpaddusb:
            return asmjit::x86::Inst::kIdVpaddusb;
        case Mnemonic::Vpaddusw:
            return asmjit::x86::Inst::kIdVpaddusw;
        case Mnemonic::Vpaddw:
            return asmjit::x86::Inst::kIdVpaddw;
        case Mnemonic::Vpalignr:
            return asmjit::x86::Inst::kIdVpalignr;
        case Mnemonic::Vpand:
            return asmjit::x86::Inst::kIdVpand;
        case Mnemonic::Vpandd:
            return asmjit::x86::Inst::kIdVpandd;
        case Mnemonic::Vpandn:
            return asmjit::x86::Inst::kIdVpandn;
        case Mnemonic::Vpandnd:
            return asmjit::x86::Inst::kIdVpandnd;
        case Mnemonic::Vpandnq:
            return asmjit::x86::Inst::kIdVpandnq;
        case Mnemonic::Vpandq:
            return asmjit::x86::Inst::kIdVpandq;
        case Mnemonic::Vpavgb:
            return asmjit::x86::Inst::kIdVpavgb;
        case Mnemonic::Vpavgw:
            return asmjit::x86::Inst::kIdVpavgw;
        case Mnemonic::Vpblendd:
            return asmjit::x86::Inst::kIdVpblendd;
        case Mnemonic::Vpblendvb:
            return asmjit::x86::Inst::kIdVpblendvb;
        case Mnemonic::Vpblendw:
            return asmjit::x86::Inst::kIdVpblendw;
        case Mnemonic::Vpbroadcastb:
            return asmjit::x86::Inst::kIdVpbroadcastb;
        case Mnemonic::Vpbroadcastd:
            return asmjit::x86::Inst::kIdVpbroadcastd;
        case Mnemonic::Vpbroadcastmb2q:
            return asmjit::x86::Inst::kIdVpbroadcastmb2q;
        case Mnemonic::Vpbroadcastq:
            return asmjit::x86::Inst::kIdVpbroadcastq;
        case Mnemonic::Vpbroadcastw:
            return asmjit::x86::Inst::kIdVpbroadcastw;
        case Mnemonic::Vpclmulqdq:
            return asmjit::x86::Inst::kIdVpclmulqdq;
        case Mnemonic::Vpcmov:
            return asmjit::x86::Inst::kIdVpcmov;
        case Mnemonic::Vpcmpb:
            return asmjit::x86::Inst::kIdVpcmpb;
        case Mnemonic::Vpcmpd:
            return asmjit::x86::Inst::kIdVpcmpd;
        case Mnemonic::Vpcmpeqb:
            return asmjit::x86::Inst::kIdVpcmpeqb;
        case Mnemonic::Vpcmpeqd:
            return asmjit::x86::Inst::kIdVpcmpeqd;
        case Mnemonic::Vpcmpeqq:
            return asmjit::x86::Inst::kIdVpcmpeqq;
        case Mnemonic::Vpcmpeqw:
            return asmjit::x86::Inst::kIdVpcmpeqw;
        case Mnemonic::Vpcmpestri:
            return asmjit::x86::Inst::kIdVpcmpestri;
        case Mnemonic::Vpcmpestrm:
            return asmjit::x86::Inst::kIdVpcmpestrm;
        case Mnemonic::Vpcmpgtb:
            return asmjit::x86::Inst::kIdVpcmpgtb;
        case Mnemonic::Vpcmpgtd:
            return asmjit::x86::Inst::kIdVpcmpgtd;
        case Mnemonic::Vpcmpgtq:
            return asmjit::x86::Inst::kIdVpcmpgtq;
        case Mnemonic::Vpcmpgtw:
            return asmjit::x86::Inst::kIdVpcmpgtw;
        case Mnemonic::Vpcmpistri:
            return asmjit::x86::Inst::kIdVpcmpistri;
        case Mnemonic::Vpcmpistrm:
            return asmjit::x86::Inst::kIdVpcmpistrm;
        case Mnemonic::Vpcmpq:
            return asmjit::x86::Inst::kIdVpcmpq;
        case Mnemonic::Vpcmpub:
            return asmjit::x86::Inst::kIdVpcmpub;
        case Mnemonic::Vpcmpud:
            return asmjit::x86::Inst::kIdVpcmpud;
        case Mnemonic::Vpcmpuq:
            return asmjit::x86::Inst::kIdVpcmpuq;
        case Mnemonic::Vpcmpuw:
            return asmjit::x86::Inst::kIdVpcmpuw;
        case Mnemonic::Vpcmpw:
            return asmjit::x86::Inst::kIdVpcmpw;
        case Mnemonic::Vpcomb:
            return asmjit::x86::Inst::kIdVpcomb;
        case Mnemonic::Vpcomd:
            return asmjit::x86::Inst::kIdVpcomd;
        case Mnemonic::Vpcompressb:
            return asmjit::x86::Inst::kIdVpcompressb;
        case Mnemonic::Vpcompressd:
            return asmjit::x86::Inst::kIdVpcompressd;
        case Mnemonic::Vpcompressq:
            return asmjit::x86::Inst::kIdVpcompressq;
        case Mnemonic::Vpcompressw:
            return asmjit::x86::Inst::kIdVpcompressw;
        case Mnemonic::Vpcomq:
            return asmjit::x86::Inst::kIdVpcomq;
        case Mnemonic::Vpcomub:
            return asmjit::x86::Inst::kIdVpcomub;
        case Mnemonic::Vpcomud:
            return asmjit::x86::Inst::kIdVpcomud;
        case Mnemonic::Vpcomuq:
            return asmjit::x86::Inst::kIdVpcomuq;
        case Mnemonic::Vpcomuw:
            return asmjit::x86::Inst::kIdVpcomuw;
        case Mnemonic::Vpcomw:
            return asmjit::x86::Inst::kIdVpcomw;
        case Mnemonic::Vpconflictd:
            return asmjit::x86::Inst::kIdVpconflictd;
        case Mnemonic::Vpconflictq:
            return asmjit::x86::Inst::kIdVpconflictq;
        case Mnemonic::Vperm2f128:
            return asmjit::x86::Inst::kIdVperm2f128;
        case Mnemonic::Vperm2i128:
            return asmjit::x86::Inst::kIdVperm2i128;
        case Mnemonic::Vpermb:
            return asmjit::x86::Inst::kIdVpermb;
        case Mnemonic::Vpermd:
            return asmjit::x86::Inst::kIdVpermd;
        case Mnemonic::Vpermi2b:
            return asmjit::x86::Inst::kIdVpermi2b;
        case Mnemonic::Vpermi2d:
            return asmjit::x86::Inst::kIdVpermi2d;
        case Mnemonic::Vpermi2pd:
            return asmjit::x86::Inst::kIdVpermi2pd;
        case Mnemonic::Vpermi2ps:
            return asmjit::x86::Inst::kIdVpermi2ps;
        case Mnemonic::Vpermi2q:
            return asmjit::x86::Inst::kIdVpermi2q;
        case Mnemonic::Vpermi2w:
            return asmjit::x86::Inst::kIdVpermi2w;
        case Mnemonic::Vpermil2pd:
            return asmjit::x86::Inst::kIdVpermil2pd;
        case Mnemonic::Vpermil2ps:
            return asmjit::x86::Inst::kIdVpermil2ps;
        case Mnemonic::Vpermilpd:
            return asmjit::x86::Inst::kIdVpermilpd;
        case Mnemonic::Vpermilps:
            return asmjit::x86::Inst::kIdVpermilps;
        case Mnemonic::Vpermpd:
            return asmjit::x86::Inst::kIdVpermpd;
        case Mnemonic::Vpermps:
            return asmjit::x86::Inst::kIdVpermps;
        case Mnemonic::Vpermq:
            return asmjit::x86::Inst::kIdVpermq;
        case Mnemonic::Vpermt2b:
            return asmjit::x86::Inst::kIdVpermt2b;
        case Mnemonic::Vpermt2d:
            return asmjit::x86::Inst::kIdVpermt2d;
        case Mnemonic::Vpermt2pd:
            return asmjit::x86::Inst::kIdVpermt2pd;
        case Mnemonic::Vpermt2ps:
            return asmjit::x86::Inst::kIdVpermt2ps;
        case Mnemonic::Vpermt2q:
            return asmjit::x86::Inst::kIdVpermt2q;
        case Mnemonic::Vpermt2w:
            return asmjit::x86::Inst::kIdVpermt2w;
        case Mnemonic::Vpermw:
            return asmjit::x86::Inst::kIdVpermw;
        case Mnemonic::Vpexpandb:
            return asmjit::x86::Inst::kIdVpexpandb;
        case Mnemonic::Vpexpandd:
            return asmjit::x86::Inst::kIdVpexpandd;
        case Mnemonic::Vpexpandq:
            return asmjit::x86::Inst::kIdVpexpandq;
        case Mnemonic::Vpexpandw:
            return asmjit::x86::Inst::kIdVpexpandw;
        case Mnemonic::Vpextrb:
            return asmjit::x86::Inst::kIdVpextrb;
        case Mnemonic::Vpextrd:
            return asmjit::x86::Inst::kIdVpextrd;
        case Mnemonic::Vpextrq:
            return asmjit::x86::Inst::kIdVpextrq;
        case Mnemonic::Vpextrw:
            return asmjit::x86::Inst::kIdVpextrw;
        case Mnemonic::Vpgatherdd:
            return asmjit::x86::Inst::kIdVpgatherdd;
        case Mnemonic::Vpgatherdq:
            return asmjit::x86::Inst::kIdVpgatherdq;
        case Mnemonic::Vpgatherqd:
            return asmjit::x86::Inst::kIdVpgatherqd;
        case Mnemonic::Vpgatherqq:
            return asmjit::x86::Inst::kIdVpgatherqq;
        case Mnemonic::Vphaddbd:
            return asmjit::x86::Inst::kIdVphaddbd;
        case Mnemonic::Vphaddbq:
            return asmjit::x86::Inst::kIdVphaddbq;
        case Mnemonic::Vphaddbw:
            return asmjit::x86::Inst::kIdVphaddbw;
        case Mnemonic::Vphaddd:
            return asmjit::x86::Inst::kIdVphaddd;
        case Mnemonic::Vphadddq:
            return asmjit::x86::Inst::kIdVphadddq;
        case Mnemonic::Vphaddsw:
            return asmjit::x86::Inst::kIdVphaddsw;
        case Mnemonic::Vphaddubd:
            return asmjit::x86::Inst::kIdVphaddubd;
        case Mnemonic::Vphaddubq:
            return asmjit::x86::Inst::kIdVphaddubq;
        case Mnemonic::Vphaddubw:
            return asmjit::x86::Inst::kIdVphaddubw;
        case Mnemonic::Vphaddudq:
            return asmjit::x86::Inst::kIdVphaddudq;
        case Mnemonic::Vphadduwd:
            return asmjit::x86::Inst::kIdVphadduwd;
        case Mnemonic::Vphadduwq:
            return asmjit::x86::Inst::kIdVphadduwq;
        case Mnemonic::Vphaddw:
            return asmjit::x86::Inst::kIdVphaddw;
        case Mnemonic::Vphaddwd:
            return asmjit::x86::Inst::kIdVphaddwd;
        case Mnemonic::Vphaddwq:
            return asmjit::x86::Inst::kIdVphaddwq;
        case Mnemonic::Vphminposuw:
            return asmjit::x86::Inst::kIdVphminposuw;
        case Mnemonic::Vphsubbw:
            return asmjit::x86::Inst::kIdVphsubbw;
        case Mnemonic::Vphsubd:
            return asmjit::x86::Inst::kIdVphsubd;
        case Mnemonic::Vphsubdq:
            return asmjit::x86::Inst::kIdVphsubdq;
        case Mnemonic::Vphsubsw:
            return asmjit::x86::Inst::kIdVphsubsw;
        case Mnemonic::Vphsubw:
            return asmjit::x86::Inst::kIdVphsubw;
        case Mnemonic::Vphsubwd:
            return asmjit::x86::Inst::kIdVphsubwd;
        case Mnemonic::Vpinsrb:
            return asmjit::x86::Inst::kIdVpinsrb;
        case Mnemonic::Vpinsrd:
            return asmjit::x86::Inst::kIdVpinsrd;
        case Mnemonic::Vpinsrq:
            return asmjit::x86::Inst::kIdVpinsrq;
        case Mnemonic::Vpinsrw:
            return asmjit::x86::Inst::kIdVpinsrw;
        case Mnemonic::Vplzcntd:
            return asmjit::x86::Inst::kIdVplzcntd;
        case Mnemonic::Vplzcntq:
            return asmjit::x86::Inst::kIdVplzcntq;
        case Mnemonic::Vpmacsdd:
            return asmjit::x86::Inst::kIdVpmacsdd;
        case Mnemonic::Vpmacsdqh:
            return asmjit::x86::Inst::kIdVpmacsdqh;
        case Mnemonic::Vpmacsdql:
            return asmjit::x86::Inst::kIdVpmacsdql;
        case Mnemonic::Vpmacssdd:
            return asmjit::x86::Inst::kIdVpmacssdd;
        case Mnemonic::Vpmacssdqh:
            return asmjit::x86::Inst::kIdVpmacssdqh;
        case Mnemonic::Vpmacssdql:
            return asmjit::x86::Inst::kIdVpmacssdql;
        case Mnemonic::Vpmacsswd:
            return asmjit::x86::Inst::kIdVpmacsswd;
        case Mnemonic::Vpmacssww:
            return asmjit::x86::Inst::kIdVpmacssww;
        case Mnemonic::Vpmacswd:
            return asmjit::x86::Inst::kIdVpmacswd;
        case Mnemonic::Vpmacsww:
            return asmjit::x86::Inst::kIdVpmacsww;
        case Mnemonic::Vpmadcsswd:
            return asmjit::x86::Inst::kIdVpmadcsswd;
        case Mnemonic::Vpmadcswd:
            return asmjit::x86::Inst::kIdVpmadcswd;
        case Mnemonic::Vpmadd52huq:
            return asmjit::x86::Inst::kIdVpmadd52huq;
        case Mnemonic::Vpmadd52luq:
            return asmjit::x86::Inst::kIdVpmadd52luq;
        case Mnemonic::Vpmaddubsw:
            return asmjit::x86::Inst::kIdVpmaddubsw;
        case Mnemonic::Vpmaddwd:
            return asmjit::x86::Inst::kIdVpmaddwd;
        case Mnemonic::Vpmaskmovd:
            return asmjit::x86::Inst::kIdVpmaskmovd;
        case Mnemonic::Vpmaskmovq:
            return asmjit::x86::Inst::kIdVpmaskmovq;
        case Mnemonic::Vpmaxsb:
            return asmjit::x86::Inst::kIdVpmaxsb;
        case Mnemonic::Vpmaxsd:
            return asmjit::x86::Inst::kIdVpmaxsd;
        case Mnemonic::Vpmaxsq:
            return asmjit::x86::Inst::kIdVpmaxsq;
        case Mnemonic::Vpmaxsw:
            return asmjit::x86::Inst::kIdVpmaxsw;
        case Mnemonic::Vpmaxub:
            return asmjit::x86::Inst::kIdVpmaxub;
        case Mnemonic::Vpmaxud:
            return asmjit::x86::Inst::kIdVpmaxud;
        case Mnemonic::Vpmaxuq:
            return asmjit::x86::Inst::kIdVpmaxuq;
        case Mnemonic::Vpmaxuw:
            return asmjit::x86::Inst::kIdVpmaxuw;
        case Mnemonic::Vpminsb:
            return asmjit::x86::Inst::kIdVpminsb;
        case Mnemonic::Vpminsd:
            return asmjit::x86::Inst::kIdVpminsd;
        case Mnemonic::Vpminsq:
            return asmjit::x86::Inst::kIdVpminsq;
        case Mnemonic::Vpminsw:
            return asmjit::x86::Inst::kIdVpminsw;
        case Mnemonic::Vpminub:
            return asmjit::x86::Inst::kIdVpminub;
        case Mnemonic::Vpminud:
            return asmjit::x86::Inst::kIdVpminud;
        case Mnemonic::Vpminuq:
            return asmjit::x86::Inst::kIdVpminuq;
        case Mnemonic::Vpminuw:
            return asmjit::x86::Inst::kIdVpminuw;
        case Mnemonic::Vpmovb2m:
            return asmjit::x86::Inst::kIdVpmovb2m;
        case Mnemonic::Vpmovd2m:
            return asmjit::x86::Inst::kIdVpmovd2m;
        case Mnemonic::Vpmovdb:
            return asmjit::x86::Inst::kIdVpmovdb;
        case Mnemonic::Vpmovdw:
            return asmjit::x86::Inst::kIdVpmovdw;
        case Mnemonic::Vpmovm2b:
            return asmjit::x86::Inst::kIdVpmovm2b;
        case Mnemonic::Vpmovm2d:
            return asmjit::x86::Inst::kIdVpmovm2d;
        case Mnemonic::Vpmovm2q:
            return asmjit::x86::Inst::kIdVpmovm2q;
        case Mnemonic::Vpmovm2w:
            return asmjit::x86::Inst::kIdVpmovm2w;
        case Mnemonic::Vpmovmskb:
            return asmjit::x86::Inst::kIdVpmovmskb;
        case Mnemonic::Vpmovq2m:
            return asmjit::x86::Inst::kIdVpmovq2m;
        case Mnemonic::Vpmovqb:
            return asmjit::x86::Inst::kIdVpmovqb;
        case Mnemonic::Vpmovqd:
            return asmjit::x86::Inst::kIdVpmovqd;
        case Mnemonic::Vpmovqw:
            return asmjit::x86::Inst::kIdVpmovqw;
        case Mnemonic::Vpmovsdb:
            return asmjit::x86::Inst::kIdVpmovsdb;
        case Mnemonic::Vpmovsdw:
            return asmjit::x86::Inst::kIdVpmovsdw;
        case Mnemonic::Vpmovsqb:
            return asmjit::x86::Inst::kIdVpmovsqb;
        case Mnemonic::Vpmovsqd:
            return asmjit::x86::Inst::kIdVpmovsqd;
        case Mnemonic::Vpmovsqw:
            return asmjit::x86::Inst::kIdVpmovsqw;
        case Mnemonic::Vpmovswb:
            return asmjit::x86::Inst::kIdVpmovswb;
        case Mnemonic::Vpmovsxbd:
            return asmjit::x86::Inst::kIdVpmovsxbd;
        case Mnemonic::Vpmovsxbq:
            return asmjit::x86::Inst::kIdVpmovsxbq;
        case Mnemonic::Vpmovsxbw:
            return asmjit::x86::Inst::kIdVpmovsxbw;
        case Mnemonic::Vpmovsxdq:
            return asmjit::x86::Inst::kIdVpmovsxdq;
        case Mnemonic::Vpmovsxwd:
            return asmjit::x86::Inst::kIdVpmovsxwd;
        case Mnemonic::Vpmovsxwq:
            return asmjit::x86::Inst::kIdVpmovsxwq;
        case Mnemonic::Vpmovusdb:
            return asmjit::x86::Inst::kIdVpmovusdb;
        case Mnemonic::Vpmovusdw:
            return asmjit::x86::Inst::kIdVpmovusdw;
        case Mnemonic::Vpmovusqb:
            return asmjit::x86::Inst::kIdVpmovusqb;
        case Mnemonic::Vpmovusqd:
            return asmjit::x86::Inst::kIdVpmovusqd;
        case Mnemonic::Vpmovusqw:
            return asmjit::x86::Inst::kIdVpmovusqw;
        case Mnemonic::Vpmovuswb:
            return asmjit::x86::Inst::kIdVpmovuswb;
        case Mnemonic::Vpmovw2m:
            return asmjit::x86::Inst::kIdVpmovw2m;
        case Mnemonic::Vpmovwb:
            return asmjit::x86::Inst::kIdVpmovwb;
        case Mnemonic::Vpmovzxbd:
            return asmjit::x86::Inst::kIdVpmovzxbd;
        case Mnemonic::Vpmovzxbq:
            return asmjit::x86::Inst::kIdVpmovzxbq;
        case Mnemonic::Vpmovzxbw:
            return asmjit::x86::Inst::kIdVpmovzxbw;
        case Mnemonic::Vpmovzxdq:
            return asmjit::x86::Inst::kIdVpmovzxdq;
        case Mnemonic::Vpmovzxwd:
            return asmjit::x86::Inst::kIdVpmovzxwd;
        case Mnemonic::Vpmovzxwq:
            return asmjit::x86::Inst::kIdVpmovzxwq;
        case Mnemonic::Vpmuldq:
            return asmjit::x86::Inst::kIdVpmuldq;
        case Mnemonic::Vpmulhrsw:
            return asmjit::x86::Inst::kIdVpmulhrsw;
        case Mnemonic::Vpmulhuw:
            return asmjit::x86::Inst::kIdVpmulhuw;
        case Mnemonic::Vpmulhw:
            return asmjit::x86::Inst::kIdVpmulhw;
        case Mnemonic::Vpmulld:
            return asmjit::x86::Inst::kIdVpmulld;
        case Mnemonic::Vpmullq:
            return asmjit::x86::Inst::kIdVpmullq;
        case Mnemonic::Vpmullw:
            return asmjit::x86::Inst::kIdVpmullw;
        case Mnemonic::Vpmultishiftqb:
            return asmjit::x86::Inst::kIdVpmultishiftqb;
        case Mnemonic::Vpmuludq:
            return asmjit::x86::Inst::kIdVpmuludq;
        case Mnemonic::Vpopcntb:
            return asmjit::x86::Inst::kIdVpopcntb;
        case Mnemonic::Vpopcntd:
            return asmjit::x86::Inst::kIdVpopcntd;
        case Mnemonic::Vpopcntq:
            return asmjit::x86::Inst::kIdVpopcntq;
        case Mnemonic::Vpopcntw:
            return asmjit::x86::Inst::kIdVpopcntw;
        case Mnemonic::Vpor:
            return asmjit::x86::Inst::kIdVpor;
        case Mnemonic::Vpord:
            return asmjit::x86::Inst::kIdVpord;
        case Mnemonic::Vporq:
            return asmjit::x86::Inst::kIdVporq;
        case Mnemonic::Vpperm:
            return asmjit::x86::Inst::kIdVpperm;
        case Mnemonic::Vprold:
            return asmjit::x86::Inst::kIdVprold;
        case Mnemonic::Vprolq:
            return asmjit::x86::Inst::kIdVprolq;
        case Mnemonic::Vprolvd:
            return asmjit::x86::Inst::kIdVprolvd;
        case Mnemonic::Vprolvq:
            return asmjit::x86::Inst::kIdVprolvq;
        case Mnemonic::Vprord:
            return asmjit::x86::Inst::kIdVprord;
        case Mnemonic::Vprorq:
            return asmjit::x86::Inst::kIdVprorq;
        case Mnemonic::Vprorvd:
            return asmjit::x86::Inst::kIdVprorvd;
        case Mnemonic::Vprorvq:
            return asmjit::x86::Inst::kIdVprorvq;
        case Mnemonic::Vprotb:
            return asmjit::x86::Inst::kIdVprotb;
        case Mnemonic::Vprotd:
            return asmjit::x86::Inst::kIdVprotd;
        case Mnemonic::Vprotq:
            return asmjit::x86::Inst::kIdVprotq;
        case Mnemonic::Vprotw:
            return asmjit::x86::Inst::kIdVprotw;
        case Mnemonic::Vpsadbw:
            return asmjit::x86::Inst::kIdVpsadbw;
        case Mnemonic::Vpscatterdd:
            return asmjit::x86::Inst::kIdVpscatterdd;
        case Mnemonic::Vpscatterdq:
            return asmjit::x86::Inst::kIdVpscatterdq;
        case Mnemonic::Vpscatterqd:
            return asmjit::x86::Inst::kIdVpscatterqd;
        case Mnemonic::Vpscatterqq:
            return asmjit::x86::Inst::kIdVpscatterqq;
        case Mnemonic::Vpshab:
            return asmjit::x86::Inst::kIdVpshab;
        case Mnemonic::Vpshad:
            return asmjit::x86::Inst::kIdVpshad;
        case Mnemonic::Vpshaq:
            return asmjit::x86::Inst::kIdVpshaq;
        case Mnemonic::Vpshaw:
            return asmjit::x86::Inst::kIdVpshaw;
        case Mnemonic::Vpshlb:
            return asmjit::x86::Inst::kIdVpshlb;
        case Mnemonic::Vpshld:
            return asmjit::x86::Inst::kIdVpshld;
        case Mnemonic::Vpshldd:
            return asmjit::x86::Inst::kIdVpshldd;
        case Mnemonic::Vpshldq:
            return asmjit::x86::Inst::kIdVpshldq;
        case Mnemonic::Vpshldvd:
            return asmjit::x86::Inst::kIdVpshldvd;
        case Mnemonic::Vpshldvq:
            return asmjit::x86::Inst::kIdVpshldvq;
        case Mnemonic::Vpshldvw:
            return asmjit::x86::Inst::kIdVpshldvw;
        case Mnemonic::Vpshldw:
            return asmjit::x86::Inst::kIdVpshldw;
        case Mnemonic::Vpshlq:
            return asmjit::x86::Inst::kIdVpshlq;
        case Mnemonic::Vpshlw:
            return asmjit::x86::Inst::kIdVpshlw;
        case Mnemonic::Vpshrdd:
            return asmjit::x86::Inst::kIdVpshrdd;
        case Mnemonic::Vpshrdq:
            return asmjit::x86::Inst::kIdVpshrdq;
        case Mnemonic::Vpshrdvd:
            return asmjit::x86::Inst::kIdVpshrdvd;
        case Mnemonic::Vpshrdvq:
            return asmjit::x86::Inst::kIdVpshrdvq;
        case Mnemonic::Vpshrdvw:
            return asmjit::x86::Inst::kIdVpshrdvw;
        case Mnemonic::Vpshrdw:
            return asmjit::x86::Inst::kIdVpshrdw;
        case Mnemonic::Vpshufb:
            return asmjit::x86::Inst::kIdVpshufb;
        case Mnemonic::Vpshufbitqmb:
            return asmjit::x86::Inst::kIdVpshufbitqmb;
        case Mnemonic::Vpshufd:
            return asmjit::x86::Inst::kIdVpshufd;
        case Mnemonic::Vpshufhw:
            return asmjit::x86::Inst::kIdVpshufhw;
        case Mnemonic::Vpshuflw:
            return asmjit::x86::Inst::kIdVpshuflw;
        case Mnemonic::Vpsignb:
            return asmjit::x86::Inst::kIdVpsignb;
        case Mnemonic::Vpsignd:
            return asmjit::x86::Inst::kIdVpsignd;
        case Mnemonic::Vpsignw:
            return asmjit::x86::Inst::kIdVpsignw;
        case Mnemonic::Vpslld:
            return asmjit::x86::Inst::kIdVpslld;
        case Mnemonic::Vpslldq:
            return asmjit::x86::Inst::kIdVpslldq;
        case Mnemonic::Vpsllq:
            return asmjit::x86::Inst::kIdVpsllq;
        case Mnemonic::Vpsllvd:
            return asmjit::x86::Inst::kIdVpsllvd;
        case Mnemonic::Vpsllvq:
            return asmjit::x86::Inst::kIdVpsllvq;
        case Mnemonic::Vpsllvw:
            return asmjit::x86::Inst::kIdVpsllvw;
        case Mnemonic::Vpsllw:
            return asmjit::x86::Inst::kIdVpsllw;
        case Mnemonic::Vpsrad:
            return asmjit::x86::Inst::kIdVpsrad;
        case Mnemonic::Vpsraq:
            return asmjit::x86::Inst::kIdVpsraq;
        case Mnemonic::Vpsravd:
            return asmjit::x86::Inst::kIdVpsravd;
        case Mnemonic::Vpsravq:
            return asmjit::x86::Inst::kIdVpsravq;
        case Mnemonic::Vpsravw:
            return asmjit::x86::Inst::kIdVpsravw;
        case Mnemonic::Vpsraw:
            return asmjit::x86::Inst::kIdVpsraw;
        case Mnemonic::Vpsrld:
            return asmjit::x86::Inst::kIdVpsrld;
        case Mnemonic::Vpsrldq:
            return asmjit::x86::Inst::kIdVpsrldq;
        case Mnemonic::Vpsrlq:
            return asmjit::x86::Inst::kIdVpsrlq;
        case Mnemonic::Vpsrlvd:
            return asmjit::x86::Inst::kIdVpsrlvd;
        case Mnemonic::Vpsrlvq:
            return asmjit::x86::Inst::kIdVpsrlvq;
        case Mnemonic::Vpsrlvw:
            return asmjit::x86::Inst::kIdVpsrlvw;
        case Mnemonic::Vpsrlw:
            return asmjit::x86::Inst::kIdVpsrlw;
        case Mnemonic::Vpsubb:
            return asmjit::x86::Inst::kIdVpsubb;
        case Mnemonic::Vpsubd:
            return asmjit::x86::Inst::kIdVpsubd;
        case Mnemonic::Vpsubq:
            return asmjit::x86::Inst::kIdVpsubq;
        case Mnemonic::Vpsubsb:
            return asmjit::x86::Inst::kIdVpsubsb;
        case Mnemonic::Vpsubsw:
            return asmjit::x86::Inst::kIdVpsubsw;
        case Mnemonic::Vpsubusb:
            return asmjit::x86::Inst::kIdVpsubusb;
        case Mnemonic::Vpsubusw:
            return asmjit::x86::Inst::kIdVpsubusw;
        case Mnemonic::Vpsubw:
            return asmjit::x86::Inst::kIdVpsubw;
        case Mnemonic::Vpternlogd:
            return asmjit::x86::Inst::kIdVpternlogd;
        case Mnemonic::Vpternlogq:
            return asmjit::x86::Inst::kIdVpternlogq;
        case Mnemonic::Vptest:
            return asmjit::x86::Inst::kIdVptest;
        case Mnemonic::Vptestmb:
            return asmjit::x86::Inst::kIdVptestmb;
        case Mnemonic::Vptestmd:
            return asmjit::x86::Inst::kIdVptestmd;
        case Mnemonic::Vptestmq:
            return asmjit::x86::Inst::kIdVptestmq;
        case Mnemonic::Vptestmw:
            return asmjit::x86::Inst::kIdVptestmw;
        case Mnemonic::Vptestnmb:
            return asmjit::x86::Inst::kIdVptestnmb;
        case Mnemonic::Vptestnmd:
            return asmjit::x86::Inst::kIdVptestnmd;
        case Mnemonic::Vptestnmq:
            return asmjit::x86::Inst::kIdVptestnmq;
        case Mnemonic::Vptestnmw:
            return asmjit::x86::Inst::kIdVptestnmw;
        case Mnemonic::Vpunpckhbw:
            return asmjit::x86::Inst::kIdVpunpckhbw;
        case Mnemonic::Vpunpckhdq:
            return asmjit::x86::Inst::kIdVpunpckhdq;
        case Mnemonic::Vpunpckhqdq:
            return asmjit::x86::Inst::kIdVpunpckhqdq;
        case Mnemonic::Vpunpckhwd:
            return asmjit::x86::Inst::kIdVpunpckhwd;
        case Mnemonic::Vpunpcklbw:
            return asmjit::x86::Inst::kIdVpunpcklbw;
        case Mnemonic::Vpunpckldq:
            return asmjit::x86::Inst::kIdVpunpckldq;
        case Mnemonic::Vpunpcklqdq:
            return asmjit::x86::Inst::kIdVpunpcklqdq;
        case Mnemonic::Vpunpcklwd:
            return asmjit::x86::Inst::kIdVpunpcklwd;
        case Mnemonic::Vpxor:
            return asmjit::x86::Inst::kIdVpxor;
        case Mnemonic::Vpxord:
            return asmjit::x86::Inst::kIdVpxord;
        case Mnemonic::Vpxorq:
            return asmjit::x86::Inst::kIdVpxorq;
        case Mnemonic::Vrangepd:
            return asmjit::x86::Inst::kIdVrangepd;
        case Mnemonic::Vrangeps:
            return asmjit::x86::Inst::kIdVrangeps;
        case Mnemonic::Vrangesd:
            return asmjit::x86::Inst::kIdVrangesd;
        case Mnemonic::Vrangess:
            return asmjit::x86::Inst::kIdVrangess;
        case Mnemonic::Vrcp14pd:
            return asmjit::x86::Inst::kIdVrcp14pd;
        case Mnemonic::Vrcp14ps:
            return asmjit::x86::Inst::kIdVrcp14ps;
        case Mnemonic::Vrcp14sd:
            return asmjit::x86::Inst::kIdVrcp14sd;
        case Mnemonic::Vrcp14ss:
            return asmjit::x86::Inst::kIdVrcp14ss;
        case Mnemonic::Vrcp28pd:
            return asmjit::x86::Inst::kIdVrcp28pd;
        case Mnemonic::Vrcp28ps:
            return asmjit::x86::Inst::kIdVrcp28ps;
        case Mnemonic::Vrcp28sd:
            return asmjit::x86::Inst::kIdVrcp28sd;
        case Mnemonic::Vrcp28ss:
            return asmjit::x86::Inst::kIdVrcp28ss;
        case Mnemonic::Vrcpps:
            return asmjit::x86::Inst::kIdVrcpps;
        case Mnemonic::Vrcpss:
            return asmjit::x86::Inst::kIdVrcpss;
        case Mnemonic::Vreducepd:
            return asmjit::x86::Inst::kIdVreducepd;
        case Mnemonic::Vreduceps:
            return asmjit::x86::Inst::kIdVreduceps;
        case Mnemonic::Vreducesd:
            return asmjit::x86::Inst::kIdVreducesd;
        case Mnemonic::Vreducess:
            return asmjit::x86::Inst::kIdVreducess;
        case Mnemonic::Vrndscalepd:
            return asmjit::x86::Inst::kIdVrndscalepd;
        case Mnemonic::Vrndscaleps:
            return asmjit::x86::Inst::kIdVrndscaleps;
        case Mnemonic::Vrndscalesd:
            return asmjit::x86::Inst::kIdVrndscalesd;
        case Mnemonic::Vrndscaless:
            return asmjit::x86::Inst::kIdVrndscaless;
        case Mnemonic::Vroundpd:
            return asmjit::x86::Inst::kIdVroundpd;
        case Mnemonic::Vroundps:
            return asmjit::x86::Inst::kIdVroundps;
        case Mnemonic::Vroundsd:
            return asmjit::x86::Inst::kIdVroundsd;
        case Mnemonic::Vroundss:
            return asmjit::x86::Inst::kIdVroundss;
        case Mnemonic::Vrsqrt14pd:
            return asmjit::x86::Inst::kIdVrsqrt14pd;
        case Mnemonic::Vrsqrt14ps:
            return asmjit::x86::Inst::kIdVrsqrt14ps;
        case Mnemonic::Vrsqrt14sd:
            return asmjit::x86::Inst::kIdVrsqrt14sd;
        case Mnemonic::Vrsqrt14ss:
            return asmjit::x86::Inst::kIdVrsqrt14ss;
        case Mnemonic::Vrsqrt28pd:
            return asmjit::x86::Inst::kIdVrsqrt28pd;
        case Mnemonic::Vrsqrt28ps:
            return asmjit::x86::Inst::kIdVrsqrt28ps;
        case Mnemonic::Vrsqrt28sd:
            return asmjit::x86::Inst::kIdVrsqrt28sd;
        case Mnemonic::Vrsqrt28ss:
            return asmjit::x86::Inst::kIdVrsqrt28ss;
        case Mnemonic::Vrsqrtps:
            return asmjit::x86::Inst::kIdVrsqrtps;
        case Mnemonic::Vrsqrtss:
            return asmjit::x86::Inst::kIdVrsqrtss;
        case Mnemonic::Vscalefpd:
            return asmjit::x86::Inst::kIdVscalefpd;
        case Mnemonic::Vscalefps:
            return asmjit::x86::Inst::kIdVscalefps;
        case Mnemonic::Vscalefsd:
            return asmjit::x86::Inst::kIdVscalefsd;
        case Mnemonic::Vscalefss:
            return asmjit::x86::Inst::kIdVscalefss;
        case Mnemonic::Vscatterdpd:
            return asmjit::x86::Inst::kIdVscatterdpd;
        case Mnemonic::Vscatterdps:
            return asmjit::x86::Inst::kIdVscatterdps;
        case Mnemonic::Vscatterpf0dpd:
            return asmjit::x86::Inst::kIdVscatterpf0dpd;
        case Mnemonic::Vscatterpf0dps:
            return asmjit::x86::Inst::kIdVscatterpf0dps;
        case Mnemonic::Vscatterpf0qpd:
            return asmjit::x86::Inst::kIdVscatterpf0qpd;
        case Mnemonic::Vscatterpf0qps:
            return asmjit::x86::Inst::kIdVscatterpf0qps;
        case Mnemonic::Vscatterpf1dpd:
            return asmjit::x86::Inst::kIdVscatterpf1dpd;
        case Mnemonic::Vscatterpf1dps:
            return asmjit::x86::Inst::kIdVscatterpf1dps;
        case Mnemonic::Vscatterpf1qpd:
            return asmjit::x86::Inst::kIdVscatterpf1qpd;
        case Mnemonic::Vscatterpf1qps:
            return asmjit::x86::Inst::kIdVscatterpf1qps;
        case Mnemonic::Vscatterqpd:
            return asmjit::x86::Inst::kIdVscatterqpd;
        case Mnemonic::Vscatterqps:
            return asmjit::x86::Inst::kIdVscatterqps;
        case Mnemonic::Vshuff32x4:
            return asmjit::x86::Inst::kIdVshuff32x4;
        case Mnemonic::Vshuff64x2:
            return asmjit::x86::Inst::kIdVshuff64x2;
        case Mnemonic::Vshufi32x4:
            return asmjit::x86::Inst::kIdVshufi32x4;
        case Mnemonic::Vshufi64x2:
            return asmjit::x86::Inst::kIdVshufi64x2;
        case Mnemonic::Vshufpd:
            return asmjit::x86::Inst::kIdVshufpd;
        case Mnemonic::Vshufps:
            return asmjit::x86::Inst::kIdVshufps;
        case Mnemonic::Vsqrtpd:
            return asmjit::x86::Inst::kIdVsqrtpd;
        case Mnemonic::Vsqrtps:
            return asmjit::x86::Inst::kIdVsqrtps;
        case Mnemonic::Vsqrtsd:
            return asmjit::x86::Inst::kIdVsqrtsd;
        case Mnemonic::Vsqrtss:
            return asmjit::x86::Inst::kIdVsqrtss;
        case Mnemonic::Vstmxcsr:
            return asmjit::x86::Inst::kIdVstmxcsr;
        case Mnemonic::Vsubpd:
            return asmjit::x86::Inst::kIdVsubpd;
        case Mnemonic::Vsubps:
            return asmjit::x86::Inst::kIdVsubps;
        case Mnemonic::Vsubsd:
            return asmjit::x86::Inst::kIdVsubsd;
        case Mnemonic::Vsubss:
            return asmjit::x86::Inst::kIdVsubss;
        case Mnemonic::Vtestpd:
            return asmjit::x86::Inst::kIdVtestpd;
        case Mnemonic::Vtestps:
            return asmjit::x86::Inst::kIdVtestps;
        case Mnemonic::Vucomisd:
            return asmjit::x86::Inst::kIdVucomisd;
        case Mnemonic::Vucomiss:
            return asmjit::x86::Inst::kIdVucomiss;
        case Mnemonic::Vunpckhpd:
            return asmjit::x86::Inst::kIdVunpckhpd;
        case Mnemonic::Vunpckhps:
            return asmjit::x86::Inst::kIdVunpckhps;
        case Mnemonic::Vunpcklpd:
            return asmjit::x86::Inst::kIdVunpcklpd;
        case Mnemonic::Vunpcklps:
            return asmjit::x86::Inst::kIdVunpcklps;
        case Mnemonic::Vxorpd:
            return asmjit::x86::Inst::kIdVxorpd;
        case Mnemonic::Vxorps:
            return asmjit::x86::Inst::kIdVxorps;
        case Mnemonic::Vzeroall:
            return asmjit::x86::Inst::kIdVzeroall;
        case Mnemonic::Vzeroupper:
            return asmjit::x86::Inst::kIdVzeroupper;
        case Mnemonic::Wbinvd:
            return asmjit::x86::Inst::kIdWbinvd;
        case Mnemonic::Wrfsbase:
            return asmjit::x86::Inst::kIdWrfsbase;
        case Mnemonic::Wrgsbase:
            return asmjit::x86::Inst::kIdWrgsbase;
        case Mnemonic::Wrmsr:
            return asmjit::x86::Inst::kIdWrmsr;
        case Mnemonic::Xabort:
            return asmjit::x86::Inst::kIdXabort;
        case Mnemonic::Xadd:
            return asmjit::x86::Inst::kIdXadd;
        case Mnemonic::Xbegin:
            return asmjit::x86::Inst::kIdXbegin;
        case Mnemonic::Xchg:
            return asmjit::x86::Inst::kIdXchg;
        case Mnemonic::Xend:
            return asmjit::x86::Inst::kIdXend;
        case Mnemonic::Xgetbv:
            return asmjit::x86::Inst::kIdXgetbv;
        case Mnemonic::Xlat:
            return asmjit::x86::Inst::kIdXlatb;
        case Mnemonic::Xor:
            return asmjit::x86::Inst::kIdXor;
        case Mnemonic::Xorpd:
            return asmjit::x86::Inst::kIdXorpd;
        case Mnemonic::Xorps:
            return asmjit::x86::Inst::kIdXorps;
        case Mnemonic::Xrstor:
            return asmjit::x86::Inst::kIdXrstor;
        case Mnemonic::Xrstor64:
            return asmjit::x86::Inst::kIdXrstor64;
        case Mnemonic::Xrstors:
            return asmjit::x86::Inst::kIdXrstors;
        case Mnemonic::Xrstors64:
            return asmjit::x86::Inst::kIdXrstors64;
        case Mnemonic::Xsave:
            return asmjit::x86::Inst::kIdXsave;
        case Mnemonic::Xsave64:
            return asmjit::x86::Inst::kIdXsave64;
        case Mnemonic::Xsavec:
            return asmjit::x86::Inst::kIdXsavec;
        case Mnemonic::Xsavec64:
            return asmjit::x86::Inst::kIdXsavec64;
        case Mnemonic::Xsaveopt:
            return asmjit::x86::Inst::kIdXsaveopt;
        case Mnemonic::Xsaveopt64:
            return asmjit::x86::Inst::kIdXsaveopt64;
        case Mnemonic::Xsaves:
            return asmjit::x86::Inst::kIdXsaves;
        case Mnemonic::Xsaves64:
            return asmjit::x86::Inst::kIdXsaves64;
        case Mnemonic::Xsetbv:
            return asmjit::x86::Inst::kIdXsetbv;
        case Mnemonic::Xtest:
            return asmjit::x86::Inst::kIdXtest;
        case Mnemonic::Jrcxz:
            return asmjit::x86::Inst::kIdJecxz;
        case Mnemonic::Jcxz:
            return asmjit::x86::Inst::kIdJecxz;
        case Mnemonic::Stgi:
            return asmjit::x86::Inst::kIdStgi;
        default:
            __debugbreak();
        }
        return 0;
    }

    inline asmjit::x86::Reg convertAsmJitRegister(const Registers::Id reg)
    {
        switch (reg)
        {
        case Registers::Id::None:
            return {};
            // Segment registers
        case Registers::Id::Es:
            return asmjit::x86::es;
        case Registers::Id::Cs:
            return asmjit::x86::cs;
        case Registers::Id::Ss:
            return asmjit::x86::ss;
        case Registers::Id::Ds:
            return asmjit::x86::ds;
        case Registers::Id::Fs:
            return asmjit::x86::fs;
        case Registers::Id::Gs:
            return asmjit::x86::gs;
            // General purpose registers  8-bit
        case Registers::Id::Al:
            return asmjit::x86::al;
        case Registers::Id::Cl:
            return asmjit::x86::cl;
        case Registers::Id::Dl:
            return asmjit::x86::dl;
        case Registers::Id::Bl:
            return asmjit::x86::bl;
        case Registers::Id::Ah:
            return asmjit::x86::ah;
        case Registers::Id::Ch:
            return asmjit::x86::ch;
        case Registers::Id::Dh:
            return asmjit::x86::dh;
        case Registers::Id::Bh:
            return asmjit::x86::bh;
        case Registers::Id::Spl:
            return asmjit::x86::spl;
        case Registers::Id::Bpl:
            return asmjit::x86::bpl;
        case Registers::Id::Sil:
            return asmjit::x86::sil;
        case Registers::Id::Dil:
            return asmjit::x86::dil;
        case Registers::Id::R8b:
            return asmjit::x86::r8b;
        case Registers::Id::R9b:
            return asmjit::x86::r9b;
        case Registers::Id::R10b:
            return asmjit::x86::r10b;
        case Registers::Id::R11b:
            return asmjit::x86::r11b;
        case Registers::Id::R12b:
            return asmjit::x86::r12b;
        case Registers::Id::R13b:
            return asmjit::x86::r13b;
        case Registers::Id::R14b:
            return asmjit::x86::r14b;
        case Registers::Id::R15b:
            return asmjit::x86::r15b;
            // General purpose registers 16-bit
        case Registers::Id::Ax:
            return asmjit::x86::ax;
        case Registers::Id::Cx:
            return asmjit::x86::cx;
        case Registers::Id::Dx:
            return asmjit::x86::dx;
        case Registers::Id::Bx:
            return asmjit::x86::bx;
        case Registers::Id::Sp:
            return asmjit::x86::sp;
        case Registers::Id::Bp:
            return asmjit::x86::bp;
        case Registers::Id::Si:
            return asmjit::x86::si;
        case Registers::Id::Di:
            return asmjit::x86::di;
        case Registers::Id::R8w:
            return asmjit::x86::r8w;
        case Registers::Id::R9w:
            return asmjit::x86::r9w;
        case Registers::Id::R10w:
            return asmjit::x86::r10w;
        case Registers::Id::R11w:
            return asmjit::x86::r11w;
        case Registers::Id::R12w:
            return asmjit::x86::r12w;
        case Registers::Id::R13w:
            return asmjit::x86::r13w;
        case Registers::Id::R14w:
            return asmjit::x86::r14w;
        case Registers::Id::R15w:
            return asmjit::x86::r15w;
            // General purpose registers 32-bit
        case Registers::Id::Eax:
            return asmjit::x86::eax;
        case Registers::Id::Ecx:
            return asmjit::x86::ecx;
        case Registers::Id::Edx:
            return asmjit::x86::edx;
        case Registers::Id::Ebx:
            return asmjit::x86::ebx;
        case Registers::Id::Esp:
            return asmjit::x86::esp;
        case Registers::Id::Ebp:
            return asmjit::x86::ebp;
        case Registers::Id::Esi:
            return asmjit::x86::esi;
        case Registers::Id::Edi:
            return asmjit::x86::edi;
        case Registers::Id::R8d:
            return asmjit::x86::r8d;
        case Registers::Id::R9d:
            return asmjit::x86::r9d;
        case Registers::Id::R10d:
            return asmjit::x86::r10d;
        case Registers::Id::R11d:
            return asmjit::x86::r11d;
        case Registers::Id::R12d:
            return asmjit::x86::r12d;
        case Registers::Id::R13d:
            return asmjit::x86::r13d;
        case Registers::Id::R14d:
            return asmjit::x86::r14d;
        case Registers::Id::R15d:
            return asmjit::x86::r15d;
            // General purpose registers 64-bit
        case Registers::Id::Rax:
            return asmjit::x86::rax;
        case Registers::Id::Rcx:
            return asmjit::x86::rcx;
        case Registers::Id::Rdx:
            return asmjit::x86::rdx;
        case Registers::Id::Rbx:
            return asmjit::x86::rbx;
        case Registers::Id::Rsp:
            return asmjit::x86::rsp;
        case Registers::Id::Rbp:
            return asmjit::x86::rbp;
        case Registers::Id::Rsi:
            return asmjit::x86::rsi;
        case Registers::Id::Rdi:
            return asmjit::x86::rdi;
        case Registers::Id::R8:
            return asmjit::x86::r8;
        case Registers::Id::R9:
            return asmjit::x86::r9;
        case Registers::Id::R10:
            return asmjit::x86::r10;
        case Registers::Id::R11:
            return asmjit::x86::r11;
        case Registers::Id::R12:
            return asmjit::x86::r12;
        case Registers::Id::R13:
            return asmjit::x86::r13;
        case Registers::Id::R14:
            return asmjit::x86::r14;
        case Registers::Id::R15:
            return asmjit::x86::r15;
            // Floating point legacy registers
        case Registers::Id::St0:
            return asmjit::x86::st0;
        case Registers::Id::St1:
            return asmjit::x86::st1;
        case Registers::Id::St2:
            return asmjit::x86::st2;
        case Registers::Id::St3:
            return asmjit::x86::st3;
        case Registers::Id::St4:
            return asmjit::x86::st4;
        case Registers::Id::St5:
            return asmjit::x86::st5;
        case Registers::Id::St6:
            return asmjit::x86::st6;
        case Registers::Id::St7:
            return asmjit::x86::st7;
            // Floating point multimedia registers
        case Registers::Id::Mm0:
            return asmjit::x86::mm0;
        case Registers::Id::Mm1:
            return asmjit::x86::mm1;
        case Registers::Id::Mm2:
            return asmjit::x86::mm2;
        case Registers::Id::Mm3:
            return asmjit::x86::mm3;
        case Registers::Id::Mm4:
            return asmjit::x86::mm4;
        case Registers::Id::Mm5:
            return asmjit::x86::mm5;
        case Registers::Id::Mm6:
            return asmjit::x86::mm6;
        case Registers::Id::Mm7:
            return asmjit::x86::mm7;
            // Floating point vector registers 128-bit
        case Registers::Id::Xmm0:
            return asmjit::x86::xmm0;
        case Registers::Id::Xmm1:
            return asmjit::x86::xmm1;
        case Registers::Id::Xmm2:
            return asmjit::x86::xmm2;
        case Registers::Id::Xmm3:
            return asmjit::x86::xmm3;
        case Registers::Id::Xmm4:
            return asmjit::x86::xmm4;
        case Registers::Id::Xmm5:
            return asmjit::x86::xmm5;
        case Registers::Id::Xmm6:
            return asmjit::x86::xmm6;
        case Registers::Id::Xmm7:
            return asmjit::x86::xmm7;
        case Registers::Id::Xmm8:
            return asmjit::x86::xmm8;
        case Registers::Id::Xmm9:
            return asmjit::x86::xmm9;
        case Registers::Id::Xmm10:
            return asmjit::x86::xmm10;
        case Registers::Id::Xmm11:
            return asmjit::x86::xmm11;
        case Registers::Id::Xmm12:
            return asmjit::x86::xmm12;
        case Registers::Id::Xmm13:
            return asmjit::x86::xmm13;
        case Registers::Id::Xmm14:
            return asmjit::x86::xmm14;
        case Registers::Id::Xmm15:
            return asmjit::x86::xmm15;
        case Registers::Id::Xmm16:
            return asmjit::x86::xmm16;
        case Registers::Id::Xmm17:
            return asmjit::x86::xmm17;
        case Registers::Id::Xmm18:
            return asmjit::x86::xmm18;
        case Registers::Id::Xmm19:
            return asmjit::x86::xmm19;
        case Registers::Id::Xmm20:
            return asmjit::x86::xmm20;
        case Registers::Id::Xmm21:
            return asmjit::x86::xmm21;
        case Registers::Id::Xmm22:
            return asmjit::x86::xmm22;
        case Registers::Id::Xmm23:
            return asmjit::x86::xmm23;
        case Registers::Id::Xmm24:
            return asmjit::x86::xmm24;
        case Registers::Id::Xmm25:
            return asmjit::x86::xmm25;
        case Registers::Id::Xmm26:
            return asmjit::x86::xmm26;
        case Registers::Id::Xmm27:
            return asmjit::x86::xmm27;
        case Registers::Id::Xmm28:
            return asmjit::x86::xmm28;
        case Registers::Id::Xmm29:
            return asmjit::x86::xmm29;
        case Registers::Id::Xmm30:
            return asmjit::x86::xmm30;
        case Registers::Id::Xmm31:
            return asmjit::x86::xmm31;
            // Floating point vector registers 256-bit
        case Registers::Id::Ymm0:
            return asmjit::x86::ymm0;
        case Registers::Id::Ymm1:
            return asmjit::x86::ymm1;
        case Registers::Id::Ymm2:
            return asmjit::x86::ymm2;
        case Registers::Id::Ymm3:
            return asmjit::x86::ymm3;
        case Registers::Id::Ymm4:
            return asmjit::x86::ymm4;
        case Registers::Id::Ymm5:
            return asmjit::x86::ymm5;
        case Registers::Id::Ymm6:
            return asmjit::x86::ymm6;
        case Registers::Id::Ymm7:
            return asmjit::x86::ymm7;
        case Registers::Id::Ymm8:
            return asmjit::x86::ymm8;
        case Registers::Id::Ymm9:
            return asmjit::x86::ymm9;
        case Registers::Id::Ymm10:
            return asmjit::x86::ymm10;
        case Registers::Id::Ymm11:
            return asmjit::x86::ymm11;
        case Registers::Id::Ymm12:
            return asmjit::x86::ymm12;
        case Registers::Id::Ymm13:
            return asmjit::x86::ymm13;
        case Registers::Id::Ymm14:
            return asmjit::x86::ymm14;
        case Registers::Id::Ymm15:
            return asmjit::x86::ymm15;
        case Registers::Id::Ymm16:
            return asmjit::x86::ymm16;
        case Registers::Id::Ymm17:
            return asmjit::x86::ymm17;
        case Registers::Id::Ymm18:
            return asmjit::x86::ymm18;
        case Registers::Id::Ymm19:
            return asmjit::x86::ymm19;
        case Registers::Id::Ymm20:
            return asmjit::x86::ymm20;
        case Registers::Id::Ymm21:
            return asmjit::x86::ymm21;
        case Registers::Id::Ymm22:
            return asmjit::x86::ymm22;
        case Registers::Id::Ymm23:
            return asmjit::x86::ymm23;
        case Registers::Id::Ymm24:
            return asmjit::x86::ymm24;
        case Registers::Id::Ymm25:
            return asmjit::x86::ymm25;
        case Registers::Id::Ymm26:
            return asmjit::x86::ymm26;
        case Registers::Id::Ymm27:
            return asmjit::x86::ymm27;
        case Registers::Id::Ymm28:
            return asmjit::x86::ymm28;
        case Registers::Id::Ymm29:
            return asmjit::x86::ymm29;
        case Registers::Id::Ymm30:
            return asmjit::x86::ymm30;
        case Registers::Id::Ymm31:
            return asmjit::x86::ymm31;
            // Floating point vector registers 512-bit
        case Registers::Id::Zmm0:
            return asmjit::x86::zmm0;
        case Registers::Id::Zmm1:
            return asmjit::x86::zmm1;
        case Registers::Id::Zmm2:
            return asmjit::x86::zmm2;
        case Registers::Id::Zmm3:
            return asmjit::x86::zmm3;
        case Registers::Id::Zmm4:
            return asmjit::x86::zmm4;
        case Registers::Id::Zmm5:
            return asmjit::x86::zmm5;
        case Registers::Id::Zmm6:
            return asmjit::x86::zmm6;
        case Registers::Id::Zmm7:
            return asmjit::x86::zmm7;
        case Registers::Id::Zmm8:
            return asmjit::x86::zmm8;
        case Registers::Id::Zmm9:
            return asmjit::x86::zmm9;
        case Registers::Id::Zmm10:
            return asmjit::x86::zmm10;
        case Registers::Id::Zmm11:
            return asmjit::x86::zmm11;
        case Registers::Id::Zmm12:
            return asmjit::x86::zmm12;
        case Registers::Id::Zmm13:
            return asmjit::x86::zmm13;
        case Registers::Id::Zmm14:
            return asmjit::x86::zmm14;
        case Registers::Id::Zmm15:
            return asmjit::x86::zmm15;
        case Registers::Id::Zmm16:
            return asmjit::x86::zmm16;
        case Registers::Id::Zmm17:
            return asmjit::x86::zmm17;
        case Registers::Id::Zmm18:
            return asmjit::x86::zmm18;
        case Registers::Id::Zmm19:
            return asmjit::x86::zmm19;
        case Registers::Id::Zmm20:
            return asmjit::x86::zmm20;
        case Registers::Id::Zmm21:
            return asmjit::x86::zmm21;
        case Registers::Id::Zmm22:
            return asmjit::x86::zmm22;
        case Registers::Id::Zmm23:
            return asmjit::x86::zmm23;
        case Registers::Id::Zmm24:
            return asmjit::x86::zmm24;
        case Registers::Id::Zmm25:
            return asmjit::x86::zmm25;
        case Registers::Id::Zmm26:
            return asmjit::x86::zmm26;
        case Registers::Id::Zmm27:
            return asmjit::x86::zmm27;
        case Registers::Id::Zmm28:
            return asmjit::x86::zmm28;
        case Registers::Id::Zmm29:
            return asmjit::x86::zmm29;
        case Registers::Id::Zmm30:
            return asmjit::x86::zmm30;
        case Registers::Id::Zmm31:
            return asmjit::x86::zmm31;
        case Registers::Id::Cr0:
            return asmjit::x86::cr0;
        case Registers::Id::Cr1:
            return asmjit::x86::cr1;
        case Registers::Id::Cr2:
            return asmjit::x86::cr2;
        case Registers::Id::Cr3:
            return asmjit::x86::cr3;
        case Registers::Id::Cr4:
            return asmjit::x86::cr4;
        case Registers::Id::Cr5:
            return asmjit::x86::cr5;
        case Registers::Id::Cr6:
            return asmjit::x86::cr6;
        case Registers::Id::Cr7:
            return asmjit::x86::cr7;
        case Registers::Id::Cr8:
            return asmjit::x86::cr8;
        case Registers::Id::Cr9:
            return asmjit::x86::cr9;
        case Registers::Id::Cr10:
            return asmjit::x86::cr10;
        case Registers::Id::Cr11:
            return asmjit::x86::cr11;
        case Registers::Id::Cr12:
            return asmjit::x86::cr12;
        case Registers::Id::Cr13:
            return asmjit::x86::cr13;
        case Registers::Id::Cr14:
            return asmjit::x86::cr14;
        case Registers::Id::Cr15:
            return asmjit::x86::cr15;
        case Registers::Id::Idtr:
            // Not mappable.
            return {};
            // NOTE: AsmJit might handle this differently.
        case Registers::Id::Ip:
        case Registers::Id::Eip:
        case Registers::Id::Rip:
            return asmjit::x86::rip;
        case Registers::Id::Tr:
        case Registers::Id::Tr0:
        case Registers::Id::Tr1:
        case Registers::Id::Tr2:
        case Registers::Id::Tr3:
        case Registers::Id::Tr4:
        case Registers::Id::Tr5:
        case Registers::Id::Tr6:
        case Registers::Id::Tr7:
            return {};
        }

        // Bug?
        __debugbreak();
        return asmjit::x86::Reg();
    }

} // namespace Dotx64Dbg

```

`src/Bindings/Expressions.cpp`:

```cpp
#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_misc.h"
#include "pluginsdk/_dbgfunctions.h"

#include "Marshal.hpp"

using namespace System;
using namespace System::Runtime::InteropServices;

namespace Dotx64Dbg::Native
{
    [UnmanagedFunctionPointer(CallingConvention::Cdecl)]
    public delegate System::UIntPtr ExpressionHandler(int argc, System::IntPtr, System::IntPtr);

    public ref class Expressions
    {
    public:
        static bool TryEvaluate(System::String^ expr, [Out] IntPtr% value)
        {
            auto exprStr = interop::toUTF8(expr);

            duint val = 0;
            bool res = Script::Misc::ParseExpression(exprStr.c_str(), &val);

#ifdef _WIN64
            value = IntPtr((long long)val);
#else
            value = IntPtr((int)val);
#endif
            return res;
        }

        static System::IntPtr Evaluate(System::String^ expr)
        {
            IntPtr res = IntPtr(0);
            if (!TryEvaluate(expr, res))
            {
                throw gcnew System::Exception("Invalid expression");
            }
            return res;
        }

        static bool TryFormat(System::String^ expr, [Out] System::String^% value)
        {
            if (!DbgFunctions()->StringFormatInline)
                return false;

            auto exprStr = interop::toUTF8(expr);

            char buf[1024]{};
            if (!DbgFunctions()->StringFormatInline(exprStr.c_str(), sizeof(buf), buf))
            {
                return false;
            }

            value = interop::stringFromUTF8(buf);
            return true;
        }

        static System::String^ Format(System::String^ expr)
        {
            if (!DbgFunctions()->StringFormatInline)
                return nullptr;

            auto exprStr = interop::toUTF8(expr);

            char buf[1024]{};
            if (!DbgFunctions()->StringFormatInline(exprStr.c_str(), sizeof(buf), buf))
            {
                throw gcnew System::Exception("Invalid expression");
            }

            return interop::stringFromUTF8(buf);
        }

        static bool IsValidExpression(System::String^ expr)
        {
            auto exprStr = interop::toUTF8(expr);
            return DbgIsValidExpression(exprStr.c_str());
        }

        static bool RegisterExpression(int pluginHandle, System::String^ name, int argc, ExpressionHandler^ cb)
        {
            GCHandle gcCb = GCHandle::Alloc(cb);

            IntPtr ip = Marshal::GetFunctionPointerForDelegate(cb);
            auto* fn = static_cast<CBPLUGINEXPRFUNCTION>(ip.ToPointer());

            auto nameStr = interop::toUTF8(name);
            return _plugin_registerexprfunction(pluginHandle, nameStr.c_str(), argc, fn, nullptr);
        }

        static bool UnregisterExpression(int pluginHandle, System::String^ name)
        {
            auto nameStr = interop::toUTF8(name);
            return _plugin_unregisterexprfunction(pluginHandle, nameStr.c_str());
        }

    };

}

```

`src/Bindings/Instruction.Decoder.cpp`:

```cpp
#include <cstdint>
#include <utility>
#include <cctype>

#include <zydis/zydis.h>
#include "Instruction.hpp"
#include "Decoder.Converter.hpp"

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_memory.h"

namespace Dotx64Dbg
{
    struct EFlagsData
    {
        uint32_t read;
        uint32_t write;
    };

    static IOperand^ ConvertOperandImm(const ZydisDecodedInstruction& instr, const ZydisDecodedOperand& op, uint64_t addr)
    {
        Operand::Immediate^ res = gcnew Operand::Immediate();
        res->Value = op.imm.value.s;
        if (op.imm.is_relative)
        {
            res->Value += instr.length + addr;
        }
        return res;
    }

    static IOperand^ ConvertOperandReg(const ZydisDecodedInstruction& instr, const ZydisDecodedOperand& op, uint64_t addr)
    {
        const auto reg = convertZydisRegister(op.reg.value);
        return gcnew Operand::Register(reg);
    }

    static IOperand^ ConvertOperandMem(const ZydisDecodedInstruction& instr, const ZydisDecodedOperand& op, uint64_t addr)
    {
        const auto& mem = op.mem;

        Operand::Memory^ res = gcnew Operand::Memory();

        res->Size = op.size;
        res->Segment = static_cast<Registers::Id>(mem.segment);
        res->Base = static_cast<Registers::Id>(mem.base);
        res->Index = static_cast<Registers::Id>(mem.index);
        res->Scale = mem.scale;
        res->Displacement = mem.disp.value;

        if (res->Base == Registers::Id::Rip || res->Base == Registers::Id::Eip)
        {
            res->Displacement += instr.length + addr;
            res->Base = Registers::Id::None;
        }

        return res;
    }

    static IOperand^ ConvertOperand(const ZydisDecodedInstruction& instr, const ZydisDecodedOperand& op, uint64_t addr)
    {
        if (op.type == ZYDIS_OPERAND_TYPE_IMMEDIATE)
        {
            return ConvertOperandImm(instr, op, addr);
        }
        else if (op.type == ZYDIS_OPERAND_TYPE_REGISTER)
        {
            return ConvertOperandReg(instr, op, addr);
        }
        else if (op.type == ZYDIS_OPERAND_TYPE_MEMORY)
        {
            return ConvertOperandMem(instr, op, addr);
        }
        else if (op.type == ZYDIS_OPERAND_TYPE_UNUSED)
        {
            return Operand::None;
        }
        // ??
        return Operand::None;
    }

    static Instruction^ Convert(ZydisDecodedInstruction& instr, ZydisDecodedOperand* operands, uint64_t addr)
    {
        const auto id = convertZydisMnemonic(instr.mnemonic);

        auto attribs = Instruction::Attributes::None;

        auto addAttribute = [&](Instruction::Attributes a, Instruction::Attributes b)
            {
                return static_cast<Instruction::Attributes>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));
            };

        if (instr.attributes & ZYDIS_ATTRIB_HAS_LOCK)
        {
            attribs = addAttribute(attribs, Instruction::Attributes::Lock);
        }

        if (instr.attributes & ZYDIS_ATTRIB_HAS_REP)
        {
            attribs = addAttribute(attribs, Instruction::Attributes::Rep);
        }

        if (instr.attributes & ZYDIS_ATTRIB_HAS_REPE)
        {
            attribs = addAttribute(attribs, Instruction::Attributes::RepEq);
        }

        if (instr.attributes & ZYDIS_ATTRIB_HAS_REPNE)
        {
            attribs = addAttribute(attribs, Instruction::Attributes::RepNe);
        }

        if (instr.attributes & ZYDIS_ATTRIB_HAS_REPNZ)
        {
            attribs = addAttribute(attribs, Instruction::Attributes::RepNz);
        }

        auto res = gcnew Instruction(attribs, id);
        res->_Size = instr.length;
        res->_Address = addr;
        res->_FlagsModified = (EFlags)(instr.cpu_flags->modified | instr.cpu_flags->set_0 | instr.cpu_flags->set_1);
        res->_FlagsRead = (EFlags)instr.cpu_flags->tested;

        int opIndex = 0;
        for (int i = 0; i < instr.operand_count; i++)
        {
            auto& op = operands[i];

            IOperand^ newOp = ConvertOperand(instr, op, addr);
            OperandVisibility vis = OperandVisibility::Invalid;
            if (op.visibility == ZYDIS_OPERAND_VISIBILITY_EXPLICIT)
                vis = OperandVisibility::Explicit;
            else if (op.visibility == ZYDIS_OPERAND_VISIBILITY_HIDDEN)
                vis = OperandVisibility::Hidden;
            else if (op.visibility == ZYDIS_OPERAND_VISIBILITY_IMPLICIT)
                vis = OperandVisibility::Implicit;
            else
                vis = OperandVisibility::Invalid;

            OperandAccess access = OperandAccess::None;
            if (op.actions & ZYDIS_OPERAND_ACTION_MASK_READ)
            {
                access = static_cast<OperandAccess>(
                    static_cast<uint32_t>(access) | static_cast<uint32_t>(OperandAccess::Read));
            }

            if (op.actions & ZYDIS_OPERAND_ACTION_MASK_WRITE)
            {
                access = static_cast<OperandAccess>(
                    static_cast<uint32_t>(access) | static_cast<uint32_t>(OperandAccess::Write));
            }

            res->SetOperand(opIndex, newOp, access, vis);
            opIndex++;
        }

        return res;
    }

    namespace Internal {

        Instruction^ decodeInstruction(const ZydisDecoder* decoder, const uint8_t* buf, size_t len, uint64_t address)
        {
            ZydisDecodedInstruction instr{};
            ZydisDecodedOperand operands[ZYDIS_MAX_OPERAND_COUNT];
            if (auto status = ZydisDecoderDecodeFull(decoder, buf, len, &instr, operands); status != ZYAN_STATUS_SUCCESS)
            {
                return nullptr;
            }

            return Convert(instr, operands, address);
        }

    }

    public ref class Decoder
    {
        ZydisDecoder* _decoder;

    private:
        Decoder()
        {
            _decoder = new ZydisDecoder();
#ifdef _M_AMD64
            auto mode = ZYDIS_MACHINE_MODE_LONG_64;
            auto addrSize = ZYDIS_STACK_WIDTH_64;
#else
            auto mode = ZYDIS_MACHINE_MODE_LEGACY_32;
            auto addrSize = ZYDIS_STACK_WIDTH_32;
#endif
            if (auto status = ZydisDecoderInit(_decoder, mode, addrSize);
                status != ZYAN_STATUS_SUCCESS)
            {
                char msg[64]{};
                sprintf_s(msg, "ZydisDecoderInit failed: %u\n", status);
                _plugin_logprint(msg);
            }
        }

    public:
        ~Decoder()
        {
            delete _decoder;
        }

        static Decoder^ Create()
        {
            return gcnew Decoder();
        }

        Instruction^ Decode(array<System::Byte>^ data, uint64_t address)
        {
            pin_ptr<uint8_t> ptr = &data[0];
            const uint8_t* buf = ptr;

            return Internal::decodeInstruction(_decoder, buf, data->Length, address);
        }

        Instruction^ Decode(System::UIntPtr address)
        {
            auto va = static_cast<duint>(address.ToUInt64());
            duint readSize = 0;

            uint8_t buf[15];
            if (!Script::Memory::Read(static_cast<duint>(va), buf, sizeof(buf), &readSize))
                return nullptr;

            return Internal::decodeInstruction(_decoder, buf, readSize, va);
        }

    private:

    };

    // Alias for discoverability
    public ref class Disassembler
    {
    private:
        Disassembler()
        {
        }

    public:
        static Decoder^ Create()
        {
            return Decoder::Create();
        }
    };
} // namespace Dotx64Dbg

```

`src/Bindings/Instruction.Decoder.hpp`:

```hpp
#pragma once

#include <zydis/Zydis.h>
#include <cstdint>

namespace Dotx64Dbg::Internal {

    Instruction^ decodeInstruction(const ZydisDecoder* decoder, const uint8_t* buf, size_t len, uint64_t address);

}

```

`src/Bindings/Instruction.EFlags.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstdlib>
#include <cstdio>

namespace Dotx64Dbg {

    using namespace System;

    [System::Flags]
    public enum class EFlags
    {
        None = 0,
        Cf = (1 << 0),
        Pf = (1 << 2),
        Af = (1 << 4),
        Zf = (1 << 6),
        Sf = (1 << 7),
        Tf = (1 << 8),
        If = (1 << 9),
        Df = (1 << 10),
        Of = (1 << 11),
        Iopl = (1 << 12),
        Nt = (1 << 14),
        Rf = (1 << 16),
        Vm = (1 << 17),
        Ac = (1 << 18),
        Vif = (1 << 19),
        Vip = (1 << 20),
        Id = (1 << 21),
        C0 = (1 << 22),
        C1 = (1 << 23),
        C2 = (1 << 24),
        C3 = (1 << 25),
    };

}

```

`src/Bindings/Instruction.Encoder.cpp`:

```cpp
#include "AsmJitHelper.hpp"
#include "Encoder.Converter.hpp"

#include <cstdint>
#include <utility>
#include <vector>
#include <string>

namespace Dotx64Dbg {

    struct EncoderErrorHandler : asmjit::ErrorHandler
    {
        void handleError(asmjit::Error err, const char* message, asmjit::BaseEmitter* origin) override
        {
            auto errMsg = getAsmjitErrorString(err);
            if (!errMsg)
                return;

            auto exMsg = "Encoder Error: " + *errMsg;
            if (message != nullptr && strlen(message) > 0)
            {
                exMsg += "\nMessage: " + std::string(message);
            }
            auto strMessage = gcnew System::String(exMsg.c_str());
            throw gcnew System::InvalidOperationException(strMessage);
        }
    };

    static EncoderErrorHandler _errHandler{};

    template<typename T>
    static constexpr T getShift(T x)
    {
        if (x == 0)
            return 0;
        T shift = 0;
        while ((x & 1) == 0)
        {
            x >>= 1;
            shift++;
        }
        return shift;
    }

    static uint32_t bitsToBytes(uint32_t bits)
    {
        return bits >> 3;
    }

    static asmjit::Operand convertOp(asmjit::x86::Assembler* a,
        IOperand^ op,
        System::Collections::Generic::Dictionary<Label^, UInt32>^ labels)
    {
        if (op->Type == OperandType::None)
            return {};

        if (op->Type == OperandType::Register)
        {
            auto opReg = (Operand::Register^)op;
            return convertAsmJitRegister(opReg->Value);
        }
        else if (op->Type == OperandType::Immediate)
        {
            auto opImm = (Operand::Immediate^)op;
            return asmjit::Imm(opImm->Value);
        }
        else if (op->Type == OperandType::Memory)
        {
            auto opMem = (Operand::Memory^)op;
            auto mem = asmjit::x86::Mem();
            mem.setBase(convertAsmJitRegister(opMem->Base));
            mem.setIndex(convertAsmJitRegister(opMem->Index), getShift(opMem->Scale));
            mem.setSegment(convertAsmJitRegister(opMem->Segment).as<asmjit::x86::SReg>());
            mem.setSize(bitsToBytes(opMem->Size));
            mem.setOffset(opMem->Displacement);
            return mem;
        }
        else if (op->Type == OperandType::Label)
        {
            if (labels == nullptr)
            {
                return asmjit::Imm(0x7FFFFFFF);
            }
            else
            {
                auto opLabel = (Label^)op;

                asmjit::Label realLabel{};

                UInt32 labelId;
                if (labels->TryGetValue(opLabel, labelId))
                {
                    realLabel = asmjit::Label{ labelId };
                }
                else
                {
                    realLabel = a->newLabel();
                    labels->Add(opLabel, realLabel.id());
                }

                return realLabel;
            }

        }
        return {};
    }

    namespace Internal {

        bool encodeInstruction(asmjit::x86::Assembler* a,
            System::Collections::Generic::Dictionary<Label^, UInt32>^ labels,
            Instruction::Attributes attrib,
            Mnemonic mnemonic,
            IOperand^ op0_,
            IOperand^ op1_,
            IOperand^ op2_,
            IOperand^ op3_)
        {
            auto opCount = 0;

            auto op0 = convertOp(a, op0_, labels);
            if (!op0.isNone())
                opCount++;

            auto op1 = convertOp(a, op1_, labels);
            if (!op1.isNone())
                opCount++;

            auto op2 = convertOp(a, op2_, labels);
            if (!op2.isNone())
                opCount++;

            auto op3 = convertOp(a, op3_, labels);
            if (!op3.isNone())
                opCount++;

            if ((attrib & Instruction::Attributes::Lock) != Instruction::Attributes::None)
                a->lock();

            if ((attrib & Instruction::Attributes::Rep) != Instruction::Attributes::None)
                a->rep();

            if ((attrib & Instruction::Attributes::RepNe) != Instruction::Attributes::None)
                a->repne();

            if ((attrib & Instruction::Attributes::RepEq) != Instruction::Attributes::None)
                a->repe();

            if ((attrib & Instruction::Attributes::RepNz) != Instruction::Attributes::None)
                a->repnz();

            const auto asmjitMnemonic = convertAsmJitMnemonic(mnemonic);
            switch (mnemonic)
            {
            case Mnemonic::Cmpsb:
                if (opCount == 0)
                {
                    if (a->cmpsb() != asmjit::kErrorOk)
                    {
                        return false;
                    }
                    return true;
                }
                break;
            case Mnemonic::Cmpsw:
                if (opCount == 0)
                {
                    if (a->cmpsw() != asmjit::kErrorOk)
                    {
                        return false;
                    }
                    return true;
                }
                break;
            case Mnemonic::Cmpsd:
                if (opCount == 0)
                {
                    if (a->cmpsd() != asmjit::kErrorOk)
                    {
                        return false;
                    }
                    return true;
                }
                break;
            case Mnemonic::Cmpsq:
                if (opCount == 0)
                {
                    if (a->cmpsq() != asmjit::kErrorOk)
                    {
                        return false;
                    }
                    return true;
                }
                break;
            case Mnemonic::Movsb:
                if (opCount == 0)
                {
                    if (a->movsb() != asmjit::kErrorOk)
                    {
                        return false;
                    }
                    return true;
                }
                break;
            case Mnemonic::Movsw:
                if (opCount == 0)
                {
                    if (a->movsw() != asmjit::kErrorOk)
                    {
                        return false;
                    }
                    return true;
                }
                break;
            case Mnemonic::Movsd:
                if (opCount == 0)
                {
                    if (a->movsd() != asmjit::kErrorOk)
                    {
                        return false;
                    }
                    return true;
                }
                break;
            case Mnemonic::Movsq:
                if (opCount == 0)
                {
                    if (a->movsq() != asmjit::kErrorOk)
                    {
                        return false;
                    }
                    return true;
                }
                break;
            case Mnemonic::Lodsb:
                if (a->lodsb() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Lodsw:
                if (a->lodsw() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Lodsd:
                if (a->lodsd() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Lodsq:
                if (a->lodsq() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Stosb:
                if (a->stosb() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Stosw:
                if (a->stosw() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Stosd:
                if (a->stosd() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Stosq:
                if (a->stosq() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Scasb:
                if (a->scasb() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Scasw:
                if (a->scasw() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Scasd:
                if (a->scasd() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            case Mnemonic::Scasq:
                if (a->scasq() != asmjit::kErrorOk)
                {
                    return false;
                }
                return true;
            }

            // Generic case.
            if (a->emit(asmjitMnemonic, op0, op1, op2, op3) != asmjit::kErrorOk)
            {
                return false;
            }

            return true;
        }
    }

    static bool encodeInstruction(asmjit::x86::Assembler* a,
        System::Collections::Generic::Dictionary<Label^, UInt32>^ labels,
        Instruction^ instr)
    {
        auto op0 = instr->GetOperandVisibility(0) == OperandVisibility::Hidden ? Operand::None : instr->GetOperand(0);
        auto op1 = instr->GetOperandVisibility(1) == OperandVisibility::Hidden ? Operand::None : instr->GetOperand(1);
        auto op2 = instr->GetOperandVisibility(2) == OperandVisibility::Hidden ? Operand::None : instr->GetOperand(2);
        auto op3 = instr->GetOperandVisibility(3) == OperandVisibility::Hidden ? Operand::None : instr->GetOperand(3);

        auto mnemonic = convertAsmJitMnemonic(instr->Id);

        return Internal::encodeInstruction(a, labels, instr->Attribs, instr->Id, op0, op1, op2, op3);
    }

    public ref class Encoder
    {
        asmjit::CodeHolder* _code{};
        asmjit::x86::Assembler* _assembler{};
        System::Collections::Generic::Dictionary<Label^, UInt32>^ _labels;

    private:
        Encoder(uintptr_t baseVA)
        {
            _labels = gcnew System::Collections::Generic::Dictionary<Label^, UInt32>();
            _code = new asmjit::CodeHolder();
            _code->init(asmjit::Environment::host(), baseVA);
            _assembler = new asmjit::x86::Assembler(_code);
            _assembler->setErrorHandler(&_errHandler);
        }

    public:
        ~Encoder()
        {
            delete _assembler;
            delete _code;
        }

        static Encoder^ Create(System::UIntPtr baseVA)
        {
            return gcnew Encoder(static_cast<uintptr_t>(baseVA.ToUInt64()));
        }

        void Reset()
        {
            _labels->Clear();

            _code->reset(asmjit::ResetPolicy::kSoft);
            _code->attach(_assembler);
        }

        bool BindLabel(Label^ label)
        {
            asmjit::Label realLabel{};

            UInt32 labelId;
            if (_labels->TryGetValue(label, labelId))
            {
                realLabel = asmjit::Label{ labelId };
            }
            else
            {
                realLabel = _assembler->newLabel();
                _labels->Add(label, realLabel.id());
            }

            if (auto res = _assembler->bind(realLabel); res != asmjit::kErrorOk)
            {
                return false;
            }

            return true;
        }

        bool Encode(Instruction^ instr)
        {
            return encodeInstruction(_assembler, _labels, instr);
        }

        System::UIntPtr GetLabelBaseOffset(Label^ label)
        {
            if (label == nullptr)
                return System::UIntPtr((void*)((intptr_t)-1));

            UInt32 labelId;
            if (!_labels->TryGetValue(label, labelId))
                return System::UIntPtr((void*)((intptr_t)-1));

            return System::UIntPtr(_code->labelOffsetFromBase(labelId));
        }

        System::UIntPtr GetLabelOffset(Label^ label)
        {
            if (label == nullptr)
                return System::UIntPtr((void*)((intptr_t)-1));

            UInt32 labelId;
            if (!_labels->TryGetValue(label, labelId))
                return System::UIntPtr((void*)((intptr_t)-1));

            return System::UIntPtr(_code->labelOffset(labelId));
        }

        bool RelocateTo(System::UIntPtr newBaseVA)
        {
            auto va = static_cast<uintptr_t>(newBaseVA.ToUInt64());

            if (auto res = _code->relocateToBase(va); res != asmjit::kErrorOk)
            {
                return false;
            }
            return true;
        }

        array<System::Byte>^ GetData()
        {
            const size_t codeSize = _code->codeSize();

            array<System::Byte>^ res = gcnew array<System::Byte>((int)codeSize);
            if (codeSize == 0)
                return res;

            pin_ptr<uint8_t> ptr = &res[0];
            uint8_t* buf = ptr;

            _code->copyFlattenedData(ptr, codeSize);

            return res;
        }
    };

}

```

`src/Bindings/Instruction.Encoder.hpp`:

```hpp
#include <cstdint>
#include <utility>
#include <vector>
#include <string>

#include "Encoder.Converter.hpp"

namespace Dotx64Dbg::Internal {

    bool encodeInstruction(asmjit::x86::Assembler* a,
        System::Collections::Generic::Dictionary<Label^, UInt32>^ labels,
        Instruction::Attributes attrib,
        Mnemonic mnemonic,
        IOperand^ op0_,
        IOperand^ op1_,
        IOperand^ op2_,
        IOperand^ op3_
    );
}

```

`src/Bindings/Instruction.Generator.cpp`:

```cpp
#include "Instruction.Generator.hpp"
#include "Instruction.Encoder.hpp"
#include "Instruction.Decoder.hpp"
#include "AsmJitHelper.hpp"

#include <asmjit/asmjit.h>
#include <zydis/Zydis.h>

namespace Dotx64Dbg
{
    struct EncoderErrorHandler : asmjit::ErrorHandler
    {
        void handleError(asmjit::Error err, const char* message, asmjit::BaseEmitter* origin) override
        {
            auto errMsg = getAsmjitErrorString(err);
            if (!errMsg)
                return;

            auto exMsg = "Generator Error: " + *errMsg;
            if (message != nullptr && strlen(message) > 0)
            {
                exMsg += "\nMessage: " + std::string(message);
            }
            auto strMessage = gcnew System::String(exMsg.c_str());
            throw gcnew System::InvalidOperationException(strMessage);
        }
    };

    static EncoderErrorHandler _errHandler{};

    Instruction^ InstructionGenerator::Generate(Mnemonic mnemonic)
    {
        return Generate(Instruction::Attributes::None, mnemonic);
    }

    Instruction^ InstructionGenerator::Generate(Mnemonic mnemonic, IOperand^ op0)
    {
        return Generate(Instruction::Attributes::None, mnemonic, op0);
    }

    Instruction^ InstructionGenerator::Generate(Mnemonic mnemonic, IOperand^ op0, IOperand^ op1)
    {
        return Generate(Instruction::Attributes::None, mnemonic, op0, op1);
    }

    Instruction^ InstructionGenerator::Generate(Mnemonic mnemonic, IOperand^ op0, IOperand^ op1, IOperand^ op2)
    {
        return Generate(Instruction::Attributes::None, mnemonic, op0, op1, op2);
    }

    Instruction^ InstructionGenerator::Generate(Mnemonic mnemonic, IOperand^ op0, IOperand^ op1, IOperand^ op2, IOperand^ op3)
    {
        return Generate(Instruction::Attributes::None, mnemonic, op0, op1, op2, op3);
    }

    Instruction^ InstructionGenerator::Generate(Instruction::Attributes attribs, Mnemonic mnemonic)
    {
        return Generate(attribs, mnemonic, Operand::None, Operand::None, Operand::None, Operand::None);
    }

    Instruction^ InstructionGenerator::Generate(Instruction::Attributes attribs, Mnemonic mnemonic, IOperand^ op0)
    {
        return Generate(attribs, mnemonic, op0, Operand::None, Operand::None, Operand::None);
    }

    Instruction^ InstructionGenerator::Generate(Instruction::Attributes attribs, Mnemonic mnemonic, IOperand^ op0, IOperand^ op1)
    {
        return Generate(attribs, mnemonic, op0, op1, Operand::None, Operand::None);
    }

    Instruction^ InstructionGenerator::Generate(Instruction::Attributes attribs, Mnemonic mnemonic, IOperand^ op0, IOperand^ op1, IOperand^ op2)
    {
        return Generate(attribs, mnemonic, op0, op1, op2, Operand::None);
    }

    // NOTE: This has to be within rel32
    constexpr int32_t DispMagic = 0xF000BA;
    constexpr int32_t LabelMagic = 0xF111BA;
    constexpr int32_t TargetMagic = 0xF222BA;
    constexpr int8_t LoopMagic = 0x5F;

    // Because we encode at the address zero we have to make sure certain values
    // are within the range of rel32 due to x86 restrictions.
    // Labels will be replaced by LabelMagic and memory displacements will be
    // replaced by DispMagic.
    // Those values will be set back to the original once decoded.
    static IOperand^ HandleOperand(Mnemonic mnemonic, int index, IOperand^ op)
    {
        if (op->Type == OperandType::None)
            return op;

        if (op->Type == OperandType::Memory)
        {
            auto mem = (Operand::Memory^)op;
            if (mem->Displacement != 0)
            {
                auto replacement = gcnew Operand::Memory();
                replacement->Size = mem->Size;
                replacement->Segment = mem->Segment;
                replacement->Base = mem->Base;
                replacement->Index = mem->Index;
                replacement->Scale = mem->Scale;
                replacement->Displacement = DispMagic;
                return replacement;
            }
        }
        else if (op->Type == OperandType::Label)
        {
            return gcnew Operand::Immediate(LabelMagic);
        }
        else if (op->Type == OperandType::Immediate)
        {
            // Temporarily swap immediate for control flow instructions.
            if (index == 0 &&
                InstructionMetaData::isControlFlow(mnemonic) &&
                !InstructionMetaData::isRet(mnemonic))
            {
                if(InstructionMetaData::isLoop(mnemonic))
                    return gcnew Operand::Immediate(LoopMagic);
                else
                    return gcnew Operand::Immediate(TargetMagic);
            }
        }

        return op;
    }

    Instruction^ InstructionGenerator::Generate(Instruction::Attributes attribs, Mnemonic mnemonic, IOperand^ op0, IOperand^ op1, IOperand^ op2, IOperand^ op3)
    {
        asmjit::CodeHolder code;
        code.init(asmjit::Environment::host(), 0);
        code.setErrorHandler(&_errHandler);

        asmjit::x86::Assembler assembler(&code);

        bool encoded = Internal::encodeInstruction(&assembler,
            nullptr,
            attribs,
            mnemonic,
            HandleOperand(mnemonic, 0, op0),
            HandleOperand(mnemonic, 1, op1),
            HandleOperand(mnemonic, 2, op2),
            HandleOperand(mnemonic, 3, op3));

        if (!encoded)
            return nullptr;

        uint8_t buffer[64]{};

        auto codeSize = code.codeSize();
        code.copyFlattenedData(buffer, sizeof(buffer));

        ZydisDecoder decoder;
#ifdef _M_AMD64
        auto mode = ZYDIS_MACHINE_MODE_LONG_64;
        auto addrSize = ZYDIS_STACK_WIDTH_64;
#else
        auto mode = ZYDIS_MACHINE_MODE_LEGACY_32;
        auto addrSize = ZYDIS_STACK_WIDTH_32;
#endif
        if (auto status = ZydisDecoderInit(&decoder, mode, addrSize);
            status != ZYAN_STATUS_SUCCESS)
        {
            return nullptr;
        }

        auto instr = Internal::decodeInstruction(&decoder, buffer, codeSize, 0);

        // Switch out the operands if required.
        if (op0 != nullptr && op0->Type != OperandType::None)
        {
            auto newOp = instr->GetOperand(0);
            if (op0->Type == OperandType::Label)
            {
                if (newOp->Type == OperandType::Immediate)
                {
                    auto imm = (Operand::Immediate^)newOp;
                    if (imm->Value == LabelMagic)
                    {
                        instr->SetOperand(0, op0);
                    }
                }
            }
            else if (op0->Type == OperandType::Memory)
            {
                if (newOp->Type == OperandType::Memory)
                {
                    auto mem = (Operand::Memory^)newOp;
                    if (mem->Displacement == DispMagic)
                    {
                        instr->SetOperand(0, op0);
                    }
                }
            }
            else if (op0->Type == OperandType::Immediate)
            {
                if (InstructionMetaData::isControlFlow(mnemonic) && !InstructionMetaData::isRet(mnemonic))
                {
                    auto magicVal = InstructionMetaData::isLoop(mnemonic) ? LoopMagic : TargetMagic;
                    auto imm = (Operand::Immediate^)newOp;
                    if (imm->Value == magicVal)
                    {
                        instr->SetOperand(0, op0);
                    }
                }
            }
        }
        if (op1 != nullptr && op1->Type != OperandType::None)
        {
            if (op1->Type == OperandType::Memory)
            {
                auto newOp = instr->GetOperand(1);
                if (newOp->Type == OperandType::Memory)
                {
                    auto mem = (Operand::Memory^)newOp;
                    if (mem->Displacement == DispMagic)
                    {
                        instr->SetOperand(1, op1);
                    }
                }
            }
        }
        if (op2 != nullptr && op2->Type != OperandType::None)
        {
            if (op2->Type == OperandType::Memory)
            {
                auto newOp = instr->GetOperand(2);
                if (newOp->Type == OperandType::Memory)
                {
                    auto mem = (Operand::Memory^)newOp;
                    if (mem->Displacement == DispMagic)
                    {
                        instr->SetOperand(2, op2);
                    }
                }
            }
        }
        if (op3 != nullptr && op3->Type != OperandType::None)
        {
            if (op2->Type == OperandType::Memory)
            {
                auto newOp = instr->GetOperand(3);
                if (newOp->Type == OperandType::Memory)
                {
                    auto mem = (Operand::Memory^)newOp;
                    if (mem->Displacement == DispMagic)
                    {
                        instr->SetOperand(3, op3);
                    }
                }
            }
        }

        return instr;
    }

}

```

`src/Bindings/Instruction.Generator.hpp`:

```hpp
#pragma once

#include "Instruction.hpp"

namespace Dotx64Dbg {

    public ref class InstructionGenerator
    {
    public:
        static Instruction^ Generate(Mnemonic mnemonic);

        static Instruction^ Generate(Mnemonic mnemonic,
            IOperand^ op0);

        static Instruction^ Generate(Mnemonic mnemonic,
            IOperand^ op0,
            IOperand^ op1);

        static Instruction^ Generate(Mnemonic mnemonic,
            IOperand^ op0,
            IOperand^ op1,
            IOperand^ op2);

        static Instruction^ Generate(Mnemonic mnemonic,
            IOperand^ op0,
            IOperand^ op1,
            IOperand^ op2,
            IOperand^ op3);

        static Instruction^ Generate(Instruction::Attributes attribs,
            Mnemonic mnemonic);

        static Instruction^ Generate(Instruction::Attributes attribs,
            Mnemonic mnemonic,
            IOperand^ op0);

        static Instruction^ Generate(Instruction::Attributes attribs,
            Mnemonic mnemonic,
            IOperand^ op0,
            IOperand^ op1);

        static Instruction^ Generate(Instruction::Attributes attribs,
            Mnemonic mnemonic,
            IOperand^ op0,
            IOperand^ op1,
            IOperand^ op2);

        static Instruction^ Generate(Instruction::Attributes attribs,
            Mnemonic mnemonic,
            IOperand^ op0,
            IOperand^ op1,
            IOperand^ op2,
            IOperand^ op3);
    };

}

```

`src/Bindings/Instruction.Meta.hpp`:

```hpp
#pragma once

#include "Mnemonic.hpp"
#include "Instruction.Operand.hpp"
#include "Instruction.Operands.hpp"
#include "Instruction.EFlags.hpp"

namespace Dotx64Dbg {

    ref class InstructionMetaData
    {
    public:

        static inline bool isControlFlow(Mnemonic mnemonic)
        {
            switch (mnemonic)
            {
            case Mnemonic::Call:
            case Mnemonic::Ret:
            case Mnemonic::Iret:
            case Mnemonic::Iretd:
            case Mnemonic::Iretq:
            case Mnemonic::Jmp:
            case Mnemonic::Jb:
            case Mnemonic::Jbe:
            case Mnemonic::Jcxz:
            case Mnemonic::Jecxz:
            case Mnemonic::Jknzd:
            case Mnemonic::Jkzd:
            case Mnemonic::Jl:
            case Mnemonic::Jle:
            case Mnemonic::Jnb:
            case Mnemonic::Jnbe:
            case Mnemonic::Jnl:
            case Mnemonic::Jnle:
            case Mnemonic::Jno:
            case Mnemonic::Jnp:
            case Mnemonic::Jns:
            case Mnemonic::Jnz:
            case Mnemonic::Jo:
            case Mnemonic::Jp:
            case Mnemonic::Jrcxz:
            case Mnemonic::Js:
            case Mnemonic::Jz:
            case Mnemonic::Loop:
            case Mnemonic::Loope:
            case Mnemonic::Loopne:
                return true;
            }
            return false;
        }

        static inline bool isLoop(Mnemonic mnemonic)
        {
            switch (mnemonic)
            {
            case Mnemonic::Loop:
            case Mnemonic::Loope:
            case Mnemonic::Loopne:
                return true;
            }
            return false;
        }

        static inline bool isCondControlFlow(Mnemonic mnemonic)
        {
            switch (mnemonic)
            {
            case Mnemonic::Jb:
            case Mnemonic::Jbe:
            case Mnemonic::Jcxz:
            case Mnemonic::Jecxz:
            case Mnemonic::Jknzd:
            case Mnemonic::Jkzd:
            case Mnemonic::Jl:
            case Mnemonic::Jle:
            case Mnemonic::Jnb:
            case Mnemonic::Jnbe:
            case Mnemonic::Jnl:
            case Mnemonic::Jnle:
            case Mnemonic::Jno:
            case Mnemonic::Jnp:
            case Mnemonic::Jns:
            case Mnemonic::Jnz:
            case Mnemonic::Jo:
            case Mnemonic::Jp:
            case Mnemonic::Jrcxz:
            case Mnemonic::Js:
            case Mnemonic::Jz:
                return true;
            }
            return false;
        }

        static inline bool IsCall(Mnemonic mnemonic)
        {
            switch (mnemonic)
            {
            case Mnemonic::Call:
                return true;
            }
            return false;
        }

        static inline bool isRet(Mnemonic mnemonic)
        {
            switch (mnemonic)
            {
            case Mnemonic::Ret:
            case Mnemonic::Iret:
            case Mnemonic::Iretd:
            case Mnemonic::Iretq:
                return true;
            }
            return false;
        }
    };

}

```

`src/Bindings/Instruction.Operand.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstdlib>
#include <cstdio>

#include "Register.hpp"
#include "Mnemonic.hpp"

namespace Dotx64Dbg {

    using namespace System;

    public enum class OperandType
    {
        None = 0,
        Immediate,
        Register,
        Memory,
        Label,
    };

    public enum class OperandVisibility
    {
        Invalid = 0,
        Explicit,
        Implicit,
        Hidden,
    };

    [System::Flags]
    public enum class OperandAccess
    {
        None = 0,
        Read = (1 << 0),
        Write = (1 << 1),
        ReadWrite = Read | Write,
    };

    public interface class IOperand
    {
    public:
        virtual property OperandType Type
        {
            OperandType get();
        }
        virtual property int Size
        {
            int get();
        }
    };

    public ref class Label : public IOperand
    {
        int _id = -1;

    public:
        property int Value
        {
            int get()
            {
                return _id;
            }
        }

        Label()
        {
        }

        Label(int id)
            : _id(id)
        {
        }

        virtual property OperandType Type
        {
            OperandType get()
            {
                return OperandType::Label;
            }
        }

        virtual property int Size
        {
            int get()
            {
                return 0;
            }
        }
    };

    public ref class Operand
    {

    public:
        ref class NoneType : public IOperand
        {
        public:
            virtual property OperandType Type
            {
                OperandType get()
                {
                    return OperandType::None;
                }
            }
            virtual property int Size
            {
                int get()
                {
                    return 0;
                }
            }
        };

    private:
        static NoneType^ _None = gcnew NoneType();

    public:
        static property NoneType^ None {
            NoneType^ get()
            {
                return _None;
            }
        }

        // Immediate
        ref class Immediate : public IOperand
        {
        public:
            Immediate()
            {
                Value = 0;
            }

            Immediate(int64_t value)
            {
                Value = value;
            }

            virtual property OperandType Type
            {
                OperandType get()
                {
                    return OperandType::Immediate;
                }
            }

            virtual property int Size
            {
                int get()
                {
                    uint64_t val = static_cast<uint64_t>(std::abs(Value));
                    int res = 0;
                    do
                    {
                        res++;
                    } while (val >>= 8);
                    return res * 8;
                }
            }

            property int64_t Value;

            System::String^ ToString() override
            {
                char temp[128];
                snprintf(temp, sizeof(temp), "0x%llx", Value);
                return gcnew System::String(temp);
            }
        };

        // Register
        ref class Register : public IOperand
        {
            Registers::Id _Value;

        public:
            Register()
            {
                _Value = Registers::Id::None;
            }

            Register(Registers::Id reg)
            {
                _Value = reg;
            }

            virtual property OperandType Type
            {
                OperandType get()
                {
                    return OperandType::Register;
                }
            }

            /// <summary>
            /// Register  size in bits.
            /// </summary>
            virtual property int Size
            {
                int get()
                {
                    return Registers::GetSize(_Value);
                }
            }

            /// <summary>
            /// This is equivalent to checking against Register.None
            /// </summary>
            property bool IsValid
            {
                bool get()
                {
                    return _Value != Registers::Id::None;
                }
            }

            /// <summary>
            /// The register id.
            /// </summary>
            property Registers::Id Value
            {
                Registers::Id get()
                {
                    return _Value;
                }
            }

            property Registers::Class Class
            {
                Registers::Class get()
                {
                    return Registers::GetClass(_Value);
                }
            }

            /// <summary>
            /// This will be true if the register class is one of the general purpose types.
            /// </summary>
            property bool IsGp
            {
                bool get()
                {
                    switch (Class)
                    {
                    case Registers::Class::Gp8:
                    case Registers::Class::Gp16:
                    case Registers::Class::Gp32:
                    case Registers::Class::Gp64:
                        return true;
                    }
                    return false;
                }
            }

            /// <summary>
            /// Retrieves the root register id, will be Register.None if none.
            /// If the register is ax it would result eax on 32 bit and rax on 64 bit.
            /// </summary>
            property Registers::Id RootId
            {
                Registers::Id get()
                {
                    return Registers::GetRoot(_Value);
                }
            }

            /// <summary>
            /// Equivalent to RootId != Register.None
            /// </summary>
            property bool HasRoot
            {
                bool get()
                {
                    return Registers::GetRoot(_Value) != Registers::Id::None;
                }
            }

            /// <see cref="GetRoot" />
            property Register^ Root
            {
                Register^ get()
                {
                    return GetRoot();
                }
            }

            /// <summary>
            /// Retrieves the root register.
            /// If the register is ax it would result eax on 32 bit and rax on 64 bit.
            /// </summary>
            Register^ GetRoot()
            {
                return gcnew Register(Registers::GetRoot(_Value));
            }

            /// <summary>
            /// Retrieves the parent register id, will be Register.None if none.
            /// </summary>
            property Registers::Id ParentId
            {
                Registers::Id get()
                {
                    return Registers::GetParent(_Value);
                }
            }

            /// <summary>
            /// Equivalent to RootId != Register.None
            /// </summary>
            property bool HasParent
            {
                bool get()
                {
                    return Registers::GetParent(_Value) != Registers::Id::None;
                }
            }

            /// <see cref="GetParent" />
            property Register^ Parent
            {
                Register^ get()
                {
                    return GetParent();
                }
            }

            /// <summary>
            /// If the register is part of another register this will return the parent.
            /// So in case the register is ax the parent would be eax and for eax it would be rax on 64 bit.
            /// <returns>New OpReg, this will never result null.</returns>
            /// </summary>
            Register^ GetParent()
            {
                return gcnew Register(Registers::GetParent(_Value));
            }

            /// <see cref="GetPosition" />
            property int Position
            {
                int get()
                {
                    return GetPosition();
                }
            }

            /// <summary>
            /// This returns number of bits offset from the root register.
            /// In case of Register.Ax this would result 8.
            /// <returns>Returns number of bits at where the register is located in the root register</returns>
            /// </summary>
            int GetPosition()
            {
                return Registers::GetOffsetForRoot(_Value);
            }

            /// <summary>
            /// Gets the index of the register within its category so for Gp it would be 0 to 15, Xmm 0 to 31
            /// </summary>
            /// <returns>Index of register</returns>
            int GetIndex()
            {
                return Registers::GetIndex(_Value);
            }

            /// <summary>
            /// A small helper to determine if the parent register would be mutated
            /// if the register is modified.
            /// This is primarily useful for the 64 bit architecture where modifying a register
            /// such as eax would result in the upper 32 bit of rax being modified/mutated.
            /// </summary>
            property bool MutatesParent
            {
                bool get()
                {
#ifdef _M_AMD64
                    if (IsGp && Size == 32)
                        return true;
#endif
                    return false;
                }
            }

            System::String^ ToString() override
            {
                return gcnew System::String(Registers::GetName(_Value));
            }
        };

        // Memory
        ref class Memory : public IOperand
        {
            int MemSize = 0;

        public:
            Memory()
            {
            }

            Memory(int size, Registers::Id seg, Registers::Id base, Registers::Id index, int32_t scale, int64_t disp)
            {
                Size = size;
                Segment = seg;
                Base = base;
                Index = index;
                Scale = scale;
                Displacement = disp;
            }

            Memory(int size, Registers::Id base, Registers::Id index, int32_t scale, int64_t disp)
            {
                Size = size;
                Segment = Registers::Id::Ds;
                Base = base;
                Index = index;
                Scale = scale;
                Displacement = disp;
            }

            virtual property OperandType Type
            {
                OperandType get()
                {
                    return OperandType::Memory;
                }
            }

            virtual property int Size
            {
                int get()
                {
                    return MemSize;
                }
                void set(int value)
                {
                    MemSize = value;
                }
            }

            property Registers::Id Segment;
            property Registers::Id Base;
            property Registers::Id Index;
            property int32_t Scale;
            property int64_t Displacement;

            Memory^ WithSegment(Registers::Id reg)
            {
                Segment = reg;
                return this;
            }

            Memory^ WithSegment(Register^ reg)
            {
                Segment = reg->Value;
                return this;
            }

            Memory^ WithBase(Registers::Id reg)
            {
                Base = reg;
                return this;
            }
            Memory^ WithBase(Register^ reg)
            {
                Base = reg->Value;
                return this;
            }

            Memory^ WithIndex(Registers::Id reg)
            {
                Index = reg;
                return this;
            }
            Memory^ WithIndex(Register^ reg)
            {
                Index = reg->Value;
                return this;
            }

            Memory^ WithScale(int32_t scale)
            {
                Scale = scale;
                return this;
            }

            Memory^ WithDisplacement(int64_t disp)
            {
                Displacement = disp;
                return this;
            }

            System::String^ ToString() override
            {
                char temp[128];
                int p = 0;

                switch (Size)
                {
                case 8:
                    p += snprintf(temp + p, sizeof(temp) - p, "byte ptr ");
                    break;
                case 16:
                    p += snprintf(temp + p, sizeof(temp) - p, "word ptr ");
                    break;
                case 32:
                    p += snprintf(temp + p, sizeof(temp) - p, "dword ptr ");
                    break;
                case 64:
                    p += snprintf(temp + p, sizeof(temp) - p, "qword ptr ");
                    break;
                case 80:
                    p += snprintf(temp + p, sizeof(temp) - p, "tword ptr ");
                    break;
                case 128:
                    p += snprintf(temp + p, sizeof(temp) - p, "xmmword ptr ");
                    break;
                case 256:
                    p += snprintf(temp + p, sizeof(temp) - p, "ymmword ptr ");
                    break;
                case 512:
                    p += snprintf(temp + p, sizeof(temp) - p, "zmmword ptr ");
                    break;
                }

                if (Segment != Registers::Id::Ds && Segment != Registers::Id::Cs)
                {
                    p += snprintf(temp + p, sizeof(temp) - p, "%s:", Registers::GetName(Segment));
                }

                p += snprintf(temp + p, sizeof(temp) - p, "[");

                if (Base != Registers::Id::None)
                {
                    p += snprintf(temp + p, sizeof(temp) - p, "%s", Registers::GetName(Base));
                }

                if (Index != Registers::Id::None)
                {
                    if (Base != Registers::Id::None)
                        p += snprintf(temp + p, sizeof(temp) - p, "+");

                    p += snprintf(temp + p, sizeof(temp) - p, "%s", Registers::GetName(Index));
                }

                if (Scale > 0)
                {
                    if (Index != Registers::Id::None)
                        p += snprintf(temp + p, sizeof(temp) - p, "*");

                    p += snprintf(temp + p, sizeof(temp) - p, "%d", Scale);
                }

                if (Displacement > 0)
                {
                    auto val = Displacement;
                    if (Base != Registers::Id::None || Index != Registers::Id::None)
                    {
                        if (val < 0)
                        {
                            p += snprintf(temp + p, sizeof(temp) - p, "-");
                            val = -val;
                        }
                        else
                        {
                            p += snprintf(temp + p, sizeof(temp) - p, "+");
                        }
                    }
                    p += snprintf(temp + p, sizeof(temp) - p, "%llu", val);
                }

                p += snprintf(temp + p, sizeof(temp) - p, "]");

                return gcnew System::String(temp);
            }
        };
    };

}

```

`src/Bindings/Instruction.Operands.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstdlib>
#include <cstdio>

#include "Register.hpp"
#include "Mnemonic.hpp"
#include "Instruction.Operand.hpp"

namespace Dotx64Dbg {

    public ref class Operands
    {
    private:
        static int AddressSize()
        {
#ifdef _M_X64
            return 64;
#else
            return 32;
#endif
        }

    public:
        // Byte
        //////////////////////////////////////////////////////////////////////////
        static Operand::Memory^ BytePtr(Int64 disp)
        {
            return gcnew Operand::Memory(8, Registers::Id::None, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ BytePtr(Registers::Id baseReg)
        {
            return gcnew Operand::Memory(8, baseReg, Registers::Id::None, 0, 0);
        }
        static Operand::Memory^ BytePtr(Operand::Register^ baseReg)
        {
            return gcnew Operand::Memory(8, baseReg->Value, Registers::Id::None, 0, 0);
        }

        static Operand::Memory^ BytePtr(Registers::Id baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(8, baseReg, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ BytePtr(Operand::Register^ baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(8, baseReg->Value, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ BytePtr(Registers::Id baseReg, Registers::Id index)
        {
            return gcnew Operand::Memory(8, baseReg, index, 0, 0);
        }
        static Operand::Memory^ BytePtr(Operand::Register^ baseReg, Operand::Register^ index)
        {
            return gcnew Operand::Memory(8, baseReg->Value, index->Value, 0, 0);
        }

        static Operand::Memory^ BytePtr(Registers::Id baseReg, Registers::Id index, Int64 disp)
        {
            return gcnew Operand::Memory(8, baseReg, index, 0, disp);
        }
        static Operand::Memory^ BytePtr(Operand::Register^ baseReg, Operand::Register^ index, Int64 disp)
        {
            return gcnew Operand::Memory(8, baseReg->Value, index->Value, 0, disp);
        }

        static Operand::Memory^ BytePtr(Registers::Id baseReg, Registers::Id index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(8, baseReg, index, scale, disp);
        }
        static Operand::Memory^ BytePtr(Operand::Register^ baseReg, Operand::Register^ index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(8, baseReg->Value, index->Value, scale, disp);
        }

        // Word
        //////////////////////////////////////////////////////////////////////////
        static Operand::Memory^ WordPtr(Int64 disp)
        {
            return gcnew Operand::Memory(16, Registers::Id::None, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ WordPtr(Registers::Id baseReg)
        {
            return gcnew Operand::Memory(16, baseReg, Registers::Id::None, 0, 0);
        }
        static Operand::Memory^ WordPtr(Operand::Register^ baseReg)
        {
            return gcnew Operand::Memory(16, baseReg->Value, Registers::Id::None, 0, 0);
        }

        static Operand::Memory^ WordPtr(Registers::Id baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(16, baseReg, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ WordPtr(Operand::Register^ baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(16, baseReg->Value, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ WordPtr(Registers::Id baseReg, Registers::Id index)
        {
            return gcnew Operand::Memory(16, baseReg, index, 0, 0);
        }
        static Operand::Memory^ WordPtr(Operand::Register^ baseReg, Operand::Register^ index)
        {
            return gcnew Operand::Memory(16, baseReg->Value, index->Value, 0, 0);
        }

        static Operand::Memory^ WordPtr(Registers::Id baseReg, Registers::Id index, Int64 disp)
        {
            return gcnew Operand::Memory(16, baseReg, index, 0, disp);
        }
        static Operand::Memory^ WordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int64 disp)
        {
            return gcnew Operand::Memory(16, baseReg->Value, index->Value, 0, disp);
        }

        static Operand::Memory^ WordPtr(Registers::Id baseReg, Registers::Id index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(16, baseReg, index, scale, disp);
        }
        static Operand::Memory^ WordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(16, baseReg->Value, index->Value, scale, disp);
        }

        // Dword
        //////////////////////////////////////////////////////////////////////////
        static Operand::Memory^ DwordPtr(Int64 disp)
        {
            return gcnew Operand::Memory(32, Registers::Id::None, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ DwordPtr(Registers::Id baseReg)
        {
            return gcnew Operand::Memory(32, baseReg, Registers::Id::None, 0, 0);
        }
        static Operand::Memory^ DwordPtr(Operand::Register^ baseReg)
        {
            return gcnew Operand::Memory(32, baseReg->Value, Registers::Id::None, 0, 0);
        }

        static Operand::Memory^ DwordPtr(Registers::Id baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(32, baseReg, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ DwordPtr(Operand::Register^ baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(32, baseReg->Value, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ DwordPtr(Registers::Id baseReg, Registers::Id index)
        {
            return gcnew Operand::Memory(32, baseReg, index, 0, 0);
        }
        static Operand::Memory^ DwordPtr(Operand::Register^ baseReg, Operand::Register^ index)
        {
            return gcnew Operand::Memory(32, baseReg->Value, index->Value, 0, 0);
        }

        static Operand::Memory^ DwordPtr(Registers::Id baseReg, Registers::Id index, Int64 disp)
        {
            return gcnew Operand::Memory(32, baseReg, index, 0, disp);
        }
        static Operand::Memory^ DwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int64 disp)
        {
            return gcnew Operand::Memory(32, baseReg->Value, index->Value, 0, disp);
        }

        static Operand::Memory^ DwordPtr(Registers::Id baseReg, Registers::Id index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(32, baseReg, index, scale, disp);
        }
        static Operand::Memory^ DwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(32, baseReg->Value, index->Value, scale, disp);
        }

        // Qword
        //////////////////////////////////////////////////////////////////////////
        static Operand::Memory^ QwordPtr(Int64 disp)
        {
            return gcnew Operand::Memory(64, Registers::Id::None, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ QwordPtr(Registers::Id baseReg)
        {
            return gcnew Operand::Memory(64, baseReg, Registers::Id::None, 0, 0);
        }
        static Operand::Memory^ QwordPtr(Operand::Register^ baseReg)
        {
            return gcnew Operand::Memory(64, baseReg->Value, Registers::Id::None, 0, 0);
        }

        static Operand::Memory^ QwordPtr(Registers::Id baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(64, baseReg, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ QwordPtr(Operand::Register^ baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(64, baseReg->Value, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ QwordPtr(Registers::Id baseReg, Registers::Id index)
        {
            return gcnew Operand::Memory(64, baseReg, index, 0, 0);
        }
        static Operand::Memory^ QwordPtr(Operand::Register^ baseReg, Operand::Register^ index)
        {
            return gcnew Operand::Memory(64, baseReg->Value, index->Value, 0, 0);
        }

        static Operand::Memory^ QwordPtr(Registers::Id baseReg, Registers::Id index, Int64 disp)
        {
            return gcnew Operand::Memory(64, baseReg, index, 0, disp);
        }
        static Operand::Memory^ QwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int64 disp)
        {
            return gcnew Operand::Memory(64, baseReg->Value, index->Value, 0, disp);
        }

        static Operand::Memory^ QwordPtr(Registers::Id baseReg, Registers::Id index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(64, baseReg, index, scale, disp);
        }
        static Operand::Memory^ QwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(64, baseReg->Value, index->Value, scale, disp);
        }

        // Tword
        //////////////////////////////////////////////////////////////////////////
        static Operand::Memory^ TwordPtr(Int64 disp)
        {
            return gcnew Operand::Memory(80, Registers::Id::None, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ TwordPtr(Registers::Id baseReg)
        {
            return gcnew Operand::Memory(80, baseReg, Registers::Id::None, 0, 0);
        }
        static Operand::Memory^ TwordPtr(Operand::Register^ baseReg)
        {
            return gcnew Operand::Memory(80, baseReg->Value, Registers::Id::None, 0, 0);
        }

        static Operand::Memory^ TwordPtr(Registers::Id baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(80, baseReg, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ TwordPtr(Operand::Register^ baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(80, baseReg->Value, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ TwordPtr(Registers::Id baseReg, Registers::Id index)
        {
            return gcnew Operand::Memory(80, baseReg, index, 0, 0);
        }
        static Operand::Memory^ TwordPtr(Operand::Register^ baseReg, Operand::Register^ index)
        {
            return gcnew Operand::Memory(80, baseReg->Value, index->Value, 0, 0);
        }

        static Operand::Memory^ TwordPtr(Registers::Id baseReg, Registers::Id index, Int64 disp)
        {
            return gcnew Operand::Memory(80, baseReg, index, 0, disp);
        }
        static Operand::Memory^ TwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int64 disp)
        {
            return gcnew Operand::Memory(80, baseReg->Value, index->Value, 0, disp);
        }

        static Operand::Memory^ TwordPtr(Registers::Id baseReg, Registers::Id index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(80, baseReg, index, scale, disp);
        }
        static Operand::Memory^ TwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(80, baseReg->Value, index->Value, scale, disp);
        }

        // Xmmword
        //////////////////////////////////////////////////////////////////////////
        static Operand::Memory^ XmmwordPtr(Int64 disp)
        {
            return gcnew Operand::Memory(128, Registers::Id::None, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ XmmwordPtr(Registers::Id baseReg)
        {
            return gcnew Operand::Memory(128, baseReg, Registers::Id::None, 0, 0);
        }
        static Operand::Memory^ XmmwordPtr(Operand::Register^ baseReg)
        {
            return gcnew Operand::Memory(128, baseReg->Value, Registers::Id::None, 0, 0);
        }

        static Operand::Memory^ XmmwordPtr(Registers::Id baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(128, baseReg, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ XmmwordPtr(Operand::Register^ baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(128, baseReg->Value, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ XmmwordPtr(Registers::Id baseReg, Registers::Id index)
        {
            return gcnew Operand::Memory(128, baseReg, index, 0, 0);
        }
        static Operand::Memory^ XmmwordPtr(Operand::Register^ baseReg, Operand::Register^ index)
        {
            return gcnew Operand::Memory(128, baseReg->Value, index->Value, 0, 0);
        }

        static Operand::Memory^ XmmwordPtr(Registers::Id baseReg, Registers::Id index, Int64 disp)
        {
            return gcnew Operand::Memory(128, baseReg, index, 0, disp);
        }
        static Operand::Memory^ XmmwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int64 disp)
        {
            return gcnew Operand::Memory(128, baseReg->Value, index->Value, 0, disp);
        }

        static Operand::Memory^ XmmwordPtr(Registers::Id baseReg, Registers::Id index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(128, baseReg, index, scale, disp);
        }
        static Operand::Memory^ XmmwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(128, baseReg->Value, index->Value, scale, disp);
        }

        // Ymmword
        //////////////////////////////////////////////////////////////////////////
        static Operand::Memory^ YmmwordPtr(Int64 disp)
        {
            return gcnew Operand::Memory(256, Registers::Id::None, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ YmmwordPtr(Registers::Id baseReg)
        {
            return gcnew Operand::Memory(256, baseReg, Registers::Id::None, 0, 0);
        }
        static Operand::Memory^ YmmwordPtr(Operand::Register^ baseReg)
        {
            return gcnew Operand::Memory(256, baseReg->Value, Registers::Id::None, 0, 0);
        }

        static Operand::Memory^ YmmwordPtr(Registers::Id baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(256, baseReg, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ YmmwordPtr(Operand::Register^ baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(256, baseReg->Value, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ YmmwordPtr(Registers::Id baseReg, Registers::Id index)
        {
            return gcnew Operand::Memory(256, baseReg, index, 0, 0);
        }
        static Operand::Memory^ YmmwordPtr(Operand::Register^ baseReg, Operand::Register^ index)
        {
            return gcnew Operand::Memory(256, baseReg->Value, index->Value, 0, 0);
        }

        static Operand::Memory^ YmmwordPtr(Registers::Id baseReg, Registers::Id index, Int64 disp)
        {
            return gcnew Operand::Memory(256, baseReg, index, 0, disp);
        }
        static Operand::Memory^ YmmwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int64 disp)
        {
            return gcnew Operand::Memory(256, baseReg->Value, index->Value, 0, disp);
        }

        static Operand::Memory^ YmmwordPtr(Registers::Id baseReg, Registers::Id index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(256, baseReg, index, scale, disp);
        }
        static Operand::Memory^ YmmwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(256, baseReg->Value, index->Value, scale, disp);
        }

        // Zmmword
        //////////////////////////////////////////////////////////////////////////
        static Operand::Memory^ ZmmwordPtr(Int64 disp)
        {
            return gcnew Operand::Memory(512, Registers::Id::None, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ ZmmwordPtr(Registers::Id baseReg)
        {
            return gcnew Operand::Memory(512, baseReg, Registers::Id::None, 0, 0);
        }
        static Operand::Memory^ ZmmwordPtr(Operand::Register^ baseReg)
        {
            return gcnew Operand::Memory(512, baseReg->Value, Registers::Id::None, 0, 0);
        }

        static Operand::Memory^ ZmmwordPtr(Registers::Id baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(512, baseReg, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ ZmmwordPtr(Operand::Register^ baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(512, baseReg->Value, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ ZmmwordPtr(Registers::Id baseReg, Registers::Id index)
        {
            return gcnew Operand::Memory(512, baseReg, index, 0, 0);
        }
        static Operand::Memory^ ZmmwordPtr(Operand::Register^ baseReg, Operand::Register^ index)
        {
            return gcnew Operand::Memory(512, baseReg->Value, index->Value, 0, 0);
        }

        static Operand::Memory^ ZmmwordPtr(Registers::Id baseReg, Registers::Id index, Int64 disp)
        {
            return gcnew Operand::Memory(512, baseReg, index, 0, disp);
        }
        static Operand::Memory^ ZmmwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int64 disp)
        {
            return gcnew Operand::Memory(512, baseReg->Value, index->Value, 0, disp);
        }

        static Operand::Memory^ ZmmwordPtr(Registers::Id baseReg, Registers::Id index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(512, baseReg, index, scale, disp);
        }
        static Operand::Memory^ ZmmwordPtr(Operand::Register^ baseReg, Operand::Register^ index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(512, baseReg->Value, index->Value, scale, disp);
        }

        // Host
        //////////////////////////////////////////////////////////////////////////
        static Operand::Memory^ Ptr(Int64 disp)
        {
            return gcnew Operand::Memory(AddressSize(), Registers::Id::None, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ Ptr(Registers::Id baseReg)
        {
            return gcnew Operand::Memory(AddressSize(), baseReg, Registers::Id::None, 0, 0);
        }
        static Operand::Memory^ Ptr(Operand::Register^ baseReg)
        {
            return gcnew Operand::Memory(AddressSize(), baseReg->Value, Registers::Id::None, 0, 0);
        }

        static Operand::Memory^ Ptr(Registers::Id baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(AddressSize(), baseReg, Registers::Id::None, 0, disp);
        }
        static Operand::Memory^ Ptr(Operand::Register^ baseReg, Int64 disp)
        {
            return gcnew Operand::Memory(AddressSize(), baseReg->Value, Registers::Id::None, 0, disp);
        }

        static Operand::Memory^ Ptr(Registers::Id baseReg, Registers::Id index)
        {
            return gcnew Operand::Memory(AddressSize(), baseReg, index, 0, 0);
        }
        static Operand::Memory^ Ptr(Operand::Register^ baseReg, Operand::Register^ index)
        {
            return gcnew Operand::Memory(AddressSize(), baseReg->Value, index->Value, 0, 0);
        }

        static Operand::Memory^ Ptr(Registers::Id baseReg, Registers::Id index, Int64 disp)
        {
            return gcnew Operand::Memory(AddressSize(), baseReg, index, 0, disp);
        }
        static Operand::Memory^ Ptr(Operand::Register^ baseReg, Operand::Register^ index, Int64 disp)
        {
            return gcnew Operand::Memory(AddressSize(), baseReg->Value, index->Value, 0, disp);
        }

        static Operand::Memory^ Ptr(Registers::Id baseReg, Registers::Id index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(AddressSize(), baseReg, index, scale, disp);
        }
        static Operand::Memory^ Ptr(Operand::Register^ baseReg, Operand::Register^ index, Int32 scale, Int64 disp)
        {
            return gcnew Operand::Memory(AddressSize(), baseReg->Value, index->Value, scale, disp);
        }

    public:
        // General purpose registers  8-bit
        static initonly Operand::Register^ Al = gcnew Operand::Register(Registers::Id::Al);
        static initonly Operand::Register^ Cl = gcnew Operand::Register(Registers::Id::Cl);
        static initonly Operand::Register^ Dl = gcnew Operand::Register(Registers::Id::Dl);
        static initonly Operand::Register^ Bl = gcnew Operand::Register(Registers::Id::Bl);
        static initonly Operand::Register^ Ah = gcnew Operand::Register(Registers::Id::Ah);
        static initonly Operand::Register^ Ch = gcnew Operand::Register(Registers::Id::Ch);
        static initonly Operand::Register^ Dh = gcnew Operand::Register(Registers::Id::Dh);
        static initonly Operand::Register^ Bh = gcnew Operand::Register(Registers::Id::Bh);
        static initonly Operand::Register^ Spl = gcnew Operand::Register(Registers::Id::Spl);
        static initonly Operand::Register^ Bpl = gcnew Operand::Register(Registers::Id::Bpl);
        static initonly Operand::Register^ Sil = gcnew Operand::Register(Registers::Id::Sil);
        static initonly Operand::Register^ Dil = gcnew Operand::Register(Registers::Id::Dil);
#if _M_X64
        static initonly Operand::Register^ R8b = gcnew Operand::Register(Registers::Id::R8b);
        static initonly Operand::Register^ R9b = gcnew Operand::Register(Registers::Id::R9b);
        static initonly Operand::Register^ R10b = gcnew Operand::Register(Registers::Id::R10b);
        static initonly Operand::Register^ R11b = gcnew Operand::Register(Registers::Id::R11b);
        static initonly Operand::Register^ R12b = gcnew Operand::Register(Registers::Id::R12b);
        static initonly Operand::Register^ R13b = gcnew Operand::Register(Registers::Id::R13b);
        static initonly Operand::Register^ R14b = gcnew Operand::Register(Registers::Id::R14b);
        static initonly Operand::Register^ R15b = gcnew Operand::Register(Registers::Id::R15b);
#endif
        // General purpose registers 16-bit
        static initonly Operand::Register^ Ax = gcnew Operand::Register(Registers::Id::Ax);
        static initonly Operand::Register^ Cx = gcnew Operand::Register(Registers::Id::Cx);
        static initonly Operand::Register^ Dx = gcnew Operand::Register(Registers::Id::Dx);
        static initonly Operand::Register^ Bx = gcnew Operand::Register(Registers::Id::Bx);
        static initonly Operand::Register^ Sp = gcnew Operand::Register(Registers::Id::Sp);
        static initonly Operand::Register^ Bp = gcnew Operand::Register(Registers::Id::Bp);
        static initonly Operand::Register^ Si = gcnew Operand::Register(Registers::Id::Si);
        static initonly Operand::Register^ Di = gcnew Operand::Register(Registers::Id::Di);
#if _M_X64
        static initonly Operand::Register^ R8w = gcnew Operand::Register(Registers::Id::R8w);
        static initonly Operand::Register^ R9w = gcnew Operand::Register(Registers::Id::R9w);
        static initonly Operand::Register^ R10w = gcnew Operand::Register(Registers::Id::R10w);
        static initonly Operand::Register^ R11w = gcnew Operand::Register(Registers::Id::R11w);
        static initonly Operand::Register^ R12w = gcnew Operand::Register(Registers::Id::R12w);
        static initonly Operand::Register^ R13w = gcnew Operand::Register(Registers::Id::R13w);
        static initonly Operand::Register^ R14w = gcnew Operand::Register(Registers::Id::R14w);
        static initonly Operand::Register^ R15w = gcnew Operand::Register(Registers::Id::R15w);
#endif
        // General purpose registers 32-bit
        static initonly Operand::Register^ Eax = gcnew Operand::Register(Registers::Id::Eax);
        static initonly Operand::Register^ Ecx = gcnew Operand::Register(Registers::Id::Ecx);
        static initonly Operand::Register^ Edx = gcnew Operand::Register(Registers::Id::Edx);
        static initonly Operand::Register^ Ebx = gcnew Operand::Register(Registers::Id::Ebx);
        static initonly Operand::Register^ Esp = gcnew Operand::Register(Registers::Id::Esp);
        static initonly Operand::Register^ Ebp = gcnew Operand::Register(Registers::Id::Ebp);
        static initonly Operand::Register^ Esi = gcnew Operand::Register(Registers::Id::Esi);
        static initonly Operand::Register^ Edi = gcnew Operand::Register(Registers::Id::Edi);
        static initonly Operand::Register^ R8d = gcnew Operand::Register(Registers::Id::R8d);
        static initonly Operand::Register^ R9d = gcnew Operand::Register(Registers::Id::R9d);
        static initonly Operand::Register^ R10d = gcnew Operand::Register(Registers::Id::R10d);
        static initonly Operand::Register^ R11d = gcnew Operand::Register(Registers::Id::R11d);
        static initonly Operand::Register^ R12d = gcnew Operand::Register(Registers::Id::R12d);
        static initonly Operand::Register^ R13d = gcnew Operand::Register(Registers::Id::R13d);
        static initonly Operand::Register^ R14d = gcnew Operand::Register(Registers::Id::R14d);
        static initonly Operand::Register^ R15d = gcnew Operand::Register(Registers::Id::R15d);

#if _M_X64
        // General purpose registers 64-bit
        static initonly Operand::Register^ Rax = gcnew Operand::Register(Registers::Id::Rax);
        static initonly Operand::Register^ Rcx = gcnew Operand::Register(Registers::Id::Rcx);
        static initonly Operand::Register^ Rdx = gcnew Operand::Register(Registers::Id::Rdx);
        static initonly Operand::Register^ Rbx = gcnew Operand::Register(Registers::Id::Rbx);
        static initonly Operand::Register^ Rsp = gcnew Operand::Register(Registers::Id::Rsp);
        static initonly Operand::Register^ Rbp = gcnew Operand::Register(Registers::Id::Rbp);
        static initonly Operand::Register^ Rsi = gcnew Operand::Register(Registers::Id::Rsi);
        static initonly Operand::Register^ Rdi = gcnew Operand::Register(Registers::Id::Rdi);
        static initonly Operand::Register^ R8 = gcnew Operand::Register(Registers::Id::R8);
        static initonly Operand::Register^ R9 = gcnew Operand::Register(Registers::Id::R9);
        static initonly Operand::Register^ R10 = gcnew Operand::Register(Registers::Id::R10);
        static initonly Operand::Register^ R11 = gcnew Operand::Register(Registers::Id::R11);
        static initonly Operand::Register^ R12 = gcnew Operand::Register(Registers::Id::R12);
        static initonly Operand::Register^ R13 = gcnew Operand::Register(Registers::Id::R13);
        static initonly Operand::Register^ R14 = gcnew Operand::Register(Registers::Id::R14);
        static initonly Operand::Register^ R15 = gcnew Operand::Register(Registers::Id::R15);
#endif
        // Floating point legacy registers
        static initonly Operand::Register^ St0 = gcnew Operand::Register(Registers::Id::St0);
        static initonly Operand::Register^ St1 = gcnew Operand::Register(Registers::Id::St1);
        static initonly Operand::Register^ St2 = gcnew Operand::Register(Registers::Id::St2);
        static initonly Operand::Register^ St3 = gcnew Operand::Register(Registers::Id::St3);
        static initonly Operand::Register^ St4 = gcnew Operand::Register(Registers::Id::St4);
        static initonly Operand::Register^ St5 = gcnew Operand::Register(Registers::Id::St5);
        static initonly Operand::Register^ St6 = gcnew Operand::Register(Registers::Id::St6);
        static initonly Operand::Register^ St7 = gcnew Operand::Register(Registers::Id::St7);
        static initonly Operand::Register^ X87Control = gcnew Operand::Register(Registers::Id::X87Control);
        static initonly Operand::Register^ X87Status = gcnew Operand::Register(Registers::Id::X87Status);
        static initonly Operand::Register^ X87Tag = gcnew Operand::Register(Registers::Id::X87Tag);
        // Floating point multimedia registers
        static initonly Operand::Register^ Mm0 = gcnew Operand::Register(Registers::Id::Mm0);
        static initonly Operand::Register^ Mm1 = gcnew Operand::Register(Registers::Id::Mm1);
        static initonly Operand::Register^ Mm2 = gcnew Operand::Register(Registers::Id::Mm2);
        static initonly Operand::Register^ Mm3 = gcnew Operand::Register(Registers::Id::Mm3);
        static initonly Operand::Register^ Mm4 = gcnew Operand::Register(Registers::Id::Mm4);
        static initonly Operand::Register^ Mm5 = gcnew Operand::Register(Registers::Id::Mm5);
        static initonly Operand::Register^ Mm6 = gcnew Operand::Register(Registers::Id::Mm6);
        static initonly Operand::Register^ Mm7 = gcnew Operand::Register(Registers::Id::Mm7);
        // Floating point vector registers 128-bit
        static initonly Operand::Register^ Xmm0 = gcnew Operand::Register(Registers::Id::Xmm0);
        static initonly Operand::Register^ Xmm1 = gcnew Operand::Register(Registers::Id::Xmm1);
        static initonly Operand::Register^ Xmm2 = gcnew Operand::Register(Registers::Id::Xmm2);
        static initonly Operand::Register^ Xmm3 = gcnew Operand::Register(Registers::Id::Xmm3);
        static initonly Operand::Register^ Xmm4 = gcnew Operand::Register(Registers::Id::Xmm4);
        static initonly Operand::Register^ Xmm5 = gcnew Operand::Register(Registers::Id::Xmm5);
        static initonly Operand::Register^ Xmm6 = gcnew Operand::Register(Registers::Id::Xmm6);
        static initonly Operand::Register^ Xmm7 = gcnew Operand::Register(Registers::Id::Xmm7);
        static initonly Operand::Register^ Xmm8 = gcnew Operand::Register(Registers::Id::Xmm8);
        static initonly Operand::Register^ Xmm9 = gcnew Operand::Register(Registers::Id::Xmm9);
        static initonly Operand::Register^ Xmm10 = gcnew Operand::Register(Registers::Id::Xmm10);
        static initonly Operand::Register^ Xmm11 = gcnew Operand::Register(Registers::Id::Xmm11);
        static initonly Operand::Register^ Xmm12 = gcnew Operand::Register(Registers::Id::Xmm12);
        static initonly Operand::Register^ Xmm13 = gcnew Operand::Register(Registers::Id::Xmm13);
        static initonly Operand::Register^ Xmm14 = gcnew Operand::Register(Registers::Id::Xmm14);
        static initonly Operand::Register^ Xmm15 = gcnew Operand::Register(Registers::Id::Xmm15);
        static initonly Operand::Register^ Xmm16 = gcnew Operand::Register(Registers::Id::Xmm16);
        static initonly Operand::Register^ Xmm17 = gcnew Operand::Register(Registers::Id::Xmm17);
        static initonly Operand::Register^ Xmm18 = gcnew Operand::Register(Registers::Id::Xmm18);
        static initonly Operand::Register^ Xmm19 = gcnew Operand::Register(Registers::Id::Xmm19);
        static initonly Operand::Register^ Xmm20 = gcnew Operand::Register(Registers::Id::Xmm20);
        static initonly Operand::Register^ Xmm21 = gcnew Operand::Register(Registers::Id::Xmm21);
        static initonly Operand::Register^ Xmm22 = gcnew Operand::Register(Registers::Id::Xmm22);
        static initonly Operand::Register^ Xmm23 = gcnew Operand::Register(Registers::Id::Xmm23);
        static initonly Operand::Register^ Xmm24 = gcnew Operand::Register(Registers::Id::Xmm24);
        static initonly Operand::Register^ Xmm25 = gcnew Operand::Register(Registers::Id::Xmm25);
        static initonly Operand::Register^ Xmm26 = gcnew Operand::Register(Registers::Id::Xmm26);
        static initonly Operand::Register^ Xmm27 = gcnew Operand::Register(Registers::Id::Xmm27);
        static initonly Operand::Register^ Xmm28 = gcnew Operand::Register(Registers::Id::Xmm28);
        static initonly Operand::Register^ Xmm29 = gcnew Operand::Register(Registers::Id::Xmm29);
        static initonly Operand::Register^ Xmm30 = gcnew Operand::Register(Registers::Id::Xmm30);
        static initonly Operand::Register^ Xmm31 = gcnew Operand::Register(Registers::Id::Xmm31);
        // Floating point vector registers 256-bit
        static initonly Operand::Register^ Ymm0 = gcnew Operand::Register(Registers::Id::Ymm0);
        static initonly Operand::Register^ Ymm1 = gcnew Operand::Register(Registers::Id::Ymm1);
        static initonly Operand::Register^ Ymm2 = gcnew Operand::Register(Registers::Id::Ymm2);
        static initonly Operand::Register^ Ymm3 = gcnew Operand::Register(Registers::Id::Ymm3);
        static initonly Operand::Register^ Ymm4 = gcnew Operand::Register(Registers::Id::Ymm4);
        static initonly Operand::Register^ Ymm5 = gcnew Operand::Register(Registers::Id::Ymm5);
        static initonly Operand::Register^ Ymm6 = gcnew Operand::Register(Registers::Id::Ymm6);
        static initonly Operand::Register^ Ymm7 = gcnew Operand::Register(Registers::Id::Ymm7);
        static initonly Operand::Register^ Ymm8 = gcnew Operand::Register(Registers::Id::Ymm8);
        static initonly Operand::Register^ Ymm9 = gcnew Operand::Register(Registers::Id::Ymm9);
        static initonly Operand::Register^ Ymm10 = gcnew Operand::Register(Registers::Id::Ymm10);
        static initonly Operand::Register^ Ymm11 = gcnew Operand::Register(Registers::Id::Ymm11);
        static initonly Operand::Register^ Ymm12 = gcnew Operand::Register(Registers::Id::Ymm12);
        static initonly Operand::Register^ Ymm13 = gcnew Operand::Register(Registers::Id::Ymm13);
        static initonly Operand::Register^ Ymm14 = gcnew Operand::Register(Registers::Id::Ymm14);
        static initonly Operand::Register^ Ymm15 = gcnew Operand::Register(Registers::Id::Ymm15);
        static initonly Operand::Register^ Ymm16 = gcnew Operand::Register(Registers::Id::Ymm16);
        static initonly Operand::Register^ Ymm17 = gcnew Operand::Register(Registers::Id::Ymm17);
        static initonly Operand::Register^ Ymm18 = gcnew Operand::Register(Registers::Id::Ymm18);
        static initonly Operand::Register^ Ymm19 = gcnew Operand::Register(Registers::Id::Ymm19);
        static initonly Operand::Register^ Ymm20 = gcnew Operand::Register(Registers::Id::Ymm20);
        static initonly Operand::Register^ Ymm21 = gcnew Operand::Register(Registers::Id::Ymm21);
        static initonly Operand::Register^ Ymm22 = gcnew Operand::Register(Registers::Id::Ymm22);
        static initonly Operand::Register^ Ymm23 = gcnew Operand::Register(Registers::Id::Ymm23);
        static initonly Operand::Register^ Ymm24 = gcnew Operand::Register(Registers::Id::Ymm24);
        static initonly Operand::Register^ Ymm25 = gcnew Operand::Register(Registers::Id::Ymm25);
        static initonly Operand::Register^ Ymm26 = gcnew Operand::Register(Registers::Id::Ymm26);
        static initonly Operand::Register^ Ymm27 = gcnew Operand::Register(Registers::Id::Ymm27);
        static initonly Operand::Register^ Ymm28 = gcnew Operand::Register(Registers::Id::Ymm28);
        static initonly Operand::Register^ Ymm29 = gcnew Operand::Register(Registers::Id::Ymm29);
        static initonly Operand::Register^ Ymm30 = gcnew Operand::Register(Registers::Id::Ymm30);
        static initonly Operand::Register^ Ymm31 = gcnew Operand::Register(Registers::Id::Ymm31);
        // Floating point vector registers 512-bit
        static initonly Operand::Register^ Zmm0 = gcnew Operand::Register(Registers::Id::Zmm0);
        static initonly Operand::Register^ Zmm1 = gcnew Operand::Register(Registers::Id::Zmm1);
        static initonly Operand::Register^ Zmm2 = gcnew Operand::Register(Registers::Id::Zmm2);
        static initonly Operand::Register^ Zmm3 = gcnew Operand::Register(Registers::Id::Zmm3);
        static initonly Operand::Register^ Zmm4 = gcnew Operand::Register(Registers::Id::Zmm4);
        static initonly Operand::Register^ Zmm5 = gcnew Operand::Register(Registers::Id::Zmm5);
        static initonly Operand::Register^ Zmm6 = gcnew Operand::Register(Registers::Id::Zmm6);
        static initonly Operand::Register^ Zmm7 = gcnew Operand::Register(Registers::Id::Zmm7);
        static initonly Operand::Register^ Zmm8 = gcnew Operand::Register(Registers::Id::Zmm8);
        static initonly Operand::Register^ Zmm9 = gcnew Operand::Register(Registers::Id::Zmm9);
        static initonly Operand::Register^ Zmm10 = gcnew Operand::Register(Registers::Id::Zmm10);
        static initonly Operand::Register^ Zmm11 = gcnew Operand::Register(Registers::Id::Zmm11);
        static initonly Operand::Register^ Zmm12 = gcnew Operand::Register(Registers::Id::Zmm12);
        static initonly Operand::Register^ Zmm13 = gcnew Operand::Register(Registers::Id::Zmm13);
        static initonly Operand::Register^ Zmm14 = gcnew Operand::Register(Registers::Id::Zmm14);
        static initonly Operand::Register^ Zmm15 = gcnew Operand::Register(Registers::Id::Zmm15);
        static initonly Operand::Register^ Zmm16 = gcnew Operand::Register(Registers::Id::Zmm16);
        static initonly Operand::Register^ Zmm17 = gcnew Operand::Register(Registers::Id::Zmm17);
        static initonly Operand::Register^ Zmm18 = gcnew Operand::Register(Registers::Id::Zmm18);
        static initonly Operand::Register^ Zmm19 = gcnew Operand::Register(Registers::Id::Zmm19);
        static initonly Operand::Register^ Zmm20 = gcnew Operand::Register(Registers::Id::Zmm20);
        static initonly Operand::Register^ Zmm21 = gcnew Operand::Register(Registers::Id::Zmm21);
        static initonly Operand::Register^ Zmm22 = gcnew Operand::Register(Registers::Id::Zmm22);
        static initonly Operand::Register^ Zmm23 = gcnew Operand::Register(Registers::Id::Zmm23);
        static initonly Operand::Register^ Zmm24 = gcnew Operand::Register(Registers::Id::Zmm24);
        static initonly Operand::Register^ Zmm25 = gcnew Operand::Register(Registers::Id::Zmm25);
        static initonly Operand::Register^ Zmm26 = gcnew Operand::Register(Registers::Id::Zmm26);
        static initonly Operand::Register^ Zmm27 = gcnew Operand::Register(Registers::Id::Zmm27);
        static initonly Operand::Register^ Zmm28 = gcnew Operand::Register(Registers::Id::Zmm28);
        static initonly Operand::Register^ Zmm29 = gcnew Operand::Register(Registers::Id::Zmm29);
        static initonly Operand::Register^ Zmm30 = gcnew Operand::Register(Registers::Id::Zmm30);
        static initonly Operand::Register^ Zmm31 = gcnew Operand::Register(Registers::Id::Zmm31);
        // Flags registers
        static initonly Operand::Register^ Flags = gcnew Operand::Register(Registers::Id::Flags);
        static initonly Operand::Register^ EFlags = gcnew Operand::Register(Registers::Id::EFlags);
        static initonly Operand::Register^ RFlags = gcnew Operand::Register(Registers::Id::RFlags);
        // Instruction-pointer registers
        static initonly Operand::Register^ Ip = gcnew Operand::Register(Registers::Id::Ip);
        static initonly Operand::Register^ Eip = gcnew Operand::Register(Registers::Id::Eip);
        static initonly Operand::Register^ Rip = gcnew Operand::Register(Registers::Id::Rip);
        // Segment registers
        static initonly Operand::Register^ Es = gcnew Operand::Register(Registers::Id::Es);
        static initonly Operand::Register^ Cs = gcnew Operand::Register(Registers::Id::Cs);
        static initonly Operand::Register^ Ss = gcnew Operand::Register(Registers::Id::Ss);
        static initonly Operand::Register^ Ds = gcnew Operand::Register(Registers::Id::Ds);
        static initonly Operand::Register^ Fs = gcnew Operand::Register(Registers::Id::Fs);
        static initonly Operand::Register^ Gs = gcnew Operand::Register(Registers::Id::Gs);
        // Table registers
        static initonly Operand::Register^ Gdtr = gcnew Operand::Register(Registers::Id::Gdtr);
        static initonly Operand::Register^ Ldtr = gcnew Operand::Register(Registers::Id::Ldtr);
        static initonly Operand::Register^ Idtr = gcnew Operand::Register(Registers::Id::Idtr);
        static initonly Operand::Register^ Tr = gcnew Operand::Register(Registers::Id::Tr);
        // Test registers
        static initonly Operand::Register^ Tr0 = gcnew Operand::Register(Registers::Id::Tr0);
        static initonly Operand::Register^ Tr1 = gcnew Operand::Register(Registers::Id::Tr1);
        static initonly Operand::Register^ Tr2 = gcnew Operand::Register(Registers::Id::Tr2);
        static initonly Operand::Register^ Tr3 = gcnew Operand::Register(Registers::Id::Tr3);
        static initonly Operand::Register^ Tr4 = gcnew Operand::Register(Registers::Id::Tr4);
        static initonly Operand::Register^ Tr5 = gcnew Operand::Register(Registers::Id::Tr5);
        static initonly Operand::Register^ Tr6 = gcnew Operand::Register(Registers::Id::Tr6);
        static initonly Operand::Register^ Tr7 = gcnew Operand::Register(Registers::Id::Tr7);
        // Control registers
        static initonly Operand::Register^ Cr0 = gcnew Operand::Register(Registers::Id::Cr0);
        static initonly Operand::Register^ Cr1 = gcnew Operand::Register(Registers::Id::Cr1);
        static initonly Operand::Register^ Cr2 = gcnew Operand::Register(Registers::Id::Cr2);
        static initonly Operand::Register^ Cr3 = gcnew Operand::Register(Registers::Id::Cr3);
        static initonly Operand::Register^ Cr4 = gcnew Operand::Register(Registers::Id::Cr4);
        static initonly Operand::Register^ Cr5 = gcnew Operand::Register(Registers::Id::Cr5);
        static initonly Operand::Register^ Cr6 = gcnew Operand::Register(Registers::Id::Cr6);
        static initonly Operand::Register^ Cr7 = gcnew Operand::Register(Registers::Id::Cr7);
        static initonly Operand::Register^ Cr8 = gcnew Operand::Register(Registers::Id::Cr8);
        static initonly Operand::Register^ Cr9 = gcnew Operand::Register(Registers::Id::Cr9);
        static initonly Operand::Register^ Cr10 = gcnew Operand::Register(Registers::Id::Cr10);
        static initonly Operand::Register^ Cr11 = gcnew Operand::Register(Registers::Id::Cr11);
        static initonly Operand::Register^ Cr12 = gcnew Operand::Register(Registers::Id::Cr12);
        static initonly Operand::Register^ Cr13 = gcnew Operand::Register(Registers::Id::Cr13);
        static initonly Operand::Register^ Cr14 = gcnew Operand::Register(Registers::Id::Cr14);
        static initonly Operand::Register^ Cr15 = gcnew Operand::Register(Registers::Id::Cr15);
        // Debug registers
        static initonly Operand::Register^ Dr0 = gcnew Operand::Register(Registers::Id::Dr0);
        static initonly Operand::Register^ Dr1 = gcnew Operand::Register(Registers::Id::Dr1);
        static initonly Operand::Register^ Dr2 = gcnew Operand::Register(Registers::Id::Dr2);
        static initonly Operand::Register^ Dr3 = gcnew Operand::Register(Registers::Id::Dr3);
        static initonly Operand::Register^ Dr4 = gcnew Operand::Register(Registers::Id::Dr4);
        static initonly Operand::Register^ Dr5 = gcnew Operand::Register(Registers::Id::Dr5);
        static initonly Operand::Register^ Dr6 = gcnew Operand::Register(Registers::Id::Dr6);
        static initonly Operand::Register^ Dr7 = gcnew Operand::Register(Registers::Id::Dr7);
        static initonly Operand::Register^ Dr8 = gcnew Operand::Register(Registers::Id::Dr8);
        static initonly Operand::Register^ Dr9 = gcnew Operand::Register(Registers::Id::Dr9);
        static initonly Operand::Register^ Dr10 = gcnew Operand::Register(Registers::Id::Dr10);
        static initonly Operand::Register^ Dr11 = gcnew Operand::Register(Registers::Id::Dr11);
        static initonly Operand::Register^ Dr12 = gcnew Operand::Register(Registers::Id::Dr12);
        static initonly Operand::Register^ Dr13 = gcnew Operand::Register(Registers::Id::Dr13);
        static initonly Operand::Register^ Dr14 = gcnew Operand::Register(Registers::Id::Dr14);
        static initonly Operand::Register^ Dr15 = gcnew Operand::Register(Registers::Id::Dr15);
        // Mask registers
        static initonly Operand::Register^ K0 = gcnew Operand::Register(Registers::Id::K0);
        static initonly Operand::Register^ K1 = gcnew Operand::Register(Registers::Id::K1);
        static initonly Operand::Register^ K2 = gcnew Operand::Register(Registers::Id::K2);
        static initonly Operand::Register^ K3 = gcnew Operand::Register(Registers::Id::K3);
        static initonly Operand::Register^ K4 = gcnew Operand::Register(Registers::Id::K4);
        static initonly Operand::Register^ K5 = gcnew Operand::Register(Registers::Id::K5);
        static initonly Operand::Register^ K6 = gcnew Operand::Register(Registers::Id::K6);
        static initonly Operand::Register^ K7 = gcnew Operand::Register(Registers::Id::K7);
        // Bound registers
        static initonly Operand::Register^ Bnd0 = gcnew Operand::Register(Registers::Id::Bnd0);
        static initonly Operand::Register^ Bnd1 = gcnew Operand::Register(Registers::Id::Bnd1);
        static initonly Operand::Register^ Bnd2 = gcnew Operand::Register(Registers::Id::Bnd2);
        static initonly Operand::Register^ Bnd3 = gcnew Operand::Register(Registers::Id::Bnd3);
        static initonly Operand::Register^ BndCfg = gcnew Operand::Register(Registers::Id::BndCfg);
        static initonly Operand::Register^ BndStatus = gcnew Operand::Register(Registers::Id::BndStatus);
        // Uncategorized
        static initonly Operand::Register^ Mxcsr = gcnew Operand::Register(Registers::Id::Mxcsr);
        static initonly Operand::Register^ Pkru = gcnew Operand::Register(Registers::Id::Pkru);
        static initonly Operand::Register^ Xcr0 = gcnew Operand::Register(Registers::Id::Xcr0);
        // Host specific
        static initonly Operand::Register^ Nax = gcnew Operand::Register(Registers::Id::Nax);
        static initonly Operand::Register^ Ncx = gcnew Operand::Register(Registers::Id::Ncx);
        static initonly Operand::Register^ Ndx = gcnew Operand::Register(Registers::Id::Ndx);
        static initonly Operand::Register^ Nbx = gcnew Operand::Register(Registers::Id::Nbx);
        static initonly Operand::Register^ Nsp = gcnew Operand::Register(Registers::Id::Nsp);
        static initonly Operand::Register^ Nbp = gcnew Operand::Register(Registers::Id::Nbp);
        static initonly Operand::Register^ Nsi = gcnew Operand::Register(Registers::Id::Nsi);
        static initonly Operand::Register^ Ndi = gcnew Operand::Register(Registers::Id::Ndi);
        static initonly Operand::Register^ Nip = gcnew Operand::Register(Registers::Id::Nip);
        static initonly Operand::Register^ NFlags = gcnew Operand::Register(Registers::Id::NFlags);

        static Operand::Register^ Reg(Registers::Id reg)
        {
            return gcnew Operand::Register(reg);
        }

    public:
        static Operand::Immediate^ Imm(Int64 val)
        {
            return gcnew Operand::Immediate(val);
        }
    };

}

```

`src/Bindings/Instruction.cpp`:

```cpp
#include "Instruction.hpp"
#include <cstdio>

namespace Dotx64Dbg {

    System::String^ Instruction::ToString()
    {
        char temp[128]{};

        int p = 0;
        p += snprintf(temp + p, sizeof(temp) - p, "%s", MnemonicGetString(Id));

        System::String^ ins = gcnew System::String(temp);

        for (int i = 0; i < Operands->Length; i++)
        {
            IOperand^ op = GetOperand(i);
            if (op == nullptr || op->Type == OperandType::None)
                break;
            if (GetOperandVisibility(i) == OperandVisibility::Hidden)
                continue;
            if (i > 0)
                ins = ins->Concat(ins, gcnew System::String(", "));
            else
                ins = ins->Concat(ins, gcnew System::String(" "));

            ins = ins->Concat(ins, op->ToString());
        }

        return ins;
    }

}

```

`src/Bindings/Instruction.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstdlib>
#include <cstdio>

#include "Mnemonic.hpp"
#include "Instruction.Operand.hpp"
#include "Instruction.EFlags.hpp"
#include "Instruction.Meta.hpp"

namespace Dotx64Dbg {

    using namespace System;

    public ref class Instruction
    {
    internal:
        array<IOperand^>^ Operands;
        array<OperandVisibility>^ Visibility;
        array<OperandAccess>^ Access;
        Mnemonic _Id{};
        EFlags _FlagsRead{};
        EFlags _FlagsModified{};
        int _Size{};
        uint64_t _Address{};

    public:
        static initonly int32_t MaxOperands = 8;

    private:

        void Init(Mnemonic mnemonic)
        {
            _Id = mnemonic;

            Operands = gcnew array<IOperand^>(MaxOperands);
            Visibility = gcnew array<OperandVisibility>(MaxOperands);
            Access = gcnew array<OperandAccess>(MaxOperands);

            for (int i = 0; i < MaxOperands; i++)
            {
                Operands[i] = Operand::None;
                Visibility[i] = OperandVisibility::Invalid;
                Access[i] = OperandAccess::None;
            }
        }

    public:
        [System::Flags]
        enum class Attributes
        {
            None = 0,
            Lock = (1 << 0),
            Rep = (1 << 1),
            RepNe = (1 << 2),
            RepEq = (1 << 3),
            RepNz = (1 << 4),
        };

        Instruction()
        {
            Init(::Dotx64Dbg::Mnemonic::Invalid);
        }

    internal:
        Instruction(Attributes attribs, Mnemonic id)
        {
            Init(id);
            Attribs = attribs;
        }

        Instruction(Attributes attribs, Mnemonic id, IOperand^ op0)
        {
            Init(id);
            Attribs = attribs;
            SetOperand(0, op0);
        }

        Instruction(Attributes attribs, Mnemonic id, IOperand^ op0, IOperand^ op1)
        {
            Init(id);
            Attribs = attribs;
            SetOperand(0, op0);
            SetOperand(1, op1);
        }

        Instruction(Attributes attribs, Mnemonic id, IOperand^ op0, IOperand^ op1, IOperand^ op2)
        {
            Init(id);
            Attribs = attribs;
            SetOperand(0, op0);
            SetOperand(1, op1);
            SetOperand(2, op2);
        }

        Instruction(Attributes attribs, Mnemonic id, IOperand^ op0, IOperand^ op1, IOperand^ op2, IOperand^ op3)
        {
            Init(id);
            Attribs = attribs;
            SetOperand(0, op0);
            SetOperand(1, op1);
            SetOperand(2, op2);
            SetOperand(3, op3);
        }

    public:
        property uint32_t Size
        {
            uint32_t get()
            {
                return _Size;
            }
        }

        property System::IntPtr Address
        {
            System::IntPtr get()
            {
                return System::IntPtr((long long)_Address);
            }
        }

        property Mnemonic Id
        {
            Mnemonic get()
            {
                return _Id;
            }
        }

        property Mnemonic Mnemonic
        {
            ::Dotx64Dbg::Mnemonic get()
            {
                return _Id;
            }
        }

        property EFlags FlagsWrite
        {
            EFlags get()
            {
                return _FlagsModified;
            }
        }

        property EFlags FlagsRead
        {
            EFlags get()
            {
                return _FlagsRead;
            }
        }

        property Attributes Attribs;

        property bool IsControlFlow
        {
            bool get()
            {
                return InstructionMetaData::isControlFlow(Id);
            }
        }

        property bool IsConditionalControlFlow
        {
            bool get()
            {
                return InstructionMetaData::isCondControlFlow(Id);
            }
        }

        property bool HasCondition
        {
            bool get()
            {
                return FlagsRead != EFlags::None;
            }
        }

        property bool IsCall
        {
            bool get()
            {
                return InstructionMetaData::IsCall(Id);
            }
        }

        property bool IsJmp
        {
            bool get()
            {
                return Id == ::Dotx64Dbg::Mnemonic::Jmp;
            }
        }

        property bool IsRet
        {
            bool get()
            {
                return InstructionMetaData::isRet(Id);
            }
        }

        IOperand^ GetOperand(int index)
        {
            if (index < 0 || index >= MaxOperands)
                return nullptr;

            return Operands[index];
        }

        OperandAccess GetOperandAccess(int index)
        {
            if (index < 0 || index >= MaxOperands)
                return OperandAccess::None;

            return Access[index];
        }

        OperandVisibility GetOperandVisibility(int index)
        {
            if (index < 0 || index >= MaxOperands)
                return OperandVisibility::Invalid;

            return Visibility[index];
        }

        System::String^ ToString() override;

    internal:
        void SetOperand(int index, IOperand^ op)
        {
            if (index < 0 || index >= MaxOperands)
                return;

            Operands[index] = op;
        }

        void SetOperand(int index, IOperand^ op, OperandAccess access, OperandVisibility vis)
        {
            if (index < 0 || index >= MaxOperands)
                return;

            Operands[index] = op;
            Visibility[index] = vis;
            Access[index] = access;
        }

    };
}

```

`src/Bindings/Logging.cpp`:

```cpp
#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "Marshal.hpp"

namespace Dotx64Dbg::Native
{
    public ref class Logging
    {
    public:
        static void Write(System::String^ text)
        {
            auto textStr = interop::toUTF8(text);
            _plugin_logprint(textStr.c_str());
        }

        static void WriteLine(System::String^ text)
        {
            auto textStr = interop::toUTF8(text);
            textStr = textStr + "\n";
            _plugin_logprint(textStr.c_str());
        }

        static void WriteLine()
        {
            _plugin_logprint("\n");
        }
    };
}

```

`src/Bindings/Marshal.hpp`:

```hpp
#pragma once

#include <string>

#pragma push_macro("_CRT_WINDOWS")
#define _CRT_WINDOWS
#include <msclr\marshal.h>
#pragma pop_macro("_CRT_WINDOWS")

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>

namespace interop {

    using namespace System;
    using namespace System::Runtime::InteropServices;

    inline std::string toUTF8(System::String^ str)
    {
        msclr::interop::marshal_context oMarshalContext;

        const wchar_t* cstr = oMarshalContext.marshal_as<const wchar_t*>(str);

        const auto bytesRequired = WideCharToMultiByte(CP_UTF8, 0, cstr, -1, nullptr, 0, nullptr, nullptr);
        if (bytesRequired == 0)
            return {};

        std::string buf;
        buf.resize(bytesRequired);

        const auto bytesCopied = WideCharToMultiByte(CP_UTF8, 0, cstr, -1, &buf[0], bytesRequired, nullptr, nullptr);
        if (bytesRequired == 0)
            return {};

        // std::string has explicit null termination.
        while (buf.size() > 0 && buf.back() == '\0')
            buf.pop_back();

        return buf;
    }

    inline std::wstring toUTF16(System::String^ str)
    {
        msclr::interop::marshal_context oMarshalContext;

        const wchar_t* cstr = oMarshalContext.marshal_as<const wchar_t*>(str);

        return cstr;
    }

    inline System::String^ stringFromUTF8(const char* str)
    {
        return Marshal::PtrToStringUTF8(System::IntPtr((void*)str));
    }
}

```

`src/Bindings/Memory.cpp`:

```cpp
#include <vector>
#include <cstdint>

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_memory.h"

namespace Dotx64Dbg::Native
{
    public ref class Memory
    {
    public:
        /// <summary>
        /// Attempt to read memory from the debugged process.
        /// </summary>
        /// <param name="addr">Virtual address in the debugged process space</param>
        /// <param name="length">Amount of bytes to read</param>
        /// <returns>The bytes read from the process</returns>
        static array<System::Byte>^ Read(System::UIntPtr addr, int length)
        {
            auto va = static_cast<duint>(addr.ToUInt64());

            array<System::Byte>^ res = gcnew array<System::Byte>((int)length);

            pin_ptr<uint8_t> ptr = &res[0];
            uint8_t* buf = ptr;

            duint readSize = 0;
            if (!Script::Memory::Read(va, buf, length, &readSize))
            {
                array<System::Byte>::Resize(res, 0);
                return res;
            }

            array<System::Byte>::Resize(res, (int)readSize);
            return res;
        }

        /// <summary>
        /// Attempt to write memory to the debugged process.
        /// </summary>
        /// <param name="addr">Virtual address in the debugged process space</param>
        /// <param name="data">The bytes to be written</param>
        /// <param name="length">The maximum amount of bytes to write, can not be bigger than `data`</param>
        /// <returns>The amount of bytes written</returns>
        static int Write(System::UIntPtr addr, array<System::Byte>^ data, int length)
        {
            auto va = static_cast<duint>(addr.ToUInt64());

            duint maxLength = data->Length < length ? data->Length : length;
            if (maxLength <= 0)
                return 0;

            pin_ptr<uint8_t> ptr = &data[0];
            const uint8_t* buf = ptr;

            duint bytesWritten = 0;
            if (!Script::Memory::Write(va, buf, maxLength, &bytesWritten))
            {
                return 0;
            }

            return (int)bytesWritten;
        }

        /// <summary>
        /// Attempt to write memory to the debugged process.
        /// </summary>
        /// <param name="addr">Virtual address in the debugged process space</param>
        /// <param name="data">The bytes to be written</param>
        /// <param name="length">The maximum amount of bytes to write, can not be bigger than `data`</param>
        /// <returns>The amount of bytes written</returns>
        static int Write(System::UIntPtr addr, array<System::Byte>^ data, int offset, int length)
        {
            auto va = static_cast<duint>(addr.ToUInt64());

            duint maxLength = data->Length < length ? data->Length : length;
            if (maxLength <= 0)
                return 0;

            pin_ptr<uint8_t> ptr = &data[0];
            const uint8_t* buf = ptr;

            duint bytesWritten = 0;
            if (!Script::Memory::Write(va, buf + offset, maxLength, &bytesWritten))
            {
                return 0;
            }

            return (int)bytesWritten;
        }

        static uint32_t GetProtection(System::UIntPtr addr, bool useCache)
        {
            auto va = static_cast<duint>(addr.ToUInt64());

            return Script::Memory::GetProtect(va, false, useCache);
        }

        static bool SetProtection(System::UIntPtr addr, uint32_t prot, int size)
        {
            auto va = static_cast<duint>(addr.ToUInt64());

            return Script::Memory::SetProtect(va, prot, (duint)size);
        }

        static System::UIntPtr GetBase(System::UIntPtr addr)
        {
            auto va = static_cast<duint>(addr.ToUInt64());

            auto base = Script::Memory::GetBase(va);
            return System::UIntPtr(reinterpret_cast<void*>(base));
        }

        static System::UIntPtr GetSize(System::UIntPtr addr)
        {
            auto va = static_cast<duint>(addr.ToUInt64());

            const uintptr_t size = Script::Memory::GetSize(va);
            return System::UIntPtr(size);
        }

        static System::UIntPtr RemoteAlloc(System::UIntPtr addr, int size)
        {
            uintptr_t va = Script::Memory::RemoteAlloc(addr.ToUInt64(), (duint)size);
            return System::UIntPtr(va);
        }

        static bool RemoteFree(System::UIntPtr addr)
        {
            return Script::Memory::RemoteFree(addr.ToUInt64());
        }
    };
}

```

`src/Bindings/Mnemonic.hpp`:

```hpp
#pragma once

namespace Dotx64Dbg
{

    public enum class Mnemonic
    {
        Invalid,
        Aaa,
        Aad,
        Aam,
        Aas,
        Adc,
        Adcx,
        Add,
        Addpd,
        Addps,
        Addsd,
        Addss,
        Addsubpd,
        Addsubps,
        Adox,
        Aesdec,
        Aesdec128kl,
        Aesdec256kl,
        Aesdeclast,
        Aesdecwide128kl,
        Aesdecwide256kl,
        Aesenc,
        Aesenc128kl,
        Aesenc256kl,
        Aesenclast,
        Aesencwide128kl,
        Aesencwide256kl,
        Aesimc,
        Aeskeygenassist,
        And,
        Andn,
        Andnpd,
        Andnps,
        Andpd,
        Andps,
        Arpl,
        Bextr,
        Blcfill,
        Blci,
        Blcic,
        Blcmsk,
        Blcs,
        Blendpd,
        Blendps,
        Blendvpd,
        Blendvps,
        Blsfill,
        Blsi,
        Blsic,
        Blsmsk,
        Blsr,
        Bndcl,
        Bndcn,
        Bndcu,
        Bndldx,
        Bndmk,
        Bndmov,
        Bndstx,
        Bound,
        Bsf,
        Bsr,
        Bswap,
        Bt,
        Btc,
        Btr,
        Bts,
        Bzhi,
        Call,
        Cbw,
        Cdq,
        Cdqe,
        Clac,
        Clc,
        Cld,
        Cldemote,
        Clevict0,
        Clevict1,
        Clflush,
        Clflushopt,
        Clgi,
        Cli,
        Clrssbsy,
        Clts,
        Clui,
        Clwb,
        Clzero,
        Cmc,
        Cmovb,
        Cmovbe,
        Cmovl,
        Cmovle,
        Cmovnb,
        Cmovnbe,
        Cmovnl,
        Cmovnle,
        Cmovno,
        Cmovnp,
        Cmovns,
        Cmovnz,
        Cmovo,
        Cmovp,
        Cmovs,
        Cmovz,
        Cmp,
        Cmppd,
        Cmpps,
        Cmpsb,
        Cmpsd,
        Cmpsq,
        Cmpss,
        Cmpsw,
        Cmpxchg,
        Cmpxchg16b,
        Cmpxchg8b,
        Comisd,
        Comiss,
        Cpuid,
        Cqo,
        Crc32,
        Cvtdq2pd,
        Cvtdq2ps,
        Cvtpd2dq,
        Cvtpd2pi,
        Cvtpd2ps,
        Cvtpi2pd,
        Cvtpi2ps,
        Cvtps2dq,
        Cvtps2pd,
        Cvtps2pi,
        Cvtsd2si,
        Cvtsd2ss,
        Cvtsi2sd,
        Cvtsi2ss,
        Cvtss2sd,
        Cvtss2si,
        Cvttpd2dq,
        Cvttpd2pi,
        Cvttps2dq,
        Cvttps2pi,
        Cvttsd2si,
        Cvttss2si,
        Cwd,
        Cwde,
        Daa,
        Das,
        Dec,
        Delay,
        Div,
        Divpd,
        Divps,
        Divsd,
        Divss,
        Dppd,
        Dpps,
        Emms,
        Encls,
        Enclu,
        Enclv,
        Encodekey128,
        Encodekey256,
        Endbr32,
        Endbr64,
        Enqcmd,
        Enqcmds,
        Enter,
        Extractps,
        Extrq,
        F2xm1,
        Fabs,
        Fadd,
        Faddp,
        Fbld,
        Fbstp,
        Fchs,
        Fcmovb,
        Fcmovbe,
        Fcmove,
        Fcmovnb,
        Fcmovnbe,
        Fcmovne,
        Fcmovnu,
        Fcmovu,
        Fcom,
        Fcomi,
        Fcomip,
        Fcomp,
        Fcompp,
        Fcos,
        Fdecstp,
        Fdisi8087_nop,
        Fdiv,
        Fdivp,
        Fdivr,
        Fdivrp,
        Femms,
        Feni8087_nop,
        Ffree,
        Ffreep,
        Fiadd,
        Ficom,
        Ficomp,
        Fidiv,
        Fidivr,
        Fild,
        Fimul,
        Fincstp,
        Fist,
        Fistp,
        Fisttp,
        Fisub,
        Fisubr,
        Fld,
        Fld1,
        Fldcw,
        Fldenv,
        Fldl2e,
        Fldl2t,
        Fldlg2,
        Fldln2,
        Fldpi,
        Fldz,
        Fmul,
        Fmulp,
        Fnclex,
        Fninit,
        Fnop,
        Fnsave,
        Fnstcw,
        Fnstenv,
        Fnstsw,
        Fpatan,
        Fprem,
        Fprem1,
        Fptan,
        Frndint,
        Frstor,
        Fscale,
        Fsetpm287_nop,
        Fsin,
        Fsincos,
        Fsqrt,
        Fst,
        Fstp,
        Fstpnce,
        Fsub,
        Fsubp,
        Fsubr,
        Fsubrp,
        Ftst,
        Fucom,
        Fucomi,
        Fucomip,
        Fucomp,
        Fucompp,
        Fwait,
        Fxam,
        Fxch,
        Fxrstor,
        Fxrstor64,
        Fxsave,
        Fxsave64,
        Fxtract,
        Fyl2x,
        Fyl2xp1,
        Getsec,
        Gf2p8affineinvqb,
        Gf2p8affineqb,
        Gf2p8mulb,
        Haddpd,
        Haddps,
        Hlt,
        Hreset,
        Hsubpd,
        Hsubps,
        Idiv,
        Imul,
        In,
        Inc,
        Incsspd,
        Incsspq,
        Insb,
        Insd,
        Insertps,
        Insertq,
        Insw,
        Int,
        Int1,
        Int3,
        Into,
        Invd,
        Invept,
        Invlpg,
        Invlpga,
        Invlpgb,
        Invpcid,
        Invvpid,
        Iret,
        Iretd,
        Iretq,
        Jb,
        Jbe,
        Jcxz,
        Jecxz,
        Jknzd,
        Jkzd,
        Jl,
        Jle,
        Jmp,
        Jnb,
        Jnbe,
        Jnl,
        Jnle,
        Jno,
        Jnp,
        Jns,
        Jnz,
        Jo,
        Jp,
        Jrcxz,
        Js,
        Jz,
        Kaddb,
        Kaddd,
        Kaddq,
        Kaddw,
        Kand,
        Kandb,
        Kandd,
        Kandn,
        Kandnb,
        Kandnd,
        Kandnq,
        Kandnr,
        Kandnw,
        Kandq,
        Kandw,
        Kconcath,
        Kconcatl,
        Kextract,
        Kmerge2l1h,
        Kmerge2l1l,
        Kmov,
        Kmovb,
        Kmovd,
        Kmovq,
        Kmovw,
        Knot,
        Knotb,
        Knotd,
        Knotq,
        Knotw,
        Kor,
        Korb,
        Kord,
        Korq,
        Kortest,
        Kortestb,
        Kortestd,
        Kortestq,
        Kortestw,
        Korw,
        Kshiftlb,
        Kshiftld,
        Kshiftlq,
        Kshiftlw,
        Kshiftrb,
        Kshiftrd,
        Kshiftrq,
        Kshiftrw,
        Ktestb,
        Ktestd,
        Ktestq,
        Ktestw,
        Kunpckbw,
        Kunpckdq,
        Kunpckwd,
        Kxnor,
        Kxnorb,
        Kxnord,
        Kxnorq,
        Kxnorw,
        Kxor,
        Kxorb,
        Kxord,
        Kxorq,
        Kxorw,
        Lahf,
        Lar,
        Lddqu,
        Ldmxcsr,
        Lds,
        Ldtilecfg,
        Lea,
        Leave,
        Les,
        Lfence,
        Lfs,
        Lgdt,
        Lgs,
        Lidt,
        Lldt,
        Llwpcb,
        Lmsw,
        Loadiwkey,
        Lodsb,
        Lodsd,
        Lodsq,
        Lodsw,
        Loop,
        Loope,
        Loopne,
        Lsl,
        Lss,
        Ltr,
        Lwpins,
        Lwpval,
        Lzcnt,
        Maskmovdqu,
        Maskmovq,
        Maxpd,
        Maxps,
        Maxsd,
        Maxss,
        Mcommit,
        Mfence,
        Minpd,
        Minps,
        Minsd,
        Minss,
        Monitor,
        Monitorx,
        Montmul,
        Mov,
        Movapd,
        Movaps,
        Movbe,
        Movd,
        Movddup,
        Movdir64b,
        Movdiri,
        Movdq2q,
        Movdqa,
        Movdqu,
        Movhlps,
        Movhpd,
        Movhps,
        Movlhps,
        Movlpd,
        Movlps,
        Movmskpd,
        Movmskps,
        Movntdq,
        Movntdqa,
        Movnti,
        Movntpd,
        Movntps,
        Movntq,
        Movntsd,
        Movntss,
        Movq,
        Movq2dq,
        Movsb,
        Movsd,
        Movshdup,
        Movsldup,
        Movsq,
        Movss,
        Movsw,
        Movsx,
        Movsxd,
        Movupd,
        Movups,
        Movzx,
        Mpsadbw,
        Mul,
        Mulpd,
        Mulps,
        Mulsd,
        Mulss,
        Mulx,
        Mwait,
        Mwaitx,
        Neg,
        Nop,
        Not,
        Or,
        Orpd,
        Orps,
        Out,
        Outsb,
        Outsd,
        Outsw,
        Pabsb,
        Pabsd,
        Pabsw,
        Packssdw,
        Packsswb,
        Packusdw,
        Packuswb,
        Paddb,
        Paddd,
        Paddq,
        Paddsb,
        Paddsw,
        Paddusb,
        Paddusw,
        Paddw,
        Palignr,
        Pand,
        Pandn,
        Pause,
        Pavgb,
        Pavgusb,
        Pavgw,
        Pblendvb,
        Pblendw,
        Pclmulqdq,
        Pcmpeqb,
        Pcmpeqd,
        Pcmpeqq,
        Pcmpeqw,
        Pcmpestri,
        Pcmpestrm,
        Pcmpgtb,
        Pcmpgtd,
        Pcmpgtq,
        Pcmpgtw,
        Pcmpistri,
        Pcmpistrm,
        Pconfig,
        Pdep,
        Pext,
        Pextrb,
        Pextrd,
        Pextrq,
        Pextrw,
        Pf2id,
        Pf2iw,
        Pfacc,
        Pfadd,
        Pfcmpeq,
        Pfcmpge,
        Pfcmpgt,
        Pfcpit1,
        Pfmax,
        Pfmin,
        Pfmul,
        Pfnacc,
        Pfpnacc,
        Pfrcp,
        Pfrcpit2,
        Pfrsqit1,
        Pfsqrt,
        Pfsub,
        Pfsubr,
        Phaddd,
        Phaddsw,
        Phaddw,
        Phminposuw,
        Phsubd,
        Phsubsw,
        Phsubw,
        Pi2fd,
        Pi2fw,
        Pinsrb,
        Pinsrd,
        Pinsrq,
        Pinsrw,
        Pmaddubsw,
        Pmaddwd,
        Pmaxsb,
        Pmaxsd,
        Pmaxsw,
        Pmaxub,
        Pmaxud,
        Pmaxuw,
        Pminsb,
        Pminsd,
        Pminsw,
        Pminub,
        Pminud,
        Pminuw,
        Pmovmskb,
        Pmovsxbd,
        Pmovsxbq,
        Pmovsxbw,
        Pmovsxdq,
        Pmovsxwd,
        Pmovsxwq,
        Pmovzxbd,
        Pmovzxbq,
        Pmovzxbw,
        Pmovzxdq,
        Pmovzxwd,
        Pmovzxwq,
        Pmuldq,
        Pmulhrsw,
        Pmulhrw,
        Pmulhuw,
        Pmulhw,
        Pmulld,
        Pmullw,
        Pmuludq,
        Pop,
        Popa,
        Popad,
        Popcnt,
        Popf,
        Popfd,
        Popfq,
        Por,
        Prefetch,
        Prefetchnta,
        Prefetcht0,
        Prefetcht1,
        Prefetcht2,
        Prefetchw,
        Prefetchwt1,
        Psadbw,
        Pshufb,
        Pshufd,
        Pshufhw,
        Pshuflw,
        Pshufw,
        Psignb,
        Psignd,
        Psignw,
        Pslld,
        Pslldq,
        Psllq,
        Psllw,
        Psmash,
        Psrad,
        Psraw,
        Psrld,
        Psrldq,
        Psrlq,
        Psrlw,
        Psubb,
        Psubd,
        Psubq,
        Psubsb,
        Psubsw,
        Psubusb,
        Psubusw,
        Psubw,
        Pswapd,
        Ptest,
        Ptwrite,
        Punpckhbw,
        Punpckhdq,
        Punpckhqdq,
        Punpckhwd,
        Punpcklbw,
        Punpckldq,
        Punpcklqdq,
        Punpcklwd,
        Push,
        Pusha,
        Pushad,
        Pushf,
        Pushfd,
        Pushfq,
        Pvalidate,
        Pxor,
        Rcl,
        Rcpps,
        Rcpss,
        Rcr,
        Rdfsbase,
        Rdgsbase,
        Rdmsr,
        Rdpid,
        Rdpkru,
        Rdpmc,
        Rdpru,
        Rdrand,
        Rdseed,
        Rdsspd,
        Rdsspq,
        Rdtsc,
        Rdtscp,
        Ret,
        Rmpadjust,
        Rmpupdate,
        Rol,
        Ror,
        Rorx,
        Roundpd,
        Roundps,
        Roundsd,
        Roundss,
        Rsm,
        Rsqrtps,
        Rsqrtss,
        Rstorssp,
        Sahf,
        Salc,
        Sar,
        Sarx,
        Saveprevssp,
        Sbb,
        Scasb,
        Scasd,
        Scasq,
        Scasw,
        Seamcall,
        Seamops,
        Seamret,
        Senduipi,
        Serialize,
        Setb,
        Setbe,
        Setl,
        Setle,
        Setnb,
        Setnbe,
        Setnl,
        Setnle,
        Setno,
        Setnp,
        Setns,
        Setnz,
        Seto,
        Setp,
        Sets,
        Setssbsy,
        Setz,
        Sfence,
        Sgdt,
        Sha1msg1,
        Sha1msg2,
        Sha1nexte,
        Sha1rnds4,
        Sha256msg1,
        Sha256msg2,
        Sha256rnds2,
        Shl,
        Shld,
        Shlx,
        Shr,
        Shrd,
        Shrx,
        Shufpd,
        Shufps,
        Sidt,
        Skinit,
        Sldt,
        Slwpcb,
        Smsw,
        Spflt,
        Sqrtpd,
        Sqrtps,
        Sqrtsd,
        Sqrtss,
        Stac,
        Stc,
        Std,
        Stgi,
        Sti,
        Stmxcsr,
        Stosb,
        Stosd,
        Stosq,
        Stosw,
        Str,
        Sttilecfg,
        Stui,
        Sub,
        Subpd,
        Subps,
        Subsd,
        Subss,
        Swapgs,
        Syscall,
        Sysenter,
        Sysexit,
        Sysret,
        T1mskc,
        Tdcall,
        Tdpbf16ps,
        Tdpbssd,
        Tdpbsud,
        Tdpbusd,
        Tdpbuud,
        Test,
        Testui,
        Tileloadd,
        Tileloaddt1,
        Tilerelease,
        Tilestored,
        Tilezero,
        Tlbsync,
        Tpause,
        Tzcnt,
        Tzcnti,
        Tzmsk,
        Ucomisd,
        Ucomiss,
        Ud0,
        Ud1,
        Ud2,
        Uiret,
        Umonitor,
        Umwait,
        Unpckhpd,
        Unpckhps,
        Unpcklpd,
        Unpcklps,
        V4fmaddps,
        V4fmaddss,
        V4fnmaddps,
        V4fnmaddss,
        Vaddnpd,
        Vaddnps,
        Vaddpd,
        Vaddph,
        Vaddps,
        Vaddsd,
        Vaddsetsps,
        Vaddsh,
        Vaddss,
        Vaddsubpd,
        Vaddsubps,
        Vaesdec,
        Vaesdeclast,
        Vaesenc,
        Vaesenclast,
        Vaesimc,
        Vaeskeygenassist,
        Valignd,
        Valignq,
        Vandnpd,
        Vandnps,
        Vandpd,
        Vandps,
        Vblendmpd,
        Vblendmps,
        Vblendpd,
        Vblendps,
        Vblendvpd,
        Vblendvps,
        Vbroadcastf128,
        Vbroadcastf32x2,
        Vbroadcastf32x4,
        Vbroadcastf32x8,
        Vbroadcastf64x2,
        Vbroadcastf64x4,
        Vbroadcasti128,
        Vbroadcasti32x2,
        Vbroadcasti32x4,
        Vbroadcasti32x8,
        Vbroadcasti64x2,
        Vbroadcasti64x4,
        Vbroadcastsd,
        Vbroadcastss,
        Vcmppd,
        Vcmpph,
        Vcmpps,
        Vcmpsd,
        Vcmpsh,
        Vcmpss,
        Vcomisd,
        Vcomish,
        Vcomiss,
        Vcompresspd,
        Vcompressps,
        Vcvtdq2pd,
        Vcvtdq2ph,
        Vcvtdq2ps,
        Vcvtfxpntdq2ps,
        Vcvtfxpntpd2dq,
        Vcvtfxpntpd2udq,
        Vcvtfxpntps2dq,
        Vcvtfxpntps2udq,
        Vcvtfxpntudq2ps,
        Vcvtne2ps2bf16,
        Vcvtneps2bf16,
        Vcvtpd2dq,
        Vcvtpd2ph,
        Vcvtpd2ps,
        Vcvtpd2qq,
        Vcvtpd2udq,
        Vcvtpd2uqq,
        Vcvtph2dq,
        Vcvtph2pd,
        Vcvtph2ps,
        Vcvtph2psx,
        Vcvtph2qq,
        Vcvtph2udq,
        Vcvtph2uqq,
        Vcvtph2uw,
        Vcvtph2w,
        Vcvtps2dq,
        Vcvtps2pd,
        Vcvtps2ph,
        Vcvtps2phx,
        Vcvtps2qq,
        Vcvtps2udq,
        Vcvtps2uqq,
        Vcvtqq2pd,
        Vcvtqq2ph,
        Vcvtqq2ps,
        Vcvtsd2sh,
        Vcvtsd2si,
        Vcvtsd2ss,
        Vcvtsd2usi,
        Vcvtsh2sd,
        Vcvtsh2si,
        Vcvtsh2ss,
        Vcvtsh2usi,
        Vcvtsi2sd,
        Vcvtsi2sh,
        Vcvtsi2ss,
        Vcvtss2sd,
        Vcvtss2sh,
        Vcvtss2si,
        Vcvtss2usi,
        Vcvttpd2dq,
        Vcvttpd2qq,
        Vcvttpd2udq,
        Vcvttpd2uqq,
        Vcvttph2dq,
        Vcvttph2qq,
        Vcvttph2udq,
        Vcvttph2uqq,
        Vcvttph2uw,
        Vcvttph2w,
        Vcvttps2dq,
        Vcvttps2qq,
        Vcvttps2udq,
        Vcvttps2uqq,
        Vcvttsd2si,
        Vcvttsd2usi,
        Vcvttsh2si,
        Vcvttsh2usi,
        Vcvttss2si,
        Vcvttss2usi,
        Vcvtudq2pd,
        Vcvtudq2ph,
        Vcvtudq2ps,
        Vcvtuqq2pd,
        Vcvtuqq2ph,
        Vcvtuqq2ps,
        Vcvtusi2sd,
        Vcvtusi2sh,
        Vcvtusi2ss,
        Vcvtuw2ph,
        Vcvtw2ph,
        Vdbpsadbw,
        Vdivpd,
        Vdivph,
        Vdivps,
        Vdivsd,
        Vdivsh,
        Vdivss,
        Vdpbf16ps,
        Vdppd,
        Vdpps,
        Verr,
        Verw,
        Vexp223ps,
        Vexp2pd,
        Vexp2ps,
        Vexpandpd,
        Vexpandps,
        Vextractf128,
        Vextractf32x4,
        Vextractf32x8,
        Vextractf64x2,
        Vextractf64x4,
        Vextracti128,
        Vextracti32x4,
        Vextracti32x8,
        Vextracti64x2,
        Vextracti64x4,
        Vextractps,
        Vfcmaddcph,
        Vfcmaddcsh,
        Vfcmulcph,
        Vfcmulcsh,
        Vfixupimmpd,
        Vfixupimmps,
        Vfixupimmsd,
        Vfixupimmss,
        Vfixupnanpd,
        Vfixupnanps,
        Vfmadd132pd,
        Vfmadd132ph,
        Vfmadd132ps,
        Vfmadd132sd,
        Vfmadd132sh,
        Vfmadd132ss,
        Vfmadd213pd,
        Vfmadd213ph,
        Vfmadd213ps,
        Vfmadd213sd,
        Vfmadd213sh,
        Vfmadd213ss,
        Vfmadd231pd,
        Vfmadd231ph,
        Vfmadd231ps,
        Vfmadd231sd,
        Vfmadd231sh,
        Vfmadd231ss,
        Vfmadd233ps,
        Vfmaddcph,
        Vfmaddcsh,
        Vfmaddpd,
        Vfmaddps,
        Vfmaddsd,
        Vfmaddss,
        Vfmaddsub132pd,
        Vfmaddsub132ph,
        Vfmaddsub132ps,
        Vfmaddsub213pd,
        Vfmaddsub213ph,
        Vfmaddsub213ps,
        Vfmaddsub231pd,
        Vfmaddsub231ph,
        Vfmaddsub231ps,
        Vfmaddsubpd,
        Vfmaddsubps,
        Vfmsub132pd,
        Vfmsub132ph,
        Vfmsub132ps,
        Vfmsub132sd,
        Vfmsub132sh,
        Vfmsub132ss,
        Vfmsub213pd,
        Vfmsub213ph,
        Vfmsub213ps,
        Vfmsub213sd,
        Vfmsub213sh,
        Vfmsub213ss,
        Vfmsub231pd,
        Vfmsub231ph,
        Vfmsub231ps,
        Vfmsub231sd,
        Vfmsub231sh,
        Vfmsub231ss,
        Vfmsubadd132pd,
        Vfmsubadd132ph,
        Vfmsubadd132ps,
        Vfmsubadd213pd,
        Vfmsubadd213ph,
        Vfmsubadd213ps,
        Vfmsubadd231pd,
        Vfmsubadd231ph,
        Vfmsubadd231ps,
        Vfmsubaddpd,
        Vfmsubaddps,
        Vfmsubpd,
        Vfmsubps,
        Vfmsubsd,
        Vfmsubss,
        Vfmulcph,
        Vfmulcsh,
        Vfnmadd132pd,
        Vfnmadd132ph,
        Vfnmadd132ps,
        Vfnmadd132sd,
        Vfnmadd132sh,
        Vfnmadd132ss,
        Vfnmadd213pd,
        Vfnmadd213ph,
        Vfnmadd213ps,
        Vfnmadd213sd,
        Vfnmadd213sh,
        Vfnmadd213ss,
        Vfnmadd231pd,
        Vfnmadd231ph,
        Vfnmadd231ps,
        Vfnmadd231sd,
        Vfnmadd231sh,
        Vfnmadd231ss,
        Vfnmaddpd,
        Vfnmaddps,
        Vfnmaddsd,
        Vfnmaddss,
        Vfnmsub132pd,
        Vfnmsub132ph,
        Vfnmsub132ps,
        Vfnmsub132sd,
        Vfnmsub132sh,
        Vfnmsub132ss,
        Vfnmsub213pd,
        Vfnmsub213ph,
        Vfnmsub213ps,
        Vfnmsub213sd,
        Vfnmsub213sh,
        Vfnmsub213ss,
        Vfnmsub231pd,
        Vfnmsub231ph,
        Vfnmsub231ps,
        Vfnmsub231sd,
        Vfnmsub231sh,
        Vfnmsub231ss,
        Vfnmsubpd,
        Vfnmsubps,
        Vfnmsubsd,
        Vfnmsubss,
        Vfpclasspd,
        Vfpclassph,
        Vfpclassps,
        Vfpclasssd,
        Vfpclasssh,
        Vfpclassss,
        Vfrczpd,
        Vfrczps,
        Vfrczsd,
        Vfrczss,
        Vgatherdpd,
        Vgatherdps,
        Vgatherpf0dpd,
        Vgatherpf0dps,
        Vgatherpf0hintdpd,
        Vgatherpf0hintdps,
        Vgatherpf0qpd,
        Vgatherpf0qps,
        Vgatherpf1dpd,
        Vgatherpf1dps,
        Vgatherpf1qpd,
        Vgatherpf1qps,
        Vgatherqpd,
        Vgatherqps,
        Vgetexppd,
        Vgetexpph,
        Vgetexpps,
        Vgetexpsd,
        Vgetexpsh,
        Vgetexpss,
        Vgetmantpd,
        Vgetmantph,
        Vgetmantps,
        Vgetmantsd,
        Vgetmantsh,
        Vgetmantss,
        Vgf2p8affineinvqb,
        Vgf2p8affineqb,
        Vgf2p8mulb,
        Vgmaxabsps,
        Vgmaxpd,
        Vgmaxps,
        Vgminpd,
        Vgminps,
        Vhaddpd,
        Vhaddps,
        Vhsubpd,
        Vhsubps,
        Vinsertf128,
        Vinsertf32x4,
        Vinsertf32x8,
        Vinsertf64x2,
        Vinsertf64x4,
        Vinserti128,
        Vinserti32x4,
        Vinserti32x8,
        Vinserti64x2,
        Vinserti64x4,
        Vinsertps,
        Vlddqu,
        Vldmxcsr,
        Vloadunpackhd,
        Vloadunpackhpd,
        Vloadunpackhps,
        Vloadunpackhq,
        Vloadunpackld,
        Vloadunpacklpd,
        Vloadunpacklps,
        Vloadunpacklq,
        Vlog2ps,
        Vmaskmovdqu,
        Vmaskmovpd,
        Vmaskmovps,
        Vmaxpd,
        Vmaxph,
        Vmaxps,
        Vmaxsd,
        Vmaxsh,
        Vmaxss,
        Vmcall,
        Vmclear,
        Vmfunc,
        Vminpd,
        Vminph,
        Vminps,
        Vminsd,
        Vminsh,
        Vminss,
        Vmlaunch,
        Vmload,
        Vmmcall,
        Vmovapd,
        Vmovaps,
        Vmovd,
        Vmovddup,
        Vmovdqa,
        Vmovdqa32,
        Vmovdqa64,
        Vmovdqu,
        Vmovdqu16,
        Vmovdqu32,
        Vmovdqu64,
        Vmovdqu8,
        Vmovhlps,
        Vmovhpd,
        Vmovhps,
        Vmovlhps,
        Vmovlpd,
        Vmovlps,
        Vmovmskpd,
        Vmovmskps,
        Vmovnrapd,
        Vmovnraps,
        Vmovnrngoapd,
        Vmovnrngoaps,
        Vmovntdq,
        Vmovntdqa,
        Vmovntpd,
        Vmovntps,
        Vmovq,
        Vmovsd,
        Vmovsh,
        Vmovshdup,
        Vmovsldup,
        Vmovss,
        Vmovupd,
        Vmovups,
        Vmovw,
        Vmpsadbw,
        Vmptrld,
        Vmptrst,
        Vmread,
        Vmresume,
        Vmrun,
        Vmsave,
        Vmulpd,
        Vmulph,
        Vmulps,
        Vmulsd,
        Vmulsh,
        Vmulss,
        Vmwrite,
        Vmxoff,
        Vmxon,
        Vorpd,
        Vorps,
        Vp2intersectd,
        Vp2intersectq,
        Vp4dpwssd,
        Vp4dpwssds,
        Vpabsb,
        Vpabsd,
        Vpabsq,
        Vpabsw,
        Vpackssdw,
        Vpacksswb,
        Vpackstorehd,
        Vpackstorehpd,
        Vpackstorehps,
        Vpackstorehq,
        Vpackstoreld,
        Vpackstorelpd,
        Vpackstorelps,
        Vpackstorelq,
        Vpackusdw,
        Vpackuswb,
        Vpadcd,
        Vpaddb,
        Vpaddd,
        Vpaddq,
        Vpaddsb,
        Vpaddsetcd,
        Vpaddsetsd,
        Vpaddsw,
        Vpaddusb,
        Vpaddusw,
        Vpaddw,
        Vpalignr,
        Vpand,
        Vpandd,
        Vpandn,
        Vpandnd,
        Vpandnq,
        Vpandq,
        Vpavgb,
        Vpavgw,
        Vpblendd,
        Vpblendmb,
        Vpblendmd,
        Vpblendmq,
        Vpblendmw,
        Vpblendvb,
        Vpblendw,
        Vpbroadcastb,
        Vpbroadcastd,
        Vpbroadcastmb2q,
        Vpbroadcastmw2d,
        Vpbroadcastq,
        Vpbroadcastw,
        Vpclmulqdq,
        Vpcmov,
        Vpcmpb,
        Vpcmpd,
        Vpcmpeqb,
        Vpcmpeqd,
        Vpcmpeqq,
        Vpcmpeqw,
        Vpcmpestri,
        Vpcmpestrm,
        Vpcmpgtb,
        Vpcmpgtd,
        Vpcmpgtq,
        Vpcmpgtw,
        Vpcmpistri,
        Vpcmpistrm,
        Vpcmpltd,
        Vpcmpq,
        Vpcmpub,
        Vpcmpud,
        Vpcmpuq,
        Vpcmpuw,
        Vpcmpw,
        Vpcomb,
        Vpcomd,
        Vpcompressb,
        Vpcompressd,
        Vpcompressq,
        Vpcompressw,
        Vpcomq,
        Vpcomub,
        Vpcomud,
        Vpcomuq,
        Vpcomuw,
        Vpcomw,
        Vpconflictd,
        Vpconflictq,
        Vpdpbusd,
        Vpdpbusds,
        Vpdpwssd,
        Vpdpwssds,
        Vperm2f128,
        Vperm2i128,
        Vpermb,
        Vpermd,
        Vpermf32x4,
        Vpermi2b,
        Vpermi2d,
        Vpermi2pd,
        Vpermi2ps,
        Vpermi2q,
        Vpermi2w,
        Vpermil2pd,
        Vpermil2ps,
        Vpermilpd,
        Vpermilps,
        Vpermpd,
        Vpermps,
        Vpermq,
        Vpermt2b,
        Vpermt2d,
        Vpermt2pd,
        Vpermt2ps,
        Vpermt2q,
        Vpermt2w,
        Vpermw,
        Vpexpandb,
        Vpexpandd,
        Vpexpandq,
        Vpexpandw,
        Vpextrb,
        Vpextrd,
        Vpextrq,
        Vpextrw,
        Vpgatherdd,
        Vpgatherdq,
        Vpgatherqd,
        Vpgatherqq,
        Vphaddbd,
        Vphaddbq,
        Vphaddbw,
        Vphaddd,
        Vphadddq,
        Vphaddsw,
        Vphaddubd,
        Vphaddubq,
        Vphaddubw,
        Vphaddudq,
        Vphadduwd,
        Vphadduwq,
        Vphaddw,
        Vphaddwd,
        Vphaddwq,
        Vphminposuw,
        Vphsubbw,
        Vphsubd,
        Vphsubdq,
        Vphsubsw,
        Vphsubw,
        Vphsubwd,
        Vpinsrb,
        Vpinsrd,
        Vpinsrq,
        Vpinsrw,
        Vplzcntd,
        Vplzcntq,
        Vpmacsdd,
        Vpmacsdqh,
        Vpmacsdql,
        Vpmacssdd,
        Vpmacssdqh,
        Vpmacssdql,
        Vpmacsswd,
        Vpmacssww,
        Vpmacswd,
        Vpmacsww,
        Vpmadcsswd,
        Vpmadcswd,
        Vpmadd231d,
        Vpmadd233d,
        Vpmadd52huq,
        Vpmadd52luq,
        Vpmaddubsw,
        Vpmaddwd,
        Vpmaskmovd,
        Vpmaskmovq,
        Vpmaxsb,
        Vpmaxsd,
        Vpmaxsq,
        Vpmaxsw,
        Vpmaxub,
        Vpmaxud,
        Vpmaxuq,
        Vpmaxuw,
        Vpminsb,
        Vpminsd,
        Vpminsq,
        Vpminsw,
        Vpminub,
        Vpminud,
        Vpminuq,
        Vpminuw,
        Vpmovb2m,
        Vpmovd2m,
        Vpmovdb,
        Vpmovdw,
        Vpmovm2b,
        Vpmovm2d,
        Vpmovm2q,
        Vpmovm2w,
        Vpmovmskb,
        Vpmovq2m,
        Vpmovqb,
        Vpmovqd,
        Vpmovqw,
        Vpmovsdb,
        Vpmovsdw,
        Vpmovsqb,
        Vpmovsqd,
        Vpmovsqw,
        Vpmovswb,
        Vpmovsxbd,
        Vpmovsxbq,
        Vpmovsxbw,
        Vpmovsxdq,
        Vpmovsxwd,
        Vpmovsxwq,
        Vpmovusdb,
        Vpmovusdw,
        Vpmovusqb,
        Vpmovusqd,
        Vpmovusqw,
        Vpmovuswb,
        Vpmovw2m,
        Vpmovwb,
        Vpmovzxbd,
        Vpmovzxbq,
        Vpmovzxbw,
        Vpmovzxdq,
        Vpmovzxwd,
        Vpmovzxwq,
        Vpmuldq,
        Vpmulhd,
        Vpmulhrsw,
        Vpmulhud,
        Vpmulhuw,
        Vpmulhw,
        Vpmulld,
        Vpmullq,
        Vpmullw,
        Vpmultishiftqb,
        Vpmuludq,
        Vpopcntb,
        Vpopcntd,
        Vpopcntq,
        Vpopcntw,
        Vpor,
        Vpord,
        Vporq,
        Vpperm,
        Vprefetch0,
        Vprefetch1,
        Vprefetch2,
        Vprefetche0,
        Vprefetche1,
        Vprefetche2,
        Vprefetchenta,
        Vprefetchnta,
        Vprold,
        Vprolq,
        Vprolvd,
        Vprolvq,
        Vprord,
        Vprorq,
        Vprorvd,
        Vprorvq,
        Vprotb,
        Vprotd,
        Vprotq,
        Vprotw,
        Vpsadbw,
        Vpsbbd,
        Vpsbbrd,
        Vpscatterdd,
        Vpscatterdq,
        Vpscatterqd,
        Vpscatterqq,
        Vpshab,
        Vpshad,
        Vpshaq,
        Vpshaw,
        Vpshlb,
        Vpshld,
        Vpshldd,
        Vpshldq,
        Vpshldvd,
        Vpshldvq,
        Vpshldvw,
        Vpshldw,
        Vpshlq,
        Vpshlw,
        Vpshrdd,
        Vpshrdq,
        Vpshrdvd,
        Vpshrdvq,
        Vpshrdvw,
        Vpshrdw,
        Vpshufb,
        Vpshufbitqmb,
        Vpshufd,
        Vpshufhw,
        Vpshuflw,
        Vpsignb,
        Vpsignd,
        Vpsignw,
        Vpslld,
        Vpslldq,
        Vpsllq,
        Vpsllvd,
        Vpsllvq,
        Vpsllvw,
        Vpsllw,
        Vpsrad,
        Vpsraq,
        Vpsravd,
        Vpsravq,
        Vpsravw,
        Vpsraw,
        Vpsrld,
        Vpsrldq,
        Vpsrlq,
        Vpsrlvd,
        Vpsrlvq,
        Vpsrlvw,
        Vpsrlw,
        Vpsubb,
        Vpsubd,
        Vpsubq,
        Vpsubrd,
        Vpsubrsetbd,
        Vpsubsb,
        Vpsubsetbd,
        Vpsubsw,
        Vpsubusb,
        Vpsubusw,
        Vpsubw,
        Vpternlogd,
        Vpternlogq,
        Vptest,
        Vptestmb,
        Vptestmd,
        Vptestmq,
        Vptestmw,
        Vptestnmb,
        Vptestnmd,
        Vptestnmq,
        Vptestnmw,
        Vpunpckhbw,
        Vpunpckhdq,
        Vpunpckhqdq,
        Vpunpckhwd,
        Vpunpcklbw,
        Vpunpckldq,
        Vpunpcklqdq,
        Vpunpcklwd,
        Vpxor,
        Vpxord,
        Vpxorq,
        Vrangepd,
        Vrangeps,
        Vrangesd,
        Vrangess,
        Vrcp14pd,
        Vrcp14ps,
        Vrcp14sd,
        Vrcp14ss,
        Vrcp23ps,
        Vrcp28pd,
        Vrcp28ps,
        Vrcp28sd,
        Vrcp28ss,
        Vrcpph,
        Vrcpps,
        Vrcpsh,
        Vrcpss,
        Vreducepd,
        Vreduceph,
        Vreduceps,
        Vreducesd,
        Vreducesh,
        Vreducess,
        Vrndfxpntpd,
        Vrndfxpntps,
        Vrndscalepd,
        Vrndscaleph,
        Vrndscaleps,
        Vrndscalesd,
        Vrndscalesh,
        Vrndscaless,
        Vroundpd,
        Vroundps,
        Vroundsd,
        Vroundss,
        Vrsqrt14pd,
        Vrsqrt14ps,
        Vrsqrt14sd,
        Vrsqrt14ss,
        Vrsqrt23ps,
        Vrsqrt28pd,
        Vrsqrt28ps,
        Vrsqrt28sd,
        Vrsqrt28ss,
        Vrsqrtph,
        Vrsqrtps,
        Vrsqrtsh,
        Vrsqrtss,
        Vscalefpd,
        Vscalefph,
        Vscalefps,
        Vscalefsd,
        Vscalefsh,
        Vscalefss,
        Vscaleps,
        Vscatterdpd,
        Vscatterdps,
        Vscatterpf0dpd,
        Vscatterpf0dps,
        Vscatterpf0hintdpd,
        Vscatterpf0hintdps,
        Vscatterpf0qpd,
        Vscatterpf0qps,
        Vscatterpf1dpd,
        Vscatterpf1dps,
        Vscatterpf1qpd,
        Vscatterpf1qps,
        Vscatterqpd,
        Vscatterqps,
        Vshuff32x4,
        Vshuff64x2,
        Vshufi32x4,
        Vshufi64x2,
        Vshufpd,
        Vshufps,
        Vsqrtpd,
        Vsqrtph,
        Vsqrtps,
        Vsqrtsd,
        Vsqrtsh,
        Vsqrtss,
        Vstmxcsr,
        Vsubpd,
        Vsubph,
        Vsubps,
        Vsubrpd,
        Vsubrps,
        Vsubsd,
        Vsubsh,
        Vsubss,
        Vtestpd,
        Vtestps,
        Vucomisd,
        Vucomish,
        Vucomiss,
        Vunpckhpd,
        Vunpckhps,
        Vunpcklpd,
        Vunpcklps,
        Vxorpd,
        Vxorps,
        Vzeroall,
        Vzeroupper,
        Wbinvd,
        Wrfsbase,
        Wrgsbase,
        Wrmsr,
        Wrpkru,
        Wrssd,
        Wrssq,
        Wrussd,
        Wrussq,
        Xabort,
        Xadd,
        Xbegin,
        Xchg,
        Xcrypt_cbc,
        Xcrypt_cfb,
        Xcrypt_ctr,
        Xcrypt_ecb,
        Xcrypt_ofb,
        Xend,
        Xgetbv,
        Xlat,
        Xor,
        Xorpd,
        Xorps,
        Xresldtrk,
        Xrstor,
        Xrstor64,
        Xrstors,
        Xrstors64,
        Xsave,
        Xsave64,
        Xsavec,
        Xsavec64,
        Xsaveopt,
        Xsaveopt64,
        Xsaves,
        Xsaves64,
        Xsetbv,
        Xsha1,
        Xsha256,
        Xstore,
        Xsusldtrk,
        Xtest,
    };

    constexpr const char* MnemonicGetString(Mnemonic mnemonic)
    {
        switch (mnemonic)
        {
        case Mnemonic::Invalid:
            return "invalid";
        case Mnemonic::Aaa:
            return "aaa";
        case Mnemonic::Aad:
            return "aad";
        case Mnemonic::Aam:
            return "aam";
        case Mnemonic::Aas:
            return "aas";
        case Mnemonic::Adc:
            return "adc";
        case Mnemonic::Adcx:
            return "adcx";
        case Mnemonic::Add:
            return "add";
        case Mnemonic::Addpd:
            return "addpd";
        case Mnemonic::Addps:
            return "addps";
        case Mnemonic::Addsd:
            return "addsd";
        case Mnemonic::Addss:
            return "addss";
        case Mnemonic::Addsubpd:
            return "addsubpd";
        case Mnemonic::Addsubps:
            return "addsubps";
        case Mnemonic::Adox:
            return "adox";
        case Mnemonic::Aesdec:
            return "aesdec";
        case Mnemonic::Aesdec128kl:
            return "aesdec128kl";
        case Mnemonic::Aesdec256kl:
            return "aesdec256kl";
        case Mnemonic::Aesdeclast:
            return "aesdeclast";
        case Mnemonic::Aesdecwide128kl:
            return "aesdecwide128kl";
        case Mnemonic::Aesdecwide256kl:
            return "aesdecwide256kl";
        case Mnemonic::Aesenc:
            return "aesenc";
        case Mnemonic::Aesenc128kl:
            return "aesenc128kl";
        case Mnemonic::Aesenc256kl:
            return "aesenc256kl";
        case Mnemonic::Aesenclast:
            return "aesenclast";
        case Mnemonic::Aesencwide128kl:
            return "aesencwide128kl";
        case Mnemonic::Aesencwide256kl:
            return "aesencwide256kl";
        case Mnemonic::Aesimc:
            return "aesimc";
        case Mnemonic::Aeskeygenassist:
            return "aeskeygenassist";
        case Mnemonic::And:
            return "and";
        case Mnemonic::Andn:
            return "andn";
        case Mnemonic::Andnpd:
            return "andnpd";
        case Mnemonic::Andnps:
            return "andnps";
        case Mnemonic::Andpd:
            return "andpd";
        case Mnemonic::Andps:
            return "andps";
        case Mnemonic::Arpl:
            return "arpl";
        case Mnemonic::Bextr:
            return "bextr";
        case Mnemonic::Blcfill:
            return "blcfill";
        case Mnemonic::Blci:
            return "blci";
        case Mnemonic::Blcic:
            return "blcic";
        case Mnemonic::Blcmsk:
            return "blcmsk";
        case Mnemonic::Blcs:
            return "blcs";
        case Mnemonic::Blendpd:
            return "blendpd";
        case Mnemonic::Blendps:
            return "blendps";
        case Mnemonic::Blendvpd:
            return "blendvpd";
        case Mnemonic::Blendvps:
            return "blendvps";
        case Mnemonic::Blsfill:
            return "blsfill";
        case Mnemonic::Blsi:
            return "blsi";
        case Mnemonic::Blsic:
            return "blsic";
        case Mnemonic::Blsmsk:
            return "blsmsk";
        case Mnemonic::Blsr:
            return "blsr";
        case Mnemonic::Bndcl:
            return "bndcl";
        case Mnemonic::Bndcn:
            return "bndcn";
        case Mnemonic::Bndcu:
            return "bndcu";
        case Mnemonic::Bndldx:
            return "bndldx";
        case Mnemonic::Bndmk:
            return "bndmk";
        case Mnemonic::Bndmov:
            return "bndmov";
        case Mnemonic::Bndstx:
            return "bndstx";
        case Mnemonic::Bound:
            return "bound";
        case Mnemonic::Bsf:
            return "bsf";
        case Mnemonic::Bsr:
            return "bsr";
        case Mnemonic::Bswap:
            return "bswap";
        case Mnemonic::Bt:
            return "bt";
        case Mnemonic::Btc:
            return "btc";
        case Mnemonic::Btr:
            return "btr";
        case Mnemonic::Bts:
            return "bts";
        case Mnemonic::Bzhi:
            return "bzhi";
        case Mnemonic::Call:
            return "call";
        case Mnemonic::Cbw:
            return "cbw";
        case Mnemonic::Cdq:
            return "cdq";
        case Mnemonic::Cdqe:
            return "cdqe";
        case Mnemonic::Clac:
            return "clac";
        case Mnemonic::Clc:
            return "clc";
        case Mnemonic::Cld:
            return "cld";
        case Mnemonic::Cldemote:
            return "cldemote";
        case Mnemonic::Clevict0:
            return "clevict0";
        case Mnemonic::Clevict1:
            return "clevict1";
        case Mnemonic::Clflush:
            return "clflush";
        case Mnemonic::Clflushopt:
            return "clflushopt";
        case Mnemonic::Clgi:
            return "clgi";
        case Mnemonic::Cli:
            return "cli";
        case Mnemonic::Clrssbsy:
            return "clrssbsy";
        case Mnemonic::Clts:
            return "clts";
        case Mnemonic::Clui:
            return "clui";
        case Mnemonic::Clwb:
            return "clwb";
        case Mnemonic::Clzero:
            return "clzero";
        case Mnemonic::Cmc:
            return "cmc";
        case Mnemonic::Cmovb:
            return "cmovb";
        case Mnemonic::Cmovbe:
            return "cmovbe";
        case Mnemonic::Cmovl:
            return "cmovl";
        case Mnemonic::Cmovle:
            return "cmovle";
        case Mnemonic::Cmovnb:
            return "cmovnb";
        case Mnemonic::Cmovnbe:
            return "cmovnbe";
        case Mnemonic::Cmovnl:
            return "cmovnl";
        case Mnemonic::Cmovnle:
            return "cmovnle";
        case Mnemonic::Cmovno:
            return "cmovno";
        case Mnemonic::Cmovnp:
            return "cmovnp";
        case Mnemonic::Cmovns:
            return "cmovns";
        case Mnemonic::Cmovnz:
            return "cmovnz";
        case Mnemonic::Cmovo:
            return "cmovo";
        case Mnemonic::Cmovp:
            return "cmovp";
        case Mnemonic::Cmovs:
            return "cmovs";
        case Mnemonic::Cmovz:
            return "cmovz";
        case Mnemonic::Cmp:
            return "cmp";
        case Mnemonic::Cmppd:
            return "cmppd";
        case Mnemonic::Cmpps:
            return "cmpps";
        case Mnemonic::Cmpsb:
            return "cmpsb";
        case Mnemonic::Cmpsd:
            return "cmpsd";
        case Mnemonic::Cmpsq:
            return "cmpsq";
        case Mnemonic::Cmpss:
            return "cmpss";
        case Mnemonic::Cmpsw:
            return "cmpsw";
        case Mnemonic::Cmpxchg:
            return "cmpxchg";
        case Mnemonic::Cmpxchg16b:
            return "cmpxchg16b";
        case Mnemonic::Cmpxchg8b:
            return "cmpxchg8b";
        case Mnemonic::Comisd:
            return "comisd";
        case Mnemonic::Comiss:
            return "comiss";
        case Mnemonic::Cpuid:
            return "cpuid";
        case Mnemonic::Cqo:
            return "cqo";
        case Mnemonic::Crc32:
            return "crc32";
        case Mnemonic::Cvtdq2pd:
            return "cvtdq2pd";
        case Mnemonic::Cvtdq2ps:
            return "cvtdq2ps";
        case Mnemonic::Cvtpd2dq:
            return "cvtpd2dq";
        case Mnemonic::Cvtpd2pi:
            return "cvtpd2pi";
        case Mnemonic::Cvtpd2ps:
            return "cvtpd2ps";
        case Mnemonic::Cvtpi2pd:
            return "cvtpi2pd";
        case Mnemonic::Cvtpi2ps:
            return "cvtpi2ps";
        case Mnemonic::Cvtps2dq:
            return "cvtps2dq";
        case Mnemonic::Cvtps2pd:
            return "cvtps2pd";
        case Mnemonic::Cvtps2pi:
            return "cvtps2pi";
        case Mnemonic::Cvtsd2si:
            return "cvtsd2si";
        case Mnemonic::Cvtsd2ss:
            return "cvtsd2ss";
        case Mnemonic::Cvtsi2sd:
            return "cvtsi2sd";
        case Mnemonic::Cvtsi2ss:
            return "cvtsi2ss";
        case Mnemonic::Cvtss2sd:
            return "cvtss2sd";
        case Mnemonic::Cvtss2si:
            return "cvtss2si";
        case Mnemonic::Cvttpd2dq:
            return "cvttpd2dq";
        case Mnemonic::Cvttpd2pi:
            return "cvttpd2pi";
        case Mnemonic::Cvttps2dq:
            return "cvttps2dq";
        case Mnemonic::Cvttps2pi:
            return "cvttps2pi";
        case Mnemonic::Cvttsd2si:
            return "cvttsd2si";
        case Mnemonic::Cvttss2si:
            return "cvttss2si";
        case Mnemonic::Cwd:
            return "cwd";
        case Mnemonic::Cwde:
            return "cwde";
        case Mnemonic::Daa:
            return "daa";
        case Mnemonic::Das:
            return "das";
        case Mnemonic::Dec:
            return "dec";
        case Mnemonic::Delay:
            return "delay";
        case Mnemonic::Div:
            return "div";
        case Mnemonic::Divpd:
            return "divpd";
        case Mnemonic::Divps:
            return "divps";
        case Mnemonic::Divsd:
            return "divsd";
        case Mnemonic::Divss:
            return "divss";
        case Mnemonic::Dppd:
            return "dppd";
        case Mnemonic::Dpps:
            return "dpps";
        case Mnemonic::Emms:
            return "emms";
        case Mnemonic::Encls:
            return "encls";
        case Mnemonic::Enclu:
            return "enclu";
        case Mnemonic::Enclv:
            return "enclv";
        case Mnemonic::Encodekey128:
            return "encodekey128";
        case Mnemonic::Encodekey256:
            return "encodekey256";
        case Mnemonic::Endbr32:
            return "endbr32";
        case Mnemonic::Endbr64:
            return "endbr64";
        case Mnemonic::Enqcmd:
            return "enqcmd";
        case Mnemonic::Enqcmds:
            return "enqcmds";
        case Mnemonic::Enter:
            return "enter";
        case Mnemonic::Extractps:
            return "extractps";
        case Mnemonic::Extrq:
            return "extrq";
        case Mnemonic::F2xm1:
            return "f2xm1";
        case Mnemonic::Fabs:
            return "fabs";
        case Mnemonic::Fadd:
            return "fadd";
        case Mnemonic::Faddp:
            return "faddp";
        case Mnemonic::Fbld:
            return "fbld";
        case Mnemonic::Fbstp:
            return "fbstp";
        case Mnemonic::Fchs:
            return "fchs";
        case Mnemonic::Fcmovb:
            return "fcmovb";
        case Mnemonic::Fcmovbe:
            return "fcmovbe";
        case Mnemonic::Fcmove:
            return "fcmove";
        case Mnemonic::Fcmovnb:
            return "fcmovnb";
        case Mnemonic::Fcmovnbe:
            return "fcmovnbe";
        case Mnemonic::Fcmovne:
            return "fcmovne";
        case Mnemonic::Fcmovnu:
            return "fcmovnu";
        case Mnemonic::Fcmovu:
            return "fcmovu";
        case Mnemonic::Fcom:
            return "fcom";
        case Mnemonic::Fcomi:
            return "fcomi";
        case Mnemonic::Fcomip:
            return "fcomip";
        case Mnemonic::Fcomp:
            return "fcomp";
        case Mnemonic::Fcompp:
            return "fcompp";
        case Mnemonic::Fcos:
            return "fcos";
        case Mnemonic::Fdecstp:
            return "fdecstp";
        case Mnemonic::Fdisi8087_nop:
            return "fdisi8087_nop";
        case Mnemonic::Fdiv:
            return "fdiv";
        case Mnemonic::Fdivp:
            return "fdivp";
        case Mnemonic::Fdivr:
            return "fdivr";
        case Mnemonic::Fdivrp:
            return "fdivrp";
        case Mnemonic::Femms:
            return "femms";
        case Mnemonic::Feni8087_nop:
            return "feni8087_nop";
        case Mnemonic::Ffree:
            return "ffree";
        case Mnemonic::Ffreep:
            return "ffreep";
        case Mnemonic::Fiadd:
            return "fiadd";
        case Mnemonic::Ficom:
            return "ficom";
        case Mnemonic::Ficomp:
            return "ficomp";
        case Mnemonic::Fidiv:
            return "fidiv";
        case Mnemonic::Fidivr:
            return "fidivr";
        case Mnemonic::Fild:
            return "fild";
        case Mnemonic::Fimul:
            return "fimul";
        case Mnemonic::Fincstp:
            return "fincstp";
        case Mnemonic::Fist:
            return "fist";
        case Mnemonic::Fistp:
            return "fistp";
        case Mnemonic::Fisttp:
            return "fisttp";
        case Mnemonic::Fisub:
            return "fisub";
        case Mnemonic::Fisubr:
            return "fisubr";
        case Mnemonic::Fld:
            return "fld";
        case Mnemonic::Fld1:
            return "fld1";
        case Mnemonic::Fldcw:
            return "fldcw";
        case Mnemonic::Fldenv:
            return "fldenv";
        case Mnemonic::Fldl2e:
            return "fldl2e";
        case Mnemonic::Fldl2t:
            return "fldl2t";
        case Mnemonic::Fldlg2:
            return "fldlg2";
        case Mnemonic::Fldln2:
            return "fldln2";
        case Mnemonic::Fldpi:
            return "fldpi";
        case Mnemonic::Fldz:
            return "fldz";
        case Mnemonic::Fmul:
            return "fmul";
        case Mnemonic::Fmulp:
            return "fmulp";
        case Mnemonic::Fnclex:
            return "fnclex";
        case Mnemonic::Fninit:
            return "fninit";
        case Mnemonic::Fnop:
            return "fnop";
        case Mnemonic::Fnsave:
            return "fnsave";
        case Mnemonic::Fnstcw:
            return "fnstcw";
        case Mnemonic::Fnstenv:
            return "fnstenv";
        case Mnemonic::Fnstsw:
            return "fnstsw";
        case Mnemonic::Fpatan:
            return "fpatan";
        case Mnemonic::Fprem:
            return "fprem";
        case Mnemonic::Fprem1:
            return "fprem1";
        case Mnemonic::Fptan:
            return "fptan";
        case Mnemonic::Frndint:
            return "frndint";
        case Mnemonic::Frstor:
            return "frstor";
        case Mnemonic::Fscale:
            return "fscale";
        case Mnemonic::Fsetpm287_nop:
            return "fsetpm287_nop";
        case Mnemonic::Fsin:
            return "fsin";
        case Mnemonic::Fsincos:
            return "fsincos";
        case Mnemonic::Fsqrt:
            return "fsqrt";
        case Mnemonic::Fst:
            return "fst";
        case Mnemonic::Fstp:
            return "fstp";
        case Mnemonic::Fstpnce:
            return "fstpnce";
        case Mnemonic::Fsub:
            return "fsub";
        case Mnemonic::Fsubp:
            return "fsubp";
        case Mnemonic::Fsubr:
            return "fsubr";
        case Mnemonic::Fsubrp:
            return "fsubrp";
        case Mnemonic::Ftst:
            return "ftst";
        case Mnemonic::Fucom:
            return "fucom";
        case Mnemonic::Fucomi:
            return "fucomi";
        case Mnemonic::Fucomip:
            return "fucomip";
        case Mnemonic::Fucomp:
            return "fucomp";
        case Mnemonic::Fucompp:
            return "fucompp";
        case Mnemonic::Fwait:
            return "fwait";
        case Mnemonic::Fxam:
            return "fxam";
        case Mnemonic::Fxch:
            return "fxch";
        case Mnemonic::Fxrstor:
            return "fxrstor";
        case Mnemonic::Fxrstor64:
            return "fxrstor64";
        case Mnemonic::Fxsave:
            return "fxsave";
        case Mnemonic::Fxsave64:
            return "fxsave64";
        case Mnemonic::Fxtract:
            return "fxtract";
        case Mnemonic::Fyl2x:
            return "fyl2x";
        case Mnemonic::Fyl2xp1:
            return "fyl2xp1";
        case Mnemonic::Getsec:
            return "getsec";
        case Mnemonic::Gf2p8affineinvqb:
            return "gf2p8affineinvqb";
        case Mnemonic::Gf2p8affineqb:
            return "gf2p8affineqb";
        case Mnemonic::Gf2p8mulb:
            return "gf2p8mulb";
        case Mnemonic::Haddpd:
            return "haddpd";
        case Mnemonic::Haddps:
            return "haddps";
        case Mnemonic::Hlt:
            return "hlt";
        case Mnemonic::Hreset:
            return "hreset";
        case Mnemonic::Hsubpd:
            return "hsubpd";
        case Mnemonic::Hsubps:
            return "hsubps";
        case Mnemonic::Idiv:
            return "idiv";
        case Mnemonic::Imul:
            return "imul";
        case Mnemonic::In:
            return "in";
        case Mnemonic::Inc:
            return "inc";
        case Mnemonic::Incsspd:
            return "incsspd";
        case Mnemonic::Incsspq:
            return "incsspq";
        case Mnemonic::Insb:
            return "insb";
        case Mnemonic::Insd:
            return "insd";
        case Mnemonic::Insertps:
            return "insertps";
        case Mnemonic::Insertq:
            return "insertq";
        case Mnemonic::Insw:
            return "insw";
        case Mnemonic::Int:
            return "int";
        case Mnemonic::Int1:
            return "int1";
        case Mnemonic::Int3:
            return "int3";
        case Mnemonic::Into:
            return "into";
        case Mnemonic::Invd:
            return "invd";
        case Mnemonic::Invept:
            return "invept";
        case Mnemonic::Invlpg:
            return "invlpg";
        case Mnemonic::Invlpga:
            return "invlpga";
        case Mnemonic::Invlpgb:
            return "invlpgb";
        case Mnemonic::Invpcid:
            return "invpcid";
        case Mnemonic::Invvpid:
            return "invvpid";
        case Mnemonic::Iret:
            return "iret";
        case Mnemonic::Iretd:
            return "iretd";
        case Mnemonic::Iretq:
            return "iretq";
        case Mnemonic::Jb:
            return "jb";
        case Mnemonic::Jbe:
            return "jbe";
        case Mnemonic::Jcxz:
            return "jcxz";
        case Mnemonic::Jecxz:
            return "jecxz";
        case Mnemonic::Jknzd:
            return "jknzd";
        case Mnemonic::Jkzd:
            return "jkzd";
        case Mnemonic::Jl:
            return "jl";
        case Mnemonic::Jle:
            return "jle";
        case Mnemonic::Jmp:
            return "jmp";
        case Mnemonic::Jnb:
            return "jnb";
        case Mnemonic::Jnbe:
            return "jnbe";
        case Mnemonic::Jnl:
            return "jnl";
        case Mnemonic::Jnle:
            return "jnle";
        case Mnemonic::Jno:
            return "jno";
        case Mnemonic::Jnp:
            return "jnp";
        case Mnemonic::Jns:
            return "jns";
        case Mnemonic::Jnz:
            return "jnz";
        case Mnemonic::Jo:
            return "jo";
        case Mnemonic::Jp:
            return "jp";
        case Mnemonic::Jrcxz:
            return "jrcxz";
        case Mnemonic::Js:
            return "js";
        case Mnemonic::Jz:
            return "jz";
        case Mnemonic::Kaddb:
            return "kaddb";
        case Mnemonic::Kaddd:
            return "kaddd";
        case Mnemonic::Kaddq:
            return "kaddq";
        case Mnemonic::Kaddw:
            return "kaddw";
        case Mnemonic::Kand:
            return "kand";
        case Mnemonic::Kandb:
            return "kandb";
        case Mnemonic::Kandd:
            return "kandd";
        case Mnemonic::Kandn:
            return "kandn";
        case Mnemonic::Kandnb:
            return "kandnb";
        case Mnemonic::Kandnd:
            return "kandnd";
        case Mnemonic::Kandnq:
            return "kandnq";
        case Mnemonic::Kandnr:
            return "kandnr";
        case Mnemonic::Kandnw:
            return "kandnw";
        case Mnemonic::Kandq:
            return "kandq";
        case Mnemonic::Kandw:
            return "kandw";
        case Mnemonic::Kconcath:
            return "kconcath";
        case Mnemonic::Kconcatl:
            return "kconcatl";
        case Mnemonic::Kextract:
            return "kextract";
        case Mnemonic::Kmerge2l1h:
            return "kmerge2l1h";
        case Mnemonic::Kmerge2l1l:
            return "kmerge2l1l";
        case Mnemonic::Kmov:
            return "kmov";
        case Mnemonic::Kmovb:
            return "kmovb";
        case Mnemonic::Kmovd:
            return "kmovd";
        case Mnemonic::Kmovq:
            return "kmovq";
        case Mnemonic::Kmovw:
            return "kmovw";
        case Mnemonic::Knot:
            return "knot";
        case Mnemonic::Knotb:
            return "knotb";
        case Mnemonic::Knotd:
            return "knotd";
        case Mnemonic::Knotq:
            return "knotq";
        case Mnemonic::Knotw:
            return "knotw";
        case Mnemonic::Kor:
            return "kor";
        case Mnemonic::Korb:
            return "korb";
        case Mnemonic::Kord:
            return "kord";
        case Mnemonic::Korq:
            return "korq";
        case Mnemonic::Kortest:
            return "kortest";
        case Mnemonic::Kortestb:
            return "kortestb";
        case Mnemonic::Kortestd:
            return "kortestd";
        case Mnemonic::Kortestq:
            return "kortestq";
        case Mnemonic::Kortestw:
            return "kortestw";
        case Mnemonic::Korw:
            return "korw";
        case Mnemonic::Kshiftlb:
            return "kshiftlb";
        case Mnemonic::Kshiftld:
            return "kshiftld";
        case Mnemonic::Kshiftlq:
            return "kshiftlq";
        case Mnemonic::Kshiftlw:
            return "kshiftlw";
        case Mnemonic::Kshiftrb:
            return "kshiftrb";
        case Mnemonic::Kshiftrd:
            return "kshiftrd";
        case Mnemonic::Kshiftrq:
            return "kshiftrq";
        case Mnemonic::Kshiftrw:
            return "kshiftrw";
        case Mnemonic::Ktestb:
            return "ktestb";
        case Mnemonic::Ktestd:
            return "ktestd";
        case Mnemonic::Ktestq:
            return "ktestq";
        case Mnemonic::Ktestw:
            return "ktestw";
        case Mnemonic::Kunpckbw:
            return "kunpckbw";
        case Mnemonic::Kunpckdq:
            return "kunpckdq";
        case Mnemonic::Kunpckwd:
            return "kunpckwd";
        case Mnemonic::Kxnor:
            return "kxnor";
        case Mnemonic::Kxnorb:
            return "kxnorb";
        case Mnemonic::Kxnord:
            return "kxnord";
        case Mnemonic::Kxnorq:
            return "kxnorq";
        case Mnemonic::Kxnorw:
            return "kxnorw";
        case Mnemonic::Kxor:
            return "kxor";
        case Mnemonic::Kxorb:
            return "kxorb";
        case Mnemonic::Kxord:
            return "kxord";
        case Mnemonic::Kxorq:
            return "kxorq";
        case Mnemonic::Kxorw:
            return "kxorw";
        case Mnemonic::Lahf:
            return "lahf";
        case Mnemonic::Lar:
            return "lar";
        case Mnemonic::Lddqu:
            return "lddqu";
        case Mnemonic::Ldmxcsr:
            return "ldmxcsr";
        case Mnemonic::Lds:
            return "lds";
        case Mnemonic::Ldtilecfg:
            return "ldtilecfg";
        case Mnemonic::Lea:
            return "lea";
        case Mnemonic::Leave:
            return "leave";
        case Mnemonic::Les:
            return "les";
        case Mnemonic::Lfence:
            return "lfence";
        case Mnemonic::Lfs:
            return "lfs";
        case Mnemonic::Lgdt:
            return "lgdt";
        case Mnemonic::Lgs:
            return "lgs";
        case Mnemonic::Lidt:
            return "lidt";
        case Mnemonic::Lldt:
            return "lldt";
        case Mnemonic::Llwpcb:
            return "llwpcb";
        case Mnemonic::Lmsw:
            return "lmsw";
        case Mnemonic::Loadiwkey:
            return "loadiwkey";
        case Mnemonic::Lodsb:
            return "lodsb";
        case Mnemonic::Lodsd:
            return "lodsd";
        case Mnemonic::Lodsq:
            return "lodsq";
        case Mnemonic::Lodsw:
            return "lodsw";
        case Mnemonic::Loop:
            return "loop";
        case Mnemonic::Loope:
            return "loope";
        case Mnemonic::Loopne:
            return "loopne";
        case Mnemonic::Lsl:
            return "lsl";
        case Mnemonic::Lss:
            return "lss";
        case Mnemonic::Ltr:
            return "ltr";
        case Mnemonic::Lwpins:
            return "lwpins";
        case Mnemonic::Lwpval:
            return "lwpval";
        case Mnemonic::Lzcnt:
            return "lzcnt";
        case Mnemonic::Maskmovdqu:
            return "maskmovdqu";
        case Mnemonic::Maskmovq:
            return "maskmovq";
        case Mnemonic::Maxpd:
            return "maxpd";
        case Mnemonic::Maxps:
            return "maxps";
        case Mnemonic::Maxsd:
            return "maxsd";
        case Mnemonic::Maxss:
            return "maxss";
        case Mnemonic::Mcommit:
            return "mcommit";
        case Mnemonic::Mfence:
            return "mfence";
        case Mnemonic::Minpd:
            return "minpd";
        case Mnemonic::Minps:
            return "minps";
        case Mnemonic::Minsd:
            return "minsd";
        case Mnemonic::Minss:
            return "minss";
        case Mnemonic::Monitor:
            return "monitor";
        case Mnemonic::Monitorx:
            return "monitorx";
        case Mnemonic::Montmul:
            return "montmul";
        case Mnemonic::Mov:
            return "mov";
        case Mnemonic::Movapd:
            return "movapd";
        case Mnemonic::Movaps:
            return "movaps";
        case Mnemonic::Movbe:
            return "movbe";
        case Mnemonic::Movd:
            return "movd";
        case Mnemonic::Movddup:
            return "movddup";
        case Mnemonic::Movdir64b:
            return "movdir64b";
        case Mnemonic::Movdiri:
            return "movdiri";
        case Mnemonic::Movdq2q:
            return "movdq2q";
        case Mnemonic::Movdqa:
            return "movdqa";
        case Mnemonic::Movdqu:
            return "movdqu";
        case Mnemonic::Movhlps:
            return "movhlps";
        case Mnemonic::Movhpd:
            return "movhpd";
        case Mnemonic::Movhps:
            return "movhps";
        case Mnemonic::Movlhps:
            return "movlhps";
        case Mnemonic::Movlpd:
            return "movlpd";
        case Mnemonic::Movlps:
            return "movlps";
        case Mnemonic::Movmskpd:
            return "movmskpd";
        case Mnemonic::Movmskps:
            return "movmskps";
        case Mnemonic::Movntdq:
            return "movntdq";
        case Mnemonic::Movntdqa:
            return "movntdqa";
        case Mnemonic::Movnti:
            return "movnti";
        case Mnemonic::Movntpd:
            return "movntpd";
        case Mnemonic::Movntps:
            return "movntps";
        case Mnemonic::Movntq:
            return "movntq";
        case Mnemonic::Movntsd:
            return "movntsd";
        case Mnemonic::Movntss:
            return "movntss";
        case Mnemonic::Movq:
            return "movq";
        case Mnemonic::Movq2dq:
            return "movq2dq";
        case Mnemonic::Movsb:
            return "movsb";
        case Mnemonic::Movsd:
            return "movsd";
        case Mnemonic::Movshdup:
            return "movshdup";
        case Mnemonic::Movsldup:
            return "movsldup";
        case Mnemonic::Movsq:
            return "movsq";
        case Mnemonic::Movss:
            return "movss";
        case Mnemonic::Movsw:
            return "movsw";
        case Mnemonic::Movsx:
            return "movsx";
        case Mnemonic::Movsxd:
            return "movsxd";
        case Mnemonic::Movupd:
            return "movupd";
        case Mnemonic::Movups:
            return "movups";
        case Mnemonic::Movzx:
            return "movzx";
        case Mnemonic::Mpsadbw:
            return "mpsadbw";
        case Mnemonic::Mul:
            return "mul";
        case Mnemonic::Mulpd:
            return "mulpd";
        case Mnemonic::Mulps:
            return "mulps";
        case Mnemonic::Mulsd:
            return "mulsd";
        case Mnemonic::Mulss:
            return "mulss";
        case Mnemonic::Mulx:
            return "mulx";
        case Mnemonic::Mwait:
            return "mwait";
        case Mnemonic::Mwaitx:
            return "mwaitx";
        case Mnemonic::Neg:
            return "neg";
        case Mnemonic::Nop:
            return "nop";
        case Mnemonic::Not:
            return "not";
        case Mnemonic::Or:
            return "or";
        case Mnemonic::Orpd:
            return "orpd";
        case Mnemonic::Orps:
            return "orps";
        case Mnemonic::Out:
            return "out";
        case Mnemonic::Outsb:
            return "outsb";
        case Mnemonic::Outsd:
            return "outsd";
        case Mnemonic::Outsw:
            return "outsw";
        case Mnemonic::Pabsb:
            return "pabsb";
        case Mnemonic::Pabsd:
            return "pabsd";
        case Mnemonic::Pabsw:
            return "pabsw";
        case Mnemonic::Packssdw:
            return "packssdw";
        case Mnemonic::Packsswb:
            return "packsswb";
        case Mnemonic::Packusdw:
            return "packusdw";
        case Mnemonic::Packuswb:
            return "packuswb";
        case Mnemonic::Paddb:
            return "paddb";
        case Mnemonic::Paddd:
            return "paddd";
        case Mnemonic::Paddq:
            return "paddq";
        case Mnemonic::Paddsb:
            return "paddsb";
        case Mnemonic::Paddsw:
            return "paddsw";
        case Mnemonic::Paddusb:
            return "paddusb";
        case Mnemonic::Paddusw:
            return "paddusw";
        case Mnemonic::Paddw:
            return "paddw";
        case Mnemonic::Palignr:
            return "palignr";
        case Mnemonic::Pand:
            return "pand";
        case Mnemonic::Pandn:
            return "pandn";
        case Mnemonic::Pause:
            return "pause";
        case Mnemonic::Pavgb:
            return "pavgb";
        case Mnemonic::Pavgusb:
            return "pavgusb";
        case Mnemonic::Pavgw:
            return "pavgw";
        case Mnemonic::Pblendvb:
            return "pblendvb";
        case Mnemonic::Pblendw:
            return "pblendw";
        case Mnemonic::Pclmulqdq:
            return "pclmulqdq";
        case Mnemonic::Pcmpeqb:
            return "pcmpeqb";
        case Mnemonic::Pcmpeqd:
            return "pcmpeqd";
        case Mnemonic::Pcmpeqq:
            return "pcmpeqq";
        case Mnemonic::Pcmpeqw:
            return "pcmpeqw";
        case Mnemonic::Pcmpestri:
            return "pcmpestri";
        case Mnemonic::Pcmpestrm:
            return "pcmpestrm";
        case Mnemonic::Pcmpgtb:
            return "pcmpgtb";
        case Mnemonic::Pcmpgtd:
            return "pcmpgtd";
        case Mnemonic::Pcmpgtq:
            return "pcmpgtq";
        case Mnemonic::Pcmpgtw:
            return "pcmpgtw";
        case Mnemonic::Pcmpistri:
            return "pcmpistri";
        case Mnemonic::Pcmpistrm:
            return "pcmpistrm";
        case Mnemonic::Pconfig:
            return "pconfig";
        case Mnemonic::Pdep:
            return "pdep";
        case Mnemonic::Pext:
            return "pext";
        case Mnemonic::Pextrb:
            return "pextrb";
        case Mnemonic::Pextrd:
            return "pextrd";
        case Mnemonic::Pextrq:
            return "pextrq";
        case Mnemonic::Pextrw:
            return "pextrw";
        case Mnemonic::Pf2id:
            return "pf2id";
        case Mnemonic::Pf2iw:
            return "pf2iw";
        case Mnemonic::Pfacc:
            return "pfacc";
        case Mnemonic::Pfadd:
            return "pfadd";
        case Mnemonic::Pfcmpeq:
            return "pfcmpeq";
        case Mnemonic::Pfcmpge:
            return "pfcmpge";
        case Mnemonic::Pfcmpgt:
            return "pfcmpgt";
        case Mnemonic::Pfcpit1:
            return "pfcpit1";
        case Mnemonic::Pfmax:
            return "pfmax";
        case Mnemonic::Pfmin:
            return "pfmin";
        case Mnemonic::Pfmul:
            return "pfmul";
        case Mnemonic::Pfnacc:
            return "pfnacc";
        case Mnemonic::Pfpnacc:
            return "pfpnacc";
        case Mnemonic::Pfrcp:
            return "pfrcp";
        case Mnemonic::Pfrcpit2:
            return "pfrcpit2";
        case Mnemonic::Pfrsqit1:
            return "pfrsqit1";
        case Mnemonic::Pfsqrt:
            return "pfsqrt";
        case Mnemonic::Pfsub:
            return "pfsub";
        case Mnemonic::Pfsubr:
            return "pfsubr";
        case Mnemonic::Phaddd:
            return "phaddd";
        case Mnemonic::Phaddsw:
            return "phaddsw";
        case Mnemonic::Phaddw:
            return "phaddw";
        case Mnemonic::Phminposuw:
            return "phminposuw";
        case Mnemonic::Phsubd:
            return "phsubd";
        case Mnemonic::Phsubsw:
            return "phsubsw";
        case Mnemonic::Phsubw:
            return "phsubw";
        case Mnemonic::Pi2fd:
            return "pi2fd";
        case Mnemonic::Pi2fw:
            return "pi2fw";
        case Mnemonic::Pinsrb:
            return "pinsrb";
        case Mnemonic::Pinsrd:
            return "pinsrd";
        case Mnemonic::Pinsrq:
            return "pinsrq";
        case Mnemonic::Pinsrw:
            return "pinsrw";
        case Mnemonic::Pmaddubsw:
            return "pmaddubsw";
        case Mnemonic::Pmaddwd:
            return "pmaddwd";
        case Mnemonic::Pmaxsb:
            return "pmaxsb";
        case Mnemonic::Pmaxsd:
            return "pmaxsd";
        case Mnemonic::Pmaxsw:
            return "pmaxsw";
        case Mnemonic::Pmaxub:
            return "pmaxub";
        case Mnemonic::Pmaxud:
            return "pmaxud";
        case Mnemonic::Pmaxuw:
            return "pmaxuw";
        case Mnemonic::Pminsb:
            return "pminsb";
        case Mnemonic::Pminsd:
            return "pminsd";
        case Mnemonic::Pminsw:
            return "pminsw";
        case Mnemonic::Pminub:
            return "pminub";
        case Mnemonic::Pminud:
            return "pminud";
        case Mnemonic::Pminuw:
            return "pminuw";
        case Mnemonic::Pmovmskb:
            return "pmovmskb";
        case Mnemonic::Pmovsxbd:
            return "pmovsxbd";
        case Mnemonic::Pmovsxbq:
            return "pmovsxbq";
        case Mnemonic::Pmovsxbw:
            return "pmovsxbw";
        case Mnemonic::Pmovsxdq:
            return "pmovsxdq";
        case Mnemonic::Pmovsxwd:
            return "pmovsxwd";
        case Mnemonic::Pmovsxwq:
            return "pmovsxwq";
        case Mnemonic::Pmovzxbd:
            return "pmovzxbd";
        case Mnemonic::Pmovzxbq:
            return "pmovzxbq";
        case Mnemonic::Pmovzxbw:
            return "pmovzxbw";
        case Mnemonic::Pmovzxdq:
            return "pmovzxdq";
        case Mnemonic::Pmovzxwd:
            return "pmovzxwd";
        case Mnemonic::Pmovzxwq:
            return "pmovzxwq";
        case Mnemonic::Pmuldq:
            return "pmuldq";
        case Mnemonic::Pmulhrsw:
            return "pmulhrsw";
        case Mnemonic::Pmulhrw:
            return "pmulhrw";
        case Mnemonic::Pmulhuw:
            return "pmulhuw";
        case Mnemonic::Pmulhw:
            return "pmulhw";
        case Mnemonic::Pmulld:
            return "pmulld";
        case Mnemonic::Pmullw:
            return "pmullw";
        case Mnemonic::Pmuludq:
            return "pmuludq";
        case Mnemonic::Pop:
            return "pop";
        case Mnemonic::Popa:
            return "popa";
        case Mnemonic::Popad:
            return "popad";
        case Mnemonic::Popcnt:
            return "popcnt";
        case Mnemonic::Popf:
            return "popf";
        case Mnemonic::Popfd:
            return "popfd";
        case Mnemonic::Popfq:
            return "popfq";
        case Mnemonic::Por:
            return "por";
        case Mnemonic::Prefetch:
            return "prefetch";
        case Mnemonic::Prefetchnta:
            return "prefetchnta";
        case Mnemonic::Prefetcht0:
            return "prefetcht0";
        case Mnemonic::Prefetcht1:
            return "prefetcht1";
        case Mnemonic::Prefetcht2:
            return "prefetcht2";
        case Mnemonic::Prefetchw:
            return "prefetchw";
        case Mnemonic::Prefetchwt1:
            return "prefetchwt1";
        case Mnemonic::Psadbw:
            return "psadbw";
        case Mnemonic::Pshufb:
            return "pshufb";
        case Mnemonic::Pshufd:
            return "pshufd";
        case Mnemonic::Pshufhw:
            return "pshufhw";
        case Mnemonic::Pshuflw:
            return "pshuflw";
        case Mnemonic::Pshufw:
            return "pshufw";
        case Mnemonic::Psignb:
            return "psignb";
        case Mnemonic::Psignd:
            return "psignd";
        case Mnemonic::Psignw:
            return "psignw";
        case Mnemonic::Pslld:
            return "pslld";
        case Mnemonic::Pslldq:
            return "pslldq";
        case Mnemonic::Psllq:
            return "psllq";
        case Mnemonic::Psllw:
            return "psllw";
        case Mnemonic::Psmash:
            return "psmash";
        case Mnemonic::Psrad:
            return "psrad";
        case Mnemonic::Psraw:
            return "psraw";
        case Mnemonic::Psrld:
            return "psrld";
        case Mnemonic::Psrldq:
            return "psrldq";
        case Mnemonic::Psrlq:
            return "psrlq";
        case Mnemonic::Psrlw:
            return "psrlw";
        case Mnemonic::Psubb:
            return "psubb";
        case Mnemonic::Psubd:
            return "psubd";
        case Mnemonic::Psubq:
            return "psubq";
        case Mnemonic::Psubsb:
            return "psubsb";
        case Mnemonic::Psubsw:
            return "psubsw";
        case Mnemonic::Psubusb:
            return "psubusb";
        case Mnemonic::Psubusw:
            return "psubusw";
        case Mnemonic::Psubw:
            return "psubw";
        case Mnemonic::Pswapd:
            return "pswapd";
        case Mnemonic::Ptest:
            return "ptest";
        case Mnemonic::Ptwrite:
            return "ptwrite";
        case Mnemonic::Punpckhbw:
            return "punpckhbw";
        case Mnemonic::Punpckhdq:
            return "punpckhdq";
        case Mnemonic::Punpckhqdq:
            return "punpckhqdq";
        case Mnemonic::Punpckhwd:
            return "punpckhwd";
        case Mnemonic::Punpcklbw:
            return "punpcklbw";
        case Mnemonic::Punpckldq:
            return "punpckldq";
        case Mnemonic::Punpcklqdq:
            return "punpcklqdq";
        case Mnemonic::Punpcklwd:
            return "punpcklwd";
        case Mnemonic::Push:
            return "push";
        case Mnemonic::Pusha:
            return "pusha";
        case Mnemonic::Pushad:
            return "pushad";
        case Mnemonic::Pushf:
            return "pushf";
        case Mnemonic::Pushfd:
            return "pushfd";
        case Mnemonic::Pushfq:
            return "pushfq";
        case Mnemonic::Pvalidate:
            return "pvalidate";
        case Mnemonic::Pxor:
            return "pxor";
        case Mnemonic::Rcl:
            return "rcl";
        case Mnemonic::Rcpps:
            return "rcpps";
        case Mnemonic::Rcpss:
            return "rcpss";
        case Mnemonic::Rcr:
            return "rcr";
        case Mnemonic::Rdfsbase:
            return "rdfsbase";
        case Mnemonic::Rdgsbase:
            return "rdgsbase";
        case Mnemonic::Rdmsr:
            return "rdmsr";
        case Mnemonic::Rdpid:
            return "rdpid";
        case Mnemonic::Rdpkru:
            return "rdpkru";
        case Mnemonic::Rdpmc:
            return "rdpmc";
        case Mnemonic::Rdpru:
            return "rdpru";
        case Mnemonic::Rdrand:
            return "rdrand";
        case Mnemonic::Rdseed:
            return "rdseed";
        case Mnemonic::Rdsspd:
            return "rdsspd";
        case Mnemonic::Rdsspq:
            return "rdsspq";
        case Mnemonic::Rdtsc:
            return "rdtsc";
        case Mnemonic::Rdtscp:
            return "rdtscp";
        case Mnemonic::Ret:
            return "ret";
        case Mnemonic::Rmpadjust:
            return "rmpadjust";
        case Mnemonic::Rmpupdate:
            return "rmpupdate";
        case Mnemonic::Rol:
            return "rol";
        case Mnemonic::Ror:
            return "ror";
        case Mnemonic::Rorx:
            return "rorx";
        case Mnemonic::Roundpd:
            return "roundpd";
        case Mnemonic::Roundps:
            return "roundps";
        case Mnemonic::Roundsd:
            return "roundsd";
        case Mnemonic::Roundss:
            return "roundss";
        case Mnemonic::Rsm:
            return "rsm";
        case Mnemonic::Rsqrtps:
            return "rsqrtps";
        case Mnemonic::Rsqrtss:
            return "rsqrtss";
        case Mnemonic::Rstorssp:
            return "rstorssp";
        case Mnemonic::Sahf:
            return "sahf";
        case Mnemonic::Salc:
            return "salc";
        case Mnemonic::Sar:
            return "sar";
        case Mnemonic::Sarx:
            return "sarx";
        case Mnemonic::Saveprevssp:
            return "saveprevssp";
        case Mnemonic::Sbb:
            return "sbb";
        case Mnemonic::Scasb:
            return "scasb";
        case Mnemonic::Scasd:
            return "scasd";
        case Mnemonic::Scasq:
            return "scasq";
        case Mnemonic::Scasw:
            return "scasw";
        case Mnemonic::Seamcall:
            return "seamcall";
        case Mnemonic::Seamops:
            return "seamops";
        case Mnemonic::Seamret:
            return "seamret";
        case Mnemonic::Senduipi:
            return "senduipi";
        case Mnemonic::Serialize:
            return "serialize";
        case Mnemonic::Setb:
            return "setb";
        case Mnemonic::Setbe:
            return "setbe";
        case Mnemonic::Setl:
            return "setl";
        case Mnemonic::Setle:
            return "setle";
        case Mnemonic::Setnb:
            return "setnb";
        case Mnemonic::Setnbe:
            return "setnbe";
        case Mnemonic::Setnl:
            return "setnl";
        case Mnemonic::Setnle:
            return "setnle";
        case Mnemonic::Setno:
            return "setno";
        case Mnemonic::Setnp:
            return "setnp";
        case Mnemonic::Setns:
            return "setns";
        case Mnemonic::Setnz:
            return "setnz";
        case Mnemonic::Seto:
            return "seto";
        case Mnemonic::Setp:
            return "setp";
        case Mnemonic::Sets:
            return "sets";
        case Mnemonic::Setssbsy:
            return "setssbsy";
        case Mnemonic::Setz:
            return "setz";
        case Mnemonic::Sfence:
            return "sfence";
        case Mnemonic::Sgdt:
            return "sgdt";
        case Mnemonic::Sha1msg1:
            return "sha1msg1";
        case Mnemonic::Sha1msg2:
            return "sha1msg2";
        case Mnemonic::Sha1nexte:
            return "sha1nexte";
        case Mnemonic::Sha1rnds4:
            return "sha1rnds4";
        case Mnemonic::Sha256msg1:
            return "sha256msg1";
        case Mnemonic::Sha256msg2:
            return "sha256msg2";
        case Mnemonic::Sha256rnds2:
            return "sha256rnds2";
        case Mnemonic::Shl:
            return "shl";
        case Mnemonic::Shld:
            return "shld";
        case Mnemonic::Shlx:
            return "shlx";
        case Mnemonic::Shr:
            return "shr";
        case Mnemonic::Shrd:
            return "shrd";
        case Mnemonic::Shrx:
            return "shrx";
        case Mnemonic::Shufpd:
            return "shufpd";
        case Mnemonic::Shufps:
            return "shufps";
        case Mnemonic::Sidt:
            return "sidt";
        case Mnemonic::Skinit:
            return "skinit";
        case Mnemonic::Sldt:
            return "sldt";
        case Mnemonic::Slwpcb:
            return "slwpcb";
        case Mnemonic::Smsw:
            return "smsw";
        case Mnemonic::Spflt:
            return "spflt";
        case Mnemonic::Sqrtpd:
            return "sqrtpd";
        case Mnemonic::Sqrtps:
            return "sqrtps";
        case Mnemonic::Sqrtsd:
            return "sqrtsd";
        case Mnemonic::Sqrtss:
            return "sqrtss";
        case Mnemonic::Stac:
            return "stac";
        case Mnemonic::Stc:
            return "stc";
        case Mnemonic::Std:
            return "std";
        case Mnemonic::Stgi:
            return "stgi";
        case Mnemonic::Sti:
            return "sti";
        case Mnemonic::Stmxcsr:
            return "stmxcsr";
        case Mnemonic::Stosb:
            return "stosb";
        case Mnemonic::Stosd:
            return "stosd";
        case Mnemonic::Stosq:
            return "stosq";
        case Mnemonic::Stosw:
            return "stosw";
        case Mnemonic::Str:
            return "str";
        case Mnemonic::Sttilecfg:
            return "sttilecfg";
        case Mnemonic::Stui:
            return "stui";
        case Mnemonic::Sub:
            return "sub";
        case Mnemonic::Subpd:
            return "subpd";
        case Mnemonic::Subps:
            return "subps";
        case Mnemonic::Subsd:
            return "subsd";
        case Mnemonic::Subss:
            return "subss";
        case Mnemonic::Swapgs:
            return "swapgs";
        case Mnemonic::Syscall:
            return "syscall";
        case Mnemonic::Sysenter:
            return "sysenter";
        case Mnemonic::Sysexit:
            return "sysexit";
        case Mnemonic::Sysret:
            return "sysret";
        case Mnemonic::T1mskc:
            return "t1mskc";
        case Mnemonic::Tdcall:
            return "tdcall";
        case Mnemonic::Tdpbf16ps:
            return "tdpbf16ps";
        case Mnemonic::Tdpbssd:
            return "tdpbssd";
        case Mnemonic::Tdpbsud:
            return "tdpbsud";
        case Mnemonic::Tdpbusd:
            return "tdpbusd";
        case Mnemonic::Tdpbuud:
            return "tdpbuud";
        case Mnemonic::Test:
            return "test";
        case Mnemonic::Testui:
            return "testui";
        case Mnemonic::Tileloadd:
            return "tileloadd";
        case Mnemonic::Tileloaddt1:
            return "tileloaddt1";
        case Mnemonic::Tilerelease:
            return "tilerelease";
        case Mnemonic::Tilestored:
            return "tilestored";
        case Mnemonic::Tilezero:
            return "tilezero";
        case Mnemonic::Tlbsync:
            return "tlbsync";
        case Mnemonic::Tpause:
            return "tpause";
        case Mnemonic::Tzcnt:
            return "tzcnt";
        case Mnemonic::Tzcnti:
            return "tzcnti";
        case Mnemonic::Tzmsk:
            return "tzmsk";
        case Mnemonic::Ucomisd:
            return "ucomisd";
        case Mnemonic::Ucomiss:
            return "ucomiss";
        case Mnemonic::Ud0:
            return "ud0";
        case Mnemonic::Ud1:
            return "ud1";
        case Mnemonic::Ud2:
            return "ud2";
        case Mnemonic::Uiret:
            return "uiret";
        case Mnemonic::Umonitor:
            return "umonitor";
        case Mnemonic::Umwait:
            return "umwait";
        case Mnemonic::Unpckhpd:
            return "unpckhpd";
        case Mnemonic::Unpckhps:
            return "unpckhps";
        case Mnemonic::Unpcklpd:
            return "unpcklpd";
        case Mnemonic::Unpcklps:
            return "unpcklps";
        case Mnemonic::V4fmaddps:
            return "v4fmaddps";
        case Mnemonic::V4fmaddss:
            return "v4fmaddss";
        case Mnemonic::V4fnmaddps:
            return "v4fnmaddps";
        case Mnemonic::V4fnmaddss:
            return "v4fnmaddss";
        case Mnemonic::Vaddnpd:
            return "vaddnpd";
        case Mnemonic::Vaddnps:
            return "vaddnps";
        case Mnemonic::Vaddpd:
            return "vaddpd";
        case Mnemonic::Vaddph:
            return "vaddph";
        case Mnemonic::Vaddps:
            return "vaddps";
        case Mnemonic::Vaddsd:
            return "vaddsd";
        case Mnemonic::Vaddsetsps:
            return "vaddsetsps";
        case Mnemonic::Vaddsh:
            return "vaddsh";
        case Mnemonic::Vaddss:
            return "vaddss";
        case Mnemonic::Vaddsubpd:
            return "vaddsubpd";
        case Mnemonic::Vaddsubps:
            return "vaddsubps";
        case Mnemonic::Vaesdec:
            return "vaesdec";
        case Mnemonic::Vaesdeclast:
            return "vaesdeclast";
        case Mnemonic::Vaesenc:
            return "vaesenc";
        case Mnemonic::Vaesenclast:
            return "vaesenclast";
        case Mnemonic::Vaesimc:
            return "vaesimc";
        case Mnemonic::Vaeskeygenassist:
            return "vaeskeygenassist";
        case Mnemonic::Valignd:
            return "valignd";
        case Mnemonic::Valignq:
            return "valignq";
        case Mnemonic::Vandnpd:
            return "vandnpd";
        case Mnemonic::Vandnps:
            return "vandnps";
        case Mnemonic::Vandpd:
            return "vandpd";
        case Mnemonic::Vandps:
            return "vandps";
        case Mnemonic::Vblendmpd:
            return "vblendmpd";
        case Mnemonic::Vblendmps:
            return "vblendmps";
        case Mnemonic::Vblendpd:
            return "vblendpd";
        case Mnemonic::Vblendps:
            return "vblendps";
        case Mnemonic::Vblendvpd:
            return "vblendvpd";
        case Mnemonic::Vblendvps:
            return "vblendvps";
        case Mnemonic::Vbroadcastf128:
            return "vbroadcastf128";
        case Mnemonic::Vbroadcastf32x2:
            return "vbroadcastf32x2";
        case Mnemonic::Vbroadcastf32x4:
            return "vbroadcastf32x4";
        case Mnemonic::Vbroadcastf32x8:
            return "vbroadcastf32x8";
        case Mnemonic::Vbroadcastf64x2:
            return "vbroadcastf64x2";
        case Mnemonic::Vbroadcastf64x4:
            return "vbroadcastf64x4";
        case Mnemonic::Vbroadcasti128:
            return "vbroadcasti128";
        case Mnemonic::Vbroadcasti32x2:
            return "vbroadcasti32x2";
        case Mnemonic::Vbroadcasti32x4:
            return "vbroadcasti32x4";
        case Mnemonic::Vbroadcasti32x8:
            return "vbroadcasti32x8";
        case Mnemonic::Vbroadcasti64x2:
            return "vbroadcasti64x2";
        case Mnemonic::Vbroadcasti64x4:
            return "vbroadcasti64x4";
        case Mnemonic::Vbroadcastsd:
            return "vbroadcastsd";
        case Mnemonic::Vbroadcastss:
            return "vbroadcastss";
        case Mnemonic::Vcmppd:
            return "vcmppd";
        case Mnemonic::Vcmpph:
            return "vcmpph";
        case Mnemonic::Vcmpps:
            return "vcmpps";
        case Mnemonic::Vcmpsd:
            return "vcmpsd";
        case Mnemonic::Vcmpsh:
            return "vcmpsh";
        case Mnemonic::Vcmpss:
            return "vcmpss";
        case Mnemonic::Vcomisd:
            return "vcomisd";
        case Mnemonic::Vcomish:
            return "vcomish";
        case Mnemonic::Vcomiss:
            return "vcomiss";
        case Mnemonic::Vcompresspd:
            return "vcompresspd";
        case Mnemonic::Vcompressps:
            return "vcompressps";
        case Mnemonic::Vcvtdq2pd:
            return "vcvtdq2pd";
        case Mnemonic::Vcvtdq2ph:
            return "vcvtdq2ph";
        case Mnemonic::Vcvtdq2ps:
            return "vcvtdq2ps";
        case Mnemonic::Vcvtfxpntdq2ps:
            return "vcvtfxpntdq2ps";
        case Mnemonic::Vcvtfxpntpd2dq:
            return "vcvtfxpntpd2dq";
        case Mnemonic::Vcvtfxpntpd2udq:
            return "vcvtfxpntpd2udq";
        case Mnemonic::Vcvtfxpntps2dq:
            return "vcvtfxpntps2dq";
        case Mnemonic::Vcvtfxpntps2udq:
            return "vcvtfxpntps2udq";
        case Mnemonic::Vcvtfxpntudq2ps:
            return "vcvtfxpntudq2ps";
        case Mnemonic::Vcvtne2ps2bf16:
            return "vcvtne2ps2bf16";
        case Mnemonic::Vcvtneps2bf16:
            return "vcvtneps2bf16";
        case Mnemonic::Vcvtpd2dq:
            return "vcvtpd2dq";
        case Mnemonic::Vcvtpd2ph:
            return "vcvtpd2ph";
        case Mnemonic::Vcvtpd2ps:
            return "vcvtpd2ps";
        case Mnemonic::Vcvtpd2qq:
            return "vcvtpd2qq";
        case Mnemonic::Vcvtpd2udq:
            return "vcvtpd2udq";
        case Mnemonic::Vcvtpd2uqq:
            return "vcvtpd2uqq";
        case Mnemonic::Vcvtph2dq:
            return "vcvtph2dq";
        case Mnemonic::Vcvtph2pd:
            return "vcvtph2pd";
        case Mnemonic::Vcvtph2ps:
            return "vcvtph2ps";
        case Mnemonic::Vcvtph2psx:
            return "vcvtph2psx";
        case Mnemonic::Vcvtph2qq:
            return "vcvtph2qq";
        case Mnemonic::Vcvtph2udq:
            return "vcvtph2udq";
        case Mnemonic::Vcvtph2uqq:
            return "vcvtph2uqq";
        case Mnemonic::Vcvtph2uw:
            return "vcvtph2uw";
        case Mnemonic::Vcvtph2w:
            return "vcvtph2w";
        case Mnemonic::Vcvtps2dq:
            return "vcvtps2dq";
        case Mnemonic::Vcvtps2pd:
            return "vcvtps2pd";
        case Mnemonic::Vcvtps2ph:
            return "vcvtps2ph";
        case Mnemonic::Vcvtps2phx:
            return "vcvtps2phx";
        case Mnemonic::Vcvtps2qq:
            return "vcvtps2qq";
        case Mnemonic::Vcvtps2udq:
            return "vcvtps2udq";
        case Mnemonic::Vcvtps2uqq:
            return "vcvtps2uqq";
        case Mnemonic::Vcvtqq2pd:
            return "vcvtqq2pd";
        case Mnemonic::Vcvtqq2ph:
            return "vcvtqq2ph";
        case Mnemonic::Vcvtqq2ps:
            return "vcvtqq2ps";
        case Mnemonic::Vcvtsd2sh:
            return "vcvtsd2sh";
        case Mnemonic::Vcvtsd2si:
            return "vcvtsd2si";
        case Mnemonic::Vcvtsd2ss:
            return "vcvtsd2ss";
        case Mnemonic::Vcvtsd2usi:
            return "vcvtsd2usi";
        case Mnemonic::Vcvtsh2sd:
            return "vcvtsh2sd";
        case Mnemonic::Vcvtsh2si:
            return "vcvtsh2si";
        case Mnemonic::Vcvtsh2ss:
            return "vcvtsh2ss";
        case Mnemonic::Vcvtsh2usi:
            return "vcvtsh2usi";
        case Mnemonic::Vcvtsi2sd:
            return "vcvtsi2sd";
        case Mnemonic::Vcvtsi2sh:
            return "vcvtsi2sh";
        case Mnemonic::Vcvtsi2ss:
            return "vcvtsi2ss";
        case Mnemonic::Vcvtss2sd:
            return "vcvtss2sd";
        case Mnemonic::Vcvtss2sh:
            return "vcvtss2sh";
        case Mnemonic::Vcvtss2si:
            return "vcvtss2si";
        case Mnemonic::Vcvtss2usi:
            return "vcvtss2usi";
        case Mnemonic::Vcvttpd2dq:
            return "vcvttpd2dq";
        case Mnemonic::Vcvttpd2qq:
            return "vcvttpd2qq";
        case Mnemonic::Vcvttpd2udq:
            return "vcvttpd2udq";
        case Mnemonic::Vcvttpd2uqq:
            return "vcvttpd2uqq";
        case Mnemonic::Vcvttph2dq:
            return "vcvttph2dq";
        case Mnemonic::Vcvttph2qq:
            return "vcvttph2qq";
        case Mnemonic::Vcvttph2udq:
            return "vcvttph2udq";
        case Mnemonic::Vcvttph2uqq:
            return "vcvttph2uqq";
        case Mnemonic::Vcvttph2uw:
            return "vcvttph2uw";
        case Mnemonic::Vcvttph2w:
            return "vcvttph2w";
        case Mnemonic::Vcvttps2dq:
            return "vcvttps2dq";
        case Mnemonic::Vcvttps2qq:
            return "vcvttps2qq";
        case Mnemonic::Vcvttps2udq:
            return "vcvttps2udq";
        case Mnemonic::Vcvttps2uqq:
            return "vcvttps2uqq";
        case Mnemonic::Vcvttsd2si:
            return "vcvttsd2si";
        case Mnemonic::Vcvttsd2usi:
            return "vcvttsd2usi";
        case Mnemonic::Vcvttsh2si:
            return "vcvttsh2si";
        case Mnemonic::Vcvttsh2usi:
            return "vcvttsh2usi";
        case Mnemonic::Vcvttss2si:
            return "vcvttss2si";
        case Mnemonic::Vcvttss2usi:
            return "vcvttss2usi";
        case Mnemonic::Vcvtudq2pd:
            return "vcvtudq2pd";
        case Mnemonic::Vcvtudq2ph:
            return "vcvtudq2ph";
        case Mnemonic::Vcvtudq2ps:
            return "vcvtudq2ps";
        case Mnemonic::Vcvtuqq2pd:
            return "vcvtuqq2pd";
        case Mnemonic::Vcvtuqq2ph:
            return "vcvtuqq2ph";
        case Mnemonic::Vcvtuqq2ps:
            return "vcvtuqq2ps";
        case Mnemonic::Vcvtusi2sd:
            return "vcvtusi2sd";
        case Mnemonic::Vcvtusi2sh:
            return "vcvtusi2sh";
        case Mnemonic::Vcvtusi2ss:
            return "vcvtusi2ss";
        case Mnemonic::Vcvtuw2ph:
            return "vcvtuw2ph";
        case Mnemonic::Vcvtw2ph:
            return "vcvtw2ph";
        case Mnemonic::Vdbpsadbw:
            return "vdbpsadbw";
        case Mnemonic::Vdivpd:
            return "vdivpd";
        case Mnemonic::Vdivph:
            return "vdivph";
        case Mnemonic::Vdivps:
            return "vdivps";
        case Mnemonic::Vdivsd:
            return "vdivsd";
        case Mnemonic::Vdivsh:
            return "vdivsh";
        case Mnemonic::Vdivss:
            return "vdivss";
        case Mnemonic::Vdpbf16ps:
            return "vdpbf16ps";
        case Mnemonic::Vdppd:
            return "vdppd";
        case Mnemonic::Vdpps:
            return "vdpps";
        case Mnemonic::Verr:
            return "verr";
        case Mnemonic::Verw:
            return "verw";
        case Mnemonic::Vexp223ps:
            return "vexp223ps";
        case Mnemonic::Vexp2pd:
            return "vexp2pd";
        case Mnemonic::Vexp2ps:
            return "vexp2ps";
        case Mnemonic::Vexpandpd:
            return "vexpandpd";
        case Mnemonic::Vexpandps:
            return "vexpandps";
        case Mnemonic::Vextractf128:
            return "vextractf128";
        case Mnemonic::Vextractf32x4:
            return "vextractf32x4";
        case Mnemonic::Vextractf32x8:
            return "vextractf32x8";
        case Mnemonic::Vextractf64x2:
            return "vextractf64x2";
        case Mnemonic::Vextractf64x4:
            return "vextractf64x4";
        case Mnemonic::Vextracti128:
            return "vextracti128";
        case Mnemonic::Vextracti32x4:
            return "vextracti32x4";
        case Mnemonic::Vextracti32x8:
            return "vextracti32x8";
        case Mnemonic::Vextracti64x2:
            return "vextracti64x2";
        case Mnemonic::Vextracti64x4:
            return "vextracti64x4";
        case Mnemonic::Vextractps:
            return "vextractps";
        case Mnemonic::Vfcmaddcph:
            return "vfcmaddcph";
        case Mnemonic::Vfcmaddcsh:
            return "vfcmaddcsh";
        case Mnemonic::Vfcmulcph:
            return "vfcmulcph";
        case Mnemonic::Vfcmulcsh:
            return "vfcmulcsh";
        case Mnemonic::Vfixupimmpd:
            return "vfixupimmpd";
        case Mnemonic::Vfixupimmps:
            return "vfixupimmps";
        case Mnemonic::Vfixupimmsd:
            return "vfixupimmsd";
        case Mnemonic::Vfixupimmss:
            return "vfixupimmss";
        case Mnemonic::Vfixupnanpd:
            return "vfixupnanpd";
        case Mnemonic::Vfixupnanps:
            return "vfixupnanps";
        case Mnemonic::Vfmadd132pd:
            return "vfmadd132pd";
        case Mnemonic::Vfmadd132ph:
            return "vfmadd132ph";
        case Mnemonic::Vfmadd132ps:
            return "vfmadd132ps";
        case Mnemonic::Vfmadd132sd:
            return "vfmadd132sd";
        case Mnemonic::Vfmadd132sh:
            return "vfmadd132sh";
        case Mnemonic::Vfmadd132ss:
            return "vfmadd132ss";
        case Mnemonic::Vfmadd213pd:
            return "vfmadd213pd";
        case Mnemonic::Vfmadd213ph:
            return "vfmadd213ph";
        case Mnemonic::Vfmadd213ps:
            return "vfmadd213ps";
        case Mnemonic::Vfmadd213sd:
            return "vfmadd213sd";
        case Mnemonic::Vfmadd213sh:
            return "vfmadd213sh";
        case Mnemonic::Vfmadd213ss:
            return "vfmadd213ss";
        case Mnemonic::Vfmadd231pd:
            return "vfmadd231pd";
        case Mnemonic::Vfmadd231ph:
            return "vfmadd231ph";
        case Mnemonic::Vfmadd231ps:
            return "vfmadd231ps";
        case Mnemonic::Vfmadd231sd:
            return "vfmadd231sd";
        case Mnemonic::Vfmadd231sh:
            return "vfmadd231sh";
        case Mnemonic::Vfmadd231ss:
            return "vfmadd231ss";
        case Mnemonic::Vfmadd233ps:
            return "vfmadd233ps";
        case Mnemonic::Vfmaddcph:
            return "vfmaddcph";
        case Mnemonic::Vfmaddcsh:
            return "vfmaddcsh";
        case Mnemonic::Vfmaddpd:
            return "vfmaddpd";
        case Mnemonic::Vfmaddps:
            return "vfmaddps";
        case Mnemonic::Vfmaddsd:
            return "vfmaddsd";
        case Mnemonic::Vfmaddss:
            return "vfmaddss";
        case Mnemonic::Vfmaddsub132pd:
            return "vfmaddsub132pd";
        case Mnemonic::Vfmaddsub132ph:
            return "vfmaddsub132ph";
        case Mnemonic::Vfmaddsub132ps:
            return "vfmaddsub132ps";
        case Mnemonic::Vfmaddsub213pd:
            return "vfmaddsub213pd";
        case Mnemonic::Vfmaddsub213ph:
            return "vfmaddsub213ph";
        case Mnemonic::Vfmaddsub213ps:
            return "vfmaddsub213ps";
        case Mnemonic::Vfmaddsub231pd:
            return "vfmaddsub231pd";
        case Mnemonic::Vfmaddsub231ph:
            return "vfmaddsub231ph";
        case Mnemonic::Vfmaddsub231ps:
            return "vfmaddsub231ps";
        case Mnemonic::Vfmaddsubpd:
            return "vfmaddsubpd";
        case Mnemonic::Vfmaddsubps:
            return "vfmaddsubps";
        case Mnemonic::Vfmsub132pd:
            return "vfmsub132pd";
        case Mnemonic::Vfmsub132ph:
            return "vfmsub132ph";
        case Mnemonic::Vfmsub132ps:
            return "vfmsub132ps";
        case Mnemonic::Vfmsub132sd:
            return "vfmsub132sd";
        case Mnemonic::Vfmsub132sh:
            return "vfmsub132sh";
        case Mnemonic::Vfmsub132ss:
            return "vfmsub132ss";
        case Mnemonic::Vfmsub213pd:
            return "vfmsub213pd";
        case Mnemonic::Vfmsub213ph:
            return "vfmsub213ph";
        case Mnemonic::Vfmsub213ps:
            return "vfmsub213ps";
        case Mnemonic::Vfmsub213sd:
            return "vfmsub213sd";
        case Mnemonic::Vfmsub213sh:
            return "vfmsub213sh";
        case Mnemonic::Vfmsub213ss:
            return "vfmsub213ss";
        case Mnemonic::Vfmsub231pd:
            return "vfmsub231pd";
        case Mnemonic::Vfmsub231ph:
            return "vfmsub231ph";
        case Mnemonic::Vfmsub231ps:
            return "vfmsub231ps";
        case Mnemonic::Vfmsub231sd:
            return "vfmsub231sd";
        case Mnemonic::Vfmsub231sh:
            return "vfmsub231sh";
        case Mnemonic::Vfmsub231ss:
            return "vfmsub231ss";
        case Mnemonic::Vfmsubadd132pd:
            return "vfmsubadd132pd";
        case Mnemonic::Vfmsubadd132ph:
            return "vfmsubadd132ph";
        case Mnemonic::Vfmsubadd132ps:
            return "vfmsubadd132ps";
        case Mnemonic::Vfmsubadd213pd:
            return "vfmsubadd213pd";
        case Mnemonic::Vfmsubadd213ph:
            return "vfmsubadd213ph";
        case Mnemonic::Vfmsubadd213ps:
            return "vfmsubadd213ps";
        case Mnemonic::Vfmsubadd231pd:
            return "vfmsubadd231pd";
        case Mnemonic::Vfmsubadd231ph:
            return "vfmsubadd231ph";
        case Mnemonic::Vfmsubadd231ps:
            return "vfmsubadd231ps";
        case Mnemonic::Vfmsubaddpd:
            return "vfmsubaddpd";
        case Mnemonic::Vfmsubaddps:
            return "vfmsubaddps";
        case Mnemonic::Vfmsubpd:
            return "vfmsubpd";
        case Mnemonic::Vfmsubps:
            return "vfmsubps";
        case Mnemonic::Vfmsubsd:
            return "vfmsubsd";
        case Mnemonic::Vfmsubss:
            return "vfmsubss";
        case Mnemonic::Vfmulcph:
            return "vfmulcph";
        case Mnemonic::Vfmulcsh:
            return "vfmulcsh";
        case Mnemonic::Vfnmadd132pd:
            return "vfnmadd132pd";
        case Mnemonic::Vfnmadd132ph:
            return "vfnmadd132ph";
        case Mnemonic::Vfnmadd132ps:
            return "vfnmadd132ps";
        case Mnemonic::Vfnmadd132sd:
            return "vfnmadd132sd";
        case Mnemonic::Vfnmadd132sh:
            return "vfnmadd132sh";
        case Mnemonic::Vfnmadd132ss:
            return "vfnmadd132ss";
        case Mnemonic::Vfnmadd213pd:
            return "vfnmadd213pd";
        case Mnemonic::Vfnmadd213ph:
            return "vfnmadd213ph";
        case Mnemonic::Vfnmadd213ps:
            return "vfnmadd213ps";
        case Mnemonic::Vfnmadd213sd:
            return "vfnmadd213sd";
        case Mnemonic::Vfnmadd213sh:
            return "vfnmadd213sh";
        case Mnemonic::Vfnmadd213ss:
            return "vfnmadd213ss";
        case Mnemonic::Vfnmadd231pd:
            return "vfnmadd231pd";
        case Mnemonic::Vfnmadd231ph:
            return "vfnmadd231ph";
        case Mnemonic::Vfnmadd231ps:
            return "vfnmadd231ps";
        case Mnemonic::Vfnmadd231sd:
            return "vfnmadd231sd";
        case Mnemonic::Vfnmadd231sh:
            return "vfnmadd231sh";
        case Mnemonic::Vfnmadd231ss:
            return "vfnmadd231ss";
        case Mnemonic::Vfnmaddpd:
            return "vfnmaddpd";
        case Mnemonic::Vfnmaddps:
            return "vfnmaddps";
        case Mnemonic::Vfnmaddsd:
            return "vfnmaddsd";
        case Mnemonic::Vfnmaddss:
            return "vfnmaddss";
        case Mnemonic::Vfnmsub132pd:
            return "vfnmsub132pd";
        case Mnemonic::Vfnmsub132ph:
            return "vfnmsub132ph";
        case Mnemonic::Vfnmsub132ps:
            return "vfnmsub132ps";
        case Mnemonic::Vfnmsub132sd:
            return "vfnmsub132sd";
        case Mnemonic::Vfnmsub132sh:
            return "vfnmsub132sh";
        case Mnemonic::Vfnmsub132ss:
            return "vfnmsub132ss";
        case Mnemonic::Vfnmsub213pd:
            return "vfnmsub213pd";
        case Mnemonic::Vfnmsub213ph:
            return "vfnmsub213ph";
        case Mnemonic::Vfnmsub213ps:
            return "vfnmsub213ps";
        case Mnemonic::Vfnmsub213sd:
            return "vfnmsub213sd";
        case Mnemonic::Vfnmsub213sh:
            return "vfnmsub213sh";
        case Mnemonic::Vfnmsub213ss:
            return "vfnmsub213ss";
        case Mnemonic::Vfnmsub231pd:
            return "vfnmsub231pd";
        case Mnemonic::Vfnmsub231ph:
            return "vfnmsub231ph";
        case Mnemonic::Vfnmsub231ps:
            return "vfnmsub231ps";
        case Mnemonic::Vfnmsub231sd:
            return "vfnmsub231sd";
        case Mnemonic::Vfnmsub231sh:
            return "vfnmsub231sh";
        case Mnemonic::Vfnmsub231ss:
            return "vfnmsub231ss";
        case Mnemonic::Vfnmsubpd:
            return "vfnmsubpd";
        case Mnemonic::Vfnmsubps:
            return "vfnmsubps";
        case Mnemonic::Vfnmsubsd:
            return "vfnmsubsd";
        case Mnemonic::Vfnmsubss:
            return "vfnmsubss";
        case Mnemonic::Vfpclasspd:
            return "vfpclasspd";
        case Mnemonic::Vfpclassph:
            return "vfpclassph";
        case Mnemonic::Vfpclassps:
            return "vfpclassps";
        case Mnemonic::Vfpclasssd:
            return "vfpclasssd";
        case Mnemonic::Vfpclasssh:
            return "vfpclasssh";
        case Mnemonic::Vfpclassss:
            return "vfpclassss";
        case Mnemonic::Vfrczpd:
            return "vfrczpd";
        case Mnemonic::Vfrczps:
            return "vfrczps";
        case Mnemonic::Vfrczsd:
            return "vfrczsd";
        case Mnemonic::Vfrczss:
            return "vfrczss";
        case Mnemonic::Vgatherdpd:
            return "vgatherdpd";
        case Mnemonic::Vgatherdps:
            return "vgatherdps";
        case Mnemonic::Vgatherpf0dpd:
            return "vgatherpf0dpd";
        case Mnemonic::Vgatherpf0dps:
            return "vgatherpf0dps";
        case Mnemonic::Vgatherpf0hintdpd:
            return "vgatherpf0hintdpd";
        case Mnemonic::Vgatherpf0hintdps:
            return "vgatherpf0hintdps";
        case Mnemonic::Vgatherpf0qpd:
            return "vgatherpf0qpd";
        case Mnemonic::Vgatherpf0qps:
            return "vgatherpf0qps";
        case Mnemonic::Vgatherpf1dpd:
            return "vgatherpf1dpd";
        case Mnemonic::Vgatherpf1dps:
            return "vgatherpf1dps";
        case Mnemonic::Vgatherpf1qpd:
            return "vgatherpf1qpd";
        case Mnemonic::Vgatherpf1qps:
            return "vgatherpf1qps";
        case Mnemonic::Vgatherqpd:
            return "vgatherqpd";
        case Mnemonic::Vgatherqps:
            return "vgatherqps";
        case Mnemonic::Vgetexppd:
            return "vgetexppd";
        case Mnemonic::Vgetexpph:
            return "vgetexpph";
        case Mnemonic::Vgetexpps:
            return "vgetexpps";
        case Mnemonic::Vgetexpsd:
            return "vgetexpsd";
        case Mnemonic::Vgetexpsh:
            return "vgetexpsh";
        case Mnemonic::Vgetexpss:
            return "vgetexpss";
        case Mnemonic::Vgetmantpd:
            return "vgetmantpd";
        case Mnemonic::Vgetmantph:
            return "vgetmantph";
        case Mnemonic::Vgetmantps:
            return "vgetmantps";
        case Mnemonic::Vgetmantsd:
            return "vgetmantsd";
        case Mnemonic::Vgetmantsh:
            return "vgetmantsh";
        case Mnemonic::Vgetmantss:
            return "vgetmantss";
        case Mnemonic::Vgf2p8affineinvqb:
            return "vgf2p8affineinvqb";
        case Mnemonic::Vgf2p8affineqb:
            return "vgf2p8affineqb";
        case Mnemonic::Vgf2p8mulb:
            return "vgf2p8mulb";
        case Mnemonic::Vgmaxabsps:
            return "vgmaxabsps";
        case Mnemonic::Vgmaxpd:
            return "vgmaxpd";
        case Mnemonic::Vgmaxps:
            return "vgmaxps";
        case Mnemonic::Vgminpd:
            return "vgminpd";
        case Mnemonic::Vgminps:
            return "vgminps";
        case Mnemonic::Vhaddpd:
            return "vhaddpd";
        case Mnemonic::Vhaddps:
            return "vhaddps";
        case Mnemonic::Vhsubpd:
            return "vhsubpd";
        case Mnemonic::Vhsubps:
            return "vhsubps";
        case Mnemonic::Vinsertf128:
            return "vinsertf128";
        case Mnemonic::Vinsertf32x4:
            return "vinsertf32x4";
        case Mnemonic::Vinsertf32x8:
            return "vinsertf32x8";
        case Mnemonic::Vinsertf64x2:
            return "vinsertf64x2";
        case Mnemonic::Vinsertf64x4:
            return "vinsertf64x4";
        case Mnemonic::Vinserti128:
            return "vinserti128";
        case Mnemonic::Vinserti32x4:
            return "vinserti32x4";
        case Mnemonic::Vinserti32x8:
            return "vinserti32x8";
        case Mnemonic::Vinserti64x2:
            return "vinserti64x2";
        case Mnemonic::Vinserti64x4:
            return "vinserti64x4";
        case Mnemonic::Vinsertps:
            return "vinsertps";
        case Mnemonic::Vlddqu:
            return "vlddqu";
        case Mnemonic::Vldmxcsr:
            return "vldmxcsr";
        case Mnemonic::Vloadunpackhd:
            return "vloadunpackhd";
        case Mnemonic::Vloadunpackhpd:
            return "vloadunpackhpd";
        case Mnemonic::Vloadunpackhps:
            return "vloadunpackhps";
        case Mnemonic::Vloadunpackhq:
            return "vloadunpackhq";
        case Mnemonic::Vloadunpackld:
            return "vloadunpackld";
        case Mnemonic::Vloadunpacklpd:
            return "vloadunpacklpd";
        case Mnemonic::Vloadunpacklps:
            return "vloadunpacklps";
        case Mnemonic::Vloadunpacklq:
            return "vloadunpacklq";
        case Mnemonic::Vlog2ps:
            return "vlog2ps";
        case Mnemonic::Vmaskmovdqu:
            return "vmaskmovdqu";
        case Mnemonic::Vmaskmovpd:
            return "vmaskmovpd";
        case Mnemonic::Vmaskmovps:
            return "vmaskmovps";
        case Mnemonic::Vmaxpd:
            return "vmaxpd";
        case Mnemonic::Vmaxph:
            return "vmaxph";
        case Mnemonic::Vmaxps:
            return "vmaxps";
        case Mnemonic::Vmaxsd:
            return "vmaxsd";
        case Mnemonic::Vmaxsh:
            return "vmaxsh";
        case Mnemonic::Vmaxss:
            return "vmaxss";
        case Mnemonic::Vmcall:
            return "vmcall";
        case Mnemonic::Vmclear:
            return "vmclear";
        case Mnemonic::Vmfunc:
            return "vmfunc";
        case Mnemonic::Vminpd:
            return "vminpd";
        case Mnemonic::Vminph:
            return "vminph";
        case Mnemonic::Vminps:
            return "vminps";
        case Mnemonic::Vminsd:
            return "vminsd";
        case Mnemonic::Vminsh:
            return "vminsh";
        case Mnemonic::Vminss:
            return "vminss";
        case Mnemonic::Vmlaunch:
            return "vmlaunch";
        case Mnemonic::Vmload:
            return "vmload";
        case Mnemonic::Vmmcall:
            return "vmmcall";
        case Mnemonic::Vmovapd:
            return "vmovapd";
        case Mnemonic::Vmovaps:
            return "vmovaps";
        case Mnemonic::Vmovd:
            return "vmovd";
        case Mnemonic::Vmovddup:
            return "vmovddup";
        case Mnemonic::Vmovdqa:
            return "vmovdqa";
        case Mnemonic::Vmovdqa32:
            return "vmovdqa32";
        case Mnemonic::Vmovdqa64:
            return "vmovdqa64";
        case Mnemonic::Vmovdqu:
            return "vmovdqu";
        case Mnemonic::Vmovdqu16:
            return "vmovdqu16";
        case Mnemonic::Vmovdqu32:
            return "vmovdqu32";
        case Mnemonic::Vmovdqu64:
            return "vmovdqu64";
        case Mnemonic::Vmovdqu8:
            return "vmovdqu8";
        case Mnemonic::Vmovhlps:
            return "vmovhlps";
        case Mnemonic::Vmovhpd:
            return "vmovhpd";
        case Mnemonic::Vmovhps:
            return "vmovhps";
        case Mnemonic::Vmovlhps:
            return "vmovlhps";
        case Mnemonic::Vmovlpd:
            return "vmovlpd";
        case Mnemonic::Vmovlps:
            return "vmovlps";
        case Mnemonic::Vmovmskpd:
            return "vmovmskpd";
        case Mnemonic::Vmovmskps:
            return "vmovmskps";
        case Mnemonic::Vmovnrapd:
            return "vmovnrapd";
        case Mnemonic::Vmovnraps:
            return "vmovnraps";
        case Mnemonic::Vmovnrngoapd:
            return "vmovnrngoapd";
        case Mnemonic::Vmovnrngoaps:
            return "vmovnrngoaps";
        case Mnemonic::Vmovntdq:
            return "vmovntdq";
        case Mnemonic::Vmovntdqa:
            return "vmovntdqa";
        case Mnemonic::Vmovntpd:
            return "vmovntpd";
        case Mnemonic::Vmovntps:
            return "vmovntps";
        case Mnemonic::Vmovq:
            return "vmovq";
        case Mnemonic::Vmovsd:
            return "vmovsd";
        case Mnemonic::Vmovsh:
            return "vmovsh";
        case Mnemonic::Vmovshdup:
            return "vmovshdup";
        case Mnemonic::Vmovsldup:
            return "vmovsldup";
        case Mnemonic::Vmovss:
            return "vmovss";
        case Mnemonic::Vmovupd:
            return "vmovupd";
        case Mnemonic::Vmovups:
            return "vmovups";
        case Mnemonic::Vmovw:
            return "vmovw";
        case Mnemonic::Vmpsadbw:
            return "vmpsadbw";
        case Mnemonic::Vmptrld:
            return "vmptrld";
        case Mnemonic::Vmptrst:
            return "vmptrst";
        case Mnemonic::Vmread:
            return "vmread";
        case Mnemonic::Vmresume:
            return "vmresume";
        case Mnemonic::Vmrun:
            return "vmrun";
        case Mnemonic::Vmsave:
            return "vmsave";
        case Mnemonic::Vmulpd:
            return "vmulpd";
        case Mnemonic::Vmulph:
            return "vmulph";
        case Mnemonic::Vmulps:
            return "vmulps";
        case Mnemonic::Vmulsd:
            return "vmulsd";
        case Mnemonic::Vmulsh:
            return "vmulsh";
        case Mnemonic::Vmulss:
            return "vmulss";
        case Mnemonic::Vmwrite:
            return "vmwrite";
        case Mnemonic::Vmxoff:
            return "vmxoff";
        case Mnemonic::Vmxon:
            return "vmxon";
        case Mnemonic::Vorpd:
            return "vorpd";
        case Mnemonic::Vorps:
            return "vorps";
        case Mnemonic::Vp2intersectd:
            return "vp2intersectd";
        case Mnemonic::Vp2intersectq:
            return "vp2intersectq";
        case Mnemonic::Vp4dpwssd:
            return "vp4dpwssd";
        case Mnemonic::Vp4dpwssds:
            return "vp4dpwssds";
        case Mnemonic::Vpabsb:
            return "vpabsb";
        case Mnemonic::Vpabsd:
            return "vpabsd";
        case Mnemonic::Vpabsq:
            return "vpabsq";
        case Mnemonic::Vpabsw:
            return "vpabsw";
        case Mnemonic::Vpackssdw:
            return "vpackssdw";
        case Mnemonic::Vpacksswb:
            return "vpacksswb";
        case Mnemonic::Vpackstorehd:
            return "vpackstorehd";
        case Mnemonic::Vpackstorehpd:
            return "vpackstorehpd";
        case Mnemonic::Vpackstorehps:
            return "vpackstorehps";
        case Mnemonic::Vpackstorehq:
            return "vpackstorehq";
        case Mnemonic::Vpackstoreld:
            return "vpackstoreld";
        case Mnemonic::Vpackstorelpd:
            return "vpackstorelpd";
        case Mnemonic::Vpackstorelps:
            return "vpackstorelps";
        case Mnemonic::Vpackstorelq:
            return "vpackstorelq";
        case Mnemonic::Vpackusdw:
            return "vpackusdw";
        case Mnemonic::Vpackuswb:
            return "vpackuswb";
        case Mnemonic::Vpadcd:
            return "vpadcd";
        case Mnemonic::Vpaddb:
            return "vpaddb";
        case Mnemonic::Vpaddd:
            return "vpaddd";
        case Mnemonic::Vpaddq:
            return "vpaddq";
        case Mnemonic::Vpaddsb:
            return "vpaddsb";
        case Mnemonic::Vpaddsetcd:
            return "vpaddsetcd";
        case Mnemonic::Vpaddsetsd:
            return "vpaddsetsd";
        case Mnemonic::Vpaddsw:
            return "vpaddsw";
        case Mnemonic::Vpaddusb:
            return "vpaddusb";
        case Mnemonic::Vpaddusw:
            return "vpaddusw";
        case Mnemonic::Vpaddw:
            return "vpaddw";
        case Mnemonic::Vpalignr:
            return "vpalignr";
        case Mnemonic::Vpand:
            return "vpand";
        case Mnemonic::Vpandd:
            return "vpandd";
        case Mnemonic::Vpandn:
            return "vpandn";
        case Mnemonic::Vpandnd:
            return "vpandnd";
        case Mnemonic::Vpandnq:
            return "vpandnq";
        case Mnemonic::Vpandq:
            return "vpandq";
        case Mnemonic::Vpavgb:
            return "vpavgb";
        case Mnemonic::Vpavgw:
            return "vpavgw";
        case Mnemonic::Vpblendd:
            return "vpblendd";
        case Mnemonic::Vpblendmb:
            return "vpblendmb";
        case Mnemonic::Vpblendmd:
            return "vpblendmd";
        case Mnemonic::Vpblendmq:
            return "vpblendmq";
        case Mnemonic::Vpblendmw:
            return "vpblendmw";
        case Mnemonic::Vpblendvb:
            return "vpblendvb";
        case Mnemonic::Vpblendw:
            return "vpblendw";
        case Mnemonic::Vpbroadcastb:
            return "vpbroadcastb";
        case Mnemonic::Vpbroadcastd:
            return "vpbroadcastd";
        case Mnemonic::Vpbroadcastmb2q:
            return "vpbroadcastmb2q";
        case Mnemonic::Vpbroadcastmw2d:
            return "vpbroadcastmw2d";
        case Mnemonic::Vpbroadcastq:
            return "vpbroadcastq";
        case Mnemonic::Vpbroadcastw:
            return "vpbroadcastw";
        case Mnemonic::Vpclmulqdq:
            return "vpclmulqdq";
        case Mnemonic::Vpcmov:
            return "vpcmov";
        case Mnemonic::Vpcmpb:
            return "vpcmpb";
        case Mnemonic::Vpcmpd:
            return "vpcmpd";
        case Mnemonic::Vpcmpeqb:
            return "vpcmpeqb";
        case Mnemonic::Vpcmpeqd:
            return "vpcmpeqd";
        case Mnemonic::Vpcmpeqq:
            return "vpcmpeqq";
        case Mnemonic::Vpcmpeqw:
            return "vpcmpeqw";
        case Mnemonic::Vpcmpestri:
            return "vpcmpestri";
        case Mnemonic::Vpcmpestrm:
            return "vpcmpestrm";
        case Mnemonic::Vpcmpgtb:
            return "vpcmpgtb";
        case Mnemonic::Vpcmpgtd:
            return "vpcmpgtd";
        case Mnemonic::Vpcmpgtq:
            return "vpcmpgtq";
        case Mnemonic::Vpcmpgtw:
            return "vpcmpgtw";
        case Mnemonic::Vpcmpistri:
            return "vpcmpistri";
        case Mnemonic::Vpcmpistrm:
            return "vpcmpistrm";
        case Mnemonic::Vpcmpltd:
            return "vpcmpltd";
        case Mnemonic::Vpcmpq:
            return "vpcmpq";
        case Mnemonic::Vpcmpub:
            return "vpcmpub";
        case Mnemonic::Vpcmpud:
            return "vpcmpud";
        case Mnemonic::Vpcmpuq:
            return "vpcmpuq";
        case Mnemonic::Vpcmpuw:
            return "vpcmpuw";
        case Mnemonic::Vpcmpw:
            return "vpcmpw";
        case Mnemonic::Vpcomb:
            return "vpcomb";
        case Mnemonic::Vpcomd:
            return "vpcomd";
        case Mnemonic::Vpcompressb:
            return "vpcompressb";
        case Mnemonic::Vpcompressd:
            return "vpcompressd";
        case Mnemonic::Vpcompressq:
            return "vpcompressq";
        case Mnemonic::Vpcompressw:
            return "vpcompressw";
        case Mnemonic::Vpcomq:
            return "vpcomq";
        case Mnemonic::Vpcomub:
            return "vpcomub";
        case Mnemonic::Vpcomud:
            return "vpcomud";
        case Mnemonic::Vpcomuq:
            return "vpcomuq";
        case Mnemonic::Vpcomuw:
            return "vpcomuw";
        case Mnemonic::Vpcomw:
            return "vpcomw";
        case Mnemonic::Vpconflictd:
            return "vpconflictd";
        case Mnemonic::Vpconflictq:
            return "vpconflictq";
        case Mnemonic::Vpdpbusd:
            return "vpdpbusd";
        case Mnemonic::Vpdpbusds:
            return "vpdpbusds";
        case Mnemonic::Vpdpwssd:
            return "vpdpwssd";
        case Mnemonic::Vpdpwssds:
            return "vpdpwssds";
        case Mnemonic::Vperm2f128:
            return "vperm2f128";
        case Mnemonic::Vperm2i128:
            return "vperm2i128";
        case Mnemonic::Vpermb:
            return "vpermb";
        case Mnemonic::Vpermd:
            return "vpermd";
        case Mnemonic::Vpermf32x4:
            return "vpermf32x4";
        case Mnemonic::Vpermi2b:
            return "vpermi2b";
        case Mnemonic::Vpermi2d:
            return "vpermi2d";
        case Mnemonic::Vpermi2pd:
            return "vpermi2pd";
        case Mnemonic::Vpermi2ps:
            return "vpermi2ps";
        case Mnemonic::Vpermi2q:
            return "vpermi2q";
        case Mnemonic::Vpermi2w:
            return "vpermi2w";
        case Mnemonic::Vpermil2pd:
            return "vpermil2pd";
        case Mnemonic::Vpermil2ps:
            return "vpermil2ps";
        case Mnemonic::Vpermilpd:
            return "vpermilpd";
        case Mnemonic::Vpermilps:
            return "vpermilps";
        case Mnemonic::Vpermpd:
            return "vpermpd";
        case Mnemonic::Vpermps:
            return "vpermps";
        case Mnemonic::Vpermq:
            return "vpermq";
        case Mnemonic::Vpermt2b:
            return "vpermt2b";
        case Mnemonic::Vpermt2d:
            return "vpermt2d";
        case Mnemonic::Vpermt2pd:
            return "vpermt2pd";
        case Mnemonic::Vpermt2ps:
            return "vpermt2ps";
        case Mnemonic::Vpermt2q:
            return "vpermt2q";
        case Mnemonic::Vpermt2w:
            return "vpermt2w";
        case Mnemonic::Vpermw:
            return "vpermw";
        case Mnemonic::Vpexpandb:
            return "vpexpandb";
        case Mnemonic::Vpexpandd:
            return "vpexpandd";
        case Mnemonic::Vpexpandq:
            return "vpexpandq";
        case Mnemonic::Vpexpandw:
            return "vpexpandw";
        case Mnemonic::Vpextrb:
            return "vpextrb";
        case Mnemonic::Vpextrd:
            return "vpextrd";
        case Mnemonic::Vpextrq:
            return "vpextrq";
        case Mnemonic::Vpextrw:
            return "vpextrw";
        case Mnemonic::Vpgatherdd:
            return "vpgatherdd";
        case Mnemonic::Vpgatherdq:
            return "vpgatherdq";
        case Mnemonic::Vpgatherqd:
            return "vpgatherqd";
        case Mnemonic::Vpgatherqq:
            return "vpgatherqq";
        case Mnemonic::Vphaddbd:
            return "vphaddbd";
        case Mnemonic::Vphaddbq:
            return "vphaddbq";
        case Mnemonic::Vphaddbw:
            return "vphaddbw";
        case Mnemonic::Vphaddd:
            return "vphaddd";
        case Mnemonic::Vphadddq:
            return "vphadddq";
        case Mnemonic::Vphaddsw:
            return "vphaddsw";
        case Mnemonic::Vphaddubd:
            return "vphaddubd";
        case Mnemonic::Vphaddubq:
            return "vphaddubq";
        case Mnemonic::Vphaddubw:
            return "vphaddubw";
        case Mnemonic::Vphaddudq:
            return "vphaddudq";
        case Mnemonic::Vphadduwd:
            return "vphadduwd";
        case Mnemonic::Vphadduwq:
            return "vphadduwq";
        case Mnemonic::Vphaddw:
            return "vphaddw";
        case Mnemonic::Vphaddwd:
            return "vphaddwd";
        case Mnemonic::Vphaddwq:
            return "vphaddwq";
        case Mnemonic::Vphminposuw:
            return "vphminposuw";
        case Mnemonic::Vphsubbw:
            return "vphsubbw";
        case Mnemonic::Vphsubd:
            return "vphsubd";
        case Mnemonic::Vphsubdq:
            return "vphsubdq";
        case Mnemonic::Vphsubsw:
            return "vphsubsw";
        case Mnemonic::Vphsubw:
            return "vphsubw";
        case Mnemonic::Vphsubwd:
            return "vphsubwd";
        case Mnemonic::Vpinsrb:
            return "vpinsrb";
        case Mnemonic::Vpinsrd:
            return "vpinsrd";
        case Mnemonic::Vpinsrq:
            return "vpinsrq";
        case Mnemonic::Vpinsrw:
            return "vpinsrw";
        case Mnemonic::Vplzcntd:
            return "vplzcntd";
        case Mnemonic::Vplzcntq:
            return "vplzcntq";
        case Mnemonic::Vpmacsdd:
            return "vpmacsdd";
        case Mnemonic::Vpmacsdqh:
            return "vpmacsdqh";
        case Mnemonic::Vpmacsdql:
            return "vpmacsdql";
        case Mnemonic::Vpmacssdd:
            return "vpmacssdd";
        case Mnemonic::Vpmacssdqh:
            return "vpmacssdqh";
        case Mnemonic::Vpmacssdql:
            return "vpmacssdql";
        case Mnemonic::Vpmacsswd:
            return "vpmacsswd";
        case Mnemonic::Vpmacssww:
            return "vpmacssww";
        case Mnemonic::Vpmacswd:
            return "vpmacswd";
        case Mnemonic::Vpmacsww:
            return "vpmacsww";
        case Mnemonic::Vpmadcsswd:
            return "vpmadcsswd";
        case Mnemonic::Vpmadcswd:
            return "vpmadcswd";
        case Mnemonic::Vpmadd231d:
            return "vpmadd231d";
        case Mnemonic::Vpmadd233d:
            return "vpmadd233d";
        case Mnemonic::Vpmadd52huq:
            return "vpmadd52huq";
        case Mnemonic::Vpmadd52luq:
            return "vpmadd52luq";
        case Mnemonic::Vpmaddubsw:
            return "vpmaddubsw";
        case Mnemonic::Vpmaddwd:
            return "vpmaddwd";
        case Mnemonic::Vpmaskmovd:
            return "vpmaskmovd";
        case Mnemonic::Vpmaskmovq:
            return "vpmaskmovq";
        case Mnemonic::Vpmaxsb:
            return "vpmaxsb";
        case Mnemonic::Vpmaxsd:
            return "vpmaxsd";
        case Mnemonic::Vpmaxsq:
            return "vpmaxsq";
        case Mnemonic::Vpmaxsw:
            return "vpmaxsw";
        case Mnemonic::Vpmaxub:
            return "vpmaxub";
        case Mnemonic::Vpmaxud:
            return "vpmaxud";
        case Mnemonic::Vpmaxuq:
            return "vpmaxuq";
        case Mnemonic::Vpmaxuw:
            return "vpmaxuw";
        case Mnemonic::Vpminsb:
            return "vpminsb";
        case Mnemonic::Vpminsd:
            return "vpminsd";
        case Mnemonic::Vpminsq:
            return "vpminsq";
        case Mnemonic::Vpminsw:
            return "vpminsw";
        case Mnemonic::Vpminub:
            return "vpminub";
        case Mnemonic::Vpminud:
            return "vpminud";
        case Mnemonic::Vpminuq:
            return "vpminuq";
        case Mnemonic::Vpminuw:
            return "vpminuw";
        case Mnemonic::Vpmovb2m:
            return "vpmovb2m";
        case Mnemonic::Vpmovd2m:
            return "vpmovd2m";
        case Mnemonic::Vpmovdb:
            return "vpmovdb";
        case Mnemonic::Vpmovdw:
            return "vpmovdw";
        case Mnemonic::Vpmovm2b:
            return "vpmovm2b";
        case Mnemonic::Vpmovm2d:
            return "vpmovm2d";
        case Mnemonic::Vpmovm2q:
            return "vpmovm2q";
        case Mnemonic::Vpmovm2w:
            return "vpmovm2w";
        case Mnemonic::Vpmovmskb:
            return "vpmovmskb";
        case Mnemonic::Vpmovq2m:
            return "vpmovq2m";
        case Mnemonic::Vpmovqb:
            return "vpmovqb";
        case Mnemonic::Vpmovqd:
            return "vpmovqd";
        case Mnemonic::Vpmovqw:
            return "vpmovqw";
        case Mnemonic::Vpmovsdb:
            return "vpmovsdb";
        case Mnemonic::Vpmovsdw:
            return "vpmovsdw";
        case Mnemonic::Vpmovsqb:
            return "vpmovsqb";
        case Mnemonic::Vpmovsqd:
            return "vpmovsqd";
        case Mnemonic::Vpmovsqw:
            return "vpmovsqw";
        case Mnemonic::Vpmovswb:
            return "vpmovswb";
        case Mnemonic::Vpmovsxbd:
            return "vpmovsxbd";
        case Mnemonic::Vpmovsxbq:
            return "vpmovsxbq";
        case Mnemonic::Vpmovsxbw:
            return "vpmovsxbw";
        case Mnemonic::Vpmovsxdq:
            return "vpmovsxdq";
        case Mnemonic::Vpmovsxwd:
            return "vpmovsxwd";
        case Mnemonic::Vpmovsxwq:
            return "vpmovsxwq";
        case Mnemonic::Vpmovusdb:
            return "vpmovusdb";
        case Mnemonic::Vpmovusdw:
            return "vpmovusdw";
        case Mnemonic::Vpmovusqb:
            return "vpmovusqb";
        case Mnemonic::Vpmovusqd:
            return "vpmovusqd";
        case Mnemonic::Vpmovusqw:
            return "vpmovusqw";
        case Mnemonic::Vpmovuswb:
            return "vpmovuswb";
        case Mnemonic::Vpmovw2m:
            return "vpmovw2m";
        case Mnemonic::Vpmovwb:
            return "vpmovwb";
        case Mnemonic::Vpmovzxbd:
            return "vpmovzxbd";
        case Mnemonic::Vpmovzxbq:
            return "vpmovzxbq";
        case Mnemonic::Vpmovzxbw:
            return "vpmovzxbw";
        case Mnemonic::Vpmovzxdq:
            return "vpmovzxdq";
        case Mnemonic::Vpmovzxwd:
            return "vpmovzxwd";
        case Mnemonic::Vpmovzxwq:
            return "vpmovzxwq";
        case Mnemonic::Vpmuldq:
            return "vpmuldq";
        case Mnemonic::Vpmulhd:
            return "vpmulhd";
        case Mnemonic::Vpmulhrsw:
            return "vpmulhrsw";
        case Mnemonic::Vpmulhud:
            return "vpmulhud";
        case Mnemonic::Vpmulhuw:
            return "vpmulhuw";
        case Mnemonic::Vpmulhw:
            return "vpmulhw";
        case Mnemonic::Vpmulld:
            return "vpmulld";
        case Mnemonic::Vpmullq:
            return "vpmullq";
        case Mnemonic::Vpmullw:
            return "vpmullw";
        case Mnemonic::Vpmultishiftqb:
            return "vpmultishiftqb";
        case Mnemonic::Vpmuludq:
            return "vpmuludq";
        case Mnemonic::Vpopcntb:
            return "vpopcntb";
        case Mnemonic::Vpopcntd:
            return "vpopcntd";
        case Mnemonic::Vpopcntq:
            return "vpopcntq";
        case Mnemonic::Vpopcntw:
            return "vpopcntw";
        case Mnemonic::Vpor:
            return "vpor";
        case Mnemonic::Vpord:
            return "vpord";
        case Mnemonic::Vporq:
            return "vporq";
        case Mnemonic::Vpperm:
            return "vpperm";
        case Mnemonic::Vprefetch0:
            return "vprefetch0";
        case Mnemonic::Vprefetch1:
            return "vprefetch1";
        case Mnemonic::Vprefetch2:
            return "vprefetch2";
        case Mnemonic::Vprefetche0:
            return "vprefetche0";
        case Mnemonic::Vprefetche1:
            return "vprefetche1";
        case Mnemonic::Vprefetche2:
            return "vprefetche2";
        case Mnemonic::Vprefetchenta:
            return "vprefetchenta";
        case Mnemonic::Vprefetchnta:
            return "vprefetchnta";
        case Mnemonic::Vprold:
            return "vprold";
        case Mnemonic::Vprolq:
            return "vprolq";
        case Mnemonic::Vprolvd:
            return "vprolvd";
        case Mnemonic::Vprolvq:
            return "vprolvq";
        case Mnemonic::Vprord:
            return "vprord";
        case Mnemonic::Vprorq:
            return "vprorq";
        case Mnemonic::Vprorvd:
            return "vprorvd";
        case Mnemonic::Vprorvq:
            return "vprorvq";
        case Mnemonic::Vprotb:
            return "vprotb";
        case Mnemonic::Vprotd:
            return "vprotd";
        case Mnemonic::Vprotq:
            return "vprotq";
        case Mnemonic::Vprotw:
            return "vprotw";
        case Mnemonic::Vpsadbw:
            return "vpsadbw";
        case Mnemonic::Vpsbbd:
            return "vpsbbd";
        case Mnemonic::Vpsbbrd:
            return "vpsbbrd";
        case Mnemonic::Vpscatterdd:
            return "vpscatterdd";
        case Mnemonic::Vpscatterdq:
            return "vpscatterdq";
        case Mnemonic::Vpscatterqd:
            return "vpscatterqd";
        case Mnemonic::Vpscatterqq:
            return "vpscatterqq";
        case Mnemonic::Vpshab:
            return "vpshab";
        case Mnemonic::Vpshad:
            return "vpshad";
        case Mnemonic::Vpshaq:
            return "vpshaq";
        case Mnemonic::Vpshaw:
            return "vpshaw";
        case Mnemonic::Vpshlb:
            return "vpshlb";
        case Mnemonic::Vpshld:
            return "vpshld";
        case Mnemonic::Vpshldd:
            return "vpshldd";
        case Mnemonic::Vpshldq:
            return "vpshldq";
        case Mnemonic::Vpshldvd:
            return "vpshldvd";
        case Mnemonic::Vpshldvq:
            return "vpshldvq";
        case Mnemonic::Vpshldvw:
            return "vpshldvw";
        case Mnemonic::Vpshldw:
            return "vpshldw";
        case Mnemonic::Vpshlq:
            return "vpshlq";
        case Mnemonic::Vpshlw:
            return "vpshlw";
        case Mnemonic::Vpshrdd:
            return "vpshrdd";
        case Mnemonic::Vpshrdq:
            return "vpshrdq";
        case Mnemonic::Vpshrdvd:
            return "vpshrdvd";
        case Mnemonic::Vpshrdvq:
            return "vpshrdvq";
        case Mnemonic::Vpshrdvw:
            return "vpshrdvw";
        case Mnemonic::Vpshrdw:
            return "vpshrdw";
        case Mnemonic::Vpshufb:
            return "vpshufb";
        case Mnemonic::Vpshufbitqmb:
            return "vpshufbitqmb";
        case Mnemonic::Vpshufd:
            return "vpshufd";
        case Mnemonic::Vpshufhw:
            return "vpshufhw";
        case Mnemonic::Vpshuflw:
            return "vpshuflw";
        case Mnemonic::Vpsignb:
            return "vpsignb";
        case Mnemonic::Vpsignd:
            return "vpsignd";
        case Mnemonic::Vpsignw:
            return "vpsignw";
        case Mnemonic::Vpslld:
            return "vpslld";
        case Mnemonic::Vpslldq:
            return "vpslldq";
        case Mnemonic::Vpsllq:
            return "vpsllq";
        case Mnemonic::Vpsllvd:
            return "vpsllvd";
        case Mnemonic::Vpsllvq:
            return "vpsllvq";
        case Mnemonic::Vpsllvw:
            return "vpsllvw";
        case Mnemonic::Vpsllw:
            return "vpsllw";
        case Mnemonic::Vpsrad:
            return "vpsrad";
        case Mnemonic::Vpsraq:
            return "vpsraq";
        case Mnemonic::Vpsravd:
            return "vpsravd";
        case Mnemonic::Vpsravq:
            return "vpsravq";
        case Mnemonic::Vpsravw:
            return "vpsravw";
        case Mnemonic::Vpsraw:
            return "vpsraw";
        case Mnemonic::Vpsrld:
            return "vpsrld";
        case Mnemonic::Vpsrldq:
            return "vpsrldq";
        case Mnemonic::Vpsrlq:
            return "vpsrlq";
        case Mnemonic::Vpsrlvd:
            return "vpsrlvd";
        case Mnemonic::Vpsrlvq:
            return "vpsrlvq";
        case Mnemonic::Vpsrlvw:
            return "vpsrlvw";
        case Mnemonic::Vpsrlw:
            return "vpsrlw";
        case Mnemonic::Vpsubb:
            return "vpsubb";
        case Mnemonic::Vpsubd:
            return "vpsubd";
        case Mnemonic::Vpsubq:
            return "vpsubq";
        case Mnemonic::Vpsubrd:
            return "vpsubrd";
        case Mnemonic::Vpsubrsetbd:
            return "vpsubrsetbd";
        case Mnemonic::Vpsubsb:
            return "vpsubsb";
        case Mnemonic::Vpsubsetbd:
            return "vpsubsetbd";
        case Mnemonic::Vpsubsw:
            return "vpsubsw";
        case Mnemonic::Vpsubusb:
            return "vpsubusb";
        case Mnemonic::Vpsubusw:
            return "vpsubusw";
        case Mnemonic::Vpsubw:
            return "vpsubw";
        case Mnemonic::Vpternlogd:
            return "vpternlogd";
        case Mnemonic::Vpternlogq:
            return "vpternlogq";
        case Mnemonic::Vptest:
            return "vptest";
        case Mnemonic::Vptestmb:
            return "vptestmb";
        case Mnemonic::Vptestmd:
            return "vptestmd";
        case Mnemonic::Vptestmq:
            return "vptestmq";
        case Mnemonic::Vptestmw:
            return "vptestmw";
        case Mnemonic::Vptestnmb:
            return "vptestnmb";
        case Mnemonic::Vptestnmd:
            return "vptestnmd";
        case Mnemonic::Vptestnmq:
            return "vptestnmq";
        case Mnemonic::Vptestnmw:
            return "vptestnmw";
        case Mnemonic::Vpunpckhbw:
            return "vpunpckhbw";
        case Mnemonic::Vpunpckhdq:
            return "vpunpckhdq";
        case Mnemonic::Vpunpckhqdq:
            return "vpunpckhqdq";
        case Mnemonic::Vpunpckhwd:
            return "vpunpckhwd";
        case Mnemonic::Vpunpcklbw:
            return "vpunpcklbw";
        case Mnemonic::Vpunpckldq:
            return "vpunpckldq";
        case Mnemonic::Vpunpcklqdq:
            return "vpunpcklqdq";
        case Mnemonic::Vpunpcklwd:
            return "vpunpcklwd";
        case Mnemonic::Vpxor:
            return "vpxor";
        case Mnemonic::Vpxord:
            return "vpxord";
        case Mnemonic::Vpxorq:
            return "vpxorq";
        case Mnemonic::Vrangepd:
            return "vrangepd";
        case Mnemonic::Vrangeps:
            return "vrangeps";
        case Mnemonic::Vrangesd:
            return "vrangesd";
        case Mnemonic::Vrangess:
            return "vrangess";
        case Mnemonic::Vrcp14pd:
            return "vrcp14pd";
        case Mnemonic::Vrcp14ps:
            return "vrcp14ps";
        case Mnemonic::Vrcp14sd:
            return "vrcp14sd";
        case Mnemonic::Vrcp14ss:
            return "vrcp14ss";
        case Mnemonic::Vrcp23ps:
            return "vrcp23ps";
        case Mnemonic::Vrcp28pd:
            return "vrcp28pd";
        case Mnemonic::Vrcp28ps:
            return "vrcp28ps";
        case Mnemonic::Vrcp28sd:
            return "vrcp28sd";
        case Mnemonic::Vrcp28ss:
            return "vrcp28ss";
        case Mnemonic::Vrcpph:
            return "vrcpph";
        case Mnemonic::Vrcpps:
            return "vrcpps";
        case Mnemonic::Vrcpsh:
            return "vrcpsh";
        case Mnemonic::Vrcpss:
            return "vrcpss";
        case Mnemonic::Vreducepd:
            return "vreducepd";
        case Mnemonic::Vreduceph:
            return "vreduceph";
        case Mnemonic::Vreduceps:
            return "vreduceps";
        case Mnemonic::Vreducesd:
            return "vreducesd";
        case Mnemonic::Vreducesh:
            return "vreducesh";
        case Mnemonic::Vreducess:
            return "vreducess";
        case Mnemonic::Vrndfxpntpd:
            return "vrndfxpntpd";
        case Mnemonic::Vrndfxpntps:
            return "vrndfxpntps";
        case Mnemonic::Vrndscalepd:
            return "vrndscalepd";
        case Mnemonic::Vrndscaleph:
            return "vrndscaleph";
        case Mnemonic::Vrndscaleps:
            return "vrndscaleps";
        case Mnemonic::Vrndscalesd:
            return "vrndscalesd";
        case Mnemonic::Vrndscalesh:
            return "vrndscalesh";
        case Mnemonic::Vrndscaless:
            return "vrndscaless";
        case Mnemonic::Vroundpd:
            return "vroundpd";
        case Mnemonic::Vroundps:
            return "vroundps";
        case Mnemonic::Vroundsd:
            return "vroundsd";
        case Mnemonic::Vroundss:
            return "vroundss";
        case Mnemonic::Vrsqrt14pd:
            return "vrsqrt14pd";
        case Mnemonic::Vrsqrt14ps:
            return "vrsqrt14ps";
        case Mnemonic::Vrsqrt14sd:
            return "vrsqrt14sd";
        case Mnemonic::Vrsqrt14ss:
            return "vrsqrt14ss";
        case Mnemonic::Vrsqrt23ps:
            return "vrsqrt23ps";
        case Mnemonic::Vrsqrt28pd:
            return "vrsqrt28pd";
        case Mnemonic::Vrsqrt28ps:
            return "vrsqrt28ps";
        case Mnemonic::Vrsqrt28sd:
            return "vrsqrt28sd";
        case Mnemonic::Vrsqrt28ss:
            return "vrsqrt28ss";
        case Mnemonic::Vrsqrtph:
            return "vrsqrtph";
        case Mnemonic::Vrsqrtps:
            return "vrsqrtps";
        case Mnemonic::Vrsqrtsh:
            return "vrsqrtsh";
        case Mnemonic::Vrsqrtss:
            return "vrsqrtss";
        case Mnemonic::Vscalefpd:
            return "vscalefpd";
        case Mnemonic::Vscalefph:
            return "vscalefph";
        case Mnemonic::Vscalefps:
            return "vscalefps";
        case Mnemonic::Vscalefsd:
            return "vscalefsd";
        case Mnemonic::Vscalefsh:
            return "vscalefsh";
        case Mnemonic::Vscalefss:
            return "vscalefss";
        case Mnemonic::Vscaleps:
            return "vscaleps";
        case Mnemonic::Vscatterdpd:
            return "vscatterdpd";
        case Mnemonic::Vscatterdps:
            return "vscatterdps";
        case Mnemonic::Vscatterpf0dpd:
            return "vscatterpf0dpd";
        case Mnemonic::Vscatterpf0dps:
            return "vscatterpf0dps";
        case Mnemonic::Vscatterpf0hintdpd:
            return "vscatterpf0hintdpd";
        case Mnemonic::Vscatterpf0hintdps:
            return "vscatterpf0hintdps";
        case Mnemonic::Vscatterpf0qpd:
            return "vscatterpf0qpd";
        case Mnemonic::Vscatterpf0qps:
            return "vscatterpf0qps";
        case Mnemonic::Vscatterpf1dpd:
            return "vscatterpf1dpd";
        case Mnemonic::Vscatterpf1dps:
            return "vscatterpf1dps";
        case Mnemonic::Vscatterpf1qpd:
            return "vscatterpf1qpd";
        case Mnemonic::Vscatterpf1qps:
            return "vscatterpf1qps";
        case Mnemonic::Vscatterqpd:
            return "vscatterqpd";
        case Mnemonic::Vscatterqps:
            return "vscatterqps";
        case Mnemonic::Vshuff32x4:
            return "vshuff32x4";
        case Mnemonic::Vshuff64x2:
            return "vshuff64x2";
        case Mnemonic::Vshufi32x4:
            return "vshufi32x4";
        case Mnemonic::Vshufi64x2:
            return "vshufi64x2";
        case Mnemonic::Vshufpd:
            return "vshufpd";
        case Mnemonic::Vshufps:
            return "vshufps";
        case Mnemonic::Vsqrtpd:
            return "vsqrtpd";
        case Mnemonic::Vsqrtph:
            return "vsqrtph";
        case Mnemonic::Vsqrtps:
            return "vsqrtps";
        case Mnemonic::Vsqrtsd:
            return "vsqrtsd";
        case Mnemonic::Vsqrtsh:
            return "vsqrtsh";
        case Mnemonic::Vsqrtss:
            return "vsqrtss";
        case Mnemonic::Vstmxcsr:
            return "vstmxcsr";
        case Mnemonic::Vsubpd:
            return "vsubpd";
        case Mnemonic::Vsubph:
            return "vsubph";
        case Mnemonic::Vsubps:
            return "vsubps";
        case Mnemonic::Vsubrpd:
            return "vsubrpd";
        case Mnemonic::Vsubrps:
            return "vsubrps";
        case Mnemonic::Vsubsd:
            return "vsubsd";
        case Mnemonic::Vsubsh:
            return "vsubsh";
        case Mnemonic::Vsubss:
            return "vsubss";
        case Mnemonic::Vtestpd:
            return "vtestpd";
        case Mnemonic::Vtestps:
            return "vtestps";
        case Mnemonic::Vucomisd:
            return "vucomisd";
        case Mnemonic::Vucomish:
            return "vucomish";
        case Mnemonic::Vucomiss:
            return "vucomiss";
        case Mnemonic::Vunpckhpd:
            return "vunpckhpd";
        case Mnemonic::Vunpckhps:
            return "vunpckhps";
        case Mnemonic::Vunpcklpd:
            return "vunpcklpd";
        case Mnemonic::Vunpcklps:
            return "vunpcklps";
        case Mnemonic::Vxorpd:
            return "vxorpd";
        case Mnemonic::Vxorps:
            return "vxorps";
        case Mnemonic::Vzeroall:
            return "vzeroall";
        case Mnemonic::Vzeroupper:
            return "vzeroupper";
        case Mnemonic::Wbinvd:
            return "wbinvd";
        case Mnemonic::Wrfsbase:
            return "wrfsbase";
        case Mnemonic::Wrgsbase:
            return "wrgsbase";
        case Mnemonic::Wrmsr:
            return "wrmsr";
        case Mnemonic::Wrpkru:
            return "wrpkru";
        case Mnemonic::Wrssd:
            return "wrssd";
        case Mnemonic::Wrssq:
            return "wrssq";
        case Mnemonic::Wrussd:
            return "wrussd";
        case Mnemonic::Wrussq:
            return "wrussq";
        case Mnemonic::Xabort:
            return "xabort";
        case Mnemonic::Xadd:
            return "xadd";
        case Mnemonic::Xbegin:
            return "xbegin";
        case Mnemonic::Xchg:
            return "xchg";
        case Mnemonic::Xcrypt_cbc:
            return "xcrypt_cbc";
        case Mnemonic::Xcrypt_cfb:
            return "xcrypt_cfb";
        case Mnemonic::Xcrypt_ctr:
            return "xcrypt_ctr";
        case Mnemonic::Xcrypt_ecb:
            return "xcrypt_ecb";
        case Mnemonic::Xcrypt_ofb:
            return "xcrypt_ofb";
        case Mnemonic::Xend:
            return "xend";
        case Mnemonic::Xgetbv:
            return "xgetbv";
        case Mnemonic::Xlat:
            return "xlat";
        case Mnemonic::Xor:
            return "xor";
        case Mnemonic::Xorpd:
            return "xorpd";
        case Mnemonic::Xorps:
            return "xorps";
        case Mnemonic::Xresldtrk:
            return "xresldtrk";
        case Mnemonic::Xrstor:
            return "xrstor";
        case Mnemonic::Xrstor64:
            return "xrstor64";
        case Mnemonic::Xrstors:
            return "xrstors";
        case Mnemonic::Xrstors64:
            return "xrstors64";
        case Mnemonic::Xsave:
            return "xsave";
        case Mnemonic::Xsave64:
            return "xsave64";
        case Mnemonic::Xsavec:
            return "xsavec";
        case Mnemonic::Xsavec64:
            return "xsavec64";
        case Mnemonic::Xsaveopt:
            return "xsaveopt";
        case Mnemonic::Xsaveopt64:
            return "xsaveopt64";
        case Mnemonic::Xsaves:
            return "xsaves";
        case Mnemonic::Xsaves64:
            return "xsaves64";
        case Mnemonic::Xsetbv:
            return "xsetbv";
        case Mnemonic::Xsha1:
            return "xsha1";
        case Mnemonic::Xsha256:
            return "xsha256";
        case Mnemonic::Xstore:
            return "xstore";
        case Mnemonic::Xsusldtrk:
            return "xsusldtrk";
        case Mnemonic::Xtest:
            return "xtest";
        }
        return "invalid";
    }

}

```

`src/Bindings/Module.cpp`:

```cpp
#include <vector>
#include <cstdint>

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_module.h"
#include "Register.hpp"
#include "pluginsdk/TitanEngine/TitanEngine.h"

#include "Marshal.hpp"

using namespace System;
using namespace System::Runtime::InteropServices;

namespace Dotx64Dbg::Native
{
    public ref class Module
    {
    public:
        ref class Section
        {
        public:
            System::String^ Name;
            duint Address;
            duint Size;
        };

        ref class Export
        {
        public:
            System::UIntPtr Rva;
            System::UIntPtr Va;
            System::String^ DecoratedName;
            System::String^ UndecoratedName;
            System::String^ ForwarderName;
            int Ordinal;
        };

        ref class Import
        {
        public:
            System::UIntPtr Rva;
            System::UIntPtr Va;
            System::String^ DecoratedName;
            System::String^ UndecoratedName;
            int Ordinal;
        };

        static array<duint>^ GetAll()
        {
            BridgeList<Script::Module::ModuleInfo> list;

            if (!Script::Module::GetList(&list))
                return nullptr;

            auto res = gcnew array<duint>(list.Count());
            for (int i = 0; i < list.Count(); i++)
            {
                res[i] = list[i].base;
            }
            return res;
        }

        static duint GetMain()
        {
            return Script::Module::GetMainModuleBase();
        }

        static duint FindByName(System::String^ name)
        {
            auto nameStr = interop::toUTF8(name);
            return Script::Module::BaseFromName(nameStr.c_str());
        }

        static duint FindByAddress(System::UIntPtr addr)
        {
            auto va = static_cast<duint>(addr.ToUInt64());

            return Script::Module::BaseFromAddr(va);
        }

        static duint GetSize(System::UIntPtr base)
        {
            auto va = static_cast<duint>(base.ToUInt64());
            return Script::Module::SizeFromAddr(va);
        }

        static System::String^ GetPath(System::UIntPtr base)
        {
            auto va = static_cast<duint>(base.ToUInt64());

            char modPath[4096]{};
            if (!Script::Module::PathFromAddr(va, modPath))
                return nullptr;

            return interop::stringFromUTF8(modPath);
        }

        static System::String^ GetName(System::UIntPtr base)
        {
            auto va = static_cast<duint>(base.ToUInt64());

            char modName[4096]{};
            if (!Script::Module::NameFromAddr(va, modName))
                return nullptr;

            return interop::stringFromUTF8(modName);
        }

        static duint GetEntrypoint(System::UIntPtr base)
        {
            auto va = static_cast<duint>(base.ToUInt64());

            return Script::Module::EntryFromAddr(va);
        }

        static int GetSectionCount(System::UIntPtr base)
        {
            auto va = static_cast<duint>(base.ToUInt64());

            return Script::Module::SectionCountFromAddr(va);
        }

        static Section^ GetSection(System::UIntPtr base, int index)
        {
            auto va = static_cast<duint>(base.ToUInt64());

            Script::Module::ModuleSectionInfo sect{};
            if (!Script::Module::SectionFromAddr(va, index, &sect))
                return nullptr;

            auto res = gcnew Section();
            res->Address = sect.addr;
            res->Size = sect.size;
            res->Name = interop::stringFromUTF8(sect.name);
            return res;
        }

        static array<Export^>^ GetExports(System::UIntPtr base)
        {
            auto va = static_cast<duint>(base.ToUInt64());

            BridgeList<Script::Module::ModuleExport> list;

            Script::Module::ModuleInfo mod{};
            mod.base = va;

            if (!Script::Module::GetExports(&mod, &list))
                return nullptr;

            auto res = gcnew array<Export^>(list.Count());
            for (int i = 0; i < list.Count(); i++)
            {
                const auto& info = list[i];

                auto entry = gcnew Export();
                entry->Rva = System::UIntPtr(static_cast<uintptr_t>(info.rva));
                entry->Va = System::UIntPtr(static_cast<uintptr_t>(info.va));
                entry->DecoratedName = interop::stringFromUTF8(info.name);
                entry->UndecoratedName = interop::stringFromUTF8(info.undecoratedName);
                entry->ForwarderName = interop::stringFromUTF8(info.forwardName);
                entry->Ordinal = (int)info.ordinal;

                res[i] = entry;
            }

            return res;
        }

        static array<Import^>^ GetImports(System::UIntPtr base)
        {
            auto va = static_cast<duint>(base.ToUInt64());

            BridgeList<Script::Module::ModuleImport> list;

            Script::Module::ModuleInfo mod{};
            mod.base = va;

            if (!Script::Module::GetExports(&mod, &list))
                return nullptr;

            auto res = gcnew array<Import^>(list.Count());
            for (int i = 0; i < list.Count(); i++)
            {
                const auto& info = list[i];

                auto entry = gcnew Import();
                entry->Rva = System::UIntPtr(static_cast<uintptr_t>(info.iatRva));
                entry->Va = System::UIntPtr(static_cast<uintptr_t>(info.iatVa));
                entry->DecoratedName = interop::stringFromUTF8(info.name);
                entry->UndecoratedName = interop::stringFromUTF8(info.undecoratedName);
                entry->Ordinal = (int)info.ordinal;

                res[i] = entry;
            }

            return res;
        }
    };
}

```

`src/Bindings/Platform.cpp`:

```cpp
#include <cstdint>
#include <Shlobj.h>

#include "pluginsdk/bridgemain.h"
#include "Marshal.hpp"

#pragma comment(lib, "Shell32.lib")

using namespace System;
using namespace System::Runtime::InteropServices;

namespace Dotx64Dbg::Native {

    namespace Detail {

        // Converts the browser filter to the format required by GetOpenFileNameW.
        // Example
        //   Input: ".cs (*.cs)|*.cs|All files (*.*)|*.*"
        //   Output: "*.cs (*.cs)\0*.cs\0All files (*.*)\0*.*\0\0"
        static std::wstring getBrowseFilter(const std::wstring& filter)
        {
            // Replace | with \0
            std::wstring result = filter;
            for (size_t i = 0; i < result.size(); i++)
            {
                if (result[i] == L'|')
                    result[i] = L'\0';
            }
            // Append terminator
            result.push_back(L'\0');
            return result;
        }
    }

    public ref class Platform
    {
    public:

        static System::String^ BrowseForFolder(System::String^ title)
        {
            const auto titleStr = interop::toUTF16(title);

            BROWSEINFOW bi{};
            bi.hwndOwner = GuiGetWindowHandle();
            bi.lpszTitle = titleStr.c_str();
            bi.lpfn = nullptr;
            bi.lParam = 0;
            bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_USENEWUI;

            auto pidl = SHBrowseForFolderW(&bi);
            if (!pidl)
                return nullptr;

            wchar_t path[MAX_PATH]{};
            if (!SHGetPathFromIDListW(pidl, path))
                return nullptr;

            return gcnew System::String(path);
        }

        static System::String^ OpenFileBrowse(System::String^ title, System::String^ filter)
        {
            const auto titleStr = interop::toUTF16(title);
            const auto filterStr = Detail::getBrowseFilter(interop::toUTF16(filter));
            wchar_t path[1024]{};

            OPENFILENAMEW ofn{};
            ofn.lStructSize = sizeof(ofn);
            ofn.hInstance = GetModuleHandle(nullptr);
            ofn.hwndOwner = GuiGetWindowHandle();
            ofn.lpstrTitle = titleStr.c_str();
            ofn.lpstrFilter = filterStr.c_str();
            ofn.nFilterIndex = 1;
            ofn.lpstrFile = path;
            ofn.nMaxFile = sizeof(path) / sizeof(wchar_t);
            ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

            if (!GetOpenFileNameW(&ofn))
                return nullptr;

            return gcnew System::String(path);
        }

        static System::String^ SaveFileBrowse(System::String^ title, System::String^ filter)
        {
            const auto titleStr = interop::toUTF16(title);
            const auto filterStr = Detail::getBrowseFilter(interop::toUTF16(filter));
            wchar_t path[1024]{};

            OPENFILENAMEW ofn{};
            ofn.lStructSize = sizeof(ofn);
            ofn.hInstance = GetModuleHandle(nullptr);
            ofn.hwndOwner = GuiGetWindowHandle();
            ofn.lpstrTitle = titleStr.c_str();
            ofn.lpstrFilter = filterStr.c_str();
            ofn.nFilterIndex = 1;
            ofn.lpstrFile = path;
            ofn.nMaxFile = sizeof(path) / sizeof(wchar_t);
            ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR;

            if (!GetSaveFileNameW(&ofn))
                return nullptr;

            return gcnew System::String(path);
        }

        static void SetClipboardText(System::String^ text)
        {
            const auto textStr = interop::toUTF16(text);

            const auto size = (textStr.size() + 1) * sizeof(wchar_t);
            auto hMem = GlobalAlloc(GMEM_MOVEABLE, size);
            if (!hMem)
                return;

            auto pMem = GlobalLock(hMem);
            if (!pMem)
            {
                GlobalFree(hMem);
                return;
            }
            memcpy(pMem, textStr.data(), size);
            GlobalUnlock(hMem);

            if (!OpenClipboard(GuiGetWindowHandle()))
            {
                GlobalFree(hMem);
                return;
            }

            EmptyClipboard();
            SetClipboardData(CF_UNICODETEXT, hMem);
            CloseClipboard();
        }

        static void MessageBoxInfo(System::String^ text, System::String^ title)
        {
            const auto textStr = interop::toUTF16(text);
            const auto titleStr = title ? interop::toUTF16(title) : L"Information";
            MessageBoxW(GuiGetWindowHandle(), textStr.c_str(), titleStr.c_str(), MB_ICONINFORMATION);
        }

        static void MessageBoxError(System::String^ text, System::String^ title)
        {
            const auto textStr = interop::toUTF16(text);
            const auto titleStr = title ? interop::toUTF16(title) : L"Error";
            MessageBoxW(GuiGetWindowHandle(), textStr.c_str(), titleStr.c_str(), MB_ICONERROR);
        }
    };

}

```

`src/Bindings/Process.cpp`:

```cpp
#include <vector>
#include <cstdint>

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "Register.hpp"
#include "pluginsdk/TitanEngine/TitanEngine.h"

#include "Marshal.hpp"

using namespace System;
using namespace System::Runtime::InteropServices;

namespace Dotx64Dbg::Native
{
    public ref class Process
    {
    public:
        static uint32_t GetPID()
        {
            return DbgGetProcessId();
        }

        static System::UIntPtr GetNativeHandle()
        {
            return System::UIntPtr(DbgGetProcessHandle());
        }
    };
}

```

`src/Bindings/Register.hpp`:

```hpp
#pragma once

#include <cstdint>

namespace Dotx64Dbg
{
    public ref class Registers
    {
    public:
        enum class Class
        {
            Invalid,
            /**
            * @brief   8-bit general-purpose registers.
            */
            Gp8,
            /**
            * @brief   16-bit general-purpose registers.
            */
            Gp16,
            /**
            * @brief   32-bit general-purpose registers.
            */
            Gp32,
            /**
            * @brief   64-bit general-purpose registers.
            */
            Gp64,
            /**
            * @brief   Floating point legacy registers.
            */
            X87,
            /**
            * @brief   Floating point multimedia registers.
            */
            Mmx,
            /**
            * @brief   128-bit vector registers.
            */
            Xmm,
            /**
            * @brief   256-bit vector registers.
            */
            Ymm,
            /**
            * @brief   512-bit vector registers.
            */
            Zmm,
            /**
            * @brief   Flags registers.
            */
            Flags,
            /**
            * @brief   Instruction-pointer registers.
            */
            IP,
            /**
            * @brief   Segment registers.
            */
            Segment,
            /**
            * @brief   Test registers.
            */
            Test,
            /**
            * @brief   Control registers.
            */
            Control,
            /**
            * @brief   Debug registers.
            */
            Debug,
            /**
            * @brief   Mask registers.
            */
            Mask,
            /**
            * @brief   Bound registers.
            */
            Bound,
        };

        enum class Category
        {
            Invalid = -1,
            Gp = 0,
            X87,
            Simd,
            Flags,
            Debug,
            Segment,
            Mask,
            Control,
        };

        enum class Id
        {
            None,
            // General purpose registers  8-bit
            Al,
            Cl,
            Dl,
            Bl,
            Ah,
            Ch,
            Dh,
            Bh,
            Spl,
            Bpl,
            Sil,
            Dil,
            R8b,
            R9b,
            R10b,
            R11b,
            R12b,
            R13b,
            R14b,
            R15b,
            // General purpose registers 16-bit
            Ax,
            Cx,
            Dx,
            Bx,
            Sp,
            Bp,
            Si,
            Di,
            R8w,
            R9w,
            R10w,
            R11w,
            R12w,
            R13w,
            R14w,
            R15w,
            // General purpose registers 32-bit
            Eax,
            Ecx,
            Edx,
            Ebx,
            Esp,
            Ebp,
            Esi,
            Edi,
            R8d,
            R9d,
            R10d,
            R11d,
            R12d,
            R13d,
            R14d,
            R15d,
            // General purpose registers 64-bit
            Rax,
            Rcx,
            Rdx,
            Rbx,
            Rsp,
            Rbp,
            Rsi,
            Rdi,
            R8,
            R9,
            R10,
            R11,
            R12,
            R13,
            R14,
            R15,
            // Floating point legacy registers
            St0,
            St1,
            St2,
            St3,
            St4,
            St5,
            St6,
            St7,
            X87Control,
            X87Status,
            X87Tag,
            // Floating point multimedia registers
            Mm0,
            Mm1,
            Mm2,
            Mm3,
            Mm4,
            Mm5,
            Mm6,
            Mm7,
            // Floating point vector registers 128-bit
            Xmm0,
            Xmm1,
            Xmm2,
            Xmm3,
            Xmm4,
            Xmm5,
            Xmm6,
            Xmm7,
            Xmm8,
            Xmm9,
            Xmm10,
            Xmm11,
            Xmm12,
            Xmm13,
            Xmm14,
            Xmm15,
            Xmm16,
            Xmm17,
            Xmm18,
            Xmm19,
            Xmm20,
            Xmm21,
            Xmm22,
            Xmm23,
            Xmm24,
            Xmm25,
            Xmm26,
            Xmm27,
            Xmm28,
            Xmm29,
            Xmm30,
            Xmm31,
            // Floating point vector registers 256-bit
            Ymm0,
            Ymm1,
            Ymm2,
            Ymm3,
            Ymm4,
            Ymm5,
            Ymm6,
            Ymm7,
            Ymm8,
            Ymm9,
            Ymm10,
            Ymm11,
            Ymm12,
            Ymm13,
            Ymm14,
            Ymm15,
            Ymm16,
            Ymm17,
            Ymm18,
            Ymm19,
            Ymm20,
            Ymm21,
            Ymm22,
            Ymm23,
            Ymm24,
            Ymm25,
            Ymm26,
            Ymm27,
            Ymm28,
            Ymm29,
            Ymm30,
            Ymm31,
            // Floating point vector registers 512-bit
            Zmm0,
            Zmm1,
            Zmm2,
            Zmm3,
            Zmm4,
            Zmm5,
            Zmm6,
            Zmm7,
            Zmm8,
            Zmm9,
            Zmm10,
            Zmm11,
            Zmm12,
            Zmm13,
            Zmm14,
            Zmm15,
            Zmm16,
            Zmm17,
            Zmm18,
            Zmm19,
            Zmm20,
            Zmm21,
            Zmm22,
            Zmm23,
            Zmm24,
            Zmm25,
            Zmm26,
            Zmm27,
            Zmm28,
            Zmm29,
            Zmm30,
            Zmm31,
            // Matrix registers
            Tmm0,
            Tmm1,
            Tmm2,
            Tmm3,
            Tmm4,
            Tmm5,
            Tmm6,
            Tmm7,
            // Flags registers
            Flags,
            EFlags,
            RFlags,
            // Instruction-pointer registers
            Ip,
            Eip,
            Rip,
            // Segment registers
            Es,
            Cs,
            Ss,
            Ds,
            Fs,
            Gs,
            // Table registers
            Gdtr,
            Ldtr,
            Idtr,
            Tr,
            // Test registers
            Tr0,
            Tr1,
            Tr2,
            Tr3,
            Tr4,
            Tr5,
            Tr6,
            Tr7,
            // Control registers
            Cr0,
            Cr1,
            Cr2,
            Cr3,
            Cr4,
            Cr5,
            Cr6,
            Cr7,
            Cr8,
            Cr9,
            Cr10,
            Cr11,
            Cr12,
            Cr13,
            Cr14,
            Cr15,
            // Debug registers
            Dr0,
            Dr1,
            Dr2,
            Dr3,
            Dr4,
            Dr5,
            Dr6,
            Dr7,
            Dr8,
            Dr9,
            Dr10,
            Dr11,
            Dr12,
            Dr13,
            Dr14,
            Dr15,
            // Mask registers
            K0,
            K1,
            K2,
            K3,
            K4,
            K5,
            K6,
            K7,
            // Bound registers
            Bnd0,
            Bnd1,
            Bnd2,
            Bnd3,
            BndCfg,
            BndStatus,
            // Uncategorized
            Mxcsr,
            Pkru,
            Xcr0,

            // Host Aliases
#ifdef _M_AMD64
            Nax = Rax,
            Ncx = Rcx,
            Ndx = Rdx,
            Nbx = Rbx,
            Nsp = Rsp,
            Nbp = Rbp,
            Nsi = Rsi,
            Ndi = Rdi,
            N8 = R8,
            N9 = R9,
            N10 = R10,
            N11 = R11,
            N12 = R12,
            N13 = R13,
            N14 = R14,
            N15 = R15,
            Nip = Rip,
            NFlags = RFlags,
#else
            Nax = Eax,
            Ncx = Ecx,
            Ndx = Edx,
            Nbx = Ebx,
            Nsp = Esp,
            Nbp = Ebp,
            Nsi = Esi,
            Ndi = Edi,
            N8 = R8d,
            N9 = R9d,
            N10 = R10d,
            N11 = R11d,
            N12 = R12d,
            N13 = R13d,
            N14 = R14d,
            N15 = R15d,
            Nip = Eip,
            NFlags = EFlags,
#endif
            Invalid = 0xFFFF,
        };

        static const char* GetName(Id id)
        {
            switch (id)
            {
            case Id::None:
                return "none";
            case Id::Al:
                return "al";
            case Id::Cl:
                return "cl";
            case Id::Dl:
                return "dl";
            case Id::Bl:
                return "bl";
            case Id::Ah:
                return "ah";
            case Id::Ch:
                return "ch";
            case Id::Dh:
                return "dh";
            case Id::Bh:
                return "bh";
            case Id::Spl:
                return "spl";
            case Id::Bpl:
                return "bpl";
            case Id::Sil:
                return "sil";
            case Id::Dil:
                return "dil";
            case Id::R8b:
                return "r8b";
            case Id::R9b:
                return "r9b";
            case Id::R10b:
                return "r10b";
            case Id::R11b:
                return "r11b";
            case Id::R12b:
                return "r12b";
            case Id::R13b:
                return "r13b";
            case Id::R14b:
                return "r14b";
            case Id::R15b:
                return "r15b";
            case Id::Ax:
                return "ax";
            case Id::Cx:
                return "cx";
            case Id::Dx:
                return "dx";
            case Id::Bx:
                return "bx";
            case Id::Sp:
                return "sp";
            case Id::Bp:
                return "bp";
            case Id::Si:
                return "si";
            case Id::Di:
                return "di";
            case Id::R8w:
                return "r8w";
            case Id::R9w:
                return "r9w";
            case Id::R10w:
                return "r10w";
            case Id::R11w:
                return "r11w";
            case Id::R12w:
                return "r12w";
            case Id::R13w:
                return "r13w";
            case Id::R14w:
                return "r14w";
            case Id::R15w:
                return "r15w";
            case Id::Eax:
                return "eax";
            case Id::Ecx:
                return "ecx";
            case Id::Edx:
                return "edx";
            case Id::Ebx:
                return "ebx";
            case Id::Esp:
                return "esp";
            case Id::Ebp:
                return "ebp";
            case Id::Esi:
                return "esi";
            case Id::Edi:
                return "edi";
            case Id::R8d:
                return "r8d";
            case Id::R9d:
                return "r9d";
            case Id::R10d:
                return "r10d";
            case Id::R11d:
                return "r11d";
            case Id::R12d:
                return "r12d";
            case Id::R13d:
                return "r13d";
            case Id::R14d:
                return "r14d";
            case Id::R15d:
                return "r15d";
            case Id::Rax:
                return "rax";
            case Id::Rcx:
                return "rcx";
            case Id::Rdx:
                return "rdx";
            case Id::Rbx:
                return "rbx";
            case Id::Rsp:
                return "rsp";
            case Id::Rbp:
                return "rbp";
            case Id::Rsi:
                return "rsi";
            case Id::Rdi:
                return "rdi";
            case Id::R8:
                return "r8";
            case Id::R9:
                return "r9";
            case Id::R10:
                return "r10";
            case Id::R11:
                return "r11";
            case Id::R12:
                return "r12";
            case Id::R13:
                return "r13";
            case Id::R14:
                return "r14";
            case Id::R15:
                return "r15";
            case Id::St0:
                return "st0";
            case Id::St1:
                return "st1";
            case Id::St2:
                return "st2";
            case Id::St3:
                return "st3";
            case Id::St4:
                return "st4";
            case Id::St5:
                return "st5";
            case Id::St6:
                return "st6";
            case Id::St7:
                return "st7";
            case Id::X87Control:
                return "x87control";
            case Id::X87Status:
                return "x87status";
            case Id::X87Tag:
                return "x87tag";
            case Id::Mm0:
                return "mm0";
            case Id::Mm1:
                return "mm1";
            case Id::Mm2:
                return "mm2";
            case Id::Mm3:
                return "mm3";
            case Id::Mm4:
                return "mm4";
            case Id::Mm5:
                return "mm5";
            case Id::Mm6:
                return "mm6";
            case Id::Mm7:
                return "mm7";
                // Floating point vector registers 128-bit
            case Id::Xmm0:
                return "xmm0";
            case Id::Xmm1:
                return "xmm1";
            case Id::Xmm2:
                return "xmm2";
            case Id::Xmm3:
                return "xmm3";
            case Id::Xmm4:
                return "xmm4";
            case Id::Xmm5:
                return "xmm5";
            case Id::Xmm6:
                return "xmm6";
            case Id::Xmm7:
                return "xmm7";
            case Id::Xmm8:
                return "xmm8";
            case Id::Xmm9:
                return "xmm9";
            case Id::Xmm10:
                return "xmm10";
            case Id::Xmm11:
                return "xmm11";
            case Id::Xmm12:
                return "xmm12";
            case Id::Xmm13:
                return "xmm13";
            case Id::Xmm14:
                return "xmm14";
            case Id::Xmm15:
                return "xmm15";
            case Id::Xmm16:
                return "xmm16";
            case Id::Xmm17:
                return "xmm17";
            case Id::Xmm18:
                return "xmm18";
            case Id::Xmm19:
                return "xmm19";
            case Id::Xmm20:
                return "xmm20";
            case Id::Xmm21:
                return "xmm21";
            case Id::Xmm22:
                return "xmm22";
            case Id::Xmm23:
                return "xmm23";
            case Id::Xmm24:
                return "xmm24";
            case Id::Xmm25:
                return "xmm25";
            case Id::Xmm26:
                return "xmm26";
            case Id::Xmm27:
                return "xmm27";
            case Id::Xmm28:
                return "xmm28";
            case Id::Xmm29:
                return "xmm29";
            case Id::Xmm30:
                return "xmm30";
            case Id::Xmm31:
                return "xmm31";
                // Floating point vector registers 256-bit
            case Id::Ymm0:
                return "ymm0";
            case Id::Ymm1:
                return "ymm1";
            case Id::Ymm2:
                return "ymm2";
            case Id::Ymm3:
                return "ymm3";
            case Id::Ymm4:
                return "ymm4";
            case Id::Ymm5:
                return "ymm5";
            case Id::Ymm6:
                return "ymm6";
            case Id::Ymm7:
                return "ymm7";
            case Id::Ymm8:
                return "ymm8";
            case Id::Ymm9:
                return "ymm9";
            case Id::Ymm10:
                return "ymm10";
            case Id::Ymm11:
                return "ymm11";
            case Id::Ymm12:
                return "ymm12";
            case Id::Ymm13:
                return "ymm13";
            case Id::Ymm14:
                return "ymm14";
            case Id::Ymm15:
                return "ymm15";
            case Id::Ymm16:
                return "ymm16";
            case Id::Ymm17:
                return "ymm17";
            case Id::Ymm18:
                return "ymm18";
            case Id::Ymm19:
                return "ymm19";
            case Id::Ymm20:
                return "ymm20";
            case Id::Ymm21:
                return "ymm21";
            case Id::Ymm22:
                return "ymm22";
            case Id::Ymm23:
                return "ymm23";
            case Id::Ymm24:
                return "ymm24";
            case Id::Ymm25:
                return "ymm25";
            case Id::Ymm26:
                return "ymm26";
            case Id::Ymm27:
                return "ymm27";
            case Id::Ymm28:
                return "ymm28";
            case Id::Ymm29:
                return "ymm29";
            case Id::Ymm30:
                return "ymm30";
            case Id::Ymm31:
                return "ymm31";
                // Floating point vector registers 512-bit
            case Id::Zmm0:
                return "zmm0";
            case Id::Zmm1:
                return "zmm1";
            case Id::Zmm2:
                return "zmm2";
            case Id::Zmm3:
                return "zmm3";
            case Id::Zmm4:
                return "zmm4";
            case Id::Zmm5:
                return "zmm5";
            case Id::Zmm6:
                return "zmm6";
            case Id::Zmm7:
                return "zmm7";
            case Id::Zmm8:
                return "zmm8";
            case Id::Zmm9:
                return "zmm9";
            case Id::Zmm10:
                return "zmm10";
            case Id::Zmm11:
                return "zmm11";
            case Id::Zmm12:
                return "zmm12";
            case Id::Zmm13:
                return "zmm13";
            case Id::Zmm14:
                return "zmm14";
            case Id::Zmm15:
                return "zmm15";
            case Id::Zmm16:
                return "zmm16";
            case Id::Zmm17:
                return "zmm17";
            case Id::Zmm18:
                return "zmm18";
            case Id::Zmm19:
                return "zmm19";
            case Id::Zmm20:
                return "zmm20";
            case Id::Zmm21:
                return "zmm21";
            case Id::Zmm22:
                return "zmm22";
            case Id::Zmm23:
                return "zmm23";
            case Id::Zmm24:
                return "zmm24";
            case Id::Zmm25:
                return "zmm25";
            case Id::Zmm26:
                return "zmm26";
            case Id::Zmm27:
                return "zmm27";
            case Id::Zmm28:
                return "zmm28";
            case Id::Zmm29:
                return "zmm29";
            case Id::Zmm30:
                return "zmm30";
            case Id::Zmm31:
                return "zmm31";
                // Matrix registers
            case Id::Tmm0:
                return "tmm0";
            case Id::Tmm1:
                return "tmm1";
            case Id::Tmm2:
                return "tmm2";
            case Id::Tmm3:
                return "tmm3";
            case Id::Tmm4:
                return "tmm4";
            case Id::Tmm5:
                return "tmm5";
            case Id::Tmm6:
                return "tmm6";
            case Id::Tmm7:
                return "tmm7";
            case Id::Flags:
                return "flags";
            case Id::EFlags:
                return "eflags";
            case Id::RFlags:
                return "rflags";
            case Id::Ip:
                return "ip";
            case Id::Eip:
                return "eip";
            case Id::Rip:
                return "rip";
            case Id::Es:
                return "es";
            case Id::Cs:
                return "cs";
            case Id::Ss:
                return "ss";
            case Id::Ds:
                return "ds";
            case Id::Fs:
                return "fs";
            case Id::Gs:
                return "gs";
            case Id::Gdtr:
                return "gdtr";
            case Id::Ldtr:
                return "ldtr";
            case Id::Idtr:
                return "idtr";
            case Id::Tr:
                return "tr";
            case Id::Tr0:
                return "tr0";
            case Id::Tr1:
                return "tr1";
            case Id::Tr2:
                return "tr2";
            case Id::Tr3:
                return "tr3";
            case Id::Tr4:
                return "tr4";
            case Id::Tr5:
                return "tr5";
            case Id::Tr6:
                return "tr6";
            case Id::Tr7:
                return "tr7";
                // Control registers
            case Id::Cr0:
                return "cr0";
            case Id::Cr1:
                return "cr1";
            case Id::Cr2:
                return "cr2";
            case Id::Cr3:
                return "cr3";
            case Id::Cr4:
                return "cr4";
            case Id::Cr5:
                return "cr5";
            case Id::Cr6:
                return "cr6";
            case Id::Cr7:
                return "cr7";
            case Id::Cr8:
                return "cr8";
            case Id::Cr9:
                return "cr9";
            case Id::Cr10:
                return "cr10";
            case Id::Cr11:
                return "cr11";
            case Id::Cr12:
                return "cr12";
            case Id::Cr13:
                return "cr13";
            case Id::Cr14:
                return "cr14";
            case Id::Cr15:
                return "cr15";
                // Debug registers
            case Id::Dr0:
                return "dr0";
            case Id::Dr1:
                return "dr1";
            case Id::Dr2:
                return "dr2";
            case Id::Dr3:
                return "dr3";
            case Id::Dr4:
                return "dr4";
            case Id::Dr5:
                return "dr5";
            case Id::Dr6:
                return "dr6";
            case Id::Dr7:
                return "dr7";
            case Id::Dr8:
                return "dr8";
            case Id::Dr9:
                return "dr9";
            case Id::Dr10:
                return "dr10";
            case Id::Dr11:
                return "dr11";
            case Id::Dr12:
                return "dr12";
            case Id::Dr13:
                return "dr13";
            case Id::Dr14:
                return "dr14";
            case Id::Dr15:
                return "dr15";
            case Id::K0:
                return "k0";
            case Id::K1:
                return "k1";
            case Id::K2:
                return "k2";
            case Id::K3:
                return "k3";
            case Id::K4:
                return "k4";
            case Id::K5:
                return "k5";
            case Id::K6:
                return "k6";
            case Id::K7:
                return "k7";
            case Id::Bnd0:
                return "bnd0";
            case Id::Bnd1:
                return "bnd1";
            case Id::Bnd2:
                return "bnd2";
            case Id::Bnd3:
                return "bnd3";
            case Id::BndCfg:
                return "bndcfg";
            case Id::BndStatus:
                return "bndstatus";
            case Id::Mxcsr:
                return "mxcsr";
            case Id::Pkru:
                return "pkru";
            case Id::Xcr0:
                return "xcr0";
            }
            return "invalid";
        }

        static int GetSize(Id id)
        {
            switch (id)
            {
            case Id::None:
                return 0;
            case Id::Al:
            case Id::Cl:
            case Id::Dl:
            case Id::Bl:
            case Id::Ah:
            case Id::Ch:
            case Id::Dh:
            case Id::Bh:
            case Id::Spl:
            case Id::Bpl:
            case Id::Sil:
            case Id::Dil:
            case Id::R8b:
            case Id::R9b:
            case Id::R10b:
            case Id::R11b:
            case Id::R12b:
            case Id::R13b:
            case Id::R14b:
            case Id::R15b:
                return 8;
            case Id::Ax:
            case Id::Cx:
            case Id::Dx:
            case Id::Bx:
            case Id::Sp:
            case Id::Bp:
            case Id::Si:
            case Id::Di:
            case Id::R8w:
            case Id::R9w:
            case Id::R10w:
            case Id::R11w:
            case Id::R12w:
            case Id::R13w:
            case Id::R14w:
            case Id::R15w:
                return 16;
            case Id::Eax:
            case Id::Ecx:
            case Id::Edx:
            case Id::Ebx:
            case Id::Esp:
            case Id::Ebp:
            case Id::Esi:
            case Id::Edi:
            case Id::R8d:
            case Id::R9d:
            case Id::R10d:
            case Id::R11d:
            case Id::R12d:
            case Id::R13d:
            case Id::R14d:
            case Id::R15d:
                return 32;
            case Id::Rax:
            case Id::Rcx:
            case Id::Rdx:
            case Id::Rbx:
            case Id::Rsp:
            case Id::Rbp:
            case Id::Rsi:
            case Id::Rdi:
            case Id::R8:
            case Id::R9:
            case Id::R10:
            case Id::R11:
            case Id::R12:
            case Id::R13:
            case Id::R14:
            case Id::R15:
                return 64;
            case Id::St0:
            case Id::St1:
            case Id::St2:
            case Id::St3:
            case Id::St4:
            case Id::St5:
            case Id::St6:
            case Id::St7:
                return 80;
            case Id::X87Control:
            case Id::X87Status:
            case Id::X87Tag:
                return 16;
            case Id::Mm0:
            case Id::Mm1:
            case Id::Mm2:
            case Id::Mm3:
            case Id::Mm4:
            case Id::Mm5:
            case Id::Mm6:
            case Id::Mm7:
                return 64;
            case Id::Xmm0:
            case Id::Xmm1:
            case Id::Xmm2:
            case Id::Xmm3:
            case Id::Xmm4:
            case Id::Xmm5:
            case Id::Xmm6:
            case Id::Xmm7:
            case Id::Xmm8:
            case Id::Xmm9:
            case Id::Xmm10:
            case Id::Xmm11:
            case Id::Xmm12:
            case Id::Xmm13:
            case Id::Xmm14:
            case Id::Xmm15:
            case Id::Xmm16:
            case Id::Xmm17:
            case Id::Xmm18:
            case Id::Xmm19:
            case Id::Xmm20:
            case Id::Xmm21:
            case Id::Xmm22:
            case Id::Xmm23:
            case Id::Xmm24:
            case Id::Xmm25:
            case Id::Xmm26:
            case Id::Xmm27:
            case Id::Xmm28:
            case Id::Xmm29:
            case Id::Xmm30:
            case Id::Xmm31:
                return 128;
            case Id::Ymm0:
            case Id::Ymm1:
            case Id::Ymm2:
            case Id::Ymm3:
            case Id::Ymm4:
            case Id::Ymm5:
            case Id::Ymm6:
            case Id::Ymm7:
            case Id::Ymm8:
            case Id::Ymm9:
            case Id::Ymm10:
            case Id::Ymm11:
            case Id::Ymm12:
            case Id::Ymm13:
            case Id::Ymm14:
            case Id::Ymm15:
            case Id::Ymm16:
            case Id::Ymm17:
            case Id::Ymm18:
            case Id::Ymm19:
            case Id::Ymm20:
            case Id::Ymm21:
            case Id::Ymm22:
            case Id::Ymm23:
            case Id::Ymm24:
            case Id::Ymm25:
            case Id::Ymm26:
            case Id::Ymm27:
            case Id::Ymm28:
            case Id::Ymm29:
            case Id::Ymm30:
            case Id::Ymm31:
                return 256;
            case Id::Zmm0:
            case Id::Zmm1:
            case Id::Zmm2:
            case Id::Zmm3:
            case Id::Zmm4:
            case Id::Zmm5:
            case Id::Zmm6:
            case Id::Zmm7:
            case Id::Zmm8:
            case Id::Zmm9:
            case Id::Zmm10:
            case Id::Zmm11:
            case Id::Zmm12:
            case Id::Zmm13:
            case Id::Zmm14:
            case Id::Zmm15:
            case Id::Zmm16:
            case Id::Zmm17:
            case Id::Zmm18:
            case Id::Zmm19:
            case Id::Zmm20:
            case Id::Zmm21:
            case Id::Zmm22:
            case Id::Zmm23:
            case Id::Zmm24:
            case Id::Zmm25:
            case Id::Zmm26:
            case Id::Zmm27:
            case Id::Zmm28:
            case Id::Zmm29:
            case Id::Zmm30:
            case Id::Zmm31:
                return 512;
            case Id::Tmm0:
            case Id::Tmm1:
            case Id::Tmm2:
            case Id::Tmm3:
            case Id::Tmm4:
            case Id::Tmm5:
            case Id::Tmm6:
            case Id::Tmm7:
                return 8192;
            case Id::Flags:
                return 16;
            case Id::EFlags:
                return 32;
            case Id::RFlags:
                return 64;
            case Id::Ip:
                return 16;
            case Id::Eip:
                return 32;
            case Id::Rip:
                return 64;
            case Id::Es:
            case Id::Cs:
            case Id::Ss:
            case Id::Ds:
            case Id::Fs:
            case Id::Gs:
                return 16;
            case Id::Gdtr:
            case Id::Ldtr:
            case Id::Idtr:
            case Id::Tr:
                return 16;
            case Id::Tr0:
            case Id::Tr1:
            case Id::Tr2:
            case Id::Tr3:
            case Id::Tr4:
            case Id::Tr5:
            case Id::Tr6:
            case Id::Tr7:
                return 64;
            case Id::Cr0:
            case Id::Cr1:
            case Id::Cr2:
            case Id::Cr3:
            case Id::Cr4:
            case Id::Cr5:
            case Id::Cr6:
            case Id::Cr7:
            case Id::Cr8:
            case Id::Cr9:
            case Id::Cr10:
            case Id::Cr11:
            case Id::Cr12:
            case Id::Cr13:
            case Id::Cr14:
            case Id::Cr15:
                return 64;
            case Id::Dr0:
            case Id::Dr1:
            case Id::Dr2:
            case Id::Dr3:
            case Id::Dr4:
            case Id::Dr5:
            case Id::Dr6:
            case Id::Dr7:
            case Id::Dr8:
            case Id::Dr9:
            case Id::Dr10:
            case Id::Dr11:
            case Id::Dr12:
            case Id::Dr13:
            case Id::Dr14:
            case Id::Dr15:
#ifdef _M_AMD64
                return 64;
#else
                return 32;
#endif
            case Id::K0:
            case Id::K1:
            case Id::K2:
            case Id::K3:
            case Id::K4:
            case Id::K5:
            case Id::K6:
            case Id::K7:
                return 64;
            case Id::Bnd0:
            case Id::Bnd1:
            case Id::Bnd2:
            case Id::Bnd3:
                return 128;
            case Id::BndCfg:
            case Id::BndStatus:
                return 16;
            case Id::Mxcsr:
                return 32;
            case Id::Pkru:
            case Id::Xcr0:
                return 0;
            }
            return 0;
        }

        static Id GetRoot(Id id)
        {
            switch (id)
            {
            case Id::Al:
            case Id::Ax:
            case Id::Ah:
#ifdef _M_AMD64
                return Id::Rax;
#else
                return Id::Eax;
#endif
            case Id::Cl:
            case Id::Cx:
            case Id::Ch:
#ifdef _M_AMD64
                return Id::Rcx;
#else
                return Id::Ecx;
#endif
            case Id::Dl:
            case Id::Dx:
            case Id::Dh:
#ifdef _M_AMD64
                return Id::Rdx;
#else
                return Id::Edx;
#endif
            case Id::Bl:
            case Id::Bx:
            case Id::Bh:
#ifdef _M_AMD64
                return Id::Rbx;
#else
                return Id::Ebx;
#endif
            case Id::Sp:
            case Id::Spl:
#ifdef _M_AMD64
                return Id::Rsp;
#else
                return Id::Esp;
#endif
            case Id::Bpl:
            case Id::Bp:
#ifdef _M_AMD64
                return Id::Rbp;
#else
                return Id::Ebp;
#endif
            case Id::Si:
            case Id::Sil:
#ifdef _M_AMD64
                return Id::Rsi;
#else
                return Id::Esi;
#endif
            case Id::Di:
            case Id::Dil:
#ifdef _M_AMD64
                return Id::Rdi;
#else
                return Id::Edi;
#endif
#ifdef _M_AMD64
            case Id::R8b:
            case Id::R8w:
                return Id::R8;
            case Id::R9b:
            case Id::R9w:
                return Id::R9;
            case Id::R10b:
            case Id::R10w:
                return Id::R10;
            case Id::R11b:
            case Id::R11w:
                return Id::R11;
            case Id::R12b:
            case Id::R12w:
                return Id::R12;
            case Id::R13b:
            case Id::R13w:
                return Id::R13;
            case Id::R14b:
            case Id::R14w:
                return Id::R14;
            case Id::R15b:
            case Id::R15w:
                return Id::R15;
#endif
            case Id::Eax:
#ifdef _M_AMD64
                return Id::Rax;
#endif
            case Id::Ecx:
#ifdef _M_AMD64
                return Id::Rcx;
#endif
            case Id::Edx:
#ifdef _M_AMD64
                return Id::Rdx;
#endif
            case Id::Ebx:
#ifdef _M_AMD64
                return Id::Rbx;
#endif
            case Id::Esp:
#ifdef _M_AMD64
                return Id::Rsp;
#endif
            case Id::Ebp:
#ifdef _M_AMD64
                return Id::Rbp;
#endif
            case Id::Esi:
#ifdef _M_AMD64
                return Id::Rsi;
#endif
            case Id::Edi:
#ifdef _M_AMD64
                return Id::Rdi;
#endif
                break;
#ifdef _M_AMD64
            case Id::R8d:
#    ifdef _M_AMD64
                return Id::R8;
#    endif
            case Id::R9d:
#    ifdef _M_AMD64
                return Id::R9;
#    endif
            case Id::R10d:
#    ifdef _M_AMD64
                return Id::R10;
#    endif
            case Id::R11d:
#    ifdef _M_AMD64
                return Id::R11;
#    endif
            case Id::R12d:
#    ifdef _M_AMD64
                return Id::R12;
#    endif
            case Id::R13d:
#    ifdef _M_AMD64
                return Id::R13;
#    endif
            case Id::R14d:
#    ifdef _M_AMD64
                return Id::R14;
#    endif
            case Id::R15d:
#    ifdef _M_AMD64
                return Id::R15;
#    endif
                break;
#endif
            case Id::Flags:
#ifdef _M_AMD64
                return Id::RFlags;
#else
                return Id::EFlags;
#endif
            case Id::EFlags:
#ifdef _M_AMD64
                return Id::RFlags;
#endif
            case Id::RFlags:
            case Id::Ip:
#ifdef _M_AMD64
                return Id::Rip;
#else
                return Id::Eip;
#endif
            case Id::Eip:
#ifdef _M_AMD64
                return Id::Rip;
#endif
            case Id::Rip:
                break;
            }
            return Id::None;
        }

        static Id GetParent(Id id)
        {
            switch (id)
            {
            case Id::Al:
                return Id::Ax;
            case Id::Ax:
                return Id::Eax;
            case Id::Ah:
                return Id::Ax;
            case Id::Cl:
                return Id::Cx;
            case Id::Cx:
                return Id::Ecx;
            case Id::Ch:
                return Id::Cx;
            case Id::Dl:
                return Id::Dx;
            case Id::Dx:
                return Id::Edx;
            case Id::Dh:
                return Id::Dx;
            case Id::Bl:
                return Id::Bx;
            case Id::Bx:
                return Id::Ebx;
            case Id::Bh:
                return Id::Bx;
            case Id::Sp:
                return Id::Esp;
            case Id::Spl:
                return Id::Sp;
            case Id::Bpl:
                return Id::Bp;
            case Id::Bp:
                return Id::Ebp;
            case Id::Si:
                return Id::Esi;
            case Id::Sil:
                return Id::Si;
            case Id::Di:
                return Id::Edi;
            case Id::Dil:
                return Id::Di;
#ifdef _M_AMD64
            case Id::R8b:
                return Id::R8w;
            case Id::R8w:
                return Id::R8d;
            case Id::R9b:
                return Id::R9w;
            case Id::R9w:
                return Id::R9d;
            case Id::R10b:
                return Id::R10w;
            case Id::R10w:
                return Id::R10d;
            case Id::R11b:
                return Id::R11w;
            case Id::R11w:
                return Id::R11d;
            case Id::R12b:
                return Id::R12w;
            case Id::R12w:
                return Id::R12d;
            case Id::R13b:
                return Id::R13w;
            case Id::R13w:
                return Id::R13d;
            case Id::R14b:
                return Id::R14w;
            case Id::R14w:
                return Id::R14d;
            case Id::R15b:
                return Id::R15w;
            case Id::R15w:
                return Id::R15d;
#endif
            case Id::Eax:
#ifdef _M_AMD64
                return Id::Rax;
#else
                return Id::None;
#endif
            case Id::Ecx:
#ifdef _M_AMD64
                return Id::Rcx;
#else
                return Id::None;
#endif
            case Id::Edx:
#ifdef _M_AMD64
                return Id::Rdx;
#else
                return Id::None;
#endif
            case Id::Ebx:
#ifdef _M_AMD64
                return Id::Rbx;
#endif
            case Id::Esp:
#ifdef _M_AMD64
                return Id::Rsp;
#else
                return Id::None;
#endif
            case Id::Ebp:
#ifdef _M_AMD64
                return Id::Rbp;
#else
                return Id::None;
#endif
            case Id::Esi:
#ifdef _M_AMD64
                return Id::Rsi;
#else
                return Id::None;
#endif
            case Id::Edi:
#ifdef _M_AMD64
                return Id::Rdi;
#else
                return Id::None;
#endif

#ifdef _M_AMD64
            case Id::R8d:
#    ifdef _M_AMD64
                return Id::R8;
#    else
                return Id::None;
#    endif
            case Id::R9d:
#    ifdef _M_AMD64
                return Id::R9;
#    else
                return Id::None;
#    endif
            case Id::R10d:
#    ifdef _M_AMD64
                return Id::R10;
#    else
                return Id::None;
#    endif
            case Id::R11d:
#    ifdef _M_AMD64
                return Id::R11;
#    else
                return Id::None;
#    endif
            case Id::R12d:
#    ifdef _M_AMD64
                return Id::R12;
#    else
                return Id::None;
#    endif
            case Id::R13d:
#    ifdef _M_AMD64
                return Id::R13;
#    else
                return Id::None;
#    endif
            case Id::R14d:
#    ifdef _M_AMD64
                return Id::R14;
#    else
                return Id::None;
#    endif
            case Id::R15d:
#    ifdef _M_AMD64
                return Id::R15;
#    else
                return Id::None;
#    endif

#endif
            case Id::Flags:
#ifdef _M_AMD64
                return Id::RFlags;
#else
                return Id::EFlags;
#endif
            case Id::EFlags:
#ifdef _M_AMD64
                return Id::RFlags;
#endif
            case Id::RFlags:
            case Id::Ip:
#ifdef _M_AMD64
                return Id::Rip;
#else
                return Id::Eip;
#endif
            case Id::Eip:
#ifdef _M_AMD64
                return Id::Rip;
#else
                return Id::None;
#endif
            case Id::Rip:
                break;
            }

            return Id::None;
        }

        static int32_t GetOffsetForRoot(Id id)
        {
            switch (id)
            {
            case Id::Ah:
            case Id::Bh:
            case Id::Ch:
            case Id::Dh:
                return 8;
            }
            return 0;
        }

        static Class GetClass(Id id)
        {
            switch (id)
            {
            case Id::None:
                return Class::Invalid;
            case Id::Al:
            case Id::Cl:
            case Id::Dl:
            case Id::Bl:
            case Id::Ah:
            case Id::Ch:
            case Id::Dh:
            case Id::Bh:
            case Id::Spl:
            case Id::Bpl:
            case Id::Sil:
            case Id::Dil:
            case Id::R8b:
            case Id::R9b:
            case Id::R10b:
            case Id::R11b:
            case Id::R12b:
            case Id::R13b:
            case Id::R14b:
            case Id::R15b:
                return Class::Gp8;
            case Id::Ax:
            case Id::Cx:
            case Id::Dx:
            case Id::Bx:
            case Id::Sp:
            case Id::Bp:
            case Id::Si:
            case Id::Di:
            case Id::R8w:
            case Id::R9w:
            case Id::R10w:
            case Id::R11w:
            case Id::R12w:
            case Id::R13w:
            case Id::R14w:
            case Id::R15w:
                return Class::Gp16;
            case Id::Eax:
            case Id::Ecx:
            case Id::Edx:
            case Id::Ebx:
            case Id::Esp:
            case Id::Ebp:
            case Id::Esi:
            case Id::Edi:
            case Id::R8d:
            case Id::R9d:
            case Id::R10d:
            case Id::R11d:
            case Id::R12d:
            case Id::R13d:
            case Id::R14d:
            case Id::R15d:
                return Class::Gp32;
            case Id::Rax:
            case Id::Rcx:
            case Id::Rdx:
            case Id::Rbx:
            case Id::Rsp:
            case Id::Rbp:
            case Id::Rsi:
            case Id::Rdi:
            case Id::R8:
            case Id::R9:
            case Id::R10:
            case Id::R11:
            case Id::R12:
            case Id::R13:
            case Id::R14:
            case Id::R15:
                return Class::Gp64;
            case Id::St0:
            case Id::St1:
            case Id::St2:
            case Id::St3:
            case Id::St4:
            case Id::St5:
            case Id::St6:
            case Id::St7:
                return Class::X87;
            case Id::X87Control:
            case Id::X87Status:
            case Id::X87Tag:
                return Class::Control;
            case Id::Mm0:
            case Id::Mm1:
            case Id::Mm2:
            case Id::Mm3:
            case Id::Mm4:
            case Id::Mm5:
            case Id::Mm6:
            case Id::Mm7:
                return Class::Mmx;
            case Id::Xmm0:
            case Id::Xmm1:
            case Id::Xmm2:
            case Id::Xmm3:
            case Id::Xmm4:
            case Id::Xmm5:
            case Id::Xmm6:
            case Id::Xmm7:
            case Id::Xmm8:
            case Id::Xmm9:
            case Id::Xmm10:
            case Id::Xmm11:
            case Id::Xmm12:
            case Id::Xmm13:
            case Id::Xmm14:
            case Id::Xmm15:
            case Id::Xmm16:
            case Id::Xmm17:
            case Id::Xmm18:
            case Id::Xmm19:
            case Id::Xmm20:
            case Id::Xmm21:
            case Id::Xmm22:
            case Id::Xmm23:
            case Id::Xmm24:
            case Id::Xmm25:
            case Id::Xmm26:
            case Id::Xmm27:
            case Id::Xmm28:
            case Id::Xmm29:
            case Id::Xmm30:
            case Id::Xmm31:
                return Class::Xmm;
            case Id::Ymm0:
            case Id::Ymm1:
            case Id::Ymm2:
            case Id::Ymm3:
            case Id::Ymm4:
            case Id::Ymm5:
            case Id::Ymm6:
            case Id::Ymm7:
            case Id::Ymm8:
            case Id::Ymm9:
            case Id::Ymm10:
            case Id::Ymm11:
            case Id::Ymm12:
            case Id::Ymm13:
            case Id::Ymm14:
            case Id::Ymm15:
            case Id::Ymm16:
            case Id::Ymm17:
            case Id::Ymm18:
            case Id::Ymm19:
            case Id::Ymm20:
            case Id::Ymm21:
            case Id::Ymm22:
            case Id::Ymm23:
            case Id::Ymm24:
            case Id::Ymm25:
            case Id::Ymm26:
            case Id::Ymm27:
            case Id::Ymm28:
            case Id::Ymm29:
            case Id::Ymm30:
            case Id::Ymm31:
                return Class::Ymm;
            case Id::Zmm0:
            case Id::Zmm1:
            case Id::Zmm2:
            case Id::Zmm3:
            case Id::Zmm4:
            case Id::Zmm5:
            case Id::Zmm6:
            case Id::Zmm7:
            case Id::Zmm8:
            case Id::Zmm9:
            case Id::Zmm10:
            case Id::Zmm11:
            case Id::Zmm12:
            case Id::Zmm13:
            case Id::Zmm14:
            case Id::Zmm15:
            case Id::Zmm16:
            case Id::Zmm17:
            case Id::Zmm18:
            case Id::Zmm19:
            case Id::Zmm20:
            case Id::Zmm21:
            case Id::Zmm22:
            case Id::Zmm23:
            case Id::Zmm24:
            case Id::Zmm25:
            case Id::Zmm26:
            case Id::Zmm27:
            case Id::Zmm28:
            case Id::Zmm29:
            case Id::Zmm30:
            case Id::Zmm31:
                return Class::Zmm;
            case Id::Flags:
            case Id::EFlags:
            case Id::RFlags:
                return Class::Flags;
            case Id::Ip:
            case Id::Eip:
            case Id::Rip:
                return Class::IP;
            case Id::Es:
            case Id::Cs:
            case Id::Ss:
            case Id::Ds:
            case Id::Fs:
            case Id::Gs:
            case Id::Gdtr:
            case Id::Ldtr:
            case Id::Idtr:
                return Class::Segment;
            case Id::Tr:
            case Id::Tr0:
            case Id::Tr1:
            case Id::Tr2:
            case Id::Tr3:
            case Id::Tr4:
            case Id::Tr5:
            case Id::Tr6:
            case Id::Tr7:
                return Class::Test;
            case Id::Cr0:
            case Id::Cr1:
            case Id::Cr2:
            case Id::Cr3:
            case Id::Cr4:
            case Id::Cr5:
            case Id::Cr6:
            case Id::Cr7:
            case Id::Cr8:
            case Id::Cr9:
            case Id::Cr10:
            case Id::Cr11:
            case Id::Cr12:
            case Id::Cr13:
            case Id::Cr14:
            case Id::Cr15:
                return Class::Control;
            case Id::Dr0:
            case Id::Dr1:
            case Id::Dr2:
            case Id::Dr3:
            case Id::Dr4:
            case Id::Dr5:
            case Id::Dr6:
            case Id::Dr7:
            case Id::Dr8:
            case Id::Dr9:
            case Id::Dr10:
            case Id::Dr11:
            case Id::Dr12:
            case Id::Dr13:
            case Id::Dr14:
            case Id::Dr15:
                return Class::Debug;
            case Id::K0:
            case Id::K1:
            case Id::K2:
            case Id::K3:
            case Id::K4:
            case Id::K5:
            case Id::K6:
            case Id::K7:
                return Class::Mask;
            case Id::Bnd0:
            case Id::Bnd1:
            case Id::Bnd2:
            case Id::Bnd3:
            case Id::BndCfg:
            case Id::BndStatus:
                return Class::Bound;
            }
            return Class::Invalid;
        }

        static Category GetCategory(Id reg)
        {
            switch (GetClass(reg))
            {
            case Class::Gp8:
            case Class::Gp16:
            case Class::Gp32:
            case Class::Gp64:
            case Class::IP:
                return Category::Gp;
            case Class::X87:
                return Category::X87;
            case Class::Mmx:
                break;
            case Class::Xmm:
            case Class::Ymm:
            case Class::Zmm:
                return Category::Simd;
            case Class::Flags:
                return Category::Flags;
            case Class::Segment:
                return Category::Segment;
            case Class::Control:
                return Category::Control;
            case Class::Debug:
                return Category::Debug;
            case Class::Mask:
                return Category::Mask;
            default:
                break;
            }
            return Category::Invalid;
        }

        static int GetIndex(Id reg)
        {
            if (reg == Id::None)
                return -1;

            if (reg >= Id::Al && reg <= Id::R15)
            {
                // Gp.
                if (reg >= Id::Al && reg <= Id::R15b)
                {
                    auto index = (int)reg - (int)Id::Al;
                    if (reg >= Id::Ah && reg <= Id::Bh)
                    {
                        index -= 4;
                    }
                    return index;
                }
                else if (reg >= Id::Ax && reg <= Id::R15w)
                {
                    return  (int)reg - (int)Id::Ax;
                }
                else if (reg >= Id::Eax && reg <= Id::R15d)
                {
                    return (int)reg - (int)Id::Eax;
                }
                else if (reg >= Id::Rax && reg <= Id::R15)
                {
                    return (int)reg - (int)Id::Rax;
                }
            }
            else if (reg >= Id::St0 && reg <= Id::St1)
            {
                return (int)reg - (int)Id::St0;
            }
            else if (reg >= Id::X87Control && reg <= Id::X87Tag)
            {
                return (int)reg - (int)Id::X87Control;
            }
            else if (reg >= Id::Mm0 && reg <= Id::Mm7)
            {
                return (int)reg - (int)Id::Mm0;
            }
            else if (reg >= Id::Xmm0 && reg <= Id::Xmm31)
            {
                return (int)reg - (int)Id::Xmm0;
            }
            else if (reg >= Id::Ymm0 && reg <= Id::Ymm31)
            {
                return (int)reg - (int)Id::Ymm0;
            }
            else if (reg >= Id::Zmm0 && reg <= Id::Zmm31)
            {
                return (int)reg - (int)Id::Zmm0;
            }
            else if (reg >= Id::Flags && reg <= Id::RFlags)
            {
                return (int)reg - (int)Id::Flags;
            }
            else if (reg >= Id::Ip && reg <= Id::Rip)
            {
                return (int)reg - (int)Id::Ip;
            }
            return -1;
        }

    };

} // namespace Dotx64Dbg

```

`src/Bindings/Settings.cpp`:

```cpp
#include <vector>
#include <cstdint>

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_module.h"
#include "Register.hpp"
#include "pluginsdk/TitanEngine/TitanEngine.h"

#include "Marshal.hpp"

namespace Dotx64Dbg {

    public ref class X64DbgSettings
    {
    public:
        static System::String^ Get(System::String^ section, System::String^ key)
        {
            auto sectionStr = interop::toUTF8(section);
            auto keyStr = interop::toUTF8(key);

            char buf[1024]{};
            if (!BridgeSettingGet(sectionStr.c_str(), keyStr.c_str(), buf))
                return nullptr;

            return interop::stringFromUTF8(buf);
        }
    };

}

```

`src/Bindings/Symbols.cpp`:

```cpp
#include <cstdint>
#include <utility>
#include <vector>

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_label.h"
#include "pluginsdk/_scriptapi_function.h"
#include "pluginsdk/_scriptapi_comment.h"

#include "Marshal.hpp"
#include <optional>

namespace Dotx64Dbg {

    namespace Detail
    {
        inline std::optional<Script::Label::LabelInfo> GetLabelInfo(System::UIntPtr addr)
        {
            auto va = reinterpret_cast<duint>(addr.ToPointer());

            Script::Label::LabelInfo info;
            if (Script::Label::GetInfo(va, &info))
            {
                return info;
            }

            return std::nullopt;
        }


        inline bool LabelIsTemporary(System::UIntPtr addr)
        {
            auto va = reinterpret_cast<duint>(addr.ToPointer());
            return Script::Label::IsTemporary(va);
        }

        inline std::optional<Script::Function::FunctionInfo> GetFuncInfo(System::UIntPtr addr)
        {
            auto va = reinterpret_cast<duint>(addr.ToPointer());

            Script::Function::FunctionInfo info;
            if (Script::Function::GetInfo(va, &info))
            {
                return info;
            }

            return std::nullopt;
        }

        inline std::optional<Script::Comment::CommentInfo> GetCommentInfo(System::UIntPtr addr)
        {
            auto va = reinterpret_cast<duint>(addr.ToPointer());

            Script::Comment::CommentInfo info;
            if (Script::Comment::GetInfo(va, &info))
            {
                return info;
            }

            return std::nullopt;
        }
    }

    public interface class Symbol
    {
    public:
        enum class Type
        {
            None = 0,
            Label,
            Function,
            Comment,
        };

        property Type SymbolType
        {
            virtual Type get();
        }

        property System::UIntPtr Address
        {
            virtual System::UIntPtr get();
        }

        property int Size
        {
            virtual int get();
        }

        property System::String^ Text
        {
            virtual System::String^ get();
        }
    };

    public ref class Symbols
    {
    public:
        /// Label
        /////////////////////////////////////////////////////////////////////////////
        ref class Label : public Symbol
        {
            System::UIntPtr _address;
            uint32_t _rva;

        public:
            [System::Flags]
            enum class Attribs
            {
                None = 0,
                Manual = (1 << 0),
                Temporary = (1 << 1),
            };

        internal:
            Label(System::UIntPtr address, uint32_t rva)
            {
                _address = address;
                _rva = rva;
            }

        public:
            property Symbol::Type SymbolType
            {
                virtual Symbol::Type get()
                {
                    return Symbol::Type::Label;
                }
            }

            property System::UIntPtr Address
            {
                virtual System::UIntPtr get()
                {
                    return _address;
                }
            }

            property uint32_t RVA
            {
                virtual uint32_t get()
                {
                    return _rva;
                }
            }

            property int Size
            {
                virtual int get()
                {
                    return 0;
                }
            }

            property System::String^ Text
            {
                virtual System::String^ get()
                {
                    if (auto info = Detail::GetLabelInfo(_address))
                    {
                        return interop::stringFromUTF8(info->text);
                    }
                    return nullptr;
                }
            }

            property System::String^ Module
            {
                virtual System::String^ get()
                {
                    if (auto info = Detail::GetLabelInfo(_address))
                    {
                        return interop::stringFromUTF8(info->mod);
                    }
                    return nullptr;
                }
            }

            property Attribs Attributes
            {
                Attribs get()
                {
                    Attribs res = Attribs::None;

                    if (auto info = Detail::GetLabelInfo(_address))
                    {
                        if (info->manual)
                            res = static_cast<Attribs>(static_cast<uint32_t>(res) | static_cast<uint32_t>(Attribs::Manual));

                        if (Detail::LabelIsTemporary(_address))
                            res = static_cast<Attribs>(static_cast<uint32_t>(res) | static_cast<uint32_t>(Attribs::Temporary));
                    }

                    return res;
                }
            }

            static Symbols::Label^ Get(System::UIntPtr address)
            {
                auto va = reinterpret_cast<duint>(address.ToPointer());

                Script::Label::LabelInfo info;
                if (Script::Label::GetInfo(va, &info))
                {
                    Label^ res = gcnew Label(address, static_cast<uint32_t>(info.rva));
                    return res;
                }

                return nullptr;
            }

            static bool Set(System::UIntPtr address, System::String^ name, Symbols::Label::Attribs attribs)
            {
                auto va = reinterpret_cast<duint>(address.ToPointer());

                auto nameStr = interop::toUTF8(name);
                bool manual = (attribs & Symbols::Label::Attribs::Manual) != Symbols::Label::Attribs::None;

                // NOTE: Temporary is not supported until the https://github.com/x64dbg/x64dbg/pull/2695 is merged.
                bool temporary = (attribs & Label::Attribs::Manual) != Symbols::Label::Attribs::None;

                return Script::Label::Set(va, nameStr.c_str(), manual, temporary);
            }

            static bool Remove(System::UIntPtr address)
            {
                auto va = reinterpret_cast<duint>(address.ToPointer());

                return Script::Label::Delete(va);
            }
        };

    public:
        /// Function
        /////////////////////////////////////////////////////////////////////////////
        ref class Function : public Symbol
        {
            System::UIntPtr _address;
            uint32_t _rva;

        internal:
            Function(System::UIntPtr address, uint32_t rva)
            {
                _address = address;
            }

        public:
            property Symbol::Type SymbolType
            {
                virtual Symbol::Type get()
                {
                    return Symbol::Type::Function;
                }
            }

            property System::UIntPtr Address
            {
                virtual System::UIntPtr get()
                {
                    return _address;
                }
            }

            property uint32_t RVA
            {
                virtual uint32_t get()
                {
                    return _rva;
                }
            }

            property int Size
            {
                virtual int get()
                {
                    if (auto info = Detail::GetFuncInfo(_address))
                    {
                        return static_cast<int>(info->rvaEnd - info->rvaStart);
                    }
                    return 0;
                }
            }

            property System::String^ Text
            {
                virtual System::String^ get()
                {
                    return gcnew System::String("<function>");
                }
            }

            property System::String^ Module
            {
                virtual System::String^ get()
                {
                    if (auto info = Detail::GetFuncInfo(_address))
                    {
                        return interop::stringFromUTF8(info->mod);
                    }
                    return nullptr;
                }
            }

            static Symbols::Function^ Get(System::UIntPtr address)
            {
                if (auto info = Detail::GetFuncInfo(address))
                {
                    Symbols::Function^ res = gcnew Symbols::Function(address, (uint32_t)info->rvaStart);
                    return res;
                }
                return nullptr;
            }

            static bool Set(System::UIntPtr startAddress, System::UIntPtr endAddress, bool manual)
            {
                auto startVA = reinterpret_cast<duint>(startAddress.ToPointer());
                auto endVA = reinterpret_cast<duint>(startAddress.ToPointer());

                return Script::Function::Add(startVA, endVA, manual, 0);
            }

            static bool Remove(System::UIntPtr address)
            {
                auto va = reinterpret_cast<duint>(address.ToPointer());
                return Script::Function::Delete(va);
            }
        };

    public:
        /// Comment
        /////////////////////////////////////////////////////////////////////////////
        ref class Comment : public Symbol
        {
            System::UIntPtr _address;
            uint32_t _rva;

        internal:
            Comment(System::UIntPtr address, uint32_t rva)
            {
                _address = address;
            }

        public:
            property Symbol::Type SymbolType
            {
                virtual Symbol::Type get()
                {
                    return Symbol::Type::Comment;
                }
            }

            property System::UIntPtr Address
            {
                virtual System::UIntPtr get()
                {
                    return _address;
                }
            }

            property uint32_t RVA
            {
                virtual uint32_t get()
                {
                    return _rva;
                }
            }

            property int Size
            {
                virtual int get()
                {
                    return 0;
                }
            }

            property System::String^ Text
            {
                virtual System::String^ get()
                {
                    if (auto cmtInfo = Detail::GetCommentInfo(_address))
                    {
                        return interop::stringFromUTF8(cmtInfo->text);
                    }
                    return nullptr;
                }
            }

            property System::String^ Module
            {
                virtual System::String^ get()
                {
                    if (auto info = Detail::GetCommentInfo(_address))
                    {
                        return interop::stringFromUTF8(info->mod);
                    }
                    return nullptr;
                }
            }

            static Symbols::Comment^ Get(System::UIntPtr address)
            {
                if (auto info = Detail::GetCommentInfo(address))
                {
                    Symbols::Comment^ res = gcnew Symbols::Comment(address, (uint32_t)info->rva);
                    return res;
                }
                return nullptr;
            }

            static bool Set(System::UIntPtr address, System::String^ text, bool manual)
            {
                auto va = reinterpret_cast<duint>(address.ToPointer());

                auto textStr = interop::toUTF8(text);
                return Script::Comment::Set(va, textStr.c_str(), manual);
            }

            static bool Remove(System::UIntPtr address)
            {
                auto va = reinterpret_cast<duint>(address.ToPointer());
                return Script::Comment::Delete(va);
            }
        };
    };

}

```

`src/Bindings/Thread.cpp`:

```cpp
#include <vector>
#include <cstdint>

#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_memory.h"
#include "Register.hpp"
#include "pluginsdk/TitanEngine/TitanEngine.h"

namespace Dotx64Dbg::Native
{
    public ref struct ThreadInfo
    {
        uint32_t Id;
        System::UIntPtr Handle;
        uintptr_t IP;
        uint32_t SuspendCount;
        uint32_t LastError;
        uint64_t UserTime;
        uint64_t KernelTime;
        uint64_t CreationTime;
        uint64_t Cycles;
    };

    public ref class Thread
    {
    public:
        static uint32_t GetActiveThreadId()
        {
            return DbgGetThreadId();
        }

        static bool SetActiveThreadId(uint32_t threadId)
        {
            char cmd[128] = {};
            sprintf_s(cmd, "switchthread %X", (uint32_t)threadId);

            return DbgCmdExecDirect(cmd);
        }

        static uint32_t GetMainThreadId()
        {
            THREADLIST tl{};
            DbgGetThreadList(&tl);

            uint32_t id = 0;
            for (int i = 0; i < tl.count; i++)
            {
                const auto& th = tl.list[i];
                if (th.BasicInfo.ThreadNumber == 0)
                {
                    id = th.BasicInfo.ThreadId;
                    break;
                }
            }

            BridgeFree(tl.list);
            return id;
        }

        static bool IsValid(uint32_t threadId)
        {
            THREADLIST tl{};
            DbgGetThreadList(&tl);

            bool valid = false;
            for (int i = 0; i < tl.count; i++)
            {
                if (threadId == tl.list[i].BasicInfo.ThreadId)
                {
                    valid = true;
                    break;
                }
            }

            BridgeFree(tl.list);

            return valid;
        }

        static array<System::UInt32>^ GetThreads()
        {
            THREADLIST tl{};
            DbgGetThreadList(&tl);

            array<System::UInt32>^ res = gcnew array<System::UInt32>(tl.count);
            for (int i = 0; i < tl.count; i++)
            {
                res[i] = tl.list[i].BasicInfo.ThreadId;
            }

            BridgeFree(tl.list);

            return res;
        }

        static bool Resume(uint64_t hThread)
        {
            return false;
        }

        static bool Pause(uint64_t hThread)
        {
            return false;
        }

        static ThreadInfo^ GetThreadInfo(uint32_t id)
        {
            THREADLIST tl{};
            DbgGetThreadList(&tl);

            ThreadInfo^ res = nullptr;
            for (int i = 0; i < tl.count; i++)
            {
                auto& th = tl.list[i];
                if (th.BasicInfo.ThreadId != id)
                    continue;

                res = gcnew ThreadInfo();
                res->Id = id;
                res->Handle = System::UIntPtr(th.BasicInfo.Handle);
                res->IP = th.ThreadCip;
                res->SuspendCount = th.SuspendCount;
                res->LastError = th.LastError;
                res->UserTime = static_cast<uint64_t>(th.UserTime.dwHighDateTime) << 32 | th.UserTime.dwLowDateTime;
                res->KernelTime = static_cast<uint64_t>(th.KernelTime.dwHighDateTime) << 32 | th.KernelTime.dwLowDateTime;
                res->CreationTime = static_cast<uint64_t>(th.CreationTime.dwHighDateTime) << 32 | th.CreationTime.dwLowDateTime;
                res->Cycles = th.Cycles;

                break;
            }

            BridgeFree(tl.list);

            return res;
        }

        static array<System::Byte>^ ReadRegister(System::UIntPtr hThread, int reg, int size, int offset)
        {
            array<System::Byte>^ res = gcnew array<System::Byte>(size);

            pin_ptr<uint8_t> p = &res[0];
            uint8_t* data = p;

            ULONG_PTR val = GetContextDataEx(hThread.ToPointer(), reg);
            std::memcpy(data, reinterpret_cast<const uint8_t*>(&val) + offset, size);

            return res;
        }

        static array<System::Byte>^ ReadRegister(System::UIntPtr hThread, int reg, int size)
        {
            return ReadRegister(hThread, reg, size, 0);
        }

        static array<System::Byte>^ GetRegisterData(System::UIntPtr hThread, Registers::Id reg)
        {
            switch (reg)
            {
            case Registers::Id::None:
                return gcnew array<System::Byte>(0);
#ifdef _M_X64
            case Registers::Id::Al:
                return ReadRegister(hThread, UE_RAX, 1);
            case Registers::Id::Cl:
                return ReadRegister(hThread, UE_RCX, 1);
            case Registers::Id::Dl:
                return ReadRegister(hThread, UE_RDX, 1);
            case Registers::Id::Bl:
                return ReadRegister(hThread, UE_RBX, 1);
            case Registers::Id::Ah:
                return ReadRegister(hThread, UE_RAX, 1, 1);
            case Registers::Id::Ch:
                return ReadRegister(hThread, UE_RCX, 1, 1);
            case Registers::Id::Dh:
                return ReadRegister(hThread, UE_RDX, 1, 1);
            case Registers::Id::Bh:
                return ReadRegister(hThread, UE_RBX, 1, 1);
            case Registers::Id::Spl:
                return ReadRegister(hThread, UE_RSP, 1);
            case Registers::Id::Bpl:
                return ReadRegister(hThread, UE_RBP, 1);
            case Registers::Id::Sil:
                return ReadRegister(hThread, UE_RSI, 1);
            case Registers::Id::Dil:
                return ReadRegister(hThread, UE_RDI, 1);
            case Registers::Id::R8b:
                return ReadRegister(hThread, UE_R8, 1);
            case Registers::Id::R9b:
                return ReadRegister(hThread, UE_R9, 1);
            case Registers::Id::R10b:
                return ReadRegister(hThread, UE_R10, 1);
            case Registers::Id::R11b:
                return ReadRegister(hThread, UE_R11, 1);
            case Registers::Id::R12b:
                return ReadRegister(hThread, UE_R12, 1);
            case Registers::Id::R13b:
                return ReadRegister(hThread, UE_R13, 1);
            case Registers::Id::R14b:
                return ReadRegister(hThread, UE_R14, 1);
            case Registers::Id::R15b:
                return ReadRegister(hThread, UE_R15, 1);
            case Registers::Id::Ax:
                return ReadRegister(hThread, UE_RAX, 2);
            case Registers::Id::Cx:
                return ReadRegister(hThread, UE_RCX, 2);
            case Registers::Id::Dx:
                return ReadRegister(hThread, UE_RDX, 2);
            case Registers::Id::Bx:
                return ReadRegister(hThread, UE_RBX, 2);
            case Registers::Id::Sp:
                return ReadRegister(hThread, UE_RSP, 2);
            case Registers::Id::Bp:
                return ReadRegister(hThread, UE_RBP, 2);
            case Registers::Id::Si:
                return ReadRegister(hThread, UE_RSI, 2);
            case Registers::Id::Di:
                return ReadRegister(hThread, UE_RDI, 2);
            case Registers::Id::R8w:
                return ReadRegister(hThread, UE_R8, 2);
            case Registers::Id::R9w:
                return ReadRegister(hThread, UE_R9, 2);
            case Registers::Id::R10w:
                return ReadRegister(hThread, UE_R10, 2);
            case Registers::Id::R11w:
                return ReadRegister(hThread, UE_R11, 2);
            case Registers::Id::R12w:
                return ReadRegister(hThread, UE_R12, 2);
            case Registers::Id::R13w:
                return ReadRegister(hThread, UE_R13, 2);
            case Registers::Id::R14w:
                return ReadRegister(hThread, UE_R14, 2);
            case Registers::Id::R15w:
                return ReadRegister(hThread, UE_R15, 2);
            case Registers::Id::Eax:
                return ReadRegister(hThread, UE_RAX, 4);
            case Registers::Id::Ecx:
                return ReadRegister(hThread, UE_RCX, 4);
            case Registers::Id::Edx:
                return ReadRegister(hThread, UE_RDX, 4);
            case Registers::Id::Ebx:
                return ReadRegister(hThread, UE_RBX, 4);
            case Registers::Id::Esp:
                return ReadRegister(hThread, UE_RSP, 4);
            case Registers::Id::Ebp:
                return ReadRegister(hThread, UE_RBP, 4);
            case Registers::Id::Esi:
                return ReadRegister(hThread, UE_RSI, 4);
            case Registers::Id::Edi:
                return ReadRegister(hThread, UE_RDI, 4);
            case Registers::Id::R8d:
                return ReadRegister(hThread, UE_R8, 4);
            case Registers::Id::R9d:
                return ReadRegister(hThread, UE_R9, 4);
            case Registers::Id::R10d:
                return ReadRegister(hThread, UE_R10, 4);
            case Registers::Id::R11d:
                return ReadRegister(hThread, UE_R11, 4);
            case Registers::Id::R12d:
                return ReadRegister(hThread, UE_R12, 4);
            case Registers::Id::R13d:
                return ReadRegister(hThread, UE_R13, 4);
            case Registers::Id::R14d:
                return ReadRegister(hThread, UE_R14, 4);
            case Registers::Id::R15d:
                return ReadRegister(hThread, UE_R15, 4);
            case Registers::Id::Rax:
                return ReadRegister(hThread, UE_RAX, 8);
            case Registers::Id::Rcx:
                return ReadRegister(hThread, UE_RCX, 8);
            case Registers::Id::Rdx:
                return ReadRegister(hThread, UE_RDX, 8);
            case Registers::Id::Rbx:
                return ReadRegister(hThread, UE_RBX, 8);
            case Registers::Id::Rsp:
                return ReadRegister(hThread, UE_RSP, 8);
            case Registers::Id::Rbp:
                return ReadRegister(hThread, UE_RBP, 8);
            case Registers::Id::Rsi:
                return ReadRegister(hThread, UE_RSI, 8);
            case Registers::Id::Rdi:
                return ReadRegister(hThread, UE_RDI, 8);
            case Registers::Id::R8:
                return ReadRegister(hThread, UE_R8, 8);
            case Registers::Id::R9:
                return ReadRegister(hThread, UE_R9, 8);
            case Registers::Id::R10:
                return ReadRegister(hThread, UE_R10, 8);
            case Registers::Id::R11:
                return ReadRegister(hThread, UE_R11, 8);
            case Registers::Id::R12:
                return ReadRegister(hThread, UE_R12, 8);
            case Registers::Id::R13:
                return ReadRegister(hThread, UE_R13, 8);
            case Registers::Id::R14:
                return ReadRegister(hThread, UE_R14, 8);
            case Registers::Id::R15:
                return ReadRegister(hThread, UE_R15, 8);
#else
            case Registers::Id::Al:
                return ReadRegister(hThread, UE_EAX, 1);
            case Registers::Id::Cl:
                return ReadRegister(hThread, UE_ECX, 1);
            case Registers::Id::Dl:
                return ReadRegister(hThread, UE_EDX, 1);
            case Registers::Id::Bl:
                return ReadRegister(hThread, UE_EBX, 1);
            case Registers::Id::Ah:
                return ReadRegister(hThread, UE_EAX, 1, 1);
            case Registers::Id::Ch:
                return ReadRegister(hThread, UE_ECX, 1, 1);
            case Registers::Id::Dh:
                return ReadRegister(hThread, UE_EDX, 1, 1);
            case Registers::Id::Bh:
                return ReadRegister(hThread, UE_EBX, 1, 1);
            case Registers::Id::Spl:
                return ReadRegister(hThread, UE_ESP, 1);
            case Registers::Id::Bpl:
                return ReadRegister(hThread, UE_EBP, 1);
            case Registers::Id::Sil:
                return ReadRegister(hThread, UE_ESI, 1);
            case Registers::Id::Dil:
                return ReadRegister(hThread, UE_EDI, 1);
            case Registers::Id::Ax:
                return ReadRegister(hThread, UE_EAX, 2);
            case Registers::Id::Cx:
                return ReadRegister(hThread, UE_ECX, 2);
            case Registers::Id::Dx:
                return ReadRegister(hThread, UE_EDX, 2);
            case Registers::Id::Bx:
                return ReadRegister(hThread, UE_EBX, 2);
            case Registers::Id::Sp:
                return ReadRegister(hThread, UE_ESP, 2);
            case Registers::Id::Bp:
                return ReadRegister(hThread, UE_EBP, 2);
            case Registers::Id::Si:
                return ReadRegister(hThread, UE_ESI, 2);
            case Registers::Id::Di:
                return ReadRegister(hThread, UE_EDI, 2);
            case Registers::Id::Eax:
                return ReadRegister(hThread, UE_EAX, 4);
            case Registers::Id::Ecx:
                return ReadRegister(hThread, UE_ECX, 4);
            case Registers::Id::Edx:
                return ReadRegister(hThread, UE_EDX, 4);
            case Registers::Id::Ebx:
                return ReadRegister(hThread, UE_EBX, 4);
            case Registers::Id::Esp:
                return ReadRegister(hThread, UE_ESP, 4);
            case Registers::Id::Ebp:
                return ReadRegister(hThread, UE_EBP, 4);
            case Registers::Id::Esi:
                return ReadRegister(hThread, UE_ESI, 4);
            case Registers::Id::Edi:
                return ReadRegister(hThread, UE_EDI, 4);
            case Registers::Id::Rax:
                return ReadRegister(hThread, UE_EAX, 8);
#endif
            case Registers::Id::St0:
                break;
            case Registers::Id::St1:
                break;
            case Registers::Id::St2:
                break;
            case Registers::Id::St3:
                break;
            case Registers::Id::St4:
                break;
            case Registers::Id::St5:
                break;
            case Registers::Id::St6:
                break;
            case Registers::Id::St7:
                break;
            case Registers::Id::X87Control:
                break;
            case Registers::Id::X87Status:
                break;
            case Registers::Id::X87Tag:
                break;
            case Registers::Id::Mm0:
                break;
            case Registers::Id::Mm1:
                break;
            case Registers::Id::Mm2:
                break;
            case Registers::Id::Mm3:
                break;
            case Registers::Id::Mm4:
                break;
            case Registers::Id::Mm5:
                break;
            case Registers::Id::Mm6:
                break;
            case Registers::Id::Mm7:
                break;
            case Registers::Id::Xmm0:
                break;
            case Registers::Id::Xmm1:
                break;
            case Registers::Id::Xmm2:
                break;
            case Registers::Id::Xmm3:
                break;
            case Registers::Id::Xmm4:
                break;
            case Registers::Id::Xmm5:
                break;
            case Registers::Id::Xmm6:
                break;
            case Registers::Id::Xmm7:
                break;
            case Registers::Id::Xmm8:
                break;
            case Registers::Id::Xmm9:
                break;
            case Registers::Id::Xmm10:
                break;
            case Registers::Id::Xmm11:
                break;
            case Registers::Id::Xmm12:
                break;
            case Registers::Id::Xmm13:
                break;
            case Registers::Id::Xmm14:
                break;
            case Registers::Id::Xmm15:
                break;
            case Registers::Id::Xmm16:
                break;
            case Registers::Id::Xmm17:
                break;
            case Registers::Id::Xmm18:
                break;
            case Registers::Id::Xmm19:
                break;
            case Registers::Id::Xmm20:
                break;
            case Registers::Id::Xmm21:
                break;
            case Registers::Id::Xmm22:
                break;
            case Registers::Id::Xmm23:
                break;
            case Registers::Id::Xmm24:
                break;
            case Registers::Id::Xmm25:
                break;
            case Registers::Id::Xmm26:
                break;
            case Registers::Id::Xmm27:
                break;
            case Registers::Id::Xmm28:
                break;
            case Registers::Id::Xmm29:
                break;
            case Registers::Id::Xmm30:
                break;
            case Registers::Id::Xmm31:
                break;
            case Registers::Id::Ymm0:
                break;
            case Registers::Id::Ymm1:
                break;
            case Registers::Id::Ymm2:
                break;
            case Registers::Id::Ymm3:
                break;
            case Registers::Id::Ymm4:
                break;
            case Registers::Id::Ymm5:
                break;
            case Registers::Id::Ymm6:
                break;
            case Registers::Id::Ymm7:
                break;
            case Registers::Id::Ymm8:
                break;
            case Registers::Id::Ymm9:
                break;
            case Registers::Id::Ymm10:
                break;
            case Registers::Id::Ymm11:
                break;
            case Registers::Id::Ymm12:
                break;
            case Registers::Id::Ymm13:
                break;
            case Registers::Id::Ymm14:
                break;
            case Registers::Id::Ymm15:
                break;
            case Registers::Id::Ymm16:
                break;
            case Registers::Id::Ymm17:
                break;
            case Registers::Id::Ymm18:
                break;
            case Registers::Id::Ymm19:
                break;
            case Registers::Id::Ymm20:
                break;
            case Registers::Id::Ymm21:
                break;
            case Registers::Id::Ymm22:
                break;
            case Registers::Id::Ymm23:
                break;
            case Registers::Id::Ymm24:
                break;
            case Registers::Id::Ymm25:
                break;
            case Registers::Id::Ymm26:
                break;
            case Registers::Id::Ymm27:
                break;
            case Registers::Id::Ymm28:
                break;
            case Registers::Id::Ymm29:
                break;
            case Registers::Id::Ymm30:
                break;
            case Registers::Id::Ymm31:
                break;
            case Registers::Id::Zmm0:
                break;
            case Registers::Id::Zmm1:
                break;
            case Registers::Id::Zmm2:
                break;
            case Registers::Id::Zmm3:
                break;
            case Registers::Id::Zmm4:
                break;
            case Registers::Id::Zmm5:
                break;
            case Registers::Id::Zmm6:
                break;
            case Registers::Id::Zmm7:
                break;
            case Registers::Id::Zmm8:
                break;
            case Registers::Id::Zmm9:
                break;
            case Registers::Id::Zmm10:
                break;
            case Registers::Id::Zmm11:
                break;
            case Registers::Id::Zmm12:
                break;
            case Registers::Id::Zmm13:
                break;
            case Registers::Id::Zmm14:
                break;
            case Registers::Id::Zmm15:
                break;
            case Registers::Id::Zmm16:
                break;
            case Registers::Id::Zmm17:
                break;
            case Registers::Id::Zmm18:
                break;
            case Registers::Id::Zmm19:
                break;
            case Registers::Id::Zmm20:
                break;
            case Registers::Id::Zmm21:
                break;
            case Registers::Id::Zmm22:
                break;
            case Registers::Id::Zmm23:
                break;
            case Registers::Id::Zmm24:
                break;
            case Registers::Id::Zmm25:
                break;
            case Registers::Id::Zmm26:
                break;
            case Registers::Id::Zmm27:
                break;
            case Registers::Id::Zmm28:
                break;
            case Registers::Id::Zmm29:
                break;
            case Registers::Id::Zmm30:
                break;
            case Registers::Id::Zmm31:
                break;
#ifdef _M_X64
            case Registers::Id::Flags:
                return ReadRegister(hThread, UE_RFLAGS, 2);
            case Registers::Id::EFlags:
                return ReadRegister(hThread, UE_RFLAGS, 4);
            case Registers::Id::RFlags:
                return ReadRegister(hThread, UE_RFLAGS, 8);
#else
            case Registers::Id::Flags:
                return ReadRegister(hThread, UE_EFLAGS, 2);
            case Registers::Id::EFlags:
                return ReadRegister(hThread, UE_EFLAGS, 4);
#endif

#ifdef _M_X64
            case Registers::Id::Ip:
                return ReadRegister(hThread, UE_RIP, 2);
            case Registers::Id::Eip:
                return ReadRegister(hThread, UE_RIP, 4);
            case Registers::Id::Rip:
                return ReadRegister(hThread, UE_RIP, 8);
#else
            case Registers::Id::Ip:
                return ReadRegister(hThread, UE_EIP, 2);
            case Registers::Id::Eip:
                return ReadRegister(hThread, UE_EIP, 4);
#endif
            case Registers::Id::Es:
                return ReadRegister(hThread, UE_SEG_ES, 2);
            case Registers::Id::Cs:
                return ReadRegister(hThread, UE_SEG_CS, 2);
            case Registers::Id::Ss:
                return ReadRegister(hThread, UE_SEG_SS, 2);
            case Registers::Id::Ds:
                return ReadRegister(hThread, UE_SEG_DS, 2);
            case Registers::Id::Fs:
                return ReadRegister(hThread, UE_SEG_FS, 2);
            case Registers::Id::Gs:
                return ReadRegister(hThread, UE_SEG_GS, 2);
            case Registers::Id::Gdtr:
                break;
            case Registers::Id::Ldtr:
                break;
            case Registers::Id::Idtr:
                break;
            case Registers::Id::Tr:
                break;
            case Registers::Id::Tr0:
                break;
            case Registers::Id::Tr1:
                break;
            case Registers::Id::Tr2:
                break;
            case Registers::Id::Tr3:
                break;
            case Registers::Id::Tr4:
                break;
            case Registers::Id::Tr5:
                break;
            case Registers::Id::Tr6:
                break;
            case Registers::Id::Tr7:
                break;
            case Registers::Id::Cr0:
                break;
            case Registers::Id::Cr1:
                break;
            case Registers::Id::Cr2:
                break;
            case Registers::Id::Cr3:
                break;
            case Registers::Id::Cr4:
                break;
            case Registers::Id::Cr5:
                break;
            case Registers::Id::Cr6:
                break;
            case Registers::Id::Cr7:
                break;
            case Registers::Id::Cr8:
                break;
            case Registers::Id::Cr9:
                break;
            case Registers::Id::Cr10:
                break;
            case Registers::Id::Cr11:
                break;
            case Registers::Id::Cr12:
                break;
            case Registers::Id::Cr13:
                break;
            case Registers::Id::Cr14:
                break;
            case Registers::Id::Cr15:
                break;
            case Registers::Id::Dr0:
                break;
            case Registers::Id::Dr1:
                break;
            case Registers::Id::Dr2:
                break;
            case Registers::Id::Dr3:
                break;
            case Registers::Id::Dr4:
                break;
            case Registers::Id::Dr5:
                break;
            case Registers::Id::Dr6:
                break;
            case Registers::Id::Dr7:
                break;
            case Registers::Id::Dr8:
                break;
            case Registers::Id::Dr9:
                break;
            case Registers::Id::Dr10:
                break;
            case Registers::Id::Dr11:
                break;
            case Registers::Id::Dr12:
                break;
            case Registers::Id::Dr13:
                break;
            case Registers::Id::Dr14:
                break;
            case Registers::Id::Dr15:
                break;
            case Registers::Id::K0:
                break;
            case Registers::Id::K1:
                break;
            case Registers::Id::K2:
                break;
            case Registers::Id::K3:
                break;
            case Registers::Id::K4:
                break;
            case Registers::Id::K5:
                break;
            case Registers::Id::K6:
                break;
            case Registers::Id::K7:
                break;
            case Registers::Id::Bnd0:
                break;
            case Registers::Id::Bnd1:
                break;
            case Registers::Id::Bnd2:
                break;
            case Registers::Id::Bnd3:
                break;
            case Registers::Id::BndCfg:
                break;
            case Registers::Id::BndStatus:
                break;
            case Registers::Id::Mxcsr:
                break;
            case Registers::Id::Pkru:
                break;
            case Registers::Id::Xcr0:
                break;
            default:
                break;
            }

            // Unsupported.
            return gcnew array<System::Byte>(0);
        }

        static void WriteRegister(System::UIntPtr hThread, array<System::Byte>^ data, int reg, int size, int offset)
        {
            HANDLE handle = hThread.ToPointer();

            pin_ptr<uint8_t> p = &data[0];
            const uint8_t* ptr = p;

            // This is terrible, but to preserve the data when the write happens on smaller regs we need the
            // value not to be zero.
            ULONG_PTR val = size < sizeof(ULONG_PTR) ? GetContextDataEx(handle, reg) : 0;

            std::memcpy(reinterpret_cast<uint8_t*>(&val) + offset, ptr, std::min<size_t>(data->Length, size));

            if (!SetContextDataEx(handle, reg, val))
            {
                throw gcnew System::Exception("Unable to set context data");
            }
        }

        static void WriteRegister(System::UIntPtr hThread, array<System::Byte>^ data, int reg, int size)
        {
            WriteRegister(hThread, data, reg, size, 0);
            GuiUpdateRegisterView();
        }

        static void SetRegisterData(System::UIntPtr hThread, Registers::Id reg, array<System::Byte>^ data)
        {
            switch (reg)
            {
            case Registers::Id::None:
                return;
#ifdef _M_X64
            case Registers::Id::Al:
                return WriteRegister(hThread, data, UE_RAX, 1);
            case Registers::Id::Cl:
                return WriteRegister(hThread, data, UE_RCX, 1);
            case Registers::Id::Dl:
                return WriteRegister(hThread, data, UE_RDX, 1);
            case Registers::Id::Bl:
                return WriteRegister(hThread, data, UE_RBX, 1);
            case Registers::Id::Ah:
                return WriteRegister(hThread, data, UE_RAX, 1, 1);
            case Registers::Id::Ch:
                return WriteRegister(hThread, data, UE_RCX, 1, 1);
            case Registers::Id::Dh:
                return WriteRegister(hThread, data, UE_RDX, 1, 1);
            case Registers::Id::Bh:
                return WriteRegister(hThread, data, UE_RBX, 1, 1);
            case Registers::Id::Spl:
                return WriteRegister(hThread, data, UE_RSP, 1);
            case Registers::Id::Bpl:
                return WriteRegister(hThread, data, UE_RBP, 1);
            case Registers::Id::Sil:
                return WriteRegister(hThread, data, UE_RSI, 1);
            case Registers::Id::Dil:
                return WriteRegister(hThread, data, UE_RDI, 1);
            case Registers::Id::R8b:
                return WriteRegister(hThread, data, UE_R8, 1);
            case Registers::Id::R9b:
                return WriteRegister(hThread, data, UE_R9, 1);
            case Registers::Id::R10b:
                return WriteRegister(hThread, data, UE_R10, 1);
            case Registers::Id::R11b:
                return WriteRegister(hThread, data, UE_R11, 1);
            case Registers::Id::R12b:
                return WriteRegister(hThread, data, UE_R12, 1);
            case Registers::Id::R13b:
                return WriteRegister(hThread, data, UE_R13, 1);
            case Registers::Id::R14b:
                return WriteRegister(hThread, data, UE_R14, 1);
            case Registers::Id::R15b:
                return WriteRegister(hThread, data, UE_R15, 1);
            case Registers::Id::Ax:
                return WriteRegister(hThread, data, UE_RAX, 2);
            case Registers::Id::Cx:
                return WriteRegister(hThread, data, UE_RCX, 2);
            case Registers::Id::Dx:
                return WriteRegister(hThread, data, UE_RDX, 2);
            case Registers::Id::Bx:
                return WriteRegister(hThread, data, UE_RBX, 2);
            case Registers::Id::Sp:
                return WriteRegister(hThread, data, UE_RSP, 2);
            case Registers::Id::Bp:
                return WriteRegister(hThread, data, UE_RBP, 2);
            case Registers::Id::Si:
                return WriteRegister(hThread, data, UE_RSI, 2);
            case Registers::Id::Di:
                return WriteRegister(hThread, data, UE_RDI, 2);
            case Registers::Id::R8w:
                return WriteRegister(hThread, data, UE_R8, 2);
            case Registers::Id::R9w:
                return WriteRegister(hThread, data, UE_R9, 2);
            case Registers::Id::R10w:
                return WriteRegister(hThread, data, UE_R10, 2);
            case Registers::Id::R11w:
                return WriteRegister(hThread, data, UE_R11, 2);
            case Registers::Id::R12w:
                return WriteRegister(hThread, data, UE_R12, 2);
            case Registers::Id::R13w:
                return WriteRegister(hThread, data, UE_R13, 2);
            case Registers::Id::R14w:
                return WriteRegister(hThread, data, UE_R14, 2);
            case Registers::Id::R15w:
                return WriteRegister(hThread, data, UE_R15, 2);
            case Registers::Id::Eax:
                return WriteRegister(hThread, data, UE_RAX, 4);
            case Registers::Id::Ecx:
                return WriteRegister(hThread, data, UE_RCX, 4);
            case Registers::Id::Edx:
                return WriteRegister(hThread, data, UE_RDX, 4);
            case Registers::Id::Ebx:
                return WriteRegister(hThread, data, UE_RBX, 4);
            case Registers::Id::Esp:
                return WriteRegister(hThread, data, UE_RSP, 4);
            case Registers::Id::Ebp:
                return WriteRegister(hThread, data, UE_RBP, 4);
            case Registers::Id::Esi:
                return WriteRegister(hThread, data, UE_RSI, 4);
            case Registers::Id::Edi:
                return WriteRegister(hThread, data, UE_RDI, 4);
            case Registers::Id::R8d:
                return WriteRegister(hThread, data, UE_R8, 4);
            case Registers::Id::R9d:
                return WriteRegister(hThread, data, UE_R9, 4);
            case Registers::Id::R10d:
                return WriteRegister(hThread, data, UE_R10, 4);
            case Registers::Id::R11d:
                return WriteRegister(hThread, data, UE_R11, 4);
            case Registers::Id::R12d:
                return WriteRegister(hThread, data, UE_R12, 4);
            case Registers::Id::R13d:
                return WriteRegister(hThread, data, UE_R13, 4);
            case Registers::Id::R14d:
                return WriteRegister(hThread, data, UE_R14, 4);
            case Registers::Id::R15d:
                return WriteRegister(hThread, data, UE_R15, 4);
            case Registers::Id::Rax:
                return WriteRegister(hThread, data, UE_RAX, 8);
            case Registers::Id::Rcx:
                return WriteRegister(hThread, data, UE_RCX, 8);
            case Registers::Id::Rdx:
                return WriteRegister(hThread, data, UE_RDX, 8);
            case Registers::Id::Rbx:
                return WriteRegister(hThread, data, UE_RBP, 8);
            case Registers::Id::Rsp:
                return WriteRegister(hThread, data, UE_RSP, 8);
            case Registers::Id::Rbp:
                return WriteRegister(hThread, data, UE_RBP, 8);
            case Registers::Id::Rsi:
                return WriteRegister(hThread, data, UE_RSI, 8);
            case Registers::Id::Rdi:
                return WriteRegister(hThread, data, UE_RDI, 8);
            case Registers::Id::R8:
                return WriteRegister(hThread, data, UE_R8, 8);
            case Registers::Id::R9:
                return WriteRegister(hThread, data, UE_R9, 8);
            case Registers::Id::R10:
                return WriteRegister(hThread, data, UE_R10, 8);
            case Registers::Id::R11:
                return WriteRegister(hThread, data, UE_R11, 8);
            case Registers::Id::R12:
                return WriteRegister(hThread, data, UE_R12, 8);
            case Registers::Id::R13:
                return WriteRegister(hThread, data, UE_R13, 8);
            case Registers::Id::R14:
                return WriteRegister(hThread, data, UE_R14, 8);
            case Registers::Id::R15:
                return WriteRegister(hThread, data, UE_R15, 8);
#else
            case Registers::Id::Al:
                return WriteRegister(hThread, data, UE_EAX, 1);
            case Registers::Id::Cl:
                return WriteRegister(hThread, data, UE_ECX, 1);
            case Registers::Id::Dl:
                return WriteRegister(hThread, data, UE_EDX, 1);
            case Registers::Id::Bl:
                return WriteRegister(hThread, data, UE_EBX, 1);
            case Registers::Id::Ah:
                return WriteRegister(hThread, data, UE_EAX, 1, 1);
            case Registers::Id::Ch:
                return WriteRegister(hThread, data, UE_ECX, 1, 1);
            case Registers::Id::Dh:
                return WriteRegister(hThread, data, UE_EDX, 1, 1);
            case Registers::Id::Bh:
                return WriteRegister(hThread, data, UE_EBX, 1, 1);
            case Registers::Id::Spl:
                return WriteRegister(hThread, data, UE_ESP, 1);
            case Registers::Id::Bpl:
                return WriteRegister(hThread, data, UE_EBP, 1);
            case Registers::Id::Sil:
                return WriteRegister(hThread, data, UE_ESI, 1);
            case Registers::Id::Dil:
                return WriteRegister(hThread, data, UE_EDI, 1);
            case Registers::Id::Ax:
                return WriteRegister(hThread, data, UE_EAX, 2);
            case Registers::Id::Cx:
                return WriteRegister(hThread, data, UE_ECX, 2);
            case Registers::Id::Dx:
                return WriteRegister(hThread, data, UE_EDX, 2);
            case Registers::Id::Bx:
                return WriteRegister(hThread, data, UE_EBX, 2);
            case Registers::Id::Sp:
                return WriteRegister(hThread, data, UE_ESP, 2);
            case Registers::Id::Bp:
                return WriteRegister(hThread, data, UE_EBP, 2);
            case Registers::Id::Si:
                return WriteRegister(hThread, data, UE_ESI, 2);
            case Registers::Id::Di:
                return WriteRegister(hThread, data, UE_EDI, 2);
            case Registers::Id::Eax:
                return WriteRegister(hThread, data, UE_EAX, 4);
            case Registers::Id::Ecx:
                return WriteRegister(hThread, data, UE_ECX, 4);
            case Registers::Id::Edx:
                return WriteRegister(hThread, data, UE_EDX, 4);
            case Registers::Id::Ebx:
                return WriteRegister(hThread, data, UE_EBX, 4);
            case Registers::Id::Esp:
                return WriteRegister(hThread, data, UE_ESP, 4);
            case Registers::Id::Ebp:
                return WriteRegister(hThread, data, UE_EBP, 4);
            case Registers::Id::Esi:
                return WriteRegister(hThread, data, UE_ESI, 4);
            case Registers::Id::Edi:
                return WriteRegister(hThread, data, UE_EDI, 4);
#endif
            case Registers::Id::St0:
                break;
            case Registers::Id::St1:
                break;
            case Registers::Id::St2:
                break;
            case Registers::Id::St3:
                break;
            case Registers::Id::St4:
                break;
            case Registers::Id::St5:
                break;
            case Registers::Id::St6:
                break;
            case Registers::Id::St7:
                break;
            case Registers::Id::X87Control:
                break;
            case Registers::Id::X87Status:
                break;
            case Registers::Id::X87Tag:
                break;
            case Registers::Id::Mm0:
                break;
            case Registers::Id::Mm1:
                break;
            case Registers::Id::Mm2:
                break;
            case Registers::Id::Mm3:
                break;
            case Registers::Id::Mm4:
                break;
            case Registers::Id::Mm5:
                break;
            case Registers::Id::Mm6:
                break;
            case Registers::Id::Mm7:
                break;
            case Registers::Id::Xmm0:
                break;
            case Registers::Id::Xmm1:
                break;
            case Registers::Id::Xmm2:
                break;
            case Registers::Id::Xmm3:
                break;
            case Registers::Id::Xmm4:
                break;
            case Registers::Id::Xmm5:
                break;
            case Registers::Id::Xmm6:
                break;
            case Registers::Id::Xmm7:
                break;
            case Registers::Id::Xmm8:
                break;
            case Registers::Id::Xmm9:
                break;
            case Registers::Id::Xmm10:
                break;
            case Registers::Id::Xmm11:
                break;
            case Registers::Id::Xmm12:
                break;
            case Registers::Id::Xmm13:
                break;
            case Registers::Id::Xmm14:
                break;
            case Registers::Id::Xmm15:
                break;
            case Registers::Id::Xmm16:
                break;
            case Registers::Id::Xmm17:
                break;
            case Registers::Id::Xmm18:
                break;
            case Registers::Id::Xmm19:
                break;
            case Registers::Id::Xmm20:
                break;
            case Registers::Id::Xmm21:
                break;
            case Registers::Id::Xmm22:
                break;
            case Registers::Id::Xmm23:
                break;
            case Registers::Id::Xmm24:
                break;
            case Registers::Id::Xmm25:
                break;
            case Registers::Id::Xmm26:
                break;
            case Registers::Id::Xmm27:
                break;
            case Registers::Id::Xmm28:
                break;
            case Registers::Id::Xmm29:
                break;
            case Registers::Id::Xmm30:
                break;
            case Registers::Id::Xmm31:
                break;
            case Registers::Id::Ymm0:
                break;
            case Registers::Id::Ymm1:
                break;
            case Registers::Id::Ymm2:
                break;
            case Registers::Id::Ymm3:
                break;
            case Registers::Id::Ymm4:
                break;
            case Registers::Id::Ymm5:
                break;
            case Registers::Id::Ymm6:
                break;
            case Registers::Id::Ymm7:
                break;
            case Registers::Id::Ymm8:
                break;
            case Registers::Id::Ymm9:
                break;
            case Registers::Id::Ymm10:
                break;
            case Registers::Id::Ymm11:
                break;
            case Registers::Id::Ymm12:
                break;
            case Registers::Id::Ymm13:
                break;
            case Registers::Id::Ymm14:
                break;
            case Registers::Id::Ymm15:
                break;
            case Registers::Id::Ymm16:
                break;
            case Registers::Id::Ymm17:
                break;
            case Registers::Id::Ymm18:
                break;
            case Registers::Id::Ymm19:
                break;
            case Registers::Id::Ymm20:
                break;
            case Registers::Id::Ymm21:
                break;
            case Registers::Id::Ymm22:
                break;
            case Registers::Id::Ymm23:
                break;
            case Registers::Id::Ymm24:
                break;
            case Registers::Id::Ymm25:
                break;
            case Registers::Id::Ymm26:
                break;
            case Registers::Id::Ymm27:
                break;
            case Registers::Id::Ymm28:
                break;
            case Registers::Id::Ymm29:
                break;
            case Registers::Id::Ymm30:
                break;
            case Registers::Id::Ymm31:
                break;
            case Registers::Id::Zmm0:
                break;
            case Registers::Id::Zmm1:
                break;
            case Registers::Id::Zmm2:
                break;
            case Registers::Id::Zmm3:
                break;
            case Registers::Id::Zmm4:
                break;
            case Registers::Id::Zmm5:
                break;
            case Registers::Id::Zmm6:
                break;
            case Registers::Id::Zmm7:
                break;
            case Registers::Id::Zmm8:
                break;
            case Registers::Id::Zmm9:
                break;
            case Registers::Id::Zmm10:
                break;
            case Registers::Id::Zmm11:
                break;
            case Registers::Id::Zmm12:
                break;
            case Registers::Id::Zmm13:
                break;
            case Registers::Id::Zmm14:
                break;
            case Registers::Id::Zmm15:
                break;
            case Registers::Id::Zmm16:
                break;
            case Registers::Id::Zmm17:
                break;
            case Registers::Id::Zmm18:
                break;
            case Registers::Id::Zmm19:
                break;
            case Registers::Id::Zmm20:
                break;
            case Registers::Id::Zmm21:
                break;
            case Registers::Id::Zmm22:
                break;
            case Registers::Id::Zmm23:
                break;
            case Registers::Id::Zmm24:
                break;
            case Registers::Id::Zmm25:
                break;
            case Registers::Id::Zmm26:
                break;
            case Registers::Id::Zmm27:
                break;
            case Registers::Id::Zmm28:
                break;
            case Registers::Id::Zmm29:
                break;
            case Registers::Id::Zmm30:
                break;
            case Registers::Id::Zmm31:
                break;
#ifdef _M_X64
            case Registers::Id::Flags:
                return WriteRegister(hThread, data, UE_RFLAGS, 2);
            case Registers::Id::EFlags:
                return WriteRegister(hThread, data, UE_RFLAGS, 4);
            case Registers::Id::RFlags:
                return WriteRegister(hThread, data, UE_RFLAGS, 8);
            case Registers::Id::Ip:
                return WriteRegister(hThread, data, UE_RIP, 2);
            case Registers::Id::Eip:
                return WriteRegister(hThread, data, UE_RIP, 4);
            case Registers::Id::Rip:
                return WriteRegister(hThread, data, UE_RIP, 8);
#else
            case Registers::Id::Flags:
                return WriteRegister(hThread, data, UE_EFLAGS, 2);
            case Registers::Id::EFlags:
                return WriteRegister(hThread, data, UE_EFLAGS, 4);
            case Registers::Id::Ip:
                return WriteRegister(hThread, data, UE_EIP, 2);
            case Registers::Id::Eip:
                return WriteRegister(hThread, data, UE_EIP, 4);
#endif
            case Registers::Id::Es:
                return WriteRegister(hThread, data, UE_SEG_ES, 2);
            case Registers::Id::Cs:
                return WriteRegister(hThread, data, UE_SEG_CS, 2);
            case Registers::Id::Ss:
                return WriteRegister(hThread, data, UE_SEG_SS, 2);
            case Registers::Id::Ds:
                return WriteRegister(hThread, data, UE_SEG_DS, 2);
            case Registers::Id::Fs:
                return WriteRegister(hThread, data, UE_SEG_FS, 2);
            case Registers::Id::Gs:
                return WriteRegister(hThread, data, UE_SEG_GS, 2);
            case Registers::Id::Gdtr:
                break;
            case Registers::Id::Ldtr:
                break;
            case Registers::Id::Idtr:
                break;
            case Registers::Id::Tr:
                break;
            case Registers::Id::Tr0:
                break;
            case Registers::Id::Tr1:
                break;
            case Registers::Id::Tr2:
                break;
            case Registers::Id::Tr3:
                break;
            case Registers::Id::Tr4:
                break;
            case Registers::Id::Tr5:
                break;
            case Registers::Id::Tr6:
                break;
            case Registers::Id::Tr7:
                break;
            case Registers::Id::Cr0:
                break;
            case Registers::Id::Cr1:
                break;
            case Registers::Id::Cr2:
                break;
            case Registers::Id::Cr3:
                break;
            case Registers::Id::Cr4:
                break;
            case Registers::Id::Cr5:
                break;
            case Registers::Id::Cr6:
                break;
            case Registers::Id::Cr7:
                break;
            case Registers::Id::Cr8:
                break;
            case Registers::Id::Cr9:
                break;
            case Registers::Id::Cr10:
                break;
            case Registers::Id::Cr11:
                break;
            case Registers::Id::Cr12:
                break;
            case Registers::Id::Cr13:
                break;
            case Registers::Id::Cr14:
                break;
            case Registers::Id::Cr15:
                break;
            case Registers::Id::Dr0:
                break;
            case Registers::Id::Dr1:
                break;
            case Registers::Id::Dr2:
                break;
            case Registers::Id::Dr3:
                break;
            case Registers::Id::Dr4:
                break;
            case Registers::Id::Dr5:
                break;
            case Registers::Id::Dr6:
                break;
            case Registers::Id::Dr7:
                break;
            case Registers::Id::Dr8:
                break;
            case Registers::Id::Dr9:
                break;
            case Registers::Id::Dr10:
                break;
            case Registers::Id::Dr11:
                break;
            case Registers::Id::Dr12:
                break;
            case Registers::Id::Dr13:
                break;
            case Registers::Id::Dr14:
                break;
            case Registers::Id::Dr15:
                break;
            case Registers::Id::K0:
                break;
            case Registers::Id::K1:
                break;
            case Registers::Id::K2:
                break;
            case Registers::Id::K3:
                break;
            case Registers::Id::K4:
                break;
            case Registers::Id::K5:
                break;
            case Registers::Id::K6:
                break;
            case Registers::Id::K7:
                break;
            case Registers::Id::Bnd0:
                break;
            case Registers::Id::Bnd1:
                break;
            case Registers::Id::Bnd2:
                break;
            case Registers::Id::Bnd3:
                break;
            case Registers::Id::BndCfg:
                break;
            case Registers::Id::BndStatus:
                break;
            case Registers::Id::Mxcsr:
                break;
            case Registers::Id::Pkru:
                break;
            case Registers::Id::Xcr0:
                break;
            default:
                break;
            }
        }

    };
}

```

`src/Bindings/UI.cpp`:

```cpp
#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_gui.h"

#include "Marshal.hpp"

#pragma comment(lib, "Gdi32.lib")

using namespace System;
using namespace System::Runtime::InteropServices;

namespace Dotx64Dbg::Native
{
    public ref class UI
    {
    public:
        /// <summary>
        /// Selection holds the start and end address of the selected elements in a window.
        /// </summary>
        ref struct Selection
        {
        public:
            /// <summary>
            /// Start address of the selection.
            /// </summary>
            uint64_t Start;

            /// <summary>
            /// End address of the selection.
            /// </summary>
            uint64_t End;

            /// <summary>
            /// The size of the selection, End - Start.
            /// </summary>
            property uint64_t Size
            {
                uint64_t get()
                {
                    return End - Start;
                }
            }
        };

        enum class WindowType
        {
            Disassembly = GUI_DISASSEMBLY,
            Dump = GUI_DUMP,
            Stack = GUI_STACK,
            Graph = GUI_GRAPH,
            MemoryMap = GUI_MEMMAP,
            SymbolModule = GUI_SYMMOD,
            Types, // No native id for this one.
        };

    public:
        static Selection^ GetSelection(WindowType wndType)
        {
            GUISELECTIONTYPE wndType2 = static_cast<GUISELECTIONTYPE>(wndType);

            SELECTIONDATA data{};
            if (!GuiSelectionGet(wndType2, &data))
                return nullptr;

            Selection^ res = gcnew Selection();
            res->Start = data.start;
            res->End = data.end;

            return res;
        }

        static bool SetSelection(WindowType wndType, Selection^ sel)
        {
            if (sel == nullptr)
                return false;

            SELECTIONDATA data{};
            data.start = (duint)sel->Start;
            data.end = (duint)sel->End;

            GUISELECTIONTYPE wndType2 = static_cast<GUISELECTIONTYPE>(wndType);
            return GuiSelectionSet(wndType2, &data);
        }

        static void SetStatusBarText(String^ str)
        {
            msclr::interop::marshal_context oMarshalContext;

            const char* cstr = oMarshalContext.marshal_as<const char*>(str);

            GuiAddStatusBarMessage(cstr);
        }

        static void Update()
        {
            GuiUpdateAllViews();
        }

        static void Update(WindowType wndType)
        {
            switch (wndType)
            {
            case WindowType::Disassembly:
                GuiUpdateDisassemblyView();
                break;
            case WindowType::Dump:
                GuiUpdateDumpView();
                break;
            case WindowType::Stack:
                GuiUpdateCallStack();
                break;
            case WindowType::Graph:
                GuiUpdateGraphView();
                break;
            case WindowType::MemoryMap:
                GuiUpdateMemoryView();
                break;
            case WindowType::SymbolModule:
                GuiUpdateAllViews();
                break;
            case WindowType::Types:
                GuiUpdateTypeWidget();
                break;
            default:
                break;
            }
        }

        static bool UpdatesEnabled()
        {
            return GuiIsUpdateDisabled();
        }

        static void EnableUpdates(bool enabled)
        {
            if (enabled)
                GuiUpdateEnable(true);
            else
                GuiUpdateDisable();
        }

        static void ClearLog()
        {
            GuiLogClear();
        }

        ref class Menu
        {
        public:
            static int Add(int parent, System::String^ name)
            {
                msclr::interop::marshal_context oMarshalContext;

                const char* cstr = oMarshalContext.marshal_as<const char*>(name);

                return _plugin_menuadd(parent, cstr);
            }

            static bool SetIcon(int hMenu, array<System::Byte>^ image)
            {
                if (image == nullptr)
                    return false;

                pin_ptr<uint8_t> data = &image[0];

                ICONDATA icon{ 0 };
                icon.data = data;
                if (icon.size = image->Length; !icon.size)
                    return false;

                _plugin_menuseticon(hMenu, &icon);

                return true;
            }

            static bool SetEntryIcon(int hPlugin, int hEntry, array<System::Byte>^ image)
            {
                pin_ptr<uint8_t> data = &image[0];

                ICONDATA icon{ 0 };
                icon.data = data;
                if (icon.size = image->Length; !icon.size)
                    return false;

                _plugin_menuentryseticon(hPlugin, hEntry, &icon);

                return true;
            }

            static bool AddEntry(int parent, int id, System::String^ name)
            {
                msclr::interop::marshal_context oMarshalContext;

                const char* cstr = oMarshalContext.marshal_as<const char*>(name);

                return _plugin_menuaddentry(parent, id, cstr);
            }

            static bool AddSeperator(int parent)
            {
                return _plugin_menuaddseparator(parent);
            }

            static bool RemoveEntry(int pluginHandle, int id)
            {
                return _plugin_menuentryremove(pluginHandle, id);
            }

            static bool Remove(int id)
            {
                return _plugin_menuremove(id);
            }
        };

        static System::String^ InputPrompt(System::String^ title)
        {
            auto titleStr = interop::toUTF8(title);

            auto buf = std::make_unique<char[]>(GUI_MAX_LINE_SIZE);
            if (!Script::Gui::InputLine(titleStr.c_str(), buf.get()))
            {
                return nullptr;
            }

            return interop::stringFromUTF8(buf.get());
        }

        enum class MsgBoxType
        {
            Ok = MB_OK,
            OkCancel = MB_OKCANCEL,
            YesNo = MB_YESNO,
            YesNoCancel = MB_YESNOCANCEL,
            RetryCancel = MB_RETRYCANCEL,
            AbortRetryIgnore = MB_ABORTRETRYIGNORE,
            CancelTryContinue = MB_CANCELTRYCONTINUE,
        };

        enum class MsgBoxIcon
        {
            None = 0,
            Error = MB_ICONERROR,
            Question = MB_ICONQUESTION,
            Warning = MB_ICONWARNING,
            Information = MB_ICONINFORMATION,
        };

        enum class MsgBoxResult
        {
            Ok = IDOK,
            Cancel = IDCANCEL,
            Yes = IDYES,
            No = IDNO,
            Retry = IDRETRY,
            Abort = IDABORT,
            Ignore = IDIGNORE,
            TryAgain = IDTRYAGAIN,
            Continue = IDCONTINUE,
        };

        static MsgBoxResult MsgBox(System::String^ title, System::String^ message, MsgBoxType type, MsgBoxIcon icon)
        {
            const auto titleStr = interop::toUTF16(title);
            const auto messageStr = interop::toUTF16(message);
            const auto msgBoxType = (UINT)type | (UINT)icon;
            return (MsgBoxResult)MessageBoxW(nullptr, messageStr.c_str(), titleStr.c_str(), msgBoxType);
        }
    };
}

```

`src/Dotx64Dbg/Loader.cpp`:

```cpp
#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_memory.h"
#include "pluginsdk/_scriptapi_register.h"
#include "pluginsdk/_scriptapi_module.h"

struct Wrapper
{
    static bool Init(int pluginHandle)
    {
        return Dotx64Dbg::Manager::Init(pluginHandle);
    }

    static void Setup()
    {
        Dotx64Dbg::Manager::Setup();
    }

    static void Shutdown()
    {
        Dotx64Dbg::Manager::Shutdown();
    }

    static void SetMenuData(PLUG_SETUPSTRUCT* setupStruct)
    {
        Dotx64Dbg::MenuData data;
        data.hMenu = setupStruct->hMenu;
        data.hMenuDisasm = setupStruct->hMenuDisasm;
        data.hMenuDump = setupStruct->hMenuDump;
        data.hMenuStack = setupStruct->hMenuStack;
        data.hMenuGraph = setupStruct->hMenuGraph;
        data.hMenuMemmap = setupStruct->hMenuMemmap;
        data.hMenuSymmod = setupStruct->hMenuSymmod;
        Dotx64Dbg::Manager::SetMenuData(data);
    }

    static void OnProcessCreate(PLUG_CB_CREATEPROCESS* info)
    {
        auto* src = info->CreateProcessInfo;

        const auto imageBase = reinterpret_cast<duint>(src->lpBaseOfImage);
        char pathBuf[MAX_PATH]{};
        if (!Script::Module::PathFromAddr(imageBase, pathBuf))
        {
            // TODO: Handle the error.
        }

        const auto imageSize = Script::Module::SizeFromAddr(imageBase);

        Dotx64Dbg::ProcessCreateEventInfo dst{};
        dst.ProcessId = info->fdProcessInfo->dwProcessId;
        dst.ThreadId = info->fdProcessInfo->dwThreadId;
        dst.FileHandle = reinterpret_cast<uint64_t>(src->hFile);
        dst.ProcessHandle = reinterpret_cast<uint64_t>(info->fdProcessInfo->hProcess);
        dst.ThreadHandle = reinterpret_cast<uint64_t>(info->fdProcessInfo->hThread);
        dst.ImageBase = imageBase;
        dst.ImageSize = imageSize;
        dst.DebugInfoFileOffset = src->dwDebugInfoFileOffset;
        dst.DebugInfoSize = src->nDebugInfoSize;
        dst.ThreadLocalBase = reinterpret_cast<uint64_t>(src->lpThreadLocalBase);
        dst.StartAddress = reinterpret_cast<uint64_t>(src->lpStartAddress);
        dst.FilePath = gcnew System::String(pathBuf);
        dst.Unicode = src->fUnicode;

        Dotx64Dbg::Manager::OnProcessCreateEvent(dst);
    }

    static void OnBreakpointEvent(PLUG_CB_BREAKPOINT* info, bool systemBp)
    {
        Dotx64Dbg::BreakpointEventInfo dst{};

        if (info == nullptr && systemBp)
        {
            auto addr = Script::Register::Get(Script::Register::CIP);
            char modName[1024]{};
            DbgGetModuleAt(addr, modName);

            dst.Type = Dotx64Dbg::Breakpoints::Type::System;
            dst.Address = addr;
            dst.Name = gcnew System::String("System Breakpoint");
            dst.Slot = 0xFFFF;
            dst.HitCount = 1;
            dst.Active = false;
            dst.Module = gcnew System::String(modName);
        }
        else
        {
            const auto* bp = info->breakpoint;

            dst.Type = (Dotx64Dbg::Breakpoints::Type)bp->type;
            dst.Address = bp->addr;
            dst.Enabled = bp->enabled;
            dst.Singleshot = bp->singleshoot;
            dst.Active = bp->active;
            dst.Name = gcnew System::String(bp->name);
            dst.Module = gcnew System::String(bp->mod);
            dst.Slot = bp->slot;
            dst.TypeEx = bp->typeEx;
            dst.Size = static_cast<int>(bp->hwSize);
            dst.HitCount = bp->hitCount;
            dst.FastResume = bp->fastResume;
            dst.Silent = bp->silent;
            dst.BreakCondition = gcnew System::String(bp->breakCondition);
            dst.LogText = gcnew System::String(bp->logText);
            dst.LogCondition = gcnew System::String(bp->logCondition);
            dst.CommandText = gcnew System::String(bp->commandText);
            dst.CommandCondition = gcnew System::String(bp->commandCondition);
        }

        Dotx64Dbg::Manager::OnBreakpointEvent(dst);
    }

    static void MenuCallback(int id)
    {
        Dotx64Dbg::Manager::OnMenuCallback(id);
    }

    static bool EvalScript(const char* input)
    {
        auto str = gcnew System::String(input);
        return Dotx64Dbg::Manager::EvalScript(str);
    }

    static void OnSteppedEvent()
    {
        Dotx64Dbg::Manager::OnSteppedEvent();
    }

    static void OnDebuggerStart(const char* file)
    {
        auto str = gcnew System::String(file);
        Dotx64Dbg::Manager::OnDebuggerStart(str);
    }

    static void OnDebuggerStop()
    {
        Dotx64Dbg::Manager::OnDebuggerStop();
    }

    static void OnDebuggerResume()
    {
        Dotx64Dbg::Manager::OnDebuggerResume();
    }

    static void OnDebuggerPause()
    {
        Dotx64Dbg::Manager::OnDebuggerPause();
    }

    static void OnModuleLoad(PLUG_CB_LOADDLL* info)
    {
        const auto imageBase = reinterpret_cast<duint>(info->LoadDll->lpBaseOfDll);

        char pathBuf[MAX_PATH]{};
        if (!Script::Module::PathFromAddr(imageBase, pathBuf))
        {
            // TODO: Handle the error.
        }

        const auto imageSize = Script::Module::SizeFromAddr(imageBase);

        Dotx64Dbg::ModuleLoadEventInfo ev{};
        ev.FilePath = gcnew System::String(pathBuf);
        ev.ImageBase = imageBase;
        ev.ImageSize = imageSize;
        ev.DebugInfoFileOffset = info->LoadDll->dwDebugInfoFileOffset;
        ev.DebugInfoSize = info->LoadDll->nDebugInfoSize;

        Dotx64Dbg::Manager::OnModuleLoadEvent(ev);
    }

    static void OnModuleUnload(PLUG_CB_UNLOADDLL* info)
    {
        const auto imageBase = reinterpret_cast<duint>(info->UnloadDll->lpBaseOfDll);

        char pathBuf[MAX_PATH]{};
        if (!Script::Module::PathFromAddr(imageBase, pathBuf))
        {
            // TODO: Handle the error.
        }

        const auto imageSize = Script::Module::SizeFromAddr(imageBase);

        Dotx64Dbg::ModuleUnloadEventInfo ev{};
        ev.ImageBase = imageBase;
        ev.ImageSize = imageSize;
        ev.FilePath = gcnew System::String(pathBuf);

        Dotx64Dbg::Manager::OnModuleUnloadEvent(ev);
    }

    static void DebugEvent(PLUG_CB_DEBUGEVENT* ev)
    {
        switch (ev->DebugEvent->dwDebugEventCode)
        {
        case EXCEPTION_DEBUG_EVENT:
        {
            auto& src = ev->DebugEvent->u.Exception;

            Dotx64Dbg::ExceptionEventInfo dst{};
            dst.ProcessId = ev->DebugEvent->dwProcessId;
            dst.ThreadId = ev->DebugEvent->dwThreadId;
            dst.FirstChance = src.dwFirstChance ? true : false;
            dst.ExceptionCode = src.ExceptionRecord.ExceptionCode;
            dst.ExceptionFlags = src.ExceptionRecord.ExceptionFlags;
            dst.ExceptionAddress = reinterpret_cast<uintptr_t>(src.ExceptionRecord.ExceptionAddress);

            Dotx64Dbg::Manager::OnExceptionEvent(dst);
            break;
        }
        case CREATE_THREAD_DEBUG_EVENT:
        {
            auto& src = ev->DebugEvent->u.CreateThread;

            Dotx64Dbg::ThreadCreateEventInfo dst{};
            dst.ProcessId = ev->DebugEvent->dwProcessId;
            dst.ThreadId = ev->DebugEvent->dwThreadId;
            dst.Handle = reinterpret_cast<uint64_t>(src.hThread);
            dst.StartAddress = reinterpret_cast<uint64_t>(src.lpStartAddress);
            dst.ThreadLocalBase = reinterpret_cast<uint64_t>(src.lpThreadLocalBase);

            Dotx64Dbg::Manager::OnThreadCreateEvent(dst);
            break;
        }
        case CREATE_PROCESS_DEBUG_EVENT:
        {
            // Moved to OnProcessCreate plugin callback.
            break;
        }
        case EXIT_THREAD_DEBUG_EVENT:
        {
            auto& src = ev->DebugEvent->u.ExitThread;

            Dotx64Dbg::ThreadExitEventInfo dst{};
            dst.ProcessId = ev->DebugEvent->dwProcessId;
            dst.ThreadId = ev->DebugEvent->dwThreadId;
            dst.ExitCode = src.dwExitCode;

            Dotx64Dbg::Manager::OnThreadExitEvent(dst);
            break;
        }
        case EXIT_PROCESS_DEBUG_EVENT:
        {
            auto& src = ev->DebugEvent->u.ExitProcess;

            Dotx64Dbg::ProcessExitEventInfo dst{};
            dst.ProcessId = ev->DebugEvent->dwProcessId;
            dst.ThreadId = ev->DebugEvent->dwThreadId;
            dst.ExitCode = src.dwExitCode;

            Dotx64Dbg::Manager::OnProcessExitEvent(dst);
            break;
        }
        case LOAD_DLL_DEBUG_EVENT:
        {
            break;
        }
        case UNLOAD_DLL_DEBUG_EVENT:
        {
            break;
        }
        case OUTPUT_DEBUG_STRING_EVENT:
        {
            break;
        }
        case RIP_EVENT:
        {
            break;
        }
        }
    }
};

// Unmanaged section.
#pragma unmanaged

#define PLUG_EXPORT extern "C" __declspec(dllexport)

PLUG_EXPORT void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY* info)
{
    Wrapper::MenuCallback(info->hEntry);
}

PLUG_EXPORT void CBINITDEBUG(CBTYPE cbType, PLUG_CB_INITDEBUG* info)
{
    Wrapper::OnDebuggerStart(info->szFileName);
}

PLUG_EXPORT void CBSTOPDEBUG(CBTYPE cbType, PLUG_CB_STOPDEBUG* info)
{
    Wrapper::OnDebuggerStop();
}

PLUG_EXPORT void CBEXCEPTION(CBTYPE cbType, PLUG_CB_EXCEPTION* info)
{
}

PLUG_EXPORT void CBPAUSEDEBUG(CBTYPE cbType, PLUG_CB_PAUSEDEBUG* info)
{
    Wrapper::OnDebuggerPause();
}

PLUG_EXPORT void CBCREATEPROCESS(CBTYPE cbType, PLUG_CB_CREATEPROCESS* info)
{
    Wrapper::OnProcessCreate(info);
}

PLUG_EXPORT void CBBREAKPOINT(CBTYPE cbType, PLUG_CB_BREAKPOINT* info)
{
    Wrapper::OnBreakpointEvent(info, false);
}

PLUG_EXPORT void CBSYSTEMBREAKPOINT(CBTYPE cbType, PLUG_CB_SYSTEMBREAKPOINT* info)
{
    Wrapper::OnBreakpointEvent(nullptr, true);
}

PLUG_EXPORT void CBRESUMEDEBUG(CBTYPE cbType, PLUG_CB_RESUMEDEBUG* info)
{
    Wrapper::OnDebuggerResume();
}

PLUG_EXPORT void CBSTEPPED(CBTYPE cbType, PLUG_CB_STEPPED* info)
{
    Wrapper::OnSteppedEvent();
}

PLUG_EXPORT void CBDEBUGEVENT(CBTYPE cbType, PLUG_CB_DEBUGEVENT* info)
{
    Wrapper::DebugEvent(info);
}

PLUG_EXPORT void CBLOADDLL(CBTYPE cbType, PLUG_CB_LOADDLL* info)
{
    Wrapper::OnModuleLoad(info);
}

PLUG_EXPORT void CBUNLOADDLL(CBTYPE cbType, PLUG_CB_UNLOADDLL* info)
{
    Wrapper::OnModuleUnload(info);
}

PLUG_EXPORT void CBCREATETHREAD(CBTYPE cbType, PLUG_CB_CREATETHREAD* info)
{
    // Handled in DebugEvent callback.
}

PLUG_EXPORT void CBEXITTHREAD(CBTYPE cbType, PLUG_CB_EXITTHREAD* info)
{
    // Handled in DebugEvent callback.
}

bool CBEXECUTESCRIPT(const char* text)
{
    return Wrapper::EvalScript(text);
}

void CBSCRIPTAUTOCOMPLETE(const char* text, char** entries, int* entryCount)
{
    if (entryCount)
        *entryCount = 0;
}

PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
    if (!Wrapper::Init(initStruct->pluginHandle))
    {
        return false;
    }

    initStruct->pluginVersion = 1;
    initStruct->sdkVersion = 1;
    strncpy_s(initStruct->pluginName, "DotX64Dbg", _TRUNCATE);

    SCRIPTTYPEINFO sti = {};
    sti.execute = CBEXECUTESCRIPT;
    strcpy_s(sti.name, "DotX64Dbg");

    GuiRegisterScriptLanguage(&sti);

    return true;
}

PLUG_EXPORT bool plugstop()
{
    Wrapper::Shutdown();
    return true;
}

PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
    Wrapper::SetMenuData(setupStruct);
}

```

`src/Dotx64DbgLoader/Loader.cpp`:

```cpp
#include "pluginsdk/bridgemain.h"
#include "pluginsdk/_plugins.h"
#include "pluginsdk/_scriptapi_memory.h"
#include "pluginsdk/_scriptapi_register.h"

static HMODULE _module{};

template<typename T>
class CallHelper
{
    T _f;
public:
    CallHelper(HMODULE mod, const char* name)
    {
        _f = reinterpret_cast<T>(GetProcAddress(mod, name));
    }

    operator bool() const
    {
        return _f != nullptr;
    }

    template<typename ...Args>
    auto operator()(Args&& ...args)
    {
        return _f(std::forward<Args&&>(args)...);
    }
};

#define PLUG_EXPORT extern "C" __declspec(dllexport)

PLUG_EXPORT void CBMENUENTRY(CBTYPE cbType, PLUG_CB_MENUENTRY* info)
{
    static CallHelper<decltype(&CBMENUENTRY)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBINITDEBUG(CBTYPE cbType, PLUG_CB_INITDEBUG* info)
{
    static CallHelper<decltype(&CBINITDEBUG)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBSTOPDEBUG(CBTYPE cbType, PLUG_CB_STOPDEBUG* info)
{
    static CallHelper<decltype(&CBSTOPDEBUG)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBEXCEPTION(CBTYPE cbType, PLUG_CB_EXCEPTION* info)
{
    static CallHelper<decltype(&CBEXCEPTION)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBPAUSEDEBUG(CBTYPE cbType, PLUG_CB_PAUSEDEBUG* info)
{
    static CallHelper<decltype(&CBPAUSEDEBUG)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBCREATEPROCESS(CBTYPE cbType, PLUG_CB_CREATEPROCESS* info)
{
    static CallHelper<decltype(&CBCREATEPROCESS)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBBREAKPOINT(CBTYPE cbType, PLUG_CB_BREAKPOINT* info)
{
    static CallHelper<decltype(&CBBREAKPOINT)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBSYSTEMBREAKPOINT(CBTYPE cbType, PLUG_CB_SYSTEMBREAKPOINT* info)
{
    static CallHelper<decltype(&CBSYSTEMBREAKPOINT)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBRESUMEDEBUG(CBTYPE cbType, PLUG_CB_RESUMEDEBUG* info)
{
    static CallHelper<decltype(&CBRESUMEDEBUG)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBSTEPPED(CBTYPE cbType, PLUG_CB_STEPPED* info)
{
    static CallHelper<decltype(&CBSTEPPED)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBDEBUGEVENT(CBTYPE cbType, PLUG_CB_DEBUGEVENT* info)
{
    static CallHelper<decltype(&CBDEBUGEVENT)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBLOADDLL(CBTYPE cbType, PLUG_CB_LOADDLL* info)
{
    static CallHelper<decltype(&CBLOADDLL)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBUNLOADDLL(CBTYPE cbType, PLUG_CB_UNLOADDLL* info)
{
    static CallHelper<decltype(&CBUNLOADDLL)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBCREATETHREAD(CBTYPE cbType, PLUG_CB_CREATETHREAD* info)
{
    static CallHelper<decltype(&CBCREATETHREAD)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

PLUG_EXPORT void CBEXITTHREAD(CBTYPE cbType, PLUG_CB_EXITTHREAD* info)
{
    static CallHelper<decltype(&CBEXITTHREAD)> f(_module, __FUNCTION__);
    if (f)
        return f(cbType, info);
}

bool CBEXECUTESCRIPT(const char* text)
{
    static CallHelper<decltype(&CBEXECUTESCRIPT)> f(_module, __FUNCTION__);
    if (f)
        return f(text);

    return false;
}

void CBSCRIPTAUTOCOMPLETE(const char* text, char** entries, int* entryCount)
{
    static CallHelper<decltype(&CBSCRIPTAUTOCOMPLETE)> f(_module, __FUNCTION__);
    if (f)
        return f(text, entries, entryCount);
}

static HMODULE _thisModule = nullptr;

int DllMain(HMODULE hmodule, DWORD reason, LPVOID reserved)
{
    if (reason == DLL_PROCESS_ATTACH)
    {
        _thisModule = hmodule;
    }
    return TRUE;
}

static int exceptionHandler(int code, PEXCEPTION_POINTERS ex)
{
    _plugin_logprintf("Exception while trying to load Dotx64Dbg (%08X)\n", code);
    return EXCEPTION_EXECUTE_HANDLER;
}

static bool checkLegacyInstall()
{
    // If Dotx64Dbg.Loader.dp32 exists in the main plugin folder refuse to load.
    wchar_t curPath[1024]{};
    GetModuleFileNameW(nullptr, curPath, sizeof(curPath) / sizeof(wchar_t));

    if (auto* p = wcsrchr(curPath, L'\\'); p != nullptr)
    {
        *p = '\0';
    }

    wchar_t dllPath[1024]{};
#if _X86_
    swprintf_s(dllPath, L"%s\\plugins\\Dotx64Dbg.Loader.dp32", curPath);
#else
    swprintf_s(dllPath, L"%s\\plugins\\Dotx64Dbg.Loader.dp64", curPath);
#endif

    if (GetFileAttributesW(dllPath) != INVALID_FILE_ATTRIBUTES)
    {
        _plugin_lograw_html("<b style=\"color: red\">Dotx64Dbg.Loader.dp32 found in main plugin folder, please delete the old install.</b>\n");
        return true;
    }

    return false;
}

PLUG_EXPORT bool pluginit(PLUG_INITSTRUCT* initStruct)
{
    // Check for the legacy install.
    if (checkLegacyInstall())
        return false;

    wchar_t curPath[1024]{};
    GetModuleFileNameW(_thisModule, curPath, sizeof(curPath) / sizeof(wchar_t));

    if (auto* p = wcsrchr(curPath, L'\\'); p != nullptr)
    {
        *p = '\0';
    }

    wchar_t dllPath[1024]{};
    swprintf_s(dllPath, L"%s\\Dotx64Dbg.dll", curPath);

    bool loadingError = false;

    __try
    {
        _module = LoadLibraryW(dllPath);
        if (_module == nullptr)
        {
            loadingError = true;
        }
    }
    __except (exceptionHandler(GetExceptionCode(), GetExceptionInformation()))
    {
        loadingError = true;
    }

    if (loadingError)
    {
#if _X86_
        static const wchar_t* arch = L"x86";
#else
        static const wchar_t* arch = L"x64";
#endif
        _plugin_logprintf("Unable to load Dotx64Dbg (%08X), make sure you have following installed:\n"
            "- .NET 6.0 %s Runtime (https://dotnet.microsoft.com/download/dotnet/6.0)\n"
            "- Visual Studio 2019 Runtime (https://support.microsoft.com/en-us/topic/the-latest-supported-visual-c-downloads-2647da03-1eea-4433-9aff-95f26a218cc0)\n",
            GetLastError(),
            arch
        );
        return false;
    }

    static CallHelper<decltype(&pluginit)> f(_module, __FUNCTION__);
    if (f)
        return f(initStruct);

    return false;
}

PLUG_EXPORT bool plugstop()
{
    if (_module == nullptr)
        return false;

    static CallHelper<decltype(&plugstop)> f(_module, __FUNCTION__);
    if (f)
    {
        f();
    }

    FreeLibrary(_module);
    return true;
}

PLUG_EXPORT void plugsetup(PLUG_SETUPSTRUCT* setupStruct)
{
    static CallHelper<decltype(&plugsetup)> f(_module, __FUNCTION__);
    if (f)
    {
        return f(setupStruct);
    }
}

```

`src/Dotx64DbgTests/Runner.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;

namespace Dotx64Dbg.Managed.Tests
{
    public class Tests
    {
        private const ConsoleColor ColorOk = ConsoleColor.DarkGreen;
        private const ConsoleColor ColorBad = ConsoleColor.DarkRed;

        private static void Write(ConsoleColor color, string str)
        {
            var col = Console.ForegroundColor;
            Console.ForegroundColor = color;
            Console.Write(str);
            Console.ForegroundColor = col;
        }

        private static void WriteLine(string str)
        {
            Console.WriteLine(str);
        }

        private static IEnumerable<MethodInfo> GetMethodsWithAttribute<T>()
        {
            return System.Reflection.Assembly.GetExecutingAssembly()
                .GetTypes()
                .SelectMany(t => t.GetMethods())
                .Where(m => m.GetCustomAttributes(typeof(T), false).Length > 0)
                ;
        }

        class TestGroup
        {
            public Type ClassType;
            public List<TestEntry> Entries;
        }

        class TestEntry
        {
            public string Name;
            public TestGroup Group;
            public MethodInfo Function;
        }

        class TestingState
        {
            public List<TestGroup> Groups = new();
            public List<TestEntry> Failed = new();
            public ulong TotalTime = 0;
            public ulong Ran = 0;
            public ulong Passed = 0;
        }

        private static void SetupTests(TestingState state)
        {
            var tests = state.Groups;

            var testFuncs = GetMethodsWithAttribute<Test>();
            foreach (var func in testFuncs)
            {
                TestGroup entry = tests.Find(x => x.ClassType == func.DeclaringType);
                if (entry == null)
                {
                    entry = new TestGroup()
                    {
                        ClassType = func.DeclaringType,
                        Entries = new()
                    };
                    tests.Add(entry);
                }

                entry.Entries.Add(new()
                {
                    Name = $"{entry.ClassType.Name}.{func.Name}",
                    Group = entry,
                    Function = func
                });
            }
        }

        private static bool RunTestGroup(TestingState state, TestGroup group)
        {
            var instance = Activator.CreateInstance(group.ClassType);
            foreach (var func in group.Entries)
            {
                RunTest(state, instance, group, func);
            }
            return false;
        }

        private static void LogException(TestingState state, Exception ex)
        {
            if (ex is AssertException assertEx)
            {
                Write(ColorBad, "[  ASSERT  ] ");
                WriteLine($"{assertEx.Message}");

                Write(ColorBad, "[          ] ");
                WriteLine($"Source: {assertEx.SourceFile}:{assertEx.LineNumber}");
            }
            else
            {
                Write(ColorBad, "[  FAILED  ] ");
                WriteLine($"{ex.Message}");
            }
        }

        private static void DryRunTest(TestingState state, object instance, TestGroup group, TestEntry test)
        {
            try
            {
                test.Function.Invoke(instance, Array.Empty<object>());
            }
            catch (Exception)
            {
            }
        }

        private static bool RunTest(TestingState state, object instance, TestGroup group, TestEntry test)
        {
            bool passed = true;

            // Do not account for assembly loading, make a quiet run first.
            DryRunTest(state, instance, group, test);

            var sw = new Stopwatch();
            state.Ran++;

            Write(ColorOk, "[ Run      ] ");
            WriteLine($"{test.Name}");

            try
            {
                sw.Restart();
                test.Function.Invoke(instance, Array.Empty<object>());
                sw.Stop();
            }
            catch (Exception ex)
            {
                LogException(state, ex.InnerException ?? ex);
                passed = false;
            }

            if (passed)
            {
                Write(ColorOk, "[       OK ] ");
                WriteLine($"{test.Name} ({sw.ElapsedMilliseconds} ms)");
                state.Passed++;
                state.TotalTime += (ulong)sw.ElapsedMilliseconds;
            }
            else
            {
                Write(ColorBad, "[  FAILED  ] ");
                WriteLine($"{test.Name}");
                state.Failed.Add(test);
            }

            return passed;
        }

        public static void Main(string[] args)
        {
            TestingState state = new();

            SetupTests(state);

            foreach (var test in state.Groups)
            {
                Write(ColorOk, "[----------] ");
                WriteLine($"{test.Entries.Count} test(s) from {test.ClassType.Name}");
                RunTestGroup(state, test);
            }

            WriteLine("");

            Write(ColorOk, $"[==========] ");
            WriteLine($"{state.Ran} tests ran. ({state.TotalTime} ms total)");

            ulong passing = state.Ran - (ulong)state.Failed.Count;
            if (passing == 0)
            {
                Write(ColorBad, $"[  FAILED  ] ");
                WriteLine($"No tests passed.");
            }
            else
            {
                Write(ColorOk, $"[  PASSED  ] ");
                WriteLine($"{state.Ran - (ulong)state.Failed.Count} tests.");
            }

            if (state.Failed.Count > 0)
            {
                Write(ColorBad, $"[  FAILED  ] ");
                WriteLine($"{state.Failed.Count} tests, listed below:");
                foreach (var failedTest in state.Failed)
                {
                    Write(ColorBad, $"[  FAILED  ] ");
                    WriteLine($"{failedTest.Name}");
                }

                Environment.ExitCode = -1;
            }
            else
            {
                Environment.ExitCode = 0;
            }

        }

    }
}

```

`src/Dotx64DbgTests/Testing.cs`:

```cs
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.CompilerServices;

namespace Dotx64Dbg.Managed.Tests
{
    public class Test : Attribute { }

    public class AssertException : Exception
    {
        public string MemberName { get; private set; }
        public string SourceFile { get; private set; }
        public int LineNumber { get; private set; }
        public AssertException(string message,
            string memberName,
            string sourceFilePath,
            int lineNumber) : base(message)
        {
            MemberName = memberName;
            SourceFile = sourceFilePath;
            LineNumber = lineNumber;
        }
    }

    public static class Testing
    {
        public static void AssertEq<T>(T? a, T? b,
            [CallerMemberName] string memberName = "",
            [CallerFilePath] string sourceFilePath = "",
            [CallerLineNumber] int sourceLineNumber = 0)
        {
            if (!EqualityComparer<T>.Default.Equals(a, b))
            {
                throw new AssertException($"Assertion: {a} == {b}", memberName, sourceFilePath, sourceLineNumber);
            }
        }

        public static void AssertNeq<T>(T? a, T? b,
            [CallerMemberName] string memberName = "",
            [CallerFilePath] string sourceFilePath = "",
            [CallerLineNumber] int sourceLineNumber = 0)
        {
            if (EqualityComparer<T>.Default.Equals(a, b))
            {
                throw new AssertException($"Assertion: {a} == {b}", memberName, sourceFilePath, sourceLineNumber);
            }
        }
    }
}

```

`src/Dotx64DbgTests/Tests/Tests.Assembler.cs`:

```cs
namespace Dotx64Dbg.Managed.Tests
{
    using static Operands;
    using static Testing;

    class TestAssembler
    {
#if _X64_
        [Test]
        public void TestEncodeXorRaxRax()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Xor(Rax, Rax);
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(3, data.Length);
            AssertEq(0x48, data[0]);
            AssertEq(0x31, data[1]);
            AssertEq(0xC0, data[2]);
        }

        [Test]
        public void TestEncodeLeaBasic64()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Lea(Rax, QwordPtr(Rax));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(4, data.Length);
            AssertEq(0x3E, data[0]);
            AssertEq(0x48, data[1]);
            AssertEq(0x8d, data[2]);
            AssertEq(0x00, data[3]);
        }

        [Test]
        public void TestEncodeLeaBasic32()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Lea(Eax, DwordPtr(Eax));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(4, data.Length);
            AssertEq(0x3E, data[0]);
            AssertEq(0x67, data[1]);
            AssertEq(0x8D, data[2]);
            AssertEq(0x00, data[3]);
        }

        [Test]
        public void TestEncodeMemSegment64()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Mov(Rax, QwordPtr(0x60).WithSegment(Gs));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(9, data.Length);
            AssertEq(0x65, data[0]);
            AssertEq(0x48, data[1]);
            AssertEq(0x8B, data[2]);
            AssertEq(0x04, data[3]);
            AssertEq(0x25, data[4]);
            AssertEq(0x60, data[5]);
            AssertEq(0x00, data[6]);
            AssertEq(0x00, data[7]);
            AssertEq(0x00, data[8]);
        }

        [Test]
        public void TestEncodeLeaScale2()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Lea(Rax, DwordPtr(Rax, Rdx, 2, 0));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(5, data.Length);
            AssertEq(0x3E, data[0]);
            AssertEq(0x48, data[1]);
            AssertEq(0x8D, data[2]);
            AssertEq(0x04, data[3]);
            AssertEq(0x50, data[4]);
        }


        [Test]
        public void TestEncodeLeaScale4()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Lea(Rax, DwordPtr(Rax, Rdx, 4, 0));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(5, data.Length);
            AssertEq(0x3E, data[0]);
            AssertEq(0x48, data[1]);
            AssertEq(0x8D, data[2]);
            AssertEq(0x04, data[3]);
            AssertEq(0x90, data[4]);
        }


        [Test]
        public void TestEncodeLeaScale8()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Lea(Rax, DwordPtr(Rax, Rdx, 8, 0));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(5, data.Length);
            AssertEq(0x3E, data[0]);
            AssertEq(0x48, data[1]);
            AssertEq(0x8D, data[2]);
            AssertEq(0x04, data[3]);
            AssertEq(0xD0, data[4]);
        }
#else
        [Test]
        public void TestEncodeLeaBasic32()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Lea(Eax, DwordPtr(Eax));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(3, data.Length);
            AssertEq(0x3E, data[0]);
            AssertEq(0x8D, data[1]);
            AssertEq(0x00, data[2]);
        }

        [Test]
        public void TestEncodeMemSegment32()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Mov(Eax, DwordPtr(0x30).WithSegment(Fs));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(6, data.Length);
            AssertEq(0x64, data[0]);
            AssertEq(0xA1, data[1]);
            AssertEq(0x30, data[2]);
            AssertEq(0x00, data[3]);
            AssertEq(0x00, data[4]);
            AssertEq(0x00, data[5]);
        }

        [Test]
        public void TestEncodeLeaScale2()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Lea(Eax, DwordPtr(Eax, Edx, 2, 0));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(4, data.Length);
            AssertEq(0x3E, data[0]);
            AssertEq(0x8D, data[1]);
            AssertEq(0x04, data[2]);
            AssertEq(0x50, data[3]);
        }


        [Test]
        public void TestEncodeLeaScale4()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Lea(Eax, DwordPtr(Eax, Edx, 4, 0));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(4, data.Length);
            AssertEq(0x3E, data[0]);
            AssertEq(0x8D, data[1]);
            AssertEq(0x04, data[2]);
            AssertEq(0x90, data[3]);
        }


        [Test]
        public void TestEncodeLeaScale8()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Lea(Eax, DwordPtr(Eax, Edx, 8, 0));
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(4, data.Length);
            AssertEq(0x3E, data[0]);
            AssertEq(0x8D, data[1]);
            AssertEq(0x04, data[2]);
            AssertEq(0xD0, data[3]);
        }
#endif

        [Test]
        public void TestEncodeXorEaxEax()
        {
            var assembler = new Dotx64Dbg.Assembler();
            assembler.Xor(Eax, Eax);
            assembler.Finalize();

            var data = assembler.GetData();
            AssertEq(2, data.Length);
            AssertEq(0x31, data[0]);
            AssertEq(0xC0, data[1]);
        }


    }
}

```

`src/Dotx64DbgTests/Tests/Tests.Decoder.cs`:

```cs
namespace Dotx64Dbg.Managed.Tests
{
    class TestDecoder
    {

    }
}

```

`src/Dotx64DbgTests/Tests/Tests.Generator.cs`:

```cs
namespace Dotx64Dbg.Managed.Tests
{
    using static Operands;
    using static Testing;

    class TestInstructionGenerator
    {
        [Test]
        public void TestSubEaxEdx()
        {
            var instr = InstructionGenerator.Generate(Mnemonic.Sub, Eax, Edx);
            AssertNeq(instr, null);
            AssertEq((instr.GetOperand(0) as Operand.Register).Value, Eax.Value);
            AssertEq(instr.GetOperandAccess(0), OperandAccess.ReadWrite);
            AssertEq((instr.GetOperand(1) as Operand.Register).Value, Edx.Value);
            AssertEq(instr.GetOperandAccess(1), OperandAccess.Read);
            AssertEq(instr.FlagsRead, Dotx64Dbg.EFlags.None);
            AssertEq(instr.FlagsWrite, Dotx64Dbg.EFlags.Of |
                Dotx64Dbg.EFlags.Sf |
                Dotx64Dbg.EFlags.Zf |
                Dotx64Dbg.EFlags.Af |
                Dotx64Dbg.EFlags.Pf |
                Dotx64Dbg.EFlags.Cf);
        }

        [Test]
        public void TestSubEaxEdx100000()
        {
            for (int i = 0; i < 100000; i++)
            {
                var instr = InstructionGenerator.Generate(Mnemonic.Sub, Eax, Edx);
                AssertNeq(instr, null);
                AssertEq((instr.GetOperand(0) as Operand.Register).Value, Eax.Value);
                AssertEq(instr.GetOperandAccess(0), OperandAccess.ReadWrite);
                AssertEq((instr.GetOperand(1) as Operand.Register).Value, Edx.Value);
                AssertEq(instr.GetOperandAccess(1), OperandAccess.Read);
                AssertEq(instr.FlagsRead, Dotx64Dbg.EFlags.None);
                AssertEq(instr.FlagsWrite, Dotx64Dbg.EFlags.Of |
                    Dotx64Dbg.EFlags.Sf |
                    Dotx64Dbg.EFlags.Zf |
                    Dotx64Dbg.EFlags.Af |
                    Dotx64Dbg.EFlags.Pf |
                    Dotx64Dbg.EFlags.Cf);
            }
        }

        [Test]
        public void TestLeaNoDisp()
        {
            var instr = InstructionGenerator.Generate(Mnemonic.Lea, Eax, DwordPtr(Eax, Edx));
            AssertNeq(instr, null);
            AssertEq((instr.GetOperand(0) as Operand.Register).Value, Eax.Value);
            AssertEq(instr.GetOperandAccess(0), OperandAccess.Write);
            var op1 = instr.GetOperand(1);
            AssertEq(op1.Type, OperandType.Memory);
            var mem = op1 as Operand.Memory;
            AssertEq(mem.Segment, Registers.Id.Ds);
            AssertEq(mem.Base, Registers.Id.Eax);
            AssertEq(mem.Index, Registers.Id.Edx);
            AssertEq(mem.Displacement, 0);
        }

        [Test]
        public void TestLeaDisp()
        {
            var instr = InstructionGenerator.Generate(Mnemonic.Lea, Eax, DwordPtr(Eax, Edx, 0xBADBABE));
            AssertNeq(instr, null);
            AssertEq((instr.GetOperand(0) as Operand.Register).Value, Eax.Value);
            AssertEq(instr.GetOperandAccess(0), OperandAccess.Write);
            var op1 = instr.GetOperand(1);
            AssertEq(op1.Type, OperandType.Memory);
            var mem = op1 as Operand.Memory;
            AssertEq(mem.Segment, Registers.Id.Ds);
            AssertEq(mem.Base, Registers.Id.Eax);
            AssertEq(mem.Index, Registers.Id.Edx);
            AssertEq(mem.Displacement, 0xBADBABE);
        }
    }
}

```

`src/Dotx64DbgTests/Tests/Tests.Operands.cs`:

```cs
namespace Dotx64Dbg.Managed.Tests
{
    using static Testing;

    class TestOperands
    {
        [Test]
        public void TestOperandImm()
        {
            var imm1 = Operands.Imm(1);
            AssertEq(imm1.Size, 8);

            var imm2 = Operands.Imm(0xFF);
            AssertEq(imm2.Size, 8);

            var imm3 = Operands.Imm(0xFF + 1);
            AssertEq(imm3.Size, 16);

            var imm4 = Operands.Imm(-1);
            AssertEq(imm4.Size, 8);

            var imm5 = Operands.Imm(-255);
            AssertEq(imm5.Size, 8);

            var imm6 = Operands.Imm(-256);
            AssertEq(imm6.Size, 16);
        }

        [Test]
        public void TestOperandReg()
        {
            var al = Operands.Reg(Registers.Id.Al);
            AssertEq(al.Size, 8);

            var ax = Operands.Reg(Registers.Id.Ax);
            AssertEq(ax.Size, 16);

            var eax = Operands.Reg(Registers.Id.Eax);
            AssertEq(eax.Size, 32);

            var rax = Operands.Reg(Registers.Id.Rax);
            AssertEq(rax.Size, 64);
        }

        [Test]
        public void TestOperandMemory8()
        {
            var mem1 = Operands.BytePtr(Registers.Id.Rax);
            AssertEq(mem1.Size, 8);
            AssertEq(mem1.Base, Registers.Id.Rax);

            var str1 = mem1.ToString();
            AssertEq(str1, "byte ptr [rax]");

            var mem2 = Operands.BytePtr(Registers.Id.Rax, Registers.Id.Rdx);
            AssertEq(mem2.Size, 8);
            AssertEq(mem2.Base, Registers.Id.Rax);
            AssertEq(mem2.Index, Registers.Id.Rdx);

            var str2 = mem2.ToString();
            AssertEq(str2, "byte ptr [rax+rdx]");
        }

        [Test]
        public void TestOperandMemory16()
        {
            var mem1 = Operands.WordPtr(Registers.Id.Rax);
            AssertEq(mem1.Size, 16);
            AssertEq(mem1.Base, Registers.Id.Rax);

            var str1 = mem1.ToString();
            AssertEq(str1, "word ptr [rax]");

            var mem2 = Operands.WordPtr(Registers.Id.Rax, Registers.Id.Rdx);
            AssertEq(mem2.Size, 16);
            AssertEq(mem2.Base, Registers.Id.Rax);
            AssertEq(mem2.Index, Registers.Id.Rdx);

            var str2 = mem2.ToString();
            AssertEq(str2, "word ptr [rax+rdx]");
        }
    }
}

```

`src/Dotx64DbgTests/Tests/Tests.RegisterMaskGp.cs`:

```cs
using System.Collections.Generic;

namespace Dotx64Dbg.Managed.Tests
{
    using static Testing;

    class TestRegisterMaskGp
    {
        [Test]
        public void TestMask()
        {
            var mask = Analysis.RegisterMaskGp.None;
            mask.Add(Registers.Id.Ah);
            mask.Add(Registers.Id.Al);
            mask.Add(Registers.Id.Ecx);

            AssertEq(mask.Count, 2);

            var regs = mask.GetRegisters();
            AssertEq(regs.Length, 2);

#if _X64_
            AssertEq(regs[0], Registers.Id.Rax);
            AssertEq(regs[1], Registers.Id.Rcx);
#else
            AssertEq(regs[0], Registers.Id.Eax);
            AssertEq(regs[1], Registers.Id.Ecx);
#endif

            Operand.Register[] regs2;
            mask.GetRegisters(out regs2);

            AssertEq(regs2.Length, 2);

            for (int i = 0; i < regs2.Length; i++)
            {
                AssertEq(regs2[i].Value, regs[i]);
            }
        }

        [Test]
        public void TestMask2()
        {
            var mask = Analysis.RegisterMaskGp.None;
            mask.Add(Registers.Id.Ah);
            mask.Add(Registers.Id.Al);
            mask.Add(Registers.Id.R15);

            AssertEq(mask.Count, 2);

            var regs = mask.GetRegisters();
            AssertEq(regs.Length, 2);

#if _X64_
            AssertEq(regs[0], Registers.Id.Rax);
            AssertEq(regs[1], Registers.Id.R15);
#else
            AssertEq(regs[0], Registers.Id.Eax);
            AssertEq(regs[1], Registers.Id.R15d);
#endif

            Operand.Register[] regs2;
            mask.GetRegisters(out regs2);

            AssertEq(regs2.Length, 2);

            for (int i = 0; i < regs2.Length; i++)
            {
                AssertEq(regs2[i].Value, regs[i]);
            }
        }

        [Test]
        public void TestMaskCountForward()
        {
            Registers.Id[] regs = new[] {
                Registers.Id.Eax,
                Registers.Id.Ebx,
                Registers.Id.Ecx,
                Registers.Id.Edx,
                Registers.Id.Ebp,
                Registers.Id.Esp,
                Registers.Id.Edi,
                Registers.Id.R8d,
                Registers.Id.R9d,
                Registers.Id.R10d,
                Registers.Id.R11d,
                Registers.Id.R12d,
                Registers.Id.R13d,
                Registers.Id.R14d,
                Registers.Id.R15d
            };

            var mask = Analysis.RegisterMaskGp.None;
            var i = 0;
            foreach (var reg in regs)
            {
                mask.Add(reg);

                i++;
                AssertEq(mask.Count, i);
            }

        }

        [Test]
        public void TestMaskCountReverse()
        {
            List<Registers.Id> regs = new()
            {
                Registers.Id.Eax,
                Registers.Id.Ebx,
                Registers.Id.Ecx,
                Registers.Id.Edx,
                Registers.Id.Ebp,
                Registers.Id.Esp,
                Registers.Id.Edi,
                Registers.Id.R8d,
                Registers.Id.R9d,
                Registers.Id.R10d,
                Registers.Id.R11d,
                Registers.Id.R12d,
                Registers.Id.R13d,
                Registers.Id.R14d,
                Registers.Id.R15d
            };

            var mask = Analysis.RegisterMaskGp.None;
            var i = 0;

            regs.Reverse();
            foreach (var reg in regs)
            {
                mask.Add(reg);

                i++;
                AssertEq(mask.Count, i);
            }

        }

        [Test]
        public void TestMaskCountRandom()
        {
            List<Registers.Id> regs = new()
            {
                Registers.Id.Eax,
                Registers.Id.Ebx,
                Registers.Id.Ecx,
                Registers.Id.Edx,
                Registers.Id.Ebp,
                Registers.Id.Esp,
                Registers.Id.Edi,
                Registers.Id.R8d,
                Registers.Id.R9d,
                Registers.Id.R10d,
                Registers.Id.R11d,
                Registers.Id.R12d,
                Registers.Id.R13d,
                Registers.Id.R14d,
                Registers.Id.R15d
            };

            for (int seed = 0; seed < 100; seed++)
            {
                var mask = Analysis.RegisterMaskGp.None;
                var i = 0;
                var prng = new System.Random(seed);

                while (regs.Count > 0)
                {
                    var idx = prng.Next(0, regs.Count - 1);
                    var reg = regs[idx];
                    regs.RemoveAt(idx);

                    mask.Add(reg);

                    i++;
                    AssertEq(mask.Count, i);
                }
            }

        }


    }
}

```

`src/Dotx64DbgTests/Tests/Tests.Registers.cs`:

```cs
namespace Dotx64Dbg.Managed.Tests
{
    using static Testing;

    class TestRegisters
    {
        [Test]
        public void TestRoot()
        {
            AssertEq(Operands.Reg(Registers.Id.None).RootId, Registers.Id.None);
#if _X64_
            AssertEq(Operands.Al.RootId, Registers.Id.Rax);
            AssertEq(Operands.Cl.RootId, Registers.Id.Rcx);
            AssertEq(Operands.Dl.RootId, Registers.Id.Rdx);
            AssertEq(Operands.Bl.RootId, Registers.Id.Rbx);
            AssertEq(Operands.Ah.RootId, Registers.Id.Rax);
            AssertEq(Operands.Ch.RootId, Registers.Id.Rcx);
            AssertEq(Operands.Dh.RootId, Registers.Id.Rdx);
            AssertEq(Operands.Bh.RootId, Registers.Id.Rbx);
            AssertEq(Operands.Spl.RootId, Registers.Id.Rsp);
            AssertEq(Operands.Bpl.RootId, Registers.Id.Rbp);
            AssertEq(Operands.Sil.RootId, Registers.Id.Rsi);
            AssertEq(Operands.Dil.RootId, Registers.Id.Rdi);
            AssertEq(Operands.R8b.RootId, Registers.Id.R8);
            AssertEq(Operands.R9b.RootId, Registers.Id.R9);
            AssertEq(Operands.R10b.RootId, Registers.Id.R10);
            AssertEq(Operands.R11b.RootId, Registers.Id.R11);
            AssertEq(Operands.R12b.RootId, Registers.Id.R12);
            AssertEq(Operands.R13b.RootId, Registers.Id.R13);
            AssertEq(Operands.R14b.RootId, Registers.Id.R14);
            AssertEq(Operands.R15b.RootId, Registers.Id.R15);
            AssertEq(Operands.Ax.RootId, Registers.Id.Rax);
            AssertEq(Operands.Cx.RootId, Registers.Id.Rcx);
            AssertEq(Operands.Dx.RootId, Registers.Id.Rdx);
            AssertEq(Operands.Bx.RootId, Registers.Id.Rbx);
            AssertEq(Operands.Sp.RootId, Registers.Id.Rsp);
            AssertEq(Operands.Bp.RootId, Registers.Id.Rbp);
            AssertEq(Operands.Si.RootId, Registers.Id.Rsi);
            AssertEq(Operands.Di.RootId, Registers.Id.Rdi);
            AssertEq(Operands.R8w.RootId, Registers.Id.R8);
            AssertEq(Operands.R9w.RootId, Registers.Id.R9);
            AssertEq(Operands.R10w.RootId, Registers.Id.R10);
            AssertEq(Operands.R11w.RootId, Registers.Id.R11);
            AssertEq(Operands.R12w.RootId, Registers.Id.R12);
            AssertEq(Operands.R13w.RootId, Registers.Id.R13);
            AssertEq(Operands.R14w.RootId, Registers.Id.R14);
            AssertEq(Operands.R15w.RootId, Registers.Id.R15);
            AssertEq(Operands.Eax.RootId, Registers.Id.Rax);
            AssertEq(Operands.Ecx.RootId, Registers.Id.Rcx);
            AssertEq(Operands.Edx.RootId, Registers.Id.Rdx);
            AssertEq(Operands.Ebx.RootId, Registers.Id.Rbx);
            AssertEq(Operands.Esp.RootId, Registers.Id.Rsp);
            AssertEq(Operands.Ebp.RootId, Registers.Id.Rbp);
            AssertEq(Operands.Esi.RootId, Registers.Id.Rsi);
            AssertEq(Operands.Edi.RootId, Registers.Id.Rdi);
            AssertEq(Operands.R8d.RootId, Registers.Id.R8);
            AssertEq(Operands.R9d.RootId, Registers.Id.R9);
            AssertEq(Operands.R10d.RootId, Registers.Id.R10);
            AssertEq(Operands.R11d.RootId, Registers.Id.R11);
            AssertEq(Operands.R12d.RootId, Registers.Id.R12);
            AssertEq(Operands.R13d.RootId, Registers.Id.R13);
            AssertEq(Operands.R14d.RootId, Registers.Id.R14);
            AssertEq(Operands.R15d.RootId, Registers.Id.R15);
            AssertEq(Operands.Rax.RootId, Registers.Id.None);
            AssertEq(Operands.Rcx.RootId, Registers.Id.None);
            AssertEq(Operands.Rdx.RootId, Registers.Id.None);
            AssertEq(Operands.Rbx.RootId, Registers.Id.None);
            AssertEq(Operands.Rsp.RootId, Registers.Id.None);
            AssertEq(Operands.Rbp.RootId, Registers.Id.None);
            AssertEq(Operands.Rsi.RootId, Registers.Id.None);
            AssertEq(Operands.Rdi.RootId, Registers.Id.None);
            AssertEq(Operands.R8.RootId, Registers.Id.None);
            AssertEq(Operands.R9.RootId, Registers.Id.None);
            AssertEq(Operands.R10.RootId, Registers.Id.None);
            AssertEq(Operands.R11.RootId, Registers.Id.None);
            AssertEq(Operands.R12.RootId, Registers.Id.None);
            AssertEq(Operands.R13.RootId, Registers.Id.None);
            AssertEq(Operands.R14.RootId, Registers.Id.None);
            AssertEq(Operands.R15.RootId, Registers.Id.None);
#else
            AssertEq(Operands.Al.RootId, Registers.Id.Eax);
            AssertEq(Operands.Cl.RootId, Registers.Id.Ecx);
            AssertEq(Operands.Dl.RootId, Registers.Id.Edx);
            AssertEq(Operands.Bl.RootId, Registers.Id.Ebx);
            AssertEq(Operands.Ah.RootId, Registers.Id.Eax);
            AssertEq(Operands.Ch.RootId, Registers.Id.Ecx);
            AssertEq(Operands.Dh.RootId, Registers.Id.Edx);
            AssertEq(Operands.Bh.RootId, Registers.Id.Ebx);
            AssertEq(Operands.Spl.RootId, Registers.Id.Esp);
            AssertEq(Operands.Bpl.RootId, Registers.Id.Ebp);
            AssertEq(Operands.Sil.RootId, Registers.Id.Esi);
            AssertEq(Operands.Dil.RootId, Registers.Id.Edi);
            AssertEq(Operands.Ax.RootId, Registers.Id.Eax);
            AssertEq(Operands.Cx.RootId, Registers.Id.Ecx);
            AssertEq(Operands.Dx.RootId, Registers.Id.Edx);
            AssertEq(Operands.Bx.RootId, Registers.Id.Ebx);
            AssertEq(Operands.Sp.RootId, Registers.Id.Esp);
            AssertEq(Operands.Bp.RootId, Registers.Id.Ebp);
            AssertEq(Operands.Si.RootId, Registers.Id.Esi);
            AssertEq(Operands.Di.RootId, Registers.Id.Edi);
            AssertEq(Operands.Eax.RootId, Registers.Id.None);
            AssertEq(Operands.Ecx.RootId, Registers.Id.None);
            AssertEq(Operands.Edx.RootId, Registers.Id.None);
            AssertEq(Operands.Ebx.RootId, Registers.Id.None);
            AssertEq(Operands.Esp.RootId, Registers.Id.None);
            AssertEq(Operands.Ebp.RootId, Registers.Id.None);
            AssertEq(Operands.Esi.RootId, Registers.Id.None);
            AssertEq(Operands.Edi.RootId, Registers.Id.None);
            AssertEq(Operands.R8d.RootId, Registers.Id.None);
            AssertEq(Operands.R9d.RootId, Registers.Id.None);
            AssertEq(Operands.R10d.RootId, Registers.Id.None);
            AssertEq(Operands.R11d.RootId, Registers.Id.None);
            AssertEq(Operands.R12d.RootId, Registers.Id.None);
            AssertEq(Operands.R13d.RootId, Registers.Id.None);
            AssertEq(Operands.R14d.RootId, Registers.Id.None);
            AssertEq(Operands.R15d.RootId, Registers.Id.None);
#endif
        }

        [Test]
        public void TestParent()
        {
            AssertEq(Operands.Al.ParentId, Registers.Id.Ax);
            AssertEq(Operands.Cl.ParentId, Registers.Id.Cx);
            AssertEq(Operands.Dl.ParentId, Registers.Id.Dx);
            AssertEq(Operands.Bl.ParentId, Registers.Id.Bx);
            AssertEq(Operands.Ah.ParentId, Registers.Id.Ax);
            AssertEq(Operands.Ch.ParentId, Registers.Id.Cx);
            AssertEq(Operands.Dh.ParentId, Registers.Id.Dx);
            AssertEq(Operands.Bh.ParentId, Registers.Id.Bx);
            AssertEq(Operands.Spl.ParentId, Registers.Id.Sp);
            AssertEq(Operands.Bpl.ParentId, Registers.Id.Bp);
            AssertEq(Operands.Sil.ParentId, Registers.Id.Si);
            AssertEq(Operands.Dil.ParentId, Registers.Id.Di);
#if _X64_
            AssertEq(Operands.R8b.ParentId, Registers.Id.R8w);
            AssertEq(Operands.R9b.ParentId, Registers.Id.R9w);
            AssertEq(Operands.R10b.ParentId, Registers.Id.R10w);
            AssertEq(Operands.R11b.ParentId, Registers.Id.R11w);
            AssertEq(Operands.R12b.ParentId, Registers.Id.R12w);
            AssertEq(Operands.R13b.ParentId, Registers.Id.R13w);
            AssertEq(Operands.R14b.ParentId, Registers.Id.R14w);
            AssertEq(Operands.R15b.ParentId, Registers.Id.R15w);
#endif
            AssertEq(Operands.Ax.ParentId, Registers.Id.Eax);
            AssertEq(Operands.Cx.ParentId, Registers.Id.Ecx);
            AssertEq(Operands.Dx.ParentId, Registers.Id.Edx);
            AssertEq(Operands.Bx.ParentId, Registers.Id.Ebx);
            AssertEq(Operands.Sp.ParentId, Registers.Id.Esp);
            AssertEq(Operands.Bp.ParentId, Registers.Id.Ebp);
            AssertEq(Operands.Si.ParentId, Registers.Id.Esi);
            AssertEq(Operands.Di.ParentId, Registers.Id.Edi);
#if _X64_
            AssertEq(Operands.R8w.ParentId, Registers.Id.R8d);
            AssertEq(Operands.R9w.ParentId, Registers.Id.R9d);
            AssertEq(Operands.R10w.ParentId, Registers.Id.R10d);
            AssertEq(Operands.R11w.ParentId, Registers.Id.R11d);
            AssertEq(Operands.R12w.ParentId, Registers.Id.R12d);
            AssertEq(Operands.R13w.ParentId, Registers.Id.R13d);
            AssertEq(Operands.R14w.ParentId, Registers.Id.R14d);
            AssertEq(Operands.R15w.ParentId, Registers.Id.R15d);
#endif

#if _X64_
            AssertEq(Operands.Eax.ParentId, Registers.Id.Rax);
            AssertEq(Operands.Ecx.ParentId, Registers.Id.Rcx);
            AssertEq(Operands.Edx.ParentId, Registers.Id.Rdx);
            AssertEq(Operands.Ebx.ParentId, Registers.Id.Rbx);
            AssertEq(Operands.Esp.ParentId, Registers.Id.Rsp);
            AssertEq(Operands.Ebp.ParentId, Registers.Id.Rbp);
            AssertEq(Operands.Esi.ParentId, Registers.Id.Rsi);
            AssertEq(Operands.Edi.ParentId, Registers.Id.Rdi);
#else
            AssertEq(Operands.Eax.ParentId, Registers.Id.None);
            AssertEq(Operands.Ecx.ParentId, Registers.Id.None);
            AssertEq(Operands.Edx.ParentId, Registers.Id.None);
            AssertEq(Operands.Ebx.ParentId, Registers.Id.None);
            AssertEq(Operands.Esp.ParentId, Registers.Id.None);
            AssertEq(Operands.Ebp.ParentId, Registers.Id.None);
            AssertEq(Operands.Esi.ParentId, Registers.Id.None);
            AssertEq(Operands.Edi.ParentId, Registers.Id.None);
#endif
#if _X64_
            AssertEq(Operands.R8d.ParentId, Registers.Id.R8);
            AssertEq(Operands.R9d.ParentId, Registers.Id.R9);
            AssertEq(Operands.R10d.ParentId, Registers.Id.R10);
            AssertEq(Operands.R11d.ParentId, Registers.Id.R11);
            AssertEq(Operands.R12d.ParentId, Registers.Id.R12);
            AssertEq(Operands.R13d.ParentId, Registers.Id.R13);
            AssertEq(Operands.R14d.ParentId, Registers.Id.R14);
            AssertEq(Operands.R15d.ParentId, Registers.Id.R15);
            AssertEq(Operands.Rax.ParentId, Registers.Id.None);
            AssertEq(Operands.Rcx.ParentId, Registers.Id.None);
            AssertEq(Operands.Rdx.ParentId, Registers.Id.None);
            AssertEq(Operands.Rbx.ParentId, Registers.Id.None);
            AssertEq(Operands.Rsp.ParentId, Registers.Id.None);
            AssertEq(Operands.Rbp.ParentId, Registers.Id.None);
            AssertEq(Operands.Rsi.ParentId, Registers.Id.None);
            AssertEq(Operands.Rdi.ParentId, Registers.Id.None);
            AssertEq(Operands.R8.ParentId, Registers.Id.None);
            AssertEq(Operands.R9.ParentId, Registers.Id.None);
            AssertEq(Operands.R10.ParentId, Registers.Id.None);
            AssertEq(Operands.R11.ParentId, Registers.Id.None);
            AssertEq(Operands.R12.ParentId, Registers.Id.None);
            AssertEq(Operands.R13.ParentId, Registers.Id.None);
            AssertEq(Operands.R14.ParentId, Registers.Id.None);
            AssertEq(Operands.R15.ParentId, Registers.Id.None);
#endif
        }

        [Test]
        public void TestMutating()
        {
            AssertEq(Operands.Al.MutatesParent, false);
            AssertEq(Operands.Cl.MutatesParent, false);
            AssertEq(Operands.Dl.MutatesParent, false);
            AssertEq(Operands.Bl.MutatesParent, false);
            AssertEq(Operands.Ah.MutatesParent, false);
            AssertEq(Operands.Ch.MutatesParent, false);
            AssertEq(Operands.Dh.MutatesParent, false);
            AssertEq(Operands.Bh.MutatesParent, false);
            AssertEq(Operands.Spl.MutatesParent, false);
            AssertEq(Operands.Bpl.MutatesParent, false);
            AssertEq(Operands.Sil.MutatesParent, false);
            AssertEq(Operands.Dil.MutatesParent, false);
#if _X64_
            AssertEq(Operands.R8b.MutatesParent, false);
            AssertEq(Operands.R9b.MutatesParent, false);
            AssertEq(Operands.R10b.MutatesParent, false);
            AssertEq(Operands.R11b.MutatesParent, false);
            AssertEq(Operands.R12b.MutatesParent, false);
            AssertEq(Operands.R13b.MutatesParent, false);
            AssertEq(Operands.R14b.MutatesParent, false);
            AssertEq(Operands.R15b.MutatesParent, false);
#endif
            AssertEq(Operands.Ax.MutatesParent, false);
            AssertEq(Operands.Cx.MutatesParent, false);
            AssertEq(Operands.Dx.MutatesParent, false);
            AssertEq(Operands.Bx.MutatesParent, false);
            AssertEq(Operands.Sp.MutatesParent, false);
            AssertEq(Operands.Bp.MutatesParent, false);
            AssertEq(Operands.Si.MutatesParent, false);
            AssertEq(Operands.Di.MutatesParent, false);
#if _X64_
            AssertEq(Operands.R8w.MutatesParent, false);
            AssertEq(Operands.R9w.MutatesParent, false);
            AssertEq(Operands.R10w.MutatesParent, false);
            AssertEq(Operands.R11w.MutatesParent, false);
            AssertEq(Operands.R12w.MutatesParent, false);
            AssertEq(Operands.R13w.MutatesParent, false);
            AssertEq(Operands.R14w.MutatesParent, false);
            AssertEq(Operands.R15w.MutatesParent, false);
#endif

#if _X64_
            AssertEq(Operands.Eax.MutatesParent, true);
            AssertEq(Operands.Ecx.MutatesParent, true);
            AssertEq(Operands.Edx.MutatesParent, true);
            AssertEq(Operands.Ebx.MutatesParent, true);
            AssertEq(Operands.Esp.MutatesParent, true);
            AssertEq(Operands.Ebp.MutatesParent, true);
            AssertEq(Operands.Edi.MutatesParent, true);
            AssertEq(Operands.Esi.MutatesParent, true);
            AssertEq(Operands.R8d.MutatesParent, true);
            AssertEq(Operands.R9d.MutatesParent, true);
            AssertEq(Operands.R10d.MutatesParent, true);
            AssertEq(Operands.R11d.MutatesParent, true);
            AssertEq(Operands.R12d.MutatesParent, true);
            AssertEq(Operands.R13d.MutatesParent, true);
            AssertEq(Operands.R14d.MutatesParent, true);
            AssertEq(Operands.R15d.MutatesParent, true);
            AssertEq(Operands.Rax.MutatesParent, false);
            AssertEq(Operands.Rcx.MutatesParent, false);
            AssertEq(Operands.Rdx.MutatesParent, false);
            AssertEq(Operands.Rbx.MutatesParent, false);
            AssertEq(Operands.Rsp.MutatesParent, false);
            AssertEq(Operands.Rbp.MutatesParent, false);
            AssertEq(Operands.Rdi.MutatesParent, false);
            AssertEq(Operands.Rsi.MutatesParent, false);
            AssertEq(Operands.R8.MutatesParent, false);
            AssertEq(Operands.R9.MutatesParent, false);
            AssertEq(Operands.R10.MutatesParent, false);
            AssertEq(Operands.R11.MutatesParent, false);
            AssertEq(Operands.R12.MutatesParent, false);
            AssertEq(Operands.R13.MutatesParent, false);
            AssertEq(Operands.R14.MutatesParent, false);
            AssertEq(Operands.R15.MutatesParent, false);
#else
            AssertEq(Operands.Eax.MutatesParent, false);
            AssertEq(Operands.Ecx.MutatesParent, false);
            AssertEq(Operands.Edx.MutatesParent, false);
            AssertEq(Operands.Ebx.MutatesParent, false);
            AssertEq(Operands.Esp.MutatesParent, false);
            AssertEq(Operands.Ebp.MutatesParent, false);
            AssertEq(Operands.Edi.MutatesParent, false);
            AssertEq(Operands.Esi.MutatesParent, false);
            AssertEq(Operands.R8d.MutatesParent, false);
            AssertEq(Operands.R9d.MutatesParent, false);
            AssertEq(Operands.R10d.MutatesParent, false);
            AssertEq(Operands.R11d.MutatesParent, false);
            AssertEq(Operands.R12d.MutatesParent, false);
            AssertEq(Operands.R13d.MutatesParent, false);
            AssertEq(Operands.R14d.MutatesParent, false);
            AssertEq(Operands.R15d.MutatesParent, false);
#endif
        }
    }
}

```

`src/Dotx64Managed/API/Analysis/RegisterMask.cs`:

```cs
using System;

namespace Dotx64Dbg.Analysis
{
    using RegisterMaskType = UInt32;

    public struct RegisterMaskGp
    {
        private RegisterMaskType Mask;

        public const uint MaxRegisters = sizeof(RegisterMaskType) * 8u;

        public static readonly RegisterMaskGp None = new RegisterMaskGp();
        public static readonly RegisterMaskGp All = new RegisterMaskGp { Mask = ~0u };

        public RegisterMaskGp Add(Dotx64Dbg.Operand.Register reg)
        {
            return Add(reg.Value);
        }

        public RegisterMaskGp Add(Registers.Id reg)
        {
            var index = Registers.GetIndex(reg);
            if (index == -1)
                throw new InvalidOperationException("Invalid register type");

            Mask |= (UInt16)(1u << index);

            return this;
        }

        public int Count
        {
            get
            {
                return (int)System.Runtime.Intrinsics.X86.Popcnt.PopCount(Mask);
            }
        }

        public void GetRegisters(out Operand.Register[] res)
        {
            res = new Operand.Register[Count];

            var idx = 0;
            for (int i = 0; i < MaxRegisters; i++)
            {
                if ((Mask & (1u << i)) != 0)
                {
#if _X64_
                    var regId = Registers.Id.Rax + i;
#else
                    var regId = Registers.Id.Eax + i;
#endif
                    res[idx] = Operands.Reg(regId);
                    idx++;
                }
            }
        }

        public Registers.Id[] GetRegisters()
        {
            var res = new Registers.Id[Count];

            var idx = 0;
            for (int i = 0; i < 32; i++)
            {
                if ((Mask & (1u << i)) != 0)
                {
#if _X64_
                    var regId = Registers.Id.Rax + i;
#else
                    var regId = Registers.Id.Eax + i;
#endif
                    res[idx] = regId;
                    idx++;
                }
            }
            return res;
        }

        public RegisterMaskType Value()
        {
            return Mask;
        }

        public static RegisterMaskGp operator &(RegisterMaskGp left, RegisterMaskGp right)
        {
            return new() { Mask = (RegisterMaskType)(left.Mask & right.Mask) };
        }

        public static RegisterMaskGp operator |(RegisterMaskGp left, RegisterMaskGp right)
        {
            return new() { Mask = (RegisterMaskType)(left.Mask | right.Mask) };
        }

        public static RegisterMaskGp operator ^(RegisterMaskGp left, RegisterMaskGp right)
        {
            return new() { Mask = (RegisterMaskType)(left.Mask ^ right.Mask) };
        }

        public static RegisterMaskGp operator ~(RegisterMaskGp left)
        {
            return new() { Mask = (RegisterMaskType)~left.Mask };
        }
    }
}

```

`src/Dotx64Managed/API/Assembler.Instructions.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    public partial class Assembler
    {
        //! \name Base Instructions & Operand.OpReg Extensions
        public Assembler Adc(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Adc, a, b);
        public Assembler Adc(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Adc, a, b);
        public Assembler Adc(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Adc, a, b);
        public Assembler Adc(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Adc, a, b);
        public Assembler Adc(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Adc, a, b);
        public Assembler Add(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Add, a, b);
        public Assembler Add(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Add, a, b);
        public Assembler Add(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Add, a, b);
        public Assembler Add(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Add, a, b);
        public Assembler Add(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Add, a, b);
        public Assembler And(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.And, a, b);
        public Assembler And(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.And, a, b);
        public Assembler And(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.And, a, b);
        public Assembler And(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.And, a, b);
        public Assembler And(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.And, a, b);
        public Assembler Arpl(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Arpl, a, b);
        public Assembler Arpl(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Arpl, a, b);
        public Assembler Bound(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Bound, a, b);
        public Assembler Bsf(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Bsf, a, b);
        public Assembler Bsf(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Bsf, a, b);
        public Assembler Bsr(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Bsr, a, b);
        public Assembler Bsr(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Bsr, a, b);
        public Assembler Bswap(Operand.Register a) => CreateInstr(Mnemonic.Bswap, a);
        public Assembler Bt(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Bt, a, b);
        public Assembler Bt(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Bt, a, b);
        public Assembler Bt(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Bt, a, b);
        public Assembler Bt(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Bt, a, b);
        public Assembler Btc(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Btc, a, b);
        public Assembler Btc(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Btc, a, b);
        public Assembler Btc(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Btc, a, b);
        public Assembler Btc(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Btc, a, b);
        public Assembler Btr(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Btr, a, b);
        public Assembler Btr(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Btr, a, b);
        public Assembler Btr(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Btr, a, b);
        public Assembler Btr(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Btr, a, b);
        public Assembler Bts(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Bts, a, b);
        public Assembler Bts(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Bts, a, b);
        public Assembler Bts(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Bts, a, b);
        public Assembler Bts(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Bts, a, b);
        public Assembler Clc() => CreateInstr(Mnemonic.Clc);
        public Assembler Cld() => CreateInstr(Mnemonic.Cld);
        public Assembler Cli() => CreateInstr(Mnemonic.Cli);
        public Assembler Clts() => CreateInstr(Mnemonic.Clts);
        public Assembler Cmc() => CreateInstr(Mnemonic.Cmc);
        public Assembler Cmp(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cmp, a, b);
        public Assembler Cmp(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cmp, a, b);
        public Assembler Cmp(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Cmp, a, b);
        public Assembler Cmp(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Cmp, a, b);
        public Assembler Cmp(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Cmp, a, b);
        public Assembler Dec(Operand.Register a) => CreateInstr(Mnemonic.Dec, a);
        public Assembler Dec(Operand.Memory a) => CreateInstr(Mnemonic.Dec, a);
        public Assembler Emms() => CreateInstr(Mnemonic.Emms);
        public Assembler Enter(Operand.Immediate a, Operand.Immediate b) => CreateInstr(Mnemonic.Enter, a, b);
        public Assembler Hlt() => CreateInstr(Mnemonic.Hlt);
        public Assembler Imul(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Imul, a, b);
        public Assembler Imul(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Imul, a, b, c);
        public Assembler Imul(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Imul, a, b, c);
        public Assembler Inc(Operand.Register a) => CreateInstr(Mnemonic.Inc, a);
        public Assembler Inc(Operand.Memory a) => CreateInstr(Mnemonic.Inc, a);
        public Assembler Insb() => CreateInstr(Mnemonic.Insb);
        public Assembler Insw() => CreateInstr(Mnemonic.Insw);
        public Assembler Insd() => CreateInstr(Mnemonic.Insd);
        public Assembler Int(Operand.Immediate a) => CreateInstr(Mnemonic.Int, a);
        public Assembler Int3() => CreateInstr(Mnemonic.Int3);
        public Assembler Into() => CreateInstr(Mnemonic.Into);
        public Assembler Invd() => CreateInstr(Mnemonic.Invd);
        public Assembler Invlpg(Operand.Memory a) => CreateInstr(Mnemonic.Invlpg, a);
        public Assembler Invpcid(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Invpcid, a, b);

        public Assembler Lar(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Lar, a, b);
        public Assembler Lar(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Lar, a, b);
        public Assembler Ldmxcsr(Operand.Memory a) => CreateInstr(Mnemonic.Ldmxcsr, a);
        public Assembler Lds(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Lds, a, b);
        public Assembler Lea(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Lea, a, b);
        public Assembler Leave() => CreateInstr(Mnemonic.Leave);
        public Assembler Les(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Les, a, b);
        public Assembler Lfence() => CreateInstr(Mnemonic.Lfence);
        public Assembler Lfs(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Lfs, a, b);
        public Assembler Lgdt(Operand.Memory a) => CreateInstr(Mnemonic.Lgdt, a);
        public Assembler Lgs(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Lgs, a, b);
        public Assembler Lidt(Operand.Memory a) => CreateInstr(Mnemonic.Lidt, a);
        public Assembler Lldt(Operand.Register a) => CreateInstr(Mnemonic.Lldt, a);
        public Assembler Lldt(Operand.Memory a) => CreateInstr(Mnemonic.Lldt, a);
        public Assembler Lmsw(Operand.Register a) => CreateInstr(Mnemonic.Lmsw, a);
        public Assembler Lmsw(Operand.Memory a) => CreateInstr(Mnemonic.Lmsw, a);
        public Assembler Lsl(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Lsl, a, b);
        public Assembler Lsl(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Lsl, a, b);
        public Assembler Lss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Lss, a, b);
        public Assembler Ltr(Operand.Register a) => CreateInstr(Mnemonic.Ltr, a);
        public Assembler Ltr(Operand.Memory a) => CreateInstr(Mnemonic.Ltr, a);
        public Assembler Mfence() => CreateInstr(Mnemonic.Mfence);
        public Assembler Mov(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Mov, a, b);
        public Assembler Mov(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Mov, a, b);
        public Assembler Mov(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Mov, a, b);
        public Assembler Mov(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Mov, a, b);
        public Assembler Mov(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Mov, a, b);
        public Assembler Movnti(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movnti, a, b);
        public Assembler Movsx(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movsx, a, b);
        public Assembler Movsx(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movsx, a, b);
        public Assembler Movsxd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movsxd, a, b);
        public Assembler Movsxd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movsxd, a, b);
        public Assembler Movzx(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movzx, a, b);
        public Assembler Movzx(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movzx, a, b);
        public Assembler Neg(Operand.Register a) => CreateInstr(Mnemonic.Neg, a);
        public Assembler Neg(Operand.Memory a) => CreateInstr(Mnemonic.Neg, a);
        public Assembler Nop() => CreateInstr(Mnemonic.Nop);
        public Assembler Nop(Operand.Register a) => CreateInstr(Mnemonic.Nop, a);
        public Assembler Nop(Operand.Memory a) => CreateInstr(Mnemonic.Nop, a);
        public Assembler Not(Operand.Register a) => CreateInstr(Mnemonic.Not, a);
        public Assembler Not(Operand.Memory a) => CreateInstr(Mnemonic.Not, a);
        public Assembler Or(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Or, a, b);
        public Assembler Or(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Or, a, b);
        public Assembler Or(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Or, a, b);
        public Assembler Or(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Or, a, b);
        public Assembler Or(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Or, a, b);
        public Assembler Out(Operand.Immediate a) => CreateInstr(Mnemonic.Out, a);
        public Assembler Out() => CreateInstr(Mnemonic.Out);
        public Assembler Outsb() => CreateInstr(Mnemonic.Outsb);
        public Assembler Outsw() => CreateInstr(Mnemonic.Outsw);
        public Assembler Outsd() => CreateInstr(Mnemonic.Outsd);
        public Assembler Pause() => CreateInstr(Mnemonic.Pause);
        public Assembler Pop(Operand.Register a) => CreateInstr(Mnemonic.Pop, a);
        public Assembler Pop(Operand.Memory a) => CreateInstr(Mnemonic.Pop, a);
        public Assembler Popa() => CreateInstr(Mnemonic.Popa);
        public Assembler Popad() => CreateInstr(Mnemonic.Popad);
        public Assembler Popf() => CreateInstr(Mnemonic.Popf);
        public Assembler Popfd() => CreateInstr(Mnemonic.Popfd);
        public Assembler Popfq() => CreateInstr(Mnemonic.Popfq);
        public Assembler Prefetch(Operand.Memory a) => CreateInstr(Mnemonic.Prefetch, a);
        public Assembler Prefetchnta(Operand.Memory a) => CreateInstr(Mnemonic.Prefetchnta, a);
        public Assembler Prefetcht0(Operand.Memory a) => CreateInstr(Mnemonic.Prefetcht0, a);
        public Assembler Prefetcht1(Operand.Memory a) => CreateInstr(Mnemonic.Prefetcht1, a);
        public Assembler Prefetcht2(Operand.Memory a) => CreateInstr(Mnemonic.Prefetcht2, a);
        public Assembler Prefetchw(Operand.Memory a) => CreateInstr(Mnemonic.Prefetchw, a);
        public Assembler Prefetchwt1(Operand.Memory a) => CreateInstr(Mnemonic.Prefetchwt1, a);
        public Assembler Push(Operand.Register a) => CreateInstr(Mnemonic.Push, a);
        public Assembler Push(Operand.Memory a) => CreateInstr(Mnemonic.Push, a);
        public Assembler Push(Operand.Immediate a) => CreateInstr(Mnemonic.Push, a);
        public Assembler Pusha() => CreateInstr(Mnemonic.Pusha);
        public Assembler Pushad() => CreateInstr(Mnemonic.Pushad);
        public Assembler Pushf() => CreateInstr(Mnemonic.Pushf);
        public Assembler Pushfd() => CreateInstr(Mnemonic.Pushfd);
        public Assembler Pushfq() => CreateInstr(Mnemonic.Pushfq);
        public Assembler Rcl(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Rcl, a, b);
        public Assembler Rcl(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Rcl, a, b);
        public Assembler Rcr(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Rcr, a, b);
        public Assembler Rcr(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Rcr, a, b);
        public Assembler Rol(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Rol, a, b);
        public Assembler Rol(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Rol, a, b);
        public Assembler Ror(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Ror, a, b);
        public Assembler Ror(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Ror, a, b);
        public Assembler Rsm() => CreateInstr(Mnemonic.Rsm);
        public Assembler Sbb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sbb, a, b);
        public Assembler Sbb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sbb, a, b);
        public Assembler Sbb(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Sbb, a, b);
        public Assembler Sbb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Sbb, a, b);
        public Assembler Sbb(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Sbb, a, b);
        public Assembler Salc(Operand.Register a) => CreateInstr(Mnemonic.Salc, a);
        public Assembler Salc(Operand.Memory a) => CreateInstr(Mnemonic.Salc, a);
        public Assembler Salc(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Salc, a, b);
        public Assembler Salc(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Salc, a, b);
        public Assembler Sar(Operand.Register a) => CreateInstr(Mnemonic.Sar, a);
        public Assembler Sar(Operand.Memory a) => CreateInstr(Mnemonic.Sar, a);
        public Assembler Sar(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Sar, a, b);
        public Assembler Sar(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Sar, a, b);
        public Assembler Sfence() => CreateInstr(Mnemonic.Sfence);
        public Assembler Sgdt(Operand.Memory a) => CreateInstr(Mnemonic.Sgdt, a);
        public Assembler Shl(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Shl, a, b);
        public Assembler Shl(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Shl, a, b);
        public Assembler Shr(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Shr, a, b);
        public Assembler Shr(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Shr, a, b);
        public Assembler Shld(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Shld, a, b);
        public Assembler Shld(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Shld, a, b);
        public Assembler Shld(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Shld, a, b, c);
        public Assembler Shld(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Shld, a, b, c);
        public Assembler Shrd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Shrd, a, b);
        public Assembler Shrd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Shrd, a, b);
        public Assembler Shrd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Shrd, a, b, c);
        public Assembler Shrd(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Shrd, a, b, c);
        public Assembler Sidt(Operand.Memory a) => CreateInstr(Mnemonic.Sidt, a);
        public Assembler Sldt(Operand.Register a) => CreateInstr(Mnemonic.Sldt, a);
        public Assembler Sldt(Operand.Memory a) => CreateInstr(Mnemonic.Sldt, a);
        public Assembler Smsw(Operand.Register a) => CreateInstr(Mnemonic.Smsw, a);
        public Assembler Smsw(Operand.Memory a) => CreateInstr(Mnemonic.Smsw, a);
        public Assembler Stc() => CreateInstr(Mnemonic.Stc);
        public Assembler Std() => CreateInstr(Mnemonic.Std);
        public Assembler Sti() => CreateInstr(Mnemonic.Sti);
        public Assembler Stmxcsr(Operand.Memory a) => CreateInstr(Mnemonic.Stmxcsr, a);
        public Assembler Str(Operand.Register a) => CreateInstr(Mnemonic.Str, a);
        public Assembler Str(Operand.Memory a) => CreateInstr(Mnemonic.Str, a);
        public Assembler Sub(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sub, a, b);
        public Assembler Sub(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sub, a, b);
        public Assembler Sub(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Sub, a, b);
        public Assembler Sub(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Sub, a, b);
        public Assembler Sub(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Sub, a, b);
        public Assembler Swapgs() => CreateInstr(Mnemonic.Swapgs);
        public Assembler Test(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Test, a, b);
        public Assembler Test(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Test, a, b);
        public Assembler Test(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Test, a, b);
        public Assembler Test(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Test, a, b);
        public Assembler Ud2() => CreateInstr(Mnemonic.Ud2);
        public Assembler Verr(Operand.Register a) => CreateInstr(Mnemonic.Verr, a);
        public Assembler Verr(Operand.Memory a) => CreateInstr(Mnemonic.Verr, a);
        public Assembler Verw(Operand.Register a) => CreateInstr(Mnemonic.Verw, a);
        public Assembler Verw(Operand.Memory a) => CreateInstr(Mnemonic.Verw, a);
        public Assembler Xadd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Xadd, a, b);
        public Assembler Xadd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Xadd, a, b);
        public Assembler Xchg(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Xchg, a, b);
        public Assembler Xchg(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Xchg, a, b);
        public Assembler Xchg(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Xchg, a, b);
        public Assembler Xor(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Xor, a, b);
        public Assembler Xor(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Xor, a, b);
        public Assembler Xor(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Xor, a, b);
        public Assembler Xor(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Xor, a, b);
        public Assembler Xor(Operand.Memory a, Operand.Immediate b) => CreateInstr(Mnemonic.Xor, a, b);
        //! \name ADX Instructions
        public Assembler Adcx(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Adcx, a, b);
        public Assembler Adcx(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Adcx, a, b);
        public Assembler Adox(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Adox, a, b);
        public Assembler Adox(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Adox, a, b);
        public Assembler Andn(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Andn, a, b, c);
        public Assembler Andn(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Andn, a, b, c);
        public Assembler Bextr(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Bextr, a, b, c);
        public Assembler Bextr(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Bextr, a, b, c);
        public Assembler Blsi(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blsi, a, b);
        public Assembler Blsi(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blsi, a, b);
        public Assembler Blsmsk(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blsmsk, a, b);
        public Assembler Blsmsk(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blsmsk, a, b);
        public Assembler Blsr(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blsr, a, b);
        public Assembler Blsr(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blsr, a, b);
        public Assembler Tzcnt(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Tzcnt, a, b);
        public Assembler Tzcnt(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Tzcnt, a, b);
        public Assembler Bzhi(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Bzhi, a, b, c);
        public Assembler Bzhi(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Bzhi, a, b, c);
        public Assembler Pdep(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Pdep, a, b, c);
        public Assembler Pdep(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Pdep, a, b, c);
        public Assembler Pext(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Pext, a, b, c);
        public Assembler Pext(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Pext, a, b, c);
        public Assembler Rorx(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Rorx, a, b, c);
        public Assembler Rorx(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Rorx, a, b, c);
        public Assembler Sarx(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Sarx, a, b, c);
        public Assembler Sarx(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Sarx, a, b, c);
        public Assembler Shlx(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Shlx, a, b, c);
        public Assembler Shlx(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Shlx, a, b, c);
        public Assembler Shrx(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Shrx, a, b, c);
        public Assembler Shrx(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Shrx, a, b, c);
        public Assembler Cldemote(Operand.Memory a) => CreateInstr(Mnemonic.Cldemote, a);
        public Assembler Clflush(Operand.Memory a) => CreateInstr(Mnemonic.Clflush, a);
        public Assembler Clflushopt(Operand.Memory a) => CreateInstr(Mnemonic.Clflushopt, a);
        public Assembler Clwb(Operand.Memory a) => CreateInstr(Mnemonic.Clwb, a);
        public Assembler Crc32(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Crc32, a, b);
        public Assembler Crc32(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Crc32, a, b);
        public Assembler Enqcmd(Operand.Memory a, Operand.Memory b) => CreateInstr(Mnemonic.Enqcmd, a, b);
        public Assembler Enqcmds(Operand.Memory a, Operand.Memory b) => CreateInstr(Mnemonic.Enqcmds, a, b);
        public Assembler Rdfsbase(Operand.Register a) => CreateInstr(Mnemonic.Rdfsbase, a);
        public Assembler Rdgsbase(Operand.Register a) => CreateInstr(Mnemonic.Rdgsbase, a);
        public Assembler Wrfsbase(Operand.Register a) => CreateInstr(Mnemonic.Wrfsbase, a);
        public Assembler Wrgsbase(Operand.Register a) => CreateInstr(Mnemonic.Wrgsbase, a);
        public Assembler Fxrstor(Operand.Memory a) => CreateInstr(Mnemonic.Fxrstor, a);
        public Assembler Fxrstor64(Operand.Memory a) => CreateInstr(Mnemonic.Fxrstor64, a);
        public Assembler Fxsave(Operand.Memory a) => CreateInstr(Mnemonic.Fxsave, a);
        public Assembler Fxsave64(Operand.Memory a) => CreateInstr(Mnemonic.Fxsave64, a);
        public Assembler Llwpcb(Operand.Register a) => CreateInstr(Mnemonic.Llwpcb, a);
        public Assembler Lwpins(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Lwpins, a, b, c);
        public Assembler Lwpins(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Lwpins, a, b, c);
        public Assembler Lwpval(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Lwpval, a, b, c);
        public Assembler Lwpval(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Lwpval, a, b, c);
        public Assembler Slwpcb(Operand.Register a) => CreateInstr(Mnemonic.Slwpcb, a);
        public Assembler Lzcnt(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Lzcnt, a, b);
        public Assembler Lzcnt(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Lzcnt, a, b);
        public Assembler Movbe(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movbe, a, b);
        public Assembler Movbe(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movbe, a, b);
        public Assembler Movdiri(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movdiri, a, b);
        public Assembler Movdir64b(Operand.Memory a, Operand.Memory b) => CreateInstr(Mnemonic.Movdir64b, a, b);
        public Assembler Bndcl(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Bndcl, a, b);
        public Assembler Bndcl(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Bndcl, a, b);
        public Assembler Bndcn(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Bndcn, a, b);
        public Assembler Bndcn(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Bndcn, a, b);
        public Assembler Bndcu(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Bndcu, a, b);
        public Assembler Bndcu(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Bndcu, a, b);
        public Assembler Bndldx(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Bndldx, a, b);
        public Assembler Bndmk(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Bndmk, a, b);
        public Assembler Bndmov(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Bndmov, a, b);
        public Assembler Bndmov(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Bndmov, a, b);
        public Assembler Bndmov(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Bndmov, a, b);
        public Assembler Bndstx(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Bndstx, a, b);
        public Assembler Popcnt(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Popcnt, a, b);
        public Assembler Popcnt(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Popcnt, a, b);
        public Assembler Rdrand(Operand.Register a) => CreateInstr(Mnemonic.Rdrand, a);
        public Assembler Rdseed(Operand.Register a) => CreateInstr(Mnemonic.Rdseed, a);
        public Assembler Xabort() => CreateInstr(Mnemonic.Xabort);
        public Assembler Xbegin(Operand.Immediate a) => CreateInstr(Mnemonic.Xbegin, a);
        public Assembler Xend() => CreateInstr(Mnemonic.Xend);
        public Assembler Xtest() => CreateInstr(Mnemonic.Xtest);
        public Assembler Clac() => CreateInstr(Mnemonic.Clac);
        public Assembler Stac() => CreateInstr(Mnemonic.Stac);
        public Assembler Clgi() => CreateInstr(Mnemonic.Clgi);
        public Assembler Stgi() => CreateInstr(Mnemonic.Stgi);
        public Assembler Vmmcall() => CreateInstr(Mnemonic.Vmmcall);
        public Assembler Blcfill(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blcfill, a, b);
        public Assembler Blcfill(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blcfill, a, b);
        public Assembler Blci(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blci, a, b);
        public Assembler Blci(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blci, a, b);
        public Assembler Blcic(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blcic, a, b);
        public Assembler Blcic(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blcic, a, b);
        public Assembler Blcmsk(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blcmsk, a, b);
        public Assembler Blcmsk(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blcmsk, a, b);
        public Assembler Blcs(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blcs, a, b);
        public Assembler Blcs(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blcs, a, b);
        public Assembler Blsfill(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blsfill, a, b);
        public Assembler Blsfill(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blsfill, a, b);
        public Assembler Blsic(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blsic, a, b);
        public Assembler Blsic(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blsic, a, b);
        public Assembler T1mskc(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.T1mskc, a, b);
        public Assembler T1mskc(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.T1mskc, a, b);
        public Assembler Tzmsk(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Tzmsk, a, b);
        public Assembler Tzmsk(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Tzmsk, a, b);
        public Assembler Invept(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Invept, a, b);
        public Assembler Invvpid(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Invvpid, a, b);
        public Assembler Vmcall() => CreateInstr(Mnemonic.Vmcall);
        public Assembler Vmclear(Operand.Memory a) => CreateInstr(Mnemonic.Vmclear, a);
        public Assembler Vmfunc() => CreateInstr(Mnemonic.Vmfunc);
        public Assembler Vmlaunch() => CreateInstr(Mnemonic.Vmlaunch);
        public Assembler Vmptrld(Operand.Memory a) => CreateInstr(Mnemonic.Vmptrld, a);
        public Assembler Vmptrst(Operand.Memory a) => CreateInstr(Mnemonic.Vmptrst, a);
        public Assembler Vmread(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmread, a, b);
        public Assembler Vmresume() => CreateInstr(Mnemonic.Vmresume);
        public Assembler Vmwrite(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmwrite, a, b);
        public Assembler Vmxon(Operand.Memory a) => CreateInstr(Mnemonic.Vmxon, a);
        public Assembler Getsec() => CreateInstr(Mnemonic.Getsec);
        public Assembler Rdpid(Operand.Register a) => CreateInstr(Mnemonic.Rdpid, a);
        public Assembler F2xm1() => CreateInstr(Mnemonic.F2xm1);
        public Assembler Fabs() => CreateInstr(Mnemonic.Fabs);
        public Assembler Fadd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Fadd, a, b);
        public Assembler Fadd(Operand.Memory a) => CreateInstr(Mnemonic.Fadd, a);
        public Assembler Faddp(Operand.Register a) => CreateInstr(Mnemonic.Faddp, a);
        public Assembler Faddp() => CreateInstr(Mnemonic.Faddp);
        public Assembler Fbld(Operand.Memory a) => CreateInstr(Mnemonic.Fbld, a);
        public Assembler Fbstp(Operand.Memory a) => CreateInstr(Mnemonic.Fbstp, a);
        public Assembler Fchs() => CreateInstr(Mnemonic.Fchs);
        public Assembler Fcmovb(Operand.Register a) => CreateInstr(Mnemonic.Fcmovb, a);
        public Assembler Fcmovbe(Operand.Register a) => CreateInstr(Mnemonic.Fcmovbe, a);
        public Assembler Fcmove(Operand.Register a) => CreateInstr(Mnemonic.Fcmove, a);
        public Assembler Fcmovnb(Operand.Register a) => CreateInstr(Mnemonic.Fcmovnb, a);
        public Assembler Fcmovnbe(Operand.Register a) => CreateInstr(Mnemonic.Fcmovnbe, a);
        public Assembler Fcmovne(Operand.Register a) => CreateInstr(Mnemonic.Fcmovne, a);
        public Assembler Fcmovnu(Operand.Register a) => CreateInstr(Mnemonic.Fcmovnu, a);
        public Assembler Fcmovu(Operand.Register a) => CreateInstr(Mnemonic.Fcmovu, a);
        public Assembler Fcom(Operand.Register a) => CreateInstr(Mnemonic.Fcom, a);
        public Assembler Fcom() => CreateInstr(Mnemonic.Fcom);
        public Assembler Fcom(Operand.Memory a) => CreateInstr(Mnemonic.Fcom, a);
        public Assembler Fcomp(Operand.Register a) => CreateInstr(Mnemonic.Fcomp, a);
        public Assembler Fcomp() => CreateInstr(Mnemonic.Fcomp);
        public Assembler Fcomp(Operand.Memory a) => CreateInstr(Mnemonic.Fcomp, a);
        public Assembler Fcompp() => CreateInstr(Mnemonic.Fcompp);
        public Assembler Fcomi(Operand.Register a) => CreateInstr(Mnemonic.Fcomi, a);
        public Assembler Fcomip(Operand.Register a) => CreateInstr(Mnemonic.Fcomip, a);
        public Assembler Fcos() => CreateInstr(Mnemonic.Fcos);
        public Assembler Fdecstp() => CreateInstr(Mnemonic.Fdecstp);
        public Assembler Fdiv(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Fdiv, a, b);
        public Assembler Fdiv(Operand.Memory a) => CreateInstr(Mnemonic.Fdiv, a);
        public Assembler Fdivp(Operand.Register a) => CreateInstr(Mnemonic.Fdivp, a);
        public Assembler Fdivp() => CreateInstr(Mnemonic.Fdivp);
        public Assembler Fdivr(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Fdivr, a, b);
        public Assembler Fdivr(Operand.Memory a) => CreateInstr(Mnemonic.Fdivr, a);
        public Assembler Fdivrp(Operand.Register a) => CreateInstr(Mnemonic.Fdivrp, a);
        public Assembler Fdivrp() => CreateInstr(Mnemonic.Fdivrp);
        public Assembler Ffree(Operand.Register a) => CreateInstr(Mnemonic.Ffree, a);
        public Assembler Fiadd(Operand.Memory a) => CreateInstr(Mnemonic.Fiadd, a);
        public Assembler Ficom(Operand.Memory a) => CreateInstr(Mnemonic.Ficom, a);
        public Assembler Ficomp(Operand.Memory a) => CreateInstr(Mnemonic.Ficomp, a);
        public Assembler Fidiv(Operand.Memory a) => CreateInstr(Mnemonic.Fidiv, a);
        public Assembler Fidivr(Operand.Memory a) => CreateInstr(Mnemonic.Fidivr, a);
        public Assembler Fild(Operand.Memory a) => CreateInstr(Mnemonic.Fild, a);
        public Assembler Fimul(Operand.Memory a) => CreateInstr(Mnemonic.Fimul, a);
        public Assembler Fincstp() => CreateInstr(Mnemonic.Fincstp);
        public Assembler Fisub(Operand.Memory a) => CreateInstr(Mnemonic.Fisub, a);
        public Assembler Fisubr(Operand.Memory a) => CreateInstr(Mnemonic.Fisubr, a);
        public Assembler Fninit() => CreateInstr(Mnemonic.Fninit);
        public Assembler Fist(Operand.Memory a) => CreateInstr(Mnemonic.Fist, a);
        public Assembler Fistp(Operand.Memory a) => CreateInstr(Mnemonic.Fistp, a);
        public Assembler Fisttp(Operand.Memory a) => CreateInstr(Mnemonic.Fisttp, a);
        public Assembler Fld(Operand.Memory a) => CreateInstr(Mnemonic.Fld, a);
        public Assembler Fld(Operand.Register a) => CreateInstr(Mnemonic.Fld, a);
        public Assembler Fld1() => CreateInstr(Mnemonic.Fld1);
        public Assembler Fldl2t() => CreateInstr(Mnemonic.Fldl2t);
        public Assembler Fldl2e() => CreateInstr(Mnemonic.Fldl2e);
        public Assembler Fldpi() => CreateInstr(Mnemonic.Fldpi);
        public Assembler Fldlg2() => CreateInstr(Mnemonic.Fldlg2);
        public Assembler Fldln2() => CreateInstr(Mnemonic.Fldln2);
        public Assembler Fldz() => CreateInstr(Mnemonic.Fldz);
        public Assembler Fldcw(Operand.Memory a) => CreateInstr(Mnemonic.Fldcw, a);
        public Assembler Fldenv(Operand.Memory a) => CreateInstr(Mnemonic.Fldenv, a);
        public Assembler Fmul(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Fmul, a, b);
        public Assembler Fmul(Operand.Memory a) => CreateInstr(Mnemonic.Fmul, a);
        public Assembler Fmulp(Operand.Register a) => CreateInstr(Mnemonic.Fmulp, a);
        public Assembler Fmulp() => CreateInstr(Mnemonic.Fmulp);
        public Assembler Fnclex() => CreateInstr(Mnemonic.Fnclex);
        public Assembler Fnop() => CreateInstr(Mnemonic.Fnop);
        public Assembler Fnsave(Operand.Memory a) => CreateInstr(Mnemonic.Fnsave, a);
        public Assembler Fnstenv(Operand.Memory a) => CreateInstr(Mnemonic.Fnstenv, a);
        public Assembler Fnstcw(Operand.Memory a) => CreateInstr(Mnemonic.Fnstcw, a);
        public Assembler Fpatan() => CreateInstr(Mnemonic.Fpatan);
        public Assembler Fprem() => CreateInstr(Mnemonic.Fprem);
        public Assembler Fprem1() => CreateInstr(Mnemonic.Fprem1);
        public Assembler Fptan() => CreateInstr(Mnemonic.Fptan);
        public Assembler Frndint() => CreateInstr(Mnemonic.Frndint);
        public Assembler Frstor(Operand.Memory a) => CreateInstr(Mnemonic.Frstor, a);
        public Assembler Fscale() => CreateInstr(Mnemonic.Fscale);
        public Assembler Fsin() => CreateInstr(Mnemonic.Fsin);
        public Assembler Fsincos() => CreateInstr(Mnemonic.Fsincos);
        public Assembler Fsqrt() => CreateInstr(Mnemonic.Fsqrt);
        public Assembler Fst(Operand.Memory a) => CreateInstr(Mnemonic.Fst, a);
        public Assembler Fst(Operand.Register a) => CreateInstr(Mnemonic.Fst, a);
        public Assembler Fstp(Operand.Memory a) => CreateInstr(Mnemonic.Fstp, a);
        public Assembler Fstp(Operand.Register a) => CreateInstr(Mnemonic.Fstp, a);
        public Assembler Fsub(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Fsub, a, b);
        public Assembler Fsub(Operand.Memory a) => CreateInstr(Mnemonic.Fsub, a);
        public Assembler Fsubp(Operand.Register a) => CreateInstr(Mnemonic.Fsubp, a);
        public Assembler Fsubp() => CreateInstr(Mnemonic.Fsubp);
        public Assembler Fsubr(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Fsubr, a, b);
        public Assembler Fsubr(Operand.Memory a) => CreateInstr(Mnemonic.Fsubr, a);
        public Assembler Fsubrp(Operand.Register a) => CreateInstr(Mnemonic.Fsubrp, a);
        public Assembler Fsubrp() => CreateInstr(Mnemonic.Fsubrp);
        public Assembler Ftst() => CreateInstr(Mnemonic.Ftst);
        public Assembler Fucom(Operand.Register a) => CreateInstr(Mnemonic.Fucom, a);
        public Assembler Fucom() => CreateInstr(Mnemonic.Fucom);
        public Assembler Fucomi(Operand.Register a) => CreateInstr(Mnemonic.Fucomi, a);
        public Assembler Fucomip(Operand.Register a) => CreateInstr(Mnemonic.Fucomip, a);
        public Assembler Fucomp(Operand.Register a) => CreateInstr(Mnemonic.Fucomp, a);
        public Assembler Fucomp() => CreateInstr(Mnemonic.Fucomp);
        public Assembler Fucompp() => CreateInstr(Mnemonic.Fucompp);
        public Assembler Fwait() => CreateInstr(Mnemonic.Fwait);
        public Assembler Fxam() => CreateInstr(Mnemonic.Fxam);
        public Assembler Fxch(Operand.Register a) => CreateInstr(Mnemonic.Fxch, a);
        public Assembler Fxtract() => CreateInstr(Mnemonic.Fxtract);
        public Assembler Fyl2x() => CreateInstr(Mnemonic.Fyl2x);
        public Assembler Fyl2xp1() => CreateInstr(Mnemonic.Fyl2xp1);
        public Assembler Fnstsw(Operand.Register a) => CreateInstr(Mnemonic.Fnstsw, a);
        public Assembler Fnstsw(Operand.Memory a) => CreateInstr(Mnemonic.Fnstsw, a);
        public Assembler Addpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Addpd, a, b);
        public Assembler Addpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Addpd, a, b);
        public Assembler Addps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Addps, a, b);
        public Assembler Addps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Addps, a, b);
        public Assembler Addsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Addsd, a, b);
        public Assembler Addsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Addsd, a, b);
        public Assembler Addss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Addss, a, b);
        public Assembler Addss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Addss, a, b);
        public Assembler Addsubpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Addsubpd, a, b);
        public Assembler Addsubpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Addsubpd, a, b);
        public Assembler Addsubps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Addsubps, a, b);
        public Assembler Addsubps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Addsubps, a, b);
        public Assembler Andnpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Andnpd, a, b);
        public Assembler Andnpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Andnpd, a, b);
        public Assembler Andnps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Andnps, a, b);
        public Assembler Andnps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Andnps, a, b);
        public Assembler Andpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Andpd, a, b);
        public Assembler Andpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Andpd, a, b);
        public Assembler Andps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Andps, a, b);
        public Assembler Andps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Andps, a, b);
        public Assembler Blendpd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Blendpd, a, b, c);
        public Assembler Blendpd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Blendpd, a, b, c);
        public Assembler Blendps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Blendps, a, b, c);
        public Assembler Blendps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Blendps, a, b, c);
        public Assembler Cmppd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Cmppd, a, b, c);
        public Assembler Cmppd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Cmppd, a, b, c);
        public Assembler Cmpps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Cmpps, a, b, c);
        public Assembler Cmpps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Cmpps, a, b, c);
        public Assembler Cmpsd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Cmpsd, a, b, c);
        public Assembler Cmpsd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Cmpsd, a, b, c);
        public Assembler Cmpss(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Cmpss, a, b, c);
        public Assembler Cmpss(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Cmpss, a, b, c);
        public Assembler Comisd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Comisd, a, b);
        public Assembler Comisd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Comisd, a, b);
        public Assembler Comiss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Comiss, a, b);
        public Assembler Comiss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Comiss, a, b);
        public Assembler Cvtdq2pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtdq2pd, a, b);
        public Assembler Cvtdq2pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtdq2pd, a, b);
        public Assembler Cvtdq2ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtdq2ps, a, b);
        public Assembler Cvtdq2ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtdq2ps, a, b);
        public Assembler Cvtpd2dq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtpd2dq, a, b);
        public Assembler Cvtpd2dq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtpd2dq, a, b);
        public Assembler Cvtpd2pi(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtpd2pi, a, b);
        public Assembler Cvtpd2pi(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtpd2pi, a, b);
        public Assembler Cvtpd2ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtpd2ps, a, b);
        public Assembler Cvtpd2ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtpd2ps, a, b);
        public Assembler Cvtpi2pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtpi2pd, a, b);
        public Assembler Cvtpi2pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtpi2pd, a, b);
        public Assembler Cvtpi2ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtpi2ps, a, b);
        public Assembler Cvtpi2ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtpi2ps, a, b);
        public Assembler Cvtps2dq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtps2dq, a, b);
        public Assembler Cvtps2dq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtps2dq, a, b);
        public Assembler Cvtps2pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtps2pd, a, b);
        public Assembler Cvtps2pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtps2pd, a, b);
        public Assembler Cvtps2pi(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtps2pi, a, b);
        public Assembler Cvtps2pi(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtps2pi, a, b);
        public Assembler Cvtsd2si(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtsd2si, a, b);
        public Assembler Cvtsd2si(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtsd2si, a, b);
        public Assembler Cvtsd2ss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtsd2ss, a, b);
        public Assembler Cvtsd2ss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtsd2ss, a, b);
        public Assembler Cvtsi2sd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtsi2sd, a, b);
        public Assembler Cvtsi2sd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtsi2sd, a, b);
        public Assembler Cvtsi2ss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtsi2ss, a, b);
        public Assembler Cvtsi2ss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtsi2ss, a, b);
        public Assembler Cvtss2sd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtss2sd, a, b);
        public Assembler Cvtss2sd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtss2sd, a, b);
        public Assembler Cvtss2si(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvtss2si, a, b);
        public Assembler Cvtss2si(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvtss2si, a, b);
        public Assembler Cvttpd2pi(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvttpd2pi, a, b);
        public Assembler Cvttpd2pi(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvttpd2pi, a, b);
        public Assembler Cvttpd2dq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvttpd2dq, a, b);
        public Assembler Cvttpd2dq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvttpd2dq, a, b);
        public Assembler Cvttps2dq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvttps2dq, a, b);
        public Assembler Cvttps2dq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvttps2dq, a, b);
        public Assembler Cvttps2pi(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvttps2pi, a, b);
        public Assembler Cvttps2pi(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvttps2pi, a, b);
        public Assembler Cvttsd2si(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvttsd2si, a, b);
        public Assembler Cvttsd2si(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvttsd2si, a, b);
        public Assembler Cvttss2si(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cvttss2si, a, b);
        public Assembler Cvttss2si(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Cvttss2si, a, b);
        public Assembler Divpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Divpd, a, b);
        public Assembler Divpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Divpd, a, b);
        public Assembler Divps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Divps, a, b);
        public Assembler Divps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Divps, a, b);
        public Assembler Divsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Divsd, a, b);
        public Assembler Divsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Divsd, a, b);
        public Assembler Divss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Divss, a, b);
        public Assembler Divss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Divss, a, b);
        public Assembler Dppd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Dppd, a, b, c);
        public Assembler Dppd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Dppd, a, b, c);
        public Assembler Dpps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Dpps, a, b, c);
        public Assembler Dpps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Dpps, a, b, c);
        public Assembler Extractps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Extractps, a, b, c);
        public Assembler Extractps(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Extractps, a, b, c);
        public Assembler Extrq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Extrq, a, b);
        public Assembler Gf2p8affineinvqb(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Gf2p8affineinvqb, a, b, c);
        public Assembler Gf2p8affineinvqb(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Gf2p8affineinvqb, a, b, c);
        public Assembler Gf2p8affineqb(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Gf2p8affineqb, a, b, c);
        public Assembler Gf2p8affineqb(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Gf2p8affineqb, a, b, c);
        public Assembler Gf2p8mulb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Gf2p8mulb, a, b);
        public Assembler Gf2p8mulb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Gf2p8mulb, a, b);
        public Assembler Haddpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Haddpd, a, b);
        public Assembler Haddpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Haddpd, a, b);
        public Assembler Haddps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Haddps, a, b);
        public Assembler Haddps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Haddps, a, b);
        public Assembler Hsubpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Hsubpd, a, b);
        public Assembler Hsubpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Hsubpd, a, b);
        public Assembler Hsubps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Hsubps, a, b);
        public Assembler Hsubps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Hsubps, a, b);
        public Assembler Insertps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Insertps, a, b, c);
        public Assembler Insertps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Insertps, a, b, c);
        public Assembler Insertq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Insertq, a, b);
        public Assembler Lddqu(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Lddqu, a, b);
        public Assembler Maxpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Maxpd, a, b);
        public Assembler Maxpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Maxpd, a, b);
        public Assembler Maxps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Maxps, a, b);
        public Assembler Maxps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Maxps, a, b);
        public Assembler Maxsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Maxsd, a, b);
        public Assembler Maxsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Maxsd, a, b);
        public Assembler Maxss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Maxss, a, b);
        public Assembler Maxss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Maxss, a, b);
        public Assembler Minpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Minpd, a, b);
        public Assembler Minpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Minpd, a, b);
        public Assembler Minps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Minps, a, b);
        public Assembler Minps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Minps, a, b);
        public Assembler Minsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Minsd, a, b);
        public Assembler Minsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Minsd, a, b);
        public Assembler Minss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Minss, a, b);
        public Assembler Minss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Minss, a, b);
        public Assembler Movapd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movapd, a, b);
        public Assembler Movapd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movapd, a, b);
        public Assembler Movapd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movapd, a, b);
        public Assembler Movaps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movaps, a, b);
        public Assembler Movaps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movaps, a, b);
        public Assembler Movaps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movaps, a, b);
        public Assembler Movd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movd, a, b);
        public Assembler Movd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movd, a, b);
        public Assembler Movd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movd, a, b);
        public Assembler Movddup(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movddup, a, b);
        public Assembler Movddup(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movddup, a, b);
        public Assembler Movdq2q(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movdq2q, a, b);
        public Assembler Movdqa(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movdqa, a, b);
        public Assembler Movdqa(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movdqa, a, b);
        public Assembler Movdqa(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movdqa, a, b);
        public Assembler Movdqu(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movdqu, a, b);
        public Assembler Movdqu(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movdqu, a, b);
        public Assembler Movdqu(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movdqu, a, b);
        public Assembler Movhlps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movhlps, a, b);
        public Assembler Movhpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movhpd, a, b);
        public Assembler Movhpd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movhpd, a, b);
        public Assembler Movhps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movhps, a, b);
        public Assembler Movhps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movhps, a, b);
        public Assembler Movlhps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movlhps, a, b);
        public Assembler Movlpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movlpd, a, b);
        public Assembler Movlpd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movlpd, a, b);
        public Assembler Movlps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movlps, a, b);
        public Assembler Movlps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movlps, a, b);
        public Assembler Movmskps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movmskps, a, b);
        public Assembler Movmskpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movmskpd, a, b);
        public Assembler Movntdq(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movntdq, a, b);
        public Assembler Movntdqa(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movntdqa, a, b);
        public Assembler Movntpd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movntpd, a, b);
        public Assembler Movntps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movntps, a, b);
        public Assembler Movntsd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movntsd, a, b);
        public Assembler Movntss(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movntss, a, b);
        public Assembler Movntq(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movntq, a, b);
        public Assembler Movq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movq, a, b);
        public Assembler Movq(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movq, a, b);
        public Assembler Movq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movq, a, b);
        public Assembler Movq2dq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movq2dq, a, b);
        public Assembler Movsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movsd, a, b);
        public Assembler Movsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movsd, a, b);
        public Assembler Movsd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movsd, a, b);
        public Assembler Movshdup(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movshdup, a, b);
        public Assembler Movshdup(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movshdup, a, b);
        public Assembler Movsldup(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movsldup, a, b);
        public Assembler Movsldup(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movsldup, a, b);
        public Assembler Movss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movss, a, b);
        public Assembler Movss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movss, a, b);
        public Assembler Movss(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movss, a, b);
        public Assembler Movupd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movupd, a, b);
        public Assembler Movupd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movupd, a, b);
        public Assembler Movupd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movupd, a, b);
        public Assembler Movups(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Movups, a, b);
        public Assembler Movups(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Movups, a, b);
        public Assembler Movups(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Movups, a, b);
        public Assembler Mpsadbw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Mpsadbw, a, b, c);
        public Assembler Mpsadbw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Mpsadbw, a, b, c);
        public Assembler Mulpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Mulpd, a, b);
        public Assembler Mulpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Mulpd, a, b);
        public Assembler Mulps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Mulps, a, b);
        public Assembler Mulps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Mulps, a, b);
        public Assembler Mulsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Mulsd, a, b);
        public Assembler Mulsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Mulsd, a, b);
        public Assembler Mulss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Mulss, a, b);
        public Assembler Mulss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Mulss, a, b);
        public Assembler Orpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Orpd, a, b);
        public Assembler Orpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Orpd, a, b);
        public Assembler Orps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Orps, a, b);
        public Assembler Orps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Orps, a, b);
        public Assembler Packssdw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Packssdw, a, b);
        public Assembler Packssdw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Packssdw, a, b);
        public Assembler Packsswb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Packsswb, a, b);
        public Assembler Packsswb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Packsswb, a, b);
        public Assembler Packusdw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Packusdw, a, b);
        public Assembler Packusdw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Packusdw, a, b);
        public Assembler Packuswb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Packuswb, a, b);
        public Assembler Packuswb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Packuswb, a, b);
        public Assembler Pabsb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pabsb, a, b);
        public Assembler Pabsb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pabsb, a, b);
        public Assembler Pabsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pabsd, a, b);
        public Assembler Pabsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pabsd, a, b);
        public Assembler Pabsw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pabsw, a, b);
        public Assembler Pabsw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pabsw, a, b);
        public Assembler Paddb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Paddb, a, b);
        public Assembler Paddb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Paddb, a, b);
        public Assembler Paddd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Paddd, a, b);
        public Assembler Paddd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Paddd, a, b);
        public Assembler Paddq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Paddq, a, b);
        public Assembler Paddq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Paddq, a, b);
        public Assembler Paddsb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Paddsb, a, b);
        public Assembler Paddsb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Paddsb, a, b);
        public Assembler Paddsw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Paddsw, a, b);
        public Assembler Paddsw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Paddsw, a, b);
        public Assembler Paddusb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Paddusb, a, b);
        public Assembler Paddusb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Paddusb, a, b);
        public Assembler Paddusw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Paddusw, a, b);
        public Assembler Paddusw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Paddusw, a, b);
        public Assembler Paddw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Paddw, a, b);
        public Assembler Paddw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Paddw, a, b);
        public Assembler Palignr(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Palignr, a, b, c);
        public Assembler Palignr(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Palignr, a, b, c);
        public Assembler Pand(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pand, a, b);
        public Assembler Pand(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pand, a, b);
        public Assembler Pandn(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pandn, a, b);
        public Assembler Pandn(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pandn, a, b);
        public Assembler Pavgb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pavgb, a, b);
        public Assembler Pavgb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pavgb, a, b);
        public Assembler Pavgw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pavgw, a, b);
        public Assembler Pavgw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pavgw, a, b);
        public Assembler Pblendw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pblendw, a, b, c);
        public Assembler Pblendw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pblendw, a, b, c);
        public Assembler Pclmulqdq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pclmulqdq, a, b, c);
        public Assembler Pclmulqdq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pclmulqdq, a, b, c);
        public Assembler Pcmpeqb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pcmpeqb, a, b);
        public Assembler Pcmpeqb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pcmpeqb, a, b);
        public Assembler Pcmpeqd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pcmpeqd, a, b);
        public Assembler Pcmpeqd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pcmpeqd, a, b);
        public Assembler Pcmpeqq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pcmpeqq, a, b);
        public Assembler Pcmpeqq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pcmpeqq, a, b);
        public Assembler Pcmpeqw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pcmpeqw, a, b);
        public Assembler Pcmpeqw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pcmpeqw, a, b);
        public Assembler Pcmpgtb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pcmpgtb, a, b);
        public Assembler Pcmpgtb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pcmpgtb, a, b);
        public Assembler Pcmpgtd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pcmpgtd, a, b);
        public Assembler Pcmpgtd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pcmpgtd, a, b);
        public Assembler Pcmpgtq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pcmpgtq, a, b);
        public Assembler Pcmpgtq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pcmpgtq, a, b);
        public Assembler Pcmpgtw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pcmpgtw, a, b);
        public Assembler Pcmpgtw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pcmpgtw, a, b);
        public Assembler Pextrb(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pextrb, a, b, c);
        public Assembler Pextrb(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pextrb, a, b, c);
        public Assembler Pextrd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pextrd, a, b, c);
        public Assembler Pextrd(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pextrd, a, b, c);
        public Assembler Pextrq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pextrq, a, b, c);
        public Assembler Pextrq(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pextrq, a, b, c);
        public Assembler Pextrw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pextrw, a, b, c);
        public Assembler Pextrw(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pextrw, a, b, c);
        public Assembler Phaddd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Phaddd, a, b);
        public Assembler Phaddd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Phaddd, a, b);
        public Assembler Phaddsw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Phaddsw, a, b);
        public Assembler Phaddsw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Phaddsw, a, b);
        public Assembler Phaddw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Phaddw, a, b);
        public Assembler Phaddw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Phaddw, a, b);
        public Assembler Phminposuw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Phminposuw, a, b);
        public Assembler Phminposuw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Phminposuw, a, b);
        public Assembler Phsubd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Phsubd, a, b);
        public Assembler Phsubd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Phsubd, a, b);
        public Assembler Phsubsw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Phsubsw, a, b);
        public Assembler Phsubsw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Phsubsw, a, b);
        public Assembler Phsubw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Phsubw, a, b);
        public Assembler Phsubw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Phsubw, a, b);
        public Assembler Pinsrb(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pinsrb, a, b, c);
        public Assembler Pinsrb(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pinsrb, a, b, c);
        public Assembler Pinsrd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pinsrd, a, b, c);
        public Assembler Pinsrd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pinsrd, a, b, c);
        public Assembler Pinsrq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pinsrq, a, b, c);
        public Assembler Pinsrq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pinsrq, a, b, c);
        public Assembler Pinsrw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pinsrw, a, b, c);
        public Assembler Pinsrw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pinsrw, a, b, c);
        public Assembler Pmaddubsw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmaddubsw, a, b);
        public Assembler Pmaddubsw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmaddubsw, a, b);
        public Assembler Pmaddwd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmaddwd, a, b);
        public Assembler Pmaddwd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmaddwd, a, b);
        public Assembler Pmaxsb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmaxsb, a, b);
        public Assembler Pmaxsb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmaxsb, a, b);
        public Assembler Pmaxsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmaxsd, a, b);
        public Assembler Pmaxsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmaxsd, a, b);
        public Assembler Pmaxsw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmaxsw, a, b);
        public Assembler Pmaxsw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmaxsw, a, b);
        public Assembler Pmaxub(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmaxub, a, b);
        public Assembler Pmaxub(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmaxub, a, b);
        public Assembler Pmaxud(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmaxud, a, b);
        public Assembler Pmaxud(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmaxud, a, b);
        public Assembler Pmaxuw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmaxuw, a, b);
        public Assembler Pmaxuw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmaxuw, a, b);
        public Assembler Pminsb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pminsb, a, b);
        public Assembler Pminsb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pminsb, a, b);
        public Assembler Pminsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pminsd, a, b);
        public Assembler Pminsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pminsd, a, b);
        public Assembler Pminsw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pminsw, a, b);
        public Assembler Pminsw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pminsw, a, b);
        public Assembler Pminub(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pminub, a, b);
        public Assembler Pminub(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pminub, a, b);
        public Assembler Pminud(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pminud, a, b);
        public Assembler Pminud(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pminud, a, b);
        public Assembler Pminuw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pminuw, a, b);
        public Assembler Pminuw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pminuw, a, b);
        public Assembler Pmovmskb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovmskb, a, b);
        public Assembler Pmovsxbd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovsxbd, a, b);
        public Assembler Pmovsxbd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovsxbd, a, b);
        public Assembler Pmovsxbq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovsxbq, a, b);
        public Assembler Pmovsxbq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovsxbq, a, b);
        public Assembler Pmovsxbw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovsxbw, a, b);
        public Assembler Pmovsxbw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovsxbw, a, b);
        public Assembler Pmovsxdq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovsxdq, a, b);
        public Assembler Pmovsxdq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovsxdq, a, b);
        public Assembler Pmovsxwd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovsxwd, a, b);
        public Assembler Pmovsxwd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovsxwd, a, b);
        public Assembler Pmovsxwq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovsxwq, a, b);
        public Assembler Pmovsxwq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovsxwq, a, b);
        public Assembler Pmovzxbd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovzxbd, a, b);
        public Assembler Pmovzxbd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovzxbd, a, b);
        public Assembler Pmovzxbq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovzxbq, a, b);
        public Assembler Pmovzxbq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovzxbq, a, b);
        public Assembler Pmovzxbw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovzxbw, a, b);
        public Assembler Pmovzxbw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovzxbw, a, b);
        public Assembler Pmovzxdq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovzxdq, a, b);
        public Assembler Pmovzxdq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovzxdq, a, b);
        public Assembler Pmovzxwd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovzxwd, a, b);
        public Assembler Pmovzxwd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovzxwd, a, b);
        public Assembler Pmovzxwq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmovzxwq, a, b);
        public Assembler Pmovzxwq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmovzxwq, a, b);
        public Assembler Pmuldq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmuldq, a, b);
        public Assembler Pmuldq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmuldq, a, b);
        public Assembler Pmulhrsw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmulhrsw, a, b);
        public Assembler Pmulhrsw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmulhrsw, a, b);
        public Assembler Pmulhw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmulhw, a, b);
        public Assembler Pmulhw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmulhw, a, b);
        public Assembler Pmulhuw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmulhuw, a, b);
        public Assembler Pmulhuw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmulhuw, a, b);
        public Assembler Pmulld(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmulld, a, b);
        public Assembler Pmulld(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmulld, a, b);
        public Assembler Pmullw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmullw, a, b);
        public Assembler Pmullw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmullw, a, b);
        public Assembler Pmuludq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmuludq, a, b);
        public Assembler Pmuludq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmuludq, a, b);
        public Assembler Por(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Por, a, b);
        public Assembler Por(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Por, a, b);
        public Assembler Psadbw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psadbw, a, b);
        public Assembler Psadbw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psadbw, a, b);
        public Assembler Pslld(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pslld, a, b);
        public Assembler Pslld(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pslld, a, b);
        public Assembler Pslld(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Pslld, a, b);
        public Assembler Pslldq(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Pslldq, a, b);
        public Assembler Psllq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psllq, a, b);
        public Assembler Psllq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psllq, a, b);
        public Assembler Psllq(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Psllq, a, b);
        public Assembler Psllw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psllw, a, b);
        public Assembler Psllw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psllw, a, b);
        public Assembler Psllw(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Psllw, a, b);
        public Assembler Psrad(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psrad, a, b);
        public Assembler Psrad(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psrad, a, b);
        public Assembler Psrad(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Psrad, a, b);
        public Assembler Psraw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psraw, a, b);
        public Assembler Psraw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psraw, a, b);
        public Assembler Psraw(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Psraw, a, b);
        public Assembler Pshufb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pshufb, a, b);
        public Assembler Pshufb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pshufb, a, b);
        public Assembler Pshufd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pshufd, a, b, c);
        public Assembler Pshufd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pshufd, a, b, c);
        public Assembler Pshufhw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pshufhw, a, b, c);
        public Assembler Pshufhw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pshufhw, a, b, c);
        public Assembler Pshuflw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pshuflw, a, b, c);
        public Assembler Pshuflw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pshuflw, a, b, c);
        public Assembler Pshufw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pshufw, a, b, c);
        public Assembler Pshufw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pshufw, a, b, c);
        public Assembler Psignb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psignb, a, b);
        public Assembler Psignb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psignb, a, b);
        public Assembler Psignd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psignd, a, b);
        public Assembler Psignd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psignd, a, b);
        public Assembler Psignw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psignw, a, b);
        public Assembler Psignw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psignw, a, b);
        public Assembler Psrld(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psrld, a, b);
        public Assembler Psrld(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psrld, a, b);
        public Assembler Psrld(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Psrld, a, b);
        public Assembler Psrldq(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Psrldq, a, b);
        public Assembler Psrlq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psrlq, a, b);
        public Assembler Psrlq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psrlq, a, b);
        public Assembler Psrlq(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Psrlq, a, b);
        public Assembler Psrlw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psrlw, a, b);
        public Assembler Psrlw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psrlw, a, b);
        public Assembler Psrlw(Operand.Register a, Operand.Immediate b) => CreateInstr(Mnemonic.Psrlw, a, b);
        public Assembler Psubb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psubb, a, b);
        public Assembler Psubb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psubb, a, b);
        public Assembler Psubd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psubd, a, b);
        public Assembler Psubd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psubd, a, b);
        public Assembler Psubq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psubq, a, b);
        public Assembler Psubq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psubq, a, b);
        public Assembler Psubsb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psubsb, a, b);
        public Assembler Psubsb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psubsb, a, b);
        public Assembler Psubsw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psubsw, a, b);
        public Assembler Psubsw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psubsw, a, b);
        public Assembler Psubusb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psubusb, a, b);
        public Assembler Psubusb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psubusb, a, b);
        public Assembler Psubusw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psubusw, a, b);
        public Assembler Psubusw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psubusw, a, b);
        public Assembler Psubw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Psubw, a, b);
        public Assembler Psubw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Psubw, a, b);
        public Assembler Ptest(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Ptest, a, b);
        public Assembler Ptest(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Ptest, a, b);
        public Assembler Punpckhbw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Punpckhbw, a, b);
        public Assembler Punpckhbw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Punpckhbw, a, b);
        public Assembler Punpckhdq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Punpckhdq, a, b);
        public Assembler Punpckhdq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Punpckhdq, a, b);
        public Assembler Punpckhqdq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Punpckhqdq, a, b);
        public Assembler Punpckhqdq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Punpckhqdq, a, b);
        public Assembler Punpckhwd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Punpckhwd, a, b);
        public Assembler Punpckhwd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Punpckhwd, a, b);
        public Assembler Punpcklbw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Punpcklbw, a, b);
        public Assembler Punpcklbw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Punpcklbw, a, b);
        public Assembler Punpckldq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Punpckldq, a, b);
        public Assembler Punpckldq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Punpckldq, a, b);
        public Assembler Punpcklqdq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Punpcklqdq, a, b);
        public Assembler Punpcklqdq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Punpcklqdq, a, b);
        public Assembler Punpcklwd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Punpcklwd, a, b);
        public Assembler Punpcklwd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Punpcklwd, a, b);
        public Assembler Pxor(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pxor, a, b);
        public Assembler Pxor(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pxor, a, b);
        public Assembler Rcpps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Rcpps, a, b);
        public Assembler Rcpps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Rcpps, a, b);
        public Assembler Rcpss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Rcpss, a, b);
        public Assembler Rcpss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Rcpss, a, b);
        public Assembler Roundpd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Roundpd, a, b, c);
        public Assembler Roundpd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Roundpd, a, b, c);
        public Assembler Roundps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Roundps, a, b, c);
        public Assembler Roundps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Roundps, a, b, c);
        public Assembler Roundsd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Roundsd, a, b, c);
        public Assembler Roundsd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Roundsd, a, b, c);
        public Assembler Roundss(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Roundss, a, b, c);
        public Assembler Roundss(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Roundss, a, b, c);
        public Assembler Rsqrtps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Rsqrtps, a, b);
        public Assembler Rsqrtps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Rsqrtps, a, b);
        public Assembler Rsqrtss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Rsqrtss, a, b);
        public Assembler Rsqrtss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Rsqrtss, a, b);
        public Assembler Shufpd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Shufpd, a, b, c);
        public Assembler Shufpd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Shufpd, a, b, c);
        public Assembler Shufps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Shufps, a, b, c);
        public Assembler Shufps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Shufps, a, b, c);
        public Assembler Sqrtpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sqrtpd, a, b);
        public Assembler Sqrtpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sqrtpd, a, b);
        public Assembler Sqrtps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sqrtps, a, b);
        public Assembler Sqrtps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sqrtps, a, b);
        public Assembler Sqrtsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sqrtsd, a, b);
        public Assembler Sqrtsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sqrtsd, a, b);
        public Assembler Sqrtss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sqrtss, a, b);
        public Assembler Sqrtss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sqrtss, a, b);
        public Assembler Subpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Subpd, a, b);
        public Assembler Subpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Subpd, a, b);
        public Assembler Subps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Subps, a, b);
        public Assembler Subps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Subps, a, b);
        public Assembler Subsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Subsd, a, b);
        public Assembler Subsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Subsd, a, b);
        public Assembler Subss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Subss, a, b);
        public Assembler Subss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Subss, a, b);
        public Assembler Ucomisd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Ucomisd, a, b);
        public Assembler Ucomisd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Ucomisd, a, b);
        public Assembler Ucomiss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Ucomiss, a, b);
        public Assembler Ucomiss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Ucomiss, a, b);
        public Assembler Unpckhpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Unpckhpd, a, b);
        public Assembler Unpckhpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Unpckhpd, a, b);
        public Assembler Unpckhps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Unpckhps, a, b);
        public Assembler Unpckhps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Unpckhps, a, b);
        public Assembler Unpcklpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Unpcklpd, a, b);
        public Assembler Unpcklpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Unpcklpd, a, b);
        public Assembler Unpcklps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Unpcklps, a, b);
        public Assembler Unpcklps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Unpcklps, a, b);
        public Assembler Xorpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Xorpd, a, b);
        public Assembler Xorpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Xorpd, a, b);
        public Assembler Xorps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Xorps, a, b);
        public Assembler Xorps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Xorps, a, b);
        public Assembler Pavgusb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pavgusb, a, b);
        public Assembler Pavgusb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pavgusb, a, b);
        public Assembler Pf2id(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pf2id, a, b);
        public Assembler Pf2id(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pf2id, a, b);
        public Assembler Pf2iw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pf2iw, a, b);
        public Assembler Pf2iw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pf2iw, a, b);
        public Assembler Pfacc(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfacc, a, b);
        public Assembler Pfacc(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfacc, a, b);
        public Assembler Pfadd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfadd, a, b);
        public Assembler Pfadd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfadd, a, b);
        public Assembler Pfcmpeq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfcmpeq, a, b);
        public Assembler Pfcmpeq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfcmpeq, a, b);
        public Assembler Pfcmpge(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfcmpge, a, b);
        public Assembler Pfcmpge(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfcmpge, a, b);
        public Assembler Pfcmpgt(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfcmpgt, a, b);
        public Assembler Pfcmpgt(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfcmpgt, a, b);
        public Assembler Pfmax(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfmax, a, b);
        public Assembler Pfmax(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfmax, a, b);
        public Assembler Pfmin(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfmin, a, b);
        public Assembler Pfmin(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfmin, a, b);
        public Assembler Pfmul(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfmul, a, b);
        public Assembler Pfmul(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfmul, a, b);
        public Assembler Pfnacc(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfnacc, a, b);
        public Assembler Pfnacc(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfnacc, a, b);
        public Assembler Pfpnacc(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfpnacc, a, b);
        public Assembler Pfpnacc(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfpnacc, a, b);
        public Assembler Pfrcp(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfrcp, a, b);
        public Assembler Pfrcp(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfrcp, a, b);
        public Assembler Pfrcpit2(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfrcpit2, a, b);
        public Assembler Pfrcpit2(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfrcpit2, a, b);
        public Assembler Pfrsqit1(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfrsqit1, a, b);
        public Assembler Pfrsqit1(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfrsqit1, a, b);
        public Assembler Pfsub(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfsub, a, b);
        public Assembler Pfsub(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfsub, a, b);
        public Assembler Pfsubr(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pfsubr, a, b);
        public Assembler Pfsubr(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pfsubr, a, b);
        public Assembler Pi2fd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pi2fd, a, b);
        public Assembler Pi2fd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pi2fd, a, b);
        public Assembler Pi2fw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pi2fw, a, b);
        public Assembler Pi2fw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pi2fw, a, b);
        public Assembler Pmulhrw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pmulhrw, a, b);
        public Assembler Pmulhrw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pmulhrw, a, b);
        public Assembler Pswapd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pswapd, a, b);
        public Assembler Pswapd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pswapd, a, b);
        public Assembler Femms() => CreateInstr(Mnemonic.Femms);
        public Assembler Aesdec(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Aesdec, a, b);
        public Assembler Aesdec(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Aesdec, a, b);
        public Assembler Aesdeclast(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Aesdeclast, a, b);
        public Assembler Aesdeclast(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Aesdeclast, a, b);
        public Assembler Aesenc(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Aesenc, a, b);
        public Assembler Aesenc(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Aesenc, a, b);
        public Assembler Aesenclast(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Aesenclast, a, b);
        public Assembler Aesenclast(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Aesenclast, a, b);
        public Assembler Aesimc(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Aesimc, a, b);
        public Assembler Aesimc(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Aesimc, a, b);
        public Assembler Aeskeygenassist(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Aeskeygenassist, a, b, c);
        public Assembler Aeskeygenassist(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Aeskeygenassist, a, b, c);
        public Assembler Sha1msg1(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sha1msg1, a, b);
        public Assembler Sha1msg1(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sha1msg1, a, b);
        public Assembler Sha1msg2(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sha1msg2, a, b);
        public Assembler Sha1msg2(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sha1msg2, a, b);
        public Assembler Sha1nexte(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sha1nexte, a, b);
        public Assembler Sha1nexte(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sha1nexte, a, b);
        public Assembler Sha1rnds4(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Sha1rnds4, a, b, c);
        public Assembler Sha1rnds4(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Sha1rnds4, a, b, c);
        public Assembler Sha256msg1(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sha256msg1, a, b);
        public Assembler Sha256msg1(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sha256msg1, a, b);
        public Assembler Sha256msg2(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sha256msg2, a, b);
        public Assembler Sha256msg2(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sha256msg2, a, b);
        public Assembler Kaddb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kaddb, a, b, c);
        public Assembler Kaddd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kaddd, a, b, c);
        public Assembler Kaddq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kaddq, a, b, c);
        public Assembler Kaddw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kaddw, a, b, c);
        public Assembler Kandb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kandb, a, b, c);
        public Assembler Kandd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kandd, a, b, c);
        public Assembler Kandnb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kandnb, a, b, c);
        public Assembler Kandnd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kandnd, a, b, c);
        public Assembler Kandnq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kandnq, a, b, c);
        public Assembler Kandnw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kandnw, a, b, c);
        public Assembler Kandq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kandq, a, b, c);
        public Assembler Kandw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kandw, a, b, c);
        public Assembler Kmovb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Kmovb, a, b);
        public Assembler Kmovb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Kmovb, a, b);
        public Assembler Kmovb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Kmovb, a, b);
        public Assembler Kmovd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Kmovd, a, b);
        public Assembler Kmovd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Kmovd, a, b);
        public Assembler Kmovd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Kmovd, a, b);
        public Assembler Kmovq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Kmovq, a, b);
        public Assembler Kmovq(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Kmovq, a, b);
        public Assembler Kmovq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Kmovq, a, b);
        public Assembler Kmovw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Kmovw, a, b);
        public Assembler Kmovw(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Kmovw, a, b);
        public Assembler Kmovw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Kmovw, a, b);
        public Assembler Knotb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Knotb, a, b);
        public Assembler Knotd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Knotd, a, b);
        public Assembler Knotq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Knotq, a, b);
        public Assembler Knotw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Knotw, a, b);
        public Assembler Korb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Korb, a, b, c);
        public Assembler Kord(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kord, a, b, c);
        public Assembler Korq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Korq, a, b, c);
        public Assembler Kortestb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Kortestb, a, b);
        public Assembler Kortestd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Kortestd, a, b);
        public Assembler Kortestq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Kortestq, a, b);
        public Assembler Kortestw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Kortestw, a, b);
        public Assembler Korw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Korw, a, b, c);
        public Assembler Kshiftlb(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Kshiftlb, a, b, c);
        public Assembler Kshiftld(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Kshiftld, a, b, c);
        public Assembler Kshiftlq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Kshiftlq, a, b, c);
        public Assembler Kshiftlw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Kshiftlw, a, b, c);
        public Assembler Kshiftrb(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Kshiftrb, a, b, c);
        public Assembler Kshiftrd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Kshiftrd, a, b, c);
        public Assembler Kshiftrq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Kshiftrq, a, b, c);
        public Assembler Kshiftrw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Kshiftrw, a, b, c);
        public Assembler Ktestb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Ktestb, a, b);
        public Assembler Ktestd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Ktestd, a, b);
        public Assembler Ktestq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Ktestq, a, b);
        public Assembler Ktestw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Ktestw, a, b);
        public Assembler Kunpckbw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kunpckbw, a, b, c);
        public Assembler Kunpckdq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kunpckdq, a, b, c);
        public Assembler Kunpckwd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kunpckwd, a, b, c);
        public Assembler Kxnorb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kxnorb, a, b, c);
        public Assembler Kxnord(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kxnord, a, b, c);
        public Assembler Kxnorq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kxnorq, a, b, c);
        public Assembler Kxnorw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kxnorw, a, b, c);
        public Assembler Kxorb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kxorb, a, b, c);
        public Assembler Kxord(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kxord, a, b, c);
        public Assembler Kxorq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kxorq, a, b, c);
        public Assembler Kxorw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Kxorw, a, b, c);
        public Assembler Vaddpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vaddpd, a, b, c);
        public Assembler Vaddpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vaddpd, a, b, c);
        public Assembler Vaddps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vaddps, a, b, c);
        public Assembler Vaddps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vaddps, a, b, c);
        public Assembler Vaddsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vaddsd, a, b, c);
        public Assembler Vaddsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vaddsd, a, b, c);
        public Assembler Vaddss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vaddss, a, b, c);
        public Assembler Vaddss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vaddss, a, b, c);
        public Assembler Vaddsubpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vaddsubpd, a, b, c);
        public Assembler Vaddsubpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vaddsubpd, a, b, c);
        public Assembler Vaddsubps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vaddsubps, a, b, c);
        public Assembler Vaddsubps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vaddsubps, a, b, c);
        public Assembler Vaesdec(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vaesdec, a, b, c);
        public Assembler Vaesdec(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vaesdec, a, b, c);
        public Assembler Vaesdeclast(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vaesdeclast, a, b, c);
        public Assembler Vaesdeclast(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vaesdeclast, a, b, c);
        public Assembler Vaesenc(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vaesenc, a, b, c);
        public Assembler Vaesenc(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vaesenc, a, b, c);
        public Assembler Vaesenclast(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vaesenclast, a, b, c);
        public Assembler Vaesenclast(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vaesenclast, a, b, c);
        public Assembler Vaesimc(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vaesimc, a, b);
        public Assembler Vaesimc(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vaesimc, a, b);
        public Assembler Vaeskeygenassist(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vaeskeygenassist, a, b, c);
        public Assembler Vaeskeygenassist(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vaeskeygenassist, a, b, c);
        public Assembler Valignd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Valignd, a, b, c, d);
        public Assembler Valignd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Valignd, a, b, c, d);
        public Assembler Valignq(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Valignq, a, b, c, d);
        public Assembler Valignq(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Valignq, a, b, c, d);
        public Assembler Vandnpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vandnpd, a, b, c);
        public Assembler Vandnpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vandnpd, a, b, c);
        public Assembler Vandnps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vandnps, a, b, c);
        public Assembler Vandnps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vandnps, a, b, c);
        public Assembler Vandpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vandpd, a, b, c);
        public Assembler Vandpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vandpd, a, b, c);
        public Assembler Vandps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vandps, a, b, c);
        public Assembler Vandps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vandps, a, b, c);
        public Assembler Vblendmpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vblendmpd, a, b, c);
        public Assembler Vblendmpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vblendmpd, a, b, c);
        public Assembler Vblendmps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vblendmps, a, b, c);
        public Assembler Vblendmps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vblendmps, a, b, c);
        public Assembler Vblendpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vblendpd, a, b, c, d);
        public Assembler Vblendpd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vblendpd, a, b, c, d);
        public Assembler Vblendps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vblendps, a, b, c, d);
        public Assembler Vblendps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vblendps, a, b, c, d);
        public Assembler Vblendvpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vblendvpd, a, b, c, d);
        public Assembler Vblendvpd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vblendvpd, a, b, c, d);
        public Assembler Vblendvps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vblendvps, a, b, c, d);
        public Assembler Vblendvps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vblendvps, a, b, c, d);
        public Assembler Vbroadcastf128(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcastf128, a, b);
        public Assembler Vbroadcastf32x2(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vbroadcastf32x2, a, b);
        public Assembler Vbroadcastf32x2(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcastf32x2, a, b);
        public Assembler Vbroadcastf32x4(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcastf32x4, a, b);
        public Assembler Vbroadcastf32x8(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcastf32x8, a, b);
        public Assembler Vbroadcastf64x2(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcastf64x2, a, b);
        public Assembler Vbroadcastf64x4(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcastf64x4, a, b);
        public Assembler Vbroadcasti128(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcasti128, a, b);
        public Assembler Vbroadcasti32x2(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vbroadcasti32x2, a, b);
        public Assembler Vbroadcasti32x2(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcasti32x2, a, b);
        public Assembler Vbroadcasti32x4(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcasti32x4, a, b);
        public Assembler Vbroadcasti32x8(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcasti32x8, a, b);
        public Assembler Vbroadcasti64x2(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vbroadcasti64x2, a, b);
        public Assembler Vbroadcasti64x2(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcasti64x2, a, b);
        public Assembler Vbroadcasti64x4(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vbroadcasti64x4, a, b);
        public Assembler Vbroadcasti64x4(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcasti64x4, a, b);
        public Assembler Vbroadcastsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vbroadcastsd, a, b);
        public Assembler Vbroadcastsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcastsd, a, b);
        public Assembler Vbroadcastss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vbroadcastss, a, b);
        public Assembler Vbroadcastss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vbroadcastss, a, b);
        public Assembler Vcmppd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vcmppd, a, b, c, d);
        public Assembler Vcmppd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vcmppd, a, b, c, d);
        public Assembler Vcmpps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vcmpps, a, b, c, d);
        public Assembler Vcmpps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vcmpps, a, b, c, d);
        public Assembler Vcmpsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vcmpsd, a, b, c, d);
        public Assembler Vcmpsd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vcmpsd, a, b, c, d);
        public Assembler Vcmpss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vcmpss, a, b, c, d);
        public Assembler Vcmpss(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vcmpss, a, b, c, d);
        public Assembler Vcomisd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcomisd, a, b);
        public Assembler Vcomisd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcomisd, a, b);
        public Assembler Vcomiss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcomiss, a, b);
        public Assembler Vcomiss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcomiss, a, b);
        public Assembler Vcompresspd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcompresspd, a, b);
        public Assembler Vcompresspd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vcompresspd, a, b);
        public Assembler Vcompressps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcompressps, a, b);
        public Assembler Vcompressps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vcompressps, a, b);
        public Assembler Vcvtdq2pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtdq2pd, a, b);
        public Assembler Vcvtdq2pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtdq2pd, a, b);
        public Assembler Vcvtdq2ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtdq2ps, a, b);
        public Assembler Vcvtdq2ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtdq2ps, a, b);
        public Assembler Vcvtne2ps2bf16(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vcvtne2ps2bf16, a, b, c);
        public Assembler Vcvtne2ps2bf16(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vcvtne2ps2bf16, a, b, c);
        public Assembler Vcvtneps2bf16(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtneps2bf16, a, b);
        public Assembler Vcvtneps2bf16(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtneps2bf16, a, b);
        public Assembler Vcvtpd2dq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtpd2dq, a, b);
        public Assembler Vcvtpd2dq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtpd2dq, a, b);
        public Assembler Vcvtpd2ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtpd2ps, a, b);
        public Assembler Vcvtpd2ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtpd2ps, a, b);
        public Assembler Vcvtpd2qq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtpd2qq, a, b);
        public Assembler Vcvtpd2qq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtpd2qq, a, b);
        public Assembler Vcvtpd2udq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtpd2udq, a, b);
        public Assembler Vcvtpd2udq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtpd2udq, a, b);
        public Assembler Vcvtpd2uqq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtpd2uqq, a, b);
        public Assembler Vcvtpd2uqq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtpd2uqq, a, b);
        public Assembler Vcvtph2ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtph2ps, a, b);
        public Assembler Vcvtph2ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtph2ps, a, b);
        public Assembler Vcvtps2dq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtps2dq, a, b);
        public Assembler Vcvtps2dq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtps2dq, a, b);
        public Assembler Vcvtps2pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtps2pd, a, b);
        public Assembler Vcvtps2pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtps2pd, a, b);
        public Assembler Vcvtps2ph(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vcvtps2ph, a, b, c);
        public Assembler Vcvtps2ph(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vcvtps2ph, a, b, c);
        public Assembler Vcvtps2qq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtps2qq, a, b);
        public Assembler Vcvtps2qq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtps2qq, a, b);
        public Assembler Vcvtps2udq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtps2udq, a, b);
        public Assembler Vcvtps2udq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtps2udq, a, b);
        public Assembler Vcvtps2uqq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtps2uqq, a, b);
        public Assembler Vcvtps2uqq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtps2uqq, a, b);
        public Assembler Vcvtqq2pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtqq2pd, a, b);
        public Assembler Vcvtqq2pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtqq2pd, a, b);
        public Assembler Vcvtqq2ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtqq2ps, a, b);
        public Assembler Vcvtqq2ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtqq2ps, a, b);
        public Assembler Vcvtsd2si(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtsd2si, a, b);
        public Assembler Vcvtsd2si(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtsd2si, a, b);
        public Assembler Vcvtsd2ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vcvtsd2ss, a, b, c);
        public Assembler Vcvtsd2ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vcvtsd2ss, a, b, c);
        public Assembler Vcvtsd2usi(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtsd2usi, a, b);
        public Assembler Vcvtsd2usi(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtsd2usi, a, b);
        public Assembler Vcvtsi2sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vcvtsi2sd, a, b, c);
        public Assembler Vcvtsi2sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vcvtsi2sd, a, b, c);
        public Assembler Vcvtsi2ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vcvtsi2ss, a, b, c);
        public Assembler Vcvtsi2ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vcvtsi2ss, a, b, c);
        public Assembler Vcvtss2sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vcvtss2sd, a, b, c);
        public Assembler Vcvtss2sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vcvtss2sd, a, b, c);
        public Assembler Vcvtss2si(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtss2si, a, b);
        public Assembler Vcvtss2si(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtss2si, a, b);
        public Assembler Vcvtss2usi(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtss2usi, a, b);
        public Assembler Vcvtss2usi(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtss2usi, a, b);
        public Assembler Vcvttpd2dq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttpd2dq, a, b);
        public Assembler Vcvttpd2dq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttpd2dq, a, b);
        public Assembler Vcvttpd2qq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttpd2qq, a, b);
        public Assembler Vcvttpd2qq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttpd2qq, a, b);
        public Assembler Vcvttpd2udq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttpd2udq, a, b);
        public Assembler Vcvttpd2udq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttpd2udq, a, b);
        public Assembler Vcvttpd2uqq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttpd2uqq, a, b);
        public Assembler Vcvttpd2uqq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttpd2uqq, a, b);
        public Assembler Vcvttps2dq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttps2dq, a, b);
        public Assembler Vcvttps2dq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttps2dq, a, b);
        public Assembler Vcvttps2qq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttps2qq, a, b);
        public Assembler Vcvttps2qq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttps2qq, a, b);
        public Assembler Vcvttps2udq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttps2udq, a, b);
        public Assembler Vcvttps2udq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttps2udq, a, b);
        public Assembler Vcvttps2uqq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttps2uqq, a, b);
        public Assembler Vcvttps2uqq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttps2uqq, a, b);
        public Assembler Vcvttsd2si(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttsd2si, a, b);
        public Assembler Vcvttsd2si(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttsd2si, a, b);
        public Assembler Vcvttsd2usi(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttsd2usi, a, b);
        public Assembler Vcvttsd2usi(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttsd2usi, a, b);
        public Assembler Vcvttss2si(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttss2si, a, b);
        public Assembler Vcvttss2si(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttss2si, a, b);
        public Assembler Vcvttss2usi(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvttss2usi, a, b);
        public Assembler Vcvttss2usi(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvttss2usi, a, b);
        public Assembler Vcvtudq2pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtudq2pd, a, b);
        public Assembler Vcvtudq2pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtudq2pd, a, b);
        public Assembler Vcvtudq2ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtudq2ps, a, b);
        public Assembler Vcvtudq2ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtudq2ps, a, b);
        public Assembler Vcvtuqq2pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtuqq2pd, a, b);
        public Assembler Vcvtuqq2pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtuqq2pd, a, b);
        public Assembler Vcvtuqq2ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vcvtuqq2ps, a, b);
        public Assembler Vcvtuqq2ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vcvtuqq2ps, a, b);
        public Assembler Vcvtusi2sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vcvtusi2sd, a, b, c);
        public Assembler Vcvtusi2sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vcvtusi2sd, a, b, c);
        public Assembler Vcvtusi2ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vcvtusi2ss, a, b, c);
        public Assembler Vcvtusi2ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vcvtusi2ss, a, b, c);
        public Assembler Vdbpsadbw(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vdbpsadbw, a, b, c, d);
        public Assembler Vdbpsadbw(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vdbpsadbw, a, b, c, d);
        public Assembler Vdivpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vdivpd, a, b, c);
        public Assembler Vdivpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vdivpd, a, b, c);
        public Assembler Vdivps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vdivps, a, b, c);
        public Assembler Vdivps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vdivps, a, b, c);
        public Assembler Vdivsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vdivsd, a, b, c);
        public Assembler Vdivsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vdivsd, a, b, c);
        public Assembler Vdivss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vdivss, a, b, c);
        public Assembler Vdivss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vdivss, a, b, c);
        public Assembler Vdpbf16ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vdpbf16ps, a, b, c);
        public Assembler Vdpbf16ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vdpbf16ps, a, b, c);
        public Assembler Vdppd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vdppd, a, b, c, d);
        public Assembler Vdppd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vdppd, a, b, c, d);
        public Assembler Vdpps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vdpps, a, b, c, d);
        public Assembler Vdpps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vdpps, a, b, c, d);
        public Assembler Vexp2pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vexp2pd, a, b);
        public Assembler Vexp2pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vexp2pd, a, b);
        public Assembler Vexp2ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vexp2ps, a, b);
        public Assembler Vexp2ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vexp2ps, a, b);
        public Assembler Vexpandpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vexpandpd, a, b);
        public Assembler Vexpandpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vexpandpd, a, b);
        public Assembler Vexpandps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vexpandps, a, b);
        public Assembler Vexpandps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vexpandps, a, b);
        public Assembler Vextractf128(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractf128, a, b, c);
        public Assembler Vextractf128(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractf128, a, b, c);
        public Assembler Vextractf32x4(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractf32x4, a, b, c);
        public Assembler Vextractf32x4(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractf32x4, a, b, c);
        public Assembler Vextractf32x8(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractf32x8, a, b, c);
        public Assembler Vextractf32x8(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractf32x8, a, b, c);
        public Assembler Vextractf64x2(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractf64x2, a, b, c);
        public Assembler Vextractf64x2(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractf64x2, a, b, c);
        public Assembler Vextractf64x4(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractf64x4, a, b, c);
        public Assembler Vextractf64x4(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractf64x4, a, b, c);
        public Assembler Vextracti128(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextracti128, a, b, c);
        public Assembler Vextracti128(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextracti128, a, b, c);
        public Assembler Vextracti32x4(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextracti32x4, a, b, c);
        public Assembler Vextracti32x4(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextracti32x4, a, b, c);
        public Assembler Vextracti32x8(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextracti32x8, a, b, c);
        public Assembler Vextracti32x8(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextracti32x8, a, b, c);
        public Assembler Vextracti64x2(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextracti64x2, a, b, c);
        public Assembler Vextracti64x2(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextracti64x2, a, b, c);
        public Assembler Vextracti64x4(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextracti64x4, a, b, c);
        public Assembler Vextracti64x4(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextracti64x4, a, b, c);
        public Assembler Vextractps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractps, a, b, c);
        public Assembler Vextractps(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vextractps, a, b, c);
        public Assembler Vfmadd132pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd132pd, a, b, c);
        public Assembler Vfmadd132pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd132pd, a, b, c);
        public Assembler Vfmadd132ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd132ps, a, b, c);
        public Assembler Vfmadd132ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd132ps, a, b, c);
        public Assembler Vfmadd132sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd132sd, a, b, c);
        public Assembler Vfmadd132sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd132sd, a, b, c);
        public Assembler Vfmadd132ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd132ss, a, b, c);
        public Assembler Vfmadd132ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd132ss, a, b, c);
        public Assembler Vfmadd213pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd213pd, a, b, c);
        public Assembler Vfmadd213pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd213pd, a, b, c);
        public Assembler Vfmadd213ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd213ps, a, b, c);
        public Assembler Vfmadd213ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd213ps, a, b, c);
        public Assembler Vfmadd213sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd213sd, a, b, c);
        public Assembler Vfmadd213sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd213sd, a, b, c);
        public Assembler Vfmadd213ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd213ss, a, b, c);
        public Assembler Vfmadd213ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd213ss, a, b, c);
        public Assembler Vfmadd231pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd231pd, a, b, c);
        public Assembler Vfmadd231pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd231pd, a, b, c);
        public Assembler Vfmadd231ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd231ps, a, b, c);
        public Assembler Vfmadd231ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd231ps, a, b, c);
        public Assembler Vfmadd231sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd231sd, a, b, c);
        public Assembler Vfmadd231sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd231sd, a, b, c);
        public Assembler Vfmadd231ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmadd231ss, a, b, c);
        public Assembler Vfmadd231ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmadd231ss, a, b, c);
        public Assembler Vfmaddsub132pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmaddsub132pd, a, b, c);
        public Assembler Vfmaddsub132pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmaddsub132pd, a, b, c);
        public Assembler Vfmaddsub132ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmaddsub132ps, a, b, c);
        public Assembler Vfmaddsub132ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmaddsub132ps, a, b, c);
        public Assembler Vfmaddsub213pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmaddsub213pd, a, b, c);
        public Assembler Vfmaddsub213pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmaddsub213pd, a, b, c);
        public Assembler Vfmaddsub213ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmaddsub213ps, a, b, c);
        public Assembler Vfmaddsub213ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmaddsub213ps, a, b, c);
        public Assembler Vfmaddsub231pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmaddsub231pd, a, b, c);
        public Assembler Vfmaddsub231pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmaddsub231pd, a, b, c);
        public Assembler Vfmaddsub231ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmaddsub231ps, a, b, c);
        public Assembler Vfmaddsub231ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmaddsub231ps, a, b, c);
        public Assembler Vfmsub132pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub132pd, a, b, c);
        public Assembler Vfmsub132pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub132pd, a, b, c);
        public Assembler Vfmsub132ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub132ps, a, b, c);
        public Assembler Vfmsub132ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub132ps, a, b, c);
        public Assembler Vfmsub132sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub132sd, a, b, c);
        public Assembler Vfmsub132sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub132sd, a, b, c);
        public Assembler Vfmsub132ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub132ss, a, b, c);
        public Assembler Vfmsub132ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub132ss, a, b, c);
        public Assembler Vfmsub213pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub213pd, a, b, c);
        public Assembler Vfmsub213pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub213pd, a, b, c);
        public Assembler Vfmsub213ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub213ps, a, b, c);
        public Assembler Vfmsub213ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub213ps, a, b, c);
        public Assembler Vfmsub213sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub213sd, a, b, c);
        public Assembler Vfmsub213sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub213sd, a, b, c);
        public Assembler Vfmsub213ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub213ss, a, b, c);
        public Assembler Vfmsub213ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub213ss, a, b, c);
        public Assembler Vfmsub231pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub231pd, a, b, c);
        public Assembler Vfmsub231pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub231pd, a, b, c);
        public Assembler Vfmsub231ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub231ps, a, b, c);
        public Assembler Vfmsub231ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub231ps, a, b, c);
        public Assembler Vfmsub231sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub231sd, a, b, c);
        public Assembler Vfmsub231sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub231sd, a, b, c);
        public Assembler Vfmsub231ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsub231ss, a, b, c);
        public Assembler Vfmsub231ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsub231ss, a, b, c);
        public Assembler Vfmsubadd132pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsubadd132pd, a, b, c);
        public Assembler Vfmsubadd132pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsubadd132pd, a, b, c);
        public Assembler Vfmsubadd132ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsubadd132ps, a, b, c);
        public Assembler Vfmsubadd132ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsubadd132ps, a, b, c);
        public Assembler Vfmsubadd213pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsubadd213pd, a, b, c);
        public Assembler Vfmsubadd213pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsubadd213pd, a, b, c);
        public Assembler Vfmsubadd213ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsubadd213ps, a, b, c);
        public Assembler Vfmsubadd213ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsubadd213ps, a, b, c);
        public Assembler Vfmsubadd231pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsubadd231pd, a, b, c);
        public Assembler Vfmsubadd231pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsubadd231pd, a, b, c);
        public Assembler Vfmsubadd231ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfmsubadd231ps, a, b, c);
        public Assembler Vfmsubadd231ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfmsubadd231ps, a, b, c);
        public Assembler Vfnmadd132pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd132pd, a, b, c);
        public Assembler Vfnmadd132pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd132pd, a, b, c);
        public Assembler Vfnmadd132ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd132ps, a, b, c);
        public Assembler Vfnmadd132ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd132ps, a, b, c);
        public Assembler Vfnmadd132sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd132sd, a, b, c);
        public Assembler Vfnmadd132sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd132sd, a, b, c);
        public Assembler Vfnmadd132ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd132ss, a, b, c);
        public Assembler Vfnmadd132ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd132ss, a, b, c);
        public Assembler Vfnmadd213pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd213pd, a, b, c);
        public Assembler Vfnmadd213pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd213pd, a, b, c);
        public Assembler Vfnmadd213ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd213ps, a, b, c);
        public Assembler Vfnmadd213ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd213ps, a, b, c);
        public Assembler Vfnmadd213sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd213sd, a, b, c);
        public Assembler Vfnmadd213sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd213sd, a, b, c);
        public Assembler Vfnmadd213ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd213ss, a, b, c);
        public Assembler Vfnmadd213ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd213ss, a, b, c);
        public Assembler Vfnmadd231pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd231pd, a, b, c);
        public Assembler Vfnmadd231pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd231pd, a, b, c);
        public Assembler Vfnmadd231ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd231ps, a, b, c);
        public Assembler Vfnmadd231ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd231ps, a, b, c);
        public Assembler Vfnmadd231sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd231sd, a, b, c);
        public Assembler Vfnmadd231sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd231sd, a, b, c);
        public Assembler Vfnmadd231ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmadd231ss, a, b, c);
        public Assembler Vfnmadd231ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmadd231ss, a, b, c);
        public Assembler Vfnmsub132pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub132pd, a, b, c);
        public Assembler Vfnmsub132pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub132pd, a, b, c);
        public Assembler Vfnmsub132ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub132ps, a, b, c);
        public Assembler Vfnmsub132ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub132ps, a, b, c);
        public Assembler Vfnmsub132sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub132sd, a, b, c);
        public Assembler Vfnmsub132sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub132sd, a, b, c);
        public Assembler Vfnmsub132ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub132ss, a, b, c);
        public Assembler Vfnmsub132ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub132ss, a, b, c);
        public Assembler Vfnmsub213pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub213pd, a, b, c);
        public Assembler Vfnmsub213pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub213pd, a, b, c);
        public Assembler Vfnmsub213ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub213ps, a, b, c);
        public Assembler Vfnmsub213ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub213ps, a, b, c);
        public Assembler Vfnmsub213sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub213sd, a, b, c);
        public Assembler Vfnmsub213sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub213sd, a, b, c);
        public Assembler Vfnmsub213ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub213ss, a, b, c);
        public Assembler Vfnmsub213ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub213ss, a, b, c);
        public Assembler Vfnmsub231pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub231pd, a, b, c);
        public Assembler Vfnmsub231pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub231pd, a, b, c);
        public Assembler Vfnmsub231ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub231ps, a, b, c);
        public Assembler Vfnmsub231ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub231ps, a, b, c);
        public Assembler Vfnmsub231sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub231sd, a, b, c);
        public Assembler Vfnmsub231sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub231sd, a, b, c);
        public Assembler Vfnmsub231ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vfnmsub231ss, a, b, c);
        public Assembler Vfnmsub231ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vfnmsub231ss, a, b, c);
        public Assembler Vfpclasspd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vfpclasspd, a, b, c);
        public Assembler Vfpclasspd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vfpclasspd, a, b, c);
        public Assembler Vfpclassps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vfpclassps, a, b, c);
        public Assembler Vfpclassps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vfpclassps, a, b, c);
        public Assembler Vfpclasssd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vfpclasssd, a, b, c);
        public Assembler Vfpclasssd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vfpclasssd, a, b, c);
        public Assembler Vfpclassss(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vfpclassss, a, b, c);
        public Assembler Vfpclassss(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vfpclassss, a, b, c);
        public Assembler Vgatherdpd(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vgatherdpd, a, b, c);
        public Assembler Vgatherdpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vgatherdpd, a, b);
        public Assembler Vgatherdps(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vgatherdps, a, b, c);
        public Assembler Vgatherdps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vgatherdps, a, b);
        public Assembler Vgatherpf0dpd(Operand.Memory a) => CreateInstr(Mnemonic.Vgatherpf0dpd, a);
        public Assembler Vgatherpf0dps(Operand.Memory a) => CreateInstr(Mnemonic.Vgatherpf0dps, a);
        public Assembler Vgatherpf0qpd(Operand.Memory a) => CreateInstr(Mnemonic.Vgatherpf0qpd, a);
        public Assembler Vgatherpf0qps(Operand.Memory a) => CreateInstr(Mnemonic.Vgatherpf0qps, a);
        public Assembler Vgatherpf1dpd(Operand.Memory a) => CreateInstr(Mnemonic.Vgatherpf1dpd, a);
        public Assembler Vgatherpf1dps(Operand.Memory a) => CreateInstr(Mnemonic.Vgatherpf1dps, a);
        public Assembler Vgatherpf1qpd(Operand.Memory a) => CreateInstr(Mnemonic.Vgatherpf1qpd, a);
        public Assembler Vgatherpf1qps(Operand.Memory a) => CreateInstr(Mnemonic.Vgatherpf1qps, a);
        public Assembler Vgatherqpd(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vgatherqpd, a, b, c);
        public Assembler Vgatherqpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vgatherqpd, a, b);
        public Assembler Vgatherqps(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vgatherqps, a, b, c);
        public Assembler Vgatherqps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vgatherqps, a, b);
        public Assembler Vgetexppd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vgetexppd, a, b);
        public Assembler Vgetexppd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vgetexppd, a, b);
        public Assembler Vgetexpps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vgetexpps, a, b);
        public Assembler Vgetexpps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vgetexpps, a, b);
        public Assembler Vgetexpsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vgetexpsd, a, b, c);
        public Assembler Vgetexpsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vgetexpsd, a, b, c);
        public Assembler Vgetexpss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vgetexpss, a, b, c);
        public Assembler Vgetexpss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vgetexpss, a, b, c);
        public Assembler Vgetmantpd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vgetmantpd, a, b, c);
        public Assembler Vgetmantpd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vgetmantpd, a, b, c);
        public Assembler Vgetmantps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vgetmantps, a, b, c);
        public Assembler Vgetmantps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vgetmantps, a, b, c);
        public Assembler Vgetmantsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vgetmantsd, a, b, c, d);
        public Assembler Vgetmantsd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vgetmantsd, a, b, c, d);
        public Assembler Vgetmantss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vgetmantss, a, b, c, d);
        public Assembler Vgetmantss(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vgetmantss, a, b, c, d);
        public Assembler Vgf2p8affineinvqb(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vgf2p8affineinvqb, a, b, c, d);
        public Assembler Vgf2p8affineinvqb(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vgf2p8affineinvqb, a, b, c, d);
        public Assembler Vgf2p8affineqb(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vgf2p8affineqb, a, b, c, d);
        public Assembler Vgf2p8affineqb(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vgf2p8affineqb, a, b, c, d);
        public Assembler Vgf2p8mulb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vgf2p8mulb, a, b, c);
        public Assembler Vgf2p8mulb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vgf2p8mulb, a, b, c);
        public Assembler Vhaddpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vhaddpd, a, b, c);
        public Assembler Vhaddpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vhaddpd, a, b, c);
        public Assembler Vhaddps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vhaddps, a, b, c);
        public Assembler Vhaddps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vhaddps, a, b, c);
        public Assembler Vhsubpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vhsubpd, a, b, c);
        public Assembler Vhsubpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vhsubpd, a, b, c);
        public Assembler Vhsubps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vhsubps, a, b, c);
        public Assembler Vhsubps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vhsubps, a, b, c);
        public Assembler Vinsertf128(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertf128, a, b, c, d);
        public Assembler Vinsertf128(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertf128, a, b, c, d);
        public Assembler Vinsertf32x4(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertf32x4, a, b, c, d);
        public Assembler Vinsertf32x4(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertf32x4, a, b, c, d);
        public Assembler Vinsertf32x8(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertf32x8, a, b, c, d);
        public Assembler Vinsertf32x8(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertf32x8, a, b, c, d);
        public Assembler Vinsertf64x2(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertf64x2, a, b, c, d);
        public Assembler Vinsertf64x2(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertf64x2, a, b, c, d);
        public Assembler Vinsertf64x4(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertf64x4, a, b, c, d);
        public Assembler Vinsertf64x4(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertf64x4, a, b, c, d);
        public Assembler Vinserti128(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinserti128, a, b, c, d);
        public Assembler Vinserti128(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinserti128, a, b, c, d);
        public Assembler Vinserti32x4(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinserti32x4, a, b, c, d);
        public Assembler Vinserti32x4(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinserti32x4, a, b, c, d);
        public Assembler Vinserti32x8(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinserti32x8, a, b, c, d);
        public Assembler Vinserti32x8(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinserti32x8, a, b, c, d);
        public Assembler Vinserti64x2(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinserti64x2, a, b, c, d);
        public Assembler Vinserti64x2(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinserti64x2, a, b, c, d);
        public Assembler Vinserti64x4(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinserti64x4, a, b, c, d);
        public Assembler Vinserti64x4(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinserti64x4, a, b, c, d);
        public Assembler Vinsertps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertps, a, b, c, d);
        public Assembler Vinsertps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vinsertps, a, b, c, d);
        public Assembler Vlddqu(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vlddqu, a, b);
        public Assembler Vldmxcsr(Operand.Memory a) => CreateInstr(Mnemonic.Vldmxcsr, a);
        public Assembler Vmaskmovpd(Operand.Memory a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmaskmovpd, a, b, c);
        public Assembler Vmaskmovpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmaskmovpd, a, b, c);
        public Assembler Vmaskmovps(Operand.Memory a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmaskmovps, a, b, c);
        public Assembler Vmaskmovps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmaskmovps, a, b, c);
        public Assembler Vmaxpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmaxpd, a, b, c);
        public Assembler Vmaxpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmaxpd, a, b, c);
        public Assembler Vmaxps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmaxps, a, b, c);
        public Assembler Vmaxps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmaxps, a, b, c);
        public Assembler Vmaxsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmaxsd, a, b, c);
        public Assembler Vmaxsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmaxsd, a, b, c);
        public Assembler Vmaxss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmaxss, a, b, c);
        public Assembler Vmaxss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmaxss, a, b, c);
        public Assembler Vminpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vminpd, a, b, c);
        public Assembler Vminpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vminpd, a, b, c);
        public Assembler Vminps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vminps, a, b, c);
        public Assembler Vminps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vminps, a, b, c);
        public Assembler Vminsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vminsd, a, b, c);
        public Assembler Vminsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vminsd, a, b, c);
        public Assembler Vminss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vminss, a, b, c);
        public Assembler Vminss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vminss, a, b, c);
        public Assembler Vmovapd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovapd, a, b);
        public Assembler Vmovapd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovapd, a, b);
        public Assembler Vmovapd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovapd, a, b);
        public Assembler Vmovaps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovaps, a, b);
        public Assembler Vmovaps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovaps, a, b);
        public Assembler Vmovaps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovaps, a, b);
        public Assembler Vmovd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovd, a, b);
        public Assembler Vmovd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovd, a, b);
        public Assembler Vmovd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovd, a, b);
        public Assembler Vmovddup(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovddup, a, b);
        public Assembler Vmovddup(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovddup, a, b);
        public Assembler Vmovdqa(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqa, a, b);
        public Assembler Vmovdqa(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovdqa, a, b);
        public Assembler Vmovdqa(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqa, a, b);
        public Assembler Vmovdqa32(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqa32, a, b);
        public Assembler Vmovdqa32(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovdqa32, a, b);
        public Assembler Vmovdqa32(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqa32, a, b);
        public Assembler Vmovdqa64(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqa64, a, b);
        public Assembler Vmovdqa64(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovdqa64, a, b);
        public Assembler Vmovdqa64(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqa64, a, b);
        public Assembler Vmovdqu(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqu, a, b);
        public Assembler Vmovdqu(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovdqu, a, b);
        public Assembler Vmovdqu(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqu, a, b);
        public Assembler Vmovdqu16(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqu16, a, b);
        public Assembler Vmovdqu16(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovdqu16, a, b);
        public Assembler Vmovdqu16(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqu16, a, b);
        public Assembler Vmovdqu32(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqu32, a, b);
        public Assembler Vmovdqu32(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovdqu32, a, b);
        public Assembler Vmovdqu32(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqu32, a, b);
        public Assembler Vmovdqu64(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqu64, a, b);
        public Assembler Vmovdqu64(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovdqu64, a, b);
        public Assembler Vmovdqu64(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqu64, a, b);
        public Assembler Vmovdqu8(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqu8, a, b);
        public Assembler Vmovdqu8(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovdqu8, a, b);
        public Assembler Vmovdqu8(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovdqu8, a, b);
        public Assembler Vmovhlps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmovhlps, a, b, c);
        public Assembler Vmovhpd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovhpd, a, b);
        public Assembler Vmovhpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmovhpd, a, b, c);
        public Assembler Vmovhps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovhps, a, b);
        public Assembler Vmovhps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmovhps, a, b, c);
        public Assembler Vmovlhps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmovlhps, a, b, c);
        public Assembler Vmovlpd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovlpd, a, b);
        public Assembler Vmovlpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmovlpd, a, b, c);
        public Assembler Vmovlps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovlps, a, b);
        public Assembler Vmovlps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmovlps, a, b, c);
        public Assembler Vmovmskpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovmskpd, a, b);
        public Assembler Vmovmskps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovmskps, a, b);
        public Assembler Vmovntdq(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovntdq, a, b);
        public Assembler Vmovntdqa(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovntdqa, a, b);
        public Assembler Vmovntpd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovntpd, a, b);
        public Assembler Vmovntps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovntps, a, b);
        public Assembler Vmovq(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovq, a, b);
        public Assembler Vmovq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovq, a, b);
        public Assembler Vmovq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovq, a, b);
        public Assembler Vmovsd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovsd, a, b);
        public Assembler Vmovsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovsd, a, b);
        public Assembler Vmovsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmovsd, a, b, c);
        public Assembler Vmovshdup(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovshdup, a, b);
        public Assembler Vmovshdup(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovshdup, a, b);
        public Assembler Vmovsldup(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovsldup, a, b);
        public Assembler Vmovsldup(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovsldup, a, b);
        public Assembler Vmovss(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovss, a, b);
        public Assembler Vmovss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovss, a, b);
        public Assembler Vmovss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmovss, a, b, c);
        public Assembler Vmovupd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovupd, a, b);
        public Assembler Vmovupd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovupd, a, b);
        public Assembler Vmovupd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovupd, a, b);
        public Assembler Vmovups(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmovups, a, b);
        public Assembler Vmovups(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vmovups, a, b);
        public Assembler Vmovups(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vmovups, a, b);
        public Assembler Vmpsadbw(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vmpsadbw, a, b, c, d);
        public Assembler Vmpsadbw(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vmpsadbw, a, b, c, d);
        public Assembler Vmulpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmulpd, a, b, c);
        public Assembler Vmulpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmulpd, a, b, c);
        public Assembler Vmulps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmulps, a, b, c);
        public Assembler Vmulps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmulps, a, b, c);
        public Assembler Vmulsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmulsd, a, b, c);
        public Assembler Vmulsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmulsd, a, b, c);
        public Assembler Vmulss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vmulss, a, b, c);
        public Assembler Vmulss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vmulss, a, b, c);
        public Assembler Vorpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vorpd, a, b, c);
        public Assembler Vorpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vorpd, a, b, c);
        public Assembler Vorps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vorps, a, b, c);
        public Assembler Vorps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vorps, a, b, c);
        public Assembler Vpabsb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpabsb, a, b);
        public Assembler Vpabsb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpabsb, a, b);
        public Assembler Vpabsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpabsd, a, b);
        public Assembler Vpabsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpabsd, a, b);
        public Assembler Vpabsq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpabsq, a, b);
        public Assembler Vpabsq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpabsq, a, b);
        public Assembler Vpabsw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpabsw, a, b);
        public Assembler Vpabsw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpabsw, a, b);
        public Assembler Vpackssdw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpackssdw, a, b, c);
        public Assembler Vpackssdw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpackssdw, a, b, c);
        public Assembler Vpacksswb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpacksswb, a, b, c);
        public Assembler Vpacksswb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpacksswb, a, b, c);
        public Assembler Vpackusdw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpackusdw, a, b, c);
        public Assembler Vpackusdw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpackusdw, a, b, c);
        public Assembler Vpackuswb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpackuswb, a, b, c);
        public Assembler Vpackuswb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpackuswb, a, b, c);
        public Assembler Vpaddb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpaddb, a, b, c);
        public Assembler Vpaddb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpaddb, a, b, c);
        public Assembler Vpaddd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpaddd, a, b, c);
        public Assembler Vpaddd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpaddd, a, b, c);
        public Assembler Vpaddq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpaddq, a, b, c);
        public Assembler Vpaddq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpaddq, a, b, c);
        public Assembler Vpaddsb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpaddsb, a, b, c);
        public Assembler Vpaddsb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpaddsb, a, b, c);
        public Assembler Vpaddsw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpaddsw, a, b, c);
        public Assembler Vpaddsw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpaddsw, a, b, c);
        public Assembler Vpaddusb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpaddusb, a, b, c);
        public Assembler Vpaddusb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpaddusb, a, b, c);
        public Assembler Vpaddusw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpaddusw, a, b, c);
        public Assembler Vpaddusw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpaddusw, a, b, c);
        public Assembler Vpaddw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpaddw, a, b, c);
        public Assembler Vpaddw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpaddw, a, b, c);
        public Assembler Vpalignr(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpalignr, a, b, c, d);
        public Assembler Vpalignr(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpalignr, a, b, c, d);
        public Assembler Vpand(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpand, a, b, c);
        public Assembler Vpand(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpand, a, b, c);
        public Assembler Vpandd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpandd, a, b, c);
        public Assembler Vpandd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpandd, a, b, c);
        public Assembler Vpandn(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpandn, a, b, c);
        public Assembler Vpandn(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpandn, a, b, c);
        public Assembler Vpandnd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpandnd, a, b, c);
        public Assembler Vpandnd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpandnd, a, b, c);
        public Assembler Vpandnq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpandnq, a, b, c);
        public Assembler Vpandnq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpandnq, a, b, c);
        public Assembler Vpandq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpandq, a, b, c);
        public Assembler Vpandq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpandq, a, b, c);
        public Assembler Vpavgb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpavgb, a, b, c);
        public Assembler Vpavgb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpavgb, a, b, c);
        public Assembler Vpavgw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpavgw, a, b, c);
        public Assembler Vpavgw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpavgw, a, b, c);
        public Assembler Vpblendd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpblendd, a, b, c, d);
        public Assembler Vpblendd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpblendd, a, b, c, d);
        public Assembler Vpblendvb(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpblendvb, a, b, c, d);
        public Assembler Vpblendvb(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpblendvb, a, b, c, d);
        public Assembler Vpblendw(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpblendw, a, b, c, d);
        public Assembler Vpblendw(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpblendw, a, b, c, d);
        public Assembler Vpbroadcastb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpbroadcastb, a, b);
        public Assembler Vpbroadcastb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpbroadcastb, a, b);
        public Assembler Vpbroadcastd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpbroadcastd, a, b);
        public Assembler Vpbroadcastd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpbroadcastd, a, b);
        public Assembler Vpbroadcastmb2q(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpbroadcastmb2q, a, b);
        public Assembler Vpbroadcastq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpbroadcastq, a, b);
        public Assembler Vpbroadcastq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpbroadcastq, a, b);
        public Assembler Vpbroadcastw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpbroadcastw, a, b);
        public Assembler Vpbroadcastw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpbroadcastw, a, b);
        public Assembler Vpclmulqdq(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpclmulqdq, a, b, c, d);
        public Assembler Vpclmulqdq(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpclmulqdq, a, b, c, d);
        public Assembler Vpcmpb(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpb, a, b, c, d);
        public Assembler Vpcmpb(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpb, a, b, c, d);
        public Assembler Vpcmpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpd, a, b, c, d);
        public Assembler Vpcmpd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpd, a, b, c, d);
        public Assembler Vpcmpeqb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpcmpeqb, a, b, c);
        public Assembler Vpcmpeqb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpcmpeqb, a, b, c);
        public Assembler Vpcmpeqd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpcmpeqd, a, b, c);
        public Assembler Vpcmpeqd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpcmpeqd, a, b, c);
        public Assembler Vpcmpeqq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpcmpeqq, a, b, c);
        public Assembler Vpcmpeqq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpcmpeqq, a, b, c);
        public Assembler Vpcmpeqw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpcmpeqw, a, b, c);
        public Assembler Vpcmpeqw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpcmpeqw, a, b, c);
        public Assembler Vpcmpgtb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpcmpgtb, a, b, c);
        public Assembler Vpcmpgtb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpcmpgtb, a, b, c);
        public Assembler Vpcmpgtd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpcmpgtd, a, b, c);
        public Assembler Vpcmpgtd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpcmpgtd, a, b, c);
        public Assembler Vpcmpgtq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpcmpgtq, a, b, c);
        public Assembler Vpcmpgtq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpcmpgtq, a, b, c);
        public Assembler Vpcmpgtw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpcmpgtw, a, b, c);
        public Assembler Vpcmpgtw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpcmpgtw, a, b, c);
        public Assembler Vpcmpq(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpq, a, b, c, d);
        public Assembler Vpcmpq(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpq, a, b, c, d);
        public Assembler Vpcmpub(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpub, a, b, c, d);
        public Assembler Vpcmpub(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpub, a, b, c, d);
        public Assembler Vpcmpud(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpud, a, b, c, d);
        public Assembler Vpcmpud(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpud, a, b, c, d);
        public Assembler Vpcmpuq(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpuq, a, b, c, d);
        public Assembler Vpcmpuq(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpuq, a, b, c, d);
        public Assembler Vpcmpuw(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpuw, a, b, c, d);
        public Assembler Vpcmpuw(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpuw, a, b, c, d);
        public Assembler Vpcmpw(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpw, a, b, c, d);
        public Assembler Vpcmpw(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcmpw, a, b, c, d);
        public Assembler Vpcompressb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpcompressb, a, b);
        public Assembler Vpcompressb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpcompressb, a, b);
        public Assembler Vpcompressd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpcompressd, a, b);
        public Assembler Vpcompressd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpcompressd, a, b);
        public Assembler Vpcompressq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpcompressq, a, b);
        public Assembler Vpcompressq(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpcompressq, a, b);
        public Assembler Vpcompressw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpcompressw, a, b);
        public Assembler Vpcompressw(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpcompressw, a, b);
        public Assembler Vpconflictd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpconflictd, a, b);
        public Assembler Vpconflictd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpconflictd, a, b);
        public Assembler Vpconflictq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpconflictq, a, b);
        public Assembler Vpconflictq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpconflictq, a, b);
        public Assembler Vpdpbusd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpdpbusd, a, b, c);
        public Assembler Vpdpbusd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpdpbusd, a, b, c);
        public Assembler Vpdpbusds(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpdpbusds, a, b, c);
        public Assembler Vpdpbusds(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpdpbusds, a, b, c);
        public Assembler Vpdpwssd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpdpwssd, a, b, c);
        public Assembler Vpdpwssd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpdpwssd, a, b, c);
        public Assembler Vpdpwssds(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpdpwssds, a, b, c);
        public Assembler Vpdpwssds(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpdpwssds, a, b, c);
        public Assembler Vperm2f128(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vperm2f128, a, b, c, d);
        public Assembler Vperm2f128(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vperm2f128, a, b, c, d);
        public Assembler Vperm2i128(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vperm2i128, a, b, c, d);
        public Assembler Vperm2i128(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vperm2i128, a, b, c, d);
        public Assembler Vpermb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermb, a, b, c);
        public Assembler Vpermb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermb, a, b, c);
        public Assembler Vpermd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermd, a, b, c);
        public Assembler Vpermd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermd, a, b, c);
        public Assembler Vpermi2b(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermi2b, a, b, c);
        public Assembler Vpermi2b(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermi2b, a, b, c);
        public Assembler Vpermi2d(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermi2d, a, b, c);
        public Assembler Vpermi2d(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermi2d, a, b, c);
        public Assembler Vpermi2pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermi2pd, a, b, c);
        public Assembler Vpermi2pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermi2pd, a, b, c);
        public Assembler Vpermi2ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermi2ps, a, b, c);
        public Assembler Vpermi2ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermi2ps, a, b, c);
        public Assembler Vpermi2q(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermi2q, a, b, c);
        public Assembler Vpermi2q(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermi2q, a, b, c);
        public Assembler Vpermi2w(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermi2w, a, b, c);
        public Assembler Vpermi2w(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermi2w, a, b, c);
        public Assembler Vpermilpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermilpd, a, b, c);
        public Assembler Vpermilpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermilpd, a, b, c);
        public Assembler Vpermilpd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpermilpd, a, b, c);
        public Assembler Vpermilpd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpermilpd, a, b, c);
        public Assembler Vpermilps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermilps, a, b, c);
        public Assembler Vpermilps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermilps, a, b, c);
        public Assembler Vpermilps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpermilps, a, b, c);
        public Assembler Vpermilps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpermilps, a, b, c);
        public Assembler Vpermpd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpermpd, a, b, c);
        public Assembler Vpermpd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpermpd, a, b, c);
        public Assembler Vpermps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermps, a, b, c);
        public Assembler Vpermps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermps, a, b, c);
        public Assembler Vpermq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermq, a, b, c);
        public Assembler Vpermq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermq, a, b, c);
        public Assembler Vpermq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpermq, a, b, c);
        public Assembler Vpermq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpermq, a, b, c);
        public Assembler Vpermt2b(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermt2b, a, b, c);
        public Assembler Vpermt2b(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermt2b, a, b, c);
        public Assembler Vpermt2d(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermt2d, a, b, c);
        public Assembler Vpermt2d(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermt2d, a, b, c);
        public Assembler Vpermt2pd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermt2pd, a, b, c);
        public Assembler Vpermt2pd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermt2pd, a, b, c);
        public Assembler Vpermt2ps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermt2ps, a, b, c);
        public Assembler Vpermt2ps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermt2ps, a, b, c);
        public Assembler Vpermt2q(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermt2q, a, b, c);
        public Assembler Vpermt2q(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermt2q, a, b, c);
        public Assembler Vpermt2w(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermt2w, a, b, c);
        public Assembler Vpermt2w(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermt2w, a, b, c);
        public Assembler Vpermw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpermw, a, b, c);
        public Assembler Vpermw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpermw, a, b, c);
        public Assembler Vpexpandb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpexpandb, a, b);
        public Assembler Vpexpandb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpexpandb, a, b);
        public Assembler Vpexpandd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpexpandd, a, b);
        public Assembler Vpexpandd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpexpandd, a, b);
        public Assembler Vpexpandq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpexpandq, a, b);
        public Assembler Vpexpandq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpexpandq, a, b);
        public Assembler Vpexpandw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpexpandw, a, b);
        public Assembler Vpexpandw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpexpandw, a, b);
        public Assembler Vpextrb(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpextrb, a, b, c);
        public Assembler Vpextrb(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpextrb, a, b, c);
        public Assembler Vpextrd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpextrd, a, b, c);
        public Assembler Vpextrd(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpextrd, a, b, c);
        public Assembler Vpextrq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpextrq, a, b, c);
        public Assembler Vpextrq(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpextrq, a, b, c);
        public Assembler Vpextrw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpextrw, a, b, c);
        public Assembler Vpextrw(Operand.Memory a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpextrw, a, b, c);
        public Assembler Vpgatherdd(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpgatherdd, a, b, c);
        public Assembler Vpgatherdd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpgatherdd, a, b);
        public Assembler Vpgatherdq(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpgatherdq, a, b, c);
        public Assembler Vpgatherdq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpgatherdq, a, b);
        public Assembler Vpgatherqd(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpgatherqd, a, b, c);
        public Assembler Vpgatherqd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpgatherqd, a, b);
        public Assembler Vpgatherqq(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpgatherqq, a, b, c);
        public Assembler Vpgatherqq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpgatherqq, a, b);
        public Assembler Vphaddd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vphaddd, a, b, c);
        public Assembler Vphaddd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vphaddd, a, b, c);
        public Assembler Vphaddsw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vphaddsw, a, b, c);
        public Assembler Vphaddsw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vphaddsw, a, b, c);
        public Assembler Vphaddw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vphaddw, a, b, c);
        public Assembler Vphaddw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vphaddw, a, b, c);
        public Assembler Vphminposuw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphminposuw, a, b);
        public Assembler Vphminposuw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphminposuw, a, b);
        public Assembler Vphsubd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vphsubd, a, b, c);
        public Assembler Vphsubd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vphsubd, a, b, c);
        public Assembler Vphsubsw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vphsubsw, a, b, c);
        public Assembler Vphsubsw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vphsubsw, a, b, c);
        public Assembler Vphsubw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vphsubw, a, b, c);
        public Assembler Vphsubw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vphsubw, a, b, c);
        public Assembler Vpinsrb(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpinsrb, a, b, c, d);
        public Assembler Vpinsrb(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpinsrb, a, b, c, d);
        public Assembler Vpinsrd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpinsrd, a, b, c, d);
        public Assembler Vpinsrd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpinsrd, a, b, c, d);
        public Assembler Vpinsrq(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpinsrq, a, b, c, d);
        public Assembler Vpinsrq(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpinsrq, a, b, c, d);
        public Assembler Vpinsrw(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpinsrw, a, b, c, d);
        public Assembler Vpinsrw(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpinsrw, a, b, c, d);
        public Assembler Vplzcntd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vplzcntd, a, b);
        public Assembler Vplzcntd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vplzcntd, a, b);
        public Assembler Vplzcntq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vplzcntq, a, b);
        public Assembler Vplzcntq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vplzcntq, a, b);
        public Assembler Vpmadd52huq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmadd52huq, a, b, c);
        public Assembler Vpmadd52huq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmadd52huq, a, b, c);
        public Assembler Vpmadd52luq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmadd52luq, a, b, c);
        public Assembler Vpmadd52luq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmadd52luq, a, b, c);
        public Assembler Vpmaddubsw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaddubsw, a, b, c);
        public Assembler Vpmaddubsw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaddubsw, a, b, c);
        public Assembler Vpmaddwd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaddwd, a, b, c);
        public Assembler Vpmaddwd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaddwd, a, b, c);
        public Assembler Vpmaskmovd(Operand.Memory a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaskmovd, a, b, c);
        public Assembler Vpmaskmovd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaskmovd, a, b, c);
        public Assembler Vpmaskmovq(Operand.Memory a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaskmovq, a, b, c);
        public Assembler Vpmaskmovq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaskmovq, a, b, c);
        public Assembler Vpmaxsb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaxsb, a, b, c);
        public Assembler Vpmaxsb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaxsb, a, b, c);
        public Assembler Vpmaxsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaxsd, a, b, c);
        public Assembler Vpmaxsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaxsd, a, b, c);
        public Assembler Vpmaxsq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaxsq, a, b, c);
        public Assembler Vpmaxsq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaxsq, a, b, c);
        public Assembler Vpmaxsw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaxsw, a, b, c);
        public Assembler Vpmaxsw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaxsw, a, b, c);
        public Assembler Vpmaxub(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaxub, a, b, c);
        public Assembler Vpmaxub(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaxub, a, b, c);
        public Assembler Vpmaxud(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaxud, a, b, c);
        public Assembler Vpmaxud(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaxud, a, b, c);
        public Assembler Vpmaxuq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaxuq, a, b, c);
        public Assembler Vpmaxuq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaxuq, a, b, c);
        public Assembler Vpmaxuw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmaxuw, a, b, c);
        public Assembler Vpmaxuw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmaxuw, a, b, c);
        public Assembler Vpminsb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpminsb, a, b, c);
        public Assembler Vpminsb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpminsb, a, b, c);
        public Assembler Vpminsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpminsd, a, b, c);
        public Assembler Vpminsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpminsd, a, b, c);
        public Assembler Vpminsq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpminsq, a, b, c);
        public Assembler Vpminsq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpminsq, a, b, c);
        public Assembler Vpminsw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpminsw, a, b, c);
        public Assembler Vpminsw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpminsw, a, b, c);
        public Assembler Vpminub(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpminub, a, b, c);
        public Assembler Vpminub(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpminub, a, b, c);
        public Assembler Vpminud(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpminud, a, b, c);
        public Assembler Vpminud(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpminud, a, b, c);
        public Assembler Vpminuq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpminuq, a, b, c);
        public Assembler Vpminuq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpminuq, a, b, c);
        public Assembler Vpminuw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpminuw, a, b, c);
        public Assembler Vpminuw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpminuw, a, b, c);
        public Assembler Vpmovb2m(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovb2m, a, b);
        public Assembler Vpmovd2m(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovd2m, a, b);
        public Assembler Vpmovdb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovdb, a, b);
        public Assembler Vpmovdb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovdb, a, b);
        public Assembler Vpmovdw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovdw, a, b);
        public Assembler Vpmovdw(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovdw, a, b);
        public Assembler Vpmovm2b(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovm2b, a, b);
        public Assembler Vpmovm2d(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovm2d, a, b);
        public Assembler Vpmovm2q(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovm2q, a, b);
        public Assembler Vpmovm2w(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovm2w, a, b);
        public Assembler Vpmovmskb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovmskb, a, b);
        public Assembler Vpmovq2m(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovq2m, a, b);
        public Assembler Vpmovqb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovqb, a, b);
        public Assembler Vpmovqb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovqb, a, b);
        public Assembler Vpmovqd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovqd, a, b);
        public Assembler Vpmovqd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovqd, a, b);
        public Assembler Vpmovqw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovqw, a, b);
        public Assembler Vpmovqw(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovqw, a, b);
        public Assembler Vpmovsdb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsdb, a, b);
        public Assembler Vpmovsdb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsdb, a, b);
        public Assembler Vpmovsdw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsdw, a, b);
        public Assembler Vpmovsdw(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsdw, a, b);
        public Assembler Vpmovsqb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsqb, a, b);
        public Assembler Vpmovsqb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsqb, a, b);
        public Assembler Vpmovsqd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsqd, a, b);
        public Assembler Vpmovsqd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsqd, a, b);
        public Assembler Vpmovsqw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsqw, a, b);
        public Assembler Vpmovsqw(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsqw, a, b);
        public Assembler Vpmovswb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovswb, a, b);
        public Assembler Vpmovswb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovswb, a, b);
        public Assembler Vpmovsxbd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsxbd, a, b);
        public Assembler Vpmovsxbd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovsxbd, a, b);
        public Assembler Vpmovsxbq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsxbq, a, b);
        public Assembler Vpmovsxbq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovsxbq, a, b);
        public Assembler Vpmovsxbw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsxbw, a, b);
        public Assembler Vpmovsxbw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovsxbw, a, b);
        public Assembler Vpmovsxdq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsxdq, a, b);
        public Assembler Vpmovsxdq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovsxdq, a, b);
        public Assembler Vpmovsxwd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsxwd, a, b);
        public Assembler Vpmovsxwd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovsxwd, a, b);
        public Assembler Vpmovsxwq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovsxwq, a, b);
        public Assembler Vpmovsxwq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovsxwq, a, b);
        public Assembler Vpmovusdb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovusdb, a, b);
        public Assembler Vpmovusdb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovusdb, a, b);
        public Assembler Vpmovusdw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovusdw, a, b);
        public Assembler Vpmovusdw(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovusdw, a, b);
        public Assembler Vpmovusqb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovusqb, a, b);
        public Assembler Vpmovusqb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovusqb, a, b);
        public Assembler Vpmovusqd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovusqd, a, b);
        public Assembler Vpmovusqd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovusqd, a, b);
        public Assembler Vpmovusqw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovusqw, a, b);
        public Assembler Vpmovusqw(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovusqw, a, b);
        public Assembler Vpmovuswb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovuswb, a, b);
        public Assembler Vpmovuswb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovuswb, a, b);
        public Assembler Vpmovw2m(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovw2m, a, b);
        public Assembler Vpmovwb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovwb, a, b);
        public Assembler Vpmovwb(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovwb, a, b);
        public Assembler Vpmovzxbd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovzxbd, a, b);
        public Assembler Vpmovzxbd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovzxbd, a, b);
        public Assembler Vpmovzxbq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovzxbq, a, b);
        public Assembler Vpmovzxbq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovzxbq, a, b);
        public Assembler Vpmovzxbw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovzxbw, a, b);
        public Assembler Vpmovzxbw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovzxbw, a, b);
        public Assembler Vpmovzxdq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovzxdq, a, b);
        public Assembler Vpmovzxdq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovzxdq, a, b);
        public Assembler Vpmovzxwd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovzxwd, a, b);
        public Assembler Vpmovzxwd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovzxwd, a, b);
        public Assembler Vpmovzxwq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpmovzxwq, a, b);
        public Assembler Vpmovzxwq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpmovzxwq, a, b);
        public Assembler Vpmuldq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmuldq, a, b, c);
        public Assembler Vpmuldq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmuldq, a, b, c);
        public Assembler Vpmulhrsw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmulhrsw, a, b, c);
        public Assembler Vpmulhrsw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmulhrsw, a, b, c);
        public Assembler Vpmulhuw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmulhuw, a, b, c);
        public Assembler Vpmulhuw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmulhuw, a, b, c);
        public Assembler Vpmulhw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmulhw, a, b, c);
        public Assembler Vpmulhw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmulhw, a, b, c);
        public Assembler Vpmulld(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmulld, a, b, c);
        public Assembler Vpmulld(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmulld, a, b, c);
        public Assembler Vpmullq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmullq, a, b, c);
        public Assembler Vpmullq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmullq, a, b, c);
        public Assembler Vpmullw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmullw, a, b, c);
        public Assembler Vpmullw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmullw, a, b, c);
        public Assembler Vpmultishiftqb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmultishiftqb, a, b, c);
        public Assembler Vpmultishiftqb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmultishiftqb, a, b, c);
        public Assembler Vpmuludq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpmuludq, a, b, c);
        public Assembler Vpmuludq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpmuludq, a, b, c);
        public Assembler Vpopcntb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpopcntb, a, b);
        public Assembler Vpopcntb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpopcntb, a, b);
        public Assembler Vpopcntd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpopcntd, a, b);
        public Assembler Vpopcntd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpopcntd, a, b);
        public Assembler Vpopcntq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpopcntq, a, b);
        public Assembler Vpopcntq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpopcntq, a, b);
        public Assembler Vpopcntw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vpopcntw, a, b);
        public Assembler Vpopcntw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vpopcntw, a, b);
        public Assembler Vpor(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpor, a, b, c);
        public Assembler Vpor(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpor, a, b, c);
        public Assembler Vpord(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpord, a, b, c);
        public Assembler Vpord(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpord, a, b, c);
        public Assembler Vporq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vporq, a, b, c);
        public Assembler Vporq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vporq, a, b, c);
        public Assembler Vprold(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprold, a, b, c);
        public Assembler Vprold(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprold, a, b, c);
        public Assembler Vprolq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprolq, a, b, c);
        public Assembler Vprolq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprolq, a, b, c);
        public Assembler Vprolvd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vprolvd, a, b, c);
        public Assembler Vprolvd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vprolvd, a, b, c);
        public Assembler Vprolvq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vprolvq, a, b, c);
        public Assembler Vprolvq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vprolvq, a, b, c);
        public Assembler Vprord(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprord, a, b, c);
        public Assembler Vprord(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprord, a, b, c);
        public Assembler Vprorq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprorq, a, b, c);
        public Assembler Vprorq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprorq, a, b, c);
        public Assembler Vprorvd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vprorvd, a, b, c);
        public Assembler Vprorvd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vprorvd, a, b, c);
        public Assembler Vprorvq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vprorvq, a, b, c);
        public Assembler Vprorvq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vprorvq, a, b, c);
        public Assembler Vpsadbw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsadbw, a, b, c);
        public Assembler Vpsadbw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsadbw, a, b, c);
        public Assembler Vpscatterdd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpscatterdd, a, b);
        public Assembler Vpscatterdq(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpscatterdq, a, b);
        public Assembler Vpscatterqd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpscatterqd, a, b);
        public Assembler Vpscatterqq(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vpscatterqq, a, b);
        public Assembler Vpshldd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpshldd, a, b, c, d);
        public Assembler Vpshldd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpshldd, a, b, c, d);
        public Assembler Vpshldvd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshldvd, a, b, c);
        public Assembler Vpshldvd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshldvd, a, b, c);
        public Assembler Vpshldvq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshldvq, a, b, c);
        public Assembler Vpshldvq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshldvq, a, b, c);
        public Assembler Vpshldvw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshldvw, a, b, c);
        public Assembler Vpshldvw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshldvw, a, b, c);
        public Assembler Vpshrdd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpshrdd, a, b, c, d);
        public Assembler Vpshrdd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpshrdd, a, b, c, d);
        public Assembler Vpshrdvd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshrdvd, a, b, c);
        public Assembler Vpshrdvd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshrdvd, a, b, c);
        public Assembler Vpshrdvq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshrdvq, a, b, c);
        public Assembler Vpshrdvq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshrdvq, a, b, c);
        public Assembler Vpshrdvw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshrdvw, a, b, c);
        public Assembler Vpshrdvw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshrdvw, a, b, c);
        public Assembler Vpshrdw(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpshrdw, a, b, c, d);
        public Assembler Vpshrdw(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpshrdw, a, b, c, d);
        public Assembler Vpshufb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshufb, a, b, c);
        public Assembler Vpshufb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshufb, a, b, c);
        public Assembler Vpshufbitqmb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshufbitqmb, a, b, c);
        public Assembler Vpshufbitqmb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshufbitqmb, a, b, c);
        public Assembler Vpshufd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpshufd, a, b, c);
        public Assembler Vpshufd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpshufd, a, b, c);
        public Assembler Vpshufhw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpshufhw, a, b, c);
        public Assembler Vpshufhw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpshufhw, a, b, c);
        public Assembler Vpshuflw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpshuflw, a, b, c);
        public Assembler Vpshuflw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpshuflw, a, b, c);
        public Assembler Vpsignb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsignb, a, b, c);
        public Assembler Vpsignb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsignb, a, b, c);
        public Assembler Vpsignd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsignd, a, b, c);
        public Assembler Vpsignd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsignd, a, b, c);
        public Assembler Vpsignw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsignw, a, b, c);
        public Assembler Vpsignw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsignw, a, b, c);
        public Assembler Vpslld(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpslld, a, b, c);
        public Assembler Vpslld(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpslld, a, b, c);
        public Assembler Vpslld(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpslld, a, b, c);
        public Assembler Vpslld(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpslld, a, b, c);
        public Assembler Vpslldq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpslldq, a, b, c);
        public Assembler Vpslldq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpslldq, a, b, c);
        public Assembler Vpsllq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsllq, a, b, c);
        public Assembler Vpsllq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsllq, a, b, c);
        public Assembler Vpsllq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsllq, a, b, c);
        public Assembler Vpsllq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsllq, a, b, c);
        public Assembler Vpsllvd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsllvd, a, b, c);
        public Assembler Vpsllvd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsllvd, a, b, c);
        public Assembler Vpsllvq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsllvq, a, b, c);
        public Assembler Vpsllvq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsllvq, a, b, c);
        public Assembler Vpsllvw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsllvw, a, b, c);
        public Assembler Vpsllvw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsllvw, a, b, c);
        public Assembler Vpsllw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsllw, a, b, c);
        public Assembler Vpsllw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsllw, a, b, c);
        public Assembler Vpsllw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsllw, a, b, c);
        public Assembler Vpsllw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsllw, a, b, c);
        public Assembler Vpsrad(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsrad, a, b, c);
        public Assembler Vpsrad(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsrad, a, b, c);
        public Assembler Vpsrad(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsrad, a, b, c);
        public Assembler Vpsrad(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsrad, a, b, c);
        public Assembler Vpsraq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsraq, a, b, c);
        public Assembler Vpsraq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsraq, a, b, c);
        public Assembler Vpsraq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsraq, a, b, c);
        public Assembler Vpsraq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsraq, a, b, c);
        public Assembler Vpsravd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsravd, a, b, c);
        public Assembler Vpsravd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsravd, a, b, c);
        public Assembler Vpsravq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsravq, a, b, c);
        public Assembler Vpsravq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsravq, a, b, c);
        public Assembler Vpsravw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsravw, a, b, c);
        public Assembler Vpsravw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsravw, a, b, c);
        public Assembler Vpsraw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsraw, a, b, c);
        public Assembler Vpsraw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsraw, a, b, c);
        public Assembler Vpsraw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsraw, a, b, c);
        public Assembler Vpsraw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsraw, a, b, c);
        public Assembler Vpsrld(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsrld, a, b, c);
        public Assembler Vpsrld(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsrld, a, b, c);
        public Assembler Vpsrld(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsrld, a, b, c);
        public Assembler Vpsrld(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsrld, a, b, c);
        public Assembler Vpsrldq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsrldq, a, b, c);
        public Assembler Vpsrldq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsrldq, a, b, c);
        public Assembler Vpsrlq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsrlq, a, b, c);
        public Assembler Vpsrlq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsrlq, a, b, c);
        public Assembler Vpsrlq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsrlq, a, b, c);
        public Assembler Vpsrlq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsrlq, a, b, c);
        public Assembler Vpsrlvd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsrlvd, a, b, c);
        public Assembler Vpsrlvd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsrlvd, a, b, c);
        public Assembler Vpsrlvq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsrlvq, a, b, c);
        public Assembler Vpsrlvq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsrlvq, a, b, c);
        public Assembler Vpsrlvw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsrlvw, a, b, c);
        public Assembler Vpsrlvw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsrlvw, a, b, c);
        public Assembler Vpsrlw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsrlw, a, b, c);
        public Assembler Vpsrlw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsrlw, a, b, c);
        public Assembler Vpsrlw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsrlw, a, b, c);
        public Assembler Vpsrlw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpsrlw, a, b, c);
        public Assembler Vpsubb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsubb, a, b, c);
        public Assembler Vpsubb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsubb, a, b, c);
        public Assembler Vpsubd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsubd, a, b, c);
        public Assembler Vpsubd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsubd, a, b, c);
        public Assembler Vpsubq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsubq, a, b, c);
        public Assembler Vpsubq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsubq, a, b, c);
        public Assembler Vpsubsb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsubsb, a, b, c);
        public Assembler Vpsubsb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsubsb, a, b, c);
        public Assembler Vpsubsw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsubsw, a, b, c);
        public Assembler Vpsubsw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsubsw, a, b, c);
        public Assembler Vpsubusb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsubusb, a, b, c);
        public Assembler Vpsubusb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsubusb, a, b, c);
        public Assembler Vpsubusw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsubusw, a, b, c);
        public Assembler Vpsubusw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsubusw, a, b, c);
        public Assembler Vpsubw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpsubw, a, b, c);
        public Assembler Vpsubw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpsubw, a, b, c);
        public Assembler Vpternlogd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpternlogd, a, b, c, d);
        public Assembler Vpternlogd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpternlogd, a, b, c, d);
        public Assembler Vpternlogq(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpternlogq, a, b, c, d);
        public Assembler Vpternlogq(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpternlogq, a, b, c, d);
        public Assembler Vptest(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vptest, a, b);
        public Assembler Vptest(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vptest, a, b);
        public Assembler Vptestmb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vptestmb, a, b, c);
        public Assembler Vptestmb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vptestmb, a, b, c);
        public Assembler Vptestmd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vptestmd, a, b, c);
        public Assembler Vptestmd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vptestmd, a, b, c);
        public Assembler Vptestmq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vptestmq, a, b, c);
        public Assembler Vptestmq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vptestmq, a, b, c);
        public Assembler Vptestmw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vptestmw, a, b, c);
        public Assembler Vptestmw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vptestmw, a, b, c);
        public Assembler Vptestnmb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vptestnmb, a, b, c);
        public Assembler Vptestnmb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vptestnmb, a, b, c);
        public Assembler Vptestnmd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vptestnmd, a, b, c);
        public Assembler Vptestnmd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vptestnmd, a, b, c);
        public Assembler Vptestnmq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vptestnmq, a, b, c);
        public Assembler Vptestnmq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vptestnmq, a, b, c);
        public Assembler Vptestnmw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vptestnmw, a, b, c);
        public Assembler Vptestnmw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vptestnmw, a, b, c);
        public Assembler Vpunpckhbw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpunpckhbw, a, b, c);
        public Assembler Vpunpckhbw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpunpckhbw, a, b, c);
        public Assembler Vpunpckhdq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpunpckhdq, a, b, c);
        public Assembler Vpunpckhdq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpunpckhdq, a, b, c);
        public Assembler Vpunpckhqdq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpunpckhqdq, a, b, c);
        public Assembler Vpunpckhqdq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpunpckhqdq, a, b, c);
        public Assembler Vpunpckhwd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpunpckhwd, a, b, c);
        public Assembler Vpunpckhwd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpunpckhwd, a, b, c);
        public Assembler Vpunpcklbw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpunpcklbw, a, b, c);
        public Assembler Vpunpcklbw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpunpcklbw, a, b, c);
        public Assembler Vpunpckldq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpunpckldq, a, b, c);
        public Assembler Vpunpckldq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpunpckldq, a, b, c);
        public Assembler Vpunpcklqdq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpunpcklqdq, a, b, c);
        public Assembler Vpunpcklqdq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpunpcklqdq, a, b, c);
        public Assembler Vpunpcklwd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpunpcklwd, a, b, c);
        public Assembler Vpunpcklwd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpunpcklwd, a, b, c);
        public Assembler Vpxor(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpxor, a, b, c);
        public Assembler Vpxor(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpxor, a, b, c);
        public Assembler Vpxord(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpxord, a, b, c);
        public Assembler Vpxord(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpxord, a, b, c);
        public Assembler Vpxorq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpxorq, a, b, c);
        public Assembler Vpxorq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpxorq, a, b, c);
        public Assembler Vrangepd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrangepd, a, b, c, d);
        public Assembler Vrangepd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrangepd, a, b, c, d);
        public Assembler Vrangeps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrangeps, a, b, c, d);
        public Assembler Vrangeps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrangeps, a, b, c, d);
        public Assembler Vrangesd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrangesd, a, b, c, d);
        public Assembler Vrangesd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrangesd, a, b, c, d);
        public Assembler Vrangess(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrangess, a, b, c, d);
        public Assembler Vrangess(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrangess, a, b, c, d);
        public Assembler Vrcp14pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vrcp14pd, a, b);
        public Assembler Vrcp14pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vrcp14pd, a, b);
        public Assembler Vrcp14ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vrcp14ps, a, b);
        public Assembler Vrcp14ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vrcp14ps, a, b);
        public Assembler Vrcp14sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vrcp14sd, a, b, c);
        public Assembler Vrcp14sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vrcp14sd, a, b, c);
        public Assembler Vrcp14ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vrcp14ss, a, b, c);
        public Assembler Vrcp14ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vrcp14ss, a, b, c);
        public Assembler Vrcp28pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vrcp28pd, a, b);
        public Assembler Vrcp28pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vrcp28pd, a, b);
        public Assembler Vrcp28ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vrcp28ps, a, b);
        public Assembler Vrcp28ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vrcp28ps, a, b);
        public Assembler Vrcp28sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vrcp28sd, a, b, c);
        public Assembler Vrcp28sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vrcp28sd, a, b, c);
        public Assembler Vrcp28ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vrcp28ss, a, b, c);
        public Assembler Vrcp28ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vrcp28ss, a, b, c);
        public Assembler Vrcpps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vrcpps, a, b);
        public Assembler Vrcpps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vrcpps, a, b);
        public Assembler Vrcpss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vrcpss, a, b, c);
        public Assembler Vrcpss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vrcpss, a, b, c);
        public Assembler Vreducepd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vreducepd, a, b, c);
        public Assembler Vreducepd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vreducepd, a, b, c);
        public Assembler Vreduceps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vreduceps, a, b, c);
        public Assembler Vreduceps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vreduceps, a, b, c);
        public Assembler Vreducesd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vreducesd, a, b, c, d);
        public Assembler Vreducesd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vreducesd, a, b, c, d);
        public Assembler Vreducess(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vreducess, a, b, c, d);
        public Assembler Vreducess(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vreducess, a, b, c, d);
        public Assembler Vrndscalepd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vrndscalepd, a, b, c);
        public Assembler Vrndscalepd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vrndscalepd, a, b, c);
        public Assembler Vrndscaleps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vrndscaleps, a, b, c);
        public Assembler Vrndscaleps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vrndscaleps, a, b, c);
        public Assembler Vrndscalesd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrndscalesd, a, b, c, d);
        public Assembler Vrndscalesd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrndscalesd, a, b, c, d);
        public Assembler Vrndscaless(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrndscaless, a, b, c, d);
        public Assembler Vrndscaless(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vrndscaless, a, b, c, d);
        public Assembler Vroundpd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vroundpd, a, b, c);
        public Assembler Vroundpd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vroundpd, a, b, c);
        public Assembler Vroundps(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vroundps, a, b, c);
        public Assembler Vroundps(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vroundps, a, b, c);
        public Assembler Vroundsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vroundsd, a, b, c, d);
        public Assembler Vroundsd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vroundsd, a, b, c, d);
        public Assembler Vroundss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vroundss, a, b, c, d);
        public Assembler Vroundss(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vroundss, a, b, c, d);
        public Assembler Vrsqrt14pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vrsqrt14pd, a, b);
        public Assembler Vrsqrt14pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vrsqrt14pd, a, b);
        public Assembler Vrsqrt14ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vrsqrt14ps, a, b);
        public Assembler Vrsqrt14ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vrsqrt14ps, a, b);
        public Assembler Vrsqrt14sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vrsqrt14sd, a, b, c);
        public Assembler Vrsqrt14sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vrsqrt14sd, a, b, c);
        public Assembler Vrsqrt14ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vrsqrt14ss, a, b, c);
        public Assembler Vrsqrt14ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vrsqrt14ss, a, b, c);
        public Assembler Vrsqrt28pd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vrsqrt28pd, a, b);
        public Assembler Vrsqrt28pd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vrsqrt28pd, a, b);
        public Assembler Vrsqrt28ps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vrsqrt28ps, a, b);
        public Assembler Vrsqrt28ps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vrsqrt28ps, a, b);
        public Assembler Vrsqrt28sd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vrsqrt28sd, a, b, c);
        public Assembler Vrsqrt28sd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vrsqrt28sd, a, b, c);
        public Assembler Vrsqrt28ss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vrsqrt28ss, a, b, c);
        public Assembler Vrsqrt28ss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vrsqrt28ss, a, b, c);
        public Assembler Vrsqrtps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vrsqrtps, a, b);
        public Assembler Vrsqrtps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vrsqrtps, a, b);
        public Assembler Vrsqrtss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vrsqrtss, a, b, c);
        public Assembler Vrsqrtss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vrsqrtss, a, b, c);
        public Assembler Vscalefpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vscalefpd, a, b, c);
        public Assembler Vscalefpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vscalefpd, a, b, c);
        public Assembler Vscalefps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vscalefps, a, b, c);
        public Assembler Vscalefps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vscalefps, a, b, c);
        public Assembler Vscalefsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vscalefsd, a, b, c);
        public Assembler Vscalefsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vscalefsd, a, b, c);
        public Assembler Vscalefss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vscalefss, a, b, c);
        public Assembler Vscalefss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vscalefss, a, b, c);
        public Assembler Vscatterdpd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vscatterdpd, a, b);
        public Assembler Vscatterdps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vscatterdps, a, b);
        public Assembler Vscatterpf0dpd(Operand.Memory a) => CreateInstr(Mnemonic.Vscatterpf0dpd, a);
        public Assembler Vscatterpf0dps(Operand.Memory a) => CreateInstr(Mnemonic.Vscatterpf0dps, a);
        public Assembler Vscatterpf0qpd(Operand.Memory a) => CreateInstr(Mnemonic.Vscatterpf0qpd, a);
        public Assembler Vscatterpf0qps(Operand.Memory a) => CreateInstr(Mnemonic.Vscatterpf0qps, a);
        public Assembler Vscatterpf1dpd(Operand.Memory a) => CreateInstr(Mnemonic.Vscatterpf1dpd, a);
        public Assembler Vscatterpf1dps(Operand.Memory a) => CreateInstr(Mnemonic.Vscatterpf1dps, a);
        public Assembler Vscatterpf1qpd(Operand.Memory a) => CreateInstr(Mnemonic.Vscatterpf1qpd, a);
        public Assembler Vscatterpf1qps(Operand.Memory a) => CreateInstr(Mnemonic.Vscatterpf1qps, a);
        public Assembler Vscatterqpd(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vscatterqpd, a, b);
        public Assembler Vscatterqps(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Vscatterqps, a, b);
        public Assembler Vshuff32x4(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshuff32x4, a, b, c, d);
        public Assembler Vshuff32x4(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshuff32x4, a, b, c, d);
        public Assembler Vshuff64x2(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshuff64x2, a, b, c, d);
        public Assembler Vshuff64x2(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshuff64x2, a, b, c, d);
        public Assembler Vshufi32x4(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshufi32x4, a, b, c, d);
        public Assembler Vshufi32x4(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshufi32x4, a, b, c, d);
        public Assembler Vshufi64x2(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshufi64x2, a, b, c, d);
        public Assembler Vshufi64x2(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshufi64x2, a, b, c, d);
        public Assembler Vshufpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshufpd, a, b, c, d);
        public Assembler Vshufpd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshufpd, a, b, c, d);
        public Assembler Vshufps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshufps, a, b, c, d);
        public Assembler Vshufps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vshufps, a, b, c, d);
        public Assembler Vsqrtpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vsqrtpd, a, b);
        public Assembler Vsqrtpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vsqrtpd, a, b);
        public Assembler Vsqrtps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vsqrtps, a, b);
        public Assembler Vsqrtps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vsqrtps, a, b);
        public Assembler Vsqrtsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vsqrtsd, a, b, c);
        public Assembler Vsqrtsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vsqrtsd, a, b, c);
        public Assembler Vsqrtss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vsqrtss, a, b, c);
        public Assembler Vsqrtss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vsqrtss, a, b, c);
        public Assembler Vstmxcsr(Operand.Memory a) => CreateInstr(Mnemonic.Vstmxcsr, a);
        public Assembler Vsubpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vsubpd, a, b, c);
        public Assembler Vsubpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vsubpd, a, b, c);
        public Assembler Vsubps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vsubps, a, b, c);
        public Assembler Vsubps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vsubps, a, b, c);
        public Assembler Vsubsd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vsubsd, a, b, c);
        public Assembler Vsubsd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vsubsd, a, b, c);
        public Assembler Vsubss(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vsubss, a, b, c);
        public Assembler Vsubss(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vsubss, a, b, c);
        public Assembler Vtestpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vtestpd, a, b);
        public Assembler Vtestpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vtestpd, a, b);
        public Assembler Vtestps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vtestps, a, b);
        public Assembler Vtestps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vtestps, a, b);
        public Assembler Vucomisd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vucomisd, a, b);
        public Assembler Vucomisd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vucomisd, a, b);
        public Assembler Vucomiss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vucomiss, a, b);
        public Assembler Vucomiss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vucomiss, a, b);
        public Assembler Vunpckhpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vunpckhpd, a, b, c);
        public Assembler Vunpckhpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vunpckhpd, a, b, c);
        public Assembler Vunpckhps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vunpckhps, a, b, c);
        public Assembler Vunpckhps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vunpckhps, a, b, c);
        public Assembler Vunpcklpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vunpcklpd, a, b, c);
        public Assembler Vunpcklpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vunpcklpd, a, b, c);
        public Assembler Vunpcklps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vunpcklps, a, b, c);
        public Assembler Vunpcklps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vunpcklps, a, b, c);
        public Assembler Vxorpd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vxorpd, a, b, c);
        public Assembler Vxorpd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vxorpd, a, b, c);
        public Assembler Vxorps(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vxorps, a, b, c);
        public Assembler Vxorps(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vxorps, a, b, c);
        public Assembler Vzeroall() => CreateInstr(Mnemonic.Vzeroall);
        public Assembler Vzeroupper() => CreateInstr(Mnemonic.Vzeroupper);
        public Assembler Vfmaddpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddpd, a, b, c, d);
        public Assembler Vfmaddpd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddpd, a, b, c, d);
        public Assembler Vfmaddpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmaddpd, a, b, c, d);
        public Assembler Vfmaddps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddps, a, b, c, d);
        public Assembler Vfmaddps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddps, a, b, c, d);
        public Assembler Vfmaddps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmaddps, a, b, c, d);
        public Assembler Vfmaddsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddsd, a, b, c, d);
        public Assembler Vfmaddsd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddsd, a, b, c, d);
        public Assembler Vfmaddsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmaddsd, a, b, c, d);
        public Assembler Vfmaddss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddss, a, b, c, d);
        public Assembler Vfmaddss(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddss, a, b, c, d);
        public Assembler Vfmaddss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmaddss, a, b, c, d);
        public Assembler Vfmaddsubpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddsubpd, a, b, c, d);
        public Assembler Vfmaddsubpd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddsubpd, a, b, c, d);
        public Assembler Vfmaddsubpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmaddsubpd, a, b, c, d);
        public Assembler Vfmaddsubps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddsubps, a, b, c, d);
        public Assembler Vfmaddsubps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmaddsubps, a, b, c, d);
        public Assembler Vfmaddsubps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmaddsubps, a, b, c, d);
        public Assembler Vfmsubaddpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubaddpd, a, b, c, d);
        public Assembler Vfmsubaddpd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubaddpd, a, b, c, d);
        public Assembler Vfmsubaddpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmsubaddpd, a, b, c, d);
        public Assembler Vfmsubaddps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubaddps, a, b, c, d);
        public Assembler Vfmsubaddps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubaddps, a, b, c, d);
        public Assembler Vfmsubaddps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmsubaddps, a, b, c, d);
        public Assembler Vfmsubpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubpd, a, b, c, d);
        public Assembler Vfmsubpd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubpd, a, b, c, d);
        public Assembler Vfmsubpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmsubpd, a, b, c, d);
        public Assembler Vfmsubps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubps, a, b, c, d);
        public Assembler Vfmsubps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubps, a, b, c, d);
        public Assembler Vfmsubps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmsubps, a, b, c, d);
        public Assembler Vfmsubsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubsd, a, b, c, d);
        public Assembler Vfmsubsd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubsd, a, b, c, d);
        public Assembler Vfmsubsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmsubsd, a, b, c, d);
        public Assembler Vfmsubss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubss, a, b, c, d);
        public Assembler Vfmsubss(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfmsubss, a, b, c, d);
        public Assembler Vfmsubss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfmsubss, a, b, c, d);
        public Assembler Vfnmaddpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmaddpd, a, b, c, d);
        public Assembler Vfnmaddpd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmaddpd, a, b, c, d);
        public Assembler Vfnmaddpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfnmaddpd, a, b, c, d);
        public Assembler Vfnmaddps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmaddps, a, b, c, d);
        public Assembler Vfnmaddps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmaddps, a, b, c, d);
        public Assembler Vfnmaddps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfnmaddps, a, b, c, d);
        public Assembler Vfnmaddsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmaddsd, a, b, c, d);
        public Assembler Vfnmaddsd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmaddsd, a, b, c, d);
        public Assembler Vfnmaddsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfnmaddsd, a, b, c, d);
        public Assembler Vfnmaddss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmaddss, a, b, c, d);
        public Assembler Vfnmaddss(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmaddss, a, b, c, d);
        public Assembler Vfnmaddss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfnmaddss, a, b, c, d);
        public Assembler Vfnmsubpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmsubpd, a, b, c, d);
        public Assembler Vfnmsubpd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmsubpd, a, b, c, d);
        public Assembler Vfnmsubpd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfnmsubpd, a, b, c, d);
        public Assembler Vfnmsubps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmsubps, a, b, c, d);
        public Assembler Vfnmsubps(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmsubps, a, b, c, d);
        public Assembler Vfnmsubps(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfnmsubps, a, b, c, d);
        public Assembler Vfnmsubsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmsubsd, a, b, c, d);
        public Assembler Vfnmsubsd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmsubsd, a, b, c, d);
        public Assembler Vfnmsubsd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfnmsubsd, a, b, c, d);
        public Assembler Vfnmsubss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmsubss, a, b, c, d);
        public Assembler Vfnmsubss(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vfnmsubss, a, b, c, d);
        public Assembler Vfnmsubss(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vfnmsubss, a, b, c, d);
        public Assembler Vfrczpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vfrczpd, a, b);
        public Assembler Vfrczpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vfrczpd, a, b);
        public Assembler Vfrczps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vfrczps, a, b);
        public Assembler Vfrczps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vfrczps, a, b);
        public Assembler Vfrczsd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vfrczsd, a, b);
        public Assembler Vfrczsd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vfrczsd, a, b);
        public Assembler Vfrczss(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vfrczss, a, b);
        public Assembler Vfrczss(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vfrczss, a, b);
        public Assembler Vpcmov(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpcmov, a, b, c, d);
        public Assembler Vpcmov(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpcmov, a, b, c, d);
        public Assembler Vpcmov(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vpcmov, a, b, c, d);
        public Assembler Vpcomb(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomb, a, b, c, d);
        public Assembler Vpcomb(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomb, a, b, c, d);
        public Assembler Vpcomd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomd, a, b, c, d);
        public Assembler Vpcomd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomd, a, b, c, d);
        public Assembler Vpcomq(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomq, a, b, c, d);
        public Assembler Vpcomq(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomq, a, b, c, d);
        public Assembler Vpcomw(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomw, a, b, c, d);
        public Assembler Vpcomw(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomw, a, b, c, d);
        public Assembler Vpcomub(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomub, a, b, c, d);
        public Assembler Vpcomub(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomub, a, b, c, d);
        public Assembler Vpcomud(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomud, a, b, c, d);
        public Assembler Vpcomud(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomud, a, b, c, d);
        public Assembler Vpcomuq(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomuq, a, b, c, d);
        public Assembler Vpcomuq(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomuq, a, b, c, d);
        public Assembler Vpcomuw(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomuw, a, b, c, d);
        public Assembler Vpcomuw(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Immediate d) => CreateInstr(Mnemonic.Vpcomuw, a, b, c, d);
        public Assembler Vphaddbd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphaddbd, a, b);
        public Assembler Vphaddbd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphaddbd, a, b);
        public Assembler Vphaddbq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphaddbq, a, b);
        public Assembler Vphaddbq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphaddbq, a, b);
        public Assembler Vphaddbw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphaddbw, a, b);
        public Assembler Vphaddbw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphaddbw, a, b);
        public Assembler Vphadddq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphadddq, a, b);
        public Assembler Vphadddq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphadddq, a, b);
        public Assembler Vphaddwd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphaddwd, a, b);
        public Assembler Vphaddwd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphaddwd, a, b);
        public Assembler Vphaddwq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphaddwq, a, b);
        public Assembler Vphaddwq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphaddwq, a, b);
        public Assembler Vphaddubd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphaddubd, a, b);
        public Assembler Vphaddubd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphaddubd, a, b);
        public Assembler Vphaddubq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphaddubq, a, b);
        public Assembler Vphaddubq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphaddubq, a, b);
        public Assembler Vphaddubw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphaddubw, a, b);
        public Assembler Vphaddubw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphaddubw, a, b);
        public Assembler Vphaddudq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphaddudq, a, b);
        public Assembler Vphaddudq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphaddudq, a, b);
        public Assembler Vphadduwd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphadduwd, a, b);
        public Assembler Vphadduwd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphadduwd, a, b);
        public Assembler Vphadduwq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphadduwq, a, b);
        public Assembler Vphadduwq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphadduwq, a, b);
        public Assembler Vphsubbw(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphsubbw, a, b);
        public Assembler Vphsubbw(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphsubbw, a, b);
        public Assembler Vphsubdq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphsubdq, a, b);
        public Assembler Vphsubdq(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphsubdq, a, b);
        public Assembler Vphsubwd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vphsubwd, a, b);
        public Assembler Vphsubwd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Vphsubwd, a, b);
        public Assembler Vpmacsdd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacsdd, a, b, c, d);
        public Assembler Vpmacsdd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacsdd, a, b, c, d);
        public Assembler Vpmacsdqh(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacsdqh, a, b, c, d);
        public Assembler Vpmacsdqh(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacsdqh, a, b, c, d);
        public Assembler Vpmacsdql(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacsdql, a, b, c, d);
        public Assembler Vpmacsdql(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacsdql, a, b, c, d);
        public Assembler Vpmacswd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacswd, a, b, c, d);
        public Assembler Vpmacswd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacswd, a, b, c, d);
        public Assembler Vpmacsww(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacsww, a, b, c, d);
        public Assembler Vpmacsww(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacsww, a, b, c, d);
        public Assembler Vpmacssdd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacssdd, a, b, c, d);
        public Assembler Vpmacssdd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacssdd, a, b, c, d);
        public Assembler Vpmacssdqh(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacssdqh, a, b, c, d);
        public Assembler Vpmacssdqh(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacssdqh, a, b, c, d);
        public Assembler Vpmacssdql(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacssdql, a, b, c, d);
        public Assembler Vpmacssdql(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacssdql, a, b, c, d);
        public Assembler Vpmacsswd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacsswd, a, b, c, d);
        public Assembler Vpmacsswd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacsswd, a, b, c, d);
        public Assembler Vpmacssww(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacssww, a, b, c, d);
        public Assembler Vpmacssww(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmacssww, a, b, c, d);
        public Assembler Vpmadcsswd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmadcsswd, a, b, c, d);
        public Assembler Vpmadcsswd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmadcsswd, a, b, c, d);
        public Assembler Vpmadcswd(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpmadcswd, a, b, c, d);
        public Assembler Vpmadcswd(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpmadcswd, a, b, c, d);
        public Assembler Vpperm(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Register d) => CreateInstr(Mnemonic.Vpperm, a, b, c, d);
        public Assembler Vpperm(Operand.Register a, Operand.Register b, Operand.Memory c, Operand.Register d) => CreateInstr(Mnemonic.Vpperm, a, b, c, d);
        public Assembler Vpperm(Operand.Register a, Operand.Register b, Operand.Register c, Operand.Memory d) => CreateInstr(Mnemonic.Vpperm, a, b, c, d);
        public Assembler Vprotb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vprotb, a, b, c);
        public Assembler Vprotb(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vprotb, a, b, c);
        public Assembler Vprotb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vprotb, a, b, c);
        public Assembler Vprotb(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprotb, a, b, c);
        public Assembler Vprotb(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprotb, a, b, c);
        public Assembler Vprotd(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vprotd, a, b, c);
        public Assembler Vprotd(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vprotd, a, b, c);
        public Assembler Vprotd(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vprotd, a, b, c);
        public Assembler Vprotd(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprotd, a, b, c);
        public Assembler Vprotd(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprotd, a, b, c);
        public Assembler Vprotq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vprotq, a, b, c);
        public Assembler Vprotq(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vprotq, a, b, c);
        public Assembler Vprotq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vprotq, a, b, c);
        public Assembler Vprotq(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprotq, a, b, c);
        public Assembler Vprotq(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprotq, a, b, c);
        public Assembler Vprotw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vprotw, a, b, c);
        public Assembler Vprotw(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vprotw, a, b, c);
        public Assembler Vprotw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vprotw, a, b, c);
        public Assembler Vprotw(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprotw, a, b, c);
        public Assembler Vprotw(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vprotw, a, b, c);
        public Assembler Vpshab(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshab, a, b, c);
        public Assembler Vpshab(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpshab, a, b, c);
        public Assembler Vpshab(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshab, a, b, c);
        public Assembler Vpshad(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshad, a, b, c);
        public Assembler Vpshad(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpshad, a, b, c);
        public Assembler Vpshad(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshad, a, b, c);
        public Assembler Vpshaq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshaq, a, b, c);
        public Assembler Vpshaq(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpshaq, a, b, c);
        public Assembler Vpshaq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshaq, a, b, c);
        public Assembler Vpshaw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshaw, a, b, c);
        public Assembler Vpshaw(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpshaw, a, b, c);
        public Assembler Vpshaw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshaw, a, b, c);
        public Assembler Vpshlb(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshlb, a, b, c);
        public Assembler Vpshlb(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpshlb, a, b, c);
        public Assembler Vpshlb(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshlb, a, b, c);
        public Assembler Vpshld(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshld, a, b, c);
        public Assembler Vpshld(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpshld, a, b, c);
        public Assembler Vpshld(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshld, a, b, c);
        public Assembler Vpshlq(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshlq, a, b, c);
        public Assembler Vpshlq(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpshlq, a, b, c);
        public Assembler Vpshlq(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshlq, a, b, c);
        public Assembler Vpshlw(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Vpshlw, a, b, c);
        public Assembler Vpshlw(Operand.Register a, Operand.Memory b, Operand.Register c) => CreateInstr(Mnemonic.Vpshlw, a, b, c);
        public Assembler Vpshlw(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Vpshlw, a, b, c);
        public Assembler Cbw() => CreateInstr(Mnemonic.Cbw);
        public Assembler Cdq() => CreateInstr(Mnemonic.Cdq);
        public Assembler Cdqe() => CreateInstr(Mnemonic.Cdqe);
        public Assembler Cmpxchg(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Cmpxchg, a, b);
        public Assembler Cmpxchg(Operand.Memory a, Operand.Register b) => CreateInstr(Mnemonic.Cmpxchg, a, b);
        public Assembler Cmpxchg16b(Operand.Memory a) => CreateInstr(Mnemonic.Cmpxchg16b, a);
        public Assembler Cmpxchg8b(Operand.Memory a) => CreateInstr(Mnemonic.Cmpxchg8b, a);
        public Assembler Cpuid() => CreateInstr(Mnemonic.Cpuid);
        public Assembler Cqo() => CreateInstr(Mnemonic.Cqo);
        public Assembler Cwd() => CreateInstr(Mnemonic.Cwd);
        public Assembler Cwde() => CreateInstr(Mnemonic.Cwde);
        public Assembler Daa() => CreateInstr(Mnemonic.Daa);
        public Assembler Das() => CreateInstr(Mnemonic.Das);
        public Assembler Div(Operand.Register a) => CreateInstr(Mnemonic.Div, a);
        public Assembler Div(Operand.Memory a) => CreateInstr(Mnemonic.Div, a);
        public Assembler Idiv(Operand.Register a) => CreateInstr(Mnemonic.Idiv, a);
        public Assembler Idiv(Operand.Memory a) => CreateInstr(Mnemonic.Idiv, a);
        public Assembler Imul(Operand.Register a) => CreateInstr(Mnemonic.Imul, a);
        public Assembler Imul(Operand.Memory a) => CreateInstr(Mnemonic.Imul, a);
        public Assembler Iret() => CreateInstr(Mnemonic.Iret);
        public Assembler Iretd() => CreateInstr(Mnemonic.Iretd);
        public Assembler Iretq() => CreateInstr(Mnemonic.Iretq);
        //public Assembler Jecxz(Label a) => CreateInstr(Mnemonic.Jecxz, a);
        public Assembler Jecxz(Operand.Immediate a) => CreateInstr(Mnemonic.Jecxz, a);
        public Assembler Lahf() => CreateInstr(Mnemonic.Lahf);
        //public Assembler Loop(Label a) => CreateInstr(Mnemonic.Loop, a);
        public Assembler Loop(Operand.Immediate a) => CreateInstr(Mnemonic.Loop, a);
        //public Assembler Loope(Label a) => CreateInstr(Mnemonic.Loope, a);
        public Assembler Loope(Operand.Immediate a) => CreateInstr(Mnemonic.Loope, a);
        //public Assembler Loopne(Label a) => CreateInstr(Mnemonic.Loopne, a);
        public Assembler Loopne(Operand.Immediate a) => CreateInstr(Mnemonic.Loopne, a);
        public Assembler Mul(Operand.Register a) => CreateInstr(Mnemonic.Mul, a);
        public Assembler Mul(Operand.Memory a) => CreateInstr(Mnemonic.Mul, a);
        public Assembler Rdmsr() => CreateInstr(Mnemonic.Rdmsr);
        public Assembler Rdpmc() => CreateInstr(Mnemonic.Rdpmc);
        public Assembler Rdtsc() => CreateInstr(Mnemonic.Rdtsc);
        public Assembler Rdtscp() => CreateInstr(Mnemonic.Rdtscp);
        public Assembler Ret() => CreateInstr(Mnemonic.Ret);
        public Assembler Ret(Operand.Immediate a) => CreateInstr(Mnemonic.Ret, a);
        public Assembler Sahf() => CreateInstr(Mnemonic.Sahf);
        public Assembler Syscall() => CreateInstr(Mnemonic.Syscall);
        public Assembler Sysenter() => CreateInstr(Mnemonic.Sysenter);
        public Assembler Sysexit() => CreateInstr(Mnemonic.Sysexit);
        public Assembler Sysexit64() => CreateInstr(Mnemonic.Sysexit);
        public Assembler Sysret() => CreateInstr(Mnemonic.Sysret);
        public Assembler Sysret64() => CreateInstr(Mnemonic.Sysret);
        public Assembler Wrmsr() => CreateInstr(Mnemonic.Wrmsr);
        public Assembler Xlatb() => CreateInstr(Mnemonic.Xlat);
        //! \name CL Instructions
        public Assembler Clzero() => CreateInstr(Mnemonic.Clzero);
        public Assembler Mulx(Operand.Register a, Operand.Register b, Operand.Register c) => CreateInstr(Mnemonic.Mulx, a, b, c);
        public Assembler Mulx(Operand.Register a, Operand.Register b, Operand.Memory c) => CreateInstr(Mnemonic.Mulx, a, b, c);
        public Assembler Xgetbv() => CreateInstr(Mnemonic.Xgetbv);
        public Assembler Xrstor(Operand.Memory a) => CreateInstr(Mnemonic.Xrstor, a);
        public Assembler Xrstor64(Operand.Memory a) => CreateInstr(Mnemonic.Xrstor64, a);
        public Assembler Xrstors(Operand.Memory a) => CreateInstr(Mnemonic.Xrstors, a);
        public Assembler Xrstors64(Operand.Memory a) => CreateInstr(Mnemonic.Xrstors64, a);
        public Assembler Xsave(Operand.Memory a) => CreateInstr(Mnemonic.Xsave, a);
        public Assembler Xsave64(Operand.Memory a) => CreateInstr(Mnemonic.Xsave64, a);
        public Assembler Xsavec(Operand.Memory a) => CreateInstr(Mnemonic.Xsavec, a);
        public Assembler Xsavec64(Operand.Memory a) => CreateInstr(Mnemonic.Xsavec64, a);
        public Assembler Xsaveopt(Operand.Memory a) => CreateInstr(Mnemonic.Xsaveopt, a);
        public Assembler Xsaveopt64(Operand.Memory a) => CreateInstr(Mnemonic.Xsaveopt64, a);
        public Assembler Xsaves(Operand.Memory a) => CreateInstr(Mnemonic.Xsaves, a);
        public Assembler Xsaves64(Operand.Memory a) => CreateInstr(Mnemonic.Xsaves64, a);
        public Assembler Xsetbv() => CreateInstr(Mnemonic.Xsetbv);

        public Assembler Monitor() => CreateInstr(Mnemonic.Monitor);
        public Assembler Monitorx() => CreateInstr(Mnemonic.Monitorx);
        public Assembler Mwait() => CreateInstr(Mnemonic.Mwait);
        public Assembler Mwaitx() => CreateInstr(Mnemonic.Mwaitx);
        //! \}
        //! \name MMX & SSE Instructions
        //! \{
        public Assembler Blendvpd(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blendvpd, a, b);
        public Assembler Blendvpd(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blendvpd, a, b);
        public Assembler Blendvps(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Blendvps, a, b);
        public Assembler Blendvps(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Blendvps, a, b);
        public Assembler Pblendvb(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Pblendvb, a, b);
        public Assembler Pblendvb(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Pblendvb, a, b);
        public Assembler Maskmovq(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Maskmovq, a, b);
        public Assembler Maskmovdqu(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Maskmovdqu, a, b);
        public Assembler Pcmpestri(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pcmpestri, a, b, c);
        public Assembler Pcmpestri(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pcmpestri, a, b, c);
        public Assembler Pcmpestrm(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pcmpestrm, a, b, c);
        public Assembler Pcmpestrm(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pcmpestrm, a, b, c);
        public Assembler Pcmpistri(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pcmpistri, a, b, c);
        public Assembler Pcmpistri(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pcmpistri, a, b, c);
        public Assembler Pcmpistrm(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Pcmpistrm, a, b, c);
        public Assembler Pcmpistrm(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Pcmpistrm, a, b, c);
        public Assembler Sha256rnds2(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Sha256rnds2, a, b);
        public Assembler Sha256rnds2(Operand.Register a, Operand.Memory b) => CreateInstr(Mnemonic.Sha256rnds2, a, b);
        public Assembler Vmaskmovdqu(Operand.Register a, Operand.Register b) => CreateInstr(Mnemonic.Vmaskmovdqu, a, b);
        public Assembler Vpcmpestri(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpcmpestri, a, b, c);
        public Assembler Vpcmpestri(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpcmpestri, a, b, c);
        public Assembler Vpcmpestrm(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpcmpestrm, a, b, c);
        public Assembler Vpcmpestrm(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpcmpestrm, a, b, c);
        public Assembler Vpcmpistri(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpcmpistri, a, b, c);
        public Assembler Vpcmpistri(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpcmpistri, a, b, c);
        public Assembler Vpcmpistrm(Operand.Register a, Operand.Register b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpcmpistrm, a, b, c);
        public Assembler Vpcmpistrm(Operand.Register a, Operand.Memory b, Operand.Immediate c) => CreateInstr(Mnemonic.Vpcmpistrm, a, b, c);

        public Assembler Jmp(Label a) => CreateInstr(Mnemonic.Jmp, a);
        public Assembler Jmp(Operand.Register a) => CreateInstr(Mnemonic.Jmp, a);
        public Assembler Jmp(Operand.Memory a) => CreateInstr(Mnemonic.Jmp, a);
        public Assembler Jmp(Operand.Immediate a) => CreateInstr(Mnemonic.Jmp, a);

        public Assembler Jnz(Label a) => CreateInstr(Mnemonic.Jnz, a);
        public Assembler Jnz(Operand.Immediate a) => CreateInstr(Mnemonic.Jnz, a);

        public Assembler Jz(Label a) => CreateInstr(Mnemonic.Jz, a);
        public Assembler Jz(Operand.Immediate a) => CreateInstr(Mnemonic.Jz, a);

        public Assembler Jnb(Label a) => CreateInstr(Mnemonic.Jnb, a);
        public Assembler Jnb(Operand.Immediate a) => CreateInstr(Mnemonic.Jnb, a);

        public Assembler Jno(Label a) => CreateInstr(Mnemonic.Jno, a);
        public Assembler Jno(Operand.Immediate a) => CreateInstr(Mnemonic.Jno, a);

        public Assembler Js(Label a) => CreateInstr(Mnemonic.Js, a);
        public Assembler Js(Operand.Immediate a) => CreateInstr(Mnemonic.Js, a);

        public Assembler Jp(Label a) => CreateInstr(Mnemonic.Jp, a);
        public Assembler Jp(Operand.Immediate a) => CreateInstr(Mnemonic.Jp, a);

        public Assembler Call(Operand.Register a) => CreateInstr(Mnemonic.Call, a);
        public Assembler Call(Operand.Memory a) => CreateInstr(Mnemonic.Call, a);
        public Assembler Call(Label a) => CreateInstr(Mnemonic.Call, a);
        public Assembler Call(Operand.Immediate a) => CreateInstr(Mnemonic.Call, a);
    }
}

```

`src/Dotx64Managed/API/Assembler.cs`:

```cs
using System;
using System.Collections.Generic;

namespace Dotx64Dbg
{
    internal class LabelData
    {
        internal Label Label;
        internal NodeList.Node Node;
    }

    public partial class Assembler : IDisposable
    {
        private NodeList Nodes = new();
        public NodeList.Node Cursor { get; set; }

        internal Encoder Encoder;

        internal bool disposed = false;

        internal Instruction.Attributes AttribState;

        internal List<LabelData> Labels = new();


        public class NodeInstr : NodeList.NodeKind<Instruction>
        {
        }

        public class NodeData : NodeList.NodeKind<byte[]>
        {
        }

        public class NodeLabel : NodeList.NodeKind<Label>
        {

        }

        public Assembler()
        {
            Encoder = Dotx64Dbg.Encoder.Create((nuint)0);
        }

        public Assembler(nuint baseVA = 0)
        {
            Encoder = Dotx64Dbg.Encoder.Create(baseVA);
        }

        public NodeList.Node Head { get => Nodes.Head; }
        public NodeList.Node Tail { get => Nodes.Tail; }

        public NodeList GetNodes()
        {
            return Nodes;
        }

        public Label CreateLabel()
        {
            var data = new LabelData()
            {
                Label = new Label(Labels.Count),
                Node = null,
            };

            Labels.Add(data);

            return data.Label;
        }

        public Assembler BindLabel(Label label)
        {
            var labelData = Labels[label.Value];
            if (labelData.Node != null)
            {
                throw new Exception("Label is already bound, can not bind twice.");
            }

            var node = new NodeLabel() { Value = label };
            labelData.Node = node;

            Cursor = Nodes.InsertAfter(Cursor, node);

            return this;
        }

        internal Assembler CreateInstr(Mnemonic id)
        {
            var node = new NodeInstr() { Value = InstructionGenerator.Generate(AttribState, id) };
            AttribState = Instruction.Attributes.None;
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        internal Assembler CreateInstr(Mnemonic id, IOperand op0)
        {
            var node = new NodeInstr() { Value = InstructionGenerator.Generate(AttribState, id, op0) };
            AttribState = Instruction.Attributes.None;
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        internal Assembler CreateInstr(Mnemonic id, IOperand op0, IOperand op1)
        {
            var node = new NodeInstr() { Value = InstructionGenerator.Generate(AttribState, id, op0, op1) };
            AttribState = Instruction.Attributes.None;
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        internal Assembler CreateInstr(Mnemonic id, IOperand op0, IOperand op1, IOperand op2)
        {
            var node = new NodeInstr() { Value = InstructionGenerator.Generate(AttribState, id, op0, op1, op2) };
            AttribState = Instruction.Attributes.None;
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        internal Assembler CreateInstr(Mnemonic id, IOperand op0, IOperand op1, IOperand op2, IOperand op3)
        {
            var node = new NodeInstr() { Value = InstructionGenerator.Generate(AttribState, id, op0, op1, op2, op3) };
            AttribState = Instruction.Attributes.None;
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        public Assembler Emit(Instruction instr)
        {
            // Max explicit operands.
            var ops = new IOperand[] { Operand.None, Operand.None, Operand.None, Operand.None };
            var numOps = 0;
            for (int i = 0; i < Instruction.MaxOperands; i++)
            {
                if (instr.GetOperandVisibility(i) == OperandVisibility.Hidden)
                    continue;
                var op = instr.GetOperand(i);
                if (op.Type == OperandType.None)
                    continue;
                ops[numOps] = instr.GetOperand(i);
                numOps++;
            }
            var node = new NodeInstr() { Value = InstructionGenerator.Generate(instr.Attribs, instr.Id, ops[0], ops[1], ops[2], ops[3]) };
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        public Assembler Db(byte val)
        {
            var node = new NodeData() { Value = new byte[] { val } };
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        public Assembler Dw(ushort val)
        {
            var node = new NodeData() { Value = BitConverter.GetBytes(val) };
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        public Assembler Dw(short val)
        {
            var node = new NodeData() { Value = BitConverter.GetBytes(val) };
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        public Assembler Dd(UInt32 val)
        {
            var node = new NodeData() { Value = BitConverter.GetBytes(val) };
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        public Assembler Dd(Int32 val)
        {
            var node = new NodeData() { Value = BitConverter.GetBytes(val) };
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        public Assembler Dq(UInt64 val)
        {
            var node = new NodeData() { Value = BitConverter.GetBytes(val) };
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        public Assembler Dq(Int64 val)
        {
            var node = new NodeData() { Value = BitConverter.GetBytes(val) };
            Cursor = Nodes.InsertAfter(Cursor, node);
            return this;
        }

        public Assembler Lock()
        {
            AttribState |= Instruction.Attributes.Lock;
            return this;
        }

        public Assembler Rep()
        {
            AttribState |= Instruction.Attributes.Rep;
            return this;
        }
        public Assembler RepNe()
        {
            AttribState |= Instruction.Attributes.RepNe;
            return this;
        }

        public bool Finalize()
        {
            // Encode everything.
            var node = Head;
            while (node != null)
            {
                if (node is NodeInstr nodeInstr)
                {
                    if (!Encoder.Encode(nodeInstr.Value))
                    {
                        return false;
                    }
                }
                else if (node is NodeLabel nodeLabel)
                {
                    if (!Encoder.BindLabel(nodeLabel.Value))
                    {
                        return false;
                    }
                }
                node = node.Next;
            }

            return true;

        }

        public void Reset()
        {
            Encoder.Reset();
            Nodes = new();
            Cursor = null;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposed)
                return;

            if (disposing)
            {
                Encoder = null;
                Nodes = null;
                Labels = null;
            }

            disposed = true;
        }

        public bool RelocateTo(nuint newBaseVA)
        {
            return Encoder.RelocateTo(newBaseVA);
        }

        public byte[] GetData()
        {
            return Encoder.GetData();
        }

        public nuint GetLabelBaseOffset(Label label)
        {
            return Encoder.GetLabelBaseOffset(label);
        }

        public nuint GetLabelOffset(Label label)
        {
            return Encoder.GetLabelOffset(label);
        }
    }
}

```

`src/Dotx64Managed/API/Breakpoints.cs`:

```cs
namespace Dotx64Dbg
{
    using BreakpointsNative = Native.Breakpoints;

    public static class Breakpoints
    {
        public enum Type
        {
            None = 0,
            Software = (1 << 0),
            Hardware = (1 << 1),
            Memory = (1 << 2),
            Dll = (1 << 3),
            Exception = (1 << 4),
            System = (1 << 5),

            Normal = Software, // Backwards compatibility
        };

        public enum HardwareType
        {
            Access = BreakpointsNative.HardwareType.HardwareAccess,
            Write = BreakpointsNative.HardwareType.HardwareWrite,
            Execute = BreakpointsNative.HardwareType.HardwareExecute
        };

        public static bool SetBreakpoint(nuint address)
        {
            return BreakpointsNative.SetBreakpoint(address);
        }

        public static bool DeleteBreakpoint(nuint address)
        {
            return BreakpointsNative.DeleteBreakpoint(address);
        }

        public static bool DisableBreakpoint(nuint address)
        {
            return BreakpointsNative.DisableBreakpoint(address);
        }

        public static bool SetHardwareBreakpoint(nuint address, HardwareType type)
        {
            return BreakpointsNative.SetHardwareBreakpoint(address, (BreakpointsNative.HardwareType)type);
        }

        public static bool DeleteHardwareBreakpoint(nuint address)
        {
            return BreakpointsNative.DeleteHardwareBreakpoint(address);
        }
    }
}

```

`src/Dotx64Managed/API/Commands.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace Dotx64Dbg
{
    /// <summary>
    /// Command attribute to dynamically register commands in x64Dbg.
    /// </summary>
    public class Command : Attribute
    {
        /// <summary>
        /// Name of the command.
        /// </summary>
        public string Name { get; internal set; }

        /// <summary>
        /// If DebugOnly is set to true the command be only executed when the debugger is active.
        /// </summary>
        public bool DebugOnly { get; set; } = false;

        /// <summary>
        /// Default constructor.
        /// </summary>
        public Command(string Name)
        {
            this.Name = Name;
        }
    }

    internal static class Commands
    {
        public delegate bool Handler(string[] args);

        internal delegate bool HandlerNoArgs();
        internal delegate void HandlerVoid(string[] args);
        internal delegate void HandlerVoidNoArgs();

        internal struct CommandInfo
        {
            public Plugin Plugin;
            public Handler Handler;
        }

        internal static Dictionary<string, CommandInfo> Registered;

        internal static void Initialize()
        {
            Registered = new();
        }

        internal static bool CommandHandler(string cmd, int argc, IntPtr ptr)
        {
            CommandInfo info;

            if (!Registered.TryGetValue(cmd, out info))
                return false;

            string[] args = new string[argc];

            int elementSize = Marshal.SizeOf(typeof(IntPtr));
            for (int i = 0; i < argc; i++)
            {
                var stringPtr = Marshal.ReadIntPtr(ptr, i * elementSize);
                args[i] = Marshal.PtrToStringAnsi(stringPtr);
            }

            return info.Handler(args);
        }

        internal static bool Register(Plugin Plugin, string cmd, bool debugOnly, Handler handler)
        {
            if (Registered.ContainsKey(cmd))
            {
                //throw new Exception($"Command '{cmd}' already registered");
                return false;
            }

            CommandInfo info = new()
            {
                Plugin = Plugin,
                Handler = handler
            };

            Registered.Add(cmd, info);

            return Native.Commands.RegisterCommand(Manager.PluginHandle, cmd, debugOnly, delegate (int argc, System.IntPtr argv)
            {
                try
                {
                    return CommandHandler(cmd, argc, argv);
                }
                catch (Exception ex)
                {
                    Utils.PrintException(ex);
                    return false;
                }
            });
        }

        internal static bool Remove(string cmd)
        {
            if (!Registered.ContainsKey(cmd))
            {
                //throw new Exception($"Command '{cmd}' not registered");
                return false;
            }

            Registered.Remove(cmd);

            return Native.Commands.UnregisterCommand(Manager.PluginHandle, cmd);
        }

        internal static bool RemoveAll()
        {
            bool res = true;

            foreach (var kv in Registered)
            {
                if (!Native.Commands.UnregisterCommand(Manager.PluginHandle, kv.Key))
                    res = false;
            }

            Registered.Clear();

            return res;
        }

        internal static bool RemoveAllFor(Plugin plugin)
        {
            Registered.Where(x => x.Value.Plugin == plugin)
                .Select(x => x.Key)
                .ToList()
                .ForEach(name =>
            {
                Remove(name);
            });

            return true;
        }

    }
}

```

`src/Dotx64Managed/API/Debugger.cs`:

```cs
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    /// <summary>
    /// A class to control the debugger.
    /// </summary>
    public static class Debugger
    {
        /// <summary>
        /// If the debugger has a process and its valid this will be true.
        /// </summary>
        public static bool IsActive { get => Native.Debugger.IsActive(); }

        /// <summary>
        /// Waits for the debugger to be paused.
        /// The function will not return before the debugger paused.
        /// </summary>
        public static void WaitForPause()
        {
            Native.Debugger.Wait();
        }

        /// <summary>
        /// Signals the debugger to resume all execution in the debug process, returns immediately.
        /// </summary>
        public static void Run()
        {
            Native.Debugger.Run();
        }

        public static void RunAsync()
        {
            //Native.Debugger.Run();
            Debugger.RunCommandAsync("run");
        }

        /// <summary>
        /// Signals the debugger to pause, will block until the debugger stopped.
        /// </summary>
        public static void Pause()
        {
            Native.Debugger.Pause();
        }

        /// <summary>
        /// Signals the debugger to stop, will block until the debugger stopped.
        /// </summary>
        public static void Stop()
        {
            Native.Debugger.Stop();
        }

        /// <summary>
        /// Signals the debugger to step in, will block until the debugger stopped.
        /// </summary>
        public static void StepIn()
        {
            Native.Debugger.StepIn();
        }

        public static void StepInAsync()
        {
            Debugger.RunCommandAsync("sti");
        }

        /// <summary>
        /// Signals the debugger to step over, will block until the debugger stopped.
        /// </summary>
        public static void StepOver()
        {
            Native.Debugger.StepOver();
        }

        public static void StepOverAsync()
        {
            Debugger.RunCommandAsync("sto");
        }

        /// <summary>
        /// Signals the debugger to step out, will block until the debugger stopped.
        /// </summary>
        public static void StepOut()
        {
            Native.Debugger.StepOut();
        }

        public static void StepOutAsync()
        {
            Debugger.RunCommandAsync("rtr");
        }

        /// <summary>
        /// Performs synchronous execution of a debugger command. This function call only
        /// returns after the command has completed.
        ///
        /// Example: Debugger.RunCommand("loadlib advapi32.dll")
        /// </summary>
        /// <param name="cmd">The command to execute.</param>
        /// <returns>True if the command executed successfully, False if there was a problem.</returns>
        public static bool RunCommand(string cmd)
        {
            return Native.Debugger.RunCommand(cmd);
        }

        /// <summary>
        /// Asynchronously execute a debugger command by adding it to the command queue.
        /// Note: the command may not have completed before this call returns. Use this
        /// function if you don't care when the command gets executed.
        ///
        /// Example: Debugger.RunCommandAsync("ClearLog")
        /// </summary>
        /// <param name="cmd">The command to execute.</param>
        /// <returns>True if the command was successfully submitted to the command queue. False if the submission failed.</returns>
        public static bool RunCommandAsync(string cmd)
        {
            return Native.Debugger.RunCommandAsync(cmd);
        }
    }
}

```

`src/Dotx64Managed/API/Expressions.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace Dotx64Dbg
{
    /// <summary>
    /// Expression attribute to dynamically register expression functions in x64Dbg.
    /// </summary>
    public class Expression : Attribute
    {
        /// <summary>
        /// Name of the command.
        /// </summary>
        public string Name { get; internal set; }

        /// <summary>
        /// Default constructor.
        /// </summary>
        public Expression(string Name)
        {
            this.Name = Name;
        }
    }

    public static class Expressions
    {
        internal struct ExpressionInfo
        {
            public Plugin plugin;
        }

        internal static Dictionary<string, ExpressionInfo> Registered;

        internal static void Initialize()
        {
            Registered = new();
        }

        /// <summary>
        /// Evaluates the given expression and results the evaluated value.
        /// </summary>
        /// <param name="expr">Expression</param>
        /// <param name="value">Resulting value</param>
        /// <returns>True on success, false in case of errors</returns>
        /// <example>
        /// <code>
        /// ulong val = 0;
        /// if(Expression.TryEvaluate("rip", val)) { Console.WriteLine("Value of rip {0}", val); }
        /// </code>
        /// </example>

        public static bool TryEvaluate(string expr, out nuint value)
        {
            IntPtr val;
            var res = Native.Expressions.TryEvaluate(expr, out val);
            value = (nuint)(nint)val;
            return res;
        }

        /// <summary>
        /// Same as TryEvaluate except the function throws if the expression is invalid.
        /// </summary>
        /// <see cref="TryEvaluate"/>
        public static nuint Evaluate(string expr)
        {
            return (nuint)(nint)Native.Expressions.Evaluate(expr);
        }

        /// <summary>
        /// Formats the given the expression and results the formatted string.
        /// </summary>
        /// <param name="expr">Expression to format</param>
        /// <param name="value">Resulting formatted expression</param>
        /// <returns>True on success, false in case of any errors</returns>
        /// <example>
        /// <code>
        /// string formatted;
        /// if(Expression.TryFormat("rip = {rip}", formatted)) { Console.WriteLine("Formatted: {0}", formatted); }
        /// </code>
        /// </example>
        public static bool TryFormat(string expr, out string value)
        {
            return Native.Expressions.TryFormat(expr, out value);
        }

        /// <summary>
        /// Same as TryFormat except the function throws if the expression is invalid.
        /// </summary>
        /// <see cref="TryFormat"/>
        public static string Format(string expr)
        {
            return Native.Expressions.Format(expr);
        }

        /// <summary>
        /// Checks if the provided expression is valid.
        /// </summary>
        /// <param name="expr">Expression to validate</param>
        /// <returns>True if the expression is valid, false in case of errors</returns>
        public static bool IsValidExpression(string expr)
        {
            return Native.Expressions.IsValidExpression(expr);
        }

        public delegate nuint ExpressionFunc0();
        public delegate nuint ExpressionFunc1(nuint a);
        public delegate nuint ExpressionFunc2(nuint a, nuint b);
        public delegate nuint ExpressionFunc3(nuint a, nuint b, nuint c);

        internal static int PointerSize = Marshal.SizeOf(typeof(System.IntPtr));

        internal static void Register(Plugin plugin, string name)
        {
            var info = new ExpressionInfo()
            {
                plugin = plugin
            };
            Registered.Add(name, info);
        }

        internal static bool Register(Plugin plugin, string name, ExpressionFunc0 func)
        {
            var registered = Native.Expressions.RegisterExpression(Manager.PluginHandle, name, 0, delegate (int argc, System.IntPtr argv, System.IntPtr x)
            {
                var res = func();
                return (System.UIntPtr)res;
            });
            if (registered)
            {
                Register(plugin, name);
            }
            return registered;
        }

        internal static bool Register(Plugin plugin, string name, ExpressionFunc1 func)
        {
            var registered = Native.Expressions.RegisterExpression(Manager.PluginHandle, name, 1, delegate (int argc, System.IntPtr argv, System.IntPtr x)
            {
                var arg0 = (nint)Marshal.ReadIntPtr(argv, 0 * PointerSize);
                return func((nuint)arg0);
            });
            if (registered)
            {
                Register(plugin, name);
            }
            return registered;
        }

        internal static bool Register(Plugin plugin, string name, ExpressionFunc2 func)
        {
            var registered = Native.Expressions.RegisterExpression(Manager.PluginHandle, name, 2, delegate (int argc, System.IntPtr argv, System.IntPtr x)
            {
                var arg0 = (nint)Marshal.ReadIntPtr(argv, 0 * PointerSize);
                var arg1 = (nint)Marshal.ReadIntPtr(argv, 1 * PointerSize);
                return func((nuint)arg0, (nuint)arg1);
            });
            if (registered)
            {
                Register(plugin, name);
            }
            return registered;
        }

        internal static bool Register(Plugin plugin, string name, ExpressionFunc3 func)
        {
            var registered = Native.Expressions.RegisterExpression(Manager.PluginHandle, name, 3, delegate (int argc, System.IntPtr argv, System.IntPtr x)
            {
                var arg0 = (nint)Marshal.ReadIntPtr(argv, 0 * PointerSize);
                var arg1 = (nint)Marshal.ReadIntPtr(argv, 1 * PointerSize);
                var arg2 = (nint)Marshal.ReadIntPtr(argv, 2 * PointerSize);
                return func((nuint)arg0, (nuint)arg1, (nuint)arg2);
            });
            if (registered)
            {
                Register(plugin, name);
            }
            return registered;
        }

        internal static bool Remove(string name)
        {
            if (!Registered.ContainsKey(name))
            {
                return false;
            }
            Registered.Remove(name);
            return Native.Expressions.UnregisterExpression(Manager.PluginHandle, name);
        }

        internal static bool RemoveAllFor(Plugin plugin)
        {
            Registered.Where(x => x.Value.plugin == plugin)
                .Select(x => x.Key)
                .ToList()
                .ForEach(name =>
            {
                Remove(name);
            });

            return true;
        }
    }
}
```

`src/Dotx64Managed/API/Memory.Stream.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    public static partial class Memory
    {
        public class Stream : System.IO.Stream
        {
            public nuint Base { get; init; }

            internal long Size;
            internal long Offset;

            internal Stream(nuint address)
            {
                Base = Memory.GetBase(address);
                Size = (long)Memory.GetSize(address);
                Offset = (long)(address - Base);
            }

            public override bool CanRead => true;

            public override bool CanSeek => true;

            public override bool CanWrite => true;

            public override long Length => (long)Size;

            public override long Position
            {
                get => Offset;
                set
                {
                    Offset = value;
                    if (Offset > Size)
                        Offset = Size;
                    if (Offset < 0)
                        Offset = 0;
                }
            }

            public override void Flush()
            {
                throw new NotSupportedException();
            }

            public override int Read(byte[] buffer, int offset, int count)
            {
                var bytesLeft = Size - Offset;
                var numBytes = (int)Math.Min(bytesLeft, count);

                var data = Native.Memory.Read(Base + (nuint)Offset, numBytes);
                data.CopyTo(buffer, offset);

                Offset += numBytes;

                return numBytes;
            }

            public override long Seek(long offset, SeekOrigin origin)
            {
                throw new NotImplementedException();
            }

            public override void SetLength(long value)
            {
                throw new NotSupportedException();
            }

            public override void Write(byte[] buffer, int offset, int count)
            {
                var bytesLeft = Size - Offset;
                var numBytes = (int)Math.Min(bytesLeft, count);
                numBytes = Math.Min(numBytes, buffer.Length - offset);

                Native.Memory.Write(Base + (nuint)Offset, buffer, offset, numBytes);

                Offset += numBytes;
            }
        }

        public static Stream GetStream(nuint address)
        {
            return new Stream(address);
        }
    }
}

```

`src/Dotx64Managed/API/Memory.cs`:

```cs
using System;

namespace Dotx64Dbg
{
    public static partial class Memory
    {
        [Flags]
        public enum Protection
        {
            Invalid = 0,
            NoAccess = 0x01,
            ReadOnly = 0x02,
            ReadWrite = 0x04,
            WriteCopy = 0x08,
            Execute = 0x10,
            ExecuteRead = 0x20,
            ExecuteWriteRead = 0x40,
            ExecuteWriteCopy,
            // Extra flags.
            Guard = 0x100,
            NoCache = 0x200,
            WriteCombine = 0x400,
            // CFG Settings.
            PageTargetsInvalid = 0x40000000,
            PageTargetsNoUpdate = 0x40000000,
        }

        /// <summary>
        /// Attempt to read memory from the debugged process.
        /// </summary>
        /// <param name="addr">Virtual address in the debugged process space</param>
        /// <param name="length">Amount of bytes to read</param>
        /// <returns>The bytes read from the process</returns>
        public static byte[] Read(nuint addr, int length)
        {
            return Native.Memory.Read(addr, length);
        }

        /// <see cref="Read(nuint, int)"/>
        public static byte[] Read(nuint addr, nuint length)
        {
            return Native.Memory.Read(addr, (int)length);
        }

        /// <see cref="Read(nuint, int)"/>
        public static byte[] Read(ulong addr, int length)
        {
            return Native.Memory.Read((nuint)addr, length);
        }

        /// <summary>
        /// Attempt to read pointer sized value from the debugged process.
        /// </summary>
        /// <param name="addr">Virtual address in the debugged process space</param>
        /// <returns>Value as nuint</returns>
        public static nuint ReadPtr(ulong addr)
        {
#if _X64_
            var data = Read(addr, 8);
            var val = BitConverter.ToInt64(data, 0);
#else
            var data = Read(addr, 4);
            var val = BitConverter.ToInt32(data, 0);
#endif
            return (nuint)val;
        }

        /// <summary>
        /// Attempt to write memory to the debugged process.
        /// </summary>
        /// <param name="address">Virtual address in the debugged process space</param>
        /// <param name="data">The bytes to be written</param>
        /// <param name="length">The maximum amount of bytes to write, can not be bigger than `data`</param>
        /// <returns>The amount of bytes written</returns>
        public static int Write(nuint address, byte[] data, int length)
        {
            return Native.Memory.Write(address, data, length);
        }

        /// <see cref="Write(nuint, byte[], int)"/>
        public static int Write(nuint address, byte[] data, nuint length)
        {
            return Native.Memory.Write(address, data, (int)length);
        }

        /// <see cref="Write(nuint, byte[], int)"/>
        public static int Write(ulong address, byte[] data, int length)
        {
            return Native.Memory.Write((nuint)address, data, length);
        }

        /// <summary>
        /// Attempt to write value of pointer size to the debugged process.
        /// </summary>
        /// <param name="addr">Virtual address in the debugged process space</param>
        /// <param name="value">Value to write</param>
        /// <returns>true if successful, false on failure.</returns>
        public static bool WritePtr(ulong addr, nuint value)
        {
            var data = BitConverter.GetBytes(value);
            return Write(addr, data) == data.Length;
        }

        /// <summary>
        /// Attempt to write memory to the debugged process.
        /// </summary>
        /// <param name="address">Virtual address in the debugged process space</param>
        /// <param name="data">The bytes to be written</param>
        /// <returns>The amount of bytes written</returns>
        public static int Write(nuint address, byte[] data)
        {
            return Write(address, data, data.Length);
        }

        /// <see cref="Write(nuint, byte[])"/>
        public static int Write(ulong address, byte[] data)
        {
            return Write((nuint)address, data, data.Length);
        }

        /// <summary>
        /// Returns the size of the specified memory region, the address must be the base address of the region.
        /// </summary>
        /// <param name="address">Virtual address in the debugged process space</param>
        /// <returns>Size of memory region</returns>
        public static nuint GetSize(nuint address)
        {
            return (nuint)Native.Memory.GetSize(address);
        }

        /// <see cref="GetSize(nuint)"/> 
        public static nuint GetSize(ulong address)
        {
            return GetSize((nuint)address);
        }

        /// <summary>
        /// Returns the address of where the memory region starts.
        /// </summary>
        /// <param name="address">Virtual address in the debugged process space</param>
        /// <returns>Base address</returns>
        public static nuint GetBase(nuint address)
        {
            return Native.Memory.GetBase(address);
        }

        /// <see cref="GetBase(nuint)"/>
        public static nuint GetBase(ulong address)
        {
            return GetBase((nuint)address);
        }

        /// <summary>
        /// Gets the protection of the memory, if the cache is used this is the last queried page info.
        /// It is normally safe to use the cache for performance, when the cache is used the internal
        /// API will not use a syscall to determine the protection.
        /// </summary>
        /// <param name="address">Address of the page to query</param>
        /// <param name="useCache">If this is true it will use the last queried page information</param>
        /// <returns>In case of failure the result is Protection.Invalid otherwise actual protection</returns>
        public static Protection GetProtection(nuint address, bool useCache)
        {
            return (Protection)Native.Memory.GetProtection(address, useCache);
        }
        public static Protection GetProtection(ulong address, bool useCache)
        {
            return GetProtection((nuint)address, useCache);
        }

        /// <summary>
        /// Sets a new protection on the specified address, the address will be aligned to page
        /// boundaries and sets the entire page which is by 4 KiB. This may split up
        /// an existing range from the memory map.
        /// Internally the size will be always aligned to a minimum of a single page, if the size
        /// spans more than two pages then both pages will be modified.
        /// <note>This will also update the cached protection info</note>
        /// </summary>
        /// <param name="address">Address of the page</param>
        /// <param name="protect">New protection</param>
        /// <param name="size">The size of the range</param>
        /// <returns>True on success</returns>
        public static bool SetProtection(nuint address, Protection protect, int size)
        {
            return Native.Memory.SetProtection(address, (UInt32)protect, size);
        }
        public static bool SetProtection(ulong address, Protection protect, int size)
        {
            return SetProtection((nuint)address, protect, size);
        }

        public static nuint RemoteAlloc(nuint address, int size)
        {
            return Native.Memory.RemoteAlloc(address, size);
        }
        public static nuint RemoteAlloc(ulong address, int size)
        {
            return RemoteAlloc((nuint)address, size);
        }

        public static bool RemoteFree(nuint address)
        {
            return Native.Memory.RemoteFree(address);
        }

        public static bool RemoteFree(ulong address)
        {
            return RemoteFree((nuint)address);
        }
    };
}

```

`src/Dotx64Managed/API/Module.Exports.cs`:

```cs
namespace Dotx64Dbg
{
    /// <summary>
    /// Object that represents a module in the debugged process.
    /// </summary>
    public partial class Module
    {
        public class Export
        {
            public nuint Rva { get; init; }
            public nuint Address { get; init; }
            public string DecoratedName { get; init; }
            public string UndecoratedName { get; init; }
            public string ForwarderName { get; init; }
            public int Ordinal { get; init; }
        }

        public Export[] Exports { get => GetExports(); }

        public Export[] GetExports()
        {
            var entries = Native.Module.GetExports(Base);
            var res = new Export[entries.Length];
            for (int i = 0; i < entries.Length; i++)
            {
                res[i] = new Export()
                {
                    Rva = entries[i].Rva,
                    Address = entries[i].Va,
                    DecoratedName = entries[i].DecoratedName,
                    UndecoratedName = entries[i].UndecoratedName,
                    ForwarderName = entries[i].ForwarderName,
                    Ordinal = entries[i].Ordinal,
                };
            }
            return res;
        }


    }
}

```

`src/Dotx64Managed/API/Module.Imports.cs`:

```cs
namespace Dotx64Dbg
{
    /// <summary>
    /// Object that represents a module in the debugged process.
    /// </summary>
    public partial class Module
    {
        public class Import
        {
            public nuint Rva { get; init; }
            public nuint Address { get; init; }
            public string DecoratedName { get; init; }
            public string UndecoratedName { get; init; }
            public int Ordinal { get; init; }
        }

        public Import[] Imports { get => GetImports(); }

        public Import[] GetImports()
        {
            var entries = Native.Module.GetImports(Base);
            var res = new Import[entries.Length];
            for (int i = 0; i < entries.Length; i++)
            {
                res[i] = new Import()
                {
                    Rva = entries[i].Rva,
                    Address = entries[i].Va,
                    DecoratedName = entries[i].DecoratedName,
                    UndecoratedName = entries[i].UndecoratedName,
                    Ordinal = entries[i].Ordinal,
                };
            }
            return res;
        }


    }
}

```

`src/Dotx64Managed/API/Module.Sections.cs`:

```cs
namespace Dotx64Dbg
{
    /// <summary>
    /// Object that represents a module in the debugged process.
    /// </summary>
    public partial class Module
    {
        public class Section
        {
            public string Name { get; init; }
            public nuint Address { get; init; }
            public nuint Size { get; init; }
        }

        public int SectionCount { get => GetSectionCount(); }

        public Section[] Sections { get => GetSections(); }

        public int GetSectionCount()
        {
            return Native.Module.GetSectionCount(Base);
        }

        public Section GetSection(int index)
        {
            var sect = Native.Module.GetSection(Base, index);
            return new Section()
            {
                Name = sect.Name,
                Address = (nuint)sect.Address,
                Size = (nuint)sect.Size
            };
        }

        public Section[] GetSections()
        {
            var res = new Section[SectionCount];
            for (int i = 0; i < SectionCount; i++)
            {
                res[i] = GetSection(i);
            }
            return res;
        }


    }
}

```

`src/Dotx64Managed/API/Module.cs`:

```cs
namespace Dotx64Dbg
{
    /// <summary>
    /// Object that represents a module in the debugged process.
    /// </summary>
    public partial class Module
    {
        public readonly nuint Base;

        public static Module Main { get => GetMain(); }

        public string Name { get => GetName(); }

        public string Path { get => GetPath(); }

        public nuint EntryPoint { get => GetEntryPoint(); }

        public nuint Size { get => GetSize(); }

        internal Module(nuint baseAddr)
        {
            Base = baseAddr;
        }

        public static Module GetMain()
        {
            return new Module((nuint)Native.Module.GetMain());
        }

        public static Module FindByName(string name)
        {
            var baseAddr = Native.Module.FindByName(name);
            if (baseAddr == 0)
                return null;

            return new Module((nuint)baseAddr);
        }

        public static Module FindByAddress(nuint address)
        {
            var baseAddr = Native.Module.FindByAddress(address);
            if (baseAddr == 0)
                return null;

            return new Module((nuint)baseAddr);
        }

        public static Module[] GetAll()
        {
            var mods = Native.Module.GetAll();
            var res = new Module[mods.Length];
            for (int i = 0; i < res.Length; i++)
            {
                res[i] = new Module((nuint)mods[i]);
            }
            return res;
        }

        public string GetName()
        {
            return Native.Module.GetName(Base);
        }

        public string GetPath()
        {
            return Native.Module.GetPath(Base);
        }

        public nuint GetEntryPoint()
        {
            return (nuint)Native.Module.GetEntrypoint(Base);
        }

        public nuint GetSize()
        {
            return (nuint)Native.Module.GetSize(Base);
        }

        /// <summary>Pretty name</summary>
        public override string ToString()
        {
            return $"Module:{Name}";
        }
    }
}

```

`src/Dotx64Managed/API/Platform.cs`:

```cs
namespace Dotx64Dbg
{
    public static partial class Platform
    {

        public static string OpenFolderBrowse(string title)
        {
            return Native.Platform.BrowseForFolder(title);
        }

        public static string OpenFileBrowse(string title, string filter)
        {
            return Native.Platform.OpenFileBrowse(title, filter);
        }

        public static string SaveFileBrowse(string title, string filter)
        {
            return Native.Platform.SaveFileBrowse(title, filter);
        }

        public static void SetClipboardText(string text)
        {
            Native.Platform.SetClipboardText(text);
        }

        public static void MessageBoxInfo(string text, string title = null)
        {
            Native.Platform.MessageBoxInfo(text, title);
        }

        public static void MessageBoxError(string text, string title = null)
        {
            Native.Platform.MessageBoxError(text, title);
        }
    }
}

```

`src/Dotx64Managed/API/Process.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    public static class Process
    {
        // <see cref="GetPID"/>
        public static UInt32 PID { get { return GetPID(); } }

        /// <summary>
        /// Process id of the current debugged process.
        /// </summary>
        public static UInt32 GetPID()
        {
            return Native.Process.GetPID();
        }

        // <see cref="GetNativeHandle"/>
        public static UIntPtr NativeHandle { get { return GetNativeHandle(); } }

        /// <summary>
        /// Native handle of the current debugged process.
        /// </summary>
        public static UIntPtr GetNativeHandle()
        {
            return Native.Process.GetNativeHandle();
        }

    }
}

```

`src/Dotx64Managed/API/Thread.Register.cs`:

```cs
using System;
using System.Numerics;

namespace Dotx64Dbg
{
    public partial class Thread
    {
        private byte GetRegisterU8(Registers.Id reg)
        {
            var bytes = Native.Thread.GetRegisterData(Handle, reg);
            return bytes[0];
        }

        private void SetRegisterU8(Registers.Id reg, byte val)
        {
            Native.Thread.SetRegisterData(Handle, reg, BitConverter.GetBytes(val));
        }

        private ushort GetRegisterU16(Registers.Id reg)
        {
            var bytes = Native.Thread.GetRegisterData(Handle, reg);
            return BitConverter.ToUInt16(bytes);
        }

        private void SetRegisterU16(Registers.Id reg, ushort val)
        {
            Native.Thread.SetRegisterData(Handle, reg, BitConverter.GetBytes(val));
        }

        private uint GetRegisterU32(Registers.Id reg)
        {
            var bytes = Native.Thread.GetRegisterData(Handle, reg);
            return BitConverter.ToUInt32(bytes);
        }

#if _X64_
        private void SetRegisterU32(Registers.Id reg, uint val)
#else

        private void SetRegisterU32(Registers.Id reg, nuint val)
#endif
        {
            Native.Thread.SetRegisterData(Handle, reg, BitConverter.GetBytes(val));
        }

        private ulong GetRegisterU64(Registers.Id reg)
        {
            var bytes = Native.Thread.GetRegisterData(Handle, reg);
            return BitConverter.ToUInt64(bytes);
        }


#if _X64_
        private void SetRegisterU64(Registers.Id reg, nuint val)
#else

        private void SetRegisterU64(Registers.Id reg, ulong val)
#endif
        {
            Native.Thread.SetRegisterData(Handle, reg, BitConverter.GetBytes(val));
        }

        public BigInteger GetRegister(Registers.Id reg)
        {
            var bytes = Native.Thread.GetRegisterData(Handle, reg);
            return new BigInteger(bytes, true);
        }

        public void SetRegister(Registers.Id reg, BigInteger val)
        {
            Native.Thread.SetRegisterData(Handle, reg, val.ToByteArray());
        }

        public byte Al { get => GetRegisterU8(Registers.Id.Al); set => SetRegisterU8(Registers.Id.Al, value); }
        public byte Cl { get => GetRegisterU8(Registers.Id.Cl); set => SetRegisterU8(Registers.Id.Cl, value); }
        public byte Dl { get => GetRegisterU8(Registers.Id.Dl); set => SetRegisterU8(Registers.Id.Dl, value); }
        public byte Bl { get => GetRegisterU8(Registers.Id.Bl); set => SetRegisterU8(Registers.Id.Bl, value); }
        public byte Ah { get => GetRegisterU8(Registers.Id.Ah); set => SetRegisterU8(Registers.Id.Ah, value); }
        public byte Ch { get => GetRegisterU8(Registers.Id.Ch); set => SetRegisterU8(Registers.Id.Ch, value); }
        public byte Dh { get => GetRegisterU8(Registers.Id.Dh); set => SetRegisterU8(Registers.Id.Dh, value); }
        public byte Bh { get => GetRegisterU8(Registers.Id.Bh); set => SetRegisterU8(Registers.Id.Bh, value); }
        public byte Spl { get => GetRegisterU8(Registers.Id.Spl); set => SetRegisterU8(Registers.Id.Spl, value); }
        public byte Bpl { get => GetRegisterU8(Registers.Id.Bpl); set => SetRegisterU8(Registers.Id.Bpl, value); }
        public byte Sil { get => GetRegisterU8(Registers.Id.Sil); set => SetRegisterU8(Registers.Id.Sil, value); }
        public byte Dil { get => GetRegisterU8(Registers.Id.Dil); set => SetRegisterU8(Registers.Id.Dil, value); }
#if _X64_
        public byte R8b { get => GetRegisterU8(Registers.Id.R8b); set => SetRegisterU8(Registers.Id.R8b, value); }
        public byte R9b { get => GetRegisterU8(Registers.Id.R9b); set => SetRegisterU8(Registers.Id.R9b, value); }
        public byte R10b { get => GetRegisterU8(Registers.Id.R10b); set => SetRegisterU8(Registers.Id.R10b, value); }
        public byte R11b { get => GetRegisterU8(Registers.Id.R11b); set => SetRegisterU8(Registers.Id.R11b, value); }
        public byte R12b { get => GetRegisterU8(Registers.Id.R12b); set => SetRegisterU8(Registers.Id.R12b, value); }
        public byte R13b { get => GetRegisterU8(Registers.Id.R13b); set => SetRegisterU8(Registers.Id.R13b, value); }
        public byte R14b { get => GetRegisterU8(Registers.Id.R14b); set => SetRegisterU8(Registers.Id.R14b, value); }
        public byte R15b { get => GetRegisterU8(Registers.Id.R15b); set => SetRegisterU8(Registers.Id.R15b, value); }
#endif
        public ushort Ax { get => GetRegisterU16(Registers.Id.Ax); set => SetRegisterU16(Registers.Id.Ax, value); }
        public ushort Cx { get => GetRegisterU16(Registers.Id.Cx); set => SetRegisterU16(Registers.Id.Cx, value); }
        public ushort Dx { get => GetRegisterU16(Registers.Id.Dx); set => SetRegisterU16(Registers.Id.Dx, value); }
        public ushort Bx { get => GetRegisterU16(Registers.Id.Bx); set => SetRegisterU16(Registers.Id.Bx, value); }
        public ushort Sp { get => GetRegisterU16(Registers.Id.Sp); set => SetRegisterU16(Registers.Id.Sp, value); }
        public ushort Bp { get => GetRegisterU16(Registers.Id.Bp); set => SetRegisterU16(Registers.Id.Bp, value); }
        public ushort Si { get => GetRegisterU16(Registers.Id.Si); set => SetRegisterU16(Registers.Id.Si, value); }
        public ushort Di { get => GetRegisterU16(Registers.Id.Di); set => SetRegisterU16(Registers.Id.Di, value); }
#if _X64_
        public ushort R8w { get => GetRegisterU16(Registers.Id.R8w); set => SetRegisterU16(Registers.Id.R8w, value); }
        public ushort R9w { get => GetRegisterU16(Registers.Id.R9w); set => SetRegisterU16(Registers.Id.R9w, value); }
        public ushort R10w { get => GetRegisterU16(Registers.Id.R10w); set => SetRegisterU16(Registers.Id.R10w, value); }
        public ushort R11w { get => GetRegisterU16(Registers.Id.R11w); set => SetRegisterU16(Registers.Id.R11w, value); }
        public ushort R12w { get => GetRegisterU16(Registers.Id.R12w); set => SetRegisterU16(Registers.Id.R12w, value); }
        public ushort R13w { get => GetRegisterU16(Registers.Id.R13w); set => SetRegisterU16(Registers.Id.R13w, value); }
        public ushort R14w { get => GetRegisterU16(Registers.Id.R14w); set => SetRegisterU16(Registers.Id.R14w, value); }
        public ushort R15w { get => GetRegisterU16(Registers.Id.R15w); set => SetRegisterU16(Registers.Id.R15w, value); }
#endif

#if _X64_
        public uint Eax { get => GetRegisterU32(Registers.Id.Eax); set => SetRegisterU32(Registers.Id.Eax, value); }
        public uint Ecx { get => GetRegisterU32(Registers.Id.Ecx); set => SetRegisterU32(Registers.Id.Ecx, value); }
        public uint Edx { get => GetRegisterU32(Registers.Id.Edx); set => SetRegisterU32(Registers.Id.Edx, value); }
        public uint Ebx { get => GetRegisterU32(Registers.Id.Ebx); set => SetRegisterU32(Registers.Id.Ebx, value); }
        public uint Esp { get => GetRegisterU32(Registers.Id.Esp); set => SetRegisterU32(Registers.Id.Esp, value); }
        public uint Ebp { get => GetRegisterU32(Registers.Id.Ebp); set => SetRegisterU32(Registers.Id.Ebp, value); }
        public uint Esi { get => GetRegisterU32(Registers.Id.Esi); set => SetRegisterU32(Registers.Id.Esi, value); }
        public uint Edi { get => GetRegisterU32(Registers.Id.Edi); set => SetRegisterU32(Registers.Id.Edi, value); }
#else
        public nuint Eax { get => (nuint)GetRegisterU32(Registers.Id.Eax); set => SetRegisterU32(Registers.Id.Eax, value); }
        public nuint Ecx { get => (nuint)GetRegisterU32(Registers.Id.Ecx); set => SetRegisterU32(Registers.Id.Ecx, value); }
        public nuint Edx { get => (nuint)GetRegisterU32(Registers.Id.Edx); set => SetRegisterU32(Registers.Id.Edx, value); }
        public nuint Ebx { get => (nuint)GetRegisterU32(Registers.Id.Ebx); set => SetRegisterU32(Registers.Id.Ebx, value); }
        public nuint Esp { get => (nuint)GetRegisterU32(Registers.Id.Esp); set => SetRegisterU32(Registers.Id.Esp, value); }
        public nuint Ebp { get => (nuint)GetRegisterU32(Registers.Id.Ebp); set => SetRegisterU32(Registers.Id.Ebp, value); }
        public nuint Esi { get => (nuint)GetRegisterU32(Registers.Id.Esi); set => SetRegisterU32(Registers.Id.Esi, value); }
        public nuint Edi { get => (nuint)GetRegisterU32(Registers.Id.Edi); set => SetRegisterU32(Registers.Id.Edi, value); }
#endif

#if _X64_
        public uint R8d { get => GetRegisterU32(Registers.Id.R8d); set => SetRegisterU32(Registers.Id.R8d, value); }
        public uint R9d { get => GetRegisterU32(Registers.Id.R9d); set => SetRegisterU32(Registers.Id.R9d, value); }
        public uint R10d { get => GetRegisterU32(Registers.Id.R10d); set => SetRegisterU32(Registers.Id.R10d, value); }
        public uint R11d { get => GetRegisterU32(Registers.Id.R11d); set => SetRegisterU32(Registers.Id.R11d, value); }
        public uint R12d { get => GetRegisterU32(Registers.Id.R12d); set => SetRegisterU32(Registers.Id.R12d, value); }
        public uint R13d { get => GetRegisterU32(Registers.Id.R13d); set => SetRegisterU32(Registers.Id.R13d, value); }
        public uint R14d { get => GetRegisterU32(Registers.Id.R14d); set => SetRegisterU32(Registers.Id.R14d, value); }
        public uint R15d { get => GetRegisterU32(Registers.Id.R15d); set => SetRegisterU32(Registers.Id.R15d, value); }
        public nuint Rax { get => (nuint)GetRegisterU64(Registers.Id.Rax); set => SetRegisterU64(Registers.Id.Rax, value); }
        public nuint Rcx { get => (nuint)GetRegisterU64(Registers.Id.Rcx); set => SetRegisterU64(Registers.Id.Rcx, value); }
        public nuint Rdx { get => (nuint)GetRegisterU64(Registers.Id.Rdx); set => SetRegisterU64(Registers.Id.Rdx, value); }
        public nuint Rbx { get => (nuint)GetRegisterU64(Registers.Id.Rbx); set => SetRegisterU64(Registers.Id.Rbx, value); }
        public nuint Rsp { get => (nuint)GetRegisterU64(Registers.Id.Rsp); set => SetRegisterU64(Registers.Id.Rsp, value); }
        public nuint Rbp { get => (nuint)GetRegisterU64(Registers.Id.Rbp); set => SetRegisterU64(Registers.Id.Rbp, value); }
        public nuint Rsi { get => (nuint)GetRegisterU64(Registers.Id.Rsi); set => SetRegisterU64(Registers.Id.Rsi, value); }
        public nuint Rdi { get => (nuint)GetRegisterU64(Registers.Id.Rdi); set => SetRegisterU64(Registers.Id.Rdi, value); }
        public nuint R8 { get => (nuint)GetRegisterU64(Registers.Id.R8); set => SetRegisterU64(Registers.Id.R8, value); }
        public nuint R9 { get => (nuint)GetRegisterU64(Registers.Id.R9); set => SetRegisterU64(Registers.Id.R9, value); }
        public nuint R10 { get => (nuint)GetRegisterU64(Registers.Id.R10); set => SetRegisterU64(Registers.Id.R10, value); }
        public nuint R11 { get => (nuint)GetRegisterU64(Registers.Id.R11); set => SetRegisterU64(Registers.Id.R11, value); }
        public nuint R12 { get => (nuint)GetRegisterU64(Registers.Id.R12); set => SetRegisterU64(Registers.Id.R12, value); }
        public nuint R13 { get => (nuint)GetRegisterU64(Registers.Id.R13); set => SetRegisterU64(Registers.Id.R13, value); }
        public nuint R14 { get => (nuint)GetRegisterU64(Registers.Id.R14); set => SetRegisterU64(Registers.Id.R14, value); }
        public nuint R15 { get => (nuint)GetRegisterU64(Registers.Id.R15); set => SetRegisterU64(Registers.Id.R15, value); }
#endif
        public BigInteger St0 { get => GetRegister(Registers.Id.St0); set => SetRegister(Registers.Id.St0, value); }
        public BigInteger St1 { get => GetRegister(Registers.Id.St1); set => SetRegister(Registers.Id.St1, value); }
        public BigInteger St2 { get => GetRegister(Registers.Id.St2); set => SetRegister(Registers.Id.St2, value); }
        public BigInteger St3 { get => GetRegister(Registers.Id.St3); set => SetRegister(Registers.Id.St3, value); }
        public BigInteger St4 { get => GetRegister(Registers.Id.St4); set => SetRegister(Registers.Id.St4, value); }
        public BigInteger St5 { get => GetRegister(Registers.Id.St5); set => SetRegister(Registers.Id.St5, value); }
        public BigInteger St6 { get => GetRegister(Registers.Id.St6); set => SetRegister(Registers.Id.St6, value); }
        public BigInteger St7 { get => GetRegister(Registers.Id.St7); set => SetRegister(Registers.Id.St7, value); }
        public BigInteger X87Control { get => GetRegister(Registers.Id.X87Control); set => SetRegister(Registers.Id.X87Control, value); }
        public BigInteger X87Status { get => GetRegister(Registers.Id.X87Status); set => SetRegister(Registers.Id.X87Status, value); }
        public BigInteger X87Tag { get => GetRegister(Registers.Id.X87Tag); set => SetRegister(Registers.Id.X87Tag, value); }
        public BigInteger Mm0 { get => GetRegister(Registers.Id.Mm0); set => SetRegister(Registers.Id.Mm0, value); }
        public BigInteger Mm1 { get => GetRegister(Registers.Id.Mm1); set => SetRegister(Registers.Id.Mm1, value); }
        public BigInteger Mm2 { get => GetRegister(Registers.Id.Mm2); set => SetRegister(Registers.Id.Mm2, value); }
        public BigInteger Mm3 { get => GetRegister(Registers.Id.Mm3); set => SetRegister(Registers.Id.Mm3, value); }
        public BigInteger Mm4 { get => GetRegister(Registers.Id.Mm4); set => SetRegister(Registers.Id.Mm4, value); }
        public BigInteger Mm5 { get => GetRegister(Registers.Id.Mm5); set => SetRegister(Registers.Id.Mm5, value); }
        public BigInteger Mm6 { get => GetRegister(Registers.Id.Mm6); set => SetRegister(Registers.Id.Mm6, value); }
        public BigInteger Mm7 { get => GetRegister(Registers.Id.Mm7); set => SetRegister(Registers.Id.Mm7, value); }
        public BigInteger Xmm0 { get => GetRegister(Registers.Id.Xmm0); set => SetRegister(Registers.Id.Xmm0, value); }
        public BigInteger Xmm1 { get => GetRegister(Registers.Id.Xmm1); set => SetRegister(Registers.Id.Xmm1, value); }
        public BigInteger Xmm2 { get => GetRegister(Registers.Id.Xmm2); set => SetRegister(Registers.Id.Xmm2, value); }
        public BigInteger Xmm3 { get => GetRegister(Registers.Id.Xmm3); set => SetRegister(Registers.Id.Xmm3, value); }
        public BigInteger Xmm4 { get => GetRegister(Registers.Id.Xmm4); set => SetRegister(Registers.Id.Xmm4, value); }
        public BigInteger Xmm5 { get => GetRegister(Registers.Id.Xmm5); set => SetRegister(Registers.Id.Xmm5, value); }
        public BigInteger Xmm6 { get => GetRegister(Registers.Id.Xmm6); set => SetRegister(Registers.Id.Xmm6, value); }
        public BigInteger Xmm7 { get => GetRegister(Registers.Id.Xmm7); set => SetRegister(Registers.Id.Xmm7, value); }
        public BigInteger Xmm8 { get => GetRegister(Registers.Id.Xmm8); set => SetRegister(Registers.Id.Xmm8, value); }
        public BigInteger Xmm9 { get => GetRegister(Registers.Id.Xmm9); set => SetRegister(Registers.Id.Xmm9, value); }
        public BigInteger Xmm10 { get => GetRegister(Registers.Id.Xmm10); set => SetRegister(Registers.Id.Xmm10, value); }
        public BigInteger Xmm11 { get => GetRegister(Registers.Id.Xmm11); set => SetRegister(Registers.Id.Xmm11, value); }
        public BigInteger Xmm12 { get => GetRegister(Registers.Id.Xmm12); set => SetRegister(Registers.Id.Xmm12, value); }
        public BigInteger Xmm13 { get => GetRegister(Registers.Id.Xmm13); set => SetRegister(Registers.Id.Xmm13, value); }
        public BigInteger Xmm14 { get => GetRegister(Registers.Id.Xmm14); set => SetRegister(Registers.Id.Xmm14, value); }
        public BigInteger Xmm15 { get => GetRegister(Registers.Id.Xmm15); set => SetRegister(Registers.Id.Xmm15, value); }
        public BigInteger Xmm16 { get => GetRegister(Registers.Id.Xmm16); set => SetRegister(Registers.Id.Xmm16, value); }
        public BigInteger Xmm17 { get => GetRegister(Registers.Id.Xmm17); set => SetRegister(Registers.Id.Xmm17, value); }
        public BigInteger Xmm18 { get => GetRegister(Registers.Id.Xmm18); set => SetRegister(Registers.Id.Xmm18, value); }
        public BigInteger Xmm19 { get => GetRegister(Registers.Id.Xmm19); set => SetRegister(Registers.Id.Xmm19, value); }
        public BigInteger Xmm20 { get => GetRegister(Registers.Id.Xmm20); set => SetRegister(Registers.Id.Xmm20, value); }
        public BigInteger Xmm21 { get => GetRegister(Registers.Id.Xmm21); set => SetRegister(Registers.Id.Xmm21, value); }
        public BigInteger Xmm22 { get => GetRegister(Registers.Id.Xmm22); set => SetRegister(Registers.Id.Xmm22, value); }
        public BigInteger Xmm23 { get => GetRegister(Registers.Id.Xmm23); set => SetRegister(Registers.Id.Xmm23, value); }
        public BigInteger Xmm24 { get => GetRegister(Registers.Id.Xmm24); set => SetRegister(Registers.Id.Xmm24, value); }
        public BigInteger Xmm25 { get => GetRegister(Registers.Id.Xmm25); set => SetRegister(Registers.Id.Xmm25, value); }
        public BigInteger Xmm26 { get => GetRegister(Registers.Id.Xmm26); set => SetRegister(Registers.Id.Xmm26, value); }
        public BigInteger Xmm27 { get => GetRegister(Registers.Id.Xmm27); set => SetRegister(Registers.Id.Xmm27, value); }
        public BigInteger Xmm28 { get => GetRegister(Registers.Id.Xmm28); set => SetRegister(Registers.Id.Xmm28, value); }
        public BigInteger Xmm29 { get => GetRegister(Registers.Id.Xmm29); set => SetRegister(Registers.Id.Xmm29, value); }
        public BigInteger Xmm30 { get => GetRegister(Registers.Id.Xmm30); set => SetRegister(Registers.Id.Xmm30, value); }
        public BigInteger Xmm31 { get => GetRegister(Registers.Id.Xmm31); set => SetRegister(Registers.Id.Xmm31, value); }
        public BigInteger Ymm0 { get => GetRegister(Registers.Id.Ymm0); set => SetRegister(Registers.Id.Ymm0, value); }
        public BigInteger Ymm1 { get => GetRegister(Registers.Id.Ymm1); set => SetRegister(Registers.Id.Ymm1, value); }
        public BigInteger Ymm2 { get => GetRegister(Registers.Id.Ymm2); set => SetRegister(Registers.Id.Ymm2, value); }
        public BigInteger Ymm3 { get => GetRegister(Registers.Id.Ymm3); set => SetRegister(Registers.Id.Ymm3, value); }
        public BigInteger Ymm4 { get => GetRegister(Registers.Id.Ymm4); set => SetRegister(Registers.Id.Ymm4, value); }
        public BigInteger Ymm5 { get => GetRegister(Registers.Id.Ymm5); set => SetRegister(Registers.Id.Ymm5, value); }
        public BigInteger Ymm6 { get => GetRegister(Registers.Id.Ymm6); set => SetRegister(Registers.Id.Ymm6, value); }
        public BigInteger Ymm7 { get => GetRegister(Registers.Id.Ymm7); set => SetRegister(Registers.Id.Ymm7, value); }
        public BigInteger Ymm8 { get => GetRegister(Registers.Id.Ymm8); set => SetRegister(Registers.Id.Ymm8, value); }
        public BigInteger Ymm9 { get => GetRegister(Registers.Id.Ymm9); set => SetRegister(Registers.Id.Ymm9, value); }
        public BigInteger Ymm10 { get => GetRegister(Registers.Id.Ymm10); set => SetRegister(Registers.Id.Ymm10, value); }
        public BigInteger Ymm11 { get => GetRegister(Registers.Id.Ymm11); set => SetRegister(Registers.Id.Ymm11, value); }
        public BigInteger Ymm12 { get => GetRegister(Registers.Id.Ymm12); set => SetRegister(Registers.Id.Ymm12, value); }
        public BigInteger Ymm13 { get => GetRegister(Registers.Id.Ymm13); set => SetRegister(Registers.Id.Ymm13, value); }
        public BigInteger Ymm14 { get => GetRegister(Registers.Id.Ymm14); set => SetRegister(Registers.Id.Ymm14, value); }
        public BigInteger Ymm15 { get => GetRegister(Registers.Id.Ymm15); set => SetRegister(Registers.Id.Ymm15, value); }
        public BigInteger Ymm16 { get => GetRegister(Registers.Id.Ymm16); set => SetRegister(Registers.Id.Ymm16, value); }
        public BigInteger Ymm17 { get => GetRegister(Registers.Id.Ymm17); set => SetRegister(Registers.Id.Ymm17, value); }
        public BigInteger Ymm18 { get => GetRegister(Registers.Id.Ymm18); set => SetRegister(Registers.Id.Ymm18, value); }
        public BigInteger Ymm19 { get => GetRegister(Registers.Id.Ymm19); set => SetRegister(Registers.Id.Ymm19, value); }
        public BigInteger Ymm20 { get => GetRegister(Registers.Id.Ymm20); set => SetRegister(Registers.Id.Ymm20, value); }
        public BigInteger Ymm21 { get => GetRegister(Registers.Id.Ymm21); set => SetRegister(Registers.Id.Ymm21, value); }
        public BigInteger Ymm22 { get => GetRegister(Registers.Id.Ymm22); set => SetRegister(Registers.Id.Ymm22, value); }
        public BigInteger Ymm23 { get => GetRegister(Registers.Id.Ymm23); set => SetRegister(Registers.Id.Ymm23, value); }
        public BigInteger Ymm24 { get => GetRegister(Registers.Id.Ymm24); set => SetRegister(Registers.Id.Ymm24, value); }
        public BigInteger Ymm25 { get => GetRegister(Registers.Id.Ymm25); set => SetRegister(Registers.Id.Ymm25, value); }
        public BigInteger Ymm26 { get => GetRegister(Registers.Id.Ymm26); set => SetRegister(Registers.Id.Ymm26, value); }
        public BigInteger Ymm27 { get => GetRegister(Registers.Id.Ymm27); set => SetRegister(Registers.Id.Ymm27, value); }
        public BigInteger Ymm28 { get => GetRegister(Registers.Id.Ymm28); set => SetRegister(Registers.Id.Ymm28, value); }
        public BigInteger Ymm29 { get => GetRegister(Registers.Id.Ymm29); set => SetRegister(Registers.Id.Ymm29, value); }
        public BigInteger Ymm30 { get => GetRegister(Registers.Id.Ymm30); set => SetRegister(Registers.Id.Ymm30, value); }
        public BigInteger Ymm31 { get => GetRegister(Registers.Id.Ymm31); set => SetRegister(Registers.Id.Ymm31, value); }
        public BigInteger Zmm0 { get => GetRegister(Registers.Id.Zmm0); set => SetRegister(Registers.Id.Zmm0, value); }
        public BigInteger Zmm1 { get => GetRegister(Registers.Id.Zmm1); set => SetRegister(Registers.Id.Zmm1, value); }
        public BigInteger Zmm2 { get => GetRegister(Registers.Id.Zmm2); set => SetRegister(Registers.Id.Zmm2, value); }
        public BigInteger Zmm3 { get => GetRegister(Registers.Id.Zmm3); set => SetRegister(Registers.Id.Zmm3, value); }
        public BigInteger Zmm4 { get => GetRegister(Registers.Id.Zmm4); set => SetRegister(Registers.Id.Zmm4, value); }
        public BigInteger Zmm5 { get => GetRegister(Registers.Id.Zmm5); set => SetRegister(Registers.Id.Zmm5, value); }
        public BigInteger Zmm6 { get => GetRegister(Registers.Id.Zmm6); set => SetRegister(Registers.Id.Zmm6, value); }
        public BigInteger Zmm7 { get => GetRegister(Registers.Id.Zmm7); set => SetRegister(Registers.Id.Zmm7, value); }
        public BigInteger Zmm8 { get => GetRegister(Registers.Id.Zmm8); set => SetRegister(Registers.Id.Zmm8, value); }
        public BigInteger Zmm9 { get => GetRegister(Registers.Id.Zmm9); set => SetRegister(Registers.Id.Zmm9, value); }
        public BigInteger Zmm10 { get => GetRegister(Registers.Id.Zmm10); set => SetRegister(Registers.Id.Zmm10, value); }
        public BigInteger Zmm11 { get => GetRegister(Registers.Id.Zmm11); set => SetRegister(Registers.Id.Zmm11, value); }
        public BigInteger Zmm12 { get => GetRegister(Registers.Id.Zmm12); set => SetRegister(Registers.Id.Zmm12, value); }
        public BigInteger Zmm13 { get => GetRegister(Registers.Id.Zmm13); set => SetRegister(Registers.Id.Zmm13, value); }
        public BigInteger Zmm14 { get => GetRegister(Registers.Id.Zmm14); set => SetRegister(Registers.Id.Zmm14, value); }
        public BigInteger Zmm15 { get => GetRegister(Registers.Id.Zmm15); set => SetRegister(Registers.Id.Zmm15, value); }
        public BigInteger Zmm16 { get => GetRegister(Registers.Id.Zmm16); set => SetRegister(Registers.Id.Zmm16, value); }
        public BigInteger Zmm17 { get => GetRegister(Registers.Id.Zmm17); set => SetRegister(Registers.Id.Zmm17, value); }
        public BigInteger Zmm18 { get => GetRegister(Registers.Id.Zmm18); set => SetRegister(Registers.Id.Zmm18, value); }
        public BigInteger Zmm19 { get => GetRegister(Registers.Id.Zmm19); set => SetRegister(Registers.Id.Zmm19, value); }
        public BigInteger Zmm20 { get => GetRegister(Registers.Id.Zmm20); set => SetRegister(Registers.Id.Zmm20, value); }
        public BigInteger Zmm21 { get => GetRegister(Registers.Id.Zmm21); set => SetRegister(Registers.Id.Zmm21, value); }
        public BigInteger Zmm22 { get => GetRegister(Registers.Id.Zmm22); set => SetRegister(Registers.Id.Zmm22, value); }
        public BigInteger Zmm23 { get => GetRegister(Registers.Id.Zmm23); set => SetRegister(Registers.Id.Zmm23, value); }
        public BigInteger Zmm24 { get => GetRegister(Registers.Id.Zmm24); set => SetRegister(Registers.Id.Zmm24, value); }
        public BigInteger Zmm25 { get => GetRegister(Registers.Id.Zmm25); set => SetRegister(Registers.Id.Zmm25, value); }
        public BigInteger Zmm26 { get => GetRegister(Registers.Id.Zmm26); set => SetRegister(Registers.Id.Zmm26, value); }
        public BigInteger Zmm27 { get => GetRegister(Registers.Id.Zmm27); set => SetRegister(Registers.Id.Zmm27, value); }
        public BigInteger Zmm28 { get => GetRegister(Registers.Id.Zmm28); set => SetRegister(Registers.Id.Zmm28, value); }
        public BigInteger Zmm29 { get => GetRegister(Registers.Id.Zmm29); set => SetRegister(Registers.Id.Zmm29, value); }
        public BigInteger Zmm30 { get => GetRegister(Registers.Id.Zmm30); set => SetRegister(Registers.Id.Zmm30, value); }
        public BigInteger Zmm31 { get => GetRegister(Registers.Id.Zmm31); set => SetRegister(Registers.Id.Zmm31, value); }
        public BigInteger Flags { get => GetRegister(Registers.Id.Flags); set => SetRegister(Registers.Id.Flags, value); }

#if _X64_
        public uint EFlags { get => GetRegisterU32(Registers.Id.EFlags); set => SetRegisterU32(Registers.Id.EFlags, value); }
        public nuint RFlags { get => (nuint)GetRegisterU64(Registers.Id.RFlags); set => SetRegisterU64(Registers.Id.RFlags, value); }
#else
        public nuint EFlags { get => (nuint)GetRegisterU32(Registers.Id.EFlags); set => SetRegisterU32(Registers.Id.EFlags, value); }
#endif
        public ushort Ip { get => GetRegisterU16(Registers.Id.Ip); set => SetRegisterU16(Registers.Id.Ip, value); }

#if _X64_
        public uint Eip { get => GetRegisterU32(Registers.Id.Eip); set => SetRegisterU32(Registers.Id.Eip, value); }
        public nuint Rip { get => (nuint)GetRegisterU64(Registers.Id.Rip); set => SetRegisterU64(Registers.Id.Rip, value); }
#else
        public nuint Eip { get => (nuint)GetRegisterU32(Registers.Id.Eip); set => SetRegisterU32(Registers.Id.Eip, value); }
#endif

        public ushort Es { get => GetRegisterU16(Registers.Id.Es); set => SetRegisterU16(Registers.Id.Es, value); }
        public ushort Cs { get => GetRegisterU16(Registers.Id.Cs); set => SetRegisterU16(Registers.Id.Cs, value); }
        public ushort Ss { get => GetRegisterU16(Registers.Id.Ss); set => SetRegisterU16(Registers.Id.Ss, value); }
        public ushort Ds { get => GetRegisterU16(Registers.Id.Ds); set => SetRegisterU16(Registers.Id.Ds, value); }
        public ushort Fs { get => GetRegisterU16(Registers.Id.Fs); set => SetRegisterU16(Registers.Id.Fs, value); }
        public ushort Gs { get => GetRegisterU16(Registers.Id.Gs); set => SetRegisterU16(Registers.Id.Gs, value); }
        public BigInteger Gdtr { get => GetRegister(Registers.Id.Gdtr); set => SetRegister(Registers.Id.Gdtr, value); }
        public BigInteger Ldtr { get => GetRegister(Registers.Id.Ldtr); set => SetRegister(Registers.Id.Ldtr, value); }
        public BigInteger Idtr { get => GetRegister(Registers.Id.Idtr); set => SetRegister(Registers.Id.Idtr, value); }
        public BigInteger Tr { get => GetRegister(Registers.Id.Tr); set => SetRegister(Registers.Id.Tr, value); }
        public BigInteger Tr0 { get => GetRegister(Registers.Id.Tr0); set => SetRegister(Registers.Id.Tr0, value); }
        public BigInteger Tr1 { get => GetRegister(Registers.Id.Tr1); set => SetRegister(Registers.Id.Tr1, value); }
        public BigInteger Tr2 { get => GetRegister(Registers.Id.Tr2); set => SetRegister(Registers.Id.Tr2, value); }
        public BigInteger Tr3 { get => GetRegister(Registers.Id.Tr3); set => SetRegister(Registers.Id.Tr3, value); }
        public BigInteger Tr4 { get => GetRegister(Registers.Id.Tr4); set => SetRegister(Registers.Id.Tr4, value); }
        public BigInteger Tr5 { get => GetRegister(Registers.Id.Tr5); set => SetRegister(Registers.Id.Tr5, value); }
        public BigInteger Tr6 { get => GetRegister(Registers.Id.Tr6); set => SetRegister(Registers.Id.Tr6, value); }
        public BigInteger Tr7 { get => GetRegister(Registers.Id.Tr7); set => SetRegister(Registers.Id.Tr7, value); }
        public BigInteger Cr0 { get => GetRegister(Registers.Id.Cr0); set => SetRegister(Registers.Id.Cr0, value); }
        public BigInteger Cr1 { get => GetRegister(Registers.Id.Cr1); set => SetRegister(Registers.Id.Cr1, value); }
        public BigInteger Cr2 { get => GetRegister(Registers.Id.Cr2); set => SetRegister(Registers.Id.Cr2, value); }
        public BigInteger Cr3 { get => GetRegister(Registers.Id.Cr3); set => SetRegister(Registers.Id.Cr3, value); }
        public BigInteger Cr4 { get => GetRegister(Registers.Id.Cr4); set => SetRegister(Registers.Id.Cr4, value); }
        public BigInteger Cr5 { get => GetRegister(Registers.Id.Cr5); set => SetRegister(Registers.Id.Cr5, value); }
        public BigInteger Cr6 { get => GetRegister(Registers.Id.Cr6); set => SetRegister(Registers.Id.Cr6, value); }
        public BigInteger Cr7 { get => GetRegister(Registers.Id.Cr7); set => SetRegister(Registers.Id.Cr7, value); }
        public BigInteger Cr8 { get => GetRegister(Registers.Id.Cr8); set => SetRegister(Registers.Id.Cr8, value); }
        public BigInteger Cr9 { get => GetRegister(Registers.Id.Cr9); set => SetRegister(Registers.Id.Cr9, value); }
        public BigInteger Cr10 { get => GetRegister(Registers.Id.Cr10); set => SetRegister(Registers.Id.Cr10, value); }
        public BigInteger Cr11 { get => GetRegister(Registers.Id.Cr11); set => SetRegister(Registers.Id.Cr11, value); }
        public BigInteger Cr12 { get => GetRegister(Registers.Id.Cr12); set => SetRegister(Registers.Id.Cr12, value); }
        public BigInteger Cr13 { get => GetRegister(Registers.Id.Cr13); set => SetRegister(Registers.Id.Cr13, value); }
        public BigInteger Cr14 { get => GetRegister(Registers.Id.Cr14); set => SetRegister(Registers.Id.Cr14, value); }
        public BigInteger Cr15 { get => GetRegister(Registers.Id.Cr15); set => SetRegister(Registers.Id.Cr15, value); }
#if _X64_
        public nuint Dr0 { get => (nuint)GetRegisterU64(Registers.Id.Dr0); set => SetRegisterU64(Registers.Id.Dr0, value); }
        public nuint Dr1 { get => (nuint)GetRegisterU64(Registers.Id.Dr1); set => SetRegisterU64(Registers.Id.Dr1, value); }
        public nuint Dr2 { get => (nuint)GetRegisterU64(Registers.Id.Dr2); set => SetRegisterU64(Registers.Id.Dr2, value); }
        public nuint Dr3 { get => (nuint)GetRegisterU64(Registers.Id.Dr3); set => SetRegisterU64(Registers.Id.Dr3, value); }
        public nuint Dr4 { get => (nuint)GetRegisterU64(Registers.Id.Dr4); set => SetRegisterU64(Registers.Id.Dr4, value); }
        public nuint Dr5 { get => (nuint)GetRegisterU64(Registers.Id.Dr5); set => SetRegisterU64(Registers.Id.Dr5, value); }
        public nuint Dr6 { get => (nuint)GetRegisterU64(Registers.Id.Dr6); set => SetRegisterU64(Registers.Id.Dr6, value); }
        public nuint Dr7 { get => (nuint)GetRegisterU64(Registers.Id.Dr7); set => SetRegisterU64(Registers.Id.Dr7, value); }
        public nuint Dr8 { get => (nuint)GetRegisterU64(Registers.Id.Dr8); set => SetRegisterU64(Registers.Id.Dr8, value); }
        public nuint Dr9 { get => (nuint)GetRegisterU64(Registers.Id.Dr9); set => SetRegisterU64(Registers.Id.Dr9, value); }
        public nuint Dr10 { get => (nuint)GetRegisterU64(Registers.Id.Dr10); set => SetRegisterU64(Registers.Id.Dr10, value); }
        public nuint Dr11 { get => (nuint)GetRegisterU64(Registers.Id.Dr11); set => SetRegisterU64(Registers.Id.Dr11, value); }
        public nuint Dr12 { get => (nuint)GetRegisterU64(Registers.Id.Dr12); set => SetRegisterU64(Registers.Id.Dr12, value); }
        public nuint Dr13 { get => (nuint)GetRegisterU64(Registers.Id.Dr13); set => SetRegisterU64(Registers.Id.Dr13, value); }
        public nuint Dr14 { get => (nuint)GetRegisterU64(Registers.Id.Dr14); set => SetRegisterU64(Registers.Id.Dr14, value); }
        public nuint Dr15 { get => (nuint)GetRegisterU64(Registers.Id.Dr15); set => SetRegisterU64(Registers.Id.Dr15, value); }
#else
        public nuint Dr0 { get => (nuint)GetRegisterU32(Registers.Id.Dr0); set => SetRegisterU32(Registers.Id.Dr0, value); }
        public nuint Dr1 { get => (nuint)GetRegisterU32(Registers.Id.Dr1); set => SetRegisterU32(Registers.Id.Dr1, value); }
        public nuint Dr2 { get => (nuint)GetRegisterU32(Registers.Id.Dr2); set => SetRegisterU32(Registers.Id.Dr2, value); }
        public nuint Dr3 { get => (nuint)GetRegisterU32(Registers.Id.Dr3); set => SetRegisterU32(Registers.Id.Dr3, value); }
        public nuint Dr4 { get => (nuint)GetRegisterU32(Registers.Id.Dr4); set => SetRegisterU32(Registers.Id.Dr4, value); }
        public nuint Dr5 { get => (nuint)GetRegisterU32(Registers.Id.Dr5); set => SetRegisterU32(Registers.Id.Dr5, value); }
        public nuint Dr6 { get => (nuint)GetRegisterU32(Registers.Id.Dr6); set => SetRegisterU32(Registers.Id.Dr6, value); }
        public nuint Dr7 { get => (nuint)GetRegisterU32(Registers.Id.Dr7); set => SetRegisterU32(Registers.Id.Dr7, value); }
        public nuint Dr8 { get => (nuint)GetRegisterU32(Registers.Id.Dr8); set => SetRegisterU32(Registers.Id.Dr8, value); }
        public nuint Dr9 { get => (nuint)GetRegisterU32(Registers.Id.Dr9); set => SetRegisterU32(Registers.Id.Dr9, value); }
        public nuint Dr10 { get => (nuint)GetRegisterU32(Registers.Id.Dr10); set => SetRegisterU32(Registers.Id.Dr10, value); }
        public nuint Dr11 { get => (nuint)GetRegisterU32(Registers.Id.Dr11); set => SetRegisterU32(Registers.Id.Dr11, value); }
        public nuint Dr12 { get => (nuint)GetRegisterU32(Registers.Id.Dr12); set => SetRegisterU32(Registers.Id.Dr12, value); }
        public nuint Dr13 { get => (nuint)GetRegisterU32(Registers.Id.Dr13); set => SetRegisterU32(Registers.Id.Dr13, value); }
        public nuint Dr14 { get => (nuint)GetRegisterU32(Registers.Id.Dr14); set => SetRegisterU32(Registers.Id.Dr14, value); }
        public nuint Dr15 { get => (nuint)GetRegisterU32(Registers.Id.Dr15); set => SetRegisterU32(Registers.Id.Dr15, value); }
#endif
        public BigInteger K0 { get => GetRegister(Registers.Id.K0); set => SetRegister(Registers.Id.K0, value); }
        public BigInteger K1 { get => GetRegister(Registers.Id.K1); set => SetRegister(Registers.Id.K1, value); }
        public BigInteger K2 { get => GetRegister(Registers.Id.K2); set => SetRegister(Registers.Id.K2, value); }
        public BigInteger K3 { get => GetRegister(Registers.Id.K3); set => SetRegister(Registers.Id.K3, value); }
        public BigInteger K4 { get => GetRegister(Registers.Id.K4); set => SetRegister(Registers.Id.K4, value); }
        public BigInteger K5 { get => GetRegister(Registers.Id.K5); set => SetRegister(Registers.Id.K5, value); }
        public BigInteger K6 { get => GetRegister(Registers.Id.K6); set => SetRegister(Registers.Id.K6, value); }
        public BigInteger K7 { get => GetRegister(Registers.Id.K7); set => SetRegister(Registers.Id.K7, value); }
        public BigInteger Bnd0 { get => GetRegister(Registers.Id.Bnd0); set => SetRegister(Registers.Id.Bnd0, value); }
        public BigInteger Bnd1 { get => GetRegister(Registers.Id.Bnd1); set => SetRegister(Registers.Id.Bnd1, value); }
        public BigInteger Bnd2 { get => GetRegister(Registers.Id.Bnd2); set => SetRegister(Registers.Id.Bnd2, value); }
        public BigInteger Bnd3 { get => GetRegister(Registers.Id.Bnd3); set => SetRegister(Registers.Id.Bnd3, value); }
        public BigInteger BndCfg { get => GetRegister(Registers.Id.BndCfg); set => SetRegister(Registers.Id.BndCfg, value); }
        public BigInteger BndStatus { get => GetRegister(Registers.Id.BndStatus); set => SetRegister(Registers.Id.BndStatus, value); }
        public BigInteger Mxcsr { get => GetRegister(Registers.Id.Mxcsr); set => SetRegister(Registers.Id.Mxcsr, value); }
        public BigInteger Pkru { get => GetRegister(Registers.Id.Pkru); set => SetRegister(Registers.Id.Pkru, value); }
        public BigInteger Xcr0 { get => GetRegister(Registers.Id.Xcr0); set => SetRegister(Registers.Id.Xcr0, value); }

        // Host Specific
#if _X64_
        public nuint Nax { get => (nuint)GetRegisterU64(Registers.Id.Rax); set => SetRegisterU64(Registers.Id.Rax, value); }
        public nuint Ncx { get => (nuint)GetRegisterU64(Registers.Id.Rcx); set => SetRegisterU64(Registers.Id.Rcx, value); }
        public nuint Ndx { get => (nuint)GetRegisterU64(Registers.Id.Rdx); set => SetRegisterU64(Registers.Id.Rdx, value); }
        public nuint Nbx { get => (nuint)GetRegisterU64(Registers.Id.Rbx); set => SetRegisterU64(Registers.Id.Rbx, value); }
        public nuint Nsp { get => (nuint)GetRegisterU64(Registers.Id.Rsp); set => SetRegisterU64(Registers.Id.Rsp, value); }
        public nuint Nbp { get => (nuint)GetRegisterU64(Registers.Id.Rbp); set => SetRegisterU64(Registers.Id.Rbp, value); }
        public nuint Nsi { get => (nuint)GetRegisterU64(Registers.Id.Rsi); set => SetRegisterU64(Registers.Id.Rsi, value); }
        public nuint Ndi { get => (nuint)GetRegisterU64(Registers.Id.Rdi); set => SetRegisterU64(Registers.Id.Rdi, value); }
        public nuint Nip { get => (nuint)GetRegisterU64(Registers.Id.Rip); set => SetRegisterU64(Registers.Id.Rip, value); }
#else
        public nuint Nax { get => (nuint)GetRegisterU32(Registers.Id.Eax); set => SetRegisterU32(Registers.Id.Eax, value); }
        public nuint Ncx { get => (nuint)GetRegisterU32(Registers.Id.Ecx); set => SetRegisterU32(Registers.Id.Ecx, value); }
        public nuint Ndx { get => (nuint)GetRegisterU32(Registers.Id.Edx); set => SetRegisterU32(Registers.Id.Edx, value); }
        public nuint Nbx { get => (nuint)GetRegisterU32(Registers.Id.Ebx); set => SetRegisterU32(Registers.Id.Ebx, value); }
        public nuint Nsp { get => (nuint)GetRegisterU32(Registers.Id.Esp); set => SetRegisterU32(Registers.Id.Esp, value); }
        public nuint Nbp { get => (nuint)GetRegisterU32(Registers.Id.Ebp); set => SetRegisterU32(Registers.Id.Ebp, value); }
        public nuint Nsi { get => (nuint)GetRegisterU32(Registers.Id.Esi); set => SetRegisterU32(Registers.Id.Esi, value); }
        public nuint Ndi { get => (nuint)GetRegisterU32(Registers.Id.Edi); set => SetRegisterU32(Registers.Id.Edi, value); }
        public nuint Nip { get => (nuint)GetRegisterU32(Registers.Id.Eip); set => SetRegisterU32(Registers.Id.Eip, value); }
#endif
    }
}

```

`src/Dotx64Managed/API/Thread.cs`:

```cs
namespace Dotx64Dbg
{
    /// <summary>
    /// A thread object that represents a thread in the debugged process.
    /// </summary>
    public partial class Thread
    {
        /// <summary>
        /// The native thread id.
        /// </summary>
        public readonly uint Id;

        /// <summary>
        /// The native thread handle.
        /// </summary>
        public readonly System.UIntPtr Handle;

        /// <summary>
        /// If this is the first thread created in the process this will be true.
        /// </summary>
        public bool IsMain { get => Id == Native.Thread.GetMainThreadId(); }

        /// <summary>
        /// If this is the currently active thread it will return true.
        /// </summary>
        public bool IsActive { get => Id == Native.Thread.GetActiveThreadId(); }

        /// <summary>
        /// The thread object is garbage collected, if the native thread does no longer exist this will return false.
        /// </summary>
        public bool IsValid { get => Handle != System.UIntPtr.Zero && Native.Thread.IsValid(Id); }

        /// <summary>
        /// Quick accessor for GetMain
        /// </summary>
        public static Thread Main { get => GetMain(); }

        /// <summary>
        /// Quick accessor for GetActive
        /// </summary>
        public static Thread Active { get => GetActive(); }

        internal Thread(uint internalId)
        {
            Id = internalId;

            var info = Native.Thread.GetThreadInfo(Id);
            if (info != null)
            {
                Handle = info.Handle;
            }
            else
            {
                Handle = System.UIntPtr.Zero;
            }
        }

        /// <summary>
        /// Gets the currently active thread from the debugger.
        /// </summary>
        public static Thread GetActive()
        {
            var th = new Thread(Native.Thread.GetActiveThreadId());
            if (!th.IsValid)
                return null;

            return th;
        }

        /// <summary>
        /// Get a thread by its native id.
        /// </summary>
        public static Thread GetById(uint id)
        {
            if (!Native.Thread.IsValid(id))
            {
                return null;
            }

            return new Thread(id);
        }

        /// <summary>
        /// Sets the active thread in the debugger.
        /// </summary>
        public static bool SetActive(Thread thread)
        {
            if (thread == null)
                return false;

            return Native.Thread.SetActiveThreadId(thread.Id);
        }

        /// <summary>
        /// Gets the first created thread for the process.
        /// </summary>
        public static Thread GetMain()
        {
            var mainId = Native.Thread.GetMainThreadId();
            if (mainId == 0)
                return null;

            return new Thread(mainId);
        }

        /// <summary>
        /// Returns all active threads from the debugger.
        /// </summary>
        public static Thread[] GetThreads()
        {
            var threadIds = Native.Thread.GetThreads();

            var threads = new Thread[threadIds.Length];
            for (int i = 0; i < threadIds.Length; i++)
            {
                threads[i] = new Thread(threadIds[i]);
            }

            return threads;
        }

        /// <summary>Pretty name</summary>
        public override string ToString()
        {
            return $"Thread #{Id}";
        }
    }
}

```

`src/Dotx64Managed/API/UI/Disassembly.cs`:

```cs
namespace Dotx64Dbg
{
    public static partial class UI
    {
        public static class Disassembly
        {
            internal static WindowType WndType = WindowType.Disassembly;
            internal static Menu.Id MenuId = 0;

            public const Menu.Root Menu = UI.Menu.Root.Disassembly;


            /// <summary>
            /// Returns the selected range from the disassembly.
            /// </summary>
            /// <returns>Selection</returns>
            public static Selection GetSelection()
            {
                var sel = Selection.FromNative(Native.UI.GetSelection((Native.UI.WindowType)WndType));
                if (sel != null)
                {
                    // NOTE: Compensate that selection is off by 1, include entire length.
                    sel.End++;
                }
                return sel;
            }

            public static bool SetSelection(Selection selection)
            {
                return Native.UI.SetSelection((Native.UI.WindowType)WndType, selection.ToNative());
            }

            public static void Update()
            {
                Native.UI.Update((Native.UI.WindowType)WndType);
            }

            internal static Menu.Id GetMenu()
            {
                return MenuId;
            }

            internal static void SetMenuId(Menu.Id id)
            {
                MenuId = id;
            }
        }
    }


}

```

`src/Dotx64Managed/API/UI/Dump.cs`:

```cs
namespace Dotx64Dbg
{
    public static partial class UI
    {
        public static class Dump
        {
            internal static WindowType WndType = WindowType.Dump;
            internal static Menu.Id MenuId = 0;

            public const Menu.Root Menu = UI.Menu.Root.Dump;

            /// <summary>
            /// Returns the selected range from the dump.
            /// </summary>
            /// <returns>Selection</returns>
            public static Selection GetSelection()
            {
                var sel = Selection.FromNative(Native.UI.GetSelection((Native.UI.WindowType)WndType));
                if (sel != null)
                {
                    // NOTE: Compensate that selection is off by 1, include entire length.
                    sel.End++;
                }
                return sel;
            }

            public static bool SetSelection(Selection selection)
            {
                return Native.UI.SetSelection((Native.UI.WindowType)WndType, selection.ToNative());
            }

            public static void Update()
            {
                Native.UI.Update((Native.UI.WindowType)WndType);
            }

            internal static Menu.Id GetMenuId()
            {
                return MenuId;
            }

            internal static void SetMenuId(Menu.Id id)
            {
                MenuId = id;
            }
        }
    }
}

```

`src/Dotx64Managed/API/UI/Log.cs`:

```cs
namespace Dotx64Dbg
{
    public static partial class UI
    {
        public static class Log
        {
            internal static Menu.Id MenuId = 0;

            /// <summary>
            /// Clears log window.
            /// </summary>
            public static void Clear()
            {
                Native.UI.ClearLog();
            }

            internal static Menu.Id GetMenu()
            {
                return MenuId;
            }

            internal static void SetMenuId(Menu.Id id)
            {
                MenuId = id;
            }
        }
    }
}

```

`src/Dotx64Managed/API/UI/MemoryMap.cs`:

```cs
namespace Dotx64Dbg
{
    public static partial class UI
    {
        public static class MemoryMap
        {
            internal static WindowType WndType = WindowType.MemoryMap;
            internal static Menu.Id MenuId = 0;

            public const Menu.Root Menu = UI.Menu.Root.MemoryMap;

            /// <summary>
            /// Returns the selected range from the memory map.
            /// </summary>
            /// <returns>Selection</returns>
            public static Selection GetSelection()
            {
                var sel = Selection.FromNative(Native.UI.GetSelection((Native.UI.WindowType)WndType));
                if (sel != null)
                {
                    // NOTE: Compensate that selection is off by 1, include entire length.
                    sel.End++;
                }
                return sel;
            }

            public static bool SetSelection(Selection selection)
            {
                return Native.UI.SetSelection((Native.UI.WindowType)WndType, selection.ToNative());
            }

            public static void Update()
            {
                Native.UI.Update((Native.UI.WindowType)WndType);
            }

            internal static Menu.Id GetMenuId()
            {
                return MenuId;
            }

            internal static void SetMenuId(Menu.Id id)
            {
                MenuId = id;
            }
        }
    }
}

```

`src/Dotx64Managed/API/UI/Menu.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    public static partial class UI
    {
        /// <summary>
        /// Adding this attribute to functions dynamically registers a new menu.
        /// </summary>
        /// <remarks>
        /// Menus that have children can not be clicked.
        /// </remarks>
        public class Menu : Attribute
        {
            public enum Root
            {
                Disassembly,
                Dump,
                Stack,
                MemoryMap,
            }

            public string Path { get; init; }

            public Root Parent { get; init; }

            /// <summary>
            /// Adding this attribute to functions dynamically registers a new menu.
            /// </summary>
            /// <param name="parent">One of the root menus such as Disassembly or Stack</param>
            /// <param name="path">This must be a path such as "My Menu" or "Sub Menus/Entry"</param>
            /// <remarks>
            /// Menus that have children can not be clicked.
            /// </remarks>
            public Menu(Root parent, string path)
            {
                Path = path;
                Parent = parent;
            }

            internal struct Id
            {
                int Value { get; init; }

                public static implicit operator Id(int id)
                {
                    return new Id { Value = id };
                }

                public static implicit operator int(Id id)
                {
                    return id.Value;
                }
            }

            public delegate void MenuDelegate();
        }
    }
}
```

`src/Dotx64Managed/API/UI/Stack.cs`:

```cs
namespace Dotx64Dbg
{
    public static partial class UI
    {
        public static class Stack
        {
            internal static WindowType WndType = WindowType.Stack;
            internal static Menu.Id MenuId = 0;

            public const Menu.Root Menu = UI.Menu.Root.Stack;

            /// <summary>
            /// Returns the selected range from the stack.
            /// </summary>
            /// <returns>Selection</returns>
            public static Selection GetSelection()
            {
                var sel = Selection.FromNative(Native.UI.GetSelection((Native.UI.WindowType)WndType));
                if (sel != null)
                {
                    // NOTE: Compensate that selection is off by 1, include entire length.
                    sel.End++;
                }
                return sel;
            }

            public static bool SetSelection(Selection selection)
            {
                return Native.UI.SetSelection((Native.UI.WindowType)WndType, selection.ToNative());
            }

            public static void Update()
            {
                Native.UI.Update((Native.UI.WindowType)WndType);
            }

            internal static Menu.Id GetMenuId()
            {
                return MenuId;
            }

            internal static void SetMenuId(Menu.Id id)
            {
                MenuId = id;
            }
        }
    }
}

```

`src/Dotx64Managed/API/UI/StatusBar.cs`:

```cs
namespace Dotx64Dbg
{
    public static partial class UI
    {
        public static class StatusBar
        {
            public static string Text { set => Native.UI.SetStatusBarText($"{value}\n"); }
        }
    }
}

```

`src/Dotx64Managed/API/UI/Types.cs`:

```cs
namespace Dotx64Dbg
{
    public static partial class UI
    {
        public static class Types
        {
            internal static WindowType WndType = WindowType.Types;
            internal static Menu.Id MenuId = 0;

            /// <summary>
            /// Updates the Types window
            /// </summary>
            public static void Update()
            {
                Native.UI.Update((Native.UI.WindowType)WndType);
            }

            internal static Menu.Id GetMenu()
            {
                return MenuId;
            }

            internal static void SetMenuId(Menu.Id id)
            {
                MenuId = id;
            }
        }
    }
}

```

`src/Dotx64Managed/API/UI/UI.cs`:

```cs
using System;

namespace Dotx64Dbg
{
    public static partial class UI
    {
        public enum WindowType
        {
            Disassembly = Native.UI.WindowType.Disassembly,
            Dump = Native.UI.WindowType.Dump,
            Stack = Native.UI.WindowType.Stack,
            Graph = Native.UI.WindowType.Graph,
            MemoryMap = Native.UI.WindowType.MemoryMap,
            SymbolModule = Native.UI.WindowType.SymbolModule,
            Types = Native.UI.WindowType.Types,
        };

        public enum MsgBoxType
        {
            Ok = Native.UI.MsgBoxType.Ok,
            OkCancel = Native.UI.MsgBoxType.OkCancel,
            YesNo = Native.UI.MsgBoxType.YesNo,
            YesNoCancel = Native.UI.MsgBoxType.YesNoCancel,
        };

        public enum MsgBoxResult
        {
            Ok = Native.UI.MsgBoxResult.Ok,
            Cancel = Native.UI.MsgBoxResult.Cancel,
            Yes = Native.UI.MsgBoxResult.Yes,
            No = Native.UI.MsgBoxResult.No,
        };

        public enum MsgBoxIcon
        {
            None = Native.UI.MsgBoxIcon.None,
            Error = Native.UI.MsgBoxIcon.Error,
            Warning = Native.UI.MsgBoxIcon.Warning,
            Information = Native.UI.MsgBoxIcon.Information,
            Question = Native.UI.MsgBoxIcon.Question,
        };

        public class Selection
        {
            public Selection()
            {
            }

            public Selection(ulong start, ulong end)
            {
                Start = (nuint)start;
                End = (nuint)end;
            }

            internal Selection(Native.UI.Selection sel)
            {
                Start = (nuint)sel.Start;
                End = (nuint)sel.End;
            }

            internal static Selection FromNative(Native.UI.Selection sel)
            {
                if (sel == null)
                    return null;
                return new Selection() { Start = (nuint)sel.Start, End = (nuint)sel.End };
            }

            internal Native.UI.Selection ToNative()
            {
                return new Native.UI.Selection()
                {
                    Start = this.Start,
                    End = this.End,
                };
            }

            //
            // Summary:
            //     Start address of the selection.
            public nuint Start;
            //
            // Summary:
            //     End address of the selection.
            public nuint End;

            //
            // Summary:
            //     The size of the selection, End - Start.
            public nuint Size
            {
                get => End - Start;
            }
        }

        /// <summary>
        /// Allows to suppress UI updates, this can speed up certain actions.
        /// </summary>
        public static bool UpdatesEnabled
        {
            get
            {
                return Native.UI.UpdatesEnabled();
            }

            set
            {
                Native.UI.EnableUpdates(value);
            }
        }

        public static void Update()
        {
            Native.UI.Update();
        }

        public class UpdateSuppressor : IDisposable
        {
            private bool wasEnabled;

            public UpdateSuppressor()
            {
                wasEnabled = UpdatesEnabled;
                if (wasEnabled)
                    UpdatesEnabled = false;
            }

            public void Dispose()
            {
                if (wasEnabled)
                    UpdatesEnabled = true;
            }
        }

        public static MsgBoxResult MsgBox(string title, string text, MsgBoxType type = MsgBoxType.Ok, MsgBoxIcon icon = MsgBoxIcon.None)
        {
            return (MsgBoxResult)Native.UI.MsgBox(title, text, (Native.UI.MsgBoxType)type, (Native.UI.MsgBoxIcon)icon);
        }

    }
}

```

`src/Dotx64Managed/AssemblyLoader.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.Loader;

namespace Dotx64Dbg
{
    internal class AssemblyLoader : AssemblyLoadContext
    {
        public Assembly Current;

        public AssemblyLoader()
            : base(true)
        {
            /*
             * Some plugin dependencies don't trigger the AssemblyLoadContext.Load()
             * So we need to load any missing dependency to the app domain 'manually'
            */
            AppDomain.CurrentDomain.AssemblyResolve += CurrentDomain_AssemblyResolve;
        }

        private Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args)
        {
            var assemblyName = new System.Reflection.AssemblyName(args.Name);

            Utils.DebugPrintLine("LoaderContext.AssemblyResolve({0})", assemblyName.Name);

            var extenalDll = externalAssemblies.FirstOrDefault(file => System.IO.Path.GetFileNameWithoutExtension(file)
                .Equals(assemblyName.Name, StringComparison.InvariantCultureIgnoreCase));

            if (extenalDll is not null)
            {
                externalAssemblies.Remove(extenalDll);
                return System.Reflection.Assembly.LoadFrom(extenalDll);
            }

            // If the required assembly is not in the list it's probably because it is already loaded in the current domain.
            // So as the last resource we gonna try to find it in the current domain;
            var requiredAssembly = AppDomain.CurrentDomain.GetAssemblies().FirstOrDefault(assembly => assembly.FullName == assemblyName.FullName);
            return requiredAssembly;
        }

        protected override Assembly Load(AssemblyName assemblyName)
        {
            Utils.DebugPrintLine("LoaderContext.Load({0})", assemblyName.Name);

            // See if the assembly is already loaded including the version.
            var loadedAssembly = AppDomain.CurrentDomain.GetAssemblies().FirstOrDefault(assembly =>
                assembly.GetName().Name.Equals(assemblyName.Name, StringComparison.InvariantCultureIgnoreCase) &&
                assembly.GetName().Version == assemblyName.Version);

            if (loadedAssembly is not null)
                return loadedAssembly;

            var extenalDll = externalAssemblies.FirstOrDefault(file => System.IO.Path.GetFileNameWithoutExtension(file)
                .Equals(assemblyName.Name, StringComparison.InvariantCultureIgnoreCase));

            if (extenalDll is not null)
            {
                externalAssemblies.Remove(extenalDll);
                return Assembly.LoadFile(extenalDll);
            }

            return Assembly.Load(assemblyName); // The assembly is already loaded in the context (We hope so)
        }

        public Assembly LoadFromFile(string path)
        {
            Current = LoadFromAssemblyPath(path);
            return Current;
        }

        public bool UnloadCurrent()
        {
            if (Current == null)
                return false;

            Unload();
            Current = null;

            return true;
        }

        public void AddExternalRequiredAssemblies(ICollection<string> assembliesPath)
        {
            var loadedAssemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (string assemblyPath in assembliesPath)
            {
                // Filter assemblies that are already loaded
                var assemblyName = System.Reflection.AssemblyName.GetAssemblyName(assemblyPath);
                if (loadedAssemblies.Any(assembly => assembly.FullName == assemblyName.FullName))
                    continue;
                externalAssemblies.Add(assemblyPath);
            }
        }

        public bool IsLoaded()
        {
            return Current != null;
        }

        ~AssemblyLoader()
        {
            AppDomain.CurrentDomain.AssemblyResolve -= CurrentDomain_AssemblyResolve;
        }

        private HashSet<string> externalAssemblies = new();
    }
}

```

`src/Dotx64Managed/Compiler.cs`:

```cs
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace Dotx64Dbg
{
    class Compiler
    {
        private string OutputPath;
        private string Name;
        private string[] Dependencies = Array.Empty<string>();

        public class Result
        {
            internal bool success = false;
            public bool Success
            {
                get => success;
            }
            public string OutputAssemblyPath;
            public MemoryStream AssemblyStream;
            public MemoryStream DebugStream;
        }

        public Compiler(string name, string outputPath = "")
        {
            OutputPath = outputPath;
            Name = name;
        }

        public Compiler WithDependencies(string[] deps)
        {
            Dependencies = deps;
            return this;
        }

        private List<SyntaxTree> ParseCode(string[] files, bool forScripting)
        {
            List<SyntaxTree> parsed = new();

            foreach (var file in files)
            {
                if (!file.EndsWith(".cs"))
                    continue;

                var parsedFile = ParseFile(file, forScripting);
                parsed.Add(parsedFile);
            }

            return parsed;
        }

        public Result Compile(string[] files, bool forScripting = false)
        {
            try
            {
                var parsed = ParseCode(files, forScripting);
                if (parsed.Count == 0)
                {
                    return new Result()
                    {
                        success = false
                    };
                }
                return CompileInternal(parsed, forScripting);
            }
            catch (System.Exception ex)
            {
                Utils.PrintException(ex);
            }

            return new Result();
        }

        public Result Compile(string code)
        {
            try
            {
                List<SyntaxTree> parsed = new() { ParseCode(code, true) };
                return CompileInternal(parsed, true);
            }
            catch (System.Exception ex)
            {
                Utils.PrintException(ex);
            }

            return new Result();
        }

        private Result CompileInternal(List<SyntaxTree> parsed, bool forScripting = false)
        {
            var coreAssemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location);

            var assemblyRefs = new HashSet<string>();
            assemblyRefs.Add(typeof(object).Assembly.Location);
            assemblyRefs.Add(typeof(Logging).Assembly.Location);
            assemblyRefs.Add(typeof(System.Runtime.CompilerServices.DynamicAttribute).Assembly.Location);
            assemblyRefs.Add(typeof(Console).Assembly.Location);
            assemblyRefs.Add(typeof(System.Runtime.AssemblyTargetedPatchBandAttribute).Assembly.Location);
            assemblyRefs.Add(typeof(Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo).Assembly.Location);
            assemblyRefs.Add(typeof(Native.Logging).Assembly.Location);
            assemblyRefs.Add(typeof(System.ComponentModel.Component).Assembly.Location);

            assemblyRefs.Add(typeof(System.Data.AcceptRejectRule).Assembly.Location);

            assemblyRefs.Add(Path.Combine(coreAssemblyPath, "netstandard.dll")); // Some libraries require .NETStandard
            assemblyRefs.Add(Path.Combine(coreAssemblyPath, "mscorlib.dll"));
            assemblyRefs.Add(Path.Combine(coreAssemblyPath, "System.dll"));
            assemblyRefs.Add(Path.Combine(coreAssemblyPath, "System.Core.dll"));
            assemblyRefs.Add(Path.Combine(coreAssemblyPath, "System.Runtime.dll"));

            Assembly.GetExecutingAssembly().GetReferencedAssemblies()
                    .ToList()
                    .ForEach(a => assemblyRefs.Add(Assembly.Load(a).Location));

            foreach (var dep in Dependencies)
            {
                assemblyRefs.Add(Path.Combine(coreAssemblyPath, dep));
            }

            var references = new List<MetadataReference>();
            foreach (var assemblyRef in assemblyRefs)
            {
                references.Add(MetadataReference.CreateFromFile(assemblyRef));
            }

            var guid = Guid.NewGuid().ToString();
            var assemblyName = Name + guid;
            var assemblyPath = Path.Combine(OutputPath, Name + guid + ".dll");
            var debugFilePath = Path.Combine(OutputPath, Name + guid + ".pdb");

            var options = new CSharpCompilationOptions(forScripting ? OutputKind.ConsoleApplication : OutputKind.DynamicallyLinkedLibrary)
                .WithOptimizationLevel(OptimizationLevel.Debug)
                .WithAssemblyIdentityComparer(DesktopAssemblyIdentityComparer.Default)
#if _X86_
                .WithPlatform(Microsoft.CodeAnalysis.Platform.X86)
#else
                .WithPlatform(Microsoft.CodeAnalysis.Platform.X64)
#endif
                .WithModuleName(Name + guid)
            ;

            if (forScripting)
            {
                options = options.WithUsings(new[] {
                    "System",
                    "Dotx64Dbg",
                    "Dotx64Dbg.Scripting",
                });
            }

            var compiler = CSharpCompilation.Create(assemblyName,
                parsed,
                references: references,
                options: options);

            try
            {
                var res = new Result();
                EmitResult result;

                if (forScripting)
                {
                    res.AssemblyStream = new MemoryStream();
                    res.DebugStream = new MemoryStream();
                    result = compiler.Emit(res.AssemblyStream, res.DebugStream);
                }
                else
                {
                    result = compiler.Emit(assemblyPath, debugFilePath);
                }

                if (!result.Success)
                {
                    Console.WriteLine("[DotX64Dbg] Build failed");

                    foreach (var info in result.Diagnostics)
                    {
                        Console.WriteLine(info.ToString());
                    }

                    res.AssemblyStream?.Dispose();
                    res.DebugStream?.Dispose();
                    res.AssemblyStream = null;
                    res.DebugStream = null;
                }
                else
                {
                    res.success = true;
                    res.OutputAssemblyPath = assemblyPath;

                    return res;
                }
            }
            catch (Exception ex)
            {
                Utils.PrintException(ex);
            }

            return new Result();
        }

        private SyntaxTree ParseFile(string file, bool forScripting)
        {
            var code = System.IO.File.ReadAllText(file, Encoding.UTF8);
            return ParseCode(code, forScripting, file);
        }

        private UsingDirectiveSyntax CreateUsingDirective(string usingName)
        {
            var name = SyntaxFactory.ParseName(usingName);
            return SyntaxFactory.UsingDirective(name);
        }

        private SyntaxTree ParseCode(string code, bool forScripting, string file = "")
        {
            var preprocessorSymbols = new List<string>();
#if _X64_
            preprocessorSymbols.Add("_X64_");
#elif _X86_
            preprocessorSymbols.Add("_X86_");
#endif
            var codeString = SourceText.From(code, Encoding.UTF8);
            var options = CSharpParseOptions.Default
                .WithLanguageVersion(LanguageVersion.CSharp9)
                .WithPreprocessorSymbols(preprocessorSymbols.ToArray())
                .WithKind(forScripting ? SourceCodeKind.Script : SourceCodeKind.Regular)
                ;
            var parsedTree = SyntaxFactory.ParseSyntaxTree(codeString, options, file);

            return parsedTree;
        }
    }
}

```

`src/Dotx64Managed/Hotload/Hotload.Adapter.Array.cs`:

```cs
namespace Dotx64Dbg
{
    internal partial class Hotload
    {
        internal static object AdaptArray(Context ctx, object oldInstance, System.Type newArrayType)
        {
            object res;
            if (ctx.GetNewReference(oldInstance, out res))
            {
                return res;
            }

            var oldArrayType = oldInstance.GetType();

            var oldElemType = oldArrayType.GetElementType();
            var newElemType = newArrayType.GetElementType();
            if (oldElemType.IsValueType || oldElemType.IsPrimitive)
            {
                // Take ownership.
                return oldInstance;
            }
            else
            {
                var src = oldInstance as System.Array;
                var dst = ctx.CreateArray(newArrayType.GetElementType(), src.Length) as System.Array;
                for (int i = 0; i < src.Length; i++)
                {
                    var oldEntry = src.GetValue(i);
                    var newObj = AdaptObject(ctx, oldEntry, oldElemType, newElemType);
                    dst.SetValue(newObj, i);
                }

                res = dst;
                ctx.MapReference(oldInstance, res);
            }

            return res;
        }
    }
}

```

`src/Dotx64Managed/Hotload/Hotload.Adapter.Class.cs`:

```cs
using System;
using System.Linq;
using System.Reflection;

namespace Dotx64Dbg
{
    internal partial class Hotload
    {
        internal static void AdaptField(Hotload.Context ctx, object oldInstance, FieldInfo oldField, object newInstance, FieldInfo newField)
        {
            var oldFieldType = oldField.FieldType;
            var newFieldType = newField.FieldType;

            var oldValue = oldField.GetValue(oldInstance);
            var newObject = AdaptObject(ctx, oldValue, oldFieldType, newFieldType);

            if (newFieldType.IsEnum)
            {
                newObject = Enum.ToObject(newFieldType, newObject);
            }

            newField.SetValue(newInstance, newObject);

            if (Nullable.GetUnderlyingType(oldFieldType) != null)
            {
                oldField.SetValue(oldInstance, null);
            }
        }

        internal static object AdaptClass(Hotload.Context ctx, object oldInstance, System.Type oldType, object newInstance, System.Type newType)
        {
            if (oldType.Assembly != ctx.OldAssembly)
            {
                return oldInstance;
            }

            Utils.DebugPrintLine($"[Hotload] Adapting instance of Class: {oldType.Name}");

            if (newInstance == null)
                newInstance = ctx.Create(newType);

            ctx.MapReference(oldInstance, newInstance);

            var fields = newType.GetRuntimeFields();
            foreach (var newField in fields)
            {
                Utils.DebugPrintLine($"[Hotload] Field: {newField.Name}, Type: {newField.FieldType}");

                var oldField = oldType.GetRuntimeFields().FirstOrDefault(a => a.Name == newField.Name);
                if (oldField != null)
                {
                    if (oldField.FieldType.Name == newField.FieldType.Name)
                    {
                        AdaptField(ctx, oldInstance, oldField, newInstance, newField);
                    }
                }
            }

            return newInstance;
        }
    }
}

```

`src/Dotx64Managed/Hotload/Hotload.Adapter.GenericDictionary.cs`:

```cs
using System.Collections;

namespace Dotx64Dbg
{
    internal partial class Hotload
    {

        internal static object AdaptGenericDictionary(Hotload.Context ctx, object oldInstance, System.Type newListType)
        {
            object res;
            if (ctx.GetNewReference(oldInstance, out res))
            {
                return res;
            }

            var elemKeyType = newListType.GenericTypeArguments[0];
            var elemValType = newListType.GenericTypeArguments[1];
            if ((elemKeyType.IsValueType || elemKeyType.IsPrimitive) && (elemValType.IsValueType || elemValType.IsPrimitive))
            {
                Utils.DebugPrintLine("[Hotload] Adapting Dictionary<> by move.");
                return oldInstance;
            }
            else
            {
                Utils.DebugPrintLine("[Hotload] Adapting Dictionary by copy.");

                var oldList = (IDictionary)oldInstance;
                var newList = (IDictionary)newListType.MakeGenericType(newListType.GenericTypeArguments)
                    .GetConstructor(System.Type.EmptyTypes)
                    .Invoke(null);

                var enumerator = oldList.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    var newKey = AdaptObject(ctx, enumerator.Key, elemKeyType, elemKeyType);
                    var newVal = AdaptObject(ctx, enumerator.Value, elemValType, elemValType);
                    newList.Add(newKey, newVal);
                }

                res = newList;

                ctx.MapReference(oldInstance, res);
            }

            return res;
        }
    }
}

```

`src/Dotx64Managed/Hotload/Hotload.Adapter.GenericList.cs`:

```cs
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace Dotx64Dbg
{
    internal partial class Hotload
    {
        private static MethodInfo GetCollectionInserterMethod(System.Type collectionType)
        {
            if (collectionType.GetGenericTypeDefinition() == typeof(Stack<>))
            {
                return collectionType.GetMethod("Push");
            }
            else if (collectionType.GetGenericTypeDefinition() == typeof(Queue<>))
            {
                return collectionType.GetMethod("Enqueue");
            }
            else if (collectionType.GetGenericTypeDefinition() == typeof(List<>))
            {
                return collectionType.GetMethod("Add");
            }
            else if (collectionType.GetGenericTypeDefinition() == typeof(HashSet<>))
            {
                return collectionType.GetMethod("Add");
            }
            else if (collectionType.GetGenericTypeDefinition() == typeof(SortedSet<>))
            {
                return collectionType.GetMethod("Add");
            }
            else
            {
                Utils.DebugPrintLine($"[Hotload] Unsupported collection type '{collectionType.FullName}', skipping.");
            }

            return null;
        }

        // Adapt a collection type that only holds values, it must have the base of IEnumerable.
        internal static object AdaptGenericList(Hotload.Context ctx, object oldInstance, System.Type newListType)
        {
            var oldList = oldInstance as IEnumerable;
            if (oldList == null)
            {
                Utils.DebugPrintLine($"[Hotload] '{newListType.FullName}' has no IEnumerable base.");
                return null;
            }

            object res;
            if (ctx.GetNewReference(oldInstance, out res))
            {
                return res;
            }

            var elemType = newListType.GenericTypeArguments[0];
            if (elemType.IsValueType || elemType.IsPrimitive)
            {
                Utils.DebugPrintLine("[Hotload] Adapting list by move.");
                return oldInstance;
            }
            else
            {
                Utils.DebugPrintLine("[Hotload] Adapting List<> by copy.");

                var newList = newListType.MakeGenericType(newListType.GenericTypeArguments)
                    .GetConstructor(System.Type.EmptyTypes)
                    .Invoke(null);

                var inserterMethod = GetCollectionInserterMethod(newListType);
                if (inserterMethod == null)
                {
                    return null;
                }

                foreach (var entry in oldList)
                {
                    var newEntry = AdaptObject(ctx, entry, elemType, elemType);
                    inserterMethod.Invoke(newList, new object[] { newEntry });
                }

                res = newList;

                ctx.MapReference(oldInstance, res);
            }

            return res;
        }
    }
}

```

`src/Dotx64Managed/Hotload/Hotload.Adapter.Object.cs`:

```cs
using System.Collections.Generic;

namespace Dotx64Dbg
{
    internal partial class Hotload
    {
        public static object AdaptObject(Hotload.Context ctx, object oldInstance, System.Type oldType, System.Type newType)
        {
            if (oldInstance == null)
                return null;

            // Types from other assemblies will be moved.
            if (oldType.Assembly != ctx.OldAssembly)
            {
                return oldInstance;
            }

            if (oldType.FullName != newType.FullName)
            {
                Utils.DebugPrintLine($"[Hotload] Type mismatch '{oldType.FullName}' to '{newType.FullName}', skipping.");
                return null;
            }

            if (oldType.IsValueType && newType.IsValueType)
            {
                return oldInstance;
            }

            if (oldType.IsPrimitive && newType.IsPrimitive)
            {
                return oldInstance;
            }

            object res;
            if (ctx.GetNewReference(oldInstance, out res))
            {
                return res;
            }

            if (newType == typeof(string))
            {
                return oldInstance;
            }
            else if (newType.IsArray)
            {
                res = AdaptArray(ctx, oldInstance, newType);
            }
            else if (newType.IsClass)
            {
                if (newType.IsGenericType)
                {
                    var genericType = newType.GetGenericTypeDefinition();
                    if (genericType == typeof(List<>))
                    {
                        res = AdaptGenericList(ctx, oldInstance, newType);
                    }
                    else if (genericType == typeof(Stack<>))
                    {
                        res = AdaptGenericList(ctx, oldInstance, newType);
                    }
                    else if (genericType == typeof(HashSet<>))
                    {
                        res = AdaptGenericList(ctx, oldInstance, newType);
                    }
                    else if (genericType == typeof(SortedSet<>))
                    {
                        res = AdaptGenericList(ctx, oldInstance, newType);
                    }
                    else if (genericType == typeof(Dictionary<,>))
                    {
                        res = AdaptGenericDictionary(ctx, oldInstance, newType);
                    }
                    else if (genericType == typeof(SortedDictionary<,>))
                    {
                        res = AdaptGenericDictionary(ctx, oldInstance, newType);
                    }
                    else
                    {
                        Utils.DebugPrintLine($"[Hotload] Unsupported transition for '{oldType.FullName}', skipping.");
                    }
                    // TODO: Add more support for generic collections.
                }
                else
                {
                    res = AdaptClass(ctx, oldInstance, oldType, res, newType);
                }
            }

            return res;
        }
    }
}

```

`src/Dotx64Managed/Hotload/Hotload.Adapter.Statics.cs`:

```cs
using System.Reflection;

namespace Dotx64Dbg
{
    internal partial class Hotload
    {
        internal static void AdaptStatics(Hotload.Context ctx, Assembly oldAssembly, Assembly newAssembly)
        {
            foreach (var newType in newAssembly.GetTypes())
            {
                if (!newType.IsClass)
                    continue;

                // TODO: Fix all statics.
            }
        }
    }
}

```

`src/Dotx64Managed/Hotload/Hotload.Adapter.cs`:

```cs
namespace Dotx64Dbg
{
    internal partial class Hotload
    {
    }
}

```

`src/Dotx64Managed/Hotload/Hotload.Context.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;

namespace Dotx64Dbg
{
    internal partial class Hotload
    {
        internal class Context : IDisposable
        {
            Dictionary<object, object> ReferenceMap = new();
            List<object> NewObjects = new();
            public Assembly OldAssembly
            {
                get;
            }
            public Assembly NewAssembly
            {
                get;
            }

            public Context(Assembly oldAssembly, Assembly newAssembly)
            {
                OldAssembly = oldAssembly;
                NewAssembly = newAssembly;
            }

            public void Dispose()
            {
                ReferenceMap.Clear();
                ReferenceMap = null;
            }

            public object Create(Type type)
            {
                var obj = FormatterServices.GetUninitializedObject(type);
                NewObjects.Add(obj);
                return obj;
            }

            public object CreateArray(Type elemType, int size)
            {
                var obj = Array.CreateInstance(elemType, size);
                NewObjects.Add(obj);
                return obj;
            }

            public bool GetNewReference(object oldObj, out object newObj)
            {
                return ReferenceMap.TryGetValue(oldObj, out newObj);
            }

            public void MapReference(object oldObj, object newObj)
            {
                ReferenceMap.Add(oldObj, newObj);
            }

            public object[] GetObjectsWithInterface(Type type)
            {
                var res = NewObjects.Where(a => a.GetType().GetInterface(type.Name) != null).ToArray();
                return res;
            }
        }
    }
}

```

`src/Dotx64Managed/Hotload/Hotload.cs`:

```cs
namespace Dotx64Dbg
{
    internal partial class Hotload
    {
    }
}

```

`src/Dotx64Managed/IPlugin.cs`:

```cs
namespace Dotx64Dbg
{
    public interface IHotload
    {
        // Called as soon the plugin is compiled and reloaded.
        public void OnHotload();
    }

    public interface IPlugin
    {
        // Called when the plugin is loaded.
        public void Startup()
        {
        }

        // Called when the plugin is unloaded.
        public void Shutdown()
        {
        }

        // Debug Events
        public void OnExceptionEvent(ExceptionEventInfo ev)
        {
        }
        public void OnThreadCreateEvent(ThreadCreateEventInfo ev)
        {
        }
        public void OnThreadExitEvent(ThreadExitEventInfo ev)
        {
        }
        public void OnProcessCreateEvent(ProcessCreateEventInfo ev)
        {
        }
        public void OnProcessExitEvent(ProcessExitEventInfo ev)
        {
        }
        public void OnBreakpointEvent(BreakpointEventInfo ev)
        {
        }
        public void OnSteppedEvent()
        {
        }
        public void OnDebuggerStart(string fileName)
        {
        }
        public void OnDebuggerStop()
        {
        }
        public void OnDebuggerResume()
        {
        }
        public void OnDebuggerPause()
        {
        }
        public void OnModuleLoadEvent(ModuleLoadEventInfo ev)
        {
        }
        public void OnModuleUnloadEvent(ModuleUnloadEventInfo ev)
        {
        }
    }
}

```

`src/Dotx64Managed/Logging.cs`:

```cs
using System;
using System.IO;
using System.Text;

namespace Dotx64Dbg
{
    class ConsoleWriter : TextWriter
    {
        public override Encoding Encoding { get { return Encoding.UTF8; } }

        public override void Write(string value)
        {
            Native.Logging.Write(value);
        }

        public override void WriteLine(string value)
        {
            Native.Logging.WriteLine(value);
        }
        public override void WriteLine()
        {
            Native.Logging.WriteLine();
        }
    }

    public static class Logging
    {
        internal static void Initialize()
        {
            var sink = new ConsoleWriter();
            Console.SetOut(sink);
            Console.SetError(sink);
        }
    }

}

```

`src/Dotx64Managed/Manager.Events.cs`:

```cs
using System;

namespace Dotx64Dbg
{
    /// <summary>
    /// Passed in OnExceptionEvent
    /// </summary>
    public struct ExceptionEventInfo
    {

        public uint ProcessId;
        public uint ThreadId;
        public bool FirstChance;
        public uint ExceptionCode;
        public uint ExceptionFlags;
        public ulong ExceptionAddress;
    }

    /// <summary>
    /// Passed in OnThreadCreateEvent
    /// </summary>
    public struct ThreadCreateEventInfo
    {
        public uint ProcessId;
        public uint ThreadId;
        public ulong Handle;
        public ulong ThreadLocalBase;
        public ulong StartAddress;
    }

    /// <summary>
    /// Passed in OnThreadExitEvent
    /// </summary>
    public struct ThreadExitEventInfo
    {
        public uint ProcessId;
        public uint ThreadId;
        public uint ExitCode;
    }

    /// <summary>
    /// Passed in OnProcessCreateEvent
    /// </summary>
    public struct ProcessCreateEventInfo
    {
        public uint ProcessId;
        public uint ThreadId;
        public ulong FileHandle;
        public ulong ProcessHandle;
        public ulong ThreadHandle;
        public ulong ImageBase;
        public ulong ImageSize;
        public uint DebugInfoFileOffset;
        public uint DebugInfoSize;
        public ulong ThreadLocalBase;
        public ulong StartAddress;
        public string FilePath;
        public short Unicode;
    }

    /// <summary>Passed in OnProcessExitEvent</summary>
    public struct ProcessExitEventInfo
    {
        /// <summary>Native process id.</summary>
        public uint ProcessId;
        public uint ThreadId;
        public uint ExitCode;
    }

    /// <summary>Passed in OnBreakpointEvent</summary>
    public struct BreakpointEventInfo
    {
        public Breakpoints.Type Type;
        public ulong Address;
        public bool Enabled;
        public bool Singleshot;
        public bool Active;
        public string Name;
        public string Module;
        public ushort Slot;
        public int TypeEx;
        public int Size;
        public uint HitCount;
        public bool FastResume;
        public bool Silent;
        public string BreakCondition;
        public string LogText;
        public string LogCondition;
        public string CommandText;
        public string CommandCondition;
    }

    public struct ModuleLoadEventInfo
    {
        public ulong ImageBase;
        public ulong ImageSize;
        public string FilePath;
        public uint DebugInfoFileOffset;
        public uint DebugInfoSize;
    }

    public struct ModuleUnloadEventInfo
    {
        public ulong ImageBase;
        public ulong ImageSize;
        public string FilePath;
    }

    /// <summary>Class for synchronization between x64Dbg and this plugin.</summary>
    public static partial class Manager
    {
        internal static void PluginEventCall(Action<IPlugin> action)
        {
            PluginManager.GetPluginInstances().ForEach(delegate (IPlugin instance)
            {
                try
                {
                    action(instance);
                }
                catch (Exception ex)
                {
                    Utils.PrintException(ex);
                }
            });
        }

        /// <summary>Internal function, do not call this.</summary>
        public static void OnExceptionEvent(ExceptionEventInfo ev)
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnExceptionEvent(ev);
            });
        }

        /// <summary>Internal function, do not call this.</summary>
        public static void OnThreadCreateEvent(ThreadCreateEventInfo ev)
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnThreadCreateEvent(ev);
            });
        }

        /// <summary>Internal function, do not call this.</summary>
        public static void OnProcessCreateEvent(ProcessCreateEventInfo ev)
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnProcessCreateEvent(ev);
            });
        }

        /// <summary>Internal function, do not call this.</summary>
        public static void OnThreadExitEvent(ThreadExitEventInfo ev)
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnThreadExitEvent(ev);
            });
        }

        /// <summary>Internal function, do not call this.</summary>
        public static void OnProcessExitEvent(ProcessExitEventInfo ev)
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnProcessExitEvent(ev);
            });
        }

        public static void OnBreakpointEvent(BreakpointEventInfo ev)
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnBreakpointEvent(ev);
            });
        }

        public static void OnSteppedEvent()
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnSteppedEvent();
            });
        }

        public static void OnDebuggerStart(string fileName)
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnDebuggerStart(fileName);
            });
        }

        public static void OnDebuggerStop()
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnDebuggerStop();
            });
        }
        public static void OnDebuggerResume()
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnDebuggerResume();
            });
        }
        public static void OnDebuggerPause()
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnDebuggerPause();
            });
        }

        public static void OnModuleLoadEvent(ModuleLoadEventInfo ev)
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnModuleLoadEvent(ev);
            });
        }

        public static void OnModuleUnloadEvent(ModuleUnloadEventInfo ev)
        {
            PluginEventCall(delegate (IPlugin instance)
            {
                instance.OnModuleUnloadEvent(ev);
            });
        }
    }
}

```

`src/Dotx64Managed/Manager.cs`:

```cs
using System;
using System.IO;
using System.Linq;

namespace Dotx64Dbg
{
    public static partial class Manager
    {
        // Lock used to avoid a fight between main thread events and
        // plugin hot-load events.
        internal static Object LoaderLock = new Object();

        internal static Plugins PluginManager;
        internal static int PluginHandle;

        private static void RunTests()
        {
            var tests = new Tests();
            tests.Run();
        }

        public static bool Init(int pluginHandle)
        {
            try
            {
                lock (LoaderLock)
                {
                    PluginHandle = pluginHandle;

                    AppDomain.CurrentDomain.AssemblyResolve += CurrentDomain_NugetDepsAssemblyResolve;

                    Logging.Initialize();
                    Commands.Initialize();
                    Expressions.Initialize();
                    ScriptLoader.Initialize();
                    Menus.Initialize();

                    if (!Settings.Load(Path.Combine(Utils.GetRootPath(), "dotx64dbg.json")))
                    {
                        Console.WriteLine("[DotX64Dbg] Failed to load settings, using default configuration");
                    }

                    if (Settings.EnableTests)
                    {
                        RunTests();
                    }

                    Console.WriteLine("[DotX64Dbg] Manager initialized");
                }
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Exception: {ex.Message}");
                return false;
            }

            return true;
        }

        private static System.Reflection.Assembly CurrentDomain_NugetDepsAssemblyResolve(object sender, ResolveEventArgs args)
        {
            var libs = new DirectoryInfo(Utils.DotX64DbgNugetDepsPath).GetFiles("*.dll");
            var assemblyName = new System.Reflection.AssemblyName(args.Name);

            var dll = libs.FirstOrDefault(file => Path.GetFileNameWithoutExtension(file.Name)
                .Equals(assemblyName.Name, StringComparison.InvariantCultureIgnoreCase));

            if (dll is not null)
            {
                return System.Reflection.Assembly.LoadFrom(dll.FullName);
            }
            return null;
        }

        public static void Setup()
        {
        }

        public static void Shutdown()
        {
            PluginManager.Shutdown();
            PluginManager = null;
        }

        public static void SetMenuData(MenuData data)
        {
            lock (LoaderLock)
            {
                Menus.InitializeMenus(data);

                PluginManager = new();
                PluginManager.Initialize();
            }
        }

        public static void OnMenuCallback(int id)
        {
            Menus.HandleCallback(id);
        }

        public static bool EvalScript(string code)
        {
            return ScriptLoader.ExecuteCode(code);
        }

        internal static Plugins GetPlugins()
        {
            return PluginManager;
        }
    }
}

```

`src/Dotx64Managed/Menus.Main.cs`:

```cs
using System.Diagnostics;
using System.IO;

namespace Dotx64Dbg
{
    internal static partial class Menus
    {
        internal static void RunScript()
        {
            var fileFilter = "C# File (*.cs)|*.cs|All files (*.*)|*.*";
            var scriptPath = Platform.OpenFileBrowse("Open Dotx64Dbg Script", fileFilter);
            if (scriptPath == null)
                return;

            ScriptLoader.ExecuteScriptFile(scriptPath);
        }

        internal static void OpenEditor(string projectPath)
        {
            System.Diagnostics.Process.Start(new ProcessStartInfo(projectPath) { UseShellExecute = true });
        }
        internal static void OpenFolder(string folder)
        {
            System.Diagnostics.Process.Start(new ProcessStartInfo(folder) { UseShellExecute = true });
        }

        internal static string PromptPluginName()
        {
            var plugins = Manager.GetPlugins();

            for (; ; )
            {
                var pluginName = Native.UI.InputPrompt("Enter a name for the Plugin");
                if (pluginName == null)
                    return null;

                if (plugins.IsPluginNameTaken(pluginName))
                {
                    UI.MsgBox("Error", "A plugin with the specified name already exists.", UI.MsgBoxType.Ok);
                    continue;
                }

                return pluginName;
            }
        }

        internal static void CreateNewPlugin()
        {
            var plugins = Manager.GetPlugins();

            string pluginName = PromptPluginName();
            if (pluginName == null)
                return;

            var pluginPath = plugins.CreatePluginTemplate(pluginName);
            if (pluginPath == null)
            {
                UI.MsgBox("Error", "Failed to create new plugin", UI.MsgBoxType.Ok);
                return;
            }

            OpenFolder(pluginPath);
        }

        internal static void InitializeMainMenu()
        {
            // Plugin icon
            Native.UI.Menu.SetIcon(MainMenu, Resources.GetData("Dotx64DbgIcon.png"));

            AddMenu("Main/Run Script", Resources.GetData("RunIcon.png"), RunScript);
            AddMenu("Main/Create Plugin", Resources.GetData("NewScriptIcon.png"), CreateNewPlugin);
            AddSeperator("Main");
        }

        internal static void AddPluginMenu(Plugin plugin)
        {
            if (plugin.Info == null)
                return;

            string rootPath = $"Main/Plugins/{plugin.Info.Name}";

            // Open Editor.
            // TODO: Find a way to determine if something actually handles .csproj
            {
                string path = $"{rootPath}/Open in Editor";
                string projectPath = plugin.ProjectFilePath;
                AddMenu(plugin, path, delegate ()
                {
                    if (!File.Exists(plugin.ProjectFilePath))
                    {
                        Plugins.GenerateProject(plugin);
                    }
                    OpenEditor(projectPath);
                });
            }

            // Open in Explorer.
            {
                string path = $"{rootPath}/Open in Explorer";
                string pluginPath = plugin.Path;
                AddMenu(plugin, path, delegate ()
                {
                    OpenFolder(pluginPath);
                });
            }

            AddSeperator(rootPath);

            // About.
            {
                string path = $"{rootPath}/About";
                AddMenu(plugin, path, delegate ()
                {
                    if (plugin.Info == null)
                        return;

                    var info = plugin.Info;
                    UI.MsgBox(info.Name,
                        $"Author: {info.Author}\n" +
                        $"Version: {info.Version}\n" +
                        $"Website: {info.Website}\n" +
                        $"Description: {info.Description}", UI.MsgBoxType.Ok, UI.MsgBoxIcon.Information);
                });
            }

        }


    }
}

```

`src/Dotx64Managed/Menus.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;

namespace Dotx64Dbg
{
    public struct MenuData
    {
        public int hMenu; //plugin menu handle
        public int hMenuDisasm; //plugin disasm menu handle
        public int hMenuDump; //plugin dump menu handle
        public int hMenuStack; //plugin stack menu handle
        public int hMenuGraph; //plugin graph menu handle
        public int hMenuMemmap; //plugin memory map menu handle
        public int hMenuSymmod; //plugin symbol module menu handle
    }

    internal static partial class Menus
    {
        internal class MenuEntry
        {
            internal Plugin plugin;
            internal UI.Menu.Id id;
            internal UI.Menu.Id parent;
            internal bool subEntry;
        }

        internal static Dictionary<string, MenuEntry> Registered;
        internal static Dictionary<int, UI.Menu.MenuDelegate> Handlers;

        internal static UI.Menu.Id NextInternalId = 0;
        internal static UI.Menu.Id MainMenu;

        // Reserved menu paths that can not belong to a plugin.
        private static readonly string[] PreservedMenus =
        {
            "Main",
            "Main/Plugins",
        };

        internal static void Initialize()
        {
            Registered = new();
            Handlers = new();
        }

        internal static byte[] ImageToBytes(Object image)
        {
            return null;
        }

        internal static void InitializeMenus(MenuData data)
        {
            MainMenu = data.hMenu;
            Registered.Add("Main", new()
            {
                plugin = null,
                id = data.hMenu,
                parent = -1
            });

            UI.Disassembly.SetMenuId(data.hMenuDisasm);
            Registered.Add("Disassembly", new()
            {
                plugin = null,
                id = data.hMenuDisasm,
                parent = -1
            });

            UI.Dump.SetMenuId(data.hMenuDump);
            Registered.Add("Dump", new()
            {
                plugin = null,
                id = data.hMenuDump,
                parent = -1
            });

            UI.MemoryMap.SetMenuId(data.hMenuMemmap);
            Registered.Add("MemoryMap", new()
            {
                plugin = null,
                id = data.hMenuMemmap,
                parent = -1
            });

            UI.Stack.SetMenuId(data.hMenuStack);
            Registered.Add("Stack", new()
            {
                plugin = null,
                id = data.hMenuStack,
                parent = -1
            });

            InitializeMainMenu();
        }

        internal static void HandleCallback(int id)
        {
            UI.Menu.MenuDelegate func;
            if (Handlers.TryGetValue(id, out func))
            {
                try
                {
                    func();
                }
                catch (Exception ex)
                {
                    Utils.PrintException(ex);
                }
            }
        }

        internal static void AddMenu(string path, UI.Menu.MenuDelegate func) =>
            AddMenu(path, null, func);

        internal static void AddMenu(string path, byte[] imageData, UI.Menu.MenuDelegate func) =>
            AddMenu(null, path, imageData, func);

        internal static void AddMenu(Plugin plugin, string path, UI.Menu.MenuDelegate func) =>
            AddMenu(plugin, path, null, func);

        internal static void AddMenu(Plugin plugin, string path, byte[] imageData, UI.Menu.MenuDelegate func)
        {
            var pos = 0;
            var prev = 0;
            var entryName = "";

            MenuEntry entry = null;
            MenuEntry nextEntry = null;

            pos = path.IndexOf('/', pos);
            while (pos > 0)
            {
                var currentPath = path.Substring(0, pos);
                entryName = path.Substring(prev, (pos - prev));

                if (!Registered.TryGetValue(currentPath, out nextEntry))
                {
                    var parentId = entry != null ? entry.id : (UI.Menu.Id)(-1);

                    nextEntry = new()
                    {
                        plugin = plugin,
                        parent = parentId,
                        id = Native.UI.Menu.Add(parentId, entryName),
                        subEntry = false,
                    };
                    if (PreservedMenus.Contains(currentPath))
                    {
                        nextEntry.plugin = null;
                    }
                    Registered.Add(currentPath, nextEntry);

                    entry = nextEntry;
                }
                else
                {
                    entry = nextEntry;
                }

                prev = pos + 1;
                pos = path.IndexOf('/', pos + 1);
            }

            // Add the final entry.
            nextEntry = new MenuEntry()
            {
                plugin = plugin,
                parent = entry.id,
                id = NextInternalId,
                subEntry = true,
            };
            if (PreservedMenus.Contains(path))
            {
                nextEntry.plugin = null;
            }
            Registered.Add(path, nextEntry);

            Handlers.Add(nextEntry.id, func);

            entryName = path.Substring(prev);
            Native.UI.Menu.AddEntry(nextEntry.parent, nextEntry.id, entryName);
            if (imageData is not null)
            {
                Native.UI.Menu.SetEntryIcon(Manager.PluginHandle, nextEntry.id, imageData);
            }

            NextInternalId++;
        }

        internal static bool TryFindMenu(string path, out UI.Menu.Id id)
        {
            MenuEntry entry = null;
            if (!Registered.TryGetValue(path, out entry))
            {
                id = -1;
                return false;
            }
            id = entry.id;
            return true;
        }

        internal static bool AddSeperator(string path)
        {
            UI.Menu.Id id;
            if (!TryFindMenu(path, out id))
            {
                return false;
            }
            return Native.UI.Menu.AddSeperator(id);
        }

        internal static bool Remove(string name)
        {
            MenuEntry entry;
            if (Registered.TryGetValue(name, out entry))
            {
                if (entry.subEntry)
                    Native.UI.Menu.RemoveEntry(Manager.PluginHandle, entry.id);
                else
                    Native.UI.Menu.Remove(entry.id);

                Handlers.Remove(entry.id);
                Registered.Remove(name);

                return true;
            }

            return false;
        }

        internal static bool RemoveAllFor(Plugin plugin)
        {
            Registered.Where(x => x.Value.plugin == plugin)
                .Select(x => x.Key)
                .ToList()
                .ForEach(name =>
                {
                    Remove(name);
                });

            return true;
        }

    }
}

```

`src/Dotx64Managed/NodeList.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    public class NodeList
    {
        public abstract class Node
        {
            public Node Prev { get; internal set; }
            public Node Next { get; internal set; }
        }

        public abstract class NodeKind<T> : Node
        {
            public T Value { get; set; }
        }

        public Node Head { get; internal set; }
        public Node Tail { get; internal set; }

        public ulong Count { get; internal set; }

        public Node Prepend(Node node)
        {
            node.Next = Head;
            node.Prev = null;

            if (Head != null)
                Head.Prev = node;
            else
                Tail = node;

            Head = node;
            Count++;
            return Head;
        }

        public Node Apend(Node node)
        {
            node.Next = null;
            if (Tail == null)
            {
                node.Prev = null;
                Head = Tail = node;
            }
            else
            {
                Tail.Next = node;
                node.Prev = Tail;
                Tail = node;
            }

            Count++;
            return node;
        }

        public Node Detach(Node node)
        {
            var pre = node.Prev;
            var post = node.Next;

            if (pre != null)
                pre.Next = post;

            if (post != null)
                post.Prev = pre;

            if (node == Head)
                Head = post;

            if (node == Tail)
                Tail = pre;

            Count--;

            node.Prev = null;
            node.Next = null;

            return pre;
        }

        public Node InsertBefore(Node pos, Node node)
        {
            if (pos == Head || pos == null)
                return Prepend(node);

            var pre = pos.Prev;

            node.Prev = pre;
            node.Next = pos;

            pre.Next = node;
            pos.Prev = node;

            Count++;
            return node;
        }

        public Node InsertAfter(Node pos, Node node)
        {
            if (pos == null)
                return Prepend(node);
            else if (pos == Tail)
                return Apend(node);

            var next = pos.Next;
            pos.Next = node;

            if (next != null)
                next.Prev = node;

            node.Prev = pos;
            node.Next = next;

            Count++;
            return node;
        }

    }
}

```

`src/Dotx64Managed/Plugins.Builder.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;

namespace Dotx64Dbg
{
    internal partial class Plugins
    {
        System.Threading.Thread BuildThread;
        System.Threading.AutoResetEvent WorkerWakeup = new(false);
        System.Threading.CancellationTokenSource BuildCancellation = new();

        const UInt32 PluginCacheMagic = 0x58746F44; // DotX.
        const UInt32 PluginCacheVersion = 0x00000002;

        bool RebuildInProgress = false;
        bool SkipRebuilding = false;

        void StartBuildWorker()
        {
            BuildThread = new(BuildWorker);
            BuildThread.Start();
        }

        void StopBuildWorker()
        {
            try
            {
                BuildCancellation.Cancel();
                WorkerWakeup.Set();
                BuildThread.Join();
            }
            catch (Exception)
            {
            }
        }

        void BuildWorker()
        {
            try
            {
                var cancelToken = BuildCancellation.Token;

                while (true)
                {
                    WorkerWakeup.WaitOne();

                    cancelToken.ThrowIfCancellationRequested();

                    // Delay this a bit to give the file notification handler a chance
                    // to process multiple files.
                    System.Threading.Thread.Sleep(100);

                    lock (Manager.LoaderLock)
                    {
                        Utils.DebugPrintLine("Begin rebuild");

                        RebuildPlugins(cancelToken);

                        Utils.DebugPrintLine("End rebuild");
                        RebuildInProgress = false;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                Utils.DebugPrintLine("Loop canceled");
                RebuildInProgress = false;
            }
            catch (Exception ex)
            {
                RebuildInProgress = false;
                Utils.PrintException(ex);
            }
        }

        private void TriggerRebuild()
        {
            if (SkipRebuilding)
                return;

            Utils.DebugPrintLine($"TriggerRebuild");

            RebuildInProgress = true;
            WorkerWakeup.Set();
        }

        private void WaitForRebuild()
        {
            while (RebuildInProgress)
            {
                System.Threading.Thread.Sleep(10);
            }
        }

        bool RebuildPlugin(Plugin plugin, System.Threading.CancellationToken token)
        {
            var stopwatch = new Stopwatch();

            Console.WriteLine("[DotX64Dbg] Rebuilding plugin '{0}'...", plugin.Info.Name);
            stopwatch.Start();

            var compiler = new Compiler(plugin.Info.Name, plugin.BuildOutputPath)
                .WithDependencies(plugin.ResolveDependencies(dependencyResolver, token));

            var res = compiler.Compile(plugin.SourceFiles.ToArray());
            stopwatch.Stop();

            if (!res.Success)
            {
                Console.WriteLine("[DotX64Dbg] Build failed");
                return false;
            }

            Console.WriteLine("[DotX64Dbg] Compiled plugin '{0}' in {1} ms", plugin.Info.Name, stopwatch.ElapsedMilliseconds);

            // Successfully built.
            plugin.RequiresRebuild = false;

            return ReloadPlugin(plugin, res.OutputAssemblyPath, token);
        }

        void RebuildPlugins(System.Threading.CancellationToken token)
        {
            // TODO: Investigate building in parallel            
            //Parallel.ForEach(Registered, plugin =>
            Registered.ForEach(plugin =>
            {
                token.ThrowIfCancellationRequested();

                if (plugin.Info == null || plugin.RequiresRebuild == false)
                {
                    return;
                }

                if (plugin.SourceFiles.Count == 0)
                {
                    Utils.DebugPrintLine($"Plugin {plugin.Path} has no source files, skipping.");
                    return;
                }

                // We need to check if a rebuild is indeed necessary
                var cacheDirectory = new DirectoryInfo(Path.Combine(plugin.BuildOutputPath, ".cache"));
                cacheDirectory.Create();
                var cacheFile = Path.Combine(cacheDirectory.FullName, "last_build");
                if (plugin.AssemblyPath is null && File.Exists(cacheFile))
                {
                    if (InitializePluginFromCache(plugin, cacheFile))
                    {
                        if (ReloadPlugin(plugin, plugin.AssemblyPath, token))
                        {
                            Utils.DebugPrintLine($"Loaded plugin '{plugin.Info.Name}' from cache");
                        }
                        DeleteNotUsedPluginCache(plugin);
                        plugin.RequiresRebuild = false;
                        return;
                    }
                    else
                    {
                        Utils.DebugPrintLine($"[{plugin.Name}] Deleting cache...");
                        File.Delete(cacheFile);
                    }
                }
                if (RebuildPlugin(plugin, token))
                {
                    CachePluginBuild(plugin, cacheFile);
                }
                DeleteNotUsedPluginCache(plugin);
            });

            void DeleteNotUsedPluginCache(Plugin plugin)
            {
                var oldFiles = Directory.GetFiles(plugin.BuildOutputPath, "*.*", SearchOption.AllDirectories);
                string baseFileName = Path.GetFileNameWithoutExtension(plugin.AssemblyPath);

                foreach (var oldFile in oldFiles)
                {
                    if (Path.GetFileNameWithoutExtension(oldFile).Equals(baseFileName, StringComparison.OrdinalIgnoreCase))
                        continue;

                    try
                    {
                        if (oldFile.EndsWith(".dll") || oldFile.EndsWith(".pdb"))
                        {
                            File.Delete(oldFile);
                        }
                    }
                    catch (Exception)
                    {
                    }
                }
            }

            uint ComputePluginSourcesHash(Plugin plugin)
            {
                uint hash = uint.MaxValue;
                var md5 = System.Security.Cryptography.MD5.Create();
                foreach (var source in plugin.SourceFiles)
                {
                    var md5Hash = md5.ComputeHash(File.ReadAllBytes(source));
                    foreach (byte b in md5Hash)
                        hash = (hash >> 8) ^ b;
                }
                return hash;
            }

            void CachePluginBuild(Plugin plugin, string cacheFilePath)
            {
                using var fs = File.OpenWrite(cacheFilePath);
                using System.IO.Compression.ZipArchive zipArchive = new(fs, System.IO.Compression.ZipArchiveMode.Create);
                var entry = zipArchive.CreateEntry(nameof(Plugin));
                using BinaryWriter bw = new(entry.Open());
                bw.Write(PluginCacheMagic);
                bw.Write(PluginCacheVersion);
                bw.Write(Utils.GetVersionHash());
                bw.Write(ComputePluginSourcesHash(plugin)); // uint32 hash
                bw.Write(plugin.AssemblyPath);
                bw.Write(plugin.BuildOutputPath);
                bw.Write(PluginCacheMagic);
            }

            bool InitializePluginFromCache(Plugin plugin, string cacheFilePath)
            {
                try
                {
                    using System.IO.Compression.ZipArchive zipArchive = System.IO.Compression.ZipFile.OpenRead(cacheFilePath);
                    var entry = zipArchive.GetEntry(nameof(Plugin));
                    if (entry is null)
                        return false;

                    using BinaryReader br = new(entry.Open());

                    if (br.ReadUInt32() != PluginCacheMagic)
                    {
                        Utils.DebugPrintLine($"Invalid cache for plugin '{plugin.Path}'");
                        return false;
                    }

                    var cacheVersion = br.ReadUInt32();
                    if (cacheVersion < PluginCacheVersion)
                    {
                        Utils.DebugPrintLine($"Cache version mismatch for plugin '{plugin.Path}': {cacheVersion} < {PluginCacheVersion}");
                        return false;
                    }

                    var versionHash = br.ReadUInt32();
                    if (versionHash != Utils.GetVersionHash())
                    {
                        Utils.DebugPrintLine($"Version hash mismatch for plugin '{plugin.Path}': {versionHash} != {Utils.GetVersionHash()}");
                        return false;
                    }

                    uint hash = br.ReadUInt32();
                    if (hash != ComputePluginSourcesHash(plugin))
                    {
                        Utils.DebugPrintLine($"Source hash mismatch for plugin '{plugin.Path}': {hash} != {ComputePluginSourcesHash(plugin)}");
                        return false;
                    }

                    string assemblyPath = br.ReadString();
                    if (!File.Exists(assemblyPath))
                    {
                        Utils.DebugPrintLine($"Assembly '{assemblyPath}' does not exist for plugin '{plugin.Path}'");
                        return false;
                    }
                    string buildOutputPath = br.ReadString();

                    if (br.ReadUInt32() != PluginCacheMagic)
                    {
                        Utils.DebugPrintLine($"Invalid cache for plugin '{plugin.Path}'");
                        return false;
                    }

                    plugin.AssemblyPath = assemblyPath;
                    plugin.BuildOutputPath = buildOutputPath;
                    return true;

                }
                catch (Exception ex)
                {
                    if (ex is FormatException || ex is EndOfStreamException || ex is InvalidDataException)
                    {
                        Utils.DebugPrintLine($"Failed to read cache for plugin '{plugin.Path}': {ex.Message}");
                        return false;
                    }
                    throw;
                }
            }
        }
    }
}

```

`src/Dotx64Managed/Plugins.DependencyManager.cs`:

```cs
using NuGet.Common;
using NuGet.Frameworks;
using NuGet.Packaging;
using NuGet.Packaging.Core;
using NuGet.Protocol;
using NuGet.Protocol.Core.Types;
using NuGet.Versioning;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    internal partial class Plugins
    {
        internal class PluginDependencyConsumer
        {
            public PluginInfo PluginInfo
            {
                get;
            }

            public bool HasNext => (_currentNode is null & _head.Next is not null) | _currentNode?.Next is not null;

            public bool HasAny => _head.Next is not null;

            public string Name => _currentNode?.Name ?? throw new NullReferenceException($"The consumer was not initialized with '{nameof(MoveNext)}'");

            public string[] ResolvedDepencies => fullpathDeps.ToArray();

            public bool ResetIterator()
            {
                if (_head.Next is null)
                    return false;
                _currentNode = null;
                return true;
            }

            public bool MoveNext()
            {
                if (!HasNext)
                {
                    if (_head.Next?.Resolved ?? false)
                        _head.Next = null; // The last item was consumed
                    return false;
                }

                if (_currentNode is null)
                {
                    _currentNode = _head.Next;
                    return true;
                }

                if (_currentNode.Resolved) // Detach from list
                {
                    _currentNode.Previous.Next = _currentNode.Next;
                    if (_currentNode.Next is not null)
                        _currentNode.Next.Previous = _currentNode.Previous;
                }
                _currentNode = _currentNode.Next;

                return true;
            }

            public bool Resolve(string libFullPath)
            {
                if (_currentNode == null)
                    throw new NullReferenceException($"The consumer was not initialized with '{nameof(MoveNext)}'");

                if (_currentNode.Resolved || !File.Exists(libFullPath))
                    return false;

                _currentNode.Resolved = true;
                fullpathDeps.Add(libFullPath);
                return true;
            }

            public bool AddRequiredAssemblies(IEnumerable<string> libsFullPath) =>
                AddRequiredAssemblies(libsFullPath.ToArray());

            public bool AddRequiredAssemblies(string[] libsFullPath)
            {
                if (!_currentNode.Resolved || libsFullPath.Any(path => !Path.IsPathFullyQualified(path) || !File.Exists(path)))
                    return false;

                fullpathDeps.AddRange(libsFullPath);
                return true;
            }

            public PluginDependencyConsumer(PluginInfo pluginInfo)
            {
                this.PluginInfo = pluginInfo;

                string[] deps = pluginInfo.Dependencies;
                if (deps is null)
                    return;

                var it = _head;
                foreach (var dep in deps)
                {
                    DependencyNode node = new(dep);
                    node.Previous = it;
                    it.Next = node;
                    it = node;
                }
            }

            private readonly DependencyNode _head = DependencyNode.Null;
            private DependencyNode _currentNode = null;
            private readonly HashSet<string> fullpathDeps = new();

            class DependencyNode : IEquatable<DependencyNode>
            {
                public static DependencyNode Null => new();

                public DependencyNode Next
                {
                    get; set;
                }
                public DependencyNode Previous
                {
                    get; set;
                }
                public bool Resolved { get; set; } = false;

                public int Id { get; } = 0;
                public string Name { get; } = string.Empty;

                public DependencyNode(string name)
                {
                    Name = name;
                    Id = name.GetHashCode();
                }

                private DependencyNode()
                {
                }

                public bool Equals(DependencyNode other) => Id == other.Id;

                public override bool Equals(object obj) => Equals(obj as DependencyNode);

                public override int GetHashCode() => Id;
            }
        }


        /// <summary>
        /// Represents a class that can resolve full paths from dependencies names
        /// </summary>
        internal interface IDependencyResolver
        {
            void ResolveFullpathToDependency(PluginDependencyConsumer dependencyConsumer, CancellationToken token);
        }

        internal class DependencyResolver
        {
            public DependencyResolver()
            {
                pluginDepsCache = new();
            }

            public string[] ResolvePluginDependencies(Plugin plugin, CancellationToken cancellationToken)
            {
                if (plugin.Info.Dependencies is null || plugin.Info!.Dependencies.Length == 0)
                    return Array.Empty<string>();

                if (!HasDependenciesChanged(plugin))
                    return pluginDepsCache[plugin.GetHashCode()].cachedResolvedDependencies;

                PluginDependencyConsumer dependencyConsumer = new(plugin.Info);

                foreach (var resolver in resolvers)
                {
                    resolver.ResolveFullpathToDependency(dependencyConsumer, cancellationToken);
                    if (!dependencyConsumer.HasAny)
                        break; // We don't need to continue, all deps are resolved
                    dependencyConsumer.ResetIterator();
                }

                if (dependencyConsumer.HasAny)
                {
                    // TODO: Create a proper exception for this
                    throw new Exception("The current resolvers where not able to resolve all the dependencies");
                }

                var deps = dependencyConsumer.ResolvedDepencies;
                AddPluginToCache(plugin, deps);
                return deps;
            }

            public void AddResolver(IDependencyResolver dependencyResolver)
            {
                resolvers.Add(dependencyResolver);
            }

            private static int GetDependenciesHash(Plugin plugin)
            {
                int hash = 0;
                foreach (var p in plugin.Info.Dependencies)
                    hash ^= p.GetHashCode();
                return hash;
            }

            private bool HasDependenciesChanged(Plugin plugin)
            {
                int pluginInstanceHash = plugin.GetHashCode();
                int currentDepsHash = GetDependenciesHash(plugin);
                if (!pluginDepsCache.TryGetValue(pluginInstanceHash, out var cache))
                {
                    return true;
                }
                return currentDepsHash != cache.depsHash;
            }

            private void AddPluginToCache(Plugin plugin, string[] resolvedDepencies)
            {
                int pluginInstanceHash = plugin.GetHashCode();
                int currentDepsHash = GetDependenciesHash(plugin);
                pluginDepsCache[pluginInstanceHash] = (currentDepsHash, resolvedDepencies);
            }

            readonly Dictionary<int, (int depsHash, string[] cachedResolvedDependencies)> pluginDepsCache;
            readonly List<IDependencyResolver> resolvers = new();
        }

        /// <summary>
        /// A class that can resolve dependencies via nuget
        /// </summary>
        internal class NuGetDependencyResolver : IDependencyResolver
        {
            static readonly string NugetSource = "https://api.nuget.org/v3/index.json";
            static string LocalNugetRepo => Manager.PluginManager.PluginsPath;

            private readonly NuGet.Common.ILogger Logger;

            private static readonly object _lock = new();
            readonly SourceRepository localRepository;
            readonly SourceRepository globalCache;

            public NuGetDependencyResolver()
            {
                this.localRepository = new SourceRepository(new(LocalNugetRepo), Repository.Provider.GetCoreV3());
                this.globalCache = new SourceRepository(new(GetGlobalPackagesPath()), Repository.Provider.GetCoreV3());
                Logger = new NuGetDependencyResolverLogger(Console.Out);
            }

            public void ResolveFullpathToDependency(PluginDependencyConsumer dependencyConsumer, CancellationToken token)
            {
                while (dependencyConsumer.MoveNext())
                {
                    string name = dependencyConsumer.Name;
                    if (!VersioningHelper.IsValidDotNetFrameworkName(name))
                    {
                        continue; //  We can't resolve this library
                    }

                    string pkgId = name[..name.IndexOf(',')];
                    string pkgVersion = VersioningHelper.GetFrameworkVersion(name);

                    var packageInfo = FindLocalOrDownloadPackage(pkgId, pkgVersion, token);
                    if (packageInfo is null)
                    {
                        Logger.LogError($"Failed to acquire nuget package: {pkgId}");
                        continue;
                    }

                    var executingFramework = VersioningHelper.GetFrameworkFromAssembly(Assembly.GetExecutingAssembly());
                    using var pkgReader = packageInfo.GetReader();
                    var requiredPkg = pkgReader.GetLibItems().GetNearest(executingFramework);
                    var requiredPkgDeps = ResolvePackageDepencies(pkgId, pkgVersion, requiredPkg.TargetFramework, token);

                    dependencyConsumer.Resolve(requiredPkg.Items
                        .Where(item => Path.GetExtension(item).Equals(".dll"))
                        .Select((item) => Path.GetFullPath(Path.Combine(Path.GetDirectoryName(packageInfo.Path), item)))
                        .First()
                    );

                    foreach (var pkgDep in requiredPkgDeps)
                    {
                        using var depPkgReader = pkgDep.GetReader();
                        var libItems = depPkgReader.GetLibItems().GetNearest(requiredPkg.TargetFramework);
                        dependencyConsumer.AddRequiredAssemblies(libItems.Items
                            .Where(item => Path.GetExtension(item).Equals(".dll"))
                            .Select(item => Path.GetFullPath(Path.Combine(Path.GetDirectoryName(pkgDep.Path), item)))
                        );
                    }
                }
            }

            private static string GetOrCreatePackageDirectory(string pkgId, string version)
            {
                string path = System.IO.Path.Combine(LocalNugetRepo, pkgId, version);
                if (!System.IO.Directory.Exists(path))
                    return System.IO.Directory.CreateDirectory(path).FullName;
                return path;
            }

            private static string CreateNuGetArchiveFileName(string pkgId, string version) =>
                string.Format("{0}.{1}", pkgId, version + PackagingCoreConstants.NupkgExtension);

            private static string GetGlobalPackagesPath()
            {
                var settings = NuGet.Configuration.Settings.LoadDefaultSettings(null);
                string globalPkgFolder = NuGet.Configuration.SettingsUtility.GetGlobalPackagesFolder(settings);
                return globalPkgFolder;
            }

            private static bool InitializePackageFolder(string pkgFullName, CancellationToken token)
            {
                var pkgArchiveReader = new NuGet.Packaging.PackageArchiveReader(pkgFullName);

                var copiedFiles = pkgArchiveReader.CopyFiles(
                    Path.GetDirectoryName(pkgFullName),
                    pkgArchiveReader.GetFiles(),
                    new ExtractPackageFileDelegate((pkgFileName, targetFilePath, Stream) =>
                    {
                        var fileInfo = new FileInfo(targetFilePath);
                        fileInfo.Directory!.Create();
                        using var fs = File.Create(fileInfo.FullName);
                        Stream.CopyTo(fs);
                        fs.Close();
                        return targetFilePath;
                    }),
                    NuGet.Common.NullLogger.Instance,
                    token
                );

                if (!copiedFiles.All(filePath => File.Exists(filePath)))
                    return false;

                // NuGetV3 - https://github.com/NuGet/Home/wiki/Nupkg-Metadata-File#solution
                NuGet.Packaging.NupkgMetadataFile nupkgMetadataFile = new()
                {
                    ContentHash = pkgArchiveReader.GetContentHash(token),
                    Version = 2,
                    Source = NugetSource
                };

                //  NuGet package original hash
                string hashFilePath = Path.Combine(
                    Path.GetDirectoryName(pkgFullName),
                    Path.GetFileNameWithoutExtension(pkgFullName) + PackagingCoreConstants.HashFileExtension);
                using var hashFile = File.Create(hashFilePath);

                // Write operations
                try
                {
                    // Metadada
                    NuGet.Packaging.NupkgMetadataFileFormat.Write(
                        System.IO.Path.Combine(
                            System.IO.Path.GetDirectoryName(pkgFullName),
                            PackagingCoreConstants.NupkgMetadataFileExtension),
                        nupkgMetadataFile
                    );

                    // Hash file
                    hashFile.Write(Encoding.UTF8.GetBytes(nupkgMetadataFile.ContentHash));

                }
                catch (IOException)
                {
                    return false;
                }

                return true;
            }

            private static bool IsPackageInitialized(string pkgFullName, CancellationToken token)
            {
                if (!File.Exists(pkgFullName))
                    return false;

                string hashFilePath = Path.Combine(
                    Path.GetDirectoryName(pkgFullName),
                    Path.GetFileNameWithoutExtension(pkgFullName) + PackagingCoreConstants.HashFileExtension);
                if (!File.Exists(hashFilePath))
                    return false;

                string metadataFilePath = Path.Combine(
                           Path.GetDirectoryName(pkgFullName),
                           PackagingCoreConstants.NupkgMetadataFileExtension);
                if (!File.Exists(metadataFilePath))
                    return false;

                var pkgArchiveReader = new PackageArchiveReader(pkgFullName);
                var metadataFile = NupkgMetadataFileFormat.Read(metadataFilePath);

                string hashFileHash = File.OpenText(hashFilePath).ReadToEnd();
                string nupkgHash = pkgArchiveReader.GetContentHash(token);

                return nupkgHash.Equals(hashFileHash, StringComparison.InvariantCultureIgnoreCase) &&
                    nupkgHash.Equals(metadataFile.ContentHash, StringComparison.InvariantCultureIgnoreCase);
            }

            private bool DownloadPackage(string pkgId, string version, System.IO.Stream destStream, CancellationToken token)
            {
                SourceCacheContext cache = new();
                var repo = Repository.Factory.GetCoreV3(NugetSource);

                var resource = repo.GetResource<FindPackageByIdResource>();

                var pkgVersion = new NuGetVersion(version);

                return resource.CopyNupkgToStreamAsync(
                        pkgId,
                        pkgVersion,
                        destStream,
                        cache,
                        Logger,
                        token
                ).GetAwaiter().GetResult();
            }

            private LocalPackageInfo FindPackage(SourceRepository sourceRepository, string pkgId, string version, CancellationToken token)
            {
                var searchLocalResource = sourceRepository.GetResource<FindLocalPackagesResource>();

                var result = searchLocalResource.FindPackagesById(
                        pkgId,
                        Logger,
                        token
                );

                return result.Where(pkg => pkg.Identity.Version.OriginalVersion == version).FirstOrDefault();
            }

            private LocalPackageInfo FindPackageOnLocalRepo(string pkgId, string version, CancellationToken token) =>
                FindPackage(localRepository, pkgId, version, token);

            private LocalPackageInfo FindPackageOnGlobalCache(string pkgId, string version, CancellationToken token) =>
                FindPackage(globalCache, pkgId, version, token);

            private LocalPackageInfo FindLocalOrDownloadPackage(string pkgId, string version, CancellationToken token, bool allowDownload = true)
            {
                LocalPackageInfo localPackageInfo = FindPackageOnGlobalCache(pkgId, version, token);

                if (localPackageInfo == null && allowDownload)
                {
                    string pkgFullName = System.IO.Path.Combine(
                        GetOrCreatePackageDirectory(pkgId, version),
                        CreateNuGetArchiveFileName(pkgId, version));

                    lock (_lock)
                    {
                        if (!File.Exists(pkgFullName))
                        {
                            using var fs = new FileStream(
                                pkgFullName,
                                FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.Read
                            );
                            if (!DownloadPackage(pkgId, version, fs, token))
                                return null;
                        }
                        if (!IsPackageInitialized(pkgFullName, token) && !InitializePackageFolder(pkgFullName, token))
                        {
                            Logger.LogError($"Package '{pkgId}' directory initialization failed!");
                            File.Delete(pkgFullName); // Maybe the nupkg is corrupted?
                        }
                    }
                    localPackageInfo = FindPackageOnLocalRepo(pkgId, version, token);
                }

                return localPackageInfo;
            }

            private List<LocalPackageInfo> ResolvePackageDepencies(string pkgId, string version, NuGet.Frameworks.NuGetFramework framework, CancellationToken token, bool download = true)
            {
                LocalPackageInfo localPackageInfo = FindLocalOrDownloadPackage(pkgId, version, token, download);
                if (localPackageInfo is null)
                    return null;

                var dependencyGroup = localPackageInfo.GetReader().GetPackageDependencies()
                    .Single(depGroup => depGroup.TargetFramework.Equals(framework));

                List<LocalPackageInfo> localPackages = new();

                foreach (var pkg in dependencyGroup.Packages)
                {
                    var depPkg = FindLocalOrDownloadPackage(pkg.Id, pkg.VersionRange.OriginalString, token, download);
                    localPackages.Add(depPkg);
                }

                return localPackages;
            }


            public class VersioningHelper
            {
                private static readonly string FrameworkNamePattern =
                    @"^(?<Name>[a-zA-Z.]+),Version=v(?<Version>(?<Major>[\d]+)\.(?<Minor>[\d]+)(?:\.(?<Build>[\d]+))?)$";

                private readonly static System.Text.RegularExpressions.Regex Regex = new(FrameworkNamePattern);

                public static NuGet.Frameworks.NuGetFramework GetFrameworkFromAssembly(System.Reflection.Assembly assembly)
                {
                    var frameworks = assembly.GetCustomAttributes(true).
                        OfType<System.Runtime.Versioning.TargetFrameworkAttribute>();
                    var framework = frameworks.FirstOrDefault();

                    var match = Regex.Match(framework.FrameworkName);

                    int major = int.Parse(match.Groups["Major"].Value);
                    int minor = int.Parse(match.Groups["Minor"].Value);
                    if (!int.TryParse(match.Groups["Build"]?.Value, out int build))
                        build = 0;

                    return new NuGet.Frameworks.NuGetFramework(
                        match.Groups["Name"].Value,
                        new Version(major, minor, build)
                    );
                }

                public static string GetFrameworkName(string dotNetFrameworkName) =>
                    Regex.Match(dotNetFrameworkName)?.Groups["Name"].Value;

                public static string GetFrameworkVersion(string dotNetFrameworkName) =>
                    Regex.Match(dotNetFrameworkName)?.Groups["Version"].Value;

                public static bool IsValidDotNetFrameworkName(string dotNetFrameworkName) => Regex.IsMatch(dotNetFrameworkName);
            }

            internal class NuGetDependencyResolverLogger : NuGet.Common.LoggerBase
            {
                private readonly TextWriter textWriter;

                public NuGetDependencyResolverLogger(TextWriter textWriter)
                {
                    this.textWriter = textWriter;
                }

                string FormatLog(ILogMessage message) => string.Format(
                        "[{0}] {1}: {2}",
                        message.Level,
                        nameof(NuGetDependencyResolver),
                        message.Message);

                public override void Log(ILogMessage message) => textWriter.WriteLine(FormatLog(message));

                public override Task LogAsync(ILogMessage message) => Task.Run(() => Log(message));
            }
        }

        internal class LocalAssembliesResolver : IDependencyResolver
        {
            public void ResolveFullpathToDependency(PluginDependencyConsumer dependencyConsumer, CancellationToken token)
            {
                while (dependencyConsumer.MoveNext())
                {
                    token.ThrowIfCancellationRequested();

                    string assemblyName = dependencyConsumer.Name;
                    var coreAssemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location);
                    dependencyConsumer.Resolve(Path.Combine(coreAssemblyPath, assemblyName));
                }
            }
        }
    }

    internal static class DependencyResolverExtensions
    {
        public static string[] ResolveDependencies(this Plugin plugin, Plugins.DependencyResolver resolver, CancellationToken token)
        {
            return resolver.ResolvePluginDependencies(plugin, token);
        }

        public static string[] ResolveDependencies(this Plugin plugin, Plugins.DependencyResolver resolver) =>
            plugin.ResolveDependencies(resolver, CancellationToken.None);
    }
}



```

`src/Dotx64Managed/Plugins.Hotload.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    internal partial class Plugins
    {
        internal bool IsSystemType(Type t)
        {
            return false;
        }

        Type GetPluginClass(Assembly assembly)
        {
            var entries = assembly.GetTypes().Where(a => a.GetInterface(nameof(IPlugin)) != null).ToArray();
            if (entries.Length > 1)
            {
                throw new Exception("Assembly has multiple classes with IPlugin, can have only one entry.");
            }
            if (entries.Length == 0)
            {
                throw new Exception("Assembly has no IPlugin class.");
            }
            return entries.First();
        }

        void UnloadPluginInstance(Plugin plugin, CancellationToken token, bool isReloading = false)
        {
            token.ThrowIfCancellationRequested();

            if (plugin.Instance == null)
                return;

            var pluginName = plugin.Info != null ? plugin.Info.Name : plugin.Path;
            Utils.DebugPrintLine($"Unloading plugin: {plugin.Path}");

            if (!isReloading)
            {
                plugin.Instance.Shutdown();
            }

            Commands.RemoveAllFor(plugin);
            Expressions.RemoveAllFor(plugin);
            Menus.RemoveAllFor(plugin);

            Console.WriteLine($"[DotX64Dbg] Unloaded plugin: {pluginName}");
        }

        void RegisterPluginCommand(Plugin plugin, MethodInfo fn, Command cmd, object obj)
        {
            Commands.Handler cb = null;

            var hasArgs = fn.GetParameters().Length > 0;

            if (fn.ReturnType == typeof(void) && hasArgs)
            {
                var cb2 = fn.CreateDelegate<Commands.HandlerVoid>(obj);
                cb = (string[] args) =>
                {
                    cb2(args);
                    return true;
                };
            }
            if (fn.ReturnType == typeof(void) && !hasArgs)
            {
                var cb2 = fn.CreateDelegate<Commands.HandlerVoidNoArgs>(obj);
                cb = (string[] args) =>
                {
                    cb2();
                    return true;
                };
            }
            else if (fn.ReturnType == typeof(bool) && !hasArgs)
            {
                var cb2 = fn.CreateDelegate<Commands.HandlerNoArgs>(obj);
                cb = (string[] args) =>
                {
                    return cb2();
                };
            }
            else if (fn.ReturnType == typeof(bool) && hasArgs)
            {
                cb = fn.CreateDelegate<Commands.Handler>(obj);
            }

            Commands.Register(plugin, cmd.Name, cmd.DebugOnly, cb);
        }

        void RegisterExpression(Plugin plugin, MethodInfo fn, Expression expr, object obj)
        {
            if (fn.ReturnType != typeof(nuint))
            {
                throw new Exception($"Expression functions must return 'nuint', Function: {fn.Name}");
            }

            var args = fn.GetParameters();
            foreach (var arg in args)
            {
                if (arg.ParameterType != typeof(nuint))
                {
                    throw new Exception($"Expression arguments must be 'nuint', Function: {fn.Name}");
                }
            }

            if (args.Length == 0)
            {
                var cb = fn.CreateDelegate<Expressions.ExpressionFunc0>(obj);
                Expressions.Register(plugin, expr.Name, cb);
            }
            else if (args.Length == 1)
            {
                var cb = fn.CreateDelegate<Expressions.ExpressionFunc1>(obj);
                Expressions.Register(plugin, expr.Name, cb);
            }
            else if (args.Length == 2)
            {
                var cb = fn.CreateDelegate<Expressions.ExpressionFunc2>(obj);
                Expressions.Register(plugin, expr.Name, cb);
            }
            else if (args.Length == 3)
            {
                var cb = fn.CreateDelegate<Expressions.ExpressionFunc3>(obj);
                Expressions.Register(plugin, expr.Name, cb);
            }
        }

        void RegisterMenu(Plugin plugin, MethodInfo fn, UI.Menu menu, object obj)
        {
            var cb = fn.CreateDelegate<UI.Menu.MenuDelegate>(obj);

            var menuPath = menu.Path;
            var rootMenu = menu.Parent.ToString();

            Menus.AddMenu(plugin, $"{rootMenu}/{plugin.Info.Name}/{menuPath}", cb);
        }

        void LoadPluginInstanceRecursive(Plugin plugin, object obj, HashSet<object> processed, CancellationToken token)
        {
            token.ThrowIfCancellationRequested();

            if (obj == null)
                return;

            if (obj.GetType().Assembly != plugin.Loader.Current)
                return;

            processed.Add(obj);

            var instType = obj.GetType();
            var funcs = instType.GetRuntimeMethods();

            foreach (var fn in funcs)
            {
                var attribs = fn.GetCustomAttributes();
                foreach (var attrib in attribs)
                {
                    if (attrib is Command cmd)
                    {
                        RegisterPluginCommand(plugin, fn, cmd, obj);
                    }
                    else if (attrib is Expression expr)
                    {
                        RegisterExpression(plugin, fn, expr, obj);
                    }
                    else if (attrib is UI.Menu menu)
                    {
                        RegisterMenu(plugin, fn, menu, obj);
                    }
                }
            }

            var fields = instType.GetRuntimeFields();
            foreach (var field in fields)
            {
                var fieldType = field.FieldType;
                if (IsSystemType(fieldType))
                    continue;

                if (fieldType.IsClass && !fieldType.IsArray)
                {
                    var nextObj = field.GetValue(obj);
                    if (!processed.Contains(nextObj))
                    {
                        LoadPluginInstanceRecursive(plugin, nextObj, processed, token);
                    }
                }
            }

            var props = instType.GetRuntimeProperties();
            foreach (var prop in props)
            {
                var fieldType = prop.PropertyType;
                if (IsSystemType(fieldType))
                    continue;
                if (prop.GetIndexParameters().Count() > 0)
                    continue;

                if (fieldType.IsClass && !fieldType.IsArray)
                {
                    var nextObj = prop.GetValue(obj);
                    if (!processed.Contains(nextObj))
                    {
                        LoadPluginInstanceRecursive(plugin, nextObj, processed, token);
                    }
                }
            }

        }

        void LoadPluginInstance(Plugin plugin, CancellationToken token)
        {
            token.ThrowIfCancellationRequested();

            if (plugin.Instance == null)
                return;

            LoadPluginInstanceRecursive(plugin, plugin.Instance, new(), token);
        }

        bool ReloadPlugin(Plugin plugin, string newAssemblyPath, CancellationToken token)
        {
            token.ThrowIfCancellationRequested();

            var hotReload = Settings.EnableHotloading && plugin.Instance != null;

            Console.WriteLine($"[DotX64Dbg] {(hotReload ? "Reloading" : "Loading")} '{plugin.Info.Name}'");

            try
            {
                UnloadPluginInstance(plugin, token, hotReload);

                var loader = new AssemblyLoader();
                loader.AddExternalRequiredAssemblies(plugin.ResolveDependencies(dependencyResolver, token));
                var newAssembly = loader.LoadFromFile(newAssemblyPath);

                var pluginClass = GetPluginClass(newAssembly);
                if (pluginClass != null)
                {
                    Utils.DebugPrintLine("Entry class: {0}", pluginClass.Name);
                }

                // NOTE: RemapContext stores old references, to fully unload the dll
                // it must be disposed first.
                using (var ctx = new Hotload.Context(plugin.Loader?.Current, newAssembly))
                {
                    var newInstance = ctx.Create(pluginClass);

                    if (hotReload)
                    {
                        Hotload.AdaptStatics(ctx, plugin.Loader.Current, newAssembly);
                        Hotload.AdaptClass(ctx, plugin.Instance, plugin.InstanceType, newInstance, pluginClass);
                    }
                    else
                    {
                        // Initial startup.
                        var ctor = pluginClass.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, Array.Empty<Type>(), null);
                        if (ctor != null)
                        {
                            ctor.Invoke(newInstance, Array.Empty<object>());
                        }

                        var startup = pluginClass.GetMethod("Startup");
                        if (startup != null)
                        {
                            try
                            {
                                startup.Invoke(newInstance, Array.Empty<object>());
                            }
                            catch (Exception ex)
                            {
                                Utils.PrintException(ex);
                            }
                        }
                    }

                    plugin.Instance = newInstance as IPlugin;
                    plugin.InstanceType = pluginClass;

                    if (hotReload)
                    {
                        var reloadables = ctx.GetObjectsWithInterface(typeof(IHotload));
                        foreach (var obj in reloadables)
                        {
                            var reloadable = obj as IHotload;
                            reloadable.OnHotload();
                        }
                    }
                }

                if (plugin.Loader != null)
                {
                    var cur = plugin.Loader;
                    plugin.Loader = null;

                    var oldAssemblyPath = plugin.AssemblyPath;
                    var oldPdbPath = oldAssemblyPath.Replace(".dll", ".pdb");

                    cur.UnloadCurrent();
                    cur = null;

                    for (int i = 0; i < 50; i++)
                    {
                        GC.Collect();
                        GC.WaitForPendingFinalizers();
                    }

                    token.ThrowIfCancellationRequested();

                    Task.Run(async delegate
                    {
                        await Task.Delay(2000);

                        // Remove previous assembly.
                        try
                        {
                            System.IO.File.Delete(oldAssemblyPath);
                        }
                        catch (Exception)
                        {
                            Utils.DebugPrintLine("WARNING: Unable to remove old assembly, ensure no references are stored.");
                        }

                        // Remove previous debug symbols.
                        // NOTE: If the debugger is attached this may be locked.
                        try
                        {
                            System.IO.File.Delete(oldPdbPath);
                        }
                        catch (Exception)
                        {
                            Utils.DebugPrintLine("WARNING: Unable to remove old PDB file, will be removed next start, probably locked by debugger.");
                        }
                    });
                }

                plugin.Loader = loader;
                plugin.AssemblyPath = newAssemblyPath;

                LoadPluginInstance(plugin, token);

                Menus.AddPluginMenu(plugin);
            }
            catch (Exception ex)
            {
                Utils.PrintException(ex);
                return false;
            }

            Console.WriteLine($"[DotX64Dbg] {(hotReload ? "Reloaded" : "Loaded")} '{plugin.Info.Name}'");
            return true;
        }

        public void UnloadPlugin(Plugin plugin, CancellationToken token = default(CancellationToken))
        {
            if (plugin.Instance != null)
            {
                UnloadPluginInstance(plugin, token);
                plugin.Instance = null;
            }

            if (plugin.Loader != null)
            {
                plugin.Loader.UnloadCurrent();
                plugin.Loader = null;
            }

            plugin.RequiresRebuild = false;
        }

    }
}

```

`src/Dotx64Managed/Plugins.Watcher.cs`:

```cs
using System.IO;

namespace Dotx64Dbg
{

    internal class PluginFileInfo
    {
        public string PluginName
        {
            get; set;
        }
        // Absolute path to the plugin folder.
        public string PluginPath
        {
            get; set;
        }
        // The file in question relative to PluginPath.
        public string RelativeFilePath
        {
            get; set;
        }
        // The absolute file path, this is the same as Path.Combine(PluginPath, RelativeFilePath)
        public string FilePath
        {
            get; set;
        }
        // This is set to true if the file/folder in question is PluginPath.
        public bool PluginRootFolder
        {
            get; set;
        }
    }

    internal partial class Plugins
    {
        FileSystemWatcher PluginWatch;

        public void InitializeWatcher()
        {
            PluginWatch = new FileSystemWatcher(PluginsPath, "*.*");
            PluginWatch.NotifyFilter = NotifyFilters.FileName | NotifyFilters.DirectoryName | NotifyFilters.Size | NotifyFilters.LastWrite | NotifyFilters.Attributes;
            PluginWatch.IncludeSubdirectories = true;
            PluginWatch.EnableRaisingEvents = true;
            PluginWatch.Created += OnPluginCreate;
            PluginWatch.Deleted += OnPluginRemove;
            PluginWatch.Renamed += OnPluginRename;
            PluginWatch.Changed += OnPluginChange;
        }

        PluginFileInfo ParseInfo(string path)
        {
            var relativePath = Path.GetRelativePath(PluginsPath, path);
            if (relativePath.Length == 0)
                return null;

            if (relativePath.Contains(Path.DirectorySeparatorChar))
            {
                var pos = relativePath.IndexOf(Path.DirectorySeparatorChar);
                var pluginName = relativePath.Substring(0, pos);
                relativePath = relativePath.Substring(pos + 1);

                return new PluginFileInfo()
                {
                    PluginRootFolder = false,
                    PluginName = pluginName,
                    RelativeFilePath = relativePath,
                    PluginPath = Path.Combine(PluginsPath, pluginName),
                    FilePath = Path.Combine(PluginsPath, pluginName, relativePath),
                };
            }
            else
            {
                return new PluginFileInfo()
                {
                    PluginRootFolder = true,
                    PluginName = relativePath,
                    RelativeFilePath = "",
                    FilePath = Path.Combine(PluginsPath, relativePath),
                    PluginPath = Path.Combine(PluginsPath, relativePath),
                };
            }
        }

        bool IsPathIgnored(string relativePluginPath)
        {
            string[] blockedPaths = { ".vs", "bin", "obj", ".git", ".vscode" };
            foreach (var blockedPath in blockedPaths)
            {
                if (relativePluginPath.Contains(blockedPath))
                    return true;
            }
            return false;
        }

        bool IsExcludedFileOrFolder(string pluginPath, string filePath)
        {
            if (!filePath.EndsWith(".cs"))
                return true;

            string[] excludedFolders = { ".vs" };

            foreach (var folder in excludedFolders)
            {
                var excludedPath = Path.Combine(pluginPath, folder);
                if (filePath.StartsWith(excludedPath))
                    return true;
            }

            return false;
        }

        // FileWatcher Event
        void OnPluginCreate(object sender, FileSystemEventArgs e)
        {
            lock (PluginWatch)
            {
                var info = ParseInfo(e.FullPath);
                if (info == null)
                    return;

                if (IsPathIgnored(info.RelativeFilePath))
                {
                    return;
                }

                if (info.PluginRootFolder)
                {
                    if (Directory.Exists(e.FullPath))
                    {
                        RegisterPlugin(e.FullPath);
                    }
                }
                else
                {
                    var plugin = FindPlugin(info.PluginPath);
                    if (plugin == null)
                    {
                        Utils.DebugPrintLine($"[PluginWatch] Unable to find registered plugin for {info.PluginName}");
                        return;
                    }

                    // File was created.
                    OnPluginFileCreate(plugin, info);
                }
            }
        }

        void OnPluginFileCreate(Plugin plugin, PluginFileInfo info)
        {
            if (info.RelativeFilePath == "plugin.json")
            {
                LoadPlugin(plugin);
            }
            else
            {
                if (IsExcludedFileOrFolder(info.PluginPath, info.FilePath))
                    return;

                if (!plugin.SourceFiles.Contains(info.FilePath))
                {
                    Utils.DebugPrintLine($"[PluginWatch] Plugin File Create: {info.FilePath}");

                    plugin.SourceFiles.Add(info.FilePath);

                    RebuildOrUnloadPlugin(plugin);
                }
            }
        }

        // FileWatcher Event
        void OnPluginRemove(object sender, FileSystemEventArgs e)
        {
            lock (PluginWatch)
            {
                var info = ParseInfo(e.FullPath);
                if (info == null)
                    return;

                if (IsPathIgnored(info.RelativeFilePath))
                {
                    return;
                }

                var plugin = FindPlugin(info.PluginPath);
                if (plugin == null)
                {
                    Utils.DebugPrintLine($"[PluginWatch] Unable to find registered plugin for {info.PluginName}");
                    return;
                }

                if (info.PluginRootFolder)
                {
                    RemovePlugin(plugin);
                }
                else
                {
                    OnPluginFileRemove(plugin, info);
                }
            }
        }

        void OnPluginFileRemove(Plugin plugin, PluginFileInfo info)
        {
            if (plugin.ConfigPath == info.FilePath)
            {
                Utils.DebugPrintLine("[PluginWatch] plugin.json got removed, unloading plugin");

                plugin.Info = null;
                UnloadPlugin(plugin);
            }
            else
            {
                if (plugin.SourceFiles.Remove(info.FilePath))
                {
                    Utils.DebugPrintLine($"[PluginWatch] Plugin File Remove: {info.FilePath}");

                    RebuildOrUnloadPlugin(plugin);
                }
            }
        }

        // FileWatcher Event
        void OnPluginRename(object sender, RenamedEventArgs e)
        {
            lock (PluginWatch)
            {
                // Use old path first to identify the current plugin.
                var info = ParseInfo(e.OldFullPath);
                if (info == null)
                    return;

                if (IsPathIgnored(info.RelativeFilePath))
                {
                    return;
                }

                var plugin = FindPlugin(info.PluginPath);
                if (plugin == null)
                {
                    Utils.DebugPrintLine($"[PluginWatch] Unable to find registered plugin for {info.PluginName}");
                    return;
                }

                if (info.PluginRootFolder)
                {
                    RemovePlugin(plugin);
                    RegisterPlugin(e.FullPath);
                }
                else
                {
                    // If its not the root folder use the new full path.
                    info = ParseInfo(e.FullPath);
                    if (info == null)
                        return;

                    plugin = FindPlugin(info.PluginPath);
                    if (plugin == null)
                    {
                        Utils.DebugPrintLine($"[PluginWatch] Unable to find registered plugin for {info.PluginName}");
                        return;
                    }

                    OnPluginFileRename(plugin, info, e.OldFullPath);
                }
            }
        }

        void OnPluginFileRename(Plugin plugin, PluginFileInfo info, string oldFullPath)
        {
            if (plugin.ConfigPath == oldFullPath)
            {
                UnloadPlugin(plugin);
                plugin.Info = null;
            }
            else if (plugin.ConfigPath == info.FilePath)
            {
                LoadPlugin(plugin);
            }
            else
            {
                var isSourceRemoved = plugin.SourceFiles.Remove(oldFullPath);
                var isExcluded = IsExcludedFileOrFolder(info.PluginPath, info.FilePath);
                var isAdded = false;

                if (!isExcluded)
                {
                    if (!plugin.SourceFiles.Contains(info.FilePath))
                    {
                        plugin.SourceFiles.Add(info.FilePath);
                        isAdded = true;
                    }
                }

                // Work-around for issue #66
                // VS temporarily renames source files, don't unload as the next event is another rename.
                var allowUnload = true;
                if (isSourceRemoved && info.FilePath.ToLower().EndsWith(".tmp"))
                {
                    allowUnload = false;
                }

                if (isSourceRemoved || isAdded)
                {
                    Utils.DebugPrintLine($"[PluginWatch] Plugin File Rename: {oldFullPath} -> {info.FilePath}");

                    RebuildOrUnloadPlugin(plugin, allowUnload);
                }
            }
        }

        // FileWatcher Event
        void OnPluginChange(object sender, FileSystemEventArgs e)
        {
            lock (PluginWatch)
            {
                var info = ParseInfo(e.FullPath);
                if (info == null)
                    return;

                if (IsPathIgnored(info.RelativeFilePath))
                {
                    return;
                }

                if (!info.PluginRootFolder)
                {
                    var plugin = FindPlugin(info.PluginPath);
                    if (plugin == null)
                    {
                        Utils.DebugPrintLine($"[PluginWatch] Unable to find registered plugin for {info.PluginName}");
                        return;
                    }

                    OnPluginFileChange(plugin, info);
                }
            }
        }

        void OnPluginFileChange(Plugin plugin, PluginFileInfo info)
        {
            if (plugin.ConfigPath == info.FilePath)
            {
                Utils.DebugPrintLine("[PluginWatch] Plugin info modified, reloading meta...");
                var oldInfo = plugin.Info;

                var pluginInfo = GetPluginInfo(info.FilePath);
                if (pluginInfo == null)
                {
                    Utils.DebugPrintLine("Unable to read plugin meta");
                }

                plugin.Info = pluginInfo;

                var requiresRebuild = false;
                var dependeniesChanged = false;
                if (oldInfo == null && pluginInfo != null)
                {
                    // No info previously
                    requiresRebuild = true;
                    dependeniesChanged = true;
                }
                else if (oldInfo != null && pluginInfo != null)
                {
                    dependeniesChanged = CheckDependeniesChanged(oldInfo.Dependencies, pluginInfo.Dependencies);
                    if (dependeniesChanged)
                    {
                        Utils.DebugPrintLine("Dependencies changed");
                        requiresRebuild = true;
                    }
                }

                // The json drives the project settings.
                if (dependeniesChanged)
                {
                    // Also generate new project, currently doesn't deal with nuget references.
                    GenerateProject(plugin);
                }

                if (requiresRebuild)
                {
                    RebuildOrUnloadPlugin(plugin);
                }
            }
            else
            {
                if (plugin.SourceFiles.Contains(info.FilePath))
                {
                    Utils.DebugPrintLine($"[PluginWatch] Plugin Change: {info.FilePath}");

                    RebuildOrUnloadPlugin(plugin);
                }
            }
        }

    }
}

```

`src/Dotx64Managed/Plugins.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;

namespace Dotx64Dbg
{
    internal class PluginInfo
    {
        public string Name
        {
            get; set;
        }
        public string Description
        {
            get; set;
        }
        public string Version
        {
            get; set;
        }
        public string Author
        {
            get; set;
        }
        public string Website
        {
            get; set;
        }

        public string[] Dependencies
        {
            get; set;
        }
    }

    internal class Plugin
    {
        public PluginInfo Info;
        public string Path;
        public string ConfigPath;
        public string BuildOutputPath;
        public List<string> SourceFiles;
        public bool RequiresRebuild;
        internal AssemblyLoader Loader;
        internal string AssemblyPath;
        internal IPlugin Instance;
        internal Type InstanceType;

        public string ProjectFilePath
        {
            get
            {
                if (Info == null)
                    return null;
                return System.IO.Path.Combine(Path, Info.Name + ".csproj");
            }
        }

        public string SolutionFilePath
        {
            get
            {
                if (Info == null)
                    return null;
                return System.IO.Path.Combine(Path, Info.Name + ".sln");
            }
        }

        public string Name => Info?.Name;
    }

    internal partial class Plugins
    {
        string PluginsPath = "dotplugins";
        string AppDataPath;
        string PluginOutputPath;

        DependencyResolver dependencyResolver;

        List<Plugin> Registered = new();

        private void SetupDirectories()
        {
            PluginsPath = Settings.PluginsPath;
            if (!Directory.Exists(PluginsPath))
            {
                try
                {
                    Directory.CreateDirectory(PluginsPath);
                }
                catch (Exception)
                {
                    Console.WriteLine("[DotX64Dbg] Unable to create directory for plugins: {0}", PluginsPath);
                }
            }

            Console.WriteLine("[DotX64Dbg] Plugins Path: {0}", PluginsPath);

            AppDataPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "DotX64Dbg");
#if _X64_
            PluginOutputPath = Path.Combine(AppDataPath, "x64");
#else
            PluginOutputPath = Path.Combine(AppDataPath, "x86");
#endif
            PluginOutputPath = Path.Combine(PluginOutputPath, "Plugins");
            if (!Directory.Exists(PluginOutputPath))
            {
                Directory.CreateDirectory(PluginOutputPath);
            }
        }

        public void Initialize()
        {
            SetupDirectories();
            InitializeWatcher();

            dependencyResolver = new();
            dependencyResolver.AddResolver(new NuGetDependencyResolver());
            dependencyResolver.AddResolver(new LocalAssembliesResolver());

            SkipRebuilding = true;
            RegisterPlugins();
            GenerateProjects();
            StartBuildWorker();

            SkipRebuilding = false;
            TriggerRebuild();
        }

        public void Shutdown()
        {
            StopBuildWorker();
            foreach (var plugin in Registered)
            {
                UnloadPlugin(plugin);
            }
        }

        void RegisterPlugins()
        {
            var dirs = new List<string>(Directory.EnumerateDirectories(PluginsPath));
            foreach (var dir in dirs)
            {
                RegisterPlugin(dir);
            }
        }

        static Guid SeededGuid(int seed)
        {
            var random = new Random(seed);
            return Guid.Parse(string.Format("{0:X4}{1:X4}-{2:X4}-{3:X4}-{4:X4}-{5:X4}{6:X4}{7:X4}",
                random.Next(0, 0xffff), random.Next(0, 0xffff),
                random.Next(0, 0xffff),
                random.Next(0, 0xffff) | 0x4000,
                random.Next(0, 0x3fff) | 0x8000,
                random.Next(0, 0xffff), random.Next(0, 0xffff), random.Next(0, 0xffff)));
        }

        static uint FNV1a(string str)
        {
            uint hash = 0x811C9DC5;
            foreach (var ch in Encoding.UTF8.GetBytes(str))
            {
                hash ^= (byte)ch;
                hash *= 0x1000193;
            }
            return hash;
        }

        public static void GenerateProject(Plugin plugin)
        {
            var binaryPathX86 = Path.Combine(Utils.GetRootPath(), "x86", "plugins", "Dotx64Dbg");
            var binaryPathX64 = Path.Combine(Utils.GetRootPath(), "x64", "plugins", "Dotx64Dbg");
            var assemblies = new string[] {
                "Dotx64DbgBindings.dll", "Dotx64DbgManaged.dll"
            };

            if (plugin.Info == null)
                return;

            var projectFilePath = plugin.ProjectFilePath;
            Console.WriteLine($"[DotX64Dbg] Generating project for {plugin.Info.Name}");

            var projGen = new ProjectGenerator();
            projGen.ReferencePathX86 = binaryPathX86;
            projGen.ReferencePathX64 = binaryPathX64;
            projGen.References = assemblies;
            if (plugin.Info.Dependencies is not null)
            {
                projGen.Frameworks = plugin.Info.Dependencies
                    .Where(deps => NuGetDependencyResolver.VersioningHelper.IsValidDotNetFrameworkName(deps))
                    .Select(deps => new NuGet.Frameworks.NuGetFramework(
                            NuGetDependencyResolver.VersioningHelper.GetFrameworkName(deps),
                            new Version(NuGetDependencyResolver.VersioningHelper.GetFrameworkVersion(deps)))
                    ).ToArray();
            }

            projGen.Save(projectFilePath);

            var guid = SeededGuid((int)FNV1a(plugin.Info.Name)).ToString().ToUpper();
            var solutionText = $@"
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32929.385
MinimumVisualStudioVersion = 10.0.40219.1
Project(""{{9A19103F-16F7-4668-BE54-9A1E7A4F7556}}"") = ""{plugin.Info.Name}"", ""{plugin.Info.Name}.csproj"", ""{{{guid}}}""
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{{{guid}}}.Release|x64.ActiveCfg = Release|x64
		{{{guid}}}.Release|x64.Build.0 = Release|x64
		{{{guid}}}.Release|x86.ActiveCfg = Release|x86
		{{{guid}}}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {{8BF78ACB-FDCE-407F-89A6-C8FE26E643E6}}
	EndGlobalSection
EndGlobal
".ReplaceLineEndings();

            var solutionFilePath = plugin.SolutionFilePath;
            if (File.Exists(solutionFilePath))
            {
                // Do not recreate the solution if it's already up to date
                var existingText = File.ReadAllText(solutionFilePath, Encoding.UTF8);
                if (existingText != solutionText)
                {
                    File.WriteAllText(solutionFilePath, solutionText, Encoding.UTF8);
                }
            }
            else
            {
                File.WriteAllText(solutionFilePath, solutionText, Encoding.UTF8);
            }
        }

        void GenerateProjects()
        {
            foreach (var plugin in Registered)
            {
                GenerateProject(plugin);
            }
        }

        List<string> EnumerateSourceFiles(string pluginPath)
        {
            return Directory.EnumerateFiles(pluginPath, "*.cs", new EnumerationOptions()
            {
                RecurseSubdirectories = true,
            }).Where(file => !IsExcludedFileOrFolder(pluginPath, file)).ToList();
        }

        PluginInfo GetPluginInfo(string jsonFile)
        {
            try
            {
                var jsonString = Utils.ReadFileContents(jsonFile);
                var pluginInfo = JsonSerializer.Deserialize<PluginInfo>(jsonString);

                var res = JsonSerializer.Deserialize<PluginInfo>(jsonString);
                if (res.Dependencies == null)
                {
                    // Ensure this is never null.
                    res.Dependencies = Array.Empty<string>();
                }

                // Ensure no duplicates exist.
                res.Dependencies = res.Dependencies.Distinct().ToArray();

                // This list has to be sorted to avoid rebuilds when only the order changes.
                Array.Sort(res.Dependencies);

                return res;
            }
            catch (System.Exception)
            {
                return null;
            }
        }

        void RegisterPlugin(string path)
        {
            var jsonFile = Path.Combine(path, "plugin.json");
            var pluginInfo = GetPluginInfo(jsonFile);
            if(pluginInfo == null)
            {
                Console.WriteLine($"[DotX64Dbg] Unable to load plugin info: {jsonFile}");
                return;
            }

            var pathName = Path.GetFileName(path);
            var plugin = new Plugin()
            {
                Info = pluginInfo,
                Path = path,
                ConfigPath = jsonFile,
                RequiresRebuild = false,
                BuildOutputPath = Path.Combine(PluginOutputPath, pathName),
                SourceFiles = EnumerateSourceFiles(path),
            };

            if (!Directory.Exists(plugin.BuildOutputPath))
            {
                Directory.CreateDirectory(plugin.BuildOutputPath);
            }

            Registered.Add(plugin);
            Utils.DebugPrintLine($"Registered new plugin: {plugin.Path}");

            if (plugin.Info != null)
            {
                LoadPlugin(plugin);
            }
        }

        void RemovePlugin(Plugin plugin)
        {
            Utils.DebugPrintLine($"Removing plugin: {plugin.Path}");

            UnloadPlugin(plugin);

            for (var i = 0; i < Registered.Count; ++i)
            {
                if (Registered[i].Path == plugin.Path)
                {
                    Registered.RemoveAt(i);
                    break;
                }
            }
        }

        void LoadPlugin(Plugin plugin)
        {
            var pluginInfo = GetPluginInfo(plugin.ConfigPath);
            if (pluginInfo == null)
            {
                Utils.DebugPrintLine($"[{plugin.Name}] Unable to load plugin info.");
                return;
            }

            Utils.DebugPrintLine($"[{plugin.Name}] Plugin meta loaded, activating plugin.");
            plugin.Info = pluginInfo;

            if (!File.Exists(plugin.ProjectFilePath))
            {
                GenerateProject(plugin);
            }

            plugin.RequiresRebuild = true;
            TriggerRebuild();
        }

        Plugin FindPlugin(string path)
        {
            foreach (var plugin in Registered)
            {
                if (plugin.Path == path)
                {
                    return plugin;
                }
            }
            return null;
        }

        void RebuildOrUnloadPlugin(Plugin plugin, bool unloadWithoutSources = true)
        {
            if (unloadWithoutSources)
            {
                if (plugin.Instance != null && plugin.SourceFiles.Count == 0)
                {
                    Utils.DebugPrintLine($"[PluginWatch] Plugin {plugin.Name} has no sources, unloading.");
                    UnloadPlugin(plugin);
                    return;
                }
            }

            plugin.RequiresRebuild = true;
            TriggerRebuild();
        }

        bool CheckDependeniesChanged(string[] left, string[] right)
        {
            if (left.Length != right.Length)
                return true;

            if (Enumerable.SequenceEqual(left, right))
                return false;

            return true;
        }

        public List<IPlugin> GetPluginInstances()
        {
            // If we are currently rebuilding we have to wait.
            WaitForRebuild();

            return Registered
                .Select(x => x.Instance as IPlugin)
                .Where(x => x != null)
                .ToList();
        }

        internal bool IsPluginNameTaken(string pluginName)
        {
            var path = Path.Combine(Settings.PluginsPath, pluginName);
            if (Directory.Exists(path))
            {
                return true;
            }
            return false;
        }

        public string CreatePluginTemplate(string pluginName)
        {
            var pluginPath = Path.Combine(Settings.PluginsPath, pluginName);
            if (Directory.Exists(pluginPath))
            {
                return null;
            }

            var pluginJsonPath = Path.Combine(pluginPath, "plugin.json");
            var pluginCsPath = Path.Combine(pluginPath, "plugin.cs");

            // Search and replace keywords in templates.
            var replacements = new Dictionary<string, string> {
                { "%PLUGIN_NAME%", pluginName }
            };

            if (!Utils.CreateDir(pluginPath))
            {
                // ERROR.
                return null;
            }


            if (!Utils.WriteReplacedContents(Resources.GetString("Template/plugin.json"), replacements, pluginJsonPath))
            {
                // ERROR.
                return null;
            }

            if (!Utils.WriteReplacedContents(Resources.GetString("Template/plugin.cs"), replacements, pluginCsPath))
            {
                // ERROR.
                return null;
            }

            return pluginPath;
        }
    }
}

```

`src/Dotx64Managed/ProjectGenerator.cs`:

```cs
using System;
using System.IO;
using System.Xml;

namespace Dotx64Dbg
{
    class ProjectGenerator
    {
        public string Sdk = "Microsoft.NET.Sdk";

        public string TargetFramework = "net6.0";

        public string Platforms = "x64;x86";

        public string[] References = Array.Empty<string>();

        public NuGet.Frameworks.NuGetFramework[] Frameworks = Array.Empty<NuGet.Frameworks.NuGetFramework>();

        public string ReferencePathX86;

        public string ReferencePathX64;

        public bool Save(string file)
        {
            try
            {
                XmlDocument doc = new();

                var nodeProject = doc.CreateElement("Project");
                doc.AppendChild(nodeProject);

                // PropertyGroup
                {
                    var nodePropsGroup = doc.CreateElement("PropertyGroup");
                    nodeProject.AppendChild(nodePropsGroup);

                    void AppendTextNode(string name, string innerText)
                    {
                        var node = doc.CreateElement(name);
                        node.InnerText = innerText;
                        nodePropsGroup.AppendChild(node);
                    }

                    AppendTextNode("BaseIntermediateOutputPath", @".vs\obj");
                    AppendTextNode("MSBUildProjectExtensionsPath", @".vs\obj");
                    AppendTextNode("MSBuildWarningsAsMessages", "$(MSBuildWarningsAsMessages);MSB3277");
                    AppendTextNode("Configurations", "Release");
                }

                // Import SDK
                {
                    var nodeImport = doc.CreateElement("Import");
                    nodeImport.SetAttribute("Project", "Sdk.props");
                    nodeImport.SetAttribute("Sdk", Sdk);
                    nodeProject.AppendChild(nodeImport);
                }

                // PropertyGroup
                {
                    var nodePropsGroup = doc.CreateElement("PropertyGroup");
                    nodeProject.AppendChild(nodePropsGroup);

                    // TargetFrameWork
                    var nodeTargetFramework = doc.CreateElement("TargetFramework");
                    nodeTargetFramework.InnerText = TargetFramework;
                    nodePropsGroup.AppendChild(nodeTargetFramework);

                    // Platforms
                    var nodePlatforms = doc.CreateElement("Platforms");
                    nodePlatforms.InnerText = Platforms;
                    nodePropsGroup.AppendChild(nodePlatforms);

                    // AppendTargetFrameworkToOutputPath
                    var nodeAppendTargetFrameworkToOutputPath = doc.CreateElement("AppendTargetFrameworkToOutputPath");
                    nodeAppendTargetFrameworkToOutputPath.InnerText = "false";
                    nodePropsGroup.AppendChild(nodeAppendTargetFrameworkToOutputPath);

                    // AppendRuntimeIdentifierToOutputPath
                    var nodeAppendRuntimeIdentifierToOutputPath = doc.CreateElement("AppendRuntimeIdentifierToOutputPath");
                    nodeAppendRuntimeIdentifierToOutputPath.InnerText = "false";
                    nodePropsGroup.AppendChild(nodeAppendRuntimeIdentifierToOutputPath);

                    // BaseOutputPath
                    var nodeBaseOutputPath = doc.CreateElement("BaseOutputPath");
                    nodeBaseOutputPath.InnerText = ".vs\\bin";
                    nodePropsGroup.AppendChild(nodeBaseOutputPath);

                    // UseCommonOutputDirectory
                    var nodeUseCommonOutputDirectory = doc.CreateElement("UseCommonOutputDirectory");
                    nodeUseCommonOutputDirectory.InnerText = "false";
                    nodePropsGroup.AppendChild(nodeUseCommonOutputDirectory);
                }

                // X86 References
                {
                    var nodeItemGroup = doc.CreateElement("ItemGroup");
                    nodeItemGroup.SetAttribute("Condition", "'$(PlatformName)' == 'x86'");

                    foreach (var fileRef in References)
                    {
                        var nodeRef = doc.CreateElement("Reference");
                        var refPath = Path.Combine(ReferencePathX86, fileRef);
                        nodeRef.SetAttribute("Include", refPath);

                        nodeItemGroup.AppendChild(nodeRef);
                    }

                    nodeProject.AppendChild(nodeItemGroup);
                }

                // X64 References
                {
                    var nodeItemGroup = doc.CreateElement("ItemGroup");
                    nodeItemGroup.SetAttribute("Condition", "'$(PlatformName)' == 'x64'");

                    foreach (var fileRef in References)
                    {
                        var nodeRef = doc.CreateElement("Reference");
                        var refPath = Path.Combine(ReferencePathX64, fileRef);
                        nodeRef.SetAttribute("Include", refPath);

                        nodeItemGroup.AppendChild(nodeRef);
                    }

                    nodeProject.AppendChild(nodeItemGroup);
                }

                // Packages References
                {
                    var nodePkgRefs = doc.CreateElement("ItemGroup");
                    foreach (var pkg in Frameworks)
                    {
                        var nodeRef = doc.CreateElement("PackageReference");
                        nodeRef.SetAttribute("Include", pkg.Framework);
                        nodeRef.SetAttribute("Version", pkg.Version.ToString(3));

                        nodePkgRefs.AppendChild(nodeRef);
                    }

                    nodeProject.AppendChild(nodePkgRefs);
                }

                // Import targets
                {
                    var nodeImport = doc.CreateElement("Import");
                    nodeImport.SetAttribute("Project", "Sdk.targets");
                    nodeImport.SetAttribute("Sdk", Sdk);
                    nodeProject.AppendChild(nodeImport);
                }

                // Override build target
                {
                    var nodeTarget = doc.CreateElement("Target");
                    nodeTarget.SetAttribute("Name", "PostBuildWarn");
                    nodeTarget.SetAttribute("AfterTargets", "PostBuildEvent");

                    nodeProject.AppendChild(nodeTarget);

                    var nodeMsg = doc.CreateElement("Message");
                    nodeMsg.SetAttribute("Text", "NOTE: Building the project is not required, Dotx64Dbg will automatically build and reload on source code changes.");
                    nodeMsg.SetAttribute("Importance", "High");

                    nodeTarget.AppendChild(nodeMsg);
                }

                // Only write a new project file if the contents have changed
                using (var sw = new StringWriter())
                {
                    doc.Save(sw);
                    var text = sw.ToString();
                    if (File.Exists(file))
                    {
                        var existingText = File.ReadAllText(file);
                        if (text != existingText)
                        {
                            File.WriteAllText(file, text);
                        }
                    }
                    else
                    {
                        File.WriteAllText(file, text);
                    }
                }
            }
            catch (Exception ex)
            {
                Utils.PrintException(ex);
                return false;
            }

            return true;
        }
    }
}

```

`src/Dotx64Managed/Resources.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Dotx64Dbg
{
    class Resources
    {
        private static Dictionary<string, byte[]> _resources = new Dictionary<string, byte[]>();

        static Resources()
        {
            var pluginPath = Utils.GetPluginPath();
            var resourcesPath = Path.Combine(pluginPath, "Resources");

            // Check if directory exists
            if (!Directory.Exists(resourcesPath))
            {
                Console.Error.WriteLine($"Resources directory not found: {resourcesPath}");
                return;
            }

            var files = Directory.EnumerateFiles(resourcesPath, "*.*", SearchOption.AllDirectories);
            foreach (var file in files)
            {
                var name = file.Substring(resourcesPath.Length + 1);
                name = name.Replace('\\', '/');
                _resources[name] = File.ReadAllBytes(file);
            }

            Utils.DebugPrintLine($"Loaded {_resources.Count} resources");
        }

        public static byte[] GetData(string name)
        {
            name = name.Replace('\\', '/');
            if (_resources.TryGetValue(name, out var data))
                return data;

            Utils.DebugPrintLine($"Resource not found: {name}");
            return null;
        }

        public static string GetString(string name)
        {
            name = name.Replace('\\', '/');
            var data = GetData(name);
            if (data == null)
                return null;

            return System.Text.Encoding.UTF8.GetString(data);
        }
    }
}

```

`src/Dotx64Managed/ScriptLoader.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    internal class ScriptLoader
    {
        static string ScriptBuildOutputPath;
        static Task ActiveScript;

        private static bool RunScriptCommand(string[] args)
        {
            if (args.Length != 2)
            {
                Console.WriteLine("[DotX64Dbg] ERROR: Missing argument <file>");
                return false;
            }

            return ExecuteScriptFile(args[1]);
        }

        private static void SetupDirectories()
        {
            string AppDataPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "DotX64Dbg");
#if _X64_
            ScriptBuildOutputPath = Path.Combine(AppDataPath, "x64");
#else
            ScriptBuildOutputPath = Path.Combine(AppDataPath, "x86");
#endif
            ScriptBuildOutputPath = Path.Combine(ScriptBuildOutputPath, "Scripts");
            if (!Directory.Exists(ScriptBuildOutputPath))
            {
                Directory.CreateDirectory(ScriptBuildOutputPath);
            }
        }

        public static void Initialize()
        {
            SetupDirectories();
            Commands.Register(null, "dotscript", false, RunScriptCommand);
        }

        private static Type GetScriptClass(Assembly assembly)
        {
            // Auto-generated class from Roslyn.
            var entries = assembly.GetTypes().Where(a => a.Name == "Script").ToArray();
            if (entries.Length == 0)
            {
                throw new Exception("Assembly has no Script entry.");
            }
            return entries.First();
        }

        public static bool ExecuteScriptAssembly(Compiler.Result data)
        {
            // Make sure the stream positions are at 0.
            data.AssemblyStream.Position = 0;
            data.DebugStream.Position = 0;

            var loader = new AssemblyLoader();
            var newAssembly = loader.LoadFromStream(data.AssemblyStream, data.DebugStream);

            var scriptClass = GetScriptClass(newAssembly);
            if (scriptClass != null)
            {
                Utils.DebugPrintLine($"Entry class: {scriptClass.Name}");
            }

            // Auto-generated method from Roslyn.
            var entry = scriptClass.GetMethod("<Main>", BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic);
            if (entry == null)
            {
                Console.WriteLine("[DotX64Dbg] No entrypoint defined");
                return false;
            }

            Utils.DebugPrintLine($"Entrypoint: {entry}");

            ActiveScript = Task.Run(delegate ()
            {
                try
                {
                    entry.Invoke(null, new object[0]);
                }
                catch (Exception ex)
                {
                    Utils.PrintException(ex);
                }

                ActiveScript = null;

                GC.Collect();
            });

            return false;
        }

        public static bool ExecuteScriptFile(string file)
        {
            var scriptName = Path.GetFileNameWithoutExtension(file);

            var stopwatch = new Stopwatch();

            Console.WriteLine("[DotX64Dbg] Building script '{0}'...", file);
            stopwatch.Start();

            var compiler = new Compiler(scriptName);

            var res = compiler.Compile(new string[] { file }, true);
            stopwatch.Stop();

            if (!res.Success)
            {
                Console.WriteLine("[DotX64Dbg] Build failed");
            }
            else
            {
                Console.WriteLine("[DotX64Dbg] Compiled script '{0}' in {1} ms", file, stopwatch.ElapsedMilliseconds);
                ExecuteScriptAssembly(res);
            }

            return true;
        }

        public static bool ExecuteCode(string code)
        {
            var compiler = new Compiler("script");

            Console.WriteLine($"> {code}");

            var res = compiler.Compile(code);
            if (!res.Success)
            {
                return false;
            }

            return ExecuteScriptAssembly(res);
        }

    }
}

```

`src/Dotx64Managed/Scripting/Scripting.Register.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    internal class BadRegisterAccess : Exception
    {
        internal BadRegisterAccess(string message)
            : base(message)
        {
        }
    }

    public static partial class Scripting
    {
        internal static Thread GetThread()
        {
            var active = Thread.Active;

            if (active == null)
                throw new BadRegisterAccess("Register access requires an active thread");

            return active;
        }

        public static byte Al { get => GetThread().Al; set => GetThread().Al = value; }
        public static byte Cl { get => GetThread().Cl; set => GetThread().Cl = value; }
        public static byte Dl { get => GetThread().Dl; set => GetThread().Dl = value; }
        public static byte Bl { get => GetThread().Bl; set => GetThread().Bl = value; }
        public static byte Ah { get => GetThread().Ah; set => GetThread().Ah = value; }
        public static byte Ch { get => GetThread().Ch; set => GetThread().Ch = value; }
        public static byte Dh { get => GetThread().Dh; set => GetThread().Dh = value; }
        public static byte Bh { get => GetThread().Bh; set => GetThread().Bh = value; }
        public static byte Spl { get => GetThread().Spl; set => GetThread().Spl = value; }
        public static byte Bpl { get => GetThread().Bpl; set => GetThread().Bpl = value; }
        public static byte Sil { get => GetThread().Sil; set => GetThread().Sil = value; }
        public static byte Dil { get => GetThread().Dil; set => GetThread().Dil = value; }
#if _X64_
        public static byte R8b { get => GetThread().R8b; set => GetThread().R8b = value; }
        public static byte R9b { get => GetThread().R9b; set => GetThread().R9b = value; }
        public static byte R10b { get => GetThread().R10b; set => GetThread().R10b = value; }
        public static byte R11b { get => GetThread().R11b; set => GetThread().R11b = value; }
        public static byte R12b { get => GetThread().R12b; set => GetThread().R12b = value; }
        public static byte R13b { get => GetThread().R13b; set => GetThread().R13b = value; }
        public static byte R14b { get => GetThread().R14b; set => GetThread().R14b = value; }
        public static byte R15b { get => GetThread().R15b; set => GetThread().R15b = value; }
#endif
        public static ushort Ax { get => GetThread().Ax; set => GetThread().Ax = value; }
        public static ushort Cx { get => GetThread().Cx; set => GetThread().Cx = value; }
        public static ushort Dx { get => GetThread().Dx; set => GetThread().Dx = value; }
        public static ushort Bx { get => GetThread().Bx; set => GetThread().Bx = value; }
        public static ushort Sp { get => GetThread().Sp; set => GetThread().Sp = value; }
        public static ushort Bp { get => GetThread().Bp; set => GetThread().Bp = value; }
        public static ushort Si { get => GetThread().Si; set => GetThread().Si = value; }
        public static ushort Di { get => GetThread().Di; set => GetThread().Di = value; }
#if _X64_
        public static ushort R8w { get => GetThread().R8w; set => GetThread().R8w = value; }
        public static ushort R9w { get => GetThread().R9w; set => GetThread().R9w = value; }
        public static ushort R10w { get => GetThread().R10w; set => GetThread().R10w = value; }
        public static ushort R11w { get => GetThread().R11w; set => GetThread().R11w = value; }
        public static ushort R12w { get => GetThread().R12w; set => GetThread().R12w = value; }
        public static ushort R13w { get => GetThread().R13w; set => GetThread().R13w = value; }
        public static ushort R14w { get => GetThread().R14w; set => GetThread().R14w = value; }
        public static ushort R15w { get => GetThread().R15w; set => GetThread().R15w = value; }
#endif

#if _X64_
        public static uint Eax { get => GetThread().Eax; set => GetThread().Eax = value; }
        public static uint Ecx { get => GetThread().Ecx; set => GetThread().Ecx = value; }
        public static uint Edx { get => GetThread().Edx; set => GetThread().Edx = value; }
        public static uint Ebx { get => GetThread().Ebx; set => GetThread().Ebx = value; }
        public static uint Esp { get => GetThread().Esp; set => GetThread().Esp = value; }
        public static uint Ebp { get => GetThread().Ebp; set => GetThread().Ebp = value; }
        public static uint Esi { get => GetThread().Esi; set => GetThread().Esi = value; }
        public static uint Edi { get => GetThread().Edi; set => GetThread().Edi = value; }

        public static uint R8d { get => GetThread().R8d; set => GetThread().R8d = value; }
        public static uint R9d { get => GetThread().R9d; set => GetThread().R9d = value; }
        public static uint R10d { get => GetThread().R10d; set => GetThread().R10d = value; }
        public static uint R11d { get => GetThread().R11d; set => GetThread().R11d = value; }
        public static uint R12d { get => GetThread().R12d; set => GetThread().R12d = value; }
        public static uint R13d { get => GetThread().R13d; set => GetThread().R13d = value; }
        public static uint R14d { get => GetThread().R14d; set => GetThread().R14d = value; }
        public static uint R15d { get => GetThread().R15d; set => GetThread().R15d = value; }
        public static nuint Rax { get => GetThread().Rax; set => GetThread().Rax = value; }
        public static nuint Rcx { get => GetThread().Rcx; set => GetThread().Rcx = value; }
        public static nuint Rdx { get => GetThread().Rdx; set => GetThread().Rdx = value; }
        public static nuint Rbx { get => GetThread().Rbx; set => GetThread().Rbx = value; }
        public static nuint Rsp { get => GetThread().Rsp; set => GetThread().Rsp = value; }
        public static nuint Rbp { get => GetThread().Rbp; set => GetThread().Rbp = value; }
        public static nuint Rsi { get => GetThread().Rsi; set => GetThread().Rsi = value; }
        public static nuint Rdi { get => GetThread().Rdi; set => GetThread().Rdi = value; }
        public static nuint R8 { get => GetThread().R8; set => GetThread().R8 = value; }
        public static nuint R9 { get => GetThread().R9; set => GetThread().R9 = value; }
        public static nuint R10 { get => GetThread().R10; set => GetThread().R10 = value; }
        public static nuint R11 { get => GetThread().R11; set => GetThread().R11 = value; }
        public static nuint R12 { get => GetThread().R12; set => GetThread().R12 = value; }
        public static nuint R13 { get => GetThread().R13; set => GetThread().R13 = value; }
        public static nuint R14 { get => GetThread().R14; set => GetThread().R14 = value; }
        public static nuint R15 { get => GetThread().R15; set => GetThread().R15 = value; }
#else
        public static nuint Eax { get => GetThread().Eax; set => GetThread().Eax = value; }
        public static nuint Ecx { get => GetThread().Ecx; set => GetThread().Ecx = value; }
        public static nuint Edx { get => GetThread().Edx; set => GetThread().Edx = value; }
        public static nuint Ebx { get => GetThread().Ebx; set => GetThread().Ebx = value; }
        public static nuint Esp { get => GetThread().Esp; set => GetThread().Esp = value; }
        public static nuint Ebp { get => GetThread().Ebp; set => GetThread().Ebp = value; }
        public static nuint Esi { get => GetThread().Esi; set => GetThread().Esi = value; }
        public static nuint Edi { get => GetThread().Edi; set => GetThread().Edi = value; }
#endif
        public static BigInteger St0 { get => GetThread().St0; set => GetThread().St0 = value; }
        public static BigInteger St1 { get => GetThread().St1; set => GetThread().St1 = value; }
        public static BigInteger St2 { get => GetThread().St2; set => GetThread().St2 = value; }
        public static BigInteger St3 { get => GetThread().St3; set => GetThread().St3 = value; }
        public static BigInteger St4 { get => GetThread().St4; set => GetThread().St4 = value; }
        public static BigInteger St5 { get => GetThread().St5; set => GetThread().St5 = value; }
        public static BigInteger St6 { get => GetThread().St6; set => GetThread().St6 = value; }
        public static BigInteger St7 { get => GetThread().St7; set => GetThread().St7 = value; }
        public static BigInteger X87Control { get => GetThread().X87Control; set => GetThread().X87Control = value; }
        public static BigInteger X87Status { get => GetThread().X87Status; set => GetThread().X87Status = value; }
        public static BigInteger X87Tag { get => GetThread().X87Tag; set => GetThread().X87Tag = value; }
        public static BigInteger Mm0 { get => GetThread().Mm0; set => GetThread().Mm0 = value; }
        public static BigInteger Mm1 { get => GetThread().Mm1; set => GetThread().Mm1 = value; }
        public static BigInteger Mm2 { get => GetThread().Mm2; set => GetThread().Mm2 = value; }
        public static BigInteger Mm3 { get => GetThread().Mm3; set => GetThread().Mm3 = value; }
        public static BigInteger Mm4 { get => GetThread().Mm4; set => GetThread().Mm4 = value; }
        public static BigInteger Mm5 { get => GetThread().Mm5; set => GetThread().Mm5 = value; }
        public static BigInteger Mm6 { get => GetThread().Mm6; set => GetThread().Mm6 = value; }
        public static BigInteger Mm7 { get => GetThread().Mm7; set => GetThread().Mm7 = value; }
        public static BigInteger Xmm0 { get => GetThread().Xmm0; set => GetThread().Xmm0 = value; }
        public static BigInteger Xmm1 { get => GetThread().Xmm1; set => GetThread().Xmm1 = value; }
        public static BigInteger Xmm2 { get => GetThread().Xmm2; set => GetThread().Xmm2 = value; }
        public static BigInteger Xmm3 { get => GetThread().Xmm3; set => GetThread().Xmm3 = value; }
        public static BigInteger Xmm4 { get => GetThread().Xmm4; set => GetThread().Xmm4 = value; }
        public static BigInteger Xmm5 { get => GetThread().Xmm5; set => GetThread().Xmm5 = value; }
        public static BigInteger Xmm6 { get => GetThread().Xmm6; set => GetThread().Xmm6 = value; }
        public static BigInteger Xmm7 { get => GetThread().Xmm7; set => GetThread().Xmm7 = value; }
        public static BigInteger Xmm8 { get => GetThread().Xmm8; set => GetThread().Xmm8 = value; }
        public static BigInteger Xmm9 { get => GetThread().Xmm9; set => GetThread().Xmm9 = value; }
        public static BigInteger Xmm10 { get => GetThread().Xmm10; set => GetThread().Xmm10 = value; }
        public static BigInteger Xmm11 { get => GetThread().Xmm11; set => GetThread().Xmm11 = value; }
        public static BigInteger Xmm12 { get => GetThread().Xmm12; set => GetThread().Xmm12 = value; }
        public static BigInteger Xmm13 { get => GetThread().Xmm13; set => GetThread().Xmm13 = value; }
        public static BigInteger Xmm14 { get => GetThread().Xmm14; set => GetThread().Xmm14 = value; }
        public static BigInteger Xmm15 { get => GetThread().Xmm15; set => GetThread().Xmm15 = value; }
        public static BigInteger Xmm16 { get => GetThread().Xmm16; set => GetThread().Xmm16 = value; }
        public static BigInteger Xmm17 { get => GetThread().Xmm17; set => GetThread().Xmm17 = value; }
        public static BigInteger Xmm18 { get => GetThread().Xmm18; set => GetThread().Xmm18 = value; }
        public static BigInteger Xmm19 { get => GetThread().Xmm19; set => GetThread().Xmm19 = value; }
        public static BigInteger Xmm20 { get => GetThread().Xmm20; set => GetThread().Xmm20 = value; }
        public static BigInteger Xmm21 { get => GetThread().Xmm21; set => GetThread().Xmm21 = value; }
        public static BigInteger Xmm22 { get => GetThread().Xmm22; set => GetThread().Xmm22 = value; }
        public static BigInteger Xmm23 { get => GetThread().Xmm23; set => GetThread().Xmm23 = value; }
        public static BigInteger Xmm24 { get => GetThread().Xmm24; set => GetThread().Xmm24 = value; }
        public static BigInteger Xmm25 { get => GetThread().Xmm25; set => GetThread().Xmm25 = value; }
        public static BigInteger Xmm26 { get => GetThread().Xmm26; set => GetThread().Xmm26 = value; }
        public static BigInteger Xmm27 { get => GetThread().Xmm27; set => GetThread().Xmm27 = value; }
        public static BigInteger Xmm28 { get => GetThread().Xmm28; set => GetThread().Xmm28 = value; }
        public static BigInteger Xmm29 { get => GetThread().Xmm29; set => GetThread().Xmm29 = value; }
        public static BigInteger Xmm30 { get => GetThread().Xmm30; set => GetThread().Xmm30 = value; }
        public static BigInteger Xmm31 { get => GetThread().Xmm31; set => GetThread().Xmm31 = value; }
        public static BigInteger Ymm0 { get => GetThread().Ymm0; set => GetThread().Ymm0 = value; }
        public static BigInteger Ymm1 { get => GetThread().Ymm1; set => GetThread().Ymm1 = value; }
        public static BigInteger Ymm2 { get => GetThread().Ymm2; set => GetThread().Ymm2 = value; }
        public static BigInteger Ymm3 { get => GetThread().Ymm3; set => GetThread().Ymm3 = value; }
        public static BigInteger Ymm4 { get => GetThread().Ymm4; set => GetThread().Ymm4 = value; }
        public static BigInteger Ymm5 { get => GetThread().Ymm5; set => GetThread().Ymm5 = value; }
        public static BigInteger Ymm6 { get => GetThread().Ymm6; set => GetThread().Ymm6 = value; }
        public static BigInteger Ymm7 { get => GetThread().Ymm7; set => GetThread().Ymm7 = value; }
        public static BigInteger Ymm8 { get => GetThread().Ymm8; set => GetThread().Ymm8 = value; }
        public static BigInteger Ymm9 { get => GetThread().Ymm9; set => GetThread().Ymm9 = value; }
        public static BigInteger Ymm10 { get => GetThread().Ymm10; set => GetThread().Ymm10 = value; }
        public static BigInteger Ymm11 { get => GetThread().Ymm11; set => GetThread().Ymm11 = value; }
        public static BigInteger Ymm12 { get => GetThread().Ymm12; set => GetThread().Ymm12 = value; }
        public static BigInteger Ymm13 { get => GetThread().Ymm13; set => GetThread().Ymm13 = value; }
        public static BigInteger Ymm14 { get => GetThread().Ymm14; set => GetThread().Ymm14 = value; }
        public static BigInteger Ymm15 { get => GetThread().Ymm15; set => GetThread().Ymm15 = value; }
        public static BigInteger Ymm16 { get => GetThread().Ymm16; set => GetThread().Ymm16 = value; }
        public static BigInteger Ymm17 { get => GetThread().Ymm17; set => GetThread().Ymm17 = value; }
        public static BigInteger Ymm18 { get => GetThread().Ymm18; set => GetThread().Ymm18 = value; }
        public static BigInteger Ymm19 { get => GetThread().Ymm19; set => GetThread().Ymm19 = value; }
        public static BigInteger Ymm20 { get => GetThread().Ymm20; set => GetThread().Ymm20 = value; }
        public static BigInteger Ymm21 { get => GetThread().Ymm21; set => GetThread().Ymm21 = value; }
        public static BigInteger Ymm22 { get => GetThread().Ymm22; set => GetThread().Ymm22 = value; }
        public static BigInteger Ymm23 { get => GetThread().Ymm23; set => GetThread().Ymm23 = value; }
        public static BigInteger Ymm24 { get => GetThread().Ymm24; set => GetThread().Ymm24 = value; }
        public static BigInteger Ymm25 { get => GetThread().Ymm25; set => GetThread().Ymm25 = value; }
        public static BigInteger Ymm26 { get => GetThread().Ymm26; set => GetThread().Ymm26 = value; }
        public static BigInteger Ymm27 { get => GetThread().Ymm27; set => GetThread().Ymm27 = value; }
        public static BigInteger Ymm28 { get => GetThread().Ymm28; set => GetThread().Ymm28 = value; }
        public static BigInteger Ymm29 { get => GetThread().Ymm29; set => GetThread().Ymm29 = value; }
        public static BigInteger Ymm30 { get => GetThread().Ymm30; set => GetThread().Ymm30 = value; }
        public static BigInteger Ymm31 { get => GetThread().Ymm31; set => GetThread().Ymm31 = value; }
        public static BigInteger Zmm0 { get => GetThread().Zmm0; set => GetThread().Zmm0 = value; }
        public static BigInteger Zmm1 { get => GetThread().Zmm1; set => GetThread().Zmm1 = value; }
        public static BigInteger Zmm2 { get => GetThread().Zmm2; set => GetThread().Zmm2 = value; }
        public static BigInteger Zmm3 { get => GetThread().Zmm3; set => GetThread().Zmm3 = value; }
        public static BigInteger Zmm4 { get => GetThread().Zmm4; set => GetThread().Zmm4 = value; }
        public static BigInteger Zmm5 { get => GetThread().Zmm5; set => GetThread().Zmm5 = value; }
        public static BigInteger Zmm6 { get => GetThread().Zmm6; set => GetThread().Zmm6 = value; }
        public static BigInteger Zmm7 { get => GetThread().Zmm7; set => GetThread().Zmm7 = value; }
        public static BigInteger Zmm8 { get => GetThread().Zmm8; set => GetThread().Zmm8 = value; }
        public static BigInteger Zmm9 { get => GetThread().Zmm9; set => GetThread().Zmm9 = value; }
        public static BigInteger Zmm10 { get => GetThread().Zmm10; set => GetThread().Zmm10 = value; }
        public static BigInteger Zmm11 { get => GetThread().Zmm11; set => GetThread().Zmm11 = value; }
        public static BigInteger Zmm12 { get => GetThread().Zmm12; set => GetThread().Zmm12 = value; }
        public static BigInteger Zmm13 { get => GetThread().Zmm13; set => GetThread().Zmm13 = value; }
        public static BigInteger Zmm14 { get => GetThread().Zmm14; set => GetThread().Zmm14 = value; }
        public static BigInteger Zmm15 { get => GetThread().Zmm15; set => GetThread().Zmm15 = value; }
        public static BigInteger Zmm16 { get => GetThread().Zmm16; set => GetThread().Zmm16 = value; }
        public static BigInteger Zmm17 { get => GetThread().Zmm17; set => GetThread().Zmm17 = value; }
        public static BigInteger Zmm18 { get => GetThread().Zmm18; set => GetThread().Zmm18 = value; }
        public static BigInteger Zmm19 { get => GetThread().Zmm19; set => GetThread().Zmm19 = value; }
        public static BigInteger Zmm20 { get => GetThread().Zmm20; set => GetThread().Zmm20 = value; }
        public static BigInteger Zmm21 { get => GetThread().Zmm21; set => GetThread().Zmm21 = value; }
        public static BigInteger Zmm22 { get => GetThread().Zmm22; set => GetThread().Zmm22 = value; }
        public static BigInteger Zmm23 { get => GetThread().Zmm23; set => GetThread().Zmm23 = value; }
        public static BigInteger Zmm24 { get => GetThread().Zmm24; set => GetThread().Zmm24 = value; }
        public static BigInteger Zmm25 { get => GetThread().Zmm25; set => GetThread().Zmm25 = value; }
        public static BigInteger Zmm26 { get => GetThread().Zmm26; set => GetThread().Zmm26 = value; }
        public static BigInteger Zmm27 { get => GetThread().Zmm27; set => GetThread().Zmm27 = value; }
        public static BigInteger Zmm28 { get => GetThread().Zmm28; set => GetThread().Zmm28 = value; }
        public static BigInteger Zmm29 { get => GetThread().Zmm29; set => GetThread().Zmm29 = value; }
        public static BigInteger Zmm30 { get => GetThread().Zmm30; set => GetThread().Zmm30 = value; }
        public static BigInteger Zmm31 { get => GetThread().Zmm31; set => GetThread().Zmm31 = value; }
        public static BigInteger Flags { get => GetThread().Flags; set => GetThread().Flags = value; }
#if _X64_
        public static uint EFlags { get => GetThread().EFlags; set => GetThread().EFlags = value; }
        public static nuint RFlags { get => GetThread().RFlags; set => GetThread().RFlags = value; }
#else
        public static nuint EFlags { get => GetThread().EFlags; set => GetThread().EFlags = value; }
#endif
        public static ushort Ip { get => GetThread().Ip; set => GetThread().Ip = value; }

#if _X64_
        public static uint Eip { get => GetThread().Eip; set => GetThread().Eip = value; }
        public static nuint Rip { get => GetThread().Rip; set => GetThread().Rip = value; }
#else
        public static nuint Eip { get => GetThread().Eip; set => GetThread().Eip = value; }
#endif

        public static ushort Es { get => GetThread().Es; set => GetThread().Es = value; }
        public static ushort Cs { get => GetThread().Cs; set => GetThread().Cs = value; }
        public static ushort Ss { get => GetThread().Ss; set => GetThread().Ss = value; }
        public static ushort Ds { get => GetThread().Ds; set => GetThread().Ds = value; }
        public static ushort Fs { get => GetThread().Fs; set => GetThread().Fs = value; }
        public static ushort Gs { get => GetThread().Gs; set => GetThread().Gs = value; }
        public static BigInteger Gdtr { get => GetThread().Gdtr; set => GetThread().Gdtr = value; }
        public static BigInteger Ldtr { get => GetThread().Ldtr; set => GetThread().Ldtr = value; }
        public static BigInteger Idtr { get => GetThread().Idtr; set => GetThread().Idtr = value; }
        public static BigInteger Tr { get => GetThread().Tr; set => GetThread().Tr = value; }
        public static BigInteger Tr0 { get => GetThread().Tr0; set => GetThread().Tr0 = value; }
        public static BigInteger Tr1 { get => GetThread().Tr1; set => GetThread().Tr1 = value; }
        public static BigInteger Tr2 { get => GetThread().Tr2; set => GetThread().Tr2 = value; }
        public static BigInteger Tr3 { get => GetThread().Tr3; set => GetThread().Tr3 = value; }
        public static BigInteger Tr4 { get => GetThread().Tr4; set => GetThread().Tr4 = value; }
        public static BigInteger Tr5 { get => GetThread().Tr5; set => GetThread().Tr5 = value; }
        public static BigInteger Tr6 { get => GetThread().Tr6; set => GetThread().Tr6 = value; }
        public static BigInteger Tr7 { get => GetThread().Tr7; set => GetThread().Tr7 = value; }
        public static BigInteger Cr0 { get => GetThread().Cr0; set => GetThread().Cr0 = value; }
        public static BigInteger Cr1 { get => GetThread().Cr1; set => GetThread().Cr1 = value; }
        public static BigInteger Cr2 { get => GetThread().Cr2; set => GetThread().Cr2 = value; }
        public static BigInteger Cr3 { get => GetThread().Cr3; set => GetThread().Cr3 = value; }
        public static BigInteger Cr4 { get => GetThread().Cr4; set => GetThread().Cr4 = value; }
        public static BigInteger Cr5 { get => GetThread().Cr5; set => GetThread().Cr5 = value; }
        public static BigInteger Cr6 { get => GetThread().Cr6; set => GetThread().Cr6 = value; }
        public static BigInteger Cr7 { get => GetThread().Cr7; set => GetThread().Cr7 = value; }
        public static BigInteger Cr8 { get => GetThread().Cr8; set => GetThread().Cr8 = value; }
        public static BigInteger Cr9 { get => GetThread().Cr9; set => GetThread().Cr9 = value; }
        public static BigInteger Cr10 { get => GetThread().Cr10; set => GetThread().Cr10 = value; }
        public static BigInteger Cr11 { get => GetThread().Cr11; set => GetThread().Cr11 = value; }
        public static BigInteger Cr12 { get => GetThread().Cr12; set => GetThread().Cr12 = value; }
        public static BigInteger Cr13 { get => GetThread().Cr13; set => GetThread().Cr13 = value; }
        public static BigInteger Cr14 { get => GetThread().Cr14; set => GetThread().Cr14 = value; }
        public static BigInteger Cr15 { get => GetThread().Cr15; set => GetThread().Cr15 = value; }

        public static nuint Dr0 { get => GetThread().Dr0; set => GetThread().Dr0 = value; }
        public static nuint Dr1 { get => GetThread().Dr1; set => GetThread().Dr1 = value; }
        public static nuint Dr2 { get => GetThread().Dr2; set => GetThread().Dr2 = value; }
        public static nuint Dr3 { get => GetThread().Dr3; set => GetThread().Dr3 = value; }
        public static nuint Dr4 { get => GetThread().Dr4; set => GetThread().Dr4 = value; }
        public static nuint Dr5 { get => GetThread().Dr5; set => GetThread().Dr5 = value; }
        public static nuint Dr6 { get => GetThread().Dr6; set => GetThread().Dr6 = value; }
        public static nuint Dr7 { get => GetThread().Dr7; set => GetThread().Dr7 = value; }
        public static nuint Dr8 { get => GetThread().Dr8; set => GetThread().Dr8 = value; }
        public static nuint Dr9 { get => GetThread().Dr9; set => GetThread().Dr9 = value; }
        public static nuint Dr10 { get => GetThread().Dr10; set => GetThread().Dr10 = value; }
        public static nuint Dr11 { get => GetThread().Dr11; set => GetThread().Dr11 = value; }
        public static nuint Dr12 { get => GetThread().Dr12; set => GetThread().Dr12 = value; }
        public static nuint Dr13 { get => GetThread().Dr13; set => GetThread().Dr13 = value; }
        public static nuint Dr14 { get => GetThread().Dr14; set => GetThread().Dr14 = value; }
        public static nuint Dr15 { get => GetThread().Dr15; set => GetThread().Dr15 = value; }

        public static BigInteger K0 { get => GetThread().K0; set => GetThread().K0 = value; }
        public static BigInteger K1 { get => GetThread().K1; set => GetThread().K1 = value; }
        public static BigInteger K2 { get => GetThread().K2; set => GetThread().K2 = value; }
        public static BigInteger K3 { get => GetThread().K3; set => GetThread().K3 = value; }
        public static BigInteger K4 { get => GetThread().K4; set => GetThread().K4 = value; }
        public static BigInteger K5 { get => GetThread().K5; set => GetThread().K5 = value; }
        public static BigInteger K6 { get => GetThread().K6; set => GetThread().K6 = value; }
        public static BigInteger K7 { get => GetThread().K7; set => GetThread().K7 = value; }
        public static BigInteger Bnd0 { get => GetThread().Bnd0; set => GetThread().Bnd0 = value; }
        public static BigInteger Bnd1 { get => GetThread().Bnd1; set => GetThread().Bnd1 = value; }
        public static BigInteger Bnd2 { get => GetThread().Bnd2; set => GetThread().Bnd2 = value; }
        public static BigInteger Bnd3 { get => GetThread().Bnd3; set => GetThread().Bnd3 = value; }
        public static BigInteger BndCfg { get => GetThread().BndCfg; set => GetThread().BndCfg = value; }
        public static BigInteger BndStatus { get => GetThread().BndStatus; set => GetThread().BndStatus = value; }
        public static BigInteger Mxcsr { get => GetThread().Mxcsr; set => GetThread().Mxcsr = value; }
        public static BigInteger Pkru { get => GetThread().Pkru; set => GetThread().Pkru = value; }
        public static BigInteger Xcr0 { get => GetThread().Xcr0; set => GetThread().Xcr0 = value; }

        // Host Specific
#if _X64_
        public static nuint Nax { get => GetThread().Rax; set => GetThread().Rax = value; }
        public static nuint Ncx { get => GetThread().Rcx; set => GetThread().Rcx = value; }
        public static nuint Ndx { get => GetThread().Rdx; set => GetThread().Rdx = value; }
        public static nuint Nbx { get => GetThread().Rbx; set => GetThread().Rbx = value; }
        public static nuint Nsp { get => GetThread().Rsp; set => GetThread().Rsp = value; }
        public static nuint Nbp { get => GetThread().Rbp; set => GetThread().Rbp = value; }
        public static nuint Nsi { get => GetThread().Rsi; set => GetThread().Rsi = value; }
        public static nuint Ndi { get => GetThread().Rdi; set => GetThread().Rdi = value; }
        public static nuint Nip { get => GetThread().Rip; set => GetThread().Rip = value; }
#else 
        public static nuint Nax { get => GetThread().Eax; set => GetThread().Eax = value; }
        public static nuint Ncx { get => GetThread().Ecx; set => GetThread().Ecx = value; }
        public static nuint Ndx { get => GetThread().Edx; set => GetThread().Edx = value; }
        public static nuint Nbx { get => GetThread().Ebx; set => GetThread().Ebx = value; }
        public static nuint Nsp { get => GetThread().Esp; set => GetThread().Esp = value; }
        public static nuint Nbp { get => GetThread().Ebp; set => GetThread().Ebp = value; }
        public static nuint Nsi { get => GetThread().Esi; set => GetThread().Esi = value; }
        public static nuint Ndi { get => GetThread().Edi; set => GetThread().Edi = value; }
        public static nuint Nip { get => GetThread().Eip; set => GetThread().Eip = value; }
#endif
    }
}

```

`src/Dotx64Managed/Scripting/Scripting.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Dotx64Dbg
{
    /// <summary>
    /// Wrapper to simplify the scripting environment.
    /// </summary>
    public static partial class Scripting
    {
        public static void Print(string line)
        {
            Console.WriteLine(line);
        }
        public static void Print(string fmt, params object[] args)
        {
            Console.WriteLine(fmt, args);
        }

        public static void Sti()
        {
            Debugger.StepIn();
        }

        public static void Sti(int steps)
        {
            for (int i = 0; i < steps; i++)
                Sti();
        }

        public static void Sto()
        {
            Debugger.StepOver();
        }

        public static void Sto(int steps)
        {
            for (int i = 0; i < steps; i++)
                Sto();
        }

        public static void Run()
        {
            Debugger.Run();
        }

        public static void Pause()
        {
            Debugger.Pause();
        }

        public static void Stop()
        {
            Debugger.Stop();
        }

        public static void Skip(int numInstructions = 1)
        {
            Debugger.RunCommand($"skip {numInstructions}");
        }
    }
}

```

`src/Dotx64Managed/Settings.cs`:

```cs
using System;
using System.IO;
using System.Text.Json;

namespace Dotx64Dbg
{
    class SettingsData
    {
        public string PluginsPath
        {
            get; set;
        }
        public bool EnableTests
        {
            get; set;
        } = false;
        public bool EnableHotloading
        {
            get; set;
        } = false;
    }

    static class Settings
    {
        private static SettingsData Data = new();

        public static string PluginsPath
        {
            get => Data.PluginsPath;
        }

        public static bool EnableTests
        {
            get => Data.EnableTests;
        }

        public static bool EnableHotloading
        {
            get => Data.EnableHotloading;
        }

        static void LoadDefaults()
        {
            Data.PluginsPath = "dotplugins";
            Data.EnableTests = false;
            Data.EnableHotloading = false;
        }

        public static bool Load(string file)
        {
            try
            {
                var fileData = System.IO.File.ReadAllText(file);
                Data = JsonSerializer.Deserialize<SettingsData>(fileData);

                if (!Path.IsPathFullyQualified(PluginsPath))
                {
                    Data.PluginsPath = Path.GetFullPath(Path.Combine(Utils.GetRootPath(), PluginsPath));
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[DotX64Dbg] Exception while loading settings, using defaults.\n{ex}");
                LoadDefaults();
                return false;
            }
            return true;
        }
    }
}

```

`src/Dotx64Managed/Template/plugin.cs`:

```cs
using System;
using Dotx64Dbg;

public partial class MyPlugin : IPlugin, IHotload
{
    /// <summary>
    /// Called as soon the plugin is first loaded, consequent hot-loads will not call this again.
    /// </summary>
    public MyPlugin()
    {
        Console.WriteLine("Hello World");
    }

    /// <summary>
    /// This is called after construction. This is also only called once.
    /// </summary>
    public void Startup()
    {
    }

    /// <summary>
    /// Classes that  have IHotload can implement this to get a notification for whenever
    /// the plugin was hot-loaded due to changes. This is not called for the startup.
    /// </summary>
    public void OnHotload()
    {
    }

    /// <summary>
    /// This is called right before the plugin is about to be shutdown.
    /// </summary>
    public void Shutdown()
    {
    }
}

```

`src/Dotx64Managed/Template/plugin.json`:

```json
{
  "Name": "%PLUGIN_NAME%",
  "Description": "",
  "Version": "0.0.0",
  "Author": "",
  "Website": ""
}

```

`src/Dotx64Managed/Tests.cs`:

```cs
using System;
using System.Reflection;

namespace Dotx64Dbg
{
    partial class Tests
    {
        public void Run()
        {
            // Run all test functions within this class.
            var type = this.GetType();

            var methods = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);
            foreach (var method in methods)
            {
                if (!method.Name.StartsWith("Test"))
                    continue;

                method.Invoke(this, Array.Empty<object>());
            }
        }
    }
}

```

`src/Dotx64Managed/Utils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;

namespace Dotx64Dbg
{
    public static class Utils
    {
        public static UInt32 VersionHash = 0x00000000;

        public static UInt32 GetVersionHash()
        {
            if (VersionHash != 0)
                return VersionHash;

            // Get the hash of the executing assembly
            var assembly = System.Reflection.Assembly.GetExecutingAssembly();
            var assemblyPath = assembly.Location;
            var fileData = File.ReadAllBytes(assemblyPath);

            // Create a simple hash of all the bytes in the assembly.
            UInt32 hash = UInt32.MaxValue;
            foreach (var b in fileData)
            {
                // Rotate and xor.
                hash = (hash << 1) | (hash >> 31);
                hash ^= b;
            }

            VersionHash = hash;
            return VersionHash;
        }

        public static string GetRootPath()
        {
            var process = System.Diagnostics.Process.GetCurrentProcess();
            string fullPath = process.MainModule.FileName;
            string processPath = Path.GetDirectoryName(fullPath);
            string x64DbgPath = Path.GetFullPath(Path.Combine(processPath, ".."));
            return x64DbgPath;
        }

        // Returns the path to the folder of where this x64dbg plugin is located.
        public static string GetPluginPath()
        {
            // Get the current assembly path
            var fullPath = System.Reflection.Assembly.GetExecutingAssembly().Location;
            return Path.GetDirectoryName(fullPath);
        }

        public static string DotX64DbgNugetDepsPath => GetPluginPath();

        public static void PrintFields(object obj)
        {
            var typeInfo = obj.GetType();
            var typeName = typeInfo.Name;

            Console.WriteLine($"{typeName} = {{");

            var typeData = typeInfo.GetFields();
            foreach (var field in typeData)
            {
                Console.WriteLine("  .{0} = {1}", field.Name, field.GetValue(obj));
            }

            Console.WriteLine("}");
        }

        internal static string GetExceptionMessage(Exception ex)
        {
            return ex.ToString();
        }

        internal static void PrintException(Exception ex)
        {
            ex = ex.InnerException ?? ex;
            Console.WriteLine($"[DotX64Dbg] Exception: {GetExceptionMessage(ex)}");
        }

        internal static string ReadFileContents(string path, int retryAttempts = 5, int retryTime = 100)
        {
            string res = null;
            for (int i = 0; i < retryAttempts; i++)
            {
                try
                {
                    using (var fs = File.OpenText(path))
                    {
                        res = fs.ReadToEnd();
                        break;
                    }
                }
                catch (Exception)
                {
                    System.Threading.Thread.Sleep(retryTime);
                    continue;
                }
            }
            return res;
        }

        [Conditional("DEBUG")]
        internal static void DebugPrintLine(string fmt, params object[] args)
        {
            DebugPrintLine(string.Format(fmt, args));
        }

        [Conditional("DEBUG")]
        internal static void DebugPrintLine(string line)
        {
            Console.WriteLine($"[DotX64Dbg][DEBUG] {line}");
        }

        /// <summary>
        /// Replaces the contents of inputText with replacements before writing to targetFile.
        /// </summary>
        internal static bool WriteReplacedContents(string inputText, Dictionary<string, string> replacements, string targetFile)
        {
            try
            {
                foreach (var kv in replacements)
                {
                    inputText = inputText.Replace(kv.Key, kv.Value);
                }
                
                File.WriteAllText(targetFile, inputText, new UTF8Encoding(false));
            }
            catch (Exception)
            {
                return false;
            }
            return true;
        }

        internal static bool CreateDir(string path)
        {
            try
            {
                System.IO.Directory.CreateDirectory(path);
            }
            catch (Exception)
            {
                return false;
            }
            return true;
        }
    }
}

```

`src/Resources/Template/plugin.cs`:

```cs
using System;
using Dotx64Dbg;

public partial class MyPlugin : IPlugin, IHotload
{
    /// <summary>
    /// Called as soon the plugin is first loaded, consequent hot-loads will not call this again.
    /// </summary>
    public MyPlugin()
    {
        Console.WriteLine("Hello World");
    }

    /// <summary>
    /// This is called after construction. This is also only called once.
    /// </summary>
    public void Startup()
    {
    }

    /// <summary>
    /// Classes that  have IHotload can implement this to get a notification for whenever
    /// the plugin was hot-loaded due to changes. This is not called for the startup.
    /// </summary>
    public void OnHotload()
    {
    }

    /// <summary>
    /// This is called right before the plugin is about to be shutdown.
    /// </summary>
    public void Shutdown()
    {
    }
}

```

`src/Resources/Template/plugin.json`:

```json
{
  "Name": "%PLUGIN_NAME%",
  "Description": "",
  "Version": "0.0.0",
  "Author": "",
  "Website": ""
}

```

`thirdparty/CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

# Create a configure-time dependency on cmake.toml to improve IDE support
if(CMKR_ROOT_PROJECT)
	configure_file(cmake.toml cmake.toml COPYONLY)
endif()

# Options
option(ASMJIT_STATIC "" ON)
option(ASMJIT_TEST "" OFF)
option(ZYDIS_BUILD_EXAMPLES "" OFF)
option(ZYDIS_BUILD_TOOLS "" OFF)
option(ZYDIS_BUILD_SHARED_LIB "" OFF)
option(ZYDIS_BUILD_DOXYGEN "" OFF)

include(FetchContent)

# Fix warnings about DOWNLOAD_EXTRACT_TIMESTAMP
if(POLICY CMP0135)
	cmake_policy(SET CMP0135 NEW)
endif()
message(STATUS "Fetching Zydis (53dd088062c734e7882b3a77ff287bdf3356d977)...")
FetchContent_Declare(Zydis SYSTEM
	GIT_REPOSITORY
		"https://github.com/zyantific/zydis"
	GIT_TAG
		53dd088062c734e7882b3a77ff287bdf3356d977
)
FetchContent_MakeAvailable(Zydis)

message(STATUS "Fetching asmjit (0c03ed2f7497441ac0de232bda2e6b8cc041b2dc)...")
FetchContent_Declare(asmjit SYSTEM
	GIT_REPOSITORY
		"https://github.com/asmjit/asmjit"
	GIT_TAG
		0c03ed2f7497441ac0de232bda2e6b8cc041b2dc
)
FetchContent_MakeAvailable(asmjit)

message(STATUS "Fetching x64dbg_pluginsdk (11536beb42ec7cb9c0c8112af02d78fe083256d3)...")
FetchContent_Declare(x64dbg_pluginsdk SYSTEM
	GIT_REPOSITORY
		"https://github.com/ZehMatt/x64dbg-pluginsdk"
	GIT_TAG
		11536beb42ec7cb9c0c8112af02d78fe083256d3
)
FetchContent_MakeAvailable(x64dbg_pluginsdk)

```

`thirdparty/cmake.toml`:

```toml
# Reference: https://build-cpp.github.io/cmkr/cmake-toml

[options]
ASMJIT_STATIC = true
ASMJIT_TEST = false
ZYDIS_BUILD_EXAMPLES = false
ZYDIS_BUILD_TOOLS = false
ZYDIS_BUILD_SHARED_LIB = false
ZYDIS_BUILD_DOXYGEN = false

[fetch-content.Zydis]
git = "https://github.com/zyantific/zydis"
tag = "53dd088062c734e7882b3a77ff287bdf3356d977"

[fetch-content.asmjit]
git = "https://github.com/asmjit/asmjit"
tag = "0c03ed2f7497441ac0de232bda2e6b8cc041b2dc"

[fetch-content.x64dbg_pluginsdk]
git = "https://github.com/ZehMatt/x64dbg-pluginsdk"
tag = "11536beb42ec7cb9c0c8112af02d78fe083256d3"

```