Project Path: arc_scottcgi_Mojoc_zddui36x

Source Tree:

```txt
arc_scottcgi_Mojoc_zddui36x
├── ChangeLog.md
├── Docs
│   ├── Building.md
│   ├── CodeDetails.md
│   ├── CodeStyle.md
│   ├── ComponentArchitecture.md
│   ├── Home.md
│   ├── Images
│   ├── OOC.md
│   └── QuickStart.md
├── Engine
│   ├── Application
│   │   ├── Application.c
│   │   ├── Application.h
│   │   ├── Component.c
│   │   ├── Component.h
│   │   ├── Input.c
│   │   ├── Input.h
│   │   ├── Platform
│   │   │   ├── Android
│   │   │   │   ├── JniTool.c
│   │   │   │   ├── JniTool.h
│   │   │   │   ├── NativeGlue.c
│   │   │   │   ├── SystemInfo.c
│   │   │   │   └── Vibrator.c
│   │   │   ├── IOS
│   │   │   │   ├── SystemInfo.m
│   │   │   │   └── Vibrator.m
│   │   │   ├── SystemInfo.h
│   │   │   └── Vibrator.h
│   │   ├── Scheduler.c
│   │   └── Scheduler.h
│   ├── Audio
│   │   └── Platform
│   │       ├── Android
│   │       │   └── Audio.c
│   │       ├── Audio.h
│   │       └── IOS
│   │           └── Audio.m
│   ├── Build
│   │   └── Android
│   │       └── CMakeLists.txt
│   ├── Extension
│   │   ├── DrawAtlas.c
│   │   ├── DrawAtlas.h
│   │   ├── Extension.c
│   │   ├── Extension.h
│   │   ├── Font.c
│   │   ├── Font.h
│   │   ├── Spine
│   │   │   ├── Skeleton.c
│   │   │   ├── Skeleton.h
│   │   │   ├── SkeletonAnimationPlayer.c
│   │   │   ├── SkeletonAnimationPlayer.h
│   │   │   ├── SkeletonBone.c
│   │   │   ├── SkeletonBone.h
│   │   │   ├── SkeletonData.c
│   │   │   ├── SkeletonData.h
│   │   │   ├── SkeletonSlot.c
│   │   │   ├── SkeletonSlot.h
│   │   │   ├── SkeletonTimeline.c
│   │   │   └── SkeletonTimeline.h
│   │   ├── TextureAtlas.c
│   │   └── TextureAtlas.h
│   ├── Graphics
│   │   ├── Draw
│   │   │   ├── Color.c
│   │   │   ├── Color.h
│   │   │   ├── Drawable.c
│   │   │   ├── Drawable.h
│   │   │   ├── Quad.c
│   │   │   └── Quad.h
│   │   ├── Graphics.c
│   │   ├── Graphics.h
│   │   ├── OpenGL
│   │   │   ├── Camera.c
│   │   │   ├── Camera.h
│   │   │   ├── GLInfo.c
│   │   │   ├── GLInfo.h
│   │   │   ├── GLPrimitive.c
│   │   │   ├── GLPrimitive.h
│   │   │   ├── GLTool.c
│   │   │   ├── GLTool.h
│   │   │   ├── Mesh.c
│   │   │   ├── Mesh.h
│   │   │   ├── MeshDefine.h
│   │   │   ├── Platform
│   │   │   │   ├── EGLTool.c
│   │   │   │   ├── EGLTool.h
│   │   │   │   ├── egl.h
│   │   │   │   └── gl3.h
│   │   │   ├── Shader
│   │   │   │   ├── Shader.c
│   │   │   │   ├── Shader.h
│   │   │   │   ├── ShaderMesh.c
│   │   │   │   ├── ShaderMesh.h
│   │   │   │   ├── ShaderPrimitive.c
│   │   │   │   ├── ShaderPrimitive.h
│   │   │   │   ├── ShaderSprite.c
│   │   │   │   └── ShaderSprite.h
│   │   │   ├── Sprite.c
│   │   │   ├── Sprite.h
│   │   │   ├── SubMesh.c
│   │   │   ├── SubMesh.h
│   │   │   ├── Texture.c
│   │   │   └── Texture.h
│   │   ├── Tween
│   │   │   └── TweenDrawable.c
│   │   └── Utils
│   │       ├── Image.c
│   │       └── Image.h
│   ├── Physics
│   │   ├── Physics.c
│   │   ├── Physics.h
│   │   ├── PhysicsBody.c
│   │   ├── PhysicsBody.h
│   │   ├── PhysicsCollision.c
│   │   ├── PhysicsCollision.h
│   │   ├── PhysicsConfig.h
│   │   ├── PhysicsWorld.c
│   │   └── PhysicsWorld.h
│   ├── ThirdParty
│   │   └── PNG
│   │       ├── Include
│   │       │   ├── Android
│   │       │   │   ├── png.h
│   │       │   │   ├── pngconf.h
│   │       │   │   └── pnglibconf.h
│   │       │   └── IOS
│   │       │       ├── png.h
│   │       │       ├── pngconf.h
│   │       │       └── pnglibconf.h
│   │       └── Prebuilt
│   │           ├── Android
│   │           │   ├── arm64-v8a
│   │           │   ├── armeabi
│   │           │   ├── armeabi-v7a
│   │           │   └── x86
│   │           └── IOS
│   └── Toolkit
│       ├── HeaderUtils
│       │   ├── ArrayRange.h
│       │   ├── Bitwise.h
│       │   ├── Define.h
│       │   ├── Rect.h
│       │   ├── String.h
│       │   ├── Struct.h
│       │   └── UserData.h
│       ├── Math
│       │   ├── Math.c
│       │   ├── Math.h
│       │   ├── Matrix.c
│       │   ├── Matrix.h
│       │   ├── TweenEase.c
│       │   ├── TweenEase.h
│       │   └── Vector.h
│       ├── Platform
│       │   ├── Android
│       │   │   └── File.c
│       │   ├── File.h
│       │   ├── IOS
│       │   │   └── File.m
│       │   ├── Log.h
│       │   └── Platform.h
│       ├── Toolkit.c
│       ├── Toolkit.h
│       └── Utils
│           ├── Array.c
│           ├── Array.h
│           ├── ArrayIntMap.c
│           ├── ArrayIntMap.h
│           ├── ArrayIntSet.c
│           ├── ArrayIntSet.h
│           ├── ArrayList.c
│           ├── ArrayList.h
│           ├── ArrayQueue.c
│           ├── ArrayQueue.h
│           ├── ArrayStrMap.c
│           ├── ArrayStrMap.h
│           ├── ArrayStrSet.c
│           ├── ArrayStrSet.h
│           ├── BufferReader.c
│           ├── BufferReader.h
│           ├── Coroutine.c
│           ├── Coroutine.h
│           ├── FileTool.c
│           ├── FileTool.h
│           ├── Json.c
│           ├── Json.h
│           ├── Thread.c
│           ├── Thread.h
│           ├── Tween.c
│           ├── Tween.h
│           ├── TweenTool.c
│           └── TweenTool.h
├── LICENSE
├── README.md
├── Samples
│   ├── Apk
│   │   ├── Sample.apk
│   │   └── SuperLittleRed-2.4.0.apk
│   └── SuperLittleRed
│       ├── Android
│       │   ├── app
│       │   │   ├── build.gradle
│       │   │   ├── proguard-rules.pro
│       │   │   └── src
│       │   │       └── main
│       │   │           ├── AndroidManifest.xml
│       │   │           ├── assets
│       │   │           │   ├── Animation
│       │   │           │   │   ├── dizzy-star.atlas
│       │   │           │   │   ├── dizzy-star.json
│       │   │           │   │   ├── hit-floor.atlas
│       │   │           │   │   ├── hit-floor.json
│       │   │           │   │   ├── hit.atlas
│       │   │           │   │   ├── hit.json
│       │   │           │   │   ├── redgirl.atlas
│       │   │           │   │   ├── redgirl.json
│       │   │           │   │   ├── wood.atlas
│       │   │           │   │   └── wood.json
│       │   │           │   ├── Audio
│       │   │           │   ├── Font
│       │   │           │   │   ├── TalkChar.atlas
│       │   │           │   │   ├── UINumber.atlas
│       │   │           │   │   └── hp.atlas
│       │   │           │   ├── Stage
│       │   │           │   │   ├── Stage11.atlas
│       │   │           │   │   └── Stage11.json
│       │   │           │   ├── Texture
│       │   │           │   │   ├── Arrow.atlas
│       │   │           │   │   └── Drop.atlas
│       │   │           │   └── UI
│       │   │           │       ├── Curtain.atlas
│       │   │           │       ├── Curtain.json
│       │   │           │       ├── HUD.atlas
│       │   │           │       ├── HUD.json
│       │   │           │       ├── UIFail-zh.atlas
│       │   │           │       ├── UIFail-zh.json
│       │   │           │       ├── UIFail.atlas
│       │   │           │       ├── UIFail.json
│       │   │           │       ├── UIMenu-zh.atlas
│       │   │           │       ├── UIMenu-zh.json
│       │   │           │       ├── UIMenu.atlas
│       │   │           │       ├── UIMenu.json
│       │   │           │       ├── UIRecord-zh.atlas
│       │   │           │       ├── UIRecord-zh.json
│       │   │           │       ├── UIRecord.atlas
│       │   │           │       ├── UIRecord.json
│       │   │           │       ├── UITutorial-zh.atlas
│       │   │           │       ├── UITutorial-zh.json
│       │   │           │       ├── UITutorial.atlas
│       │   │           │       └── UITutorial.json
│       │   │           ├── java
│       │   │           │   └── com
│       │   │           │       └── Mojoc
│       │   │           │           └── Samples
│       │   │           │               └── SuperLittleRed
│       │   │           │                   └── GameActivity.java
│       │   │           └── res
│       │   │               ├── values
│       │   │               │   └── strings.xml
│       │   │               └── values-zh-rCN
│       │   │                   └── strings.xml
│       │   ├── build.gradle
│       │   ├── gradle.properties
│       │   └── settings.gradle
│       ├── Code
│       │   ├── ADTool.c
│       │   ├── ADTool.h
│       │   ├── AppInit.c
│       │   ├── AudioTool.c
│       │   ├── AudioTool.h
│       │   ├── Build
│       │   │   └── Android
│       │   │       └── CMakeLists.txt
│       │   ├── Config.h
│       │   ├── Enemy.c
│       │   ├── Enemy.h
│       │   ├── EnemyAI.c
│       │   ├── EnemyAI.h
│       │   ├── GameActor.c
│       │   ├── GameActor.h
│       │   ├── GameData.c
│       │   ├── GameData.h
│       │   ├── GameMap.c
│       │   ├── GameMap.h
│       │   ├── HUD.c
│       │   ├── HUD.h
│       │   ├── Hero.c
│       │   ├── Hero.h
│       │   ├── Tool.c
│       │   ├── Tool.h
│       │   ├── UI.c
│       │   └── UI.h
│       └── IOS
│           ├── Animation
│           │   ├── dizzy-star.atlas
│           │   ├── dizzy-star.json
│           │   ├── hit-floor.atlas
│           │   ├── hit-floor.json
│           │   ├── hit.atlas
│           │   ├── hit.json
│           │   ├── redgirl.atlas
│           │   ├── redgirl.json
│           │   ├── wood.atlas
│           │   └── wood.json
│           ├── AppDelegate.swift
│           ├── Assets.xcassets
│           │   ├── AppIcon.appiconset
│           │   │   └── Contents.json
│           │   └── Contents.json
│           ├── Audio
│           ├── Base.lproj
│           │   ├── LaunchScreen.storyboard
│           │   └── Main.storyboard
│           ├── Font
│           │   ├── TalkChar.atlas
│           │   ├── UINumber.atlas
│           │   └── hp.atlas
│           ├── GameViewController.swift
│           ├── Info.plist
│           ├── Stage
│           │   ├── Stage11.atlas
│           │   └── Stage11.json
│           ├── SuperLittleRed-Bridging-Header.h
│           ├── SuperLittleRed.xcodeproj
│           │   ├── project.pbxproj
│           │   └── project.xcworkspace
│           │       └── contents.xcworkspacedata
│           ├── Texture
│           │   ├── Arrow.atlas
│           │   └── Drop.atlas
│           ├── UI
│           │   ├── Curtain.atlas
│           │   ├── Curtain.json
│           │   ├── HUD.atlas
│           │   ├── HUD.json
│           │   ├── UIFail-zh.atlas
│           │   ├── UIFail-zh.json
│           │   ├── UIFail.atlas
│           │   ├── UIFail.json
│           │   ├── UIMenu-zh.atlas
│           │   ├── UIMenu-zh.json
│           │   ├── UIMenu.atlas
│           │   ├── UIMenu.json
│           │   ├── UIRecord-zh.atlas
│           │   ├── UIRecord-zh.json
│           │   ├── UIRecord.atlas
│           │   ├── UIRecord.json
│           │   ├── UITutorial-zh.atlas
│           │   ├── UITutorial-zh.json
│           │   ├── UITutorial.atlas
│           │   └── UITutorial.json
│           ├── en.lproj
│           │   └── InfoPlist.strings
│           └── zh-Hans.lproj
│               └── InfoPlist.strings
└── ThirdPartyBuild
    └── PNG
        ├── Android
        │   ├── app
        │   │   ├── CMakeLists.txt
        │   │   ├── build.gradle
        │   │   ├── proguard-rules.pro
        │   │   └── src
        │   │       └── main
        │   │           ├── AndroidManifest.xml
        │   │           └── cpp
        │   │               └── native-lib.cpp
        │   ├── build.gradle
        │   ├── gradle.properties
        │   └── settings.gradle
        ├── Code
        │   ├── libpng1.6.28.txt
        │   ├── png.c
        │   ├── png.h
        │   ├── pngconf.h
        │   ├── pngdebug.h
        │   ├── pngerror.c
        │   ├── pngget.c
        │   ├── pnginfo.h
        │   ├── pnglibconf.h
        │   ├── pngmem.c
        │   ├── pngpread.c
        │   ├── pngpriv.h
        │   ├── pngread.c
        │   ├── pngrio.c
        │   ├── pngrtran.c
        │   ├── pngrutil.c
        │   ├── pngset.c
        │   ├── pngstruct.h
        │   ├── pngtest.c
        │   ├── pngtrans.c
        │   ├── pngwio.c
        │   ├── pngwrite.c
        │   ├── pngwtran.c
        │   └── pngwutil.c
        └── IOS
            └── LibPng.xcodeproj
                ├── project.pbxproj
                ├── project.xcworkspace
                │   ├── contents.xcworkspacedata
                │   └── xcshareddata
                │       └── IDEWorkspaceChecks.plist
                └── xcshareddata
                    └── xcschemes
                        └── LibPNG.xcscheme

```

`ChangeLog.md`:

```md
## v0.7.1

_`2022.10.20 UTC+8 16:00`_

* Fix the `Tween` error with queue actions. 


## v0.7.0

_`2021.8.18 UTC+8 10:42`_

* Fix case spelling error in `ArrayList.c`.
* Update the `Vibrator` API of Android.
* Add the `Smooth` function and Set the `Smooth` as the default ease.
* Optimize the `Tween` implementation by remove the `queueAction`.
* Refactor the `ArrayQueue`, rename `Push` to `Enqueue` and `Pop` to `Dequeue`. **(Break Compatibility)**


## v0.6.4

_`2021.2.19 UTC+8 00:27`_

* Fix `static` missing of EGLTool function.
* Add AFont_SetTextColor to Font.
* Add docs to repo.
* Improve comments and logs of [Application, Input, Vibrator].
* Update the codestyle site for all source code.


## v0.6.0

_`2021.2.6 UTC+8 13:26`_

* Refactor the PhysicsCollision implementation.
* Remove `RotateM` function in `Matrix.c`.

* Rename Ortho to Orthographic.
* Rename `Interpolates` to `Easing` in `ATweenEase`.

* Add some collision algorithms to the `Math`.
* Add `rotatioinX` and `rotationY` in `Drawable`. 
* Add `EasingTimeFns` in `ATweenEase`. 

* Fix precision problem of TweenEase BackInElasticOut.
* Fix `Bounce` function error when easing complete in `TweenEase`.
* Fix bug `off_t` convert to `off_t*` in function `OpenFileDescriptor` of `File.c`.
* Fix the bug of Json `parseObject` that modifying the json string.

* Optimize matrix `ratation`.
* Optimize easing functions that delete all redundant `else` keywords.
* Optimize easing functions `ElasticIn, Out, IntOut`.
* Optimize the implementation of Json `SkipString`.


## v0.5.0
_`2019.9.5 UTC+8 15:42`_

* **Features**

  * Add `Vibrator`implementation.
  * Add `JniTool` functions: `CallNativeActivityMethod`, `CallActivityMethod`, `GetField`, `GetArrayLength`, `GetArrayAt`, `GetNativeActivityField`, `GetEnvPtr`.
  * Add Audio `Stop` function.
  * Add `Create` and `Init` functions with filePath.
  * Add `AUserData_AddSlotInt` and `AUserData_AddSlotFloat`.
  * Add macro `AArray_MakeWithData()`.
  * Add Mesh drawMode.
  * Add Vector and Color macro define for construct composite literal.
  * Add Mesh fucntions: `Deform, DeformByIndex`.
  * Add `GetDrawCalls` function of ADrawable.
  * Add `Color RGB` macros.
  * Add `Deform` function of Sprite.
  * Add `TweenEase` functions: `TweenEaseType_BackInExponentialOut, TweenEaseType_BackInElasticOut`.
  * Add `Thread` implementation.
  * Add `SystemInfo` implementation.
  * Add AMath inline functions: `AMath_InvSqrtf, AMath_Sqrtf in Math`.
  * Add `MultiplyMZ` function of AMatrix.
  * Add `GetWorldScaleV2` function of ADrawable.
  * Add macro `AMatrix_Make(...)` for construct Matrix composite literal.


* **Refactor Code (Break Compatibility)**

  * Refactor "JniTool" implementation.
  * Refactor `Primitive` implementation.
  * Refactor `Quad` implementation.
  * Refactor `Mesh` and `SubMesh` implementation.
  * Refactor `Physics` implementation.
  * Refactor `File` and `FileTool` implementation.
  * Refactor `UserData` implementation.
  * Refactor `Drawable and ADrawable` implementation.
  * Refactor `ABitwise` implementation.
  * Refactor `PhysicsBody` state and collisionGroup `set/add` functions.
  * Refactor `NativeGlue.c` context data object.
  * Refactor the `GetKey` function return value type from `char*` to `const char*`.
  * Refactor `ACoroutine` implementation from `labels as values` to `switch case`.
  * Refactor const constraints of `Json` implementation.


* **Refactor Name (Break Compatibility)**

  * Rename `random()`to `rand()` and `srandom()` to `srand()`.
  * Rename Id to ID.
  * Rename `SetPlay` to `Play`, `SetPause` to `Pause`.
  * Rename enum variable names of `MeshDefine`.
  * Rename JSON `Release` to `Delete`.
  * Rename Toolkit `Head` to `HeaderUtils`.
  * Rename `DrawableState_UpdateInverse` to `DrawableState_UpdateInverseMatrix`, `DrawableState_IsUpdateMVP` to `DrawableState_IsUpdateMVPMatrix`.
  * Rename `elementArray` to `elementArr`.
  * Rename `Json` and `Tween` functions name.
  * Rename `File` and `FileTool` functions name.
  * Rename `SetWithQuad` to `SetUVWithQuad`.
  * Rename `ADrawable` `RenderQueue` to `Render`.
  * Rename `BufferReader` functions name and macros.
  * Rename consts of `Sprite, Mesh, Quad` that make them legible.


* **Removed Code (Break Compatibility)**

  * Remove `AArray_GetData` of Array.
  * Remove `Particle` System.


* **Optimizations**

  * Optimize IOS swift calls `Mojoc` code.
  * Optimize `i--` to `--i` as can do as possible.
  * Optimize `i++` to `++i` as can do as possible.
  * Optimize `Mesh, SubMesh, Quad` data calculation.
  * Optimize `Skeleton` `Update` function implementation.
  * Optimize `Physics` implementation
  * Optimize `BufferReader` implementation.
  * Optimize `File` and `FileTool `implementation.
  * Optimize `InputTouch` implementation.
  * Optimize `Application` make it more clear and stable.
  * Optimize `composite literal` have clear length.
  * Optimize binary search.
  * Optimize `BufferReader` `TryFindString` function.
  * Optimize Json `ParseNumber` function.
  * Optimize functions: `MultiplyMX, MultiplyMY, MultiplyMV2`.
  * Optimize audio play callback error check.
  * Optimize Json function `SkipWhiteSpace` call in `ParseArray` and `ParseObject`.
  * Optimize `Mesh` and `SubMesh` funcations: `SetUVWithQuad, CreateWithData, CreateWithQuad.
  * Optimize Sprite `Deform` that move update data implementation to render function by if use VBO.


* **Fix Bugs**

  * Fix `FontText` alignment bug.
  * Fix rendering bug when app goes into the background and not changing the content size.
  * Fix Android destroy callback bug when app in background.
  * Fix Audio `Release` bug in Android.
  * Fix `RenderLines` bug.
  * Fix `ANativeActivity`, `OnContentRectChanged` callback bug.
  * Fix `NativeGlue` bug when window resized.
  * Fix `EGL` error setting when screen lock/unlock.
  * Fix E/libEGL: validate_display:99 error 3008 (EGL_BAD_DISPLAY).
  * Fix OpenSLES "E/libOpenSLES: Error after prepare: 1" in some devices.
  * Fix point and polygon collision algorithm error.


## v0.4.7
_`2018.1.16 UTC+8 17:12`_

* Update copyright.
* Optimize Json ParseNumber and code format.
* Json optimize if else to switch case.
* Refactor Json ParseObject, ParseArray and SkipString fucntions.
* Rename TweenData to Tween.
* Fix tween variable name error and float value missing 'f'.
* Fix code warning and modify log msg.
* Add LibPng 1.6.25 XCode and AndroidStudio project.
* Modify java and swift code.


## v0.0.0
_`2017.7.2 UTC+8 09:58`_

* Initial Release.

```

`Docs/Building.md`:

```md
### BUILDING ANDROID MOJOC PROJECTS FROM LINUX COMMANDLINE

#### 1. Install the required packages

- Java
    ```shell
    $ apt install openjdk-8-jdk
    ```

- Android SDK
    ```shell
    $ snap install androidsdk
    ```

- SDK tools
    ```shell
    $ androidsdk "platform-tools" "platforms;android-28"  
    $ androidsdk "build-tools;30.0.3" "cmake;3.10.2.4988404"
    ```
- NDK
    ```shell
    $ androidsdk "ndk;22.0.7026061"
    ```

- Gradle

    Install [SDKMAN](https://sdkman.io/install)

    ```shell
    $ curl -s "https://get.sdkman.io" | bash
    $ source "$HOME/.sdkman/bin/sdkman-init.sh"
    ```

    Install [Gradle](https://gradle.org/install/)
    ```shell
    $ sdk install gradle 6.8.2
    ```

#### 2. Building the sample project.

- Add `ndkVersion` in build.gradle found in app folder.
    ```gradle
    android {
      ndkVersion "22.0.7026061"
      ...  
    }
    ```

- Run `gladle build` in the Android folder.
    ```shell
    $ gradle build
    ```

```

`Docs/CodeDetails.md`:

```md
<img src="./Images/Architecture.png" width="790" height="560" alt="Mojoc Engine Architecture" title="Mojoc Engine Architecture" />

## 

Mojoc modules have a dependency hierarchy, the upper layer can reference the lower layer, but the lower layer cannot reference the upper layer, and parallel modules cannot reference each other. This ensures minimal dependency compilation of modules.

* [Toolkit Module](#toolkit-module)
* [ThirdParty Module](#thirdparty-module)
* [Graphics Module](#graphics-module)
* [Physics Module](#physics-module)
* [Audio Module](#audio-module)
* [Extension Module](#extension-module)
* [Application Module](#application-module)


## Toolkit Module

The [Toolkit](../Engine/Toolkit) module is a development kit for the C language. It provides basic data structure and algorithm support.

* [Math](../Engine/Toolkit/Math) provides mathematical algorithms implementation.
* [Utils](../Engine/Toolkit/Utils) provides basic data storage tools and algorithms.
* [HeaderUtils](../Engine/Toolkit/HeaderUtils) provides independent structure definitions or functions (with no `.c` file implementation).
* [Platform](../Engine/Toolkit/Platform) provides platform-related tools.


## ThirdParty Module

The [ThirdParty](../Engine/ThirdParty) module contains third party libraries, that can be directly called by the Mojoc engine. So the third party needs to provide different prebuilt lib files for native platforms supported by Mojoc.

* Currently only contains [PNG](../Engine/ThirdParty/PNG) library.
* [ThirdPartyBuild](../ThirdPartyBuild) is a multi-platform build project of the ThirdParty module.

## Graphics Module

[Graphics](../Engine/Graphics) module is draw layer implemented with OpenGLES3, and provides drawing tools and implementations.

* [Draw](../Engine/Graphics/Draw) provides basic abstract drawing layer.
* [OpenGL](../Engine/Graphics/OpenGL) provides OpenGLES rendering functions.
  * [Platform](../Engine/Graphics/OpenGL/Platform) provides platform-related EGL implementation.
* [Tween](../Engine/Graphics/Tween) provides tween animation implementation.
* [Utils](../Engine/Graphics/Utils) provides drawing support tools.

## Physics Module

[Physics](../Engine/Physics) module provides simple physical simulation.

## Audio Module

* [Audio.h](../Engine/Audio/Platform/Audio.h) is an interface for the audio API.
* [Platform](../Engine/Audio/Platform) is a cross-platform audio implementation.
  * [Android/Audio.c](../Engine/Audio/Platform/Android/Audio.c) is OpenSLES implementation in Android.
  * [IOS/Audio.m](../Engine/Audio/Platform/IOS/Audio.m) is OpenAL implementation in IOS.

## Extension Module

[Extension](../Engine/Extension) module contains editor-related implementations.
  * [Spine](../Engine/Extension/Spine) is runtime implementation of Spine 2D skeleton animation.

## Application Module

[Application](../Engine/Application) module contains the app control and interaction layer. It provides app lifecycle callbacks, input events, native platform functions, component architecture and so on.

* [Platform](../Engine/Application/Platform) contains platform-related implementations.
  * [Platform/Android](../Engine/Application/Platform/Android) contains native function implementations of Android.
  * [Platform/IOS](../Engine/Application/Platform/IOS) contains native function implementations of IOS.

## 
:book:
```

`Docs/CodeStyle.md`:

```md
Mojoc strictly follow this code style to ensure the C code **readability** and **uniformity**. This code style is important to understanding how Mojoc works.

#### Code Naming
* [Basic Naming](#basic-naming)
* [Variable Naming](#variable-naming)
* [Abbreviated Naming](#abbreviated-naming)
* [Goto Label Naming](#goto-label-naming)
* [Enum Naming](#enum-naming)
* [Function Naming](#function-naming)
* [Struct Naming](#struct-naming)
* [Macro Naming](#macro-naming)
* [Array Naming](#array-naming)
* [Others Naming](#others-naming)

#### Code Format
* [Basic   Format](#basic-format)
* [Space   Format](#space-format)
* [Indent  Format](#indent-format)
* [Parentheses Format](#parentheses-format)
* [Lines   Format](#lines-format)
* [Comment format](#code-comment)

#### Others
* [Other Rules](#other-rules)


## Basic Naming

The basic use CamelCased, this is `BigCamelCased`, this is `smallCamelCased`.

## Variable Naming

* The common variable use `smallCamelCased`.
    ```c
    int               keyLength;
    int               valueTypeSize;
    SkeletonBone*     bone;
    SkeletonBoneData* boneData;
    Drawable*         drawable;
    ```

* The const use `smallCamelCased`.
  ```c
  static const char*  ids[AudioId_Length];
  static const char*  saveDataFileName = "MojocSaveDataFile";
  static const int    bezierSize       = (BEZIER_SEGMENTS + 1) * 2 - 1;
  static const float  subDivPre        = subDivStep3           / pre5;
  ```

* The bool variable (including member variables) begin with prefix `is`, then the whole is `smallCamelCased`.
  ```c
  SLboolean isLoopEnabled;
  bool      isFound;
  bool      isRemoved;
  particle->isActive
  ```

* The singleton variable begin with prefix `A`, then the whole is `BigCamelCased`.
  ```c
  extern struct AComponent   AComponent  [1];
  extern struct ADrawable    ADrawable   [1];
  extern struct AParticle    AParticle   [1];
  extern struct AApplication AApplication[1];
  ```

* The variable of function get out argument begin with prefix `out`, then the whole is `smallCamelCased`.
  ```c
  void (*OnSaveData)(void**   outSaveData,   int*         outLength);
  void (*Inverse)   (Matrix4* matrix4,       Matrix4*     outInverse);
  void Init         (int      valueTypeSize, ArrayIntMap* outArrayIntMap);
  ```

* The variable of function pointer use `BigCamelCased`.
  ```c
  typedef struct
  {
      void (*OnPause)  (void);
      void (*OnResume) (void);
      void (*OnDestroy)(void);
  }
  ApplicationCallbacks;


  typedef float (*TweenActionValueOnGet)(void* target);
  typedef void  (*TweenActionValueOnSet)(void* target, float value);


  typedef struct
  {
      TweenActionValueOnGet OnGet;
      TweenActionValueOnSet OnSet;
  }
  TweenActionValueGetSet;
  ```

## Abbreviated Naming

* The abbreviated words use `uppercase` words or `lowercase` words.
  ```c
  typedef struct
  {
  }
  RGB;


  RGB rgb;
  RGB myRGB;
  RGB rgbDatas[10];
  RGB myRGBData;
  

  void SetRGB    (RGB* rgb);
  void RGBSet    (RGB* rgb);
  void SetRGBData(RGB* rgb);

  ```

## Goto Label Naming

* The goto label tag use `BigCamelCased`. But goto label address use common variable rule. 

  ```c
  goto ParseArrayEnd;
  goto ParseObjectEnd;
  goto UseVBO;
  goto UseVAO;
  goto *coroutine->step;
  ```

## Enum Naming

* The enum use `BigCamelCased`, and must have prefix separated by `_`.
  ```c
  enum
  {
      HeroState_Stand,
      HeroState_DieOver,
  };


  enum
  {
      CollisionGroup_HeroBody   = 1,
      CollisionGroup_HeroAttack = 1 << 1,
  };
  ```

* The typedef enum use `BigCamelCased`, and must have prefix separated by `_`.
  ```c
  typedef enum
  {
      FontTextAlignment_HorizontalLeft,
      FontTextAlignment_HorizontalRight,
      FontTextAlignment_VerticalTop,
      FontTextAlignment_VerticalBottom,
  }
  FontTextAlignment;


  typedef enum
  {
      InputTouchType_Up     = 1,
      InputTouchType_Down   = 2,
      InputTouchType_Move   = 3,
      InputTouchType_Cancel = 4,
  }
  InputTouchType;
  ```

## Function Naming

* The global function and global inline function use `BigCamelCased`, and must have prefix separated by `_`.
  ```c
  extern void         Application_Main        (void);
  static inline void  AApplication_AppendChild(Component* child);
  static inline float AGLTool_ToGLWidth       (float      screenWidth);
  static inline float AMath_Random            (void);
  ```

* The local function and local inline function use `BigCamelCased`;
  ```c
  static void         LoadingRun    (Coroutine* coroutine);
  static inline float GetWorldScaleY(Drawable*  drawable);
  ```

* The typedef function use `BigCamelCased`, and must have prefix.
  ```c
  typedef float (*TweenActionValueOnGet)(void*      target);
  typedef void  (*TweenActionValueOnSet)(void*      target, float value);
  typedef void  (*CoroutineRun)         (Coroutine* coroutine);
  ```

* The function operation may not succeed, begin with prefix `Try`, then the whole is `BigCamelCased`.
  ```c
  void* (*TryPut)   (ArrayIntMap* arrayIntMap, intptr_t key, void* valuePtr);
  bool  (*TryRemove)(ArrayIntMap* arrayIntMap, intptr_t key);
  ```

* The function return boolean which is operation purpose, begin with prefix `Is` or `Test` or `Check` , then the whole is `BigCamelCased`.
  ```c
  bool (*IsContains)         (ArrayIntSet*  arrayIntSet, intptr_t element);
  bool (*TestPolygonPoint)   (Array(float)* vertexArr,   float x, float y);
  bool ADrawable_CheckVisible(Drawable*     drawable);
  ```

* The function begin with prefix `Release`, means free the struct members memory, after then the pointer needs to be freed manually.
  ```c
  void (*Release)    (Mesh* mesh);
  void (*ReleaseQuad)(DrawAtlas* drawAtlas, SubMesh* subMesh);
  ```

* The function begin with the prefix `Destroy`, means free the struct members and self memory, after then the pointer cannot be used.
  ```c
  void (*Destroy)(void);
  void (*Destroy)(Texture* texture);
  ```

* The function begin with prefix `Create`, means return the malloc pointer, so use `Release` and `free` or `Destroy` for delete.
  ```c
  ArrayList* (*Create)            (int elementTypeSize);
  ArrayList* (*CreateWithSize)    (int elementTypeSize, int size);
  ArrayList* (*CreateWithCapacity)(int elementTypeSize, int capacity);
  ```

* The function begin with prefix `Init`, means the pointer members memory on stack, so use `Release` or `Destroy` for delete memory.
  ```c
  void (*Init)            (int elementTypeSize, ArrayList*               outArrayList);
  void (*InitWithSize)    (int elementTypeSize, int size,     ArrayList* outArrayList);
  void (*InitWithCapacity)(int elementTypeSize, int capacity, ArrayList* outArrayList);
  ```

* The function if no args then type `void` arg.
  ```c
  Drawable*          (*Create)      (void);
  int                (*GetDrawCalls)(void);
  struct ATweenTool* (*AddAction)   (void);
  ```

* The function have suffix `Impl`, means the function must be implemented in `.c` file.
  ```c
  extern void Application_MainImpl(void);


  struct ATweenActionValueGetSetImpl
  {
      TweenActionValueGetSet moveX  [1];
      TweenActionValueGetSet moveY  [1];

      TweenActionValueGetSet scaleX [1];
      TweenActionValueGetSet scaleY [1];

      TweenActionValueGetSet rotateZ[1];
      TweenActionValueGetSet fadeTo [1];
  };

  extern struct ATweenActionValueGetSetImpl ATweenActionValueGetSetImpl[1];
  ```

## Struct Naming

* The struct (union) or typedef struct (union), use `BigCamelCased`.

## Macro Naming

* The head define macro, use `uppercase` words separated by `_` and have suffix `H`.
  ```c
  #ifndef STYLE_GUIDE_H
  #define STYLE_GUIDE_H
  ```

* The macro without parameters, use `uppercase` words separated by `_`.
  ```c
  #define MATH_PI  3.141592653589793
  #define MATH_2PI 6.283185307179586
  #define MATH_PI2 1.570796326794897
  ```

* The macro with parameters, use `BigCamelCased`, and must have prefix separated by `_`.
  ```c
  #define AMath_Min(x, y) 
  #define AStruct_GetParent2(memberPtr, structType)
  #define ACoroutine_YieldFrames(waitFrames)
  ```

* The local macro in `.c` file, use `BigCamelCased`, no prefix required, and must `#undef` in same `.c` file.
  ```c
  #define CheckIndex(tag, index)
  #define CheckCallback(callback)
  #define CheckFingerId(tag, fingerId)

  #undef CheckIndex
  #undef CheckCallback
  #undef CheckFingerId
  ```

* The macro type parameter must have suffix `Type`.
  ```c
  #define ArrayList(ElementType)
  #define AArrayIntSet_Init(ElementType, increase)
  #define AArrayList_Pop(arrayList, ElementType)
  ```

## Array Naming

* Array as parameter, use `[]` form, not `*` form.
  ```c
  void (*SetTimeToBuff)(char        buff  [], int seconds);
  int  (*BinarySearch) (const float values[], int valuesLength, float target);
  ```

* Array as parameter, use `[length]` form, if the length is clear.
  ```c
  void (*GetLanguageCode)(char outLanguageCode[2]);
  ```

* Array variable use `[length]` form, if the length is clear.
  ```c
  extern struct AMesh AMesh[1];


  struct AGLInfo
  {
      GLfloat pointSizeRange[2];
      GLfloat lineWidthRange[2];
  }


  ArrayIntSet set[1] = AArrayIntSet_Init(ElementType, increase);
  ```

* Array composite literal use `[length]` form, if the length is clear.
  ```c
  #define AColor_Make(r, g, b, a) (Color[1])   {{r, g, b, a }}
  #define AMatrix_Make(...)       (Matrix4[1]) {{__VA_ARGS__}}
  InitSprite(outSprite, texture, (Array(Quad)[1]) {quad, 1}); 
  ```

## Others Naming

* The following cases use `BigCamelCased`. 
  * File Name
  * Folder Name
  * Resource Name


## Basic Format

* Use `4 spaces` key indent, not `tab` key.
* One line `120 chars`.
* The pointer `*` on type name side.
  ```c
  int*  p1;
  int** p2 = &p1;
  void* Function(char* str);
  ```
* In code block try `vertical` alignment.
  ```c
  See all the examples above.
  ```


## Space Format

* The operator at least `one space` on both sides.
  ```c
  vertexX + (y - vertexY) / (preY - vertexY) * (preX - vertexX)
  ```

* The `if, while, for, switch`, must have `{}`, and `one space` with `()`.
  ```c
  if (...)
  {
  }
  

  while (...)
  {
  }


  for (...)
  {
  }


  switch (...)
  {
  }
  ```

## Indent Format

* The case `4 spaces` indent, and the break `4 spaces` indent in switch case.
  ```c
  switch (...)
  {
      case 0:
          break;

      case 1:
      {
          break;
      }
  }
  ```

* The goto label indent with the current line.
  ```c
  static void Function()
  { 
       goto Label:

       Label1:
       int a;

       Label2:
       int b;

       Label3:
       int c;
  }
  ``` 
  
* The conditional compile, indent with the current line.
  ```c
  typedef struct
  {
       Sprite       sprite[1];
       PhysicsBody* body;
       Enemy*       enemy;
       ArrowHitType hitType;

       #ifdef APP_DEBUG
       Drawable     debugDrawable[1];
       #endif
  }
  Arrow;

  void Function()
  {
      int a;
        
      #ifdef APP_DEBUG
      int b;
      #endif
  }


  #ifdef APP_DEBUG
  Drawable debugDrawable[1];
  #endif
  ```

## Parentheses Format

* The `{}` and `{{}}` vertical alignment or on the same line.
  ```c
  {
    ...
  }  // vertical alignment
  
    
  {{
    ...
  }} // vertical alignment 


  {...} // same line
  

  {{...}} // same line
  ```

* The `{{}}` used for array init.
  ```c
  struct AGameMap AGameMap[1] =
  {{
      .Init      = Init,
      .Run       = Run,
      .RandomMap = RandomMap,
  }};

  Vector3 vector[1] =
  {{
      drawable->modelMatrix->m0,
      drawable->modelMatrix->m1,
      drawable->modelMatrix->m2,
  }};

  #define AMatrix_Make(...) (Matrix4[1]) {{__VA_ARGS__}}
  ```

* The `()` if need to wrap, then vertical alignment.
  ```c
  AMath_Max
  (
      animationData->duration,
      AArray_Get
      (
          deformTimeline->frameArr,
          deformTimeline->frameArr->length - 1,
          float
      )
  );

  static void ReadAnimationDeform
  (
      SkeletonData*          skeletonData,
      JsonObject*            jsonDeform,
      SkeletonAnimationData* animationData,
      ArrayList*             skeletonTimelineArr
  )
  {
  }
  ```

## Lines Format

* Empty `two lines` around functions.
  ```c
  static int a = 100;


  static void Function1()
  {
  }


  static inline void Function2()
  {
  }

 
  struct A
  {
  }
  ```

* Empty `two lines` between different contents.
  ```c
  #include "AAA.h"
  #include "BBB.h"


  typedef float (*Function1)(void* target);
  typedef float (*Function2)();


  struct A
  {
  }


  struct B
  {
  }


  extern struct B B[1];
  ```

## Code Comment

* Outside function body use `/***/`.
  ```c
  /**
   * Comment struct
   */  
  struct A
  {   
      /**
       * Comment property
       */ 
      int a;
      
      /**
       * Comment function
       */
      void (*Function)();
  }
  ```

* In function body use `//`.
  ```c
  void Function()
  {
    // comment in function body.
  } 
  ```

* Comment block or multiline code.
  ```c
  /* This is means comment block or multiline code. */

  /* 
  This is means comment block or multiline code. 
  */
  ```

* Use comment line to separate different logical related contents.
  ```c
  void Function1();


  //--------------------
  

  void Function2();


  void Function3()
  {
      int a;

      //---------------- 

      int b;
  }
  ```

* Use comment line to mark macros `#ifdef Platform_X` or multiple `#endif`.
  ```c
  #ifndef PLATFORM_H
  #define PLATFORM_H


  //------------------------
  #ifdef IS_PLATFORM_ANDROID
  //------------------------


  // platform codes.


  //---------------------------
  #endif // IS_PLATFORM_ANDROID
  //---------------------------


  //------------------
  #endif // PLATFORM_H
  //------------------
  ```


## Other Rules
* The parameter macro, used only when `inline` function not working.
  * such as shortcut parameters of function call.
    ```c
    /**
     * Shortcut of AArrayList->GetAdd.
     * return element.
     */
     #define AArrayList_GetAdd(arrayList, ElementType) \ 
     (*(ElementType*) AArrayList->GetAdd(arrayList))
    ```
  * such as macro specific functionality.
    ```c
    #define CheckIndex(tag, index)                                      \
    ALog_A                                                              \
    (                                                                   \
        ((index) < arrayList->size && (index) >= 0),                    \
        "AArrayList " tag " failed index error, index = %d, size = %d", \
        index,                                                          \
        arrayList->size                                                 \
    )     
    ```

  * such as generic parameter.
    ```c
    /**
     * Marked ArrayList element type.
     * ElementType: element data type
     */
    #define ArrayList(ElementType) ArrayList
    ```

  * such as varargs.
    ```c
    #define ALog_A(e, ...) e ? (void) 0 : ALog_E(__VA_ARGS__),  assert(e);
    ```

* Do not use number as `boolean` value.
* The `coefficient` number uses `int` unless it is a `float`.
  ```c
  float f1 = sprite->width / 2;
  float f2 = sprite->width / 2.5f;
  ```
* Use `++i` whenever possible.
  ```c
  for (int i = 0; i < 10; ++i)
  {
  }
  ```
* Assignment appears in the `if` or `while` statement, adding brackets.
  ```c
  int intVal;
  if ((intVal = GetInt())) 
  {
      int tmp = intVal * 100;
  }

  int intVal1;
  int intVal2 = GetInt();
  while ((intVal1 = intVal2)) 
  {
      int tmp = intVal1 * 100;
  }
  ```
* The `const` variable cannot be modified.
* Use `enum` instead of macro `#define` whenever possible.
* Use a monospaced font.

#
:smiling_imp: _**Follow the Style, Feel the Power !**_

```

`Docs/ComponentArchitecture.md`:

```md
Mojoc combines Component-Based, State-Machine, Message-Driven in one structure, which is **Mojoc Component**.

* [Component-Based](#component-based)
* [State-Machine](#state-machine)
* [Message-Driven](#message-driven)
* [Mojoc Component](#mojoc-component)

## Component-Based
There is no Entity to manage Components here, because the Entity functions are merged into the Component. The result is that all components build a recursive tree structure, and the Component is a minimal reusable structure, which can manage a set of subcomponents.

```c
struct Component
{
    int                            order;
    Component*                     parent;
    ArrayIntMap(order, Component*) childMap[1];
};


struct AComponent
{
    void  (*AddChild)          (Component* parent, Component* child, int order);
    void  (*AppendChild)       (Component* parent, Component* child);
    void  (*RemoveChild)       (Component* parent, Component* child);
    void  (*RemoveAllChildren) (Component* parent);
    void  (*ReorderAllChildren)(Component* parent);
};
```

* `Component` through `childMap` control subcomponents.
* Parallel subcomponents are sorted by order.

## State-Machine
A Component has one or more states, and must be in a certain state — everything has a state, this is an abstract mapping. And the Component as a minimal reusable structure, usually has data and behavior, the state is the presentation of different behaviors under the different data.

So this is means the Component can has own State-Machine to control and manage its states.

```c
struct ComponentState
{
    int  id;
    void (*Update)     (Component* component, float deltaSeconds);
    void (*UpdateAfter)(Component* component, float deltaSeconds);
    bool (*OnMessage)  (Component* component, void* sender, int subject, void* extraData);
};


struct Component
{
    ComponentState*                       curState;
    ComponentState*                       preState;
    ComponentState*                       defaultState;
    ArrayIntMap(stateId, ComponentState*) stateMap[1];
};


struct AComponent
{
    void            (*SetState)(Component* component, int stateId);
    ComponentState* (*AddState)(Component* component, int stateId, ComponentStateOnMessage onMessage, ComponentStateUpdate update);
};
```

* Each state can receive and handle message.
* Components can build a hierarchical state machine system.

## Message-Driven
The Component can be either a message publisher or a message subscriber. It‘s like a minimal interactive structure, and the Component implements the control and feedback.

```c
struct Component
{
    ArrayIntSet(Component*) observerSet[1];
};


struct AComponent
{
    void (*AddObserver)   (Component* sender,    Component* observer);
    void (*RemoveObserver)(Component* sender,    Component* observer);
    bool (*SendMessage)   (Component* component, void*      sender,  int   subject, void* extraData);
    void (*Notify)        (Component* sender,    int        subject, void* extraData);
};
```

* `SendMessage` and `Notify`, both use `OnMessage` receive message notification.
* `SendMessage` for all subcomponents.
* `Notify` for subscription components.

## Mojoc Component
It's a minimal reusable, interactive, stateful, composable, extensible structure. And the code implementation is as follows:
* [Component.h](../Engine/Application/Component.h)
* [Component.c](../Engine/Application/Component.c)

##
:curly_loop:
```

`Docs/Home.md`:

```md
## Guide

* [Quick Start](./QuickStart.md)
* [Building Android From Linux](./Building.md)
* [Code Style](./CodeStyle.md)
* [OOC (Object Oriented C)](./OOC.md)
* [Component Architecture](./ComponentArchitecture.md)
* [Code Details](./CodeDetails.md)
* [Roadmap](../README.md#roadmap)

## 中文指南
* [又在写代码（知乎专栏）](https://zhuanlan.zhihu.com/p/52864752)

##
:flags:



```

`Docs/OOC.md`:

```md
Mojoc strictly follow this OOC (Object Oriented C) programing model. The model is customized by C unique features, so it supports C language to build large and complex projects, and still remains simple to use and easy to understand.

* [Singleton](#Singleton)
* [Encapsulation](#encapsulation)
* [Inheritance](#inheritance)
* [Composite](#composite)
* [Polymorphism](#polymorphism)
* [Override](#override)
* [Memory](#memory)
* [Examples](#examples)
* [Sample](#Sample)

## Singleton

The Singleton pattern is very important to Mojoc. In C language the data and behavior are separated and there is no namespace. The singleton can abstract a group of behavior and give it namespace. This model build a parallel data struct and behavior struct that correspond to the class of OOP model.

#### In `.h` file
  ```c
  struct ADrawable
  {
      Drawable* (*Create)();  
      void      (*Init)  (Drawable* outDrawable);
  };


  extern struct ADrawable ADrawable[1];
  ```
  
  * The `ADrawable` is singleton, global unique.
  * The struct `ADrawable` is type name, `ADrawable[1]` is object name.
  * The `ADrawable` object defined as an array, can let it use like a ptr.

#### In `.c` file
  ```c
  static Drawable* Create()
  {
      return (Drawable*) malloc(sizeof(Drawable));
  }

 
  static void Init(Drawable* outDrawable)
  {
      // init outDrawable
  }


  struct ADrawable ADrawable[1] =
  {
      Create,  
      Init,
  };
  ```
 
  * Just initialize the singleton `ADrawable` object.


## Encapsulation

#### In `.h` file
  ```c
  typedef struct Drawable Drawable;  
  struct  Drawable  
  {  
      float positionX;  
      float positionY;  
  };


  typedef struct 
  {  
      Drawable* (*Create)();  
      void      (*Init)  (Drawable* outDrawable);  
  }  
  ADrawable;  
  

  extern ADrawable ADrawable[1]; 
  ```
  
  * The `Drawable` object hold the data.
  * The `ADrawable` object hold the behavior.
  * The `Create` function malloc the `Drawable` memory like new keyword.
  * The Init function initialize `Drawable` which memory already exists, often in stack or in superclass memory.

## Inheritance

The inheritance is superclass struct all datas are embedded in subclass struct. Then one malloc can get all memory in inheritance chain, and one free on subclass object can release all memory in inheritance chain.

  ```c
  typedef struct Drawable Drawable;  
  struct  Drawable  
  {  
      int a;
  };


  typedef struct
  {
      Drawable drawable[1];
  }
  Sprite;


  struct ASprite
  {
      Sprite* (*Create)();  
      void    (*Init)  (Sprite* outSprite);  
  };
  ```

* The `Drawable` is superclass.
* The `Sprite` is subclass.
* The `drawable[1]` as an array, can let it use like a ptr.
* In `ASprite` function `Create` and `Init`, indirect call `ADrawable->Init` for initialize superclass memory.
* In C there is no limit of inheritance number, the subclass can inheritance any numbers of superclass — this is a new angle of abstract.

#### How to visit subclass from superclass ?

```c
/**
 * Get struct pointer from member pointer.
 * this for memberPtr same as memberName.
 * 
 * memberPtr: the pointer that point struct's member.
 *            it's the member address offset from struct address.
 * 
 */
#define AStruct_GetParent(memberPtr, ParentType) \
    ((ParentType*) ((char*) (memberPtr) - offsetof(ParentType, memberPtr)))

Sprite* sprite = AStruct_GetParent(drawable, Sprite);
```

* First, get the superclass offset in subclass struct.
* Second, get the subclass ptr from superclass ptr by superclass offset.
* With this ability, we can hold superclass ptr execute same interface, but different implementation of subclass — this is polymorphism.

## Composite

The composite is independent struct ptr are embedded in struct .

```c
typedef struct Drawable Drawable;  
struct  Drawable  
{  
    Drawable* parent;
}; 
```

* The parent composite into `Drawable`, the memory manage by independent `Create` and `Release` of parent.

## Polymorphism

```c
typedef struct Drawable Drawable;  
struct  Drawable  
{   
    void (*Draw)(Drawable* drawable);  
};  
```

The function `Draw` in struct, means different `Drawable` object can has own implementation of `Draw`.

  ```c
  typedef struct  
  {  
      Drawable drawable[1];  
  }  
  Hero;


  typedef struct  
  {  
      Drawable drawable[1];  
  }  
  Enemy; 


  Drawable drawables[] =   
  {  
      hero->drawable,  
      enemy->drawable,  
  };  


  for (int i = 0; i < 2; ++i)  
  {  
      Drawable* drawable = drawables[i];  
      drawable->Draw(drawable);  
  }
  ```

The `Hero` and `Enemy` implement own `Draw` behavior.

## Override

In inheritance chain, usually need to override superclass function and call superclass function.

  ```c
  typedef struct  
  {  
      Drawable drawable[1];  
  }  
  Sprite;  


  struct ASprite
  {  
      void (*Draw)(Drawable* drawable);  
  };  


  extern ASprite ASprite;  
  ```

If we want to override Sprite's `Draw` function: 
  * First, need to publish `Draw` to `ASprite`;
  * Second, override `Draw` function; 
  * Then, we can still call the original `Draw` by `ASprite`.

  ```c
  typedef struct  
  {  
      Sprite sprite[1];  
  }  
  SpriteBatch;


  // subclass implementation  
  static void SpriteBatchDraw(Drawable* drawable)  
  {  
        // call father  
        ASprite->Draw(drawable);
      
        // do extra things...
  }  


  // override
  spriteBatch->sprite->drawable->Draw = SpriteBatchDraw;
  ```

## Memory

* `Create` — malloc struct memory and delete by `free` and `Release` if needed.
* `Init` — initialize struct memory and delete by `Release` if needed.
* `Release` — delete struct member ptr memory which composite into struct and `Create` by struct self.
* `Destroy` — first `Release` then `free`.

## Examples

* [Drawable.h](../Engine/Graphics/Draw/Drawable.h)
* [Drawable.c](../Engine/Graphics/Draw/Drawable.c)
* [Sprite.h](../Engine/Graphics/OpenGL/Sprite.h)
* [Sprite.c](../Engine/Graphics/OpenGL/Sprite.c)
* [Struct.h](../Engine/Toolkit/HeaderUtils/Struct.h)

## Sample

Mojoc uses [OOC Spine](../Engine/Extension/Spine) to implement the Java [OOP Spine](https://github.com/EsotericSoftware/spine-runtimes/tree/3.5/spine-libgdx/spine-libgdx/src/com/esotericsoftware/spine).

##
:rocket:
```

`Docs/QuickStart.md`:

```md
## Three Steps To Quick Start

#### Step 1.
To get the source code, there are three options.

* Git clone from <https://github.com/scottcgi/Mojoc.git>
* Download Github master zip file from <https://github.com/scottcgi/Mojoc/archive/master.zip>
* Download released version from <https://github.com/scottcgi/Mojoc/releases>

#### Step 2.

Running sample [SuperLittleRed](../Samples/SuperLittleRed), debugging on phone.

  * [IOS Folder](../Samples/SuperLittleRed/IOS) is XCode project that all set up well, just open it with XCode. 
  * [Android Folder](../Samples/SuperLittleRed/Android) is AndroidStudio project that all set up well, just open it with AndroidStudio.
  * The only thing that needs to be set is Mojoc platform macro in [Platform.h](../Engine/Toolkit/Platform/Platform.h). 
    ```c
    #define PLATFORM_TARGET PLATFORM_IOS
    #define PLATFORM_TARGET PLATFORM_ANDROID
    ```
  * [Code Folder](../Samples/SuperLittleRed/Code) is sample code shared between android and ios.

The AndroidStudio and Xcode sample source code already references [engine code](../Engine). So any engine code changes will be present in the sample game.

#### Step 3.
Understanding the source code.

* [Code Style](./CodeStyle.md) is unified code writing style that all the source code follows.
* [OOC (Object Oriented C)](./OOC.md)) is the OOP (Object Oriented Programming) model of C language. 
  * Mojoc uses extremely lightweight OOC model that is very easy to understand and use. 
  * Following the OOC rules, the C language can build complex projects, and can organize and reuse large amounts of code.
* [Component Architecture](./ComponentArchitecture.md) is code architecture that supports gameplay logic.
* [Code Details](./CodeDetails.md) to introduce the engine modules and functions of each source file. Through this can understand all the code of Mojoc.

The sample [SuperLittleRed](../Samples/SuperLittleRed) shows all aspects of using Mojoc, including all the above features. So modifying and debugging the source code helps to understand everything about Mojoc.

## Android Studio Bug

The `.C` source code of Mojoc in Android Studio may have a type of error msg — `"Field 'xxx' must be static"`. But this will not affect compile and run.

Obviously, this is an AS bug — that the AS error references the function defined in `.h` file, rather than the static function implemented in the `.c` file.

So, in Xcode everything is fine.

**Finally, this bug was fixed in AS 4.0.0.**

##
:door:
```

`Engine/Application/Application.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-9-4
 * Update   : 2019-1-7
 * Author   : scott.cgi
 */


#include "Engine/Graphics/Graphics.h"
#include "Engine/Audio/Platform/Audio.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Application/Application.h"
#include "Engine/Application/Scheduler.h"
#include "Engine/Toolkit/Utils/Tween.h"
#include "Engine/Graphics/Draw/Drawable.h"
#include "Engine/Extension/Extension.h"
#include "Engine/Physics/Physics.h"
#include "Engine/Physics/PhysicsWorld.h"
#include "Engine/Toolkit/Utils/Coroutine.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Toolkit/Utils/Thread.h"


static struct timespec now;
static struct timespec last;


#define CheckCallback(callback) \
    ALog_A((callback) != NULL, #callback " in Application_MainImpl cannot NULL !")


static void Init()
{
    AToolkit  ->Init();
    APhysics  ->Init();
    AExtension->Init();
    AAudio    ->Init();
    AComponent->Init(AApplication->rootComponent);

    // entry called
    Application_MainImpl();

    CheckCallback(AApplication->callbacks->OnReady);
    CheckCallback(AApplication->callbacks->OnPause);
    CheckCallback(AApplication->callbacks->OnResume);
    CheckCallback(AApplication->callbacks->OnDestroy);
    CheckCallback(AApplication->callbacks->OnResized);
    CheckCallback(AApplication->callbacks->OnSaveData);

    // start clock
    clock_gettime(CLOCK_MONOTONIC, &last);
}


#undef CheckCallback


static void Loop()
{
    clock_gettime(CLOCK_MONOTONIC, &now);
    float deltaSeconds = (float) ((now.tv_nsec - last.tv_nsec) * 0.000000001 + (now.tv_sec - last.tv_sec));
    last               =  now;

    APhysicsWorld->Update(deltaSeconds);
    ATween       ->Update(deltaSeconds);
    AScheduler   ->Update(deltaSeconds);
    ACoroutine   ->Update(deltaSeconds);
    AAudio       ->Update(deltaSeconds);

    // root update
    AComponent->Update(AApplication->rootComponent, deltaSeconds);

    // rendering
    ADrawable->Render();
}


static void Resized(int width, int height)
{
    AGLTool->SetSize(width, height);
    AApplication->callbacks->OnResized(width, height);
}


static void Ready(int width, int height)
{
    Resized(width, height);
    AGraphics->Init();
    AApplication->callbacks->OnReady();
}


static void Pause()
{
    AApplication->callbacks->OnPause();
}


static void Resume()
{
    AApplication->callbacks->OnResume();
    // restart clock
    clock_gettime(CLOCK_MONOTONIC, &last);
}


static void Destroy()
{
    AApplication->callbacks->OnDestroy();
}


static void Touch(int fingerID, float pixelX, float pixelY, InputTouchType inputTouchType)
{
    AComponent->SendMessage
    (
        AApplication->rootComponent,
        AApplication,
        ComponentMsg_OnTouch,
        AArray_Make(InputTouch*, 1, AInput->SetTouch(fingerID, pixelX, pixelY, inputTouchType))
    );
}


static void Touches(int fingerIDs[], float pixelXs[], float pixelYs[], int touchesCount, InputTouchType inputTouchType)
{
    InputTouch* touches[touchesCount];

    for (int i = 0; i < touchesCount; ++i)
    {
        touches[i] = AInput->SetTouch(fingerIDs[i], pixelXs[i], pixelYs[i], inputTouchType);
    }

    AComponent->SendMessage
    (
        AApplication->rootComponent,
        AApplication,
        ComponentMsg_OnTouch,
        (Array(InputTouch*)[1]) {touches, touchesCount}
    );
}


void* SaveDataRun(void* param)
{
    AApplication->callbacks->OnSaveData(param);
    return NULL;
}

static void SaveData(void* param)
{
    AThread->StartThread(SaveDataRun, param);
}


struct AApplication AApplication[1] =
{{
     .callbacks =
     {{
         .OnReady    = NULL,
         .OnPause    = NULL,
         .OnResume   = NULL,
         .OnDestroy  = NULL,
         .OnResized  = NULL,
         .OnSaveData = NULL,
     }},

     .Init           = Init,
     .Loop           = Loop,
     .Ready          = Ready,
     .Resized        = Resized,
     .Pause          = Pause,
     .Resume         = Resume,
     .Destroy        = Destroy,
     .Touch          = Touch,
     .Touches        = Touches,
     .SaveData       = SaveData,
}};


```

`Engine/Application/Application.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-9-4
 * Update   : 2019-1-25
 * Author   : scott.cgi
 */


#ifndef APPLICATION_H
#define APPLICATION_H


#include "Engine/Application/Component.h"
#include "Engine/Application/Input.h"


/**
 * ComponentState subject.
 *
 * AApplication receive this type of subject message,
 * then the OnMessage called for handle,
 * and these messages callback from target platform.
 */
enum
{
    /**
     * When touch event happened.
     *
     * sender   : AApplication
     * extraData: Array(InputTouch*)*, the index of array not corresponding to fingerID.
     */
    ComponentMsg_OnTouch,
};


//----------------------------------------------------------------------------------------------------------------------


/**
 * Application lifecycle callbacks, not running in rendering thread.
 */
typedef struct
{
    /**
     * Callback when application window ready that can rendering.
     */
    void (*OnReady)            (void);

    /**
     * Callback when application going into the background.
     */
    void (*OnPause)            (void);

    /**
     * Callback when application going into the foreground.
     */
    void (*OnResume)           (void);

    /**
     * Callback when application is being destroyed.
     */
    void (*OnDestroy)          (void);

    /**
     * Callback when application surface size changed.
     */
    void (*OnResized)          (int width, int height);

    /**
     * Callback when application request save persistent data,
     * or AApplication->SaveData(param) called manually，
     * and this method running in a detached thread.
     *
     * param: pass by AApplication->SaveData,
     *       if application request save data then it will be NULL
     */
    void (*OnSaveData)         (void* param);
}
ApplicationCallbacks;


//----------------------------------------------------------------------------------------------------------------------


/**
 * Control Application and interact with the native platform.
 */
struct AApplication
{
    /**
     * Root Component after application Ready can add child,
     * and everything from here.
     */
    Component             rootComponent[1];

    /**
     * Application life cycle callbacks.
     */
    ApplicationCallbacks  callbacks[1];

    /* These functions called in target platform. */

    /**
     * Init each modules when application create.
     */
    void (*Init)    (void);

    /**
     * Loop called every frame.
     */
    void (*Loop)    (void);

    /**
     * Called when ready to rendering.
     */
    void (*Ready)   (int width, int height);

    /**
     * Called when window resized.
     */
    void (*Resized) (int width, int height);

    /**
     * Called when application pause.
     */
    void (*Pause)   (void);

    /**
     * Called when application resume from pause.
     */
    void (*Resume)  (void);

    /**
     * Called when application destroyed.
     */
    void (*Destroy) (void);

    /**
     * Called when received one touch event.
     * touch event will convert to Array(InputTouch*)*,
     * and send to rootComponent with ComponentMsg_OnTouch.
     *
     * fingerID      : identify touch finger
     * pixelX        : screen pixel x
     * pixelY        : screen pixel y
     * inputTouchType: touch event type
     */
    void (*Touch)   (int fingerID, float pixelX, float pixelY, InputTouchType inputTouchType);

    /**
     * Called when received multiple touches event.
     * touches event will convert to Array(InputTouch*)*,
     * and send to rootComponent with ComponentMsg_OnTouch.
     */
    void (*Touches) (int fingerIDs[], float pixelXs[], float pixelYs[], int touchesCount, InputTouchType inputTouchType);

    /**
     * Callback when application request save persistent data,
     * or can called manually if need to save persistent data,
     * and this method will start a detached thread to execute ApplicationCallbacks->OnSaveData.
     *
     * param: if application request call this method then pass NULL
     */
    void (*SaveData)(void* param);
};


extern struct AApplication AApplication[1];


/**
 * This function must be implemented to set the methods of ApplicationCallbacks,
 * and it will be called on very first entry.
 */
extern void Application_MainImpl(void);


/**
 * Append child to rootComponent.
 */
static inline void AApplication_AppendChild(Component* child)
{
    AComponent->AppendChild(AApplication->rootComponent, child);
}


/**
 * Add child to rootComponent.
 */
static inline void AApplication_AddChild(Component* child, int order)
{
    AComponent->AddChild(AApplication->rootComponent, child, order);
}


#endif

```

`Engine/Application/Component.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-8-19
 * Update   : 2019-1-27
 * Author   : scott.cgi
 */


#include <string.h>
#include <stdlib.h>
#include "Engine/Toolkit/Utils/ArrayIntSet.h"
#include "Engine/Application/Component.h"
#include "Engine/Toolkit/Platform/Log.h"


static void Init(Component* outComponent)
{
    AUserData_Init(outComponent->userData);

    outComponent->order        = 0;
    outComponent->deltaOrder   = 100;
    outComponent->parent       = NULL;
    outComponent->isActive     = true;

    AArrayIntMap->Init(sizeof(Component*), outComponent->childMap);
    AArrayIntSet->Init(outComponent->observerSet);
    AArrayIntMap->InitWithCapacity(sizeof(ComponentState*), 1, outComponent->stateMap);

    outComponent->stateMap->elementList->increase = 5;
    outComponent->defaultState = AComponent->AddState(outComponent, ComponentState_Default, NULL, NULL);
    outComponent->curState     = outComponent->defaultState;
    outComponent->preState     = outComponent->defaultState;
}



static Component* Create()
{
    Component* component = malloc(sizeof(Component));
    Init(component);

    return component;
}


static void Release(Component* component)
{
    AArrayIntMap->Release(component->childMap);
    AArrayIntSet->Release(component->observerSet);

    for (int i = 0; i < component->stateMap->elementList->size; ++i)
    {
        free(AArrayIntMap_GetAt(component->stateMap, i, ComponentState*));
    }

    AArrayIntMap->Release(component->stateMap);

    component->defaultState = NULL;
    component->curState     = NULL;
    component->preState     = NULL;
}


//----------------------------------------------------------------------------------------------------------------------


static void AddChild(Component* parent, Component* child, int order)
{
    ALog_A(parent != NULL && child != NULL, "AComponent AddChild failed, parent and child cannot NULL");
    ALog_A(child->parent == NULL,           "AComponent AddChild failed, child already has parent");

    if (AArrayIntMap_TryPut(parent->childMap, order, child) != NULL)
    {
        child->order  = order;
        child->parent = parent;
    }
    else
    {
        ALog_A(false, "AComponent AddChild failed, order = %d already exist", order);
    }
}


static void AppendChild(Component* parent, Component* child)
{
    ALog_A(parent != NULL && child != NULL, "AComponent AppendChild failed, parent and child cannot NULL");

    int order;

    if (parent->childMap->elementList->size == 0)
    {
        order = parent->deltaOrder;
    }
    else
    {
        order = AArrayIntMap_GetAt
                (
                    parent->childMap,
                    parent->childMap->elementList->size - 1,
                    Component*
                )
                ->order + parent->deltaOrder;
    }

    AddChild(parent, child, order);
}


static void RemoveChild(Component* parent, Component* child)
{
    ALog_A(parent!= NULL && child != NULL, "AComponent RemoveChild failed, parent and child cannot NULL");

    bool isRemoved = AArrayIntMap->TryRemove(parent->childMap, child->order);

    ALog_A
    (
        isRemoved,
        "AComponent cannot found child by order = %d, "
        "may forget called ReorderAllChildren after changed order",
        child->order
    );

    child->parent = NULL;
}


static void RemoveAllChildren(Component* parent)
{
    ALog_A(parent != NULL, "AComponent RemoveAllChildren failed, parent cannot NULL");

    for (int i = 0; i < parent->childMap->elementList->size; ++i)
    {
        Component* child = AArrayIntMap_GetAt(parent->childMap, i, Component*);
        child->parent    = NULL;
    }

    AArrayIntMap->Clear(parent->childMap);
}


static int Compare(const void* a, const void* b)
{
    int keyA = (int) (*(ArrayIntMapElement**) a)->key;
    int keyB = (int) (*(ArrayIntMapElement**) b)->key;
    ALog_A(keyA != keyB, "AComponent ReorderAllChildren failed, two child has same order = %d", keyA);

    return keyA - keyB;
}


static void ReorderAllChildren(Component* parent)
{
    // renew all children key
    for (int i = 0; i < parent->childMap->elementList->size; ++i)
    {
        ArrayIntMapElement* element = AArrayList_Get(parent->childMap->elementList, i, ArrayIntMapElement*);
        element->key                = (*(Component**) element->valuePtr)->order;
    }

    qsort
    (
        parent->childMap->elementList->elementArr->data,
        (size_t) parent->childMap->elementList->size,
        sizeof(ArrayIntMapElement*),
        Compare
    );
}


//----------------------------------------------------------------------------------------------------------------------


static void AddObserver(Component* sender, Component* observer)
{
    ALog_A(sender != NULL && observer != NULL, "AComponent AddObserver failed, sender and observer cannot NULL");

    if (AArrayIntSet->TryAdd(sender->observerSet, (intptr_t) observer) == false)
    {
        ALog_A(false, "AComponent AddObserver failed, observer %p already exist in sender", observer);
    }
}


static void RemoveObserver(Component* sender, Component* observer)
{
    ALog_A(sender != NULL && observer != NULL, "AComponent RemoveObserver failed, sender and observer cannot NULL");

    bool isRemoved = AArrayIntSet->TryRemove(sender->observerSet, (intptr_t) observer);

    ALog_A
    (
        isRemoved,
        "AComponent RemoveObserver sender cannot found observer = %p",
        observer
    );
}


static bool SendMessage(Component* component, void* sender, int subject, void* extraData)
{
    if (component->isActive)
    {
        if(component->curState->OnMessage != NULL)
        {
            if (component->curState->OnMessage(component, sender, subject, extraData))
            {
                // stop message passing
                return true;
            }
        }

        // the order bigger the response first
        for (int i = component->childMap->elementList->size - 1; i > -1 ; --i)
        {
            if
            (
                // if in OnMessage removed parent child, the i index may overflow
                AComponent->SendMessage
                (
                    AArrayIntMap_GetAt(component->childMap, i, Component*),
                    sender,
                    subject,
                    extraData
                )
            )
            {
                // stop message passing
                return true;
            }
        }
    }

    return false;
}


static void Notify(Component* sender, int subject, void* extraData)
{
    ALog_A(sender != NULL, "AComponent Notify failed, sender cannot NULL");

    if (sender->isActive)
    {
        for (int i = 0; i < sender->observerSet->elementList->size; ++i)
        {
            Component* observer = AArrayList_Get(sender->observerSet->elementList, i, Component*);

            if (observer->isActive && observer->curState->OnMessage != NULL)
            {
                observer->curState->OnMessage(observer, sender, subject, extraData);
            }
        }
    }
}


//----------------------------------------------------------------------------------------------------------------------


static void SetState(Component* component, int stateID)
{
    if (component->isActive)
    {
        ComponentState* state = AArrayIntMap_Get(component->stateMap, stateID, ComponentState*);
        ALog_A(state != NULL, "AComponent SetState not found ComponentState by stateID = %d", stateID);

        if (component->curState->OnMessage != NULL)
        {
            component->curState->OnMessage(component, AComponent, ComponentMsg_OnExit, NULL);
        }

        component->preState = component->curState;
        component->curState = state;

        if (state->OnMessage != NULL)
        {
            state->OnMessage(component, AComponent, ComponentMsg_OnEnter, NULL);
        }
    }
}


static ComponentState* AddState
(
    Component*              component,
    int                     stateID,
    ComponentStateOnMessage OnMessage,
    ComponentStateUpdate    Update
)
{
    ALog_A(component != NULL, "AComponent AddState failed, component cannot NULL");

    int index = AArrayIntMap->GetIndex(component->stateMap, stateID);
    ALog_A(index < 0, "AComponent AddState failed, stateID = %d already exist", stateID);

    ComponentState* state = malloc(sizeof(ComponentState));
    state->id             = stateID;
    state->Update         = Update;
    state->UpdateAfter    = NULL;
    state->OnMessage      = OnMessage;
    AUserData_Init(state->userData);

    AArrayIntMap_InsertAt(component->stateMap, stateID, -index - 1, state);

    return state;
}


//----------------------------------------------------------------------------------------------------------------------


static void SetActive(Component* component, bool isActive)
{
    component->isActive = isActive;

    for (int i = 0; i < component->childMap->elementList->size; ++i)
    {
        AArrayIntMap_GetAt(component->childMap, i, Component*)->isActive = isActive;
    }
}


static void Update(Component* component, float deltaSeconds)
{
    if (component->isActive)
    {
        if (component->curState->Update != NULL)
        {
            component->curState->Update(component, deltaSeconds);
        }

        for (int i = 0;;)
        {
            while (i + 3 < component->childMap->elementList->size)
            {
                AComponent->Update(AArrayIntMap_GetAt(component->childMap, i,     Component*), deltaSeconds);
                AComponent->Update(AArrayIntMap_GetAt(component->childMap, i + 1, Component*), deltaSeconds);
                AComponent->Update(AArrayIntMap_GetAt(component->childMap, i + 2, Component*), deltaSeconds);
                AComponent->Update(AArrayIntMap_GetAt(component->childMap, i + 3, Component*), deltaSeconds);

                i += 4;
            }

            while (i < component->childMap->elementList->size)
            {
                AComponent->Update(AArrayIntMap_GetAt(component->childMap, i++, Component*), deltaSeconds);
            }

            break;
        }

        if (component->curState->UpdateAfter != NULL)
        {
            component->curState->UpdateAfter(component, deltaSeconds);
        }
    }
}


struct AComponent AComponent[1] =
{{
    Create,
    Init,
    Release,

    AddChild,
    AppendChild,
    RemoveChild,
    RemoveAllChildren,
    ReorderAllChildren,

    AddObserver,
    RemoveObserver,
    SendMessage,
    Notify,

    SetState,
    AddState,
    SetActive,
    Update,
}};

```

`Engine/Application/Component.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-8-19
 * Update   : 2019-1-26
 * Author   : scott.cgi
 */


#ifndef COMPONENT_H
#define COMPONENT_H


#include "Engine/Toolkit/Utils/ArrayIntMap.h"
#include "Engine/Toolkit/Utils/ArrayIntSet.h"
#include "Engine/Toolkit/HeaderUtils/UserData.h"


typedef struct Component      Component;
typedef struct ComponentState ComponentState;


/**
 * Component has a State-Machine, message subscription list, and component child list.
 * State-Machine make component can switch self state.
 * message subscription make component can send message to subscriber.
 * components and sub components form a tree structure that make message can delivery to any child.
 *
 * also component can sort children by order, but not draw or render anything.
 * The function of draw or render need to sub component implementation,
 * such as SpriteComponent that is component with sprite,
 * and then the component can draw sprite,
 * the sprite has component's State-Machine, message subscription so on.
 */
struct Component
{
    UserData                              userData[1];

    /**
     * If isActive false Component will not change state, update state, handle and send message.
     */
    bool                                  isActive;

    /**
     * Order in parent children list when add in auto setting.
     * if changed it then ReorderAllChildren will resort Component order in parent list.
     */
    int                                   order;

    /**
     * When append child the order increased by deltaOrder, default 100.
     */
    int                                   deltaOrder;

    /**
     * Component's parent in a tree structure.
     */
    Component*                            parent;

    /**
     * Current active state, default is defaultState.
     */
    ComponentState*                       curState;

    /**
     * Previous active state, default is defaultState.
     */
    ComponentState*                       preState;

    /**
     * Default state when Component created with stateID ComponentState_Default.
     */
    ComponentState*                       defaultState;

    /**
     * Children mapped by Component order.
     */
    ArrayIntMap(order, Component*)        childMap   [1];

    /**
     * Component notification observers.
     */
    ArrayIntSet(Component*)               observerSet[1];

    /**
     * All ComponentStates mapped by ComponentState's id.
     */
    ArrayIntMap(stateID, ComponentState*) stateMap   [1];
};



/**
 * ComponentState stateID.
 */
enum
{
    /**
     * ComponentState default stateID, any other stateID must be different.
     */
    ComponentState_Default = 0
};


/**
 * ComponentState subject.
 *
 * Component's ComponentState may receive this type of subject message,
 * then OnMessage called for handle.
 */
enum
{
    /**
     * When ComponentState enter.
     * 
     * sender   : AComponent
     * extraData: NULL
     */
    ComponentMsg_OnEnter,

    /**
     * When ComponentState exit.
     *
     * sender   : AComponent
     * extraData: NULL
     */
    ComponentMsg_OnExit,
};


/**
 * Component's ComponentState for handle different logic in different states.
 */
struct ComponentState
{
    UserData  userData[1];

    /**
     * Key in Component's stateMap
     */
    int       id;

    /**
     * Active ComponentState called every frame.
     */
    void (*Update)      (Component* component, float deltaSeconds);

    /**
     * After Component's children updated called every frame.
     */
    void (*UpdateAfter) (Component* component, float deltaSeconds);

    /**
     * When message received called.
     * if return true means consumed event then will stop event passing.
     */
    bool (*OnMessage)   (Component* component, void* sender, int subject, void* extraData);
};


typedef void (*ComponentStateUpdate)   (Component* component, float deltaSeconds);
typedef bool (*ComponentStateOnMessage)(Component* component, void* sender, int subject, void* extraData);


/**
 * Manage and control Component.
 */
struct AComponent
{
    /**
     * Create new Component that malloc memory and need to free it manually.
     */
    Component*      (*Create)               (void);

    /**
     * Init Component that memory has already malloc.
     */
    void            (*Init)                 (Component* outComponent);

    /**
     * Free members memory and reset some property values.
     */
    void            (*Release)              (Component* component);

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Add child into parent's children list by order.
     */
    void            (*AddChild)             (Component* parent, Component* child, int order);

    /**
     * Append child and auto set child order by deltaOrder.
     */
    void            (*AppendChild)          (Component* parent, Component* child);

    /**
     * Remove child from parent's children list and reindex other children.
     */
    void            (*RemoveChild)          (Component* parent, Component* child);

    /**
     * Remove all children from parent.
     */
    void            (*RemoveAllChildren)    (Component* parent);

    /**
     * Reorder all children by child's order.
     * we should apply this method after Component order changed. (may after all orders changes have been completed)
     */
    void            (*ReorderAllChildren)   (Component* parent);

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Add observer to sender, will receive notification by sender.
     */
    void            (*AddObserver)          (Component* sender, Component* observer);

    /**
     * Remove observer from sender.
     */
    void            (*RemoveObserver)       (Component* sender, Component* observer);

    /**
     * Send message to component self and children (depth-first traversal),
     * and will call self and children's ComponentState OnMessage method,
     * and the component order bigger the response first.
     * 
     * if any OnMessage return true means consumed event then will stop event passing.
     * if in OnMessage removed parent child will cause error.
     * if component isActive false will do nothing.
     */
    bool            (*SendMessage)          (Component* component, void* sender, int subject, void* extraData);

    /**
     * Notify sender all observers,
     * and will call observers ComponentState OnMessage method.
     *
     * if sender isActive false will do nothing.
     * if observers isActive false will not call OnMessage.
     * if in observers OnMessage removed sender observer will cause error.
     */
    void            (*Notify)               (Component* sender, int subject, void* extraData);

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Change Component current active State.
     * if component isActive false will do nothing.
     */
    void            (*SetState)             (Component* component, int stateID);

    /**
     * Create ComponentState with stateID, and add into Component.
     * the add ComponentState free by Component's Release.
     */
    ComponentState* (*AddState)             (
                                                Component*              component,
                                                int                     stateID,
                                                ComponentStateOnMessage OnMessage,
                                                ComponentStateUpdate    Update
                                            );

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Set Component and all children active state.
     */
    void            (*SetActive)            (Component* component, bool isActive);

    /**
     * Update Component self and children's state that will call ComponentState update method.
     */
    void            (*Update)               (Component* component, float deltaSeconds);
};


extern struct AComponent AComponent[1];


#endif

```

`Engine/Application/Input.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-3-24
 * Update   : 2019-1-25
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Application/Input.h"
#include "Engine/Graphics/OpenGL/GLTool.h"


enum
{
    Finger_Num = 10,
};


#define CheckFingerID(tag, fingerID) \
    ALog_A((fingerID) > -1 && (fingerID) < Finger_Num, "AInput " tag " fingerID = %d invalid", fingerID)


static InputTouch touches[Finger_Num];


static InputTouch* SetTouch(int fingerID, float pixelX, float pixelY, InputTouchType type)
{
    CheckFingerID("SetTouch", fingerID);

    InputTouch* touch = touches + fingerID;
    touch->fingerID   = fingerID;
    touch->x          = AGLTool_ToGLX(pixelX);
    touch->y          = AGLTool_ToGLY(pixelY);
    touch->type       = type;

    return touch;
}


static InputTouch* GetTouch(int fingerID)
{
    CheckFingerID("GetTouch", fingerID);
    return touches + fingerID;
}


#undef CheckFingerID


struct AInput AInput[1] =
{{
    SetTouch,
    GetTouch,
}};

```

`Engine/Application/Input.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-3-24
 * Update   : 2021-2-8
 * Author   : scott.cgi
 */


#ifndef INPUT_H
#define INPUT_H


#include "Engine/Toolkit/HeaderUtils/Define.h"


typedef enum
{
    InputTouchType_Up     = 1,
    InputTouchType_Down   = 2,
    InputTouchType_Move   = 3,
    InputTouchType_Cancel = 4,
}
InputTouchType;


/**
 * Input touch event info.
 */
typedef struct
{
    /* Use openGL coordinate. */
    float          x;
    float          y;

    /**
     * Identify touch point, [0, 9] corresponds to 10 fingers.
     */
    int            fingerID;
    
    InputTouchType type;
}
InputTouch;


/**
 * Manage and control InputTouch.
 */
struct AInput
{
    /**
     * Set InputTouch with fingerID, and later can get by fingerID.
     * the x y is in screen pixel coordinate.
     * return the InputTouch that fingerID associated.
     */
    InputTouch* (*SetTouch)(int fingerID, float pixelX, float pixelY, InputTouchType type);

    /**
     * Get the InputTouch that fingerID associated.
     */
    InputTouch* (*GetTouch)(int fingerID);
};


extern struct AInput AInput[1];


#endif

```

`Engine/Application/Platform/Android/JniTool.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-4-1
 * Update   : 2019-8-1
 * Author   : scott.cgi
 */


#include "Engine/Application/Platform/Android/JniTool.h"


//------------------------
#ifdef IS_PLATFORM_ANDROID
//------------------------


#include <android/native_activity.h>
#include <stdbool.h>
#include "Engine/Toolkit/Platform/Log.h"


extern ANativeActivity* nativeActivity;
static JNIEnv*          envPtr = NULL;


static void Init()
{
    (*nativeActivity->vm)->AttachCurrentThread(nativeActivity->vm, &envPtr, NULL);
}


static JNIEnv* GetEnvPtr()
{
    return envPtr;
}


static inline jclass GetClass(const char* className)
{
    static  jobject   classLoaderObj = NULL;
    static  jmethodID loadClassID    = NULL;

    if (classLoaderObj == NULL)
    {
        jclass    activityCls      = (*envPtr)->FindClass(envPtr, "android/app/NativeActivity");
        jclass    loaderCls        = (*envPtr)->FindClass(envPtr, "java/lang/ClassLoader");

        jmethodID getClassLoaderID = (*envPtr)->GetMethodID
                                     (
                                        envPtr,
                                        activityCls,
                                        "getClassLoader",
                                        "()Ljava/lang/ClassLoader;"
                                     );

        classLoaderObj             = (*envPtr)->CallObjectMethod(envPtr, nativeActivity->clazz, getClassLoaderID);
        loadClassID                = (*envPtr)->GetMethodID
                                     (
                                         envPtr,
                                         loaderCls,
                                         "loadClass",
                                         "(Ljava/lang/String;)Ljava/lang/Class;"
                                     );
    }

    jstring classNameStr = (*envPtr)->NewStringUTF    (envPtr, className);
    jclass  cls          = (*envPtr)->CallObjectMethod(envPtr, classLoaderObj, loadClassID, classNameStr);

    ALog_A(cls != NULL, "AJniTool GetClass cannot load class = %s", className);

    (*envPtr)->DeleteLocalRef(envPtr, classNameStr);

    return cls;
}


static jvalue CallStaticMethod(const char* className, const char* methodName, const char* paramCode, ...)
{
    jclass      cls      = GetClass(className);
    jmethodID   methodID = (*envPtr)->GetStaticMethodID(envPtr, cls, methodName, paramCode);

    const char* p        = paramCode;
    // skip '()' to find out the return type
    while (*p++ != ')');

    va_list args;
    va_start(args, paramCode);
    jvalue  value = {};

    switch (*p)
    {
        case 'V':
            (*envPtr)->CallStaticVoidMethodV             (envPtr, cls, methodID, args);
            break;

        case '[':
        case 'L':
            value.l = (*envPtr)->CallStaticObjectMethodV (envPtr, cls, methodID, args);
            break;

        case 'Z':
            value.z = (*envPtr)->CallStaticBooleanMethodV(envPtr, cls, methodID, args);
            break;

        case 'B':
            value.b = (*envPtr)->CallStaticByteMethodV   (envPtr, cls, methodID, args);
            break;

        case 'C':
            value.c = (*envPtr)->CallStaticCharMethodV   (envPtr, cls, methodID, args);
            break;

        case 'S':
            value.s = (*envPtr)->CallStaticShortMethodV  (envPtr, cls, methodID, args);
            break;

        case 'I':
            value.i = (*envPtr)->CallStaticIntMethodV    (envPtr, cls, methodID, args);
            break;

        case 'J':
            value.j = (*envPtr)->CallStaticLongMethodV   (envPtr, cls, methodID, args);
            break;

        case 'F':
            value.f = (*envPtr)->CallStaticFloatMethodV  (envPtr, cls, methodID, args);
            break;

        case 'D':
            value.d = (*envPtr)->CallStaticDoubleMethodV (envPtr, cls, methodID, args);
            break;

        default:
            ALog_A(false, "AJniTool CallStaticMethod paramCode = %s, illegal", paramCode);
    }

    va_end(args);

    return value;
}


static inline jvalue CallMethodV(jobject object, const char* methodName, const char* paramCode, va_list args)
{
    jmethodID   methodID = (*envPtr)->GetMethodID(envPtr, (*envPtr)->GetObjectClass(envPtr, object), methodName, paramCode);

    const char* p        = paramCode;
    // skip '()' to find out the return type
    while (*p++ != ')');

    jvalue value = {};

    switch (*p)
    {
        case 'V':
            (*envPtr)->CallVoidMethodV             (envPtr, object, methodID, args);
            break;

        case '[':
        case 'L':
            value.l = (*envPtr)->CallObjectMethodV (envPtr, object, methodID, args);
            break;

        case 'Z':
            value.z = (*envPtr)->CallBooleanMethodV(envPtr, object, methodID, args);
            break;

        case 'B':
            value.b = (*envPtr)->CallByteMethodV   (envPtr, object, methodID, args);
            break;

        case 'C':
            value.c = (*envPtr)->CallCharMethodV   (envPtr, object, methodID, args);
            break;

        case 'S':
            value.s = (*envPtr)->CallShortMethodV  (envPtr, object, methodID, args);
            break;

        case 'I':
            value.i = (*envPtr)->CallIntMethodV    (envPtr, object, methodID, args);
            break;

        case 'J':
            value.j = (*envPtr)->CallLongMethodV   (envPtr, object, methodID, args);
            break;

        case 'F':
            value.f = (*envPtr)->CallFloatMethodV  (envPtr, object, methodID, args);
            break;

        case 'D':
            value.d = (*envPtr)->CallDoubleMethodV (envPtr, object, methodID, args);
            break;

        default:
            ALog_A(false, "AJniTool CallMethodV paramCode = %s, illegal", paramCode);
    }

    return value;
}


static jvalue CallMethod(jobject object, const char* methodName, const char* paramCode, ...)
{
    va_list args;
    va_start(args, paramCode);
    jvalue  value  = CallMethodV(object, methodName, paramCode, args);
    va_end  (args);

    return value;
}


static jvalue CallNativeActivityMethod(const char* methodName, const char* paramCode, ...)
{
    va_list args;
    va_start(args, paramCode);
    jvalue  value = CallMethodV(nativeActivity->clazz, methodName, paramCode, args);
    va_end  (args);
    
    return value;
}


//----------------------------------------------------------------------------------------------------------------------


static jvalue GetStaticField(const char* className, const char* fieldName, const char* typeCode)
{
    jclass   cls     = GetClass(className);
    jfieldID fieldID = (*envPtr)->GetStaticFieldID(envPtr, cls, fieldName, typeCode);
    jvalue   value;

    switch (*typeCode)
    {
        case '[':
        case 'L':
            value.l = (*envPtr)->GetStaticObjectField (envPtr, cls, fieldID);
            break;

        case 'Z':
            value.z = (*envPtr)->GetStaticBooleanField(envPtr, cls, fieldID);
            break;

        case 'B':
            value.b = (*envPtr)->GetStaticByteField   (envPtr, cls, fieldID);
            break;

        case 'C':
            value.c = (*envPtr)->GetStaticCharField   (envPtr, cls, fieldID);
            break;

        case 'S':
            value.s = (*envPtr)->GetStaticShortField  (envPtr, cls, fieldID);
            break;

        case 'I':
            value.i = (*envPtr)->GetStaticIntField    (envPtr, cls, fieldID);
            break;

        case 'J':
            value.j = (*envPtr)->GetStaticLongField   (envPtr, cls, fieldID);
            break;

        case 'F':
            value.f = (*envPtr)->GetStaticFloatField  (envPtr, cls, fieldID);
            break;

        case 'D':
            value.d = (*envPtr)->GetStaticDoubleField (envPtr, cls, fieldID);
            break;

        default:
            ALog_A(false, "AJniTool GetStaticField typeCode = %s, illegal", typeCode);
    }

    return value;
}


static inline jvalue GetField(jobject object, const char* fieldName, const char* typeCode)
{
    jfieldID fieldID = (*envPtr)->GetFieldID(envPtr, (*envPtr)->GetObjectClass(envPtr, object), fieldName, typeCode);
    jvalue   value   = {};

    switch (*typeCode)
    {
        case '[':
        case 'L':
            value.l = (*envPtr)->GetObjectField (envPtr, object, fieldID);
            break;

        case 'Z':
            value.z = (*envPtr)->GetBooleanField(envPtr, object, fieldID);
            break;

        case 'B':
            value.b = (*envPtr)->GetByteField   (envPtr, object, fieldID);
            break;

        case 'C':
            value.c = (*envPtr)->GetCharField   (envPtr, object, fieldID);
            break;

        case 'S':
            value.s = (*envPtr)->GetShortField  (envPtr, object, fieldID);
            break;

        case 'I':
            value.i = (*envPtr)->GetIntField    (envPtr, object, fieldID);
            break;

        case 'J':
            value.j = (*envPtr)->GetLongField   (envPtr, object, fieldID);
            break;

        case 'F':
            value.f = (*envPtr)->GetFloatField  (envPtr, object, fieldID);
            break;

        case 'D':
            value.d = (*envPtr)->GetDoubleField (envPtr, object, fieldID);
            break;

        default:
            ALog_A(false, "AJniTool GetField typeCode = %s, illegal", typeCode);
    }

    return value;
}


static jsize GetArrayLength(jarray array)
{
    return (*envPtr)->GetArrayLength(envPtr, array);
}


static jvalue GetArrayAt(jarray array, jint index, char typeChar)
{
    jvalue value = {};

    switch (typeChar)
    {
        case '[':
        case 'L':
            value.l = (*envPtr)->GetObjectArrayElement  (envPtr, array, index);
            break;

        case 'Z':
            value.z = (*envPtr)->GetBooleanArrayElements(envPtr, array, false)[index];
            break;

        case 'B':
            value.b = (*envPtr)->GetByteArrayElements   (envPtr, array, false)[index];
            break;

        case 'C':
            value.c = (*envPtr)->GetCharArrayElements   (envPtr, array, false)[index];
            break;

        case 'S':
            value.s = (*envPtr)->GetShortArrayElements  (envPtr, array, false)[index];
            break;

        case 'I':
            value.i = (*envPtr)->GetIntArrayElements    (envPtr, array, false)[index];
            break;

        case 'J':
            value.j = (*envPtr)->GetLongArrayElements   (envPtr, array, false)[index];
            break;

        case 'F':
            value.f = (*envPtr)->GetFloatArrayElements  (envPtr, array, false)[index];
            break;

        case 'D':
            value.d = (*envPtr)->GetDoubleArrayElements (envPtr, array, false)[index];
            break;

        default:
            ALog_A(false, "AJniTool GetArrayAt typeChar = %c, illegal", typeChar);
    }

    return value;
}


static jvalue GetNativeActivityField(const char* fieldName, const char* typeCode)
{
    return GetField(nativeActivity->clazz, fieldName, typeCode);
}


static int GetSignHashCode()
{
    jobject packageManager = CallNativeActivityMethod
                             (
                                 "getPackageManager",
                                 "()Landroid/content/pm/PackageManager;"
                             ).l;

    jstring packageName    = CallNativeActivityMethod
                             (
                                 "getPackageName",
                                 "()Ljava/lang/String;"
                             ).l;

    jobject packageInfo    = CallMethod
                             (
                                 packageManager,
                                 "getPackageInfo",
                                 "(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;",
                                 packageName,
                                 GetStaticField("android/content/pm/PackageManager", "GET_SIGNATURES", "I").i
                             ).l;

    jarray  signatureArr   = GetField(packageInfo, "signatures", "[Landroid/content/pm/Signature;").l;
    jobject signature      = (*envPtr)->GetObjectArrayElement(envPtr, signatureArr, 0);

    return CallMethod(signature, "hashCode", "()I").i;
}


struct AJniTool AJniTool[1] =
{{
    Init,
    GetEnvPtr,

    CallStaticMethod,
    CallMethod,
    CallNativeActivityMethod,

    GetStaticField,
    GetField,
    GetArrayLength,
    GetArrayAt,
    GetNativeActivityField,

    GetSignHashCode,
}};


//---------------------------
#endif // IS_PLATFORM_ANDROID
//---------------------------


```

`Engine/Application/Platform/Android/JniTool.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-4-1
 * Update   : 2019-7-30
 * Author   : scott.cgi
 */


#ifndef JNI_TOOL_H
#define JNI_TOOL_H


#include "Engine/Toolkit/Platform/Platform.h"


//------------------------
#ifdef IS_PLATFORM_ANDROID
//------------------------


#include <jni.h>
#include "Engine/Toolkit/HeaderUtils/Define.h"


/**
 * The AJniTool must Called in game thread, not main thread.
 * the main thread Env is nativeActivity->env, and work in ANativeActivityCallbacks.
 *
 * className : pass to FindClass which is java class name with package such as: "java/lang/ClassLoader"
 * methodName: java class/object method name such as: "getClassLoader"
 * paramCode : java class/object method arguments such as: "(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;"
 * ...       : varargs parameter which are method parameters.
 *
 * typeCode  : java class/object field type such as: "Landroid/content/pm/PackageInfo;", "I"
 * typeChar  : java class/object field type such as: 'L', 'B', 'I', 'V' (void)
 *
 * jvalue    : '[' - l - Array (Object)
 *             'L' - l - Object
 *             'Z' - z - Boolean
 *             'B' - b - Byte
 *             'C' - c - Char
 *             'S' - s - Short
 *             'I' - i - Int
 *             'J' - j - Long (in C is long long type)
 *             'F' - f - Float
 *             'D' - d - Double
 *
 * 
 * Important tips:
 * - if the param of java method is String, then you must pass the jstring (not char*) to "paramCode".
 * - if JNI calls cannot find a method or field, may consider "code proguard" settings.
 */
struct AJniTool
{
    /**
     * Called by NativeGlue for init a thread env, and AJniTool work with this env.
     */
    void    (*Init)                     ();

    /**
     * Get the thread evn of AJniTool.
     */
    JNIEnv* (*GetEnvPtr)                ();

    /**
     * Call java class static method.
     */
    jvalue  (*CallStaticMethod)        (const char* className, const char* methodName, const char* paramCode, ...);

    /**
     * Call java object method.
     * the object is any instance of a java class.
     */
    jvalue  (*CallMethod)              (jobject     object,    const char* methodName, const char* paramCode, ...);

    /**
     * Call the method of NativeActivity (or the Activity inherits NativeActivity) instance.
     */
    jvalue  (*CallNativeActivityMethod)(const char* methodName, const char* paramCode, ...);

    /**
     * Get class static field.
     */
    jvalue  (*GetStaticField)          (const char* className,  const char* fieldName,  const char* typeCode);

    /**
     * Get java object field.
     */
    jvalue  (*GetField)                (jobject object, const char* fieldName, const char* typeCode);

    /**
     * Get java object Array field length.
     * the array is jobject which GetStaticField/GetField returned.
     */
    jsize   (*GetArrayLength)          (jarray array);

    /**
     * Get java object Array field element at index.
     * the array is jobject which GetStaticField/GetField returned.
     */
    jvalue  (*GetArrayAt)              (jarray array, jint index, char typeChar);

    /**
     * Get the field of NativeActivity (or the Activity inherits NativeActivity) instance.
     */
    jvalue  (*GetNativeActivityField)  (const char* fieldName, const char* typeCode);

    /**
     * Get hash code from apk signature (work only in Android).
     */
    int     (*GetSignHashCode)         ();
};


extern struct AJniTool AJniTool[1];


//---------------------------
#endif // IS_PLATFORM_ANDROID
//---------------------------


#endif
```

`Engine/Application/Platform/Android/NativeGlue.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-1-28
 * Update   : 2019-1-7
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Platform.h"


//------------------------
#ifdef IS_PLATFORM_ANDROID
//------------------------


#include <android/asset_manager.h>
#include <android/configuration.h>
#include <android/looper.h>
#include <android/native_activity.h>
#include <stdbool.h>
#include <stdio.h>

#include "Engine/Application/Application.h"
#include "Engine/Toolkit/Utils/FileTool.h"
#include "Engine/Graphics/OpenGL/Platform/EGLTool.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Application/Input.h"
#include "Engine/Toolkit/Utils/Thread.h"
#include "JniTool.h"


/**
 * IDentify input event.
 */
enum
{
    LooperID_Input,
    LooperID_Sensor,
};


/**
 * IDentify main thread callbacks from java client.
 */
typedef volatile enum
{
    MainThread_OnLoop,
    MainThread_OnWait,
    MainThread_OnResized,
    MainThread_OnPause,
    MainThread_OnResume,
    MainThread_OnNeedCreateEGL,
    MainThread_OnDestroy,
}
MainThreadCallback;


/* public to external methods calls. */
ANativeActivity*      nativeActivity       = NULL;
AConfiguration*       nativeActivityConfig = NULL;


/* EGL setting objects. */
static EGLDisplay     eglDisplay;
static EGLSurface     eglSurface;
static EGLContext     eglContext;
static EGLConfig      eglConfig;
static EGLint         eglFormat;


/* NDK support objects. */
static ANativeWindow* nativeWindow;
static ALooper*       looper;
static AInputQueue*   inputQueue;


/**
 * The volatile make sure not optimized by the compiler,
 * because two threads one set and one get,
 * but look at one thread, it seems never modified.
 */
static volatile MainThreadCallback mainThreadCallback = MainThread_OnWait;
static          bool               isNeedCreateEGL    = true;
static          bool               isPaused           = true;


/**
 * One touch event handle.
 */
static void inline Touch(AInputEvent* event, int pointerIndex, InputTouchType inputTouchType)
{
    AApplication->Touch
    (
        AMotionEvent_getPointerId(event, (size_t) pointerIndex),
        AMotionEvent_getX        (event, (size_t) pointerIndex),
        AMotionEvent_getY        (event, (size_t) pointerIndex),
        inputTouchType
    );
}


/**
 * Multiple touches event handle.
 */
static void inline Touches(AInputEvent* event, InputTouchType inputTouchType)
{
    int   count = (int) AMotionEvent_getPointerCount(event);
    int   fingerIDs[count];
    float pixelXs  [count];
    float pixelYs  [count];

    for (int i = 0; i < count; ++i)
    {
        fingerIDs[i] = AMotionEvent_getPointerId(event, (size_t) i);
        pixelXs  [i] = AMotionEvent_getX        (event, (size_t) i);
        pixelYs  [i] = AMotionEvent_getY        (event, (size_t) i);
    }

    AApplication->Touches(fingerIDs, pixelXs, pixelYs, count, inputTouchType);
}


/**
 * Process the input event.
 * return 0 event not handled.
 * return 1 event handled.
 */
static inline int32_t OnInputEvent(AInputEvent* event)
{
    switch (AInputEvent_getType(event))
    {
        case AINPUT_EVENT_TYPE_MOTION:
        {
            int32_t action = AMotionEvent_getAction(event);

            switch (action & AMOTION_EVENT_ACTION_MASK)
            {
                // first pointer down
                case AMOTION_EVENT_ACTION_DOWN:
                {
                    Touch(event, 0, InputTouchType_Down);
                    break;
                }

                // not first pointer down
                case AMOTION_EVENT_ACTION_POINTER_DOWN:
                    Touch
                    (
                        event,
                        (action & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >>
                        AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT,
                        InputTouchType_Down
                    );
                    break;

                // first pinter up
                case AMOTION_EVENT_ACTION_UP:
                    Touch(event, 0, InputTouchType_Up);
                    break;

                // not first pointer up
                case AMOTION_EVENT_ACTION_POINTER_UP:
                    Touch
                    (
                        event,
                        (action & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >>
                        AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT,
                        InputTouchType_Up
                    );
                    break;

                case AMOTION_EVENT_ACTION_MOVE:
                    Touches(event, InputTouchType_Move);
                    break;

                case AMOTION_EVENT_ACTION_CANCEL:
                    Touches(event, InputTouchType_Cancel);
                    break;

                default:
                    return 0;
            }

            return 1;
        }

        case AINPUT_EVENT_TYPE_KEY:
            break;

        default:
            break;
    }

    // default continue dispatching event
    return 0;
}


/**
 * Implementations should return 1 to continue receiving callbacks,
 * or 0 to have this file descriptor (fd) and callback unregistered from the looper.
 *
 * events: typically ALOOPER_EVENT_INPUT
 */
static int LooperOnInputEvent(int fd, int events, void* data)
{
    AInputEvent* event;

    while (AInputQueue_getEvent(inputQueue, &event) >= 0)
    {
        // returns 0 if it was not pre-dispatched,
        // meaning you can process it right now.
        // not 0 maybe IME consumed this event.
        if (AInputQueue_preDispatchEvent(inputQueue, event) == 0)
        {
            AInputQueue_finishEvent(inputQueue, event, OnInputEvent(event));
        }
    }

    // continue receiving callbacks
    return 1;
}


static void* LoopThreadRun(void* param)
{
    // attach thread env
    AJniTool->Init();

    looper = ALooper_prepare(0);

    while (true)
    {
        switch (mainThreadCallback)
        {
            case MainThread_OnLoop:
                // handle event
                ALooper_pollAll(0, NULL, NULL, NULL);

                // application main loop
                AApplication->Loop();

                // render buffer
                eglSwapBuffers(eglDisplay, eglSurface);
                continue;

            case MainThread_OnDestroy:
                AApplication->Destroy();
                // wait for OnStart when app destroy in background
                mainThreadCallback = MainThread_OnWait;
                return NULL;

            case MainThread_OnPause: // sometimes before resized
                AApplication->Pause();
                mainThreadCallback = MainThread_OnWait;
                continue;

            case MainThread_OnResume:
                AApplication->Resume();
                mainThreadCallback = MainThread_OnWait;
                break;

            case MainThread_OnNeedCreateEGL:
                // we need create EGL and use openGL in one thread
                AEGLTool->CreateEGL(nativeWindow, &eglDisplay, &eglContext, &eglSurface, &eglConfig);

                // EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is
                // guaranteed to be accepted by ANativeWindow_SetBuffersGeometry()
                // As soon as we picked a EGLConfig, we can safely reconfigure the
                // ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID
                eglGetConfigAttrib(eglDisplay, eglConfig, EGL_NATIVE_VISUAL_ID, &eglFormat);
                
                ANativeWindow_setBuffersGeometry(nativeWindow,  0, 0, eglFormat);

                // app ready to rendering
                AApplication->Ready
                (
                    ANativeWindow_getWidth (nativeWindow),
                    ANativeWindow_getHeight(nativeWindow)
                );
                
                mainThreadCallback = MainThread_OnLoop;
                break;

            case MainThread_OnResized:
                // not need to destroy EGL but only reset window
                AEGLTool->ResetSurface(nativeWindow, eglDisplay, eglContext, eglConfig, &eglSurface);
                ANativeWindow_setBuffersGeometry(nativeWindow, 0, 0, eglFormat);
                AApplication->Resized
                (
                    ANativeWindow_getWidth(nativeWindow),
                    ANativeWindow_getHeight(nativeWindow)
                );
                mainThreadCallback = MainThread_OnLoop;
                break;

            case MainThread_OnWait:
                break;

            default:
                break;
        }
    }
}


/* The following methods callback from ANativeActivity. */

static void OnStart(ANativeActivity* activity)
{
    ALog_D("ANativeActivity OnStart");
}


static void OnResume(ANativeActivity* activity)
{
    ALog_D("ANativeActivity OnResume");
    mainThreadCallback = MainThread_OnResume;
    isPaused           = false;
}


static void* OnSaveInstanceState(ANativeActivity* activity, size_t* outSaveSize)
{
    ALog_D("ANativeActivity OnSaveInstanceState");
    AApplication->SaveData(NULL);
    *outSaveSize = 0;
    
    return NULL;
}


static void OnPause(ANativeActivity* activity)
{
    ALog_D("ANativeActivity OnPause");
    mainThreadCallback = MainThread_OnPause;
    isPaused           = true;
}


static void OnStop(ANativeActivity* activity)
{
    ALog_D("ANativeActivity OnStop");
}


static void OnDestroy(ANativeActivity* activity)
{
    ALog_D("ANativeActivity OnDestroy");
    mainThreadCallback = MainThread_OnDestroy;
    AApplication->SaveData(NULL);
}


static void OnWindowFocusChanged(ANativeActivity* activity, int hasFocus)
{
    ALog_D("ANativeActivity OnWindowFocusChanged");
}


static void OnNativeWindowCreated(ANativeActivity* activity, ANativeWindow* window)
{
    ALog_D("ANativeActivity OnNativeWindowCreated");
    nativeWindow = window;
}


static void OnNativeWindowResized(ANativeActivity* activity, ANativeWindow* window)
{
    ALog_D("ANativeActivity OnNativeWindowResized");

    // when start app and from back to front screen

    if (isNeedCreateEGL == false)
    {
        mainThreadCallback = MainThread_OnResized;
        ALog_D("When OnNativeWindowResized do MainThread_OnResized");
    }
    else
    {
        isNeedCreateEGL    = false;
        mainThreadCallback = MainThread_OnNeedCreateEGL;
        ALog_D("When OnNativeWindowResized do MainThread_OnNeedCreateEGL");
    }
}


static void OnNativeWindowRedrawNeeded(ANativeActivity* activity, ANativeWindow* window)
{
    ALog_D("ANativeActivity OnNativeWindowRedrawNeeded");
    
    if (isPaused == false)
    {
        if (mainThreadCallback == MainThread_OnWait)
        {
            mainThreadCallback = MainThread_OnResized;
            ALog_D("When OnNativeWindowRedrawNeeded do MainThread_OnResized");
        }
    }
}


static void OnNativeWindowDestroyed(ANativeActivity* activity, ANativeWindow* window)
{
    ALog_D("ANativeActivity OnNativeWindowDestroyed");
    mainThreadCallback = MainThread_OnWait;
}


static void OnInputQueueCreated(ANativeActivity* activity, AInputQueue* queue)
{
    ALog_D("ANativeActivity OnInputQueueCreated");
    inputQueue = queue;
    AInputQueue_attachLooper(inputQueue, looper, LooperID_Input, LooperOnInputEvent, NULL);
}


static void OnInputQueueDestroyed(ANativeActivity* activity, AInputQueue* queue)
{
    ALog_D("ANativeActivity OnInputQueueDestroyed");
    AInputQueue_detachLooper(queue);
}


static void OnContentRectChanged(ANativeActivity* activity, const ARect* rect)
{
    ALog_D("ANativeActivity OnContentRectChanged");

    // when start app and lock/unlock screen

    if (isPaused == false)
    {
        if (isNeedCreateEGL == false)
        {
            if (mainThreadCallback != MainThread_OnNeedCreateEGL)
            {
                mainThreadCallback = MainThread_OnResized;
                ALog_D("When OnContentRectChanged do MainThread_OnResized");
            }
        }
    }
}


static void OnConfigurationChanged(ANativeActivity* activity)
{
    ALog_D("ANativeActivity OnConfigurationChanged");
    AConfiguration_fromAssetManager(nativeActivityConfig, activity->assetManager);
}


static void OnLowMemory(ANativeActivity* activity)
{
    ALog_D("ANativeActivity OnLowMemory");
}


/**
 * Called from java native activity when the java activity creating.
 * the func name set by AndroidManifest.xml with meta-data android:name = "android.app.func_name".
 */
void ANativeActivity_OnCreate(ANativeActivity* activity, void* savedState, size_t savedStateSize)
{
    ALog_D("ANativeActivity_OnCreate Start");

    activity->callbacks->onStart                    = OnStart;
    activity->callbacks->onResume                   = OnResume;
    activity->callbacks->onSaveInstanceState        = OnSaveInstanceState;
    activity->callbacks->onPause                    = OnPause;
    activity->callbacks->onStop                     = OnStop;
    activity->callbacks->onDestroy                  = OnDestroy;
    activity->callbacks->onWindowFocusChanged       = OnWindowFocusChanged;
    activity->callbacks->onNativeWindowCreated      = OnNativeWindowCreated;
    activity->callbacks->onNativeWindowResized      = OnNativeWindowResized;
    activity->callbacks->onNativeWindowRedrawNeeded = OnNativeWindowRedrawNeeded;
    activity->callbacks->onNativeWindowDestroyed    = OnNativeWindowDestroyed;
    activity->callbacks->onInputQueueCreated        = OnInputQueueCreated;
    activity->callbacks->onInputQueueDestroyed      = OnInputQueueDestroyed;
    activity->callbacks->onContentRectChanged       = OnContentRectChanged;
    activity->callbacks->onConfigurationChanged     = OnConfigurationChanged;
    activity->callbacks->onLowMemory                = OnLowMemory;

    if (nativeActivity == NULL)
    {
        AApplication->Init();
    }
    else
    {
        // app destroy in background
        AConfiguration_delete(nativeActivityConfig);
    }

    nativeActivity       = activity;
    // create and set AConfiguration by assetManager
    nativeActivityConfig = AConfiguration_new();
    AConfiguration_fromAssetManager(nativeActivityConfig, activity->assetManager);

    // start loop thread for app's render and logic
    AThread->StartThread(LoopThreadRun, NULL);
}


//---------------------------
#endif // IS_PLATFORM_ANDROID
//---------------------------

```

`Engine/Application/Platform/Android/SystemInfo.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2018-12-6
 * Update   : 2019-7-8
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Platform.h"


//------------------------
#ifdef IS_PLATFORM_ANDROID
//------------------------



#include <android/configuration.h>
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Application/Platform/SystemInfo.h"


extern AConfiguration* nativeActivityConfig;


static void GetLanguageCode(char* outLanguageCode)
{
    AConfiguration_getLanguage(nativeActivityConfig, outLanguageCode);
}


struct ASystemInfo ASystemInfo[1] =
{{
    GetLanguageCode,
}};


//---------------------------
#endif // IS_PLATFORM_ANDROID
//---------------------------

```

`Engine/Application/Platform/Android/Vibrator.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2019-8-5
 * Update   : 2019-8-5
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Platform.h"


//------------------------
#ifdef IS_PLATFORM_ANDROID
//------------------------


#include "Engine/Application/Platform/Vibrator.h"
#include "Engine/Application/Platform/Android/JniTool.h"


static void Vibrate(int milliseconds)
{
    jobject vibrator        = AJniTool->CallNativeActivityMethod
                              (
                                  "getSystemService",
                                  "(Ljava/lang/String;)Ljava/lang/Object;",
                                  AJniTool->GetStaticField
                                  (
                                      "android/content/Context",
                                      "VIBRATOR_SERVICE",
                                      "Ljava/lang/String;"
                                  ).l
                              ).l;

    jvalue  vibrationEffect = AJniTool->CallStaticMethod
                              (
                                  "android/os/VibrationEffect",
                                  "createOneShot",
                                  "(JI)Landroid/os/VibrationEffect;",
                                  (long long) milliseconds,
                                  255
                              );

    AJniTool->CallMethod(vibrator, "vibrate", "(Landroid/os/VibrationEffect;)V", vibrationEffect);
}


struct AVibrator AVibrator[1] =
{{
     Vibrate,
}};


//---------------------------
#endif // IS_PLATFORM_ANDROID
//---------------------------

```

`Engine/Application/Platform/IOS/SystemInfo.m`:

```m
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2019-5-8
 * Update   : 2019-8-8
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Platform.h"


//--------------------
#ifdef IS_PLATFORM_IOS
//--------------------


#include <Foundation/Foundation.h>
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Application/Platform/SystemInfo.h"


static void GetLanguageCode(char* outLanguageCode)
{
    NSString* languageCode = [NSLocale preferredLanguages][0];

    if (languageCode != nil)
    {
        outLanguageCode[0] = languageCode.UTF8String[0];
        outLanguageCode[1] = languageCode.UTF8String[1];
    }
    else
    {
        outLanguageCode[0] = 'e';
        outLanguageCode[1] = 'n';
    }
}


struct ASystemInfo ASystemInfo[1] =
{{
    GetLanguageCode,
}};


//-----------------------
#endif // IS_PLATFORM_IOS
//-----------------------

```

`Engine/Application/Platform/IOS/Vibrator.m`:

```m
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2019-8-6
 * Update   : 2021-2-10
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Platform.h"


//--------------------
#ifdef IS_PLATFORM_IOS
//--------------------


#include <AudioToolbox/AudioToolbox.h>
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Application/Platform/Vibrator.h"


static void Vibrate(int milliseconds)
{
    if (milliseconds <= 50)
    {
        // 3D Touch Peek
        AudioServicesPlaySystemSound(1519);
    }
    else
    {
        // 3D Touch Pop
        AudioServicesPlaySystemSound(1520);
    }
}


struct AVibrator AVibrator[1] =
{{
     Vibrate,
}};


//-----------------------
#endif // IS_PLATFORM_IOS
//-----------------------

```

`Engine/Application/Platform/SystemInfo.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2018-12-6
 * Update   : 2019-1-28
 * Author   : scott.cgi
 */


#ifndef DEVICE_INFO_H
#define DEVICE_INFO_H


#include <stdbool.h>


/**
 * Get system info in native platform.
 */
struct ASystemInfo
{
    /**
     * The outLanguageCode will be filled with an array of two characters.
     */
    void (*GetLanguageCode)(char outLanguageCode[2]);
};


extern struct ASystemInfo ASystemInfo[1];


#endif

```

`Engine/Application/Platform/Vibrator.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2019-8-5
 * Update   : 2019-8-5
 * Author   : scott.cgi
 */

#ifndef VIBRATOR_H
#define VIBRATOR_H


/**
 * Control device vibrate.
 *
 * Android: requires <uses-permission android:name="android.permission.VIBRATE"/>
 * IOS    : only support two types that milliseconds in [<= 50 and > 50].
 */
struct AVibrator
{
    void (*Vibrate)(int milliseconds);
};


extern struct AVibrator AVibrator[1];


#endif

```

`Engine/Application/Scheduler.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-1-16
 * Update   : 2019-1-25
 * Author   : scott.cgi
 */


#include <stdlib.h>
#include "Engine/Toolkit/HeaderUtils/Define.h"
#include "Engine/Application/Scheduler.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Toolkit/Utils/ArrayList.h"


static ArrayList(Scheduler*) schedulerRun [1] = AArrayList_Init(Scheduler*, 30);
static ArrayList(Scheduler*) schedulerList[1] = AArrayList_Init(Scheduler*, 30);


static inline Scheduler* GetScheduler(SchedulerUpdate Update, float intervalTime)
{
    ALog_A(Update != NULL, "ASchedule GetScheduler Update must not NULL");

    Scheduler* scheduler = AArrayList_Pop(schedulerList, Scheduler*);

    if (scheduler == NULL)
    {
        scheduler = malloc(sizeof(Scheduler));
    }

    AUserData_Init(scheduler->userData);
    scheduler->currentTime  = 0.0f;
    scheduler->intervalTime = intervalTime;
    scheduler->Update       = Update;

    AArrayList_Add(schedulerRun, scheduler);

    return scheduler;
}


static Scheduler* Schedule(SchedulerUpdate Update, float intervalTime)
{
    Scheduler* scheduler = GetScheduler(Update, intervalTime);
    scheduler->isCancel  = false;
    return scheduler;
}


static Scheduler* ScheduleOnce(SchedulerUpdate Update, float intervalTime)
{
    Scheduler* scheduler = GetScheduler(Update, intervalTime);
    scheduler->isCancel  = true;
    return scheduler;
}


static void Update(float deltaSeconds)
{
    for (int i = schedulerRun->size - 1; i > -1; --i)
    {
        Scheduler* scheduler = AArrayList_Get(schedulerRun, i, Scheduler*);

        if (scheduler->currentTime < scheduler->intervalTime)
        {
            scheduler->currentTime += deltaSeconds;
        }
        else
        {
            scheduler->Update(scheduler, deltaSeconds);

            if (scheduler->isCancel)
            {
                AArrayList->RemoveByLast(schedulerRun, i);
                AArrayList_Add(schedulerList, scheduler);
            }
            else
            {
                scheduler->currentTime = 0.0f;
            }
        }
    }
}


struct AScheduler AScheduler[1] =
{{
    Schedule,
    ScheduleOnce,
    Update,
}};

```

`Engine/Application/Scheduler.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-1-16
 * Update   : 2019-1-25
 * Author   : scott.cgi
 */


#ifndef SCHEDULER_H
#define SCHEDULER_H


#include <stdbool.h>
#include "Engine/Toolkit/HeaderUtils/Define.h"
#include "Engine/Toolkit/HeaderUtils/UserData.h"


typedef struct Scheduler Scheduler;


/**
 * Callback by interval time.
 *
 * scheduler   : caller
 * deltaSeconds: frame delta seconds
 */
typedef void (*SchedulerUpdate)(Scheduler* scheduler, float deltaSeconds);


/**
 * Schedule update function callback by interval time.
 */
struct Scheduler
{
    UserData        userData[1];

    /**
     * Schedule interval time for update method called.
     */
    float           intervalTime;

    /**
     * Whether cancel scheduler, default false.
     * once isCancel set true scheduler will be removed from callback list.
     */
    bool            isCancel;

    /**
     * Current schedule time.
     */
    float           currentTime;

    /**
     * Schedule callback.
     */
    SchedulerUpdate Update;
};


/**
 * Control Scheduler.
 */
struct AScheduler
{
    /**
     * Scheduler to be scheduled by intervalTime.
     */
    Scheduler* (*Schedule)    (SchedulerUpdate Update, float intervalTime);

    /**
     * Only schedule once by intervalTime.
     */
    Scheduler* (*ScheduleOnce)(SchedulerUpdate Update, float intervalTime);

    /**
     * Every frame update by loop.
     */
    void       (*Update)      (float deltaSeconds);
};


extern struct AScheduler AScheduler[1];


#endif

```

`Engine/Audio/Platform/Android/Audio.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-2-16
 * Update   : 2019-1-7
 * Author   : scott.cgi
 */

 
#include "Engine/Toolkit/Platform/Platform.h"


//------------------------
#ifdef IS_PLATFORM_ANDROID
//------------------------


#include <stdlib.h>
#include <SLES/OpenSLES.h>
#include <SLES/OpenSLES_Android.h>

#include "Engine/Toolkit/Utils/ArrayList.h"
#include "Engine/Toolkit/Utils/ArrayStrSet.h"
#include "Engine/Toolkit/Platform/File.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Audio/Platform/Audio.h"


// engine interfaces
static SLObjectItf engineObject    = NULL;
static SLEngineItf engineEngine    = NULL;
// output mix interfaces
static SLObjectItf outputMixObject = NULL;


/**
 * Defined in Audio.h
 */
struct AudioPlayer
{
    SLObjectItf object;
    SLPlayItf   play;
    SLSeekItf   seek;
    SLVolumeItf volume;
    const char* filePath;
    int         waitCallbackCount;
};


static ArrayList  (AudioPlayer*) cacheList    [1] = AArrayList_Init (AudioPlayer*, 20);
static ArrayList  (AudioPlayer*) destroyList  [1] = AArrayList_Init (AudioPlayer*, 20);
static ArrayList  (AudioPlayer*) loopList     [1] = AArrayList_Init (AudioPlayer*, 5);
static ArrayList  (AudioPlayer*) testErrorList[1] = AArrayList_Init (AudioPlayer*, 5);
static ArrayStrSet(filePath)     filePathSet  [1] = ArrayStrSet_Init(filePath,     20);


enum
{
    AudioPlayer_WaitMax  = 120,
    AudioPlayer_WaitOver = -1,
};


#define CheckError(tag, filePath)     \
    ALog_A                            \
    (                                 \
        result == SL_RESULT_SUCCESS,  \
        "Audio " tag " failed, "      \
        "error = %x, file path = %s", \
        result,                       \
        filePath                      \
    )


static void Update(float deltaSeconds)
{
    while (destroyList->size > 0)
    {
        AudioPlayer* player = AArrayList_Pop(destroyList, AudioPlayer*);

        // remove from loopList
        AAudio->SetLoop(player, false);

        (*player->object)->Destroy(player->object);

        player->play   = NULL;
        player->volume = NULL;
        player->seek   = NULL;
        player->object = NULL;

        AArrayList_Add(cacheList, player);
    }

    for (int i = testErrorList->size - 1; i > -1 ; --i)
    {
        AudioPlayer* player = AArrayList_Get(testErrorList, i, AudioPlayer*);

        if (player->waitCallbackCount == AudioPlayer_WaitOver)
        {
            AArrayList->RemoveByLast(testErrorList, i);
        }
        else if (player->waitCallbackCount >= AudioPlayer_WaitMax)
        {
            // player callback not called, maybe E/libOpenSLES: Error after prepare: 1
            AArrayList->RemoveByLast(testErrorList, i);
            (*player->object)->Destroy(player->object);
            AArrayList_Add(cacheList, player);

            ALog_E("AAudio player = %s not callback normal", player->filePath);
        }
        else
        {
            ++player->waitCallbackCount;
        }
    }
}


static void SetLoopPause()
{
    for (int i = 0; i < loopList->size; ++i)
    {
        AAudio->Pause(AArrayList_Get(loopList, i, AudioPlayer*));
    }
}


static void SetLoopResume()
{
    for (int i = 0; i < loopList->size; ++i)
    {
        AAudio->Play(AArrayList_Get(loopList, i, AudioPlayer*));
    }
}


static void Init()
{
    SLresult result;

    // create engine
    result = slCreateEngine(&engineObject, 0, NULL, 0, NULL, NULL);
    CheckError("Init slCreateEngine", "");

    // realize the engine
    result = (*engineObject)->Realize(engineObject, SL_BOOLEAN_TRUE);
    CheckError("Init Realize engineObject", "");

    // get the engine interface, which is needed in order to create other objects
    result = (*engineObject)->GetInterface(engineObject, SL_IID_ENGINE, &engineEngine);
    CheckError("Init GetInterface", "");

    result = (*engineEngine)->CreateOutputMix(engineEngine, &outputMixObject, 0, NULL, NULL);
    CheckError("Init CreateOutputMix", "");

    // realize the output mix
    result = (*outputMixObject)->Realize(outputMixObject, SL_BOOLEAN_FALSE);
    CheckError("Init Realize outputMixObject", "");
}


static SLmillisecond inline GetDuration(AudioPlayer* player)
{
    SLresult      result;
    SLmillisecond msec;

    result = (*player->play)->GetDuration(player->play, &msec);
    CheckError("GetDuration", "");

    return msec;
}


static void PlayerCallback(SLPlayItf caller, void* pContext, SLuint32 event)
{
    AudioPlayer* player = (AudioPlayer*) pContext;

    switch (event)
    {
        case SL_PLAYEVENT_HEADATEND:
            // play finish
            AArrayList_Add(destroyList, player);
            (*player->play)->SetPlayState(player->play, SL_PLAYSTATE_PAUSED);
            player->waitCallbackCount = AudioPlayer_WaitOver;
            break;

        case SL_PLAYEVENT_HEADATNEWPOS:
            // play normal
            player->waitCallbackCount = AudioPlayer_WaitOver;
            // remove SL_PLAYEVENT_HEADATNEWPOS for reduce the number of callback
            (*player->play)->SetCallbackEventsMask(player->play, SL_PLAYEVENT_HEADATEND);
            break;

        default:
            break;
    }
}

static inline void InitPlayer(const char* relativeFilePath, AudioPlayer* player)
{
    off_t start;
    off_t length;
    int   fd = AFile->OpenFileDescriptor(relativeFilePath, &start, &length);

    // configure audio source
    SLDataLocator_AndroidFD locFD     = {SL_DATALOCATOR_ANDROIDFD, fd, start, length};
    SLDataFormat_MIME       formatMME = {SL_DATAFORMAT_MIME, NULL, SL_CONTAINERTYPE_UNSPECIFIED};
    SLDataSource            audioSrc  = {&locFD, &formatMME};

    // configure audio sink
    SLDataLocator_OutputMix locOutMix = {SL_DATALOCATOR_OUTPUTMIX, outputMixObject};
    SLDataSink              audioSnk  = {&locOutMix, NULL};

    // create audio player
    SLInterfaceID           ids[3]    = {SL_IID_SEEK,     SL_IID_PLAY,     SL_IID_VOLUME};
    SLboolean               req[3]    = {SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE};

    SLresult                result    = (*engineEngine)->CreateAudioPlayer
                                                         (
                                                             engineEngine,
                                                             &player->object,
                                                             &audioSrc,
                                                             &audioSnk,
                                                             3, ids, req
                                                         );

    CheckError("CreatePlayer CreateAudioPlayer", relativeFilePath);

    // realize the player
    result = (*player->object)->Realize(player->object, SL_BOOLEAN_FALSE);
    CheckError("CreatePlayer player Realize", relativeFilePath);

    // get the player interface
    result = (*player->object)->GetInterface(player->object, SL_IID_PLAY, &player->play);
    CheckError("CreatePlayer player GetInterface play", relativeFilePath);

    // player callback
    result = (*player->play)->RegisterCallback(player->play, PlayerCallback, player);
    CheckError("CreatePlayer player RegisterCallback", relativeFilePath);

    result = (*player->play)->SetCallbackEventsMask(player->play,  SL_PLAYEVENT_HEADATEND | SL_PLAYEVENT_HEADATNEWPOS);
    CheckError("CreatePlayer player SetCallbackEventsMask", relativeFilePath);

    // get the seek interface
    result = (*player->object)->GetInterface(player->object, SL_IID_SEEK, &player->seek);
    CheckError("CreatePlayer player GetInterface seek", relativeFilePath);

    // disable looping
    result = (*player->seek)->SetLoop(player->seek, SL_BOOLEAN_FALSE, 0, SL_TIME_UNKNOWN);
    CheckError("CreatePlayer SetLoop", relativeFilePath);

    // get the volume interface
    result = (*player->object)->GetInterface(player->object, SL_IID_VOLUME, &player->volume);
    CheckError("CreatePlayer player GetInterface volume", relativeFilePath);

    player->waitCallbackCount = 0;
    player->filePath          = AArrayStrSet->Get(filePathSet, relativeFilePath);
}


static void SetLoop(AudioPlayer* player, bool isLoop)
{
    SLboolean     isLoopEnabled;
    SLmillisecond startPos;
    SLmillisecond endPos;
    (*player->seek)->GetLoop(player->seek, &isLoopEnabled, &startPos, &endPos);

    if (isLoopEnabled == (SLboolean) isLoop)
    {
        return;
    }

    SLresult result = (*player->seek)->SetLoop(player->seek, (SLboolean) isLoop, 0, GetDuration(player));
    CheckError("SetLoop", player->filePath);

    if (isLoop)
    {
        AArrayList_Add(loopList, player);
    }
    else
    {
        for (int i = 0; i < loopList->size; ++i)
        {
            if (player == AArrayList_Get(loopList, i, AudioPlayer*))
            {
                AArrayList->RemoveByLast(loopList, i);
                break;
            }
        }
    }
}


static void SetVolume(AudioPlayer* player, float volume)
{
    ALog_A
    (
        volume >= 0.0f && volume <= 1.0f,
        "AAudio SetVolume volume %f not in [0.0, 1.0], file path = %s",
        volume,
        player->filePath
    );

    SLresult result = (*player->volume)->SetVolumeLevel(player->volume, (SLmillibel) ((1.0f - volume) * -5000.0f));
    CheckError("SetVolume", player->filePath);
}


static void Play(AudioPlayer* player)
{
    // set the player's state
    SLresult result = (*player->play)->SetPlayState(player->play, SL_PLAYSTATE_PLAYING);
    CheckError("Play", player->filePath);
    AArrayList_Add(testErrorList, player);
}


static void Pause(AudioPlayer* player)
{
    // set the player's state
    SLresult result = (*player->play)->SetPlayState(player->play, SL_PLAYSTATE_PAUSED);
    CheckError("Pause", player->filePath);
}


static void Stop(AudioPlayer* player)
{
    // set the player's state
    SLresult result = (*player->play)->SetPlayState(player->play, SL_PLAYSTATE_STOPPED);
    CheckError("Stop", player->filePath);
    AArrayList_Add(destroyList, player);
    player->waitCallbackCount = AudioPlayer_WaitOver;
}


static bool IsPlaying(AudioPlayer* player)
{
    SLuint32 state;
    (*player->play)->GetPlayState(player->play, &state);

    if (state == SL_PLAYSTATE_PLAYING)
    {
        return true;
    }
    else
    {
        return false;
    }
}


static AudioPlayer* GetPlayer(const char* relativeFilePath)
{
    AudioPlayer* player = AArrayList_Pop(cacheList, AudioPlayer*);

    if (player == NULL)
    {
        player = malloc(sizeof(AudioPlayer));
    }

    InitPlayer(relativeFilePath, player);

    return player;
}


static void Destroy(ArrayList(AudioPlayer*)* playerList)
{
    while (playerList->size > 0)
    {
        AudioPlayer* player = AArrayList_Pop(playerList, AudioPlayer*);
        (*player->object)->Destroy(player->object);
    }
}


static void Release()
{
    Destroy(destroyList);
    Destroy(loopList);
    Destroy(testErrorList);

    AArrayList  ->Release(cacheList);
    AArrayList  ->Release(destroyList);
    AArrayList  ->Release(loopList);
    AArrayList  ->Release(testErrorList);
    AArrayStrSet->Release(filePathSet);

    (*outputMixObject)->Destroy(outputMixObject);
    (*engineObject)   ->Destroy(engineObject);
}


struct AAudio AAudio[1] =
{{
    Init,
    Release,
    Update,
    SetLoopPause,
    SetLoopResume,
    GetPlayer,

    SetVolume,
    SetLoop,

    Play,
    Pause,
    Stop,
    IsPlaying,
}};


//---------------------------
#endif // IS_PLATFORM_ANDROID
//---------------------------


```

`Engine/Audio/Platform/Audio.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-2-16
 * Update   : 2019-1-7
 * Author   : scott.cgi
 */


#ifndef AUDIO_H
#define AUDIO_H


#include <stdbool.h>


/**
 * Play one audio file.
 */
typedef struct AudioPlayer AudioPlayer;

/**
 * Manage and control all AudioPlayers.
 */
struct  AAudio
{
    /**
     * Init audio engine.
     */
    void         (*Init)         (void);

    /**
     * Destroy audio engine.
     */
    void         (*Release)      (void);

    /**
     * Every frame update by loop.
     */
    void         (*Update)       (float deltaSeconds);

    /**
     * Pause all looping AudioPlayer.
     */
    void         (*SetLoopPause) (void);

    /**
     * Resume all looping AudioPlayer.
     */
    void         (*SetLoopResume)(void);

    /**
     * AudioPlayer will cache by relativeFilePath.
     *
     * relativeFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    AudioPlayer* (*GetPlayer)    (const char* relativeFilePath);

    /**
     * The volume range in [0.0, 1.0].
     */
    void         (*SetVolume)    (AudioPlayer* player, float volume);
    void         (*SetLoop)      (AudioPlayer* player, bool  isLoop);

    void         (*Play)         (AudioPlayer* player);
    void         (*Pause)        (AudioPlayer* player);
    void         (*Stop)         (AudioPlayer* player);
    bool         (*IsPlaying)    (AudioPlayer* player);
};


extern struct AAudio AAudio[1];


#endif

```

`Engine/Audio/Platform/IOS/Audio.m`:

```m
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-5-4
 * Update   : 2019-1-7
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Platform.h"


//--------------------
#ifdef IS_PLATFORM_IOS
//--------------------


#include <stddef.h>
#include <Foundation/Foundation.h>
#include <AudioToolbox/AudioToolbox.h>
#include <OpenAL/OpenAL.h>

#include "Engine/Audio/Platform/Audio.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Toolkit/Utils/ArrayStrMap.h"
#include "Engine/Toolkit/Utils/ArrayStrSet.h"


typedef struct
{
    ALsizei size;
    ALenum  format;
    ALsizei sampleRate;
    void*   data;
}
AudioData;


static ArrayStrMap(filePath, AudioData*) audioDataMap[1] = AArrayStrMap_Init(AudioData*,  20);
static ArrayList  (AudioPlayer*)         cacheList  [1] = AArrayList_Init  (AudioPlayer*, 20);
static ArrayList  (AudioPlayer*)         destroyList[1] = AArrayList_Init  (AudioPlayer*, 20);
static ArrayList  (AudioPlayer*)         loopList   [1] = AArrayList_Init  (AudioPlayer*, 5 );
static ArrayStrSet(filePath)             filePathSet[1] = ArrayStrSet_Init (filePath,     20);


#define CheckAudioDataError(tag)               \
    ALog_A                                     \
    (                                          \
        error == noErr,                        \
        "AAudio GetAudioData " tag " failed, " \
        "OSStatus error = %x, file path = %s", \
        (int) error,                           \
        relativeFilePath                       \
    )

#define CheckAudioError(tag, filePath)        \
    ALog_A                                    \
    (                                         \
        (error = alGetError()) == AL_NO_ERROR,\
        "AAudio " tag " failed, "             \
        "alGetError = %x, file path = %s",    \
        error,                                \
        filePath                              \
    )


/**
 * The return data will cached in AudioDataMap.
 */
static inline AudioData* GetAudioData(const char* relativeFilePath)
{
    AudioData* audioData = NULL;
    int        index     = AArrayStrMap->GetIndex(audioDataMap, relativeFilePath);

    if (index < 0)
    {
        AudioStreamBasicDescription fileFormat;
        AudioStreamBasicDescription outputFormat;

        SInt64          fileLengthInFrames = 0;
        UInt32          propertySize       = sizeof(fileFormat);
        ExtAudioFileRef audioFileRef       = NULL;
        NSString*       path               = [[NSBundle mainBundle] pathForResource:
                                             [NSString stringWithUTF8String:relativeFilePath] ofType:nil];

        CFURLRef        fileUrl            = CFURLCreateWithString(kCFAllocatorDefault, (CFStringRef) path, NULL);
        OSStatus        error              = ExtAudioFileOpenURL(fileUrl, &audioFileRef);
        CheckAudioDataError("ExtAudioFileOpenURL");

        CFRelease(fileUrl);

        // get the audio data format
        error = ExtAudioFileGetProperty(audioFileRef, kExtAudioFileProperty_FileDataFormat, &propertySize, &fileFormat);
        CheckAudioDataError("ExtAudioFileGetProperty kExtAudioFileProperty_FileDataFormat");

        if (fileFormat.mChannelsPerFrame > 2)
        {
            ALog_E
            (
                "AAudio GetAudioData unsupported format,"
                "channel count = %u is greater than stereo, relativeFilePath = %s",
                (unsigned int) fileFormat.mChannelsPerFrame,
                relativeFilePath
            );
        }

        // set the client format to 16 bit signed integer (native-endian) data
        // maintain the channel count and sample rate of the original source format
        outputFormat.mSampleRate       = fileFormat.mSampleRate;
        outputFormat.mChannelsPerFrame = fileFormat.mChannelsPerFrame;
        outputFormat.mFormatID         = kAudioFormatLinearPCM;
        outputFormat.mBytesPerPacket   = outputFormat.mChannelsPerFrame * 2;
        outputFormat.mFramesPerPacket  = 1;
        outputFormat.mBytesPerFrame    = outputFormat.mChannelsPerFrame * 2;
        outputFormat.mBitsPerChannel   = 16;
        outputFormat.mFormatFlags      = kAudioFormatFlagsNativeEndian  |
                                         kAudioFormatFlagIsPacked       |
                                         kAudioFormatFlagIsSignedInteger;

        // set the desired client (output) data format
        error = ExtAudioFileSetProperty
                (
                    audioFileRef,
                    kExtAudioFileProperty_ClientDataFormat,
                    sizeof(outputFormat),
                    &outputFormat
                );
        CheckAudioDataError("ExtAudioFileSetProperty kExtAudioFileProperty_ClientDataFormat");

        // get the total frame count
        propertySize = sizeof(fileLengthInFrames);
        error        = ExtAudioFileGetProperty
                       (
                           audioFileRef,
                           kExtAudioFileProperty_FileLengthFrames,
                           &propertySize,
                           &fileLengthInFrames
                       );
        CheckAudioDataError("ExtAudioFileGetProperty kExtAudioFileProperty_FileLengthFrames");

        // read all the data into memory
        UInt32 framesToRead = (UInt32) fileLengthInFrames;
        UInt32 dataSize     = framesToRead * outputFormat.mBytesPerFrame;

//----------------------------------------------------------------------------------------------------------------------

        audioData             = malloc(sizeof(AudioData) + dataSize);
        audioData->size       = (ALsizei) dataSize;
        audioData->format     = outputFormat.mChannelsPerFrame > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;
        audioData->sampleRate = (ALsizei) outputFormat.mSampleRate;
        audioData->data       = (char*) audioData + sizeof(AudioData);

        AudioBufferList dataBuffer;
        dataBuffer.mNumberBuffers              = 1;
        dataBuffer.mBuffers[0].mDataByteSize   = dataSize;
        dataBuffer.mBuffers[0].mNumberChannels = outputFormat.mChannelsPerFrame;
        dataBuffer.mBuffers[0].mData           = audioData->data;

        // read the data into an AudioBufferList
        error = ExtAudioFileRead(audioFileRef, &framesToRead, &dataBuffer);
        CheckAudioDataError("ExtAudioFileRead");

        // dispose the ExtAudioFileRef, it is no longer needed
        ExtAudioFileDispose(audioFileRef);

        AArrayStrMap_InsertAt(audioDataMap, relativeFilePath, -index - 1, audioData);
    }
    else
    {
        audioData = AArrayStrMap_GetAt(audioDataMap, index, AudioData*);
    }

    return audioData;
}


#undef CheckAudioDataError


//----------------------------------------------------------------------------------------------------------------------


static ALCdevice*                device                 = NULL;
static ALCcontext*               context                = NULL;
static alBufferDataStaticProcPtr alBufferDataStaticProc = NULL;


/**
 * Defined in Audio.h
 */
struct AudioPlayer
{
    ALuint      sourceId;
    ALuint      bufferId;
    const char* filePath;
};


static void Update(float deltaSeconds)
{
    for (int i = destroyList->size - 1; i > -1; --i)
    {
        AudioPlayer* player = AArrayList_Get(destroyList, i, AudioPlayer*);
        
        ALint state;
        alGetSourcei(player->sourceId, AL_SOURCE_STATE, &state);
        
        if (state == AL_STOPPED)
        {
            alDeleteSources(1, &player->sourceId);
            alDeleteBuffers(1, &player->bufferId);

            player->sourceId = 0;
            player->bufferId = 0;
            player->filePath = NULL;

            AArrayList->Remove(destroyList, i);
            AArrayList_Add(cacheList, player);
        }
    }
}


static void SetLoopPause()
{
    for (int i = 0; i < loopList->size; ++i)
    {
        AAudio->Pause(AArrayList_Get(loopList, i, AudioPlayer*));
    }
}


static void SetLoopResume()
{
    for (int i = 0; i < loopList->size; ++i)
    {
        AAudio->Play(AArrayList_Get(loopList, i, AudioPlayer*));
    }
}


static void Init()
{
    // get static buffer data API
    alBufferDataStaticProc = alcGetProcAddress(NULL, "alBufferDataStatic");
    
    // create a new OpenAL Device
    // pass NULL to specify the system’s default output device
    device = alcOpenDevice(NULL);
    
    if (device != NULL)
    {
        // create a new OpenAL Context
        // the new context will render to the OpenAL Device just created
        context = alcCreateContext(device, 0);
        
        if (context != NULL)
        {
            // make the new context the Current OpenAL Context
            alcMakeContextCurrent(context);
        }
    }
    else
    {
        ALog_E("AAudio Init failed, OpenAL cannot open device");
    }
    
    // clear any errors
    ALenum error;
    CheckAudioError("Init", "");
}


static inline void InitPlayer(const char* relativeFilePath, AudioPlayer* player)
{
    ALenum     error;
    AudioData* audioData = GetAudioData(relativeFilePath);
    
    alGenBuffers(1, &player->bufferId);
    CheckAudioError("InitPlayer generate buffer", relativeFilePath);
    
    // use the static buffer data API
    // the data will not copy in buffer so cannot free data until buffer deleted
    alBufferDataStaticProc(player->bufferId, audioData->format, audioData->data, audioData->size, audioData->sampleRate);
    CheckAudioError("InitPlayer attach audio data to buffer", relativeFilePath);

    alGenSources(1, &player->sourceId);
    CheckAudioError("InitPlayer generate source", relativeFilePath);

    // turn Looping off
    alSourcei(player->sourceId,  AL_LOOPING, AL_FALSE);
    
    // set Source Position
    alSourcefv(player->sourceId, AL_POSITION, (const ALfloat[3]) {0.0f, 0.0f, 0.0f});
    
    // set source reference distance
    alSourcef(player->sourceId,  AL_REFERENCE_DISTANCE, 0.0f);
    
    // attach OpenAL buffer to OpenAL Source
    alSourcei(player->sourceId,  AL_BUFFER, player->bufferId);
    CheckAudioError("InitPlayer attach buffer to source", relativeFilePath);

    // set player name
    player->filePath = AArrayStrSet->Get(filePathSet, relativeFilePath);
}


static void SetLoop(AudioPlayer* player, bool isLoop)
{
    ALint isLoopEnabled;
    alGetSourcei(player->sourceId, AL_LOOPING, &isLoopEnabled);
    
    if (isLoopEnabled == isLoop)
    {
        return;
    }
    
    alSourcei(player->sourceId, AL_LOOPING, (ALint) isLoop);

    // move player from removeList to addList
    
    ArrayList(AudioPlayer*)* addList;
    ArrayList(AudioPlayer*)* removeList;

    if (isLoop)
    {
        addList    = loopList;
        removeList = destroyList;
    }
    else
    {
        addList    = destroyList;
        removeList = loopList;
    }

    for (int i = 0; i < removeList->size; ++i)
    {
        if (player == AArrayList_Get(removeList, i, AudioPlayer*))
        {
            AArrayList->RemoveByLast(removeList, i);
            break;
        }
    }

    AArrayList_Add(addList, player);
}


static void SetVolume(AudioPlayer* player, float volume)
{
    ALog_A
    (
        volume >= 0.0f && volume <= 1.0f,
        "AAudio SetVolume volume %f not in [0.0, 1.0], audio file path = %s",
        volume,
        player->filePath
    );

    alSourcef(player->sourceId, AL_GAIN, volume);
    
    ALenum error;
    CheckAudioError("SetVolume", player->filePath);
}


static void Play(AudioPlayer* player)
{
    alSourcePlay(player->sourceId);
    ALenum error;
    CheckAudioError("Play", player->filePath);
}


static void Pause(AudioPlayer* player)
{
    alSourcePause(player->sourceId);
    ALenum error;
    CheckAudioError("Pause", player->filePath);
}


static void Stop(AudioPlayer* player)
{
    // after alSourceStop call alDeleteSources will cause OpenAL leak OALSource:AddPlaybackMessage
    alSourceStop(player->sourceId);
    ALenum error;
    CheckAudioError("Stop", player->filePath);

    // put player into destroyList
    SetLoop(player, false);
}

static bool IsPlaying(AudioPlayer* player)
{
    ALint state;
    alGetSourcei(player->sourceId, AL_SOURCE_STATE, &state);
    return state == AL_PLAYING;
}


static AudioPlayer* GetPlayer(const char* relativeFilePath)
{
    AudioPlayer* player = AArrayList_Pop(cacheList, AudioPlayer*);
    
    if (player == NULL)
    {
        player = malloc(sizeof(AudioPlayer));
    }
    
    InitPlayer(relativeFilePath, player);
    AArrayList_Add(destroyList, player);
    
    return player;
}


#undef CheckAudioError


static void Release()
{
    // release context
    alcDestroyContext(context);
    // close device
    alcCloseDevice(device);

    AArrayStrMap->Release(audioDataMap);
    AArrayList  ->Release(cacheList);
    AArrayList  ->Release(destroyList);
    AArrayList  ->Release(loopList);
    AArrayStrSet->Release(filePathSet);
}


struct AAudio AAudio[1] =
{{
    Init,
    Release,
    Update,
    SetLoopPause,
    SetLoopResume,
    GetPlayer,

    SetVolume,
    SetLoop,

    Play,
    Pause,
    Stop,
    IsPlaying,
}};


//-----------------------
#endif // IS_PLATFORM_IOS
//-----------------------

```

`Engine/Build/Android/CMakeLists.txt`:

```txt
# Sets the minimum version of CMake required to build the native
# library. You should either keep the default value or only pass a
# value of 3.4.0 or lower.

cmake_minimum_required(VERSION 3.4.1)

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O3 -std=c99")

#####################################################################

add_library(
    PNG
    STATIC
    IMPORTED
)

set_target_properties(
    PNG
    PROPERTIES IMPORTED_LOCATION
    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../Mojoc/Engine/ThirdParty/PNG/Prebuilt/Android/${ANDROID_ABI}/libpng.a
)

#####################################################################

include_directories(
    ../../../
    ../../ThirdParty/PNG/Include/Android/
)

add_library(
    Mojoc STATIC

################ MojocToolkit ####################

    ../../Toolkit/Toolkit.c

    ../../Toolkit/Math/Math.c
    ../../Toolkit/Math/Matrix.c
    ../../Toolkit/Math/TweenEase.c

    ../../Toolkit/Utils/Array.c
    ../../Toolkit/Utils/ArrayList.c
    ../../Toolkit/Utils/ArrayStrMap.c
    ../../Toolkit/Utils/ArrayIntMap.c
    ../../Toolkit/Utils/ArrayIntSet.c
    ../../Toolkit/Utils/ArrayStrSet.c
    ../../Toolkit/Utils/ArrayQueue.c
    ../../Toolkit/Utils/BufferReader.c
    ../../Toolkit/Utils/Json.c
    ../../Toolkit/Utils/Tween.c
    ../../Toolkit/Utils/TweenTool.c
    ../../Toolkit/Utils/Coroutine.c
    ../../Toolkit/Utils/FileTool.c
    ../../Toolkit/Utils/Thread.c

    ../../Toolkit/Platform/Android/File.c

################ MojocGraphics ###################

    ../../Graphics/Graphics.c

    ../../Graphics/OpenGL/Shader/ShaderSprite.c
    ../../Graphics/OpenGL/Shader/ShaderPrimitive.c
    ../../Graphics/OpenGL/Shader/ShaderMesh.c
    ../../Graphics/OpenGL/Shader/Shader.c

    ../../Graphics/OpenGL/Sprite.c

    ../../Graphics/OpenGL/Camera.c
    ../../Graphics/OpenGL/GLPrimitive.c
    ../../Graphics/OpenGL/GLInfo.c
    ../../Graphics/OpenGL/GLTool.c
    ../../Graphics/OpenGL/Texture.c
    ../../Graphics/OpenGL/Mesh.c
    ../../Graphics/OpenGL/SubMesh.c
    ../../Graphics/OpenGL/Platform/EGLTool.c

    ../../Graphics/Draw/Quad.c
    ../../Graphics/Draw/Drawable.c
    ../../Graphics/Draw/Color.c

    ../../Graphics/Utils/Image.c
    ../../Graphics/Tween/TweenDrawable.c

################ MojocPhysics ####################

    ../../Physics/PhysicsWorld.c
    ../../Physics/PhysicsBody.c
    ../../Physics/Physics.c
    ../../Physics/PhysicsCollision.c

################ MojocApplication ################

    ../../Application/Application.c
    ../../Application/Scheduler.c
    ../../Application/Component.c
    ../../Application/Input.c
    ../../Application/Platform/Android/NativeGlue.c
    ../../Application/Platform/Android/JniTool.c
    ../../Application/Platform/Android/SystemInfo.c
    ../../Application/Platform/Android/Vibrator.c

################ MojocExtension ##################

    ../../Extension/Extension.c
        
    ../../Extension/Spine/SkeletonData.c
    ../../Extension/Spine/SkeletonBone.c
    ../../Extension/Spine/Skeleton.c
    ../../Extension/Spine/SkeletonTimeline.c
    ../../Extension/Spine/SkeletonSlot.c
    ../../Extension/Spine/SkeletonAnimationPlayer.c

    ../../Extension/TextureAtlas.c
    ../../Extension/Font.c
    ../../Extension/DrawAtlas.c

################ MojocAudio ######################
    ../../Audio/Platform/Android/Audio.c
)


target_link_libraries(
    Mojoc

    PNG

    android
    EGL
    GLESv3
    log
    z
    OpenSLES
)



```

`Engine/Extension/DrawAtlas.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-1-2017
 * Update   : 2019-2-1
 * Author   : scott.cgi
 */


#include "Engine/Graphics/OpenGL/SubMesh.h"
#include "Engine/Extension/DrawAtlas.h"
#include "Engine/Toolkit/HeaderUtils/Struct.h"
#include "Engine/Toolkit/Platform/Log.h"


static ArrayList(DrawAtlas*) drawAtlasCacheList[1] = AArrayList_Init(DrawAtlas*, 10);


static DrawAtlas* Get(const char* filePath)
{
    TextureAtlas* textureAtlas = ATextureAtlas->Get(filePath);

    ALog_A
    (
        textureAtlas->textureList->size == 1,
        "DrawAtlas not support TextureAtlas has multiple textures"
    );

    DrawAtlas* drawAtlas = AArrayList_Pop(drawAtlasCacheList, DrawAtlas*);

    if (drawAtlas == NULL)
    {
        drawAtlas = malloc(sizeof(DrawAtlas));

        AMesh->InitWithCapacity
        (
            AArrayList_Get(textureAtlas->textureList, 0, Texture*),
            20,
            drawAtlas->mesh
        );

        AArrayList->InitWithCapacity(sizeof(SubMesh*), 20, drawAtlas->quadList);
    }
    else
    {
        AMesh     ->Clear(drawAtlas->mesh);
        AArrayList->Clear(drawAtlas->quadList);
    }

    drawAtlas->textureAtlas = textureAtlas;

    return drawAtlas;
}


static SubMesh* GetQuad(DrawAtlas* drawAtlas, const char* quadName)
{
    TextureAtlasQuad* atlasQuad = ATextureAtlas_GetQuad(drawAtlas->textureAtlas, quadName);
    ALog_A(atlasQuad != NULL, "ADrawAtlas GetQuad not found quadName = %s", quadName);

    SubMesh* subMesh = AArrayList_Pop(drawAtlas->quadList, SubMesh*);

    if (subMesh == NULL)
    {
        // cache more quads into quadList when cache empty
        for (int i = 0; i < 5; ++i)
        {
            subMesh = AMesh->AddChildWithQuad(drawAtlas->mesh, atlasQuad->quad);
            ADrawable_SetInvisible(subMesh->drawable);
            AArrayList_Add(drawAtlas->quadList, subMesh);
        }

        subMesh = AMesh->AddChildWithQuad(drawAtlas->mesh, atlasQuad->quad);
        AMesh->GenerateBuffer(drawAtlas->mesh);
    }
    else
    {
        ADrawable->Init(subMesh->drawable);

        ASubMesh->SetUVWithQuad
        (
            subMesh,
            atlasQuad->quad
        );
    }

    return subMesh;
}


static void Release(DrawAtlas* drawAtlas)
{
    ALog_A
    (
        drawAtlas->textureAtlas != NULL,
        "ADrawAtlas Release drawAtlas %p already released",
        drawAtlas
    );

    // quadList clear by Get function
    for (int i = 0; i < drawAtlas->quadList->size; ++i)
    {
        ADrawable_SetInvisible(AArrayList_Get(drawAtlas->quadList, i, SubMesh*)->drawable);
    }

    drawAtlas->textureAtlas = NULL;
    AArrayList_Add(drawAtlasCacheList, drawAtlas);
}


static void ReleaseQuad(DrawAtlas* drawAtlas, SubMesh* subMesh)
{
    ALog_A
    (
        drawAtlas->mesh == subMesh->parent,
        "ADrawAtlas %s ReleaseQuad drawable not in this drawAtlas",
        drawAtlas->textureAtlas->filePath
    );

    ADrawable_SetInvisible(subMesh->drawable);
    AArrayList_Add(drawAtlas->quadList, subMesh);
}


struct ADrawAtlas ADrawAtlas[1] =
{{
    Get,
    GetQuad,
    Release,
    ReleaseQuad,
}};

```

`Engine/Extension/DrawAtlas.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-1-5
 * Update   : 2019-2-1
 * Author   : scott.cgi
 */


#ifndef DRAW_ATLAS_H
#define DRAW_ATLAS_H


#include "Engine/Extension/TextureAtlas.h"
#include "Engine/Graphics/OpenGL/Mesh.h"


/**
 * Draw with TextureAtlas.
 */
typedef struct
{
    /**
     * The TextureAtlas that DrawAtlas used.
     */
    TextureAtlas*       textureAtlas;

    /**
     * The Mesh that TextureAtlas used.
     */
    Mesh                mesh[1];

    /**
     * Quads in texture which are SubMesh of Mesh.
     */
    ArrayList(SubMesh*) quadList[1];
}
DrawAtlas;


struct ADrawAtlas
{
    /**
     * Get DrawAtlas by filePath.
     *
     * filePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    DrawAtlas* (*Get)          (const char* filePath);
    SubMesh*   (*GetQuad)      (DrawAtlas*  drawAtlas, const char* quadName);

    /**
     * Make drawAtlas can reuse in Get method.
     */
    void       (*Release)      (DrawAtlas* drawAtlas);

    /**
     * Make quad can reuse in GetQuad method.
     */
    void       (*ReleaseQuad)  (DrawAtlas* drawAtlas, SubMesh* subMesh);
};


extern struct ADrawAtlas ADrawAtlas[1];


/**
 * Draw the mesh of atlas.
 */
static inline void ADrawAtlas_Draw(DrawAtlas* drawAtlas)
{
    AMesh_Draw(drawAtlas->mesh);
}


#endif

```

`Engine/Extension/Extension.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-5-4
 * Update   : 2019-2-1
 * Author   : scott.cgi
 */


#include "Engine/Extension/Extension.h"


static void Init()
{
}


struct AExtension AExtension[1] =
{{
    Init,
}};

```

`Engine/Extension/Extension.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-5-4
 * Update   : 2019-2-1
 * Author   : scott.cgi
 */


#ifndef EXTENSION_H
#define EXTENSION_H


#include "Engine/Toolkit/Toolkit.h"


struct AExtension
{
    void (*Init)(void);
};


extern struct AExtension AExtension[1];


#endif

```

`Engine/Extension/Font.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-7-27
 * Update   : 2021-2-8
 * Author   : scott.cgi
 */


#include <stdio.h>
#include <string.h>

#include "Engine/Toolkit/Utils/ArrayIntSet.h"
#include "Engine/Extension/Font.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/SubMesh.h"


static ArrayList(Font*)     fontCacheList[1] = AArrayList_Init(Font*,     5);
static ArrayList(FontText*) textCacheList[1] = AArrayList_Init(FontText*, 30);


static Font* Get(const char* filePath)
{
    TextureAtlas* textureAtlas = ATextureAtlas->Get(filePath);

    ALog_A
    (
        textureAtlas->textureList->size == 1,
        "Font not support TextureAtlas has multiple texture"
    );

    Font* font = AArrayList_Pop(fontCacheList, Font*);

    if (font == NULL)
    {
        font = malloc(sizeof(Font));

        AMesh->InitWithCapacity
        (
            AArrayList_Get(textureAtlas->textureList, 0, Texture*),
            50,
            font->mesh
        );

        AArrayIntSet->Init(font->fontTextSet);
        AArrayList  ->Init(sizeof(SubMesh*), font->unusedSubMeshList);
    }
    else
    {
        AArrayIntSet->Clear(font->fontTextSet);
        AArrayList  ->Clear(font->unusedSubMeshList);
        AMesh       ->Clear(font->mesh);
    }

    font->textureAtlas = textureAtlas;

    return font;
}


static FontText* GetText(Font* font)
{
    FontText* text = AArrayList_Pop(textCacheList, FontText*);

    if (text == NULL)
    {
        text = malloc(sizeof(FontText));
        AArrayList->Init(sizeof(SubMesh*), text->usedSubMeshList);
        text->usedSubMeshList->increase = 10;
    }
    else
    {
        AArrayList->Clear(text->usedSubMeshList);
    }

    // reset drawable
    ADrawable->Init(text->drawable);

    text->alignment   = FontTextAlignment_HorizontalLeft;
    text->charSpacing = 0.0f;
    text->font        = font;
    AArrayIntSet->TryAdd(font->fontTextSet, (intptr_t) text);

    return text;
}


static void Draw(Font* font)
{
    for (int i = 0; i < font->fontTextSet->elementList->size; ++i)
    {
        ADrawable->Draw(AArrayList_Get(font->fontTextSet->elementList, i, FontText*)->drawable);
    }

    AMesh_Draw(font->mesh);
}


static inline TextureAtlasQuad* GetAtlasQuad(FontText* text, const char* str, int index)
{
    TextureAtlasQuad* atlasQuad = ATextureAtlas_GetQuad(text->font->textureAtlas, (char[2]) {str[index], '\0'});

    ALog_A
    (
        atlasQuad != NULL,
        "AFont SetString not found char = %c in TextureAtlas quads = %s",
        str[index],
        text->font->textureAtlas->filePath
    );

    return atlasQuad;
}


static inline void SetNewChar(FontText* text, const char* str, int len)
{
    // set text new char
    for (int i = 0; i < len; ++i)
    {
        TextureAtlasQuad* atlasQuad = GetAtlasQuad(text, str, i);
        SubMesh*          subMesh   = AArrayList_Get(text->usedSubMeshList, i, SubMesh*);

        ASubMesh->SetUVWithQuad
        (
            subMesh,
            atlasQuad->quad
        );
    }
}


static void SetString(FontText* text, const char* str)
{
    ArrayList* children    = text->font->mesh->childList;
    int        len         = (int) strlen(str);

    text->drawable->height = 0.0f;
    text->drawable->width  = 0.0f;

    if (len == text->usedSubMeshList->size)
    {
        SetNewChar(text, str, len);
    }
    else if (len > text->usedSubMeshList->size)
    {
        SetNewChar(text, str, text->usedSubMeshList->size);

        int originalSize = children->size;

        // add chars more than text has
        for (int i = text->usedSubMeshList->size; i < len; ++i)
        {
            TextureAtlasQuad* atlasQuad = GetAtlasQuad(text, str, i);
            SubMesh*          subMesh;

            if (text->font->unusedSubMeshList->size > 0)
            {
                subMesh = AArrayList_Pop(text->font->unusedSubMeshList, SubMesh*);

                ADrawable_SetVisible(subMesh->drawable);
                ADrawable_SetPositionSame2(subMesh->drawable, 0.0f);
                ADrawable_SetColor(subMesh->drawable, COLOR_WHITE_ARRAY);

                ASubMesh->SetUVWithQuad
                (
                    subMesh,
                    atlasQuad->quad
                );

                if (subMesh->drawable->parent != text->drawable)
                {
                    ADrawable_SetParent(subMesh->drawable, text->drawable);
                }
            }
            else
            {
                // not enough SubMesh for text char so add SubMesh
                subMesh = AMesh->AddChildWithQuad(text->font->mesh, atlasQuad->quad);
                ADrawable_SetParent(subMesh->drawable, text->drawable);
            }

            AArrayList_Add(text->usedSubMeshList, subMesh);
        }

        if (originalSize != children->size)
        {
            // if regenerate the SubMesh's drawable the parent must visible,
            // or parent property will lost
            AMesh->GenerateBuffer(text->font->mesh);
        }
    }
    else
    {
        SetNewChar(text, str, len);

        // text has more chars remove it
        for (int i = text->usedSubMeshList->size - 1; i >= len; --i)
        {
            SubMesh* subMesh = AArrayList_Get(text->usedSubMeshList, i, SubMesh*);

            if (ADrawable_CheckVisible(subMesh->drawable))
            {
                ADrawable_SetInvisible(subMesh->drawable);
            }

            AArrayList->Remove(text->usedSubMeshList, i);
            AArrayList_Add(text->font->unusedSubMeshList, subMesh);
        }
    }

    // set text size arrangement and alignment
    // set each char position
    switch (text->alignment)
    {
        case FontTextAlignment_HorizontalLeft:
        {
            for (int i = 0; i < text->usedSubMeshList->size; ++i)
            {
                SubMesh* subMesh = AArrayList_Get(text->usedSubMeshList, i, SubMesh*);

                if (subMesh->drawable->height > text->drawable->height)
                {
                    text->drawable->height = subMesh->drawable->height;
                }

                ADrawable_SetPositionX(subMesh->drawable, text->drawable->width + subMesh->drawable->width / 2);
                text->drawable->width += subMesh->drawable->width + text->charSpacing;
            }

            // remove the end space
            text->drawable->width -= text->charSpacing;
            break;
        }

        case FontTextAlignment_HorizontalRight:
        {
            for (int i = text->usedSubMeshList->size - 1; i > -1; --i)
            {
                SubMesh* subMesh = AArrayList_Get(text->usedSubMeshList, i, SubMesh*);

                if (subMesh->drawable->height > text->drawable->height)
                {
                    text->drawable->height = subMesh->drawable->height;
                }

                ADrawable_SetPositionX(subMesh->drawable, -text->drawable->width - subMesh->drawable->width / 2);
                text->drawable->width += subMesh->drawable->width + text->charSpacing;
            }
            
            // remove the end space
            text->drawable->width -= text->charSpacing;
            break;
        }

        case FontTextAlignment_VerticalTop:
        {
            for (int i = 0; i < text->usedSubMeshList->size; ++i)
            {
                SubMesh* subMesh = AArrayList_Get(text->usedSubMeshList, i, SubMesh*);

                if (subMesh->drawable->width > text->drawable->width)
                {
                    text->drawable->width = subMesh->drawable->width;
                }

                ADrawable_SetPositionY(subMesh->drawable, -text->drawable->height - subMesh->drawable->height / 2);
                text->drawable->height += subMesh->drawable->height + text->charSpacing;
            }

            // remove the end space
            text->drawable->height -= text->charSpacing;
            break;
        }

        case FontTextAlignment_VerticalBottom:
        {
            for (int i = text->usedSubMeshList->size - 1; i > -1; --i)
            {
                SubMesh* subMesh = AArrayList_Get(text->usedSubMeshList, i, SubMesh*);

                if (subMesh->drawable->width > text->drawable->width)
                {
                    text->drawable->width = subMesh->drawable->width;
                }

                ADrawable_SetPositionY(subMesh->drawable, text->drawable->height + subMesh->drawable->height / 2);
                text->drawable->height += subMesh->drawable->height + text->charSpacing;
            }

            // remove the end space
            text->drawable->height -= text->charSpacing;
            break;
        }
    }
}


static void SetInt(FontText* text, int num)
{
    // max int digits count
    char buffer[12];
    sprintf  (buffer, "%d", num);
    SetString(text,   buffer);
}


static void SetFloat(FontText* text, float num)
{
    // max float digits count
    char buffer[20];
    sprintf  (buffer, "%.1f", num);
    SetString(text,   buffer);
}


static void Release(Font* font)
{
    ALog_A(font->textureAtlas != NULL, "AFont Release font %p already Released", font);

    for (int i = 0; i < font->fontTextSet->elementList->size; ++i)
    {
        FontText* text = AArrayList_Get(font->fontTextSet->elementList, i, FontText*);
        text->font     = NULL;
        AArrayList_Add(textCacheList, text);
    }

    font->textureAtlas = NULL;
    AArrayList_Add(fontCacheList, font);
}


static void ReleaseText(FontText* text)
{
    ALog_A(text->font != NULL, "AFont ReleaseText text %p already Released", text);

    for (int i = 0; i < text->usedSubMeshList->size; ++i)
    {
        SubMesh* subMesh = AArrayList_Get(text->usedSubMeshList, i, SubMesh*);
        ADrawable_SetInvisible(subMesh->drawable);
        AArrayList_Add(text->font->unusedSubMeshList, subMesh);
    }

    AArrayIntSet->TryRemove(text->font->fontTextSet, (intptr_t) text);
    ADrawable_SetColor(text->drawable, COLOR_WHITE_ARRAY);
    text->font = NULL;

    AArrayList_Add(textCacheList, text);
}


struct AFont AFont[1] =
{{
    Get,
    GetText,
    Draw,

    SetString,
    SetInt,
    SetFloat,

    Release,
    ReleaseText,
}};

```

`Engine/Extension/Font.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-7-27
 * Update   : 2021-2-8
 * Author   : scott.cgi
 */


#ifndef FONT_H
#define FONT_H


#include "Engine/Toolkit/Utils/ArrayIntSet.h"
#include "Engine/Extension/TextureAtlas.h"
#include "Engine/Graphics/OpenGL/Mesh.h"


/**
 * Font implementation by TextureAtlas.
 */
typedef struct
{
    /**
     * the TextureAtlas that Font used.
     */
    TextureAtlas*          textureAtlas;

    /**
     * The Mesh that textureAtlas used.
     */
    Mesh                   mesh[1];

    /**
     * Cache all FontTexts.
     */
    ArrayIntSet(FontText*) fontTextSet[1];

    /**
     * Font Mesh unused SubMesh list.
     * released FontText's SubMesh will add into this.
     */
    ArrayList  (SubMesh*)  unusedSubMeshList[1];
}
Font;


/**
 * FontText alignment type.
 */
typedef enum
{
    FontTextAlignment_HorizontalLeft,
    FontTextAlignment_HorizontalRight,
    FontTextAlignment_VerticalTop,
    FontTextAlignment_VerticalBottom,
}
FontTextAlignment;


/**
 * The text in font textureAtlas.
 */
typedef struct
{
    /**
     * The base class for provide draw functions.
     */
    Drawable            drawable[1];

    /**
     * Default FontTextAlignment_HorizontalLeft.
     */
    FontTextAlignment   alignment;

    /**
     * The spacing between chars, default 0.
     */
    float               charSpacing;

    /**
     * The Font that FontText belongs to.
     */
    Font*               font;

    /**
     * The SubMesh list that FontText used.
     */
    ArrayList(SubMesh*) usedSubMeshList[1];
}
FontText;


/**
 * Control Font and FontText.
 */
struct AFont
{
    /**
     * Get Font by filePath.
     *
     * filePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    Font*     (*Get)           (const char* filePath);
    FontText* (*GetText)       (Font* font);
    void      (*Draw)          (Font* font);

    void      (*SetString)     (FontText* text, const char* str);
    void      (*SetInt)        (FontText* text, int         num);
    void      (*SetFloat)      (FontText* text, float       num);

    /**
     * Make Font can reuse in Get method,
     * and release all FontTexts.
     */
    void      (*Release)       (Font* font);

    /**
     * Make FontText can reuse in GetText method.
     * and add FontText's SubMesh into Font->unusedSubMeshList.
     */
    void      (*ReleaseText)   (FontText* text);
};


extern struct AFont AFont[1];


/**
 * Set FontText color.
 */
static inline void AFont_SetTextColor(FontText* text, Color* color)
{
    ADrawable_SetColor(text->drawable, color);
}


#endif

```

`Engine/Extension/Spine/Skeleton.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.mdate.
 *
 * Since    : 2013-7-3
 * Update   : 2019-2-14
 * Author   : scott.cgi
 */


#include "Engine/Extension/Spine/Skeleton.h"
#include "Engine/Toolkit/HeaderUtils/Struct.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Toolkit/HeaderUtils/Define.h"
#include "Engine/Extension/Spine/SkeletonTimeline.h"
#include "Engine/Graphics/OpenGL/SubMesh.h"


static inline SubMesh* GetAttachmentSubMesh(Skeleton* skeleton, SkeletonAttachmentData* skeletonAttachmentData)
{
    int meshIndex    = *(int*) (
                                   (char*) skeletonAttachmentData->childPtr +
                                   skeletonAttachmentMeshOffset[skeletonAttachmentData->type]
                               );

    int subMeshIndex = *(int*) (
                                   (char*) skeletonAttachmentData->childPtr +
                                   skeletonAttachmentSubMeshOffset[skeletonAttachmentData->type]
                               );

    return AArrayList_Get
           (
               AArrayList_GetPtr(skeleton->meshList, meshIndex, Mesh)->childList,
               subMeshIndex,
               SubMesh*
           );
}


static inline void InitBone(Skeleton* skeleton, SkeletonData* skeletonData)
{
    Drawable*    root              = skeleton->drawable;
    ArrayStrMap* boneMap           = skeleton->boneMap;

    skeleton->boneArr              = AArray->Create(sizeof(SkeletonBone), skeletonData->boneDataOrderArr->length);
    AArrayStrMap->InitWithCapacity(sizeof(SkeletonBone*), skeletonData->boneDataOrderArr->length, boneMap);

    SkeletonBone*      bones       = skeleton->boneArr->data;
    SkeletonBoneData** bonesData   = skeletonData->boneDataOrderArr->data;

    for (int i = 0; i < skeleton->boneArr->length; ++i)
    {
        SkeletonBoneData* boneData = bonesData[i];
        SkeletonBone*     bone     = bones + i;
        ASkeletonBone->Init(boneData, bone);

        AArrayStrMap_TryPut(boneMap, boneData->name, bone);

        if (boneData->parent == NULL)
        {
            ADrawable_SetParent(bone->drawable, root);
        }
        else
        {
            SkeletonBone* boneParent = AArrayStrMap_Get(boneMap, boneData->parent->name, SkeletonBone*);

            ALog_A(boneParent != NULL, "ASkeleton InitBone bone parent = %s, not found", boneData->parent->name);

            ADrawable_SetParent(bone->drawable, boneParent->drawable);
        }
    }
}


static inline void InitSlot(Skeleton* skeleton, SkeletonData* skeletonData)
{
    ArrayStrMap*       slotMap       = skeleton->slotMap;

    skeleton->slotArr                = AArray->Create(sizeof(SkeletonSlot),  skeletonData->slotDataOrderArr->length);
    skeleton->slotOrderArr           = AArray->Create(sizeof(SkeletonSlot*), skeletonData->slotDataOrderArr->length);

    AArrayStrMap->InitWithCapacity(sizeof(SkeletonSlot*), skeletonData->slotDataOrderArr->length, slotMap);

    SkeletonSlot**     slotOrders    = skeleton->slotOrderArr->data;
    SkeletonSlotData** slotsData     = skeletonData->slotDataOrderArr->data;

    for (int i = 0; i < skeleton->slotArr->length; ++i)
    {
        SkeletonSlotData* slotData   = slotsData[i];
        SkeletonSlot*     slot       = AArray_GetPtr(skeleton->slotArr, i, SkeletonSlot);

        ASkeletonSlot->Init(slotData, skeleton, slot);

        slotOrders[i]                = slot;

        AArrayStrMap_TryPut(slotMap, slotData->name, slot);
    }
}


static void SetSkin(Skeleton* skeleton, const char* skinName)
{
    ArrayStrMap*      skinDataMap = skeleton->skeletonData->skinDataMap;
    SkeletonSkinData* skinData    = AArrayStrMap_Get(skinDataMap, skinName, SkeletonSkinData*);

    ALog_A(skinData != NULL, "ASkeleton SetSkin not found skin by name = %s", skinName);

    if (skeleton->curSkinData == skinData)
    {
        return;
    }

    if (skeleton->curSkinData != skeleton->skeletonData->skinDataDefault)
    {
        // first invisible before skin
        for (int i = 0; i < skeleton->curSkinData->slotAttachmentMap->elementList->size; ++i)
        {
            SkeletonSlot* slot = AArrayStrMap_Get
                                 (
                                    skeleton->slotMap,
                                    AArrayStrMap->GetKey(skeleton->curSkinData->slotAttachmentMap, i),
                                    SkeletonSlot*
                                 );

            if (slot->attachmentData != NULL)
            {
                SubMesh* subMesh = ASkeleton->GetAttachmentSubMesh(slot->skeleton, slot->attachmentData);

                if (subMesh != NULL)
                {
                    ADrawable_SetInvisible(subMesh->drawable);
                }

                slot->attachmentData = NULL;
            }
        }
    }

    for (int i = 0; i < skinData->slotAttachmentMap->elementList->size; ++i)
    {
        SkeletonSlot* slot = AArrayStrMap_Get
                             (
                                 skeleton->slotMap,
                                 AArrayStrMap->GetKey(skinData->slotAttachmentMap, i),
                                 SkeletonSlot*
                             );

        if (slot != NULL && slot->slotData->attachmentName != NULL)
        {
            ASkeletonSlot->SetAttachmentData
            (
                slot,
                AArrayStrMap_Get
                (
                    AArrayStrMap_GetAt(skinData->slotAttachmentMap, i, ArrayStrMap*),
                    slot->slotData->attachmentName,
                    SkeletonAttachmentData*
                )
            );
        }
    }

    skeleton->curSkinData = skinData;
}


static void ResetBones(Skeleton* skeleton)
{
    for (int i = 0; i < skeleton->boneArr->length; ++i)
    {
        ASkeletonBone->SetToSetupPose(AArray_GetPtr(skeleton->boneArr, i, SkeletonBone));
    }
}


static void ResetSlots(Skeleton* skeleton)
{
    for (int i = 0; i < skeleton->slotOrderArr->length; ++i)
    {
        ASkeletonSlot->SetToSetupPose(AArray_Get(skeleton->slotOrderArr, i, SkeletonSlot*));
    }
}


static SkeletonAttachmentData* GetAttachmentData(Skeleton* skeleton, const char* slotName, const char* attachmentName)
{
    SkeletonAttachmentData* attachmentData = ASkeletonData->GetAttachmentDataBySkinData
                                             (
                                                 skeleton->curSkinData,
                                                 slotName,
                                                 attachmentName
                                             );

    if (attachmentData == NULL && skeleton->skeletonData->skinDataDefault != skeleton->curSkinData)
    {
        attachmentData = ASkeletonData->GetAttachmentDataBySkinData
                         (
                             skeleton->skeletonData->skinDataDefault,
                             slotName,
                             attachmentName
                         );
    }

    return attachmentData;
}


static void Release(Skeleton* skeleton)
{
    free(skeleton->boneArr);
    skeleton->boneArr      = NULL;

    free(skeleton->slotArr);
    skeleton->slotArr      = NULL;

    free(skeleton->slotOrderArr);
    skeleton->slotOrderArr = NULL;

    for (int j = 0; j < skeleton->meshList->size; ++j)
    {
        AMesh->Release(AArrayList_GetPtr(skeleton->meshList, j, Mesh));
    }
    
    AArrayList  ->Release(skeleton->meshList);
    AArrayStrMap->Release(skeleton->boneMap);
    AArrayStrMap->Release(skeleton->slotMap);
}


static void Apply(Skeleton* skeleton, SkeletonAnimationData* animationData, float time, float mixPercent)
{
    for (int i = 0; i < animationData->timelineArr->size; ++i)
    {
        SkeletonTimeline* timeline = AArrayList_Get(animationData->timelineArr, i, SkeletonTimeline*);
        timeline->Apply(timeline, skeleton, time, mixPercent);
    }
}


static void Draw(Drawable* drawable)
{
    Skeleton* skeleton = AStruct_GetParent(drawable, Skeleton);

    for (int i = 0; i < skeleton->boneArr->length; ++i)
    {
        ADrawable->Draw(AArray_GetPtr(skeleton->boneArr, i, SkeletonBone)->drawable);
    }

    Mesh* parent    = NULL;
    int   fromIndex = 0;
    int   toIndex   = 0;

    for (int i = 0; i < skeleton->slotOrderArr->length; ++i)
    {
        SkeletonSlot* slot = AArray_Get(skeleton->slotOrderArr, i, SkeletonSlot*);

        if (slot->attachmentData == NULL || slot->attachmentData->type == SkeletonAttachmentDataType_BoundingBox)
        {
            continue;
        }

        SubMesh* subMesh = GetAttachmentSubMesh(skeleton, slot->attachmentData);

        if (subMesh->parent != parent)
        {
            if (parent != NULL)
            {
                AMesh_DrawByIndex(parent, fromIndex, toIndex);
            }

            fromIndex = subMesh->index;
            parent    = subMesh->parent;
        }
        
        toIndex = subMesh->index;
    }

    if (parent != NULL)
    {
        AMesh_DrawByIndex(parent, fromIndex, toIndex);
    }
}


static inline void InitMeshList(Skeleton* skeleton, SkeletonData* skeletonData)
{
    AArrayList->InitWithCapacity(sizeof(Mesh), skeletonData->textureAtlas->textureList->size, skeleton->meshList);

    for (int i = 0; i < skeletonData->textureAtlas->textureList->size; ++i)
    {
        Texture* texture = AArrayList_Get      (skeletonData->textureAtlas->textureList, i, Texture*);
        Mesh*    mesh    = AArrayList_GetPtrAdd(skeleton->meshList, Mesh);

        AMesh->Init(texture, mesh);
    }

    for (int i = 0; i < skeletonData->attachmentDataList->size; ++i)
    {
        SkeletonAttachmentData* attachmentData = AArrayList_Get
                                                 (
                                                     skeletonData->attachmentDataList,
                                                     i,
                                                     SkeletonAttachmentData*
                                                 );
        
        SubMesh* subMesh = NULL;

        switch (attachmentData->type)
        {
            case SkeletonAttachmentDataType_BoundingBox:
                continue;
                
            case SkeletonAttachmentDataType_Region:
            {
                SkeletonRegionAttachmentData* regionAttachmentData = attachmentData->childPtr;
                subMesh                                            = AMesh->AddChildWithQuad
                                                                     (
                                                                        AArrayList_GetPtr
                                                                        (
                                                                            skeleton->meshList,
                                                                            regionAttachmentData->meshIndex,
                                                                            Mesh
                                                                        ),
                                                                        regionAttachmentData->quad
                                                                     );

                if (ASkeletonData->scale != 1.0f)
                {
                    for (int l = 0; l < subMesh->positionArr->length; ++l)
                    {
                        AArray_Get(subMesh->positionArr, l, float) *= ASkeletonData->scale;
                    }

                    subMesh->drawable->width  = regionAttachmentData->width;
                    subMesh->drawable->height = regionAttachmentData->height;
                }

                break;
            }

            case SkeletonAttachmentDataType_SkinnedMesh:
            case SkeletonAttachmentDataType_Mesh:
            {
                SkeletonMeshAttachmentData* meshData;

                if (attachmentData->type == SkeletonAttachmentDataType_SkinnedMesh)
                {
                    meshData = ((SkeletonSkinnedMeshAttachmentData*) attachmentData->childPtr)->meshAttachmentData;
                }
                else
                {
                    meshData = (SkeletonMeshAttachmentData*) attachmentData->childPtr;
                }

                if (meshData->isUVMappedInTexture == false)
                {
                    float texData[Quad_UVNum];
                    AQuad->GetUV
                    (
                        meshData->quad,
                        AArrayList_Get(skeletonData->textureAtlas->textureList, meshData->meshIndex, Texture*),
                        texData
                    );

                    float  left   = texData[0];
                    float  top    = texData[1];
                    float  width  = texData[4] - left;
                    float  height = texData[5] - top;
                    float* uvs    = meshData->uvArr->data;
                    
                    for (int l = 0; l < meshData->uvArr->length; l += 2)
                    {
                        uvs[l]     = left + uvs[l]     * width;
                        uvs[l + 1] = top  + uvs[l + 1] * height;
                    }

                    meshData->isUVMappedInTexture = true;
                }

                subMesh = AMesh->AddChildWithData
                          (
                              AArrayList_GetPtr
                              (
                                  skeleton->meshList,
                                  meshData->meshIndex,
                                  Mesh
                              ),
                              meshData->vertexArr,
                              meshData->uvArr,
                              meshData->triangleArr
                          );

                if (ASkeletonData->scale != 1.0f)
                {
                    subMesh->drawable->width  = meshData->width;
                    subMesh->drawable->height = meshData->height;
                }

                break;
            }
        }

        // first born invisible
        ADrawable_SetInvisible(subMesh->drawable);
    }

    for (int i = 0; i < skeleton->meshList->size; ++i)
    {
        AMesh->GenerateBuffer(AArrayList_GetPtr(skeleton->meshList, i, Mesh));
    }
}


static void Init(SkeletonData* skeletonData, Skeleton* outSkeleton)
{
    ADrawable->Init(outSkeleton->drawable);

    outSkeleton->drawable->Draw    = Draw;
    outSkeleton->drawable->width   = skeletonData->width;
    outSkeleton->drawable->height  = skeletonData->height;
    outSkeleton->skeletonData      = skeletonData;
    outSkeleton->curSkinData       = outSkeleton->skeletonData->skinDataDefault;
    outSkeleton->FireSkeletonEvent = NULL;

    InitMeshList(outSkeleton, skeletonData);
    InitBone    (outSkeleton, skeletonData);
    InitSlot    (outSkeleton, skeletonData);

    // Release(outSkeleton);
    // ALog_A(false, "stop");
}


static Skeleton* Create(SkeletonData* skeletonData)
{
    Skeleton* skeleton = malloc(sizeof(Skeleton));
    Init(skeletonData, skeleton);

    return skeleton;
}


struct ASkeleton ASkeleton[1] =
{{
    Create,
    Init,
    Release,
    SetSkin,
    ResetBones,
    ResetSlots,
    GetAttachmentData,
    GetAttachmentSubMesh,
    Apply,
}};

```

`Engine/Extension/Spine/Skeleton.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-7-2
 * Update   : 2019-2-14
 * Author   : scott.cgi
 */


#ifndef SKELETON_H
#define SKELETON_H


#include "Engine/Toolkit/HeaderUtils/Define.h"
#include "Engine/Extension/Spine/SkeletonData.h"
#include "Engine/Extension/Spine/SkeletonBone.h"


typedef struct Skeleton Skeleton;

/**
 * Skeleton consists of bones and slots.
 * the bones can transform.
 * the slots can provide color and texture.
 * and the bones and slots read from boneData and slotData of skeletonData.
 *
 * the transform, color and texture will render by the mesh list.
 */
struct Skeleton
{
    /**
     * The base class for provide draw functions.
     */
    Drawable                             drawable[1];
    ArrayStrMap(boneName, SkeletonBone*) boneMap [1];
    ArrayStrMap(slotName, SkeletonSlot*) slotMap [1];

    SkeletonData*                        skeletonData;
    SkeletonSkinData*                    curSkinData;
    Array(SkeletonBone)*                 boneArr;
    Array(SkeletonSlot)*                 slotArr;
    Array(SkeletonSlot*)*                slotOrderArr;

    /**
     * The meshes that Skeleton needs to use.
     */
    ArrayList(Mesh)                      meshList[1];

    /**
     * If not NULL, callback when SkeletonEvent fired.
     */
    void (*FireSkeletonEvent)(Skeleton* skeleton, SkeletonEventData* eventData, float mixPercent);
};


/**
 * Control and manager Skeleton.
 */
struct ASkeleton
{
    Skeleton*               (*Create)              (SkeletonData* skeletonData);
    void                    (*Init)                (SkeletonData* skeletonData, Skeleton*   outSkeleton);
    void                    (*Release)             (Skeleton*     skeleton);
    void                    (*SetSkin)             (Skeleton*     skeleton,     const char* skinName);

    /**
     * Reset Skeleton bones to setup pose.
     */
    void                    (*ResetBones)          (Skeleton* skeleton);

    /**
     * Reset Skeleton slots to setup pose.
     */
    void                    (*ResetSlots)          (Skeleton* skeleton);


    /**
     * Find SkeletonAttachmentData by curSkinData,
     * if not found will find by default SkinData,
     * if not found yet then return NULL.
     */
    SkeletonAttachmentData* (*GetAttachmentData)   (
                                                       Skeleton*   skeleton,
                                                       const char* slotName,
                                                       const char* attachmentName
                                                   );

    /**
     * Get SubMesh in Mesh that bind in SkeletonAttachmentData.
     */
    SubMesh*                (*GetAttachmentSubMesh)(Skeleton* skeleton, SkeletonAttachmentData* skeletonAttachmentData);

    /**
     * Poses the skeleton at the specified time for animationData.
     *
     * mixPercent: percent  poses effect to apply, range in [0, 1]
     * mixPercent: 1.0f will 100% apply this time pose effect
     * mixPercent: 0.0f will 0%   apply this time pose effect
     * time      : seconds
     */
    void                     (*Apply)              (
                                                        Skeleton*              skeleton,
                                                        SkeletonAnimationData* animationData,
                                                        float                  time,
                                                        float                  mixPercent
                                                   );
};


extern struct ASkeleton ASkeleton[1];


/**
 * Draw Skeleton.
 */
static inline void ASkeleton_Draw(Skeleton* skeleton)
{
    ADrawable->Draw(skeleton->drawable);
}


/**
 * Get SkeletonAnimationData by animationName.
 */
static inline SkeletonAnimationData* ASkeleton_GetAnimationData(Skeleton* skeleton, const char* animationName)
{
    return AArrayStrMap_Get
           (
                skeleton->skeletonData->animationDataMap,
                animationName,
                SkeletonAnimationData*
           );
}


/**
 * Get SubMesh in Mesh that bind in SkeletonAttachmentData.
 */
static inline SubMesh* ASkeleton_GetSubMesh(Skeleton* skeleton, const char* slotName, const char* attachmentName)
{
    return ASkeleton->GetAttachmentSubMesh
           (
               skeleton,
               ASkeleton->GetAttachmentData(skeleton, slotName, attachmentName)
           );
}


/**
 * Get Skeleton width.
 */
static inline float ASkeleton_GetWidth(Skeleton* skeleton)
{
    return skeleton->skeletonData->width;
}


/**
 * Get Skeleton height.
 */
static inline float ASkeleton_GetHeight(Skeleton* skeleton)
{
    return skeleton->skeletonData->height;
}


#endif

```

`Engine/Extension/Spine/SkeletonAnimationPlayer.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-7-28
 * Update   : 2019-2-14
 * Author   : scott.cgi
 */


#include <math.h>
#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Extension/Spine/SkeletonAnimationPlayer.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/GLPrimitive.h"


static inline void UpdateNormal(SkeletonAnimationPlayer* player, float deltaSeconds)
{
    if (player->curTime < player->curAnimationData->duration)
    {
        ASkeleton->Apply(player->skeleton, player->curAnimationData, player->curTime, 1.0f);
        ASkeleton_Draw   (player->skeleton);

        player->curTime += deltaSeconds;

    }
    else
    {
        ASkeleton->Apply(player->skeleton, player->curAnimationData, player->curAnimationData->duration, 1.0f);
        ASkeleton_Draw  (player->skeleton);

        if (player->OnActionOver != NULL)
        {
            // action over function may call SetAnimationMix
            // so we need keep cuTime value
            player->OnActionOver(player);
        }

        if (player->loop > 0)
        {
            --player->loop;
        }

        player->curTime = 0.0f;
    }
}


static inline void UpdateMix(SkeletonAnimationPlayer* player, float deltaSeconds)
{
    if (player->preTime < player->preAnimationData->duration)
    {
        ASkeleton->Apply(player->skeleton, player->preAnimationData, player->preTime, 1.0f);
        player->preTime += deltaSeconds;
    }
    else
    {
        ASkeleton->Apply(player->skeleton, player->preAnimationData, player->preAnimationData->duration, 1.0f);
    }

    float mixPercent = player->mixTime / player->mixDuration;
    if (mixPercent < 1.0f)
    {
        player->mixTime += deltaSeconds;
    }
    else
    {
        mixPercent               = 1.0f;
        player->preAnimationData = NULL;
    }

    if (player->curTime < player->curAnimationData->duration)
    {
        ASkeleton->Apply(player->skeleton, player->curAnimationData, player->curTime, mixPercent);
        ASkeleton_Draw  (player->skeleton);

        player->curTime += deltaSeconds;
    }
    else
    {
        ASkeleton->Apply(player->skeleton, player->curAnimationData, player->curAnimationData->duration, mixPercent);
        ASkeleton_Draw  (player->skeleton);

        if (player->OnActionOver != NULL)
        {
            // action over function may call SetAnimationMix
            // so we need keep cuTime value
            player->OnActionOver(player);
        }

        player->curTime = 0.0f;
    }
}


static void Update(SkeletonAnimationPlayer* player, float deltaSeconds)
{
    if (player->loop != 0)
    {
        if (player->preAnimationData == NULL)
        {
            UpdateNormal(player, deltaSeconds);
        }
        else
        {
            UpdateMix(player, deltaSeconds);
        }
    }
}


static inline void InitSkeletonAnimationPlayer
(
    SkeletonAnimationPlayer* player, 
    SkeletonData*            skeletonData,
    const char*              animationName
)
{
    ASkeleton->Init(skeletonData, player->skeleton);
    player->preAnimationData = NULL;
    player->curAnimationData = ASkeleton_GetAnimationData(player->skeleton, animationName);

    ALog_A
    (
        player->curAnimationData != NULL,
        "ASkeletonAnimationPlayer cannot find animationData by name = %s",
        animationName
    );

    player->curTime      = 0.0f;
    player->preTime      = 0.0f;
    player->mixTime      = 0.0f;
    player->mixDuration  = 0.0f;
    player->OnActionOver = NULL;
    player->loop         = -1;

    //ASkeletonAnimationPlayer->Release(player);
    //ALog_A(0, "stop");
}


static void Release(SkeletonAnimationPlayer* player)
{
    ASkeleton->Release(player->skeleton);
}


static void SetAnimation(SkeletonAnimationPlayer* player, const char* animationName)
{
    player->curAnimationData = ASkeleton_GetAnimationData(player->skeleton,  animationName);

    ALog_A
    (
        player->curAnimationData != NULL,
        "ASkeletonAnimationPlayer SetAnimation cannot find animationData by name = %s",
        animationName
    );
    
    player->curTime = 0.0f;
}


static void SetAnimationMix(SkeletonAnimationPlayer* player, const char* animationName, float mixDuration)
{
    player->preAnimationData = player->curAnimationData;
    player->preTime          = player->curTime;
    player->curTime          = 0.0f;
    player->mixTime          = 0.0f;
    player->mixDuration      = mixDuration;
    player->curAnimationData = ASkeleton_GetAnimationData(player->skeleton,  animationName);
    
    ALog_A
    (
        player->curAnimationData != NULL,
        "SkeletonAnimationPlayer SetAnimationMix cannot find animationData by name = %s",
        animationName
    );
}


static SkeletonAnimationPlayer* CreateWithData(SkeletonData* skeletonData, const char* animationName)
{
    SkeletonAnimationPlayer* player = malloc(sizeof(SkeletonAnimationPlayer));
    InitSkeletonAnimationPlayer(player, skeletonData, animationName);

    return player;
}


static SkeletonAnimationPlayer* Create(const char* jsonFilePath, const char* animationName)
{
    SkeletonAnimationPlayer* player = malloc(sizeof(SkeletonAnimationPlayer));
    InitSkeletonAnimationPlayer(player, ASkeletonData->Get(jsonFilePath), animationName);

    return player;
}


static void Init(const char* jsonFilePath, const char* animationName, SkeletonAnimationPlayer* outPlayer)
{
    InitSkeletonAnimationPlayer(outPlayer, ASkeletonData->Get(jsonFilePath), animationName);
}


static void Render(Drawable* drawable)
{
    SkeletonSlot* slot = AUserData_GetSlotPtrWithType(drawable->userData, 0, SkeletonSlot*);

    AGLPrimitive->RenderPolygon
    (
        ASkeletonSlot_GetBoundingBox(slot)->vertexArr,
        slot->bone->drawable->mvpMatrix,
        slot->color,
        1.0f
    );
}


static void InitSlotBoundingBoxDrawable(SkeletonAnimationPlayer* player, const char* slotName, Drawable* outDrawable)
{
    SkeletonSlot* slot = ASkeletonAnimationPlayer_GetSlot(player, slotName);
    
    ALog_A
    (
        slot != NULL,
        "SkeletonAnimationPlayer InitSlotBoundingBoxDrawable not found SkeletonSlot by slotName = %s",
        slotName
    );

    ADrawable->Init(outDrawable);
    AUserData_SetSlotPtr(outDrawable->userData, 0, slot);
    outDrawable->Render = Render;

    // render requires slot mvpMatrix update
    ADrawable_AddState(slot->bone->drawable, DrawableState_IsUpdateMVPMatrix);
}


struct ASkeletonAnimationPlayer ASkeletonAnimationPlayer[1] =
{{
    Create,
    CreateWithData,
    Init,

    Release,
    Update,

    SetAnimation,
    SetAnimationMix,

    InitSlotBoundingBoxDrawable,
 }};
```

`Engine/Extension/Spine/SkeletonAnimationPlayer.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-7-28
 * Update   : 2019-2-13
 * Author   : scott.cgi
 */


#ifndef SKELETON_ANIMATION_PLAYER_H
#define SKELETON_ANIMATION_PLAYER_H


#include "Engine/Toolkit/HeaderUtils/Define.h"
#include "Engine/Extension/Spine/Skeleton.h"
#include "Engine/Extension/Spine/SkeletonSlot.h"


typedef struct SkeletonAnimationPlayer SkeletonAnimationPlayer;

/**
 * Callback when SkeletonAnimationPlayer current action over.
 */
typedef void (*SkeletonAnimationPlayerOnActionOver)(SkeletonAnimationPlayer* player);


/**
 * Drive skeleton animation play by animationData.
 */
struct SkeletonAnimationPlayer
{
    Skeleton              skeleton[1];

    /**
     * Action play loops, default -1.
     * 
     * if negative then infinite loop.
     * if positive then loop to 0.
     * if 0 then stop forever.
     */
    int                    loop;

    SkeletonAnimationData* curAnimationData;
    SkeletonAnimationData* preAnimationData;

    /**
     * The curAnimationData current time.
     */
    float                  curTime;

    /**
     * The preAnimationData current time.
     */
    float                  preTime;

    /**
     * The preAnimationData current mix time.
     */
    float                  mixTime;

    /**
     * The preAnimationData mix duration time.
     */
    float                  mixDuration;

    /**
     * Callback when action over.
     */
    SkeletonAnimationPlayerOnActionOver OnActionOver;
};


/**
 * Control and mange SkeletonAnimationPlayer.
 */
struct ASkeletonAnimationPlayer
{
    /**
     * Create SkeletonAnimationPlayer by jsonFilePath.
     *
     * jsonFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    SkeletonAnimationPlayer* (*Create)         (const char*   jsonFilePath, const char* animationName);
    SkeletonAnimationPlayer* (*CreateWithData) (SkeletonData* skeletonData, const char* animationName);

    /**
     * Init SkeletonAnimationPlayer by jsonFilePath.
     *
     * jsonFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    void                     (*Init)           (
                                                   const char*              jsonFilePath,
                                                   const char*              animationName,
                                                   SkeletonAnimationPlayer* outPlayer
                                               );
    
    void                     (*Release)        (SkeletonAnimationPlayer*    player);

    /**
     * Apply and draw skeleton.
     */
    void                     (*Update)         (SkeletonAnimationPlayer* player, float deltaSeconds);

    /**
     * Set player's animationData in Skeleton by animationName.
     */
    void                     (*SetAnimation)   (SkeletonAnimationPlayer* player, const char* animationName);

    /**
     * Set player's animationData in Skeleton by animationName.
     * the skeleton will from preAnimation mix to this animation.
     * the mixDuration is cross fade time in seconds.
     */
    void                     (*SetAnimationMix)(
                                                   SkeletonAnimationPlayer* player,
                                                   const char*              animationName,
                                                   float                    mixDuration
                                               );

    /**
     * Init Drawable that can render slot bounding box with primitive call.
     */
    void                     (*InitSlotBoundingBoxDrawable)(
                                                               SkeletonAnimationPlayer* player,
                                                               const char*              slotName,
                                                               Drawable*                outDrawable
                                                           );
};


extern struct ASkeletonAnimationPlayer ASkeletonAnimationPlayer[1];


/**
 * Get bone from player by boneName.
 */
static inline SkeletonBone* ASkeletonAnimationPlayer_GetBone(SkeletonAnimationPlayer* player, const char* boneName)
{
    return AArrayStrMap_Get(player->skeleton->boneMap, boneName, SkeletonBone*);
}


/**
 * Get slot from player by slotName.
 */
static inline SkeletonSlot* ASkeletonAnimationPlayer_GetSlot(SkeletonAnimationPlayer* player, const char* slotName)
{
    return AArrayStrMap_Get(player->skeleton->slotMap, slotName, SkeletonSlot*);
}


/**
 * Get drawable from player.
 */
static inline Drawable* ASkeletonAnimationPlayer_GetDrawable(SkeletonAnimationPlayer* player)
{
    return player->skeleton->drawable;
}


/**
 * Call player update method.
 */
static inline void ASkeletonAnimationPlayer_Update(SkeletonAnimationPlayer* player, float deltaSeconds)
{
    ASkeletonAnimationPlayer->Update(player, deltaSeconds);
}


/**
 * Get skeletonData from player.
 */
static inline SkeletonData* ASkeletonAnimationPlayer_GetSkeletonData(SkeletonAnimationPlayer* player)
{
    return player->skeleton->skeletonData;
}


/**
 * Get the player loading path.
 */
static inline const char* ASkeletonAnimationPlayer_GetPath(SkeletonAnimationPlayer* player)
{
    return player->skeleton->skeletonData->filePath;
}


/**
 * Get the SubMesh from player by slotName and attachmentName.
 */
static inline SubMesh* ASkeletonAnimationPlayer_GetSubMesh
(
    SkeletonAnimationPlayer* player, 
    const char*              slotName,
    const char*              attachmentName
)
{
    return ASkeleton_GetSubMesh(player->skeleton, slotName, attachmentName);
}


/**
 * Get the player width.
 */
static inline float ASkeletonAnimationPlayer_GetWidth(SkeletonAnimationPlayer* player)
{
    return ASkeleton_GetWidth(player->skeleton);
}


/**
 * Get the player height.
 */
static inline float ASkeletonAnimationPlayer_GetHeight(SkeletonAnimationPlayer* player)
{
    return ASkeleton_GetHeight(player->skeleton);
}


#endif

```

`Engine/Extension/Spine/SkeletonBone.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-7-2
 * Update   : 2019-2-13
 * Author   : scott.cgi
 */


#include "Engine/Extension/Spine/SkeletonBone.h"


static void SetToSetupPose(SkeletonBone* bone)
{
    Drawable*         drawable = bone->drawable;
    SkeletonBoneData* boneData = bone->boneData;

    ADrawable_SetPosition2(drawable, boneData->x,      boneData->y);
    ADrawable_SetScale2   (drawable, boneData->scaleX, boneData->scaleY);
    ADrawable_SetRotationZ(drawable, boneData->rotationZ);
}


static void Init(SkeletonBoneData* boneData, SkeletonBone* outBone)
{
    ADrawable->Init(outBone->drawable);
    outBone->boneData = boneData;
    SetToSetupPose(outBone);
}


static SkeletonBone* Create(SkeletonBoneData* boneData)
{
    SkeletonBone* bone = malloc(sizeof(SkeletonBone));
    Init(boneData, bone);

    return bone;
}


struct ASkeletonBone ASkeletonBone[1] =
{{
    Create,
    Init,
    SetToSetupPose,
}};

```

`Engine/Extension/Spine/SkeletonBone.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-7-2
 * Update   : 2019-2-13
 * Author   : scott.cgi
 */


#ifndef SKELETON_BONE_H
#define SKELETON_BONE_H


#include "Engine/Extension/Spine/SkeletonData.h"
#include "Engine/Graphics/Draw/Drawable.h"


/**
 * The skeleton bone can transform and draw by drawable.
 */
typedef struct
{
    Drawable          drawable[1];
    SkeletonBoneData* boneData;
}
SkeletonBone;


/**
 * Control SkeletonBone.
 */
struct ASkeletonBone
{
    SkeletonBone* (*Create)        (SkeletonBoneData* boneData);
    void          (*Init)          (SkeletonBoneData* boneData, SkeletonBone* outBone);

    /**
     * Set bone to setup pose.
     */
    void          (*SetToSetupPose)(SkeletonBone* bone);
};


extern struct ASkeletonBone ASkeletonBone[1];


#endif

```

`Engine/Extension/Spine/SkeletonData.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-6-27
 * Update   : 2019-2-13
 * Author   : scott.cgi
 */


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "Engine/Toolkit/Utils/Json.h"
#include "Engine/Toolkit/Utils/ArrayStrMap.h"
#include "Engine/Extension/Spine/SkeletonData.h"
#include "Engine/Toolkit/Utils/Json.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Extension/Spine/SkeletonTimeline.h"
#include "Engine/Graphics/OpenGL/GLTool.h"


static ArrayStrMap(filePath, SkeletonData*) skeletonDataMap[1] = AArrayStrMap_Init(SkeletonData*, 20);


static void Release(SkeletonData* skeletonData)
{
    bool isRemoved = AArrayStrMap->TryRemove(skeletonDataMap, skeletonData->filePath);
    ALog_A(isRemoved, "ASkeletonData Release not found %s in skeletonDataMap", skeletonData->filePath);

    // bone data
    ArrayStrMap* boneDataMap = skeletonData->boneDataMap;
    for (int i = 0; i < boneDataMap->elementList->size; ++i)
    {
        free(AArrayStrMap_GetAt(boneDataMap, i, SkeletonBoneData*));
    }
    AArrayStrMap->Release(boneDataMap);

    // slot data
    ArrayStrMap* slotDataMap = skeletonData->slotDataMap;
    for (int i = 0; i < slotDataMap->elementList->size; ++i)
    {
        SkeletonSlotData* slotData = AArrayStrMap_GetAt(slotDataMap, i, SkeletonSlotData*);
        if (slotData->attachmentDataList != NULL)
        {
            AArrayList->Release(slotData->attachmentDataList);
            free(slotData->attachmentDataList);
        }

        free(slotData);
    }
    AArrayStrMap->Release(slotDataMap);

    // event data
    ArrayStrMap* eventDataMap = skeletonData->eventDataMap;
    if (eventDataMap != NULL)
    {
        for(int i = 0; i < eventDataMap->elementList->size; ++i)
        {
            free(AArrayStrMap_GetAt(eventDataMap, i, SkeletonEventData*));
        }

        AArrayStrMap->Release(eventDataMap);
    }

    // skin data
    ArrayStrMap* skinDataMap = skeletonData->skinDataMap;
    for (int i = 0; i < skinDataMap->elementList->size; ++i)
    {
        SkeletonSkinData* skinData          = AArrayStrMap_GetAt(skinDataMap, i, SkeletonSkinData*);
        ArrayStrMap*      slotAttachmentMap = skinData->slotAttachmentMap;

        for (int j = 0; j < slotAttachmentMap->elementList->size; ++j)
        {
            ArrayStrMap* attachmentDataMap = AArrayStrMap_GetAt(slotAttachmentMap, j, ArrayStrMap*);

            for (int k = 0; k < attachmentDataMap->elementList->size; ++k)
            {
                free(AArrayStrMap_GetAt(attachmentDataMap, k, SkeletonAttachmentData*)->childPtr);
            }

            AArrayStrMap->Release(attachmentDataMap);
            free(attachmentDataMap);
        }

        AArrayStrMap->Release(slotAttachmentMap);
    }

    AArrayStrMap->Release(skinDataMap);

    free(skeletonData->boneDataOrderArr);
    skeletonData->boneDataOrderArr = NULL;

    free(skeletonData->slotDataOrderArr);
    skeletonData->slotDataOrderArr = NULL;


    // animation data
    ArrayStrMap* animationDataMap = skeletonData->animationDataMap;
    for (int j = 0; j < animationDataMap->elementList->size; ++j)
    {
        SkeletonAnimationData* animationData = AArrayStrMap_GetAt(animationDataMap, j, SkeletonAnimationData*);
        ArrayList*             timelineList  = animationData->timelineArr;

        for (int i = 0; i < timelineList->size; ++i)
        {
            SkeletonTimeline* timeline = AArrayList_Get(timelineList, i, SkeletonTimeline*);
            timeline->Release(timeline);
            free(timeline->childPtr);
        }
        AArrayList->Release(timelineList);

        free(animationData);
    }

    // attachment
    AArrayList->Release(skeletonData->attachmentDataList);

    // texture atlas
    ATextureAtlas->Release(skeletonData->textureAtlas);
}


static SkeletonAttachmentData* GetAttachmentDataBySkinData
(
    SkeletonSkinData* skinData,
    const char*       slotName,
    const char*       attachmentName
)
{
    ArrayStrMap* slotAttachmentMap = skinData->slotAttachmentMap;
    ArrayStrMap* attachmentDataMap = AArrayStrMap_Get(slotAttachmentMap, slotName, ArrayStrMap*);

    if (attachmentDataMap == NULL)
    {
        return NULL;
    }

    return AArrayStrMap_Get(attachmentDataMap, attachmentName, SkeletonAttachmentData*);
}


/**
 * return slot index in slotDataOrderArr or -1 not found.
 */
static inline int FindSlotIndex(SkeletonData* skeletonData, const char* slotName)
{
    SkeletonSlotData* slotData = AArrayStrMap_Get(skeletonData->slotDataMap, slotName, SkeletonSlotData*);
    ALog_A(slotData != NULL, "ASkeletonData FindSlotIndex SlotData = %s is not found", slotName);

    int  slotIndex = -1;
    for (int j = 0; j < skeletonData->slotDataOrderArr->length; ++j)
    {
        if (AArray_Get(skeletonData->slotDataOrderArr, j, SkeletonSlotData*) == slotData)
        {
            slotIndex = j;
            break;
        }
    }

    return slotIndex;
}


static inline void ReadBoneData(JsonObject* root, SkeletonData* skeletonData)
{
    JsonArray*   boneArr            = AJsonObject->GetArray(root, "bones");
    ArrayStrMap* boneDataMap        = skeletonData->boneDataMap;
    AArrayStrMap->InitWithCapacity(sizeof(SkeletonBoneData*), boneArr->valueList->size, boneDataMap);
    
    // hold SkeletonBoneData in JSON order
    skeletonData->boneDataOrderArr  = AArray->Create(sizeof(SkeletonBoneData*), boneArr->valueList->size);
    Array(float)* boneDataOrderArr  = skeletonData->boneDataOrderArr;

    for (int i = 0; i < boneArr->valueList->size; ++i)
    {
        JsonObject*       jsonBone   = AJsonArray->GetObject(boneArr,  i);
        char*             parentName = AJsonObject->GetString(jsonBone, "parent", NULL);
        SkeletonBoneData* parent     = NULL;
        
        if (parentName != NULL)
        {
            parent = AArrayStrMap_Get(boneDataMap, parentName, SkeletonBoneData*);
            ALog_A(parent != NULL, "ASkeletonData ReadBoneData parent not found: %s", parentName);
        }
        
        const char* name            = AJsonObject->GetString(jsonBone, "name", NULL);
        int   nameLength            = (int) strlen(name) + 1;

        SkeletonBoneData* boneData  = malloc(sizeof(SkeletonBoneData) + nameLength);
        boneData->name              = (char*) boneData + sizeof(SkeletonBoneData);
        memcpy((void*) boneData->name, name, (size_t) nameLength);

        boneData->parent            = parent;
        boneData->length            = AJsonObject->GetFloat(jsonBone, "length", 0.0f) * ASkeletonData->scale;
        boneData->x                 = AJsonObject->GetFloat(jsonBone, "x",      0.0f) * ASkeletonData->scale;
        boneData->y                 = AJsonObject->GetFloat(jsonBone, "y",      0.0f) * ASkeletonData->scale;

        boneData->length            = AGLTool_ToGLWidth (boneData->length);
        boneData->x                 = AGLTool_ToGLWidth (boneData->x);
        boneData->y                 = AGLTool_ToGLHeight(boneData->y);

        boneData->rotationZ         = AJsonObject->GetFloat(jsonBone, "rotation", 0.0f);
        boneData->scaleX            = AJsonObject->GetFloat(jsonBone, "scaleX",   1.0f);
        boneData->scaleY            = AJsonObject->GetFloat(jsonBone, "scaleY",   1.0f);

        boneData->isInheritScale    = AJsonObject->GetBool(jsonBone, "inheritScale",    true);
        boneData->isInheritRotation = AJsonObject->GetBool(jsonBone, "inheritRotation", true);

        AArrayStrMap_TryPut(boneDataMap,      boneData->name, boneData);
        AArray_Set         (boneDataOrderArr, i, boneData,    SkeletonBoneData*);
    }
}


static inline void ReadSlotData(JsonObject* root, SkeletonData* skeletonData)
{
    JsonArray*   slotArr           = AJsonObject->GetArray(root, "slots");
    ArrayStrMap* slotDataMap       = skeletonData->slotDataMap;
    AArrayStrMap->InitWithCapacity(sizeof(SkeletonSlotData*), slotArr->valueList->size, slotDataMap);

    ArrayStrMap* boneDataMap       = skeletonData->boneDataMap;


    // hold SkeletonSlotData in JSON order
    skeletonData->slotDataOrderArr             = AArray->Create(sizeof(SkeletonSlotData*), slotArr->valueList->size);
    Array(SkeletonSlotData*)* slotDataOrderArr = skeletonData->slotDataOrderArr;

    for (int i = 0; i < slotArr->valueList->size; ++i)
    {
        JsonObject* jsonSlot             = AJsonArray->GetObject(slotArr, i);
        char*       name                 = AJsonObject->GetString(jsonSlot, "name",       NULL);
        char*       attachmentName       = AJsonObject->GetString(jsonSlot, "attachment", NULL);
        int         nameLength           = (int) strlen(name) + 1;
        int         attachmentNameLength = attachmentName != NULL ? ((int) strlen(attachmentName) + 1) : 0;

        SkeletonSlotData* slotData       = malloc(sizeof(SkeletonSlotData) + nameLength + attachmentNameLength);

        slotData->name = (char*) slotData + sizeof(SkeletonSlotData);
        memcpy((void*) slotData->name, name, (size_t) nameLength);

        slotData->attachmentDataList = NULL;

        if (attachmentName != NULL)
        {
            slotData->attachmentName = (char*) slotData + sizeof(SkeletonSlotData) + nameLength;
            memcpy((void*) slotData->attachmentName, attachmentName, (size_t) attachmentNameLength);
        }
        else
        {
            slotData->attachmentName = NULL;
        }

        char* bone         = AJsonObject->GetString(jsonSlot, "bone", NULL);
        slotData->boneData = AArrayStrMap_Get(boneDataMap, bone, SkeletonBoneData*);

        ALog_A(slotData->boneData != NULL, "ASkeletonData ReadSlotData slot bone not found: %s", bone);

        char* color = AJsonObject->GetString(jsonSlot, "color", NULL);
        if (color == NULL)
        {
            slotData->color->a = 1.0f;
            slotData->color->r = 1.0f;
            slotData->color->g = 1.0f;
            slotData->color->b = 1.0f;
        }
        else
        {
            AColor->SetWithString(color, slotData->color);
        }

        slotData->isAdditiveBlending = AJsonObject->GetBool(jsonSlot, "additive", false);
        AArrayStrMap_TryPut(slotDataMap, slotData->name, slotData);
        AArray_Set(slotDataOrderArr, i, slotData, SkeletonSlotData*);
    }
}


static inline SkeletonAttachmentData* CreateAttachmentData(int length, SkeletonAttachmentDataType attachmentDataType)
{
    SkeletonAttachmentData* attachmentData;

    switch (attachmentDataType)
    {
        case SkeletonAttachmentDataType_Region:
        {
            SkeletonRegionAttachmentData*
            regionAttachmentData     = malloc(sizeof(SkeletonRegionAttachmentData) + length);
            attachmentData           = regionAttachmentData->attachmentData;
            attachmentData->childPtr = regionAttachmentData;

            break;
        }

        case SkeletonAttachmentDataType_BoundingBox:
        {
            SkeletonBoundingBoxAttachmentData*
            boundingBoxAttachmentData = malloc(sizeof(SkeletonBoundingBoxAttachmentData) + length);
            attachmentData            = boundingBoxAttachmentData->attachmentData;
            attachmentData->childPtr  = boundingBoxAttachmentData;

            break;
        }

        case SkeletonAttachmentDataType_Mesh:
        {
            SkeletonMeshAttachmentData*
            meshAttachmentData       = malloc(sizeof(SkeletonMeshAttachmentData) + length);
            attachmentData           = meshAttachmentData->attachmentData;
            attachmentData->childPtr = meshAttachmentData;

            break;
        }

        case SkeletonAttachmentDataType_SkinnedMesh:
        {
            SkeletonSkinnedMeshAttachmentData*
            skinnedMeshAttachmentData = malloc(sizeof(SkeletonSkinnedMeshAttachmentData) + length);
            attachmentData            = skinnedMeshAttachmentData->meshAttachmentData->attachmentData;
            attachmentData->childPtr  = skinnedMeshAttachmentData;

            break;
        }
        
        default:
            return NULL;
    }

    attachmentData->type = attachmentDataType;

    return attachmentData;
}


static inline ArrayStrMap* ReadSkinDataSlotAttachment(JsonObject* attachmentDataMapObject)
{
    const float  scale             = ASkeletonData->scale;
    ArrayStrMap* attachmentDataMap = AArrayStrMap->CreateWithCapacity
                                     (
                                         sizeof(SkeletonAttachmentData*),
                                         attachmentDataMapObject->valueMap->elementList->size
                                     );

    for (int i = 0; i < attachmentDataMapObject->valueMap->elementList->size; ++i)
    {
        const char* name                 = AJsonObject->GetKey          (attachmentDataMapObject, i);
        JsonObject* attachmentDataObject = AJsonObject->GetObjectByIndex(attachmentDataMapObject, i);
        char*       attachmentType       = AJsonObject->GetString       (attachmentDataObject, "type", NULL);
        const char* attachmentName       = AJsonObject->GetString       (attachmentDataObject, "name", NULL);
        int         length               = 0;
        int         nameLength           = 0;

        if (attachmentName == NULL)
        {
            attachmentName = name;
        }

        nameLength = (int) strlen(attachmentName) + 1;

        SkeletonAttachmentData* attachmentData = NULL;

        if (attachmentType == NULL)
        {
            // region
            attachmentData  = CreateAttachmentData(length + nameLength, SkeletonAttachmentDataType_Region);
            length         += sizeof(SkeletonRegionAttachmentData);

            SkeletonRegionAttachmentData* regionAttachmentData = attachmentData->childPtr;

            regionAttachmentData->x         = AJsonObject->GetFloat(attachmentDataObject, "x", 0.0f) * scale;
            regionAttachmentData->y         = AJsonObject->GetFloat(attachmentDataObject, "y", 0.0f) * scale;
            regionAttachmentData->scaleX    = AJsonObject->GetFloat(attachmentDataObject, "scaleX",   1.0f);
            regionAttachmentData->scaleY    = AJsonObject->GetFloat(attachmentDataObject, "scaleY",   1.0f);
            regionAttachmentData->rotationZ = AJsonObject->GetFloat(attachmentDataObject, "rotation", 0.0f);
            regionAttachmentData->width     = AJsonObject->GetFloat(attachmentDataObject, "width",    0.0f) * scale;
            regionAttachmentData->height    = AJsonObject->GetFloat(attachmentDataObject, "height",   0.0f) * scale;
            regionAttachmentData->x         = AGLTool_ToGLWidth (regionAttachmentData->x);
            regionAttachmentData->y         = AGLTool_ToGLHeight(regionAttachmentData->y);
            regionAttachmentData->width     = AGLTool_ToGLWidth (regionAttachmentData->width);
            regionAttachmentData->height    = AGLTool_ToGLHeight(regionAttachmentData->height);

        }
        else if (strcmp(attachmentType, "boundingbox") == 0)
        {
            JsonArray* jsonVertexArr = AJsonObject->GetArray(attachmentDataObject, "vertices");
            length                  += jsonVertexArr->valueList->size * sizeof(float);

            attachmentData           = CreateAttachmentData(length + nameLength, SkeletonAttachmentDataType_BoundingBox);
            length                  += sizeof(SkeletonBoundingBoxAttachmentData);

            SkeletonBoundingBoxAttachmentData* boundingBoxAttachmentData = attachmentData->childPtr;

            boundingBoxAttachmentData->vertexArr->length = jsonVertexArr->valueList->size;
            boundingBoxAttachmentData->vertexArr->data   = (char*) boundingBoxAttachmentData
                                                           + sizeof(SkeletonBoundingBoxAttachmentData);
            
            float* vertices = boundingBoxAttachmentData->vertexArr->data;
            for (int j = 0; j < jsonVertexArr->valueList->size; j += 2)
            {
                vertices[j]     = AGLTool_ToGLWidth (AJsonArray->GetFloat(jsonVertexArr, j)     * scale);
                vertices[j + 1] = AGLTool_ToGLHeight(AJsonArray->GetFloat(jsonVertexArr, j + 1) * scale);
            }

        }
        else if (strcmp(attachmentType, "mesh") == 0)
        {
            JsonArray* jsonVertexArr   = AJsonObject->GetArray(attachmentDataObject, "vertices");
            JsonArray* jsonTriangleArr = AJsonObject->GetArray(attachmentDataObject, "triangles");
            JsonArray* jsonUVArr       = AJsonObject->GetArray(attachmentDataObject, "uvs");

            int        verticesCount   = jsonVertexArr->valueList->size   + (jsonVertexArr->valueList->size >> 1);
            int        verticesByte    = verticesCount                    * sizeof(float);
            int        uvsByte         = jsonUVArr->valueList->size       * sizeof(float);
            int        trianglesByte   = jsonTriangleArr->valueList->size * sizeof(short);

            length                    += verticesByte +  uvsByte +  trianglesByte;
            attachmentData             = CreateAttachmentData(length + nameLength, SkeletonAttachmentDataType_Mesh);
            length                    += sizeof(SkeletonMeshAttachmentData);

            SkeletonMeshAttachmentData* meshAttachmentData = (SkeletonMeshAttachmentData*) attachmentData->childPtr;

            meshAttachmentData->isUVMappedInTexture = false;
            meshAttachmentData->vertexArr->length   = verticesCount;
            meshAttachmentData->vertexArr->data     = (char*) meshAttachmentData + sizeof(SkeletonMeshAttachmentData);

            float* vertices = meshAttachmentData->vertexArr->data;
            for (int j = 0, k = 0; j < verticesCount; j += 3, k += 2)
            {
                vertices[j]     = AGLTool_ToGLWidth (AJsonArray->GetFloat(jsonVertexArr, k)     * scale);
                vertices[j + 1] = AGLTool_ToGLHeight(AJsonArray->GetFloat(jsonVertexArr, k + 1) * scale);
                vertices[j + 2] = 0.0f;
            }

            meshAttachmentData->uvArr->length = jsonUVArr->valueList->size;
            meshAttachmentData->uvArr->data   = (char*) vertices + verticesByte;

            float* uvs = meshAttachmentData->uvArr->data;
            for (int j = 0; j < jsonUVArr->valueList->size; j += 2)
            {
                uvs[j]     = AJsonArray->GetFloat(jsonUVArr, j);
                uvs[j + 1] = AJsonArray->GetFloat(jsonUVArr, j + 1);
            }

            meshAttachmentData->triangleArr->length = jsonTriangleArr->valueList->size;
            meshAttachmentData->triangleArr->data   = (char*) uvs + uvsByte;

            short* triangles = meshAttachmentData->triangleArr->data;
            for (int j = 0; j < jsonTriangleArr->valueList->size; ++j)
            {
                triangles[j] = (short) AJsonArray->GetInt(jsonTriangleArr, j);
            }

            meshAttachmentData->width  = AJsonObject->GetFloat(attachmentDataObject, "width",  0.0f) * scale;
            meshAttachmentData->height = AJsonObject->GetFloat(attachmentDataObject, "height", 0.0f) * scale;
            meshAttachmentData->width  = AGLTool_ToGLWidth (meshAttachmentData->width);
            meshAttachmentData->height = AGLTool_ToGLHeight(meshAttachmentData->height);
        }
        else if (strcmp(attachmentType, "skinnedmesh") == 0)
        {
            // one block data is [boneCount, boneIndex, x, y, weight ...]
            JsonArray* jsonVertexArr       = AJsonObject->GetArray(attachmentDataObject, "vertices");
            JsonArray* jsonTriangleArr     = AJsonObject->GetArray(attachmentDataObject, "triangles");
            JsonArray* jsonUVArr           = AJsonObject->GetArray(attachmentDataObject, "uvs");

            int        bonesCount          = 0;
            int        weightsCount        = 0;
            int        weightVerticesCount = 0;
            int        verticesCount       = 0;

            for (int j = 0; j < jsonVertexArr->valueList->size; ++verticesCount)
            {
                int boneCount = AJsonArray->GetInt(jsonVertexArr, j);

                // contains boneCount and each bones index
                bonesCount          += boneCount  +  1;
                weightsCount        += boneCount;
                weightVerticesCount += boneCount  << 1;
                j                   += (boneCount << 2) + 1;
            }

            // how many vertices in mesh
            verticesCount           = verticesCount * 3;
            // how many vertices mix by each bone weight
            weightVerticesCount     = weightVerticesCount + (weightVerticesCount >> 1);

            int  verticesByte       = verticesCount                    * sizeof(float);
            int  weightVerticesByte = weightVerticesCount              * sizeof(float);
            int  trianglesByte      = jsonTriangleArr->valueList->size * sizeof(short);
            int  uvsByte            = jsonUVArr->valueList->size       * sizeof(float);
            int  bonesByte          = bonesCount                       * sizeof(int);
            int  weightsByte        = weightsCount                     * sizeof(float);

            length                 += verticesByte
                                   +  weightVerticesByte
                                   +  bonesByte
                                   +  weightsByte
                                   +  uvsByte
                                   +  trianglesByte;

            attachmentData = CreateAttachmentData(length + nameLength, SkeletonAttachmentDataType_SkinnedMesh);
            length        += sizeof(SkeletonSkinnedMeshAttachmentData);

            SkeletonSkinnedMeshAttachmentData* skinnedMeshAttachmentData = attachmentData->childPtr;
            SkeletonMeshAttachmentData*        meshAttachmentData        = skinnedMeshAttachmentData->meshAttachmentData;

            meshAttachmentData->vertexArr->length = verticesCount;
            meshAttachmentData->vertexArr->data   = (char*) skinnedMeshAttachmentData
                                                    + sizeof(SkeletonSkinnedMeshAttachmentData);

            memset(meshAttachmentData->vertexArr->data, 0, (size_t) verticesByte);

            skinnedMeshAttachmentData->weightVertexArr->length = weightVerticesCount;
            skinnedMeshAttachmentData->weightVertexArr->data   = (char*) meshAttachmentData->vertexArr->data
                                                                 + verticesByte;

            float* weightVertices = skinnedMeshAttachmentData->weightVertexArr->data;
            skinnedMeshAttachmentData->boneArr->length   = bonesCount;
            skinnedMeshAttachmentData->boneArr->data     = (char*) weightVertices + weightVerticesByte;

            int* bones = skinnedMeshAttachmentData->boneArr->data;
            skinnedMeshAttachmentData->weightArr->length = weightsCount;
            skinnedMeshAttachmentData->weightArr->data   = (char*) bones + bonesByte;

            float* weights = skinnedMeshAttachmentData->weightArr->data;
            for (int j = 0, b = 0, w = 0, v = 0; j < jsonVertexArr->valueList->size;)
            {
                int boneCount = AJsonArray->GetInt(jsonVertexArr, j++);
                bones[b++]    = boneCount;

                for (int k = j + boneCount * 4; j < k; j += 4, v += 3)
                {
                    // bone index
                    bones  [b++]          = AJsonArray->GetInt  (jsonVertexArr, j);
                    weights[w++]          = AJsonArray->GetFloat(jsonVertexArr, j + 3);

                    weightVertices[v]     = AGLTool_ToGLWidth (AJsonArray->GetFloat(jsonVertexArr, j + 1) * scale);
                    weightVertices[v + 1] = AGLTool_ToGLHeight(AJsonArray->GetFloat(jsonVertexArr, j + 2) * scale);
                    weightVertices[v + 2] = 0.0f;
                }
            }

            meshAttachmentData->uvArr->length = jsonUVArr->valueList->size;
            meshAttachmentData->uvArr->data   = (char*) weights + weightsByte;

            float* uvs = meshAttachmentData->uvArr->data;
            for (int j = 0; j < jsonUVArr->valueList->size; j += 2)
            {
                uvs[j]     = AJsonArray->GetFloat(jsonUVArr, j);
                uvs[j + 1] = AJsonArray->GetFloat(jsonUVArr, j + 1);
            }

            meshAttachmentData->triangleArr->length = jsonTriangleArr->valueList->size;
            meshAttachmentData->triangleArr->data   = (char*) uvs + uvsByte;

            short* triangles = meshAttachmentData->triangleArr->data;
            for (int j = 0; j < jsonTriangleArr->valueList->size; ++j)
            {
                triangles[j] = (short) AJsonArray->GetInt(jsonTriangleArr, j);
            }

            meshAttachmentData->width  = AJsonObject->GetFloat(attachmentDataObject, "width",  0.0f) * scale;
            meshAttachmentData->height = AJsonObject->GetFloat(attachmentDataObject, "height", 0.0f) * scale;
            meshAttachmentData->width  = AGLTool_ToGLWidth (meshAttachmentData->width);
            meshAttachmentData->height = AGLTool_ToGLHeight(meshAttachmentData->height);
        }
        else
        {
            ALog_E("ASkeletonData ReadSkinDataSlotAttachment not found attachmentType = %s", attachmentType);
            continue;
        }

        attachmentData->name = (char*) attachmentData->childPtr + length;
        memcpy((void*) attachmentData->name, attachmentName, (size_t) nameLength);

        AArrayStrMap_TryPut(attachmentDataMap, name, attachmentData);
    }

    return attachmentDataMap;
}


static inline void ReadSkinDataSlot(JsonObject* skinSlot, SkeletonSkinData* skinData)
{
    ArrayStrMap* slotAttachmentMap = skinData->slotAttachmentMap;
    AArrayStrMap->InitWithCapacity(sizeof(ArrayStrMap*), skinSlot->valueMap->elementList->size, slotAttachmentMap);

    for (int i = 0; i < skinSlot->valueMap->elementList->size; ++i)
    {
        const char*  slotName                = AJsonObject->GetKey(skinSlot, i);
        JsonObject*  attachmentDataMapObject = AJsonObject->GetObjectByIndex(skinSlot, i);
        ArrayStrMap* attachmentDataMap       = ReadSkinDataSlotAttachment(attachmentDataMapObject);

        AArrayStrMap_TryPut(slotAttachmentMap, slotName, attachmentDataMap);
    }
}


static inline void ReadSkinData(JsonObject* root, SkeletonData* skeletonData)
{
    JsonObject*  skinDataObject = AJsonObject->GetObject(root, "skins");
    ArrayStrMap* skinDataMap    = skeletonData->skinDataMap;
    AArrayStrMap->InitWithCapacity(sizeof(SkeletonSkinData*), skinDataObject->valueMap->elementList->size, skinDataMap);

    for (int i = 0; i < skinDataObject->valueMap->elementList->size; ++i)
    {
        const char* skinName       = AJsonObject->GetKey(skinDataObject, i);
        int   skinNameLength       = (int) strlen(skinName) + 1;

        SkeletonSkinData* skinData = malloc(sizeof(SkeletonSkinData) + skinNameLength);
        skinData->name             = (char*) skinData + sizeof(SkeletonSkinData);
        memcpy((void*) skinData->name, skinName, (size_t) skinNameLength);

        // skin all slots
        JsonObject*  skinDataSlot  = AJsonObject->GetObjectByIndex(skinDataObject, i);
        ReadSkinDataSlot(skinDataSlot, skinData);

        AArrayStrMap_TryPut(skinDataMap, skinData->name, skinData);

        if (strcmp(skinName, "default") == 0)
        {
            skeletonData->skinDataDefault = skinData;
        }
    }
}


static inline void ReadCurve(SkeletonCurveTimeline* curveTimeline, int frameIndex, JsonObject* jsonTimeline)
{
    JsonType type = AJsonObject->GetType(jsonTimeline, "curve");
    
    switch (type)
    {
        case JsonType_Null:
            ASkeletonTimeline->SetLinear(curveTimeline, frameIndex);
            break;

        case JsonType_String:
            if (strcmp(AJsonObject->GetString(jsonTimeline, "curve", ""), "stepped") == 0)
            {
                ASkeletonTimeline->SetStepped(curveTimeline, frameIndex);
            }
            break;


        case JsonType_Array:
        {
            JsonArray* curveArr = AJsonObject->GetArray(jsonTimeline, "curve");

            ASkeletonTimeline->SetCurve
            (
                curveTimeline,
                frameIndex,
                AJsonArray->GetFloat(curveArr, 0),
                AJsonArray->GetFloat(curveArr, 1),
                AJsonArray->GetFloat(curveArr, 2),
                AJsonArray->GetFloat(curveArr, 3)
            );

            break;
        }
            
        case JsonType_Float:
            break;
            
        case JsonType_Object:
            break;

        default:
            break;
    }
}


static inline void ReadAnimationBones
(
    SkeletonData*                 skeletonData,
    JsonObject*                   jsonBones,
    SkeletonAnimationData*        animationData,
    ArrayList(SkeletonTimeline*)* skeletonTimelineArr
)
{

    ArrayStrMap* boneDataMap = skeletonData->boneDataMap;

    for (int i = 0; i < jsonBones->valueMap->elementList->size; ++i)
    {
        const char*       boneName = AJsonObject->GetKey(jsonBones, i);
        SkeletonBoneData* boneData = AArrayStrMap_Get(boneDataMap, boneName, SkeletonBoneData*);
        ALog_A(boneData != NULL, "ASkeletonData ReadAnimationBones boneData = %s is not found", boneName);

        int boneIndex = -1;
        for (int j = 0; j < skeletonData->boneDataOrderArr->length; ++j)
        {
            if (AArray_Get(skeletonData->boneDataOrderArr, j, SkeletonBoneData*) == boneData)
            {
                boneIndex = j;
                break;
            }
        }

        ALog_A
        (
            boneIndex != -1,
            "ASkeletonData ReadAnimationBones not found boneData = %s in boneDataOrderArr",
            boneName
        );

        JsonObject* jsonBoneTimeline = AJsonObject->GetObjectByIndex(jsonBones, i);
        for (int j = 0; j < jsonBoneTimeline->valueMap->elementList->size; ++j)
        {
            const char* timelineType = AJsonObject->GetKey(jsonBoneTimeline, j);
            JsonArray*  timelineArr  = AJsonObject->GetArrayByIndex(jsonBoneTimeline, j);
            bool        isTranslate;

            if (strcmp(timelineType, "rotate") == 0)
            {
                SkeletonRotateTimeline* rotateTimeline = ASkeletonTimeline->CreateRotate
                                                         (
                                                             timelineArr->valueList->size,
                                                             boneIndex
                                                         );

                for (int k = 0, frameIndex = 0; k < timelineArr->valueList->size; ++k, ++frameIndex)
                {
                    JsonObject* jsonTimeline = AJsonArray->GetObject(timelineArr,  k);
                    float time               = AJsonObject->GetFloat(jsonTimeline, "time",  0.0f);
                    float angle              = AJsonObject->GetFloat(jsonTimeline, "angle", 0.0f);

                    ASkeletonTimeline->SetRotateFrame(rotateTimeline, frameIndex, time, angle);
                    ReadCurve(rotateTimeline->curveTimeline, frameIndex, jsonTimeline);
                }

                SkeletonTimeline* skeletonTimeline = rotateTimeline->skeletonTimeline;
                // because array is const no address
                // so array equals &array
                // and we use temporary variable to get the "array variable" address
                AArrayList_Add(skeletonTimelineArr, skeletonTimeline);


                animationData->duration = AMath_Max
                                          (
                                              animationData->duration,
                                              AArray_Get
                                              (
                                                  rotateTimeline->frameArr,
                                                  rotateTimeline->frameArr->length - 2,
                                                  float
                                              )
                                          );

            }
            else if ((isTranslate = strcmp(timelineType, "translate") == 0) || (strcmp(timelineType, "scale") == 0))
            {
                SkeletonTranslateTimeline* translateTimeline = NULL;
                SkeletonTimeline*          skeletonTimeline;

                if (isTranslate)
                {
                    translateTimeline = ASkeletonTimeline->CreateTranslate(timelineArr->valueList->size, boneIndex);

                }
                else
                {
                    SkeletonScaleTimeline* scaleTimeline = ASkeletonTimeline->CreateScale
                                                           (
                                                               timelineArr->valueList->size,
                                                               boneIndex
                                                           );
                    translateTimeline                    = scaleTimeline->translateTimeline;
                }

                skeletonTimeline = translateTimeline->skeletonTimeline;
                // because array is const no address
                // so array equals &array
                // and we use temporary variable to get the "array variable" address
                AArrayList_Add(skeletonTimelineArr, skeletonTimeline);

                for (int k = 0, frameIndex = 0; k < timelineArr->valueList->size; ++k, ++frameIndex)
                {
                    JsonObject* jsonTimeline = AJsonArray->GetObject(timelineArr,  k);
                    float       time         = AJsonObject->GetFloat(jsonTimeline, "time", 0.0f);
                    float       x            = AJsonObject->GetFloat(jsonTimeline, "x",    0.0f);
                    float       y            = AJsonObject->GetFloat(jsonTimeline, "y",    0.0f);

                    if (isTranslate)
                    {
                        x = AGLTool_ToGLWidth (x) * ASkeletonData->scale;
                        y = AGLTool_ToGLHeight(y) * ASkeletonData->scale;
                    }
                    else
                    {
                        // x, y is scale timeline value
                    }

                    ASkeletonTimeline->SetTranslateFrame(translateTimeline, frameIndex, time, x, y);
                    ReadCurve(translateTimeline->curveTimeline, frameIndex, jsonTimeline);
                }


                animationData->duration = AMath_Max
                                          (
                                              animationData->duration,
                                              AArray_Get
                                              (
                                                  translateTimeline->frameArr,
                                                  translateTimeline->frameArr->length - 3,
                                                  float
                                              )
                                          );

            }
            else
            {
                ALog_A(false, "ASkeletonData ReadAnimationBones invalid timeline type for a bone: %s", timelineType);
            }
        }
    }
}


static inline void ReadAnimationSlots
(
    SkeletonData*                 skeletonData,
    JsonObject*                   jsonSlots,
    SkeletonAnimationData*        animationData,
    ArrayList(SkeletonTimeline*)* skeletonTimelineArr
)
{
    for (int i = 0; i < jsonSlots->valueMap->elementList->size; ++i)
    {
        const char* slotName  = AJsonObject->GetKey(jsonSlots, i);
        int         slotIndex = FindSlotIndex(skeletonData, slotName);

        ALog_A
        (
            slotIndex != -1,
            "ASkeletonData ReadAnimationSlots not found slotData = %s in slotDataOrderArr",
            slotName
        );

        JsonObject* jsonSlotTimeline = AJsonObject->GetObjectByIndex(jsonSlots, i);
        for (int j = 0; j < jsonSlotTimeline->valueMap->elementList->size; ++j)
        {
            const char* timelineType = AJsonObject->GetKey(jsonSlotTimeline, j);
            JsonArray*  timelineArr  = AJsonObject->GetArrayByIndex(jsonSlotTimeline, j);

            if (strcmp(timelineType, "color") == 0)
            {
                SkeletonColorTimeline* colorTimeline = ASkeletonTimeline->CreateColor(timelineArr->valueList->size);
                colorTimeline->slotIndex             = slotIndex;

                for (int k = 0, frameIndex = 0; k < timelineArr->valueList->size; ++k, ++frameIndex)
                {
                    JsonObject* jsonTimeline = AJsonArray->GetObject(timelineArr,  k);
                    float       time         = AJsonObject->GetFloat (jsonTimeline, "time", 0.0);
                    char*       color        = AJsonObject->GetString(jsonTimeline, "color", NULL);

                    Color c[1];
                    AColor->SetWithString(color, c);
                    ASkeletonTimeline->SetColorFrame(colorTimeline, frameIndex, time, c);

                    ReadCurve(colorTimeline->curveTimeline, frameIndex, jsonTimeline);
                }

                SkeletonTimeline* skeletonTimeline = colorTimeline->skeletonTimeline;
                // because array is const no address
                // so array equals &array
                // and we use temporary variable to get the "array variable" address
                AArrayList_Add(skeletonTimelineArr, skeletonTimeline);

                animationData->duration = AMath_Max
                                          (
                                              animationData->duration,
                                              AArray_Get
                                              (
                                                  colorTimeline->frameArr,
                                                  colorTimeline->frameArr->length - 5,
                                                  float
                                              )
                                          );

            }
            else if (strcmp(timelineType, "attachment") == 0)
            {
                SkeletonAttachmentTimeline* attachmentTimeline = ASkeletonTimeline->CreateAttachment
                                                                 (
                                                                     timelineArr->valueList->size
                                                                 );
                attachmentTimeline->slotIndex                  = slotIndex;

                for (int k = 0, frameIndex = 0; k < timelineArr->valueList->size; ++k, ++frameIndex)
                {
                    JsonObject* jsonTimeline = AJsonArray->GetObject (timelineArr,  k);
                    float       time         = AJsonObject->GetFloat (jsonTimeline, "time", 0.0f);
                    char*       name         = AJsonObject->GetString(jsonTimeline, "name", NULL);

                    ASkeletonTimeline->SetAttachmentFrame(attachmentTimeline, frameIndex, time, name);
                }

                SkeletonTimeline* skeletonTimeline = attachmentTimeline->skeletonTimeline;
                // because array is const no address
                // so array equals &array
                // and we use temporary variable to get the "array variable" address
                AArrayList_Add(skeletonTimelineArr, skeletonTimeline);

                animationData->duration = AMath_Max
                                          (
                                              animationData->duration,
                                              AArray_Get
                                              (
                                                  attachmentTimeline->frameArr,
                                                  attachmentTimeline->frameArr->length - 1,
                                                  float
                                              )
                                          );

            }
            else
            {
                ALog_A(false, "ASkeletonData ReadAnimationSlots invalid timeline type for a slot: %s", timelineType);
            }
        }
    }
}


static inline void ReadAnimationEvents
(
    SkeletonData*                 skeletonData,
    JsonArray*                    jsonEvents,
    SkeletonAnimationData*        animationData,
    ArrayList(SkeletonTimeline*)* skeletonTimelineArr
)
{

    SkeletonEventTimeline* eventTimeline = ASkeletonTimeline->CreateEvent(jsonEvents->valueList->size);

    for (int i = 0, frameIndex = 0; i < jsonEvents->valueList->size; ++i, ++frameIndex)
    {
        JsonObject*        eventObject = AJsonArray->GetObject(jsonEvents,  i);
        char*              eventName   = AJsonObject->GetString(eventObject, "name", NULL);
        float              time        = AJsonObject->GetFloat (eventObject, "time", 0.0f);
        SkeletonEventData* eventData   = AArrayStrMap_Get(skeletonData->eventDataMap, eventName, SkeletonEventData*);

        if (eventData == NULL)
        {
            eventData = (SkeletonEventData[1]) { "", "", 0, 0.0f };
        }

        char*              stringValue  = AJsonObject->GetString(eventObject, "string", eventData->stringValue);
        int                intValue     = AJsonObject->GetInt   (eventObject, "int",    eventData->intValue);
        float              floatValue   = AJsonObject->GetFloat (eventObject, "float",  eventData->floatValue);

        int                eventLength  = (int) strlen(eventName)   + 1;
        int                valueLength  = (int) strlen(stringValue) + 1;
        SkeletonEventData* newEventData = malloc(sizeof(SkeletonEventData) + eventLength + valueLength);

        newEventData->name              = (char*) newEventData + sizeof(SkeletonEventData);
        memcpy((void*) newEventData->name, eventName, (size_t) eventLength);

        newEventData->stringValue       = (char*) newEventData + sizeof(SkeletonEventData) + eventLength;
        memcpy((void*) newEventData->stringValue, stringValue, (size_t) valueLength);

        newEventData->intValue          = intValue;
        newEventData->floatValue        = floatValue;

        ASkeletonTimeline->SetEventFrame(eventTimeline, frameIndex, time, newEventData);
    }

    SkeletonTimeline* skeletonTimeline = eventTimeline->skeletonTimeline;
    // because array is const no address
    // so array equals &array
    // and we use temporary variable to get the "array variable" address
    AArrayList_Add(skeletonTimelineArr, skeletonTimeline);

    animationData->duration = AMath_Max
                              (
                                animationData->duration,
                                AArray_Get(eventTimeline->frameArr, eventTimeline->frameArr->length - 1, float)
                              );
}


static inline void ReadAnimationDrawOrders
(
    SkeletonData*                 skeletonData,
    JsonArray*                    jsonDrawOrder,
    SkeletonAnimationData*        animationData,
    ArrayList(SkeletonTimeline*)* skeletonTimelineArr
)
{

    SkeletonDrawOrderTimeline* drawOrderTimeline = ASkeletonTimeline->CreateDrawOrder(jsonDrawOrder->valueList->size);
    int                        slotCount         = skeletonData->slotDataOrderArr->length;

    // collect slot index unchanged, but moved slot will push other move as whole
    int                        unchanged[slotCount];

    for (int i = 0, frameIndex = 0; i < jsonDrawOrder->valueList->size; ++i, ++frameIndex)
    {
        JsonObject* drawOrderObject = AJsonArray->GetObject(jsonDrawOrder,    i);
        float       time            = AJsonObject->GetFloat (drawOrderObject,  "time", 0.0f);

        JsonArray*  offsets         = AJsonObject->GetArray(drawOrderObject, "offsets");
        Array(int)* drawOrderArr    = NULL;

        if (offsets != NULL)
        {
            drawOrderArr   = AArray->Create(sizeof(int), slotCount);
            int* drawOrder = drawOrderArr->data;

            // set default value
            memset(drawOrder, -1, slotCount * sizeof(int));
            memset(unchanged, -1, slotCount * sizeof(int));

            int originalIndex  = 0;
            int unchangedIndex = 0;
            int slotIndex;

            for (int j = 0; j < offsets->valueList->size; ++j)
            {
                JsonObject* offset       = AJsonArray->GetObject(offsets, j);
                char*       slotName     = AJsonObject->GetString(offset,  "slot",   NULL);
                int         offsetIndex  = AJsonObject->GetInt   (offset,  "offset", 0);
                slotIndex                = FindSlotIndex(skeletonData, slotName);

                ALog_A
                (
                    slotIndex != -1,
                    "ASkeletonData ReadAnimationDrawOrders cannot find slot by offset name = %s",
                    slotName
                );

                // collect unchanged index until the offset index
                while (originalIndex != slotIndex)
                {
                    unchanged[unchangedIndex++] = originalIndex++;
                }

                // set changed index to new index in drawOrder
                // drawOrder first collect offset index to the right place
                drawOrder[originalIndex + offsetIndex] = originalIndex;
                ++originalIndex;
            }

            // collect remaining unchanged index
            // then unchanged collect all index not offset
            while (originalIndex < slotCount)
            {
                unchanged[unchangedIndex++] = originalIndex++;
            }

            // drawOrder have all offset index
            // fill in unchanged index to drawOrder by reverse order
            for (int j = slotCount - 1; j > -1; --j)
            {
                if (drawOrder[j] == -1)
                {
                    drawOrder[j] = unchanged[--unchangedIndex];
                }
            }

        }
        else
        {
            ALog_W("ASkeletonData ReadAnimationDrawOrders drawOrder offsets not found");
        }

        ASkeletonTimeline->SetDrawOrderFrame(drawOrderTimeline, frameIndex, time, drawOrderArr);
    }

    SkeletonTimeline* skeletonTimeline = drawOrderTimeline->skeletonTimeline;
    // because array is const no address
    // so array equals &array
    // and we use temporary variable to get the "array variable" address
    AArrayList_Add(skeletonTimelineArr, skeletonTimeline);

    animationData->duration = AMath_Max
                              (
                                  animationData->duration,
                                  AArray_Get
                                  (
                                      drawOrderTimeline->frameArr,
                                      drawOrderTimeline->frameArr->length - 1,
                                      float
                                  )
                              );

    // ALog_A(0, "stop");
}


static inline void ReadAnimationDeform
(
    SkeletonData*                 skeletonData,
    JsonObject*                   jsonDeform,
    SkeletonAnimationData*        animationData,
    ArrayList(SkeletonTimeline*)* skeletonTimelineArr
)
{
    for (int i = 0; i < jsonDeform->valueMap->elementList->size; ++i)
    {
        const char*       skinName = AJsonObject->GetKey(jsonDeform, i);
        SkeletonSkinData* skinData = AArrayStrMap_Get(skeletonData->skinDataMap, skinName, SkeletonSkinData*);

        ALog_A(skinData != NULL, "ASkeletonData ReadAnimationDeform deform skin not found %s", skinName);

        JsonObject* jsonSlots = AJsonObject->GetObjectByIndex(jsonDeform, i);
        for (int j = 0; j < jsonSlots->valueMap->elementList->size; ++j)
        {
            const char* slotName  = AJsonObject->GetKey(jsonSlots, j);
            int         slotIndex = FindSlotIndex(skeletonData, slotName);

            ALog_A
            (
                slotIndex != -1,
                "ASkeletonData ReadAnimationDeform deform not found slot = %s in slotDataOrderArr",
                slotName
            );

            JsonObject* jsonMeshes = AJsonObject->GetObjectByIndex(jsonSlots, j);
            for (int k = 0; k < jsonMeshes->valueMap->elementList->size; ++k)
            {
                JsonArray*              jsonMeshArr    = AJsonObject->GetArrayByIndex   (jsonMeshes, k);
                const char*             meshName       = AJsonObject->GetKey            (jsonMeshes, k);
                SkeletonDeformTimeline* deformTimeline = ASkeletonTimeline->CreateDeform(jsonMeshArr->valueList->size);
                SkeletonAttachmentData* attachmentData = GetAttachmentDataBySkinData(skinData, slotName, meshName);

                ALog_A
                (
                    attachmentData != NULL,
                    "ASkeletonData ReadAnimationDeform mesh attachment %s not found, slotName = %s, skinName = %s",
                    meshName, slotName, skinName
                );

                deformTimeline->slotIndex      = slotIndex;
                deformTimeline->attachmentData = attachmentData;

                Array(float)* meshVertices = NULL;

                switch (attachmentData->type)
                {
                    case SkeletonAttachmentDataType_Region:
                    case SkeletonAttachmentDataType_BoundingBox:
                        ALog_A
                        (
                            false,
                            "ASkeletonData ReadAnimationDeform attachmentData->type only can be "
                            "SkeletonAttachmentDataType_Mesh | SkeletonAttachmentDataType_SkinnedMesh"
                        );
                        break;

                    case SkeletonAttachmentDataType_Mesh:
                        meshVertices = ((SkeletonMeshAttachmentData*) attachmentData->childPtr)->vertexArr;
                        break;


                    case SkeletonAttachmentDataType_SkinnedMesh:
                        meshVertices = ((SkeletonSkinnedMeshAttachmentData*) attachmentData->childPtr)->weightVertexArr;
                        break;
                }

                for (int l = 0, frameIndex = 0; l < jsonMeshArr->valueList->size; ++l, ++frameIndex)
                {
                    JsonObject*   jsonMesh      = AJsonArray->GetObject(jsonMeshArr, l);
                    JsonArray*    jsonVertexArr = AJsonObject->GetArray(jsonMesh,    "vertices");
                    Array(float)* vertexArr     = AArray->Create(sizeof(float), meshVertices->length);

                    memcpy(vertexArr->data, meshVertices->data, sizeof(float) * meshVertices->length);

                    if (jsonVertexArr != NULL)
                    {
                        float* vertexData = vertexArr->data;

                        // "offset" is how many entries are zeros at the start
                        // also, zeros at the end are not output
                        int    start      = AJsonObject->GetInt(jsonMesh, "offset", 0);

                        for (int m = 0; m < jsonVertexArr->valueList->size; ++m, ++start)
                        {
                            // jsonVertices is x,y
                            // vertexData   is x,y,z
                            // so convert   index in jsonVertices to vertexData
                            int   index        = (start >> 1) + start;
                            float vertex       = AJsonArray->GetFloat(jsonVertexArr, m) * ASkeletonData->scale;
                            vertexData[index] += AGLTool_ToGLWidth(vertex);
                        }
                    }

                    float time = AJsonObject->GetFloat(jsonMesh, "time", 0.0f);

                    ASkeletonTimeline->SetDeformFrame(deformTimeline, frameIndex, time, vertexArr);
                    ReadCurve(deformTimeline->curveTimeline, frameIndex, jsonMesh);
                }

                SkeletonTimeline* skeletonTimeline = deformTimeline->skeletonTimeline;
                // because array is const no address
                // so array equals &array
                // and we use temporary variable to get the "array variable" address
                AArrayList_Add(skeletonTimelineArr, skeletonTimeline);

                animationData->duration = AMath_Max
                                          (
                                              animationData->duration,
                                              AArray_Get
                                              (
                                                  deformTimeline->frameArr,
                                                  deformTimeline->frameArr->length - 1,
                                                  float
                                              )
                                          );
            }
        }
    }
}


static inline void ReadAnimationData(JsonObject* root, SkeletonData* skeletonData)
{
    JsonObject*  animationDataObject = AJsonObject->GetObject(root, "animations");
    ArrayStrMap* animationDataMap    = skeletonData->animationDataMap;

    ALog_A(animationDataObject, "ASkeletonData ReadAnimationData not found animations");

    AArrayStrMap->InitWithCapacity
    (
        sizeof(SkeletonAnimationData*),
        animationDataObject->valueMap->elementList->size,
        animationDataMap
    );

    for (int i = 0; i < animationDataObject->valueMap->elementList->size; ++i)
    {
        const char*            animationName       = AJsonObject->GetKey(animationDataObject, i);
        int                    animationNameLength = (int) strlen(animationName) + 1;
        SkeletonAnimationData* animationData       = malloc(sizeof(SkeletonAnimationData) + animationNameLength);

        animationData->duration = 0.0f;
        animationData->name     = (char*) animationData + sizeof(SkeletonAnimationData);
        memcpy((void*) animationData->name, animationName, (size_t) animationNameLength);

        ArrayList(SkeletonTimeline*)* skeletonTimelineArr = animationData->timelineArr;
        AArrayList->Init(sizeof(SkeletonTimeline*), skeletonTimelineArr);

        JsonObject* animationValue = AJsonObject->GetObjectByIndex(animationDataObject, i);
        JsonObject* jsonBones      = AJsonObject->GetObject(animationValue, "bones");
        if (jsonBones != NULL)
        {
            ReadAnimationBones(skeletonData, jsonBones, animationData, skeletonTimelineArr);
        }


        JsonObject* jsonSlots = AJsonObject->GetObject(animationValue, "slots");
        if (jsonSlots != NULL)
        {
            ReadAnimationSlots(skeletonData, jsonSlots, animationData, skeletonTimelineArr);
        }

        JsonArray* jsonEvents = AJsonObject->GetArray(animationValue, "events");
        if (jsonEvents != NULL)
        {
            ReadAnimationEvents(skeletonData, jsonEvents, animationData, skeletonTimelineArr);
        }

        JsonArray* jsonDrawOrder = AJsonObject->GetArray(animationValue, "drawOrder");
        if (jsonDrawOrder != NULL)
        {
            ReadAnimationDrawOrders(skeletonData, jsonDrawOrder, animationData, skeletonTimelineArr);
        }

        JsonObject* jsonDeform = AJsonObject->GetObject(animationValue, "deform");
        if (jsonDeform != NULL)
        {
            ReadAnimationDeform(skeletonData, jsonDeform, animationData, skeletonTimelineArr);
        }

        AArrayList->Shrink(skeletonTimelineArr);
        AArrayStrMap_TryPut(animationDataMap, animationName, animationData);
    }
}


static inline void ReadEventData(JsonObject* root, SkeletonData* skeletonData)
{
    JsonObject*  eventObject  = AJsonObject->GetObject(root, "events");
    ArrayStrMap* eventDataMap = skeletonData->eventDataMap;

    int size = 0;
    if (eventObject != NULL)
    {
        size = eventObject->valueMap->elementList->size;
    }

    AArrayStrMap->InitWithCapacity(sizeof(SkeletonEventData*), size, eventDataMap);

    for (int i = 0; i < size; ++i)
    {
        JsonObject* eventValue = AJsonObject->GetObjectByIndex(eventObject, i);

        if (eventValue->valueMap->elementList->size == 0)
        {
            continue;
        }

        char* stringValue              = AJsonObject->GetString(eventValue,  "string", NULL);
        const char* name               = AJsonObject->GetKey   (eventObject, i);
        int   nameLength               = (int) strlen(name)        + 1;
        int   valueLength              = (int) strlen(stringValue) + 1;

        SkeletonEventData* eventData   = malloc(sizeof(SkeletonEventData) + nameLength + valueLength);

        eventData->name                = (char*) eventData + sizeof(SkeletonEventData);
        memcpy((void*) eventData->name, name, (size_t) nameLength);

        eventData->stringValue         = (char*) eventData + sizeof(SkeletonEventData) + nameLength;
        memcpy((void*) eventData->stringValue, stringValue, (size_t) valueLength);

        eventData->intValue            = AJsonObject->GetInt  (eventValue, "int",   0);
        eventData->floatValue          = AJsonObject->GetFloat(eventValue, "float", 0.0f);

        AArrayStrMap_TryPut(eventDataMap, name, eventData);
    }
}


static inline void ReadSkeletonData(JsonObject* root, SkeletonData* skeletonData)
{
    JsonObject* skeletonObject = AJsonObject->GetObject(root, "skeleton");

    if (skeletonObject != NULL)
    {
        skeletonData->width  = AJsonObject->GetFloat(skeletonObject, "width",  0.0f);
        skeletonData->height = AJsonObject->GetFloat(skeletonObject, "height", 0.0f);

        skeletonData->width  = AGLTool_ToGLWidth (skeletonData->width);
        skeletonData->height = AGLTool_ToGLHeight(skeletonData->height);
    }
}


static inline void Parse(SkeletonData* skeletonData, const char* jsonFilePath)
{
    JsonValue*  value = AJson->ParseFile(jsonFilePath);
    JsonObject* root  = value->jsonObject;

    // skeleton
    ReadSkeletonData(root, skeletonData);

    // bones
    ReadBoneData(root, skeletonData);

    // slots
    ReadSlotData(root, skeletonData);

    // events
    ReadEventData(root, skeletonData);

    // skins
    ReadSkinData(root, skeletonData);

    // animations
    ReadAnimationData(root, skeletonData);

    // json
    AJson->Destroy(value);
}


static inline void InitAtlas(SkeletonData* skeletonData, char* atlasPath)
{
    skeletonData->textureAtlas                 = ATextureAtlas->Get(atlasPath);
    ArrayStrMap*              skinDataMap      = skeletonData->skinDataMap;
    Array(SkeletonSlotData*)* slotDataOrderArr = skeletonData->slotDataOrderArr;

    AArrayList->InitWithCapacity(sizeof(SkeletonAttachmentData*), 20, skeletonData->attachmentDataList);

    int quadCounts[skeletonData->textureAtlas->textureList->size];
    memset(quadCounts, 0, sizeof(int) * skeletonData->textureAtlas->textureList->size);

    for (int i = 0; i < slotDataOrderArr->length; ++i)
    {
        SkeletonSlotData* slotData   = AArray_Get(slotDataOrderArr, i, SkeletonSlotData*);
        slotData->attachmentDataList = AArrayList->Create(sizeof(SkeletonAttachmentData*));

        // search all skin attachment
        for (int j = 0; j < skinDataMap->elementList->size; ++j)
        {
            // char*          skinName          = AArrayStrMap->GetKey(skinDataMap, j);
            SkeletonSkinData* skinData          = AArrayStrMap_GetAt(skinDataMap, j, SkeletonSkinData*);
            ArrayStrMap*      slotAttachmentMap = skinData->slotAttachmentMap;
            ArrayStrMap*      attachmentMap     = AArrayStrMap_Get(slotAttachmentMap, slotData->name, ArrayStrMap*);

            if (attachmentMap == NULL)
            {
                continue;
            }

            for (int k = 0; k < attachmentMap->elementList->size; ++k)
            {
//              const char*             attachmentName = AArrayStrMap->GetKey(attachmentMap, k);
                SkeletonAttachmentData* attachmentData = AArrayStrMap_GetAt(attachmentMap, k, SkeletonAttachmentData*);

                if (attachmentData->type == SkeletonAttachmentDataType_BoundingBox)
                {
                    continue;
                }

                // collect each skin attachmentData
                AArrayList_Add(slotData->attachmentDataList,     attachmentData);
                // collect all skin attachmentData
                AArrayList_Add(skeletonData->attachmentDataList, attachmentData);

                TextureAtlasQuad* atlasQuad = ATextureAtlas_GetQuad(skeletonData->textureAtlas, attachmentData->name);
                ALog_A
                (
                    atlasQuad != NULL,
                    "ASkeletonData InitAtlas cannot find attachment in TextureAtlas by name = %s",
                    attachmentData->name
                );

                switch (attachmentData->type)
                {
                    case SkeletonAttachmentDataType_Region:
                    {
                        SkeletonRegionAttachmentData* regionAttachmentData = attachmentData->childPtr;
                        regionAttachmentData->meshIndex                    = atlasQuad->textureIndex;
                        regionAttachmentData->quad                         = atlasQuad->quad;
                        regionAttachmentData->subMeshIndex                 = quadCounts[atlasQuad->textureIndex]++;
                        break;
                    }

                    case SkeletonAttachmentDataType_SkinnedMesh:
                    case SkeletonAttachmentDataType_Mesh:
                    {
                        SkeletonMeshAttachmentData* meshData;

                        if (attachmentData->type == SkeletonAttachmentDataType_SkinnedMesh)
                        {
                            meshData = ((SkeletonSkinnedMeshAttachmentData*) attachmentData->childPtr)
                                       ->meshAttachmentData;
                        }
                        else
                        {
                            meshData = (SkeletonMeshAttachmentData*) attachmentData->childPtr;
                        }

                        meshData->meshIndex    = atlasQuad->textureIndex;
                        meshData->quad         = atlasQuad->quad;
                        meshData->subMeshIndex = quadCounts[atlasQuad->textureIndex]++;
                        break;
                    }
                        
                    case SkeletonAttachmentDataType_BoundingBox:
                        break;
                }
            }
        }

        AArrayList->Shrink(slotData->attachmentDataList);
        AArrayList->Shrink(skeletonData->attachmentDataList);
    }
}


static SkeletonData* Get(const char* jsonFilePath)
{
    SkeletonData* skeletonData = AArrayStrMap_Get(skeletonDataMap, jsonFilePath, SkeletonData*);

    if (skeletonData == NULL)
    {
        skeletonData = malloc(sizeof(SkeletonData));

        char path[strlen(jsonFilePath) + sizeof(".atlas.json")];

        sprintf(path, "%s.json",  jsonFilePath);
        Parse(skeletonData, path);

        sprintf(path, "%s.atlas", jsonFilePath);
        InitAtlas(skeletonData, path);

        skeletonData->filePath = AArrayStrMap_GetKey
                                 (
                                     AArrayStrMap_TryPut(skeletonDataMap, jsonFilePath, skeletonData),
                                     skeletonDataMap->valueTypeSize
                                 );
    }

//  Release(skeletonData);
//  ALog_A(0, "Stop");

    return skeletonData;
}


struct ASkeletonData ASkeletonData[1] =
{{
    1.0f,
    Get,
    Release,
    GetAttachmentDataBySkinData,
}};


SkeletonAttachmentMeshOffset skeletonAttachmentMeshOffset[3] =
{
    SkeletonAttachmentMeshOffset_RegionIndex,
    SkeletonAttachmentMeshOffset_MeshIndex,
    SkeletonAttachmentMeshOffset_SkinnedMeshIndex,
};


SkeletonAttachmentSubMeshOffset skeletonAttachmentSubMeshOffset[3] =
{
    SkeletonAttachmentSubMeshOffset_RegionSubIndex,
    SkeletonAttachmentSubMeshOffset_MeshSubIndex,
    SkeletonAttachmentSubMeshOffset_SkinnedMeshSubIndex,
};

```

`Engine/Extension/Spine/SkeletonData.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-6-27
 * Update   : 2019-2-13
 * Author   : scott.cgi
 */


#ifndef SKELETON_DATA_H
#define SKELETON_DATA_H


#include <stdbool.h>
#include "Engine/Toolkit/Utils/ArrayStrMap.h"
#include "Engine/Graphics/Draw/Color.h"
#include "Engine/Graphics/OpenGL/Mesh.h"
#include "Engine/Extension/TextureAtlas.h"


typedef struct SkeletonBoneData SkeletonBoneData;

/**
 * The skeleton bone data read from json file.
 */
struct  SkeletonBoneData
{
    SkeletonBoneData* parent;
    const char*       name;
    float             length;
    float             x;
    float             y;
    float             rotationZ;
    float             scaleX;
    float             scaleY;
    bool              isInheritScale;
    bool              isInheritRotation;
};


/**
 * The skeleton slot data read from json file.
 */
typedef struct
{
    const char*                         name;
    const char*                         attachmentName;
    bool                                isAdditiveBlending;
    SkeletonBoneData*                   boneData;
    Color                               color[1];

    /**
     * The skin's SkeletonAttachmentData may not exits.
     */
    ArrayList(SkeletonAttachmentData*)* attachmentDataList;
}
SkeletonSlotData;


/**
 * The skeleton event data read from json file.
 */
typedef struct
{
    const char* name;
    const char* stringValue;
    int         intValue;
    float       floatValue;
}
SkeletonEventData;


/**
 * The skeleton animation data read from json file.
 */
typedef struct
{
    const char*                  name;
    float                        duration;
    ArrayList(SkeletonTimeline*) timelineArr[1];
}
SkeletonAnimationData;


/**
 * The skeleton skin data read from json file.
 */
typedef struct
{
    /**
     * The slotAttachmentMap key is slotData name,        value is attachmentDataMap.
     * the attachmentDataMap key is slot attachment name, value is SkeletonAttachmentData.
     */
    ArrayStrMap
    (
        slotName,
        ArrayStrMap(attachmentName, SkeletonAttachmentData*)*
    )
    slotAttachmentMap[1];

    const char* name;
}
SkeletonSkinData;


//----------------------------------------------------------------------------------------------------------------------


typedef enum
{
    SkeletonAttachmentDataType_Region,
    SkeletonAttachmentDataType_Mesh,
    SkeletonAttachmentDataType_SkinnedMesh,
    SkeletonAttachmentDataType_BoundingBox,
}
SkeletonAttachmentDataType;


/**
 * The abstract skeleton attachment data.
 */
typedef struct
{
    /**
     * Attachment actual name.
     */
    const char*                name;

    /**
     * Subclass attachment pointer.
     */
    void*                      childPtr;
    SkeletonAttachmentDataType type;
}
SkeletonAttachmentData;


/**
 * The skeleton region attachment data read from json file.
 */
typedef struct
{
    float                  x;
    float                  y;
    float                  rotationZ;
    float                  scaleX;
    float                  scaleY;
    float                  width;
    float                  height;
    SkeletonAttachmentData attachmentData[1];

    /**
     * Index of meshList in Skeleton.
     */
    int                    meshIndex;

    /**
     * Index of SubMeshList in Mesh.
     */
    int                    subMeshIndex;

    /**
     * Texture atlas quad.
     */
    Quad*                  quad;
}
SkeletonRegionAttachmentData;


/**
 * The skeleton boundingBox attachment data read from json file.
 */
typedef struct
{
    SkeletonAttachmentData attachmentData[1];
    Array(float)           vertexArr     [1];
}
SkeletonBoundingBoxAttachmentData;


/**
 * The skeleton mesh attachment data read from json file.
 */
typedef struct
{
    float                  width;
    float                  height;
    SkeletonAttachmentData attachmentData[1];

    Array(float)           vertexArr     [1];
    Array(float)           uvArr         [1];

    /**
     * Careful 4 byte aligned.
     */
    Array(short)           triangleArr   [1];

    /**
     * Index of meshList in Skeleton.
     */
    int                    meshIndex;

    /**
     * Index of SubMeshList in Mesh.
     */
    int                    subMeshIndex;

    /**
     * Texture atlas quad.
     */
    Quad*                  quad;

    /**
     * Whether convert uv data to TextureAtlas.
     */
    bool                   isUVMappedInTexture;
}
SkeletonMeshAttachmentData;


/**
 * The skeleton skinned mesh attachment data read from json file.
 */
typedef struct
{
    Array(int)                 boneArr           [1];
    Array(float)               weightArr         [1];
    Array(float)               weightVertexArr   [1];
    SkeletonMeshAttachmentData meshAttachmentData[1];
}
SkeletonSkinnedMeshAttachmentData;


typedef enum
{
    SkeletonAttachmentMeshOffset_RegionIndex      = (int) offsetof(SkeletonRegionAttachmentData, meshIndex),
    SkeletonAttachmentMeshOffset_MeshIndex        = (int) offsetof(SkeletonMeshAttachmentData,   meshIndex),
    SkeletonAttachmentMeshOffset_SkinnedMeshIndex = (int) offsetof
                                                          (
                                                              SkeletonSkinnedMeshAttachmentData,
                                                              meshAttachmentData
                                                          )
                                                          + SkeletonAttachmentMeshOffset_MeshIndex,
}
SkeletonAttachmentMeshOffset;


extern SkeletonAttachmentMeshOffset skeletonAttachmentMeshOffset[3];


typedef enum
{
    SkeletonAttachmentSubMeshOffset_RegionSubIndex      = (int) offsetof(SkeletonRegionAttachmentData, subMeshIndex),
    SkeletonAttachmentSubMeshOffset_MeshSubIndex        = (int) offsetof(SkeletonMeshAttachmentData,   subMeshIndex),
    SkeletonAttachmentSubMeshOffset_SkinnedMeshSubIndex = (int) offsetof
                                                                (
                                                                    SkeletonSkinnedMeshAttachmentData,
                                                                    meshAttachmentData
                                                                )
                                                                + SkeletonAttachmentSubMeshOffset_MeshSubIndex,
}
SkeletonAttachmentSubMeshOffset;


extern SkeletonAttachmentSubMeshOffset skeletonAttachmentSubMeshOffset[3];


//----------------------------------------------------------------------------------------------------------------------


/**
 * The skeleton data read from json file.
 */
typedef struct
{
    float                                                 width;
    float                                                 height;
    const char*                                           filePath;
    TextureAtlas*                                         textureAtlas;
    SkeletonSkinData*                                     skinDataDefault;

    ArrayStrMap(boneName,      SkeletonBoneData*)         boneDataMap     [1];
    ArrayStrMap(slotName,      SkeletonSlotData*)         slotDataMap     [1];
    ArrayStrMap(skinName,      SkeletonSkinData*)         skinDataMap     [1];
    ArrayStrMap(animationName, SkeletonAnimationDataMap*) animationDataMap[1];
    ArrayStrMap(eventName,     SkeletonEventDataMap*)     eventDataMap    [1];

    /**
     * All SkeletonBoneData order same as in JSON.
     */
    Array(SkeletonBoneData*)*                             boneDataOrderArr;

    /**
     * All SkeletonSlotData order same as in JSON.
     */
    Array(SkeletonSlotData*)*                             slotDataOrderArr;

    /**
     * All slot attachments.
     */
    ArrayList(SkeletonAttachmentData*)                    attachmentDataList[1];
}
SkeletonData;


/**
 * Control and mange SkeletonData.
 */
struct ASkeletonData
{
    /**
     * Scales the bones, images, and animations as they are loaded, default 1.0.
     */
    float scale;

    /**
     * Get SkeletonData by jsonFilePath, not found will create one.
     *
     * jsonFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    SkeletonData*           (*Get)                        (const char*          jsonFilePath);
    void                    (*Release)                    (SkeletonData*        skeletonData);
    SkeletonAttachmentData* (*GetAttachmentDataBySkinData)(
                                                              SkeletonSkinData* skinData,
                                                              const char*       slotName,
                                                              const char*       attachmentName
                                                          );
};


extern struct ASkeletonData ASkeletonData[1];


#endif

```

`Engine/Extension/Spine/SkeletonSlot.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-7-7
 * Update   : 2019-2-12
 * Author   : scott.cgi
 */


#include <string.h>
#include "Engine/Graphics/OpenGL/SubMesh.h"
#include "Engine/Extension/Spine/SkeletonSlot.h"


static inline void SetAttachmentToBone(SkeletonSlot* slot)
{
    SkeletonAttachmentData* attachmentData = slot->attachmentData;
    Drawable*               drawable;

    switch (attachmentData->type)
    {
        case SkeletonAttachmentDataType_Region:
        {
            SkeletonRegionAttachmentData* regionAttachmentData = attachmentData->childPtr;
            SubMesh*                      subMesh              = AArrayList_Get
                                                                 (
                                                                     AArrayList_GetPtr
                                                                     (
                                                                         slot->skeleton->meshList,
                                                                         regionAttachmentData->meshIndex,
                                                                         Mesh
                                                                     )
                                                                     ->childList,
                                                                     
                                                                     regionAttachmentData->subMeshIndex,
                                                                     SubMesh*
                                                                 );

            drawable         = subMesh->drawable;
            drawable->width  = regionAttachmentData->width;
            drawable->height = regionAttachmentData->height;

            ADrawable_SetParent   (drawable, slot->bone->drawable);
            ADrawable_SetPosition2(drawable, regionAttachmentData->x,      regionAttachmentData->y);
            ADrawable_SetRotationZ(drawable, regionAttachmentData->rotationZ);
            ADrawable_SetScale2   (drawable, regionAttachmentData->scaleX, regionAttachmentData->scaleY);

            break;
        }

        case SkeletonAttachmentDataType_Mesh:
        {
            SkeletonMeshAttachmentData* meshAttachmentData = attachmentData->childPtr;
            SubMesh*                    subMesh            = AArrayList_Get
                                                             (
                                                                 AArrayList_GetPtr
                                                                 (
                                                                     slot->skeleton->meshList,
                                                                     meshAttachmentData->meshIndex,
                                                                     Mesh
                                                                 )
                                                                 ->childList,
                                                                 
                                                                 meshAttachmentData->subMeshIndex,
                                                                 SubMesh*
                                                             );

            drawable         = subMesh->drawable;
            drawable->width  = meshAttachmentData->width;
            drawable->height = meshAttachmentData->height;
            ADrawable_SetParent(drawable, slot->bone->drawable);

            break;
        }

        case SkeletonAttachmentDataType_SkinnedMesh:
        {
            SkeletonSkinnedMeshAttachmentData* skinnedMeshAttachmentData = attachmentData->childPtr;
            SkeletonMeshAttachmentData*        meshAttachmentData        = skinnedMeshAttachmentData->meshAttachmentData;
            SubMesh*                           subMesh                   = AArrayList_Get
                                                                           (
                                                                             AArrayList_GetPtr
                                                                             (
                                                                                 slot->skeleton->meshList,
                                                                                 meshAttachmentData->meshIndex,
                                                                                 Mesh
                                                                             )
                                                                             ->childList,

                                                                             meshAttachmentData->subMeshIndex,
                                                                             SubMesh*
                                                                           );

            float* positions      = subMesh->positionArr->data;
            int*   bones          = skinnedMeshAttachmentData->boneArr->data;
            float* weights        = skinnedMeshAttachmentData->weightArr->data;
            float* weightVertices = skinnedMeshAttachmentData->weightVertexArr->data;

            for (int i = 0, w = 0, v = 0, p = 0; i < skinnedMeshAttachmentData->boneArr->length; p += 3)
            {
                float wx = 0.0f;
                float wy = 0.0f;
                int   k  = bones[i] + i + 1;
                
                ++i;

                for (; i < k; ++i, ++w, v += 3)
                {
                    int           boneIndex = bones[i];
                    SkeletonBone* bone      = AArray_GetPtr(slot->skeleton->boneArr, boneIndex, SkeletonBone);
                    float         weight    = weights[w];
                    Vector2       v2[1];

                    AMatrix->MultiplyMV2
                    (
                        bone->drawable->modelMatrix,
                        weightVertices[v],
                        weightVertices[v + 1],
                        v2
                    );

                    wx += v2->x * weight;
                    wy += v2->y * weight;
                }

                positions[p]     = wx;
                positions[p + 1] = wy;
            }

            drawable = subMesh->drawable;
            // we compute final world coordinate, so no parent
            ADrawable_SetParent(drawable, NULL);

            break;
        }

        default:
            return;
    }

    if (memcmp(drawable->color, slot->color, sizeof(Color)) != 0)
    {
        ADrawable_SetColor(drawable, slot->color);
    }

    if (ADrawable_CheckVisible(drawable) == false)
    {
        ADrawable_SetVisible(drawable);
    }
}


static void SetAttachmentData(SkeletonSlot* slot, SkeletonAttachmentData* attachmentData)
{
    if (slot->attachmentData == attachmentData)
    {
        return;
    }

    if (slot->attachmentData != NULL)
    {
        SubMesh* subMesh = ASkeleton->GetAttachmentSubMesh(slot->skeleton, slot->attachmentData);

        if (subMesh != NULL)
        {
            ADrawable_SetInvisible(subMesh->drawable);
        }
    }

    slot->attachmentData = attachmentData;
    *slot->color         = *slot->slotData->color;

    if (attachmentData != NULL)
    {
        SetAttachmentToBone(slot);
    }
}


static void SetToSetupPose(SkeletonSlot* slot)
{
    const char* attachmentName = slot->slotData->attachmentName;

    if (attachmentName != NULL)
    {
        SetAttachmentData(slot, ASkeleton->GetAttachmentData(slot->skeleton, slot->slotData->name, attachmentName));
    }
}


static void Init(SkeletonSlotData* slotData, Skeleton* skeleton, SkeletonSlot* outSlot)
{
    outSlot->slotData       = slotData;
    outSlot->skeleton       = skeleton;
    outSlot->attachmentData = NULL;
    outSlot->bone           = AArrayStrMap_Get(skeleton->boneMap, slotData->boneData->name, SkeletonBone*);

    SetToSetupPose(outSlot);
}


static SkeletonSlot* Create(SkeletonSlotData* slotData, Skeleton* skeleton)
{
    SkeletonSlot* slot = malloc(sizeof(SkeletonSlot));
    Init(slotData, skeleton, slot);

    return slot;
}


struct ASkeletonSlot ASkeletonSlot[1] =
{{
    Create,
    Init,
    SetAttachmentData,
    SetToSetupPose,
}};


```

`Engine/Extension/Spine/SkeletonSlot.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-7-7
 * Update   : 2019-2-12
 * Author   : scott.cgi
 */


#ifndef SKELETON_SLOT_H
#define SKELETON_SLOT_H


#include "Engine/Extension/Spine/SkeletonData.h"
#include "Engine/Extension/Spine/SkeletonBone.h"
#include "Engine/Extension/Spine/Skeleton.h"


/**
 * The skeleton slot can provide color and texture.
 */
typedef struct
{
    Color                   color[1];
    SkeletonBone*           bone;
    SkeletonSlotData*       slotData;
    Skeleton*               skeleton;
    SkeletonAttachmentData* attachmentData;
}
SkeletonSlot;


struct ASkeletonSlot
{
    SkeletonSlot* (*Create)           (SkeletonSlotData* slotData, Skeleton* skeleton);
    void          (*Init)             (SkeletonSlotData* slotData, Skeleton* skeleton, SkeletonSlot* outSlot);

    void          (*SetAttachmentData)(SkeletonSlot* slot, SkeletonAttachmentData* attachmentData);

    /**
     * Set slot to setup pose.
     */
    void          (*SetToSetupPose)   (SkeletonSlot* slot);
};


extern struct ASkeletonSlot ASkeletonSlot[1];


/**
 * Get boundingBox in slot.
 */
static inline SkeletonBoundingBoxAttachmentData* ASkeletonSlot_GetBoundingBox(SkeletonSlot* slot)
{
    return slot->attachmentData->childPtr;
}


/**
 * Get region in slot.
 */
static inline SkeletonRegionAttachmentData* ASkeletonSlot_GetRegion(SkeletonSlot* slot)
{
    return slot->attachmentData->childPtr;
}


/**
 * Get mesh in slot.
 */
static inline SkeletonMeshAttachmentData* ASkeletonSlot_GetMesh(SkeletonSlot* slot)
{
    return slot->attachmentData->childPtr;
}


/**
 * Get skinned mesh in slot.
 */
static inline SkeletonSkinnedMeshAttachmentData* ASkeletonSlot_GetSkinnedMesh(SkeletonSlot* slot)
{
    return slot->attachmentData->childPtr;
}


#endif

```

`Engine/Extension/Spine/SkeletonTimeline.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-7-3
 * Update   : 2019-2-2
 * Author   : scott.cgi
 */


#include <stdbool.h>
#include <string.h>

#include "Engine/Graphics/OpenGL/SubMesh.h"
#include "Engine/Extension/Spine/SkeletonTimeline.h"
#include "Engine/Toolkit/Platform/Log.h"


/**
 * The target After the first and before the last entry.
 */
static inline int BinarySearchByStep(const float values[], int valuesLength, float target, int step)
{
    int low  = 0;
    int high = valuesLength / step - 2;

    if (high <= 0)
    {
        return step;
    }

    int current = (unsigned int) high >> 1;

    while (true)
    {
        if (values[(current + 1) * step] <= target)
        {
            low  = current + 1;
        }
        else
        {
            high = current;
        }

        if (low == high)
        {
            return (low + 1) * step;
        }

        current = (unsigned int) (low + high) >> 1;
    }
}


/**
 * The target After the first and before the last entry.
 */
static inline int BinarySearch(const float values[], int valuesLength, float target)
{
    int low  = 0;
    int high = valuesLength - 2;

    if (high <= 0)
    {
        return 1;
    }

    int current = (unsigned int) high >> 1;

    while (true)
    {
        if (values[current + 1] <= target)
        {
            low  = current + 1;
        }
        else
        {
            high = current;
        }

        if (low == high)
        {
            return low + 1;
        }

        current = (unsigned int) (low + high) >> 1;
    }
}


enum
{
    Bezier_Segments = 12,
    Bezier_Size     = ((Bezier_Segments + 1) << 1) - 1,
};


static inline void SetLinear(SkeletonCurveTimeline* curveTimeline, int frameIndex)
{
    AArray_Set(curveTimeline->curveArr, frameIndex * Bezier_Size, SkeletonCurveType_Linear, float);
}


static inline void SetStepped(SkeletonCurveTimeline* curveTimeline, int frameIndex)
{
    AArray_Set(curveTimeline->curveArr, frameIndex * Bezier_Size, SkeletonCurveType_Stepped, float);
}


static const float subDivStep  = 1.0f        / Bezier_Segments;
static const float subDivStep2 = subDivStep  * subDivStep;
static const float subDivStep3 = subDivStep2 * subDivStep;
static const float pre1        = 3           * subDivStep;
static const float pre2        = 3           * subDivStep2;
static const float pre4        = 6           * subDivStep2;
static const float pre5        = 6           * subDivStep3;
static const float subDivPre   = subDivStep3 / pre5;


static void SetCurve(SkeletonCurveTimeline* curveTimeline, int frameIndex, float cx1, float cy1, float cx2, float cy2)
{
    float  tmpx   = -cx1 * 2 + cx2;
    float  tmpy   = -cy1 * 2 + cy2;

    float  dddfx  = ((cx1 - cx2) * 3 + 1) * pre5;
    float  dddfy  = ((cy1 - cy2) * 3 + 1) * pre5;

    float  ddfx   = tmpx * pre4 + dddfx;
    float  ddfy   = tmpy * pre4 + dddfy;

    float  dfx    = cx1 * pre1 + tmpx * pre2 + dddfx * subDivPre;
    float  dfy    = cy1 * pre1 + tmpy * pre2 + dddfy * subDivPre;

    float* curves = curveTimeline->curveArr->data;
    int    i      = frameIndex * Bezier_Size;
    curves[i++]   = SkeletonCurveType_Bezier;

    float  x      = dfx;
    float  y      = dfy;

    for (int n = i + Bezier_Size - 1; i < n; i += 2)
    {
        curves[i]     = x;
        curves[i + 1] = y;

        dfx          += ddfx;
        dfy          += ddfy;
        ddfx         += dddfx;
        ddfy         += dddfy;

        x            += dfx;
        y            += dfy;
    }
}


static inline float GetCurvePercent(SkeletonCurveTimeline* curveTimeline, int frameIndex, float percent)
{
    int    i      = frameIndex * Bezier_Size;
    float* curves = curveTimeline->curveArr->data;
    float  dfx    = curves[i];

    switch ((int) dfx)
    {
        case SkeletonCurveType_Linear:
            return AMath_Clamp(percent, 0.0f, 1.0f);

        case SkeletonCurveType_Bezier:
        {
            ++i;
            percent = AMath_Clamp(percent, 0.0f, 1.0f);
            float x  = 0.0f;

            for (int start = i, n = i + Bezier_Size - 1; i < n; i += 2)
            {
                x = curves[i];

                if (x >= percent)
                {
                    float preX;
                    float preY;

                    if (i == start)
                    {
                        preX = 0;
                        preY = 0;
                    }
                    else
                    {
                        preX = curves[i - 2];
                        preY = curves[i - 1];
                    }

                    return preY + (curves[i + 1] - preY) * (percent - preX) / (x - preX);
                }
            }

            float y = curves[i - 1];

            // last point is 1, 1
            return y + (1 - y) * (percent - x) / (1 - x);
        }

        case SkeletonCurveType_Stepped:
            break;
        default:
            break;
    }

    return 0.0f;
}


static inline void CurveRelease(SkeletonCurveTimeline* curveTimeline)
{
    free(curveTimeline->curveArr);
    curveTimeline->curveArr = NULL;
}


static inline void CurveTimelineInit(SkeletonCurveTimeline* curveTimeline, int frameCount)
{
    curveTimeline->curveArr = AArray->Create(sizeof(float), frameCount * Bezier_Size);
}


//----------------------------------------------------------------------------------------------------------------------


enum 
{
    RotateFrame_Value = 1,
    RotateFrame_Times = 2,
};


static void SetRotateFrame(SkeletonRotateTimeline* rotateTimeline, int frameIndex, float time, float angle)
{
    float* frames          = rotateTimeline->frameArr->data;
    frameIndex            *= RotateFrame_Times;
    frames[frameIndex]     = time;
    frames[frameIndex + 1] = angle;
}


static void RotateApply(SkeletonTimeline* skeletonTimeline, Skeleton* skeleton, float time, float mixPercent)
{
    SkeletonRotateTimeline* rotateTimeline = skeletonTimeline->childPtr;

    float* frames      = rotateTimeline->frameArr->data;
    int    frameLength = rotateTimeline->frameArr->length;

    if (time < frames[0])
    {
        // time is before first frame
        return;
    }

    SkeletonBone*     bone     = AArray_GetPtr(skeleton->boneArr, rotateTimeline->boneIndex, SkeletonBone);
    SkeletonBoneData* boneData = bone->boneData;
    Drawable*         drawable = bone->drawable;

    if (time >= frames[frameLength - RotateFrame_Times])
    {
        // time is after last frame

        float amount = boneData->rotationZ + frames[frameLength - 1] - drawable->rotationZ;

        while (amount > 180)
        {
            amount -= 360;
        }

        while (amount < -180)
        {
            amount += 360;
        }

        ADrawable_SetRotationZ(drawable, drawable->rotationZ + amount * mixPercent);
        return;
    }

    // interpolate between the last frame and the current frame
    int frameIndex       = BinarySearchByStep(frames, frameLength, time, RotateFrame_Times);

    float lastFrameValue = frames[frameIndex - 1];
    float frameTime      = frames[frameIndex];
    float percent        = GetCurvePercent
                          (
                              rotateTimeline->curveTimeline, (frameIndex >> 1) - 1,
                              1.0f - (time - frameTime) / (frames[frameIndex - RotateFrame_Times] - frameTime)
                          );
    float amount         = frames[frameIndex + RotateFrame_Value] - lastFrameValue;

    while (amount > 180)
    {
        amount -= 360;
    }

    while (amount < -180)
    {
        amount += 360;
    }

    amount = boneData->rotationZ + (lastFrameValue + amount * percent) - drawable->rotationZ;

    while (amount > 180)
    {
        amount -= 360;
    }

    while (amount < -180)
    {
        amount += 360;
    }

    ADrawable_SetRotationZ(drawable, drawable->rotationZ + amount * mixPercent);
}


static void RotateRelease(SkeletonTimeline* skeletonTimeline)
{
    SkeletonRotateTimeline* rotateTimeline = skeletonTimeline->childPtr;

    CurveRelease(rotateTimeline->curveTimeline);
    free(rotateTimeline->frameArr);
    rotateTimeline->frameArr = NULL;
}


static SkeletonRotateTimeline* CreateRotate(int frameCount, int boneIndex)
{
    SkeletonRotateTimeline* rotateTimeline     = malloc(sizeof(SkeletonRotateTimeline));

    CurveTimelineInit(rotateTimeline->curveTimeline, frameCount);

    rotateTimeline->skeletonTimeline->Apply    = RotateApply;
    rotateTimeline->skeletonTimeline->Release  = RotateRelease;
    rotateTimeline->skeletonTimeline->childPtr = rotateTimeline;

    rotateTimeline->frameArr                   = AArray->Create(sizeof(float), frameCount * RotateFrame_Times);
    rotateTimeline->boneIndex                  = boneIndex;

    return rotateTimeline;
}


//----------------------------------------------------------------------------------------------------------------------


enum
{
    TranslateFrame_X     = 1,
    TranslateFrame_Y     = 2,
    TranslateFrame_Times = 3,
};


static void SetTranslateFrame(SkeletonTranslateTimeline* translateTimeline, int frameIndex, float time, float x, float y)
{
    float* frames          = translateTimeline->frameArr->data;
    frameIndex            *= TranslateFrame_Times;
    frames[frameIndex]     = time;
    frames[frameIndex + 1] = x;
    frames[frameIndex + 2] = y;
}


static void TranslateApply(SkeletonTimeline* skeletonTimeline, Skeleton* skeleton, float time, float mixPercent)
{
    SkeletonTranslateTimeline* translateTimeline = skeletonTimeline->childPtr;
    float*                     frames            = translateTimeline->frameArr->data;

    if (time < frames[0])
    {
        return; // time is before first frame
    }

    int               frameLength = translateTimeline->frameArr->length;
    SkeletonBone*     bone        = AArray_GetPtr(skeleton->boneArr, translateTimeline->boneIndex, SkeletonBone);
    SkeletonBoneData* boneData    = bone->boneData;
    Drawable*         drawable    = bone->drawable;

    if (time >= frames[frameLength - TranslateFrame_Times])
    {
        // time is after last frame
        // each frame value is relative boneData x or y
        ADrawable_SetPosition2
        (
            drawable,
            drawable->positionX +
            (boneData->x + frames[frameLength - TranslateFrame_Y] - drawable->positionX) * mixPercent,
            drawable->positionY +
            (boneData->y + frames[frameLength - TranslateFrame_X] - drawable->positionY) * mixPercent
        );

        return;
    }

    // interpolate between the last frame and the current frame.
    int   frameIndex  = BinarySearchByStep(frames, frameLength, time, TranslateFrame_Times);
    float lastFrameX  = frames[frameIndex - TranslateFrame_Y];
    float lastFrameY  = frames[frameIndex - TranslateFrame_X];
    float frameTime   = frames[frameIndex];
    float percent     = GetCurvePercent
                        (
                            translateTimeline->curveTimeline, frameIndex / TranslateFrame_Times - 1,
                            1.0f - (time - frameTime) / (frames[frameIndex - TranslateFrame_Times] - frameTime)
                        );

    ADrawable_SetPosition2
    (
        drawable,
        
        drawable->positionX +
        (
            boneData->x + lastFrameX +
            (frames[frameIndex + TranslateFrame_X] - lastFrameX) * percent - drawable->positionX
        )
        * mixPercent,

        drawable->positionY +
        (
            boneData->y + lastFrameY +
            (frames[frameIndex + TranslateFrame_Y] - lastFrameY) * percent - drawable->positionY
        )
        * mixPercent
    );
}


static void TranslateRelease(SkeletonTimeline* skeletonTimeline)
{
    SkeletonTranslateTimeline* translateTimeline = skeletonTimeline->childPtr;

    CurveRelease(translateTimeline->curveTimeline);
    free(translateTimeline->frameArr);
    translateTimeline->frameArr = NULL;
}


static inline void TranslateTimelineInit(SkeletonTranslateTimeline* translateTimeline, int frameCount, int boneIndex)
{
    CurveTimelineInit(translateTimeline->curveTimeline, frameCount);

    translateTimeline->skeletonTimeline->Apply    = TranslateApply;
    translateTimeline->skeletonTimeline->Release  = TranslateRelease;
    translateTimeline->skeletonTimeline->childPtr = translateTimeline;

    translateTimeline->frameArr                   = AArray->Create(sizeof(float), frameCount * TranslateFrame_Times);
    translateTimeline->boneIndex                  = boneIndex;
}


static SkeletonTranslateTimeline* CreateTranslate(int frameCount, int boneIndex)
{
    SkeletonTranslateTimeline* translateTimeline = malloc(sizeof(SkeletonTranslateTimeline));
    TranslateTimelineInit(translateTimeline, frameCount, boneIndex);

    return translateTimeline;
}


//----------------------------------------------------------------------------------------------------------------------


static void ScaleApply(SkeletonTimeline* skeletonTimeline, Skeleton* skeleton, float time, float mixPercent)
{
    SkeletonScaleTimeline*     scaleTimeline     = skeletonTimeline->childPtr;
    SkeletonTranslateTimeline* translateTimeline = scaleTimeline->translateTimeline;

    float* frames = translateTimeline->frameArr->data;

    if (time < frames[0])
    {
        return; // time is before first frame
    }

    int               frameLength = translateTimeline->frameArr->length;
    SkeletonBone*     bone        = AArray_GetPtr(skeleton->boneArr, translateTimeline->boneIndex, SkeletonBone);
    SkeletonBoneData* boneData    = bone->boneData;
    Drawable*         drawable    = bone->drawable;

    if (time >= frames[frameLength - TranslateFrame_Times])
    {
        // time is after last frame
        // each frame scale value is relative 1.0 not boneData scale
        // so we use boneData scale - 1.0f
        ADrawable_SetScale2
        (
            drawable,

            drawable->scaleX +
            (boneData->scaleX - 1.0f + frames[frameLength - TranslateFrame_Y] - drawable->scaleX) * mixPercent,

            drawable->scaleY +
            (boneData->scaleY - 1.0f + frames[frameLength - TranslateFrame_X] - drawable->scaleY) * mixPercent
        );

        return;
    }

    // interpolate between the last frame and the current frame.
    int   frameIndex = BinarySearchByStep(frames, frameLength, time, TranslateFrame_Times);
    float lastFrameX = frames[frameIndex - TranslateFrame_Y];
    float lastFrameY = frames[frameIndex - TranslateFrame_X];
    float frameTime  = frames[frameIndex];

    float percent    = 1.0f - (time - frameTime) / (frames[frameIndex - TranslateFrame_Times] - frameTime);
    percent          = GetCurvePercent(translateTimeline->curveTimeline, frameIndex / TranslateFrame_Times - 1, percent);

    ADrawable_SetScale2
    (
        drawable,

        drawable->scaleX +
        (
            boneData->scaleX - 1.0f + lastFrameX +
            (frames[frameIndex + TranslateFrame_X] - lastFrameX) * percent - drawable->scaleX
        )
        * mixPercent,

        drawable->scaleY +
        (
            boneData->scaleY - 1.0f + lastFrameY +
            (frames[frameIndex + TranslateFrame_Y] - lastFrameY) * percent - drawable->scaleY
        )
        * mixPercent
    );
}


static void ScaleRelease(SkeletonTimeline* skeletonTimeline)
{
    SkeletonScaleTimeline* scaleTimeline = skeletonTimeline->childPtr;
    skeletonTimeline->childPtr           = scaleTimeline->translateTimeline;
    TranslateRelease(scaleTimeline->translateTimeline->skeletonTimeline);
}


static SkeletonScaleTimeline* CreateScale(int frameCount, int boneIndex)
{
    SkeletonScaleTimeline* scaleTimeline = malloc(sizeof(SkeletonScaleTimeline));
    TranslateTimelineInit(scaleTimeline->translateTimeline, frameCount, boneIndex);

    scaleTimeline->translateTimeline->skeletonTimeline->Apply    = ScaleApply;
    scaleTimeline->translateTimeline->skeletonTimeline->Release  = ScaleRelease;
    scaleTimeline->translateTimeline->skeletonTimeline->childPtr = scaleTimeline;

    return scaleTimeline;
}


//----------------------------------------------------------------------------------------------------------------------


enum
{
    ColorFrame_R     = 1,
    ColorFrame_G     = 2,
    ColorFrame_B     = 3,
    ColorFrame_A     = 4,
    ColorFrame_Times = 5,
};


static void SetColorFrame(SkeletonColorTimeline* colorTimeline, int frameIndex, float time,  Color* color)
{
    float* frames                     = colorTimeline->frameArr->data;
    frameIndex                       *= ColorFrame_Times;
    frames[frameIndex]                = time;
    frames[frameIndex + ColorFrame_R] = color->r;
    frames[frameIndex + ColorFrame_G] = color->g;
    frames[frameIndex + ColorFrame_B] = color->b;
    frames[frameIndex + ColorFrame_A] = color->a;
}


static void ColorApply(SkeletonTimeline* skeletonTimeline, Skeleton* skeleton, float time, float mixPercent)
{
    SkeletonColorTimeline* colorTimeline = skeletonTimeline->childPtr;
    float*                 frames        = colorTimeline->frameArr->data;

    if (time < frames[0])
    {
        return; // time is before first frame
    }

    SkeletonSlot* slot = AArray_GetPtr(skeleton->slotArr, colorTimeline->slotIndex, SkeletonSlot);

    if (slot->attachmentData == NULL)
    {
        return;
    }

    int    frameLength = colorTimeline->frameArr->length;
    Color* color       = slot->color;

    if (time >= frames[frameLength - ColorFrame_Times])
    {
        // time is after last frame.
        color->r = frames[frameLength - ColorFrame_A];
        color->g = frames[frameLength - ColorFrame_B];
        color->b = frames[frameLength - ColorFrame_G];
        color->a = frames[frameLength - ColorFrame_R];
    }
    else
    {
        // interpolate between the last frame and the current frame.
        int   frameIndex = BinarySearchByStep(frames, frameLength, time, ColorFrame_Times);
        float frameTime  = frames[frameIndex];
        float r          = frames[frameIndex - ColorFrame_A];
        float g          = frames[frameIndex - ColorFrame_B];
        float b          = frames[frameIndex - ColorFrame_G];
        float a          = frames[frameIndex - ColorFrame_R];

        float percent    = GetCurvePercent
                           (
                               colorTimeline->curveTimeline,
                               frameIndex / ColorFrame_Times - 1,
                               1.0f - (time - frameTime) / (frames[frameIndex - ColorFrame_Times] - frameTime)
                           );

        r               += (frames[frameIndex + ColorFrame_R] - r) * percent;
        g               += (frames[frameIndex + ColorFrame_G] - g) * percent;
        b               += (frames[frameIndex + ColorFrame_B] - b) * percent;
        a               += (frames[frameIndex + ColorFrame_A] - a) * percent;

        if (mixPercent < 1.0f)
        {
            color->r = (r - color->r) * mixPercent;
            color->g = (g - color->g) * mixPercent;
            color->b = (b - color->b) * mixPercent;
            color->a = (a - color->a) * mixPercent;
        }
        else
        {
            color->r = r;
            color->g = g;
            color->b = b;
            color->a = a;
        }
    }

    SubMesh* subMesh = ASkeleton->GetAttachmentSubMesh(skeleton, slot->attachmentData);

    if (memcmp(subMesh->drawable->color, color, sizeof(Color)) != 0)
    {
        ADrawable_SetColor(subMesh->drawable, color);
    }
}


static void ColorRelease(SkeletonTimeline* skeletonTimeline)
{
    SkeletonColorTimeline* colorTimeline = skeletonTimeline->childPtr;

    free(colorTimeline->frameArr);
    colorTimeline->frameArr = NULL;

    CurveRelease(colorTimeline->curveTimeline);
}


static SkeletonColorTimeline* CreateColor(int frameCount)
{
    SkeletonColorTimeline* colorTimeline      = malloc(sizeof(SkeletonColorTimeline));
    CurveTimelineInit(colorTimeline->curveTimeline, frameCount);

    colorTimeline->skeletonTimeline->Apply    = ColorApply;
    colorTimeline->skeletonTimeline->Release  = ColorRelease;
    colorTimeline->skeletonTimeline->childPtr = colorTimeline;
    colorTimeline->frameArr                   = AArray->Create(sizeof(float), frameCount * ColorFrame_Times);

    return colorTimeline;
}


//----------------------------------------------------------------------------------------------------------------------


static void SetAttachmentFrame
(
    SkeletonAttachmentTimeline* attachmentTimeline,
    int                         frameIndex,
    float                       time,
    const char*                 attachmentName
)
{
    char* copyName = malloc(strlen(attachmentName) + 1);
    strcpy(copyName, attachmentName);

    AArray_Set(attachmentTimeline->frameArr,          frameIndex, time,     float);
    AArray_Set(attachmentTimeline->attachmentNameArr, frameIndex, copyName, const char*);
}


static void AttachmentApply(SkeletonTimeline* skeletonTimeline, Skeleton* skeleton, float time, float mixPercent)
{
    SkeletonAttachmentTimeline* attachmentTimeline = skeletonTimeline->childPtr;
    float*                      frames             = attachmentTimeline->frameArr->data;

    // time is before first frame
    if (time < frames[0])
    {
        attachmentTimeline->preFrameIndex = -1;
        return;
    }

    int frameLength = attachmentTimeline->frameArr->length;
    int frameIndex;

    if (time >= frames[frameLength - 1])
    {
        // time is after last frame
        frameIndex = frameLength - 1;
    }
    else
    {
        frameIndex = BinarySearch(frames, frameLength, time) - 1;
    }

    if (attachmentTimeline->preFrameIndex == frameIndex)
    {
        return;
    }
    else
    {
        attachmentTimeline->preFrameIndex = frameIndex;
    }

    SkeletonSlot*           slot           = AArray_GetPtr
                                             (
                                                 skeleton->slotArr,
                                                 attachmentTimeline->slotIndex,
                                                 SkeletonSlot
                                             );
    const char*             attachmentName = AArray_Get
                                             (
                                                 attachmentTimeline->attachmentNameArr,
                                                 frameIndex,
                                                 const char*
                                             );
    SkeletonAttachmentData* attachmentData = ASkeleton->GetAttachmentData
                                             (
                                                 slot->skeleton,
                                                 slot->slotData->name,
                                                 attachmentName
                                             );

    ASkeletonSlot->SetAttachmentData(slot, attachmentData);
}


static void AttachmentRelease(SkeletonTimeline* skeletonTimeline )
{
    SkeletonAttachmentTimeline* attachmentTimeline = skeletonTimeline->childPtr;

    for (int i = 0; i < attachmentTimeline->attachmentNameArr->length; ++i)
    {
        free(AArray_Get(attachmentTimeline->attachmentNameArr, i, char*));
    }

    free(attachmentTimeline->frameArr);
    attachmentTimeline->frameArr = NULL;

    free(attachmentTimeline->attachmentNameArr);
    attachmentTimeline->attachmentNameArr = NULL;
}


static SkeletonAttachmentTimeline* CreateAttachment(int frameCount)
{
    SkeletonAttachmentTimeline* attachmentTimeline = malloc(sizeof(SkeletonAttachmentTimeline));

    attachmentTimeline->skeletonTimeline->Apply    = AttachmentApply;
    attachmentTimeline->skeletonTimeline->Release  = AttachmentRelease;
    attachmentTimeline->skeletonTimeline->childPtr = attachmentTimeline;

    attachmentTimeline->frameArr                   = AArray->Create(sizeof(float),  frameCount);
    attachmentTimeline->attachmentNameArr          = AArray->Create(sizeof(char*), frameCount);
    attachmentTimeline->preFrameIndex              = -1;


    return attachmentTimeline;
}


//----------------------------------------------------------------------------------------------------------------------


static void SetEventFrame(SkeletonEventTimeline* eventTimeline, int frameIndex, float time, SkeletonEventData* eventData)
{
    AArray_Set(eventTimeline->frameArr, frameIndex, time,      float);
    AArray_Set(eventTimeline->eventArr, frameIndex, eventData, SkeletonEventData*);
}


static void EventApply(SkeletonTimeline* skeletonTimeline, Skeleton* skeleton, float time, float mixPercent)
{
    if (skeleton->FireSkeletonEvent == NULL)
    {
        return;
    }

    SkeletonEventTimeline* eventTimeline = skeletonTimeline->childPtr;
    float*                 frames        = eventTimeline->frameArr->data;

    // time is before first frame
    if (time < frames[0])
    {
        eventTimeline->preFrameIndex = -1;
        return;
    }

    int frameLength = eventTimeline->frameArr->length;
    int frameIndex;

    if (time >= frames[frameLength - 1])
    {
        // time is after last frame
        frameIndex = frameLength - 1;
    }
    else
    {
        frameIndex = BinarySearch(frames, frameLength, time) - 1;
    }


    if (eventTimeline->preFrameIndex == frameIndex)
    {
        return;
    }
    else
    {
        eventTimeline->preFrameIndex = frameIndex;
    }

    skeleton->FireSkeletonEvent
    (
        skeleton,
        AArray_Get(eventTimeline->eventArr, frameIndex, SkeletonEventData*),
        mixPercent
    );
}


static void EventRelease(SkeletonTimeline* skeletonTimeline)
{
    SkeletonEventTimeline* eventTimeline = skeletonTimeline->childPtr;

    free(eventTimeline->frameArr);
    eventTimeline->frameArr = NULL;

    for (int i = 0; i < eventTimeline->eventArr->length; ++i)
    {
        free(AArray_Get(eventTimeline->eventArr, i, SkeletonEventData*));
    }

    free(eventTimeline->eventArr);
    eventTimeline->eventArr = NULL;
}


static SkeletonEventTimeline* CreateEvent(int frameCount)
{
    SkeletonEventTimeline* eventTimeline      = malloc(sizeof(SkeletonEventTimeline));

    eventTimeline->skeletonTimeline->Apply    = EventApply;
    eventTimeline->skeletonTimeline->Release  = EventRelease;
    eventTimeline->skeletonTimeline->childPtr = eventTimeline;

    eventTimeline->frameArr                   = AArray->Create(sizeof(float), frameCount);
    eventTimeline->eventArr                   = AArray->Create(sizeof(SkeletonEventData*), frameCount);
    eventTimeline->preFrameIndex              = -1;

    return eventTimeline;
}


//----------------------------------------------------------------------------------------------------------------------


static void SetDrawOrderFrame
(
    SkeletonDrawOrderTimeline*  drawOrderTimeline,
    int                         frameIndex,
    float                       time,
    Array(int)*                 drawOrder
)
{
    AArray_Set(drawOrderTimeline->frameArr,     frameIndex, time,      float);
    AArray_Set(drawOrderTimeline->drawOrderArr, frameIndex, drawOrder, Array(int)*);
}


static void DrawOrderRelease(SkeletonTimeline* skeletonTimeline)
{
    SkeletonDrawOrderTimeline* drawOrderTimeline = skeletonTimeline->childPtr;

    free(drawOrderTimeline->frameArr);
    drawOrderTimeline->frameArr = NULL;

    for (int i = 0; i < drawOrderTimeline->drawOrderArr->length; ++i)
    {
        free(AArray_Get(drawOrderTimeline->drawOrderArr, i, Array(int)*));
    }

    free(drawOrderTimeline->drawOrderArr);
    drawOrderTimeline->drawOrderArr = NULL;
}


static void DrawOrderApply(SkeletonTimeline* skeletonTimeline, Skeleton* skeleton, float time, float mixPercent)
{
    SkeletonDrawOrderTimeline* drawOrderTimeline = skeletonTimeline->childPtr;

    float* frames = drawOrderTimeline->frameArr->data;

    // time is before first frame.
    if (time < frames[0])
    {
        drawOrderTimeline->preFrameIndex = -1;
        return;
    }

    int frameLength = drawOrderTimeline->frameArr->length;
    int frameIndex;

    if (time >= frames[frameLength - 1])
    {
        // time is after last frame.
        frameIndex = frameLength - 1;
    }
    else
    {
        frameIndex = BinarySearch(frames, frameLength, time) - 1;
    }

    if (drawOrderTimeline->preFrameIndex == frameIndex)
    {
        return;
    }
    else
    {
        drawOrderTimeline->preFrameIndex = frameIndex;
    }

    ArrayList* meshList = skeleton->meshList;
    int        subMeshIndexCount[meshList->size];

    memset(subMeshIndexCount, 0, meshList->size * sizeof(int));

    Array(int)*    drawOrderArr = AArray_Get(drawOrderTimeline->drawOrderArr, frameIndex, Array(int)*);
    SkeletonSlot*  slots        = skeleton->slotArr->data;
    SkeletonSlot** slotOrders   = skeleton->slotOrderArr->data;
    int*           drawOrder    = NULL;


    if (drawOrderArr != NULL)
    {
        drawOrder = drawOrderArr->data;
    }

    for (int i = 0; i < skeleton->slotArr->length; ++i)
    {
        SkeletonSlot* slot;

        if (drawOrder == NULL)
        {
            slot = slots + i;
        }
        else
        {
            slot = slots + drawOrder[i];
        }

        slotOrders[i] = slot;

        if (slot->slotData->attachmentDataList != NULL)
        {
            ArrayList* attachmentDataList = slot->slotData->attachmentDataList;

            for(int j = 0; j < attachmentDataList->size; ++j)
            {
                SubMesh* subMesh = ASkeleton->GetAttachmentSubMesh
                                   (
                                       skeleton,
                                       AArrayList_Get(attachmentDataList, j, SkeletonAttachmentData*)
                                   );

                for (int k = 0; k < meshList->size; ++k)
                {
                    Mesh* mesh = AArrayList_GetPtr(meshList, k, Mesh);

                    if (subMesh->parent == mesh)
                    {
                        subMesh->index = subMeshIndexCount[k]++;
                        break;
                    }
                }
            }
        }
    }

    for (int i = 0; i < meshList->size; ++i)
    {
        AMesh->ReorderAllChildren(AArrayList_GetPtr(meshList, i, Mesh));
    }
}


static SkeletonDrawOrderTimeline* CreateDrawOrder(int frameCount)
{
    SkeletonDrawOrderTimeline* drawOrderTimeline  = malloc(sizeof(SkeletonDrawOrderTimeline));

    drawOrderTimeline->skeletonTimeline->Release  = DrawOrderRelease;
    drawOrderTimeline->skeletonTimeline->Apply    = DrawOrderApply;
    drawOrderTimeline->skeletonTimeline->childPtr = drawOrderTimeline;

    drawOrderTimeline->frameArr                   = AArray->Create(sizeof(float),        frameCount);
    drawOrderTimeline->drawOrderArr               = AArray->Create(sizeof(Array(int)*), frameCount);
    drawOrderTimeline->preFrameIndex              = -1;

    return drawOrderTimeline;
}


//----------------------------------------------------------------------------------------------------------------------


static void SetDeformFrame(SkeletonDeformTimeline* deformTimeline, int frameIndex, float time, Array(float)* vertices)
{
    AArray_Set(deformTimeline->frameArr,  frameIndex, time,     float);
    AArray_Set(deformTimeline->vertexArr, frameIndex, vertices, Array(float)*);
}


static void DeformRelease(SkeletonTimeline* skeletonTimeline)
{
    SkeletonDeformTimeline* deformTimeline = skeletonTimeline->childPtr;

    free(deformTimeline->frameArr);
    deformTimeline->frameArr = NULL;

    for (int i = 0; i < deformTimeline->vertexArr->length; ++i)
    {
        free(AArray_Get(deformTimeline->vertexArr, i, Array(float)*));
    }

    free(deformTimeline->vertexArr);
    deformTimeline->vertexArr = NULL;

    CurveRelease(deformTimeline->curveTimeline);
}


static void DeformApply(SkeletonTimeline* skeletonTimeline, Skeleton* skeleton, float time, float mixPercent)
{
    SkeletonDeformTimeline* deformTimeline = skeletonTimeline->childPtr;
    SkeletonSlot*           slot           = AArray_GetPtr(skeleton->slotArr, deformTimeline->slotIndex, SkeletonSlot);

    if (slot->attachmentData != deformTimeline->attachmentData)
    {
        return;
    }

    float* frames = deformTimeline->frameArr->data;

    // time is before first frame
    if (time < frames[0])
    {
        return;
    }

    Array(float*)* positionArr = NULL;
    float*         positions   = NULL;

    switch (deformTimeline->attachmentData->type)
    {
        case SkeletonAttachmentDataType_Region:
        case SkeletonAttachmentDataType_BoundingBox:
            ALog_A
            (
                false,
                "ASkeletonTimeline DeformApply deformTimeline->attachmentData->type only can be"
                "SkeletonAttachmentDataType_Mesh or SkeletonAttachmentDataType_SkinnedMesh"
            );
            return;

        case SkeletonAttachmentDataType_Mesh:
        {
            SkeletonMeshAttachmentData* meshAttachment = deformTimeline->attachmentData->childPtr;
            SubMesh*                    subMesh        = AArrayList_Get
                                                         (
                                                             AArrayList_GetPtr
                                                             (
                                                                 skeleton->meshList,
                                                                 meshAttachment->meshIndex,
                                                                 Mesh
                                                             )
                                                             ->childList,
                                                             
                                                             meshAttachment->subMeshIndex,
                                                             SubMesh*
                                                         );

            positionArr = subMesh->positionArr;
            positions   = positionArr->data;

            break;
        }

        case SkeletonAttachmentDataType_SkinnedMesh:
        {
            SkeletonSkinnedMeshAttachmentData* skinnedMeshAttachment = deformTimeline->attachmentData->childPtr;

            positionArr = skinnedMeshAttachment->weightVertexArr;
            positions   = positionArr->data;

            break;
        }
    }

    int frameLength = deformTimeline->frameArr->length;

    if (time >= frames[frameLength - 1])
    {
        // time is after last frame.
        float* lastVertex = AArray_Get(deformTimeline->vertexArr, frameLength - 1, Array(float)*)->data;

        if (mixPercent < 1.0f)
        {
            for (int i = 0; i < positionArr->length; i += 3)
            {
                positions[i]  += (lastVertex[i]  - positions[i])  * mixPercent;
                int       i1   = i + 1;
                positions[i1] += (lastVertex[i1] - positions[i1]) * mixPercent;
            }
        }
        else
        {
            memcpy(positions, lastVertex, positionArr->length * sizeof(float));
        }

        return;
    }

    // interpolate between the previous frame and the current frame
    int    frameIndex = BinarySearch(frames, frameLength, time);
    float  frameTime  = frames[frameIndex];

    float  percent    = GetCurvePercent
                        (
                            deformTimeline->curveTimeline,
                            frameIndex - 1,
                            1.0f - (time - frameTime) / (frames[frameIndex - 1] - frameTime)
                        );

    float* pre        = AArray_Get(deformTimeline->vertexArr, frameIndex - 1, Array(float)*)->data;
    float* next       = AArray_Get(deformTimeline->vertexArr, frameIndex,     Array(float)*)->data;

    if (mixPercent < 1.0f)
    {
        for (int i = 0; i < positionArr->length; i += 3)
        {
            float p        = pre [i];
            float n        = next[i];

            positions[i]  += (p + (n - p) * percent - positions[i]) * mixPercent;

            int   i1       = i + 1;
            p              = pre [i1];
            n              = next[i1];

            positions[i1] += (p + (n - p) * percent - positions[i1]) * mixPercent;
        }

    }
    else
    {
        for (int i = 0; i < positionArr->length; i += 3)
        {
            float p       = pre [i];
            float n       = next[i];

            positions[i]  = p + (n - p) * percent;

            int  i1       = i + 1;
            p             = pre [i1];
            n             = next[i1];

            positions[i1] = p + (n - p) * percent;
        }
    }
}


static SkeletonDeformTimeline* CreateDeform(int frameCount)
{
    SkeletonDeformTimeline* deformTimeline     = malloc(sizeof(SkeletonDeformTimeline));

    CurveTimelineInit(deformTimeline->curveTimeline, frameCount);

    deformTimeline->skeletonTimeline->Release  = DeformRelease;
    deformTimeline->skeletonTimeline->Apply    = DeformApply;
    deformTimeline->skeletonTimeline->childPtr = deformTimeline;

    deformTimeline->frameArr                   = AArray->Create(sizeof(float),         frameCount);
    deformTimeline->vertexArr                  = AArray->Create(sizeof(Array(float)*), frameCount);

    return deformTimeline;
}


struct ASkeletonTimeline ASkeletonTimeline[1] =
{{
    CreateRotate,
    CreateTranslate,
    CreateScale,
    CreateColor,
    CreateAttachment,
    CreateEvent,
    CreateDrawOrder,
    CreateDeform,

    SetLinear,
    SetStepped,
    SetCurve,

    SetRotateFrame,
    SetTranslateFrame,
    SetColorFrame,
    SetAttachmentFrame,
    SetEventFrame,
    SetDrawOrderFrame,
    SetDeformFrame,
}};

```

`Engine/Extension/Spine/SkeletonTimeline.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-7-3
 * Update   : 2019-2-1
 * Author   : scott.cgi
 */


#ifndef SKELETON_TIMELINE_H
#define SKELETON_TIMELINE_H


#include "Engine/Extension/Spine/Skeleton.h"
#include "Engine/Toolkit/Utils/Array.h"
#include "Engine/Extension/Spine/SkeletonBone.h"
#include "Engine/Extension/Spine/SkeletonSlot.h"


typedef enum
{
    SkeletonCurveType_Linear  = -1,
    SkeletonCurveType_Stepped = -2,
    SkeletonCurveType_Bezier  = -3,
}
SkeletonCurveType;


typedef struct
{
    Array(float)* curveArr;
}
SkeletonCurveTimeline;


typedef struct SkeletonTimeline SkeletonTimeline;

/**
 * The abstract skeleton animation timeline.
 * the subclass implement the functions.
 */
struct SkeletonTimeline
{
    /**
     * Set bone slot attachment effect for this animation in this time.
     * the mixPercent is percent to set the effect, range in [0, 1].
     * the time is seconds
     */
    void  (*Apply)  (SkeletonTimeline* skeletonTimeline, Skeleton* skeleton, float time, float mixPercent);

    /**
     * Release member memory space.
     */
    void  (*Release)(SkeletonTimeline* skeletonTimeline);

    /**
     * Subclass pointer which inheritance SkeletonTimeline.
     */
    void* childPtr;
};


/**
 * The skeleton animation rotation timeline.
 */
typedef struct
{
    SkeletonCurveTimeline curveTimeline   [1];
    SkeletonTimeline      skeletonTimeline[1];

    /**
     * Each group has time angle, as [time, angle...]
     */
    Array(float)*         frameArr;

    /**
     * Index in SkeletonData's boneDataOrderArr.
     */
    int                   boneIndex;
}
SkeletonRotateTimeline;


/**
 * The skeleton animation translate timeline.
 */
typedef struct
{
    SkeletonCurveTimeline curveTimeline   [1];
    SkeletonTimeline      skeletonTimeline[1];

    /**
     * Each group has time x y, as [time, x, y...]
     */
    Array(float)*         frameArr;

    /**
     * Index in SkeletonData's boneDataOrderArr.
     */
    int                   boneIndex;
}
SkeletonTranslateTimeline;


/**
 * The skeleton animation scale timeline.
 */
typedef struct
{
    SkeletonTranslateTimeline translateTimeline[1];
}
SkeletonScaleTimeline;


/**
 * The skeleton animation color timeline.
 */
typedef struct
{
    SkeletonCurveTimeline curveTimeline   [1];
    SkeletonTimeline      skeletonTimeline[1];

    /**
     * Each group has time r g b a, as [time, r, g, b, a...]
     */
    Array(float)*         frameArr;

    /**
     * Index in SkeletonData's slotDataOrderArr.
     */
    int                   slotIndex;
}
SkeletonColorTimeline;


/**
 * The skeleton animation attachment timeline.
 */
typedef struct
{
    SkeletonTimeline    skeletonTimeline[1];

    /**
     * Each group has time, as [time...].
     */
    Array(float)*       frameArr;
    Array(const char*)* attachmentNameArr;

    /**
     * Index in SkeletonData's slotDataOrderArr.
     */
    int                 slotIndex;
    int                 preFrameIndex;
}
SkeletonAttachmentTimeline;


/**
 * The skeleton animation event timeline.
 */
typedef struct
{
    SkeletonTimeline           skeletonTimeline[1];

    /**
     * Each group has time, as [time...].
     */
    Array(float)*              frameArr;
    Array(SkeletonEventData*)* eventArr;
    int                        preFrameIndex;
}
SkeletonEventTimeline;


/**
 * The skeleton animation drawOrder timeline.
 */
typedef struct
{
    SkeletonTimeline    skeletonTimeline[1];

    /**
     * Each group has time, as [time...].
     */
    Array(float)*       frameArr;

    /**
     * Each frame has a new drawOrder array.
     */
    Array(Array(int)*)* drawOrderArr;
    int                 preFrameIndex;
}
SkeletonDrawOrderTimeline;


/**
 * The skeleton animation deform timeline.
 */
typedef struct
{
    SkeletonCurveTimeline   curveTimeline   [1];
    SkeletonTimeline        skeletonTimeline[1];

    /**
     * Each group has time, as [time...].
     */
    Array(float)*           frameArr;

    /**
     * Each frame has a new vertex array.
     */
    Array(Array(float)*)*   vertexArr;

    /**
     * Index in SkeletonData's slotDataOrderArr.
     */
    int                     slotIndex;


    SkeletonAttachmentData* attachmentData;
}
SkeletonDeformTimeline;


/**
 * Control and manage SkeletonTimeline.
 */
struct ASkeletonTimeline
{
    SkeletonRotateTimeline*     (*CreateRotate)    (int frameCount, int boneIndex);
    SkeletonTranslateTimeline*  (*CreateTranslate) (int frameCount, int boneIndex);
    SkeletonScaleTimeline*      (*CreateScale)     (int frameCount, int boneIndex);
    SkeletonColorTimeline*      (*CreateColor)     (int frameCount);
    SkeletonAttachmentTimeline* (*CreateAttachment)(int frameCount);
    SkeletonEventTimeline*      (*CreateEvent)     (int frameCount);
    SkeletonDrawOrderTimeline*  (*CreateDrawOrder) (int frameCount);
    SkeletonDeformTimeline*     (*CreateDeform)    (int frameCount);

    void (*SetLinear) (SkeletonCurveTimeline* curveTimeline, int frameIndex);
    void (*SetStepped)(SkeletonCurveTimeline* curveTimeline, int frameIndex);

    /**
     * Sets the control handle positions for an interpolation bezier curve.
     * used to transition from this keyframe to the next.
     *
     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes.
     * cy1 and cy2 are the percent of the difference between the keyframe's values.
     */
    void (*SetCurve)          (
                                  SkeletonCurveTimeline* curveTimeline,
                                  int                    frameIndex,
                                  float                  cx1,
                                  float                  cy1,
                                  float                  cx2,
                                  float                  cy2
                              );

    /**
     * Set the time and angle of the specified keyframe.
     */
    void (*SetRotateFrame)    (SkeletonRotateTimeline* rotateTimeline, int frameIndex, float time, float angle);

    /*  Set the time and value of the specified keyframe. */
    
    void (*SetTranslateFrame) (
                                  SkeletonTranslateTimeline*  translateTimeline,
                                  int                         frameIndex,
                                  float                       time,
                                  float                       x,
                                  float                       y
                              );
    void (*SetColorFrame)     (
                                  SkeletonColorTimeline*      colorTimeline,
                                  int                         frameIndex,
                                  float                       time,
                                  Color*                      color
                              );
    void (*SetAttachmentFrame)(
                                  SkeletonAttachmentTimeline* attachmentTimeline,
                                  int                         frameIndex,
                                  float                       time,
                                  const char*                 attachmentName
                              );
    void (*SetEventFrame)     (
                                  SkeletonEventTimeline*      eventTimeline,
                                  int                         frameIndex,
                                  float                       time,
                                  SkeletonEventData*          eventData
                              );
    void (*SetDrawOrderFrame) (
                                  SkeletonDrawOrderTimeline*  drawOrderTimeline,
                                  int                         frameIndex,
                                  float                       time,
                                  Array(int)*                 drawOrder
                              );
    void (*SetDeformFrame)    (
                                  SkeletonDeformTimeline*     deformTimeline,
                                  int                         frameIndex,
                                  float                       time,
                                  Array(float)*               vertexArr
                              );
};


extern struct ASkeletonTimeline ASkeletonTimeline[1];


#endif

```

`Engine/Extension/TextureAtlas.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-7-22
 * Update   : 2019-1-31
 * Author   : scott.cgi
 */


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "Engine/Toolkit/HeaderUtils/Define.h"
#include "Engine/Extension/TextureAtlas.h"
#include "Engine/Toolkit/Utils/BufferReader.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Toolkit/Utils/FileTool.h"


static ArrayStrMap(filePath, TextureAtlas*) textureAtlasMap[1] = AArrayStrMap_Init(TextureAtlas*, 20);


#define ReadFind(str)                                          \
    ABufferReader->ReadLine(buffer, range, line);              \
    isFound = ABufferReader->TryFindString(buffer, line, str); \
    ALog_A(isFound, "ATextureAtlas %s cannot find string = %s", filePath, str)


static void Init(const char* filePath, TextureAtlas* outTextureAtlas)
{
    AArrayStrMap->InitWithCapacity(sizeof(TextureAtlasQuad), 20, outTextureAtlas->quadMap);
    AArrayList  ->InitWithCapacity(sizeof(Texture*),         5,  outTextureAtlas->textureList);

    long  size;
    char* buffer = AFileTool->CreateDataFromResource(filePath, &size);

    ArrayRange range[1] = {0, (int) size - 1};
    ArrayRange line [1];

    ABufferReader->ReadLine(buffer, range, line);

    while (range->start < range->end)
    {
        // read image name
        ABufferReader->ReadLine(buffer, range, line);

        int  fileDirLen = AFileTool->GetDirLength(filePath);
        int  pathLen   = fileDirLen + (line->end - line->start);
        char path[pathLen + 1];

        path[pathLen]  = '\0';
        
        if (fileDirLen != 0)
        {
            memcpy(path, filePath, (size_t) fileDirLen);
            memcpy(path + fileDirLen, buffer + line->start, (size_t) (pathLen - fileDirLen));
        }

        Texture* texture = ATexture->Get(path);
        AArrayList_Add(outTextureAtlas->textureList, texture);

        bool isFound;

        ReadFind("size");
        ReadFind("format");
        ReadFind("filter");
        ReadFind("repeat");

        while (true)
        {
            // texture quad name
            ABufferReader->ReadLine(buffer, range, line);

            if (line->start == line->end)
            {
                break;
            }

            // make the line to string
            buffer[line->end]     = '\0';
            char* textureQuadName = buffer + line->start;

            ReadFind("rotate");
            isFound = ABufferReader->TryFindString(buffer, line, "true");
            ALog_A(isFound == false, "ATextureAtlas %s not support rotation", filePath);

            char* str;

            ReadFind("xy:");
            // make the line to string
            buffer[line->end] = '\0';

            str               = strtok(buffer + line->start, ",");
            ALog_A(str != NULL, "ATextureAtlas cannot find x number in xy");
            int x             = atoi(str);

            str               = strtok(NULL, ",");
            ALog_A(str != NULL, "ATextureAtlas cannot find y number in xy");
            int y             = atoi(str);

            ReadFind("size:");
            // make the line to string
            buffer[line->end] = '\0';

            str               = strtok(buffer + line->start, ",");
            ALog_A(str != NULL, "ATextureAtlas cannot find width number in size");
            int width         = atoi(str);

            str               = strtok(NULL, ",");
            ALog_A(str != NULL, "ATextureAtlas cannot find height number in size");
            int height        = atoi(str);

            ReadFind("orig");
            ReadFind("offset");
            ReadFind("index");

            TextureAtlasQuad atlasQuad[1];
            AQuad->Init(AGLTool_ToGLWidth(width), AGLTool_ToGLHeight(height), atlasQuad->quad);

            atlasQuad->textureIndex         = outTextureAtlas->textureList->size - 1;
            atlasQuad->quad->offsetTextureX = AGLTool_ToGLWidth (x);
            atlasQuad->quad->offsetTextureY = AGLTool_ToGLHeight(y);
            atlasQuad->atlas                = outTextureAtlas;

            AArrayStrMap->TryPut(outTextureAtlas->quadMap, textureQuadName, atlasQuad);
        }
    }

    AArrayList->Shrink(outTextureAtlas->quadMap->elementList);
    AArrayList->Shrink(outTextureAtlas->textureList);
    free(buffer);
}


#undef ReadFind


static void Release(TextureAtlas* textureAtlas)
{
    AArrayStrMap->Release(textureAtlas->quadMap);
    AArrayList  ->Release(textureAtlas->textureList);

    bool isRemoved = AArrayStrMap->TryRemove(textureAtlasMap, textureAtlas->filePath);
    ALog_A(isRemoved, "ATextureAtlas release not found %s", textureAtlas->filePath);

    free(textureAtlas);
}


static TextureAtlas* Get(const char* filePath)
{
    TextureAtlas* textureAtlas = AArrayStrMap_Get(textureAtlasMap, filePath, TextureAtlas*);

    if (textureAtlas == NULL)
    {
        textureAtlas           = malloc(sizeof(TextureAtlas));
        textureAtlas->filePath = AArrayStrMap_GetKey
                                 (
                                    AArrayStrMap_TryPut(textureAtlasMap, filePath, textureAtlas),
                                    textureAtlasMap->valueTypeSize
                                 );

        Init(filePath, textureAtlas);
    }

    return textureAtlas;
}


struct ATextureAtlas ATextureAtlas[1] =
{{
    Get,
    Release,
}};

```

`Engine/Extension/TextureAtlas.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-7-22
 * Update   : 2019-1-31
 * Author   : scott.cgi
 */


#ifndef TEXTURE_ATLAS_H
#define TEXTURE_ATLAS_H


#include "Engine/Graphics/Draw/Quad.h"
#include "Engine/Toolkit/Utils/ArrayStrMap.h"


/**
 * The atlas including textures and quads info.
 */
typedef struct
{
    /**
     * Texture atlas quad info from file.
     */
    ArrayStrMap(quadName, TextureAtlasQuad) quadMap[1];

    /**
     * Textures in atlas.
     */
    ArrayList  (Texture*)                   textureList[1];

    /**
     * Be key identify TextureAtlas.
     */
    const char*                             filePath;
}
TextureAtlas;


/**
 * Quad in TextureAtlas.
 */
typedef struct
{
    /**
     * Quad belongs to.
     */
    TextureAtlas* atlas;

    /**
     * Quad data in texture.
     */
    Quad          quad[1];

    /**
     * The index of Quad's texture in TextureAtlas textureList.
     */
    int           textureIndex;
}
TextureAtlasQuad;


/**
 * Manage TextureAtlas.
 */
struct ATextureAtlas
{
    /**
     * Get TextureAtlas by TextureAtlas.
     *
     * filePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    TextureAtlas* (*Get)    (const char*   filePath);
    void          (*Release)(TextureAtlas* textureAtlas);
};


extern struct ATextureAtlas ATextureAtlas[1];


/**
 * Get TextureAtlasQuad from atlas by quadName.
 */
static inline TextureAtlasQuad* ATextureAtlas_GetQuad(TextureAtlas* atlas, const char* quadName)
{
    return AArrayStrMap_GetPtr(atlas->quadMap, quadName, TextureAtlasQuad);
}


/**
 * Get Texture from atlasQuad.
 */
static inline Texture* ATextureAtlas_GetQuadTexture(TextureAtlasQuad* atlasQuad)
{
    return AArrayList_Get(atlasQuad->atlas->textureList, atlasQuad->textureIndex, Texture*);
}


#endif

```

`Engine/Graphics/Draw/Color.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-11-17
 * Update   : 2019-1-25
 * Author   : scott.cgi
 */


#include <stdio.h>
#include "Engine/Graphics/Draw/Color.h"


static void SetWithString(char* colorStr, Color* outColor)
{
    int rgba[4];

    sscanf(colorStr,     "%2x", rgba);
    sscanf(colorStr + 2, "%2x", rgba + 1);
    sscanf(colorStr + 4, "%2x", rgba + 2);
    sscanf(colorStr + 6, "%2x", rgba + 3);

    outColor->r = rgba[0] / 255.0f;
    outColor->g = rgba[1] / 255.0f;
    outColor->b = rgba[2] / 255.0f;
    outColor->a = rgba[3] / 255.0f;
}


struct AColor AColor[1] =
{{
    SetWithString,
}};

```

`Engine/Graphics/Draw/Color.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-2-1
 * Update   : 2019-1-25
 * Author   : scott.cgi
 */


#ifndef COLOR_H
#define COLOR_H


/**
 * RGBA between in [0.0f, 1.0f].
 */
typedef struct
{
    float r;
    float g;
    float b;
    float a;
}
Color;


struct AColor
{
    /**
     * String format to 000000 - ffffffff
     */
    void (*SetWithString)(char* colorStr, Color* outColor);
};


extern struct AColor AColor[1];


#define COLOR_RED   {1.0f, 0.0f, 0.0f, 1.0f}
#define COLOR_GREED {0.0f, 1.0f, 0.0f, 1.0f}
#define COLOR_BLUE  {0.0f, 0.0f, 1.0f, 1.0f}
#define COLOR_WHITE {1.0f, 1.0f, 1.0f, 1.0f}
#define COLOR_BLACK {0.0f, 0.0f, 0.0f, 1.0f}

#define COLOR_RED_ARRAY   (Color[1]) {1.0f, 0.0f, 0.0f, 1.0f}
#define COLOR_GREED_ARRAY (Color[1]) {0.0f, 1.0f, 0.0f, 1.0f}
#define COLOR_BLUE_ARRAY  (Color[1]) {0.0f, 0.0f, 1.0f, 1.0f}
#define COLOR_WHITE_ARRAY (Color[1]) {1.0f, 1.0f, 1.0f, 1.0f}
#define COLOR_BLACK_ARRAY (Color[1]) {0.0f, 0.0f, 0.0f, 1.0f}


/**
 * Construct Color composite literal.
 */
#define AColor_Make(r, g, b, a) \
   (Color[1]) {{r, g, b, a}}


#endif

```

`Engine/Graphics/Draw/Drawable.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-2
 * Update   : 2019-1-25
 * Author   : scott.cgi
 */


#include <stdlib.h>
#include "Engine/Toolkit/Math/Vector.h"
#include "Engine/Toolkit/Utils/ArrayList.h"
#include "Engine/Graphics/Draw/Drawable.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/Camera.h"


static ArrayList(Drawable*) renderQueue[1] = AArrayList_Init(Drawable*, 150);
static int                  drawCalls;


static void Draw(Drawable* drawable)
{
    if (ADrawable_CheckVisible(drawable))
    {
        bool isHasParent = drawable->parent != NULL;

        // parent not has DrawableState_DrawChanged state
        if (isHasParent && (ADrawable_CheckState(drawable->parent, DrawableState_DrawChanged) == false))
        {
            ADrawable_ClearState(drawable, DrawableState_DrawChanged);
            return;
        }

        // check transform flag
        if
        (
            ADrawable_CheckState(drawable, DrawableState_Transform) ||
            (isHasParent && ADrawable_CheckState(drawable->parent, DrawableState_TransformChanged))
        )
        {
            if (isHasParent)
            {
                // child under father matrix
                *drawable->modelMatrix = *drawable->parent->modelMatrix;
            }
            else
            {
                // self under identity matrix
                *drawable->modelMatrix = *MATRIX4_IDENTITY_ARRAY;
            }

            AMatrix->Translate
            (
                drawable->modelMatrix,
                drawable->positionX,
                drawable->positionY,
                drawable->positionZ
            );

            AMatrix->Scale
            (
                drawable->modelMatrix,
                drawable->scaleX,
                drawable->scaleY,
                drawable->scaleZ
            );

            if (drawable->rotationZ != 0.0f)
            {
                AMatrix->RotateZ(drawable->modelMatrix, drawable->rotationZ);
            }

            if (drawable->rotationX != 0.0f)
            {
                AMatrix->RotateX(drawable->modelMatrix, drawable->rotationX);
            }

            if (drawable->rotationY != 0.0f)
            {
                AMatrix->RotateY(drawable->modelMatrix, drawable->rotationY);
            }

            if (ADrawable_CheckState(drawable, DrawableState_IsUpdateMVPMatrix))
            {
                AMatrix->MultiplyMM(ACamera->vp, drawable->modelMatrix, drawable->mvpMatrix);
            }

            // flag transform for child and flag need to update inverse
            ADrawable_AddState
            (
                drawable,
                DrawableState_TransformChanged | DrawableState_UpdateInverseMatrix
            );
        }
        else
        {
            ADrawable_ClearState(drawable, DrawableState_TransformChanged);
        }

//----------------------------------------------------------------------------------------------------------------------

        // check color flag
        if
        (
            ADrawable_CheckState(drawable, DrawableState_Color) ||
            (isHasParent && ADrawable_CheckState(drawable->parent, DrawableState_ColorChanged))
        )
        {
            if (isHasParent && ADrawable_CheckState(drawable, DrawableState_IsBlendColor))
            {
                if
                (
                    ADrawable_CheckState(drawable, DrawableState_Opacity) ||
                    ADrawable_CheckState(drawable->parent, DrawableState_OpacityChanged)
                )
                {
                    // blend opacity
                    drawable->blendColor->a = drawable->color->a * drawable->parent->blendColor->a;

                    // flag rgb for child
                    ADrawable_AddState(drawable, DrawableState_OpacityChanged);
                }
                else
                {
                    ADrawable_ClearState(drawable, DrawableState_OpacityChanged);
                }

                if
                (
                    ADrawable_CheckState(drawable, DrawableState_RGB) ||
                    ADrawable_CheckState(drawable->parent, DrawableState_RGBChanged)
                )
                {
                    // blend rgb
                    drawable->blendColor->r = drawable->color->r * drawable->parent->blendColor->r;
                    drawable->blendColor->g = drawable->color->g * drawable->parent->blendColor->g;
                    drawable->blendColor->b = drawable->color->b * drawable->parent->blendColor->b;

                    // flag opacity for child
                    ADrawable_AddState(drawable, DrawableState_RGBChanged);
                }
                else
                {
                    ADrawable_ClearState(drawable, DrawableState_RGBChanged);
                }
            }
            else
            {
                if (ADrawable_CheckState(drawable, DrawableState_Opacity))
                {
                    // sync opacity
                    drawable->blendColor->a = drawable->color->a;

                    // flag rgb for child
                    ADrawable_AddState(drawable, DrawableState_OpacityChanged);
                }
                else
                {
                    ADrawable_ClearState(drawable, DrawableState_OpacityChanged);
                }

                if (ADrawable_CheckState(drawable, DrawableState_RGB))
                {
                    // sync rgb
                    drawable->blendColor->r = drawable->color->r;
                    drawable->blendColor->g = drawable->color->g;
                    drawable->blendColor->b = drawable->color->b;

                    // flag opacity for child
                    ADrawable_AddState(drawable, DrawableState_RGBChanged);
                }
                else
                {
                    ADrawable_ClearState(drawable, DrawableState_RGBChanged);
                }
            }
        }
        else
        {
            ADrawable_ClearState(drawable, DrawableState_ColorChanged);
        }

//----------------------------------------------------------------------------------------------------------------------

        // custom handler
        if (drawable->Draw != NULL)
        {
            // we can check all state change
            drawable->Draw(drawable);
        }

        // clear self all draw state change
        ADrawable_ClearAndAddState(drawable, DrawableState_Draw, DrawableState_DrawChanged);

        // if has render push into queue
        if (drawable->Render != NULL)
        {
            AArrayList_Add(renderQueue, drawable);
        }
    }
    else
    {
        ADrawable_ClearState(drawable, DrawableState_DrawChanged);
    }
}


static void Render()
{
    Drawable* drawable;

    // rendering loop unrolling
    for (int i = 0;;)
    {
        while (i + 19 < renderQueue->size)
        {
            drawable = AArrayList_Get(renderQueue, i,      Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 1,  Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 2,  Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 3,  Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 4,  Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 5,  Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 6,  Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 7,  Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 8,  Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 9,  Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 10, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 11, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 12, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 13, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 14, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 15, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 16, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 17, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 18, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 19, Drawable*);
            drawable->Render(drawable);

            i += 20;
        }

        while (i + 9 < renderQueue->size)
        {
            drawable = AArrayList_Get(renderQueue, i,     Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 1, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 2, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 3, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 4, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 5, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 6, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 7, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 8, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 9, Drawable*);
            drawable->Render(drawable);

            i += 10;
        }

        while (i + 4 < renderQueue->size)
        {
            drawable = AArrayList_Get(renderQueue, i,     Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 1, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 2, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 3, Drawable*);
            drawable->Render(drawable);

            drawable = AArrayList_Get(renderQueue, i + 4, Drawable*);
            drawable->Render(drawable);

            i += 5;
        }

        while (i < renderQueue->size)
        {
            drawable = AArrayList_Get(renderQueue, i++, Drawable*);
            drawable->Render(drawable);
        }

        break;
    }

    drawCalls = renderQueue->size;
    AArrayList->Clear(renderQueue);
}


static int GetDrawCalls()
{
    return drawCalls;
}


//----------------------------------------------------------------------------------------------------------------------


static inline float GetWorldRotationZ(Drawable* drawable)
{
    // unit x axis vector's x and y is matrix->m0, matrix->m1
    return AMath_Atan2(drawable->modelMatrix->m0, drawable->modelMatrix->m1);
}


static float GetWorldScaleX(Drawable* drawable)
{
    Drawable* parent = drawable->parent;
    int       sign   = drawable->scaleX < 0.0f ? -1 : 1;

    while (parent != NULL)
    {
        if (parent->scaleX < 0.0f)
        {
            sign = -sign;
        }

        parent = parent->parent;
    }

    // the scaleX in the xyz axis is the length of the matrix column vector values
    Vector3 vector[1] =
    {{
        drawable->modelMatrix->m0,
        drawable->modelMatrix->m1,
        drawable->modelMatrix->m2,
    }};

    return AVector3_Length(vector) * sign;
}


static float GetWorldScaleY(Drawable* drawable)
{
    Drawable* parent = drawable->parent;
    int       sign   = drawable->scaleY < 0.0f ? -1 : 1;

    while (parent != NULL)
    {
        if (parent->scaleY < 0.0f)
        {
            sign = -sign;
        }

        parent = parent->parent;
    }

    // the scaleY in the xyz axis is the length of the matrix column vector values
    Vector3 vector[1] =
    {{
        drawable->modelMatrix->m4,
        drawable->modelMatrix->m5,
        drawable->modelMatrix->m6,
    }};

    return AVector3_Length(vector) * sign;
}



static void GetWorldScaleV2(Drawable* drawable, Vector2* outScaleV2)
{
    Drawable* parent = drawable->parent;
    int       signX  = drawable->scaleX < 0.0f ? -1 : 1;
    int       signY  = drawable->scaleY < 0.0f ? -1 : 1;

    while (parent != NULL)
    {
        if (parent->scaleX < 0.0f)
        {
            signX = -signX;
        }

        if (parent->scaleY < 0.0f)
        {
            signY = -signY;
        }

        parent = parent->parent;
    }

    // the scale in the xyz axis is the length of the matrix column vector values
    Vector3 vectorX[1] =
    {{
         drawable->modelMatrix->m0,
         drawable->modelMatrix->m1,
         drawable->modelMatrix->m2,
    }};

    Vector3 vectorY[1] =
    {{
         drawable->modelMatrix->m4,
         drawable->modelMatrix->m5,
         drawable->modelMatrix->m6,
    }};

    outScaleV2->x = AVector3_Length(vectorX) * signX;
    outScaleV2->y = AVector3_Length(vectorY) * signY;
}


static float GetWorldPositionX(Drawable* drawable)
{
    ALog_A(drawable->parent != NULL, "ADrawable GetWorldPositionX the drawable parent cannot NULL !");
    return AMatrix->MultiplyMX(drawable->parent->modelMatrix, drawable->positionX);
}


static float GetWorldPositionY(Drawable* drawable)
{
    ALog_A(drawable->parent != NULL, "ADrawable GetWorldPositionY the drawable parent cannot NULL !");
    return AMatrix->MultiplyMX(drawable->parent->modelMatrix, drawable->positionY);
}


static void GetWorldPositionV2(Drawable* drawable, Vector2* outPositionV2)
{
    ALog_A(drawable->parent != NULL, "ADrawable GetWorldPositionV2 the drawable parent cannot NULL !");
    AMatrix->MultiplyMV2(drawable->parent->modelMatrix, drawable->positionX, drawable->positionY, outPositionV2);
}


static void GetWorldPositionV3(Drawable* drawable, Vector3* outPositionV3)
{
    ALog_A(drawable->parent != NULL, "ADrawable GetWorldPositionV3 the drawable parent cannot NULL !");
    
    AMatrix->MultiplyMV3
    (
        drawable->parent->modelMatrix,
        drawable->positionX,
        drawable->positionY,
        drawable->positionZ,
        outPositionV3
    );
}


//----------------------------------------------------------------------------------------------------------------------


static float ConvertToWorldPositionX(Drawable* localParent, float localPositionX)
{
    return AMatrix->MultiplyMX(localParent->modelMatrix, localPositionX);
}


static float ConvertToWorldPositionY(Drawable* localParent, float localPositionY)
{
    return AMatrix->MultiplyMY(localParent->modelMatrix, localPositionY);
}


static void ConvertToWorldPositionV2(Drawable* localParent, Vector2* localPositionV2, Vector2* outWorldPositionV2)
{
    AMatrix->MultiplyMV2(localParent->modelMatrix, localPositionV2->x, localPositionV2->y , outWorldPositionV2);
}


static inline void CheckInverse(Drawable* localParent)
{
    if (ADrawable_CheckState(localParent, DrawableState_UpdateInverseMatrix))
    {
        ADrawable_ClearState(localParent, DrawableState_UpdateInverseMatrix);
        AMatrix->Inverse(localParent->modelMatrix, localParent->inverseMatrix);
    }
}

static float ConvertToLocalPositionX(Drawable* localParent, float worldPositionX)
{
    CheckInverse(localParent);
    return AMatrix->MultiplyMX(localParent->inverseMatrix, worldPositionX);
}


static float ConvertToLocalPositionY(Drawable* localParent, float worldPositionY)
{
    CheckInverse(localParent);
    return AMatrix->MultiplyMY(localParent->inverseMatrix, worldPositionY);
}


static void ConvertToLocalPositionV2(Drawable* localParent, Vector2* worldPositionV2, Vector2* outLocalPositionV2)
{
    CheckInverse(localParent);
    AMatrix->MultiplyMV2(localParent->inverseMatrix, worldPositionV2->x, worldPositionV2->y, outLocalPositionV2);
}


static void ConvertToParent(Drawable* drawable, Drawable* parent)
{
    Vector2 worldPositionV2[1];
    float   worldRotationZ = GetWorldRotationZ(drawable);

    Vector2 worldScaleV2[1];
    GetWorldScaleV2(drawable, worldScaleV2);

    if (drawable->parent != NULL)
    {
        AMatrix->MultiplyMV2
        (
            drawable->parent->modelMatrix,
            drawable->positionX,
            drawable->positionY ,
            worldPositionV2
        );
    }
    else
    {
        AMatrix->MultiplyMV2
        (
            MATRIX4_IDENTITY_ARRAY,
            drawable->positionX,
            drawable->positionY ,
            worldPositionV2
        );
    }

    float rotationZ;

    if (parent != NULL)
    {
        Vector2 localPositionV2[1];
        ConvertToLocalPositionV2(parent,   worldPositionV2,    localPositionV2);
        ADrawable_SetPosition2  (drawable, localPositionV2->x, localPositionV2->y);

        Vector2 parentScaleV2[1];
        GetWorldScaleV2(parent, parentScaleV2);

        ALog_A(parentScaleV2->x != 0.0f, "ADrawable ConvertToParent failed, parent world scale x cannot 0.0f");
        ALog_A(parentScaleV2->y != 0.0f, "ADrawable ConvertToParent failed, parent world scale y cannot 0.0f");

        ADrawable_SetScale2(drawable, worldScaleV2->x / parentScaleV2->x, worldScaleV2->y / parentScaleV2->y);

        // if parent flipped then convert world rotationZ to parent flipped coordinate

        float parentRotationZ = GetWorldRotationZ(parent);

        if (parentScaleV2->x < 0.0f)
        {
            worldRotationZ  = 180.0f - worldRotationZ;
            parentRotationZ = 180.0f - parentRotationZ;
        }

        if (parentScaleV2->y < 0.0f)
        {
            worldRotationZ  = -worldRotationZ;
            parentRotationZ = -parentRotationZ;
        }

        // delta rotationZ between parent to world
        rotationZ = worldRotationZ - parentRotationZ;
    }
    else
    {
        rotationZ = worldRotationZ;
        ADrawable_SetPosition2(drawable, worldPositionV2->x, worldPositionV2->y);
        ADrawable_SetScale2   (drawable, worldScaleV2->x,    worldScaleV2->y);
    }

    if (drawable->scaleX < 0.0f)
    {
        rotationZ = 180.0f - drawable->rotationZ;
    }

    if (drawable->scaleY < 0.0f)
    {
        rotationZ = -drawable->rotationZ;
    }

    ADrawable_SetRotationZ(drawable, rotationZ);
    ADrawable_SetParent   (drawable, parent);
}


static float ConvertBetweenLocalPositionX(Drawable* parentA, float localPositionX, Drawable* parentB)
{
    ALog_A(parentA != NULL, "ADrawable ConvertBetweenLocalPositionX parentA cannot NULL");
    ALog_A(parentB != NULL, "ADrawable ConvertBetweenLocalPositionX parentB cannot NULL");

    return ConvertToLocalPositionX(parentB, AMatrix->MultiplyMX(parentA->modelMatrix, localPositionX));
}


static float ConvertBetweenLocalPositionY(Drawable* parentA, float localPositionY, Drawable* parentB)
{
    ALog_A(parentA != NULL, "ADrawable ConvertBetweenLocalPositionY parentA not NULL");
    ALog_A(parentB != NULL, "ADrawable ConvertBetweenLocalPositionY parentB not NULL");

    return ConvertToLocalPositionY(parentB, AMatrix->MultiplyMY(parentA->modelMatrix, localPositionY));
}


static void ConvertBetweenLocalPositionV2
(
    Drawable* parentA,
    Vector2*  localPositionV2,
    Drawable* parentB,
    Vector2*  outLocalPositionV2
)
{
    ALog_A(parentA            != NULL, "ADrawable ConvertBetweenLocal parentA            cannot NULL");
    ALog_A(localPositionV2    != NULL, "ADrawable ConvertBetweenLocal localPositionV2    cannot NULL");
    ALog_A(parentB            != NULL, "ADrawable ConvertBetweenLocal parentB            cannot NULL");
    ALog_A(outLocalPositionV2 != NULL, "ADrawable ConvertBetweenLocal outLocalPositionV2 cannot NULL");

    Vector2 worldPositionV2[1];
    AMatrix->MultiplyMV2    (parentA->modelMatrix,  localPositionV2->x, localPositionV2->y, worldPositionV2);
    ConvertToLocalPositionV2(parentB, worldPositionV2, outLocalPositionV2);
}


//----------------------------------------------------------------------------------------------------------------------


static float GetFlipRotationZ(Drawable* drawable, float rotationZ)
{
    if (drawable->scaleX < 0.0f)
    {
        rotationZ = 180.0f - rotationZ;
    }

    if (drawable->scaleY < 0.0f)
    {
        rotationZ = -rotationZ; // same as 360.0f - rotationZ;
    }

    return rotationZ;
}


static void Init(Drawable* outDrawable)
{
    AUserData_Init(outDrawable->userData);
    outDrawable->width         = 0.0f;
    outDrawable->height        = 0.0f;

    outDrawable->parent        = NULL;

    outDrawable->positionX     = 0.0f;
    outDrawable->positionY     = 0.0f;
    outDrawable->positionZ     = 0.0f;

    outDrawable->scaleX        = 1.0f;
    outDrawable->scaleY        = 1.0f;
    outDrawable->scaleZ        = 1.0f;

    outDrawable->rotationX     = 0.0f;
    outDrawable->rotationY     = 0.0f;
    outDrawable->rotationZ     = 0.0f;

    outDrawable->color->r      = 1.0f;
    outDrawable->color->g      = 1.0f;
    outDrawable->color->b      = 1.0f;
    outDrawable->color->a      = 1.0f;

    outDrawable->blendColor->r = 1.0f;
    outDrawable->blendColor->g = 1.0f;
    outDrawable->blendColor->b = 1.0f;
    outDrawable->blendColor->a = 1.0f;

//----------------------------------------------------------------------------------------------------------------------

   *outDrawable->modelMatrix   = *MATRIX4_IDENTITY_ARRAY;
    outDrawable->state         = DrawableState_Null;
    outDrawable->Draw          = NULL;
    outDrawable->Render        = NULL;

    // first born make matrix update
    // first born inverse matrix need update
    ADrawable_AddState
    (
        outDrawable,
        DrawableState_Transform           |
        DrawableState_UpdateInverseMatrix |
        DrawableState_Color               |
        DrawableState_IsBlendColor        |
        DrawableState_DrawChanged
    );
}


static Drawable* Create()
{
    Drawable* drawable = malloc(sizeof(Drawable));
    Init(drawable);

    return drawable;
}


struct ADrawable ADrawable[1] =
{{
    Create,
    Init,

    Draw,
    Render,
    GetDrawCalls,

    ConvertToWorldPositionX,
    ConvertToWorldPositionY,
    ConvertToWorldPositionV2,

    ConvertToLocalPositionX,
    ConvertToLocalPositionY,
    ConvertToLocalPositionV2,

    ConvertToParent,

    ConvertBetweenLocalPositionX,
    ConvertBetweenLocalPositionY,
    ConvertBetweenLocalPositionV2,

    GetFlipRotationZ,
    GetWorldRotationZ,
    GetWorldScaleX,
    GetWorldScaleY,
    GetWorldScaleV2,
    GetWorldPositionX,
    GetWorldPositionY,
    GetWorldPositionV2,
    GetWorldPositionV3,
}};

```

`Engine/Graphics/Draw/Drawable.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-2
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#ifndef DRAWABLE_H
#define DRAWABLE_H


#include <stdbool.h>
#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Toolkit/Math/Matrix.h"
#include "Engine/Toolkit/Math/Math.h"
#include "Engine/Toolkit/HeaderUtils/Bitwise.h"
#include "Engine/Toolkit/Utils/ArrayList.h"
#include "Engine/Graphics/Draw/Color.h"
#include "Engine/Toolkit/Math/Vector.h"
#include "Engine/Toolkit/HeaderUtils/UserData.h"


/**
 * If contains 'Is' the state can set add and clear,
 * else the state will automatically set add and clear.
 */
typedef enum
{
    DrawableState_Null                = 0,
    
    /**
     * Whether drawable is invisible.
     */
    DrawableState_IsInvisible         = 1,

    /**
     * Whether drawable mvp matrix need to update.
     */
    DrawableState_IsUpdateMVPMatrix   = 1 << 1,

    /**
     * Whether drawable calculate blendColor by parent.
     */
    DrawableState_IsBlendColor        = 1 << 2,

    /**
     * Flag drawable inverse matrix need to update.
     */
    DrawableState_UpdateInverseMatrix = 1 << 3,

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Flag drawable transform has changed.
     */
    DrawableState_TransformChanged    = 1 << 4,

    /**
     * Flag drawable rgb has changed.
     */
    DrawableState_RGBChanged          = 1 << 5,

    /**
     * Flag drawable opacity has changed.
     */
    DrawableState_OpacityChanged      = 1 << 6,

    /**
     * Flag drawable has been drawn.
     */
    DrawableState_DrawChanged         = 1 << 7,

    /**
     * Flag drawable color has changed
     */
    DrawableState_ColorChanged        = DrawableState_RGBChanged |
                                        DrawableState_OpacityChanged,

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Flag drawable parent has changed.
     */
    DrawableState_Parent              = 1 << 8,

    /**
     * Flag drawable position x has changed.
     */
    DrawableState_PositionX           = 1 << 9,

    /**
     * Flag drawable position y has changed.
     */
    DrawableState_PositionY           = 1 << 10,

    /**
     * Flag drawable position z has changed.
     */
    DrawableState_PositionZ           = 1 << 11,

    /**
     * Flag drawable position x and y have changed.
     */
    DrawableState_Position2           = DrawableState_PositionX |
                                        DrawableState_PositionY,

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Flag drawable scale x has changed.
     */
    DrawableState_ScaleX             = 1 << 12, 

    /**
     * Flag drawable scale y has changed.
     */
    DrawableState_ScaleY             = 1 << 13,

    /**
     * Flag drawable scale z has changed.
     */
    DrawableState_ScaleZ             = 1 << 14,

    /**
     * Flag drawable scale x and y have changed.
     */
    DrawableState_Scale2             = DrawableState_ScaleX | DrawableState_ScaleY,

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Flag drawable rotation x has changed.
     */
    DrawableState_RotationX          = 1 << 15,

    /**
     * Flag drawable rotation x has changed.
     */
    DrawableState_RotationY          = 1 << 16,

    /**
     * Flag drawable rotation x has changed.
     */
    DrawableState_RotationZ          = 1 << 17,

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Flag drawable rgb has changed.
     */
    DrawableState_RGB                 = 1 << 18,

    /**
     * Flag drawable opacity has changed.
     */
    DrawableState_Opacity             = 1 << 19,

    /**
     * Flag drawable color has changed.
     */
    DrawableState_Color               = DrawableState_RGB | DrawableState_Opacity,

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Flag drawable position scale rotate translate parent have changed.
     */
    DrawableState_Transform           = DrawableState_Parent    |
                                        DrawableState_PositionX |
                                        DrawableState_PositionY |
                                        DrawableState_PositionZ |
                                        DrawableState_ScaleX    |
                                        DrawableState_ScaleY    |
                                        DrawableState_ScaleZ    |
                                        DrawableState_RotationX |
                                        DrawableState_RotationY |
                                        DrawableState_RotationZ,

    /**
     * Flag drawable transform and color have changed.
     */
    DrawableState_Draw                = DrawableState_Transform |
                                        DrawableState_Color,
}
DrawableState;


typedef struct Drawable Drawable;

/**
 * If object can be drawn then must inherit Drawable.
 * the drawable provides transform, color, state, matrix properties,
 * but render function must be implemented by subclass.
 */
struct  Drawable
{
     UserData      userData[1];

     /* Default 0.0f, use openGL coordinate. */
     float         width;
     float         height;

//----------------------------------------------------------------------------------------------------------------------

     /**
      * If has parent will render use parent modelMatrix,
      * and parent invisible that children will stop rendering.
      */
     Drawable*     parent;

     /* The local position relative parent, default 0.0f. */
     float         positionX;
     float         positionY;
     float         positionZ;

     /* The local scale relative parent, default 1.0f. */
     float         scaleX;
     float         scaleY;
     float         scaleZ;

     /**
      * The local rotation relative parent, default 0.0f and clockwise [0.0f - 360.0f].
      */
     float         rotationX;
     float         rotationY;
     float         rotationZ;

     /**
      * The color value each between [0.0f, 1.0f], default {1.0f, 1.0f, 1.0f, 1.0f}.
      */
     Color         color        [1];

     /**
      * If set DrawableState_IsBlendColor
      *     equal (color) * (parent blendColor)
      * else
      *     equal color
      *
      * default {1.0f, 1.0f, 1.0f, 1.0f}
      */
     Color         blendColor   [1];

//----------------------------------------------------------------------------------------------------------------------

     /**
      * Cached MVP matrix when property has changed will update.
      */
     Matrix4       mvpMatrix    [1];

     /**
      * Cached model matrix when property has changed will update.
      */
     Matrix4       modelMatrix  [1];

     /**
      * Cached inverse model matrix。
      */
     Matrix4       inverseMatrix[1];

     /**
      * Flag the property changes.
      */
     DrawableState state;

//----------------------------------------------------------------------------------------------------------------------

    /**
      * Custom draw for preparing rendering data.
      * called by ADrawable's Draw, do not use any openGL command,
      * and can check any state change.
      *
      * if called in Scheduler or Coroutine may have draw order problem,
      * because the draw oder common controlled by Component.
      */
     void (*Draw)  (Drawable* drawable);

     /**
      * Render with openGL command.
      */
     void (*Render)(Drawable* drawable);
};


/**
 * Control Drawable and coordinate conversion.
 */
struct ADrawable
{
    Drawable* (*Create)                       (void);
    void      (*Init)                         (Drawable* outDrawable);

     /**
      * Transform model matrix by position scale rotation,
      * and calculate mvp matrix and blend color if needed,
      * and call drawable's Draw method.
      *
      * if render method implemented will push Drawable into render queue for flush openGL command.
      */
    void      (*Draw)                         (Drawable* drawable);

    /**
     * Call Render function of Drawable in the render queue and clear it for next frame.
     * the drawable will push into render queue when it's Draw function called.
     */
    void      (*Render)                       (void);

    /**
     * Get render queue size.
     */
    int       (*GetDrawCalls)                 (void);

    /**
     * Convert localPositionX in localParent to world coordinate.
     * return world position x.
     */
    float     (*ConvertToWorldPositionX)      (Drawable* localParent, float localPositionX);

    /**
     * Convert localPositionY in localParent to world coordinate.
     * return world position y.
     */
    float     (*ConvertToWorldPositionY)      (Drawable* localParent, float localPositionY);

    /**
     * Convert localPositionV2 in localParent to world coordinate.
     */
    void      (*ConvertToWorldPositionV2)     (
                                                   Drawable* localParent,
                                                   Vector2*  localPositionV2,
                                                   Vector2*  outWorldPositionV2
                                              );

    /**
     * Convert worldPositionX to localParent coordinate.
     * return local position x
     */
    float    (*ConvertToLocalPositionX)       (Drawable* localParent, float worldPositionX);

    /**
     * Convert worldPositionY to localParent coordinate.
     * return local position y.
     */
    float    (*ConvertToLocalPositionY)       (Drawable* localParent, float worldPositionY);

    /**
     * Convert worldPositionV2 to localParent coordinate.
     */
    void     (*ConvertToLocalPositionV2)      (
                                                  Drawable* localParent,
                                                  Vector2*  worldPositionV2,
                                                  Vector2*  outLocalPositionV2
                                              );

    /**
     * Set drawable parent and keep world transform.
     * if parent NULL transform will convert to world coordinate.
     */
    void     (*ConvertToParent)               (Drawable* drawable, Drawable* parent);


    /**
     * Convert localPositionX in parentA to parentB coordinate.
     * return local position x in parentB.
     */
    float    (*ConvertBetweenLocalPositionX)  (Drawable* parentA, float localPositionX, Drawable* parentB);

    /**
     * Convert localPositionY in parentA to ParentB coordinate.
     * return local position y in parentB.
     */
    float    (*ConvertBetweenLocalPositionY)  (Drawable* parentA, float localPositionY, Drawable* parentB);


    /**
     * Convert localPositionV2 in parentA to outLocalPositionV2 in parentB.
     */
    void     (*ConvertBetweenLocalPositionV2) (
                                                  Drawable* parentA,
                                                  Vector2*  localPositionV2,
                                                  Drawable* parentB,
                                                  Vector2*  outLocalPositionV2
                                              );

    /**
     * If Drawable has flip will transform rotationZ to flipped value.
     */
    float    (*GetFlipRotationZ)              (Drawable* drawable, float rotationZ);

    /**
     * Get drawable rotationZ in world coordinate.
     */
    float    (*GetWorldRotationZ)             (Drawable* drawable);

    /**
     * Get drawable scaleX in world coordinate.
     */
    float    (*GetWorldScaleX)                (Drawable* drawable);

    /**
     * Get drawable scaleY in world coordinate.
     */
    float    (*GetWorldScaleY)                (Drawable* drawable);

    /**
     * Get drawable scale Vector2 in world coordinate.
     */
    void     (*GetWorldScaleV2)               (Drawable* drawable, Vector2* outScaleV2);

    /**
     * Get drawable position x in world coordinate.
     */
    float    (*GetWorldPositionX)             (Drawable* drawable);

    /**
     * Get drawable position x in world coordinate.
     */
    float    (*GetWorldPositionY)             (Drawable* drawable);

    /**
     * Get drawable position Vector2 in world coordinate.
     */
    void     (*GetWorldPositionV2)            (Drawable* drawable, Vector2* outPositionV2);

    /**
     * Get drawable position Vector3 in world coordinate.
     */
    void     (*GetWorldPositionV3)            (Drawable* drawable, Vector3* outPositionV3);
};


extern struct ADrawable ADrawable[1];


//----------------------------------------------------------------------------------------------------------------------


/**
 * Check drawable whether has state.
 */
static inline bool ADrawable_CheckState(Drawable* drawable, DrawableState state)
{
    return ABitwise_Check(drawable->state, state);
}


/**
 * Add state to drawable.
 */
static inline void ADrawable_AddState(Drawable* drawable, DrawableState state)
{
    ABitwise_Add(drawable->state, state);
}


/**
 * Set state to drawable.
 */
static inline void ADrawable_SetState(Drawable* drawable, DrawableState state)
{
    ABitwise_Set(drawable->state, state);
}


/**
 * Clear drawable state.
 */
static inline void ADrawable_ClearState(Drawable* drawable, DrawableState state)
{
    ABitwise_Clear(drawable->state, state);
}


/**
 * Clear drawable clearState and add addState.
 */
static inline void ADrawable_ClearAndAddState(Drawable* drawable, DrawableState clearState, DrawableState addState)
{
    ABitwise_ClearAndAdd(drawable->state, clearState, addState);
}


//----------------------------------------------------------------------------------------------------------------------


/**
 * Make drawable visible.
 */
static inline void ADrawable_SetVisible(Drawable* drawable)
{
    ADrawable_ClearState(drawable, DrawableState_IsInvisible);
}


/**
 * Make drawable invisible.
 */
static inline void ADrawable_SetInvisible(Drawable* drawable)
{
    ADrawable_AddState(drawable, DrawableState_IsInvisible);
}


/**
 * Check drawable whether is visible.
 */
static inline bool ADrawable_CheckVisible(Drawable* drawable)
{
    return ADrawable_CheckState(drawable, DrawableState_IsInvisible) == false;
}


//----------------------------------------------------------------------------------------------------------------------


/**
 * Set drawable parent, current transform will become local in new parent.
 * use ADrawable->ConvertToParent can keep world transform stay.
 */
static inline void ADrawable_SetParent(Drawable* drawable, Drawable* parent)
{
    drawable->parent = parent;
    ADrawable_AddState(drawable, DrawableState_Parent);
}


//----------------------------------------------------------------------------------------------------------------------


/**
 * Set drawable position x, and flag state for Drawable->Draw to change modelMatrix.
 */
static inline void ADrawable_SetPositionX(Drawable* drawable, float positionX)
{
    drawable->positionX = positionX;
    ADrawable_AddState(drawable, DrawableState_PositionX);
}


/**
 * Set drawable position y, and flag state for Drawable->Draw to change modelMatrix.
 */
static inline void ADrawable_SetPositionY(Drawable* drawable, float positionY)
{
    drawable->positionY = positionY;
    ADrawable_AddState(drawable, DrawableState_PositionY);
}

/**
* Set drawable position x y, and flag state for Drawable->Draw to change modelMatrix.
*/
static inline void ADrawable_SetPosition2(Drawable* drawable, float positionX, float positionY)
{
    drawable->positionX = positionX;
    drawable->positionY = positionY;
    ADrawable_AddState(drawable, DrawableState_Position2);
}


/**
* Set drawable position same x y, and flag state for Drawable->Draw to change modelMatrix.
*/
static inline void ADrawable_SetPositionSame2(Drawable* drawable, float position)
{
    drawable->positionX = position;
    drawable->positionY = position;
    ADrawable_AddState(drawable, DrawableState_Position2);
}


//----------------------------------------------------------------------------------------------------------------------


/**
 * Set drawable scale x, and flag state for Drawable->Draw to change modelMatrix.
 */
static inline void ADrawable_SetScaleX(Drawable* drawable, float scaleX)
{
    drawable->scaleX = scaleX;
    ADrawable_AddState(drawable, DrawableState_ScaleX);
}


/**
 * Set drawable scale y, and flag state for Drawable->Draw to change modelMatrix.
 */
static inline void ADrawable_SetScaleY(Drawable* drawable, float scaleY)
{
    drawable->scaleY = scaleY;
    ADrawable_AddState(drawable, DrawableState_ScaleY);
}


/**
 * Set drawable scale x y, and flag state for Drawable->Draw to change modelMatrix.
 */
static inline void ADrawable_SetScale2(Drawable* drawable, float scaleX, float scaleY)
{
    drawable->scaleX = scaleX;
    drawable->scaleY = scaleY;
    ADrawable_AddState(drawable, DrawableState_Scale2);
}


/**
 * Set drawable scale same x y, and flag state for Drawable->Draw to change modelMatrix.
 */
static inline void ADrawable_SetScaleSame2(Drawable* drawable, float scale)
{
    drawable->scaleX = scale;
    drawable->scaleY = scale;
    ADrawable_AddState(drawable, DrawableState_Scale2);
}


//----------------------------------------------------------------------------------------------------------------------


/**
 * Set drawable rotation x, and flag state for Drawable->Draw to change modelMatrix.
 */
static inline void ADrawable_SetRotationX(Drawable* drawable, float rotationX)
{
    drawable->rotationX = rotationX;
    ADrawable_AddState(drawable, DrawableState_RotationX);
}


/**
 * Set drawable rotation y, and flag state for Drawable->Draw to change modelMatrix.
 */
static inline void ADrawable_SetRotationY(Drawable* drawable, float rotationY)
{
    drawable->rotationY = rotationY;
    ADrawable_AddState(drawable, DrawableState_RotationY);
}


/**
 * Set drawable rotation z, and flag state for Drawable->Draw to change modelMatrix.
 */
static inline void ADrawable_SetRotationZ(Drawable* drawable, float rotationZ)
{
    drawable->rotationZ = rotationZ;
    ADrawable_AddState(drawable, DrawableState_RotationZ);
}


//----------------------------------------------------------------------------------------------------------------------


/**
 * Set drawable rgb, and flag state for Drawable->Draw to change blendColor.
 */
static inline void ADrawable_SetRGB(Drawable* drawable, float red, float green, float blue)
{
    drawable->color->r = red;
    drawable->color->g = green;
    drawable->color->b = blue;
    ADrawable_AddState(drawable, DrawableState_RGB);
}


/**
 * Set drawable same rgb, and flag state for Drawable->Draw to change blendColor.
 */
static inline void ADrawable_SetRGBSame(Drawable* drawable, float rgb)
{
    drawable->color->r = rgb;
    drawable->color->g = rgb;
    drawable->color->b = rgb;
    ADrawable_AddState(drawable, DrawableState_RGB);
}


/**
 * Set drawable opacity, and flag state for Drawable->Draw to change blendColor.
 */
static inline void ADrawable_SetOpacity(Drawable* drawable, float opacity)
{
    drawable->color->a = opacity;
    ADrawable_AddState(drawable, DrawableState_Opacity);
}


/**
 * Set drawable rgba, and flag state for Drawable->Draw to change blendColor.
 */
static inline void ADrawable_SetRGBA(Drawable* drawable, float red, float green, float blue, float opacity)
{
    drawable->color->r = red;
    drawable->color->g = green;
    drawable->color->b = blue;
    drawable->color->a = opacity;
    ADrawable_AddState(drawable, DrawableState_Color);
}


/**
 * Set drawable same rgba, and flag state for Drawable->Draw to change blendColor.
 */
static inline void ADrawable_SetRGBASame(Drawable* drawable, float rgba)
{
    drawable->color->r = rgba;
    drawable->color->g = rgba;
    drawable->color->b = rgba;
    drawable->color->a = rgba;
    ADrawable_AddState(drawable, DrawableState_Color);
}


/**
 * Set drawable color, and flag state for Drawable->Draw to change blendColor.
 */
static inline void ADrawable_SetColor(Drawable* drawable, Color* color)
{
    *drawable->color = *color;
    ADrawable_AddState(drawable, DrawableState_Color);
}


/**
 * Make drawable color blend parent blendColor.
 */
static inline void ADrawable_SetBlendColor(Drawable* drawable)
{
    ADrawable_AddState(drawable, DrawableState_IsBlendColor);
}


#endif

```

`Engine/Graphics/Draw/Quad.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2012-12-25
 * Update   : 2019-1-23
 * Author   : scott.cgi
 */


#include <string.h>
#include <stdlib.h>
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/Draw/Quad.h"
#include "Engine/Graphics/OpenGL/GLTool.h"


static void Init(float width, float height, Quad* outQuad)
{
    outQuad->width          =  width;
    outQuad->height         =  height;
    
    outQuad->offsetCenterX  = -width  / 2;
    outQuad->offsetCenterY  =  height / 2;
    
    outQuad->offsetTextureX =  0.0f;
    outQuad->offsetTextureY =  0.0f;
}


static Quad* Create(float width, float height)
{
    Quad* quad = malloc(sizeof(Quad));
    Init(width, height, quad);

    return quad;
}


static void GetMaxSize(Array(Quad)* quadArr,  float* outWidth, float* outHeight)
{
    Quad* quads = quadArr->data;
    Quad* quad  = quads;

    float  minX  = quad->offsetCenterX;
    float  maxY  = quad->offsetCenterY;
    
    float  maxX  = minX + quad->width;
    float  minY  = maxY - quad->height;

    for (int i = 1; i < quadArr->length; ++i)
    {
        quad          = quads + i;

        float leftX   = quad->offsetCenterX;
        float topY    = quad->offsetCenterY;
        
        float rightX  = leftX + quad->width;
        float bottomY = topY - quad->height;

        // find the min x
        if (leftX < minX)
        {
            minX = leftX;
        }

        // find the max y
        if (topY > maxY)
        {
            maxY = topY;
        }

        // find the max x
        if (rightX > maxX)
        {
            maxX = rightX;
        }

        // find the min y
        if (bottomY < minY)
        {
            minY = bottomY;
        }
    }

    *outWidth  = maxX - minX;
    *outHeight = maxY - minY;
}


static void GetPosition2UV(Quad* quad, Texture* texture, float outPosition2UVData[Quad_Position2UVNum])
{
    float qx = quad->offsetCenterX;
    float qy = quad->offsetCenterY;

    float qw = qx + quad->width;
    float qh = qy - quad->height;

    float tx = AGLTool_ToUVWidth (quad->offsetTextureX, texture->width);
    float ty = AGLTool_ToUVHeight(quad->offsetTextureY, texture->height);

    float tw = tx + AGLTool_ToUVWidth (quad->width,  texture->width);
    float th = ty + AGLTool_ToUVHeight(quad->height, texture->height);

    memcpy
    (
        outPosition2UVData,
        (float[Quad_Position2UVNum])
        {
            qx, qy, // position 0, top    left
            tx, ty, // texcoord 0, top    left

            qx, qh, // position 1, bottom left
            tx, th, // texcoord 1, bottom left

            qw, qh, // position 2, bottom right
            tw, th, // texcoord 2, bottom right

            qw, qy, // position 3, top    right
            tw, ty, // texcoord 3, top    right
        },
        Quad_Position2UVSize
    );
}


static void GetPosition3(Quad* quad, float outBornPositionData[Quad_Position3Num])
{
    float qx = quad->offsetCenterX;
    float qy = quad->offsetCenterY;

    float qw = qx + quad->width;
    float qh = qy - quad->height;

    memcpy
    (
        outBornPositionData,
        (float[Quad_Position3Num])
        {
            qx, qy, 0.0f, // position 0, top    left
            qx, qh, 0.0f, // position 1, bottom left
            qw ,qh, 0.0f, // position 2, bottom right
            qw, qy, 0.0f, // position 3, top    right
        },
        Quad_Position3Size
    );
}


static void GetUV(Quad* quad, Texture* texture, float outUVData[Quad_UVNum])
{
    float tx = AGLTool_ToUVWidth (quad->offsetTextureX, texture->width);
    float ty = AGLTool_ToUVHeight(quad->offsetTextureY, texture->height);

    float tw = tx + AGLTool_ToUVWidth (quad->width,  texture->width);
    float th = ty + AGLTool_ToUVHeight(quad->height, texture->height);

    memcpy
    (
        outUVData,
        (float[Quad_UVNum])
        {
            tx, ty, // texCoord 0, top    left
            tx, th, // texCoord 1, bottom left
            tw, th, // texCoord 2, bottom right
            tw, ty, // texCoord 3, top    right
        },
        Quad_UVSize
    );
}


static void GetIndex(int vertexNumBefore, short outIndexData[Quad_IndexNum])
{
    memcpy
    (
        outIndexData,
        (short[Quad_IndexNum])
        {
            (short) (0 + vertexNumBefore),
            (short) (1 + vertexNumBefore),
            (short) (2 + vertexNumBefore),

            (short) (2 + vertexNumBefore),
            (short) (3 + vertexNumBefore),
            (short) (0 + vertexNumBefore),
        },
        Quad_IndexSize
    );
}


struct AQuad AQuad[1] =
{{
    Create,
    Init,
    GetMaxSize,

    GetPosition2UV,
    GetPosition3,
    GetUV,
    GetIndex,
}};

```

`Engine/Graphics/Draw/Quad.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2012-12-25
 * Update   : 2019-1-23
 * Author   : scott.cgi
 */


#ifndef QUAD_H
#define QUAD_H


#include "Engine/Toolkit/Utils/Array.h"
#include "Engine/Graphics/OpenGL/Texture.h"


enum
{
    /**
     * One quad has 4 vertices
     */
    Quad_VertexNum       = 4,

    /**
     * Two triangles (index order: 012, 230) has 6 vertices (index 2,0 repeats).
     */
    Quad_IndexNum        = 6,
    Quad_IndexSize       = Quad_IndexNum       * sizeof(short),

    /**
     *  3 (x, y, z) * 4 (vertices)
     */
    Quad_Position3Num    = 12,
    Quad_Position3Size   = Quad_Position3Num   * sizeof(float),

    /**
     * 2 (u, v) * 4 (vertices)
     */
    Quad_UVNum           = 8,
    Quad_UVSize          = Quad_UVNum          * sizeof(float),

    /**
     * 1 * 4 (vertices)
     */
    Quad_OpacityNum      = 4,
    Quad_OpacitySize     = Quad_OpacityNum     * sizeof(float),

    /**
     * 3 (r, g ,b) * 4 (vertices)
     */
    Quad_RGBNum          = 12,
    Quad_RGBSize         = Quad_RGBNum         * sizeof(float),

    /**
     * 2 (x, y) * 4 (vertices)
     */
    Quad_Position2Num    = 8,
    Quad_Position2UVNum  = Quad_Position2Num   + Quad_UVNum,
    Quad_Position2UVSize = Quad_Position2UVNum * sizeof(float),
};


/**
 * Rect in texture.
 */
typedef struct
{
    /**
     * The width in openGL coordinate.
     */
    float width;

    /**
     * The height in openGL coordinate.
     */
    float height;

    /**
     * The top left x of quad in texture, openGL coordinate, default 0.
     */
    float offsetTextureX;

    /**
     * The top left y of quad in texture, openGL coordinate, default 0.
     */
    float offsetTextureY;

    /**
     * The top left x offset the center.
     * default Quad center born in center of openGL coordinate,
     * so default value is (-width / 2).
     */
    float offsetCenterX;
    
    /**
     * The top left y offset the center.
     * default Quad center born in center of openGL coordinate,
     * so default value is (height / 2)
     */
    float offsetCenterY;
}
Quad;


/**
 * Control Quad.
 */
struct AQuad
{
    Quad* (*Create)       (float width, float height);
    void  (*Init)         (float width, float height, Quad* outQuad);

    /**
     * Get max size of all quads in array.
     */
    void (*GetMaxSize)    (Array(Quad)* quadArr, float* outWidth, float* outHeight);

    /**
     * Get Quad 4 vertices position and uv data into vertexData.
     */
    void (*GetPosition2UV)(Quad* quad, Texture* texture, float outPosition2UVData[Quad_Position2UVNum]);

    /**
     * Get Quad 4 vertices position data into bornPositionData.
     */
    void (*GetPosition3)  (Quad* quad, float outBornPositionData[Quad_Position3Num]);

    /**
     * Get Quad 4 vertices uv data into uvData.
     */
    void (*GetUV)         (Quad* quad, Texture* texture, float outUVData[Quad_UVNum]);

    /**
     * Get Quad 4 vertices index data into indexData.
     */
    void (*GetIndex)      (int vertexNumBefore, short outIndexData[Quad_IndexNum]);
};


extern struct AQuad AQuad[1];


#endif

```

`Engine/Graphics/Graphics.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-9-8
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#include "Engine/Graphics/Graphics.h"
#include "Engine/Graphics/OpenGL/Shader/ShaderMesh.h"
#include "Engine/Graphics/OpenGL/Shader/ShaderSprite.h"
#include "Engine/Graphics/OpenGL/Shader/ShaderPrimitive.h"
#include "Engine/Graphics/OpenGL/GLInfo.h"


static void Init()
{
    AGLInfo         ->Init();
    AShaderMesh     ->Init();
    AShaderSprite   ->Init();
    AShaderPrimitive->Init();

    AGraphics->isUseVBO       = false;
    AGraphics->isUseVAO       = false;
    AGraphics->isUseMapBuffer = false;
}


static void SetUseVAO(bool isUseVAO)
{
    if (isUseVAO && AGLInfo->version > 2.0f)
    {
        AGraphics->isUseVAO = true;
        AGraphics->isUseVBO = true;
    }
    else
    {
        AGraphics->isUseVAO = false;
        AGraphics->isUseVBO = false;
    }
}


static void SetUseMapBuffer(bool isUseMapBuffer)
{
    if (isUseMapBuffer && AGLInfo->version > 2.0f)
    {
        AGraphics->isUseMapBuffer = true;
    }
    else
    {
        AGraphics->isUseMapBuffer = false;
    }
}


struct AGraphics AGraphics[1] =
{{
    false,
    false,
    false,
    Init,
    SetUseVAO,
    SetUseMapBuffer,
}};

```

`Engine/Graphics/Graphics.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-9-8
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#ifndef GRAPHICS_H
#define GRAPHICS_H


#include <stdbool.h>


/**
 * Manage and control Graphics module.
 */
struct AGraphics
{
    /**
     * Default false.
     */
    bool isUseVBO;

    /**
     * Default false.
     * setting by method SetUseVAO.
     */
    bool isUseVAO;

    /**
     * Default false.
     * setting by method SetUseMapBuffer.
     */
    bool isUseMapBuffer;

    /**
     * Init graphics each parts.
     */
    void (*Init)           (void);

    /**
     * If VAO not support nothing changed.
     * if use VAO also use VBO.
     */
    void (*SetUseVAO)      (bool isUseVAO);

    /**
     * If glMapBufferRange not support will use glBufferSubData.
     * if not use VBO no effect.
     */
    void (*SetUseMapBuffer)(bool isUseMapBuffer);
};


extern struct AGraphics AGraphics[1];


#endif

```

`Engine/Graphics/OpenGL/Camera.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-10
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#include "Engine/Graphics/OpenGL/Camera.h"


static void SetOrthographic()
{
    // near and far is distance of eye position to look up direction
    AMatrix->Orthographic
    (
        ACamera->left,
        ACamera->right,
        ACamera->bottom,
        ACamera->top,
        ACamera->near,
        ACamera->far,
        ACamera->projection
    );

    AMatrix->MultiplyMM(ACamera->projection, ACamera->view, ACamera->vp);
}


static void SetFrustum()
{
    // near and far is distance of eye position to look up direction
    AMatrix->Frustum
    (
        ACamera->left,
        ACamera->right,
        ACamera->bottom,
        ACamera->top,
        ACamera->near,
        ACamera->far,
        ACamera->projection
    );

    AMatrix->MultiplyMM(ACamera->projection, ACamera->view, ACamera->vp);
}


static void SetLookAt()
{
    AMatrix->LookAt
    (
        ACamera->eyeX,
        ACamera->eyeY,
        ACamera->eyeZ,
        ACamera->lookX,
        ACamera->lookY,
        ACamera->lookZ,
        ACamera->upX,
        ACamera->upY,
        ACamera->upZ,
        ACamera->view
    );

    AMatrix->MultiplyMM(ACamera->projection, ACamera->view, ACamera->vp);
}


static float GetNearZOrder()
{
    return ACamera->eyeZ - ACamera->near;
}


static float GetFarZOrder()
{
    return GetNearZOrder() - ACamera->far;
}


struct ACamera ACamera[1] =
{{
    0, 0, 0,
    0, 0, 0,
    0, 0, 0,
    0, 0, 0,
    0, 0, 0,

    MATRIX4_IDENTITY,
    MATRIX4_IDENTITY,
    MATRIX4_IDENTITY,

    SetOrthographic,
    SetFrustum,
    SetLookAt,
    GetNearZOrder,
    GetFarZOrder,
}};


```

`Engine/Graphics/OpenGL/Camera.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-10
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#ifndef CAMERA_H
#define CAMERA_H


#include "Engine/Toolkit/Math/Matrix.h"
#include "Engine/Toolkit/Math/Math.h"


/**
 * Control main camera.
 */
struct ACamera
{
    float left;
    float right;
    float bottom;

    float top;
    float near;
    float far;

    /**
     * Camera position.
     */
    float eyeX;
    float eyeY;
    float eyeZ;

    /**
     * We are looking toward the distance.
     */
    float lookX;
    float lookY;
    float lookZ;

    /**
     * The up vector control camera direction, perpendicular to the camera plane.
     */
    float upX;
    float upY;
    float upZ;
    
    /**
     * Store view projection matrix.
     */
    Matrix4 vp        [1];

    /**
     * Store projection matrix.
     */
    Matrix4 projection[1];

    /**
     * Store the view matrix.
     */
    Matrix4  view     [1];


    void  (*SetOrthographic)(void);
    void  (*SetFrustum)     (void);
    void  (*SetLookAt)      (void);

    /**
     * The ZOrder most near camera.
     */
    float (*GetNearZOrder)(void);

    /**
     * The ZOrder most far camera.
     */
    float (*GetFarZOrder) (void);
};


extern struct ACamera ACamera[1];


#endif

```

`Engine/Graphics/OpenGL/GLInfo.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-4-17
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#include <string.h>
#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Graphics/OpenGL/GLInfo.h"
#include "Engine/Toolkit/Platform/Log.h"


static void Init()
{
    const char* version = (char*) glGetString(GL_VERSION);

    ALog_D
    (
        "vendor = %s \n renderer = %s \n version = %s \n extensions = %s",
         glGetString(GL_VENDOR),
         glGetString(GL_RENDERER),
         version,
         glGetString(GL_EXTENSIONS)
    );

    if(strstr(version, "OpenGL ES 3.") != NULL)
    {
        AGLInfo->version = 3.0f;
    }
    else
    {
        AGLInfo->version = 2.0f;
    }


    glGetFloatv  (GL_ALIASED_POINT_SIZE_RANGE,          AGLInfo->pointSizeRange);
    glGetFloatv  (GL_ALIASED_LINE_WIDTH_RANGE,          AGLInfo->lineWidthRange);

    glGetIntegerv(GL_MAX_VERTEX_ATTRIBS,               &AGLInfo->maxVertexAttribs);
    glGetIntegerv(GL_MAX_VERTEX_UNIFORM_VECTORS,       &AGLInfo->maxVertexUniformVectors);
    glGetIntegerv(GL_MAX_FRAGMENT_UNIFORM_VECTORS,     &AGLInfo->maxFragmentUniformVectors);
    glGetIntegerv(GL_MAX_VARYING_VECTORS,              &AGLInfo->maxVaryingVectors);
    glGetIntegerv(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS,   &AGLInfo->maxVertexTextureImageUnits);
    glGetIntegerv(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS, &AGLInfo->maxCombinedTextureImageUnits);
    glGetIntegerv(GL_MAX_TEXTURE_IMAGE_UNITS,          &AGLInfo->maxTextureImageUnits);
}


struct AGLInfo AGLInfo[1] =
{{
    .Init = Init
}};

```

`Engine/Graphics/OpenGL/GLInfo.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-4-17
 * Update   : 2019-1-14
 * Author   : scott.cgi
 */


#ifndef GL_INFO_H
#define GL_INFO_H


#include <stdbool.h>
#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Toolkit/HeaderUtils/Define.h"


/**
 * OpenGL some information.
 */
struct AGLInfo
{
    GLfloat pointSizeRange[2];
    GLfloat lineWidthRange[2];

    GLint   maxVertexAttribs;
    GLint   maxVertexUniformVectors;
    GLint   maxVertexTextureImageUnits;
    GLint   maxFragmentUniformVectors;
    GLint   maxVaryingVectors;
    GLint   maxCombinedTextureImageUnits;
    GLint   maxTextureImageUnits;

    float   version;

    void (*Init)(void);
};


extern struct AGLInfo AGLInfo[1];


#endif

```

`Engine/Graphics/OpenGL/GLPrimitive.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-2-26
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#include "Engine/Graphics/OpenGL/GLPrimitive.h"
#include "Engine/Graphics/OpenGL/Shader/ShaderPrimitive.h"
#include "Engine/Graphics/OpenGL/Camera.h"


static inline void Render
(
    GLenum   mode,
    void*    data,
    Matrix4* mvpMatrix,
    Color*   color,
    float    pointOrLineSize,
    int      count,
    bool     isLine
)
{
    if (isLine)
    {
        AShaderPrimitive->Use(mvpMatrix, color, 1.0f);
        glLineWidth(pointOrLineSize);
    }
    else
    {
        AShaderPrimitive->Use(mvpMatrix, color, pointOrLineSize);
    }

    glVertexAttribPointer((GLuint) AShaderPrimitive->attribPosition, 2, GL_FLOAT, false, 0, data);
    glDrawArrays(mode, 0, count);
}


static void RenderPoints(Array(float)* pointArr, Matrix4* mvpMatrix, Color* color, float pointSize)
{
    Render(GL_POINTS, pointArr->data, mvpMatrix, color, pointSize, pointArr->length >> 1, false);
}


static void RenderPolygon(Array(float)* vertexArr, Matrix4* mvpMatrix, Color* color, float lineWidth)
{
    Render(GL_LINE_LOOP, vertexArr->data, mvpMatrix, color, lineWidth, vertexArr->length >> 1, true);
}


static void RenderLines(Array(float)* lineArr, Matrix4* mvpMatrix, Color* color, float lineWidth)
{
    Render(GL_LINE_STRIP, lineArr->data, mvpMatrix, color, lineWidth, lineArr->length >> 1, true);
}


static void RenderRect(Rect* rect, Matrix4* mvpMatrix, Color* color, float lineWidth)
{
    Render
    (
        GL_LINE_LOOP,
        (float[8])
        {
            rect->top,    rect->left,
            rect->bottom, rect->left,
            rect->bottom, rect->right,
            rect->top,    rect->right,
        },
        mvpMatrix,
        color,
        lineWidth,
        4,
        true
    );
}


struct AGLPrimitive AGLPrimitive[1] =
{{
    RenderPoints,
    RenderPolygon,
    RenderLines,
    RenderRect,
}};

```

`Engine/Graphics/OpenGL/GLPrimitive.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-2-26
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#ifndef GL_PRIMITIVE_H
#define GL_PRIMITIVE_H


#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Toolkit/Math/Matrix.h"
#include "Engine/Toolkit/Math/Math.h"
#include "Engine/Toolkit/HeaderUtils/Rect.h"
#include "Engine/Graphics/Draw/Color.h"
#include "Engine/Toolkit/Utils/Array.h"


/**
 * Draw something without texture.
 * can render with Drawable's Render function.
 */
struct AGLPrimitive
{
    /**
     * Render array of points, the point is pair of x, y.
     */
    void (*RenderPoints) (Array(float)* pointArr,  Matrix4* mvpMatrix, Color* color, float pointSize);

    /**
     * Render array of vertices, the vertex is pair of x, y.
     */
    void (*RenderPolygon)(Array(float)* vertexArr, Matrix4* mvpMatrix, Color* color, float lineWidth);

    /**
     * Render array of lines, the line is two pairs of x, y.
     */
    void (*RenderLines)  (Array(float)* lineArr,   Matrix4* mvpMatrix, Color* color, float lineWidth);

    /**
     * Render rect.
     */
    void (*RenderRect)   (Rect*         rect,      Matrix4* mvpMatrix, Color* color, float lineWidth);
};


extern struct AGLPrimitive AGLPrimitive[1];


#endif

```

`Engine/Graphics/OpenGL/GLTool.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2012-12-22
 * Update   : 2019-1-23
 * Author   : scott.cgi
 */


#include <string.h>
#include <stdlib.h>
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Toolkit/Utils/FileTool.h"
#include "Engine/Graphics/Utils/Image.h"


static void SetSize(int width, int height)
{
    // set the OpenGL viewport to the same size as the surface.
    glViewport(0, 0, width, height);

    AGLTool->screenWidth          = (float) width;
    AGLTool->screenHeight         = (float) height;
    AGLTool->screenRatio          = (float) width  / (float) height;
    AGLTool->screenHalfWidth      = (float) width  / 2;
    AGLTool->screenHalfHeight     = (float) height / 2;

    AGLTool->ratioDivideHalfWidth = AGLTool->screenRatio     / AGLTool->screenHalfWidth;
    AGLTool->halfWidthDivideRatio = AGLTool->screenHalfWidth / AGLTool->screenRatio;
}


static GLuint LoadShader(GLenum shaderType, const char* shaderSourceStr)
{
    // create the shader object
    GLuint shader = glCreateShader(shaderType);

    if (shader == 0)
    {
        ALog_E("AGLTool LoadShader glCreateShader failed !");
        return shader;
    }

    // load the shader source
    glShaderSource(shader, 1, &shaderSourceStr, NULL);

    // compile the shader
    glCompileShader(shader);

    GLint compiled;

    // check the compile status
    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);

    if (compiled == GL_FALSE)
    {
        GLint infoLen = 0;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);

        if (infoLen > 0)
        {
            char buffer[infoLen];
            glGetShaderInfoLog(shader, infoLen, NULL, buffer);
            ALog_E("AGLTool LoadShader could not compile shader: %s, log: %s", shaderSourceStr, buffer);
            glDeleteShader(shader);
        }
        else
        {
            ALog_E("AGLTool LoadShader could not compile shader: %s", shaderSourceStr);
        }

        return 0;
    }

    return shader;
}


static GLuint LoadProgram(const char* vertexSourceStr, const char* fragmentSourceStr)
{
    GLuint program;

    // load the vertex shader
    GLuint vertexShader = LoadShader(GL_VERTEX_SHADER, vertexSourceStr);

    if (vertexShader == 0)
    {
        ALog_E("AGLTool LoadProgram failed, cannot load shader: %s", vertexSourceStr);
        return 0;
    }

    // load the fragment shader
    GLuint fragmentShader = LoadShader(GL_FRAGMENT_SHADER, fragmentSourceStr);

    if (fragmentShader == 0)
    {
        ALog_E("AGLTool LoadProgram failed, cannot load shader: %s", fragmentSourceStr);
        return 0;
    }

    // create the program object
    program = glCreateProgram();

    if (program == 0)
    {
        ALog_E("AGLTool LoadProgram glCreateProgram failed，from shader: %s, %s", vertexSourceStr, fragmentSourceStr);
        return 0;
    }

    glAttachShader(program, vertexShader);
    glAttachShader(program, fragmentShader);

    // link the program
    glLinkProgram(program);

    GLint linkStatus;
    // check the link status
    glGetProgramiv(program, GL_LINK_STATUS, &linkStatus);

    if (linkStatus == GL_FALSE)
    {
        GLint bufLength = 0;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &bufLength);

        if (bufLength > 0)
        {
            char buffer[bufLength];
            glGetProgramInfoLog(program, bufLength, NULL, buffer);
            ALog_E
            (
                "AGLTool LoadProgram cannot link program from shader: %s, %s, log: %s",
                vertexSourceStr,
                fragmentSourceStr,
                buffer
            );
        }
        else
        {
            ALog_E
            (
                "AGLTool LoadProgram cannot link program from shader: %s, %s",
                vertexSourceStr,
                fragmentSourceStr
            );
        }

        glDeleteProgram(program);

        return 0;
    }

    // free up no longer needed shader resources
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    return program;
}


GLuint LoadProgramFromFile(const char* vertexShaderFilePath, const char* fragmentShaderFilePath)
{
    char* vertexShader   = AFileTool->CreateStringFromResource(vertexShaderFilePath);
    char* fragmentShader = AFileTool->CreateStringFromResource(fragmentShaderFilePath);
    GLuint program       = LoadProgram(vertexShader, fragmentShader);

    free((void*) vertexShader);
    free((void*) fragmentShader);

    return program;
}


static void LoadTexture(const char* textureFilePath, Texture* outTexture)
{
     GLuint textureID;

     // use tightly packed data
     // glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

     // generate a outTexture object
     glGenTextures(1, &textureID);

     // bind to the outTexture
     glBindTexture(GL_TEXTURE_2D, textureID);

     outTexture->id = textureID;

     // set filtering
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,     GL_CLAMP_TO_EDGE);
     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,     GL_CLAMP_TO_EDGE);

     float width;
     float height;

     void* pixels = AImage->CreatePixelDataFromPNG(textureFilePath, &width, &height);
     ALog_A(pixels != NULL, "AGLTool LoadTexture failed, no pixels data found");

     // load the data into the bound outTexture
     glTexImage2D
     (
         GL_TEXTURE_2D,
         0,
         GL_RGBA,
         (GLsizei) width,
         (GLsizei) height, 
         0,
         GL_RGBA,
         GL_UNSIGNED_BYTE,
         pixels
     );

     outTexture->width  = AGLTool_ToGLWidth (width);
     outTexture->height = AGLTool_ToGLHeight(height);

     free(pixels);
}


struct AGLTool AGLTool[1] =
{{
    .SetSize             = SetSize,

    .LoadShader          = LoadShader,
    .LoadProgram         = LoadProgram,

    .LoadProgramFromFile = LoadProgramFromFile,
    .LoadTexture         = LoadTexture,
}};


```

`Engine/Graphics/OpenGL/GLTool.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2012-12-22
 * Update   : 2019-1-23
 * Author   : scott.cgi
 */


#ifndef GL_TOOL_H
#define GL_TOOL_H


#include <stdbool.h>
#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Graphics/OpenGL/Texture.h"
#include "Engine/Toolkit/HeaderUtils/Define.h"


struct AGLTool
{
    /**
     * Screen pixel width.
     */
    float screenWidth;

    /**
     * Screen pixel heigh.t
     */
    float screenHeight;

    /**
     * Screen half pixel width.
     */
    float screenHalfWidth;

    /**
     * Screen half pixel height.
     */
    float screenHalfHeight;

    /**
     * Screen (width / height).
     */
    float screenRatio;

    /**
     * Screen (ratio / halfWidth).
     */
    float ratioDivideHalfWidth;

    /**
     * Screen (halfWidth / ratio).
     */
    float halfWidthDivideRatio;

    /**
     * When screen rect changed called.
     */
    void   (*SetSize)            (int width, int height);

    /**
     * Load and compile shader from shaderSourceStr.
     * shaderType: GL_VERTEX_SHADER or GL_FRAGMENT_SHADER
     *
     * if success return shader id else 0.
     */
    GLuint (*LoadShader)         (GLenum shaderType, const char* shaderSourceStr);

    /**
     * Load vertex and fragment shader, and create program object, link program object.
     */
    GLuint (*LoadProgram)        (const char* vertexSourceStr, const char* fragmentSourceStr);

    /**
     * Create a program object from shader file path.
     *
     * vertexShaderFilePath and fragmentShaderFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    GLuint (*LoadProgramFromFile)(const char* vertexShaderFilePath, const char* fragmentShaderFilePath);

    /**
     * Load texture from textureFilePath.
     * 
     * textureFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    void (*LoadTexture)          (const char* textureFilePath, Texture* outTexture);
};


extern struct AGLTool AGLTool[1];


//----------------------------------------------------------------------------------------------------------------------


/**
 * Convert screen pixel width to openGL width.
 * same as (screenWidth) * AGLTool->screenRatio / AGLTool->screenHalfWidth
 */
static inline float AGLTool_ToGLWidth(float screenWidth)
{
    return screenWidth * AGLTool->ratioDivideHalfWidth;
}


/**
 * Convert screen pixel height to openGL height.
 */
static inline float AGLTool_ToGLHeight(float screenHeight)
{
    return screenHeight / AGLTool->screenHalfHeight;
}


/**
 * Convert screen pixel x to openGL x.
 */
static inline float AGLTool_ToGLX(float screenX)
{
    return AGLTool_ToGLWidth(screenX) - AGLTool->screenRatio;
}


/**
 * Convert screen pixel y to openGL y.
 */
static inline float AGLTool_ToGLY(float screenY)
{
    return 1.0f - AGLTool_ToGLHeight(screenY);
}


/**
 * Convert openGL Width to screen pixel width.
 * same as (glWidth) * AGLTool->screenHalfWidth / AGLTool->screenRatio
 */
static inline float AGLTool_ToScreenWidth(float glWidth)
{
    return glWidth * AGLTool->halfWidthDivideRatio;
}


/**
 * Convert openGL Height to screen screen pixel.
 */
static inline float AGLTool_ToScreenHeight(float glHeight)
{
    return glHeight * AGLTool->screenHalfHeight;
}


/**
 * Convert openGL x to screen pixel x.
 */
static inline float AGLTool_ToScreenX(float glX)
{
    return AGLTool_ToScreenWidth(glX + AGLTool->screenRatio);
}


/**
 * Convert openGL y to screen pixel y.
 */
static inline float AGLTool_ToScreenY(float glY)
{
    return AGLTool_ToScreenHeight(1.0f - glY);
}


/**
 * Convert width to uv width.
 * parameters both openGL or pixel coordinate.
 */
static inline float AGLTool_ToUVWidth(float width, float textureWidth)
{
    return width / textureWidth;
}


/**
 * Convert height to uv height.
 * parameters both openGL or pixel coordinate.
 */
static inline float AGLTool_ToUVHeight(float height, float textureHeight)
{
    return height / textureHeight;
}


#endif

```

`Engine/Graphics/OpenGL/Mesh.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-8-5
 * Update   : 2019-1-23
 * Author   : scott.cgi
 */


#include <string.h>
#include "Engine/Graphics/OpenGL/Mesh.h"
#include "Engine/Graphics/OpenGL/SubMesh.h"
#include "Engine/Graphics/OpenGL/Shader/ShaderMesh.h"
#include "Engine/Toolkit/HeaderUtils/Struct.h"
#include "Engine/Graphics/Graphics.h"


static void ReorderAllChildren(Mesh* mesh)
{
    ArrayList* children        = mesh->childList;
    // SubMesh keep original indexDataOffset
    int        indexDataOffset = 0;

    for (int i = 0; i < children->size; ++i)
    {
        SubMesh* subMesh = AArrayList_Get(children, i, SubMesh*);

        while (subMesh->index != i)
        {
            subMesh = AArrayList_Get(children, subMesh->index, SubMesh*);
        }

        memcpy
        (
            (char*)  mesh->indexArr->data + indexDataOffset,
            subMesh->indexArr->data,
            (size_t) subMesh->indexDataSize
        );

        indexDataOffset += subMesh->indexDataSize;
    }

    if (AGraphics->isUseVBO)
    {
        // update all index data
        VBOSubData* subData = AArrayList_GetPtrAdd(mesh->vboSubDataList, VBOSubData);
        subData->target     = GL_ELEMENT_ARRAY_BUFFER;
        subData->offset     = 0;
        subData->size       = mesh->indexDataSize;
        subData->data       = mesh->indexArr->data;
    }
}


static void Draw(Drawable* meshDrawable)
{
    Mesh* mesh             = AStruct_GetParentWithName  (meshDrawable, Mesh, drawable);
    bool  isChangedOpacity = ADrawable_CheckState(meshDrawable, DrawableState_OpacityChanged);
    bool  isChangedRGB     = ADrawable_CheckState(meshDrawable, DrawableState_RGBChanged);

    for (int i = 0; i < mesh->childList->size; ++i)
    {
        SubMesh* subMesh = AArrayList_Get(mesh->childList, i, SubMesh*);

        bool isDrawnBefore = ADrawable_CheckState(subMesh->drawable, DrawableState_DrawChanged);
        ADrawable->Draw(subMesh->drawable);
        bool isDrawnAfter  = ADrawable_CheckState(subMesh->drawable, DrawableState_DrawChanged);

        if (isDrawnAfter)
        {
            if (ADrawable_CheckState(subMesh->drawable, DrawableState_TransformChanged))
            {
                float* bornData     = subMesh->positionArr->data;
                float* positionData = (float*) ((char*) mesh->vertexArr->data + subMesh->positionDataOffset);

                // the born position data transformed (translate, scale, rotate) by SubMesh modelMatrix
                for (int j = 0; j < subMesh->positionArr->length; j += Mesh_VertexPositionNum)
                {
                    AMatrix->MultiplyMV3
                    (
                        subMesh->drawable->modelMatrix,
                        bornData[j],
                        bornData[j + 1],
                        bornData[j + 2],
                        (Vector3*) (positionData + j)
                    );
                }

                if (AGraphics->isUseVBO)
                {
                    VBOSubData* subData = AArrayList_GetPtrAdd(mesh->vboSubDataList, VBOSubData);
                    subData->target     = GL_ARRAY_BUFFER;
                    subData->offset     = subMesh->positionDataOffset;
                    subData->size       = subMesh->positionDataSize;
                    subData->data       = positionData;
                }
            }

//----------------------------------------------------------------------------------------------------------------------

            if (ADrawable_CheckState(subMesh->drawable, DrawableState_OpacityChanged) || isChangedOpacity)
            {
                float  opacity     = subMesh->drawable->blendColor->a * meshDrawable->blendColor->a;
                float* opacityData = (float*) (
                                                  (char*) mesh->vertexArr->data +
                                                  mesh->opacityDataOffset       +
                                                  subMesh->opacityDataOffset
                                              );

                for (int j = 0; j < subMesh->vertexCount; ++j)
                {
                    opacityData[j] = opacity;
                }

                if (AGraphics->isUseVBO)
                {
                    VBOSubData* subData = AArrayList_GetPtrAdd(mesh->vboSubDataList, VBOSubData);
                    subData->target     = GL_ARRAY_BUFFER;
                    subData->offset     = mesh->opacityDataOffset + subMesh->opacityDataOffset;
                    subData->size       = subMesh->vertexDataSize;
                    subData->data       = opacityData;
                }
            }

//----------------------------------------------------------------------------------------------------------------------

            if (ADrawable_CheckState(subMesh->drawable, DrawableState_RGBChanged) || isChangedRGB)
            {
                float  r       = subMesh->drawable->blendColor->r * meshDrawable->blendColor->r;
                float  g       = subMesh->drawable->blendColor->g * meshDrawable->blendColor->g;
                float  b       = subMesh->drawable->blendColor->b * meshDrawable->blendColor->b;
                float* rgbData = (float*) (
                                              (char*) mesh->vertexArr->data +
                                              mesh->rgbDataOffset           +
                                              subMesh->rgbDataOffset
                                          );

                for (int j = 0; j < subMesh->vertexCount; ++j)
                {
                    int index          = j * Mesh_VertexRGBNum;
                    rgbData[index]     = r;
                    rgbData[index + 1] = g;
                    rgbData[index + 2] = b;
                }

                if (AGraphics->isUseVBO)
                {
                    VBOSubData* subData = AArrayList_GetPtrAdd(mesh->vboSubDataList, VBOSubData);
                    subData->target     = GL_ARRAY_BUFFER;
                    subData->offset     = mesh->rgbDataOffset  + subMesh->rgbDataOffset;
                    subData->size       = subMesh->positionDataSize; // equals rgbDataSize
                    subData->data       = rgbData;
                }
            }
        }

//----------------------------------------------------------------------------------------------------------------------

        // test visible changed
        if (isDrawnBefore != isDrawnAfter)
        {
            float* opacityData = (float*) (
                                              (char*) mesh->vertexArr->data +
                                              mesh->opacityDataOffset       +
                                              subMesh->opacityDataOffset
                                          );

            if (ADrawable_CheckState(subMesh->drawable, DrawableState_DrawChanged))
            {
                float opacity = subMesh->drawable->blendColor->a * meshDrawable->blendColor->a;
                for (int j = 0; j < subMesh->vertexCount; ++j)
                {
                    opacityData[j] = opacity;
                }
            }
            else
            {
                memset(opacityData, 0, (size_t) subMesh->vertexDataSize);
            }

            if (AGraphics->isUseVBO)
            {
                VBOSubData* subData = AArrayList_GetPtrAdd(mesh->vboSubDataList, VBOSubData);
                subData->target     = GL_ARRAY_BUFFER;
                subData->offset     = mesh->opacityDataOffset + subMesh->opacityDataOffset;
                subData->size       = subMesh->vertexDataSize; // equals opacityDataSize
                subData->data       = opacityData;
            }
        }
    }
}


static inline void BindVBO(Mesh* mesh)
{
    // load the position
    glVertexAttribPointer
    (
        (GLuint) AShaderMesh->attribPosition,
        Mesh_VertexPositionNum,
        GL_FLOAT,
        false,
        Mesh_VertexPositionStride,
        0
    );

    // load the texture coordinate
    glVertexAttribPointer
    (
        (GLuint) AShaderMesh->attribTexcoord,
        Mesh_VertexUVNum,
        GL_FLOAT,
        false,
        Mesh_VertexUVStride,
        (GLvoid*) (intptr_t) mesh->uvDataOffset
    );

    // load the opacity
    glVertexAttribPointer
    (
        (GLuint) AShaderMesh->attribOpacity,
        Mesh_VertexOpacityNum,
        GL_FLOAT,
        false,
        Mesh_VertexOpacityStride,
        (GLvoid*) (intptr_t) mesh->opacityDataOffset
    );

    // load the rgb
    glVertexAttribPointer
    (
        (GLuint) AShaderMesh->attribRGB,
        Mesh_VertexRGBNum,
        GL_FLOAT,
        false,
        Mesh_VertexRGBStride,
        (GLvoid*) (intptr_t) mesh->rgbDataOffset
    );
}


static void Render(Drawable* drawable)
{
    Mesh* mesh = AStruct_GetParent(drawable, Mesh);

    if (mesh->childList->size == 0)
    {
        return;
    }

    SubMesh* fromChild;
    SubMesh* toChild;

    if (mesh->drawRangeQueue->elementList->size == 0)
    {
        fromChild = AArrayList_Get(mesh->childList, mesh->fromIndex, SubMesh*);
        toChild   = AArrayList_Get(mesh->childList, mesh->toIndex,   SubMesh*);
    }
    else
    {
        fromChild = AArrayList_Get
                    (
                        mesh->childList,
                        AArrayQueue_DequeueWithDefault(mesh->drawRangeQueue, int, mesh->fromIndex),
                        SubMesh*
                    );

        toChild   = AArrayList_Get
                    (
                        mesh->childList,
                        AArrayQueue_DequeueWithDefault(mesh->drawRangeQueue, int, mesh->toIndex),
                        SubMesh*
                    );
    }

    // all children SubMesh under Mesh matrix
    AShaderMesh->Use(drawable->mvpMatrix);

    glBindTexture(GL_TEXTURE_2D, mesh->texture->id);

    // update SubMesh data in vbo
    if (mesh->vboSubDataList->size > 0)
    {
        // load the vertex data
        glBindBuffer(GL_ARRAY_BUFFER,         mesh->vboIDs[Mesh_BufferVertex]);

        // load the vertex index
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh->vboIDs[Mesh_BufferIndex]);

        // without vao state update sub data
        if (AGraphics->isUseMapBuffer)
        {
            for (int i = 0; i < mesh->vboSubDataList->size; ++i)
            {
                VBOSubData* subData   = AArrayList_GetPtr(mesh->vboSubDataList, i, VBOSubData);
                void*       mappedPtr = glMapBufferRange
                                        (
                                            subData->target,
                                            subData->offset,
                                            subData->size,
                                            GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_RANGE_BIT
                                        );

                memcpy(mappedPtr, subData->data, (size_t) subData->size);
                glUnmapBuffer(subData->target);
            }
        }
        else
        {
            for (int i = 0; i < mesh->vboSubDataList->size; ++i)
            {
                VBOSubData* subData = AArrayList_GetPtr(mesh->vboSubDataList, i, VBOSubData);
                glBufferSubData(subData->target, subData->offset, subData->size, subData->data);
            }
        }

        AArrayList->Clear(mesh->vboSubDataList);

        if (AGraphics->isUseVAO)
        {
            // clear VBO bind
            glBindBuffer(GL_ARRAY_BUFFER,         0);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

            goto UseVAO;
        }

        goto UseVBO;
    }

    if (AGraphics->isUseVAO) // if isUseVAO then the isUseVBO must be true
    {
        UseVAO:

        glBindVertexArray(mesh->vaoID);

        glDrawElements
        (
            mesh->drawMode,
            toChild->indexOffset - fromChild->indexOffset + toChild->indexArr->length,
            GL_UNSIGNED_SHORT,
            (GLvoid*) (intptr_t) fromChild->indexDataOffset // (intptr_t) for fix xcode warning
        );

        // clear VAO bind
        glBindVertexArray(0);
    }
    else if (AGraphics->isUseVBO)
    {
        // load the vertex data
        glBindBuffer(GL_ARRAY_BUFFER,         mesh->vboIDs[Mesh_BufferVertex]);
        // load the vertex index
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh->vboIDs[Mesh_BufferIndex]);

        UseVBO:

        BindVBO(mesh);

        glDrawElements
        (
            mesh->drawMode,
            toChild->indexOffset - fromChild->indexOffset + toChild->indexArr->length,
            GL_UNSIGNED_SHORT,
            (GLvoid*) (intptr_t) fromChild->indexDataOffset // (intptr_t) for fix xcode warning
        );

        // clearAddChildWithData VBO bind
        glBindBuffer(GL_ARRAY_BUFFER,         0);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
    }
    else
    {
        // load the position
        glVertexAttribPointer
        (
            (GLuint) AShaderMesh->attribPosition,
            Mesh_VertexPositionNum,
            GL_FLOAT,
            false,
            Mesh_VertexPositionStride,
            mesh->vertexArr->data
        );

        // load the texture coordinate
        glVertexAttribPointer
        (
            (GLuint) AShaderMesh->attribTexcoord,
            Mesh_VertexUVNum,
            GL_FLOAT,
            false,
            Mesh_VertexUVStride,
            (char*) mesh->vertexArr->data + mesh->uvDataOffset
        );

        // load the opacity
        glVertexAttribPointer
        (
            (GLuint) AShaderMesh->attribOpacity,
            Mesh_VertexOpacityNum,
            GL_FLOAT,
            false,
            Mesh_VertexOpacityStride,
            (char*) mesh->vertexArr->data + mesh->opacityDataOffset
        );

        // load the rgb
        glVertexAttribPointer
        (
            (GLuint) AShaderMesh->attribRGB,
            Mesh_VertexRGBNum,
            GL_FLOAT,
            false,
            Mesh_VertexRGBStride,
            (char*) mesh->vertexArr->data + mesh->rgbDataOffset
        );

        glDrawElements
        (
            mesh->drawMode,
            toChild->indexOffset - fromChild->indexOffset + toChild->indexArr->length,
            GL_UNSIGNED_SHORT,
            (char*) mesh->indexArr->data + fromChild->indexDataOffset
        );
    }
}


static inline void ResetData(Mesh* mesh)
{
    mesh->vertexCount        = 0;
    mesh->vertexDataSize     = 0;
    mesh->indexDataSize      = 0;
    mesh->uvDataOffset       = 0;
    mesh->rgbDataOffset      = 0;
    mesh->opacityDataOffset  = 0;
    mesh->positionDataLength = 0;
    mesh->uvDataLength       = 0;
    mesh->rgbDataLength      = 0;
    mesh->opacityDataLength  = 0;
    mesh->indexDataLength    = 0;
}


static void Init(Texture* texture, Mesh* outMesh)
{
    Quad quad[1];
    AQuad->Init(texture->width, texture->height, quad);

    Drawable* drawable                 = outMesh->drawable;
    ADrawable->Init(drawable);

    // override
    drawable->Draw                     = Draw;
    drawable->Render                   = Render;

    ADrawable_AddState(drawable, DrawableState_IsUpdateMVPMatrix);


    outMesh->drawMode                  = GL_TRIANGLES;
    outMesh->texture                   = texture;
    outMesh->vboIDs[Mesh_BufferIndex]  = 0;
    outMesh->vboIDs[Mesh_BufferVertex] = 0;

    outMesh->vaoID                     = 0;
    outMesh->vertexArr                 = NULL;
    outMesh->indexArr                  = NULL;

    ResetData(outMesh);

    AArrayQueue->Init(sizeof(int),        outMesh->drawRangeQueue);
    AArrayList ->Init(sizeof(SubMesh*),   outMesh->childList);
    AArrayList ->Init(sizeof(VBOSubData), outMesh->vboSubDataList);
    outMesh->vboSubDataList->increase   = outMesh->childList->increase * 4;
}

static inline void InitBuffer(Mesh* mesh)
{
    mesh->vertexArr         = AArray->Create
                              (
                                  sizeof(float),
                                  mesh->positionDataLength +
                                  mesh->uvDataLength       +
                                  mesh->opacityDataLength  +
                                  mesh->rgbDataLength
                              );
    mesh->indexArr          = AArray->Create(sizeof(short), mesh->indexDataLength);

    mesh->vertexDataSize    = mesh->vertexArr->length       * sizeof(float);
    mesh->indexDataSize     = mesh->indexArr->length        * sizeof(short);
    mesh->uvDataOffset      = mesh->positionDataLength      * sizeof(float);
    mesh->opacityDataOffset = mesh->uvDataOffset            + mesh->uvDataLength      * sizeof(float);
    mesh->rgbDataOffset     = mesh->opacityDataOffset       + mesh->opacityDataLength * sizeof(float);
    char* uvData            = (char*) mesh->vertexArr->data + mesh->uvDataOffset;

    for (int i = 0; i < mesh->childList->size; ++i)
    {
        SubMesh* subMesh = AArrayList_Get(mesh->childList, i, SubMesh*);

        memcpy
        (
            (char*)  mesh->indexArr->data + subMesh->indexDataOffset,
            subMesh->indexArr->data,
            (size_t) subMesh->indexDataSize
        );
        
        memcpy
        (
          (char*)  mesh->vertexArr->data  + subMesh->positionDataOffset,
          subMesh->positionArr->data,
          (size_t) subMesh->positionDataSize
        );

        memcpy(uvData + subMesh->uvDataOffset, subMesh->uvArr->data, (size_t) subMesh->uvDataSize);

        // make drawable rgb and opacity update to buffer
        ADrawable_AddState(subMesh->drawable, DrawableState_Draw);
    }

    mesh->fromIndex = 0;
    mesh->toIndex   = mesh->childList->size - 1;
}


static void InitWithCapacity(Texture* texture, int capacity, Mesh* outMesh)
{
    Init(texture, outMesh);
    AArrayList->SetCapacity(outMesh->childList, capacity);
}


static Mesh* Create(Texture* texture)
{
    Mesh* mesh = malloc(sizeof(Mesh));
    Init(texture, mesh);

    return mesh;
}


static inline SubMesh* AddChild(Mesh* mesh, SubMesh* subMesh)
{
    for (int i = 0; i < subMesh->indexArr->length; ++i)
    {
        // each child index add before children vertex count
        AArray_Get(subMesh->indexArr, i, short) += mesh->vertexCount;
    }

    subMesh->index              = mesh->childList->size;
    subMesh->positionDataOffset = mesh->positionDataLength * sizeof(float);
    subMesh->uvDataOffset       = mesh->uvDataLength       * sizeof(float);
    subMesh->opacityDataOffset  = mesh->opacityDataLength  * sizeof(float);
    subMesh->rgbDataOffset      = mesh->rgbDataLength      * sizeof(float);
    subMesh->indexDataOffset    = mesh->indexDataLength    * sizeof(short);
    subMesh->indexOffset        = mesh->indexDataLength;

    mesh->vertexCount          += subMesh->vertexCount;
    mesh->positionDataLength   += subMesh->positionArr->length;
    mesh->uvDataLength         += subMesh->uvArr->length;
    mesh->opacityDataLength    += subMesh->vertexCount;
    mesh->rgbDataLength        += subMesh->positionArr->length;
    mesh->indexDataLength      += subMesh->indexArr->length;

    AArrayList_Add(mesh->childList, subMesh);

    return subMesh;
}


static SubMesh* AddChildWithData(Mesh* mesh, Array(float)* positionArr, Array(float)* uvArr, Array(short)* indexArr)
{
    return AddChild(mesh, ASubMesh->CreateWithData(mesh, positionArr, uvArr, indexArr));
}


static SubMesh* AddChildWithQuad(Mesh* mesh, Quad* quad)
{
    return AddChild(mesh, ASubMesh->CreateWithQuad(mesh, quad));
}


static inline void ReleaseBuffer(Mesh* mesh)
{
    free(mesh->vertexArr);
    free(mesh->indexArr);

    mesh->vertexArr = NULL;
    mesh->indexArr  = NULL;

    if (AGraphics->isUseVBO)
    {
        glDeleteBuffers(Mesh_BufferNum, mesh->vboIDs);
        mesh->vboIDs[Mesh_BufferIndex]  = 0;
        mesh->vboIDs[Mesh_BufferVertex] = 0;

        if (AGraphics->isUseVAO)
        {
            glDeleteVertexArrays(1, &mesh->vaoID);
            mesh->vaoID = 0;
        }
    }
}


static void GenerateBuffer(Mesh* mesh)
{
    free(mesh->vertexArr);
    free(mesh->indexArr);

    InitBuffer(mesh);

    if (AGraphics->isUseVBO)
    {
        if (mesh->vboIDs[Mesh_BufferVertex] == 0)
        {
            glGenBuffers(Mesh_BufferNum, mesh->vboIDs);
        }

        // vertex
        glBindBuffer(GL_ARRAY_BUFFER, mesh->vboIDs[Mesh_BufferVertex]);
        glBufferData
        (
            GL_ARRAY_BUFFER,
            mesh->vertexDataSize,
            mesh->vertexArr->data,
            GL_DYNAMIC_DRAW
        );

        // index
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh->vboIDs[Mesh_BufferIndex]);
        glBufferData
        (
            GL_ELEMENT_ARRAY_BUFFER,
            mesh->indexDataSize,
            mesh->indexArr->data,
            GL_STATIC_DRAW
        );

        // vertexArr and indexArr data pointer changed
        // so we clear all sub data update
        AArrayList->Clear(mesh->vboSubDataList);

        if (AGraphics->isUseVAO)
        {
            if (mesh->vaoID == 0)
            {
                glGenVertexArrays(1, &mesh->vaoID);
            }

            glBindVertexArray(mesh->vaoID);

            // with vao has own state

            // load the vertex data
            glBindBuffer(GL_ARRAY_BUFFER,         mesh->vboIDs[Mesh_BufferVertex]);
            // load the vertex index
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh->vboIDs[Mesh_BufferIndex]);

            glEnableVertexAttribArray((GLuint) AShaderMesh->attribPosition);
            glEnableVertexAttribArray((GLuint) AShaderMesh->attribTexcoord);
            glEnableVertexAttribArray((GLuint) AShaderMesh->attribOpacity);
            glEnableVertexAttribArray((GLuint) AShaderMesh->attribRGB);

            BindVBO(mesh);

            // go back to normal state
            glBindVertexArray(0);
        }
    }
}


static void Release(Mesh* mesh)
{
    ReleaseBuffer(mesh);

    for (int i = 0; i < mesh->childList->size; ++i)
    {
        free(AArrayList_Get(mesh->childList, i, SubMesh*));
    }

    AArrayList ->Release(mesh->childList);
    AArrayList ->Release(mesh->vboSubDataList);
    AArrayQueue->Release(mesh->drawRangeQueue);
}


static void Clear(Mesh* mesh)
{
    for (int i = 0; i < mesh->childList->size; ++i)
    {
        free(AArrayList_Get(mesh->childList, i, SubMesh*));
    }

    AArrayList ->Clear(mesh->childList);
    AArrayList ->Clear(mesh->vboSubDataList);
    AArrayQueue->Clear(mesh->drawRangeQueue);

    ResetData(mesh);
}


static Mesh* CreateWithFile(const char* resourceFilePath)
{
    return Create(ATexture->Get(resourceFilePath));
}


static void InitWithFile(const char* resourceFilePath, Mesh* outMesh)
{
    Init(ATexture->Get(resourceFilePath), outMesh);
}


static void InitWithFileAndCapacity(const char* resourceFilePath, int capacity, Mesh* outMesh)
{
    InitWithCapacity(ATexture->Get(resourceFilePath), capacity, outMesh);
}


struct AMesh AMesh[1] =
{{
    Create,
    Init,
    InitWithCapacity,

    CreateWithFile,
    InitWithFile,
    InitWithFileAndCapacity,

    Release,
    Clear,

    AddChildWithData,
    AddChildWithQuad,
    ReorderAllChildren,
    GenerateBuffer,
    Render,
}};

```

`Engine/Graphics/OpenGL/Mesh.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-8-5
 * Update   : 2019-1-22
 * Author   : scott.cgi
 */


#ifndef MESH_H
#define MESH_H


#include "Engine/Toolkit/Utils/ArrayList.h"
#include "Engine/Graphics/Draw/Drawable.h"
#include "Engine/Graphics/Draw/Quad.h"
#include "Engine/Graphics/OpenGL/Texture.h"
#include "Engine/Toolkit/Utils/Array.h"
#include "Engine/Toolkit/Utils/ArrayQueue.h"
#include "Engine/Graphics/OpenGL/MeshDefine.h"


/**
 * The data update to VBO buffer by glBufferSubData or glMapBufferRange.
 */
typedef struct
{
    /**
     * GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.
     */
    GLenum     target;

    /**
     * The byte offset in VBO data.
     */
    GLintptr   offset;

    /**
     * The bytes size of update data.
     */
    GLsizeiptr size;

    /**
     * The update data ptr.
     */
    GLvoid*    data;
}
VBOSubData;


/**
 * Render with texture by vertices, and the vertices info come from children SubMesh.
 * implement Drawable's render for render self.
 */
struct Mesh
{
    /**
     * The base class for provide draw functions.
     */
    Drawable             drawable[1];

    /**
     * Render texture.
     */
    Texture*             texture;

    /**
     * The mode of glDrawElements, default GL_TRIANGLES.
     */
    GLenum               drawMode;

    /**
     * The index draw from , default first in children.
     */
    int                  fromIndex;

    /**
     * The index draw to, default last in children.
     */
    int                  toIndex;

    /**
     * Every frame pop pair of [from, to] index in childList to draw.
     * if no range will default draw fromIndex to toIndex.
     * if from equals to then means only draw child at to index.
     */
    ArrayQueue(int)      drawRangeQueue[1];

    /**
     * Mesh children provide vertices info to draw.
     *
     * cannot change children order directly, and use SubMesh index for sorting.
     */
    ArrayList(SubMesh*)  childList[1];

//----------------------------------------------------------------------------------------------------------------------

    /**
     * All vertices data from children SubMesh.
     * data model: [all position data | all uv data | all opacity data | all rgb data]
     */
    Array(float)*         vertexArr;

    /**
     * All vertices data from children SubMesh.
     */
    Array(short)*         indexArr;

    /**
     * If use VBO is the generated VBO ids else 0.
     */
    GLuint                vboIDs[Mesh_BufferNum];

    /**
     * If use VAO is the generated vao id else 0.
     */
    GLuint                vaoID;

    /**
     * If use VBO use VBOSubData to update VBO buffer.
     * VBOSubData in ArrayList malloc data.
     */
    ArrayList(VBOSubData) vboSubDataList[1];

//----------------------------------------------------------------------------------------------------------------------

    /**
     * All vertices count.
     */
    int                   vertexCount;

    /**
     * The vertex bytes data size.
     */
    int                   vertexDataSize;

    /**
     * The index bytes data size.
     */
    int                   indexDataSize;

    /**
     * The uv bytes data offset in vertexArr.
     */
    int                   uvDataOffset;

    /**
     * The rgb bytes data offset in vertexArr.
     */
    int                   rgbDataOffset;

    /**
     * The opacity bytes data offset in vertexArr.
     */
    int                   opacityDataOffset;

    /**
     * The position data length in vertexArr..
     */
    int                   positionDataLength;

    /**
     * The UV data length in vertexArr.
     */
    int                   uvDataLength;

    /**
     * The RGB data length in vertexArr.
     */
    int                   rgbDataLength;

    /**
     * The opacity data length in vertexArr.
     */
    int                   opacityDataLength;

    /**
     * The index data length in indexArr.
     */
    int                   indexDataLength;
};


struct AMesh
{
    Mesh*     (*Create)            (Texture* texture);
    void      (*Init)              (Texture* texture, Mesh* outMesh);
    void      (*InitWithCapacity)  (Texture* texture, int capacity, Mesh* outMesh);

    /*
     Create or Init Mesh by resourceFilePath.

     resourceFilePath:
         Android: assets
         IOS    : NSBundle
     */

    Mesh*     (*CreateWithFile)         (const char* resourceFilePath);
    void      (*InitWithFile)           (const char* resourceFilePath, Mesh* outMesh);
    void      (*InitWithFileAndCapacity)(const char* resourceFilePath, int capacity, Mesh* outMesh);

    /**
     * Release all member memory and all children SubMesh memory.
     */
    void      (*Release)           (Mesh* mesh);

    /**
     * Clear children, drawRangeQueue, vboSubDataList, and ready to GenerateBuffer.
     */
    void      (*Clear)             (Mesh* mesh);

    /**
     * The positionArr, uvArr and indexArr will copy in SubMesh.
     * SubMesh set parent and index by parent Mesh, and will free by parent Mesh Release.
     *
     * important: before GenerateBuffer will not work correctly,
     *            and we can calling GenerateBuffer when all children have been added.
     */
    SubMesh*  (*AddChildWithData)  (Mesh* mesh, Array(float)* positionArr, Array(float)* uvArr, Array(short)* indexArr);

    /**
     * SubMesh data calculate by Quad.
     * SubMesh set parent and index by parent Mesh, and will free by parent Mesh Release.
     *
     * important: apply effect after calling GenerateBuffer,
     *            and we can calling GenerateBuffer when all children have been added.
     */
    SubMesh*  (*AddChildWithQuad)  (Mesh* mesh, Quad* quad);

    /**
     * Reorder all SubMesh draw order by index.
     */
    void      (*ReorderAllChildren)(Mesh* mesh);

    /**
     * Combine all children SubMesh data into buffer that will upload to GPU.
     * when Mesh init or SubMesh add, need to call this for generate buffer.
     * 
     * usually generate buffer before Mesh's SubMesh stable.
     */
    void      (*GenerateBuffer)    (Mesh* mesh);

    /**
     * The implementation of Drawable's render function for render Mesh.
     */
    void      (*Render)            (Drawable* drawable);
};


extern struct AMesh AMesh[1];


/**
 * Draw Mesh.
 */
static inline void AMesh_Draw(Mesh* mesh)
{
    ADrawable->Draw(mesh->drawable);
}


/**
 * Draw Mesh by fromIndex and toIndex.
 * if fromIndex equals toIndex then means only draw child at toIndex.
 */
static inline void AMesh_DrawByIndex(Mesh* mesh, int fromIndex, int toIndex)
{
    AArrayQueue_Enqueue(mesh->drawRangeQueue, fromIndex);
    AArrayQueue_Enqueue(mesh->drawRangeQueue, toIndex);
    ADrawable->Draw (mesh->drawable);
}


#endif

```

`Engine/Graphics/OpenGL/MeshDefine.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-8-7
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#ifndef MESH_DEFINE_H
#define MESH_DEFINE_H


#include "Engine/Graphics/OpenGL/Platform/gl3.h"


typedef struct Mesh    Mesh;
typedef struct SubMesh SubMesh;


enum
{
    /**
     * Number of buffers.
     */
    Mesh_BufferNum             = 2,

    /**
     * Index of buffer vertex.
     */
    Mesh_BufferVertex          = 0,

    /**
     * Index of buffer index.
     */
    Mesh_BufferIndex           = 1,

    /**
     * One vertex position has x, y, z.
     */
    Mesh_VertexPositionNum     = 3,

    /**
     * One vertex has u, v.
     */
    Mesh_VertexUVNum           = 2,

    /**
     * One vertex has one opacity.
     */
    Mesh_VertexOpacityNum      = 1,

    /**
     * One vertex has r, g, b.
     */
    Mesh_VertexRGBNum          = 3,

    /**
     * 3 (x ,y z) * 4 (sizeof float)
     */
    Mesh_VertexPositionStride  = Mesh_VertexPositionNum * sizeof(float),

    /**
     * 2 (u, v) * 4 (sizeof float)
     */
    Mesh_VertexUVStride        = Mesh_VertexUVNum       * sizeof(float),

    /**
     * 1 * 4 (sizeof float)
     */
    Mesh_VertexOpacityStride   = Mesh_VertexOpacityNum  * sizeof(float),

    /**
     * 3 (r, g, b) * 4 (sizeof float)
     */
    Mesh_VertexRGBStride       = Mesh_VertexRGBNum      * sizeof(float),
};


#endif

```

`Engine/Graphics/OpenGL/Platform/EGLTool.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-3-12
 * Update   : 2021-2-8
 * Author   : scott.cgi
 */


#include <stddef.h>
#include "Engine/Toolkit/Platform/Platform.h"


//------------------------
#ifdef IS_PLATFORM_ANDROID
//------------------------


#include "Engine/Graphics/OpenGL/Platform/EGLTool.h"
#include "Engine/Toolkit/Platform/Log.h"


static void CreateEGL
(
    EGLNativeWindowType window,
    EGLDisplay*         outDisplay,
    EGLContext*         outContext,
    EGLSurface*         outSurface,
    EGLConfig*          outConfig
)
{

    *outDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);

    if (*outDisplay == EGL_NO_DISPLAY)
    {
        ALog_A(false, "AEGLTool CreateEGL failed EGL unable to eglGetDisplay");
    }

    if (!eglInitialize(*outDisplay, NULL/*major*/, NULL/*minor*/))
    {
        ALog_A(false, "AEGLTool CreateEGL failed EGL unable to eglInitialize");
    }

    EGLint numConfigs;

    // here specify the attributes of the desired configuration.
    // below, we select an EGLConfig with at least 8 bits per color
    // component compatible with on-screen windows
    EGLint configAttribs[] =
    {
        EGL_DEPTH_SIZE,      16,
        EGL_RED_SIZE,        8,
        EGL_GREEN_SIZE,      8,
        EGL_BLUE_SIZE,       8,
        EGL_ALPHA_SIZE,      8,
        EGL_STENCIL_SIZE,    8,
        EGL_SURFACE_TYPE,    EGL_WINDOW_BIT,
        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
        EGL_NONE
    };

    // here, the application chooses the configuration it desires. In this
    // sample, we have a very simplified selection process, where we pick
    // the first EGLConfig that matches our criteria
    eglChooseConfig(*outDisplay, configAttribs, outConfig, 1, &numConfigs);

    if (numConfigs < 1)
    {
        ALog_A(false, "AEGLTool CreateEGL failed no config match eglChooseConfig");
    }

    EGLint surfaceAttrs[] =
    {
        EGL_RENDER_BUFFER,
        EGL_BACK_BUFFER,
        EGL_NONE
    };

    *outSurface = eglCreateWindowSurface(*outDisplay, *outConfig, window, surfaceAttrs);
    if (*outSurface == EGL_NO_SURFACE)
    {
        ALog_A(false, "AEGLTool CreateEGL failed EGL unable to eglCreateWindowSurface");
    }

    EGLint contextAttribs[] =
    {
        EGL_CONTEXT_CLIENT_VERSION, 2,
        EGL_NONE
    };

    *outContext = eglCreateContext(*outDisplay, *outConfig, EGL_NO_CONTEXT, contextAttribs);
    if (*outContext == EGL_NO_CONTEXT)
    {
        ALog_A(false, "AEGLTool CreateEGL failed EGL unable to eglCreateContext");
    }

    if (!eglMakeCurrent(*outDisplay, *outSurface, *outSurface, *outContext))
    {
        ALog_A(false, "AEGLTool CreateEGL failed EGL unable to eglMakeCurrent");
    }

// eglSwapInterval(*outDisplay, 0);
}


static void DestroyEGL(EGLDisplay* display, EGLContext* context, EGLSurface* surface)
{
    if (*display != EGL_NO_DISPLAY)
    {
        eglMakeCurrent(*display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);

        if (*context != EGL_NO_CONTEXT)
        {
            eglDestroyContext(*display, *context);
        }

        if (*surface != EGL_NO_SURFACE)
        {
            eglDestroySurface(*display, *surface);
        }

        eglTerminate(*display);
    }

    *display = EGL_NO_DISPLAY;
    *context = EGL_NO_CONTEXT;
    *surface = EGL_NO_SURFACE;
}


static void ResetSurface
(
    EGLNativeWindowType window,
    EGLDisplay          display,
    EGLContext          context,
    EGLConfig           config,
    EGLSurface*         surface
)
{
    if (*surface != EGL_NO_SURFACE)
    {
        eglDestroySurface(display, *surface);
    }

    EGLint surfaceAttrs[] =
    {
        EGL_RENDER_BUFFER,
        EGL_BACK_BUFFER,
        EGL_NONE
    };

    *surface = eglCreateWindowSurface(display, config, window, surfaceAttrs);

    if (eglMakeCurrent(display, *surface, *surface, context) == false)
    {
        ALog_A(false, "AEGLTool ResetSurface failed EGL unable to eglMakeCurrent");
    }
}


struct AEGLTool AEGLTool[1] =
{{
    CreateEGL,
    DestroyEGL,
    ResetSurface,
}};


//---------------------------
#endif // IS_PLATFORM_ANDROID
//---------------------------


```

`Engine/Graphics/OpenGL/Platform/EGLTool.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-3-12
 * Update   : 2019-2-23
 * Author   : scott.cgi
 */


#ifndef EGL_TOOL_H
#define EGL_TOOL_H


#include "Engine/Toolkit/Platform/Platform.h"


//------------------------
#ifdef IS_PLATFORM_ANDROID
//------------------------


#include <stdbool.h>
#include "Engine/Graphics/OpenGL/Platform/egl.h"


struct AEGLTool
{
    /**
     * Creates an EGL rendering context and all associated elements.
     */
    void (*CreateEGL)   (
                            EGLNativeWindowType window,
                            EGLDisplay*         outDisplay,
                            EGLContext*         outContext,
                            EGLSurface*         outSurface,
                            EGLConfig*          outConfig
                        );

    /**
     * Destroy EGL context and all associated elements.
     */
    void (*DestroyEGL)  (EGLDisplay* display, EGLContext* context, EGLSurface* surface);


    /**
     * When native window resized, we need reset surface,
     * the surface will destroyed and create new one and make current.
     */
    void (*ResetSurface)(
                            EGLNativeWindowType window,
                            EGLDisplay          display,
                            EGLContext          context,
                            EGLConfig           config,
                            EGLSurface*         surface
                        );
};


extern struct AEGLTool AEGLTool[1];


//---------------------------
#endif // IS_PLATFORM_ANDROID
//---------------------------


#endif

```

`Engine/Graphics/OpenGL/Platform/egl.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-3-12
 * Update   : 2019-2-23
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Platform.h"


#ifdef IS_PLATFORM_ANDROID
    #include <EGL/egl.h>
#elif defined(IS_PLATFORM_IOS)
    // coding by swift
#endif

```

`Engine/Graphics/OpenGL/Platform/gl3.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-3-12
 * Update   : 2019-2-23
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Platform.h"


#ifdef IS_PLATFORM_ANDROID
    #include <GLES3/gl3.h>
#elif defined(IS_PLATFORM_IOS)
    #include <OpenGLES/ES3/gl.h>
#endif

```

`Engine/Graphics/OpenGL/Shader/Shader.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-4-20
 * Update   : 2019-1-23
 * Author   : scott.cgi
 */

#include "Engine/Graphics/OpenGL/Shader/Shader.h"


struct AShader AShader[1] =
{{
    0,
}};

```

`Engine/Graphics/OpenGL/Shader/Shader.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-4-20
 * Update   : 2019-1-23
 * Author   : scott.cgi
 */


#ifndef SHADER_H
#define SHADER_H


#include "Engine/Graphics/OpenGL/Platform/gl3.h"


/**
 * Control shader.
 */
struct AShader
{
    /**
     * Record current using shader's program.
     */
    GLuint program;
};


extern struct AShader AShader[1];


#endif

```

`Engine/Graphics/OpenGL/Shader/ShaderMesh.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-8-13
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#include <stdbool.h>
#include "Engine/Toolkit/HeaderUtils/String.h"
#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Graphics/OpenGL/Shader/ShaderMesh.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Graphics/OpenGL/Shader/Shader.h"


static void Use(Matrix4* mvpMatrix)
{
    if (AShader->program != AShaderMesh->program)
    {
        AShader->program = AShaderMesh->program;
        glUseProgram(AShaderMesh->program);
    }

    glUniformMatrix4fv(AShaderMesh->uniformMVPMatrix, 1, false, mvpMatrix->m);

    // set the sampler to texture unit 0
    glUniform1i       (AShaderMesh->uniformSample2D, 0);
}


static void Init()
{
    AShaderMesh->program = AGLTool->LoadProgram
    (
        AString_Make
        (
            precision highp float;
            uniform   mat4  uMVPMatrix;
            attribute vec4  aPosition;
            attribute vec2  aTexcoord;
            attribute float aOpacity;
            attribute vec3  aRGB;

            varying   vec2  vTexcoord;
            varying   vec4  vColor;

            void main()
            {
                gl_Position = uMVPMatrix * aPosition;
                vTexcoord   = aTexcoord;
                vColor      = vec4(aRGB, aOpacity);
            }
        ),

        AString_Make
        (
            precision lowp      float;
            uniform   sampler2D uSampler2D;
            varying   vec2      vTexcoord;
            varying   vec4      vColor;

            void main()
            {
                gl_FragColor = texture2D(uSampler2D, vTexcoord) * vColor;
            }
        )
    );

    // Get the attribute locations
    AShaderMesh->attribPosition   = glGetAttribLocation(AShaderMesh->program, "aPosition");
    AShaderMesh->attribTexcoord   = glGetAttribLocation(AShaderMesh->program, "aTexcoord");
    AShaderMesh->attribOpacity    = glGetAttribLocation(AShaderMesh->program, "aOpacity");
    AShaderMesh->attribRGB        = glGetAttribLocation(AShaderMesh->program, "aRGB");

    AShaderMesh->uniformSample2D  = glGetUniformLocation(AShaderMesh->program, "uSampler2D");
    AShaderMesh->uniformMVPMatrix = glGetUniformLocation(AShaderMesh->program, "uMVPMatrix");

    ALog_A
    (
        AShaderMesh->uniformSample2D != -1,
        "AShaderMesh could not glGetUniformLocation for uniformSample2D"
    );

    ALog_A
    (
        AShaderMesh->uniformMVPMatrix != -1,
        "AShaderMesh could not glGetUniformLocation for uniformMVPMatrix"
    );

    glEnableVertexAttribArray((GLuint) AShaderMesh->attribPosition);
    glEnableVertexAttribArray((GLuint) AShaderMesh->attribTexcoord);
    glEnableVertexAttribArray((GLuint) AShaderMesh->attribOpacity);
    glEnableVertexAttribArray((GLuint) AShaderMesh->attribRGB);
}


struct AShaderMesh AShaderMesh[1] =
{{
    .Use  = Use,
    .Init = Init,
}};

```

`Engine/Graphics/OpenGL/Shader/ShaderMesh.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-8-13
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#ifndef SHADER_MESH_H
#define SHADER_MESH_H


#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Toolkit/Math/Matrix.h"
#include "Engine/Toolkit/Math/Math.h"


/**
 * Shader control for Mesh.
 */
struct AShaderMesh
{
    GLuint program;
    GLint  attribPosition;
    GLint  attribTexcoord;
    GLint  attribOpacity;
    GLint  attribRGB;

    GLint  uniformMVPMatrix;
    GLint  uniformSample2D;

    void (*Use) (Matrix4* mvpMatrix);
    void (*Init)(void);
};


extern struct AShaderMesh AShaderMesh[1];


#endif

```

`Engine/Graphics/OpenGL/Shader/ShaderPrimitive.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-2-26
 * Update   : 2019-1-24
 * Author   : scott.cgi
 *
 */


#include <stdbool.h>
#include "Engine/Toolkit/HeaderUtils/String.h"
#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Graphics/OpenGL/Shader/ShaderPrimitive.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Graphics/OpenGL/Shader/Shader.h"


static void Use(Matrix4* mvpMatrix, Color* color, GLfloat pointSize)
{
    if (AShader->program != AShaderPrimitive->program)
    {
        AShader->program = AShaderPrimitive->program;

        glUseProgram             (AShaderPrimitive->program);
        glEnableVertexAttribArray((GLuint) AShaderPrimitive->attribPosition);
    }

    // passed matrix into shader program
    glUniformMatrix4fv(AShaderPrimitive->uniformMVPMatrix, 1,        false,    mvpMatrix->m);
    glUniform4f       (AShaderPrimitive->uniformColor,     color->r, color->g, color->b, color->a);
    glUniform1f       (AShaderPrimitive->uniformPointSize, pointSize);
}


static void Init()
{
    AShaderPrimitive->program = AGLTool->LoadProgram
    (
        AString_Make
        (
            precision highp float;
            uniform   mat4  uMVPMatrix;
            attribute vec2  aPosition;
            uniform   float uPointSize;

            void main()
            {
                gl_Position  = uMVPMatrix * vec4(aPosition, 0.0, 1.0);
                gl_PointSize = uPointSize;
            }
        ),

        AString_Make
        (
            precision highp float;
            uniform   vec4  uColor;

            void main()
            {
                gl_FragColor = uColor;
            }
        )
    );

    // get the attribute locations
    AShaderPrimitive->attribPosition   = glGetAttribLocation (AShaderPrimitive->program, "aPosition");
    AShaderPrimitive->uniformMVPMatrix = glGetUniformLocation(AShaderPrimitive->program, "uMVPMatrix");
    AShaderPrimitive->uniformColor     = glGetUniformLocation(AShaderPrimitive->program, "uColor");
    AShaderPrimitive->uniformPointSize = glGetUniformLocation(AShaderPrimitive->program, "uPointSize");

    ALog_A
    (
        AShaderPrimitive->uniformMVPMatrix != -1,
        "AShaderPrimitive could not glGetUniformLocation for uniformMVPMatrix"
    );

    ALog_A
    (
        AShaderPrimitive->uniformColor != -1,
        "AShaderPrimitive could not glGetUniformLocation for uniformColor"
    );

    ALog_A
    (
        AShaderPrimitive->uniformPointSize != -1,
        "AShaderPrimitive could not glGetUniformLocation for uniformPointSize"
    );
}


struct AShaderPrimitive AShaderPrimitive[1] =
{{
    .Use  = Use,
    .Init = Init,
}};


```

`Engine/Graphics/OpenGL/Shader/ShaderPrimitive.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-2-26
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#ifndef SHADER_PRIMITIVE_H
#define SHADER_PRIMITIVE_H


#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Toolkit/Math/Matrix.h"
#include "Engine/Toolkit/Math/Math.h"
#include "Engine/Graphics/Draw/Color.h"


/**
 * Shader control for GLPrimitive.
 */
struct AShaderPrimitive
{
    GLuint program;
    GLint  attribPosition;
    GLint  uniformMVPMatrix;
    GLint  uniformColor;
    GLint  uniformPointSize;

    void (*Use) (Matrix4* mvpMatrix, Color* color, GLfloat pointSize);
    void (*Init)(void);
};


extern struct AShaderPrimitive AShaderPrimitive[1];


#endif

```

`Engine/Graphics/OpenGL/Shader/ShaderSprite.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-8
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#include <stdbool.h>
#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Graphics/OpenGL/Shader/ShaderSprite.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Graphics/OpenGL/Shader/Shader.h"
#include "Engine/Toolkit/HeaderUtils/String.h"


static void Use(Matrix4* mvpMatrix, Color* color)
{
    if (AShader->program != AShaderSprite->program)
    {
        AShader->program = AShaderSprite->program;
        glUseProgram(AShaderSprite->program);
    }

    glUniformMatrix4fv(AShaderSprite->uniformMVPMatrix, 1,        false,    mvpMatrix->m);
    glUniform4f       (AShaderSprite->uniformColor,     color->r, color->g, color->b, color->a);
    // set the sampler to texture unit 0
    glUniform1i       (AShaderSprite->uniformSampler2D, 0);
}


static void Init()
{
    AShaderSprite->program = AGLTool->LoadProgram
    (
        AString_Make
        (
            precision highp float;
            uniform   mat4  uMVPMatrix;
            attribute vec4  aPositionTexcoord;
            varying   vec2  vTexcoord;

            void main()
            {
                gl_Position = uMVPMatrix * vec4(aPositionTexcoord.xy, 0.0, 1.0);
                vTexcoord   = aPositionTexcoord.zw;
            }
        ),

        AString_Make
        (
            precision lowp float;
            uniform   sampler2D uSampler2D;
            uniform   vec4      uColor;
            varying   vec2      vTexcoord;

            void main()
            {
                gl_FragColor = texture2D(uSampler2D, vTexcoord) * uColor;
            }
        )
    );

    // get the attribute locations
    AShaderSprite->attribPositionTexcoord = glGetAttribLocation(AShaderSprite->program,  "aPositionTexcoord");
    AShaderSprite->uniformSampler2D       = glGetUniformLocation(AShaderSprite->program, "uSampler2D");
    AShaderSprite->uniformMVPMatrix       = glGetUniformLocation(AShaderSprite->program, "uMVPMatrix");
    AShaderSprite->uniformColor           = glGetUniformLocation(AShaderSprite->program, "uColor");

    ALog_A
    (
        AShaderSprite->uniformSampler2D != -1,
        "AShaderSprite cannot glGetUniformLocation for uniformSampler2D"
    );

    ALog_A
    (
        AShaderSprite->uniformMVPMatrix != -1,
        "AShaderSprite cannot glGetUniformLocation for uniformMVPMatrix"
    );

    ALog_A
    (
        AShaderSprite->uniformColor != -1,
        "AShaderSprite cannot glGetUniformLocation for uniformColor"
    );

    glEnableVertexAttribArray((GLuint) AShaderSprite->attribPositionTexcoord);
}


struct AShaderSprite AShaderSprite[1] =
{{
    .Use  = Use,
    .Init = Init,
}};

```

`Engine/Graphics/OpenGL/Shader/ShaderSprite.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-4-23
 * Update   : 2019-1-24
 * Author   : scott.cgi
 */


#ifndef SHADER_SPRITE_H
#define SHADER_SPRITE_H


#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Toolkit/Math/Matrix.h"
#include "Engine/Toolkit/Math/Math.h"
#include "Engine/Graphics/Draw/Color.h"


/**
 * Shader control for Sprite.
 */
struct AShaderSprite
{
    GLuint program;
    GLint  attribPositionTexcoord;
    GLint  uniformSampler2D;
    GLint  uniformMVPMatrix;
    GLint  uniformColor;

    void (*Use) (Matrix4* mvpMatrix, Color* color);
    void (*Init)(void);
};


extern struct AShaderSprite AShaderSprite[1];


#endif

```

`Engine/Graphics/OpenGL/Sprite.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-4-20
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#include <stdlib.h>
#include <memory.h>

#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/Sprite.h"
#include "Engine/Toolkit/HeaderUtils/Struct.h"
#include "Engine/Graphics/OpenGL/Shader/ShaderSprite.h"
#include "Engine/Graphics/Graphics.h"
#include "Engine/Graphics/OpenGL/GLTool.h"


static void Render(Drawable* drawable)
{
    Sprite* sprite = AStruct_GetParent(drawable, Sprite);

    AShaderSprite->Use(drawable->mvpMatrix, sprite->drawable->blendColor);

    glBindTexture(GL_TEXTURE_2D, sprite->texture->id);

    if (sprite->isDeformed)
    {
        sprite->isDeformed = false;
        
        if (AGraphics->isUseVBO)
        {
            // load the vertex data
            glBindBuffer(GL_ARRAY_BUFFER, sprite->vboIDs[Sprite_BufferVertex]);

            // without vao state update sub data
            if (AGraphics->isUseMapBuffer)
            {
                void* mappedPtr = glMapBufferRange
                                  (
                                      GL_ARRAY_BUFFER,
                                      0,
                                      sprite->vertexDataSize,
                                      GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_RANGE_BIT
                                  );

                memcpy(mappedPtr, sprite->vertexArr->data, (size_t) sprite->vertexDataSize);
                glUnmapBuffer(GL_ARRAY_BUFFER);
            }
            else
            {
                glBufferSubData(GL_ARRAY_BUFFER, 0, sprite->vertexDataSize , sprite->vertexArr->data);
            }

            if (AGraphics->isUseVAO)
            {
                // clear VBO bind
                glBindBuffer(GL_ARRAY_BUFFER, 0);
                goto UseVAO;
            }
            
            goto UseVBO;
        }

        goto UseNormal;
    }

    if (AGraphics->isUseVAO)
    {
        UseVAO:
        
        glBindVertexArray(sprite->vaoID);
        glDrawElements(GL_TRIANGLES, sprite->indexCount, GL_UNSIGNED_SHORT, 0);
        // clear VAO bind
        glBindVertexArray(0);
    }
    else if (AGraphics->isUseVBO)
    {
        glBindBuffer(GL_ARRAY_BUFFER,         sprite->vboIDs[Sprite_BufferVertex]);

        UseVBO:

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sprite->vboIDs[Sprite_BufferIndex]);

        // load the position and texture coordinate
        glVertexAttribPointer
        (
            (GLuint) AShaderSprite->attribPositionTexcoord,
            Sprite_VertexNum,
            GL_FLOAT,
            false,
            Sprite_VertexStride,
            0
        );

        glDrawElements(GL_TRIANGLES, sprite->indexCount, GL_UNSIGNED_SHORT, 0);

        // clear VBO bind
        glBindBuffer(GL_ARRAY_BUFFER,         0);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
    }
    else
    {
        UseNormal:
        
        // load the position and texture coordinate
        glVertexAttribPointer
        (
            (GLuint) AShaderSprite->attribPositionTexcoord,
            Sprite_VertexNum,
            GL_FLOAT,
            false,
            Sprite_VertexStride,
            sprite->vertexArr->data
        );

        glDrawElements(GL_TRIANGLES, sprite->indexCount, GL_UNSIGNED_SHORT, sprite->indexArr->data);
    }
}


static void Release(Sprite* sprite)
{
    free(sprite->vertexArr);
    free(sprite->indexArr);

    sprite->indexArr  = NULL;
    sprite->vertexArr = NULL;
    sprite->texture   = NULL;

    if (AGraphics->isUseVBO)
    {
        glDeleteBuffers(Sprite_BufferNum, sprite->vboIDs);
        sprite->vboIDs[Sprite_BufferVertex] = 0;
        sprite->vboIDs[Sprite_BufferIndex]  = 0;

        if (AGraphics->isUseVAO)
        {
            glDeleteVertexArrays(1, &sprite->vaoID);
            sprite->vaoID = 0;
        }
    }
}


static inline void InitSprite(Sprite* sprite, Texture* texture, Array(Quad)* quadArr)
{
    Drawable* drawable = sprite->drawable;
    ADrawable->Init(drawable);

    // calculate and cache drawable mvp matrix
    ADrawable_AddState(drawable, DrawableState_IsUpdateMVPMatrix);

    AQuad->GetMaxSize(quadArr, &drawable->width, &drawable->height);

    sprite->texture                     = texture;
    sprite->uvWidth                     = AGLTool_ToUVWidth(drawable->width,  texture->width);
    sprite->uvHeight                    = AGLTool_ToUVWidth(drawable->height, texture->height);
    sprite->vboIDs[Sprite_BufferVertex] = 0;
    sprite->vboIDs[Sprite_BufferIndex]  = 0;
    sprite->vaoID                       = 0;
    sprite->indexCount                  = quadArr->length * Quad_IndexNum;
    sprite->vertexArr                   = AArray->Create(sizeof(float), quadArr->length * Quad_Position2UVNum);
    sprite->indexArr                    = AArray->Create(sizeof(short), sprite->indexCount);
    sprite->vertexDataSize              = sprite->vertexArr->length * sizeof(float);
    sprite->isDeformed                  = false;
    
    drawable->Render                    = Render;

    for (int i = 0; i < quadArr->length; ++i)
    {
        AQuad->GetPosition2UV
        (
            AArray_GetPtr(quadArr, i, Quad),
            texture,
            (float*) sprite->vertexArr->data + i * Quad_Position2UVNum
        );
        
        AQuad->GetIndex(i * Quad_VertexNum, (short*) sprite->indexArr->data + i * Quad_IndexNum);
    }

    if (AGraphics->isUseVBO)
    {
        if (sprite->vboIDs[Sprite_BufferVertex] == 0)
        {
            glGenBuffers(Sprite_BufferNum, sprite->vboIDs);
        }

        // vertex
        glBindBuffer(GL_ARRAY_BUFFER, sprite->vboIDs[Sprite_BufferVertex]);
        glBufferData
        (
            GL_ARRAY_BUFFER,
            sprite->vertexDataSize,
            sprite->vertexArr->data,
            GL_STATIC_DRAW
        );

        // index
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sprite->vboIDs[Sprite_BufferIndex]);
        glBufferData
        (
            GL_ELEMENT_ARRAY_BUFFER,
            sprite->indexArr->length * sizeof(short),
            sprite->indexArr->data,
            GL_STATIC_DRAW
        );

        if (AGraphics->isUseVAO)
        {
            if (sprite->vaoID == 0)
            {
                glGenVertexArrays(1, &sprite->vaoID);
            }

            glBindVertexArray(sprite->vaoID);

            // with vao has own state
            glBindBuffer(GL_ARRAY_BUFFER,         sprite->vboIDs[Sprite_BufferVertex]);
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, sprite->vboIDs[Sprite_BufferIndex]);
            glEnableVertexAttribArray((GLuint) AShaderSprite->attribPositionTexcoord);

            // load the position and texture coordinate
            glVertexAttribPointer
            (
                (GLuint) AShaderSprite->attribPositionTexcoord,
                Sprite_VertexNum,
                GL_FLOAT,
                false,
                Sprite_VertexStride,
                0
            );

            // go back to normal state
            glBindVertexArray(0);
        }
    }
}



#define CheckDeformLength(arr)                                                                      \
    ALog_A                                                                                          \
    (                                                                                               \
        (arr)->length == length,                                                                    \
        "ASprite Deform " #arr " length = %d must equals the half length = %d of sprite vertexArr", \
        (arr)->length,                                                                              \
        sprite->vertexArr->length                                                                   \
    )


static void Deform(Sprite* sprite, Array(float)* positionDeformArr, Array(float)* uvDeformArr)
{
    int    length   = sprite->vertexArr->length >> 1;
    float* vertices = sprite->vertexArr->data;

    if (positionDeformArr != NULL && uvDeformArr != NULL)
    {
        CheckDeformLength(positionDeformArr);
        CheckDeformLength(uvDeformArr);

        float* positions = positionDeformArr->data;
        float* uvs       = uvDeformArr->data;

        for (int i = 0; i < positionDeformArr->length; i += Sprite_VertexPositionNum)
        {
            int      i1      = i +  1;
            int      j       = i << 1;        // to vertexArr position index
            vertices[j]     += positions[i];  // x
            vertices[j + 1] += positions[i1]; // y
            vertices[j + 2] += uvs      [i];  // u
            vertices[j + 3] += uvs      [i1]; // v
        }
    }
    else if (positionDeformArr != NULL)
    {
        CheckDeformLength(positionDeformArr);
        
        float* positions = positionDeformArr->data;

        for (int i = 0; i < positionDeformArr->length; i += Sprite_VertexPositionNum)
        {
            int      j       = i << 1;           // to vertexArr position index
            vertices[j]     += positions[i];     // x
            vertices[j + 1] += positions[i + 1]; // y
        }
    }
    else if (uvDeformArr != NULL)
    {
        CheckDeformLength(uvDeformArr);

        float* uvs = uvDeformArr->data;

        for (int i = 0; i < uvDeformArr->length; i += Sprite_VertexPositionNum)
        {
            int      j       = i << 1;     // to vertexArr position index
            vertices[j + 2] += uvs[i];     // x
            vertices[j + 3] += uvs[i + 1]; // y
        }
    }
    else
    {
        ALog_A(false, "ASprite Deform the positionDeformArr and uvDeformArr cannot both NULL");
    }

    sprite->isDeformed = true;
}


#define CheckDeformByIndex(tag, len)                                                                  \
    ALog_A                                                                                            \
    (                                                                                                 \
        (len) <= length,                                                                              \
        "ASprite DeformByIndex the " tag " = %d must less than half length = %d of sprite vertexArr", \
        (len),                                                                                        \
        sprite->vertexArr->length                                                                     \
    )


static inline int GetPositionIndex(int index)
{
    int offset             = index % Sprite_VertexPositionNum; // (0 or 1), offset of one vertex data
    int positionStartIndex = (index - offset) << 1; // to vertexArr position start index

    // position index
    return positionStartIndex + offset;
}


static void DeformByIndex(Sprite* sprite, Array(float)* positionDeformArr, Array(float)* uvDeformArr, Array(int)* indexArr)
{
    int length = sprite->vertexArr->length >> 1;

    CheckDeformByIndex("indexArr length", indexArr->length);

    float* vertices = sprite->vertexArr->data;
    int*   indices  = indexArr->data;

    if (positionDeformArr != NULL && uvDeformArr != NULL)
    {
        CheckDeformByIndex("positionDeformArr length", positionDeformArr->length);
        CheckDeformByIndex("uvDeformArr length",       uvDeformArr->length);

        float* positions = positionDeformArr->data;
        float* uvs       = uvDeformArr->data;

        for (int i = 0; i < indexArr->length; ++i)
        {
            int      index                              = GetPositionIndex(indices[i]);
            vertices[index]                            += positions[i];
            vertices[index + Sprite_VertexPositionNum] += uvs      [i];
        }
    }
    else if (positionDeformArr != NULL)
    {
        CheckDeformByIndex("positionDeformArr length", positionDeformArr->length);

        float* positions = positionDeformArr->data;

        for (int i = 0; i < indexArr->length; ++i)
        {
            vertices[GetPositionIndex(indices[i])] += positions[i];
        }
    }
    else if (uvDeformArr != NULL)
    {
        CheckDeformByIndex("uvDeformArr length", uvDeformArr->length);

        float* uvs = uvDeformArr->data;

        for (int i = 0; i < indexArr->length; ++i)
        {
            vertices[GetPositionIndex(indices[i]) + Sprite_VertexPositionNum] += uvs[i];
        }
    }
    else
    {
        ALog_A(false, "ASprite DeformByIndex the positionDeformArr and uvDeformArr cannot both NULL");
    }

    sprite->isDeformed = true;
}


#undef CheckDeformLength
#undef CheckDeformByIndex


static void Init(Texture* texture, Sprite* outSprite)
{
    Quad quad[1];
    AQuad->Init(texture->width, texture->height, quad);
    InitSprite(outSprite, texture, (Array(Quad)[1]) {quad, 1}); // equals AArray_Make(Quad, 1, *quad)
}


static Sprite* Create(Texture* texture)
{
    Sprite* sprite = malloc(sizeof(Sprite));
    Init(texture, sprite);

    return sprite;
}


static void InitWithQuad(Texture* texture, Quad* quad, Sprite* outSprite)
{
    InitSprite(outSprite, texture, (Array(Quad)[1]) {quad, 1}); // equals AArray_Make(Quad, 1, *quad)
}


static Sprite* CreateWithQuad(Texture* texture, Quad* quad)
{
    Sprite* sprite = malloc(sizeof(Sprite));
    InitWithQuad(texture, quad, sprite);

    return sprite;
}


static Sprite* CreateWithQuadArray(Texture* texture, Array(Quad)* quadArr)
{
    Sprite* sprite = malloc(sizeof(Sprite));
    InitSprite(sprite, texture, quadArr);

    return sprite;
}


static void InitWithQuadArray(Texture* texture, Array(Quad)* quadArr, Sprite* outSprite)
{
    InitSprite(outSprite, texture, quadArr);
}


static Sprite* CreateWithFile(const char* resourceFilePath)
{
    return Create(ATexture->Get(resourceFilePath));
}


static void InitWithFile(const char* resourceFilePath, Sprite* outSprite)
{
    Init(ATexture->Get(resourceFilePath), outSprite);
}


struct ASprite ASprite[1] =
{{
    Create,
    Init,

    CreateWithFile,
    InitWithFile,

    CreateWithQuad,
    InitWithQuad,

    CreateWithQuadArray,
    InitWithQuadArray,

    Release,
    Deform,
    DeformByIndex,
    Render,
}};

```

`Engine/Graphics/OpenGL/Sprite.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-4-20
 * Update   : 2019-1-21
 * Author   : scott.cgi
 */


#ifndef SPRITE_H
#define SPRITE_H


#include "Engine/Graphics/Draw/Drawable.h"
#include "Engine/Graphics/Draw/Quad.h"
#include "Engine/Graphics/OpenGL/Texture.h"
#include "Engine/Toolkit/Utils/Array.h"


enum
{
    /**
     * Number of buffers.
     */
     Sprite_BufferNum           = 2,

    /**
     * Index of buffer vertex.
     */
     Sprite_BufferVertex        = 0,
     
    /**
     * Index of buffer index.
     */
     Sprite_BufferIndex         = 1,

    /**
     * One vertex position has x, y.
     */
    Sprite_VertexPositionNum    = 2,

    /**
     * One vertex has u, v.
     */
    Sprite_VertexUVNum          = 2,

    /**
     * One vertex size.
     */
    Sprite_VertexNum            = Sprite_VertexPositionNum    + Sprite_VertexUVNum,

    /**
     * 2 (x, y) * 4 (sizeof float)
     */
    Sprite_VertexPositionStride = Sprite_VertexPositionNum    * sizeof(float),

    /**
     * 2 (u, v) * 4 (sizeof float)
     */
    Sprite_VertexUVStride       = Sprite_VertexUVNum          * sizeof(float),

    /**
     * One vertex stride.
     */
    Sprite_VertexStride         = Sprite_VertexPositionStride + Sprite_VertexUVStride,
};


/**
 * Render with texture by vertices.
 * implement Drawable's render for render self.
 */
typedef struct
{
    /**
     * The base class for provide draw functions.
     */
    Drawable      drawable[1];

    /**
     * Render texture.
     */
    Texture*      texture;

    /**
     * The uv width in texture.
     */
    float         uvWidth;

    /**
     * The uv height in texture.
     */
    float         uvHeight;

    /**
     * If use VBO is NULL else buffer all vertex data.
     * data model: [x, y, u, v...x, y, u, v...]
     */
    Array(float)*  vertexArr;

    /**
     * If use VBO is NULL else buffer all index data.
     */
    Array(short)* indexArr;

    /**
     * If use VBO is the generated VBO ids else 0.
     */
    GLuint        vboIDs[Sprite_BufferNum];

    /**
     * If use VAO is the generated vao id else 0.
     */
    GLuint        vaoID;

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Whether vertexArr has been deformed by ASprite Deform function.
     * auto reset by Render function.
     */
    bool          isDeformed;


    /**
     * All vertices index count.
     */
    int           indexCount;

    /**
     * The vertex bytes data size.
     */
    int           vertexDataSize;
}
Sprite;


/**
 * Control Sprite.
 */
struct ASprite
{
    Sprite* (*Create)             (Texture*    texture);
    void    (*Init)               (Texture*    texture,  Sprite* outSprite);

    /**
     * Create Sprite by resourceFilePath.
     *
     * resourceFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    Sprite* (*CreateWithFile)     (const char* resourceFilePath);

    /**
     * Init Sprite by resourceFilePath.
     *
     * resourceFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    void    (*InitWithFile)       (const char* resourceFilePath, Sprite* outSprite);

    Sprite* (*CreateWithQuad)     (Texture* texture, Quad* quad);
    void    (*InitWithQuad)       (Texture* texture, Quad* quad, Sprite* outSprite);


    Sprite* (*CreateWithQuadArray)(Texture* texture, Array(Quad)* quadArr);
    void    (*InitWithQuadArray)  (Texture* texture, Array(Quad)* quadArr, Sprite* outSprite);

    void    (*Release)            (Sprite*  sprite);

    /**
     * Deform Sprite vertex position and uv.
     * the positionDeformArr will add each position (x y).
     * the uvDeformArr will add each uv.
     *
     * the Sprite consists of quads,
     * and each quad vertices order is from left-top counterclockwise to right-top.
     *
     * positionDeformArr: if NULL will not deform.
     *                    the length must equals vertex positions number (the half of Sprite vertexArr length).
     *
     * uvDeformArr     : if NULL will not deform.
     *                   the length must equals vertex uvs number (the half of Sprite vertexArr length).
     */
    void    (*Deform)             (Sprite* sprite, Array(float)* positionDeformArr, Array(float)* uvDeformArr);


    /**
     * Same as Deform function but deform position and uv by index.
     *
     * indexArr: the index of position and uv array, and each vertex position or uv will deform.
     *           the positionDeformArr or uvDeformArr length must equals indexArr length.
     *
     */
    void    (*DeformByIndex)      (
                                      Sprite*       sprite,
                                      Array(float)* positionDeformArr,
                                      Array(float)* uvDeformArr,
                                      Array(int)*   indexArr
                                  );

    /**
     * The implementation of Drawable's render function for render Sprite.
     */
    void    (*Render)             (Drawable* drawable);
};


extern struct ASprite ASprite[1];


/**
 * Draw Sprite.
 */
static inline void ASprite_Draw(Sprite* sprite)
{
    // indirect call ASprite->Render
    ADrawable->Draw(sprite->drawable);
}


#endif

```

`Engine/Graphics/OpenGL/SubMesh.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-8-7
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#include <string.h>

#include "Engine/Graphics/Graphics.h"
#include "Engine/Graphics/OpenGL/SubMesh.h"
#include "Engine/Graphics/OpenGL/Mesh.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/GLTool.h"


static inline void InitSubMesh(Mesh* parent, SubMesh* subMesh, float width, float height)
{
    ADrawable->Init(subMesh->drawable);

    subMesh->parent             = parent;
    subMesh->index              = -1;
    subMesh->indexOffset        = 0;
    subMesh->positionDataOffset = 0;
    subMesh->uvDataOffset       = 0;
    subMesh->indexDataOffset    = 0;
    subMesh->opacityDataOffset  = 0;
    subMesh->rgbDataOffset      = 0;

    subMesh->vertexCount        = subMesh->positionArr->length / Mesh_VertexPositionNum;
    subMesh->vertexDataSize     = subMesh->vertexCount         * sizeof(float);
    subMesh->drawable->width    = width;
    subMesh->drawable->height   = height;
    subMesh->uvWidth            = AGLTool_ToUVWidth (width,  parent->texture->width);
    subMesh->uvHeight           = AGLTool_ToUVHeight(height, parent->texture->height);
}


static inline void GetSize(Array(float)* array, int dataNum, float* outWidth, float* outHeight)
{
    float* data = array->data;
    float  minX = data[0];
    float  minY = data[1];
    float  maxX = minX;
    float  maxY = minY;

    // calculate array size
    for (int i = dataNum; i < array->length; i += dataNum)
    {
        float x = data[i];
        float y = data[i + 1];

        if (x < minX)
        {
            minX = x;
        }
        else if (x > maxX)
        {
            maxX = x;
        }

        if (y < minY)
        {
            minY = y;
        }
        else if (y > maxY)
        {
            maxY = y;
        }
    }

    *outWidth  = maxX - minX;
    *outHeight = maxY - minY;
}


static SubMesh* CreateWithData(Mesh* parent, Array(float)* positionArr, Array(float)* uvArr, Array(short)* indexArr)
{
    int      indexDataSize       = indexArr->length    * sizeof(short);
    int      uvDataSize          = uvArr->length       * sizeof(float);
    int      positionDataSize    = positionArr->length * sizeof(float);
    SubMesh* subMesh             = malloc(sizeof(SubMesh) + indexDataSize + uvDataSize + positionDataSize);

    subMesh->uvArr->length       = uvArr->length;
    subMesh->uvArr->data         = (char*) subMesh + sizeof(SubMesh);
    memcpy(subMesh->uvArr->data, uvArr->data, (size_t) uvDataSize);

    subMesh->positionArr->length = positionArr->length;
    subMesh->positionArr->data   = (char*) subMesh->uvArr->data + uvDataSize;
    memcpy(subMesh->positionArr->data, positionArr->data, (size_t) positionDataSize);

    subMesh->indexArr->length    = indexArr->length;
    subMesh->indexArr->data      = (char*) subMesh->positionArr->data + (size_t) positionDataSize;
    memcpy(subMesh->indexArr->data, indexArr->data, (size_t) indexDataSize);

    subMesh->indexDataSize       = indexDataSize;
    subMesh->uvDataSize          = uvDataSize;
    subMesh->positionDataSize    = positionDataSize;

    float width;
    float height;
    GetSize(subMesh->positionArr, Mesh_VertexPositionNum, &width, &height);

    InitSubMesh(parent, subMesh, width, height);

    return subMesh;
}


static void SetUVWithQuad(SubMesh* subMesh, Quad* quad)
{
    subMesh->drawable->width  = quad->width;
    subMesh->drawable->height = quad->height;

    AQuad->GetUV       (quad, subMesh->parent->texture, subMesh->uvArr->data);
    AQuad->GetPosition3(quad, subMesh->positionArr->data);

    Mesh* mesh = subMesh->parent;

    ALog_A(mesh != NULL, "ASubMesh SetUVWithQuad subMesh must has parent");

    memcpy
    (
        (char*)  mesh->vertexArr->data + mesh->uvDataOffset + subMesh->uvDataOffset,
        subMesh->uvArr->data,
        (size_t) subMesh->uvDataSize
    );

    if (AGraphics->isUseVBO)
    {
        VBOSubData* subData = AArrayList_GetPtrAdd(mesh->vboSubDataList, VBOSubData);
        subData->target     = GL_ARRAY_BUFFER;
        subData->offset     = mesh->uvDataOffset + subMesh->uvDataOffset;
        subData->size       = subMesh->uvDataSize;
        subData->data       = subMesh->uvArr->data;
    }
}


static SubMesh* CreateWithQuad(Mesh* parent, Quad* quad)
{
    SubMesh* subMesh = malloc(sizeof(SubMesh) + Quad_IndexSize + Quad_UVSize + Quad_Position3Size);

    subMesh->indexArr->length    = Quad_IndexNum;
    subMesh->indexArr->data      = (char*) subMesh + sizeof(SubMesh);
    AQuad->GetIndex(0, subMesh->indexArr->data);

    subMesh->uvArr->length       = Quad_UVNum;
    subMesh->uvArr->data         = (char*) subMesh->indexArr->data + Quad_IndexSize;
    AQuad->GetUV(quad, parent->texture, subMesh->uvArr->data);

    subMesh->positionArr->length = Quad_Position3Num;
    subMesh->positionArr->data   = (char*) subMesh->uvArr->data    + Quad_UVSize;
    AQuad->GetPosition3(quad, subMesh->positionArr->data);

    subMesh->indexDataSize       = Quad_IndexSize;
    subMesh->uvDataSize          = Quad_UVSize;
    subMesh->positionDataSize    = Quad_Position3Size;

    InitSubMesh(parent, subMesh, quad->width, quad->height);

    return subMesh;
}


static inline void DeformApplyPositionUV(SubMesh *subMesh)
{
    Mesh* mesh = subMesh->parent;
    
    memcpy
    (
        (char*)  mesh->vertexArr->data + subMesh->positionDataOffset,
        subMesh->positionArr->data,
        (size_t) subMesh->positionDataSize
    );

    memcpy
    (
        (char*)  mesh->vertexArr->data + mesh->uvDataOffset + subMesh->uvDataOffset,
        subMesh->uvArr->data,
        (size_t) subMesh->uvDataSize
    );

    if (AGraphics->isUseVBO)
    {
        VBOSubData* subData = AArrayList_GetPtrAdd(mesh->vboSubDataList, VBOSubData);
        subData->target     = GL_ARRAY_BUFFER;
        subData->offset     = subMesh->positionDataOffset;
        subData->size       = subMesh->positionDataSize;
        subData->data       = subMesh->positionArr->data;

        subData             = AArrayList_GetPtrAdd(mesh->vboSubDataList, VBOSubData);
        subData->target     = GL_ARRAY_BUFFER;
        subData->offset     = mesh->uvDataOffset + subMesh->uvDataOffset;
        subData->size       = subMesh->uvDataSize;
        subData->data       = subMesh->uvArr->data;
    }
}


static inline void DeformApplyPosition(SubMesh *subMesh)
{
    Mesh* mesh = subMesh->parent;
    
    memcpy
    (
        (char*)  mesh->vertexArr->data + subMesh->positionDataOffset,
        subMesh->positionArr->data,
        (size_t) subMesh->positionDataSize
    );

    if (AGraphics->isUseVBO)
    {
        VBOSubData* subData = AArrayList_GetPtrAdd(mesh->vboSubDataList, VBOSubData);
        subData->target     = GL_ARRAY_BUFFER;
        subData->offset     = subMesh->positionDataOffset;
        subData->size       = subMesh->positionDataSize;
        subData->data       = subMesh->positionArr->data;
    }
}


static inline void DeformApplyUV(SubMesh* subMesh)
{
    Mesh* mesh = subMesh->parent;
    
    memcpy
    (
        (char*)  mesh->vertexArr->data + mesh->uvDataOffset + subMesh->uvDataOffset,
        subMesh->uvArr->data,
        (size_t) subMesh->uvDataSize
    );

    if (AGraphics->isUseVBO)
    {
        VBOSubData* subData = AArrayList_GetPtrAdd(mesh->vboSubDataList, VBOSubData);
        subData->target     = GL_ARRAY_BUFFER;
        subData->offset     = mesh->uvDataOffset + subMesh->uvDataOffset;
        subData->size       = subMesh->uvDataSize;
        subData->data       = subMesh->uvArr->data;
    }
}


#define CheckDeform(arr1, arr2)                                                           \
    ALog_A                                                                                \
    (                                                                                     \
        (arr1)->length == (arr2)->length,                                                 \
        "ASubMesh Deform the " #arr1 " length = %d must equals the " #arr2 " length = %d",\
        (arr1)->length,                                                                   \
        (arr2)->length                                                                    \
    )


static void Deform(SubMesh* subMesh, Array(float)* positionDeformArr, Array(float)* uvDeformArr)
{
    if (positionDeformArr != NULL && uvDeformArr != NULL)
    {
        CheckDeform(positionDeformArr, subMesh->positionArr);
        CheckDeform(uvDeformArr,       subMesh->uvArr);

        float* positions  = subMesh->positionArr->data;
        float* uvs        = subMesh->uvArr->data;
        float* posDeforms = positionDeformArr->data;
        float* uvDeforms  = uvDeformArr->data;
        
        for (int i = 0, j = 0; i < positionDeformArr->length; i += Mesh_VertexPositionNum, j += Mesh_VertexUVNum)
        {
            int       i1   = i + 1;
            int       i2   = i + 2;
            int       j1   = j + 1;

            positions[i]  += posDeforms[i];  // x
            positions[i1] += posDeforms[i1]; // y
            positions[i2] += posDeforms[i2]; // z

            uvs      [j]  += uvDeforms[j];   // u
            uvs      [j1] += uvDeforms[j1];  // v
        }

        DeformApplyPositionUV(subMesh);
    }
    else if (positionDeformArr != NULL)
    {
        CheckDeform(positionDeformArr, subMesh->positionArr);

        float* positions  = subMesh->positionArr->data;
        float* posDeforms = positionDeformArr->data;

        for (int i = 0; i < positionDeformArr->length; i += Mesh_VertexPositionNum)
        {
            int       i1   = i + 1;
            int       i2   = i + 2;

            positions[i]  += posDeforms[i];  // x
            positions[i1] += posDeforms[i1]; // y
            positions[i2] += posDeforms[i2]; // z
        }

        DeformApplyPosition(subMesh);
    }
    else if (uvDeformArr != NULL)
    {
        CheckDeform(uvDeformArr, subMesh->uvArr);

        float* uvs       = subMesh->uvArr->data;
        float* uvDeforms = uvDeformArr->data;

        for (int j = 0; j < uvDeformArr->length; j += Mesh_VertexUVNum)
        {
            int j1   = j + 1;
            uvs[j]  += uvDeforms[j];   // u
            uvs[j1] += uvDeforms[j1];  // v
        }

        DeformApplyUV(subMesh);
    }
    else
    {
        ALog_A(false, "ASubMesh Deform the positionDeformArr and uvDeformArr cannot both NULL");
    }
}


#define CheckDeformByIndex(arr1, arr2)                                                           \
    ALog_A                                                                                       \
    (                                                                                            \
        (arr1)->length == (arr2)->length,                                                        \
        "ASubMesh DeformByIndex the " #arr1 " length = %d must equals the " #arr2 " length = %d",\
        (arr1)->length,                                                                          \
        (arr2)->length                                                                           \
    )


#define CheckDeformByIndexLength(arr)                                                               \
    ALog_A                                                                                          \
    (                                                                                               \
        (arr)->length == length,                                                                    \
        "ASubMesh DeformByIndex " #arr " length = %d must equals the half length = %d of indexArr", \
        (arr)->length,                                                                              \
        indexArr->length                                                                            \
    )

static void DeformByIndex(SubMesh* subMesh, Array(float)* positionDeformArr, Array(float)* uvDeformArr, Array(int)* indexArr)
{
    if (positionDeformArr != NULL && uvDeformArr != NULL)
    {
        int length = indexArr->length >> 1;

        CheckDeformByIndexLength(positionDeformArr);
        CheckDeformByIndexLength(uvDeformArr);

        int*   indices    = indexArr->data;
        float* positions  = subMesh->positionArr->data;
        float* posDeforms = positionDeformArr->data;

        // position first
        for (int i = 0; i < length; ++i)
        {
            positions[indices[i]] += posDeforms[i];
        }

        float* uvs       = subMesh->uvArr->data;
        float* uvDeforms = uvDeformArr->data;

        // uv second
        for (int i = length; i < indexArr->length; ++i)
        {
            uvs[indices[i]] += uvDeforms[i - length];
        }

        DeformApplyPositionUV(subMesh);
    }
    else if (positionDeformArr != NULL)
    {
        CheckDeformByIndex(positionDeformArr,indexArr);

        float* positions  = subMesh->positionArr->data;
        float* posDeforms = positionDeformArr->data;
        int*   indices    = indexArr->data;

        for (int i = 0; i < indexArr->length; ++i)
        {
            positions[indices[i]] += posDeforms[i];
        }

        DeformApplyPosition(subMesh);
    }
    else if (uvDeformArr != NULL)
    {
        CheckDeformByIndex(uvDeformArr, indexArr);

        float* uvs       = subMesh->uvArr->data;
        float* uvDeforms = uvDeformArr->data;
        int*   indices   = indexArr->data;

        for (int i = 0; i < indexArr->length; ++i)
        {
            uvs[indices[i]] += uvDeforms[i];
        }

        DeformApplyUV(subMesh);
    }
    else
    {
        ALog_A(false, "ASubMesh DeformByIndex the positionDeformArr and uvDeformArr cannot both NULL");
    }
}


#undef CheckDeform
#undef CheckDeformByIndex
#undef CheckDeformByIndexLength


struct ASubMesh ASubMesh[1] =
{{
    CreateWithData,
    CreateWithQuad,
    SetUVWithQuad,
    Deform,
    DeformByIndex,
}};

```

`Engine/Graphics/OpenGL/SubMesh.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-8-7
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#ifndef SUB_MESH_H
#define SUB_MESH_H


#include "Engine/Graphics/OpenGL/MeshDefine.h"
#include "Engine/Graphics/Draw/Drawable.h"
#include "Engine/Graphics/Draw/Quad.h"


/**
 * The child of Mesh that render part of Texture.
 * 
 * the SubMesh has an array of vertices,
 * and each vertex has position (xyz), uv coordinates, and vertex indices.
 */
struct SubMesh
{
    /**
     * The base class for provide draw functions.
     * if regenerate and the drawable parent invisible，then the parent influence will lost.
     */
    Drawable      drawable[1];

    /**
     * SubMesh coordinate under parent Mesh drawable matrix.
     * if SubMesh drawable has own parent, equivalent to the own parent under Mesh drawable matrix.
     * so if let parent Mesh coordinate equal world space, will make SubMesh own coordinate more understandable.
     */
    Mesh*         parent;

    /**
     * Index in Mesh, so change it will reorder SubMesh by Mesh ReorderAllChildren.
     * default -1.
     */
    int           index;

    /**
     * The uv width in parent texture.
     */
    float         uvWidth;

    /**
     * The uv height in parent texture.
     */
    float         uvHeight;

//----------------------------------------------------------------------------------------------------------------------

    Array(float*) positionArr[1];
    Array(float*) uvArr      [1];
    Array(short*) indexArr   [1];

//----------------------------------------------------------------------------------------------------------------------

    /**
     * All vertices count.
     */
    int           vertexCount;

    /**
     * The vertex bytes data size.
     */
    int           vertexDataSize;

    /**
     * The index bytes data size.
     */
    int           indexDataSize;

    /**
     * The position bytes data size.
     */
    int           positionDataSize;

    /**
     * The uv bytes data size.
     */
    int           uvDataSize;

    /**
     * The index offset in parent Mesh indexArr.
     */
    int           indexOffset;

    /**
     * The position bytes data offset in parent Mesh vertexArr.
     */
    int           positionDataOffset;

    /**
     * The uv bytes data offset in parent Mesh vertexArr.
     */
    int           uvDataOffset;

    /**
     * The rgb bytes data offset in parent Mesh vertexArr.
     */
    int           rgbDataOffset;

    /**
     * The opacity bytes data offset in parent Mesh vertexArr.
     */
    int           opacityDataOffset;

    /**
     * The index bytes data offset in parent Mesh indexArr.
     */
    int           indexDataOffset;
};


/**
 * Control SubMesh.
 */
struct ASubMesh
{
    /**
     * The positionArr (array of xyz), uvArr (array of uv), indexArr (one vertex one index) will copy into SubMesh,
     * and all data create by one malloc.
     */
    SubMesh* (*CreateWithData)(Mesh* paren, Array(float)* positionArr, Array(float)* uvArr, Array(short)* indexArr);

    /**
     * The positionArr, uvArr, indexArr will calculated with quad that in texture.
     */
    SubMesh* (*CreateWithQuad)(Mesh* parent, Quad* quad);

    /**
     * Set uv data with quad that in parent texture.
     */
    void     (*SetUVWithQuad) (SubMesh* subMesh, Quad* quad);

    /**
     * Deform SubMesh vertex position and uv.
     * the positionDeformArr will add each position (x y).
     * the uvDeformArr will add each uv.
     * the vertices order is from left-top counterclockwise to right-top.
     *
     * positionDeformArr: if NULL will not deform.
     *                    the length must equals vertex positions number (positionArr length).
     *
     * uvDeformArr      : if NULL will not deform.
     *                    the length must equals vertex uvs number (uvArr length).
     */
    void    (*Deform)         (SubMesh* subMesh, Array(float)* positionDeformArr, Array(float)* uvDeformArr);

    /**
     * Same as Deform function but deform position and uv by index.
     *
     * indexArr: the index of position or uv array, and each vertex position or uv will deform.
     *
     * if deform position, then the indexArr length must equals positionDeformArr length.
     * if deform uv, then the indexArr length must equals uvArr length.
     * 
     * if deform position and uv at same time, then the indexArr must give both of position and uv index,
     * and the form like [position...position...uv...uv...],
     * and the positionDeformArr length and uvDeformArr length that each equals half length of indexArr.
     */
    void    (*DeformByIndex)  (
                                  SubMesh*      subMesh,
                                  Array(float)* positionDeformArr,
                                  Array(float)* uvDeformArr,
                                  Array(int)*   indexArr
                              );
};


extern struct ASubMesh ASubMesh[1];


/**
 * Draw SubMesh.
 */
static inline void ASubMesh_Draw(SubMesh* subMesh)
{
    ADrawable->Draw(subMesh->drawable);
}


#endif

```

`Engine/Graphics/OpenGL/Texture.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-2
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#include <stdlib.h>
#include "Engine/Graphics/OpenGL/Texture.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Toolkit/Utils/ArrayStrMap.h"
#include "Engine/Toolkit/Platform/Log.h"


static ArrayStrMap(filePath, Texture*) textureCacheMap[1] = AArrayStrMap_Init(Texture*, 25);


static Texture* Get(const char* resourceFilePath)
{
    Texture* texture = AArrayStrMap_Get(textureCacheMap, resourceFilePath, Texture*);

    if (texture == NULL)
    {
        texture = malloc(sizeof(Texture));
        AGLTool->LoadTexture(resourceFilePath, texture);

        texture->filePath = AArrayStrMap_GetKey
                           (
                               AArrayStrMap_TryPut(textureCacheMap, resourceFilePath, texture),
                               textureCacheMap->valueTypeSize
                           );
    }

    return texture;
}


static void Destroy(Texture* texture)
{
    glDeleteTextures(1, (GLuint[1]) {texture->id});

    bool isRemoved = AArrayStrMap->TryRemove(textureCacheMap, texture->filePath);
    ALog_A(isRemoved, "ATexture Destroy not found %s in textureCacheMap", texture->filePath);

    free(texture);
}


struct ATexture ATexture[1] =
{{
    Get,
    Destroy,
}};


```

`Engine/Graphics/OpenGL/Texture.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2012-12-29
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#ifndef TEXTURE_H
#define TEXTURE_H


#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Toolkit/HeaderUtils/Define.h"


typedef struct
{
    /**
     *  The openGL generated texture id.
     */
    GLuint id;

    /**
     * The texture width.
     */
    float   width;

    /**
     * The texture height.
     */
    float   height;

    /**
     * All texture cache in ArrayStrMap by filePath.
     */
    const char* filePath;
}
Texture;


/**
 * Manage and control Texture.
 */
struct ATexture
{
    /**
     * Get Texture by resourceFilePath, not found will create one.
     *
     * resourceFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    Texture*  (*Get)    (const char* resourceFilePath);

    /**
     * Destroy texture memory both in GPU and CPU, and removed from cache.
     *
     * important: after Destroy the texture will be invalidated.
     */
    void      (*Destroy)(Texture* texture);
};


extern struct ATexture ATexture[1];


#endif

```

`Engine/Graphics/Tween/TweenDrawable.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-6-17
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#include "Engine/Graphics/Draw/Drawable.h"
#include "Engine/Toolkit/Utils/TweenTool.h"


static float MoveXOnGet(void* target)
{
    return ((Drawable*) target)->positionX;
}


static void MoveXOnSet(void* target, float value)
{
    ADrawable_SetPositionX((Drawable*) target, value);
}


static void MoveYOnSet(void* target, float value)
{
    ADrawable_SetPositionY((Drawable*) target, value);
}


static float MoveYOnGet(void* target)
{
    return ((Drawable*) target)->positionY;
}


static void ScaleXOnSet(void* target, float value)
{
    ADrawable_SetScaleX((Drawable*) target, value);
}


static float ScaleXOnGet(void* target)
{
    return ((Drawable*) target)->scaleX;
}


static void ScaleYOnSet(void* target, float value)
{
    ADrawable_SetScaleY((Drawable*) target, value);
}


static float ScaleYOnGet(void* target)
{
    return ((Drawable*) target)->scaleY;
}


static void RotateZOnSet(void* target, float value)
{
    ADrawable_SetRotationZ((Drawable*) target, value);
}


static float RotateZOnGet(void* target)
{
    return ((Drawable*) target)->rotationZ;
}


static void FadeToOnSet(void* target, float value)
{
    ADrawable_SetOpacity((Drawable*) target, value);
}


static float FadeToOnGet(void* target)
{
    return ((Drawable*) target)->color->a;
}


struct ATweenActionValueGetSetImpl ATweenActionValueGetSetImpl[1] =
{{
    {
        MoveXOnGet,
        MoveXOnSet,
    },

    {
        MoveYOnGet,
        MoveYOnSet,
    },

    {
        ScaleXOnGet,
        ScaleXOnSet,
    },

    {
        ScaleYOnGet,
        ScaleYOnSet,
    },

    {
        RotateZOnGet,
        RotateZOnSet,
    },

    {
        FadeToOnGet,
        FadeToOnSet,
    },
}};

```

`Engine/Graphics/Utils/Image.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-8-30
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#include <stdbool.h>
#include <setjmp.h>

#include "Engine/Graphics/Utils/Image.h"
#include "Engine/Toolkit/Platform/File.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/ThirdParty/PNG/Include/Android/png.h"


/**
 * Callback for libpng read data.
 */
static void ReadPNGData(png_structp pngPtr, png_bytep data, png_size_t length)
{
    AFile->Read(png_get_io_ptr(pngPtr), data, length);
}


static void* CreatePixelDataFromPNG(const char* resourceFilePath, float* outWidth, float* outHeight)
{
    void* pixelData = NULL;
    File* file       = NULL;

    do
    {
        file = AFile->Open(resourceFilePath);

        unsigned char head[8];
        AFile->Read(file, head, 8);
        if (png_sig_cmp(head, 0, 8))
        {
            ALog_E("AImage CreatePixelDataFromPNG file is not PNG, %s", resourceFilePath);
            break;
        }

        // create and initialize the png_struct with the desired error handler
        // functions.  If you want to use the default stderr and longjump method,
        // you can supply NULL for the last three parameters.  We also supply the
        // the compiler header file version, so that we know if the application
        // was compiled with a compatible version of the library.  REQUIRED
        png_structp pngPtr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
        if (!pngPtr)
        {
            ALog_E("AImage CreatePixelDataFromPNG png_create_read_struct error, %s", resourceFilePath);
            break;
        }

        // allocate / initialize the memory for image information - REQUIRED
        png_infop infoPtr = png_create_info_struct(pngPtr);
        if (infoPtr == NULL)
        {
            png_destroy_read_struct(&pngPtr, NULL, NULL);
            ALog_E("AImage CreatePixelDataFromPNG png_create_info_struct infoPtr error, %s", resourceFilePath);
            break;
        }

        png_infop endInfo = png_create_info_struct(pngPtr);
        if (endInfo == NULL)
        {
            png_destroy_read_struct(&pngPtr, &infoPtr, NULL);
            ALog_E("AImage CreatePixelDataFromPNG png_create_info_struct endInfo error, %s", resourceFilePath);
            break;
        }

        // set error handling if you are using the setjmp/longjmp method (this is
        // the normal method of doing things with libpng).  REQUIRED unless you
        // set up your own error handlers in the png_create_read_struct() earlier.
        if (setjmp(png_jmpbuf(pngPtr)))
        {
          // free all of the memory associated with the png_ptr and info_ptr
          png_destroy_read_struct(&pngPtr, &infoPtr, &endInfo);
          ALog_E("AImage CreatePixelDataFromPNG during setjmp error, %s", resourceFilePath);
          break;
        }

        // if you are using replacement read functions, instead of calling
        // png_init_io() here you would call:
        // where user_io_ptr is a structure you want available to the callbacks
        png_set_read_fn(pngPtr, file, ReadPNGData);

        // if we have already read some of the signature
        png_set_sig_bytes(pngPtr, 8);

        // the call to png_read_info() gives us all of the information from the
        // PNG file before the first IDAT (image data chunk).  REQUIRED
        png_read_info(pngPtr, infoPtr);

        // note that png_get_IHDR() returns 32-bit data into
        // the application's outWidth and outHeight variables
        // This is an unsafe situation if these are 16-bit variables
        png_uint_32 pngWidth  = png_get_image_width (pngPtr, infoPtr);
        png_uint_32 pngHeight = png_get_image_height(pngPtr, infoPtr);

        int         bitDepth  = png_get_bit_depth (pngPtr, infoPtr);
        int         colorType = png_get_color_type(pngPtr, infoPtr);

        *outWidth             = (float) pngWidth;
        *outHeight            = (float) pngHeight;

        // force palette images to be expanded to 24-bit RGB
        // it may include alpha channel
        if (colorType == PNG_COLOR_TYPE_PALETTE)
        {
            png_set_palette_to_rgb(pngPtr);
        }

        // low-bit-depth grayscale images are to be expanded to 8 bits
        if (colorType == PNG_COLOR_TYPE_GRAY && bitDepth < 8)
        {
            png_set_expand_gray_1_2_4_to_8(pngPtr);
        }

        // expand any tRNS chunk data into a full alpha channel
        if (png_get_valid(pngPtr, infoPtr, PNG_INFO_tRNS))
        {
            png_set_tRNS_to_alpha(pngPtr);
        }

        // reduce images with 16-bit samples to 8 bits
        if (bitDepth == 16)
        {
            png_set_strip_16(pngPtr);
        }

        // expand grayscale images to RGB
        if (colorType == PNG_COLOR_TYPE_GRAY || colorType == PNG_COLOR_TYPE_GRAY_ALPHA)
        {
            png_set_gray_to_rgb(pngPtr);
        }

        // update the png info struct.
        png_read_update_info(pngPtr, infoPtr);

        // allocate the memory to hold the image using the fields of info_ptr
        unsigned long rowBytes = png_get_rowbytes(pngPtr, infoPtr);

        // allocate the pixel data as a big block, to be given to openGL
        pixelData = png_malloc(pngPtr, rowBytes * pngHeight);
        if (pixelData == NULL)
        {
            png_destroy_read_struct(&pngPtr, &infoPtr, &endInfo);
            ALog_E("AImage CreatePixelDataFromPNG malloc PNG pixel data error, %s", resourceFilePath);
            break;
        }

        // turn on interlace handling REQUIRED if you are not using
        // png_read_image() To see how to handle interlacing passes
        // see the png_read_row() method below:
        int numberPasses = png_set_interlace_handling(pngPtr);
        for (int pass = 0; pass < numberPasses; ++pass)
        {
            for (int row = 0; row < pngHeight; ++row)
            {
               png_read_row(pngPtr, ((unsigned char*) pixelData + (row * rowBytes)), NULL);
            }
        }

        // read rest of file, and get additional chunks in info_ptr - REQUIRED
        png_read_end(pngPtr, infoPtr);

        // at this point you have read the entire image
        // clean up after the read, and free any memory allocated - REQUIRE
        png_destroy_read_struct(&pngPtr, &infoPtr, &endInfo);

    }
    while (false);

    AFile->Close(file);

    return pixelData;
}


struct AImage AImage[1] =
{{
    CreatePixelDataFromPNG,
}};


```

`Engine/Graphics/Utils/Image.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-8-30
 * Update   : 2019-1-19
 * Author   : scott.cgi
 */


#ifndef IMAGE_H
#define IMAGE_H


#include "Engine/Toolkit/HeaderUtils/Define.h"


struct AImage
{
    /**
     * Read png pixel data from resourceFilePath, after using the data must be freed.
     * return NULL when error happened.
     *
     * resourceFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
     void* (*CreatePixelDataFromPNG)(const char* resourceFilePath, float* outWidth, float* outHeight);
};


extern struct AImage AImage[1];


#endif

```

`Engine/Physics/Physics.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-6-11
 * Update   : 2019-1-18
 * Author   : scott.cgi
 */


#include "Engine/Physics/Physics.h"
#include "Engine/Physics/PhysicsWorld.h"


static void Init()
{
    APhysicsWorld->gravity.y = -1.5f;
}


struct APhysics APhysics[1] =
{{
    Init
}};

```

`Engine/Physics/Physics.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-6-11
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#ifndef PHYSICS_H
#define PHYSICS_H


#include "Engine/Toolkit/Toolkit.h"


/**
 * Manage Physics module.
 */
struct APhysics
{
    void (*Init)(void);
};


extern struct APhysics APhysics[1];


#endif

```

`Engine/Physics/PhysicsBody.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-6-3
 * Update   : 2019-1-18
 * Author   : scott.cgi
 */


#include <string.h>
#include "Engine/Physics/PhysicsBody.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Physics/PhysicsWorld.h"


static inline PhysicsBody* CreateBody(Array(float)* vertexArr, PhysicsShape shape)
{
    int          size = sizeof(float) * vertexArr->length;
    PhysicsBody* body = malloc(sizeof(PhysicsBody) + (size << 1));

    body->vertexArr->length = vertexArr->length;
    body->vertexArr->data   = (char*) body + sizeof(PhysicsBody);
    memcpy(body->vertexArr->data, vertexArr->data, (size_t) size);

    body->transformedVertexArr->length = vertexArr->length;
    body->transformedVertexArr->data   = (char*) body->vertexArr->data + size;
    memcpy(body->transformedVertexArr->data, vertexArr->data, (size_t) size);

    AUserData_Init(body->userData);

    body->userID         = -1;
    body->positionX      = 0.0f;
    body->positionY      = 0.0f;
    body->velocityX      = 0.0f;
    body->velocityY      = 0.0f;
    body->accelerationX  = 0.0f;
    body->accelerationY  = 0.0f;
    body->rotationZ      = 0.0f;
    body->shape          = shape;
    body->state          = PhysicsBodyState_OutsideWorld;
    body->collisionGroup = 0;
    body->OnCollision    = NULL;

    return body;
}


static inline PhysicsBody* CreateWithPolygon(Array(float)* vertexArr)
{
    ALog_A(vertexArr->length >= 6, "PhysicsShape_Polygon vertexArr length must more than 6 (vertex contains x, y).");
    return CreateBody(vertexArr, PhysicsShape_Polygon);
}


static inline PhysicsBody* CreateWithLine(Array(float)* vertexArr)
{
    ALog_A(vertexArr->length == 4, "PhysicsShape_Line vertexArr length must equal 4 (vertex contains x, y).");
    return CreateBody(vertexArr, PhysicsShape_Line);
}


static inline PhysicsBody* CreateWithPoint(Array(float)* vertexArr)
{
    ALog_A(vertexArr->length == 2, "PhysicsShape_Point vertexArr length must equal 2 (vertex contains x, y).");
    return CreateBody(vertexArr, PhysicsShape_Point);
}


static PhysicsBody* Create(PhysicsShape shape, Array(float)* vertexArr)
{
    switch (shape)
    {
        case PhysicsShape_NULL:
            break;

        case PhysicsShape_Polygon:
            return CreateWithPolygon(vertexArr);

        case PhysicsShape_Line:
            return CreateWithLine(vertexArr);

        case PhysicsShape_Point:
            return CreateWithPoint(vertexArr);

        default:
            ALog_E("APhysicsBody Create with unknown shape = %d", shape);
            break;
    }

    return NULL;
}


static void ResetVertices(PhysicsBody* body)
{
    memcpy
    (
        body->transformedVertexArr->data,
        body->vertexArr->data,
        body->transformedVertexArr->length * sizeof(float)
    );
}


static void Update(PhysicsBody* body, float deltaSeconds)
{
    // cache v0
    float vx           = body->velocityX;
    float vy           = body->velocityY;

    // get final velocity in x and y direction
    // v1 = at + v0
    body->velocityX   += (body->accelerationX + APhysicsWorld->gravity.x) * deltaSeconds;
    body->velocityY   += (body->accelerationY + APhysicsWorld->gravity.y) * deltaSeconds;

    // get delta distance in x and y indirection
    // s = (v0 + v1) * t / 2
    float dx           = (body->velocityX + vx) * deltaSeconds * 0.5f;
    float dy           = (body->velocityY + vy) * deltaSeconds * 0.5f;

    // increase x and y distance
    body->positionX   += dx;
    body->positionY   += dy;
    body->rotationZ    = AMath_Atan2(dx, dy);
                      
    float  cosRZ       = AMath_Cos(body->rotationZ);
    float  sinRZ       = AMath_Sin(body->rotationZ);
    float* vertices    = body->vertexArr->data;
    float* transformed = body->transformedVertexArr->data;

    for (int i = 0; i < body->transformedVertexArr->length; i += 2)
    {
        float x = vertices[i];
        float y = vertices[i + 1];

        transformed[i]     = x * cosRZ - y * sinRZ + body->positionX;
        transformed[i + 1] = x * sinRZ + y * cosRZ + body->positionY;
    }

//  if (AMath_TestFloatEqual(body->velocityX, 0.0f) && AMath_TestFloatEqual(body->velocityY, 0.0f))
    {
        // stop motion
    }
}


struct APhysicsBody APhysicsBody[1] =
{{
    Create,
    ResetVertices,
    Update,
}};

```

`Engine/Physics/PhysicsBody.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-6-3
 * Update   : 2019-1-18
 * Author   : scott.cgi
 */


#ifndef PHYSICS_BODY_H
#define PHYSICS_BODY_H


#include "Engine/Toolkit/Math/Matrix.h"
#include "Engine/Toolkit/HeaderUtils/Bitwise.h"
#include "Engine/Toolkit/Utils/Array.h"
#include "Engine/Toolkit/HeaderUtils/UserData.h"


typedef enum
{
    PhysicsShape_NULL    = 0,
    PhysicsShape_Polygon = 1,
    PhysicsShape_Line    = 1 << 2,
    PhysicsShape_Point   = 1 << 3,
}
PhysicsShape;


typedef enum
{
    /**
     * Not add in physics world yet.
     */
    PhysicsBodyState_OutsideWorld,

    /**
     * Can motion can collision.
     */
    PhysicsBodyState_Normal,

    /**
     * No motion can collision.
     */
    PhysicsBodyState_Fixed,

    /**
     * No motion no collision.
     */
    PhysicsBodyState_Freeze,
}
PhysicsBodyState;


typedef struct PhysicsBody PhysicsBody;
struct  PhysicsBody
{
    UserData         userData[1];

    /**
     * Used to identify PhysicsBody, default -1.
     */
    int              userID;

    float            positionX;
    float            positionY;
    float            velocityX;
    float            velocityY;
    float            accelerationX;
    float            accelerationY;
    float            rotationZ;

    PhysicsShape     shape;

    /**
     * PhysicsBody current state.
     */
    PhysicsBodyState state;

    /**
     * Pow of 2, default 0.
     * body can collision between different collisionGroup (no same bit).
     */
    int              collisionGroup;

    /**
     * Store born vertices.
     */
    Array(float)     vertexArr[1];

    /**
     * The vertices after transformed.
     */
    Array(float)     transformedVertexArr[1];

    /**
     * When body collision callback.
     */
    void (*OnCollision)(PhysicsBody* self, PhysicsBody* other, float deltaSeconds);
};


/**
 * Control PhysicsBody.
 */
struct APhysicsBody
{
    /**
     * Create body with shape and vertices.
     *
     * the vertexArr will copy into body,
     * and the body's vertexArr and transformedVertexArr are same when init,
     * and all data create by one malloc.
     *
     * if shape not support will return NULL.
     */
    PhysicsBody* (*Create)       (PhysicsShape shape, Array(float)* vertexArr);

    /**
     * Reset body's transformedVertexArr to vertexArr.
     */
    void         (*ResetVertices)(PhysicsBody* body);

    /**
     * Simulate body motion and update transformedVertexArr by position, rotation.
     */
    void         (*Update)       (PhysicsBody* body, float deltaSeconds);

};


extern struct APhysicsBody APhysicsBody[1];


//----------------------------------------------------------------------------------------------------------------------


/**
 *  Check physicsBody whether has same bit in collisionGroup.
 */
static inline bool APhysicsBody_CheckCollisionGroup(PhysicsBody* physicsBody, int collisionGroup)
{
    return ABitwise_Check(physicsBody->collisionGroup, collisionGroup);
}


/**
 * Add collisionGroup to physicsBody.
 */
static inline void APhysicsBody_AddCollisionGroup(PhysicsBody* physicsBody, int collisionGroup)
{
    ABitwise_Add(physicsBody->collisionGroup, collisionGroup);
}


/**
 * Set collisionGroup to physicsBody.
 */
static inline void APhysicsBody_SetCollisionGroup(PhysicsBody* physicsBody, int collisionGroup)
{
    ABitwise_Set(physicsBody->collisionGroup, collisionGroup);
}


/**
 * Clear collisionGroup in physicsBody.
 */
static inline void APhysicsBody_ClearCollisionGroup(PhysicsBody* physicsBody, int collisionGroup)
{
    ABitwise_Clear(physicsBody->collisionGroup, collisionGroup);
}


#endif

```

`Engine/Physics/PhysicsCollision.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-7-23
 * Update   : 2019-1-18
 * Author   : scott.cgi
 */


#include "Engine/Physics/PhysicsCollision.h"


typedef enum
{
    PhysicsShape_PolygonPolygon = PhysicsShape_Polygon,
    PhysicsShape_PolygonLine    = PhysicsShape_Polygon | PhysicsShape_Line,
    PhysicsShape_LineLine       = PhysicsShape_Line,
    PhysicsShape_PolygonPoint   = PhysicsShape_Polygon | PhysicsShape_Point,
}
PhysicsShapeCollision;


static bool TestCollision(PhysicsBody* bodyA, PhysicsBody* bodyB)
{
    PhysicsShapeCollision shapeCollision = (PhysicsShapeCollision) (bodyA->shape | bodyB->shape);

    switch (shapeCollision)
    {
        case PhysicsShape_PolygonPolygon:
            return AMath->TestPolygonPolygon(bodyA->transformedVertexArr, bodyB->transformedVertexArr);

        case PhysicsShape_PolygonLine:
            // only consider line vertex in polygon
            if (bodyA->shape == PhysicsShape_Line)
            {
                return AMath->TestPolygonABStrict(bodyA->transformedVertexArr, bodyB->transformedVertexArr);
            }
            else
            {
                return AMath->TestPolygonABStrict(bodyB->transformedVertexArr, bodyA->transformedVertexArr);
            }

        case PhysicsShape_LineLine:
            return AMath->TestLineLine(bodyA->transformedVertexArr, bodyB->transformedVertexArr);

        case PhysicsShape_PolygonPoint:
            // only consider point in polygon
            if (bodyA->shape == PhysicsShape_Polygon)
            {
                return AMath->TestPolygonPoint
                       (
                           bodyA->transformedVertexArr,
                           AArray_Get(bodyB->transformedVertexArr, 0, float),
                           AArray_Get(bodyB->transformedVertexArr, 1, float)
                       );
            }
            else
            {
                return AMath->TestPolygonPoint
                        (
                            bodyB->transformedVertexArr,
                            AArray_Get(bodyA->transformedVertexArr, 0, float),
                            AArray_Get(bodyA->transformedVertexArr, 1, float)
                        );
            }
        default:
            ALog_A
            (
                false,
                "APhysicsCollision cannot test collision between shape %d and %d",
                bodyA->shape,
                bodyB->shape
            );
    }

    return false;
}


struct APhysicsCollision APhysicsCollision[1] =
{{
    TestCollision,
}};

```

`Engine/Physics/PhysicsCollision.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-7-23
 * Update   : 2019-1-18
 * Author   : scott.cgi
 */


#ifndef PHYSICS_COLLISION_H
#define PHYSICS_COLLISION_H


#include <stdbool.h>
#include "Engine/Physics/PhysicsBody.h"


/**
 * Control physics collision.
 */
struct APhysicsCollision
{
    bool (*TestCollision)(PhysicsBody* bodyA, PhysicsBody* bodyB);
};


extern struct APhysicsCollision APhysicsCollision[1];


#endif 

```

`Engine/Physics/PhysicsConfig.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-8-7
 * Author   : scott.cgi
 */


#ifndef PHYSICS_CONFIG_H
#define PHYSICS_CONFIG_H


#endif

```

`Engine/Physics/PhysicsWorld.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-5-30
 * Update   : 2019-1-18
 * Author   : scott.cgi
 */


#include "Engine/Physics/PhysicsWorld.h"
#include "Engine/Toolkit/Utils/ArrayIntSet.h"
#include "Engine/Physics/PhysicsCollision.h"


static ArrayIntSet(PhysicsBody*) bodyInWorldSet[1] = AArrayIntSet_Init(PhysicsBody*, 20);


static void Update(float deltaSeconds)
{
    for (int i = 0; i < bodyInWorldSet->elementList->size; ++i)
    {
        PhysicsBody* body = AArrayList_Get(bodyInWorldSet->elementList, i, PhysicsBody*);

        if (body->state != PhysicsBodyState_Freeze)
        {
            // test collision
            for (int fromIndex = i + 1; fromIndex < bodyInWorldSet->elementList->size; ++fromIndex)
            {
                PhysicsBody* otherBody = AArrayList_Get(bodyInWorldSet->elementList, fromIndex, PhysicsBody*);

                if
                (
                    otherBody->state != PhysicsBodyState_Freeze &&
                    // check collisionGroup whether has same bit
                    (body->collisionGroup & otherBody->collisionGroup) == 0 &&
                    APhysicsCollision->TestCollision(body, otherBody)
                )
                {
                    if (body->OnCollision != NULL)
                    {
                        body->OnCollision(body, otherBody, deltaSeconds);
                    }

                    if (otherBody->OnCollision != NULL)
                    {
                        otherBody->OnCollision(otherBody, body, deltaSeconds);
                    }
                }
            }
        }

        if (body->state != PhysicsBodyState_Freeze && body->state != PhysicsBodyState_Fixed)
        {
            // after test collision can update motion
            APhysicsBody->Update(body, deltaSeconds);
        }
    }
}



static PhysicsBody* AddBody(PhysicsShape shape, Array(float)* vertexArr)
{
    PhysicsBody* body = APhysicsBody->Create(shape, vertexArr);
    AArrayIntSet->TryAdd(bodyInWorldSet, (intptr_t) body);

    return body;
}


static void DestroyBody(PhysicsBody* body)
{
    AArrayIntSet->TryRemove(bodyInWorldSet, (intptr_t) body);
    free(body);
}


struct APhysicsWorld APhysicsWorld[1] =
{{
    {0.0f, 0.0f},
    AddBody,
    DestroyBody,
    Update,
}};

```

`Engine/Physics/PhysicsWorld.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-5-30
 * Update   : 2019-1-18
 * Author   : scott.cgi
 */


#ifndef PHYSICS_WORLD_H
#define PHYSICS_WORLD_H


#include "Engine/Physics/PhysicsBody.h"
#include "Engine/Toolkit/Math/Vector.h"


/**
 * Control and set up physics world.
 */
struct APhysicsWorld
{
    Vector2 gravity;

    /**
     * Create body and add in PhysicsWorld.
     */
    PhysicsBody* (*AddBody)    (PhysicsShape shape, Array(float)* vertexArr);

    /**
     * Remove PhysicsBody from world and free it.
     * 
     * important: after DestroyBody the body will be invalidated.
     */
    void         (*DestroyBody)(PhysicsBody* body);

    /**
     * Called every frame by loop.
     */
    void         (*Update)     (float deltaSeconds);
};


extern struct APhysicsWorld APhysicsWorld[1];


#endif

```

`Engine/ThirdParty/PNG/Include/Android/png.h`:

```h

/* png.h - header file for PNG reference library
 *
 * libpng version 1.6.28, January 5, 2017
 *
 * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license (See LICENSE, below)
 *
 * Authors and maintainers:
 *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
 *   libpng versions 0.89, June 1996, through 0.96, May 1997: Andreas Dilger
 *   libpng versions 0.97, January 1998, through 1.6.28, January 5, 2017:
 *     Glenn Randers-Pehrson.
 *   See also "Contributing Authors", below.
 */

/*
 * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
 *
 * If you modify libpng you may insert additional notices immediately following
 * this sentence.
 *
 * This code is released under the libpng license.
 *
 * libpng versions 1.0.7, July 1, 2000 through 1.6.28, January 5, 2017 are
 * Copyright (c) 2000-2002, 2004, 2006-2017 Glenn Randers-Pehrson, are
 * derived from libpng-1.0.6, and are distributed according to the same
 * disclaimer and license as libpng-1.0.6 with the following individuals
 * added to the list of Contributing Authors:
 *
 *    Simon-Pierre Cadieux
 *    Eric S. Raymond
 *    Mans Rullgard
 *    Cosmin Truta
 *    Gilles Vollant
 *    James Yu
 *    Mandar Sahastrabuddhe
 *
 * and with the following additions to the disclaimer:
 *
 *    There is no warranty against interference with your enjoyment of the
 *    library or against infringement.  There is no warranty that our
 *    efforts or the library will fulfill any of your particular purposes
 *    or needs.  This library is provided with all faults, and the entire
 *    risk of satisfactory quality, performance, accuracy, and effort is with
 *    the user.
 *
 * Some files in the "contrib" directory and some configure-generated
 * files that are distributed with libpng have other copyright owners and
 * are released under other open source licenses.
 *
 * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
 * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from
 * libpng-0.96, and are distributed according to the same disclaimer and
 * license as libpng-0.96, with the following individuals added to the list
 * of Contributing Authors:
 *
 *    Tom Lane
 *    Glenn Randers-Pehrson
 *    Willem van Schaik
 *
 * libpng versions 0.89, June 1996, through 0.96, May 1997, are
 * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,
 * and are distributed according to the same disclaimer and license as
 * libpng-0.88, with the following individuals added to the list of
 * Contributing Authors:
 *
 *    John Bowler
 *    Kevin Bracey
 *    Sam Bushell
 *    Magnus Holmgren
 *    Greg Roelofs
 *    Tom Tanner
 *
 * Some files in the "scripts" directory have other copyright owners
 * but are released under this license.
 *
 * libpng versions 0.5, May 1995, through 0.88, January 1996, are
 * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
 *
 * For the purposes of this copyright and license, "Contributing Authors"
 * is defined as the following set of individuals:
 *
 *    Andreas Dilger
 *    Dave Martindale
 *    Guy Eric Schalnat
 *    Paul Schmidt
 *    Tim Wegner
 *
 * The PNG Reference Library is supplied "AS IS".  The Contributing Authors
 * and Group 42, Inc. disclaim all warranties, expressed or implied,
 * including, without limitation, the warranties of merchantability and of
 * fitness for any purpose.  The Contributing Authors and Group 42, Inc.
 * assume no liability for direct, indirect, incidental, special, exemplary,
 * or consequential damages, which may result from the use of the PNG
 * Reference Library, even if advised of the possibility of such damage.
 *
 * Permission is hereby granted to use, copy, modify, and distribute this
 * source code, or portions hereof, for any purpose, without fee, subject
 * to the following restrictions:
 *
 *   1. The origin of this source code must not be misrepresented.
 *
 *   2. Altered versions must be plainly marked as such and must not
 *      be misrepresented as being the original source.
 *
 *   3. This Copyright notice may not be removed or altered from any
 *      source or altered source distribution.
 *
 * The Contributing Authors and Group 42, Inc. specifically permit, without
 * fee, and encourage the use of this source code as a component to
 * supporting the PNG file format in commercial products.  If you use this
 * source code in a product, acknowledgment is not required but would be
 * appreciated.
 *
 * END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.
 *
 * TRADEMARK:
 *
 * The name "libpng" has not been registered by the Copyright owner
 * as a trademark in any jurisdiction.  However, because libpng has
 * been distributed and maintained world-wide, continually since 1995,
 * the Copyright owner claims "common-law trademark protection" in any
 * jurisdiction where common-law trademark is recognized.
 *
 * OSI CERTIFICATION:
 *
 * Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is
 * a certification mark of the Open Source Initiative. OSI has not addressed
 * the additional disclaimers inserted at version 1.0.7.
 *
 * EXPORT CONTROL:
 *
 * The Copyright owner believes that the Export Control Classification
 * Number (ECCN) for libpng is EAR99, which means not subject to export
 * controls or International Traffic in Arms Regulations (ITAR) because
 * it is open source, publicly available software, that does not contain
 * any encryption software.  See the EAR, paragraphs 734.3(b)(3) and
 * 734.7(b).
 */

/*
 * A "png_get_copyright" function is available, for convenient use in "about"
 * boxes and the like:
 *
 *    printf("%s", png_get_copyright(NULL));
 *
 * Also, the PNG logo (in PNG format, of course) is supplied in the
 * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
 */

/*
 * The contributing authors would like to thank all those who helped
 * with testing, bug fixes, and patience.  This wouldn't have been
 * possible without all of you.
 *
 * Thanks to Frank J. T. Wojcik for helping with the documentation.
 */

/* Note about libpng version numbers:
 *
 *    Due to various miscommunications, unforeseen code incompatibilities
 *    and occasional factors outside the authors' control, version numbering
 *    on the library has not always been consistent and straightforward.
 *    The following table summarizes matters since version 0.89c, which was
 *    the first widely used release:
 *
 *    source                 png.h  png.h  shared-lib
 *    version                string   int  version
 *    -------                ------ -----  ----------
 *    0.89c "1.0 beta 3"     0.89      89  1.0.89
 *    0.90  "1.0 beta 4"     0.90      90  0.90  [should have been 2.0.90]
 *    0.95  "1.0 beta 5"     0.95      95  0.95  [should have been 2.0.95]
 *    0.96  "1.0 beta 6"     0.96      96  0.96  [should have been 2.0.96]
 *    0.97b "1.00.97 beta 7" 1.00.97   97  1.0.1 [should have been 2.0.97]
 *    0.97c                  0.97      97  2.0.97
 *    0.98                   0.98      98  2.0.98
 *    0.99                   0.99      98  2.0.99
 *    0.99a-m                0.99      99  2.0.99
 *    1.00                   1.00     100  2.1.0 [100 should be 10000]
 *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]
 *    1.0.1       png.h string is   10001  2.1.0
 *    1.0.1a-e    identical to the  10002  from here on, the shared library
 *    1.0.2       source version)   10002  is 2.V where V is the source code
 *    1.0.2a-b                      10003  version, except as noted.
 *    1.0.3                         10003
 *    1.0.3a-d                      10004
 *    1.0.4                         10004
 *    1.0.4a-f                      10005
 *    1.0.5 (+ 2 patches)           10005
 *    1.0.5a-d                      10006
 *    1.0.5e-r                      10100 (not source compatible)
 *    1.0.5s-v                      10006 (not binary compatible)
 *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)
 *    1.0.6d-f                      10007 (still binary incompatible)
 *    1.0.6g                        10007
 *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)
 *    1.0.6i                        10007  10.6i
 *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)
 *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)
 *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)
 *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)
 *    1.0.7                    1    10007  (still compatible)
 *    ...
 *    1.0.19                  10    10019  10.so.0.19[.0]
 *    ...
 *    1.2.57                  13    10257  12.so.0.57[.0]
 *    ...
 *    1.5.28                  15    10527  15.so.15.28[.0]
 *    ...
 *    1.6.28                  16    10628  16.so.16.28[.0]
 *
 *    Henceforth the source version will match the shared-library major
 *    and minor numbers; the shared-library major version number will be
 *    used for changes in backward compatibility, as it is intended.  The
 *    PNG_LIBPNG_VER macro, which is not used within libpng but is available
 *    for applications, is an unsigned integer of the form xyyzz corresponding
 *    to the source version x.y.z (leading zeros in y and z).  Beta versions
 *    were given the previous public release number plus a letter, until
 *    version 1.0.6j; from then on they were given the upcoming public
 *    release number plus "betaNN" or "rcNN".
 *
 *    Binary incompatibility exists only when applications make direct access
 *    to the info_ptr or png_ptr members through png.h, and the compiled
 *    application is loaded with a different version of the library.
 *
 *    DLLNUM will change each time there are forward or backward changes
 *    in binary compatibility (e.g., when a new feature is added).
 *
 * See libpng.txt or libpng.3 for more information.  The PNG specification
 * is available as a W3C Recommendation and as an ISO Specification,
 * <http://www.w3.org/TR/2003/REC-PNG-20031110/
 */

/*
 * Y2K compliance in libpng:
 * =========================
 *
 *    January 5, 2017
 *
 *    Since the PNG Development group is an ad-hoc body, we can't make
 *    an official declaration.
 *
 *    This is your unofficial assurance that libpng from version 0.71 and
 *    upward through 1.6.28 are Y2K compliant.  It is my belief that
 *    earlier versions were also Y2K compliant.
 *
 *    Libpng only has two year fields.  One is a 2-byte unsigned integer
 *    that will hold years up to 65535.  The other, which is deprecated,
 *    holds the date in text format, and will hold years up to 9999.
 *
 *    The integer is
 *        "png_uint_16 year" in png_time_struct.
 *
 *    The string is
 *        "char time_buffer[29]" in png_struct.  This is no longer used
 *    in libpng-1.6.x and will be removed from libpng-1.7.0.
 *
 *    There are seven time-related functions:
 *        png.c: png_convert_to_rfc_1123_buffer() in png.c
 *          (formerly png_convert_to_rfc_1123() prior to libpng-1.5.x and
 *          png_convert_to_rfc_1152() in error prior to libpng-0.98)
 *        png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c
 *        png_convert_from_time_t() in pngwrite.c
 *        png_get_tIME() in pngget.c
 *        png_handle_tIME() in pngrutil.c, called in pngread.c
 *        png_set_tIME() in pngset.c
 *        png_write_tIME() in pngwutil.c, called in pngwrite.c
 *
 *    All handle dates properly in a Y2K environment.  The
 *    png_convert_from_time_t() function calls gmtime() to convert from system
 *    clock time, which returns (year - 1900), which we properly convert to
 *    the full 4-digit year.  There is a possibility that libpng applications
 *    are not passing 4-digit years into the png_convert_to_rfc_1123_buffer()
 *    function, or that they are incorrectly passing only a 2-digit year
 *    instead of "year - 1900" into the png_convert_from_struct_tm() function,
 *    but this is not under our control.  The libpng documentation has always
 *    stated that it works with 4-digit years, and the APIs have been
 *    documented as such.
 *
 *    The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
 *    integer to hold the year, and can hold years as large as 65535.
 *
 *    zlib, upon which libpng depends, is also Y2K compliant.  It contains
 *    no date-related code.
 *
 *       Glenn Randers-Pehrson
 *       libpng maintainer
 *       PNG Development Group
 */

#ifndef PNG_H
#define PNG_H

/* This is not the place to learn how to use libpng. The file libpng-manual.txt
 * describes how to use libpng, and the file example.c summarizes it
 * with some code on which to build.  This file is useful for looking
 * at the actual function definitions and structure components.  If that
 * file has been stripped from your copy of libpng, you can find it at
 * <http://www.libpng.org/pub/png/libpng-manual.txt>
 *
 * If you just need to read a PNG file and don't want to read the documentation
 * skip to the end of this file and read the section entitled 'simplified API'.
 */

/* Version information for png.h - this should match the version in png.c */
#define PNG_LIBPNG_VER_STRING "1.6.28"
#define PNG_HEADER_VERSION_STRING " libpng version 1.6.28 - January 5, 2017\n"

#define PNG_LIBPNG_VER_SONUM   16
#define PNG_LIBPNG_VER_DLLNUM  16

/* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
#define PNG_LIBPNG_VER_MAJOR   1
#define PNG_LIBPNG_VER_MINOR   6
#define PNG_LIBPNG_VER_RELEASE 28

/* This should match the numeric part of the final component of
 * PNG_LIBPNG_VER_STRING, omitting any leading zero:
 */

#define PNG_LIBPNG_VER_BUILD  0

/* Release Status */
#define PNG_LIBPNG_BUILD_ALPHA    1
#define PNG_LIBPNG_BUILD_BETA     2
#define PNG_LIBPNG_BUILD_RC       3
#define PNG_LIBPNG_BUILD_STABLE   4
#define PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK 7

/* Release-Specific Flags */
#define PNG_LIBPNG_BUILD_PATCH    8 /* Can be OR'ed with
                                       PNG_LIBPNG_BUILD_STABLE only */
#define PNG_LIBPNG_BUILD_PRIVATE 16 /* Cannot be OR'ed with
                                       PNG_LIBPNG_BUILD_SPECIAL */
#define PNG_LIBPNG_BUILD_SPECIAL 32 /* Cannot be OR'ed with
                                       PNG_LIBPNG_BUILD_PRIVATE */

#define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_STABLE

/* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
 * We must not include leading zeros.
 * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
 * version 1.0.0 was mis-numbered 100 instead of 10000).  From
 * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
 */
#define PNG_LIBPNG_VER 10628 /* 1.6.28 */

/* Library configuration: these options cannot be changed after
 * the library has been built.
 */
#ifndef PNGLCONF_H
/* If pnglibconf.h is missing, you can
 * copy scripts/pnglibconf.h.prebuilt to pnglibconf.h
 */
#   include "pnglibconf.h"
#endif

#ifndef PNG_VERSION_INFO_ONLY
/* Machine specific configuration. */
#  include "pngconf.h"
#endif

/*
 * Added at libpng-1.2.8
 *
 * Ref MSDN: Private as priority over Special
 * VS_FF_PRIVATEBUILD File *was not* built using standard release
 * procedures. If this value is given, the StringFileInfo block must
 * contain a PrivateBuild string.
 *
 * VS_FF_SPECIALBUILD File *was* built by the original company using
 * standard release procedures but is a variation of the standard
 * file of the same version number. If this value is given, the
 * StringFileInfo block must contain a SpecialBuild string.
 */

#ifdef PNG_USER_PRIVATEBUILD /* From pnglibconf.h */
#  define PNG_LIBPNG_BUILD_TYPE \
       (PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_PRIVATE)
#else
#  ifdef PNG_LIBPNG_SPECIALBUILD
#    define PNG_LIBPNG_BUILD_TYPE \
         (PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_SPECIAL)
#  else
#    define PNG_LIBPNG_BUILD_TYPE (PNG_LIBPNG_BUILD_BASE_TYPE)
#  endif
#endif

#ifndef PNG_VERSION_INFO_ONLY

/* Inhibit C++ name-mangling for libpng functions but not for system calls. */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* Version information for C files, stored in png.c.  This had better match
 * the version above.
 */
#define png_libpng_ver png_get_header_ver(NULL)

/* This file is arranged in several sections:
 *
 * 1. [omitted]
 * 2. Any configuration options that can be specified by for the application
 *    code when it is built.  (Build time configuration is in pnglibconf.h)
 * 3. Type definitions (base types are defined in pngconf.h), structure
 *    definitions.
 * 4. Exported library functions.
 * 5. Simplified API.
 * 6. Implementation options.
 *
 * The library source code has additional files (principally pngpriv.h) that
 * allow configuration of the library.
 */

/* Section 1: [omitted] */

/* Section 2: run time configuration
 * See pnglibconf.h for build time configuration
 *
 * Run time configuration allows the application to choose between
 * implementations of certain arithmetic APIs.  The default is set
 * at build time and recorded in pnglibconf.h, but it is safe to
 * override these (and only these) settings.  Note that this won't
 * change what the library does, only application code, and the
 * settings can (and probably should) be made on a per-file basis
 * by setting the #defines before including png.h
 *
 * Use macros to read integers from PNG data or use the exported
 * functions?
 *   PNG_USE_READ_MACROS: use the macros (see below)  Note that
 *     the macros evaluate their argument multiple times.
 *   PNG_NO_USE_READ_MACROS: call the relevant library function.
 *
 * Use the alternative algorithm for compositing alpha samples that
 * does not use division?
 *   PNG_READ_COMPOSITE_NODIV_SUPPORTED: use the 'no division'
 *      algorithm.
 *   PNG_NO_READ_COMPOSITE_NODIV: use the 'division' algorithm.
 *
 * How to handle benign errors if PNG_ALLOW_BENIGN_ERRORS is
 * false?
 *   PNG_ALLOW_BENIGN_ERRORS: map calls to the benign error
 *      APIs to png_warning.
 * Otherwise the calls are mapped to png_error.
 */

/* Section 3: type definitions, including structures and compile time
 * constants.
 * See pngconf.h for base types that vary by machine/system
 */

/* This triggers a compiler error in png.c, if png.c and png.h
 * do not agree upon the version number.
 */
typedef char* png_libpng_version_1_6_28;

/* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.
 *
 * png_struct is the cache of information used while reading or writing a single
 * PNG file.  One of these is always required, although the simplified API
 * (below) hides the creation and destruction of it.
 */
typedef struct png_struct_def png_struct;
typedef const png_struct * png_const_structp;
typedef png_struct * png_structp;
typedef png_struct * * png_structpp;

/* png_info contains information read from or to be written to a PNG file.  One
 * or more of these must exist while reading or creating a PNG file.  The
 * information is not used by libpng during read but is used to control what
 * gets written when a PNG file is created.  "png_get_" function calls read
 * information during read and "png_set_" functions calls write information
 * when creating a PNG.
 * been moved into a separate header file that is not accessible to
 * applications.  Read libpng-manual.txt or libpng.3 for more info.
 */
typedef struct png_info_def png_info;
typedef png_info * png_infop;
typedef const png_info * png_const_infop;
typedef png_info * * png_infopp;

/* Types with names ending 'p' are pointer types.  The corresponding types with
 * names ending 'rp' are identical pointer types except that the pointer is
 * marked 'restrict', which means that it is the only pointer to the object
 * passed to the function.  Applications should not use the 'restrict' types;
 * it is always valid to pass 'p' to a pointer with a function argument of the
 * corresponding 'rp' type.  Different compilers have different rules with
 * regard to type matching in the presence of 'restrict'.  For backward
 * compatibility libpng callbacks never have 'restrict' in their parameters and,
 * consequentially, writing portable application code is extremely difficult if
 * an attempt is made to use 'restrict'.
 */
typedef png_struct * PNG_RESTRICT png_structrp;
typedef const png_struct * PNG_RESTRICT png_const_structrp;
typedef png_info * PNG_RESTRICT png_inforp;
typedef const png_info * PNG_RESTRICT png_const_inforp;

/* Three color definitions.  The order of the red, green, and blue, (and the
 * exact size) is not important, although the size of the fields need to
 * be png_byte or png_uint_16 (as defined below).
 */
typedef struct png_color_struct
{
   png_byte red;
   png_byte green;
   png_byte blue;
} png_color;
typedef png_color * png_colorp;
typedef const png_color * png_const_colorp;
typedef png_color * * png_colorpp;

typedef struct png_color_16_struct
{
   png_byte index;    /* used for palette files */
   png_uint_16 red;   /* for use in red green blue files */
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 gray;  /* for use in grayscale files */
} png_color_16;
typedef png_color_16 * png_color_16p;
typedef const png_color_16 * png_const_color_16p;
typedef png_color_16 * * png_color_16pp;

typedef struct png_color_8_struct
{
   png_byte red;   /* for use in red green blue files */
   png_byte green;
   png_byte blue;
   png_byte gray;  /* for use in grayscale files */
   png_byte alpha; /* for alpha channel files */
} png_color_8;
typedef png_color_8 * png_color_8p;
typedef const png_color_8 * png_const_color_8p;
typedef png_color_8 * * png_color_8pp;

/*
 * The following two structures are used for the in-core representation
 * of sPLT chunks.
 */
typedef struct png_sPLT_entry_struct
{
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 alpha;
   png_uint_16 frequency;
} png_sPLT_entry;
typedef png_sPLT_entry * png_sPLT_entryp;
typedef const png_sPLT_entry * png_const_sPLT_entryp;
typedef png_sPLT_entry * * png_sPLT_entrypp;

/*  When the depth of the sPLT palette is 8 bits, the color and alpha samples
 *  occupy the LSB of their respective members, and the MSB of each member
 *  is zero-filled.  The frequency member always occupies the full 16 bits.
 */

typedef struct png_sPLT_struct
{
   png_charp name;           /* palette name */
   png_byte depth;           /* depth of palette samples */
   png_sPLT_entryp entries;  /* palette entries */
   png_int_32 nentries;      /* number of palette entries */
} png_sPLT_t;
typedef png_sPLT_t * png_sPLT_tp;
typedef const png_sPLT_t * png_const_sPLT_tp;
typedef png_sPLT_t * * png_sPLT_tpp;

#ifdef PNG_TEXT_SUPPORTED
/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,
 * and whether that contents is compressed or not.  The "key" field
 * points to a regular zero-terminated C string.  The "text" fields can be a
 * regular C string, an empty string, or a NULL pointer.
 * However, the structure returned by png_get_text() will always contain
 * the "text" field as a regular zero-terminated C string (possibly
 * empty), never a NULL pointer, so it can be safely used in printf() and
 * other string-handling functions.  Note that the "itxt_length", "lang", and
 * "lang_key" members of the structure only exist when the library is built
 * with iTXt chunk support.  Prior to libpng-1.4.0 the library was built by
 * default without iTXt support. Also note that when iTXt *is* supported,
 * the "lang" and "lang_key" fields contain NULL pointers when the
 * "compression" field contains * PNG_TEXT_COMPRESSION_NONE or
 * PNG_TEXT_COMPRESSION_zTXt. Note that the "compression value" is not the
 * same as what appears in the PNG tEXt/zTXt/iTXt chunk's "compression flag"
 * which is always 0 or 1, or its "compression method" which is always 0.
 */
typedef struct png_text_struct
{
   int  compression;       /* compression value:
                             -1: tEXt, none
                              0: zTXt, deflate
                              1: iTXt, none
                              2: iTXt, deflate  */
   png_charp key;          /* keyword, 1-79 character description of "text" */
   png_charp text;         /* comment, may be an empty string (ie "")
                              or a NULL pointer */
   png_size_t text_length; /* length of the text string */
   png_size_t itxt_length; /* length of the itxt string */
   png_charp lang;         /* language code, 0-79 characters
                              or a NULL pointer */
   png_charp lang_key;     /* keyword translated UTF-8 string, 0 or more
                              chars or a NULL pointer */
} png_text;
typedef png_text * png_textp;
typedef const png_text * png_const_textp;
typedef png_text * * png_textpp;
#endif

/* Supported compression types for text in PNG files (tEXt, and zTXt).
 * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed. */
#define PNG_TEXT_COMPRESSION_NONE_WR -3
#define PNG_TEXT_COMPRESSION_zTXt_WR -2
#define PNG_TEXT_COMPRESSION_NONE    -1
#define PNG_TEXT_COMPRESSION_zTXt     0
#define PNG_ITXT_COMPRESSION_NONE     1
#define PNG_ITXT_COMPRESSION_zTXt     2
#define PNG_TEXT_COMPRESSION_LAST     3  /* Not a valid value */

/* png_time is a way to hold the time in an machine independent way.
 * Two conversions are provided, both from time_t and struct tm.  There
 * is no portable way to convert to either of these structures, as far
 * as I know.  If you know of a portable way, send it to me.  As a side
 * note - PNG has always been Year 2000 compliant!
 */
typedef struct png_time_struct
{
   png_uint_16 year; /* full year, as in, 1995 */
   png_byte month;   /* month of year, 1 - 12 */
   png_byte day;     /* day of month, 1 - 31 */
   png_byte hour;    /* hour of day, 0 - 23 */
   png_byte minute;  /* minute of hour, 0 - 59 */
   png_byte second;  /* second of minute, 0 - 60 (for leap seconds) */
} png_time;
typedef png_time * png_timep;
typedef const png_time * png_const_timep;
typedef png_time * * png_timepp;

#if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) ||\
   defined(PNG_USER_CHUNKS_SUPPORTED)
/* png_unknown_chunk is a structure to hold queued chunks for which there is
 * no specific support.  The idea is that we can use this to queue
 * up private chunks for output even though the library doesn't actually
 * know about their semantics.
 *
 * The data in the structure is set by libpng on read and used on write.
 */
typedef struct png_unknown_chunk_t
{
   png_byte name[5]; /* Textual chunk name with '\0' terminator */
   png_byte *data;   /* Data, should not be modified on read! */
   png_size_t size;

   /* On write 'location' must be set using the flag values listed below.
    * Notice that on read it is set by libpng however the values stored have
    * more bits set than are listed below.  Always treat the value as a
    * bitmask.  On write set only one bit - setting multiple bits may cause the
    * chunk to be written in multiple places.
    */
   png_byte location; /* mode of operation at read time */
}
png_unknown_chunk;

typedef png_unknown_chunk * png_unknown_chunkp;
typedef const png_unknown_chunk * png_const_unknown_chunkp;
typedef png_unknown_chunk * * png_unknown_chunkpp;
#endif

/* Flag values for the unknown chunk location byte. */
#define PNG_HAVE_IHDR  0x01
#define PNG_HAVE_PLTE  0x02
#define PNG_AFTER_IDAT 0x08

/* Maximum positive integer used in PNG is (2^31)-1 */
#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
#define PNG_UINT_32_MAX ((png_uint_32)(-1))
#define PNG_SIZE_MAX ((png_size_t)(-1))

/* These are constants for fixed point values encoded in the
 * PNG specification manner (x100000)
 */
#define PNG_FP_1    100000
#define PNG_FP_HALF  50000
#define PNG_FP_MAX  ((png_fixed_point)0x7fffffffL)
#define PNG_FP_MIN  (-PNG_FP_MAX)

/* These describe the color_type field in png_info. */
/* color type masks */
#define PNG_COLOR_MASK_PALETTE    1
#define PNG_COLOR_MASK_COLOR      2
#define PNG_COLOR_MASK_ALPHA      4

/* color types.  Note that not all combinations are legal */
#define PNG_COLOR_TYPE_GRAY 0
#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
/* aliases */
#define PNG_COLOR_TYPE_RGBA  PNG_COLOR_TYPE_RGB_ALPHA
#define PNG_COLOR_TYPE_GA  PNG_COLOR_TYPE_GRAY_ALPHA

/* This is for compression type. PNG 1.0-1.2 only define the single type. */
#define PNG_COMPRESSION_TYPE_BASE 0 /* Deflate method 8, 32K window */
#define PNG_COMPRESSION_TYPE_DEFAULT PNG_COMPRESSION_TYPE_BASE

/* This is for filter type. PNG 1.0-1.2 only define the single type. */
#define PNG_FILTER_TYPE_BASE      0 /* Single row per-byte filtering */
#define PNG_INTRAPIXEL_DIFFERENCING 64 /* Used only in MNG datastreams */
#define PNG_FILTER_TYPE_DEFAULT   PNG_FILTER_TYPE_BASE

/* These are for the interlacing type.  These values should NOT be changed. */
#define PNG_INTERLACE_NONE        0 /* Non-interlaced image */
#define PNG_INTERLACE_ADAM7       1 /* Adam7 interlacing */
#define PNG_INTERLACE_LAST        2 /* Not a valid value */

/* These are for the oFFs chunk.  These values should NOT be changed. */
#define PNG_OFFSET_PIXEL          0 /* Offset in pixels */
#define PNG_OFFSET_MICROMETER     1 /* Offset in micrometers (1/10^6 meter) */
#define PNG_OFFSET_LAST           2 /* Not a valid value */

/* These are for the pCAL chunk.  These values should NOT be changed. */
#define PNG_EQUATION_LINEAR       0 /* Linear transformation */
#define PNG_EQUATION_BASE_E       1 /* Exponential base e transform */
#define PNG_EQUATION_ARBITRARY    2 /* Arbitrary base exponential transform */
#define PNG_EQUATION_HYPERBOLIC   3 /* Hyperbolic sine transformation */
#define PNG_EQUATION_LAST         4 /* Not a valid value */

/* These are for the sCAL chunk.  These values should NOT be changed. */
#define PNG_SCALE_UNKNOWN         0 /* unknown unit (image scale) */
#define PNG_SCALE_METER           1 /* meters per pixel */
#define PNG_SCALE_RADIAN          2 /* radians per pixel */
#define PNG_SCALE_LAST            3 /* Not a valid value */

/* These are for the pHYs chunk.  These values should NOT be changed. */
#define PNG_RESOLUTION_UNKNOWN    0 /* pixels/unknown unit (aspect ratio) */
#define PNG_RESOLUTION_METER      1 /* pixels/meter */
#define PNG_RESOLUTION_LAST       2 /* Not a valid value */

/* These are for the sRGB chunk.  These values should NOT be changed. */
#define PNG_sRGB_INTENT_PERCEPTUAL 0
#define PNG_sRGB_INTENT_RELATIVE   1
#define PNG_sRGB_INTENT_SATURATION 2
#define PNG_sRGB_INTENT_ABSOLUTE   3
#define PNG_sRGB_INTENT_LAST       4 /* Not a valid value */

/* This is for text chunks */
#define PNG_KEYWORD_MAX_LENGTH     79

/* Maximum number of entries in PLTE/sPLT/tRNS arrays */
#define PNG_MAX_PALETTE_LENGTH    256

/* These determine if an ancillary chunk's data has been successfully read
 * from the PNG header, or if the application has filled in the corresponding
 * data in the info_struct to be written into the output file.  The values
 * of the PNG_INFO_<chunk> defines should NOT be changed.
 */
#define PNG_INFO_gAMA 0x0001U
#define PNG_INFO_sBIT 0x0002U
#define PNG_INFO_cHRM 0x0004U
#define PNG_INFO_PLTE 0x0008U
#define PNG_INFO_tRNS 0x0010U
#define PNG_INFO_bKGD 0x0020U
#define PNG_INFO_hIST 0x0040U
#define PNG_INFO_pHYs 0x0080U
#define PNG_INFO_oFFs 0x0100U
#define PNG_INFO_tIME 0x0200U
#define PNG_INFO_pCAL 0x0400U
#define PNG_INFO_sRGB 0x0800U  /* GR-P, 0.96a */
#define PNG_INFO_iCCP 0x1000U  /* ESR, 1.0.6 */
#define PNG_INFO_sPLT 0x2000U  /* ESR, 1.0.6 */
#define PNG_INFO_sCAL 0x4000U  /* ESR, 1.0.6 */
#define PNG_INFO_IDAT 0x8000U  /* ESR, 1.0.6 */

/* This is used for the transformation routines, as some of them
 * change these values for the row.  It also should enable using
 * the routines for other purposes.
 */
typedef struct png_row_info_struct
{
   png_uint_32 width;    /* width of row */
   png_size_t rowbytes;  /* number of bytes in row */
   png_byte color_type;  /* color type of row */
   png_byte bit_depth;   /* bit depth of row */
   png_byte channels;    /* number of channels (1, 2, 3, or 4) */
   png_byte pixel_depth; /* bits per pixel (depth * channels) */
} png_row_info;

typedef png_row_info * png_row_infop;
typedef png_row_info * * png_row_infopp;

/* These are the function types for the I/O functions and for the functions
 * that allow the user to override the default I/O functions with his or her
 * own.  The png_error_ptr type should match that of user-supplied warning
 * and error functions, while the png_rw_ptr type should match that of the
 * user read/write data functions.  Note that the 'write' function must not
 * modify the buffer it is passed. The 'read' function, on the other hand, is
 * expected to return the read data in the buffer.
 */
typedef PNG_CALLBACK(void, *png_error_ptr, (png_structp, png_const_charp));
typedef PNG_CALLBACK(void, *png_rw_ptr, (png_structp, png_bytep, png_size_t));
typedef PNG_CALLBACK(void, *png_flush_ptr, (png_structp));
typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32,
    int));
typedef PNG_CALLBACK(void, *png_write_status_ptr, (png_structp, png_uint_32,
    int));

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
typedef PNG_CALLBACK(void, *png_progressive_info_ptr, (png_structp, png_infop));
typedef PNG_CALLBACK(void, *png_progressive_end_ptr, (png_structp, png_infop));

/* The following callback receives png_uint_32 row_number, int pass for the
 * png_bytep data of the row.  When transforming an interlaced image the
 * row number is the row number within the sub-image of the interlace pass, so
 * the value will increase to the height of the sub-image (not the full image)
 * then reset to 0 for the next pass.
 *
 * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
 * find the output pixel (x,y) given an interlaced sub-image pixel
 * (row,col,pass).  (See below for these macros.)
 */
typedef PNG_CALLBACK(void, *png_progressive_row_ptr, (png_structp, png_bytep,
    png_uint_32, int));
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
typedef PNG_CALLBACK(void, *png_user_transform_ptr, (png_structp, png_row_infop,
    png_bytep));
#endif

#ifdef PNG_USER_CHUNKS_SUPPORTED
typedef PNG_CALLBACK(int, *png_user_chunk_ptr, (png_structp,
    png_unknown_chunkp));
#endif
#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
/* not used anywhere */
/* typedef PNG_CALLBACK(void, *png_unknown_chunk_ptr, (png_structp)); */
#endif

#ifdef PNG_SETJMP_SUPPORTED
/* This must match the function definition in <setjmp.h>, and the application
 * must include this before png.h to obtain the definition of jmp_buf.  The
 * function is required to be PNG_NORETURN, but this is not checked.  If the
 * function does return the application will crash via an abort() or similar
 * system level call.
 *
 * If you get a warning here while building the library you may need to make
 * changes to ensure that pnglibconf.h records the calling convention used by
 * your compiler.  This may be very difficult - try using a different compiler
 * to build the library!
 */
PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), PNGARG((jmp_buf, int)), typedef);
#endif

/* Transform masks for the high-level interface */
#define PNG_TRANSFORM_IDENTITY       0x0000    /* read and write */
#define PNG_TRANSFORM_STRIP_16       0x0001    /* read only */
#define PNG_TRANSFORM_STRIP_ALPHA    0x0002    /* read only */
#define PNG_TRANSFORM_PACKING        0x0004    /* read and write */
#define PNG_TRANSFORM_PACKSWAP       0x0008    /* read and write */
#define PNG_TRANSFORM_EXPAND         0x0010    /* read only */
#define PNG_TRANSFORM_INVERT_MONO    0x0020    /* read and write */
#define PNG_TRANSFORM_SHIFT          0x0040    /* read and write */
#define PNG_TRANSFORM_BGR            0x0080    /* read and write */
#define PNG_TRANSFORM_SWAP_ALPHA     0x0100    /* read and write */
#define PNG_TRANSFORM_SWAP_ENDIAN    0x0200    /* read and write */
#define PNG_TRANSFORM_INVERT_ALPHA   0x0400    /* read and write */
#define PNG_TRANSFORM_STRIP_FILLER   0x0800    /* write only */
/* Added to libpng-1.2.34 */
#define PNG_TRANSFORM_STRIP_FILLER_BEFORE PNG_TRANSFORM_STRIP_FILLER
#define PNG_TRANSFORM_STRIP_FILLER_AFTER 0x1000 /* write only */
/* Added to libpng-1.4.0 */
#define PNG_TRANSFORM_GRAY_TO_RGB   0x2000      /* read only */
/* Added to libpng-1.5.4 */
#define PNG_TRANSFORM_EXPAND_16     0x4000      /* read only */
#if INT_MAX >= 0x8000 /* else this might break */
#define PNG_TRANSFORM_SCALE_16      0x8000      /* read only */
#endif

/* Flags for MNG supported features */
#define PNG_FLAG_MNG_EMPTY_PLTE     0x01
#define PNG_FLAG_MNG_FILTER_64      0x04
#define PNG_ALL_MNG_FEATURES        0x05

/* NOTE: prior to 1.5 these functions had no 'API' style declaration,
 * this allowed the zlib default functions to be used on Windows
 * platforms.  In 1.5 the zlib default malloc (which just calls malloc and
 * ignores the first argument) should be completely compatible with the
 * following.
 */
typedef PNG_CALLBACK(png_voidp, *png_malloc_ptr, (png_structp,
    png_alloc_size_t));
typedef PNG_CALLBACK(void, *png_free_ptr, (png_structp, png_voidp));

/* Section 4: exported functions
 * Here are the function definitions most commonly used.  This is not
 * the place to find out how to use libpng.  See libpng-manual.txt for the
 * full explanation, see example.c for the summary.  This just provides
 * a simple one line description of the use of each function.
 *
 * The PNG_EXPORT() and PNG_EXPORTA() macros used below are defined in
 * pngconf.h and in the *.dfn files in the scripts directory.
 *
 *   PNG_EXPORT(ordinal, type, name, (args));
 *
 *       ordinal:    ordinal that is used while building
 *                   *.def files. The ordinal value is only
 *                   relevant when preprocessing png.h with
 *                   the *.dfn files for building symbol table
 *                   entries, and are removed by pngconf.h.
 *       type:       return type of the function
 *       name:       function name
 *       args:       function arguments, with types
 *
 * When we wish to append attributes to a function prototype we use
 * the PNG_EXPORTA() macro instead.
 *
 *   PNG_EXPORTA(ordinal, type, name, (args), attributes);
 *
 *       ordinal, type, name, and args: same as in PNG_EXPORT().
 *       attributes: function attributes
 */

/* Returns the version number of the library */
PNG_EXPORT(1, png_uint_32, png_access_version_number, (void));

/* Tell lib we have already handled the first <num_bytes> magic bytes.
 * Handling more than 8 bytes from the beginning of the file is an error.
 */
PNG_EXPORT(2, void, png_set_sig_bytes, (png_structrp png_ptr, int num_bytes));

/* Check sig[start] through sig[start + num_to_check - 1] to see if it's a
 * PNG file.  Returns zero if the supplied bytes match the 8-byte PNG
 * signature, and non-zero otherwise.  Having num_to_check == 0 or
 * start > 7 will always fail (ie return non-zero).
 */
PNG_EXPORT(3, int, png_sig_cmp, (png_const_bytep sig, png_size_t start,
    png_size_t num_to_check));

/* Simple signature checking function.  This is the same as calling
 * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).
 */
#define png_check_sig(sig, n) !png_sig_cmp((sig), 0, (n))

/* Allocate and initialize png_ptr struct for reading, and any other memory. */
PNG_EXPORTA(4, png_structp, png_create_read_struct,
    (png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn),
    PNG_ALLOCATED);

/* Allocate and initialize png_ptr struct for writing, and any other memory */
PNG_EXPORTA(5, png_structp, png_create_write_struct,
    (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn),
    PNG_ALLOCATED);

PNG_EXPORT(6, png_size_t, png_get_compression_buffer_size,
    (png_const_structrp png_ptr));

PNG_EXPORT(7, void, png_set_compression_buffer_size, (png_structrp png_ptr,
    png_size_t size));

/* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp
 * match up.
 */
#ifdef PNG_SETJMP_SUPPORTED
/* This function returns the jmp_buf built in to *png_ptr.  It must be
 * supplied with an appropriate 'longjmp' function to use on that jmp_buf
 * unless the default error function is overridden in which case NULL is
 * acceptable.  The size of the jmp_buf is checked against the actual size
 * allocated by the library - the call will return NULL on a mismatch
 * indicating an ABI mismatch.
 */
PNG_EXPORT(8, jmp_buf*, png_set_longjmp_fn, (png_structrp png_ptr,
    png_longjmp_ptr longjmp_fn, size_t jmp_buf_size));
#  define png_jmpbuf(png_ptr) \
      (*png_set_longjmp_fn((png_ptr), longjmp, (sizeof (jmp_buf))))
#else
#  define png_jmpbuf(png_ptr) \
      (LIBPNG_WAS_COMPILED_WITH__PNG_NO_SETJMP)
#endif
/* This function should be used by libpng applications in place of
 * longjmp(png_ptr->jmpbuf, val).  If longjmp_fn() has been set, it
 * will use it; otherwise it will call PNG_ABORT().  This function was
 * added in libpng-1.5.0.
 */
PNG_EXPORTA(9, void, png_longjmp, (png_const_structrp png_ptr, int val),
    PNG_NORETURN);

#ifdef PNG_READ_SUPPORTED
/* Reset the compression stream */
PNG_EXPORTA(10, int, png_reset_zstream, (png_structrp png_ptr), PNG_DEPRECATED);
#endif

/* New functions added in libpng-1.0.2 (not enabled by default until 1.2.0) */
#ifdef PNG_USER_MEM_SUPPORTED
PNG_EXPORTA(11, png_structp, png_create_read_struct_2,
    (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn,
    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn),
    PNG_ALLOCATED);
PNG_EXPORTA(12, png_structp, png_create_write_struct_2,
    (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn,
    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn),
    PNG_ALLOCATED);
#endif

/* Write the PNG file signature. */
PNG_EXPORT(13, void, png_write_sig, (png_structrp png_ptr));

/* Write a PNG chunk - size, type, (optional) data, CRC. */
PNG_EXPORT(14, void, png_write_chunk, (png_structrp png_ptr, png_const_bytep
    chunk_name, png_const_bytep data, png_size_t length));

/* Write the start of a PNG chunk - length and chunk name. */
PNG_EXPORT(15, void, png_write_chunk_start, (png_structrp png_ptr,
    png_const_bytep chunk_name, png_uint_32 length));

/* Write the data of a PNG chunk started with png_write_chunk_start(). */
PNG_EXPORT(16, void, png_write_chunk_data, (png_structrp png_ptr,
    png_const_bytep data, png_size_t length));

/* Finish a chunk started with png_write_chunk_start() (includes CRC). */
PNG_EXPORT(17, void, png_write_chunk_end, (png_structrp png_ptr));

/* Allocate and initialize the info structure */
PNG_EXPORTA(18, png_infop, png_create_info_struct, (png_const_structrp png_ptr),
    PNG_ALLOCATED);

/* DEPRECATED: this function allowed init structures to be created using the
 * default allocation method (typically malloc).  Use is deprecated in 1.6.0 and
 * the API will be removed in the future.
 */
PNG_EXPORTA(19, void, png_info_init_3, (png_infopp info_ptr,
    png_size_t png_info_struct_size), PNG_DEPRECATED);

/* Writes all the PNG information before the image. */
PNG_EXPORT(20, void, png_write_info_before_PLTE,
    (png_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(21, void, png_write_info,
    (png_structrp png_ptr, png_const_inforp info_ptr));

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the information before the actual image data. */
PNG_EXPORT(22, void, png_read_info,
    (png_structrp png_ptr, png_inforp info_ptr));
#endif

#ifdef PNG_TIME_RFC1123_SUPPORTED
   /* Convert to a US string format: there is no localization support in this
    * routine.  The original implementation used a 29 character buffer in
    * png_struct, this will be removed in future versions.
    */
#if PNG_LIBPNG_VER < 10700
/* To do: remove this from libpng17 (and from libpng17/png.c and pngstruct.h) */
PNG_EXPORTA(23, png_const_charp, png_convert_to_rfc1123, (png_structrp png_ptr,
    png_const_timep ptime),PNG_DEPRECATED);
#endif
PNG_EXPORT(241, int, png_convert_to_rfc1123_buffer, (char out[29],
    png_const_timep ptime));
#endif

#ifdef PNG_CONVERT_tIME_SUPPORTED
/* Convert from a struct tm to png_time */
PNG_EXPORT(24, void, png_convert_from_struct_tm, (png_timep ptime,
    const struct tm * ttime));

/* Convert from time_t to png_time.  Uses gmtime() */
PNG_EXPORT(25, void, png_convert_from_time_t, (png_timep ptime, time_t ttime));
#endif /* CONVERT_tIME */

#ifdef PNG_READ_EXPAND_SUPPORTED
/* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */
PNG_EXPORT(26, void, png_set_expand, (png_structrp png_ptr));
PNG_EXPORT(27, void, png_set_expand_gray_1_2_4_to_8, (png_structrp png_ptr));
PNG_EXPORT(28, void, png_set_palette_to_rgb, (png_structrp png_ptr));
PNG_EXPORT(29, void, png_set_tRNS_to_alpha, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_EXPAND_16_SUPPORTED
/* Expand to 16-bit channels, forces conversion of palette to RGB and expansion
 * of a tRNS chunk if present.
 */
PNG_EXPORT(221, void, png_set_expand_16, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
/* Use blue, green, red order for pixels. */
PNG_EXPORT(30, void, png_set_bgr, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
/* Expand the grayscale to 24-bit RGB if necessary. */
PNG_EXPORT(31, void, png_set_gray_to_rgb, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
/* Reduce RGB to grayscale. */
#define PNG_ERROR_ACTION_NONE  1
#define PNG_ERROR_ACTION_WARN  2
#define PNG_ERROR_ACTION_ERROR 3
#define PNG_RGB_TO_GRAY_DEFAULT (-1)/*for red/green coefficients*/

PNG_FP_EXPORT(32, void, png_set_rgb_to_gray, (png_structrp png_ptr,
    int error_action, double red, double green))
PNG_FIXED_EXPORT(33, void, png_set_rgb_to_gray_fixed, (png_structrp png_ptr,
    int error_action, png_fixed_point red, png_fixed_point green))

PNG_EXPORT(34, png_byte, png_get_rgb_to_gray_status, (png_const_structrp
    png_ptr));
#endif

#ifdef PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
PNG_EXPORT(35, void, png_build_grayscale_palette, (int bit_depth,
    png_colorp palette));
#endif

#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
/* How the alpha channel is interpreted - this affects how the color channels
 * of a PNG file are returned to the calling application when an alpha channel,
 * or a tRNS chunk in a palette file, is present.
 *
 * This has no effect on the way pixels are written into a PNG output
 * datastream. The color samples in a PNG datastream are never premultiplied
 * with the alpha samples.
 *
 * The default is to return data according to the PNG specification: the alpha
 * channel is a linear measure of the contribution of the pixel to the
 * corresponding composited pixel, and the color channels are unassociated
 * (not premultiplied).  The gamma encoded color channels must be scaled
 * according to the contribution and to do this it is necessary to undo
 * the encoding, scale the color values, perform the composition and reencode
 * the values.  This is the 'PNG' mode.
 *
 * The alternative is to 'associate' the alpha with the color information by
 * storing color channel values that have been scaled by the alpha.
 * image.  These are the 'STANDARD', 'ASSOCIATED' or 'PREMULTIPLIED' modes
 * (the latter being the two common names for associated alpha color channels).
 *
 * For the 'OPTIMIZED' mode, a pixel is treated as opaque only if the alpha
 * value is equal to the maximum value.
 *
 * The final choice is to gamma encode the alpha channel as well.  This is
 * broken because, in practice, no implementation that uses this choice
 * correctly undoes the encoding before handling alpha composition.  Use this
 * choice only if other serious errors in the software or hardware you use
 * mandate it; the typical serious error is for dark halos to appear around
 * opaque areas of the composited PNG image because of arithmetic overflow.
 *
 * The API function png_set_alpha_mode specifies which of these choices to use
 * with an enumerated 'mode' value and the gamma of the required output:
 */
#define PNG_ALPHA_PNG           0 /* according to the PNG standard */
#define PNG_ALPHA_STANDARD      1 /* according to Porter/Duff */
#define PNG_ALPHA_ASSOCIATED    1 /* as above; this is the normal practice */
#define PNG_ALPHA_PREMULTIPLIED 1 /* as above */
#define PNG_ALPHA_OPTIMIZED     2 /* 'PNG' for opaque pixels, else 'STANDARD' */
#define PNG_ALPHA_BROKEN        3 /* the alpha channel is gamma encoded */

PNG_FP_EXPORT(227, void, png_set_alpha_mode, (png_structrp png_ptr, int mode,
    double output_gamma))
PNG_FIXED_EXPORT(228, void, png_set_alpha_mode_fixed, (png_structrp png_ptr,
    int mode, png_fixed_point output_gamma))
#endif

#if defined(PNG_GAMMA_SUPPORTED) || defined(PNG_READ_ALPHA_MODE_SUPPORTED)
/* The output_gamma value is a screen gamma in libpng terminology: it expresses
 * how to decode the output values, not how they are encoded.
 */
#define PNG_DEFAULT_sRGB -1       /* sRGB gamma and color space */
#define PNG_GAMMA_MAC_18 -2       /* Old Mac '1.8' gamma and color space */
#define PNG_GAMMA_sRGB   220000   /* Television standards--matches sRGB gamma */
#define PNG_GAMMA_LINEAR PNG_FP_1 /* Linear */
#endif

/* The following are examples of calls to png_set_alpha_mode to achieve the
 * required overall gamma correction and, where necessary, alpha
 * premultiplication.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
 *    This is the default libpng handling of the alpha channel - it is not
 *    pre-multiplied into the color components.  In addition the call states
 *    that the output is for a sRGB system and causes all PNG files without gAMA
 *    chunks to be assumed to be encoded using sRGB.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
 *    In this case the output is assumed to be something like an sRGB conformant
 *    display preceeded by a power-law lookup table of power 1.45.  This is how
 *    early Mac systems behaved.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_GAMMA_LINEAR);
 *    This is the classic Jim Blinn approach and will work in academic
 *    environments where everything is done by the book.  It has the shortcoming
 *    of assuming that input PNG data with no gamma information is linear - this
 *    is unlikely to be correct unless the PNG files where generated locally.
 *    Most of the time the output precision will be so low as to show
 *    significant banding in dark areas of the image.
 *
 * png_set_expand_16(pp);
 * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_DEFAULT_sRGB);
 *    This is a somewhat more realistic Jim Blinn inspired approach.  PNG files
 *    are assumed to have the sRGB encoding if not marked with a gamma value and
 *    the output is always 16 bits per component.  This permits accurate scaling
 *    and processing of the data.  If you know that your input PNG files were
 *    generated locally you might need to replace PNG_DEFAULT_sRGB with the
 *    correct value for your system.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_OPTIMIZED, PNG_DEFAULT_sRGB);
 *    If you just need to composite the PNG image onto an existing background
 *    and if you control the code that does this you can use the optimization
 *    setting.  In this case you just copy completely opaque pixels to the
 *    output.  For pixels that are not completely transparent (you just skip
 *    those) you do the composition math using png_composite or png_composite_16
 *    below then encode the resultant 8-bit or 16-bit values to match the output
 *    encoding.
 *
 * Other cases
 *    If neither the PNG nor the standard linear encoding work for you because
 *    of the software or hardware you use then you have a big problem.  The PNG
 *    case will probably result in halos around the image.  The linear encoding
 *    will probably result in a washed out, too bright, image (it's actually too
 *    contrasty.)  Try the ALPHA_OPTIMIZED mode above - this will probably
 *    substantially reduce the halos.  Alternatively try:
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);
 *    This option will also reduce the halos, but there will be slight dark
 *    halos round the opaque parts of the image where the background is light.
 *    In the OPTIMIZED mode the halos will be light halos where the background
 *    is dark.  Take your pick - the halos are unavoidable unless you can get
 *    your hardware/software fixed!  (The OPTIMIZED approach is slightly
 *    faster.)
 *
 * When the default gamma of PNG files doesn't match the output gamma.
 *    If you have PNG files with no gamma information png_set_alpha_mode allows
 *    you to provide a default gamma, but it also sets the ouput gamma to the
 *    matching value.  If you know your PNG files have a gamma that doesn't
 *    match the output you can take advantage of the fact that
 *    png_set_alpha_mode always sets the output gamma but only sets the PNG
 *    default if it is not already set:
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
 *    The first call sets both the default and the output gamma values, the
 *    second call overrides the output gamma without changing the default.  This
 *    is easier than achieving the same effect with png_set_gamma.  You must use
 *    PNG_ALPHA_PNG for the first call - internal checking in png_set_alpha will
 *    fire if more than one call to png_set_alpha_mode and png_set_background is
 *    made in the same read operation, however multiple calls with PNG_ALPHA_PNG
 *    are ignored.
 */

#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
PNG_EXPORT(36, void, png_set_strip_alpha, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
PNG_EXPORT(37, void, png_set_swap_alpha, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
PNG_EXPORT(38, void, png_set_invert_alpha, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
/* Add a filler byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. */
PNG_EXPORT(39, void, png_set_filler, (png_structrp png_ptr, png_uint_32 filler,
    int flags));
/* The values of the PNG_FILLER_ defines should NOT be changed */
#  define PNG_FILLER_BEFORE 0
#  define PNG_FILLER_AFTER 1
/* Add an alpha byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. */
PNG_EXPORT(40, void, png_set_add_alpha, (png_structrp png_ptr,
    png_uint_32 filler, int flags));
#endif /* READ_FILLER || WRITE_FILLER */

#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
/* Swap bytes in 16-bit depth files. */
PNG_EXPORT(41, void, png_set_swap, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
/* Use 1 byte per pixel in 1, 2, or 4-bit depth files. */
PNG_EXPORT(42, void, png_set_packing, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED) || \
    defined(PNG_WRITE_PACKSWAP_SUPPORTED)
/* Swap packing order of pixels in bytes. */
PNG_EXPORT(43, void, png_set_packswap, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
/* Converts files to legal bit depths. */
PNG_EXPORT(44, void, png_set_shift, (png_structrp png_ptr, png_const_color_8p
    true_bits));
#endif

#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
    defined(PNG_WRITE_INTERLACING_SUPPORTED)
/* Have the code handle the interlacing.  Returns the number of passes.
 * MUST be called before png_read_update_info or png_start_read_image,
 * otherwise it will not have the desired effect.  Note that it is still
 * necessary to call png_read_row or png_read_rows png_get_image_height
 * times for each pass.
*/
PNG_EXPORT(45, int, png_set_interlace_handling, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
/* Invert monochrome files */
PNG_EXPORT(46, void, png_set_invert_mono, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_BACKGROUND_SUPPORTED
/* Handle alpha and tRNS by replacing with a background color.  Prior to
 * libpng-1.5.4 this API must not be called before the PNG file header has been
 * read.  Doing so will result in unexpected behavior and possible warnings or
 * errors if the PNG file contains a bKGD chunk.
 */
PNG_FP_EXPORT(47, void, png_set_background, (png_structrp png_ptr,
    png_const_color_16p background_color, int background_gamma_code,
    int need_expand, double background_gamma))
PNG_FIXED_EXPORT(215, void, png_set_background_fixed, (png_structrp png_ptr,
    png_const_color_16p background_color, int background_gamma_code,
    int need_expand, png_fixed_point background_gamma))
#endif
#ifdef PNG_READ_BACKGROUND_SUPPORTED
#  define PNG_BACKGROUND_GAMMA_UNKNOWN 0
#  define PNG_BACKGROUND_GAMMA_SCREEN  1
#  define PNG_BACKGROUND_GAMMA_FILE    2
#  define PNG_BACKGROUND_GAMMA_UNIQUE  3
#endif

#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
/* Scale a 16-bit depth file down to 8-bit, accurately. */
PNG_EXPORT(229, void, png_set_scale_16, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
#define PNG_READ_16_TO_8_SUPPORTED /* Name prior to 1.5.4 */
/* Strip the second byte of information from a 16-bit depth file. */
PNG_EXPORT(48, void, png_set_strip_16, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_QUANTIZE_SUPPORTED
/* Turn on quantizing, and reduce the palette to the number of colors
 * available.
 */
PNG_EXPORT(49, void, png_set_quantize, (png_structrp png_ptr,
    png_colorp palette, int num_palette, int maximum_colors,
    png_const_uint_16p histogram, int full_quantize));
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
/* The threshold on gamma processing is configurable but hard-wired into the
 * library.  The following is the floating point variant.
 */
#define PNG_GAMMA_THRESHOLD (PNG_GAMMA_THRESHOLD_FIXED*.00001)

/* Handle gamma correction. Screen_gamma=(display_exponent).
 * NOTE: this API simply sets the screen and file gamma values. It will
 * therefore override the value for gamma in a PNG file if it is called after
 * the file header has been read - use with care  - call before reading the PNG
 * file for best results!
 *
 * These routines accept the same gamma values as png_set_alpha_mode (described
 * above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either
 * API (floating point or fixed.)  Notice, however, that the 'file_gamma' value
 * is the inverse of a 'screen gamma' value.
 */
PNG_FP_EXPORT(50, void, png_set_gamma, (png_structrp png_ptr,
    double screen_gamma, double override_file_gamma))
PNG_FIXED_EXPORT(208, void, png_set_gamma_fixed, (png_structrp png_ptr,
    png_fixed_point screen_gamma, png_fixed_point override_file_gamma))
#endif

#ifdef PNG_WRITE_FLUSH_SUPPORTED
/* Set how many lines between output flushes - 0 for no flushing */
PNG_EXPORT(51, void, png_set_flush, (png_structrp png_ptr, int nrows));
/* Flush the current PNG output buffer */
PNG_EXPORT(52, void, png_write_flush, (png_structrp png_ptr));
#endif

/* Optional update palette with requested transformations */
PNG_EXPORT(53, void, png_start_read_image, (png_structrp png_ptr));

/* Optional call to update the users info structure */
PNG_EXPORT(54, void, png_read_update_info, (png_structrp png_ptr,
    png_inforp info_ptr));

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read one or more rows of image data. */
PNG_EXPORT(55, void, png_read_rows, (png_structrp png_ptr, png_bytepp row,
    png_bytepp display_row, png_uint_32 num_rows));
#endif

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read a row of data. */
PNG_EXPORT(56, void, png_read_row, (png_structrp png_ptr, png_bytep row,
    png_bytep display_row));
#endif

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the whole image into memory at once. */
PNG_EXPORT(57, void, png_read_image, (png_structrp png_ptr, png_bytepp image));
#endif

/* Write a row of image data */
PNG_EXPORT(58, void, png_write_row, (png_structrp png_ptr,
    png_const_bytep row));

/* Write a few rows of image data: (*row) is not written; however, the type
 * is declared as writeable to maintain compatibility with previous versions
 * of libpng and to allow the 'display_row' array from read_rows to be passed
 * unchanged to write_rows.
 */
PNG_EXPORT(59, void, png_write_rows, (png_structrp png_ptr, png_bytepp row,
    png_uint_32 num_rows));

/* Write the image data */
PNG_EXPORT(60, void, png_write_image, (png_structrp png_ptr, png_bytepp image));

/* Write the end of the PNG file. */
PNG_EXPORT(61, void, png_write_end, (png_structrp png_ptr,
    png_inforp info_ptr));

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the end of the PNG file. */
PNG_EXPORT(62, void, png_read_end, (png_structrp png_ptr, png_inforp info_ptr));
#endif

/* Free any memory associated with the png_info_struct */
PNG_EXPORT(63, void, png_destroy_info_struct, (png_const_structrp png_ptr,
    png_infopp info_ptr_ptr));

/* Free any memory associated with the png_struct and the png_info_structs */
PNG_EXPORT(64, void, png_destroy_read_struct, (png_structpp png_ptr_ptr,
    png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr));

/* Free any memory associated with the png_struct and the png_info_structs */
PNG_EXPORT(65, void, png_destroy_write_struct, (png_structpp png_ptr_ptr,
    png_infopp info_ptr_ptr));

/* Set the libpng method of handling chunk CRC errors */
PNG_EXPORT(66, void, png_set_crc_action, (png_structrp png_ptr, int crit_action,
    int ancil_action));

/* Values for png_set_crc_action() say how to handle CRC errors in
 * ancillary and critical chunks, and whether to use the data contained
 * therein.  Note that it is impossible to "discard" data in a critical
 * chunk.  For versions prior to 0.90, the action was always error/quit,
 * whereas in version 0.90 and later, the action for CRC errors in ancillary
 * chunks is warn/discard.  These values should NOT be changed.
 *
 *      value                       action:critical     action:ancillary
 */
#define PNG_CRC_DEFAULT       0  /* error/quit          warn/discard data */
#define PNG_CRC_ERROR_QUIT    1  /* error/quit          error/quit        */
#define PNG_CRC_WARN_DISCARD  2  /* (INVALID)           warn/discard data */
#define PNG_CRC_WARN_USE      3  /* warn/use data       warn/use data     */
#define PNG_CRC_QUIET_USE     4  /* quiet/use data      quiet/use data    */
#define PNG_CRC_NO_CHANGE     5  /* use current value   use current value */

#ifdef PNG_WRITE_SUPPORTED
/* These functions give the user control over the scan-line filtering in
 * libpng and the compression methods used by zlib.  These functions are
 * mainly useful for testing, as the defaults should work with most users.
 * Those users who are tight on memory or want faster performance at the
 * expense of compression can modify them.  See the compression library
 * header file (zlib.h) for an explination of the compression functions.
 */

/* Set the filtering method(s) used by libpng.  Currently, the only valid
 * value for "method" is 0.
 */
PNG_EXPORT(67, void, png_set_filter, (png_structrp png_ptr, int method,
    int filters));
#endif /* WRITE */

/* Flags for png_set_filter() to say which filters to use.  The flags
 * are chosen so that they don't conflict with real filter types
 * below, in case they are supplied instead of the #defined constants.
 * These values should NOT be changed.
 */
#define PNG_NO_FILTERS     0x00
#define PNG_FILTER_NONE    0x08
#define PNG_FILTER_SUB     0x10
#define PNG_FILTER_UP      0x20
#define PNG_FILTER_AVG     0x40
#define PNG_FILTER_PAETH   0x80
#define PNG_FAST_FILTERS (PNG_FILTER_NONE | PNG_FILTER_SUB | PNG_FILTER_UP)
#define PNG_ALL_FILTERS (PNG_FAST_FILTERS | PNG_FILTER_AVG | PNG_FILTER_PAETH)

/* Filter values (not flags) - used in pngwrite.c, pngwutil.c for now.
 * These defines should NOT be changed.
 */
#define PNG_FILTER_VALUE_NONE  0
#define PNG_FILTER_VALUE_SUB   1
#define PNG_FILTER_VALUE_UP    2
#define PNG_FILTER_VALUE_AVG   3
#define PNG_FILTER_VALUE_PAETH 4
#define PNG_FILTER_VALUE_LAST  5

#ifdef PNG_WRITE_SUPPORTED
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED /* DEPRECATED */
PNG_FP_EXPORT(68, void, png_set_filter_heuristics, (png_structrp png_ptr,
    int heuristic_method, int num_weights, png_const_doublep filter_weights,
    png_const_doublep filter_costs))
PNG_FIXED_EXPORT(209, void, png_set_filter_heuristics_fixed,
    (png_structrp png_ptr, int heuristic_method, int num_weights,
    png_const_fixed_point_p filter_weights,
    png_const_fixed_point_p filter_costs))
#endif /* WRITE_WEIGHTED_FILTER */

/* The following are no longer used and will be removed from libpng-1.7: */
#define PNG_FILTER_HEURISTIC_DEFAULT    0  /* Currently "UNWEIGHTED" */
#define PNG_FILTER_HEURISTIC_UNWEIGHTED 1  /* Used by libpng < 0.95 */
#define PNG_FILTER_HEURISTIC_WEIGHTED   2  /* Experimental feature */
#define PNG_FILTER_HEURISTIC_LAST       3  /* Not a valid value */

/* Set the library compression level.  Currently, valid values range from
 * 0 - 9, corresponding directly to the zlib compression levels 0 - 9
 * (0 - no compression, 9 - "maximal" compression).  Note that tests have
 * shown that zlib compression levels 3-6 usually perform as well as level 9
 * for PNG images, and do considerably fewer caclulations.  In the future,
 * these values may not correspond directly to the zlib compression levels.
 */
#ifdef PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
PNG_EXPORT(69, void, png_set_compression_level, (png_structrp png_ptr,
    int level));

PNG_EXPORT(70, void, png_set_compression_mem_level, (png_structrp png_ptr,
    int mem_level));

PNG_EXPORT(71, void, png_set_compression_strategy, (png_structrp png_ptr,
    int strategy));

/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 */
PNG_EXPORT(72, void, png_set_compression_window_bits, (png_structrp png_ptr,
    int window_bits));

PNG_EXPORT(73, void, png_set_compression_method, (png_structrp png_ptr,
    int method));
#endif /* WRITE_CUSTOMIZE_COMPRESSION */

#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
/* Also set zlib parameters for compressing non-IDAT chunks */
PNG_EXPORT(222, void, png_set_text_compression_level, (png_structrp png_ptr,
    int level));

PNG_EXPORT(223, void, png_set_text_compression_mem_level, (png_structrp png_ptr,
    int mem_level));

PNG_EXPORT(224, void, png_set_text_compression_strategy, (png_structrp png_ptr,
    int strategy));

/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 */
PNG_EXPORT(225, void, png_set_text_compression_window_bits,
    (png_structrp png_ptr, int window_bits));

PNG_EXPORT(226, void, png_set_text_compression_method, (png_structrp png_ptr,
    int method));
#endif /* WRITE_CUSTOMIZE_ZTXT_COMPRESSION */
#endif /* WRITE */

/* These next functions are called for input/output, memory, and error
 * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,
 * and call standard C I/O routines such as fread(), fwrite(), and
 * fprintf().  These functions can be made to use other I/O routines
 * at run time for those applications that need to handle I/O in a
 * different manner by calling png_set_???_fn().  See libpng-manual.txt for
 * more information.
 */

#ifdef PNG_STDIO_SUPPORTED
/* Initialize the input/output for the PNG file to the default functions. */
PNG_EXPORT(74, void, png_init_io, (png_structrp png_ptr, png_FILE_p fp));
#endif

/* Replace the (error and abort), and warning functions with user
 * supplied functions.  If no messages are to be printed you must still
 * write and use replacement functions. The replacement error_fn should
 * still do a longjmp to the last setjmp location if you are using this
 * method of error handling.  If error_fn or warning_fn is NULL, the
 * default function will be used.
 */

PNG_EXPORT(75, void, png_set_error_fn, (png_structrp png_ptr,
    png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warning_fn));

/* Return the user pointer associated with the error functions */
PNG_EXPORT(76, png_voidp, png_get_error_ptr, (png_const_structrp png_ptr));

/* Replace the default data output functions with a user supplied one(s).
 * If buffered output is not used, then output_flush_fn can be set to NULL.
 * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time
 * output_flush_fn will be ignored (and thus can be NULL).
 * It is probably a mistake to use NULL for output_flush_fn if
 * write_data_fn is not also NULL unless you have built libpng with
 * PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's
 * default flush function, which uses the standard *FILE structure, will
 * be used.
 */
PNG_EXPORT(77, void, png_set_write_fn, (png_structrp png_ptr, png_voidp io_ptr,
    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn));

/* Replace the default data input function with a user supplied one. */
PNG_EXPORT(78, void, png_set_read_fn, (png_structrp png_ptr, png_voidp io_ptr,
    png_rw_ptr read_data_fn));

/* Return the user pointer associated with the I/O functions */
PNG_EXPORT(79, png_voidp, png_get_io_ptr, (png_const_structrp png_ptr));

PNG_EXPORT(80, void, png_set_read_status_fn, (png_structrp png_ptr,
    png_read_status_ptr read_row_fn));

PNG_EXPORT(81, void, png_set_write_status_fn, (png_structrp png_ptr,
    png_write_status_ptr write_row_fn));

#ifdef PNG_USER_MEM_SUPPORTED
/* Replace the default memory allocation functions with user supplied one(s). */
PNG_EXPORT(82, void, png_set_mem_fn, (png_structrp png_ptr, png_voidp mem_ptr,
    png_malloc_ptr malloc_fn, png_free_ptr free_fn));
/* Return the user pointer associated with the memory functions */
PNG_EXPORT(83, png_voidp, png_get_mem_ptr, (png_const_structrp png_ptr));
#endif

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
PNG_EXPORT(84, void, png_set_read_user_transform_fn, (png_structrp png_ptr,
    png_user_transform_ptr read_user_transform_fn));
#endif

#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
PNG_EXPORT(85, void, png_set_write_user_transform_fn, (png_structrp png_ptr,
    png_user_transform_ptr write_user_transform_fn));
#endif

#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
PNG_EXPORT(86, void, png_set_user_transform_info, (png_structrp png_ptr,
    png_voidp user_transform_ptr, int user_transform_depth,
    int user_transform_channels));
/* Return the user pointer associated with the user transform functions */
PNG_EXPORT(87, png_voidp, png_get_user_transform_ptr,
    (png_const_structrp png_ptr));
#endif

#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED
/* Return information about the row currently being processed.  Note that these
 * APIs do not fail but will return unexpected results if called outside a user
 * transform callback.  Also note that when transforming an interlaced image the
 * row number is the row number within the sub-image of the interlace pass, so
 * the value will increase to the height of the sub-image (not the full image)
 * then reset to 0 for the next pass.
 *
 * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
 * find the output pixel (x,y) given an interlaced sub-image pixel
 * (row,col,pass).  (See below for these macros.)
 */
PNG_EXPORT(217, png_uint_32, png_get_current_row_number, (png_const_structrp));
PNG_EXPORT(218, png_byte, png_get_current_pass_number, (png_const_structrp));
#endif

#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
/* This callback is called only for *unknown* chunks.  If
 * PNG_HANDLE_AS_UNKNOWN_SUPPORTED is set then it is possible to set known
 * chunks to be treated as unknown, however in this case the callback must do
 * any processing required by the chunk (e.g. by calling the appropriate
 * png_set_ APIs.)
 *
 * There is no write support - on write, by default, all the chunks in the
 * 'unknown' list are written in the specified position.
 *
 * The integer return from the callback function is interpreted thus:
 *
 * negative: An error occurred; png_chunk_error will be called.
 *     zero: The chunk was not handled, the chunk will be saved. A critical
 *           chunk will cause an error at this point unless it is to be saved.
 * positive: The chunk was handled, libpng will ignore/discard it.
 *
 * See "INTERACTION WTIH USER CHUNK CALLBACKS" below for important notes about
 * how this behavior will change in libpng 1.7
 */
PNG_EXPORT(88, void, png_set_read_user_chunk_fn, (png_structrp png_ptr,
    png_voidp user_chunk_ptr, png_user_chunk_ptr read_user_chunk_fn));
#endif

#ifdef PNG_USER_CHUNKS_SUPPORTED
PNG_EXPORT(89, png_voidp, png_get_user_chunk_ptr, (png_const_structrp png_ptr));
#endif

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
/* Sets the function callbacks for the push reader, and a pointer to a
 * user-defined structure available to the callback functions.
 */
PNG_EXPORT(90, void, png_set_progressive_read_fn, (png_structrp png_ptr,
    png_voidp progressive_ptr, png_progressive_info_ptr info_fn,
    png_progressive_row_ptr row_fn, png_progressive_end_ptr end_fn));

/* Returns the user pointer associated with the push read functions */
PNG_EXPORT(91, png_voidp, png_get_progressive_ptr,
    (png_const_structrp png_ptr));

/* Function to be called when data becomes available */
PNG_EXPORT(92, void, png_process_data, (png_structrp png_ptr,
    png_inforp info_ptr, png_bytep buffer, png_size_t buffer_size));

/* A function which may be called *only* within png_process_data to stop the
 * processing of any more data.  The function returns the number of bytes
 * remaining, excluding any that libpng has cached internally.  A subsequent
 * call to png_process_data must supply these bytes again.  If the argument
 * 'save' is set to true the routine will first save all the pending data and
 * will always return 0.
 */
PNG_EXPORT(219, png_size_t, png_process_data_pause, (png_structrp, int save));

/* A function which may be called *only* outside (after) a call to
 * png_process_data.  It returns the number of bytes of data to skip in the
 * input.  Normally it will return 0, but if it returns a non-zero value the
 * application must skip than number of bytes of input data and pass the
 * following data to the next call to png_process_data.
 */
PNG_EXPORT(220, png_uint_32, png_process_data_skip, (png_structrp));

/* Function that combines rows.  'new_row' is a flag that should come from
 * the callback and be non-NULL if anything needs to be done; the library
 * stores its own version of the new data internally and ignores the passed
 * in value.
 */
PNG_EXPORT(93, void, png_progressive_combine_row, (png_const_structrp png_ptr,
    png_bytep old_row, png_const_bytep new_row));
#endif /* PROGRESSIVE_READ */

PNG_EXPORTA(94, png_voidp, png_malloc, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED);
/* Added at libpng version 1.4.0 */
PNG_EXPORTA(95, png_voidp, png_calloc, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED);

/* Added at libpng version 1.2.4 */
PNG_EXPORTA(96, png_voidp, png_malloc_warn, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED);

/* Frees a pointer allocated by png_malloc() */
PNG_EXPORT(97, void, png_free, (png_const_structrp png_ptr, png_voidp ptr));

/* Free data that was allocated internally */
PNG_EXPORT(98, void, png_free_data, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 free_me, int num));

/* Reassign responsibility for freeing existing data, whether allocated
 * by libpng or by the application; this works on the png_info structure passed
 * in, it does not change the state for other png_info structures.
 *
 * It is unlikely that this function works correctly as of 1.6.0 and using it
 * may result either in memory leaks or double free of allocated data.
 */
PNG_EXPORT(99, void, png_data_freer, (png_const_structrp png_ptr,
    png_inforp info_ptr, int freer, png_uint_32 mask));

/* Assignments for png_data_freer */
#define PNG_DESTROY_WILL_FREE_DATA 1
#define PNG_SET_WILL_FREE_DATA 1
#define PNG_USER_WILL_FREE_DATA 2
/* Flags for png_ptr->free_me and info_ptr->free_me */
#define PNG_FREE_HIST 0x0008U
#define PNG_FREE_ICCP 0x0010U
#define PNG_FREE_SPLT 0x0020U
#define PNG_FREE_ROWS 0x0040U
#define PNG_FREE_PCAL 0x0080U
#define PNG_FREE_SCAL 0x0100U
#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
#  define PNG_FREE_UNKN 0x0200U
#endif
/*      PNG_FREE_LIST 0x0400U   removed in 1.6.0 because it is ignored */
#define PNG_FREE_PLTE 0x1000U
#define PNG_FREE_TRNS 0x2000U
#define PNG_FREE_TEXT 0x4000U
#define PNG_FREE_ALL  0x7fffU
#define PNG_FREE_MUL  0x4220U /* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */

#ifdef PNG_USER_MEM_SUPPORTED
PNG_EXPORTA(100, png_voidp, png_malloc_default, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED PNG_DEPRECATED);
PNG_EXPORTA(101, void, png_free_default, (png_const_structrp png_ptr,
    png_voidp ptr), PNG_DEPRECATED);
#endif

#ifdef PNG_ERROR_TEXT_SUPPORTED
/* Fatal error in PNG image of libpng - can't continue */
PNG_EXPORTA(102, void, png_error, (png_const_structrp png_ptr,
    png_const_charp error_message), PNG_NORETURN);

/* The same, but the chunk name is prepended to the error string. */
PNG_EXPORTA(103, void, png_chunk_error, (png_const_structrp png_ptr,
    png_const_charp error_message), PNG_NORETURN);

#else
/* Fatal error in PNG image of libpng - can't continue */
PNG_EXPORTA(104, void, png_err, (png_const_structrp png_ptr), PNG_NORETURN);
#  define png_error(s1,s2) png_err(s1)
#  define png_chunk_error(s1,s2) png_err(s1)
#endif

#ifdef PNG_WARNINGS_SUPPORTED
/* Non-fatal error in libpng.  Can continue, but may have a problem. */
PNG_EXPORT(105, void, png_warning, (png_const_structrp png_ptr,
    png_const_charp warning_message));

/* Non-fatal error in libpng, chunk name is prepended to message. */
PNG_EXPORT(106, void, png_chunk_warning, (png_const_structrp png_ptr,
    png_const_charp warning_message));
#else
#  define png_warning(s1,s2) ((void)(s1))
#  define png_chunk_warning(s1,s2) ((void)(s1))
#endif

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
/* Benign error in libpng.  Can continue, but may have a problem.
 * User can choose whether to handle as a fatal error or as a warning. */
PNG_EXPORT(107, void, png_benign_error, (png_const_structrp png_ptr,
    png_const_charp warning_message));

#ifdef PNG_READ_SUPPORTED
/* Same, chunk name is prepended to message (only during read) */
PNG_EXPORT(108, void, png_chunk_benign_error, (png_const_structrp png_ptr,
    png_const_charp warning_message));
#endif

PNG_EXPORT(109, void, png_set_benign_errors,
    (png_structrp png_ptr, int allowed));
#else
#  ifdef PNG_ALLOW_BENIGN_ERRORS
#    define png_benign_error png_warning
#    define png_chunk_benign_error png_chunk_warning
#  else
#    define png_benign_error png_error
#    define png_chunk_benign_error png_chunk_error
#  endif
#endif

/* The png_set_<chunk> functions are for storing values in the png_info_struct.
 * Similarly, the png_get_<chunk> calls are used to read values from the
 * png_info_struct, either storing the parameters in the passed variables, or
 * setting pointers into the png_info_struct where the data is stored.  The
 * png_get_<chunk> functions return a non-zero value if the data was available
 * in info_ptr, or return zero and do not change any of the parameters if the
 * data was not available.
 *
 * These functions should be used instead of directly accessing png_info
 * to avoid problems with future changes in the size and internal layout of
 * png_info_struct.
 */
/* Returns "flag" if chunk data is valid in info_ptr. */
PNG_EXPORT(110, png_uint_32, png_get_valid, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 flag));

/* Returns number of bytes needed to hold a transformed row. */
PNG_EXPORT(111, png_size_t, png_get_rowbytes, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

#ifdef PNG_INFO_IMAGE_SUPPORTED
/* Returns row_pointers, which is an array of pointers to scanlines that was
 * returned from png_read_png().
 */
PNG_EXPORT(112, png_bytepp, png_get_rows, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Set row_pointers, which is an array of pointers to scanlines for use
 * by png_write_png().
 */
PNG_EXPORT(113, void, png_set_rows, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_bytepp row_pointers));
#endif

/* Returns number of color channels in image. */
PNG_EXPORT(114, png_byte, png_get_channels, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

#ifdef PNG_EASY_ACCESS_SUPPORTED
/* Returns image width in pixels. */
PNG_EXPORT(115, png_uint_32, png_get_image_width, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image height in pixels. */
PNG_EXPORT(116, png_uint_32, png_get_image_height, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image bit_depth. */
PNG_EXPORT(117, png_byte, png_get_bit_depth, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image color_type. */
PNG_EXPORT(118, png_byte, png_get_color_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image filter_type. */
PNG_EXPORT(119, png_byte, png_get_filter_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image interlace_type. */
PNG_EXPORT(120, png_byte, png_get_interlace_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image compression_type. */
PNG_EXPORT(121, png_byte, png_get_compression_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image resolution in pixels per meter, from pHYs chunk data. */
PNG_EXPORT(122, png_uint_32, png_get_pixels_per_meter,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(123, png_uint_32, png_get_x_pixels_per_meter,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(124, png_uint_32, png_get_y_pixels_per_meter,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

/* Returns pixel aspect ratio, computed from pHYs chunk data.  */
PNG_FP_EXPORT(125, float, png_get_pixel_aspect_ratio,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
PNG_FIXED_EXPORT(210, png_fixed_point, png_get_pixel_aspect_ratio_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))

/* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
PNG_EXPORT(126, png_int_32, png_get_x_offset_pixels,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(127, png_int_32, png_get_y_offset_pixels,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(128, png_int_32, png_get_x_offset_microns,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(129, png_int_32, png_get_y_offset_microns,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

#endif /* EASY_ACCESS */

#ifdef PNG_READ_SUPPORTED
/* Returns pointer to signature string read from PNG header */
PNG_EXPORT(130, png_const_bytep, png_get_signature, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));
#endif

#ifdef PNG_bKGD_SUPPORTED
PNG_EXPORT(131, png_uint_32, png_get_bKGD, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_color_16p *background));
#endif

#ifdef PNG_bKGD_SUPPORTED
PNG_EXPORT(132, void, png_set_bKGD, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_color_16p background));
#endif

#ifdef PNG_cHRM_SUPPORTED
PNG_FP_EXPORT(133, png_uint_32, png_get_cHRM, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, double *white_x, double *white_y, double *red_x,
    double *red_y, double *green_x, double *green_y, double *blue_x,
    double *blue_y))
PNG_FP_EXPORT(230, png_uint_32, png_get_cHRM_XYZ, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, double *red_X, double *red_Y, double *red_Z,
    double *green_X, double *green_Y, double *green_Z, double *blue_X,
    double *blue_Y, double *blue_Z))
PNG_FIXED_EXPORT(134, png_uint_32, png_get_cHRM_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *int_white_x, png_fixed_point *int_white_y,
    png_fixed_point *int_red_x, png_fixed_point *int_red_y,
    png_fixed_point *int_green_x, png_fixed_point *int_green_y,
    png_fixed_point *int_blue_x, png_fixed_point *int_blue_y))
PNG_FIXED_EXPORT(231, png_uint_32, png_get_cHRM_XYZ_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,
    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,
    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,
    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,
    png_fixed_point *int_blue_Z))
#endif

#ifdef PNG_cHRM_SUPPORTED
PNG_FP_EXPORT(135, void, png_set_cHRM, (png_const_structrp png_ptr,
    png_inforp info_ptr,
    double white_x, double white_y, double red_x, double red_y, double green_x,
    double green_y, double blue_x, double blue_y))
PNG_FP_EXPORT(232, void, png_set_cHRM_XYZ, (png_const_structrp png_ptr,
    png_inforp info_ptr, double red_X, double red_Y, double red_Z,
    double green_X, double green_Y, double green_Z, double blue_X,
    double blue_Y, double blue_Z))
PNG_FIXED_EXPORT(136, void, png_set_cHRM_fixed, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_white_x,
    png_fixed_point int_white_y, png_fixed_point int_red_x,
    png_fixed_point int_red_y, png_fixed_point int_green_x,
    png_fixed_point int_green_y, png_fixed_point int_blue_x,
    png_fixed_point int_blue_y))
PNG_FIXED_EXPORT(233, void, png_set_cHRM_XYZ_fixed, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_red_X, png_fixed_point int_red_Y,
    png_fixed_point int_red_Z, png_fixed_point int_green_X,
    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
    png_fixed_point int_blue_Z))
#endif

#ifdef PNG_gAMA_SUPPORTED
PNG_FP_EXPORT(137, png_uint_32, png_get_gAMA, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, double *file_gamma))
PNG_FIXED_EXPORT(138, png_uint_32, png_get_gAMA_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *int_file_gamma))
#endif

#ifdef PNG_gAMA_SUPPORTED
PNG_FP_EXPORT(139, void, png_set_gAMA, (png_const_structrp png_ptr,
    png_inforp info_ptr, double file_gamma))
PNG_FIXED_EXPORT(140, void, png_set_gAMA_fixed, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_file_gamma))
#endif

#ifdef PNG_hIST_SUPPORTED
PNG_EXPORT(141, png_uint_32, png_get_hIST, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_16p *hist));
#endif

#ifdef PNG_hIST_SUPPORTED
PNG_EXPORT(142, void, png_set_hIST, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_uint_16p hist));
#endif

PNG_EXPORT(143, png_uint_32, png_get_IHDR, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 *width, png_uint_32 *height,
    int *bit_depth, int *color_type, int *interlace_method,
    int *compression_method, int *filter_method));

PNG_EXPORT(144, void, png_set_IHDR, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 width, png_uint_32 height, int bit_depth,
    int color_type, int interlace_method, int compression_method,
    int filter_method));

#ifdef PNG_oFFs_SUPPORTED
PNG_EXPORT(145, png_uint_32, png_get_oFFs, (png_const_structrp png_ptr,
   png_const_inforp info_ptr, png_int_32 *offset_x, png_int_32 *offset_y,
   int *unit_type));
#endif

#ifdef PNG_oFFs_SUPPORTED
PNG_EXPORT(146, void, png_set_oFFs, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_int_32 offset_x, png_int_32 offset_y,
    int unit_type));
#endif

#ifdef PNG_pCAL_SUPPORTED
PNG_EXPORT(147, png_uint_32, png_get_pCAL, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_charp *purpose, png_int_32 *X0,
    png_int_32 *X1, int *type, int *nparams, png_charp *units,
    png_charpp *params));
#endif

#ifdef PNG_pCAL_SUPPORTED
PNG_EXPORT(148, void, png_set_pCAL, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_charp purpose, png_int_32 X0, png_int_32 X1,
    int type, int nparams, png_const_charp units, png_charpp params));
#endif

#ifdef PNG_pHYs_SUPPORTED
PNG_EXPORT(149, png_uint_32, png_get_pHYs, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
    int *unit_type));
#endif

#ifdef PNG_pHYs_SUPPORTED
PNG_EXPORT(150, void, png_set_pHYs, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 res_x, png_uint_32 res_y, int unit_type));
#endif

PNG_EXPORT(151, png_uint_32, png_get_PLTE, (png_const_structrp png_ptr,
   png_inforp info_ptr, png_colorp *palette, int *num_palette));

PNG_EXPORT(152, void, png_set_PLTE, (png_structrp png_ptr,
    png_inforp info_ptr, png_const_colorp palette, int num_palette));

#ifdef PNG_sBIT_SUPPORTED
PNG_EXPORT(153, png_uint_32, png_get_sBIT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_color_8p *sig_bit));
#endif

#ifdef PNG_sBIT_SUPPORTED
PNG_EXPORT(154, void, png_set_sBIT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_color_8p sig_bit));
#endif

#ifdef PNG_sRGB_SUPPORTED
PNG_EXPORT(155, png_uint_32, png_get_sRGB, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, int *file_srgb_intent));
#endif

#ifdef PNG_sRGB_SUPPORTED
PNG_EXPORT(156, void, png_set_sRGB, (png_const_structrp png_ptr,
    png_inforp info_ptr, int srgb_intent));
PNG_EXPORT(157, void, png_set_sRGB_gAMA_and_cHRM, (png_const_structrp png_ptr,
    png_inforp info_ptr, int srgb_intent));
#endif

#ifdef PNG_iCCP_SUPPORTED
PNG_EXPORT(158, png_uint_32, png_get_iCCP, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_charpp name, int *compression_type,
    png_bytepp profile, png_uint_32 *proflen));
#endif

#ifdef PNG_iCCP_SUPPORTED
PNG_EXPORT(159, void, png_set_iCCP, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_charp name, int compression_type,
    png_const_bytep profile, png_uint_32 proflen));
#endif

#ifdef PNG_sPLT_SUPPORTED
PNG_EXPORT(160, int, png_get_sPLT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_sPLT_tpp entries));
#endif

#ifdef PNG_sPLT_SUPPORTED
PNG_EXPORT(161, void, png_set_sPLT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_sPLT_tp entries, int nentries));
#endif

#ifdef PNG_TEXT_SUPPORTED
/* png_get_text also returns the number of text chunks in *num_text */
PNG_EXPORT(162, int, png_get_text, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_textp *text_ptr, int *num_text));
#endif

/* Note while png_set_text() will accept a structure whose text,
 * language, and  translated keywords are NULL pointers, the structure
 * returned by png_get_text will always contain regular
 * zero-terminated C strings.  They might be empty strings but
 * they will never be NULL pointers.
 */

#ifdef PNG_TEXT_SUPPORTED
PNG_EXPORT(163, void, png_set_text, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_textp text_ptr, int num_text));
#endif

#ifdef PNG_tIME_SUPPORTED
PNG_EXPORT(164, png_uint_32, png_get_tIME, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_timep *mod_time));
#endif

#ifdef PNG_tIME_SUPPORTED
PNG_EXPORT(165, void, png_set_tIME, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_timep mod_time));
#endif

#ifdef PNG_tRNS_SUPPORTED
PNG_EXPORT(166, png_uint_32, png_get_tRNS, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_bytep *trans_alpha, int *num_trans,
    png_color_16p *trans_color));
#endif

#ifdef PNG_tRNS_SUPPORTED
PNG_EXPORT(167, void, png_set_tRNS, (png_structrp png_ptr,
    png_inforp info_ptr, png_const_bytep trans_alpha, int num_trans,
    png_const_color_16p trans_color));
#endif

#ifdef PNG_sCAL_SUPPORTED
PNG_FP_EXPORT(168, png_uint_32, png_get_sCAL, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, int *unit, double *width, double *height))
#if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || \
   defined(PNG_FLOATING_POINT_SUPPORTED)
/* NOTE: this API is currently implemented using floating point arithmetic,
 * consequently it can only be used on systems with floating point support.
 * In any case the range of values supported by png_fixed_point is small and it
 * is highly recommended that png_get_sCAL_s be used instead.
 */
PNG_FIXED_EXPORT(214, png_uint_32, png_get_sCAL_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr, int *unit,
    png_fixed_point *width, png_fixed_point *height))
#endif
PNG_EXPORT(169, png_uint_32, png_get_sCAL_s,
    (png_const_structrp png_ptr, png_const_inforp info_ptr, int *unit,
    png_charpp swidth, png_charpp sheight));

PNG_FP_EXPORT(170, void, png_set_sCAL, (png_const_structrp png_ptr,
    png_inforp info_ptr, int unit, double width, double height))
PNG_FIXED_EXPORT(213, void, png_set_sCAL_fixed, (png_const_structrp png_ptr,
   png_inforp info_ptr, int unit, png_fixed_point width,
   png_fixed_point height))
PNG_EXPORT(171, void, png_set_sCAL_s, (png_const_structrp png_ptr,
    png_inforp info_ptr, int unit,
    png_const_charp swidth, png_const_charp sheight));
#endif /* sCAL */

#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
/* Provide the default handling for all unknown chunks or, optionally, for
 * specific unknown chunks.
 *
 * NOTE: prior to 1.6.0 the handling specified for particular chunks on read was
 * ignored and the default was used, the per-chunk setting only had an effect on
 * write.  If you wish to have chunk-specific handling on read in code that must
 * work on earlier versions you must use a user chunk callback to specify the
 * desired handling (keep or discard.)
 *
 * The 'keep' parameter is a PNG_HANDLE_CHUNK_ value as listed below.  The
 * parameter is interpreted as follows:
 *
 * READ:
 *    PNG_HANDLE_CHUNK_AS_DEFAULT:
 *       Known chunks: do normal libpng processing, do not keep the chunk (but
 *          see the comments below about PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
 *       Unknown chunks: for a specific chunk use the global default, when used
 *          as the default discard the chunk data.
 *    PNG_HANDLE_CHUNK_NEVER:
 *       Discard the chunk data.
 *    PNG_HANDLE_CHUNK_IF_SAFE:
 *       Keep the chunk data if the chunk is not critical else raise a chunk
 *       error.
 *    PNG_HANDLE_CHUNK_ALWAYS:
 *       Keep the chunk data.
 *
 * If the chunk data is saved it can be retrieved using png_get_unknown_chunks,
 * below.  Notice that specifying "AS_DEFAULT" as a global default is equivalent
 * to specifying "NEVER", however when "AS_DEFAULT" is used for specific chunks
 * it simply resets the behavior to the libpng default.
 *
 * INTERACTION WTIH USER CHUNK CALLBACKS:
 * The per-chunk handling is always used when there is a png_user_chunk_ptr
 * callback and the callback returns 0; the chunk is then always stored *unless*
 * it is critical and the per-chunk setting is other than ALWAYS.  Notice that
 * the global default is *not* used in this case.  (In effect the per-chunk
 * value is incremented to at least IF_SAFE.)
 *
 * IMPORTANT NOTE: this behavior will change in libpng 1.7 - the global and
 * per-chunk defaults will be honored.  If you want to preserve the current
 * behavior when your callback returns 0 you must set PNG_HANDLE_CHUNK_IF_SAFE
 * as the default - if you don't do this libpng 1.6 will issue a warning.
 *
 * If you want unhandled unknown chunks to be discarded in libpng 1.6 and
 * earlier simply return '1' (handled).
 *
 * PNG_HANDLE_AS_UNKNOWN_SUPPORTED:
 *    If this is *not* set known chunks will always be handled by libpng and
 *    will never be stored in the unknown chunk list.  Known chunks listed to
 *    png_set_keep_unknown_chunks will have no effect.  If it is set then known
 *    chunks listed with a keep other than AS_DEFAULT will *never* be processed
 *    by libpng, in addition critical chunks must either be processed by the
 *    callback or saved.
 *
 *    The IHDR and IEND chunks must not be listed.  Because this turns off the
 *    default handling for chunks that would otherwise be recognized the
 *    behavior of libpng transformations may well become incorrect!
 *
 * WRITE:
 *    When writing chunks the options only apply to the chunks specified by
 *    png_set_unknown_chunks (below), libpng will *always* write known chunks
 *    required by png_set_ calls and will always write the core critical chunks
 *    (as required for PLTE).
 *
 *    Each chunk in the png_set_unknown_chunks list is looked up in the
 *    png_set_keep_unknown_chunks list to find the keep setting, this is then
 *    interpreted as follows:
 *
 *    PNG_HANDLE_CHUNK_AS_DEFAULT:
 *       Write safe-to-copy chunks and write other chunks if the global
 *       default is set to _ALWAYS, otherwise don't write this chunk.
 *    PNG_HANDLE_CHUNK_NEVER:
 *       Do not write the chunk.
 *    PNG_HANDLE_CHUNK_IF_SAFE:
 *       Write the chunk if it is safe-to-copy, otherwise do not write it.
 *    PNG_HANDLE_CHUNK_ALWAYS:
 *       Write the chunk.
 *
 * Note that the default behavior is effectively the opposite of the read case -
 * in read unknown chunks are not stored by default, in write they are written
 * by default.  Also the behavior of PNG_HANDLE_CHUNK_IF_SAFE is very different
 * - on write the safe-to-copy bit is checked, on read the critical bit is
 * checked and on read if the chunk is critical an error will be raised.
 *
 * num_chunks:
 * ===========
 *    If num_chunks is positive, then the "keep" parameter specifies the manner
 *    for handling only those chunks appearing in the chunk_list array,
 *    otherwise the chunk list array is ignored.
 *
 *    If num_chunks is 0 the "keep" parameter specifies the default behavior for
 *    unknown chunks, as described above.
 *
 *    If num_chunks is negative, then the "keep" parameter specifies the manner
 *    for handling all unknown chunks plus all chunks recognized by libpng
 *    except for the IHDR, PLTE, tRNS, IDAT, and IEND chunks (which continue to
 *    be processed by libpng.
 */
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
PNG_EXPORT(172, void, png_set_keep_unknown_chunks, (png_structrp png_ptr,
    int keep, png_const_bytep chunk_list, int num_chunks));
#endif /* HANDLE_AS_UNKNOWN */

/* The "keep" PNG_HANDLE_CHUNK_ parameter for the specified chunk is returned;
 * the result is therefore true (non-zero) if special handling is required,
 * false for the default handling.
 */
PNG_EXPORT(173, int, png_handle_as_unknown, (png_const_structrp png_ptr,
    png_const_bytep chunk_name));
#endif /* SET_UNKNOWN_CHUNKS */

#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
PNG_EXPORT(174, void, png_set_unknown_chunks, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_unknown_chunkp unknowns,
    int num_unknowns));
   /* NOTE: prior to 1.6.0 this routine set the 'location' field of the added
    * unknowns to the location currently stored in the png_struct.  This is
    * invariably the wrong value on write.  To fix this call the following API
    * for each chunk in the list with the correct location.  If you know your
    * code won't be compiled on earlier versions you can rely on
    * png_set_unknown_chunks(write-ptr, png_get_unknown_chunks(read-ptr)) doing
    * the correct thing.
    */

PNG_EXPORT(175, void, png_set_unknown_chunk_location,
    (png_const_structrp png_ptr, png_inforp info_ptr, int chunk, int location));

PNG_EXPORT(176, int, png_get_unknown_chunks, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_unknown_chunkpp entries));
#endif

/* Png_free_data() will turn off the "valid" flag for anything it frees.
 * If you need to turn it off for a chunk that your application has freed,
 * you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);
 */
PNG_EXPORT(177, void, png_set_invalid, (png_const_structrp png_ptr,
    png_inforp info_ptr, int mask));

#ifdef PNG_INFO_IMAGE_SUPPORTED
/* The "params" pointer is currently not used and is for future expansion. */
#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
PNG_EXPORT(178, void, png_read_png, (png_structrp png_ptr, png_inforp info_ptr,
    int transforms, png_voidp params));
#endif
#ifdef PNG_WRITE_SUPPORTED
PNG_EXPORT(179, void, png_write_png, (png_structrp png_ptr, png_inforp info_ptr,
    int transforms, png_voidp params));
#endif
#endif

PNG_EXPORT(180, png_const_charp, png_get_copyright,
    (png_const_structrp png_ptr));
PNG_EXPORT(181, png_const_charp, png_get_header_ver,
    (png_const_structrp png_ptr));
PNG_EXPORT(182, png_const_charp, png_get_header_version,
    (png_const_structrp png_ptr));
PNG_EXPORT(183, png_const_charp, png_get_libpng_ver,
    (png_const_structrp png_ptr));

#ifdef PNG_MNG_FEATURES_SUPPORTED
PNG_EXPORT(184, png_uint_32, png_permit_mng_features, (png_structrp png_ptr,
    png_uint_32 mng_features_permitted));
#endif

/* For use in png_set_keep_unknown, added to version 1.2.6 */
#define PNG_HANDLE_CHUNK_AS_DEFAULT   0
#define PNG_HANDLE_CHUNK_NEVER        1
#define PNG_HANDLE_CHUNK_IF_SAFE      2
#define PNG_HANDLE_CHUNK_ALWAYS       3
#define PNG_HANDLE_CHUNK_LAST         4

/* Strip the prepended error numbers ("#nnn ") from error and warning
 * messages before passing them to the error or warning handler.
 */
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
PNG_EXPORT(185, void, png_set_strip_error_numbers, (png_structrp png_ptr,
    png_uint_32 strip_mode));
#endif

/* Added in libpng-1.2.6 */
#ifdef PNG_SET_USER_LIMITS_SUPPORTED
PNG_EXPORT(186, void, png_set_user_limits, (png_structrp png_ptr,
    png_uint_32 user_width_max, png_uint_32 user_height_max));
PNG_EXPORT(187, png_uint_32, png_get_user_width_max,
    (png_const_structrp png_ptr));
PNG_EXPORT(188, png_uint_32, png_get_user_height_max,
    (png_const_structrp png_ptr));
/* Added in libpng-1.4.0 */
PNG_EXPORT(189, void, png_set_chunk_cache_max, (png_structrp png_ptr,
    png_uint_32 user_chunk_cache_max));
PNG_EXPORT(190, png_uint_32, png_get_chunk_cache_max,
    (png_const_structrp png_ptr));
/* Added in libpng-1.4.1 */
PNG_EXPORT(191, void, png_set_chunk_malloc_max, (png_structrp png_ptr,
    png_alloc_size_t user_chunk_cache_max));
PNG_EXPORT(192, png_alloc_size_t, png_get_chunk_malloc_max,
    (png_const_structrp png_ptr));
#endif

#if defined(PNG_INCH_CONVERSIONS_SUPPORTED)
PNG_EXPORT(193, png_uint_32, png_get_pixels_per_inch,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

PNG_EXPORT(194, png_uint_32, png_get_x_pixels_per_inch,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

PNG_EXPORT(195, png_uint_32, png_get_y_pixels_per_inch,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

PNG_FP_EXPORT(196, float, png_get_x_offset_inches,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
#ifdef PNG_FIXED_POINT_SUPPORTED /* otherwise not implemented. */
PNG_FIXED_EXPORT(211, png_fixed_point, png_get_x_offset_inches_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
#endif

PNG_FP_EXPORT(197, float, png_get_y_offset_inches, (png_const_structrp png_ptr,
    png_const_inforp info_ptr))
#ifdef PNG_FIXED_POINT_SUPPORTED /* otherwise not implemented. */
PNG_FIXED_EXPORT(212, png_fixed_point, png_get_y_offset_inches_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
#endif

#  ifdef PNG_pHYs_SUPPORTED
PNG_EXPORT(198, png_uint_32, png_get_pHYs_dpi, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
    int *unit_type));
#  endif /* pHYs */
#endif  /* INCH_CONVERSIONS */

/* Added in libpng-1.4.0 */
#ifdef PNG_IO_STATE_SUPPORTED
PNG_EXPORT(199, png_uint_32, png_get_io_state, (png_const_structrp png_ptr));

/* Removed from libpng 1.6; use png_get_io_chunk_type. */
PNG_REMOVED(200, png_const_bytep, png_get_io_chunk_name, (png_structrp png_ptr),
    PNG_DEPRECATED)

PNG_EXPORT(216, png_uint_32, png_get_io_chunk_type,
    (png_const_structrp png_ptr));

/* The flags returned by png_get_io_state() are the following: */
#  define PNG_IO_NONE        0x0000   /* no I/O at this moment */
#  define PNG_IO_READING     0x0001   /* currently reading */
#  define PNG_IO_WRITING     0x0002   /* currently writing */
#  define PNG_IO_SIGNATURE   0x0010   /* currently at the file signature */
#  define PNG_IO_CHUNK_HDR   0x0020   /* currently at the chunk header */
#  define PNG_IO_CHUNK_DATA  0x0040   /* currently at the chunk data */
#  define PNG_IO_CHUNK_CRC   0x0080   /* currently at the chunk crc */
#  define PNG_IO_MASK_OP     0x000f   /* current operation: reading/writing */
#  define PNG_IO_MASK_LOC    0x00f0   /* current location: sig/hdr/data/crc */
#endif /* IO_STATE */

/* Interlace support.  The following macros are always defined so that if
 * libpng interlace handling is turned off the macros may be used to handle
 * interlaced images within the application.
 */
#define PNG_INTERLACE_ADAM7_PASSES 7

/* Two macros to return the first row and first column of the original,
 * full, image which appears in a given pass.  'pass' is in the range 0
 * to 6 and the result is in the range 0 to 7.
 */
#define PNG_PASS_START_ROW(pass) (((1&~(pass))<<(3-((pass)>>1)))&7)
#define PNG_PASS_START_COL(pass) (((1& (pass))<<(3-(((pass)+1)>>1)))&7)

/* A macro to return the offset between pixels in the output row for a pair of
 * pixels in the input - effectively the inverse of the 'COL_SHIFT' macro that
 * follows.  Note that ROW_OFFSET is the offset from one row to the next whereas
 * COL_OFFSET is from one column to the next, within a row.
 */
#define PNG_PASS_ROW_OFFSET(pass) ((pass)>2?(8>>(((pass)-1)>>1)):8)
#define PNG_PASS_COL_OFFSET(pass) (1<<((7-(pass))>>1))

/* Two macros to help evaluate the number of rows or columns in each
 * pass.  This is expressed as a shift - effectively log2 of the number or
 * rows or columns in each 8x8 tile of the original image.
 */
#define PNG_PASS_ROW_SHIFT(pass) ((pass)>2?(8-(pass))>>1:3)
#define PNG_PASS_COL_SHIFT(pass) ((pass)>1?(7-(pass))>>1:3)

/* Hence two macros to determine the number of rows or columns in a given
 * pass of an image given its height or width.  In fact these macros may
 * return non-zero even though the sub-image is empty, because the other
 * dimension may be empty for a small image.
 */
#define PNG_PASS_ROWS(height, pass) (((height)+(((1<<PNG_PASS_ROW_SHIFT(pass))\
   -1)-PNG_PASS_START_ROW(pass)))>>PNG_PASS_ROW_SHIFT(pass))
#define PNG_PASS_COLS(width, pass) (((width)+(((1<<PNG_PASS_COL_SHIFT(pass))\
   -1)-PNG_PASS_START_COL(pass)))>>PNG_PASS_COL_SHIFT(pass))

/* For the reader row callbacks (both progressive and sequential) it is
 * necessary to find the row in the output image given a row in an interlaced
 * image, so two more macros:
 */
#define PNG_ROW_FROM_PASS_ROW(y_in, pass) \
   (((y_in)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
#define PNG_COL_FROM_PASS_COL(x_in, pass) \
   (((x_in)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))

/* Two macros which return a boolean (0 or 1) saying whether the given row
 * or column is in a particular pass.  These use a common utility macro that
 * returns a mask for a given pass - the offset 'off' selects the row or
 * column version.  The mask has the appropriate bit set for each column in
 * the tile.
 */
#define PNG_PASS_MASK(pass,off) ( \
   ((0x110145AF>>(((7-(off))-(pass))<<2)) & 0xF) | \
   ((0x01145AF0>>(((7-(off))-(pass))<<2)) & 0xF0))

#define PNG_ROW_IN_INTERLACE_PASS(y, pass) \
   ((PNG_PASS_MASK(pass,0) >> ((y)&7)) & 1)
#define PNG_COL_IN_INTERLACE_PASS(x, pass) \
   ((PNG_PASS_MASK(pass,1) >> ((x)&7)) & 1)

#ifdef PNG_READ_COMPOSITE_NODIV_SUPPORTED
/* With these routines we avoid an integer divide, which will be slower on
 * most machines.  However, it does take more operations than the corresponding
 * divide method, so it may be slower on a few RISC systems.  There are two
 * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.
 *
 * Note that the rounding factors are NOT supposed to be the same!  128 and
 * 32768 are correct for the NODIV code; 127 and 32767 are correct for the
 * standard method.
 *
 * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]
 */

 /* fg and bg should be in `gamma 1.0' space; alpha is the opacity */

#  define png_composite(composite, fg, alpha, bg)        \
   {                                                     \
      png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
          * (png_uint_16)(alpha)                         \
          + (png_uint_16)(bg)*(png_uint_16)(255          \
          - (png_uint_16)(alpha)) + 128);                \
      (composite) = (png_byte)(((temp + (temp >> 8)) >> 8) & 0xff); \
   }

#  define png_composite_16(composite, fg, alpha, bg)     \
   {                                                     \
      png_uint_32 temp = (png_uint_32)((png_uint_32)(fg) \
          * (png_uint_32)(alpha)                         \
          + (png_uint_32)(bg)*(65535                     \
          - (png_uint_32)(alpha)) + 32768);              \
      (composite) = (png_uint_16)(0xffff & ((temp + (temp >> 16)) >> 16)); \
   }

#else  /* Standard method using integer division */

#  define png_composite(composite, fg, alpha, bg)                      \
   (composite) =                                                       \
       (png_byte)(0xff & (((png_uint_16)(fg) * (png_uint_16)(alpha) +  \
       (png_uint_16)(bg) * (png_uint_16)(255 - (png_uint_16)(alpha)) + \
       127) / 255))

#  define png_composite_16(composite, fg, alpha, bg)                       \
   (composite) =                                                           \
       (png_uint_16)(0xffff & (((png_uint_32)(fg) * (png_uint_32)(alpha) + \
       (png_uint_32)(bg)*(png_uint_32)(65535 - (png_uint_32)(alpha)) +     \
       32767) / 65535))
#endif /* READ_COMPOSITE_NODIV */

#ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED
PNG_EXPORT(201, png_uint_32, png_get_uint_32, (png_const_bytep buf));
PNG_EXPORT(202, png_uint_16, png_get_uint_16, (png_const_bytep buf));
PNG_EXPORT(203, png_int_32, png_get_int_32, (png_const_bytep buf));
#endif

PNG_EXPORT(204, png_uint_32, png_get_uint_31, (png_const_structrp png_ptr,
    png_const_bytep buf));
/* No png_get_int_16 -- may be added if there's a real need for it. */

/* Place a 32-bit number into a buffer in PNG byte order (big-endian). */
#ifdef PNG_WRITE_INT_FUNCTIONS_SUPPORTED
PNG_EXPORT(205, void, png_save_uint_32, (png_bytep buf, png_uint_32 i));
#endif
#ifdef PNG_SAVE_INT_32_SUPPORTED
PNG_EXPORT(206, void, png_save_int_32, (png_bytep buf, png_int_32 i));
#endif

/* Place a 16-bit number into a buffer in PNG byte order.
 * The parameter is declared unsigned int, not png_uint_16,
 * just to avoid potential problems on pre-ANSI C compilers.
 */
#ifdef PNG_WRITE_INT_FUNCTIONS_SUPPORTED
PNG_EXPORT(207, void, png_save_uint_16, (png_bytep buf, unsigned int i));
/* No png_save_int_16 -- may be added if there's a real need for it. */
#endif

#ifdef PNG_USE_READ_MACROS
/* Inline macros to do direct reads of bytes from the input buffer.
 * The png_get_int_32() routine assumes we are using two's complement
 * format for negative values, which is almost certainly true.
 */
#  define PNG_get_uint_32(buf) \
   (((png_uint_32)(*(buf)) << 24) + \
    ((png_uint_32)(*((buf) + 1)) << 16) + \
    ((png_uint_32)(*((buf) + 2)) << 8) + \
    ((png_uint_32)(*((buf) + 3))))

   /* From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
    * function) incorrectly returned a value of type png_uint_32.
    */
#  define PNG_get_uint_16(buf) \
   ((png_uint_16) \
    (((unsigned int)(*(buf)) << 8) + \
    ((unsigned int)(*((buf) + 1)))))

#  define PNG_get_int_32(buf) \
   ((png_int_32)((*(buf) & 0x80) \
    ? -((png_int_32)(((png_get_uint_32(buf)^0xffffffffU)+1U)&0x7fffffffU)) \
    : (png_int_32)png_get_uint_32(buf)))

/* If PNG_PREFIX is defined the same thing as below happens in pnglibconf.h,
 * but defining a macro name prefixed with PNG_PREFIX.
 */
#  ifndef PNG_PREFIX
#    define png_get_uint_32(buf) PNG_get_uint_32(buf)
#    define png_get_uint_16(buf) PNG_get_uint_16(buf)
#    define png_get_int_32(buf)  PNG_get_int_32(buf)
#  endif
#else
#  ifdef PNG_PREFIX
   /* No macros; revert to the (redefined) function */
#    define PNG_get_uint_32 (png_get_uint_32)
#    define PNG_get_uint_16 (png_get_uint_16)
#    define PNG_get_int_32  (png_get_int_32)
#  endif
#endif

#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
PNG_EXPORT(242, void, png_set_check_for_invalid_index,
    (png_structrp png_ptr, int allowed));
#  ifdef PNG_GET_PALETTE_MAX_SUPPORTED
PNG_EXPORT(243, int, png_get_palette_max, (png_const_structp png_ptr,
    png_const_infop info_ptr));
#  endif
#endif /* CHECK_FOR_INVALID_INDEX */

/*******************************************************************************
 * Section 5: SIMPLIFIED API
 *******************************************************************************
 *
 * Please read the documentation in libpng-manual.txt (TODO: write said
 * documentation) if you don't understand what follows.
 *
 * The simplified API hides the details of both libpng and the PNG file format
 * itself.  It allows PNG files to be read into a very limited number of
 * in-memory bitmap formats or to be written from the same formats.  If these
 * formats do not accomodate your needs then you can, and should, use the more
 * sophisticated APIs above - these support a wide variety of in-memory formats
 * and a wide variety of sophisticated transformations to those formats as well
 * as a wide variety of APIs to manipulate ancillary information.
 *
 * To read a PNG file using the simplified API:
 *
 * 1) Declare a 'png_image' structure (see below) on the stack, set the
 *    version field to PNG_IMAGE_VERSION and the 'opaque' pointer to NULL
 *    (this is REQUIRED, your program may crash if you don't do it.)
 * 2) Call the appropriate png_image_begin_read... function.
 * 3) Set the png_image 'format' member to the required sample format.
 * 4) Allocate a buffer for the image and, if required, the color-map.
 * 5) Call png_image_finish_read to read the image and, if required, the
 *    color-map into your buffers.
 *
 * There are no restrictions on the format of the PNG input itself; all valid
 * color types, bit depths, and interlace methods are acceptable, and the
 * input image is transformed as necessary to the requested in-memory format
 * during the png_image_finish_read() step.  The only caveat is that if you
 * request a color-mapped image from a PNG that is full-color or makes
 * complex use of an alpha channel the transformation is extremely lossy and the
 * result may look terrible.
 *
 * To write a PNG file using the simplified API:
 *
 * 1) Declare a 'png_image' structure on the stack and memset() it to all zero.
 * 2) Initialize the members of the structure that describe the image, setting
 *    the 'format' member to the format of the image samples.
 * 3) Call the appropriate png_image_write... function with a pointer to the
 *    image and, if necessary, the color-map to write the PNG data.
 *
 * png_image is a structure that describes the in-memory format of an image
 * when it is being read or defines the in-memory format of an image that you
 * need to write:
 */
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) || \
    defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)

#define PNG_IMAGE_VERSION 1

typedef struct png_control *png_controlp;
typedef struct
{
   png_controlp opaque;    /* Initialize to NULL, free with png_image_free */
   png_uint_32  version;   /* Set to PNG_IMAGE_VERSION */
   png_uint_32  width;     /* Image width in pixels (columns) */
   png_uint_32  height;    /* Image height in pixels (rows) */
   png_uint_32  format;    /* Image format as defined below */
   png_uint_32  flags;     /* A bit mask containing informational flags */
   png_uint_32  colormap_entries;
                           /* Number of entries in the color-map */

   /* In the event of an error or warning the following field will be set to a
    * non-zero value and the 'message' field will contain a '\0' terminated
    * string with the libpng error or warning message.  If both warnings and
    * an error were encountered, only the error is recorded.  If there
    * are multiple warnings, only the first one is recorded.
    *
    * The upper 30 bits of this value are reserved, the low two bits contain
    * a value as follows:
    */
#  define PNG_IMAGE_WARNING 1
#  define PNG_IMAGE_ERROR 2
   /*
    * The result is a two-bit code such that a value more than 1 indicates
    * a failure in the API just called:
    *
    *    0 - no warning or error
    *    1 - warning
    *    2 - error
    *    3 - error preceded by warning
    */
#  define PNG_IMAGE_FAILED(png_cntrl) ((((png_cntrl).warning_or_error)&0x03)>1)

   png_uint_32  warning_or_error;

   char         message[64];
} png_image, *png_imagep;

/* The samples of the image have one to four channels whose components have
 * original values in the range 0 to 1.0:
 *
 * 1: A single gray or luminance channel (G).
 * 2: A gray/luminance channel and an alpha channel (GA).
 * 3: Three red, green, blue color channels (RGB).
 * 4: Three color channels and an alpha channel (RGBA).
 *
 * The components are encoded in one of two ways:
 *
 * a) As a small integer, value 0..255, contained in a single byte.  For the
 * alpha channel the original value is simply value/255.  For the color or
 * luminance channels the value is encoded according to the sRGB specification
 * and matches the 8-bit format expected by typical display devices.
 *
 * The color/gray channels are not scaled (pre-multiplied) by the alpha
 * channel and are suitable for passing to color management software.
 *
 * b) As a value in the range 0..65535, contained in a 2-byte integer.  All
 * channels can be converted to the original value by dividing by 65535; all
 * channels are linear.  Color channels use the RGB encoding (RGB end-points) of
 * the sRGB specification.  This encoding is identified by the
 * PNG_FORMAT_FLAG_LINEAR flag below.
 *
 * When the simplified API needs to convert between sRGB and linear colorspaces,
 * the actual sRGB transfer curve defined in the sRGB specification (see the
 * article at http://en.wikipedia.org/wiki/SRGB) is used, not the gamma=1/2.2
 * approximation used elsewhere in libpng.
 *
 * When an alpha channel is present it is expected to denote pixel coverage
 * of the color or luminance channels and is returned as an associated alpha
 * channel: the color/gray channels are scaled (pre-multiplied) by the alpha
 * value.
 *
 * The samples are either contained directly in the image data, between 1 and 8
 * bytes per pixel according to the encoding, or are held in a color-map indexed
 * by bytes in the image data.  In the case of a color-map the color-map entries
 * are individual samples, encoded as above, and the image data has one byte per
 * pixel to select the relevant sample from the color-map.
 */

/* PNG_FORMAT_*
 *
 * #defines to be used in png_image::format.  Each #define identifies a
 * particular layout of sample data and, if present, alpha values.  There are
 * separate defines for each of the two component encodings.
 *
 * A format is built up using single bit flag values.  All combinations are
 * valid.  Formats can be built up from the flag values or you can use one of
 * the predefined values below.  When testing formats always use the FORMAT_FLAG
 * macros to test for individual features - future versions of the library may
 * add new flags.
 *
 * When reading or writing color-mapped images the format should be set to the
 * format of the entries in the color-map then png_image_{read,write}_colormap
 * called to read or write the color-map and set the format correctly for the
 * image data.  Do not set the PNG_FORMAT_FLAG_COLORMAP bit directly!
 *
 * NOTE: libpng can be built with particular features disabled. If you see
 * compiler errors because the definition of one of the following flags has been
 * compiled out it is because libpng does not have the required support.  It is
 * possible, however, for the libpng configuration to enable the format on just
 * read or just write; in that case you may see an error at run time.  You can
 * guard against this by checking for the definition of the appropriate
 * "_SUPPORTED" macro, one of:
 *
 *    PNG_SIMPLIFIED_{READ,WRITE}_{BGR,AFIRST}_SUPPORTED
 */
#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */

#ifdef PNG_FORMAT_BGR_SUPPORTED
#  define PNG_FORMAT_FLAG_BGR    0x10U /* BGR colors, else order is RGB */
#endif

#ifdef PNG_FORMAT_AFIRST_SUPPORTED
#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
#endif

/* Commonly used formats have predefined macros.
 *
 * First the single byte (sRGB) formats:
 */
#define PNG_FORMAT_GRAY 0
#define PNG_FORMAT_GA   PNG_FORMAT_FLAG_ALPHA
#define PNG_FORMAT_AG   (PNG_FORMAT_GA|PNG_FORMAT_FLAG_AFIRST)
#define PNG_FORMAT_RGB  PNG_FORMAT_FLAG_COLOR
#define PNG_FORMAT_BGR  (PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_BGR)
#define PNG_FORMAT_RGBA (PNG_FORMAT_RGB|PNG_FORMAT_FLAG_ALPHA)
#define PNG_FORMAT_ARGB (PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_AFIRST)
#define PNG_FORMAT_BGRA (PNG_FORMAT_BGR|PNG_FORMAT_FLAG_ALPHA)
#define PNG_FORMAT_ABGR (PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_AFIRST)

/* Then the linear 2-byte formats.  When naming these "Y" is used to
 * indicate a luminance (gray) channel.
 */
#define PNG_FORMAT_LINEAR_Y PNG_FORMAT_FLAG_LINEAR
#define PNG_FORMAT_LINEAR_Y_ALPHA (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_ALPHA)
#define PNG_FORMAT_LINEAR_RGB (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR)
#define PNG_FORMAT_LINEAR_RGB_ALPHA \
   (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA)

/* With color-mapped formats the image data is one byte for each pixel, the byte
 * is an index into the color-map which is formatted as above.  To obtain a
 * color-mapped format it is sufficient just to add the PNG_FOMAT_FLAG_COLORMAP
 * to one of the above definitions, or you can use one of the definitions below.
 */
#define PNG_FORMAT_RGB_COLORMAP  (PNG_FORMAT_RGB|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_BGR_COLORMAP  (PNG_FORMAT_BGR|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_RGBA_COLORMAP (PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_ARGB_COLORMAP (PNG_FORMAT_ARGB|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_BGRA_COLORMAP (PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_ABGR_COLORMAP (PNG_FORMAT_ABGR|PNG_FORMAT_FLAG_COLORMAP)

/* PNG_IMAGE macros
 *
 * These are convenience macros to derive information from a png_image
 * structure.  The PNG_IMAGE_SAMPLE_ macros return values appropriate to the
 * actual image sample values - either the entries in the color-map or the
 * pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values
 * for the pixels and will always return 1 for color-mapped formats.  The
 * remaining macros return information about the rows in the image and the
 * complete image.
 *
 * NOTE: All the macros that take a png_image::format parameter are compile time
 * constants if the format parameter is, itself, a constant.  Therefore these
 * macros can be used in array declarations and case labels where required.
 * Similarly the macros are also pre-processor constants (sizeof is not used) so
 * they can be used in #if tests.
 *
 * First the information about the samples.
 */
#define PNG_IMAGE_SAMPLE_CHANNELS(fmt)\
   (((fmt)&(PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA))+1)
   /* Return the total number of channels in a given format: 1..4 */

#define PNG_IMAGE_SAMPLE_COMPONENT_SIZE(fmt)\
   ((((fmt) & PNG_FORMAT_FLAG_LINEAR) >> 2)+1)
   /* Return the size in bytes of a single component of a pixel or color-map
    * entry (as appropriate) in the image: 1 or 2.
    */

#define PNG_IMAGE_SAMPLE_SIZE(fmt)\
   (PNG_IMAGE_SAMPLE_CHANNELS(fmt) * PNG_IMAGE_SAMPLE_COMPONENT_SIZE(fmt))
   /* This is the size of the sample data for one sample.  If the image is
    * color-mapped it is the size of one color-map entry (and image pixels are
    * one byte in size), otherwise it is the size of one image pixel.
    */

#define PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(fmt)\
   (PNG_IMAGE_SAMPLE_CHANNELS(fmt) * 256)
   /* The maximum size of the color-map required by the format expressed in a
    * count of components.  This can be used to compile-time allocate a
    * color-map:
    *
    * png_uint_16 colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(linear_fmt)];
    *
    * png_byte colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(sRGB_fmt)];
    *
    * Alternatively use the PNG_IMAGE_COLORMAP_SIZE macro below to use the
    * information from one of the png_image_begin_read_ APIs and dynamically
    * allocate the required memory.
    */

/* Corresponding information about the pixels */
#define PNG_IMAGE_PIXEL_(test,fmt)\
   (((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))

#define PNG_IMAGE_PIXEL_CHANNELS(fmt)\
   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_CHANNELS,fmt)
   /* The number of separate channels (components) in a pixel; 1 for a
    * color-mapped image.
    */

#define PNG_IMAGE_PIXEL_COMPONENT_SIZE(fmt)\
   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_COMPONENT_SIZE,fmt)
   /* The size, in bytes, of each component in a pixel; 1 for a color-mapped
    * image.
    */

#define PNG_IMAGE_PIXEL_SIZE(fmt) PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_SIZE,fmt)
   /* The size, in bytes, of a complete pixel; 1 for a color-mapped image. */

/* Information about the whole row, or whole image */
#define PNG_IMAGE_ROW_STRIDE(image)\
   (PNG_IMAGE_PIXEL_CHANNELS((image).format) * (image).width)
   /* Return the total number of components in a single row of the image; this
    * is the minimum 'row stride', the minimum count of components between each
    * row.  For a color-mapped image this is the minimum number of bytes in a
    * row.
    *
    * WARNING: this macro overflows for some images with more than one component
    * and very large image widths.  libpng will refuse to process an image where
    * this macro would overflow.
    */

#define PNG_IMAGE_BUFFER_SIZE(image, row_stride)\
   (PNG_IMAGE_PIXEL_COMPONENT_SIZE((image).format)*(image).height*(row_stride))
   /* Return the size, in bytes, of an image buffer given a png_image and a row
    * stride - the number of components to leave space for in each row.
    *
    * WARNING: this macro overflows a 32-bit integer for some large PNG images,
    * libpng will refuse to process an image where such an overflow would occur.
    */

#define PNG_IMAGE_SIZE(image)\
   PNG_IMAGE_BUFFER_SIZE(image, PNG_IMAGE_ROW_STRIDE(image))
   /* Return the size, in bytes, of the image in memory given just a png_image;
    * the row stride is the minimum stride required for the image.
    */

#define PNG_IMAGE_COLORMAP_SIZE(image)\
   (PNG_IMAGE_SAMPLE_SIZE((image).format) * (image).colormap_entries)
   /* Return the size, in bytes, of the color-map of this image.  If the image
    * format is not a color-map format this will return a size sufficient for
    * 256 entries in the given format; check PNG_FORMAT_FLAG_COLORMAP if
    * you don't want to allocate a color-map in this case.
    */

/* PNG_IMAGE_FLAG_*
 *
 * Flags containing additional information about the image are held in the
 * 'flags' field of png_image.
 */
#define PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB 0x01
   /* This indicates the the RGB values of the in-memory bitmap do not
    * correspond to the red, green and blue end-points defined by sRGB.
    */

#define PNG_IMAGE_FLAG_FAST 0x02
   /* On write emphasise speed over compression; the resultant PNG file will be
    * larger but will be produced significantly faster, particular for large
    * images.  Do not use this option for images which will be distributed, only
    * used it when producing intermediate files that will be read back in
    * repeatedly.  For a typical 24-bit image the option will double the read
    * speed at the cost of increasing the image size by 25%, however for many
    * more compressible images the PNG file can be 10 times larger with only a
    * slight speed gain.
    */

#define PNG_IMAGE_FLAG_16BIT_sRGB 0x04
   /* On read if the image is a 16-bit per component image and there is no gAMA
    * or sRGB chunk assume that the components are sRGB encoded.  Notice that
    * images output by the simplified API always have gamma information; setting
    * this flag only affects the interpretation of 16-bit images from an
    * external source.  It is recommended that the application expose this flag
    * to the user; the user can normally easily recognize the difference between
    * linear and sRGB encoding.  This flag has no effect on write - the data
    * passed to the write APIs must have the correct encoding (as defined
    * above.)
    *
    * If the flag is not set (the default) input 16-bit per component data is
    * assumed to be linear.
    *
    * NOTE: the flag can only be set after the png_image_begin_read_ call,
    * because that call initializes the 'flags' field.
    */

#ifdef PNG_SIMPLIFIED_READ_SUPPORTED
/* READ APIs
 * ---------
 *
 * The png_image passed to the read APIs must have been initialized by setting
 * the png_controlp field 'opaque' to NULL (or, safer, memset the whole thing.)
 */
#ifdef PNG_STDIO_SUPPORTED
PNG_EXPORT(234, int, png_image_begin_read_from_file, (png_imagep image,
   const char *file_name));
   /* The named file is opened for read and the image header is filled in
    * from the PNG header in the file.
    */

PNG_EXPORT(235, int, png_image_begin_read_from_stdio, (png_imagep image,
   FILE* file));
   /* The PNG header is read from the stdio FILE object. */
#endif /* STDIO */

PNG_EXPORT(236, int, png_image_begin_read_from_memory, (png_imagep image,
   png_const_voidp memory, png_size_t size));
   /* The PNG header is read from the given memory buffer. */

PNG_EXPORT(237, int, png_image_finish_read, (png_imagep image,
   png_const_colorp background, void *buffer, png_int_32 row_stride,
   void *colormap));
   /* Finish reading the image into the supplied buffer and clean up the
    * png_image structure.
    *
    * row_stride is the step, in byte or 2-byte units as appropriate,
    * between adjacent rows.  A positive stride indicates that the top-most row
    * is first in the buffer - the normal top-down arrangement.  A negative
    * stride indicates that the bottom-most row is first in the buffer.
    *
    * background need only be supplied if an alpha channel must be removed from
    * a png_byte format and the removal is to be done by compositing on a solid
    * color; otherwise it may be NULL and any composition will be done directly
    * onto the buffer.  The value is an sRGB color to use for the background,
    * for grayscale output the green channel is used.
    *
    * background must be supplied when an alpha channel must be removed from a
    * single byte color-mapped output format, in other words if:
    *
    * 1) The original format from png_image_begin_read_from_* had
    *    PNG_FORMAT_FLAG_ALPHA set.
    * 2) The format set by the application does not.
    * 3) The format set by the application has PNG_FORMAT_FLAG_COLORMAP set and
    *    PNG_FORMAT_FLAG_LINEAR *not* set.
    *
    * For linear output removing the alpha channel is always done by compositing
    * on black and background is ignored.
    *
    * colormap must be supplied when PNG_FORMAT_FLAG_COLORMAP is set.  It must
    * be at least the size (in bytes) returned by PNG_IMAGE_COLORMAP_SIZE.
    * image->colormap_entries will be updated to the actual number of entries
    * written to the colormap; this may be less than the original value.
    */

PNG_EXPORT(238, void, png_image_free, (png_imagep image));
   /* Free any data allocated by libpng in image->opaque, setting the pointer to
    * NULL.  May be called at any time after the structure is initialized.
    */
#endif /* SIMPLIFIED_READ */

#ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
/* WRITE APIS
 * ----------
 * For write you must initialize a png_image structure to describe the image to
 * be written.  To do this use memset to set the whole structure to 0 then
 * initialize fields describing your image.
 *
 * version: must be set to PNG_IMAGE_VERSION
 * opaque: must be initialized to NULL
 * width: image width in pixels
 * height: image height in rows
 * format: the format of the data (image and color-map) you wish to write
 * flags: set to 0 unless one of the defined flags applies; set
 *    PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB for color format images where the RGB
 *    values do not correspond to the colors in sRGB.
 * colormap_entries: set to the number of entries in the color-map (0 to 256)
 */
#ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
PNG_EXPORT(239, int, png_image_write_to_file, (png_imagep image,
   const char *file, int convert_to_8bit, const void *buffer,
   png_int_32 row_stride, const void *colormap));
   /* Write the image to the named file. */

PNG_EXPORT(240, int, png_image_write_to_stdio, (png_imagep image, FILE *file,
   int convert_to_8_bit, const void *buffer, png_int_32 row_stride,
   const void *colormap));
   /* Write the image to the given (FILE*). */
#endif /* SIMPLIFIED_WRITE_STDIO */

/* With all write APIs if image is in one of the linear formats with 16-bit
 * data then setting convert_to_8_bit will cause the output to be an 8-bit PNG
 * gamma encoded according to the sRGB specification, otherwise a 16-bit linear
 * encoded PNG file is written.
 *
 * With color-mapped data formats the colormap parameter point to a color-map
 * with at least image->colormap_entries encoded in the specified format.  If
 * the format is linear the written PNG color-map will be converted to sRGB
 * regardless of the convert_to_8_bit flag.
 *
 * With all APIs row_stride is handled as in the read APIs - it is the spacing
 * from one row to the next in component sized units (1 or 2 bytes) and if
 * negative indicates a bottom-up row layout in the buffer.  If row_stride is
 * zero, libpng will calculate it for you from the image width and number of
 * channels.
 *
 * Note that the write API does not support interlacing, sub-8-bit pixels or
 * most ancillary chunks.  If you need to write text chunks (e.g. for copyright
 * notices) you need to use one of the other APIs.
 */

PNG_EXPORT(245, int, png_image_write_to_memory, (png_imagep image, void *memory,
   png_alloc_size_t * PNG_RESTRICT memory_bytes, int convert_to_8_bit,
   const void *buffer, png_int_32 row_stride, const void *colormap));
   /* Write the image to the given memory buffer.  The function both writes the
    * whole PNG data stream to *memory and updates *memory_bytes with the count
    * of bytes written.
    *
    * 'memory' may be NULL.  In this case *memory_bytes is not read however on
    * success the number of bytes which would have been written will still be
    * stored in *memory_bytes.  On failure *memory_bytes will contain 0.
    *
    * If 'memory' is not NULL it must point to memory[*memory_bytes] of
    * writeable memory.
    *
    * If the function returns success memory[*memory_bytes] (if 'memory' is not
    * NULL) contains the written PNG data.  *memory_bytes will always be less
    * than or equal to the original value.
    *
    * If the function returns false and *memory_bytes was not changed an error
    * occured during write.  If *memory_bytes was changed, or is not 0 if
    * 'memory' was NULL, the write would have succeeded but for the memory
    * buffer being too small.  *memory_bytes contains the required number of
    * bytes and will be bigger that the original value.
    */

#define png_image_write_get_memory_size(image, size, convert_to_8_bit, buffer,\
   row_stride, colormap)\
   png_image_write_to_memory(&(image), 0, &(size), convert_to_8_bit, buffer,\
         row_stride, colormap)
   /* Return the amount of memory in 'size' required to compress this image.
    * The png_image structure 'image' must be filled in as in the above
    * function and must not be changed before the actual write call, the buffer
    * and all other parameters must also be identical to that in the final
    * write call.  The 'size' variable need not be initialized.
    *
    * NOTE: the macro returns true/false, if false is returned 'size' will be
    * set to zero and the write failed and probably will fail if tried again.
    */

/* You can pre-allocate the buffer by making sure it is of sufficient size
 * regardless of the amount of compression achieved.  The buffer size will
 * always be bigger than the original image and it will never be filled.  The
 * following macros are provided to assist in allocating the buffer.
 */
#define PNG_IMAGE_DATA_SIZE(image) (PNG_IMAGE_SIZE(image)+(image).height)
   /* The number of uncompressed bytes in the PNG byte encoding of the image;
    * uncompressing the PNG IDAT data will give this number of bytes.
    *
    * NOTE: while PNG_IMAGE_SIZE cannot overflow for an image in memory this
    * macro can because of the extra bytes used in the PNG byte encoding.  You
    * need to avoid this macro if your image size approaches 2^30 in width or
    * height.  The same goes for the remainder of these macros; they all produce
    * bigger numbers than the actual in-memory image size.
    */
#ifndef PNG_ZLIB_MAX_SIZE
#  define PNG_ZLIB_MAX_SIZE(b) ((b)+(((b)+7U)>>3)+(((b)+63U)>>6)+11U)
   /* An upper bound on the number of compressed bytes given 'b' uncompressed
    * bytes.  This is based on deflateBounds() in zlib; different
    * implementations of zlib compression may conceivably produce more data so
    * if your zlib implementation is not zlib itself redefine this macro
    * appropriately.
    */
#endif

#define PNG_IMAGE_COMPRESSED_SIZE_MAX(image)\
   PNG_ZLIB_MAX_SIZE((png_alloc_size_t)PNG_IMAGE_DATA_SIZE(image))
   /* An upper bound on the size of the data in the PNG IDAT chunks. */

#define PNG_IMAGE_PNG_SIZE_MAX_(image, image_size)\
   ((8U/*sig*/+25U/*IHDR*/+16U/*gAMA*/+44U/*cHRM*/+12U/*IEND*/+\
    (((image).format&PNG_FORMAT_FLAG_COLORMAP)?/*colormap: PLTE, tRNS*/\
    12U+3U*(image).colormap_entries/*PLTE data*/+\
    (((image).format&PNG_FORMAT_FLAG_ALPHA)?\
    12U/*tRNS*/+(image).colormap_entries:0U):0U)+\
    12U)+(12U*((image_size)/PNG_ZBUF_SIZE))/*IDAT*/+(image_size))
   /* A helper for the following macro; if your compiler cannot handle the
    * following macro use this one with the result of
    * PNG_IMAGE_COMPRESSED_SIZE_MAX(image) as the second argument (most
    * compilers should handle this just fine.)
    */

#define PNG_IMAGE_PNG_SIZE_MAX(image)\
   PNG_IMAGE_PNG_SIZE_MAX_(image, PNG_IMAGE_COMPRESSED_SIZE_MAX(image))
   /* An upper bound on the total length of the PNG data stream for 'image'.
    * The result is of type png_alloc_size_t, on 32-bit systems this may
    * overflow even though PNG_IMAGE_DATA_SIZE does not overflow; the write will
    * run out of buffer space but return a corrected size which should work.
    */
#endif /* SIMPLIFIED_WRITE */
/*******************************************************************************
 *  END OF SIMPLIFIED API
 ******************************************************************************/
#endif /* SIMPLIFIED_{READ|WRITE} */

/*******************************************************************************
 * Section 6: IMPLEMENTATION OPTIONS
 *******************************************************************************
 *
 * Support for arbitrary implementation-specific optimizations.  The API allows
 * particular options to be turned on or off.  'Option' is the number of the
 * option and 'onoff' is 0 (off) or non-0 (on).  The value returned is given
 * by the PNG_OPTION_ defines below.
 *
 * HARDWARE: normally hardware capabilites, such as the Intel SSE instructions,
 *           are detected at run time, however sometimes it may be impossible
 *           to do this in user mode, in which case it is necessary to discover
 *           the capabilities in an OS specific way.  Such capabilities are
 *           listed here when libpng has support for them and must be turned
 *           ON by the application if present.
 *
 * SOFTWARE: sometimes software optimizations actually result in performance
 *           decrease on some architectures or systems, or with some sets of
 *           PNG images.  'Software' options allow such optimizations to be
 *           selected at run time.
 */
#ifdef PNG_SET_OPTION_SUPPORTED
#ifdef PNG_ARM_NEON_API_SUPPORTED
#  define PNG_ARM_NEON   0 /* HARDWARE: ARM Neon SIMD instructions supported */
#endif
#define PNG_MAXIMUM_INFLATE_WINDOW 2 /* SOFTWARE: force maximum window */
#define PNG_SKIP_sRGB_CHECK_PROFILE 4 /* SOFTWARE: Check ICC profile for sRGB */
#ifdef PNG_MIPS_MSA_API_SUPPORTED
#  define PNG_MIPS_MSA   6 /* HARDWARE: MIPS Msa SIMD instructions supported */
#endif
#define PNG_IGNORE_ADLER32 8
#define PNG_OPTION_NEXT  10 /* Next option - numbers must be even */

/* Return values: NOTE: there are four values and 'off' is *not* zero */
#define PNG_OPTION_UNSET   0 /* Unset - defaults to off */
#define PNG_OPTION_INVALID 1 /* Option number out of range */
#define PNG_OPTION_OFF     2
#define PNG_OPTION_ON      3

PNG_EXPORT(244, int, png_set_option, (png_structrp png_ptr, int option,
   int onoff));
#endif /* SET_OPTION */

/*******************************************************************************
 *  END OF HARDWARE AND SOFTWARE OPTIONS
 ******************************************************************************/

/* Maintainer: Put new public prototypes here ^, in libpng.3, in project
 * defs, and in scripts/symbols.def.
 */

/* The last ordinal number (this is the *last* one already used; the next
 * one to use is one more than this.)
 */
#ifdef PNG_EXPORT_LAST_ORDINAL
  PNG_EXPORT_LAST_ORDINAL(245);
#endif

#ifdef __cplusplus
}
#endif

#endif /* PNG_VERSION_INFO_ONLY */
/* Do not put anything past this line */
#endif /* PNG_H */

```

`Engine/ThirdParty/PNG/Include/Android/pngconf.h`:

```h

/* pngconf.h - machine configurable file for libpng
 *
 * libpng version 1.6.28, January 5, 2017
 *
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * Any machine specific code is near the front of this file, so if you
 * are configuring libpng for a machine, you may want to read the section
 * starting here down to where it starts to typedef png_color, png_text,
 * and png_info.
 */

#ifndef PNGCONF_H
#define PNGCONF_H

#ifndef PNG_BUILDING_SYMBOL_TABLE /* else includes may cause problems */

/* From libpng 1.6.0 libpng requires an ANSI X3.159-1989 ("ISOC90") compliant C
 * compiler for correct compilation.  The following header files are required by
 * the standard.  If your compiler doesn't provide these header files, or they
 * do not match the standard, you will need to provide/improve them.
 */
#include <limits.h>
#include <stddef.h>

/* Library header files.  These header files are all defined by ISOC90; libpng
 * expects conformant implementations, however, an ISOC90 conformant system need
 * not provide these header files if the functionality cannot be implemented.
 * In this case it will be necessary to disable the relevant parts of libpng in
 * the build of pnglibconf.h.
 *
 * Prior to 1.6.0 string.h was included here; the API changes in 1.6.0 to not
 * include this unnecessary header file.
 */

#ifdef PNG_STDIO_SUPPORTED
   /* Required for the definition of FILE: */
#  include <stdio.h>
#endif

#ifdef PNG_SETJMP_SUPPORTED
   /* Required for the definition of jmp_buf and the declaration of longjmp: */
#  include <setjmp.h>
#endif

#ifdef PNG_CONVERT_tIME_SUPPORTED
   /* Required for struct tm: */
#  include <time.h>
#endif

#endif /* PNG_BUILDING_SYMBOL_TABLE */

/* Prior to 1.6.0 it was possible to turn off 'const' in declarations using
 * PNG_NO_CONST; this is no longer supported except for data declarations which
 * apparently still cause problems in 2011 on some compilers.
 */
#define PNG_CONST const /* backward compatibility only */

/* This controls optimization of the reading of 16-bit and 32-bit values
 * from PNG files.  It can be set on a per-app-file basis - it
 * just changes whether a macro is used when the function is called.
 * The library builder sets the default; if read functions are not
 * built into the library the macro implementation is forced on.
 */
#ifndef PNG_READ_INT_FUNCTIONS_SUPPORTED
#  define PNG_USE_READ_MACROS
#endif
#if !defined(PNG_NO_USE_READ_MACROS) && !defined(PNG_USE_READ_MACROS)
#  if PNG_DEFAULT_READ_MACROS
#    define PNG_USE_READ_MACROS
#  endif
#endif

/* COMPILER SPECIFIC OPTIONS.
 *
 * These options are provided so that a variety of difficult compilers
 * can be used.  Some are fixed at build time (e.g. PNG_API_RULE
 * below) but still have compiler specific implementations, others
 * may be changed on a per-file basis when compiling against libpng.
 */

/* The PNGARG macro was used in versions of libpng prior to 1.6.0 to protect
 * against legacy (pre ISOC90) compilers that did not understand function
 * prototypes.  It is not required for modern C compilers.
 */
#ifndef PNGARG
#  define PNGARG(arglist) arglist
#endif

/* Function calling conventions.
 * =============================
 * Normally it is not necessary to specify to the compiler how to call
 * a function - it just does it - however on x86 systems derived from
 * Microsoft and Borland C compilers ('IBM PC', 'DOS', 'Windows' systems
 * and some others) there are multiple ways to call a function and the
 * default can be changed on the compiler command line.  For this reason
 * libpng specifies the calling convention of every exported function and
 * every function called via a user supplied function pointer.  This is
 * done in this file by defining the following macros:
 *
 * PNGAPI    Calling convention for exported functions.
 * PNGCBAPI  Calling convention for user provided (callback) functions.
 * PNGCAPI   Calling convention used by the ANSI-C library (required
 *           for longjmp callbacks and sometimes used internally to
 *           specify the calling convention for zlib).
 *
 * These macros should never be overridden.  If it is necessary to
 * change calling convention in a private build this can be done
 * by setting PNG_API_RULE (which defaults to 0) to one of the values
 * below to select the correct 'API' variants.
 *
 * PNG_API_RULE=0 Use PNGCAPI - the 'C' calling convention - throughout.
 *                This is correct in every known environment.
 * PNG_API_RULE=1 Use the operating system convention for PNGAPI and
 *                the 'C' calling convention (from PNGCAPI) for
 *                callbacks (PNGCBAPI).  This is no longer required
 *                in any known environment - if it has to be used
 *                please post an explanation of the problem to the
 *                libpng mailing list.
 *
 * These cases only differ if the operating system does not use the C
 * calling convention, at present this just means the above cases
 * (x86 DOS/Windows systems) and, even then, this does not apply to
 * Cygwin running on those systems.
 *
 * Note that the value must be defined in pnglibconf.h so that what
 * the application uses to call the library matches the conventions
 * set when building the library.
 */

/* Symbol export
 * =============
 * When building a shared library it is almost always necessary to tell
 * the compiler which symbols to export.  The png.h macro 'PNG_EXPORT'
 * is used to mark the symbols.  On some systems these symbols can be
 * extracted at link time and need no special processing by the compiler,
 * on other systems the symbols are flagged by the compiler and just
 * the declaration requires a special tag applied (unfortunately) in a
 * compiler dependent way.  Some systems can do either.
 *
 * A small number of older systems also require a symbol from a DLL to
 * be flagged to the program that calls it.  This is a problem because
 * we do not know in the header file included by application code that
 * the symbol will come from a shared library, as opposed to a statically
 * linked one.  For this reason the application must tell us by setting
 * the magic flag PNG_USE_DLL to turn on the special processing before
 * it includes png.h.
 *
 * Four additional macros are used to make this happen:
 *
 * PNG_IMPEXP The magic (if any) to cause a symbol to be exported from
 *            the build or imported if PNG_USE_DLL is set - compiler
 *            and system specific.
 *
 * PNG_EXPORT_TYPE(type) A macro that pre or appends PNG_IMPEXP to
 *                       'type', compiler specific.
 *
 * PNG_DLL_EXPORT Set to the magic to use during a libpng build to
 *                make a symbol exported from the DLL.  Not used in the
 *                public header files; see pngpriv.h for how it is used
 *                in the libpng build.
 *
 * PNG_DLL_IMPORT Set to the magic to force the libpng symbols to come
 *                from a DLL - used to define PNG_IMPEXP when
 *                PNG_USE_DLL is set.
 */

/* System specific discovery.
 * ==========================
 * This code is used at build time to find PNG_IMPEXP, the API settings
 * and PNG_EXPORT_TYPE(), it may also set a macro to indicate the DLL
 * import processing is possible.  On Windows systems it also sets
 * compiler-specific macros to the values required to change the calling
 * conventions of the various functions.
 */
#if defined(_Windows) || defined(_WINDOWS) || defined(WIN32) ||\
    defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
  /* Windows system (DOS doesn't support DLLs).  Includes builds under Cygwin or
   * MinGW on any architecture currently supported by Windows.  Also includes
   * Watcom builds but these need special treatment because they are not
   * compatible with GCC or Visual C because of different calling conventions.
   */
#  if PNG_API_RULE == 2
   /* If this line results in an error, either because __watcall is not
    * understood or because of a redefine just below you cannot use *this*
    * build of the library with the compiler you are using.  *This* build was
    * build using Watcom and applications must also be built using Watcom!
    */
#    define PNGCAPI __watcall
#  endif

#  if defined(__GNUC__) || (defined(_MSC_VER) && (_MSC_VER >= 800))
#    define PNGCAPI __cdecl
#    if PNG_API_RULE == 1
   /* If this line results in an error __stdcall is not understood and
    * PNG_API_RULE should not have been set to '1'.
    */
#      define PNGAPI __stdcall
#    endif
#  else
   /* An older compiler, or one not detected (erroneously) above,
    * if necessary override on the command line to get the correct
    * variants for the compiler.
    */
#    ifndef PNGCAPI
#      define PNGCAPI _cdecl
#    endif
#    if PNG_API_RULE == 1 && !defined(PNGAPI)
#      define PNGAPI _stdcall
#    endif
#  endif /* compiler/api */

  /* NOTE: PNGCBAPI always defaults to PNGCAPI. */

#  if defined(PNGAPI) && !defined(PNG_USER_PRIVATEBUILD)
#     error "PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed"
#  endif

#  if (defined(_MSC_VER) && _MSC_VER < 800) ||\
      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
   /* older Borland and MSC
    * compilers used '__export' and required this to be after
    * the type.
    */
#    ifndef PNG_EXPORT_TYPE
#      define PNG_EXPORT_TYPE(type) type PNG_IMPEXP
#    endif
#    define PNG_DLL_EXPORT __export
#  else /* newer compiler */
#    define PNG_DLL_EXPORT __declspec(dllexport)
#    ifndef PNG_DLL_IMPORT
#      define PNG_DLL_IMPORT __declspec(dllimport)
#    endif
#  endif /* compiler */

#else /* !Windows */
#  if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
#    define PNGAPI _System
#  else /* !Windows/x86 && !OS/2 */
   /* Use the defaults, or define PNG*API on the command line (but
    * this will have to be done for every compile!)
    */
#  endif /* other system, !OS/2 */
#endif /* !Windows/x86 */

/* Now do all the defaulting . */
#ifndef PNGCAPI
#  define PNGCAPI
#endif
#ifndef PNGCBAPI
#  define PNGCBAPI PNGCAPI
#endif
#ifndef PNGAPI
#  define PNGAPI PNGCAPI
#endif

/* PNG_IMPEXP may be set on the compilation system command line or (if not set)
 * then in an internal header file when building the library, otherwise (when
 * using the library) it is set here.
 */
#ifndef PNG_IMPEXP
#  if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
   /* This forces use of a DLL, disallowing static linking */
#    define PNG_IMPEXP PNG_DLL_IMPORT
#  endif

#  ifndef PNG_IMPEXP
#    define PNG_IMPEXP
#  endif
#endif

/* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
 * 'attributes' as a storage class - the attributes go at the start of the
 * function definition, and attributes are always appended regardless of the
 * compiler.  This considerably simplifies these macros but may cause problems
 * if any compilers both need function attributes and fail to handle them as
 * a storage class (this is unlikely.)
 */
#ifndef PNG_FUNCTION
#  define PNG_FUNCTION(type, name, args, attributes) attributes type name args
#endif

#ifndef PNG_EXPORT_TYPE
#  define PNG_EXPORT_TYPE(type) PNG_IMPEXP type
#endif

   /* The ordinal value is only relevant when preprocessing png.h for symbol
    * table entries, so we discard it here.  See the .dfn files in the
    * scripts directory.
    */

#ifndef PNG_EXPORTA
#  define PNG_EXPORTA(ordinal, type, name, args, attributes) \
      PNG_FUNCTION(PNG_EXPORT_TYPE(type), (PNGAPI name), PNGARG(args), \
      PNG_LINKAGE_API attributes)
#endif

/* ANSI-C (C90) does not permit a macro to be invoked with an empty argument,
 * so make something non-empty to satisfy the requirement:
 */
#define PNG_EMPTY /*empty list*/

#define PNG_EXPORT(ordinal, type, name, args) \
   PNG_EXPORTA(ordinal, type, name, args, PNG_EMPTY)

/* Use PNG_REMOVED to comment out a removed interface. */
#ifndef PNG_REMOVED
#  define PNG_REMOVED(ordinal, type, name, args, attributes)
#endif

#ifndef PNG_CALLBACK
#  define PNG_CALLBACK(type, name, args) type (PNGCBAPI name) PNGARG(args)
#endif

/* Support for compiler specific function attributes.  These are used
 * so that where compiler support is available incorrect use of API
 * functions in png.h will generate compiler warnings.
 *
 * Added at libpng-1.2.41.
 */

#ifndef PNG_NO_PEDANTIC_WARNINGS
#  ifndef PNG_PEDANTIC_WARNINGS_SUPPORTED
#    define PNG_PEDANTIC_WARNINGS_SUPPORTED
#  endif
#endif

#ifdef PNG_PEDANTIC_WARNINGS_SUPPORTED
  /* Support for compiler specific function attributes.  These are used
   * so that where compiler support is available, incorrect use of API
   * functions in png.h will generate compiler warnings.  Added at libpng
   * version 1.2.41.  Disabling these removes the warnings but may also produce
   * less efficient code.
   */
#  if defined(__clang__) && defined(__has_attribute)
   /* Clang defines both __clang__ and __GNUC__. Check __clang__ first. */
#    if !defined(PNG_USE_RESULT) && __has_attribute(__warn_unused_result__)
#      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
#    endif
#    if !defined(PNG_NORETURN) && __has_attribute(__noreturn__)
#      define PNG_NORETURN __attribute__((__noreturn__))
#    endif
#    if !defined(PNG_ALLOCATED) && __has_attribute(__malloc__)
#      define PNG_ALLOCATED __attribute__((__malloc__))
#    endif
#    if !defined(PNG_DEPRECATED) && __has_attribute(__deprecated__)
#      define PNG_DEPRECATED __attribute__((__deprecated__))
#    endif
#    if !defined(PNG_PRIVATE)
#      ifdef __has_extension
#        if __has_extension(attribute_unavailable_with_message)
#          define PNG_PRIVATE __attribute__((__unavailable__(\
             "This function is not exported by libpng.")))
#        endif
#      endif
#    endif
#    ifndef PNG_RESTRICT
#      define PNG_RESTRICT __restrict
#    endif

#  elif defined(__GNUC__)
#    ifndef PNG_USE_RESULT
#      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
#    endif
#    ifndef PNG_NORETURN
#      define PNG_NORETURN   __attribute__((__noreturn__))
#    endif
#    if __GNUC__ >= 3
#      ifndef PNG_ALLOCATED
#        define PNG_ALLOCATED  __attribute__((__malloc__))
#      endif
#      ifndef PNG_DEPRECATED
#        define PNG_DEPRECATED __attribute__((__deprecated__))
#      endif
#      ifndef PNG_PRIVATE
#        if 0 /* Doesn't work so we use deprecated instead*/
#          define PNG_PRIVATE \
            __attribute__((warning("This function is not exported by libpng.")))
#        else
#          define PNG_PRIVATE \
            __attribute__((__deprecated__))
#        endif
#      endif
#      if ((__GNUC__ > 3) || !defined(__GNUC_MINOR__) || (__GNUC_MINOR__ >= 1))
#        ifndef PNG_RESTRICT
#          define PNG_RESTRICT __restrict
#        endif
#      endif /* __GNUC__.__GNUC_MINOR__ > 3.0 */
#    endif /* __GNUC__ >= 3 */

#  elif defined(_MSC_VER)  && (_MSC_VER >= 1300)
#    ifndef PNG_USE_RESULT
#      define PNG_USE_RESULT /* not supported */
#    endif
#    ifndef PNG_NORETURN
#      define PNG_NORETURN   __declspec(noreturn)
#    endif
#    ifndef PNG_ALLOCATED
#      if (_MSC_VER >= 1400)
#        define PNG_ALLOCATED __declspec(restrict)
#      endif
#    endif
#    ifndef PNG_DEPRECATED
#      define PNG_DEPRECATED __declspec(deprecated)
#    endif
#    ifndef PNG_PRIVATE
#      define PNG_PRIVATE __declspec(deprecated)
#    endif
#    ifndef PNG_RESTRICT
#      if (_MSC_VER >= 1400)
#        define PNG_RESTRICT __restrict
#      endif
#    endif

#  elif defined(__WATCOMC__)
#    ifndef PNG_RESTRICT
#      define PNG_RESTRICT __restrict
#    endif
#  endif
#endif /* PNG_PEDANTIC_WARNINGS */

#ifndef PNG_DEPRECATED
#  define PNG_DEPRECATED  /* Use of this function is deprecated */
#endif
#ifndef PNG_USE_RESULT
#  define PNG_USE_RESULT  /* The result of this function must be checked */
#endif
#ifndef PNG_NORETURN
#  define PNG_NORETURN    /* This function does not return */
#endif
#ifndef PNG_ALLOCATED
#  define PNG_ALLOCATED   /* The result of the function is new memory */
#endif
#ifndef PNG_PRIVATE
#  define PNG_PRIVATE     /* This is a private libpng function */
#endif
#ifndef PNG_RESTRICT
#  define PNG_RESTRICT    /* The C99 "restrict" feature */
#endif

#ifndef PNG_FP_EXPORT     /* A floating point API. */
#  ifdef PNG_FLOATING_POINT_SUPPORTED
#     define PNG_FP_EXPORT(ordinal, type, name, args)\
         PNG_EXPORT(ordinal, type, name, args);
#  else                   /* No floating point APIs */
#     define PNG_FP_EXPORT(ordinal, type, name, args)
#  endif
#endif
#ifndef PNG_FIXED_EXPORT  /* A fixed point API. */
#  ifdef PNG_FIXED_POINT_SUPPORTED
#     define PNG_FIXED_EXPORT(ordinal, type, name, args)\
         PNG_EXPORT(ordinal, type, name, args);
#  else                   /* No fixed point APIs */
#     define PNG_FIXED_EXPORT(ordinal, type, name, args)
#  endif
#endif

#ifndef PNG_BUILDING_SYMBOL_TABLE
/* Some typedefs to get us started.  These should be safe on most of the common
 * platforms.
 *
 * png_uint_32 and png_int_32 may, currently, be larger than required to hold a
 * 32-bit value however this is not normally advisable.
 *
 * png_uint_16 and png_int_16 should always be two bytes in size - this is
 * verified at library build time.
 *
 * png_byte must always be one byte in size.
 *
 * The checks below use constants from limits.h, as defined by the ISOC90
 * standard.
 */
#if CHAR_BIT == 8 && UCHAR_MAX == 255
   typedef unsigned char png_byte;
#else
#  error "libpng requires 8-bit bytes"
#endif

#if INT_MIN == -32768 && INT_MAX == 32767
   typedef int png_int_16;
#elif SHRT_MIN == -32768 && SHRT_MAX == 32767
   typedef short png_int_16;
#else
#  error "libpng requires a signed 16-bit type"
#endif

#if UINT_MAX == 65535
   typedef unsigned int png_uint_16;
#elif USHRT_MAX == 65535
   typedef unsigned short png_uint_16;
#else
#  error "libpng requires an unsigned 16-bit type"
#endif

#if INT_MIN < -2147483646 && INT_MAX > 2147483646
   typedef int png_int_32;
#elif LONG_MIN < -2147483646 && LONG_MAX > 2147483646
   typedef long int png_int_32;
#else
#  error "libpng requires a signed 32-bit (or more) type"
#endif

#if UINT_MAX > 4294967294U
   typedef unsigned int png_uint_32;
#elif ULONG_MAX > 4294967294U
   typedef unsigned long int png_uint_32;
#else
#  error "libpng requires an unsigned 32-bit (or more) type"
#endif

/* Prior to 1.6.0 it was possible to disable the use of size_t, 1.6.0, however,
 * requires an ISOC90 compiler and relies on consistent behavior of sizeof.
 */
typedef size_t png_size_t;
typedef ptrdiff_t png_ptrdiff_t;

/* libpng needs to know the maximum value of 'size_t' and this controls the
 * definition of png_alloc_size_t, below.  This maximum value of size_t limits
 * but does not control the maximum allocations the library makes - there is
 * direct application control of this through png_set_user_limits().
 */
#ifndef PNG_SMALL_SIZE_T
   /* Compiler specific tests for systems where size_t is known to be less than
    * 32 bits (some of these systems may no longer work because of the lack of
    * 'far' support; see above.)
    */
#  if (defined(__TURBOC__) && !defined(__FLAT__)) ||\
   (defined(_MSC_VER) && defined(MAXSEG_64K))
#     define PNG_SMALL_SIZE_T
#  endif
#endif

/* png_alloc_size_t is guaranteed to be no smaller than png_size_t, and no
 * smaller than png_uint_32.  Casts from png_size_t or png_uint_32 to
 * png_alloc_size_t are not necessary; in fact, it is recommended not to use
 * them at all so that the compiler can complain when something turns out to be
 * problematic.
 *
 * Casts in the other direction (from png_alloc_size_t to png_size_t or
 * png_uint_32) should be explicitly applied; however, we do not expect to
 * encounter practical situations that require such conversions.
 *
 * PNG_SMALL_SIZE_T must be defined if the maximum value of size_t is less than
 * 4294967295 - i.e. less than the maximum value of png_uint_32.
 */
#ifdef PNG_SMALL_SIZE_T
   typedef png_uint_32 png_alloc_size_t;
#else
   typedef png_size_t png_alloc_size_t;
#endif

/* Prior to 1.6.0 libpng offered limited support for Microsoft C compiler
 * implementations of Intel CPU specific support of user-mode segmented address
 * spaces, where 16-bit pointers address more than 65536 bytes of memory using
 * separate 'segment' registers.  The implementation requires two different
 * types of pointer (only one of which includes the segment value.)
 *
 * If required this support is available in version 1.2 of libpng and may be
 * available in versions through 1.5, although the correctness of the code has
 * not been verified recently.
 */

/* Typedef for floating-point numbers that are converted to fixed-point with a
 * multiple of 100,000, e.g., gamma
 */
typedef png_int_32 png_fixed_point;

/* Add typedefs for pointers */
typedef void                  * png_voidp;
typedef const void            * png_const_voidp;
typedef png_byte              * png_bytep;
typedef const png_byte        * png_const_bytep;
typedef png_uint_32           * png_uint_32p;
typedef const png_uint_32     * png_const_uint_32p;
typedef png_int_32            * png_int_32p;
typedef const png_int_32      * png_const_int_32p;
typedef png_uint_16           * png_uint_16p;
typedef const png_uint_16     * png_const_uint_16p;
typedef png_int_16            * png_int_16p;
typedef const png_int_16      * png_const_int_16p;
typedef char                  * png_charp;
typedef const char            * png_const_charp;
typedef png_fixed_point       * png_fixed_point_p;
typedef const png_fixed_point * png_const_fixed_point_p;
typedef png_size_t            * png_size_tp;
typedef const png_size_t      * png_const_size_tp;

#ifdef PNG_STDIO_SUPPORTED
typedef FILE            * png_FILE_p;
#endif

#ifdef PNG_FLOATING_POINT_SUPPORTED
typedef double       * png_doublep;
typedef const double * png_const_doublep;
#endif

/* Pointers to pointers; i.e. arrays */
typedef png_byte        * * png_bytepp;
typedef png_uint_32     * * png_uint_32pp;
typedef png_int_32      * * png_int_32pp;
typedef png_uint_16     * * png_uint_16pp;
typedef png_int_16      * * png_int_16pp;
typedef const char      * * png_const_charpp;
typedef char            * * png_charpp;
typedef png_fixed_point * * png_fixed_point_pp;
#ifdef PNG_FLOATING_POINT_SUPPORTED
typedef double          * * png_doublepp;
#endif

/* Pointers to pointers to pointers; i.e., pointer to array */
typedef char            * * * png_charppp;

#endif /* PNG_BUILDING_SYMBOL_TABLE */

#endif /* PNGCONF_H */

```

`Engine/ThirdParty/PNG/Include/Android/pnglibconf.h`:

```h
/* libpng 1.6.28 STANDARD API DEFINITION */

/* pnglibconf.h - library build configuration */

/* Libpng version 1.6.28 - January 5, 2017 */

/* Copyright (c) 1998-2015 Glenn Randers-Pehrson */

/* This code is released under the libpng license. */
/* For conditions of distribution and use, see the disclaimer */
/* and license in png.h */

/* pnglibconf.h */
/* Machine generated file: DO NOT EDIT */
/* Derived from: scripts/pnglibconf.dfa */
#ifndef PNGLCONF_H
#define PNGLCONF_H
/* options */
#define PNG_16BIT_SUPPORTED
#define PNG_ALIGNED_MEMORY_SUPPORTED
/*#undef PNG_ARM_NEON_API_SUPPORTED*/
/*#undef PNG_ARM_NEON_CHECK_SUPPORTED*/
#define PNG_BENIGN_ERRORS_SUPPORTED
#define PNG_BENIGN_READ_ERRORS_SUPPORTED
/*#undef PNG_BENIGN_WRITE_ERRORS_SUPPORTED*/
#define PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
#define PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
#define PNG_COLORSPACE_SUPPORTED
#define PNG_CONSOLE_IO_SUPPORTED
#define PNG_CONVERT_tIME_SUPPORTED
#define PNG_EASY_ACCESS_SUPPORTED
/*#undef PNG_ERROR_NUMBERS_SUPPORTED*/
#define PNG_ERROR_TEXT_SUPPORTED
#define PNG_FIXED_POINT_SUPPORTED
#define PNG_FLOATING_ARITHMETIC_SUPPORTED
#define PNG_FLOATING_POINT_SUPPORTED
#define PNG_FORMAT_AFIRST_SUPPORTED
#define PNG_FORMAT_BGR_SUPPORTED
#define PNG_GAMMA_SUPPORTED
#define PNG_GET_PALETTE_MAX_SUPPORTED
#define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
#define PNG_INCH_CONVERSIONS_SUPPORTED
#define PNG_INFO_IMAGE_SUPPORTED
#define PNG_IO_STATE_SUPPORTED
#define PNG_MNG_FEATURES_SUPPORTED
#define PNG_POINTER_INDEXING_SUPPORTED
#define PNG_PROGRESSIVE_READ_SUPPORTED
#define PNG_READ_16BIT_SUPPORTED
#define PNG_READ_ALPHA_MODE_SUPPORTED
#define PNG_READ_ANCILLARY_CHUNKS_SUPPORTED
#define PNG_READ_BACKGROUND_SUPPORTED
#define PNG_READ_BGR_SUPPORTED
#define PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
#define PNG_READ_COMPOSITE_NODIV_SUPPORTED
#define PNG_READ_COMPRESSED_TEXT_SUPPORTED
#define PNG_READ_EXPAND_16_SUPPORTED
#define PNG_READ_EXPAND_SUPPORTED
#define PNG_READ_FILLER_SUPPORTED
#define PNG_READ_GAMMA_SUPPORTED
#define PNG_READ_GET_PALETTE_MAX_SUPPORTED
#define PNG_READ_GRAY_TO_RGB_SUPPORTED
#define PNG_READ_INTERLACING_SUPPORTED
#define PNG_READ_INT_FUNCTIONS_SUPPORTED
#define PNG_READ_INVERT_ALPHA_SUPPORTED
#define PNG_READ_INVERT_SUPPORTED
#define PNG_READ_OPT_PLTE_SUPPORTED
#define PNG_READ_PACKSWAP_SUPPORTED
#define PNG_READ_PACK_SUPPORTED
#define PNG_READ_QUANTIZE_SUPPORTED
#define PNG_READ_RGB_TO_GRAY_SUPPORTED
#define PNG_READ_SCALE_16_TO_8_SUPPORTED
#define PNG_READ_SHIFT_SUPPORTED
#define PNG_READ_STRIP_16_TO_8_SUPPORTED
#define PNG_READ_STRIP_ALPHA_SUPPORTED
#define PNG_READ_SUPPORTED
#define PNG_READ_SWAP_ALPHA_SUPPORTED
#define PNG_READ_SWAP_SUPPORTED
#define PNG_READ_TEXT_SUPPORTED
#define PNG_READ_TRANSFORMS_SUPPORTED
#define PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_READ_USER_CHUNKS_SUPPORTED
#define PNG_READ_USER_TRANSFORM_SUPPORTED
#define PNG_READ_bKGD_SUPPORTED
#define PNG_READ_cHRM_SUPPORTED
#define PNG_READ_gAMA_SUPPORTED
#define PNG_READ_hIST_SUPPORTED
#define PNG_READ_iCCP_SUPPORTED
#define PNG_READ_iTXt_SUPPORTED
#define PNG_READ_oFFs_SUPPORTED
#define PNG_READ_pCAL_SUPPORTED
#define PNG_READ_pHYs_SUPPORTED
#define PNG_READ_sBIT_SUPPORTED
#define PNG_READ_sCAL_SUPPORTED
#define PNG_READ_sPLT_SUPPORTED
#define PNG_READ_sRGB_SUPPORTED
#define PNG_READ_tEXt_SUPPORTED
#define PNG_READ_tIME_SUPPORTED
#define PNG_READ_tRNS_SUPPORTED
#define PNG_READ_zTXt_SUPPORTED
#define PNG_SAVE_INT_32_SUPPORTED
#define PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_SEQUENTIAL_READ_SUPPORTED
#define PNG_SETJMP_SUPPORTED
#define PNG_SET_OPTION_SUPPORTED
#define PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_SET_USER_LIMITS_SUPPORTED
#define PNG_SIMPLIFIED_READ_AFIRST_SUPPORTED
#define PNG_SIMPLIFIED_READ_BGR_SUPPORTED
#define PNG_SIMPLIFIED_READ_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_BGR_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_SUPPORTED
#define PNG_STDIO_SUPPORTED
#define PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_TEXT_SUPPORTED
#define PNG_TIME_RFC1123_SUPPORTED
#define PNG_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_USER_CHUNKS_SUPPORTED
#define PNG_USER_LIMITS_SUPPORTED
#define PNG_USER_MEM_SUPPORTED
#define PNG_USER_TRANSFORM_INFO_SUPPORTED
#define PNG_USER_TRANSFORM_PTR_SUPPORTED
#define PNG_WARNINGS_SUPPORTED
#define PNG_WRITE_16BIT_SUPPORTED
#define PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
#define PNG_WRITE_BGR_SUPPORTED
#define PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
#define PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
#define PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
#define PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
#define PNG_WRITE_FILLER_SUPPORTED
#define PNG_WRITE_FILTER_SUPPORTED
#define PNG_WRITE_FLUSH_SUPPORTED
#define PNG_WRITE_GET_PALETTE_MAX_SUPPORTED
#define PNG_WRITE_INTERLACING_SUPPORTED
#define PNG_WRITE_INT_FUNCTIONS_SUPPORTED
#define PNG_WRITE_INVERT_ALPHA_SUPPORTED
#define PNG_WRITE_INVERT_SUPPORTED
#define PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
#define PNG_WRITE_PACKSWAP_SUPPORTED
#define PNG_WRITE_PACK_SUPPORTED
#define PNG_WRITE_SHIFT_SUPPORTED
#define PNG_WRITE_SUPPORTED
#define PNG_WRITE_SWAP_ALPHA_SUPPORTED
#define PNG_WRITE_SWAP_SUPPORTED
#define PNG_WRITE_TEXT_SUPPORTED
#define PNG_WRITE_TRANSFORMS_SUPPORTED
#define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_WRITE_USER_TRANSFORM_SUPPORTED
#define PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
#define PNG_WRITE_bKGD_SUPPORTED
#define PNG_WRITE_cHRM_SUPPORTED
#define PNG_WRITE_gAMA_SUPPORTED
#define PNG_WRITE_hIST_SUPPORTED
#define PNG_WRITE_iCCP_SUPPORTED
#define PNG_WRITE_iTXt_SUPPORTED
#define PNG_WRITE_oFFs_SUPPORTED
#define PNG_WRITE_pCAL_SUPPORTED
#define PNG_WRITE_pHYs_SUPPORTED
#define PNG_WRITE_sBIT_SUPPORTED
#define PNG_WRITE_sCAL_SUPPORTED
#define PNG_WRITE_sPLT_SUPPORTED
#define PNG_WRITE_sRGB_SUPPORTED
#define PNG_WRITE_tEXt_SUPPORTED
#define PNG_WRITE_tIME_SUPPORTED
#define PNG_WRITE_tRNS_SUPPORTED
#define PNG_WRITE_zTXt_SUPPORTED
#define PNG_bKGD_SUPPORTED
#define PNG_cHRM_SUPPORTED
#define PNG_gAMA_SUPPORTED
#define PNG_hIST_SUPPORTED
#define PNG_iCCP_SUPPORTED
#define PNG_iTXt_SUPPORTED
#define PNG_oFFs_SUPPORTED
#define PNG_pCAL_SUPPORTED
#define PNG_pHYs_SUPPORTED
#define PNG_sBIT_SUPPORTED
#define PNG_sCAL_SUPPORTED
#define PNG_sPLT_SUPPORTED
#define PNG_sRGB_SUPPORTED
#define PNG_tEXt_SUPPORTED
#define PNG_tIME_SUPPORTED
#define PNG_tRNS_SUPPORTED
#define PNG_zTXt_SUPPORTED
/* end of options */
/* settings */
#define PNG_API_RULE 0
#define PNG_DEFAULT_READ_MACROS 1
#define PNG_GAMMA_THRESHOLD_FIXED 5000
#define PNG_IDAT_READ_SIZE PNG_ZBUF_SIZE
#define PNG_INFLATE_BUF_SIZE 1024
#define PNG_LINKAGE_API extern
#define PNG_LINKAGE_CALLBACK extern
#define PNG_LINKAGE_DATA extern
#define PNG_LINKAGE_FUNCTION extern
#define PNG_MAX_GAMMA_8 11
#define PNG_QUANTIZE_BLUE_BITS 5
#define PNG_QUANTIZE_GREEN_BITS 5
#define PNG_QUANTIZE_RED_BITS 5
#define PNG_TEXT_Z_DEFAULT_COMPRESSION (-1)
#define PNG_TEXT_Z_DEFAULT_STRATEGY 0
#define PNG_USER_CHUNK_CACHE_MAX 1000
#define PNG_USER_CHUNK_MALLOC_MAX 8000000
#define PNG_USER_HEIGHT_MAX 1000000
#define PNG_USER_WIDTH_MAX 1000000
#define PNG_ZBUF_SIZE 8192
#define PNG_ZLIB_VERNUM 0 /* unknown */
#define PNG_Z_DEFAULT_COMPRESSION (-1)
#define PNG_Z_DEFAULT_NOFILTER_STRATEGY 0
#define PNG_Z_DEFAULT_STRATEGY 1
#define PNG_sCAL_PRECISION 5
#define PNG_sRGB_PROFILE_CHECKS 2
/* end of settings */
#endif /* PNGLCONF_H */

```

`Engine/ThirdParty/PNG/Include/IOS/png.h`:

```h

/* png.h - header file for PNG reference library
 *
 * libpng version 1.6.28, January 5, 2017
 *
 * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license (See LICENSE, below)
 *
 * Authors and maintainers:
 *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
 *   libpng versions 0.89, June 1996, through 0.96, May 1997: Andreas Dilger
 *   libpng versions 0.97, January 1998, through 1.6.28, January 5, 2017:
 *     Glenn Randers-Pehrson.
 *   See also "Contributing Authors", below.
 */

/*
 * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
 *
 * If you modify libpng you may insert additional notices immediately following
 * this sentence.
 *
 * This code is released under the libpng license.
 *
 * libpng versions 1.0.7, July 1, 2000 through 1.6.28, January 5, 2017 are
 * Copyright (c) 2000-2002, 2004, 2006-2017 Glenn Randers-Pehrson, are
 * derived from libpng-1.0.6, and are distributed according to the same
 * disclaimer and license as libpng-1.0.6 with the following individuals
 * added to the list of Contributing Authors:
 *
 *    Simon-Pierre Cadieux
 *    Eric S. Raymond
 *    Mans Rullgard
 *    Cosmin Truta
 *    Gilles Vollant
 *    James Yu
 *    Mandar Sahastrabuddhe
 *
 * and with the following additions to the disclaimer:
 *
 *    There is no warranty against interference with your enjoyment of the
 *    library or against infringement.  There is no warranty that our
 *    efforts or the library will fulfill any of your particular purposes
 *    or needs.  This library is provided with all faults, and the entire
 *    risk of satisfactory quality, performance, accuracy, and effort is with
 *    the user.
 *
 * Some files in the "contrib" directory and some configure-generated
 * files that are distributed with libpng have other copyright owners and
 * are released under other open source licenses.
 *
 * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
 * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from
 * libpng-0.96, and are distributed according to the same disclaimer and
 * license as libpng-0.96, with the following individuals added to the list
 * of Contributing Authors:
 *
 *    Tom Lane
 *    Glenn Randers-Pehrson
 *    Willem van Schaik
 *
 * libpng versions 0.89, June 1996, through 0.96, May 1997, are
 * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,
 * and are distributed according to the same disclaimer and license as
 * libpng-0.88, with the following individuals added to the list of
 * Contributing Authors:
 *
 *    John Bowler
 *    Kevin Bracey
 *    Sam Bushell
 *    Magnus Holmgren
 *    Greg Roelofs
 *    Tom Tanner
 *
 * Some files in the "scripts" directory have other copyright owners
 * but are released under this license.
 *
 * libpng versions 0.5, May 1995, through 0.88, January 1996, are
 * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
 *
 * For the purposes of this copyright and license, "Contributing Authors"
 * is defined as the following set of individuals:
 *
 *    Andreas Dilger
 *    Dave Martindale
 *    Guy Eric Schalnat
 *    Paul Schmidt
 *    Tim Wegner
 *
 * The PNG Reference Library is supplied "AS IS".  The Contributing Authors
 * and Group 42, Inc. disclaim all warranties, expressed or implied,
 * including, without limitation, the warranties of merchantability and of
 * fitness for any purpose.  The Contributing Authors and Group 42, Inc.
 * assume no liability for direct, indirect, incidental, special, exemplary,
 * or consequential damages, which may result from the use of the PNG
 * Reference Library, even if advised of the possibility of such damage.
 *
 * Permission is hereby granted to use, copy, modify, and distribute this
 * source code, or portions hereof, for any purpose, without fee, subject
 * to the following restrictions:
 *
 *   1. The origin of this source code must not be misrepresented.
 *
 *   2. Altered versions must be plainly marked as such and must not
 *      be misrepresented as being the original source.
 *
 *   3. This Copyright notice may not be removed or altered from any
 *      source or altered source distribution.
 *
 * The Contributing Authors and Group 42, Inc. specifically permit, without
 * fee, and encourage the use of this source code as a component to
 * supporting the PNG file format in commercial products.  If you use this
 * source code in a product, acknowledgment is not required but would be
 * appreciated.
 *
 * END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.
 *
 * TRADEMARK:
 *
 * The name "libpng" has not been registered by the Copyright owner
 * as a trademark in any jurisdiction.  However, because libpng has
 * been distributed and maintained world-wide, continually since 1995,
 * the Copyright owner claims "common-law trademark protection" in any
 * jurisdiction where common-law trademark is recognized.
 *
 * OSI CERTIFICATION:
 *
 * Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is
 * a certification mark of the Open Source Initiative. OSI has not addressed
 * the additional disclaimers inserted at version 1.0.7.
 *
 * EXPORT CONTROL:
 *
 * The Copyright owner believes that the Export Control Classification
 * Number (ECCN) for libpng is EAR99, which means not subject to export
 * controls or International Traffic in Arms Regulations (ITAR) because
 * it is open source, publicly available software, that does not contain
 * any encryption software.  See the EAR, paragraphs 734.3(b)(3) and
 * 734.7(b).
 */

/*
 * A "png_get_copyright" function is available, for convenient use in "about"
 * boxes and the like:
 *
 *    printf("%s", png_get_copyright(NULL));
 *
 * Also, the PNG logo (in PNG format, of course) is supplied in the
 * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
 */

/*
 * The contributing authors would like to thank all those who helped
 * with testing, bug fixes, and patience.  This wouldn't have been
 * possible without all of you.
 *
 * Thanks to Frank J. T. Wojcik for helping with the documentation.
 */

/* Note about libpng version numbers:
 *
 *    Due to various miscommunications, unforeseen code incompatibilities
 *    and occasional factors outside the authors' control, version numbering
 *    on the library has not always been consistent and straightforward.
 *    The following table summarizes matters since version 0.89c, which was
 *    the first widely used release:
 *
 *    source                 png.h  png.h  shared-lib
 *    version                string   int  version
 *    -------                ------ -----  ----------
 *    0.89c "1.0 beta 3"     0.89      89  1.0.89
 *    0.90  "1.0 beta 4"     0.90      90  0.90  [should have been 2.0.90]
 *    0.95  "1.0 beta 5"     0.95      95  0.95  [should have been 2.0.95]
 *    0.96  "1.0 beta 6"     0.96      96  0.96  [should have been 2.0.96]
 *    0.97b "1.00.97 beta 7" 1.00.97   97  1.0.1 [should have been 2.0.97]
 *    0.97c                  0.97      97  2.0.97
 *    0.98                   0.98      98  2.0.98
 *    0.99                   0.99      98  2.0.99
 *    0.99a-m                0.99      99  2.0.99
 *    1.00                   1.00     100  2.1.0 [100 should be 10000]
 *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]
 *    1.0.1       png.h string is   10001  2.1.0
 *    1.0.1a-e    identical to the  10002  from here on, the shared library
 *    1.0.2       source version)   10002  is 2.V where V is the source code
 *    1.0.2a-b                      10003  version, except as noted.
 *    1.0.3                         10003
 *    1.0.3a-d                      10004
 *    1.0.4                         10004
 *    1.0.4a-f                      10005
 *    1.0.5 (+ 2 patches)           10005
 *    1.0.5a-d                      10006
 *    1.0.5e-r                      10100 (not source compatible)
 *    1.0.5s-v                      10006 (not binary compatible)
 *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)
 *    1.0.6d-f                      10007 (still binary incompatible)
 *    1.0.6g                        10007
 *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)
 *    1.0.6i                        10007  10.6i
 *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)
 *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)
 *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)
 *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)
 *    1.0.7                    1    10007  (still compatible)
 *    ...
 *    1.0.19                  10    10019  10.so.0.19[.0]
 *    ...
 *    1.2.57                  13    10257  12.so.0.57[.0]
 *    ...
 *    1.5.28                  15    10527  15.so.15.28[.0]
 *    ...
 *    1.6.28                  16    10628  16.so.16.28[.0]
 *
 *    Henceforth the source version will match the shared-library major
 *    and minor numbers; the shared-library major version number will be
 *    used for changes in backward compatibility, as it is intended.  The
 *    PNG_LIBPNG_VER macro, which is not used within libpng but is available
 *    for applications, is an unsigned integer of the form xyyzz corresponding
 *    to the source version x.y.z (leading zeros in y and z).  Beta versions
 *    were given the previous public release number plus a letter, until
 *    version 1.0.6j; from then on they were given the upcoming public
 *    release number plus "betaNN" or "rcNN".
 *
 *    Binary incompatibility exists only when applications make direct access
 *    to the info_ptr or png_ptr members through png.h, and the compiled
 *    application is loaded with a different version of the library.
 *
 *    DLLNUM will change each time there are forward or backward changes
 *    in binary compatibility (e.g., when a new feature is added).
 *
 * See libpng.txt or libpng.3 for more information.  The PNG specification
 * is available as a W3C Recommendation and as an ISO Specification,
 * <http://www.w3.org/TR/2003/REC-PNG-20031110/
 */

/*
 * Y2K compliance in libpng:
 * =========================
 *
 *    January 5, 2017
 *
 *    Since the PNG Development group is an ad-hoc body, we can't make
 *    an official declaration.
 *
 *    This is your unofficial assurance that libpng from version 0.71 and
 *    upward through 1.6.28 are Y2K compliant.  It is my belief that
 *    earlier versions were also Y2K compliant.
 *
 *    Libpng only has two year fields.  One is a 2-byte unsigned integer
 *    that will hold years up to 65535.  The other, which is deprecated,
 *    holds the date in text format, and will hold years up to 9999.
 *
 *    The integer is
 *        "png_uint_16 year" in png_time_struct.
 *
 *    The string is
 *        "char time_buffer[29]" in png_struct.  This is no longer used
 *    in libpng-1.6.x and will be removed from libpng-1.7.0.
 *
 *    There are seven time-related functions:
 *        png.c: png_convert_to_rfc_1123_buffer() in png.c
 *          (formerly png_convert_to_rfc_1123() prior to libpng-1.5.x and
 *          png_convert_to_rfc_1152() in error prior to libpng-0.98)
 *        png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c
 *        png_convert_from_time_t() in pngwrite.c
 *        png_get_tIME() in pngget.c
 *        png_handle_tIME() in pngrutil.c, called in pngread.c
 *        png_set_tIME() in pngset.c
 *        png_write_tIME() in pngwutil.c, called in pngwrite.c
 *
 *    All handle dates properly in a Y2K environment.  The
 *    png_convert_from_time_t() function calls gmtime() to convert from system
 *    clock time, which returns (year - 1900), which we properly convert to
 *    the full 4-digit year.  There is a possibility that libpng applications
 *    are not passing 4-digit years into the png_convert_to_rfc_1123_buffer()
 *    function, or that they are incorrectly passing only a 2-digit year
 *    instead of "year - 1900" into the png_convert_from_struct_tm() function,
 *    but this is not under our control.  The libpng documentation has always
 *    stated that it works with 4-digit years, and the APIs have been
 *    documented as such.
 *
 *    The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
 *    integer to hold the year, and can hold years as large as 65535.
 *
 *    zlib, upon which libpng depends, is also Y2K compliant.  It contains
 *    no date-related code.
 *
 *       Glenn Randers-Pehrson
 *       libpng maintainer
 *       PNG Development Group
 */

#ifndef PNG_H
#define PNG_H

/* This is not the place to learn how to use libpng. The file libpng-manual.txt
 * describes how to use libpng, and the file example.c summarizes it
 * with some code on which to build.  This file is useful for looking
 * at the actual function definitions and structure components.  If that
 * file has been stripped from your copy of libpng, you can find it at
 * <http://www.libpng.org/pub/png/libpng-manual.txt>
 *
 * If you just need to read a PNG file and don't want to read the documentation
 * skip to the end of this file and read the section entitled 'simplified API'.
 */

/* Version information for png.h - this should match the version in png.c */
#define PNG_LIBPNG_VER_STRING "1.6.28"
#define PNG_HEADER_VERSION_STRING " libpng version 1.6.28 - January 5, 2017\n"

#define PNG_LIBPNG_VER_SONUM   16
#define PNG_LIBPNG_VER_DLLNUM  16

/* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
#define PNG_LIBPNG_VER_MAJOR   1
#define PNG_LIBPNG_VER_MINOR   6
#define PNG_LIBPNG_VER_RELEASE 28

/* This should match the numeric part of the final component of
 * PNG_LIBPNG_VER_STRING, omitting any leading zero:
 */

#define PNG_LIBPNG_VER_BUILD  0

/* Release Status */
#define PNG_LIBPNG_BUILD_ALPHA    1
#define PNG_LIBPNG_BUILD_BETA     2
#define PNG_LIBPNG_BUILD_RC       3
#define PNG_LIBPNG_BUILD_STABLE   4
#define PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK 7

/* Release-Specific Flags */
#define PNG_LIBPNG_BUILD_PATCH    8 /* Can be OR'ed with
                                       PNG_LIBPNG_BUILD_STABLE only */
#define PNG_LIBPNG_BUILD_PRIVATE 16 /* Cannot be OR'ed with
                                       PNG_LIBPNG_BUILD_SPECIAL */
#define PNG_LIBPNG_BUILD_SPECIAL 32 /* Cannot be OR'ed with
                                       PNG_LIBPNG_BUILD_PRIVATE */

#define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_STABLE

/* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
 * We must not include leading zeros.
 * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
 * version 1.0.0 was mis-numbered 100 instead of 10000).  From
 * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
 */
#define PNG_LIBPNG_VER 10628 /* 1.6.28 */

/* Library configuration: these options cannot be changed after
 * the library has been built.
 */
#ifndef PNGLCONF_H
/* If pnglibconf.h is missing, you can
 * copy scripts/pnglibconf.h.prebuilt to pnglibconf.h
 */
#   include "pnglibconf.h"
#endif

#ifndef PNG_VERSION_INFO_ONLY
/* Machine specific configuration. */
#  include "pngconf.h"
#endif

/*
 * Added at libpng-1.2.8
 *
 * Ref MSDN: Private as priority over Special
 * VS_FF_PRIVATEBUILD File *was not* built using standard release
 * procedures. If this value is given, the StringFileInfo block must
 * contain a PrivateBuild string.
 *
 * VS_FF_SPECIALBUILD File *was* built by the original company using
 * standard release procedures but is a variation of the standard
 * file of the same version number. If this value is given, the
 * StringFileInfo block must contain a SpecialBuild string.
 */

#ifdef PNG_USER_PRIVATEBUILD /* From pnglibconf.h */
#  define PNG_LIBPNG_BUILD_TYPE \
       (PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_PRIVATE)
#else
#  ifdef PNG_LIBPNG_SPECIALBUILD
#    define PNG_LIBPNG_BUILD_TYPE \
         (PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_SPECIAL)
#  else
#    define PNG_LIBPNG_BUILD_TYPE (PNG_LIBPNG_BUILD_BASE_TYPE)
#  endif
#endif

#ifndef PNG_VERSION_INFO_ONLY

/* Inhibit C++ name-mangling for libpng functions but not for system calls. */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* Version information for C files, stored in png.c.  This had better match
 * the version above.
 */
#define png_libpng_ver png_get_header_ver(NULL)

/* This file is arranged in several sections:
 *
 * 1. [omitted]
 * 2. Any configuration options that can be specified by for the application
 *    code when it is built.  (Build time configuration is in pnglibconf.h)
 * 3. Type definitions (base types are defined in pngconf.h), structure
 *    definitions.
 * 4. Exported library functions.
 * 5. Simplified API.
 * 6. Implementation options.
 *
 * The library source code has additional files (principally pngpriv.h) that
 * allow configuration of the library.
 */

/* Section 1: [omitted] */

/* Section 2: run time configuration
 * See pnglibconf.h for build time configuration
 *
 * Run time configuration allows the application to choose between
 * implementations of certain arithmetic APIs.  The default is set
 * at build time and recorded in pnglibconf.h, but it is safe to
 * override these (and only these) settings.  Note that this won't
 * change what the library does, only application code, and the
 * settings can (and probably should) be made on a per-file basis
 * by setting the #defines before including png.h
 *
 * Use macros to read integers from PNG data or use the exported
 * functions?
 *   PNG_USE_READ_MACROS: use the macros (see below)  Note that
 *     the macros evaluate their argument multiple times.
 *   PNG_NO_USE_READ_MACROS: call the relevant library function.
 *
 * Use the alternative algorithm for compositing alpha samples that
 * does not use division?
 *   PNG_READ_COMPOSITE_NODIV_SUPPORTED: use the 'no division'
 *      algorithm.
 *   PNG_NO_READ_COMPOSITE_NODIV: use the 'division' algorithm.
 *
 * How to handle benign errors if PNG_ALLOW_BENIGN_ERRORS is
 * false?
 *   PNG_ALLOW_BENIGN_ERRORS: map calls to the benign error
 *      APIs to png_warning.
 * Otherwise the calls are mapped to png_error.
 */

/* Section 3: type definitions, including structures and compile time
 * constants.
 * See pngconf.h for base types that vary by machine/system
 */

/* This triggers a compiler error in png.c, if png.c and png.h
 * do not agree upon the version number.
 */
typedef char* png_libpng_version_1_6_28;

/* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.
 *
 * png_struct is the cache of information used while reading or writing a single
 * PNG file.  One of these is always required, although the simplified API
 * (below) hides the creation and destruction of it.
 */
typedef struct png_struct_def png_struct;
typedef const png_struct * png_const_structp;
typedef png_struct * png_structp;
typedef png_struct * * png_structpp;

/* png_info contains information read from or to be written to a PNG file.  One
 * or more of these must exist while reading or creating a PNG file.  The
 * information is not used by libpng during read but is used to control what
 * gets written when a PNG file is created.  "png_get_" function calls read
 * information during read and "png_set_" functions calls write information
 * when creating a PNG.
 * been moved into a separate header file that is not accessible to
 * applications.  Read libpng-manual.txt or libpng.3 for more info.
 */
typedef struct png_info_def png_info;
typedef png_info * png_infop;
typedef const png_info * png_const_infop;
typedef png_info * * png_infopp;

/* Types with names ending 'p' are pointer types.  The corresponding types with
 * names ending 'rp' are identical pointer types except that the pointer is
 * marked 'restrict', which means that it is the only pointer to the object
 * passed to the function.  Applications should not use the 'restrict' types;
 * it is always valid to pass 'p' to a pointer with a function argument of the
 * corresponding 'rp' type.  Different compilers have different rules with
 * regard to type matching in the presence of 'restrict'.  For backward
 * compatibility libpng callbacks never have 'restrict' in their parameters and,
 * consequentially, writing portable application code is extremely difficult if
 * an attempt is made to use 'restrict'.
 */
typedef png_struct * PNG_RESTRICT png_structrp;
typedef const png_struct * PNG_RESTRICT png_const_structrp;
typedef png_info * PNG_RESTRICT png_inforp;
typedef const png_info * PNG_RESTRICT png_const_inforp;

/* Three color definitions.  The order of the red, green, and blue, (and the
 * exact size) is not important, although the size of the fields need to
 * be png_byte or png_uint_16 (as defined below).
 */
typedef struct png_color_struct
{
   png_byte red;
   png_byte green;
   png_byte blue;
} png_color;
typedef png_color * png_colorp;
typedef const png_color * png_const_colorp;
typedef png_color * * png_colorpp;

typedef struct png_color_16_struct
{
   png_byte index;    /* used for palette files */
   png_uint_16 red;   /* for use in red green blue files */
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 gray;  /* for use in grayscale files */
} png_color_16;
typedef png_color_16 * png_color_16p;
typedef const png_color_16 * png_const_color_16p;
typedef png_color_16 * * png_color_16pp;

typedef struct png_color_8_struct
{
   png_byte red;   /* for use in red green blue files */
   png_byte green;
   png_byte blue;
   png_byte gray;  /* for use in grayscale files */
   png_byte alpha; /* for alpha channel files */
} png_color_8;
typedef png_color_8 * png_color_8p;
typedef const png_color_8 * png_const_color_8p;
typedef png_color_8 * * png_color_8pp;

/*
 * The following two structures are used for the in-core representation
 * of sPLT chunks.
 */
typedef struct png_sPLT_entry_struct
{
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 alpha;
   png_uint_16 frequency;
} png_sPLT_entry;
typedef png_sPLT_entry * png_sPLT_entryp;
typedef const png_sPLT_entry * png_const_sPLT_entryp;
typedef png_sPLT_entry * * png_sPLT_entrypp;

/*  When the depth of the sPLT palette is 8 bits, the color and alpha samples
 *  occupy the LSB of their respective members, and the MSB of each member
 *  is zero-filled.  The frequency member always occupies the full 16 bits.
 */

typedef struct png_sPLT_struct
{
   png_charp name;           /* palette name */
   png_byte depth;           /* depth of palette samples */
   png_sPLT_entryp entries;  /* palette entries */
   png_int_32 nentries;      /* number of palette entries */
} png_sPLT_t;
typedef png_sPLT_t * png_sPLT_tp;
typedef const png_sPLT_t * png_const_sPLT_tp;
typedef png_sPLT_t * * png_sPLT_tpp;

#ifdef PNG_TEXT_SUPPORTED
/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,
 * and whether that contents is compressed or not.  The "key" field
 * points to a regular zero-terminated C string.  The "text" fields can be a
 * regular C string, an empty string, or a NULL pointer.
 * However, the structure returned by png_get_text() will always contain
 * the "text" field as a regular zero-terminated C string (possibly
 * empty), never a NULL pointer, so it can be safely used in printf() and
 * other string-handling functions.  Note that the "itxt_length", "lang", and
 * "lang_key" members of the structure only exist when the library is built
 * with iTXt chunk support.  Prior to libpng-1.4.0 the library was built by
 * default without iTXt support. Also note that when iTXt *is* supported,
 * the "lang" and "lang_key" fields contain NULL pointers when the
 * "compression" field contains * PNG_TEXT_COMPRESSION_NONE or
 * PNG_TEXT_COMPRESSION_zTXt. Note that the "compression value" is not the
 * same as what appears in the PNG tEXt/zTXt/iTXt chunk's "compression flag"
 * which is always 0 or 1, or its "compression method" which is always 0.
 */
typedef struct png_text_struct
{
   int  compression;       /* compression value:
                             -1: tEXt, none
                              0: zTXt, deflate
                              1: iTXt, none
                              2: iTXt, deflate  */
   png_charp key;          /* keyword, 1-79 character description of "text" */
   png_charp text;         /* comment, may be an empty string (ie "")
                              or a NULL pointer */
   png_size_t text_length; /* length of the text string */
   png_size_t itxt_length; /* length of the itxt string */
   png_charp lang;         /* language code, 0-79 characters
                              or a NULL pointer */
   png_charp lang_key;     /* keyword translated UTF-8 string, 0 or more
                              chars or a NULL pointer */
} png_text;
typedef png_text * png_textp;
typedef const png_text * png_const_textp;
typedef png_text * * png_textpp;
#endif

/* Supported compression types for text in PNG files (tEXt, and zTXt).
 * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed. */
#define PNG_TEXT_COMPRESSION_NONE_WR -3
#define PNG_TEXT_COMPRESSION_zTXt_WR -2
#define PNG_TEXT_COMPRESSION_NONE    -1
#define PNG_TEXT_COMPRESSION_zTXt     0
#define PNG_ITXT_COMPRESSION_NONE     1
#define PNG_ITXT_COMPRESSION_zTXt     2
#define PNG_TEXT_COMPRESSION_LAST     3  /* Not a valid value */

/* png_time is a way to hold the time in an machine independent way.
 * Two conversions are provided, both from time_t and struct tm.  There
 * is no portable way to convert to either of these structures, as far
 * as I know.  If you know of a portable way, send it to me.  As a side
 * note - PNG has always been Year 2000 compliant!
 */
typedef struct png_time_struct
{
   png_uint_16 year; /* full year, as in, 1995 */
   png_byte month;   /* month of year, 1 - 12 */
   png_byte day;     /* day of month, 1 - 31 */
   png_byte hour;    /* hour of day, 0 - 23 */
   png_byte minute;  /* minute of hour, 0 - 59 */
   png_byte second;  /* second of minute, 0 - 60 (for leap seconds) */
} png_time;
typedef png_time * png_timep;
typedef const png_time * png_const_timep;
typedef png_time * * png_timepp;

#if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) ||\
   defined(PNG_USER_CHUNKS_SUPPORTED)
/* png_unknown_chunk is a structure to hold queued chunks for which there is
 * no specific support.  The idea is that we can use this to queue
 * up private chunks for output even though the library doesn't actually
 * know about their semantics.
 *
 * The data in the structure is set by libpng on read and used on write.
 */
typedef struct png_unknown_chunk_t
{
   png_byte name[5]; /* Textual chunk name with '\0' terminator */
   png_byte *data;   /* Data, should not be modified on read! */
   png_size_t size;

   /* On write 'location' must be set using the flag values listed below.
    * Notice that on read it is set by libpng however the values stored have
    * more bits set than are listed below.  Always treat the value as a
    * bitmask.  On write set only one bit - setting multiple bits may cause the
    * chunk to be written in multiple places.
    */
   png_byte location; /* mode of operation at read time */
}
png_unknown_chunk;

typedef png_unknown_chunk * png_unknown_chunkp;
typedef const png_unknown_chunk * png_const_unknown_chunkp;
typedef png_unknown_chunk * * png_unknown_chunkpp;
#endif

/* Flag values for the unknown chunk location byte. */
#define PNG_HAVE_IHDR  0x01
#define PNG_HAVE_PLTE  0x02
#define PNG_AFTER_IDAT 0x08

/* Maximum positive integer used in PNG is (2^31)-1 */
#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
#define PNG_UINT_32_MAX ((png_uint_32)(-1))
#define PNG_SIZE_MAX ((png_size_t)(-1))

/* These are constants for fixed point values encoded in the
 * PNG specification manner (x100000)
 */
#define PNG_FP_1    100000
#define PNG_FP_HALF  50000
#define PNG_FP_MAX  ((png_fixed_point)0x7fffffffL)
#define PNG_FP_MIN  (-PNG_FP_MAX)

/* These describe the color_type field in png_info. */
/* color type masks */
#define PNG_COLOR_MASK_PALETTE    1
#define PNG_COLOR_MASK_COLOR      2
#define PNG_COLOR_MASK_ALPHA      4

/* color types.  Note that not all combinations are legal */
#define PNG_COLOR_TYPE_GRAY 0
#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
/* aliases */
#define PNG_COLOR_TYPE_RGBA  PNG_COLOR_TYPE_RGB_ALPHA
#define PNG_COLOR_TYPE_GA  PNG_COLOR_TYPE_GRAY_ALPHA

/* This is for compression type. PNG 1.0-1.2 only define the single type. */
#define PNG_COMPRESSION_TYPE_BASE 0 /* Deflate method 8, 32K window */
#define PNG_COMPRESSION_TYPE_DEFAULT PNG_COMPRESSION_TYPE_BASE

/* This is for filter type. PNG 1.0-1.2 only define the single type. */
#define PNG_FILTER_TYPE_BASE      0 /* Single row per-byte filtering */
#define PNG_INTRAPIXEL_DIFFERENCING 64 /* Used only in MNG datastreams */
#define PNG_FILTER_TYPE_DEFAULT   PNG_FILTER_TYPE_BASE

/* These are for the interlacing type.  These values should NOT be changed. */
#define PNG_INTERLACE_NONE        0 /* Non-interlaced image */
#define PNG_INTERLACE_ADAM7       1 /* Adam7 interlacing */
#define PNG_INTERLACE_LAST        2 /* Not a valid value */

/* These are for the oFFs chunk.  These values should NOT be changed. */
#define PNG_OFFSET_PIXEL          0 /* Offset in pixels */
#define PNG_OFFSET_MICROMETER     1 /* Offset in micrometers (1/10^6 meter) */
#define PNG_OFFSET_LAST           2 /* Not a valid value */

/* These are for the pCAL chunk.  These values should NOT be changed. */
#define PNG_EQUATION_LINEAR       0 /* Linear transformation */
#define PNG_EQUATION_BASE_E       1 /* Exponential base e transform */
#define PNG_EQUATION_ARBITRARY    2 /* Arbitrary base exponential transform */
#define PNG_EQUATION_HYPERBOLIC   3 /* Hyperbolic sine transformation */
#define PNG_EQUATION_LAST         4 /* Not a valid value */

/* These are for the sCAL chunk.  These values should NOT be changed. */
#define PNG_SCALE_UNKNOWN         0 /* unknown unit (image scale) */
#define PNG_SCALE_METER           1 /* meters per pixel */
#define PNG_SCALE_RADIAN          2 /* radians per pixel */
#define PNG_SCALE_LAST            3 /* Not a valid value */

/* These are for the pHYs chunk.  These values should NOT be changed. */
#define PNG_RESOLUTION_UNKNOWN    0 /* pixels/unknown unit (aspect ratio) */
#define PNG_RESOLUTION_METER      1 /* pixels/meter */
#define PNG_RESOLUTION_LAST       2 /* Not a valid value */

/* These are for the sRGB chunk.  These values should NOT be changed. */
#define PNG_sRGB_INTENT_PERCEPTUAL 0
#define PNG_sRGB_INTENT_RELATIVE   1
#define PNG_sRGB_INTENT_SATURATION 2
#define PNG_sRGB_INTENT_ABSOLUTE   3
#define PNG_sRGB_INTENT_LAST       4 /* Not a valid value */

/* This is for text chunks */
#define PNG_KEYWORD_MAX_LENGTH     79

/* Maximum number of entries in PLTE/sPLT/tRNS arrays */
#define PNG_MAX_PALETTE_LENGTH    256

/* These determine if an ancillary chunk's data has been successfully read
 * from the PNG header, or if the application has filled in the corresponding
 * data in the info_struct to be written into the output file.  The values
 * of the PNG_INFO_<chunk> defines should NOT be changed.
 */
#define PNG_INFO_gAMA 0x0001U
#define PNG_INFO_sBIT 0x0002U
#define PNG_INFO_cHRM 0x0004U
#define PNG_INFO_PLTE 0x0008U
#define PNG_INFO_tRNS 0x0010U
#define PNG_INFO_bKGD 0x0020U
#define PNG_INFO_hIST 0x0040U
#define PNG_INFO_pHYs 0x0080U
#define PNG_INFO_oFFs 0x0100U
#define PNG_INFO_tIME 0x0200U
#define PNG_INFO_pCAL 0x0400U
#define PNG_INFO_sRGB 0x0800U  /* GR-P, 0.96a */
#define PNG_INFO_iCCP 0x1000U  /* ESR, 1.0.6 */
#define PNG_INFO_sPLT 0x2000U  /* ESR, 1.0.6 */
#define PNG_INFO_sCAL 0x4000U  /* ESR, 1.0.6 */
#define PNG_INFO_IDAT 0x8000U  /* ESR, 1.0.6 */

/* This is used for the transformation routines, as some of them
 * change these values for the row.  It also should enable using
 * the routines for other purposes.
 */
typedef struct png_row_info_struct
{
   png_uint_32 width;    /* width of row */
   png_size_t rowbytes;  /* number of bytes in row */
   png_byte color_type;  /* color type of row */
   png_byte bit_depth;   /* bit depth of row */
   png_byte channels;    /* number of channels (1, 2, 3, or 4) */
   png_byte pixel_depth; /* bits per pixel (depth * channels) */
} png_row_info;

typedef png_row_info * png_row_infop;
typedef png_row_info * * png_row_infopp;

/* These are the function types for the I/O functions and for the functions
 * that allow the user to override the default I/O functions with his or her
 * own.  The png_error_ptr type should match that of user-supplied warning
 * and error functions, while the png_rw_ptr type should match that of the
 * user read/write data functions.  Note that the 'write' function must not
 * modify the buffer it is passed. The 'read' function, on the other hand, is
 * expected to return the read data in the buffer.
 */
typedef PNG_CALLBACK(void, *png_error_ptr, (png_structp, png_const_charp));
typedef PNG_CALLBACK(void, *png_rw_ptr, (png_structp, png_bytep, png_size_t));
typedef PNG_CALLBACK(void, *png_flush_ptr, (png_structp));
typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32,
    int));
typedef PNG_CALLBACK(void, *png_write_status_ptr, (png_structp, png_uint_32,
    int));

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
typedef PNG_CALLBACK(void, *png_progressive_info_ptr, (png_structp, png_infop));
typedef PNG_CALLBACK(void, *png_progressive_end_ptr, (png_structp, png_infop));

/* The following callback receives png_uint_32 row_number, int pass for the
 * png_bytep data of the row.  When transforming an interlaced image the
 * row number is the row number within the sub-image of the interlace pass, so
 * the value will increase to the height of the sub-image (not the full image)
 * then reset to 0 for the next pass.
 *
 * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
 * find the output pixel (x,y) given an interlaced sub-image pixel
 * (row,col,pass).  (See below for these macros.)
 */
typedef PNG_CALLBACK(void, *png_progressive_row_ptr, (png_structp, png_bytep,
    png_uint_32, int));
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
typedef PNG_CALLBACK(void, *png_user_transform_ptr, (png_structp, png_row_infop,
    png_bytep));
#endif

#ifdef PNG_USER_CHUNKS_SUPPORTED
typedef PNG_CALLBACK(int, *png_user_chunk_ptr, (png_structp,
    png_unknown_chunkp));
#endif
#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
/* not used anywhere */
/* typedef PNG_CALLBACK(void, *png_unknown_chunk_ptr, (png_structp)); */
#endif

#ifdef PNG_SETJMP_SUPPORTED
/* This must match the function definition in <setjmp.h>, and the application
 * must include this before png.h to obtain the definition of jmp_buf.  The
 * function is required to be PNG_NORETURN, but this is not checked.  If the
 * function does return the application will crash via an abort() or similar
 * system level call.
 *
 * If you get a warning here while building the library you may need to make
 * changes to ensure that pnglibconf.h records the calling convention used by
 * your compiler.  This may be very difficult - try using a different compiler
 * to build the library!
 */
PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), PNGARG((jmp_buf, int)), typedef);
#endif

/* Transform masks for the high-level interface */
#define PNG_TRANSFORM_IDENTITY       0x0000    /* read and write */
#define PNG_TRANSFORM_STRIP_16       0x0001    /* read only */
#define PNG_TRANSFORM_STRIP_ALPHA    0x0002    /* read only */
#define PNG_TRANSFORM_PACKING        0x0004    /* read and write */
#define PNG_TRANSFORM_PACKSWAP       0x0008    /* read and write */
#define PNG_TRANSFORM_EXPAND         0x0010    /* read only */
#define PNG_TRANSFORM_INVERT_MONO    0x0020    /* read and write */
#define PNG_TRANSFORM_SHIFT          0x0040    /* read and write */
#define PNG_TRANSFORM_BGR            0x0080    /* read and write */
#define PNG_TRANSFORM_SWAP_ALPHA     0x0100    /* read and write */
#define PNG_TRANSFORM_SWAP_ENDIAN    0x0200    /* read and write */
#define PNG_TRANSFORM_INVERT_ALPHA   0x0400    /* read and write */
#define PNG_TRANSFORM_STRIP_FILLER   0x0800    /* write only */
/* Added to libpng-1.2.34 */
#define PNG_TRANSFORM_STRIP_FILLER_BEFORE PNG_TRANSFORM_STRIP_FILLER
#define PNG_TRANSFORM_STRIP_FILLER_AFTER 0x1000 /* write only */
/* Added to libpng-1.4.0 */
#define PNG_TRANSFORM_GRAY_TO_RGB   0x2000      /* read only */
/* Added to libpng-1.5.4 */
#define PNG_TRANSFORM_EXPAND_16     0x4000      /* read only */
#if INT_MAX >= 0x8000 /* else this might break */
#define PNG_TRANSFORM_SCALE_16      0x8000      /* read only */
#endif

/* Flags for MNG supported features */
#define PNG_FLAG_MNG_EMPTY_PLTE     0x01
#define PNG_FLAG_MNG_FILTER_64      0x04
#define PNG_ALL_MNG_FEATURES        0x05

/* NOTE: prior to 1.5 these functions had no 'API' style declaration,
 * this allowed the zlib default functions to be used on Windows
 * platforms.  In 1.5 the zlib default malloc (which just calls malloc and
 * ignores the first argument) should be completely compatible with the
 * following.
 */
typedef PNG_CALLBACK(png_voidp, *png_malloc_ptr, (png_structp,
    png_alloc_size_t));
typedef PNG_CALLBACK(void, *png_free_ptr, (png_structp, png_voidp));

/* Section 4: exported functions
 * Here are the function definitions most commonly used.  This is not
 * the place to find out how to use libpng.  See libpng-manual.txt for the
 * full explanation, see example.c for the summary.  This just provides
 * a simple one line description of the use of each function.
 *
 * The PNG_EXPORT() and PNG_EXPORTA() macros used below are defined in
 * pngconf.h and in the *.dfn files in the scripts directory.
 *
 *   PNG_EXPORT(ordinal, type, name, (args));
 *
 *       ordinal:    ordinal that is used while building
 *                   *.def files. The ordinal value is only
 *                   relevant when preprocessing png.h with
 *                   the *.dfn files for building symbol table
 *                   entries, and are removed by pngconf.h.
 *       type:       return type of the function
 *       name:       function name
 *       args:       function arguments, with types
 *
 * When we wish to append attributes to a function prototype we use
 * the PNG_EXPORTA() macro instead.
 *
 *   PNG_EXPORTA(ordinal, type, name, (args), attributes);
 *
 *       ordinal, type, name, and args: same as in PNG_EXPORT().
 *       attributes: function attributes
 */

/* Returns the version number of the library */
PNG_EXPORT(1, png_uint_32, png_access_version_number, (void));

/* Tell lib we have already handled the first <num_bytes> magic bytes.
 * Handling more than 8 bytes from the beginning of the file is an error.
 */
PNG_EXPORT(2, void, png_set_sig_bytes, (png_structrp png_ptr, int num_bytes));

/* Check sig[start] through sig[start + num_to_check - 1] to see if it's a
 * PNG file.  Returns zero if the supplied bytes match the 8-byte PNG
 * signature, and non-zero otherwise.  Having num_to_check == 0 or
 * start > 7 will always fail (ie return non-zero).
 */
PNG_EXPORT(3, int, png_sig_cmp, (png_const_bytep sig, png_size_t start,
    png_size_t num_to_check));

/* Simple signature checking function.  This is the same as calling
 * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).
 */
#define png_check_sig(sig, n) !png_sig_cmp((sig), 0, (n))

/* Allocate and initialize png_ptr struct for reading, and any other memory. */
PNG_EXPORTA(4, png_structp, png_create_read_struct,
    (png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn),
    PNG_ALLOCATED);

/* Allocate and initialize png_ptr struct for writing, and any other memory */
PNG_EXPORTA(5, png_structp, png_create_write_struct,
    (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn),
    PNG_ALLOCATED);

PNG_EXPORT(6, png_size_t, png_get_compression_buffer_size,
    (png_const_structrp png_ptr));

PNG_EXPORT(7, void, png_set_compression_buffer_size, (png_structrp png_ptr,
    png_size_t size));

/* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp
 * match up.
 */
#ifdef PNG_SETJMP_SUPPORTED
/* This function returns the jmp_buf built in to *png_ptr.  It must be
 * supplied with an appropriate 'longjmp' function to use on that jmp_buf
 * unless the default error function is overridden in which case NULL is
 * acceptable.  The size of the jmp_buf is checked against the actual size
 * allocated by the library - the call will return NULL on a mismatch
 * indicating an ABI mismatch.
 */
PNG_EXPORT(8, jmp_buf*, png_set_longjmp_fn, (png_structrp png_ptr,
    png_longjmp_ptr longjmp_fn, size_t jmp_buf_size));
#  define png_jmpbuf(png_ptr) \
      (*png_set_longjmp_fn((png_ptr), longjmp, (sizeof (jmp_buf))))
#else
#  define png_jmpbuf(png_ptr) \
      (LIBPNG_WAS_COMPILED_WITH__PNG_NO_SETJMP)
#endif
/* This function should be used by libpng applications in place of
 * longjmp(png_ptr->jmpbuf, val).  If longjmp_fn() has been set, it
 * will use it; otherwise it will call PNG_ABORT().  This function was
 * added in libpng-1.5.0.
 */
PNG_EXPORTA(9, void, png_longjmp, (png_const_structrp png_ptr, int val),
    PNG_NORETURN);

#ifdef PNG_READ_SUPPORTED
/* Reset the compression stream */
PNG_EXPORTA(10, int, png_reset_zstream, (png_structrp png_ptr), PNG_DEPRECATED);
#endif

/* New functions added in libpng-1.0.2 (not enabled by default until 1.2.0) */
#ifdef PNG_USER_MEM_SUPPORTED
PNG_EXPORTA(11, png_structp, png_create_read_struct_2,
    (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn,
    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn),
    PNG_ALLOCATED);
PNG_EXPORTA(12, png_structp, png_create_write_struct_2,
    (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn,
    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn),
    PNG_ALLOCATED);
#endif

/* Write the PNG file signature. */
PNG_EXPORT(13, void, png_write_sig, (png_structrp png_ptr));

/* Write a PNG chunk - size, type, (optional) data, CRC. */
PNG_EXPORT(14, void, png_write_chunk, (png_structrp png_ptr, png_const_bytep
    chunk_name, png_const_bytep data, png_size_t length));

/* Write the start of a PNG chunk - length and chunk name. */
PNG_EXPORT(15, void, png_write_chunk_start, (png_structrp png_ptr,
    png_const_bytep chunk_name, png_uint_32 length));

/* Write the data of a PNG chunk started with png_write_chunk_start(). */
PNG_EXPORT(16, void, png_write_chunk_data, (png_structrp png_ptr,
    png_const_bytep data, png_size_t length));

/* Finish a chunk started with png_write_chunk_start() (includes CRC). */
PNG_EXPORT(17, void, png_write_chunk_end, (png_structrp png_ptr));

/* Allocate and initialize the info structure */
PNG_EXPORTA(18, png_infop, png_create_info_struct, (png_const_structrp png_ptr),
    PNG_ALLOCATED);

/* DEPRECATED: this function allowed init structures to be created using the
 * default allocation method (typically malloc).  Use is deprecated in 1.6.0 and
 * the API will be removed in the future.
 */
PNG_EXPORTA(19, void, png_info_init_3, (png_infopp info_ptr,
    png_size_t png_info_struct_size), PNG_DEPRECATED);

/* Writes all the PNG information before the image. */
PNG_EXPORT(20, void, png_write_info_before_PLTE,
    (png_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(21, void, png_write_info,
    (png_structrp png_ptr, png_const_inforp info_ptr));

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the information before the actual image data. */
PNG_EXPORT(22, void, png_read_info,
    (png_structrp png_ptr, png_inforp info_ptr));
#endif

#ifdef PNG_TIME_RFC1123_SUPPORTED
   /* Convert to a US string format: there is no localization support in this
    * routine.  The original implementation used a 29 character buffer in
    * png_struct, this will be removed in future versions.
    */
#if PNG_LIBPNG_VER < 10700
/* To do: remove this from libpng17 (and from libpng17/png.c and pngstruct.h) */
PNG_EXPORTA(23, png_const_charp, png_convert_to_rfc1123, (png_structrp png_ptr,
    png_const_timep ptime),PNG_DEPRECATED);
#endif
PNG_EXPORT(241, int, png_convert_to_rfc1123_buffer, (char out[29],
    png_const_timep ptime));
#endif

#ifdef PNG_CONVERT_tIME_SUPPORTED
/* Convert from a struct tm to png_time */
PNG_EXPORT(24, void, png_convert_from_struct_tm, (png_timep ptime,
    const struct tm * ttime));

/* Convert from time_t to png_time.  Uses gmtime() */
PNG_EXPORT(25, void, png_convert_from_time_t, (png_timep ptime, time_t ttime));
#endif /* CONVERT_tIME */

#ifdef PNG_READ_EXPAND_SUPPORTED
/* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */
PNG_EXPORT(26, void, png_set_expand, (png_structrp png_ptr));
PNG_EXPORT(27, void, png_set_expand_gray_1_2_4_to_8, (png_structrp png_ptr));
PNG_EXPORT(28, void, png_set_palette_to_rgb, (png_structrp png_ptr));
PNG_EXPORT(29, void, png_set_tRNS_to_alpha, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_EXPAND_16_SUPPORTED
/* Expand to 16-bit channels, forces conversion of palette to RGB and expansion
 * of a tRNS chunk if present.
 */
PNG_EXPORT(221, void, png_set_expand_16, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
/* Use blue, green, red order for pixels. */
PNG_EXPORT(30, void, png_set_bgr, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
/* Expand the grayscale to 24-bit RGB if necessary. */
PNG_EXPORT(31, void, png_set_gray_to_rgb, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
/* Reduce RGB to grayscale. */
#define PNG_ERROR_ACTION_NONE  1
#define PNG_ERROR_ACTION_WARN  2
#define PNG_ERROR_ACTION_ERROR 3
#define PNG_RGB_TO_GRAY_DEFAULT (-1)/*for red/green coefficients*/

PNG_FP_EXPORT(32, void, png_set_rgb_to_gray, (png_structrp png_ptr,
    int error_action, double red, double green))
PNG_FIXED_EXPORT(33, void, png_set_rgb_to_gray_fixed, (png_structrp png_ptr,
    int error_action, png_fixed_point red, png_fixed_point green))

PNG_EXPORT(34, png_byte, png_get_rgb_to_gray_status, (png_const_structrp
    png_ptr));
#endif

#ifdef PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
PNG_EXPORT(35, void, png_build_grayscale_palette, (int bit_depth,
    png_colorp palette));
#endif

#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
/* How the alpha channel is interpreted - this affects how the color channels
 * of a PNG file are returned to the calling application when an alpha channel,
 * or a tRNS chunk in a palette file, is present.
 *
 * This has no effect on the way pixels are written into a PNG output
 * datastream. The color samples in a PNG datastream are never premultiplied
 * with the alpha samples.
 *
 * The default is to return data according to the PNG specification: the alpha
 * channel is a linear measure of the contribution of the pixel to the
 * corresponding composited pixel, and the color channels are unassociated
 * (not premultiplied).  The gamma encoded color channels must be scaled
 * according to the contribution and to do this it is necessary to undo
 * the encoding, scale the color values, perform the composition and reencode
 * the values.  This is the 'PNG' mode.
 *
 * The alternative is to 'associate' the alpha with the color information by
 * storing color channel values that have been scaled by the alpha.
 * image.  These are the 'STANDARD', 'ASSOCIATED' or 'PREMULTIPLIED' modes
 * (the latter being the two common names for associated alpha color channels).
 *
 * For the 'OPTIMIZED' mode, a pixel is treated as opaque only if the alpha
 * value is equal to the maximum value.
 *
 * The final choice is to gamma encode the alpha channel as well.  This is
 * broken because, in practice, no implementation that uses this choice
 * correctly undoes the encoding before handling alpha composition.  Use this
 * choice only if other serious errors in the software or hardware you use
 * mandate it; the typical serious error is for dark halos to appear around
 * opaque areas of the composited PNG image because of arithmetic overflow.
 *
 * The API function png_set_alpha_mode specifies which of these choices to use
 * with an enumerated 'mode' value and the gamma of the required output:
 */
#define PNG_ALPHA_PNG           0 /* according to the PNG standard */
#define PNG_ALPHA_STANDARD      1 /* according to Porter/Duff */
#define PNG_ALPHA_ASSOCIATED    1 /* as above; this is the normal practice */
#define PNG_ALPHA_PREMULTIPLIED 1 /* as above */
#define PNG_ALPHA_OPTIMIZED     2 /* 'PNG' for opaque pixels, else 'STANDARD' */
#define PNG_ALPHA_BROKEN        3 /* the alpha channel is gamma encoded */

PNG_FP_EXPORT(227, void, png_set_alpha_mode, (png_structrp png_ptr, int mode,
    double output_gamma))
PNG_FIXED_EXPORT(228, void, png_set_alpha_mode_fixed, (png_structrp png_ptr,
    int mode, png_fixed_point output_gamma))
#endif

#if defined(PNG_GAMMA_SUPPORTED) || defined(PNG_READ_ALPHA_MODE_SUPPORTED)
/* The output_gamma value is a screen gamma in libpng terminology: it expresses
 * how to decode the output values, not how they are encoded.
 */
#define PNG_DEFAULT_sRGB -1       /* sRGB gamma and color space */
#define PNG_GAMMA_MAC_18 -2       /* Old Mac '1.8' gamma and color space */
#define PNG_GAMMA_sRGB   220000   /* Television standards--matches sRGB gamma */
#define PNG_GAMMA_LINEAR PNG_FP_1 /* Linear */
#endif

/* The following are examples of calls to png_set_alpha_mode to achieve the
 * required overall gamma correction and, where necessary, alpha
 * premultiplication.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
 *    This is the default libpng handling of the alpha channel - it is not
 *    pre-multiplied into the color components.  In addition the call states
 *    that the output is for a sRGB system and causes all PNG files without gAMA
 *    chunks to be assumed to be encoded using sRGB.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
 *    In this case the output is assumed to be something like an sRGB conformant
 *    display preceeded by a power-law lookup table of power 1.45.  This is how
 *    early Mac systems behaved.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_GAMMA_LINEAR);
 *    This is the classic Jim Blinn approach and will work in academic
 *    environments where everything is done by the book.  It has the shortcoming
 *    of assuming that input PNG data with no gamma information is linear - this
 *    is unlikely to be correct unless the PNG files where generated locally.
 *    Most of the time the output precision will be so low as to show
 *    significant banding in dark areas of the image.
 *
 * png_set_expand_16(pp);
 * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_DEFAULT_sRGB);
 *    This is a somewhat more realistic Jim Blinn inspired approach.  PNG files
 *    are assumed to have the sRGB encoding if not marked with a gamma value and
 *    the output is always 16 bits per component.  This permits accurate scaling
 *    and processing of the data.  If you know that your input PNG files were
 *    generated locally you might need to replace PNG_DEFAULT_sRGB with the
 *    correct value for your system.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_OPTIMIZED, PNG_DEFAULT_sRGB);
 *    If you just need to composite the PNG image onto an existing background
 *    and if you control the code that does this you can use the optimization
 *    setting.  In this case you just copy completely opaque pixels to the
 *    output.  For pixels that are not completely transparent (you just skip
 *    those) you do the composition math using png_composite or png_composite_16
 *    below then encode the resultant 8-bit or 16-bit values to match the output
 *    encoding.
 *
 * Other cases
 *    If neither the PNG nor the standard linear encoding work for you because
 *    of the software or hardware you use then you have a big problem.  The PNG
 *    case will probably result in halos around the image.  The linear encoding
 *    will probably result in a washed out, too bright, image (it's actually too
 *    contrasty.)  Try the ALPHA_OPTIMIZED mode above - this will probably
 *    substantially reduce the halos.  Alternatively try:
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);
 *    This option will also reduce the halos, but there will be slight dark
 *    halos round the opaque parts of the image where the background is light.
 *    In the OPTIMIZED mode the halos will be light halos where the background
 *    is dark.  Take your pick - the halos are unavoidable unless you can get
 *    your hardware/software fixed!  (The OPTIMIZED approach is slightly
 *    faster.)
 *
 * When the default gamma of PNG files doesn't match the output gamma.
 *    If you have PNG files with no gamma information png_set_alpha_mode allows
 *    you to provide a default gamma, but it also sets the ouput gamma to the
 *    matching value.  If you know your PNG files have a gamma that doesn't
 *    match the output you can take advantage of the fact that
 *    png_set_alpha_mode always sets the output gamma but only sets the PNG
 *    default if it is not already set:
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
 *    The first call sets both the default and the output gamma values, the
 *    second call overrides the output gamma without changing the default.  This
 *    is easier than achieving the same effect with png_set_gamma.  You must use
 *    PNG_ALPHA_PNG for the first call - internal checking in png_set_alpha will
 *    fire if more than one call to png_set_alpha_mode and png_set_background is
 *    made in the same read operation, however multiple calls with PNG_ALPHA_PNG
 *    are ignored.
 */

#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
PNG_EXPORT(36, void, png_set_strip_alpha, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
PNG_EXPORT(37, void, png_set_swap_alpha, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
PNG_EXPORT(38, void, png_set_invert_alpha, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
/* Add a filler byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. */
PNG_EXPORT(39, void, png_set_filler, (png_structrp png_ptr, png_uint_32 filler,
    int flags));
/* The values of the PNG_FILLER_ defines should NOT be changed */
#  define PNG_FILLER_BEFORE 0
#  define PNG_FILLER_AFTER 1
/* Add an alpha byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. */
PNG_EXPORT(40, void, png_set_add_alpha, (png_structrp png_ptr,
    png_uint_32 filler, int flags));
#endif /* READ_FILLER || WRITE_FILLER */

#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
/* Swap bytes in 16-bit depth files. */
PNG_EXPORT(41, void, png_set_swap, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
/* Use 1 byte per pixel in 1, 2, or 4-bit depth files. */
PNG_EXPORT(42, void, png_set_packing, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED) || \
    defined(PNG_WRITE_PACKSWAP_SUPPORTED)
/* Swap packing order of pixels in bytes. */
PNG_EXPORT(43, void, png_set_packswap, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
/* Converts files to legal bit depths. */
PNG_EXPORT(44, void, png_set_shift, (png_structrp png_ptr, png_const_color_8p
    true_bits));
#endif

#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
    defined(PNG_WRITE_INTERLACING_SUPPORTED)
/* Have the code handle the interlacing.  Returns the number of passes.
 * MUST be called before png_read_update_info or png_start_read_image,
 * otherwise it will not have the desired effect.  Note that it is still
 * necessary to call png_read_row or png_read_rows png_get_image_height
 * times for each pass.
*/
PNG_EXPORT(45, int, png_set_interlace_handling, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
/* Invert monochrome files */
PNG_EXPORT(46, void, png_set_invert_mono, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_BACKGROUND_SUPPORTED
/* Handle alpha and tRNS by replacing with a background color.  Prior to
 * libpng-1.5.4 this API must not be called before the PNG file header has been
 * read.  Doing so will result in unexpected behavior and possible warnings or
 * errors if the PNG file contains a bKGD chunk.
 */
PNG_FP_EXPORT(47, void, png_set_background, (png_structrp png_ptr,
    png_const_color_16p background_color, int background_gamma_code,
    int need_expand, double background_gamma))
PNG_FIXED_EXPORT(215, void, png_set_background_fixed, (png_structrp png_ptr,
    png_const_color_16p background_color, int background_gamma_code,
    int need_expand, png_fixed_point background_gamma))
#endif
#ifdef PNG_READ_BACKGROUND_SUPPORTED
#  define PNG_BACKGROUND_GAMMA_UNKNOWN 0
#  define PNG_BACKGROUND_GAMMA_SCREEN  1
#  define PNG_BACKGROUND_GAMMA_FILE    2
#  define PNG_BACKGROUND_GAMMA_UNIQUE  3
#endif

#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
/* Scale a 16-bit depth file down to 8-bit, accurately. */
PNG_EXPORT(229, void, png_set_scale_16, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
#define PNG_READ_16_TO_8_SUPPORTED /* Name prior to 1.5.4 */
/* Strip the second byte of information from a 16-bit depth file. */
PNG_EXPORT(48, void, png_set_strip_16, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_QUANTIZE_SUPPORTED
/* Turn on quantizing, and reduce the palette to the number of colors
 * available.
 */
PNG_EXPORT(49, void, png_set_quantize, (png_structrp png_ptr,
    png_colorp palette, int num_palette, int maximum_colors,
    png_const_uint_16p histogram, int full_quantize));
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
/* The threshold on gamma processing is configurable but hard-wired into the
 * library.  The following is the floating point variant.
 */
#define PNG_GAMMA_THRESHOLD (PNG_GAMMA_THRESHOLD_FIXED*.00001)

/* Handle gamma correction. Screen_gamma=(display_exponent).
 * NOTE: this API simply sets the screen and file gamma values. It will
 * therefore override the value for gamma in a PNG file if it is called after
 * the file header has been read - use with care  - call before reading the PNG
 * file for best results!
 *
 * These routines accept the same gamma values as png_set_alpha_mode (described
 * above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either
 * API (floating point or fixed.)  Notice, however, that the 'file_gamma' value
 * is the inverse of a 'screen gamma' value.
 */
PNG_FP_EXPORT(50, void, png_set_gamma, (png_structrp png_ptr,
    double screen_gamma, double override_file_gamma))
PNG_FIXED_EXPORT(208, void, png_set_gamma_fixed, (png_structrp png_ptr,
    png_fixed_point screen_gamma, png_fixed_point override_file_gamma))
#endif

#ifdef PNG_WRITE_FLUSH_SUPPORTED
/* Set how many lines between output flushes - 0 for no flushing */
PNG_EXPORT(51, void, png_set_flush, (png_structrp png_ptr, int nrows));
/* Flush the current PNG output buffer */
PNG_EXPORT(52, void, png_write_flush, (png_structrp png_ptr));
#endif

/* Optional update palette with requested transformations */
PNG_EXPORT(53, void, png_start_read_image, (png_structrp png_ptr));

/* Optional call to update the users info structure */
PNG_EXPORT(54, void, png_read_update_info, (png_structrp png_ptr,
    png_inforp info_ptr));

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read one or more rows of image data. */
PNG_EXPORT(55, void, png_read_rows, (png_structrp png_ptr, png_bytepp row,
    png_bytepp display_row, png_uint_32 num_rows));
#endif

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read a row of data. */
PNG_EXPORT(56, void, png_read_row, (png_structrp png_ptr, png_bytep row,
    png_bytep display_row));
#endif

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the whole image into memory at once. */
PNG_EXPORT(57, void, png_read_image, (png_structrp png_ptr, png_bytepp image));
#endif

/* Write a row of image data */
PNG_EXPORT(58, void, png_write_row, (png_structrp png_ptr,
    png_const_bytep row));

/* Write a few rows of image data: (*row) is not written; however, the type
 * is declared as writeable to maintain compatibility with previous versions
 * of libpng and to allow the 'display_row' array from read_rows to be passed
 * unchanged to write_rows.
 */
PNG_EXPORT(59, void, png_write_rows, (png_structrp png_ptr, png_bytepp row,
    png_uint_32 num_rows));

/* Write the image data */
PNG_EXPORT(60, void, png_write_image, (png_structrp png_ptr, png_bytepp image));

/* Write the end of the PNG file. */
PNG_EXPORT(61, void, png_write_end, (png_structrp png_ptr,
    png_inforp info_ptr));

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the end of the PNG file. */
PNG_EXPORT(62, void, png_read_end, (png_structrp png_ptr, png_inforp info_ptr));
#endif

/* Free any memory associated with the png_info_struct */
PNG_EXPORT(63, void, png_destroy_info_struct, (png_const_structrp png_ptr,
    png_infopp info_ptr_ptr));

/* Free any memory associated with the png_struct and the png_info_structs */
PNG_EXPORT(64, void, png_destroy_read_struct, (png_structpp png_ptr_ptr,
    png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr));

/* Free any memory associated with the png_struct and the png_info_structs */
PNG_EXPORT(65, void, png_destroy_write_struct, (png_structpp png_ptr_ptr,
    png_infopp info_ptr_ptr));

/* Set the libpng method of handling chunk CRC errors */
PNG_EXPORT(66, void, png_set_crc_action, (png_structrp png_ptr, int crit_action,
    int ancil_action));

/* Values for png_set_crc_action() say how to handle CRC errors in
 * ancillary and critical chunks, and whether to use the data contained
 * therein.  Note that it is impossible to "discard" data in a critical
 * chunk.  For versions prior to 0.90, the action was always error/quit,
 * whereas in version 0.90 and later, the action for CRC errors in ancillary
 * chunks is warn/discard.  These values should NOT be changed.
 *
 *      value                       action:critical     action:ancillary
 */
#define PNG_CRC_DEFAULT       0  /* error/quit          warn/discard data */
#define PNG_CRC_ERROR_QUIT    1  /* error/quit          error/quit        */
#define PNG_CRC_WARN_DISCARD  2  /* (INVALID)           warn/discard data */
#define PNG_CRC_WARN_USE      3  /* warn/use data       warn/use data     */
#define PNG_CRC_QUIET_USE     4  /* quiet/use data      quiet/use data    */
#define PNG_CRC_NO_CHANGE     5  /* use current value   use current value */

#ifdef PNG_WRITE_SUPPORTED
/* These functions give the user control over the scan-line filtering in
 * libpng and the compression methods used by zlib.  These functions are
 * mainly useful for testing, as the defaults should work with most users.
 * Those users who are tight on memory or want faster performance at the
 * expense of compression can modify them.  See the compression library
 * header file (zlib.h) for an explination of the compression functions.
 */

/* Set the filtering method(s) used by libpng.  Currently, the only valid
 * value for "method" is 0.
 */
PNG_EXPORT(67, void, png_set_filter, (png_structrp png_ptr, int method,
    int filters));
#endif /* WRITE */

/* Flags for png_set_filter() to say which filters to use.  The flags
 * are chosen so that they don't conflict with real filter types
 * below, in case they are supplied instead of the #defined constants.
 * These values should NOT be changed.
 */
#define PNG_NO_FILTERS     0x00
#define PNG_FILTER_NONE    0x08
#define PNG_FILTER_SUB     0x10
#define PNG_FILTER_UP      0x20
#define PNG_FILTER_AVG     0x40
#define PNG_FILTER_PAETH   0x80
#define PNG_FAST_FILTERS (PNG_FILTER_NONE | PNG_FILTER_SUB | PNG_FILTER_UP)
#define PNG_ALL_FILTERS (PNG_FAST_FILTERS | PNG_FILTER_AVG | PNG_FILTER_PAETH)

/* Filter values (not flags) - used in pngwrite.c, pngwutil.c for now.
 * These defines should NOT be changed.
 */
#define PNG_FILTER_VALUE_NONE  0
#define PNG_FILTER_VALUE_SUB   1
#define PNG_FILTER_VALUE_UP    2
#define PNG_FILTER_VALUE_AVG   3
#define PNG_FILTER_VALUE_PAETH 4
#define PNG_FILTER_VALUE_LAST  5

#ifdef PNG_WRITE_SUPPORTED
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED /* DEPRECATED */
PNG_FP_EXPORT(68, void, png_set_filter_heuristics, (png_structrp png_ptr,
    int heuristic_method, int num_weights, png_const_doublep filter_weights,
    png_const_doublep filter_costs))
PNG_FIXED_EXPORT(209, void, png_set_filter_heuristics_fixed,
    (png_structrp png_ptr, int heuristic_method, int num_weights,
    png_const_fixed_point_p filter_weights,
    png_const_fixed_point_p filter_costs))
#endif /* WRITE_WEIGHTED_FILTER */

/* The following are no longer used and will be removed from libpng-1.7: */
#define PNG_FILTER_HEURISTIC_DEFAULT    0  /* Currently "UNWEIGHTED" */
#define PNG_FILTER_HEURISTIC_UNWEIGHTED 1  /* Used by libpng < 0.95 */
#define PNG_FILTER_HEURISTIC_WEIGHTED   2  /* Experimental feature */
#define PNG_FILTER_HEURISTIC_LAST       3  /* Not a valid value */

/* Set the library compression level.  Currently, valid values range from
 * 0 - 9, corresponding directly to the zlib compression levels 0 - 9
 * (0 - no compression, 9 - "maximal" compression).  Note that tests have
 * shown that zlib compression levels 3-6 usually perform as well as level 9
 * for PNG images, and do considerably fewer caclulations.  In the future,
 * these values may not correspond directly to the zlib compression levels.
 */
#ifdef PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
PNG_EXPORT(69, void, png_set_compression_level, (png_structrp png_ptr,
    int level));

PNG_EXPORT(70, void, png_set_compression_mem_level, (png_structrp png_ptr,
    int mem_level));

PNG_EXPORT(71, void, png_set_compression_strategy, (png_structrp png_ptr,
    int strategy));

/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 */
PNG_EXPORT(72, void, png_set_compression_window_bits, (png_structrp png_ptr,
    int window_bits));

PNG_EXPORT(73, void, png_set_compression_method, (png_structrp png_ptr,
    int method));
#endif /* WRITE_CUSTOMIZE_COMPRESSION */

#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
/* Also set zlib parameters for compressing non-IDAT chunks */
PNG_EXPORT(222, void, png_set_text_compression_level, (png_structrp png_ptr,
    int level));

PNG_EXPORT(223, void, png_set_text_compression_mem_level, (png_structrp png_ptr,
    int mem_level));

PNG_EXPORT(224, void, png_set_text_compression_strategy, (png_structrp png_ptr,
    int strategy));

/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 */
PNG_EXPORT(225, void, png_set_text_compression_window_bits,
    (png_structrp png_ptr, int window_bits));

PNG_EXPORT(226, void, png_set_text_compression_method, (png_structrp png_ptr,
    int method));
#endif /* WRITE_CUSTOMIZE_ZTXT_COMPRESSION */
#endif /* WRITE */

/* These next functions are called for input/output, memory, and error
 * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,
 * and call standard C I/O routines such as fread(), fwrite(), and
 * fprintf().  These functions can be made to use other I/O routines
 * at run time for those applications that need to handle I/O in a
 * different manner by calling png_set_???_fn().  See libpng-manual.txt for
 * more information.
 */

#ifdef PNG_STDIO_SUPPORTED
/* Initialize the input/output for the PNG file to the default functions. */
PNG_EXPORT(74, void, png_init_io, (png_structrp png_ptr, png_FILE_p fp));
#endif

/* Replace the (error and abort), and warning functions with user
 * supplied functions.  If no messages are to be printed you must still
 * write and use replacement functions. The replacement error_fn should
 * still do a longjmp to the last setjmp location if you are using this
 * method of error handling.  If error_fn or warning_fn is NULL, the
 * default function will be used.
 */

PNG_EXPORT(75, void, png_set_error_fn, (png_structrp png_ptr,
    png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warning_fn));

/* Return the user pointer associated with the error functions */
PNG_EXPORT(76, png_voidp, png_get_error_ptr, (png_const_structrp png_ptr));

/* Replace the default data output functions with a user supplied one(s).
 * If buffered output is not used, then output_flush_fn can be set to NULL.
 * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time
 * output_flush_fn will be ignored (and thus can be NULL).
 * It is probably a mistake to use NULL for output_flush_fn if
 * write_data_fn is not also NULL unless you have built libpng with
 * PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's
 * default flush function, which uses the standard *FILE structure, will
 * be used.
 */
PNG_EXPORT(77, void, png_set_write_fn, (png_structrp png_ptr, png_voidp io_ptr,
    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn));

/* Replace the default data input function with a user supplied one. */
PNG_EXPORT(78, void, png_set_read_fn, (png_structrp png_ptr, png_voidp io_ptr,
    png_rw_ptr read_data_fn));

/* Return the user pointer associated with the I/O functions */
PNG_EXPORT(79, png_voidp, png_get_io_ptr, (png_const_structrp png_ptr));

PNG_EXPORT(80, void, png_set_read_status_fn, (png_structrp png_ptr,
    png_read_status_ptr read_row_fn));

PNG_EXPORT(81, void, png_set_write_status_fn, (png_structrp png_ptr,
    png_write_status_ptr write_row_fn));

#ifdef PNG_USER_MEM_SUPPORTED
/* Replace the default memory allocation functions with user supplied one(s). */
PNG_EXPORT(82, void, png_set_mem_fn, (png_structrp png_ptr, png_voidp mem_ptr,
    png_malloc_ptr malloc_fn, png_free_ptr free_fn));
/* Return the user pointer associated with the memory functions */
PNG_EXPORT(83, png_voidp, png_get_mem_ptr, (png_const_structrp png_ptr));
#endif

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
PNG_EXPORT(84, void, png_set_read_user_transform_fn, (png_structrp png_ptr,
    png_user_transform_ptr read_user_transform_fn));
#endif

#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
PNG_EXPORT(85, void, png_set_write_user_transform_fn, (png_structrp png_ptr,
    png_user_transform_ptr write_user_transform_fn));
#endif

#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
PNG_EXPORT(86, void, png_set_user_transform_info, (png_structrp png_ptr,
    png_voidp user_transform_ptr, int user_transform_depth,
    int user_transform_channels));
/* Return the user pointer associated with the user transform functions */
PNG_EXPORT(87, png_voidp, png_get_user_transform_ptr,
    (png_const_structrp png_ptr));
#endif

#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED
/* Return information about the row currently being processed.  Note that these
 * APIs do not fail but will return unexpected results if called outside a user
 * transform callback.  Also note that when transforming an interlaced image the
 * row number is the row number within the sub-image of the interlace pass, so
 * the value will increase to the height of the sub-image (not the full image)
 * then reset to 0 for the next pass.
 *
 * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
 * find the output pixel (x,y) given an interlaced sub-image pixel
 * (row,col,pass).  (See below for these macros.)
 */
PNG_EXPORT(217, png_uint_32, png_get_current_row_number, (png_const_structrp));
PNG_EXPORT(218, png_byte, png_get_current_pass_number, (png_const_structrp));
#endif

#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
/* This callback is called only for *unknown* chunks.  If
 * PNG_HANDLE_AS_UNKNOWN_SUPPORTED is set then it is possible to set known
 * chunks to be treated as unknown, however in this case the callback must do
 * any processing required by the chunk (e.g. by calling the appropriate
 * png_set_ APIs.)
 *
 * There is no write support - on write, by default, all the chunks in the
 * 'unknown' list are written in the specified position.
 *
 * The integer return from the callback function is interpreted thus:
 *
 * negative: An error occurred; png_chunk_error will be called.
 *     zero: The chunk was not handled, the chunk will be saved. A critical
 *           chunk will cause an error at this point unless it is to be saved.
 * positive: The chunk was handled, libpng will ignore/discard it.
 *
 * See "INTERACTION WTIH USER CHUNK CALLBACKS" below for important notes about
 * how this behavior will change in libpng 1.7
 */
PNG_EXPORT(88, void, png_set_read_user_chunk_fn, (png_structrp png_ptr,
    png_voidp user_chunk_ptr, png_user_chunk_ptr read_user_chunk_fn));
#endif

#ifdef PNG_USER_CHUNKS_SUPPORTED
PNG_EXPORT(89, png_voidp, png_get_user_chunk_ptr, (png_const_structrp png_ptr));
#endif

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
/* Sets the function callbacks for the push reader, and a pointer to a
 * user-defined structure available to the callback functions.
 */
PNG_EXPORT(90, void, png_set_progressive_read_fn, (png_structrp png_ptr,
    png_voidp progressive_ptr, png_progressive_info_ptr info_fn,
    png_progressive_row_ptr row_fn, png_progressive_end_ptr end_fn));

/* Returns the user pointer associated with the push read functions */
PNG_EXPORT(91, png_voidp, png_get_progressive_ptr,
    (png_const_structrp png_ptr));

/* Function to be called when data becomes available */
PNG_EXPORT(92, void, png_process_data, (png_structrp png_ptr,
    png_inforp info_ptr, png_bytep buffer, png_size_t buffer_size));

/* A function which may be called *only* within png_process_data to stop the
 * processing of any more data.  The function returns the number of bytes
 * remaining, excluding any that libpng has cached internally.  A subsequent
 * call to png_process_data must supply these bytes again.  If the argument
 * 'save' is set to true the routine will first save all the pending data and
 * will always return 0.
 */
PNG_EXPORT(219, png_size_t, png_process_data_pause, (png_structrp, int save));

/* A function which may be called *only* outside (after) a call to
 * png_process_data.  It returns the number of bytes of data to skip in the
 * input.  Normally it will return 0, but if it returns a non-zero value the
 * application must skip than number of bytes of input data and pass the
 * following data to the next call to png_process_data.
 */
PNG_EXPORT(220, png_uint_32, png_process_data_skip, (png_structrp));

/* Function that combines rows.  'new_row' is a flag that should come from
 * the callback and be non-NULL if anything needs to be done; the library
 * stores its own version of the new data internally and ignores the passed
 * in value.
 */
PNG_EXPORT(93, void, png_progressive_combine_row, (png_const_structrp png_ptr,
    png_bytep old_row, png_const_bytep new_row));
#endif /* PROGRESSIVE_READ */

PNG_EXPORTA(94, png_voidp, png_malloc, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED);
/* Added at libpng version 1.4.0 */
PNG_EXPORTA(95, png_voidp, png_calloc, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED);

/* Added at libpng version 1.2.4 */
PNG_EXPORTA(96, png_voidp, png_malloc_warn, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED);

/* Frees a pointer allocated by png_malloc() */
PNG_EXPORT(97, void, png_free, (png_const_structrp png_ptr, png_voidp ptr));

/* Free data that was allocated internally */
PNG_EXPORT(98, void, png_free_data, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 free_me, int num));

/* Reassign responsibility for freeing existing data, whether allocated
 * by libpng or by the application; this works on the png_info structure passed
 * in, it does not change the state for other png_info structures.
 *
 * It is unlikely that this function works correctly as of 1.6.0 and using it
 * may result either in memory leaks or double free of allocated data.
 */
PNG_EXPORT(99, void, png_data_freer, (png_const_structrp png_ptr,
    png_inforp info_ptr, int freer, png_uint_32 mask));

/* Assignments for png_data_freer */
#define PNG_DESTROY_WILL_FREE_DATA 1
#define PNG_SET_WILL_FREE_DATA 1
#define PNG_USER_WILL_FREE_DATA 2
/* Flags for png_ptr->free_me and info_ptr->free_me */
#define PNG_FREE_HIST 0x0008U
#define PNG_FREE_ICCP 0x0010U
#define PNG_FREE_SPLT 0x0020U
#define PNG_FREE_ROWS 0x0040U
#define PNG_FREE_PCAL 0x0080U
#define PNG_FREE_SCAL 0x0100U
#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
#  define PNG_FREE_UNKN 0x0200U
#endif
/*      PNG_FREE_LIST 0x0400U   removed in 1.6.0 because it is ignored */
#define PNG_FREE_PLTE 0x1000U
#define PNG_FREE_TRNS 0x2000U
#define PNG_FREE_TEXT 0x4000U
#define PNG_FREE_ALL  0x7fffU
#define PNG_FREE_MUL  0x4220U /* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */

#ifdef PNG_USER_MEM_SUPPORTED
PNG_EXPORTA(100, png_voidp, png_malloc_default, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED PNG_DEPRECATED);
PNG_EXPORTA(101, void, png_free_default, (png_const_structrp png_ptr,
    png_voidp ptr), PNG_DEPRECATED);
#endif

#ifdef PNG_ERROR_TEXT_SUPPORTED
/* Fatal error in PNG image of libpng - can't continue */
PNG_EXPORTA(102, void, png_error, (png_const_structrp png_ptr,
    png_const_charp error_message), PNG_NORETURN);

/* The same, but the chunk name is prepended to the error string. */
PNG_EXPORTA(103, void, png_chunk_error, (png_const_structrp png_ptr,
    png_const_charp error_message), PNG_NORETURN);

#else
/* Fatal error in PNG image of libpng - can't continue */
PNG_EXPORTA(104, void, png_err, (png_const_structrp png_ptr), PNG_NORETURN);
#  define png_error(s1,s2) png_err(s1)
#  define png_chunk_error(s1,s2) png_err(s1)
#endif

#ifdef PNG_WARNINGS_SUPPORTED
/* Non-fatal error in libpng.  Can continue, but may have a problem. */
PNG_EXPORT(105, void, png_warning, (png_const_structrp png_ptr,
    png_const_charp warning_message));

/* Non-fatal error in libpng, chunk name is prepended to message. */
PNG_EXPORT(106, void, png_chunk_warning, (png_const_structrp png_ptr,
    png_const_charp warning_message));
#else
#  define png_warning(s1,s2) ((void)(s1))
#  define png_chunk_warning(s1,s2) ((void)(s1))
#endif

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
/* Benign error in libpng.  Can continue, but may have a problem.
 * User can choose whether to handle as a fatal error or as a warning. */
PNG_EXPORT(107, void, png_benign_error, (png_const_structrp png_ptr,
    png_const_charp warning_message));

#ifdef PNG_READ_SUPPORTED
/* Same, chunk name is prepended to message (only during read) */
PNG_EXPORT(108, void, png_chunk_benign_error, (png_const_structrp png_ptr,
    png_const_charp warning_message));
#endif

PNG_EXPORT(109, void, png_set_benign_errors,
    (png_structrp png_ptr, int allowed));
#else
#  ifdef PNG_ALLOW_BENIGN_ERRORS
#    define png_benign_error png_warning
#    define png_chunk_benign_error png_chunk_warning
#  else
#    define png_benign_error png_error
#    define png_chunk_benign_error png_chunk_error
#  endif
#endif

/* The png_set_<chunk> functions are for storing values in the png_info_struct.
 * Similarly, the png_get_<chunk> calls are used to read values from the
 * png_info_struct, either storing the parameters in the passed variables, or
 * setting pointers into the png_info_struct where the data is stored.  The
 * png_get_<chunk> functions return a non-zero value if the data was available
 * in info_ptr, or return zero and do not change any of the parameters if the
 * data was not available.
 *
 * These functions should be used instead of directly accessing png_info
 * to avoid problems with future changes in the size and internal layout of
 * png_info_struct.
 */
/* Returns "flag" if chunk data is valid in info_ptr. */
PNG_EXPORT(110, png_uint_32, png_get_valid, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 flag));

/* Returns number of bytes needed to hold a transformed row. */
PNG_EXPORT(111, png_size_t, png_get_rowbytes, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

#ifdef PNG_INFO_IMAGE_SUPPORTED
/* Returns row_pointers, which is an array of pointers to scanlines that was
 * returned from png_read_png().
 */
PNG_EXPORT(112, png_bytepp, png_get_rows, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Set row_pointers, which is an array of pointers to scanlines for use
 * by png_write_png().
 */
PNG_EXPORT(113, void, png_set_rows, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_bytepp row_pointers));
#endif

/* Returns number of color channels in image. */
PNG_EXPORT(114, png_byte, png_get_channels, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

#ifdef PNG_EASY_ACCESS_SUPPORTED
/* Returns image width in pixels. */
PNG_EXPORT(115, png_uint_32, png_get_image_width, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image height in pixels. */
PNG_EXPORT(116, png_uint_32, png_get_image_height, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image bit_depth. */
PNG_EXPORT(117, png_byte, png_get_bit_depth, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image color_type. */
PNG_EXPORT(118, png_byte, png_get_color_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image filter_type. */
PNG_EXPORT(119, png_byte, png_get_filter_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image interlace_type. */
PNG_EXPORT(120, png_byte, png_get_interlace_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image compression_type. */
PNG_EXPORT(121, png_byte, png_get_compression_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image resolution in pixels per meter, from pHYs chunk data. */
PNG_EXPORT(122, png_uint_32, png_get_pixels_per_meter,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(123, png_uint_32, png_get_x_pixels_per_meter,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(124, png_uint_32, png_get_y_pixels_per_meter,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

/* Returns pixel aspect ratio, computed from pHYs chunk data.  */
PNG_FP_EXPORT(125, float, png_get_pixel_aspect_ratio,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
PNG_FIXED_EXPORT(210, png_fixed_point, png_get_pixel_aspect_ratio_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))

/* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
PNG_EXPORT(126, png_int_32, png_get_x_offset_pixels,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(127, png_int_32, png_get_y_offset_pixels,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(128, png_int_32, png_get_x_offset_microns,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(129, png_int_32, png_get_y_offset_microns,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

#endif /* EASY_ACCESS */

#ifdef PNG_READ_SUPPORTED
/* Returns pointer to signature string read from PNG header */
PNG_EXPORT(130, png_const_bytep, png_get_signature, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));
#endif

#ifdef PNG_bKGD_SUPPORTED
PNG_EXPORT(131, png_uint_32, png_get_bKGD, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_color_16p *background));
#endif

#ifdef PNG_bKGD_SUPPORTED
PNG_EXPORT(132, void, png_set_bKGD, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_color_16p background));
#endif

#ifdef PNG_cHRM_SUPPORTED
PNG_FP_EXPORT(133, png_uint_32, png_get_cHRM, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, double *white_x, double *white_y, double *red_x,
    double *red_y, double *green_x, double *green_y, double *blue_x,
    double *blue_y))
PNG_FP_EXPORT(230, png_uint_32, png_get_cHRM_XYZ, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, double *red_X, double *red_Y, double *red_Z,
    double *green_X, double *green_Y, double *green_Z, double *blue_X,
    double *blue_Y, double *blue_Z))
PNG_FIXED_EXPORT(134, png_uint_32, png_get_cHRM_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *int_white_x, png_fixed_point *int_white_y,
    png_fixed_point *int_red_x, png_fixed_point *int_red_y,
    png_fixed_point *int_green_x, png_fixed_point *int_green_y,
    png_fixed_point *int_blue_x, png_fixed_point *int_blue_y))
PNG_FIXED_EXPORT(231, png_uint_32, png_get_cHRM_XYZ_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,
    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,
    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,
    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,
    png_fixed_point *int_blue_Z))
#endif

#ifdef PNG_cHRM_SUPPORTED
PNG_FP_EXPORT(135, void, png_set_cHRM, (png_const_structrp png_ptr,
    png_inforp info_ptr,
    double white_x, double white_y, double red_x, double red_y, double green_x,
    double green_y, double blue_x, double blue_y))
PNG_FP_EXPORT(232, void, png_set_cHRM_XYZ, (png_const_structrp png_ptr,
    png_inforp info_ptr, double red_X, double red_Y, double red_Z,
    double green_X, double green_Y, double green_Z, double blue_X,
    double blue_Y, double blue_Z))
PNG_FIXED_EXPORT(136, void, png_set_cHRM_fixed, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_white_x,
    png_fixed_point int_white_y, png_fixed_point int_red_x,
    png_fixed_point int_red_y, png_fixed_point int_green_x,
    png_fixed_point int_green_y, png_fixed_point int_blue_x,
    png_fixed_point int_blue_y))
PNG_FIXED_EXPORT(233, void, png_set_cHRM_XYZ_fixed, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_red_X, png_fixed_point int_red_Y,
    png_fixed_point int_red_Z, png_fixed_point int_green_X,
    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
    png_fixed_point int_blue_Z))
#endif

#ifdef PNG_gAMA_SUPPORTED
PNG_FP_EXPORT(137, png_uint_32, png_get_gAMA, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, double *file_gamma))
PNG_FIXED_EXPORT(138, png_uint_32, png_get_gAMA_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *int_file_gamma))
#endif

#ifdef PNG_gAMA_SUPPORTED
PNG_FP_EXPORT(139, void, png_set_gAMA, (png_const_structrp png_ptr,
    png_inforp info_ptr, double file_gamma))
PNG_FIXED_EXPORT(140, void, png_set_gAMA_fixed, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_file_gamma))
#endif

#ifdef PNG_hIST_SUPPORTED
PNG_EXPORT(141, png_uint_32, png_get_hIST, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_16p *hist));
#endif

#ifdef PNG_hIST_SUPPORTED
PNG_EXPORT(142, void, png_set_hIST, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_uint_16p hist));
#endif

PNG_EXPORT(143, png_uint_32, png_get_IHDR, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 *width, png_uint_32 *height,
    int *bit_depth, int *color_type, int *interlace_method,
    int *compression_method, int *filter_method));

PNG_EXPORT(144, void, png_set_IHDR, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 width, png_uint_32 height, int bit_depth,
    int color_type, int interlace_method, int compression_method,
    int filter_method));

#ifdef PNG_oFFs_SUPPORTED
PNG_EXPORT(145, png_uint_32, png_get_oFFs, (png_const_structrp png_ptr,
   png_const_inforp info_ptr, png_int_32 *offset_x, png_int_32 *offset_y,
   int *unit_type));
#endif

#ifdef PNG_oFFs_SUPPORTED
PNG_EXPORT(146, void, png_set_oFFs, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_int_32 offset_x, png_int_32 offset_y,
    int unit_type));
#endif

#ifdef PNG_pCAL_SUPPORTED
PNG_EXPORT(147, png_uint_32, png_get_pCAL, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_charp *purpose, png_int_32 *X0,
    png_int_32 *X1, int *type, int *nparams, png_charp *units,
    png_charpp *params));
#endif

#ifdef PNG_pCAL_SUPPORTED
PNG_EXPORT(148, void, png_set_pCAL, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_charp purpose, png_int_32 X0, png_int_32 X1,
    int type, int nparams, png_const_charp units, png_charpp params));
#endif

#ifdef PNG_pHYs_SUPPORTED
PNG_EXPORT(149, png_uint_32, png_get_pHYs, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
    int *unit_type));
#endif

#ifdef PNG_pHYs_SUPPORTED
PNG_EXPORT(150, void, png_set_pHYs, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 res_x, png_uint_32 res_y, int unit_type));
#endif

PNG_EXPORT(151, png_uint_32, png_get_PLTE, (png_const_structrp png_ptr,
   png_inforp info_ptr, png_colorp *palette, int *num_palette));

PNG_EXPORT(152, void, png_set_PLTE, (png_structrp png_ptr,
    png_inforp info_ptr, png_const_colorp palette, int num_palette));

#ifdef PNG_sBIT_SUPPORTED
PNG_EXPORT(153, png_uint_32, png_get_sBIT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_color_8p *sig_bit));
#endif

#ifdef PNG_sBIT_SUPPORTED
PNG_EXPORT(154, void, png_set_sBIT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_color_8p sig_bit));
#endif

#ifdef PNG_sRGB_SUPPORTED
PNG_EXPORT(155, png_uint_32, png_get_sRGB, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, int *file_srgb_intent));
#endif

#ifdef PNG_sRGB_SUPPORTED
PNG_EXPORT(156, void, png_set_sRGB, (png_const_structrp png_ptr,
    png_inforp info_ptr, int srgb_intent));
PNG_EXPORT(157, void, png_set_sRGB_gAMA_and_cHRM, (png_const_structrp png_ptr,
    png_inforp info_ptr, int srgb_intent));
#endif

#ifdef PNG_iCCP_SUPPORTED
PNG_EXPORT(158, png_uint_32, png_get_iCCP, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_charpp name, int *compression_type,
    png_bytepp profile, png_uint_32 *proflen));
#endif

#ifdef PNG_iCCP_SUPPORTED
PNG_EXPORT(159, void, png_set_iCCP, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_charp name, int compression_type,
    png_const_bytep profile, png_uint_32 proflen));
#endif

#ifdef PNG_sPLT_SUPPORTED
PNG_EXPORT(160, int, png_get_sPLT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_sPLT_tpp entries));
#endif

#ifdef PNG_sPLT_SUPPORTED
PNG_EXPORT(161, void, png_set_sPLT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_sPLT_tp entries, int nentries));
#endif

#ifdef PNG_TEXT_SUPPORTED
/* png_get_text also returns the number of text chunks in *num_text */
PNG_EXPORT(162, int, png_get_text, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_textp *text_ptr, int *num_text));
#endif

/* Note while png_set_text() will accept a structure whose text,
 * language, and  translated keywords are NULL pointers, the structure
 * returned by png_get_text will always contain regular
 * zero-terminated C strings.  They might be empty strings but
 * they will never be NULL pointers.
 */

#ifdef PNG_TEXT_SUPPORTED
PNG_EXPORT(163, void, png_set_text, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_textp text_ptr, int num_text));
#endif

#ifdef PNG_tIME_SUPPORTED
PNG_EXPORT(164, png_uint_32, png_get_tIME, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_timep *mod_time));
#endif

#ifdef PNG_tIME_SUPPORTED
PNG_EXPORT(165, void, png_set_tIME, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_timep mod_time));
#endif

#ifdef PNG_tRNS_SUPPORTED
PNG_EXPORT(166, png_uint_32, png_get_tRNS, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_bytep *trans_alpha, int *num_trans,
    png_color_16p *trans_color));
#endif

#ifdef PNG_tRNS_SUPPORTED
PNG_EXPORT(167, void, png_set_tRNS, (png_structrp png_ptr,
    png_inforp info_ptr, png_const_bytep trans_alpha, int num_trans,
    png_const_color_16p trans_color));
#endif

#ifdef PNG_sCAL_SUPPORTED
PNG_FP_EXPORT(168, png_uint_32, png_get_sCAL, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, int *unit, double *width, double *height))
#if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || \
   defined(PNG_FLOATING_POINT_SUPPORTED)
/* NOTE: this API is currently implemented using floating point arithmetic,
 * consequently it can only be used on systems with floating point support.
 * In any case the range of values supported by png_fixed_point is small and it
 * is highly recommended that png_get_sCAL_s be used instead.
 */
PNG_FIXED_EXPORT(214, png_uint_32, png_get_sCAL_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr, int *unit,
    png_fixed_point *width, png_fixed_point *height))
#endif
PNG_EXPORT(169, png_uint_32, png_get_sCAL_s,
    (png_const_structrp png_ptr, png_const_inforp info_ptr, int *unit,
    png_charpp swidth, png_charpp sheight));

PNG_FP_EXPORT(170, void, png_set_sCAL, (png_const_structrp png_ptr,
    png_inforp info_ptr, int unit, double width, double height))
PNG_FIXED_EXPORT(213, void, png_set_sCAL_fixed, (png_const_structrp png_ptr,
   png_inforp info_ptr, int unit, png_fixed_point width,
   png_fixed_point height))
PNG_EXPORT(171, void, png_set_sCAL_s, (png_const_structrp png_ptr,
    png_inforp info_ptr, int unit,
    png_const_charp swidth, png_const_charp sheight));
#endif /* sCAL */

#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
/* Provide the default handling for all unknown chunks or, optionally, for
 * specific unknown chunks.
 *
 * NOTE: prior to 1.6.0 the handling specified for particular chunks on read was
 * ignored and the default was used, the per-chunk setting only had an effect on
 * write.  If you wish to have chunk-specific handling on read in code that must
 * work on earlier versions you must use a user chunk callback to specify the
 * desired handling (keep or discard.)
 *
 * The 'keep' parameter is a PNG_HANDLE_CHUNK_ value as listed below.  The
 * parameter is interpreted as follows:
 *
 * READ:
 *    PNG_HANDLE_CHUNK_AS_DEFAULT:
 *       Known chunks: do normal libpng processing, do not keep the chunk (but
 *          see the comments below about PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
 *       Unknown chunks: for a specific chunk use the global default, when used
 *          as the default discard the chunk data.
 *    PNG_HANDLE_CHUNK_NEVER:
 *       Discard the chunk data.
 *    PNG_HANDLE_CHUNK_IF_SAFE:
 *       Keep the chunk data if the chunk is not critical else raise a chunk
 *       error.
 *    PNG_HANDLE_CHUNK_ALWAYS:
 *       Keep the chunk data.
 *
 * If the chunk data is saved it can be retrieved using png_get_unknown_chunks,
 * below.  Notice that specifying "AS_DEFAULT" as a global default is equivalent
 * to specifying "NEVER", however when "AS_DEFAULT" is used for specific chunks
 * it simply resets the behavior to the libpng default.
 *
 * INTERACTION WTIH USER CHUNK CALLBACKS:
 * The per-chunk handling is always used when there is a png_user_chunk_ptr
 * callback and the callback returns 0; the chunk is then always stored *unless*
 * it is critical and the per-chunk setting is other than ALWAYS.  Notice that
 * the global default is *not* used in this case.  (In effect the per-chunk
 * value is incremented to at least IF_SAFE.)
 *
 * IMPORTANT NOTE: this behavior will change in libpng 1.7 - the global and
 * per-chunk defaults will be honored.  If you want to preserve the current
 * behavior when your callback returns 0 you must set PNG_HANDLE_CHUNK_IF_SAFE
 * as the default - if you don't do this libpng 1.6 will issue a warning.
 *
 * If you want unhandled unknown chunks to be discarded in libpng 1.6 and
 * earlier simply return '1' (handled).
 *
 * PNG_HANDLE_AS_UNKNOWN_SUPPORTED:
 *    If this is *not* set known chunks will always be handled by libpng and
 *    will never be stored in the unknown chunk list.  Known chunks listed to
 *    png_set_keep_unknown_chunks will have no effect.  If it is set then known
 *    chunks listed with a keep other than AS_DEFAULT will *never* be processed
 *    by libpng, in addition critical chunks must either be processed by the
 *    callback or saved.
 *
 *    The IHDR and IEND chunks must not be listed.  Because this turns off the
 *    default handling for chunks that would otherwise be recognized the
 *    behavior of libpng transformations may well become incorrect!
 *
 * WRITE:
 *    When writing chunks the options only apply to the chunks specified by
 *    png_set_unknown_chunks (below), libpng will *always* write known chunks
 *    required by png_set_ calls and will always write the core critical chunks
 *    (as required for PLTE).
 *
 *    Each chunk in the png_set_unknown_chunks list is looked up in the
 *    png_set_keep_unknown_chunks list to find the keep setting, this is then
 *    interpreted as follows:
 *
 *    PNG_HANDLE_CHUNK_AS_DEFAULT:
 *       Write safe-to-copy chunks and write other chunks if the global
 *       default is set to _ALWAYS, otherwise don't write this chunk.
 *    PNG_HANDLE_CHUNK_NEVER:
 *       Do not write the chunk.
 *    PNG_HANDLE_CHUNK_IF_SAFE:
 *       Write the chunk if it is safe-to-copy, otherwise do not write it.
 *    PNG_HANDLE_CHUNK_ALWAYS:
 *       Write the chunk.
 *
 * Note that the default behavior is effectively the opposite of the read case -
 * in read unknown chunks are not stored by default, in write they are written
 * by default.  Also the behavior of PNG_HANDLE_CHUNK_IF_SAFE is very different
 * - on write the safe-to-copy bit is checked, on read the critical bit is
 * checked and on read if the chunk is critical an error will be raised.
 *
 * num_chunks:
 * ===========
 *    If num_chunks is positive, then the "keep" parameter specifies the manner
 *    for handling only those chunks appearing in the chunk_list array,
 *    otherwise the chunk list array is ignored.
 *
 *    If num_chunks is 0 the "keep" parameter specifies the default behavior for
 *    unknown chunks, as described above.
 *
 *    If num_chunks is negative, then the "keep" parameter specifies the manner
 *    for handling all unknown chunks plus all chunks recognized by libpng
 *    except for the IHDR, PLTE, tRNS, IDAT, and IEND chunks (which continue to
 *    be processed by libpng.
 */
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
PNG_EXPORT(172, void, png_set_keep_unknown_chunks, (png_structrp png_ptr,
    int keep, png_const_bytep chunk_list, int num_chunks));
#endif /* HANDLE_AS_UNKNOWN */

/* The "keep" PNG_HANDLE_CHUNK_ parameter for the specified chunk is returned;
 * the result is therefore true (non-zero) if special handling is required,
 * false for the default handling.
 */
PNG_EXPORT(173, int, png_handle_as_unknown, (png_const_structrp png_ptr,
    png_const_bytep chunk_name));
#endif /* SET_UNKNOWN_CHUNKS */

#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
PNG_EXPORT(174, void, png_set_unknown_chunks, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_unknown_chunkp unknowns,
    int num_unknowns));
   /* NOTE: prior to 1.6.0 this routine set the 'location' field of the added
    * unknowns to the location currently stored in the png_struct.  This is
    * invariably the wrong value on write.  To fix this call the following API
    * for each chunk in the list with the correct location.  If you know your
    * code won't be compiled on earlier versions you can rely on
    * png_set_unknown_chunks(write-ptr, png_get_unknown_chunks(read-ptr)) doing
    * the correct thing.
    */

PNG_EXPORT(175, void, png_set_unknown_chunk_location,
    (png_const_structrp png_ptr, png_inforp info_ptr, int chunk, int location));

PNG_EXPORT(176, int, png_get_unknown_chunks, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_unknown_chunkpp entries));
#endif

/* Png_free_data() will turn off the "valid" flag for anything it frees.
 * If you need to turn it off for a chunk that your application has freed,
 * you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);
 */
PNG_EXPORT(177, void, png_set_invalid, (png_const_structrp png_ptr,
    png_inforp info_ptr, int mask));

#ifdef PNG_INFO_IMAGE_SUPPORTED
/* The "params" pointer is currently not used and is for future expansion. */
#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
PNG_EXPORT(178, void, png_read_png, (png_structrp png_ptr, png_inforp info_ptr,
    int transforms, png_voidp params));
#endif
#ifdef PNG_WRITE_SUPPORTED
PNG_EXPORT(179, void, png_write_png, (png_structrp png_ptr, png_inforp info_ptr,
    int transforms, png_voidp params));
#endif
#endif

PNG_EXPORT(180, png_const_charp, png_get_copyright,
    (png_const_structrp png_ptr));
PNG_EXPORT(181, png_const_charp, png_get_header_ver,
    (png_const_structrp png_ptr));
PNG_EXPORT(182, png_const_charp, png_get_header_version,
    (png_const_structrp png_ptr));
PNG_EXPORT(183, png_const_charp, png_get_libpng_ver,
    (png_const_structrp png_ptr));

#ifdef PNG_MNG_FEATURES_SUPPORTED
PNG_EXPORT(184, png_uint_32, png_permit_mng_features, (png_structrp png_ptr,
    png_uint_32 mng_features_permitted));
#endif

/* For use in png_set_keep_unknown, added to version 1.2.6 */
#define PNG_HANDLE_CHUNK_AS_DEFAULT   0
#define PNG_HANDLE_CHUNK_NEVER        1
#define PNG_HANDLE_CHUNK_IF_SAFE      2
#define PNG_HANDLE_CHUNK_ALWAYS       3
#define PNG_HANDLE_CHUNK_LAST         4

/* Strip the prepended error numbers ("#nnn ") from error and warning
 * messages before passing them to the error or warning handler.
 */
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
PNG_EXPORT(185, void, png_set_strip_error_numbers, (png_structrp png_ptr,
    png_uint_32 strip_mode));
#endif

/* Added in libpng-1.2.6 */
#ifdef PNG_SET_USER_LIMITS_SUPPORTED
PNG_EXPORT(186, void, png_set_user_limits, (png_structrp png_ptr,
    png_uint_32 user_width_max, png_uint_32 user_height_max));
PNG_EXPORT(187, png_uint_32, png_get_user_width_max,
    (png_const_structrp png_ptr));
PNG_EXPORT(188, png_uint_32, png_get_user_height_max,
    (png_const_structrp png_ptr));
/* Added in libpng-1.4.0 */
PNG_EXPORT(189, void, png_set_chunk_cache_max, (png_structrp png_ptr,
    png_uint_32 user_chunk_cache_max));
PNG_EXPORT(190, png_uint_32, png_get_chunk_cache_max,
    (png_const_structrp png_ptr));
/* Added in libpng-1.4.1 */
PNG_EXPORT(191, void, png_set_chunk_malloc_max, (png_structrp png_ptr,
    png_alloc_size_t user_chunk_cache_max));
PNG_EXPORT(192, png_alloc_size_t, png_get_chunk_malloc_max,
    (png_const_structrp png_ptr));
#endif

#if defined(PNG_INCH_CONVERSIONS_SUPPORTED)
PNG_EXPORT(193, png_uint_32, png_get_pixels_per_inch,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

PNG_EXPORT(194, png_uint_32, png_get_x_pixels_per_inch,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

PNG_EXPORT(195, png_uint_32, png_get_y_pixels_per_inch,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

PNG_FP_EXPORT(196, float, png_get_x_offset_inches,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
#ifdef PNG_FIXED_POINT_SUPPORTED /* otherwise not implemented. */
PNG_FIXED_EXPORT(211, png_fixed_point, png_get_x_offset_inches_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
#endif

PNG_FP_EXPORT(197, float, png_get_y_offset_inches, (png_const_structrp png_ptr,
    png_const_inforp info_ptr))
#ifdef PNG_FIXED_POINT_SUPPORTED /* otherwise not implemented. */
PNG_FIXED_EXPORT(212, png_fixed_point, png_get_y_offset_inches_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
#endif

#  ifdef PNG_pHYs_SUPPORTED
PNG_EXPORT(198, png_uint_32, png_get_pHYs_dpi, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
    int *unit_type));
#  endif /* pHYs */
#endif  /* INCH_CONVERSIONS */

/* Added in libpng-1.4.0 */
#ifdef PNG_IO_STATE_SUPPORTED
PNG_EXPORT(199, png_uint_32, png_get_io_state, (png_const_structrp png_ptr));

/* Removed from libpng 1.6; use png_get_io_chunk_type. */
PNG_REMOVED(200, png_const_bytep, png_get_io_chunk_name, (png_structrp png_ptr),
    PNG_DEPRECATED)

PNG_EXPORT(216, png_uint_32, png_get_io_chunk_type,
    (png_const_structrp png_ptr));

/* The flags returned by png_get_io_state() are the following: */
#  define PNG_IO_NONE        0x0000   /* no I/O at this moment */
#  define PNG_IO_READING     0x0001   /* currently reading */
#  define PNG_IO_WRITING     0x0002   /* currently writing */
#  define PNG_IO_SIGNATURE   0x0010   /* currently at the file signature */
#  define PNG_IO_CHUNK_HDR   0x0020   /* currently at the chunk header */
#  define PNG_IO_CHUNK_DATA  0x0040   /* currently at the chunk data */
#  define PNG_IO_CHUNK_CRC   0x0080   /* currently at the chunk crc */
#  define PNG_IO_MASK_OP     0x000f   /* current operation: reading/writing */
#  define PNG_IO_MASK_LOC    0x00f0   /* current location: sig/hdr/data/crc */
#endif /* IO_STATE */

/* Interlace support.  The following macros are always defined so that if
 * libpng interlace handling is turned off the macros may be used to handle
 * interlaced images within the application.
 */
#define PNG_INTERLACE_ADAM7_PASSES 7

/* Two macros to return the first row and first column of the original,
 * full, image which appears in a given pass.  'pass' is in the range 0
 * to 6 and the result is in the range 0 to 7.
 */
#define PNG_PASS_START_ROW(pass) (((1&~(pass))<<(3-((pass)>>1)))&7)
#define PNG_PASS_START_COL(pass) (((1& (pass))<<(3-(((pass)+1)>>1)))&7)

/* A macro to return the offset between pixels in the output row for a pair of
 * pixels in the input - effectively the inverse of the 'COL_SHIFT' macro that
 * follows.  Note that ROW_OFFSET is the offset from one row to the next whereas
 * COL_OFFSET is from one column to the next, within a row.
 */
#define PNG_PASS_ROW_OFFSET(pass) ((pass)>2?(8>>(((pass)-1)>>1)):8)
#define PNG_PASS_COL_OFFSET(pass) (1<<((7-(pass))>>1))

/* Two macros to help evaluate the number of rows or columns in each
 * pass.  This is expressed as a shift - effectively log2 of the number or
 * rows or columns in each 8x8 tile of the original image.
 */
#define PNG_PASS_ROW_SHIFT(pass) ((pass)>2?(8-(pass))>>1:3)
#define PNG_PASS_COL_SHIFT(pass) ((pass)>1?(7-(pass))>>1:3)

/* Hence two macros to determine the number of rows or columns in a given
 * pass of an image given its height or width.  In fact these macros may
 * return non-zero even though the sub-image is empty, because the other
 * dimension may be empty for a small image.
 */
#define PNG_PASS_ROWS(height, pass) (((height)+(((1<<PNG_PASS_ROW_SHIFT(pass))\
   -1)-PNG_PASS_START_ROW(pass)))>>PNG_PASS_ROW_SHIFT(pass))
#define PNG_PASS_COLS(width, pass) (((width)+(((1<<PNG_PASS_COL_SHIFT(pass))\
   -1)-PNG_PASS_START_COL(pass)))>>PNG_PASS_COL_SHIFT(pass))

/* For the reader row callbacks (both progressive and sequential) it is
 * necessary to find the row in the output image given a row in an interlaced
 * image, so two more macros:
 */
#define PNG_ROW_FROM_PASS_ROW(y_in, pass) \
   (((y_in)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
#define PNG_COL_FROM_PASS_COL(x_in, pass) \
   (((x_in)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))

/* Two macros which return a boolean (0 or 1) saying whether the given row
 * or column is in a particular pass.  These use a common utility macro that
 * returns a mask for a given pass - the offset 'off' selects the row or
 * column version.  The mask has the appropriate bit set for each column in
 * the tile.
 */
#define PNG_PASS_MASK(pass,off) ( \
   ((0x110145AF>>(((7-(off))-(pass))<<2)) & 0xF) | \
   ((0x01145AF0>>(((7-(off))-(pass))<<2)) & 0xF0))

#define PNG_ROW_IN_INTERLACE_PASS(y, pass) \
   ((PNG_PASS_MASK(pass,0) >> ((y)&7)) & 1)
#define PNG_COL_IN_INTERLACE_PASS(x, pass) \
   ((PNG_PASS_MASK(pass,1) >> ((x)&7)) & 1)

#ifdef PNG_READ_COMPOSITE_NODIV_SUPPORTED
/* With these routines we avoid an integer divide, which will be slower on
 * most machines.  However, it does take more operations than the corresponding
 * divide method, so it may be slower on a few RISC systems.  There are two
 * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.
 *
 * Note that the rounding factors are NOT supposed to be the same!  128 and
 * 32768 are correct for the NODIV code; 127 and 32767 are correct for the
 * standard method.
 *
 * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]
 */

 /* fg and bg should be in `gamma 1.0' space; alpha is the opacity */

#  define png_composite(composite, fg, alpha, bg)        \
   {                                                     \
      png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
          * (png_uint_16)(alpha)                         \
          + (png_uint_16)(bg)*(png_uint_16)(255          \
          - (png_uint_16)(alpha)) + 128);                \
      (composite) = (png_byte)(((temp + (temp >> 8)) >> 8) & 0xff); \
   }

#  define png_composite_16(composite, fg, alpha, bg)     \
   {                                                     \
      png_uint_32 temp = (png_uint_32)((png_uint_32)(fg) \
          * (png_uint_32)(alpha)                         \
          + (png_uint_32)(bg)*(65535                     \
          - (png_uint_32)(alpha)) + 32768);              \
      (composite) = (png_uint_16)(0xffff & ((temp + (temp >> 16)) >> 16)); \
   }

#else  /* Standard method using integer division */

#  define png_composite(composite, fg, alpha, bg)                      \
   (composite) =                                                       \
       (png_byte)(0xff & (((png_uint_16)(fg) * (png_uint_16)(alpha) +  \
       (png_uint_16)(bg) * (png_uint_16)(255 - (png_uint_16)(alpha)) + \
       127) / 255))

#  define png_composite_16(composite, fg, alpha, bg)                       \
   (composite) =                                                           \
       (png_uint_16)(0xffff & (((png_uint_32)(fg) * (png_uint_32)(alpha) + \
       (png_uint_32)(bg)*(png_uint_32)(65535 - (png_uint_32)(alpha)) +     \
       32767) / 65535))
#endif /* READ_COMPOSITE_NODIV */

#ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED
PNG_EXPORT(201, png_uint_32, png_get_uint_32, (png_const_bytep buf));
PNG_EXPORT(202, png_uint_16, png_get_uint_16, (png_const_bytep buf));
PNG_EXPORT(203, png_int_32, png_get_int_32, (png_const_bytep buf));
#endif

PNG_EXPORT(204, png_uint_32, png_get_uint_31, (png_const_structrp png_ptr,
    png_const_bytep buf));
/* No png_get_int_16 -- may be added if there's a real need for it. */

/* Place a 32-bit number into a buffer in PNG byte order (big-endian). */
#ifdef PNG_WRITE_INT_FUNCTIONS_SUPPORTED
PNG_EXPORT(205, void, png_save_uint_32, (png_bytep buf, png_uint_32 i));
#endif
#ifdef PNG_SAVE_INT_32_SUPPORTED
PNG_EXPORT(206, void, png_save_int_32, (png_bytep buf, png_int_32 i));
#endif

/* Place a 16-bit number into a buffer in PNG byte order.
 * The parameter is declared unsigned int, not png_uint_16,
 * just to avoid potential problems on pre-ANSI C compilers.
 */
#ifdef PNG_WRITE_INT_FUNCTIONS_SUPPORTED
PNG_EXPORT(207, void, png_save_uint_16, (png_bytep buf, unsigned int i));
/* No png_save_int_16 -- may be added if there's a real need for it. */
#endif

#ifdef PNG_USE_READ_MACROS
/* Inline macros to do direct reads of bytes from the input buffer.
 * The png_get_int_32() routine assumes we are using two's complement
 * format for negative values, which is almost certainly true.
 */
#  define PNG_get_uint_32(buf) \
   (((png_uint_32)(*(buf)) << 24) + \
    ((png_uint_32)(*((buf) + 1)) << 16) + \
    ((png_uint_32)(*((buf) + 2)) << 8) + \
    ((png_uint_32)(*((buf) + 3))))

   /* From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
    * function) incorrectly returned a value of type png_uint_32.
    */
#  define PNG_get_uint_16(buf) \
   ((png_uint_16) \
    (((unsigned int)(*(buf)) << 8) + \
    ((unsigned int)(*((buf) + 1)))))

#  define PNG_get_int_32(buf) \
   ((png_int_32)((*(buf) & 0x80) \
    ? -((png_int_32)(((png_get_uint_32(buf)^0xffffffffU)+1U)&0x7fffffffU)) \
    : (png_int_32)png_get_uint_32(buf)))

/* If PNG_PREFIX is defined the same thing as below happens in pnglibconf.h,
 * but defining a macro name prefixed with PNG_PREFIX.
 */
#  ifndef PNG_PREFIX
#    define png_get_uint_32(buf) PNG_get_uint_32(buf)
#    define png_get_uint_16(buf) PNG_get_uint_16(buf)
#    define png_get_int_32(buf)  PNG_get_int_32(buf)
#  endif
#else
#  ifdef PNG_PREFIX
   /* No macros; revert to the (redefined) function */
#    define PNG_get_uint_32 (png_get_uint_32)
#    define PNG_get_uint_16 (png_get_uint_16)
#    define PNG_get_int_32  (png_get_int_32)
#  endif
#endif

#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
PNG_EXPORT(242, void, png_set_check_for_invalid_index,
    (png_structrp png_ptr, int allowed));
#  ifdef PNG_GET_PALETTE_MAX_SUPPORTED
PNG_EXPORT(243, int, png_get_palette_max, (png_const_structp png_ptr,
    png_const_infop info_ptr));
#  endif
#endif /* CHECK_FOR_INVALID_INDEX */

/*******************************************************************************
 * Section 5: SIMPLIFIED API
 *******************************************************************************
 *
 * Please read the documentation in libpng-manual.txt (TODO: write said
 * documentation) if you don't understand what follows.
 *
 * The simplified API hides the details of both libpng and the PNG file format
 * itself.  It allows PNG files to be read into a very limited number of
 * in-memory bitmap formats or to be written from the same formats.  If these
 * formats do not accomodate your needs then you can, and should, use the more
 * sophisticated APIs above - these support a wide variety of in-memory formats
 * and a wide variety of sophisticated transformations to those formats as well
 * as a wide variety of APIs to manipulate ancillary information.
 *
 * To read a PNG file using the simplified API:
 *
 * 1) Declare a 'png_image' structure (see below) on the stack, set the
 *    version field to PNG_IMAGE_VERSION and the 'opaque' pointer to NULL
 *    (this is REQUIRED, your program may crash if you don't do it.)
 * 2) Call the appropriate png_image_begin_read... function.
 * 3) Set the png_image 'format' member to the required sample format.
 * 4) Allocate a buffer for the image and, if required, the color-map.
 * 5) Call png_image_finish_read to read the image and, if required, the
 *    color-map into your buffers.
 *
 * There are no restrictions on the format of the PNG input itself; all valid
 * color types, bit depths, and interlace methods are acceptable, and the
 * input image is transformed as necessary to the requested in-memory format
 * during the png_image_finish_read() step.  The only caveat is that if you
 * request a color-mapped image from a PNG that is full-color or makes
 * complex use of an alpha channel the transformation is extremely lossy and the
 * result may look terrible.
 *
 * To write a PNG file using the simplified API:
 *
 * 1) Declare a 'png_image' structure on the stack and memset() it to all zero.
 * 2) Initialize the members of the structure that describe the image, setting
 *    the 'format' member to the format of the image samples.
 * 3) Call the appropriate png_image_write... function with a pointer to the
 *    image and, if necessary, the color-map to write the PNG data.
 *
 * png_image is a structure that describes the in-memory format of an image
 * when it is being read or defines the in-memory format of an image that you
 * need to write:
 */
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) || \
    defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)

#define PNG_IMAGE_VERSION 1

typedef struct png_control *png_controlp;
typedef struct
{
   png_controlp opaque;    /* Initialize to NULL, free with png_image_free */
   png_uint_32  version;   /* Set to PNG_IMAGE_VERSION */
   png_uint_32  width;     /* Image width in pixels (columns) */
   png_uint_32  height;    /* Image height in pixels (rows) */
   png_uint_32  format;    /* Image format as defined below */
   png_uint_32  flags;     /* A bit mask containing informational flags */
   png_uint_32  colormap_entries;
                           /* Number of entries in the color-map */

   /* In the event of an error or warning the following field will be set to a
    * non-zero value and the 'message' field will contain a '\0' terminated
    * string with the libpng error or warning message.  If both warnings and
    * an error were encountered, only the error is recorded.  If there
    * are multiple warnings, only the first one is recorded.
    *
    * The upper 30 bits of this value are reserved, the low two bits contain
    * a value as follows:
    */
#  define PNG_IMAGE_WARNING 1
#  define PNG_IMAGE_ERROR 2
   /*
    * The result is a two-bit code such that a value more than 1 indicates
    * a failure in the API just called:
    *
    *    0 - no warning or error
    *    1 - warning
    *    2 - error
    *    3 - error preceded by warning
    */
#  define PNG_IMAGE_FAILED(png_cntrl) ((((png_cntrl).warning_or_error)&0x03)>1)

   png_uint_32  warning_or_error;

   char         message[64];
} png_image, *png_imagep;

/* The samples of the image have one to four channels whose components have
 * original values in the range 0 to 1.0:
 *
 * 1: A single gray or luminance channel (G).
 * 2: A gray/luminance channel and an alpha channel (GA).
 * 3: Three red, green, blue color channels (RGB).
 * 4: Three color channels and an alpha channel (RGBA).
 *
 * The components are encoded in one of two ways:
 *
 * a) As a small integer, value 0..255, contained in a single byte.  For the
 * alpha channel the original value is simply value/255.  For the color or
 * luminance channels the value is encoded according to the sRGB specification
 * and matches the 8-bit format expected by typical display devices.
 *
 * The color/gray channels are not scaled (pre-multiplied) by the alpha
 * channel and are suitable for passing to color management software.
 *
 * b) As a value in the range 0..65535, contained in a 2-byte integer.  All
 * channels can be converted to the original value by dividing by 65535; all
 * channels are linear.  Color channels use the RGB encoding (RGB end-points) of
 * the sRGB specification.  This encoding is identified by the
 * PNG_FORMAT_FLAG_LINEAR flag below.
 *
 * When the simplified API needs to convert between sRGB and linear colorspaces,
 * the actual sRGB transfer curve defined in the sRGB specification (see the
 * article at http://en.wikipedia.org/wiki/SRGB) is used, not the gamma=1/2.2
 * approximation used elsewhere in libpng.
 *
 * When an alpha channel is present it is expected to denote pixel coverage
 * of the color or luminance channels and is returned as an associated alpha
 * channel: the color/gray channels are scaled (pre-multiplied) by the alpha
 * value.
 *
 * The samples are either contained directly in the image data, between 1 and 8
 * bytes per pixel according to the encoding, or are held in a color-map indexed
 * by bytes in the image data.  In the case of a color-map the color-map entries
 * are individual samples, encoded as above, and the image data has one byte per
 * pixel to select the relevant sample from the color-map.
 */

/* PNG_FORMAT_*
 *
 * #defines to be used in png_image::format.  Each #define identifies a
 * particular layout of sample data and, if present, alpha values.  There are
 * separate defines for each of the two component encodings.
 *
 * A format is built up using single bit flag values.  All combinations are
 * valid.  Formats can be built up from the flag values or you can use one of
 * the predefined values below.  When testing formats always use the FORMAT_FLAG
 * macros to test for individual features - future versions of the library may
 * add new flags.
 *
 * When reading or writing color-mapped images the format should be set to the
 * format of the entries in the color-map then png_image_{read,write}_colormap
 * called to read or write the color-map and set the format correctly for the
 * image data.  Do not set the PNG_FORMAT_FLAG_COLORMAP bit directly!
 *
 * NOTE: libpng can be built with particular features disabled. If you see
 * compiler errors because the definition of one of the following flags has been
 * compiled out it is because libpng does not have the required support.  It is
 * possible, however, for the libpng configuration to enable the format on just
 * read or just write; in that case you may see an error at run time.  You can
 * guard against this by checking for the definition of the appropriate
 * "_SUPPORTED" macro, one of:
 *
 *    PNG_SIMPLIFIED_{READ,WRITE}_{BGR,AFIRST}_SUPPORTED
 */
#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */

#ifdef PNG_FORMAT_BGR_SUPPORTED
#  define PNG_FORMAT_FLAG_BGR    0x10U /* BGR colors, else order is RGB */
#endif

#ifdef PNG_FORMAT_AFIRST_SUPPORTED
#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
#endif

/* Commonly used formats have predefined macros.
 *
 * First the single byte (sRGB) formats:
 */
#define PNG_FORMAT_GRAY 0
#define PNG_FORMAT_GA   PNG_FORMAT_FLAG_ALPHA
#define PNG_FORMAT_AG   (PNG_FORMAT_GA|PNG_FORMAT_FLAG_AFIRST)
#define PNG_FORMAT_RGB  PNG_FORMAT_FLAG_COLOR
#define PNG_FORMAT_BGR  (PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_BGR)
#define PNG_FORMAT_RGBA (PNG_FORMAT_RGB|PNG_FORMAT_FLAG_ALPHA)
#define PNG_FORMAT_ARGB (PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_AFIRST)
#define PNG_FORMAT_BGRA (PNG_FORMAT_BGR|PNG_FORMAT_FLAG_ALPHA)
#define PNG_FORMAT_ABGR (PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_AFIRST)

/* Then the linear 2-byte formats.  When naming these "Y" is used to
 * indicate a luminance (gray) channel.
 */
#define PNG_FORMAT_LINEAR_Y PNG_FORMAT_FLAG_LINEAR
#define PNG_FORMAT_LINEAR_Y_ALPHA (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_ALPHA)
#define PNG_FORMAT_LINEAR_RGB (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR)
#define PNG_FORMAT_LINEAR_RGB_ALPHA \
   (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA)

/* With color-mapped formats the image data is one byte for each pixel, the byte
 * is an index into the color-map which is formatted as above.  To obtain a
 * color-mapped format it is sufficient just to add the PNG_FOMAT_FLAG_COLORMAP
 * to one of the above definitions, or you can use one of the definitions below.
 */
#define PNG_FORMAT_RGB_COLORMAP  (PNG_FORMAT_RGB|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_BGR_COLORMAP  (PNG_FORMAT_BGR|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_RGBA_COLORMAP (PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_ARGB_COLORMAP (PNG_FORMAT_ARGB|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_BGRA_COLORMAP (PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_ABGR_COLORMAP (PNG_FORMAT_ABGR|PNG_FORMAT_FLAG_COLORMAP)

/* PNG_IMAGE macros
 *
 * These are convenience macros to derive information from a png_image
 * structure.  The PNG_IMAGE_SAMPLE_ macros return values appropriate to the
 * actual image sample values - either the entries in the color-map or the
 * pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values
 * for the pixels and will always return 1 for color-mapped formats.  The
 * remaining macros return information about the rows in the image and the
 * complete image.
 *
 * NOTE: All the macros that take a png_image::format parameter are compile time
 * constants if the format parameter is, itself, a constant.  Therefore these
 * macros can be used in array declarations and case labels where required.
 * Similarly the macros are also pre-processor constants (sizeof is not used) so
 * they can be used in #if tests.
 *
 * First the information about the samples.
 */
#define PNG_IMAGE_SAMPLE_CHANNELS(fmt)\
   (((fmt)&(PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA))+1)
   /* Return the total number of channels in a given format: 1..4 */

#define PNG_IMAGE_SAMPLE_COMPONENT_SIZE(fmt)\
   ((((fmt) & PNG_FORMAT_FLAG_LINEAR) >> 2)+1)
   /* Return the size in bytes of a single component of a pixel or color-map
    * entry (as appropriate) in the image: 1 or 2.
    */

#define PNG_IMAGE_SAMPLE_SIZE(fmt)\
   (PNG_IMAGE_SAMPLE_CHANNELS(fmt) * PNG_IMAGE_SAMPLE_COMPONENT_SIZE(fmt))
   /* This is the size of the sample data for one sample.  If the image is
    * color-mapped it is the size of one color-map entry (and image pixels are
    * one byte in size), otherwise it is the size of one image pixel.
    */

#define PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(fmt)\
   (PNG_IMAGE_SAMPLE_CHANNELS(fmt) * 256)
   /* The maximum size of the color-map required by the format expressed in a
    * count of components.  This can be used to compile-time allocate a
    * color-map:
    *
    * png_uint_16 colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(linear_fmt)];
    *
    * png_byte colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(sRGB_fmt)];
    *
    * Alternatively use the PNG_IMAGE_COLORMAP_SIZE macro below to use the
    * information from one of the png_image_begin_read_ APIs and dynamically
    * allocate the required memory.
    */

/* Corresponding information about the pixels */
#define PNG_IMAGE_PIXEL_(test,fmt)\
   (((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))

#define PNG_IMAGE_PIXEL_CHANNELS(fmt)\
   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_CHANNELS,fmt)
   /* The number of separate channels (components) in a pixel; 1 for a
    * color-mapped image.
    */

#define PNG_IMAGE_PIXEL_COMPONENT_SIZE(fmt)\
   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_COMPONENT_SIZE,fmt)
   /* The size, in bytes, of each component in a pixel; 1 for a color-mapped
    * image.
    */

#define PNG_IMAGE_PIXEL_SIZE(fmt) PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_SIZE,fmt)
   /* The size, in bytes, of a complete pixel; 1 for a color-mapped image. */

/* Information about the whole row, or whole image */
#define PNG_IMAGE_ROW_STRIDE(image)\
   (PNG_IMAGE_PIXEL_CHANNELS((image).format) * (image).width)
   /* Return the total number of components in a single row of the image; this
    * is the minimum 'row stride', the minimum count of components between each
    * row.  For a color-mapped image this is the minimum number of bytes in a
    * row.
    *
    * WARNING: this macro overflows for some images with more than one component
    * and very large image widths.  libpng will refuse to process an image where
    * this macro would overflow.
    */

#define PNG_IMAGE_BUFFER_SIZE(image, row_stride)\
   (PNG_IMAGE_PIXEL_COMPONENT_SIZE((image).format)*(image).height*(row_stride))
   /* Return the size, in bytes, of an image buffer given a png_image and a row
    * stride - the number of components to leave space for in each row.
    *
    * WARNING: this macro overflows a 32-bit integer for some large PNG images,
    * libpng will refuse to process an image where such an overflow would occur.
    */

#define PNG_IMAGE_SIZE(image)\
   PNG_IMAGE_BUFFER_SIZE(image, PNG_IMAGE_ROW_STRIDE(image))
   /* Return the size, in bytes, of the image in memory given just a png_image;
    * the row stride is the minimum stride required for the image.
    */

#define PNG_IMAGE_COLORMAP_SIZE(image)\
   (PNG_IMAGE_SAMPLE_SIZE((image).format) * (image).colormap_entries)
   /* Return the size, in bytes, of the color-map of this image.  If the image
    * format is not a color-map format this will return a size sufficient for
    * 256 entries in the given format; check PNG_FORMAT_FLAG_COLORMAP if
    * you don't want to allocate a color-map in this case.
    */

/* PNG_IMAGE_FLAG_*
 *
 * Flags containing additional information about the image are held in the
 * 'flags' field of png_image.
 */
#define PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB 0x01
   /* This indicates the the RGB values of the in-memory bitmap do not
    * correspond to the red, green and blue end-points defined by sRGB.
    */

#define PNG_IMAGE_FLAG_FAST 0x02
   /* On write emphasise speed over compression; the resultant PNG file will be
    * larger but will be produced significantly faster, particular for large
    * images.  Do not use this option for images which will be distributed, only
    * used it when producing intermediate files that will be read back in
    * repeatedly.  For a typical 24-bit image the option will double the read
    * speed at the cost of increasing the image size by 25%, however for many
    * more compressible images the PNG file can be 10 times larger with only a
    * slight speed gain.
    */

#define PNG_IMAGE_FLAG_16BIT_sRGB 0x04
   /* On read if the image is a 16-bit per component image and there is no gAMA
    * or sRGB chunk assume that the components are sRGB encoded.  Notice that
    * images output by the simplified API always have gamma information; setting
    * this flag only affects the interpretation of 16-bit images from an
    * external source.  It is recommended that the application expose this flag
    * to the user; the user can normally easily recognize the difference between
    * linear and sRGB encoding.  This flag has no effect on write - the data
    * passed to the write APIs must have the correct encoding (as defined
    * above.)
    *
    * If the flag is not set (the default) input 16-bit per component data is
    * assumed to be linear.
    *
    * NOTE: the flag can only be set after the png_image_begin_read_ call,
    * because that call initializes the 'flags' field.
    */

#ifdef PNG_SIMPLIFIED_READ_SUPPORTED
/* READ APIs
 * ---------
 *
 * The png_image passed to the read APIs must have been initialized by setting
 * the png_controlp field 'opaque' to NULL (or, safer, memset the whole thing.)
 */
#ifdef PNG_STDIO_SUPPORTED
PNG_EXPORT(234, int, png_image_begin_read_from_file, (png_imagep image,
   const char *file_name));
   /* The named file is opened for read and the image header is filled in
    * from the PNG header in the file.
    */

PNG_EXPORT(235, int, png_image_begin_read_from_stdio, (png_imagep image,
   FILE* file));
   /* The PNG header is read from the stdio FILE object. */
#endif /* STDIO */

PNG_EXPORT(236, int, png_image_begin_read_from_memory, (png_imagep image,
   png_const_voidp memory, png_size_t size));
   /* The PNG header is read from the given memory buffer. */

PNG_EXPORT(237, int, png_image_finish_read, (png_imagep image,
   png_const_colorp background, void *buffer, png_int_32 row_stride,
   void *colormap));
   /* Finish reading the image into the supplied buffer and clean up the
    * png_image structure.
    *
    * row_stride is the step, in byte or 2-byte units as appropriate,
    * between adjacent rows.  A positive stride indicates that the top-most row
    * is first in the buffer - the normal top-down arrangement.  A negative
    * stride indicates that the bottom-most row is first in the buffer.
    *
    * background need only be supplied if an alpha channel must be removed from
    * a png_byte format and the removal is to be done by compositing on a solid
    * color; otherwise it may be NULL and any composition will be done directly
    * onto the buffer.  The value is an sRGB color to use for the background,
    * for grayscale output the green channel is used.
    *
    * background must be supplied when an alpha channel must be removed from a
    * single byte color-mapped output format, in other words if:
    *
    * 1) The original format from png_image_begin_read_from_* had
    *    PNG_FORMAT_FLAG_ALPHA set.
    * 2) The format set by the application does not.
    * 3) The format set by the application has PNG_FORMAT_FLAG_COLORMAP set and
    *    PNG_FORMAT_FLAG_LINEAR *not* set.
    *
    * For linear output removing the alpha channel is always done by compositing
    * on black and background is ignored.
    *
    * colormap must be supplied when PNG_FORMAT_FLAG_COLORMAP is set.  It must
    * be at least the size (in bytes) returned by PNG_IMAGE_COLORMAP_SIZE.
    * image->colormap_entries will be updated to the actual number of entries
    * written to the colormap; this may be less than the original value.
    */

PNG_EXPORT(238, void, png_image_free, (png_imagep image));
   /* Free any data allocated by libpng in image->opaque, setting the pointer to
    * NULL.  May be called at any time after the structure is initialized.
    */
#endif /* SIMPLIFIED_READ */

#ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
/* WRITE APIS
 * ----------
 * For write you must initialize a png_image structure to describe the image to
 * be written.  To do this use memset to set the whole structure to 0 then
 * initialize fields describing your image.
 *
 * version: must be set to PNG_IMAGE_VERSION
 * opaque: must be initialized to NULL
 * width: image width in pixels
 * height: image height in rows
 * format: the format of the data (image and color-map) you wish to write
 * flags: set to 0 unless one of the defined flags applies; set
 *    PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB for color format images where the RGB
 *    values do not correspond to the colors in sRGB.
 * colormap_entries: set to the number of entries in the color-map (0 to 256)
 */
#ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
PNG_EXPORT(239, int, png_image_write_to_file, (png_imagep image,
   const char *file, int convert_to_8bit, const void *buffer,
   png_int_32 row_stride, const void *colormap));
   /* Write the image to the named file. */

PNG_EXPORT(240, int, png_image_write_to_stdio, (png_imagep image, FILE *file,
   int convert_to_8_bit, const void *buffer, png_int_32 row_stride,
   const void *colormap));
   /* Write the image to the given (FILE*). */
#endif /* SIMPLIFIED_WRITE_STDIO */

/* With all write APIs if image is in one of the linear formats with 16-bit
 * data then setting convert_to_8_bit will cause the output to be an 8-bit PNG
 * gamma encoded according to the sRGB specification, otherwise a 16-bit linear
 * encoded PNG file is written.
 *
 * With color-mapped data formats the colormap parameter point to a color-map
 * with at least image->colormap_entries encoded in the specified format.  If
 * the format is linear the written PNG color-map will be converted to sRGB
 * regardless of the convert_to_8_bit flag.
 *
 * With all APIs row_stride is handled as in the read APIs - it is the spacing
 * from one row to the next in component sized units (1 or 2 bytes) and if
 * negative indicates a bottom-up row layout in the buffer.  If row_stride is
 * zero, libpng will calculate it for you from the image width and number of
 * channels.
 *
 * Note that the write API does not support interlacing, sub-8-bit pixels or
 * most ancillary chunks.  If you need to write text chunks (e.g. for copyright
 * notices) you need to use one of the other APIs.
 */

PNG_EXPORT(245, int, png_image_write_to_memory, (png_imagep image, void *memory,
   png_alloc_size_t * PNG_RESTRICT memory_bytes, int convert_to_8_bit,
   const void *buffer, png_int_32 row_stride, const void *colormap));
   /* Write the image to the given memory buffer.  The function both writes the
    * whole PNG data stream to *memory and updates *memory_bytes with the count
    * of bytes written.
    *
    * 'memory' may be NULL.  In this case *memory_bytes is not read however on
    * success the number of bytes which would have been written will still be
    * stored in *memory_bytes.  On failure *memory_bytes will contain 0.
    *
    * If 'memory' is not NULL it must point to memory[*memory_bytes] of
    * writeable memory.
    *
    * If the function returns success memory[*memory_bytes] (if 'memory' is not
    * NULL) contains the written PNG data.  *memory_bytes will always be less
    * than or equal to the original value.
    *
    * If the function returns false and *memory_bytes was not changed an error
    * occured during write.  If *memory_bytes was changed, or is not 0 if
    * 'memory' was NULL, the write would have succeeded but for the memory
    * buffer being too small.  *memory_bytes contains the required number of
    * bytes and will be bigger that the original value.
    */

#define png_image_write_get_memory_size(image, size, convert_to_8_bit, buffer,\
   row_stride, colormap)\
   png_image_write_to_memory(&(image), 0, &(size), convert_to_8_bit, buffer,\
         row_stride, colormap)
   /* Return the amount of memory in 'size' required to compress this image.
    * The png_image structure 'image' must be filled in as in the above
    * function and must not be changed before the actual write call, the buffer
    * and all other parameters must also be identical to that in the final
    * write call.  The 'size' variable need not be initialized.
    *
    * NOTE: the macro returns true/false, if false is returned 'size' will be
    * set to zero and the write failed and probably will fail if tried again.
    */

/* You can pre-allocate the buffer by making sure it is of sufficient size
 * regardless of the amount of compression achieved.  The buffer size will
 * always be bigger than the original image and it will never be filled.  The
 * following macros are provided to assist in allocating the buffer.
 */
#define PNG_IMAGE_DATA_SIZE(image) (PNG_IMAGE_SIZE(image)+(image).height)
   /* The number of uncompressed bytes in the PNG byte encoding of the image;
    * uncompressing the PNG IDAT data will give this number of bytes.
    *
    * NOTE: while PNG_IMAGE_SIZE cannot overflow for an image in memory this
    * macro can because of the extra bytes used in the PNG byte encoding.  You
    * need to avoid this macro if your image size approaches 2^30 in width or
    * height.  The same goes for the remainder of these macros; they all produce
    * bigger numbers than the actual in-memory image size.
    */
#ifndef PNG_ZLIB_MAX_SIZE
#  define PNG_ZLIB_MAX_SIZE(b) ((b)+(((b)+7U)>>3)+(((b)+63U)>>6)+11U)
   /* An upper bound on the number of compressed bytes given 'b' uncompressed
    * bytes.  This is based on deflateBounds() in zlib; different
    * implementations of zlib compression may conceivably produce more data so
    * if your zlib implementation is not zlib itself redefine this macro
    * appropriately.
    */
#endif

#define PNG_IMAGE_COMPRESSED_SIZE_MAX(image)\
   PNG_ZLIB_MAX_SIZE((png_alloc_size_t)PNG_IMAGE_DATA_SIZE(image))
   /* An upper bound on the size of the data in the PNG IDAT chunks. */

#define PNG_IMAGE_PNG_SIZE_MAX_(image, image_size)\
   ((8U/*sig*/+25U/*IHDR*/+16U/*gAMA*/+44U/*cHRM*/+12U/*IEND*/+\
    (((image).format&PNG_FORMAT_FLAG_COLORMAP)?/*colormap: PLTE, tRNS*/\
    12U+3U*(image).colormap_entries/*PLTE data*/+\
    (((image).format&PNG_FORMAT_FLAG_ALPHA)?\
    12U/*tRNS*/+(image).colormap_entries:0U):0U)+\
    12U)+(12U*((image_size)/PNG_ZBUF_SIZE))/*IDAT*/+(image_size))
   /* A helper for the following macro; if your compiler cannot handle the
    * following macro use this one with the result of
    * PNG_IMAGE_COMPRESSED_SIZE_MAX(image) as the second argument (most
    * compilers should handle this just fine.)
    */

#define PNG_IMAGE_PNG_SIZE_MAX(image)\
   PNG_IMAGE_PNG_SIZE_MAX_(image, PNG_IMAGE_COMPRESSED_SIZE_MAX(image))
   /* An upper bound on the total length of the PNG data stream for 'image'.
    * The result is of type png_alloc_size_t, on 32-bit systems this may
    * overflow even though PNG_IMAGE_DATA_SIZE does not overflow; the write will
    * run out of buffer space but return a corrected size which should work.
    */
#endif /* SIMPLIFIED_WRITE */
/*******************************************************************************
 *  END OF SIMPLIFIED API
 ******************************************************************************/
#endif /* SIMPLIFIED_{READ|WRITE} */

/*******************************************************************************
 * Section 6: IMPLEMENTATION OPTIONS
 *******************************************************************************
 *
 * Support for arbitrary implementation-specific optimizations.  The API allows
 * particular options to be turned on or off.  'Option' is the number of the
 * option and 'onoff' is 0 (off) or non-0 (on).  The value returned is given
 * by the PNG_OPTION_ defines below.
 *
 * HARDWARE: normally hardware capabilites, such as the Intel SSE instructions,
 *           are detected at run time, however sometimes it may be impossible
 *           to do this in user mode, in which case it is necessary to discover
 *           the capabilities in an OS specific way.  Such capabilities are
 *           listed here when libpng has support for them and must be turned
 *           ON by the application if present.
 *
 * SOFTWARE: sometimes software optimizations actually result in performance
 *           decrease on some architectures or systems, or with some sets of
 *           PNG images.  'Software' options allow such optimizations to be
 *           selected at run time.
 */
#ifdef PNG_SET_OPTION_SUPPORTED
#ifdef PNG_ARM_NEON_API_SUPPORTED
#  define PNG_ARM_NEON   0 /* HARDWARE: ARM Neon SIMD instructions supported */
#endif
#define PNG_MAXIMUM_INFLATE_WINDOW 2 /* SOFTWARE: force maximum window */
#define PNG_SKIP_sRGB_CHECK_PROFILE 4 /* SOFTWARE: Check ICC profile for sRGB */
#ifdef PNG_MIPS_MSA_API_SUPPORTED
#  define PNG_MIPS_MSA   6 /* HARDWARE: MIPS Msa SIMD instructions supported */
#endif
#define PNG_IGNORE_ADLER32 8
#define PNG_OPTION_NEXT  10 /* Next option - numbers must be even */

/* Return values: NOTE: there are four values and 'off' is *not* zero */
#define PNG_OPTION_UNSET   0 /* Unset - defaults to off */
#define PNG_OPTION_INVALID 1 /* Option number out of range */
#define PNG_OPTION_OFF     2
#define PNG_OPTION_ON      3

PNG_EXPORT(244, int, png_set_option, (png_structrp png_ptr, int option,
   int onoff));
#endif /* SET_OPTION */

/*******************************************************************************
 *  END OF HARDWARE AND SOFTWARE OPTIONS
 ******************************************************************************/

/* Maintainer: Put new public prototypes here ^, in libpng.3, in project
 * defs, and in scripts/symbols.def.
 */

/* The last ordinal number (this is the *last* one already used; the next
 * one to use is one more than this.)
 */
#ifdef PNG_EXPORT_LAST_ORDINAL
  PNG_EXPORT_LAST_ORDINAL(245);
#endif

#ifdef __cplusplus
}
#endif

#endif /* PNG_VERSION_INFO_ONLY */
/* Do not put anything past this line */
#endif /* PNG_H */

```

`Engine/ThirdParty/PNG/Include/IOS/pngconf.h`:

```h

/* pngconf.h - machine configurable file for libpng
 *
 * libpng version 1.6.28, January 5, 2017
 *
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * Any machine specific code is near the front of this file, so if you
 * are configuring libpng for a machine, you may want to read the section
 * starting here down to where it starts to typedef png_color, png_text,
 * and png_info.
 */

#ifndef PNGCONF_H
#define PNGCONF_H

#ifndef PNG_BUILDING_SYMBOL_TABLE /* else includes may cause problems */

/* From libpng 1.6.0 libpng requires an ANSI X3.159-1989 ("ISOC90") compliant C
 * compiler for correct compilation.  The following header files are required by
 * the standard.  If your compiler doesn't provide these header files, or they
 * do not match the standard, you will need to provide/improve them.
 */
#include <limits.h>
#include <stddef.h>

/* Library header files.  These header files are all defined by ISOC90; libpng
 * expects conformant implementations, however, an ISOC90 conformant system need
 * not provide these header files if the functionality cannot be implemented.
 * In this case it will be necessary to disable the relevant parts of libpng in
 * the build of pnglibconf.h.
 *
 * Prior to 1.6.0 string.h was included here; the API changes in 1.6.0 to not
 * include this unnecessary header file.
 */

#ifdef PNG_STDIO_SUPPORTED
   /* Required for the definition of FILE: */
#  include <stdio.h>
#endif

#ifdef PNG_SETJMP_SUPPORTED
   /* Required for the definition of jmp_buf and the declaration of longjmp: */
#  include <setjmp.h>
#endif

#ifdef PNG_CONVERT_tIME_SUPPORTED
   /* Required for struct tm: */
#  include <time.h>
#endif

#endif /* PNG_BUILDING_SYMBOL_TABLE */

/* Prior to 1.6.0 it was possible to turn off 'const' in declarations using
 * PNG_NO_CONST; this is no longer supported except for data declarations which
 * apparently still cause problems in 2011 on some compilers.
 */
#define PNG_CONST const /* backward compatibility only */

/* This controls optimization of the reading of 16-bit and 32-bit values
 * from PNG files.  It can be set on a per-app-file basis - it
 * just changes whether a macro is used when the function is called.
 * The library builder sets the default; if read functions are not
 * built into the library the macro implementation is forced on.
 */
#ifndef PNG_READ_INT_FUNCTIONS_SUPPORTED
#  define PNG_USE_READ_MACROS
#endif
#if !defined(PNG_NO_USE_READ_MACROS) && !defined(PNG_USE_READ_MACROS)
#  if PNG_DEFAULT_READ_MACROS
#    define PNG_USE_READ_MACROS
#  endif
#endif

/* COMPILER SPECIFIC OPTIONS.
 *
 * These options are provided so that a variety of difficult compilers
 * can be used.  Some are fixed at build time (e.g. PNG_API_RULE
 * below) but still have compiler specific implementations, others
 * may be changed on a per-file basis when compiling against libpng.
 */

/* The PNGARG macro was used in versions of libpng prior to 1.6.0 to protect
 * against legacy (pre ISOC90) compilers that did not understand function
 * prototypes.  It is not required for modern C compilers.
 */
#ifndef PNGARG
#  define PNGARG(arglist) arglist
#endif

/* Function calling conventions.
 * =============================
 * Normally it is not necessary to specify to the compiler how to call
 * a function - it just does it - however on x86 systems derived from
 * Microsoft and Borland C compilers ('IBM PC', 'DOS', 'Windows' systems
 * and some others) there are multiple ways to call a function and the
 * default can be changed on the compiler command line.  For this reason
 * libpng specifies the calling convention of every exported function and
 * every function called via a user supplied function pointer.  This is
 * done in this file by defining the following macros:
 *
 * PNGAPI    Calling convention for exported functions.
 * PNGCBAPI  Calling convention for user provided (callback) functions.
 * PNGCAPI   Calling convention used by the ANSI-C library (required
 *           for longjmp callbacks and sometimes used internally to
 *           specify the calling convention for zlib).
 *
 * These macros should never be overridden.  If it is necessary to
 * change calling convention in a private build this can be done
 * by setting PNG_API_RULE (which defaults to 0) to one of the values
 * below to select the correct 'API' variants.
 *
 * PNG_API_RULE=0 Use PNGCAPI - the 'C' calling convention - throughout.
 *                This is correct in every known environment.
 * PNG_API_RULE=1 Use the operating system convention for PNGAPI and
 *                the 'C' calling convention (from PNGCAPI) for
 *                callbacks (PNGCBAPI).  This is no longer required
 *                in any known environment - if it has to be used
 *                please post an explanation of the problem to the
 *                libpng mailing list.
 *
 * These cases only differ if the operating system does not use the C
 * calling convention, at present this just means the above cases
 * (x86 DOS/Windows systems) and, even then, this does not apply to
 * Cygwin running on those systems.
 *
 * Note that the value must be defined in pnglibconf.h so that what
 * the application uses to call the library matches the conventions
 * set when building the library.
 */

/* Symbol export
 * =============
 * When building a shared library it is almost always necessary to tell
 * the compiler which symbols to export.  The png.h macro 'PNG_EXPORT'
 * is used to mark the symbols.  On some systems these symbols can be
 * extracted at link time and need no special processing by the compiler,
 * on other systems the symbols are flagged by the compiler and just
 * the declaration requires a special tag applied (unfortunately) in a
 * compiler dependent way.  Some systems can do either.
 *
 * A small number of older systems also require a symbol from a DLL to
 * be flagged to the program that calls it.  This is a problem because
 * we do not know in the header file included by application code that
 * the symbol will come from a shared library, as opposed to a statically
 * linked one.  For this reason the application must tell us by setting
 * the magic flag PNG_USE_DLL to turn on the special processing before
 * it includes png.h.
 *
 * Four additional macros are used to make this happen:
 *
 * PNG_IMPEXP The magic (if any) to cause a symbol to be exported from
 *            the build or imported if PNG_USE_DLL is set - compiler
 *            and system specific.
 *
 * PNG_EXPORT_TYPE(type) A macro that pre or appends PNG_IMPEXP to
 *                       'type', compiler specific.
 *
 * PNG_DLL_EXPORT Set to the magic to use during a libpng build to
 *                make a symbol exported from the DLL.  Not used in the
 *                public header files; see pngpriv.h for how it is used
 *                in the libpng build.
 *
 * PNG_DLL_IMPORT Set to the magic to force the libpng symbols to come
 *                from a DLL - used to define PNG_IMPEXP when
 *                PNG_USE_DLL is set.
 */

/* System specific discovery.
 * ==========================
 * This code is used at build time to find PNG_IMPEXP, the API settings
 * and PNG_EXPORT_TYPE(), it may also set a macro to indicate the DLL
 * import processing is possible.  On Windows systems it also sets
 * compiler-specific macros to the values required to change the calling
 * conventions of the various functions.
 */
#if defined(_Windows) || defined(_WINDOWS) || defined(WIN32) ||\
    defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
  /* Windows system (DOS doesn't support DLLs).  Includes builds under Cygwin or
   * MinGW on any architecture currently supported by Windows.  Also includes
   * Watcom builds but these need special treatment because they are not
   * compatible with GCC or Visual C because of different calling conventions.
   */
#  if PNG_API_RULE == 2
   /* If this line results in an error, either because __watcall is not
    * understood or because of a redefine just below you cannot use *this*
    * build of the library with the compiler you are using.  *This* build was
    * build using Watcom and applications must also be built using Watcom!
    */
#    define PNGCAPI __watcall
#  endif

#  if defined(__GNUC__) || (defined(_MSC_VER) && (_MSC_VER >= 800))
#    define PNGCAPI __cdecl
#    if PNG_API_RULE == 1
   /* If this line results in an error __stdcall is not understood and
    * PNG_API_RULE should not have been set to '1'.
    */
#      define PNGAPI __stdcall
#    endif
#  else
   /* An older compiler, or one not detected (erroneously) above,
    * if necessary override on the command line to get the correct
    * variants for the compiler.
    */
#    ifndef PNGCAPI
#      define PNGCAPI _cdecl
#    endif
#    if PNG_API_RULE == 1 && !defined(PNGAPI)
#      define PNGAPI _stdcall
#    endif
#  endif /* compiler/api */

  /* NOTE: PNGCBAPI always defaults to PNGCAPI. */

#  if defined(PNGAPI) && !defined(PNG_USER_PRIVATEBUILD)
#     error "PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed"
#  endif

#  if (defined(_MSC_VER) && _MSC_VER < 800) ||\
      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
   /* older Borland and MSC
    * compilers used '__export' and required this to be after
    * the type.
    */
#    ifndef PNG_EXPORT_TYPE
#      define PNG_EXPORT_TYPE(type) type PNG_IMPEXP
#    endif
#    define PNG_DLL_EXPORT __export
#  else /* newer compiler */
#    define PNG_DLL_EXPORT __declspec(dllexport)
#    ifndef PNG_DLL_IMPORT
#      define PNG_DLL_IMPORT __declspec(dllimport)
#    endif
#  endif /* compiler */

#else /* !Windows */
#  if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
#    define PNGAPI _System
#  else /* !Windows/x86 && !OS/2 */
   /* Use the defaults, or define PNG*API on the command line (but
    * this will have to be done for every compile!)
    */
#  endif /* other system, !OS/2 */
#endif /* !Windows/x86 */

/* Now do all the defaulting . */
#ifndef PNGCAPI
#  define PNGCAPI
#endif
#ifndef PNGCBAPI
#  define PNGCBAPI PNGCAPI
#endif
#ifndef PNGAPI
#  define PNGAPI PNGCAPI
#endif

/* PNG_IMPEXP may be set on the compilation system command line or (if not set)
 * then in an internal header file when building the library, otherwise (when
 * using the library) it is set here.
 */
#ifndef PNG_IMPEXP
#  if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
   /* This forces use of a DLL, disallowing static linking */
#    define PNG_IMPEXP PNG_DLL_IMPORT
#  endif

#  ifndef PNG_IMPEXP
#    define PNG_IMPEXP
#  endif
#endif

/* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
 * 'attributes' as a storage class - the attributes go at the start of the
 * function definition, and attributes are always appended regardless of the
 * compiler.  This considerably simplifies these macros but may cause problems
 * if any compilers both need function attributes and fail to handle them as
 * a storage class (this is unlikely.)
 */
#ifndef PNG_FUNCTION
#  define PNG_FUNCTION(type, name, args, attributes) attributes type name args
#endif

#ifndef PNG_EXPORT_TYPE
#  define PNG_EXPORT_TYPE(type) PNG_IMPEXP type
#endif

   /* The ordinal value is only relevant when preprocessing png.h for symbol
    * table entries, so we discard it here.  See the .dfn files in the
    * scripts directory.
    */

#ifndef PNG_EXPORTA
#  define PNG_EXPORTA(ordinal, type, name, args, attributes) \
      PNG_FUNCTION(PNG_EXPORT_TYPE(type), (PNGAPI name), PNGARG(args), \
      PNG_LINKAGE_API attributes)
#endif

/* ANSI-C (C90) does not permit a macro to be invoked with an empty argument,
 * so make something non-empty to satisfy the requirement:
 */
#define PNG_EMPTY /*empty list*/

#define PNG_EXPORT(ordinal, type, name, args) \
   PNG_EXPORTA(ordinal, type, name, args, PNG_EMPTY)

/* Use PNG_REMOVED to comment out a removed interface. */
#ifndef PNG_REMOVED
#  define PNG_REMOVED(ordinal, type, name, args, attributes)
#endif

#ifndef PNG_CALLBACK
#  define PNG_CALLBACK(type, name, args) type (PNGCBAPI name) PNGARG(args)
#endif

/* Support for compiler specific function attributes.  These are used
 * so that where compiler support is available incorrect use of API
 * functions in png.h will generate compiler warnings.
 *
 * Added at libpng-1.2.41.
 */

#ifndef PNG_NO_PEDANTIC_WARNINGS
#  ifndef PNG_PEDANTIC_WARNINGS_SUPPORTED
#    define PNG_PEDANTIC_WARNINGS_SUPPORTED
#  endif
#endif

#ifdef PNG_PEDANTIC_WARNINGS_SUPPORTED
  /* Support for compiler specific function attributes.  These are used
   * so that where compiler support is available, incorrect use of API
   * functions in png.h will generate compiler warnings.  Added at libpng
   * version 1.2.41.  Disabling these removes the warnings but may also produce
   * less efficient code.
   */
#  if defined(__clang__) && defined(__has_attribute)
   /* Clang defines both __clang__ and __GNUC__. Check __clang__ first. */
#    if !defined(PNG_USE_RESULT) && __has_attribute(__warn_unused_result__)
#      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
#    endif
#    if !defined(PNG_NORETURN) && __has_attribute(__noreturn__)
#      define PNG_NORETURN __attribute__((__noreturn__))
#    endif
#    if !defined(PNG_ALLOCATED) && __has_attribute(__malloc__)
#      define PNG_ALLOCATED __attribute__((__malloc__))
#    endif
#    if !defined(PNG_DEPRECATED) && __has_attribute(__deprecated__)
#      define PNG_DEPRECATED __attribute__((__deprecated__))
#    endif
#    if !defined(PNG_PRIVATE)
#      ifdef __has_extension
#        if __has_extension(attribute_unavailable_with_message)
#          define PNG_PRIVATE __attribute__((__unavailable__(\
             "This function is not exported by libpng.")))
#        endif
#      endif
#    endif
#    ifndef PNG_RESTRICT
#      define PNG_RESTRICT __restrict
#    endif

#  elif defined(__GNUC__)
#    ifndef PNG_USE_RESULT
#      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
#    endif
#    ifndef PNG_NORETURN
#      define PNG_NORETURN   __attribute__((__noreturn__))
#    endif
#    if __GNUC__ >= 3
#      ifndef PNG_ALLOCATED
#        define PNG_ALLOCATED  __attribute__((__malloc__))
#      endif
#      ifndef PNG_DEPRECATED
#        define PNG_DEPRECATED __attribute__((__deprecated__))
#      endif
#      ifndef PNG_PRIVATE
#        if 0 /* Doesn't work so we use deprecated instead*/
#          define PNG_PRIVATE \
            __attribute__((warning("This function is not exported by libpng.")))
#        else
#          define PNG_PRIVATE \
            __attribute__((__deprecated__))
#        endif
#      endif
#      if ((__GNUC__ > 3) || !defined(__GNUC_MINOR__) || (__GNUC_MINOR__ >= 1))
#        ifndef PNG_RESTRICT
#          define PNG_RESTRICT __restrict
#        endif
#      endif /* __GNUC__.__GNUC_MINOR__ > 3.0 */
#    endif /* __GNUC__ >= 3 */

#  elif defined(_MSC_VER)  && (_MSC_VER >= 1300)
#    ifndef PNG_USE_RESULT
#      define PNG_USE_RESULT /* not supported */
#    endif
#    ifndef PNG_NORETURN
#      define PNG_NORETURN   __declspec(noreturn)
#    endif
#    ifndef PNG_ALLOCATED
#      if (_MSC_VER >= 1400)
#        define PNG_ALLOCATED __declspec(restrict)
#      endif
#    endif
#    ifndef PNG_DEPRECATED
#      define PNG_DEPRECATED __declspec(deprecated)
#    endif
#    ifndef PNG_PRIVATE
#      define PNG_PRIVATE __declspec(deprecated)
#    endif
#    ifndef PNG_RESTRICT
#      if (_MSC_VER >= 1400)
#        define PNG_RESTRICT __restrict
#      endif
#    endif

#  elif defined(__WATCOMC__)
#    ifndef PNG_RESTRICT
#      define PNG_RESTRICT __restrict
#    endif
#  endif
#endif /* PNG_PEDANTIC_WARNINGS */

#ifndef PNG_DEPRECATED
#  define PNG_DEPRECATED  /* Use of this function is deprecated */
#endif
#ifndef PNG_USE_RESULT
#  define PNG_USE_RESULT  /* The result of this function must be checked */
#endif
#ifndef PNG_NORETURN
#  define PNG_NORETURN    /* This function does not return */
#endif
#ifndef PNG_ALLOCATED
#  define PNG_ALLOCATED   /* The result of the function is new memory */
#endif
#ifndef PNG_PRIVATE
#  define PNG_PRIVATE     /* This is a private libpng function */
#endif
#ifndef PNG_RESTRICT
#  define PNG_RESTRICT    /* The C99 "restrict" feature */
#endif

#ifndef PNG_FP_EXPORT     /* A floating point API. */
#  ifdef PNG_FLOATING_POINT_SUPPORTED
#     define PNG_FP_EXPORT(ordinal, type, name, args)\
         PNG_EXPORT(ordinal, type, name, args);
#  else                   /* No floating point APIs */
#     define PNG_FP_EXPORT(ordinal, type, name, args)
#  endif
#endif
#ifndef PNG_FIXED_EXPORT  /* A fixed point API. */
#  ifdef PNG_FIXED_POINT_SUPPORTED
#     define PNG_FIXED_EXPORT(ordinal, type, name, args)\
         PNG_EXPORT(ordinal, type, name, args);
#  else                   /* No fixed point APIs */
#     define PNG_FIXED_EXPORT(ordinal, type, name, args)
#  endif
#endif

#ifndef PNG_BUILDING_SYMBOL_TABLE
/* Some typedefs to get us started.  These should be safe on most of the common
 * platforms.
 *
 * png_uint_32 and png_int_32 may, currently, be larger than required to hold a
 * 32-bit value however this is not normally advisable.
 *
 * png_uint_16 and png_int_16 should always be two bytes in size - this is
 * verified at library build time.
 *
 * png_byte must always be one byte in size.
 *
 * The checks below use constants from limits.h, as defined by the ISOC90
 * standard.
 */
#if CHAR_BIT == 8 && UCHAR_MAX == 255
   typedef unsigned char png_byte;
#else
#  error "libpng requires 8-bit bytes"
#endif

#if INT_MIN == -32768 && INT_MAX == 32767
   typedef int png_int_16;
#elif SHRT_MIN == -32768 && SHRT_MAX == 32767
   typedef short png_int_16;
#else
#  error "libpng requires a signed 16-bit type"
#endif

#if UINT_MAX == 65535
   typedef unsigned int png_uint_16;
#elif USHRT_MAX == 65535
   typedef unsigned short png_uint_16;
#else
#  error "libpng requires an unsigned 16-bit type"
#endif

#if INT_MIN < -2147483646 && INT_MAX > 2147483646
   typedef int png_int_32;
#elif LONG_MIN < -2147483646 && LONG_MAX > 2147483646
   typedef long int png_int_32;
#else
#  error "libpng requires a signed 32-bit (or more) type"
#endif

#if UINT_MAX > 4294967294U
   typedef unsigned int png_uint_32;
#elif ULONG_MAX > 4294967294U
   typedef unsigned long int png_uint_32;
#else
#  error "libpng requires an unsigned 32-bit (or more) type"
#endif

/* Prior to 1.6.0 it was possible to disable the use of size_t, 1.6.0, however,
 * requires an ISOC90 compiler and relies on consistent behavior of sizeof.
 */
typedef size_t png_size_t;
typedef ptrdiff_t png_ptrdiff_t;

/* libpng needs to know the maximum value of 'size_t' and this controls the
 * definition of png_alloc_size_t, below.  This maximum value of size_t limits
 * but does not control the maximum allocations the library makes - there is
 * direct application control of this through png_set_user_limits().
 */
#ifndef PNG_SMALL_SIZE_T
   /* Compiler specific tests for systems where size_t is known to be less than
    * 32 bits (some of these systems may no longer work because of the lack of
    * 'far' support; see above.)
    */
#  if (defined(__TURBOC__) && !defined(__FLAT__)) ||\
   (defined(_MSC_VER) && defined(MAXSEG_64K))
#     define PNG_SMALL_SIZE_T
#  endif
#endif

/* png_alloc_size_t is guaranteed to be no smaller than png_size_t, and no
 * smaller than png_uint_32.  Casts from png_size_t or png_uint_32 to
 * png_alloc_size_t are not necessary; in fact, it is recommended not to use
 * them at all so that the compiler can complain when something turns out to be
 * problematic.
 *
 * Casts in the other direction (from png_alloc_size_t to png_size_t or
 * png_uint_32) should be explicitly applied; however, we do not expect to
 * encounter practical situations that require such conversions.
 *
 * PNG_SMALL_SIZE_T must be defined if the maximum value of size_t is less than
 * 4294967295 - i.e. less than the maximum value of png_uint_32.
 */
#ifdef PNG_SMALL_SIZE_T
   typedef png_uint_32 png_alloc_size_t;
#else
   typedef png_size_t png_alloc_size_t;
#endif

/* Prior to 1.6.0 libpng offered limited support for Microsoft C compiler
 * implementations of Intel CPU specific support of user-mode segmented address
 * spaces, where 16-bit pointers address more than 65536 bytes of memory using
 * separate 'segment' registers.  The implementation requires two different
 * types of pointer (only one of which includes the segment value.)
 *
 * If required this support is available in version 1.2 of libpng and may be
 * available in versions through 1.5, although the correctness of the code has
 * not been verified recently.
 */

/* Typedef for floating-point numbers that are converted to fixed-point with a
 * multiple of 100,000, e.g., gamma
 */
typedef png_int_32 png_fixed_point;

/* Add typedefs for pointers */
typedef void                  * png_voidp;
typedef const void            * png_const_voidp;
typedef png_byte              * png_bytep;
typedef const png_byte        * png_const_bytep;
typedef png_uint_32           * png_uint_32p;
typedef const png_uint_32     * png_const_uint_32p;
typedef png_int_32            * png_int_32p;
typedef const png_int_32      * png_const_int_32p;
typedef png_uint_16           * png_uint_16p;
typedef const png_uint_16     * png_const_uint_16p;
typedef png_int_16            * png_int_16p;
typedef const png_int_16      * png_const_int_16p;
typedef char                  * png_charp;
typedef const char            * png_const_charp;
typedef png_fixed_point       * png_fixed_point_p;
typedef const png_fixed_point * png_const_fixed_point_p;
typedef png_size_t            * png_size_tp;
typedef const png_size_t      * png_const_size_tp;

#ifdef PNG_STDIO_SUPPORTED
typedef FILE            * png_FILE_p;
#endif

#ifdef PNG_FLOATING_POINT_SUPPORTED
typedef double       * png_doublep;
typedef const double * png_const_doublep;
#endif

/* Pointers to pointers; i.e. arrays */
typedef png_byte        * * png_bytepp;
typedef png_uint_32     * * png_uint_32pp;
typedef png_int_32      * * png_int_32pp;
typedef png_uint_16     * * png_uint_16pp;
typedef png_int_16      * * png_int_16pp;
typedef const char      * * png_const_charpp;
typedef char            * * png_charpp;
typedef png_fixed_point * * png_fixed_point_pp;
#ifdef PNG_FLOATING_POINT_SUPPORTED
typedef double          * * png_doublepp;
#endif

/* Pointers to pointers to pointers; i.e., pointer to array */
typedef char            * * * png_charppp;

#endif /* PNG_BUILDING_SYMBOL_TABLE */

#endif /* PNGCONF_H */

```

`Engine/ThirdParty/PNG/Include/IOS/pnglibconf.h`:

```h
/* libpng 1.6.28 STANDARD API DEFINITION */

/* pnglibconf.h - library build configuration */

/* Libpng version 1.6.28 - January 5, 2017 */

/* Copyright (c) 1998-2015 Glenn Randers-Pehrson */

/* This code is released under the libpng license. */
/* For conditions of distribution and use, see the disclaimer */
/* and license in png.h */

/* pnglibconf.h */
/* Machine generated file: DO NOT EDIT */
/* Derived from: scripts/pnglibconf.dfa */
#ifndef PNGLCONF_H
#define PNGLCONF_H
/* options */
#define PNG_16BIT_SUPPORTED
#define PNG_ALIGNED_MEMORY_SUPPORTED
/*#undef PNG_ARM_NEON_API_SUPPORTED*/
/*#undef PNG_ARM_NEON_CHECK_SUPPORTED*/
#define PNG_BENIGN_ERRORS_SUPPORTED
#define PNG_BENIGN_READ_ERRORS_SUPPORTED
/*#undef PNG_BENIGN_WRITE_ERRORS_SUPPORTED*/
#define PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
#define PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
#define PNG_COLORSPACE_SUPPORTED
#define PNG_CONSOLE_IO_SUPPORTED
#define PNG_CONVERT_tIME_SUPPORTED
#define PNG_EASY_ACCESS_SUPPORTED
/*#undef PNG_ERROR_NUMBERS_SUPPORTED*/
#define PNG_ERROR_TEXT_SUPPORTED
#define PNG_FIXED_POINT_SUPPORTED
#define PNG_FLOATING_ARITHMETIC_SUPPORTED
#define PNG_FLOATING_POINT_SUPPORTED
#define PNG_FORMAT_AFIRST_SUPPORTED
#define PNG_FORMAT_BGR_SUPPORTED
#define PNG_GAMMA_SUPPORTED
#define PNG_GET_PALETTE_MAX_SUPPORTED
#define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
#define PNG_INCH_CONVERSIONS_SUPPORTED
#define PNG_INFO_IMAGE_SUPPORTED
#define PNG_IO_STATE_SUPPORTED
#define PNG_MNG_FEATURES_SUPPORTED
#define PNG_POINTER_INDEXING_SUPPORTED
#define PNG_PROGRESSIVE_READ_SUPPORTED
#define PNG_READ_16BIT_SUPPORTED
#define PNG_READ_ALPHA_MODE_SUPPORTED
#define PNG_READ_ANCILLARY_CHUNKS_SUPPORTED
#define PNG_READ_BACKGROUND_SUPPORTED
#define PNG_READ_BGR_SUPPORTED
#define PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
#define PNG_READ_COMPOSITE_NODIV_SUPPORTED
#define PNG_READ_COMPRESSED_TEXT_SUPPORTED
#define PNG_READ_EXPAND_16_SUPPORTED
#define PNG_READ_EXPAND_SUPPORTED
#define PNG_READ_FILLER_SUPPORTED
#define PNG_READ_GAMMA_SUPPORTED
#define PNG_READ_GET_PALETTE_MAX_SUPPORTED
#define PNG_READ_GRAY_TO_RGB_SUPPORTED
#define PNG_READ_INTERLACING_SUPPORTED
#define PNG_READ_INT_FUNCTIONS_SUPPORTED
#define PNG_READ_INVERT_ALPHA_SUPPORTED
#define PNG_READ_INVERT_SUPPORTED
#define PNG_READ_OPT_PLTE_SUPPORTED
#define PNG_READ_PACKSWAP_SUPPORTED
#define PNG_READ_PACK_SUPPORTED
#define PNG_READ_QUANTIZE_SUPPORTED
#define PNG_READ_RGB_TO_GRAY_SUPPORTED
#define PNG_READ_SCALE_16_TO_8_SUPPORTED
#define PNG_READ_SHIFT_SUPPORTED
#define PNG_READ_STRIP_16_TO_8_SUPPORTED
#define PNG_READ_STRIP_ALPHA_SUPPORTED
#define PNG_READ_SUPPORTED
#define PNG_READ_SWAP_ALPHA_SUPPORTED
#define PNG_READ_SWAP_SUPPORTED
#define PNG_READ_TEXT_SUPPORTED
#define PNG_READ_TRANSFORMS_SUPPORTED
#define PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_READ_USER_CHUNKS_SUPPORTED
#define PNG_READ_USER_TRANSFORM_SUPPORTED
#define PNG_READ_bKGD_SUPPORTED
#define PNG_READ_cHRM_SUPPORTED
#define PNG_READ_gAMA_SUPPORTED
#define PNG_READ_hIST_SUPPORTED
#define PNG_READ_iCCP_SUPPORTED
#define PNG_READ_iTXt_SUPPORTED
#define PNG_READ_oFFs_SUPPORTED
#define PNG_READ_pCAL_SUPPORTED
#define PNG_READ_pHYs_SUPPORTED
#define PNG_READ_sBIT_SUPPORTED
#define PNG_READ_sCAL_SUPPORTED
#define PNG_READ_sPLT_SUPPORTED
#define PNG_READ_sRGB_SUPPORTED
#define PNG_READ_tEXt_SUPPORTED
#define PNG_READ_tIME_SUPPORTED
#define PNG_READ_tRNS_SUPPORTED
#define PNG_READ_zTXt_SUPPORTED
#define PNG_SAVE_INT_32_SUPPORTED
#define PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_SEQUENTIAL_READ_SUPPORTED
#define PNG_SETJMP_SUPPORTED
#define PNG_SET_OPTION_SUPPORTED
#define PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_SET_USER_LIMITS_SUPPORTED
#define PNG_SIMPLIFIED_READ_AFIRST_SUPPORTED
#define PNG_SIMPLIFIED_READ_BGR_SUPPORTED
#define PNG_SIMPLIFIED_READ_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_BGR_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_SUPPORTED
#define PNG_STDIO_SUPPORTED
#define PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_TEXT_SUPPORTED
#define PNG_TIME_RFC1123_SUPPORTED
#define PNG_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_USER_CHUNKS_SUPPORTED
#define PNG_USER_LIMITS_SUPPORTED
#define PNG_USER_MEM_SUPPORTED
#define PNG_USER_TRANSFORM_INFO_SUPPORTED
#define PNG_USER_TRANSFORM_PTR_SUPPORTED
#define PNG_WARNINGS_SUPPORTED
#define PNG_WRITE_16BIT_SUPPORTED
#define PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
#define PNG_WRITE_BGR_SUPPORTED
#define PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
#define PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
#define PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
#define PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
#define PNG_WRITE_FILLER_SUPPORTED
#define PNG_WRITE_FILTER_SUPPORTED
#define PNG_WRITE_FLUSH_SUPPORTED
#define PNG_WRITE_GET_PALETTE_MAX_SUPPORTED
#define PNG_WRITE_INTERLACING_SUPPORTED
#define PNG_WRITE_INT_FUNCTIONS_SUPPORTED
#define PNG_WRITE_INVERT_ALPHA_SUPPORTED
#define PNG_WRITE_INVERT_SUPPORTED
#define PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
#define PNG_WRITE_PACKSWAP_SUPPORTED
#define PNG_WRITE_PACK_SUPPORTED
#define PNG_WRITE_SHIFT_SUPPORTED
#define PNG_WRITE_SUPPORTED
#define PNG_WRITE_SWAP_ALPHA_SUPPORTED
#define PNG_WRITE_SWAP_SUPPORTED
#define PNG_WRITE_TEXT_SUPPORTED
#define PNG_WRITE_TRANSFORMS_SUPPORTED
#define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_WRITE_USER_TRANSFORM_SUPPORTED
#define PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
#define PNG_WRITE_bKGD_SUPPORTED
#define PNG_WRITE_cHRM_SUPPORTED
#define PNG_WRITE_gAMA_SUPPORTED
#define PNG_WRITE_hIST_SUPPORTED
#define PNG_WRITE_iCCP_SUPPORTED
#define PNG_WRITE_iTXt_SUPPORTED
#define PNG_WRITE_oFFs_SUPPORTED
#define PNG_WRITE_pCAL_SUPPORTED
#define PNG_WRITE_pHYs_SUPPORTED
#define PNG_WRITE_sBIT_SUPPORTED
#define PNG_WRITE_sCAL_SUPPORTED
#define PNG_WRITE_sPLT_SUPPORTED
#define PNG_WRITE_sRGB_SUPPORTED
#define PNG_WRITE_tEXt_SUPPORTED
#define PNG_WRITE_tIME_SUPPORTED
#define PNG_WRITE_tRNS_SUPPORTED
#define PNG_WRITE_zTXt_SUPPORTED
#define PNG_bKGD_SUPPORTED
#define PNG_cHRM_SUPPORTED
#define PNG_gAMA_SUPPORTED
#define PNG_hIST_SUPPORTED
#define PNG_iCCP_SUPPORTED
#define PNG_iTXt_SUPPORTED
#define PNG_oFFs_SUPPORTED
#define PNG_pCAL_SUPPORTED
#define PNG_pHYs_SUPPORTED
#define PNG_sBIT_SUPPORTED
#define PNG_sCAL_SUPPORTED
#define PNG_sPLT_SUPPORTED
#define PNG_sRGB_SUPPORTED
#define PNG_tEXt_SUPPORTED
#define PNG_tIME_SUPPORTED
#define PNG_tRNS_SUPPORTED
#define PNG_zTXt_SUPPORTED
/* end of options */
/* settings */
#define PNG_API_RULE 0
#define PNG_DEFAULT_READ_MACROS 1
#define PNG_GAMMA_THRESHOLD_FIXED 5000
#define PNG_IDAT_READ_SIZE PNG_ZBUF_SIZE
#define PNG_INFLATE_BUF_SIZE 1024
#define PNG_LINKAGE_API extern
#define PNG_LINKAGE_CALLBACK extern
#define PNG_LINKAGE_DATA extern
#define PNG_LINKAGE_FUNCTION extern
#define PNG_MAX_GAMMA_8 11
#define PNG_QUANTIZE_BLUE_BITS 5
#define PNG_QUANTIZE_GREEN_BITS 5
#define PNG_QUANTIZE_RED_BITS 5
#define PNG_TEXT_Z_DEFAULT_COMPRESSION (-1)
#define PNG_TEXT_Z_DEFAULT_STRATEGY 0
#define PNG_USER_CHUNK_CACHE_MAX 1000
#define PNG_USER_CHUNK_MALLOC_MAX 8000000
#define PNG_USER_HEIGHT_MAX 1000000
#define PNG_USER_WIDTH_MAX 1000000
#define PNG_ZBUF_SIZE 8192
#define PNG_ZLIB_VERNUM 0 /* unknown */
#define PNG_Z_DEFAULT_COMPRESSION (-1)
#define PNG_Z_DEFAULT_NOFILTER_STRATEGY 0
#define PNG_Z_DEFAULT_STRATEGY 1
#define PNG_sCAL_PRECISION 5
#define PNG_sRGB_PROFILE_CHECKS 2
/* end of settings */
#endif /* PNGLCONF_H */

```

`Engine/Toolkit/HeaderUtils/ArrayRange.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-2-1
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */


#ifndef ARRAY_RANGE_H
#define ARRAY_RANGE_H


/**
 * The range [start, end] marked in array.
 */
typedef struct
{
    /**
     * Start index in array.
     */
    int start;

    /**
     * End index in array, so the range length is (end - start + 1).
     */
    int end;
}
ArrayRange;


#endif

```

`Engine/Toolkit/HeaderUtils/Bitwise.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-3-14
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#ifndef BITWISE_H
#define BITWISE_H


/*
The biteState is usually an expression,
but the inline function cannot use expression for bitState,
so if not use macro we need pass the third parameter that is the bitState owner.
*/



/**
 * Add bits into biteState.
 */
#define ABitwise_Add(bitState, bits)   \
    ((bitState)  |= (bits))


/**
 * Set biteState bits.
 */
#define ABitwise_Set(bitState, bits)   \
    ((bitState)   = (bits))


/**
 * Clear bits from bitState.
 */
#define ABitwise_Clear(bitState, bits) \
    ((bitState)  &= ~(bits))

/**
 * Check biteState whether has bites.
 */
#define ABitwise_Check(bitState, bits) \
    (((bitState) & (bits)) != 0)


/**
 * Clear clearBits from bitState, and add addBits into biteState.
 */
#define ABitwise_ClearAndAdd(bitState, clearBits, addBits) \
    ((bitState)  = ((bitState) & ~(clearBits)) | (addBits))


/**
 * Reset bitState to 0.
 */
#define ABitwise_ClearAll(bitState) \
    ((bitState)  = 0)


#endif

```

`Engine/Toolkit/HeaderUtils/Define.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-10-2
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#ifndef DEFINE_H
#define DEFINE_H


/**
 * The pointer point to NULL.
 */
#define NULL_PTR (void*[1]) {NULL}


#endif

```

`Engine/Toolkit/HeaderUtils/Rect.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-2-1
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#ifndef RECT_H
#define RECT_H


#include <stdbool.h>


/**
 * A rectangle made up of two diagonal vertices,
 * and which are top-left and bottom-right.
 */
typedef struct
{
    float left;
    float top;
    float right;
    float bottom;
}
Rect;


/**
 * Test whether one point inside rect.
 */
static inline bool ARect_TestPoint(Rect* rect, float x, float y)
{
    return (x >= rect->left && x <= rect->right && y >= rect->bottom && y <= rect->top);
}


/**
 * Test whether one rect intersects another rect.
 */
static inline bool ARect_TestRect(Rect* rectA, Rect* rectB)
{
    return !(
                rectA->right  < rectB->left   ||
                rectA->left   > rectB->right  ||
                rectA->top    < rectB->bottom ||
                rectA->bottom > rectB->top
            );
}


#endif

```

`Engine/Toolkit/HeaderUtils/String.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-6-16
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */


#ifndef STRING_H
#define STRING_H


/**
 * Make str to string.
 */
#define AString_Make(str) #str


#endif

```

`Engine/Toolkit/HeaderUtils/Struct.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-12-22
 * Update   : 2018-1-8
 * Author   : scott.cgi
 */

 
#ifndef STRUCT_H
#define STRUCT_H


#include <stddef.h>

/*
 Examples:
     struct Parent
     {
         int  arr[1];
         int  value;
         int* ptr;
     }

     Parent parent[1];

     output true:
     AStruct_GetParentWithName(parent->arr,    Parent, arr)   == parent
     AStruct_GetParentWithName(&parent->arr,   Parent, arr)   == parent
     AStruct_GetParentWithName(&parent->value, Parent, value) == parent
     AStruct_GetParentWithName(&parent->ptr,   Parent, ptr)   == parent

     arr      = parent->arr
     value    = parent->value
     ptr      = parent->ptr
     valuePtr = &parent->value
     ptrPtr   = &parent->ptr

     output true:
     AStruct_GetParent(arr,      Parent) == parent
     AStruct_GetParent(&arr,     Parent) == parent
     AStruct_GetParent(valuePtr, Parent) == parent
     AStruct_GetParent(ptrPtr,   Parent) == parent

     output false:
     AStruct_GetParent(value,    Parent) == parent
     AStruct_GetParent(ptr,      Parent) == parent
     AStruct_GetParent(&value,   Parent) == parent
     AStruct_GetParent(&ptr,     Parent) == parent
*/


/**
 * Get struct pointer from member pointer.
 * this for memberPtr same as memberName.
 * 
 * memberPtr: the pointer that point struct's member.
 *            it's the member address offset from struct address.
 * 
 */
#define AStruct_GetParent(memberPtr, ParentType) \
    ((ParentType*) ((char*) (memberPtr) - offsetof(ParentType, memberPtr)))


/**
 * Get struct pointer from member pointer with memberName.
 * this for memberPtr not same as memberName.
 *
 * memberPtr: the pointer that point struct's member.
 *            it's the member address offset from struct address.
 */
#define AStruct_GetParentWithName(memberPtr, ParentType, memberName) \
    ((ParentType*) ((char*) (memberPtr) - offsetof(ParentType, memberName)))


#endif

```

`Engine/Toolkit/HeaderUtils/UserData.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-4-21
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#ifndef USER_DATA_H
#define USER_DATA_H


#include <stddef.h>


/**
 * A data slot in UserData that can stores one type of data in different types.
 */
typedef union
{
    int   intValue;
    float floatValue;
    void* ptrValue;
    char* stringValue;
}
UserDataSlot;


/**
 * Store user custom data in UserDataSlot array.
 */
typedef struct
{
    UserDataSlot slots[4];
}
UserData;


/**
 * Init UserData all slot data.
 */
static inline void AUserData_Init(UserData* userData)
{
    userData->slots[0].ptrValue = NULL;
    userData->slots[1].ptrValue = NULL;
    userData->slots[2].ptrValue = NULL;
    userData->slots[3].ptrValue = NULL;
}


/**
 * Set int value of UserData slot at slotIndex.
 */
static inline void AUserData_SetSlotInt(UserData* userData, int slotIndex, int value)
{
    userData->slots[slotIndex].intValue = value;
}


/**
 * Add int value of UserData slot at slotIndex.
 */
static inline void AUserData_AddSlotInt(UserData* userData, int slotIndex, int value)
{
    userData->slots[slotIndex].intValue += value;
}


/**
 * Set float value of UserData slot at slotIndex.
 */
static inline void AUserData_SetSlotFloat(UserData* userData, int slotIndex, float value)
{
    userData->slots[slotIndex].floatValue = value;
}


/**
 * Add float value of UserData slot at slotIndex.
 */
static inline void AUserData_AddSlotFloat(UserData* userData, int slotIndex, float value)
{
    userData->slots[slotIndex].floatValue += value;
}


/**
 * Set ptr value of UserData slot at slotIndex.
 */
static inline void AUserData_SetSlotPtr(UserData* userData, int slotIndex, void* value)
{
    userData->slots[slotIndex].ptrValue = value;
}


/**
 * Set string value of UserData slot at slotIndex.
 */
static inline void AUserData_SetSlotString(UserData* userData, int slotIndex, char* value)
{
    userData->slots[slotIndex].stringValue = value;
}


/**
 * Get int value of UserData slot at slotIndex.
 */
static inline int AUserData_GetSlotInt(UserData* userData, int slotIndex)
{
    return userData->slots[slotIndex].intValue;
}


/**
 * Get float value of UserData slot at slotIndex.
 */
static inline float AUserData_GetSlotFloat(UserData* userData, int slotIndex)
{
    return userData->slots[slotIndex].floatValue;
}


/**
 * Get ptr value of UserData slot at slotIndex.
 */
static inline void* AUserData_GetSlotPtr(UserData* userData, int slotIndex)
{
    return userData->slots[slotIndex].ptrValue;
}


/**
 * Get string value of UserData slot at slotIndex.
 */
static inline char* AUserData_GetSlotString(UserData* userData, int slotIndex)
{
    return userData->slots[slotIndex].stringValue;
}


/**
 * Get ptr value of UserData slot at slotIndex with PtrType.
 */
#define AUserData_GetSlotPtrWithType(userData, slotIndex, PtrType) \
    ((PtrType) (userData)->slots[slotIndex].ptrValue)

#endif

```

`Engine/Toolkit/Math/Math.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-24
 * Update   : 2019-1-18
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Toolkit/Math/Math.h"


/**
 * Test polygon contains 2D point(x, y).
 *
 * first  — foreach vector(preX - curX, preY - curY) of polygon
 * second — check the point's y on the y area of vector
 * third  — cross product between vector(x - curX, y - curY) and vector(preX - curX, preY - curY)
 * fourth — get the result is (x - curX) * (preY - curY) - (y - curY) * (preX - curX) = 0
 * then   —
 * 
 * if result zero     means point on the vector
 * if result positive means point on the right of vector
 * if result negative means point on the left  of vector
 */
#define TestPolygonXY(polygon, x, y, pointOnRight, pointOnLeft)                     \
    float* points   = polygon->data;                                                \
    int    preIndex = polygon->length - 2;                                          \
                                                                                    \
    for (int i = 0; i < polygon->length; i += 2)                                    \
    {                                                                               \
        float curY  = points[i        + 1];                                         \
        float preY  = points[preIndex + 1];                                         \
                                                                                    \
        if ((curY < y && preY >= y) || (preY < y && curY >= y))                     \
        {                                                                           \
            float curX = points[i];                                                 \
                                                                                    \
            if (curX + (y - curY) / (preY - curY) * (points[preIndex] - curX) <= x) \
            {                                                                       \
                pointOnRight;                                                       \
            }                                                                       \
            else                                                                    \
            {                                                                       \
                pointOnLeft;                                                        \
            }                                                                       \
        }                                                                           \
                                                                                    \
        preIndex = i;                                                               \
    }                                                                               \




static bool TestPolygonPoint(Array(float)* polygon, float x, float y)
{
    bool inside = false;

    TestPolygonXY
    (
        polygon,
        x,
        y,
        // point on the right of polygon vector
        inside = !inside,
    );

    return inside;
}


static bool TestPolygonAB(Array(float)* polygonA, Array(float)* polygonB)
{
    bool inside = false;
    
    for (int i = 0; i < polygonA->length; i += 2)
    {
        float x = AArray_Get(polygonA, i,     float);
        float y = AArray_Get(polygonA, i + 1, float);

        TestPolygonXY
        (
            polygonB,
            x,
            y,
            // point on the right of polygon vector
            inside = !inside,
        );

        if (inside)
        {
            return true;
        }
    }

    return inside;
}


static bool TestPolygonPolygon(Array(float)* polygonA, Array(float)* polygonB)
{
    return TestPolygonAB(polygonA, polygonB) || TestPolygonAB(polygonB, polygonA);
}


static bool TestPolygonABStrict(Array(float)* polygonA, Array(float)* polygonB)
{
    int leftCount  = 0;
    int rightCount = 0;

    for (int i = 0; i < polygonA->length; i += 2)
    {
        float x = AArray_Get(polygonA, i,     float);
        float y = AArray_Get(polygonA, i + 1, float);

        TestPolygonXY
        (
            polygonB,
            x,
            y,
            // count point on the right of polygon vector
            ++rightCount,
            // count point on the left  of polygon vector
            ++leftCount
        );

        if (rightCount % 2 != 0)
        {
            return true;
        }
    }

    return rightCount != 0 && leftCount == rightCount;
}


static bool TestPolygonPolygonStrict(Array(float)* polygonA, Array(float)* polygonB)
{
    return TestPolygonABStrict(polygonA, polygonB) || TestPolygonABStrict(polygonB, polygonA);
}


static bool TestLineAB(Array(float)* lineA, Array(float)* lineB)
{
    bool flags[2]  = {false, false};

    for (int i = 0; i < lineA->length; i += 2)
    {
        float x = AArray_Get(lineA, i,     float);
        float y = AArray_Get(lineA, i + 1, float);

        TestPolygonXY
        (
            lineB,
            x,
            y,
            // flag point on the right of line vector
            flags[(unsigned int) i >> 1] = true,
            // flag point on the left  of line vector
            flags[(unsigned int) i >> 1] = true
        );
    }

    // test lineA two points both sides of lineB
    return flags[0] && flags[1];
}


static bool TestLineLine(Array(float)* lineA, Array(float)* lineB)
{
    return TestLineAB(lineA, lineB) || TestLineAB(lineB, lineA);
}


static void RotatePoints(Array(float)* pointArr, float angle, Array(float)* outRotatedPointArr)
{
    ALog_A
    (
        outRotatedPointArr->length >= pointArr->length,
        "AMath RotatePoints2 outRotatedPointArr length must larger than pointArr."
    );

    float  cos  = AMath_Cos(angle);
    float  sin  = AMath_Sin(angle);
    float* arr1 = (float*) pointArr->data;
    float* arr2 = (float*) outRotatedPointArr->data;

    for (int i = 0; i < pointArr->length; i += 2)
    {
        float x = arr1[i];
        float y = arr1[i + 1];

        arr2[i]     = x * cos - y * sin;
        arr2[i + 1] = x * sin + y * cos;
    }
}


struct AMath AMath[1] =
{{
    TestPolygonPoint,
    TestPolygonAB,
    TestPolygonPolygon,
    TestPolygonABStrict,
    TestPolygonPolygonStrict,
    TestLineAB,
    TestLineLine,
    RotatePoints,
}};

```

`Engine/Toolkit/Math/Math.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-24
 * Update   : 2019-1-18
 * Author   : scott.cgi
 */


#ifndef MATH_H
#define MATH_H


#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <float.h>
#include <stdbool.h>

#include "Engine/Toolkit/Utils/Array.h"
#include "Engine/Toolkit/Platform/Log.h"


struct AMath
{
    /**
     * Test polygon contains 2D point.
     * one point of polygon contains pair of x, y.
     *
     * return true inside or false outside.
     */
    bool  (*TestPolygonPoint)     (Array(float)* polygon, float x, float y);

    /**
     * Test polygonA intersects polygonB.
     *
     * not test polygonB intersects polygonA.
     * not test through and cross each others.
     *
     * return true inside or false outside.
     */
    bool (*TestPolygonAB)          (Array(float)* polygonA, Array(float)* polygonB);

    /**
     * Test polygonA and polygonB intersect each others.
     * not test through and cross each others.
     *
     * return true inside or false outside.
     */
    bool (*TestPolygonPolygon)     (Array(float)* polygonA, Array(float)* polygonB);

    /**
     * Test polygonA intersects polygonB.
     *
     * not test polygonB intersects polygonA.
     * can test through and cross each others.
     *
     * return true inside or false outside.
     */
    bool (*TestPolygonABStrict)    (Array(float)* polygonA, Array(float)* polygonB);

    /**
     * Test polygonA and polygonB intersect each others.
     * can test through and cross each others.
     *
     * return true inside or false outside.
     */
    bool (*TestPolygonPolygonStrict)(Array(float)* polygonA, Array(float)* polygonB);

    /**
     * Test lineA intersects lineB.
     * not test lineB intersects lineA.
     *
     * return true inside or false outside.
     */
    bool (*TestLineAB)              (Array(float)* lineA, Array(float)* lineB);

    /**
     * Test lineA and lineB intersect each others.
     *
     * return true inside or false outside.
     */
    bool (*TestLineLine)            (Array(float)* lineA, Array(float)* lineB);

    /**
     * Rotate 2D points by angle.
     * one point of pointArr contains pair of x, y.
     */
    void  (*RotatePoints)           (Array(float)* pointArr, float angle, Array(float)* outRotatedPointArr);
};


extern struct AMath AMath[1];


//----------------------------------------------------------------------------------------------------------------------


#define GOLDEN_RATIO      0.618033988749894f


/**
 * The value of (PI / 180.0f).
 */
#define DEGREE_TO_RADIAN  0.017453292519943f


/**
 * The value of (PI / 360.0f).
 */
#define DEGREE_TO_RADIAN2 0.008726646259972f


/**
 * The value of (180.0f / PI).
 */
#define RADIAN_TO_DEGREE  57.29577951308232f


#define MATH_PI           3.141592653589793f


/**
 * The value of (2 * PI).
 */
#define MATH_2PI          6.283185307179586f


/**
 * The value of (PI / 2).
 */
#define MATH_PI2          1.570796326794897f


//----------------------------------------------------------------------------------------------------------------------


/**
 * Random float in range [0.0, 1.0].
 */
static inline float AMath_Random()
{
    return (float) (rand() / (double) RAND_MAX);
}


/**
 * Random integer in range [from, to].
 */
static inline int AMath_RandomInt(int from, int to)
{
    return (from) + rand() % ((to) - (from) + 1);
}


/**
 * Random float in range [from, to].
 */
static inline float AMath_RandomFloat(float from, float to)
{
    return from + AMath_Random() * ((to) - (from));
}


/**
 * Random seed by system time.
 */
static inline void AMath_RandomSeedByTime()
{
    srand((unsigned) time(NULL));
}


/**
 * Convert degree to radian.
 */
static inline float AMath_ToRadian(float degree)
{
    return degree * DEGREE_TO_RADIAN;
}


/**
 * Convert radian to degree.
 */
static inline float AMath_ToDegree(float radian)
{
    return radian * RADIAN_TO_DEGREE;
}


/**
 * Cos by degree.
 */
static inline float AMath_Cos(float degree)
{
    return cosf(AMath_ToRadian(degree));
}


/**
 * Sin by degree.
 */
static inline float AMath_Sin(float degree)
{
    return sinf(AMath_ToRadian(degree));
}


/**
 * Degree by atan2.
 */
static inline float AMath_Atan2(float x, float y)
{
    return AMath_ToDegree(atan2f(y, x));
}


/**
 * Degree by acosf.
 */
static inline float AMath_Acos(float ratio)
{
    return AMath_ToDegree(acosf(ratio));
}


/**
 * Degree by asinf.
 */
static inline float AMath_Asin(float ratio)
{
    return AMath_ToDegree(asinf(ratio));
}


/**
 * Compare float value equals.
 */
static inline bool AMath_IsFloatEqual(float x, float y)
{
    return fabsf((x) - (y)) <= FLT_EPSILON;
}


/**
 * Fast square inverse root float.
 */
static inline float AMath_InvSqrtf(float x)
{
    union { float f; int i; } u = {x};

    u.i = 0x5f3759df - (u.i >> 1);

    return u.f * (1.5f - 0.5f * x * u.f * u.f);
}


/**
 * Fast square root float.
 * equals AMath_InvSqrtf(x) * x.
 */
static inline float AMath_Sqrtf(float x)
{
    union { float f; int i; } u = {x};

    u.i = 0x5f3759df - (u.i >> 1);
    x  *= u.f; // reduce one multiplication and increase one assignment

    return x * (1.5f - 0.5f * x * u.f);
}


/**
 * Min in x and y, macro can use generic parameter.
 */
#define AMath_Min(x, y) \
    (((x) < (y)) ? (x) : (y))


/**
 * Max in a and b, macro can use generic parameter.
 */
#define AMath_Max(x, y) \
    (((x) > (y)) ? (x) : (y))


/**
 * Clamp x in min and max, macro can use generic parameter.
 */
#define AMath_Clamp(x, min, max) \
    (AMath_Min((max), AMath_Max((x), (min))))


#endif
```

`Engine/Toolkit/Math/Matrix.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-6
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#include <math.h>
#include "Engine/Toolkit/Math/Matrix.h"
#include "Engine/Toolkit/Platform/Log.h"


/**
 * x: right   axis
 * y: up      axis
 * z: forward axis
 * t: translation
 * 
 * (m0  m1  m2 ) x m3   |  (m0  m1  m2 ) x m3
 * (m4  m5  m6 ) y m7   |  (m4  m5  m6 ) y m7
 * (m8  m9  m10) z m11  |  (m8  m9  m10) z m11
 * (m12 m13 m14) t m15  |  (m12 m13 m14) t m15
 *
 * M-cr      = L-column         * R-row
 * M-00 (m0) = L-column[0]-048  * R-row[0]-012
 * M-10 (m1) = L-column[1]-159  * R-row[0]-012
 * M-20 (m2) = L-column[2]-2610 * R-row[0]-012
 */
static void MultiplyMM(Matrix4* left, Matrix4* right, Matrix4* outMatrix4)
{
    outMatrix4->m0  = left->m0 * right->m0  + left->m4 * right->m1  + left->m8  * right->m2  + left->m12 * right->m3;
    outMatrix4->m1  = left->m1 * right->m0  + left->m5 * right->m1  + left->m9  * right->m2  + left->m13 * right->m3;
    outMatrix4->m2  = left->m2 * right->m0  + left->m6 * right->m1  + left->m10 * right->m2  + left->m14 * right->m3;
    outMatrix4->m3  = left->m3 * right->m0  + left->m7 * right->m1  + left->m11 * right->m2  + left->m15 * right->m3;

    outMatrix4->m4  = left->m0 * right->m4  + left->m4 * right->m5  + left->m8  * right->m6  + left->m12 * right->m7;
    outMatrix4->m5  = left->m1 * right->m4  + left->m5 * right->m5  + left->m9  * right->m6  + left->m13 * right->m7;
    outMatrix4->m6  = left->m2 * right->m4  + left->m6 * right->m5  + left->m10 * right->m6  + left->m14 * right->m7;
    outMatrix4->m7  = left->m3 * right->m4  + left->m7 * right->m5  + left->m11 * right->m6  + left->m15 * right->m7;

    outMatrix4->m8  = left->m0 * right->m8  + left->m4 * right->m9  + left->m8  * right->m10 + left->m12 * right->m11;
    outMatrix4->m9  = left->m1 * right->m8  + left->m5 * right->m9  + left->m9  * right->m10 + left->m13 * right->m11;
    outMatrix4->m10 = left->m2 * right->m8  + left->m6 * right->m9  + left->m10 * right->m10 + left->m14 * right->m11;
    outMatrix4->m11 = left->m3 * right->m8  + left->m7 * right->m9  + left->m11 * right->m10 + left->m15 * right->m11;

    outMatrix4->m12 = left->m0 * right->m12 + left->m4 * right->m13 + left->m8  * right->m14 + left->m12 * right->m15;
    outMatrix4->m13 = left->m1 * right->m12 + left->m5 * right->m13 + left->m9  * right->m14 + left->m13 * right->m15;
    outMatrix4->m14 = left->m2 * right->m12 + left->m6 * right->m13 + left->m10 * right->m14 + left->m14 * right->m15;
    outMatrix4->m15 = left->m3 * right->m12 + left->m7 * right->m13 + left->m11 * right->m14 + left->m15 * right->m15;
}


static void MultiplyMMM(Matrix4* m1, Matrix4* m2, Matrix4* m3, Matrix4* outM23, Matrix4* outM231)
{
    outM23->m0   = m2->m0 * m3->m0  + m2->m4 * m3->m1  + m2->m8  * m3->m2  + m2->m12 * m3->m3;
    outM23->m1   = m2->m1 * m3->m0  + m2->m5 * m3->m1  + m2->m9  * m3->m2  + m2->m13 * m3->m3;
    outM23->m2   = m2->m2 * m3->m0  + m2->m6 * m3->m1  + m2->m10 * m3->m2  + m2->m14 * m3->m3;
    outM23->m3   = m2->m3 * m3->m0  + m2->m7 * m3->m1  + m2->m11 * m3->m2  + m2->m15 * m3->m3;

    outM23->m4   = m2->m0 * m3->m4  + m2->m4 * m3->m5  + m2->m8  * m3->m6  + m2->m12 * m3->m7;
    outM23->m5   = m2->m1 * m3->m4  + m2->m5 * m3->m5  + m2->m9  * m3->m6  + m2->m13 * m3->m7;
    outM23->m6   = m2->m2 * m3->m4  + m2->m6 * m3->m5  + m2->m10 * m3->m6  + m2->m14 * m3->m7;
    outM23->m7   = m2->m3 * m3->m4  + m2->m7 * m3->m5  + m2->m11 * m3->m6  + m2->m15 * m3->m7;

    outM23->m8   = m2->m0 * m3->m8  + m2->m4 * m3->m9  + m2->m8  * m3->m10 + m2->m12 * m3->m11;
    outM23->m9   = m2->m1 * m3->m8  + m2->m5 * m3->m9  + m2->m9  * m3->m10 + m2->m13 * m3->m11;
    outM23->m10  = m2->m2 * m3->m8  + m2->m6 * m3->m9  + m2->m10 * m3->m10 + m2->m14 * m3->m11;
    outM23->m11  = m2->m3 * m3->m8  + m2->m7 * m3->m9  + m2->m11 * m3->m10 + m2->m15 * m3->m11;

    outM23->m12  = m2->m0 * m3->m12 + m2->m4 * m3->m13 + m2->m8  * m3->m14 + m2->m12 * m3->m15;
    outM23->m13  = m2->m1 * m3->m12 + m2->m5 * m3->m13 + m2->m9  * m3->m14 + m2->m13 * m3->m15;
    outM23->m14  = m2->m2 * m3->m12 + m2->m6 * m3->m13 + m2->m10 * m3->m14 + m2->m14 * m3->m15;
    outM23->m15  = m2->m3 * m3->m12 + m2->m7 * m3->m13 + m2->m11 * m3->m14 + m2->m15 * m3->m15;

//----------------------------------------------------------------------------------------------------------------------

    outM231->m0  = m1->m0 * outM23->m0  + m1->m4 * outM23->m1  + m1->m8  * outM23->m2  + m1->m12 * outM23->m3;
    outM231->m1  = m1->m1 * outM23->m0  + m1->m5 * outM23->m1  + m1->m9  * outM23->m2  + m1->m13 * outM23->m3;
    outM231->m2  = m1->m2 * outM23->m0  + m1->m6 * outM23->m1  + m1->m10 * outM23->m2  + m1->m14 * outM23->m3;
    outM231->m3  = m1->m3 * outM23->m0  + m1->m7 * outM23->m1  + m1->m11 * outM23->m2  + m1->m15 * outM23->m3;

    outM231->m4  = m1->m0 * outM23->m4  + m1->m4 * outM23->m5  + m1->m8  * outM23->m6  + m1->m12 * outM23->m7;
    outM231->m5  = m1->m1 * outM23->m4  + m1->m5 * outM23->m5  + m1->m9  * outM23->m6  + m1->m13 * outM23->m7;
    outM231->m6  = m1->m2 * outM23->m4  + m1->m6 * outM23->m5  + m1->m10 * outM23->m6  + m1->m14 * outM23->m7;
    outM231->m7  = m1->m3 * outM23->m4  + m1->m7 * outM23->m5  + m1->m11 * outM23->m6  + m1->m15 * outM23->m7;

    outM231->m8  = m1->m0 * outM23->m8  + m1->m4 * outM23->m9  + m1->m8  * outM23->m10 + m1->m12 * outM23->m11;
    outM231->m9  = m1->m1 * outM23->m8  + m1->m5 * outM23->m9  + m1->m9  * outM23->m10 + m1->m13 * outM23->m11;
    outM231->m10 = m1->m2 * outM23->m8  + m1->m6 * outM23->m9  + m1->m10 * outM23->m10 + m1->m14 * outM23->m11;
    outM231->m11 = m1->m3 * outM23->m8  + m1->m7 * outM23->m9  + m1->m11 * outM23->m10 + m1->m15 * outM23->m11;

    outM231->m12 = m1->m0 * outM23->m12 + m1->m4 * outM23->m13 + m1->m8  * outM23->m14 + m1->m12 * outM23->m15;
    outM231->m13 = m1->m1 * outM23->m12 + m1->m5 * outM23->m13 + m1->m9  * outM23->m14 + m1->m13 * outM23->m15;
    outM231->m14 = m1->m2 * outM23->m12 + m1->m6 * outM23->m13 + m1->m10 * outM23->m14 + m1->m14 * outM23->m15;
    outM231->m15 = m1->m3 * outM23->m12 + m1->m7 * outM23->m13 + m1->m11 * outM23->m14 + m1->m15 * outM23->m15;
}


/**
 * x: right   axis
 * y: up      axis
 * z: forward axis
 * t: translation
 *
 * (m0  m1  m2 ) x m3  w  |  (x y z) w
 * (m4  m5  m6 ) y m7  w  |
 * (m8  m9  m10) z m11 w  |
 * (m12 m13 m14) t m15 w  |
 *
 * V-c[xyz]r[0] = L-column * V-row
 */
static void MultiplyMV4(Matrix4* matrix4, float x, float y, float z, float w, Vector4* outVector4)
{
    outVector4->x = matrix4->m0 * x + matrix4->m4 * y + matrix4->m8  * z + matrix4->m12 * w;
    outVector4->y = matrix4->m1 * x + matrix4->m5 * y + matrix4->m9  * z + matrix4->m13 * w;
    outVector4->z = matrix4->m2 * x + matrix4->m6 * y + matrix4->m10 * z + matrix4->m14 * w;
    outVector4->w = matrix4->m3 * x + matrix4->m7 * y + matrix4->m11 * z + matrix4->m15 * w;
}


static void multiplyMV3(Matrix4* matrix4, float x, float y, float z, Vector3* outVector3)
{
    outVector3->x = matrix4->m0 * x + matrix4->m4 * y + matrix4->m8  * z + matrix4->m12;
    outVector3->y = matrix4->m1 * x + matrix4->m5 * y + matrix4->m9  * z + matrix4->m13;
    outVector3->z = matrix4->m2 * x + matrix4->m6 * y + matrix4->m10 * z + matrix4->m14;
}


static void MultiplyMV2(Matrix4* matrix4, float x, float y, Vector2* outVector2)
{
    outVector2->x = matrix4->m0 * x + matrix4->m4 * y + matrix4->m12;
    outVector2->y = matrix4->m1 * x + matrix4->m5 * y + matrix4->m13;
}


static float MultiplyMX(Matrix4* matrix4, float x)
{
    return matrix4->m0 * x + matrix4->m12;
}


static float MultiplyMY(Matrix4* matrix4, float y)
{
    return matrix4->m5 * y + matrix4->m13;
}


static float MultiplyMZ(Matrix4* matrix4, float z)
{
   return matrix4->m10 * z + matrix4->m14;
}


/**
 * x: right   axis
 * y: up      axis
 * z: forward axis
 * t: translation
 *
 * (m0  m1  m2 ) x m3  w  |  (x y z)
 * (m4  m5  m6 ) y m7  w  |
 * (m8  m9  m10) z m11 w  |
 * (m12 m13 m14) t m15 w  |
 */
static void Translate(Matrix4* matrix4, float x, float y, float z)
{
    matrix4->m12 += matrix4->m0 * x + matrix4->m4 * y + matrix4->m8  * z;
    matrix4->m13 += matrix4->m1 * x + matrix4->m5 * y + matrix4->m9  * z;
    matrix4->m14 += matrix4->m2 * x + matrix4->m6 * y + matrix4->m10 * z;
}


/**
 * Rotate identity matrix4 and multiply matrix4.
 *
 * s = sin angle
 * c = cos angle
 * n = 1 - c
 *
 * (m0  m1  m2 ) x m3  w  |  xxn + c   xyn + zs  zxn − ys 0
 * (m4  m5  m6 ) y m7  w  |  xyn - zs  yyn + c   yzn + xs 0
 * (m8  m9  m10) z m11 w  |  zxn + ys  yzn - xs  zzn + c  0
 * (m12 m13 m14) t m15 w  |  0         0         0        1
 * 
 */
static void Rotate(Matrix4* matrix4, float angle, float x, float y, float z)
{
    angle     = AMath_ToRadian(angle);
    float s   = sinf(angle);
    float c   = cosf(angle);
    float len = AVector3_Length3(x, y, z);

    if (len  != 1.0f)
    {
        // reciprocal length
        float recipLen = 1.0f / len;
        x             *= recipLen;
        y             *= recipLen;
        z             *= recipLen;
    }

    float nc = 1.0f - c;
    float xy = x * y;
    float yz = y * z;
    float zx = z * x;
    float xs = x * s;
    float ys = y * s;
    float zs = z * s;

/*
    Matrix4 temp1[1] =
    {{
        // right x axis
        x  * x  * nc + c,
        xy * nc + zs,
        zx * nc - ys,
        0.0f,

        // up y axis
        xy * nc - zs,
        y  * y  * nc + c,
        yz * nc + xs,
        0.0f,

        // forward z axis
        zx * nc + ys,
        yz * nc - xs,
        z  * z  * nc + c,
        0.0f,

        // translation
        0.0f, 0.0f, 0.0f, 1.0f,
    }};

    Matrix4 temp2[1];
    MultiplyMM(matrix4, temp1, temp2);

    *matrix4 = *temp2; // memcpy(matrix->m, temp2->m, sizeof(Matrix4));
*/

    /* expand matrix multiplication */
    
    float rm0    = x  * x  * nc + c;
    float rm1    = xy * nc + zs;
    float rm2    = zx * nc - ys;

    float rm4    = xy * nc - zs;
    float rm5    = y  * y  * nc + c;
    float rm6    = yz * nc + xs;

    float rm8    = zx * nc + ys;
    float rm9    = yz * nc - xs;
    float rm10   = z  * z  * nc + c;

    float lm0    = matrix4->m0;
    float lm1    = matrix4->m1;
    float lm2    = matrix4->m2;
    float lm3    = matrix4->m3;

    float lm4    = matrix4->m4;
    float lm5    = matrix4->m5;
    float lm6    = matrix4->m6;
    float lm7    = matrix4->m7;

    float lm8    = matrix4->m8;
    float lm9    = matrix4->m9;
    float lm10   = matrix4->m10;
    float lm11   = matrix4->m11;

    matrix4->m0  = lm0 * rm0 + lm4 * rm1 + lm8  * rm2;
    matrix4->m1  = lm1 * rm0 + lm5 * rm1 + lm9  * rm2;
    matrix4->m2  = lm2 * rm0 + lm6 * rm1 + lm10 * rm2;
    matrix4->m3  = lm3 * rm0 + lm7 * rm1 + lm11 * rm2;

    matrix4->m4  = lm0 * rm4 + lm4 * rm5 + lm8  * rm6;
    matrix4->m5  = lm1 * rm4 + lm5 * rm5 + lm9  * rm6;
    matrix4->m6  = lm2 * rm4 + lm6 * rm5 + lm10 * rm6;
    matrix4->m7  = lm3 * rm4 + lm7 * rm5 + lm11 * rm6;

    matrix4->m8  = lm0 * rm8 + lm4 * rm9 + lm8  * rm10;
    matrix4->m9  = lm1 * rm8 + lm5 * rm9 + lm9  * rm10;
    matrix4->m10 = lm2 * rm8 + lm6 * rm9 + lm10 * rm10;
    matrix4->m11 = lm3 * rm8 + lm7 * rm9 + lm11 * rm10;
}


/**
 * x: right   axis
 * y: up      axis
 * z: forward axis
 * t: translation
 *
 * (m0  m1  m2 ) x m3   |  (1  0  0) x 0
 * (m4  m5  m6 ) y m7   |  (0  c  s) y 0
 * (m8  m9  m10) z m11  |  (0 -s  c) z 0
 * (m12 m13 m14) t m15  |  (0  0  0) t 1
 * 
 */
static void RotateX(Matrix4* matrix4, float angle)
{
    angle   = AMath_ToRadian(angle);
    float s = sinf(angle);
    float c = cosf(angle);

/*
    Matrix4 temp1[1] =
    {{
        1.0f, 0.0f, 0.0f, 0.0f,
        0.0f,    c,    s, 0.0f,
        0.0f,   -s,    c, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f,
    }};

    Matrix4 temp2[1];
    MultiplyMM(matrix4, temp1, temp2);

    *matrix4 = *temp2; // memcpy(matrix4->m, temp2->m, sizeof(Matrix4));
*/

    /* expand matrix multiplication */
    
    float m4     = matrix4->m4;
    float m5     = matrix4->m5;
    float m6     = matrix4->m6;
    float m7     = matrix4->m7;

    matrix4->m4  =  m4 *  c + matrix4->m8  * s;
    matrix4->m5  =  m5 *  c + matrix4->m9  * s;
    matrix4->m6  =  m6 *  c + matrix4->m10 * s;
    matrix4->m7  =  m7 *  c + matrix4->m11 * s;

    matrix4->m8  =  m4 * -s + matrix4->m8  * c;
    matrix4->m9  =  m5 * -s + matrix4->m9  * c;
    matrix4->m10 =  m6 * -s + matrix4->m10 * c;
    matrix4->m11 =  m7 * -s + matrix4->m11 * c;
}



/**
 * x: right   axis
 * y: up      axis
 * z: forward axis
 * t: translation
 *
 * (m0  m1  m2 ) x m3   |  (c  0 -s) x 0
 * (m4  m5  m6 ) y m7   |  (0  1  0) y 0
 * (m8  m9  m10) z m11  |  (s  0  c) z 0
 * (m12 m13 m14) t m15  |  (0  0  0) t 1
 */
static void RotateY(Matrix4* matrix4, float angle)
{
    angle   = AMath_ToRadian(angle);
    float s = sinf(angle);
    float c = cosf(angle);

/*
    Matrix4 temp1[1] =
    {{
           c, 0.0f,   -s, 0.0f,
        0.0f, 1.0f, 0.0f, 0.0f,
           s, 0.0f,    c, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f,
    }};

    Matrix4 temp2[1];
    MultiplyMM(matrix4, temp1, temp2);

    *matrix4 = *temp2; // memcpy(matrix4->m, temp2->m, sizeof(Matrix4));
*/

    /* expand matrix multiplication */

    float m0     = matrix4->m0;
    float m1     = matrix4->m1;
    float m2     = matrix4->m2;
    float m3     = matrix4->m3;

    matrix4->m0  = m0 * c + matrix4->m8  * -s;
    matrix4->m1  = m1 * c + matrix4->m9  * -s;
    matrix4->m2  = m2 * c + matrix4->m10 * -s;
    matrix4->m3  = m3 * c + matrix4->m11 * -s;

    matrix4->m8  = m0 * s + matrix4->m8  *  c;
    matrix4->m9  = m1 * s + matrix4->m9  *  c;
    matrix4->m10 = m2 * s + matrix4->m10 *  c;
    matrix4->m11 = m3 * s + matrix4->m11 *  c;
}


/**
 * x: right   axis
 * y: up      axis
 * z: forward axis
 * t: translation
 *
 * (m0  m1  m2 ) x m3   |  ( c  s  0) x 0
 * (m4  m5  m6 ) y m7   |  (-s  c  0) y 0
 * (m8  m9  m10) z m11  |  ( 0  0  1) z 0
 * (m12 m13 m14) t m15  |  ( 0  0  0) t 1
*/
static void RotateZ(Matrix4* matrix4, float angle)
{
    angle   = AMath_ToRadian(angle);
    float s = sinf(angle);
    float c = cosf(angle);

/*
    Matrix4 temp1[1] =
    {{
           c,    s, 0.0f, 0.0f,
          -s,    c, 0.0f, 0.0f,
        0.0f, 0.0f, 1.0f, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f,
    }};

    Matrix4 temp2[1];
    MultiplyMM(matrix4, temp1, temp2);

    *matrix4 = *temp2; // memcpy(matrix4->m, temp2->m, sizeof(Matrix4));
*/

    /* expand matrix multiplication */

    float m0    = matrix4->m0;
    float m1    = matrix4->m1;
    float m2    = matrix4->m2;
    float m3    = matrix4->m3;

    matrix4->m0 = m0 *  c + matrix4->m4 * s;
    matrix4->m1 = m1 *  c + matrix4->m5 * s;
    matrix4->m2 = m2 *  c + matrix4->m6 * s;
    matrix4->m3 = m3 *  c + matrix4->m7 * s;

    matrix4->m4 = m0 * -s + matrix4->m4 * c;
    matrix4->m5 = m1 * -s + matrix4->m5 * c;
    matrix4->m6 = m2 * -s + matrix4->m6 * c;
    matrix4->m7 = m3 * -s + matrix4->m7 * c;
}


/**
 * x: right   axis
 * y: up      axis
 * z: forward axis
 * t: translation
 *
 * (m0  m1  m2 ) x m3  w
 * (m4  m5  m6 ) y m7  w
 * (m8  m9  m10) z m11 w
 * (m12 m13 m14) t m15 w
 */
static void Scale(Matrix4* matrix4, float sx, float sy, float sz)
{
    matrix4->m0  *= sx;
    matrix4->m1  *= sx;
    matrix4->m2  *= sx;

    matrix4->m4  *= sy;
    matrix4->m5  *= sy;
    matrix4->m6  *= sy;

    matrix4->m8  *= sz;
    matrix4->m9  *= sz;
    matrix4->m10 *= sz;
}


static void Inverse(Matrix4* matrix4, Matrix4* outInverse)
{
    float a0 = matrix4->m0  * matrix4->m5  - matrix4->m1  * matrix4->m4;
    float a1 = matrix4->m0  * matrix4->m6  - matrix4->m2  * matrix4->m4;
    float a2 = matrix4->m0  * matrix4->m7  - matrix4->m3  * matrix4->m4;
    float a3 = matrix4->m1  * matrix4->m6  - matrix4->m2  * matrix4->m5;
    float a4 = matrix4->m1  * matrix4->m7  - matrix4->m3  * matrix4->m5;
    float a5 = matrix4->m2  * matrix4->m7  - matrix4->m3  * matrix4->m6;

    float b0 = matrix4->m8  * matrix4->m13 - matrix4->m9  * matrix4->m12;
    float b1 = matrix4->m8  * matrix4->m14 - matrix4->m10 * matrix4->m12;
    float b2 = matrix4->m8  * matrix4->m15 - matrix4->m11 * matrix4->m12;
    float b3 = matrix4->m9  * matrix4->m14 - matrix4->m10 * matrix4->m13;
    float b4 = matrix4->m9  * matrix4->m15 - matrix4->m11 * matrix4->m13;
    float b5 = matrix4->m10 * matrix4->m15 - matrix4->m11 * matrix4->m14;

/*
    // calculate the determinant
    float det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

    // close to zero, can't invert
    if (fabsf(det) < FLT_EPSILON)
    {
         return false;
    }

    float scalar = 1.0f / det;
*/

    float scalar = 1.0f / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

    // support the case where matrix == result

    outInverse->m0  = ( matrix4->m5  * b5 - matrix4->m6  * b4 + matrix4->m7  * b3) * scalar;
    outInverse->m1  = (-matrix4->m1  * b5 + matrix4->m2  * b4 - matrix4->m3  * b3) * scalar;
    outInverse->m2  = ( matrix4->m13 * a5 - matrix4->m14 * a4 + matrix4->m15 * a3) * scalar;
    outInverse->m3  = (-matrix4->m9  * a5 + matrix4->m10 * a4 - matrix4->m11 * a3) * scalar;

    outInverse->m4  = (-matrix4->m4  * b5 + matrix4->m6  * b2 - matrix4->m7  * b1) * scalar;
    outInverse->m5  = ( matrix4->m0  * b5 - matrix4->m2  * b2 + matrix4->m3  * b1) * scalar;
    outInverse->m6  = (-matrix4->m12 * a5 + matrix4->m14 * a2 - matrix4->m15 * a1) * scalar;
    outInverse->m7  = ( matrix4->m8  * a5 - matrix4->m10 * a2 + matrix4->m11 * a1) * scalar;

    outInverse->m8  = ( matrix4->m4  * b4 - matrix4->m5  * b2 + matrix4->m7  * b0) * scalar;
    outInverse->m9  = (-matrix4->m0  * b4 + matrix4->m1  * b2 - matrix4->m3  * b0) * scalar;
    outInverse->m10 = ( matrix4->m12 * a4 - matrix4->m13 * a2 + matrix4->m15 * a0) * scalar;
    outInverse->m11 = (-matrix4->m8  * a4 + matrix4->m9  * a2 - matrix4->m11 * a0) * scalar;

    outInverse->m12 = (-matrix4->m4  * b3 + matrix4->m5  * b1 - matrix4->m6  * b0) * scalar;
    outInverse->m13 = ( matrix4->m0  * b3 - matrix4->m1  * b1 + matrix4->m2  * b0) * scalar;
    outInverse->m14 = (-matrix4->m12 * a3 + matrix4->m13 * a1 - matrix4->m14 * a0) * scalar;
    outInverse->m15 = ( matrix4->m8  * a3 - matrix4->m9  * a1 + matrix4->m10 * a0) * scalar;

//  return true;
}


static void Transpose(Matrix4* matrix, Matrix4* outTranspose)
{
    *outTranspose = *AMatrix_Make
                     (
                         matrix->m0, matrix->m4, matrix->m8,  matrix->m12,
                         matrix->m1, matrix->m5, matrix->m9,  matrix->m13,
                         matrix->m2, matrix->m6, matrix->m10, matrix->m14,
                         matrix->m3, matrix->m7, matrix->m11, matrix->m15
                     );
}


/**
 * Transpose and inverse.
 */
static void InverseTranspose(Matrix4* matrix4, Matrix4* outInverseTranspose)
{
    float a0 = matrix4->m0  * matrix4->m5  - matrix4->m4  * matrix4->m1;
    float a1 = matrix4->m0  * matrix4->m9  - matrix4->m8  * matrix4->m1;
    float a2 = matrix4->m0  * matrix4->m13 - matrix4->m12 * matrix4->m1;
    float a3 = matrix4->m4  * matrix4->m9  - matrix4->m8  * matrix4->m5;
    float a4 = matrix4->m4  * matrix4->m13 - matrix4->m12 * matrix4->m5;
    float a5 = matrix4->m8  * matrix4->m13 - matrix4->m12 * matrix4->m9 ;

    float b0 = matrix4->m2  * matrix4->m7  - matrix4->m6  * matrix4->m3;
    float b1 = matrix4->m2  * matrix4->m11 - matrix4->m10 * matrix4->m3;
    float b2 = matrix4->m2  * matrix4->m15 - matrix4->m14 * matrix4->m3;
    float b3 = matrix4->m6  * matrix4->m11 - matrix4->m10 * matrix4->m7;
    float b4 = matrix4->m6  * matrix4->m15 - matrix4->m14 * matrix4->m7;
    float b5 = matrix4->m10 * matrix4->m15 - matrix4->m14 * matrix4->m11;

/*
    // calculate the determinant
    float det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;

    // close to zero, can't invert
    if (fabsf(det) < FLT_EPSILON)
    {
       return false;
    }

    float scalar = 1.0f / det;
*/

    float scalar = 1.0f / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);

    // support the case where matrix == result

    outInverseTranspose->m0  = ( matrix4->m5 * b5 - matrix4->m9  * b4 + matrix4->m13 * b3) * scalar;
    outInverseTranspose->m1  = (-matrix4->m4 * b5 + matrix4->m8  * b4 - matrix4->m12 * b3) * scalar;
    outInverseTranspose->m2  = ( matrix4->m7 * a5 - matrix4->m11 * a4 + matrix4->m15 * a3) * scalar;
    outInverseTranspose->m3  = (-matrix4->m6 * a5 + matrix4->m10 * a4 - matrix4->m14 * a3) * scalar;

    outInverseTranspose->m4  = (-matrix4->m1 * b5 + matrix4->m9  * b2 - matrix4->m13 * b1) * scalar;
    outInverseTranspose->m5  = ( matrix4->m0 * b5 - matrix4->m8  * b2 + matrix4->m12 * b1) * scalar;
    outInverseTranspose->m6  = (-matrix4->m3 * a5 + matrix4->m11 * a2 - matrix4->m15 * a1) * scalar;
    outInverseTranspose->m7  = ( matrix4->m2 * a5 - matrix4->m10 * a2 + matrix4->m14 * a1) * scalar;

    outInverseTranspose->m8  = ( matrix4->m1 * b4 - matrix4->m5  * b2 + matrix4->m13 * b0) * scalar;
    outInverseTranspose->m9  = (-matrix4->m0 * b4 + matrix4->m4  * b2 - matrix4->m12 * b0) * scalar;
    outInverseTranspose->m10 = ( matrix4->m3 * a4 - matrix4->m7  * a2 + matrix4->m15 * a0) * scalar;
    outInverseTranspose->m11 = (-matrix4->m2 * a4 + matrix4->m6  * a2 - matrix4->m14 * a0) * scalar;

    outInverseTranspose->m12 = (-matrix4->m1 * b3 + matrix4->m5  * b1 - matrix4->m9  * b0) * scalar;
    outInverseTranspose->m13 = ( matrix4->m0 * b3 - matrix4->m4  * b1 + matrix4->m8  * b0) * scalar;
    outInverseTranspose->m14 = (-matrix4->m3 * a3 + matrix4->m7  * a1 - matrix4->m11 * a0) * scalar;
    outInverseTranspose->m15 = ( matrix4->m2 * a3 - matrix4->m6  * a1 + matrix4->m10 * a0) * scalar;

//  return true;
}


static void Perspective(float fovy, float aspect, float near, float far, Matrix4* outProjection)
{
    ALog_A
    (
        far != near,
        "AMatrix Perspective failed, because far == near"
    );

    fovy               = 1.0f / tanf(fovy * DEGREE_TO_RADIAN2);
    float range        = 1.0f / (near - far);

    outProjection->m0  = fovy / aspect;
    outProjection->m1  = 0.0f;
    outProjection->m2  = 0.0f;
    outProjection->m3  = 0.0f;

    outProjection->m4  = 0.0f;
    outProjection->m5  = fovy;
    outProjection->m6  = 0.0f;
    outProjection->m7  = 0.0f;

    outProjection->m8  = 0.0f;
    outProjection->m9  = 0.0f;
    outProjection->m10 = (far + near) * range;
    outProjection->m11 = -1.0f;

    outProjection->m12 = 0.0f;
    outProjection->m13 = 0.0f;
    outProjection->m14 = 2.0f * far * near * range;
    outProjection->m15 = 0.0f;
}


static void Orthographic(float left, float right, float bottom, float top, float near, float far, Matrix4* outProjection)
{
    ALog_A
    (
        right != left && top != bottom && far != near,
        "AMatrix Orthographic failed, because right == left || top == bottom || far == near"
    );

    float width        = 1.0f / (right - left);
    float height       = 1.0f / (top   - bottom);
    float depth        = 1.0f / (far   - near);

    outProjection->m0  = 2.0f * width;  // x
    outProjection->m1  = 0.0f;
    outProjection->m2  = 0.0f;
    outProjection->m3  = 0.0f;

    outProjection->m4  = 0.0f;
    outProjection->m5  = 2.0f * height; // y
    outProjection->m6  = 0.0f;
    outProjection->m7  = 0.0f;

    outProjection->m8  = 0.0f;
    outProjection->m9  = 0.0f;
    outProjection->m10 = -2.0f * depth; // z
    outProjection->m11 = 0.0f;

    outProjection->m12 = -(right + left)   * width;  // tx
    outProjection->m13 = -(top   + bottom) * height; // ty
    outProjection->m14 = -(far   + near)   * depth;  // tz
    outProjection->m15 = 1.0f;
}


static void Frustum(float left, float right, float bottom, float top, float near, float far, Matrix4* outProjection)
{
    ALog_A
    (
        right != left && top != bottom && near != far && near > 0.0f && far > 0.0f,
        "AMatrix Frustum failed,"
        "because right == left || top == bottom || near == far || near <= 0.0f || far <= 0.0f"
    );

    float width        = 1.0f / (right - left);
    float height       = 1.0f / (top - bottom);
    float depth        = 1.0f / (near - far);

    outProjection->m0  = 2.0f * (near * width);  // x
    outProjection->m1  = 0.0f;
    outProjection->m2  = 0.0f;
    outProjection->m3  = 0.0f;

    outProjection->m4  = 0.0f;
    outProjection->m5  = 2.0f * (near * height); // y
    outProjection->m6  = 0.0f;
    outProjection->m7  = 0.0f;

    outProjection->m8  = 2.0f * ((right + left) * width); // A
    outProjection->m9  = (top + bottom) * height;         // B
    outProjection->m10 = (far + near)   * depth;          // C
    outProjection->m11 = -1.0f;

    outProjection->m12 = 0.0f;
    outProjection->m13 = 0.0f;
    outProjection->m14 = 2.0f * (far * near * depth);     // D
    outProjection->m15 = 0.0f;
}


static void LookAt
(
    float    eyeX,     float eyeY,    float eyeZ,
    float    centerX,  float centerY, float centerZ,
    float    upX,      float upY,     float upZ,
    Matrix4* outView
)
{

    // see the OpenGL GLUT documentation for gluLookAt for a description of the algorithm
    // we implement it in a straightforward way

    float fx   = centerX - eyeX;
    float fy   = centerY - eyeY;
    float fz   = centerZ - eyeZ;

    // normalize f
    float rlf  = AVector3_Normalize3(fx, fy, fz);
    fx        *= rlf;
    fy        *= rlf;
    fz        *= rlf;

    // compute s = f cross product up
    float sx  = fy * upZ - fz * upY;
    float sy  = fz * upX - fx * upZ;
    float sz  = fx * upY - fy * upX;

    // and normalize s
    float rls = AVector3_Normalize3(sx, sy, sz);
    sx       *= rls;
    sy       *= rls;
    sz       *= rls;

    // compute u = s cross product f
    float ux  = sy * fz - sz * fy;
    float uy  = sz * fx - sx * fz;
    float uz  = sx * fy - sy * fx;

    outView->m0  = sx;
    outView->m1  = ux;
    outView->m2  = -fx;
    outView->m3  = 0.0f;

    outView->m4  = sy;
    outView->m5  = uy;
    outView->m6  = -fy;
    outView->m7  = 0.0f;

    outView->m8  = sz;
    outView->m9  = uz;
    outView->m10 = -fz;
    outView->m11 = 0.0f;

    outView->m12 = 0.0f;
    outView->m13 = 0.0f;
    outView->m14 = 0.0f;
    outView->m15 = 1.0f;

    Translate(outView, -eyeX, -eyeY, -eyeZ);
}


struct AMatrix AMatrix[1] =
{{
    MultiplyMM,
    MultiplyMMM,
    MultiplyMV4,
    multiplyMV3,
    MultiplyMV2,
    MultiplyMX,
    MultiplyMY,
    MultiplyMZ,

    Translate,
    Rotate,
    RotateX,
    RotateY,
    RotateZ,
    Scale,
    Inverse,
    Transpose,
    InverseTranspose,
    Orthographic,
    Frustum,
    Perspective,
    LookAt,
}};

```

`Engine/Toolkit/Math/Matrix.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-6
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#ifndef MATRIX_H
#define MATRIX_H


#include "Engine/Toolkit/Math/Math.h"
#include "Engine/Toolkit/Math/Vector.h"


/**
 * (m0  m1  m2 ) x m3  w
 * (m4  m5  m6 ) y m7  w
 * (m8  m9  m10) z m11 w
 * (m12 m13 m14) t m15 w
 */
typedef union
{
    float m[16];
    struct
    {
        float
        m0,  m1,  m2,  m3,
        m4,  m5,  m6,  m7,
        m8,  m9,  m10, m11,
        m12, m13, m14, m15;
    };
}
Matrix4;


#define MATRIX4_IDENTITY          \
    {{                            \
          1.0f, 0.0f, 0.0f, 0.0f, \
          0.0f, 1.0f, 0.0f, 0.0f, \
          0.0f, 0.0f, 1.0f, 0.0f, \
          0.0f, 0.0f, 0.0f, 1.0f, \
    }}

#define MATRIX4_IDENTITY_ARRAY \
    (Matrix4[1]) MATRIX4_IDENTITY


/**
 * Control Matrix4.
 */
struct AMatrix
{
    /**
     * Multiply left and right matrix4 into outMatrix4.
     */
    void  (*MultiplyMM)      (Matrix4* left, Matrix4* right, Matrix4* outMatrix4);

    /**
     * Multiply m2 and m3  into outM23.
     * Multiply m1 and m23 into outM231.
     */
    void  (*MultiplyMMM)     (Matrix4* m1, Matrix4* m2, Matrix4* m3, Matrix4* outM23, Matrix4* outM231);

    /**
     * Multiply matrix4 * vector4 into outVector4.
     */
    void  (*MultiplyMV4)     (Matrix4* matrix4, float x, float y, float z, float w, Vector4* outVector4);

    /**
     * Multiply matrix4 * vector3 into outVector3.
     */
    void  (*MultiplyMV3)     (Matrix4* matrix4, float x, float y, float z, Vector3* outVector3);

    /**
     * Multiply matrix4 * vector2 into outVector2.
     */
    void  (*MultiplyMV2)     (Matrix4* matrix4, float x, float y, Vector2* outVector2);

    /**
     * Multiply matrix4 * x, return transformed x.
     */
    float (*MultiplyMX)      (Matrix4* matrix4, float x);

    /**
     * Multiply matrix4 * y, return transformed y.
     */
    float (*MultiplyMY)      (Matrix4* matrix4, float y);

    /**
     * Multiply matrix4 * z, return transformed z.
     */
    float (*MultiplyMZ)      (Matrix4* matrix4, float z);

    /**
     * Translate matrix4 by vector3.
     */
    void  (*Translate)       (Matrix4* matrix4, float x, float y, float z);

    /**
     * Rotate matrix4 by angle and vector3.
     */
    void  (*Rotate)          (Matrix4* matrix4, float angle, float x, float y, float z);

    /**
     * Rotate matrix4 by x axis with angle.
     */
    void  (*RotateX)         (Matrix4* matrix4, float angle);

    /**
     * Rotate matrix4 by y axis with angle.
     */
    void  (*RotateY)         (Matrix4* matrix4, float angle);

    /**
     * Rotate matrix4 by z axis with angle.
     */
    void  (*RotateZ)         (Matrix4* matrix4, float angle);

    /**
     * Scale matrix4 by vector3.
     */
    void  (*Scale)           (Matrix4* matrix4, float x, float y, float z);

    /**
     * Invert matrix4 into outInverse.
     */
    void  (*Inverse)         (Matrix4* matrix4, Matrix4* outInverse);

    /**
     * Transpose matrix4 into outTranspose.
     */
    void  (*Transpose)       (Matrix4* matrix4, Matrix4* outTranspose);

    /**
     * Invert transpose matrix4 into outInverseTranspose.
     */
    void  (*InverseTranspose)(Matrix4* matrix4, Matrix4* outInverseTranspose);

    /**
     * Computes an orthogonal projection matrix4.
     */
    void  (*Orthographic)    (
                                float    left,
                                float    right,
                                float    bottom,
                                float    top,
                                float    near,
                                float    far,
                                Matrix4* outProjection
                             );

    /**
     * Define a projection matrix4 in terms of six clip planes.
     */
    void  (*Frustum)         (
                                float    left,
                                float    right,
                                float    bottom,
                                float    top,
                                float    near,
                                float    far,
                                Matrix4* outProjection
                              );

    /**
     * Define a projection matrix in terms of a field of view angle an aspect ratio, and z clip planes.
     * fovy  : field of view angle for y axis.
     * aspect: width / height.
     */
    void  (*Perspective)     (float fovy, float aspect, float near, float far, Matrix4* outProjection);

    /**
     * Define a viewing transformation in terms of an eye point, a center of view, and an up vector.
     */
    void  (*LookAt)          (
                                float    eyeX,     float eyeY,    float eyeZ,
                                float    centerX,  float centerY, float centerZ,
                                float    upX,      float upY,     float upZ,
                                Matrix4* outView
                             );
};


extern struct AMatrix AMatrix[1];


/**
* Construct Matrix composite literal.
*/
#define AMatrix_Make(...) \
   (Matrix4[1]) {{__VA_ARGS__}}




#endif

```

`Engine/Toolkit/Math/TweenEase.c`:

```c
/*
 * The original algorithms of easing functions come from Robert Penner.
 * The open source licensed under the MIT License and the BSD License.
 *
 * Introduce: http://robertpenner.com/easing
 * License  : http://robertpenner.com/easing_terms_of_use.html
 *
 *----------------------------------------------------------------------------------------------------------------------
 * 
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-11-5
 * Update   : 2021-8-16
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Math/TweenEase.h"
#include "Engine/Toolkit/Math/Math.h"


static float Linear(float time)
{
    return time;
}


static float Smooth(float time)
{
    return time * time * (3.0f - 2.0f * time);
}


//----------------------------------------------------------------------------------------------------------------------


static float QuadraticIn(float time)
{
    return time * time;
}


static float QuadraticOut(float time)
{
    return time * (2.0f - time);
}


static float QuadraticInOut(float time)
{
    if (time < 0.5f)
    {
        return time * time * 2.0f;
    }

    return 2.0f * time * (2.0f - time) - 1.0f;
}


//----------------------------------------------------------------------------------------------------------------------


static float CubicIn(float time)
{
    return time * time * time;
}


static float CubicOut(float time)
{
    time -= 1.0f;
    return time * time * time + 1.0f;
}


static float CubicInOut(float time)
{
    if (time < 0.5f)
    {
        return 4.0f * time * time * time;
    }

    time -= 1.0f;
    return 4.0f * time * time * time + 1.0f;
}


//----------------------------------------------------------------------------------------------------------------------


static float QuarticIn(float time)
{
    return time * time * time * time;
}


static float QuarticOut(float time)
{
    time -= 1.0f;
    return 1.0f - time * time * time * time;
}


static float QuarticInOut(float time)
{
    if (time < 0.5f)
    {
        return 8.0f * time * time * time * time;
    }

    time -= 1.0f;
    return 1.0f - 8.0f * time * time * time * time;
}


//----------------------------------------------------------------------------------------------------------------------


static float QuinticIn(float time)
{
    return time * time * time * time * time;
}


static float QuinticOut(float time)
{
    time -= 1.0f;
    return time * time * time * time * time + 1.0f;
}


static float QuinticInOut(float time)
{
    if (time < 0.5f)
    {
        return 16.0f * time * time * time * time * time;
    }

    time -= 1.0f;
    return 16.0f * time * time * time * time * time + 1.0f;
}


//----------------------------------------------------------------------------------------------------------------------


static float ExponentialIn(float time)
{
    if (time <= 0.0f)
    {
        return time;
    }

    return powf(2.0f, 10.0f * (time - 1.0f));
}


static float ExponentialOut(float time)
{
    if (time >= 1.0f)
    {
        return time;
    }

    return 1.0f - powf(2.0f, -10.0f * time);
}


static float ExponentialInOut(float time)
{
    if (time <= 0.0f || time >= 1.0f)
    {
        return time;
    }

    if (time < 0.5f)
    {
        return 0.5f * powf(2.0f, 20.0f * time - 10.0f);
    }

    return 0.5f * (2.0f - powf(2.0f, -20.0f * time + 10.0f));
}


//----------------------------------------------------------------------------------------------------------------------


static float SineIn(float time)
{
    return 1.0f - cosf(time * 1.570796f);
}


static float SineOut(float time)
{
    return sinf(time * 1.570796f);
}


static float SineInOut(float time)
{
    return 0.5f * (1.0f - cosf(time * 3.141593f));
}


//----------------------------------------------------------------------------------------------------------------------


static float CircularIn(float time)
{
    return 1.0f - AMath_Sqrtf(1.0f - time * time);
}


static float CircularOut(float time)
{
    return AMath_Sqrtf((2.0f - time) * time);
}


static float CircularInOut(float time)
{
    if (time < 0.5f)
    {
        return 0.5f * (1.0f - AMath_Sqrtf(1.0f - 4.0f * time * time));
    }

    time = time * 2.0f - 2.0f;
    return 0.5f * (AMath_Sqrtf(1.0f - time * time) + 1.0f);
}


//----------------------------------------------------------------------------------------------------------------------


static float ElasticIn(float time)
{
    if (time <= 0.0f || time >= 1.0f)
    {
        return time;
    }

    return -powf(2.0f, 10.0f * time - 10.0f) * sinf(20.923007f * time - 22.493803f);
}


static float ElasticOut(float time)
{
    if (time <= 0.0f || time >= 1.0f)
    {
        return time;
    }
    
    return powf(2.0f, -10.0f * time) * sinf(20.923007f * time - 1.570796f) + 1.0f;
}


static float ElasticInOut(float time)
{
    if (time <= 0.0f || time >= 1.0f)
    {
        return time;
    }

    if (time < 0.5f)
    {
        return -0.5f * powf(2.0f, 20.0f * time - 10.0f) * sinf(27.960175f * time - 15.550884f);
    }

    return powf(2.0f, -20.0f * time + 10.0f) * sinf(27.960175f * time - 15.550884f) * 0.5f + 1.0f;
}


//----------------------------------------------------------------------------------------------------------------------


static float BackIn(float time)
{
    return time * time * (2.70158f * time - 1.70158f);
}


static float BackOut(float time)
{
    time -= 1.0f;
    return time * time * (2.70158f * time + 1.70158f) + 1.0f;
}


static float BackInOut(float time)
{
    if (time < 0.5f)
    {
        return time * time * (14.379636f * time - 5.189818f);
    }

    time -= 1.0f;
    return time * time * (14.379636f * time + 5.189818f) + 1.0f;
}


static float BackInExponentialOut(float time)
{
    if (time < 0.5f)
    {
        return time * time * (14.379636f * time - 5.189818f);
    }

    return 0.5f * (2.0f - powf(2.0f, -20.0f * time + 10.0f));
}


static float BackInElasticOut(float time)
{
    if (time < 0.5f)
    {
        return time * time * (14.379636f * time - 5.189818f);
    }

    if (time >= 1.0f)
    {
        return time;
    }

    return powf(2.0f, -20.0f * time + 10.0f) * sinf(27.960175f * time - 15.550884f) * 0.5f + 1.0f;
}


//----------------------------------------------------------------------------------------------------------------------


static float BounceIn(float time)
{
    if (time > 0.636364f)
    {
        time = 1.0f - time;
        return 1.0f - 7.5625f * time * time;
    }

    if (time > 0.27273f)
    {
        time = 0.454546f - time;
        return 0.25f - 7.5625f * time * time;
    }

    if (time > 0.090909f)
    {
        time = 0.181818f - time;
        return 0.0625f - 7.5625f * time * time;
    }

    if (time >= 1.0f)
    {
        return time;
    }

    time = 0.045455f - time;
    return 0.015625f - 7.5625f * time * time;
}


static float BounceOut(float time)
{
    if (time < 0.363636f)
    {
        return 7.5625f * time * time;
    }

    if (time < 0.72727f)
    {
        time -= 0.545454f;
        return 7.5625f * time * time + 0.75f;
    }

    if (time < 0.909091f)
    {
        time -= 0.818182f;
        return 7.5625f * time * time + 0.9375f;
    }

    if (time >= 1.0f)
    {
        return time;
    }
    
    time -= 0.954545f;
    return 7.5625f * time * time + 0.984375f;
}


static float BounceInOut(float time)
{
    if (time < 0.5f)
    {
        // bounce in
        if (time > 0.318182f)
        {
            time = 1.0f - time * 2.0f;
            return 0.5f - 3.78125f * time * time;
        }

        if (time > 0.136365f)
        {
            time = 0.454546f - time * 2.0f;
            return 0.125f - 3.78125f * time * time;
        }

        if (time > 0.045455f)
        {
            time = 0.181818f - time * 2.0f;
            return 0.03125f - 3.78125f * time * time;
        }

        time = 0.045455f - time * 2.0f;
        return 0.007813f - 3.78125f * time * time;
    }

    // bounce out
    if (time < 0.681818f)
    {
        time = time * 2.0f - 1.0f;
        return 3.78125f * time * time + 0.5f;
    }

    if (time < 0.863635f)
    {
        time = time * 2.0f - 1.545454f;
        return 3.78125f * time * time + 0.875f;
    }

    if (time < 0.954546f)
    {
        time = time * 2.0f - 1.818182f;
        return 3.78125f * time * time + 0.96875f;
    }

    if (time >= 1.0f)
    {
        return time;
    }

    time = time * 2.0f - 1.954545f;
    return 3.78125f * time * time + 0.992188f;
}


struct ATweenEase ATweenEase[1] =
{{
    Linear,
    Smooth,

    QuadraticIn,
    QuadraticOut,
    QuadraticInOut,

    CubicIn,
    CubicOut,
    CubicInOut,

    QuarticIn,
    QuarticOut,
    QuarticInOut,

    QuinticIn,
    QuinticOut,
    QuinticInOut,

    ExponentialIn,
    ExponentialOut,
    ExponentialInOut,

    SineIn,
    SineOut,
    SineInOut,

    CircularIn,
    CircularOut,
    CircularInOut,

    ElasticIn,
    ElasticOut,
    ElasticInOut,

    BackIn,
    BackOut,
    BackInOut,
    BackInExponentialOut,
    BackInElasticOut,

    BounceIn,
    BounceOut,
    BounceInOut,
}};

```

`Engine/Toolkit/Math/TweenEase.h`:

```h
/* 
 * The original algorithms of easing functions come from Robert Penner.
 * The open source licensed under the MIT License and the BSD License.
 *
 * Introduce: http://robertpenner.com/easing
 * License  : http://robertpenner.com/easing_terms_of_use.html
 *
 *----------------------------------------------------------------------------------------------------------------------
 * 
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-11-5
 * Update   : 2021-8-16
 * Author   : scott.cgi
 */


#ifndef TWEEN_EASE_H
#define TWEEN_EASE_H


typedef enum
{
    TweenEaseType_Linear,
    TweenEaseType_Smooth,

    TweenEaseType_QuadraticIn,
    TweenEaseType_QuadraticOut,
    TweenEaseType_QuadraticInOut,

    TweenEaseType_CubicIn,
    TweenEaseType_CubicOut,
    TweenEaseType_CubicInOut,

    TweenEaseType_QuarticIn,
    TweenEaseType_QuarticOut,
    TweenEaseType_QuarticInOut,

    TweenEaseType_QuinticIn,
    TweenEaseType_QuinticOut,
    TweenEaseType_QuinticInOut,

    TweenEaseType_ExponentialIn,
    TweenEaseType_ExponentialOut,
    TweenEaseType_ExponentialInOut,

    TweenEaseType_SineIn,
    TweenEaseType_SineOut,
    TweenEaseType_SineInOut,

    TweenEaseType_CircularIn,
    TweenEaseType_CircularOut,
    TweenEaseType_CircularInOut,

    TweenEaseType_ElasticIn,
    TweenEaseType_ElasticOut,
    TweenEaseType_ElasticInOut,

    TweenEaseType_BackIn,
    TweenEaseType_BackOut,
    TweenEaseType_BackInOut,
    TweenEaseType_BackInExponentialOut,
    TweenEaseType_BackInElasticOut,

    TweenEaseType_BounceIn,
    TweenEaseType_BounceOut,
    TweenEaseType_BounceInOut,

    TweenEaseType_Length,
}
TweenEaseType;


struct ATweenEase
{

    /**
     * Tween easing time functions.
     * the return value between [0.0f, 1.0f], which is the time between [0.0f, 1.0f] after easing.
     */
    float (*Easing[TweenEaseType_Length])(float time);
};


extern struct ATweenEase ATweenEase[1];


#endif

```

`Engine/Toolkit/Math/Vector.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-6-19
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#ifndef VECTOR_H
#define VECTOR_H


#include <math.h>
#include "Engine/Toolkit/Math/Math.h"


typedef union
{
    float v[2];
    struct
    {
        float x;
        float y;
    };
}
Vector2;


typedef union
{
    float v[3];
    struct
    {
        float x;
        float y;
        float z;
    };
}
Vector3;


typedef union
{
    float v[4];
    struct
    {
        float x;
        float y;
        float z;
        float w;
    };
}
Vector4;


/**
 * Construct Vector2 composite literal.
 */
#define AVector2_Make(x, y) \
   (Vector2[1]) {{x, y}}


/**
 * Construct Vector3 composite literal.
 */
#define AVector3_Make(x, y, z) \
   (Vector3[1]) {{x, y, z}}


/**
* Construct Vector4 composite literal.
*/
#define AVector4_Make(x, y, z, w) \
   (Vector4[1]) {{x, y, z, w}}


/**
 * Calculate Vector2 length by vec2.
 */
static inline float AVector2_Length(Vector2* vec2)
{
    return AMath_Sqrtf(vec2->x * vec2->x + vec2->y * vec2->y);
}

/**
* Calculate Vector2 length by x and y.
*/
static inline float AVector2_Length2(float x, float y)
{
    return AMath_Sqrtf(x * x + y * y);
}


/**
 * Calculate Vector3 length by vec3.
 */
static inline float AVector3_Length(Vector3* vec3)
{
    return AMath_Sqrtf(vec3->x * vec3->x + vec3->y * vec3->y + vec3->z * vec3->z);
}


/**
 * Calculate Vector3 length by x y z.
 */
static inline float AVector3_Length3(float x, float y, float z)
{
    return AMath_Sqrtf(x * x + y * y + z * z);
}


/**
 * Normalize Vector3 by vec3.
 */
static inline float AVector3_Normalize(Vector3* vec3)
{
//  return 1.0f  /  sqrtf(vec3->x * vec3->x + vec3->y * vec3->y + vec3->z * vec3->z);
    return AMath_InvSqrtf(vec3->x * vec3->x + vec3->y * vec3->y + vec3->z * vec3->z);
}


/**
 * Normalize Vector3 by x y z.
 */
static inline float AVector3_Normalize3(float x, float y, float z)
{
//  return 1.0f  /  sqrtf(x * x + y * y + z * z);
    return AMath_InvSqrtf(x * x + y * y + z * z);
}


#endif 

```

`Engine/Toolkit/Platform/Android/File.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-8-29
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */
 

#include "Engine/Toolkit/Platform/Platform.h"


//------------------------
#ifdef IS_PLATFORM_ANDROID
//------------------------


#include <string.h>
#include <android/native_activity.h>
#include "Engine/Toolkit/Platform/File.h"
#include "Engine/Toolkit/Platform/Log.h"


extern ANativeActivity* nativeActivity;


static File* Open(const char* resourceFilePath)
{
    AAsset* asset = AAssetManager_open(nativeActivity->assetManager, resourceFilePath, AASSET_MODE_UNKNOWN);
    return (File*) asset;
}


static int OpenFileDescriptor(const char* resourceFilePath, long* outStart, long* outLength)
{
    AAsset* asset = AAssetManager_open(nativeActivity->assetManager, resourceFilePath, AASSET_MODE_UNKNOWN);
    int     fd    = AAsset_openFileDescriptor(asset, (off_t*) outStart, (off_t*) outLength);
    AAsset_close(asset);

    return fd;
}


static void Close(File* file)
{
    AAsset_close((AAsset*) file);
}


static long GetLength(File* file)
{
    return (long) AAsset_getLength((AAsset*) file);
}


static int Read(File* file, void* buffer, size_t count)
{
    return AAsset_read((AAsset*) file, buffer, count);
}


static long Seek(File* file, long offset, int whence)
{
    return (long) AAsset_seek((AAsset*) file, (off_t) offset, whence);
}


static const char* GetInternalDataPath(int* outPathLength)
{
    static int length = -1;

    if (length == -1)
    {
        length = (int) strlen(nativeActivity->internalDataPath);
    }

    if (outPathLength != NULL)
    {
        *outPathLength = length;
    }

    return nativeActivity->internalDataPath;
}


struct AFile AFile[1] =
{{
    Open,
    OpenFileDescriptor,
    Close,
    GetLength,
    Read,
    Seek,
    GetInternalDataPath,
}};


//---------------------------
#endif // IS_PLATFORM_ANDROID
//---------------------------


```

`Engine/Toolkit/Platform/File.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-8-27
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#ifndef FILE_H
#define FILE_H


#include <stddef.h>
#include "Engine/Toolkit/HeaderUtils/Define.h"


/**
 * Related to platform directory.
 * 
 * Android: assets   files
 * IOS    : NSBundle files
 */
typedef struct File File;

/**
 * Resource File access API.
 */
struct AFile
{
    /**
     * Open a file from platform resource directory by file path.
     *
     * resourceFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     *
     *  return NULL if open file error.
     */
    File*       (*Open)               (const char* resourceFilePath);

    /**
     * Open a file descriptor from platform resource directory by file path.
     * it can be used to read the file data.
     *
     * resourceFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     *
     * returns < 0 if direct fd access is not possible (for example, if the file is compressed).
     */
    int         (*OpenFileDescriptor) (const char* resourceFilePath, long* outStart, long* outLength);

    /**
     * Close an opened file connection, free any related resources.
     */
    void        (*Close)              (File* file);

    /**
     * Return file length.
     */
    long        (*GetLength)          (File* file);

    /**
     * Read count bytes of data from the current offset.
     * return the number of bytes read, zero on EOF, or < 0 on error, always need to close file.
     */
    int         (*Read)               (File* file, void* buffer, size_t count);

    /**
     * Seek to the specified offset.
     * the whence uses the same constants (SEEK_SET, SEEK_CUR, SEEK_END) as fseek().
     *
     * return the new position on success, or -1 on error, always need to close file.
     */
     long       (*Seek)               (File* file, long offset, int whence);

    /**
     * The internal data path related to platform directory.
     * if outPathLength not NULL, will set the strlen(internalDataPath).
     *
     * internalDataPath:
     *     Android: internal data directory
     *     IOS    : document data directory
     */
    const char* (*GetInternalDataPath)(int* outPathLength);
};


extern struct AFile AFile[1];


#endif

```

`Engine/Toolkit/Platform/IOS/File.m`:

```m
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-8-29
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#include "Engine/Toolkit/Platform/Platform.h"


//--------------------
#ifdef IS_PLATFORM_IOS
//--------------------


#include <stdio.h>
#include <string.h>
#include <Foundation/Foundation.h>

#include "Engine/Toolkit/Platform/File.h"
#include "Engine/Toolkit/Math/Math.h"
#include "Engine/Toolkit/Platform/Log.h"


static File* Open(const char* resourceFilePath)
{
    NSString* path = [[NSBundle mainBundle] pathForResource:[NSString stringWithUTF8String:resourceFilePath] ofType:nil];
    FILE*     file = fopen([path cStringUsingEncoding:NSMacOSRomanStringEncoding], "rb");

    return (File*) file;
}


static int OpenFileDescriptor(const char* relativeFilePath, long* outStart, long* outLength)
{
    FILE* file = (FILE*) Open(relativeFilePath);
    int   fd   = fileno(file);

    *outStart  = ftell(file);
    fseek(file, 0, SEEK_END);
    *outLength = ftell(file);
    fseek(file, *outStart , SEEK_SET);

    return fd;
}


static void Close(File* file)
{
    fclose((FILE*) file);
}


static long GetLength(File* file)
{
    FILE* f = (FILE*) file;

    long start  = ftell(f);
    fseek(f, 0, SEEK_END);
    long length = ftell(f);
    fseek(f, start, SEEK_SET);
    
    return length;
}


static int Read(File* file, void* buffer, size_t count)
{
    FILE*  f    = (FILE*) file;
    size_t read = fread(buffer, count, 1, f);

    if (ferror(f) != 0)
    {
        perror("AFile Read error");
        clearerr(f);

        return -1; // error
    }

    return (int) read;
}


static long Seek(File* file, long offset, int whence)
{
    FILE* f = (FILE*) file;

    if (fseek(f, offset, whence) == 0)
    {
        return ftell(f); // success return new position
    }

    perror("AFile Seek error");
    clearerr(f);

    return -1; // error
}


static const char* GetInternalDataPath(int* outPathLength)
{
    static char* internalDataPath = NULL;
    static int   length           = -1;
    
    if (internalDataPath == NULL)
    {
        NSString*   str          = [NSHomeDirectory() stringByAppendingPathComponent:@"Documents"];
        const char* cStr         = [str cStringUsingEncoding:NSASCIIStringEncoding];
        length                   = (int) strlen(cStr) + 1;
        internalDataPath         = malloc(length);
        memcpy(internalDataPath, cStr, length);
        --length;
    }

    if (outPathLength != NULL)
    {
        *outPathLength = length;
    }

    return internalDataPath;
}


struct AFile AFile[1] =
{{
    Open,
    OpenFileDescriptor,
    Close,
    GetLength,
    Read,
    Seek,
    GetInternalDataPath,
}};


//-----------------------
#endif // IS_PLATFORM_IOS
//-----------------------

```

`Engine/Toolkit/Platform/Log.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2012-12-20
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#ifndef LOG_H
#define LOG_H


#include <assert.h>
#include "Engine/Toolkit/Platform/Platform.h"


#ifdef IS_PLATFORM_ANDROID
    #include <android/log.h>
    #define  ALog_D(...) // __android_log_print(ANDROID_LOG_DEBUG, "Mojoc debug", __VA_ARGS__)
    #define  ALog_W(...)    __android_log_print(ANDROID_LOG_WARN , "Mojoc warn" , __VA_ARGS__)
    #define  ALog_E(...)    __android_log_print(ANDROID_LOG_ERROR, "Mojoc error", __VA_ARGS__)
    #define  ALog_A(e, ...) e ? (void) 0 : ALog_E(__VA_ARGS__),  assert(e);
#elif defined(IS_PLATFORM_IOS)
    #include <stdio.h>
    #define  ALog_D(...)
    #define  ALog_W(...)
    #define  ALog_E(...)    printf(__VA_ARGS__), printf("\n");
    #define  ALog_A(e, ...) e ? (void) 0 : printf(__VA_ARGS__), printf("\n"),  assert(e);
#endif


//-------------
#endif // LOG_H
//-------------


```

`Engine/Toolkit/Platform/Platform.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-5-6
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#ifndef PLATFORM_H
#define PLATFORM_H


#define PLATFORM_ANDROID 0
#define PLATFORM_IOS     1
#define PLATFORM_TARGET  PLATFORM_ANDROID


#if PLATFORM_TARGET == PLATFORM_ANDROID
    #define IS_PLATFORM_ANDROID
#elif PLATFORM_TARGET == PLATFORM_IOS
    #define IS_PLATFORM_IOS
#endif


//------------------
#endif // PLATFORM_H
//------------------

```

`Engine/Toolkit/Toolkit.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-9-8
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Toolkit.h"


static void Init()
{
}


struct AToolkit AToolkit[1] =
{{
    Init
}};

```

`Engine/Toolkit/Toolkit.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-9-8
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */
 

#ifndef TOOLKIT_H
#define TOOLKIT_H


/**
 * Manage Toolkit module.
 */
struct AToolkit
{
    void (*Init)(void);
};


extern struct AToolkit AToolkit[1];


#endif 

```

`Engine/Toolkit/Utils/Array.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-3-11
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#include <stdlib.h>
#include "Engine/Toolkit/Utils/Array.h"


static Array* Create(int elementTypeSize, int length)
{
    Array* array  = malloc(sizeof(Array) + elementTypeSize * length);
    array->data   = (char*) array + sizeof(Array);
    array->length = length;

    return array;
}


struct AArray AArray[1] =
{{
    Create,
}};


```

`Engine/Toolkit/Utils/Array.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-2-1
 * Update   : 2017-1-17
 * Author   : scott.cgi
 */


#ifndef ARRAY_H
#define ARRAY_H


#include "Engine/Toolkit/HeaderUtils/Define.h"


/**
 * The array with length.
 */
typedef struct
{
    /**
     * Elements memory space ptr.
     * if use "void data[]" will not be able to set the data manually.
     */
    void* data;

    /**
     * Elements count.
     */
    int   length;
}
Array;


/**
 * Control Array.
 */
struct AArray
{
    /**
     * Array struct space and elements space in one malloc.
     * the data ptr store the offset of malloc return address.
     *
     * elementTypeSize: sizeof element type
     * length         : elements count
     */
    Array* (*Create)(int elementTypeSize, int length);
};


extern struct AArray AArray[1];


/**
 * Marked Array element type.
 * ElementType: element data type
 */
#define Array(ElementType) Array


/**
 * Construct Array composite literal.
 *
 * ElementType: element data type
 * length     : elements count
 * ...        : each elements
 */
#define AArray_Make(ElementType, length, ...) \
    (Array[1])                                \
    {                                         \
        (ElementType[length]) {__VA_ARGS__},  \
        length,                               \
    }


/**
 * Construct Array composite literal.
 *
 * data  : elements data
 * length: elements count
 */
#define AArray_MakeWithData(data, length) \
    (Array[1]) {data, length}


/**
 * Init constant Array.
 *
 * ElementType: element data type
 * length     : elements count
 * ...        : each elements
 */
#define AArray_Init(ElementType, length, ...) \
    {                                         \
        (ElementType[length]) {__VA_ARGS__},  \
        length,                               \
    }


/**
 * Get element at index.
 *
 * array      : Array ptr
 * index      : element index of array
 * ElementType: element data type
 */
#define AArray_Get(array, index, ElementType) \
    ((ElementType*) (array)->data)[index]


/**
 * Get element ptr at index.
 *
 * array      : Array ptr
 * index      : element index of array
 * ElementType: element data type
 */
#define AArray_GetPtr(array, index, ElementType) \
    ((ElementType*) (array)->data + (index))


/**
 * Set element at index.
 *
 * array      : Array ptr
 * index      : element index of array
 * element    : element value
 * ElementType: element data type
 */
#define AArray_Set(array, index, element, ElementType) \
    AArray_Get(array, index, ElementType) = element


#endif

```

`Engine/Toolkit/Utils/ArrayIntMap.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-5-20
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#include <string.h>
#include <stdlib.h>
#include "Engine/Toolkit/Utils/ArrayIntMap.h"
#include "Engine/Toolkit/Platform/Log.h"


#define CheckIndex(tag)                                        \
    ALog_A                                                     \
    (                                                          \
        index >= 0 && index <  arrayIntMap->elementList->size, \
        "AArrayIntMap" tag "index = %d, size = %d, invalid",   \
        index,                                                 \
        arrayIntMap->elementList->size                         \
    )


#define CheckInsertIndex(tag)                                  \
    ALog_A                                                     \
    (                                                          \
        index >= 0 && index <= arrayIntMap->elementList->size, \
        "AArrayIntMap" tag "index = %d, size = %d, invalid",   \
        index,                                                 \
        arrayIntMap->elementList->size                         \
    )



/**
 * Search index of key, if negative not found then return "-insertIndex - 1",
 * so insert index is "-BinarySearch() - 1".
 */
static inline int BinarySearch(ArrayList(intptr_t)* elementList, intptr_t key)
{
    int high  = elementList->size;
    int low   = -1;
    int guess = -1;

    while (high - low > 1) // prevent infinite loops
    {
        // (high + low) always positive, so convert to unsigned
        // then the '>>' is unsigned move right
        // so the overflow will be handled correctly
        // because sign bit shift to right and 0 will be added
        guess               = (unsigned int) (high + low) >> 1;
        intptr_t elementKey = AArrayList_Get(elementList, guess, ArrayIntMapElement*)->key;

        if (elementKey < key)
        {
            low  = guess;
        }
        else if (elementKey > key)
        {
            high = guess;
        }
        else if (elementKey == key)
        {
            // find the key, the guess is positive value
            return guess;
        }
    }

    // if guess == high
    // the guess is bigger than key index and insert value at guess

    if (guess == low)
    {
        // the guess is smaller than key index and insert value behind,
        // or if list empty then the guess is -1, so do this make guess at 0
        ++guess;
    }

    // when list empty the guess is 0, so we -1 make sure return negative value
    return -guess - 1;
}


static void* TryPut(ArrayIntMap* arrayIntMap, intptr_t key, void* valuePtr)
{
    int guess = BinarySearch(arrayIntMap->elementList, key);

    if (guess < 0)
    {
        ArrayIntMapElement* element = malloc(sizeof(ArrayIntMapElement) + arrayIntMap->valueTypeSize);
        element->key                = key;
        element->valuePtr           = (char*) element + sizeof(ArrayIntMapElement);

        AArrayList_Insert(arrayIntMap->elementList, -guess - 1, element);

        return memcpy(element->valuePtr, valuePtr, (size_t) arrayIntMap->valueTypeSize);
    }
    else
    {
        return NULL;
    }
}


static void* Get(ArrayIntMap* arrayIntMap, intptr_t key, void* defaultValuePtr)
{
    int guess = BinarySearch(arrayIntMap->elementList, key);

    return guess >= 0 ?
           AArrayList_Get(arrayIntMap->elementList, guess, ArrayIntMapElement*)->valuePtr : defaultValuePtr;
}


static void* TrySet(ArrayIntMap* arrayIntMap, intptr_t key, void* valuePtr)
{
    int guess = BinarySearch(arrayIntMap->elementList, key);

    if (guess >= 0)
    {
        return memcpy
               (
                   AArrayList_Get(arrayIntMap->elementList, guess, ArrayIntMapElement*)->valuePtr,
                   valuePtr,
                   (size_t) arrayIntMap->valueTypeSize
               );
    }
    else
    {
        return NULL;
    }
}


static bool TryRemove(ArrayIntMap* arrayIntMap, intptr_t key)
{
    int guess = BinarySearch(arrayIntMap->elementList, key);

    if (guess >= 0)
    {
        free
        (
            AArrayList_Get(arrayIntMap->elementList, guess, ArrayIntMapElement*)
        );

        AArrayList->Remove(arrayIntMap->elementList, guess);

        return true;
    }
    
    return false;
}


static void Clear(ArrayIntMap* arrayIntMap)
{
    for (int i = 0; i < arrayIntMap->elementList->size; ++i)
    {
        free
        (
            AArrayList_Get(arrayIntMap->elementList, i, ArrayIntMapElement*)
        );
    }

    AArrayList->Clear(arrayIntMap->elementList);
}


static void* InsertAt(ArrayIntMap* arrayIntMap, intptr_t key, int index, void* valuePtr)
{
    CheckInsertIndex("InsertAt");

    ArrayIntMapElement* element = malloc(sizeof(ArrayIntMapElement) + arrayIntMap->valueTypeSize);
    element->key                = key;
    element->valuePtr           = (char*) element + sizeof(ArrayIntMapElement);
    AArrayList_Insert(arrayIntMap->elementList, index, element);

    return memcpy(element->valuePtr, valuePtr, (size_t) arrayIntMap->valueTypeSize);
}


static int GetIndex(ArrayIntMap* arrayIntMap, intptr_t key)
{
    return BinarySearch(arrayIntMap->elementList, key);
}


static intptr_t GetKey(ArrayIntMap* arrayIntMap, int index)
{
    CheckIndex("GetKey");
    return AArrayList_Get(arrayIntMap->elementList, index, ArrayIntMapElement*)->key;
}


static void* GetAt(ArrayIntMap* arrayIntMap, int index)
{
    CheckIndex("GetAt");
    return AArrayList_Get(arrayIntMap->elementList, index, ArrayIntMapElement*)->valuePtr;
}


static void* SetAt(ArrayIntMap* arrayIntMap, int index, void* valuePtr)
{
    CheckIndex("SetAt");

    return memcpy
           (
               AArrayList_Get(arrayIntMap->elementList, index, ArrayIntMapElement*)->valuePtr,
               valuePtr,
               (size_t) arrayIntMap->valueTypeSize
           );
}


static void RemoveAt(ArrayIntMap* arrayIntMap, int index)
{
    CheckIndex("RemoveAt");

    free
    (
        AArrayList_Get(arrayIntMap->elementList, index, ArrayIntMapElement*)
    );

    AArrayList->Remove(arrayIntMap->elementList, index);
}


static void Release(ArrayIntMap* arrayIntMap)
{
    for (int i = 0; i < arrayIntMap->elementList->size; ++i)
    {
        free
        (
            AArrayList_Get(arrayIntMap->elementList, i, ArrayIntMapElement*)
        );
    }

    AArrayList->Release(arrayIntMap->elementList);
}


static void InitWithCapacity(int valueTypeSize, int capacity, ArrayIntMap* outArrayIntMap)
{
    if (capacity == 0)
    {
        AArrayList->Init(sizeof(ArrayIntMapElement*), outArrayIntMap->elementList);
    }
    else
    {
        AArrayList->InitWithCapacity(sizeof(ArrayIntMapElement*), capacity, outArrayIntMap->elementList);
    }

    outArrayIntMap->valueTypeSize = valueTypeSize;
}


static ArrayIntMap* CreateWithCapacity(int valueTypeSize, int capacity)
{
    ArrayIntMap* arrayIntMap = malloc(sizeof(ArrayIntMap));
    InitWithCapacity(valueTypeSize, capacity, arrayIntMap);

    return arrayIntMap;
}


static void Init(int valueTypeSize, ArrayIntMap* outArrayIntMap)
{
    InitWithCapacity(valueTypeSize, 0, outArrayIntMap);
}


static ArrayIntMap* Create(int valueTypeSize)
{
    return CreateWithCapacity(valueTypeSize, 0);
}


struct AArrayIntMap AArrayIntMap[1] =
{{
    Create,
    Init,
    CreateWithCapacity,
    InitWithCapacity,

    Release,

    TryPut,
    Get,
    TrySet,
    TryRemove,
    Clear,
    InsertAt,
    GetIndex,
    GetKey,
    GetAt,
    SetAt,
    RemoveAt,
}};


#undef CheckIndex
#undef CheckInsertIndex




```

`Engine/Toolkit/Utils/ArrayIntMap.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-5-27
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#ifndef ARRAY_INT_MAP_H
#define ARRAY_INT_MAP_H


#include <stdbool.h>
#include <stdint.h>
#include "Engine/Toolkit/Utils/ArrayList.h"


/**
 * The actual element store in ArrayIntMap.
 */
typedef struct
{
    /**
     * IDentity and search element value.
     */
    intptr_t key;

    /**
     * ArrayIntMap value pointer.
     * the value data copy into ArrayIntMapElement malloc memory space.
     */
    void*    valuePtr;
}
ArrayIntMapElement;


/**
 * A list of elements each of which is a k-v pair.
 */
typedef struct
{
    /**
     * The sizeof ArrayIntMap value type.
     */
    int                            valueTypeSize;

    /**
     * Store all ArrayIntMapElements.
     */
    ArrayList(ArrayIntMapElement*) elementList[1];
}
ArrayIntMap;


/**
 * Control ArrayIntMap.
 */
struct AArrayIntMap
{
    ArrayIntMap* (*Create)            (int valueTypeSize);
    void         (*Init)              (int valueTypeSize, ArrayIntMap* outArrayIntMap);

    ArrayIntMap* (*CreateWithCapacity)(int valueTypeSize, int capacity);
    void         (*InitWithCapacity)  (int valueTypeSize, int capacity, ArrayIntMap* outArrayIntMap);

    void         (*Release)           (ArrayIntMap* arrayIntMap);

    /**
     * Put key and value of valuePtr into ArrayIntMap.
     *
     * valuePtr: point to value that will copy in ArrayIntMapElement
     *
     * if key not exist in ArrayIntMap
     *     return valuePtr in ArrayIntMap
     * else
     *     return NULL
     */
    void*        (*TryPut)            (ArrayIntMap* arrayIntMap, intptr_t key, void* valuePtr);


    /**
     * Get valuePtr by key, if no key found return defaultValuePtr.
     */
    void*        (*Get)               (ArrayIntMap* arrayIntMap, intptr_t key, void* defaultValuePtr);


    /**
     * Try set new value of valuePtr to element by key.
     *
     * if key exist in ArrayIntMap
     *     return valuePtr in ArrayIntMap
     * else
     *     return NULL
     */
    void*        (*TrySet)            (ArrayIntMap* arrayIntMap, intptr_t key, void* valuePtr);


    /**
     * Remove element by key.
     * return true success, false failed.
     */
    bool         (*TryRemove)         (ArrayIntMap* arrayIntMap, intptr_t key);
    
    
    /**
     * Clear all elements, reset size 0, and keep memory space.
     */
    void         (*Clear)             (ArrayIntMap* arrayIntMap);
    
    
    /**
     *  Insert value of valuePtr at index, the possible index is (-getIndex() - 1).
     *  return valuePtr in ArrayIntMap
     */
    void*        (*InsertAt)          (ArrayIntMap* arrayIntMap, intptr_t key, int index, void* valuePtr);


    /**
     * Get index of key.
     * if negative means not found the element by key, and return (-insertIndex - 1),
     * so the insert index is (-getIndex() - 1).
     */
    int          (*GetIndex)          (ArrayIntMap* arrayIntMap, intptr_t key);


    /**
     * Get Key at index.
     */
    intptr_t     (*GetKey)            (ArrayIntMap* arrayIntMap, int index);


    /**
     * Get valuePtr at index.
     */
    void*        (*GetAt)             (ArrayIntMap* arrayIntMap, int index);


    /**
     * Set value of valuePtr at index.
     * return valuePtr in ArrayIntMap.
     */
    void*        (*SetAt)             (ArrayIntMap* arrayIntMap, int index, void* valuePtr);


    /**
     * Remove value at index
     */
    void         (*RemoveAt)          (ArrayIntMap* arrayIntMap, int index);
};


extern struct AArrayIntMap AArrayIntMap[1];


/**
 * Marked ArrayIntMap key and value.
 */
#define ArrayIntMap(keyName, ValueType) ArrayIntMap


/**
 * Init constant ArrayIntMap.
 * example: ArrayIntMap map[1] = AArrayIntMap_Init(ValueType, increase)
 */
#define AArrayIntMap_Init(ValueType, increase)          \
    {                                                   \
        sizeof(ValueType),                              \
        AArrayList_Init(ArrayIntMapElement*, increase), \
    }                                                   \


/**
 * Shortcut of AArrayIntMap->TryPut.
 */
#define AArrayIntMap_TryPut(arrayIntMap, key, value) \
    AArrayIntMap->TryPut(arrayIntMap, (intptr_t) (key), &(value))


/**
 * Shortcut of AArrayIntMap->Get with type.
 * return value.
 */
#define AArrayIntMap_Get(arrayIntMap, key, ValueType) \
    (*(ValueType*) AArrayIntMap->Get(arrayIntMap, (intptr_t) (key), NULL_PTR))


/**
 * Shortcut of AArrayIntMap->Get with type.
 * return valuePtr.
 */
#define AArrayIntMap_GetPtr(arrayIntMap, key, ValueType) \
    ((ValueType*) AArrayIntMap->Get(arrayIntMap, (intptr_t) (key), NULL))


/**
 * Shortcut of AArrayIntMap->TrySet.
 */
#define AArrayIntMap_TrySet(arrayIntMap, key, value) \
    AArrayIntMap->TrySet(arrayIntMap, (intptr_t) (key), &(value))


/**
 * Shortcut of AArrayIntMap->InsertAt.
 */
#define AArrayIntMap_InsertAt(arrayIntMap, key, index, value) \
    AArrayIntMap->InsertAt(arrayIntMap, (intptr_t) (key), index, &(value))


/**
 * Shortcut of AArrayIntMap->GetAt.
 * return value.
 */
#define AArrayIntMap_GetAt(arrayIntMap, index, ValueType) \
   (*(ValueType*) AArrayIntMap->GetAt(arrayIntMap, index))


/**
 * Shortcut of AArrayIntMap->GetAt.
 * return valuePtr.
 */
#define AArrayIntMap_GetPtrAt(arrayIntMap, index, ValueType) \
   ((ValueType*) AArrayIntMap->GetAt(arrayIntMap, index))


/**
 * Shortcut of AArrayIntMap->SetAt.
 */
#define AArrayIntMap_SetAt(arrayIntMap, index, value) \
    AArrayIntMap->SetAt(arrayIntMap, index, &(value))


#endif

```

`Engine/Toolkit/Utils/ArrayIntSet.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-4-23
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#include <stdlib.h>
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Toolkit/Utils/ArrayIntSet.h"


/**
 * Search index of key, if negative not found then return "-insertIndex - 1",
 * so insert index is "-BinarySearch() - 1".
 */
static inline int BinarySearch(ArrayList(intptr_t)* elementList, intptr_t key)
{
    int high  = elementList->size;
    int low   = -1;
    int guess = -1;

    while (high - low > 1) // prevent infinite loops
    {
        // (high + low) always positive, so convert to unsigned
        // then the '>>' is unsigned move right
        // so the overflow will be handled correctly
        // because sign bit shift to right and 0 will be added
        guess            = (unsigned int) (high + low) >> 1;
        intptr_t element = AArrayList_Get(elementList, guess, intptr_t);

        if (element < key)
        {
            low  = guess;
        }
        else if (element > key)
        {
            high = guess;
        }
        else if (element == key)
        {
            // find the key, the guess is positive value
            return guess;
        }
    }

    // if guess == high
    // the guess is bigger than key index and insert at guess

    if (guess == low)
    {
        // the guess is smaller than key index and insert behind,
        // or if list empty then guess is -1, also do this make guess at 0
        ++guess;
    }

    // when list empty guess is 0, so we -1 make sure return negative value
    return -guess - 1;
}


static void Release(ArrayIntSet* arrayIntSet)
{
    AArrayList->Release(arrayIntSet->elementList);
}


static void InitWithCapacity(int capacity, ArrayIntSet* arrayIntSet)
{
    if (capacity == 0)
    {
        AArrayList->Init(sizeof(intptr_t), arrayIntSet->elementList);
    }
    else
    {
        AArrayList->InitWithCapacity(sizeof(intptr_t), capacity, arrayIntSet->elementList);
    }
}


static ArrayIntSet* CreateWithCapacity(int capacity)
{
    ArrayIntSet* arrayIntSet = malloc(sizeof(ArrayIntSet));
    InitWithCapacity(capacity, arrayIntSet);

    return arrayIntSet;
}


static void Init(ArrayIntSet* arrayIntSet)
{
    InitWithCapacity(0, arrayIntSet);
}


static ArrayIntSet* Create()
{
    return CreateWithCapacity(0);
}


static bool TryAdd(ArrayIntSet* arrayIntSet, intptr_t element)
{
    int guess = BinarySearch(arrayIntSet->elementList, element);

    if (guess < 0)
    {
        AArrayList_Insert(arrayIntSet->elementList, -guess - 1, element);
        return true;
    }
    else
    {
        return false;
    }
}


static bool TryRemove(ArrayIntSet* arrayIntSet, intptr_t element)
{
    int guess = BinarySearch(arrayIntSet->elementList, element);

    if (guess >= 0)
    {
        AArrayList->Remove(arrayIntSet->elementList, guess);
        return true;
    }

    return false;
}


static bool IsContains(ArrayIntSet* arrayIntSet, intptr_t element)
{
    return  BinarySearch(arrayIntSet->elementList, element) >= 0;
}


static void Clear(ArrayIntSet* arrayIntSet)
{
    AArrayList->Clear(arrayIntSet->elementList);
}


struct AArrayIntSet AArrayIntSet[1] =
{{
    Create,
    Init,
    CreateWithCapacity,
    InitWithCapacity,
    Release,
    TryAdd,
    TryRemove,
    IsContains,
    Clear,
}};
```

`Engine/Toolkit/Utils/ArrayIntSet.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-4-23
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#ifndef ARRAY_INT_SET_H
#define ARRAY_INT_SET_H


#include <stdbool.h>
#include <stdint.h>
#include "Engine/Toolkit/Utils/ArrayList.h"


/**
 * A set of elements that not repeated and ordered by element's int value.
 * element type must compatible with integer.
 */
typedef struct
{
    /**
     * Store all Elements.
     */
    ArrayList(intptr_t) elementList[1];
}
ArrayIntSet;


/**
 * Control ArrayIntSet.
 */
struct AArrayIntSet
{
    ArrayIntSet* (*Create)            (void);
    void         (*Init)              (ArrayIntSet* outArrayIntSet);

    ArrayIntSet* (*CreateWithCapacity)(int capacity);
    void         (*InitWithCapacity)  (int capacity, ArrayIntSet* outArrayIntSet);

    void         (*Release)           (ArrayIntSet* arrayIntSet);

    /**
     * Add no repeat element to ArrayIntSet.
     *
     * if element not exist in ArrayIntSet
     *    return true
     * else
     *    return false
     */
    bool         (*TryAdd)            (ArrayIntSet* arrayIntSet, intptr_t element);

    /**
     * If remove success return true else failed.
     */
    bool         (*TryRemove)         (ArrayIntSet* arrayIntSet, intptr_t element);

    /**
     * If element already in ArrayIntSet return true else not contains.
     */
    bool         (*IsContains)        (ArrayIntSet* arrayIntSet, intptr_t element);

    /**
     * Clear all elements, reset size to 0, and keep memory space.
     */
    void         (*Clear)             (ArrayIntSet* arrayIntSet);
};


extern struct AArrayIntSet AArrayIntSet[1];


/**
 * Marked ArrayIntSet element type.
 * element type must compatible with integer.
 */
#define ArrayIntSet(ElementType) ArrayIntSet


/**
 * Init constant ArrayIntSet.
 * example: ArrayIntSet set[1] = AArrayIntSet_Init(ElementType, increase)
 */
#define AArrayIntSet_Init(ElementType, increase) \
    {                                            \
         AArrayList_Init(intptr_t, increase),    \
    }


#endif

```

`Engine/Toolkit/Utils/ArrayList.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-2-4
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#include <string.h>
#include <stdlib.h>
#include "Engine/Toolkit/Utils/ArrayList.h"
#include "Engine/Toolkit/Platform/Log.h"


#define CheckIndex(tag, index)                                          \
    ALog_A                                                              \
    (                                                                   \
        ((index) < arrayList->size && (index) >= 0),                    \
        "AArrayList " tag " failed index error, index = %d, size = %d", \
        index,                                                          \
        arrayList->size                                                 \
    )                                                                    


#define CheckInsertIndex(tag)                                           \
    ALog_A                                                              \
    (                                                                   \
        ((index) <= arrayList->size && (index) >= 0),                   \
        "AArrayList " tag " failed index error, index = %d, size = %d", \
        index,                                                          \
        arrayList->size                                                 \
    )


static inline void AddCapacity(ArrayList* arrayList, int increase)
{
    ALog_A(increase > 0, "AArrayList AddCapacity failed, increase = %d cannot <= 0", increase);

    void* data = realloc
                 (
                     arrayList->elementArr->data,
                     (size_t) (increase + arrayList->elementArr->length) * arrayList->elementTypeSize
                 );

    ALog_A
    (
        data != NULL,
        "AArrayList AddCapacity failed, unable to realloc memory, size = %d, length = %d, increase = %d",
        arrayList->size, arrayList->elementArr->length, increase
    );

    arrayList->elementArr->data    = data;
    arrayList->elementArr->length += increase;
}


static void* GetAdd(ArrayList* arrayList)
{
    if (arrayList->size == arrayList->elementArr->length)
    {
        AddCapacity(arrayList, arrayList->increase);
    }

    return (char*) arrayList->elementArr->data + arrayList->elementTypeSize * (arrayList->size++);
}


static void* GetInsert(ArrayList* arrayList, int index)
{
    // insert index can equal size
    CheckInsertIndex("GetInsert");

    if (arrayList->size == arrayList->elementArr->length)
    {
        AddCapacity(arrayList, arrayList->increase);
    }

    void* from = (char*) arrayList->elementArr->data + arrayList->elementTypeSize * index;
    void* to   = (char*) from                        + arrayList->elementTypeSize;

    // from and to overlap so cannot use memcpy
    memmove(to, from, (size_t) arrayList->elementTypeSize * ((arrayList->size++) - index));

    return from;
}


static void* Add(ArrayList* arrayList, void* elementPtr)
{
    return memcpy(GetAdd(arrayList), elementPtr, (size_t) arrayList->elementTypeSize);
}


static void* Insert(ArrayList* arrayList, int index, void* elementPtr)
{
    return memcpy(GetInsert(arrayList, index), elementPtr, (size_t) arrayList->elementTypeSize);
}


/**
 * Use macro instead.
 * Redundancy is better so don't delete.
 */
static void* Get(ArrayList* arrayList, int index)
{
    CheckIndex("Get", index);
    return (char*) arrayList->elementArr->data + arrayList->elementTypeSize * index;
}


/**
 * Use macro instead.
 * Redundancy is better so don't delete.
 */
static void Set(ArrayList* arrayList, int index, void* elementPtr)
{
    CheckIndex("Set", index);
    memcpy
    (
        (char*)  arrayList->elementArr->data + arrayList->elementTypeSize * index,
        elementPtr,
        (size_t) arrayList->elementTypeSize
    );
}



static void* Pop(ArrayList* arrayList, void* defaultElementPtr)
{
    if (arrayList->size > 0)
    {
        // now size equal last index
        return (char*) arrayList->elementArr->data + arrayList->elementTypeSize * (--arrayList->size);
    }
    else
    {
        return defaultElementPtr;
    }
}


static void AddArray(ArrayList* arrayList, void* data, int length, int elementTypeSize)
{
    ALog_A
    (
        arrayList->elementTypeSize == elementTypeSize,
        "AArrayList AddArray arrayList elementTypeSize = %d must equal Array elementTypeSize = %d",
        arrayList->elementTypeSize,
        elementTypeSize
    );

    int n = arrayList->elementArr->length - arrayList->size - length;

    if (n < 0)
    {
        AddCapacity(arrayList, -n + arrayList->increase);
    }

    memcpy
    (
        (char*)  arrayList->elementArr->data + arrayList->elementTypeSize * arrayList->size,
        data,
        (size_t) arrayList->elementTypeSize  * length
    );

    arrayList->size += length;
}


static void Remove(ArrayList* arrayList, int index)
{
    CheckIndex("Remove", index);

    // now size equal last index
    --arrayList->size;

    if (index != arrayList->size)
    {
        void* to   = (char*) arrayList->elementArr->data + arrayList->elementTypeSize * index;
        void* from = (char*) to                          + arrayList->elementTypeSize;

        // move between index and last index element
        memcpy(to, from,  (size_t) arrayList->elementTypeSize * (arrayList->size - index));
    }
}


static void RemoveRange(ArrayList* arrayList, int fromIndex, int toIndex)
{
    CheckIndex("RemoveRange", fromIndex);
    CheckIndex("RemoveRange", toIndex);
    ALog_A    (toIndex >=     fromIndex, "AArrayList RemoveRange toIndex must more than fromIndex");

    int num          = toIndex         - fromIndex + 1;
    int lastIndex    = arrayList->size - 1;

    arrayList->size -= num;

    if (toIndex != lastIndex)
    {
        void* to    = (char*) arrayList->elementArr->data + arrayList->elementTypeSize * fromIndex;
        void* from  = (char*) to                          + arrayList->elementTypeSize * num;

        // move between lastIndex and toIndex element
        memcpy(to, from, (size_t) arrayList->elementTypeSize * (lastIndex - toIndex));
    }
}


static void RemoveByLast(ArrayList* arrayList, int index)
{
    CheckIndex("RemoveByLast", index);

    // now size equal last index
    --arrayList->size;

    if (index != arrayList->size)
    {
        memcpy
        (
            (char*)  arrayList->elementArr->data + arrayList->elementTypeSize * index,
            (char*)  arrayList->elementArr->data + arrayList->elementTypeSize * arrayList->size,
            (size_t) arrayList->elementTypeSize
        );
    }
}


static void Clear(ArrayList* arrayList)
{
    arrayList->size = 0;
}


static void Shrink(ArrayList* arrayList)
{
    if (arrayList->size == 0)
    {
        free(arrayList->elementArr->data);
        arrayList->elementArr->data   = NULL;
        arrayList->elementArr->length = 0;
    }
    else
    {
        void* data = realloc(arrayList->elementArr->data, (size_t) arrayList->size * arrayList->elementTypeSize);
        ALog_A(data, "AArrayList Shrink error, size = %d ", arrayList->size);

        arrayList->elementArr->data   = data;
        arrayList->elementArr->length = arrayList->size;
    }
}


static void Release(ArrayList* arrayList)
{
    free(arrayList->elementArr->data);
    arrayList->elementArr->data   = NULL;
    arrayList->elementArr->length = 0;
    arrayList->size                 = 0;
}


static void SetSize(ArrayList* arrayList, int size)
{
    arrayList->size = size;

    if (arrayList->elementArr->length < size)
    {
        AddCapacity(arrayList, size - arrayList->elementArr->length);
    }
}


static void SetCapacity(ArrayList* arrayList, int capacity)
{
    if (arrayList->elementArr->length < capacity)
    {
        AddCapacity(arrayList, capacity - arrayList->elementArr->length);
    }
}


static inline void InitArrayList(int elementTypeSize, ArrayList* arrayList)
{
    arrayList->elementArr->data   = NULL;
    arrayList->elementArr->length = 0;
    arrayList->elementTypeSize    = elementTypeSize;
    arrayList->size               = 0;
    arrayList->increase           = 20;
}


static ArrayList* Create(int elementTypeSize)
{
    ArrayList* arrayList = malloc(sizeof(ArrayList));
    InitArrayList(elementTypeSize, arrayList);
    
    return arrayList;
}


static void Init(int elementTypeSize, ArrayList* outArrayList)
{
    InitArrayList(elementTypeSize, outArrayList);
}


static ArrayList* CreateWithSize(int elementTypeSize, int size)
{
    ArrayList* arrayList = Create(elementTypeSize);
    SetSize(arrayList, size);

    return arrayList;
}


static void InitWithSize(int elementTypeSize, int size, ArrayList* outArrayList)
{
    InitArrayList(elementTypeSize, outArrayList);
    SetSize(outArrayList, size);
}


static ArrayList* CreateWithCapacity(int elementTypeSize, int capacity)
{
    ArrayList* arrayList = Create(elementTypeSize);
    SetCapacity(arrayList, capacity);
    
    return arrayList;
}


static void InitWithCapacity(int elementTypeSize, int capacity, ArrayList* outArrayList)
{
    InitArrayList(elementTypeSize, outArrayList);
    SetCapacity(outArrayList, capacity);
}


struct AArrayList AArrayList[1] =
{{
    Create,
    Init,
    CreateWithSize,
    InitWithSize,
    CreateWithCapacity,
    InitWithCapacity,

    Release,

    GetAdd,
    GetInsert,
    Add,
    Insert,
    Pop,
    AddArray,
    Remove,
    RemoveRange,
    RemoveByLast,
    Clear,
    Shrink,
    SetSize,
    SetCapacity,
}};


#undef CheckIndex
#undef CheckInsertIndex

```

`Engine/Toolkit/Utils/ArrayList.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-2-4
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#ifndef ARRAY_LIST_H
#define ARRAY_LIST_H


#include "Engine/Toolkit/Utils/Array.h"


/**
 * The list can dynamically increase memory capacity that implemented by array.
 */
typedef struct
{
    /**
     * Increase memory space when needed, default 10.
     */
    int   increase;

    /**
     * The sizeof element type.
     */
    int   elementTypeSize;

    /**
     * Elements count.
     */
    int   size;

    /**
     * Store memory data, the length is memory capacity.
     * if increase capacity, memory data will realloc,
     * so the data address may changed.
     */
    Array elementArr[1];
}
ArrayList;


/**
 * Control ArrayList.
 */
struct AArrayList
{
    ArrayList* (*Create)            (int elementTypeSize);
    void       (*Init)              (int elementTypeSize, ArrayList* outArrayList);

    ArrayList* (*CreateWithSize)    (int elementTypeSize, int size);
    void       (*InitWithSize)      (int elementTypeSize, int size, ArrayList* outArrayList);

    ArrayList* (*CreateWithCapacity)(int elementTypeSize, int capacity);
    void       (*InitWithCapacity)  (int elementTypeSize, int capacity, ArrayList* outArrayList);

    void       (*Release)           (ArrayList* arrayList);

    /**
     * Increase one element memory (elementTypeSize data) appended to ArrayList.
     * return elementPtr point the increase element.
     */
    void*      (*GetAdd)            (ArrayList* arrayList);

    /**
     * Increase one element memory (elementTypeSize data) at the index,
     * and move index behind elements one position.
     *
     * index: range in [0, size - 1]
     *
     * return elementPtr point the increase element.
     */
    void*      (*GetInsert)         (ArrayList* arrayList, int index);

    /**
     * Copy element data into getAdd memory.
     * elementPtr: point to element
     *
     * return elementPtr in ArrayList.
     */
    void*      (*Add)               (ArrayList* arrayList, void* elementPtr);

    /**
     * Copy element data into getInsert memory.
     * elementPtr: point to element
     *
     * return elementPtr in ArrayList.
     */
    void*      (*Insert)            (ArrayList* arrayList, int index, void* elementPtr);

    /**
     * Remove last element and return removed elementPtr.
     * if empty return defaultElementPtr.
     */
    void*      (*Pop)               (ArrayList* arrayList, void* defaultElementPtr);

    /**
     * Add copy of array data.
     */
    void       (*AddArray)          (ArrayList* arrayList, void* data, int length, int elementTypeSize);

    /**
     * Remove index of element and move behind elements.
     */
    void       (*Remove)            (ArrayList* arrayList, int index);

    /**
     * Remove a range [fromIndex, toIndex] of elements.
     */
    void       (*RemoveRange)       (ArrayList* arrayList, int fromIndex, int toIndex);

    /**
     * Remove index of element and replace last element to the index. (no need to move any elements)
     */
    void       (*RemoveByLast)      (ArrayList* arrayList, int index);

    /**
     * Clear size to 0, keep memory space.
     */
    void       (*Clear)             (ArrayList* arrayList);

    /**
     * Release not used memory data which is after ArrayList size.
     * if ArrayList size is 0 will be free all memory data.
     */
    void       (*Shrink)            (ArrayList* arrayList);

    /**
     * Set ArrayList size and increase capacity if needed.
     */
    void       (*SetSize)           (ArrayList* arrayList, int size);

    /**
     * Set ArrayList capacity and increase capacity if needed.
     */
    void       (*SetCapacity)       (ArrayList* arrayList, int capacity);
};


extern struct AArrayList AArrayList[1];


/**
 * Marked ArrayList element type.
 * ElementType: element data type
 */
#define ArrayList(ElementType) ArrayList


/**
 * Init constant ArrayList.
 * example: ArrayList list[1] = AArrayList_Init(ElementType, increase)
 */
#define AArrayList_Init(ElementType, increase) \
    {                                          \
        increase,                              \
        sizeof(ElementType),                   \
        0,                                     \
        {                                      \
            NULL,                              \
            0,                                 \
        },                                     \
    }


/**
 * Init constant ArrayList with fixed capacity, unable to expansion capacity.
 * example: ArrayList list[1] = AArayList_InitFixed(ElementType, capacity, size, ...)
 */
#define AArayList_InitFixed(ElementType, capacity, size, ...) \
    {                                                         \
        0,                                                    \
        sizeof(ElementType),                                  \
        size,                                                 \
        AArray_Init(ElementType, capacity, __VA_ARGS__),      \
    }


/**
 * Shortcut of AArrayList->GetAdd.
 * return element.
 */
#define AArrayList_GetAdd(arrayList, ElementType) \
    (*(ElementType*) AArrayList->GetAdd(arrayList))


/**
 * Shortcut of AArrayList->GetAdd.
 * return elementPtr.
 */
#define AArrayList_GetPtrAdd(arrayList, ElementType) \
    ((ElementType*) AArrayList->GetAdd(arrayList))


/**
 * Shortcut of AArrayList->GetInsert.
 * return element.
 */
#define AArrayList_GetInsert(arrayList, index, ElementType) \
    (*(ElementType*) AArrayList->GetInsert(arrayList, index))


/**
 * Shortcut of AArrayList->GetInsert.
 * return elementPtr.
 */
#define AArrayList_GetPtrInsert(arrayList, index, ElementType) \
    ((ElementType*) AArrayList->GetInsert(arrayList, index))


/**
 * Shortcut of AArrayList->Add.
 */
#define AArrayList_Add(arrayList, element) \
    AArrayList->Add(arrayList, &(element))


/**
 * Shortcut of AArrayList->Insert.
 */
#define AArrayList_Insert(arrayList, index, element) \
    AArrayList->Insert(arrayList, index, &(element))


/**
 * Get the type ptr of elements.
 */
#define AArrayList_GetData(arrayList, ElementType) \
    ((ElementType*) ((arrayList)->elementArr->data))


/**
 * Get the element with type.
 */
#define AArrayList_Get(arrayList, index, ElementType) \
    (AArrayList_GetData(arrayList, ElementType))[index]


/**
 * Get the elementPtr with type.
 */
#define AArrayList_GetPtr(arrayList, index, ElementType) \
    (AArrayList_GetData(arrayList, ElementType) + (index))


/**
 * Shortcut of AArrayList->Pop.
 * return element.
 */
#define AArrayList_PopWithDefault(arrayList, ElementType, defaultValue) \
    (*(ElementType*) AArrayList->Pop(arrayList, &(defaultValue)))


/**
 * Set the element at index.
 */
#define AArrayList_Set(arrayList, index, element, ElementType) \
    AArrayList_Get(arrayList, index, ElementType) = element


/**
 * Shortcut of AArrayList->Pop
 * return element
 */
#define AArrayList_Pop(arrayList, ElementType) \
    (*(ElementType*) AArrayList->Pop(arrayList, NULL_PTR))

#endif

```

`Engine/Toolkit/Utils/ArrayQueue.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-6-5
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#include <stdlib.h>
#include "Engine/Toolkit/Utils/ArrayQueue.h"
#include "Engine/Toolkit/Platform/Log.h"


static void* Enqueue(ArrayQueue* arrayQueue, void* elementPtr)
{
    if (arrayQueue->headIndex > 0 && arrayQueue->headIndex == arrayQueue->elementList->elementArr->length)
    {
        AArrayList->RemoveRange(arrayQueue->elementList, 0, arrayQueue->headIndex - 1);
        arrayQueue->headIndex = 0;
    }

    return AArrayList->Add(arrayQueue->elementList, elementPtr);
}


static void* Dequeue(ArrayQueue* arrayQueue, void* defaultElementPtr)
{
    if (arrayQueue->headIndex == arrayQueue->elementList->size)
    {
        return defaultElementPtr;
    }

    return (char*) arrayQueue->elementList->elementArr->data +
                   arrayQueue->elementList->elementTypeSize  *
                   (arrayQueue->headIndex++);
}


static void RemoveAt(ArrayQueue* arrayQueue, int index)
{
    ALog_A
    (
        index >= arrayQueue->headIndex && index < arrayQueue->elementList->size,
        "AArrayQueue RemoveAt index = %d, out of range [%d, %d]",
        index, arrayQueue->headIndex, arrayQueue->elementList->size - 1
    );

    AArrayList->Remove(arrayQueue->elementList, index);
}


static void Release(ArrayQueue* arrayQueue)
{
    arrayQueue->headIndex = 0;
    AArrayList->Release(arrayQueue->elementList);
}


static void InitWithCapacity(int elementTypeSize, int capacity, ArrayQueue* outArrayQueue)
{
    if (capacity == 0)
    {
        AArrayList->Init(elementTypeSize, outArrayQueue->elementList);
    }
    else
    {
        AArrayList->InitWithCapacity(elementTypeSize, capacity, outArrayQueue->elementList);
    }

    outArrayQueue->headIndex = 0;
}


static ArrayQueue* CreateWithCapacity(int elementTypeSize, int capacity)
{
    ArrayQueue* arrayQueue = malloc(sizeof(ArrayQueue));
    InitWithCapacity(elementTypeSize, capacity, arrayQueue);

    return arrayQueue;
}


static void Init(int elementTypeSize, ArrayQueue* outArrayQueue)
{
    InitWithCapacity(elementTypeSize, 0, outArrayQueue);
}


static ArrayQueue* Create(int elementTypeSize)
{
    return CreateWithCapacity(elementTypeSize, 0);
}


static void Clear(ArrayQueue* arrayQueue)
{
    arrayQueue->headIndex = 0;
    AArrayList->Clear(arrayQueue->elementList);
}


struct AArrayQueue AArrayQueue[1] =
{{
    Create,
    Init,
    CreateWithCapacity,
    InitWithCapacity,
    Release,

    Enqueue,
    Dequeue,
    RemoveAt,
    Clear,
}};

```

`Engine/Toolkit/Utils/ArrayQueue.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-6-5
 * Update   : 2019-1-17
 * Author   : scott.cgi
 */


#ifndef ARRAY_QUEUE_H
#define ARRAY_QUEUE_H


#include "Engine/Toolkit/Utils/ArrayList.h"


/**
 * The queue implementation by array.
 */
typedef struct
{
    /**
     * ArrayQueue head element index.
     */
    int       headIndex;

    /**
     * Store all elements.
     */
    ArrayList elementList[1];
}
ArrayQueue;


/**
 * Control ArrayQueue.
 */
struct AArrayQueue
{
    ArrayQueue* (*Create)            (int elementTypeSize);
    void        (*Init)              (int elementTypeSize, ArrayQueue* outArrayQueue);

    ArrayQueue* (*CreateWithCapacity)(int elementTypeSize, int capacity);
    void        (*InitWithCapacity)  (int elementTypeSize, int capacity, ArrayQueue* outArrayQueue);

    void        (*Release)           (ArrayQueue* arrayQueue);

    /**
     * Add the element from elementPtr to the tail of ArrayQueue.
     * elementPtr: point to element
     *
     * return the elementPtr in ArrayQueue.
     */
    void*       (*Enqueue)           (ArrayQueue* arrayQueue, void* elementPtr);

    /**
     * Remove the element from the head of ArrayQueue.
     * return the head elementPtr of the ArrayQueue, if no element return defaultElementPtr.
     */
    void*       (*Dequeue)           (ArrayQueue* arrayQueue, void* defaultElementPtr);

    /**
     * Remove the element at index that range in [headIndex, ArrayQueue size - 1].
     */
    void        (*RemoveAt)          (ArrayQueue* arrayQueue, int   index);

    /**
     * Clear all elements, and reset headIndex to 0.
     */
    void        (*Clear)             (ArrayQueue* arrayQueue);
};


extern struct AArrayQueue AArrayQueue[1];


/**
 * Marked ArrayQueue element type.
 * ElementType: element data type
 */
#define ArrayQueue(ElementType) ArrayQueue


/**
 * Init constant ArrayQueue.
 * example: ArrayQueue queue[1] = AArrayQueue_Init(ElementType, increase)
 */
#define AArrayQueue_Init(ElementType, increase)  \
    {                                           \
        0,                                      \
        AArrayList_Init(ElementType, increase), \
    }


/**
 * Shortcut of AArrayQueue->Enqueue.
 */
#define AArrayQueue_Enqueue(arrayQueue, element) \
    AArrayQueue->Enqueue(arrayQueue, &(element))


/**
 * Shortcut of AArrayQueue->Dequeue.
 * return element.
 */
#define AArrayQueue_Dequeue(arrayQueue, ElementType) \
    (*(ElementType*) AArrayQueue->Dequeue(arrayQueue, NULL_PTR))


/**
 * Shortcut of AArrayQueue->Dequeue.
 * return element.
 */
#define AArrayQueue_DequeueWithDefault(arrayQueue, ElementType, defaultValue) \
    (*(ElementType*) AArrayQueue->Dequeue(arrayQueue, &(defaultValue)))


/**
 * Shortcut of AArrayQueue->Dequeue.
 * return elementPtr.
 */
#define AArrayQueue_DequeuePtr(arrayQueue, ElementType) \
    ((ElementType*) AArrayQueue->Dequeue(arrayQueue, NULL))


/**
 * Shortcut of AArrayQueue->Dequeue.
 * return elementPtr.
 */
#define AArrayQueue_DequeuePtrWithDefault(arrayQueue, ElementType, defaultValue) \
    ((ElementType*) AArrayQueue->Dequeue(arrayQueue, &(defaultValue)))


#endif

```

`Engine/Toolkit/Utils/ArrayStrMap.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-5-20
 * Update   : 2019-1-14
 * Author   : scott.cgi
 */


#include <string.h>
#include <stdlib.h>
#include "Engine/Toolkit/Utils/ArrayStrMap.h"
#include "Engine/Toolkit/Platform/Log.h"


#define CheckIndex(tag)                                        \
    ALog_A                                                     \
    (                                                          \
        index >= 0 && index < arrayStrMap->elementList->size,  \
        "AArrayStrMap " tag " index = %d, size = %d, invalid", \
        index,                                                 \
        arrayStrMap->elementList->size                         \
    )


#define CheckInsertIndex(tag)                                  \
    ALog_A                                                     \
    (                                                          \
        index >= 0 && index <= arrayStrMap->elementList->size, \
        "AArrayStrMap " tag " index = %d, size = %d, invalid", \
        index,                                                 \
        arrayStrMap->elementList->size                         \
    )


/**
 * Search index of key, if negative not found then return "-insertIndex - 1",
 * so insert index is "-BinarySearch() - 1".
 */
static inline int BinarySearch(ArrayList(ArrayStrMapElement)* elementList, const char* key, int keyLength)
{
    int high  = elementList->size;
    int low   = -1;
    int guess = -1;

    while (high - low > 1) // prevent infinite loops
    {
        // (high + low) always positive, so convert to unsigned
        // then the '>>' is unsigned move right
        // so the overflow will be handled correctly
        // because sign bit shift to right and 0 will be added
        guess                       = (unsigned int) (high + low) >> 1;
        ArrayStrMapElement* element = AArrayList_Get(elementList, guess, ArrayStrMapElement*);

        if (element->keyLength < keyLength)
        {
            low  = guess;
        }
        else if (element->keyLength > keyLength)
        {
            high = guess;
        }
        else if (element->keyLength == keyLength)
        {
            int cmp = memcmp(element->key, key, (size_t) keyLength);

            if (cmp < 0)
            {
                low  = guess;
            }
            else if (cmp > 0)
            {
                high = guess;
            }
            else if (cmp == 0)
            {
                // find the key, the guess is positive value
                return guess;
            }
        }
     }

    // if guess == high
    // the guess is bigger than key index and insert value at guess

    if (guess == low)
    {
        // the guess is smaller than key index and insert value behind,
        // or if list empty then the guess is -1, also do this make guess at 0
        ++guess;
    }

    // when list empty the guess is 0, so we -1 make sure return negative value
    return -guess - 1;
}


//----------------------------------------------------------------------------------------------------------------------


static void* TryPut(ArrayStrMap* arrayStrMap, const char* key, void* valuePtr)
{
    int keyLength = (int) strlen(key) + 1;
    int guess     = BinarySearch(arrayStrMap->elementList, key, keyLength);

    if (guess < 0)
    {
        int                 valueTypeSize = arrayStrMap->valueTypeSize;
        ArrayStrMapElement* element       = malloc(sizeof(ArrayStrMapElement) + valueTypeSize + keyLength);
        element->keyLength                = keyLength;
        element->valuePtr                 = (char*) element + sizeof(ArrayStrMapElement);
        element->key                      = (char*) element->valuePtr + valueTypeSize;
        
        memcpy((void*) element->key, key, (size_t) keyLength);
        AArrayList_Insert(arrayStrMap->elementList, -guess - 1, element);

        return memcpy(element->valuePtr, valuePtr, (size_t) valueTypeSize);
    }
    else
    {
        return NULL;
    }
}


static void* Get(ArrayStrMap* arrayStrMap, const char* key, void* defaultValuePtr)
{
    int guess = BinarySearch(arrayStrMap->elementList, key, (int) strlen(key) + 1);

    return guess >= 0 ?
           AArrayList_Get(arrayStrMap->elementList, guess, ArrayStrMapElement*)->valuePtr : defaultValuePtr;
}


static void* TrySet(ArrayStrMap* arrayStrMap, const char* key, void* valuePtr)
{
    int guess = BinarySearch(arrayStrMap->elementList, key, (int) strlen(key) + 1);

    if (guess >= 0)
    {
        return memcpy
               (
                   AArrayList_Get(arrayStrMap->elementList, guess, ArrayStrMapElement*)->valuePtr,
                   valuePtr,
                   (size_t) arrayStrMap->valueTypeSize
               );
    }
    else
    {
        return NULL;
    }
}


static bool TryRemove(ArrayStrMap* arrayStrMap, const char* key)
{
    int guess = BinarySearch(arrayStrMap->elementList, key, (int) strlen(key) + 1);

    if (guess >= 0)
    {
        free(AArrayList_Get(arrayStrMap->elementList, guess, ArrayStrMapElement*));
        AArrayList->Remove(arrayStrMap->elementList, guess);

        return true;
    }

    return false;
}


static void Clear(ArrayStrMap* arrayStrMap)
{
    for (int i = 0; i < arrayStrMap->elementList->size; ++i)
    {
        free(AArrayList_Get(arrayStrMap->elementList, i, ArrayStrMapElement*));
    }

    AArrayList->Clear(arrayStrMap->elementList);
}


static void* InsertAt(ArrayStrMap* arrayStrMap, const char* key, int index, void* valuePtr)
{
    CheckInsertIndex("InsertAt");

    int keyLength     = (int) strlen(key) + 1;
    int valueTypeSize = arrayStrMap->valueTypeSize;

    ArrayStrMapElement* element = malloc(sizeof(ArrayStrMapElement) + valueTypeSize + keyLength);
    element->keyLength          = keyLength;
    element->valuePtr           = (char*) element + sizeof(ArrayStrMapElement);
    element->key                = (char*) element->valuePtr + valueTypeSize;
    
    memcpy((void*) element->key, key, (size_t) keyLength);
    AArrayList_Insert( arrayStrMap->elementList, index, element);

    return memcpy(element->valuePtr, valuePtr, (size_t) valueTypeSize);
}


static int GetIndex(ArrayStrMap* arrayStrMap, const char* key)
{
    return BinarySearch(arrayStrMap->elementList, key, (int) strlen(key) + 1);
}


static const char* GetKey(ArrayStrMap* arrayStrMap, int index)
{
    CheckIndex("GetKey");
    return AArrayList_Get(arrayStrMap->elementList, index, ArrayStrMapElement*)->key;
}


static void* GetAt(ArrayStrMap* arrayStrMap, int index)
{
    CheckIndex("GetAt");
    return AArrayList_Get(arrayStrMap->elementList, index, ArrayStrMapElement*)->valuePtr;
}


static void* SetAt(ArrayStrMap* arrayStrMap, int index, void* valuePtr)
{
    CheckIndex("SetAt");

    return memcpy
           (
               AArrayList_Get(arrayStrMap->elementList, index, ArrayStrMapElement*)->valuePtr,
               valuePtr,
               (size_t) arrayStrMap->valueTypeSize
           );
}


static void RemoveAt(ArrayStrMap* arrayStrMap, int index)
{
    CheckIndex("RemoveAt");

    free(AArrayList_Get(arrayStrMap->elementList, index, ArrayStrMapElement*));
    AArrayList->Remove(arrayStrMap->elementList, index);
}


static void Release(ArrayStrMap* arrayStrMap)
{
    for (int i = 0; i < arrayStrMap->elementList->size; ++i)
    {
        free(AArrayList_Get(arrayStrMap->elementList, i, ArrayStrMapElement*));
    }

    AArrayList->Release(arrayStrMap->elementList);
}


static void InitWithCapacity(int valueTypeSize, int capacity, ArrayStrMap* outArrayStrMap)
{
    if (capacity == 0)
    {
        AArrayList->Init(sizeof(ArrayStrMapElement*), outArrayStrMap->elementList);
    }
    else
    {
        AArrayList->InitWithCapacity(sizeof(ArrayStrMapElement*), capacity, outArrayStrMap->elementList);
    }

    outArrayStrMap->valueTypeSize = valueTypeSize;
}


static ArrayStrMap* CreateWithCapacity(int valueTypeSize, int capacity)
{
    ArrayStrMap* arrayStrMap = malloc(sizeof(ArrayStrMap));
    InitWithCapacity(valueTypeSize, capacity, arrayStrMap);

    return arrayStrMap;
}


static void Init(int valueTypeSize, ArrayStrMap* outArrayStrMap)
{
    InitWithCapacity(valueTypeSize, 0, outArrayStrMap);
}


static ArrayStrMap* Create(int valueTypeSize)
{
    return CreateWithCapacity(valueTypeSize, 0);
}


struct AArrayStrMap AArrayStrMap[1] =
{{
    Create,
    Init,
    CreateWithCapacity,
    InitWithCapacity,

    Release,

    TryPut,
    Get,
    TrySet,
    TryRemove,
    Clear,
    InsertAt,
    GetIndex,
    GetKey,
    GetAt,
    SetAt,
    RemoveAt,
}};


#undef CheckIndex
#undef CheckInsertIndex

```

`Engine/Toolkit/Utils/ArrayStrMap.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-5-20
 * Update   : 2019-1-14
 * Author   : scott.cgi
 */


#ifndef ARRAY_STR_MAP_H
#define ARRAY_STR_MAP_H


#include <stdbool.h>
#include "Engine/Toolkit/Utils/ArrayList.h"


/**
 * The actual element store in ArrayStrMap.
 */
typedef struct
{
    /**
     * ArrayStrMap value's key.
     * the key data will copy into ArrayStrMapElement malloc space.
     */
    const char* key;

    /**
     * The length of key, include '\0'.
     */
    int         keyLength;

    /**
     * ArrayStrMap value pointer.
     * the value data copy into ArrayStrMapElement malloc space.
     */
    void*       valuePtr;
}
ArrayStrMapElement;


/**
 * A list of elements each of which is a k-v pair.
 */
typedef struct
{
    /**
     * The sizeof ArrayStrMap value type.
     */
    int                            valueTypeSize;

    /**
     * Store all ArrayStrMapElements.
     */
    ArrayList(ArrayStrMapElement*) elementList[1];
}
ArrayStrMap;


/**
 * Control ArrayStrMap.
 */
struct AArrayStrMap
{
    ArrayStrMap* (*Create)             (int valueTypeSize);
    void         (*Init)               (int valueTypeSize, ArrayStrMap* outArrayStrMap);

    ArrayStrMap* (*CreateWithCapacity) (int valueTypeSize, int capacity);
    void         (*InitWithCapacity)   (int valueTypeSize, int capacity, ArrayStrMap* outArrayStrMap);

    void         (*Release)            (ArrayStrMap* arrayStrMap);

    /**
     * Try put key and value of valuePtr into ArrayStrMap.
     *
     * valuePtr: point to value.
     *
     * if key not exist in ArrayStrMap
     *     return valuePtr in ArrayStrMap
     * else
     *     return NULL
     */
    void*        (*TryPut)             (ArrayStrMap* arrayStrMap, const char* key, void* valuePtr);

    /**
     * Get valuePtr by key, if no key found return defaultValuePtr.
     */
    void*        (*Get)                (ArrayStrMap* arrayStrMap, const char* key, void* defaultValuePtr);

    /**
     * Try set new value of valuePtr to element by key.
     *
     * if key exist in ArrayStrMap
     *     return valuePtr in ArrayStrMap
     * else
     *     return NULL
     */
    void*        (*TrySet)             (ArrayStrMap* arrayStrMap, const char* key, void* valuePtr);

    /**
     * Remove element by key.
     * return true success, false failed.
     */
    bool         (*TryRemove)          (ArrayStrMap* arrayStrMap, const char* key);

    /**
     * Clear all elements, reset size to 0, and keep memory space.
     */
    void         (*Clear)              (ArrayStrMap* arrayStrMap);

    /**
     * Insert value of valuePtr at index, the possible index is (-getIndex() - 1).
     * return valuePtr in ArrayStrMap.
     */
    void*        (*InsertAt)           (ArrayStrMap* arrayStrMap, const char* key, int index, void* valuePtr);

    /**
     * Get index of key.
     * if negative means not found the element by key, and return (-insertIndex - 1),
     * so the insert index is (-getIndex() - 1).
     */
    int          (*GetIndex)           (ArrayStrMap* arrayStrMap, const char* key);

    /**
     * Get key at index.
     */
    const char*  (*GetKey)             (ArrayStrMap* arrayStrMap, int index);

    /**
     * Get valuePtr at index.
     */
    void*        (*GetAt)              (ArrayStrMap* arrayStrMap, int index);

    /**
     * Set value of valuePtr at index.
     * return valuePtr in ArrayStrMap.
     */
    void*        (*SetAt)              (ArrayStrMap* arrayStrMap, int index, void* valuePtr);

    /**
     * Remove element at index.
     */
    void         (*RemoveAt)           (ArrayStrMap* arrayStrMap, int index);
};


extern struct AArrayStrMap AArrayStrMap[1];


/**
 * Get key in ArrayStrMapElement by valuePtr and valueTypeSize.
 */
static inline const char* AArrayStrMap_GetKey(void* valuePtr, int valueTypeSize)
{
    return (const char*) valuePtr + valueTypeSize;
}


/**
 * Marked ArrayStrMap key and value.
 */
#define ArrayStrMap(keyName, ValueType) ArrayStrMap


/**
 * Init constant ArrayStrMap.
 * example: ArrayStrMap map[1] = AArrayStrMap_Init(ValueType, increase)
 */
#define AArrayStrMap_Init(ValueType, increase)          \
    {                                                   \
        sizeof(ValueType),                              \
        AArrayList_Init(ArrayStrMapElement*, increase), \
    }


/**
 * Shortcut of ArrayStrMap->TryPut.
 */
#define AArrayStrMap_TryPut(arrayStrMap, key, value) \
    AArrayStrMap->TryPut(arrayStrMap, key, &(value))


/**
 * Shortcut of AArrayStrMap->Get.
 * return value.
 */
#define AArrayStrMap_Get(arrayStrMap, key, ValueType) \
    (*(ValueType*) AArrayStrMap->Get(arrayStrMap, key, NULL_PTR))


/**
 * Shortcut of AArrayStrMap->Get.
 * return valuePtr.
 */
#define AArrayStrMap_GetPtr(arrayStrMap, key, ValueType) \
    ((ValueType*) AArrayStrMap->Get(arrayStrMap, key, NULL))


/**
 * Shortcut of AArrayStrMap->TrySet.
 */
#define AArrayStrMap_TrySet(arrayStrMap, key, value) \
    AArrayStrMap->TrySet(arrayStrMap, key, &(value));


/**
 * Shortcut of AArrayStrMap->InsertAt.
 */
#define AArrayStrMap_InsertAt(arrayStrMap, key, index, value) \
    AArrayStrMap->InsertAt(arrayStrMap, key, index, &(value))


/**
 * Shortcut of AArrayStrMap->GetAt.
 * return value.
 */
#define AArrayStrMap_GetAt(arrayStrMap, index, ValueType) \
    (*(ValueType*) AArrayStrMap->GetAt(arrayStrMap, index))


/**
 * Shortcut of AArrayStrMap->GetAt.
 * return valuePtr.
 */
#define AArrayStrMap_GetPtrAt(arrayStrMap, index, ValueType) \
    ((ValueType*) AArrayStrMap->GetAt(arrayStrMap, index))


/**
 * Shortcut of AArrayStrMap->SetAt.
 */
#define AArrayStrMap_SetAt(arrayStrMap, index, value) \
    AArrayStrMap->SetAt(arrayStrMap, index, &(value))


#endif

```

`Engine/Toolkit/Utils/ArrayStrSet.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2019-1-3
 * Update   : 2019-1-14
 * Author   : scott.cgi
 */


#include <stdlib.h>
#include <string.h>
#include "Engine/Toolkit/Utils/ArrayStrSet.h"


/**
 * Search index of key, if negative not found then return "-insertIndex - 1",
 * so insert index is "-BinarySearch() - 1".
 */
static inline int BinarySearch(ArrayList(ArrayStrSetElement)* elementList, const char* str, int strLength)
{
    int high  = elementList->size;
    int low   = -1;
    int guess = -1;

    while (high - low > 1) // prevent infinite loops
    {
        // (high + low) always positive, so convert to unsigned
        // then the '>>' is unsigned move right
        // so the overflow will be handled correctly
        // because sign bit shift to right and 0 will be added
        guess                       = (unsigned int) (high + low) >> 1;
        ArrayStrSetElement* element = AArrayList_Get(elementList, guess, ArrayStrSetElement*);

        if (element->strLength < strLength)
        {
            low  = guess;
        }
        else if (element->strLength > strLength)
        {
            high = guess;
        }
        else if (element->strLength == strLength)
        {
            int cmp = memcmp(element->str, str, (size_t) strLength);

            if (cmp < 0)
            {
                low  = guess;
            }
            else if (cmp > 0)
            {
                high = guess;
            }
            else if (cmp == 0)
            {
                // find the key, the guess is positive value
                return guess;
            }
        }
    }

    // if guess == high
    // the guess is bigger than key index and insert value at guess

    if (guess == low)
    {
        // the guess is smaller than key index and insert value behind
        // or if list empty then the guess is -1, also do this make guess at 0
        ++guess;
    }

    // when list empty the guess is 0, so we -1 make sure return negative value
    return -guess - 1;
}


static void Release(ArrayStrSet* arrayStrSet)
{
    for (int i = 0; i < arrayStrSet->elementList->size; ++i)
    {
        free(AArrayList_Get(arrayStrSet->elementList, i, ArrayStrSetElement*));
    }

    AArrayList->Release(arrayStrSet->elementList);
}


static void InitWithCapacity(int capacity, ArrayStrSet* arrayStrSet)
{
    if (capacity == 0)
    {
        AArrayList->Init(sizeof(intptr_t), arrayStrSet->elementList);
    }
    else
    {
        AArrayList->InitWithCapacity(sizeof(intptr_t), capacity, arrayStrSet->elementList);
    }
}


static ArrayStrSet* CreateWithCapacity(int capacity)
{
    ArrayStrSet* arrayStrSet = malloc(sizeof(ArrayStrSet));
    InitWithCapacity(capacity, arrayStrSet);
    return arrayStrSet;
}


static void Init(ArrayStrSet* arrayStrSet)
{
    InitWithCapacity(0, arrayStrSet);
}


static ArrayStrSet* Create()
{
    return CreateWithCapacity(0);
}


static const char* Get(ArrayStrSet* arrayStrSet, const char* str)
{
    int                 strLength = (int) strlen(str) + 1;
    int                 guess     = BinarySearch(arrayStrSet->elementList, str, strLength);
    ArrayStrSetElement* element;

    if (guess < 0)
    {
        element            = malloc(sizeof(ArrayStrSetElement) + strLength);
        element->strLength = strLength;
        element->str       = (char*) element + sizeof(ArrayStrSetElement);

        memcpy((void*) element->str, str, (size_t) strLength);
        AArrayList_Insert(arrayStrSet->elementList, -guess - 1, element);
    }
    else
    {
        element = AArrayList_Get(arrayStrSet->elementList, guess, ArrayStrSetElement*);
    }

    return element->str;
}


static bool TryRemove(ArrayStrSet* arrayStrSet, const char* str)
{
    int guess = BinarySearch(arrayStrSet->elementList, str, (int) strlen(str) + 1);

    if (guess >= 0)
    {
        free(AArrayList_Get(arrayStrSet->elementList, guess, ArrayStrSetElement*));
        AArrayList->Remove(arrayStrSet->elementList, guess);
        
        return true;
    }

    return false;
}


static bool IsContains(ArrayStrSet* arrayStrSet, const char* str)
{
    return BinarySearch(arrayStrSet->elementList, str, (int) strlen(str) + 1) >= 0;
}


static void Clear(ArrayStrSet* arrayStrSet)
{
    for (int i = 0; i < arrayStrSet->elementList->size; ++i)
    {
        free(AArrayList_Get(arrayStrSet->elementList, i, ArrayStrSetElement*));
    }

    AArrayList->Clear(arrayStrSet->elementList);
}


struct AArrayStrSet AArrayStrSet[1] =
{{
    Create,
    Init,
    CreateWithCapacity,
    InitWithCapacity,
    Release,
    Get,
    TryRemove,
    IsContains,
    Clear,
}};
```

`Engine/Toolkit/Utils/ArrayStrSet.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2019-1-3
 * Update   : 2019-11
 * Author   : scott.cgi
 */

 
#ifndef ARRAY_STR_SET_H
#define ARRAY_STR_SET_H


#include <stdbool.h>
#include <stdint.h>
#include "Engine/Toolkit/Utils/ArrayList.h"


/**
 * The actual element store in ArrayStrSet.
 */
typedef struct
{
    /**
     * The str data will copy into ArrayStrSetElement malloc space.
     */
    const char* str;
    
    /**
     * The length of str, include '\0'.
     */
    int         strLength;
}
ArrayStrSetElement;


/**
 * A set of elements that not repeated and ordered by element's str.
 */
typedef struct
{
    ArrayList(ArrayStrSetElement*) elementList[1];
}
ArrayStrSet;


/**
 * Control ArrayStrSet.
 */
struct AArrayStrSet
{
    ArrayStrSet* (*Create)            (void);
    void         (*Init)              (ArrayStrSet* outArrayStrSet);

    ArrayStrSet* (*CreateWithCapacity)(int capacity);
    void         (*InitWithCapacity)  (int capacity, ArrayStrSet* outArrayStrSet);

    void         (*Release)           (ArrayStrSet* arrayStrSet);

    /**
     * Get str in ArrayStrSet, if str not found will add and return.
     */
    const char*  (*Get)               (ArrayStrSet* arrayStrSet, const char* str);

    /**
     * If remove success
     *     return true
     * else
     *     not found str in ArrayStrSet
     */
    bool         (*TryRemove)         (ArrayStrSet* arrayStrSet, const char* str);

    /**
     * If contains str
     *     return true
     * else
     *     not contains
     */
    bool         (*IsContains)        (ArrayStrSet* arrayStrSet, const char* str);

    /**
     * Clear all elements, reset size to 0, and keep memory space.
     */
    void         (*Clear)             (ArrayStrSet* arrayStrSet);
};


extern struct AArrayStrSet AArrayStrSet[1];


/**
 * Marked ArrayStrSet element name.
 */
#define ArrayStrSet(elementName) ArrayStrSet


/**
 * Init constant ArrayStrSet.
 * example: ArrayStrSet set[1] = ArrayStrSet_Init(elementName, increase)
 */
#define ArrayStrSet_Init(elementName, increase)        \
    {                                                  \
        AArrayList_Init(ArrayStrSetElement*, increase),\
    }


#endif

```

`Engine/Toolkit/Utils/BufferReader.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-4-6
 * Update   : 2019-1-9
 * Author   : scott.cgi
 */


#include <string.h>
#include "Engine/Toolkit/Utils/BufferReader.h"
#include "Engine/Toolkit/Platform/Log.h"


#define CheckRange(tag)                                           \
    ALog_A                                                        \
    (                                                             \
        range->start <= range->end,                               \
        "ABufferReader " tag " range error start[%d] > end[%d].", \
        range->start,                                             \
        range->end                                                \
    )

#define ReadLineLog() \
    ALog_D("ABufferReader ReadLine = %.*s", outLine->end - outLine->start + 1, buffer + outLine->start)


static void ReadLine(const char* buffer, ArrayRange* range, ArrayRange* outLine)
{
    CheckRange("ReadLine");

    int start      = range->start;
    int end        = range->end;
    outLine->start = start;
    outLine->end   = start;

    for (; start <= end; ++start)
    {
        if (buffer[start] == '\n')
        {
            outLine->end = start;

            if (start != end)
            {
                // move to new start
                range->start = start + 1;
            }
            else
            {
                // scan over
                range->start = end;
            }

            ReadLineLog();
            return;
        }
        else if (buffer[start] == '\r')
        {
            if (start != end)
            {
                // check next char
                ++start;
                
                if (buffer[start] == '\n')
                {
                    outLine->end = start;

                    if (start != end)
                    {
                        // move to new start
                        range->start = start + 1;
                    }
                    else
                    {
                        // scan over
                        range->start = end;
                    }
                }
                else
                {
                    // back to '\r'
                    outLine->end = start - 1;
                    // start is next
                    range->start = start;
                }
            }
            else
            {
                outLine->end = start;
                // scan over
                range->start = end;
            }

            ReadLineLog();
            return;
        }
    }

    // not found newline char
    outLine->end = end;
    range->end   = end;
    ReadLineLog();
}


/**
 * Redundancy is better so don't delete.
 */
static bool TryFindStringByLoop(const char* buffer, ArrayRange* range, const char* str)
{
    CheckRange("TryFindString");

    int  start = range->start;
    int  end   = range->end;
    int  pos   = 0;
    char first  = str[0];
    int  cmp;

    for (; start <= end; ++start)
    {
        // always test from first char
        if (buffer[start] == first)
        {
            // compare from start
            cmp = start;

            while (true)
            {
                ++pos;

                if (str[pos] == '\0')
                {
                    if (cmp != end)
                    {
                        // move to next char
                        range->start = cmp + 1;
                    }
                    else
                    {
                        // scan over
                        range->start = end;
                    }

                    ALog_D
                    (
                        "ABufferReader TryFindString found str = %.*s, after str = '%c'",
                        cmp - start + 1,
                        buffer + start,
                        buffer[range->start]
                    );

                    return true;
                }

                ++cmp;

                if (cmp > end)
                {
                    // scan over
                    goto NotFoundStr;
                }

                if (buffer[cmp] != str[pos])
                {
                    // compare failure reset to first
                    pos = 0;
                    break;
                }
            }
        }
    }

    NotFoundStr:
    ALog_D("ABufferReader TryFindString not found str = %s", str);
    // keep range->start
    return false;
}


static bool TryFindStringByMemcmp(const char* buffer, ArrayRange* range, const char* str)
{
    CheckRange("TryFindString");

    char* bufferStart = (char*) buffer + range->start;
    int   len1        = range->end     - range->start + 1; // count [start, end]
    int   len2        = (int)   strlen(str);

    while (len1 >= len2)
    {
        if (memcmp(bufferStart, str, (size_t) len2) == 0)
        {
            // move to next char
            // newStart + 1 = ((range->end - len1 + 1) + len2 - 1) + 1
            range->start = range->end - len1 + len2 + 1;

            if (range->start > range->end)
            {
                range->start = range->end;
            }

            ALog_D
            (
                "ABufferReader TryFindString found str = %.*s, after str = '%c'",
                len2,
                bufferStart,
                buffer[range->start]
            );
            
            return true;
        }

        --len1;
        ++bufferStart;
    }

    ALog_D("ABufferReader TryFindString not found str = %s", str);
    // keep range->start
    return false;
}


struct ABufferReader ABufferReader[1] =
{{
    ReadLine,
    TryFindStringByMemcmp,
}};


#undef ReadLineLog


```

`Engine/Toolkit/Utils/BufferReader.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-4-6
 * Update   : 2019-19
 * Author   : scott.cgi
 */


#ifndef BUFFER_READER_H
#define BUFFER_READER_H


#include <stdbool.h>
#include <stdint.h>
#include "Engine/Toolkit/HeaderUtils/ArrayRange.h"


/**
 * Read different types of data from buffer.
 */
struct ABufferReader
{
    /**
     * Read line from range in buffer, move range->start to newline, and record line in outLine.
     * the outLine->end may be '\n' or '\r' or range->end (not found newline char).
     */
    void   (*ReadLine)     (const char* buffer, ArrayRange* range, ArrayRange* outLine);

    /**
     * Find str from range in buffer.
     *
     * if return true
     *     found the str and move range->start behind str in buffer, but not more than range->end.
     * else
     *     not found str and keep range->start.
     */
    bool   (*TryFindString)(const char* buffer, ArrayRange* range, const char* str);
};


extern struct ABufferReader ABufferReader[1];


#endif

```

`Engine/Toolkit/Utils/Coroutine.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-11-13
 * Update   : 2019-1-9
 * Author   : scott.cgi
 */

 
#include <stdlib.h>
#include "Engine/Toolkit/HeaderUtils/Define.h"
#include "Engine/Toolkit/Utils/Coroutine.h"
#include "Engine/Toolkit/Platform/Log.h"


static ArrayList(Coroutine*) coroutineRunningList[1] = AArrayList_Init(Coroutine*, 25);
static ArrayList(Coroutine*) coroutineCacheList  [1] = AArrayList_Init(Coroutine*, 25);


static Coroutine* StartCoroutine(CoroutineRun Run)
{
    Coroutine* coroutine = AArrayList_Pop(coroutineCacheList, Coroutine*);

    if (coroutine == NULL)
    {
        coroutine = malloc(sizeof(Coroutine));
        AArrayList->Init(sizeof(Coroutine*), coroutine->waits);
        coroutine->waits->increase = 4;
    }
    else
    {
        AArrayList->Clear(coroutine->waits);
    }

    coroutine->Run          = Run;
    coroutine->step         = 0;
    coroutine->waitValue    = 0.0f;
    coroutine->curWaitValue = 0.0f;
    coroutine->waitType     = CoroutineWaitType_Null;
    coroutine->state        = CoroutineState_Ready;

    AUserData_Init(coroutine->userData);
    AArrayList_Add(coroutineRunningList, coroutine);

    return coroutine;
}


static void Update(float deltaSeconds)
{
    for (int i = coroutineRunningList->size - 1; i > -1; --i)
    {
        Coroutine* coroutine = AArrayList_Get(coroutineRunningList, i, Coroutine*);

        if (coroutine->waitType == CoroutineWaitType_Coroutines)
        {
            continue;
        }
        else if (coroutine->curWaitValue >= coroutine->waitValue)
        {
            coroutine->Run(coroutine);

            if (coroutine->state == CoroutineState_Finish)
            {
                AArrayList->RemoveByLast(coroutineRunningList, i);

                // add to cache
                AArrayList_Add(coroutineCacheList, coroutine);

                // set waiting coroutines execute forward
                for (int j = 0; j < coroutine->waits->size; ++j)
                {
                    Coroutine* wait = AArrayList_Get(coroutine->waits, j, Coroutine*);

                    ALog_A
                    (
                        wait->state != CoroutineState_Finish,
                        "Coroutine [%p] cannot finish before wait coroutine [%p] finish",
                        wait,
                        coroutine
                    );

                    wait->waitType = CoroutineWaitType_Null;
                }
                continue;
            }
        }
        else
        {
            switch (coroutine->waitType)
            {
                case CoroutineWaitType_Frames:
                    coroutine->curWaitValue += 1.0f;
                    break;

                case CoroutineWaitType_Seconds:
                    coroutine->curWaitValue += deltaSeconds;
                    break;
                    
                case CoroutineWaitType_Null:
                    break;
                    
                case CoroutineWaitType_Coroutines:
                    break;
            }
        }
    }
}


struct ACoroutine ACoroutine[1] =
{{
    StartCoroutine,
    Update,
}};

```

`Engine/Toolkit/Utils/Coroutine.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-11-13
 * Update   : 2019-18
 * Author   : scott.cgi
 */

 
#ifndef COROUTINE_H
#define COROUTINE_H


#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Toolkit/Utils/ArrayList.h"
#include "Engine/Toolkit/HeaderUtils/Define.h"


typedef enum
{
    /**
     * Coroutine wait for frame count to waitValue.
     */
     CoroutineWaitType_Frames,

    /**
     * Coroutine wait for second count to waitValue.
     */
     CoroutineWaitType_Seconds,

    /**
     * Coroutine wait for other Coroutine to finish.
     */
     CoroutineWaitType_Coroutines,

    /**
     * Coroutine just run forward.
     */
     CoroutineWaitType_Null,
}
CoroutineWaitType;


typedef enum
{
    /**
     * Coroutine enter queue ready to running.
     */
     CoroutineState_Ready,

    /**
     * Coroutine already running.
     */
     CoroutineState_Running,

    /**
     * Coroutine already finished and waiting for reuse.
     */
     CoroutineState_Finish,
}
CoroutineState;


/**
 *  A Coroutine can suspend execution and wait for execution again.
 */
typedef struct Coroutine Coroutine;

/**
 * A Coroutine running function.
 */
typedef void (*CoroutineRun)(Coroutine* coroutine);


struct Coroutine
{
    UserData              userData[1];

    /**
     * Record coroutine run step.
     */
    int                   step;

    /**
     * Coroutine implement this function.
     */
    CoroutineRun          Run;

    /**
     * Coroutine current state.
     */
    CoroutineState        state;

    /**
     * Coroutine wait value to continue execute.
     */
    float                 waitValue;

    /**
     * Current wait progress.
     */
    float                 curWaitValue;

    /**
     * Coroutine wait type.
     */
    CoroutineWaitType     waitType;

    /**
     * Store Coroutines that wait for this Coroutine to finish.
     */
    ArrayList(Coroutine*) waits [1];
};


/**
 * Control all Coroutines.
 */
struct ACoroutine
{
    /**
     * Bind CoroutineRun to Coroutine and enter running queue.
     */
    Coroutine* (*StartCoroutine)(CoroutineRun Run);

    /**
     * Update on every frame by loop.
     */
    void       (*Update)        (float deltaSeconds);
};


extern struct ACoroutine ACoroutine[1];


/**
 * Mark the Coroutine area begin.
 */
#define ACoroutine_Begin()                              \
    switch (coroutine->step)                            \
    {                                                   \
        default:                                        \
            break;                                      \
        case 0:                                         \
            coroutine->state = CoroutineState_Running


/**
* Mark the Coroutine area end.
*/
#define ACoroutine_End()                                \
    }                                                   \
    coroutine->state = CoroutineState_Finish            \


/**
 * Yield execution and wait number of frames then execution again.
 * called between ACoroutine_Begin and ACoroutine_End.
 *
 * waitFrames: CoroutineRun wait frames and running again
 */
#define ACoroutine_YieldFrames(waitFrames)              \
    coroutine->waitValue    = waitFrames;               \
    coroutine->curWaitValue = 0.0f;                     \
    coroutine->waitType     = CoroutineWaitType_Frames; \
    coroutine->step         = __LINE__;                 \
    return;                                             \
    case __LINE__:


/**
 * Yield execution and wait number of seconds then execution again.
 * called between ACoroutine_Begin and ACoroutine_End.
 * 
 * waitSeconds: CoroutineRun wait seconds and running again
 */
#define ACoroutine_YieldSeconds(waitSeconds)            \
    coroutine->waitValue    = waitSeconds;              \
    coroutine->curWaitValue = 0.0f;                     \
    coroutine->waitType     = CoroutineWaitType_Seconds;\
    coroutine->step         = __LINE__;                 \
    return;                                             \
    case __LINE__:


/**
 * Yield execution and wait other Coroutine finished then execution again.
 * called between ACoroutine_Begin and ACoroutine_End.
 * 
 * waitCoroutine: CoroutineRun wait other Coroutine finished and running again
 */
#define ACoroutine_YieldCoroutine(waitCoroutine)            \
    coroutine->waitValue    = 0.0f;                         \
    coroutine->curWaitValue = 0.0f;                         \
    coroutine->waitType     = CoroutineWaitType_Coroutines; \
    AArrayList_Add((waitCoroutine)->waits, coroutine);      \
    coroutine->step         = __LINE__;                     \
    return;                                                 \
    case __LINE__:


/**
 * Just stop Coroutine running and jump out ACoroutine_Begin and ACoroutine_End.
 * called between ACoroutine_Begin and ACoroutine_End.
 */
#define ACoroutine_YieldBreak()               \
    coroutine->state = CoroutineState_Finish; \
    break


#endif

```

`Engine/Toolkit/Utils/FileTool.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-3-20
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */


#include <string.h>
#include "Engine/Toolkit/Utils/FileTool.h"
#include "Engine/Toolkit/Math/Math.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Toolkit/Platform/File.h"


static int GetDirLength(const char* filePath)
{
    char* lastForwardSlash  = strrchr(filePath, '/');
    char* lastBackwardSlash = strrchr(filePath, '\\');
    char* lastSlash         = AMath_Max(lastForwardSlash, lastBackwardSlash);

    if (lastSlash != NULL)
    {
        // include last slash
        return (int) (lastSlash - filePath + 1);
    }
    else
    {
        return 0;
    }
}


static void* CreateDataFromAbsolute(const char* absoluteFilePath, long* outSize)
{
    FILE* file = fopen(absoluteFilePath, "rb");

    if (file != NULL)
    {
        fseek(file, 0, SEEK_END);
        long  length = ftell(file);
        void* buffer = malloc((size_t) length);
        *outSize     = length;

        fseek (file, 0, SEEK_SET);
        fread (buffer, (size_t) length, 1, file);
        fclose(file);

        return buffer;
    }
    else
    {
        *outSize = 0;
        return NULL;
    }
}


static char* CreateStringFromAbsolute(const char* absoluteFilePath)
{
    FILE* file = fopen(absoluteFilePath, "rb");

    if (file != NULL)
    {
        fseek(file, 0, SEEK_END);
        long  length   = ftell(file);
        char* buffer   = malloc((size_t) length + 1);
        buffer[length] = '\0';

        fseek (file, 0, SEEK_SET);
        fread (buffer, (size_t) length, 1, file);
        fclose(file);

        return buffer;
    }
    else
    {
        return NULL;
    }
}


static void* CreateDataFromResource(const char* resourceFilePath, long* outSize)
{
    File* file   = AFile->Open(resourceFilePath);
    long  length = AFile->GetLength(file);
    void* buffer = malloc((size_t) length);
    *outSize     = length;

    AFile->Read (file, buffer, (size_t) length);
    AFile->Close(file);

    return buffer;
}


static char* CreateStringFromResource(const char* resourceFilePath)
{
    File* file     = AFile->Open(resourceFilePath);
    long  length   = AFile->GetLength(file);
    char* buffer   = malloc((size_t) length + 1);
    buffer[length] = '\0';

    AFile->Read (file, buffer, (size_t) length);
    AFile->Close(file);

    return buffer;
}


static void* CreateDataFromRelative(const char* relativeDirFilePath, long* outSize)
{
    int         dirPathLength;
    const char* dirPath = AFile->GetInternalDataPath(&dirPathLength);

    char path[dirPathLength + strlen(relativeDirFilePath) + 2];
    sprintf(path, "%s/%s", dirPath, relativeDirFilePath);

    return CreateDataFromAbsolute(path, outSize);
}


static void WriteDataToRelative(const char* relativeDirFilePath, void* data, size_t size)
{
    ALog_A(data != NULL, "AFileTool WriteDataToDir failed, data == NULL");

    int         dirPathLength;
    const char* dirPath = AFile->GetInternalDataPath(&dirPathLength);

    char path[dirPathLength + strlen(relativeDirFilePath) + 2];
    sprintf(path, "%s/%s", dirPath, relativeDirFilePath);

    FILE* file = fopen(path, "wb");
    fwrite(data, size, 1, file);
    fclose(file);
}


struct AFileTool AFileTool[1] =
{{
    GetDirLength,
    CreateDataFromAbsolute,
    CreateStringFromAbsolute,

    CreateDataFromResource,
    CreateStringFromResource,

    CreateDataFromRelative,
    WriteDataToRelative,
}};

```

`Engine/Toolkit/Utils/FileTool.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-3-20
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#ifndef FILE_TOOL_H
#define FILE_TOOL_H


#include <stddef.h>
#include <stdio.h>


/**
 * A tool for access file by file string path.
 */
struct AFileTool
{
    /**
     * Get file directory length in file path string, include last slash '/' or '\\'.
     * return 0 when no directory.
     */
    int   (*GetDirLength)            (const char* filePath);

    /**
     * Read all file data into malloc buffer, and close file.
     *
     * outSize: the create data size.
     *
     * if file not exist
     *     return NULL
     * else
     *     return buffer ptr, and need to free it after using.
     */
    void* (*CreateDataFromAbsolute)  (const char* absoluteFilePath, long* outSize);

    /**
     * Read all file data into malloc buffer, end with '\0', and close file.
     *
     * if file not exist
     *     return NULL
     * else
     *     return buffer ptr, and need to free it after using.
     */
    char* (*CreateStringFromAbsolute)(const char* absoluteFilePath);

    /**
     * Indirect use AFile, read all file data into malloc buffer, and close file.
     *
     * outSize: the create data size.
     *
     * resourceFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     *
     * return buffer ptr, and need to free it after using.
     */
    void* (*CreateDataFromResource)  (const char* resourceFilePath, long* outSize);

    /**
     * Indirect use AFile, read all file data into malloc buffer, end with '\0', and close file.
     *
     * resourceFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     *
     * return buffer ptr, and need to free it after using.
     */
    char* (*CreateStringFromResource)(const char* resourceFilePath);

    /**
     * Read all file data into malloc buffer, and close file.
     * the relativeFilePath is relative internalDataPath from AFile->GetInternalDataPath().
     *
     * internalDataPath:
     *     Android: internal data directory
     *     IOS    : document data directory
     *
     *  outSize: the create data size.
     *
     * if file not exist
     *     return NULL
     * else
     *     return buffer ptr, and need to free it after using.
     */
    void* (*CreateDataFromRelative)  (const char* relativeFilePath, long* outSize);

    /**
     * Write data into relativeDirFilePath, and close file.
     * the relativeFilePath is relative internalDataPath from AFile->GetInternalDataPath().
     *
     * internalDataPath:
     *     Android: internal data directory
     *     IOS    : document data directory
     *
     * data: will be write to relativeFilePath
     * size: the write data size
     *
     * if file not exist will created.
     */
     void (*WriteDataToRelative)     (const char* relativeFilePath, void* data, size_t size);
};


extern struct AFileTool AFileTool[1];


#endif

```

`Engine/Toolkit/Utils/Json.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-5-29
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */


#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#include "Engine/Toolkit/Utils/Json.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Toolkit/Utils/FileTool.h"


//----------------------------------------------------------------------------------------------------------------------


/**
 * If the JsonValue is JsonType_Array,  then free each items and do recursively.
 * if the JsonValue is JsonType_Object, then free each k-v   and do recursively.
 */
static void Destroy(JsonValue* value)
{
    // JsonValue hold the whole memory
    // so free JsonValue will be release JsonValue's memory

    switch (value->type)
    {
        case JsonType_Array:
        {
            ArrayList* list = value->jsonArray->valueList;
            for (int i = 0; i < list->size; ++i)
            {
                Destroy(AArrayList_Get(list, i, JsonValue*));
            }

            AArrayList->Release(list);
            break;
        }

        case JsonType_Object:
        {
            ArrayStrMap* map = value->jsonObject->valueMap;
            for (int i = 0; i < map->elementList->size; ++i)
            {
                Destroy(AArrayStrMap_GetAt(map, i, JsonValue*));
            }

            AArrayStrMap->Release(map);
            break;
        }
            
        case JsonType_Float:
            break;
            
        case JsonType_String:
            break;
            
        case JsonType_Null:
            break;
    }

    free(value);
}


static JsonValue* CreateJsonValue(void* data, size_t valueSize, JsonType type)
{
    JsonValue* value = malloc(sizeof(JsonValue) + valueSize);

    switch (type)
    {
        case JsonType_Float:
            break;

        case JsonType_String:
            value->jsonString = memcpy((char*) value + sizeof(JsonValue), data, valueSize);
            break;

        case JsonType_Array:
            value->jsonArray = (JsonArray*) ((char*) value + sizeof(JsonValue));
            AArrayList->Init(sizeof(JsonValue*), value->jsonArray->valueList);
            break;

        case JsonType_Object:
            value->jsonObject = (JsonObject*) ((char*) value + sizeof(JsonValue));
            AArrayStrMap->Init(sizeof(JsonValue*), value->jsonObject->valueMap);
            break;

        default:
            ALog_A(false, "CreateJsonValue unknown JsonType = %d", type);
    }

    value->type = type;

    return value;
}


//----------------------------------------------------------------------------------------------------------------------


static bool ObjectGetBool(JsonObject* object, const char* key, bool defaultValue)
{
    JsonValue* jsonValue = AArrayStrMap_Get(object->valueMap, key, JsonValue*);
    return jsonValue != NULL ? strcmp(jsonValue->jsonString, "true") == 0 : defaultValue;
}


static int ObjectGetInt(JsonObject* object, const char* key, int defaultValue)
{
    JsonValue* jsonValue = AArrayStrMap_Get(object->valueMap, key, JsonValue*);
    
    if (jsonValue != NULL)
    {
        return (int) jsonValue->jsonFloat;
    }
    
    return defaultValue;
}


static float ObjectGetFloat(JsonObject* object, const char* key, float defaultValue)
{
    JsonValue* jsonValue = AArrayStrMap_Get(object->valueMap, key, JsonValue*);
    
    if (jsonValue != NULL)
    {
        return jsonValue->jsonFloat;
    }
    
    return defaultValue;
}


static char* ObjectGetString(JsonObject* object, const char* key, const char* defaultValue)
{
    JsonValue* jsonValue = AArrayStrMap_Get(object->valueMap, key, JsonValue*);
    return jsonValue != NULL ? jsonValue->jsonString : (char*) defaultValue;
}


static JsonObject* ObjectGetObject(JsonObject* object, const char* key)
{
    JsonValue* jsonValue = AArrayStrMap_Get(object->valueMap, key, JsonValue*);
    return jsonValue != NULL ? jsonValue->jsonObject : NULL;
}


static JsonArray* ObjectGetArray(JsonObject* object, const char* key)
{
    JsonValue* jsonValue = AArrayStrMap_Get(object->valueMap, key, JsonValue*);
    return jsonValue != NULL ? jsonValue->jsonArray : NULL;
}


static JsonType ObjectGetType(JsonObject* object, const char* key)
{
    JsonValue* jsonValue = AArrayStrMap_Get(object->valueMap, key, JsonValue*);

    if (jsonValue == NULL)
    {
        return JsonType_Null;
    }

    return jsonValue->type;
}


static const char* ObjectGetKey(JsonObject* object, int index)
{
    return AArrayStrMap->GetKey(object->valueMap, index);
}


static JsonObject* ObjectGetObjectByIndex(JsonObject* object, int index)
{
    return AArrayStrMap_GetAt(object->valueMap, index, JsonValue*)->jsonObject;
}


static JsonArray* ObjectGetArrayByIndex(JsonObject* object, int index)
{
    return AArrayStrMap_GetAt(object->valueMap, index, JsonValue*)->jsonArray;
}


struct AJsonObject AJsonObject[1] =
{{
    ObjectGetBool,
    ObjectGetInt,
    ObjectGetFloat,
    ObjectGetType,
    ObjectGetString,
    ObjectGetObject,
    ObjectGetArray,
    ObjectGetKey,
    ObjectGetObjectByIndex,
    ObjectGetArrayByIndex,
}};


//----------------------------------------------------------------------------------------------------------------------


static bool ArrayGetBool(JsonArray* array, int index)
{
    return strcmp(AArrayList_Get(array->valueList, index, JsonValue*)->jsonString, "true") == 0;
}


static int ArrayGetInt(JsonArray* array, int index)
{
    return (int) AArrayList_Get(array->valueList, index, JsonValue*)->jsonFloat;
}

static float ArrayGetFloat(JsonArray* array, int index)
{
    return AArrayList_Get(array->valueList, index, JsonValue*)->jsonFloat;
}


static char* ArrayGetString(JsonArray* array, int index)
{
    return AArrayList_Get(array->valueList, index, JsonValue*)->jsonString;
}


static JsonObject* ArrayGetObject(JsonArray* array, int index)
{
    return AArrayList_Get(array->valueList, index, JsonValue*)->jsonObject;
}


static JsonArray* ArrayGetArray(JsonArray* array, int index)
{
    return AArrayList_Get(array->valueList, index, JsonValue*)->jsonArray;
}


static JsonType ArrayGetType(JsonArray* array, int index)
{
    if (index < 0 || index >= array->valueList->size)
    {
        return JsonType_Null;
    }
    
    return AArrayList_Get(array->valueList, index, JsonValue*)->type;
}


struct AJsonArray AJsonArray[1] =
{{
    ArrayGetBool,
    ArrayGetInt,
    ArrayGetFloat,
    ArrayGetType,
    ArrayGetString,
    ArrayGetObject,
    ArrayGetArray,
}};


//----------------------------------------------------------------------------------------------------------------------


static inline void SkipWhiteSpace(const char** jsonPtr)
{
    const char* json = *jsonPtr;

    while (true)
    {
        switch (*json)
        {
            case ' ' :
            case '\t':
            case '\n':
            case '\r':
                ++json;
                continue;
            default:
                break;
        }
        break;
    }

    ALog_A(json != NULL, "The Json parse error on NULL, json is incomplete.");
    
    *jsonPtr = json;
}


static void* ParseNumber(const char** jsonPtr)
{
    char* endPtr;

    JsonValue* value = CreateJsonValue(NULL, 0, JsonType_Float);
    value->jsonFloat = strtof(*jsonPtr, &endPtr);

    ALog_D("Json number = %.*s", (int) (endPtr - *jsonPtr), *jsonPtr);
    
    *jsonPtr = endPtr;

    return value;
}


static int SkipString(const char** jsonPtr, const char** outStrStart)
{
    // skip '"'
    const char* json  = ++(*jsonPtr);
    int         count = 0;
    char        c;

    // check end '"'
    while ((c = json[count++]) != '"')
    {
        if (c == '\\')
        {
            // skip escaped quotes
            // the escape char may be '\"'，which will break while
            ++count;
        }
    }

    *outStrStart = json;
    
    // already skipped the string end '"'
    *jsonPtr    += count;

    // how many char skipped
    // count contains the string end '"', so -1
    return count - 1;
}


static JsonValue* ParseString(const char** jsonPtr)
{
    const char* strStart;
    int         length        = SkipString(jsonPtr, &strStart);
    JsonValue*  value         = CreateJsonValue((void*) strStart, (length + 1) * sizeof(char), JsonType_String);
    value->jsonString[length] = '\0';

    ALog_D("Json string = %s", value->jsonString);

    return value;
}


// predefine
static JsonValue* ParseValue(const char** jsonPtr);


static JsonValue* ParseArray(const char** jsonPtr)
{
    JsonValue* jsonValue = CreateJsonValue(NULL, sizeof(JsonArray), JsonType_Array);
    ArrayList* list      = jsonValue->jsonArray->valueList;

    ALog_D("Json Array: [");
    
    // skip '['
    ++(*jsonPtr);

    do
    {
        SkipWhiteSpace(jsonPtr);

        if (**jsonPtr == ']')
        {
            break;
        }

        JsonValue* value = ParseValue(jsonPtr);
        // add Array element
        AArrayList_Add(list, value);
         
        SkipWhiteSpace(jsonPtr);

        if (**jsonPtr == ',')
        {
            ++(*jsonPtr);
        }
        else
        {
            ALog_A(**jsonPtr == ']', "Json Array not has ']', error char = %c ", **jsonPtr);
            break;
        }
    }
    while (true);

    // skip ']'
    ++(*jsonPtr);
    ALog_D("] JsonArray element count = %d", list->size);
    
    return jsonValue;
}


static JsonValue* ParseObject(const char** jsonPtr)
{
    JsonValue*   jsonValue = CreateJsonValue(NULL, sizeof(JsonObject), JsonType_Object);
    ArrayStrMap* map       = jsonValue->jsonObject->valueMap;

    ALog_D("Json Object: {");
    
    // skip '{'
    ++(*jsonPtr);

    do
    {
        SkipWhiteSpace(jsonPtr);

        if (**jsonPtr == '}')
        {
            break;
        }
        
        ALog_A(**jsonPtr == '"', "Json object parse error, char = %c, should be '\"' ", **jsonPtr);

        const char* strStart;
        int         keyLen = SkipString(jsonPtr, &strStart);
        char        key[keyLen + 1];
        // make string end
        key[keyLen] = '\0';

        memcpy(key, strStart, (size_t) keyLen);
        ALog_D("Json key = %s", key);

        SkipWhiteSpace(jsonPtr);
        ALog_A((**jsonPtr) == ':', "Json object parse error, char = %c, should be ':' ", **jsonPtr);

        // skip ':'
        ++(*jsonPtr);
        JsonValue* value = ParseValue(jsonPtr);
        
        // set object element
        AArrayStrMap_TryPut(map, key, value);

        SkipWhiteSpace(jsonPtr);

        if (**jsonPtr == ',')
        {
            ++(*jsonPtr);
        }
        else
        {
            ALog_A(**jsonPtr == '}', "Json Object not has '}', error char = %c ", **jsonPtr);
            break;
        }
    }
    while (true);

    // skip '}'
    ++(*jsonPtr);
    ALog_D("} JsonObject elements count = %d", map->elementList->size);

    return jsonValue;
}


/**
 * ParseValue changed the *jsonPtr, so if *jsonPtr is direct malloc will cause error
 */
static JsonValue* ParseValue(const char** jsonPtr)
{
    SkipWhiteSpace(jsonPtr);

    char c = **jsonPtr;

    switch (c)
    {
        case '{':
            return ParseObject(jsonPtr);

        case '[':
            return ParseArray(jsonPtr);

        case '"':
            return ParseString(jsonPtr);

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '-':
            return ParseNumber(jsonPtr);

        case 'f':
        {
            const char* json = *jsonPtr;

            if
            (
                json[1] == 'a' &&
                json[2] == 'l' &&
                json[3] == 's' &&
                json[4] == 'e'
            )
            {
                ALog_D("Json false");

                (*jsonPtr) += 5;

                // copy with '\0'
                return CreateJsonValue("false", 6, JsonType_String);
            }
            break;
        }

        case 't':
        {
            const char* json = *jsonPtr;

            if
            (
                json[1] == 'r' &&
                json[2] == 'u' &&
                json[3] == 'e'
            )
            {
                ALog_D("Json true");

                (*jsonPtr) += 4;

                // copy with '\0'
                return CreateJsonValue("true", 5, JsonType_String);
            }
            break;
        }

        case 'n':
        {
            const char* json = *jsonPtr;

            if
            (
                json[1] == 'u' &&
                json[2] == 'l' &&
                json[3] == 'l'
            )
            {
                ALog_D("Json null");

                (*jsonPtr) += 4;

                // copy with '\0'
                return CreateJsonValue("null", 5, JsonType_String);
            }
            break;
        }

        default:
            break;
    }

    ALog_A(false, "Invalid json value type, error char = %c", c);

    return NULL;
}


static JsonValue* Parse(const char* jsonString)
{
    return ParseValue(&jsonString);
}


static JsonValue* ParseFile(const char* jsonFilePath)
{
    char*        jsonString = AFileTool->CreateStringFromResource(jsonFilePath);
    JsonValue*   value      = Parse(jsonString);
    free(jsonString);

    return value;
}


struct AJson AJson[1] =
{{
    Parse,
    ParseFile,
    Destroy,
}};

```

`Engine/Toolkit/Utils/Json.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-26
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#ifndef JSON_H
#define JSON_H


#include "Engine/Toolkit/Utils/ArrayStrMap.h"
#include "Engine/Toolkit/Utils/ArrayList.h"


/**
 * Json value type.
 */
typedef enum
{
    JsonType_Object,
    JsonType_Array,
    JsonType_String,
    JsonType_Float,
    JsonType_Null,
}
JsonType;


/**
 * For json object that contains a set of k-v pairs.
 */
typedef struct
{
   ArrayStrMap(objectKey, JsonValue*) valueMap[1];
}
JsonObject;


/**
 * For json array that contains a list of json value.
 */
typedef struct
{
   ArrayList(JsonValue*) valueList[1];
}
JsonArray;


/**
 * One json value.
 */
typedef struct
{
    JsonType type;

    union
    {
        /**
         * For JsonType_String.
         */
        char*       jsonString;

        /**
         * For JsonType_Object.
         */
        JsonObject* jsonObject;

        /**
         * For JsonType_Array.
         */
        JsonArray*  jsonArray;

        /**
         * For JsonType_Float and int value.
         */
        float       jsonFloat;
    };
}
JsonValue;


/**
 * Get different types of values from JsonObject.
 */
struct AJsonObject
{
    bool        (*GetBool)         (JsonObject* object, const char* key, bool  defaultValue);
    int         (*GetInt)          (JsonObject* object, const char* key, int   defaultValue);
    float       (*GetFloat)        (JsonObject* object, const char* key, float defaultValue);
    JsonType    (*GetType)         (JsonObject* object, const char* key);

    /**
     * When JsonValue released the string value will be freed.
     */
    char*       (*GetString)       (JsonObject* object, const char* key, const char* defaultValue);

    /**
     * If not found key then return NULL.
     */
    JsonObject* (*GetObject)       (JsonObject* object, const char* key);

    /**
     * If not found key then return NULL.
     */
    JsonArray*  (*GetArray)        (JsonObject* object, const char* key);

    /**
     * Get JsonObject's key.
     */
    const char* (*GetKey)          (JsonObject* object, int index);

    /**
     * Get index of JsonObject in JsonObject map.
     */
    JsonObject* (*GetObjectByIndex)(JsonObject* object, int index);

    /**
     * Get index of JsonObject in JsonArray map.
     */
    JsonArray*  (*GetArrayByIndex) (JsonObject* object, int index);
};


extern struct AJsonObject AJsonObject[1];


/**
 * Get different types of values from JsonArray.
 */
struct AJsonArray
{
    bool        (*GetBool)  (JsonArray* array, int index);
    int         (*GetInt)   (JsonArray* array, int index);
    float       (*GetFloat) (JsonArray* array, int index);
    JsonType    (*GetType)  (JsonArray* array, int index);

    /**
     * When JsonValue released the string value will be freed.
     */
    char*       (*GetString)(JsonArray* array, int index);
    JsonObject* (*GetObject)(JsonArray* array, int index);
    JsonArray*  (*GetArray) (JsonArray* array, int index);

};


extern struct AJsonArray AJsonArray[1];


/**
 * Control Json data.
 */
struct AJson
{
    /**
     * Parse the Json string, return root JsonValue.
     */
    JsonValue* (*Parse)    (const char* jsonString);

    /**
     * Parse the Json file from jsonFilePath, return root JsonValue.
     *
     * jsonFilePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    JsonValue* (*ParseFile)(const char* jsonFilePath);

    /**
     * Destroy JsonValue member memory space and free itself,
     * if Destroy root JsonValue will free all memory space.
     *
     * important: after Destroy the jsonValue will be invalidated.
     */
    void       (*Destroy)  (JsonValue* jsonValue);
};


extern struct AJson AJson[1];


#endif

```

`Engine/Toolkit/Utils/Thread.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2019-1-30
 * Update   : 2019-1-30
 * Author   : scott.cgi
 */


#include <pthread.h>
#include "Engine/Toolkit/Utils/Thread.h"


static int StartThread(ThreadRun Run, void* param)
{
    pthread_t      thread[1];
    pthread_attr_t attr  [1];
    pthread_attr_init            (attr);
    pthread_attr_setdetachstate  (attr,   PTHREAD_CREATE_DETACHED);
    int resultID = pthread_create(thread, attr, Run, param);
    pthread_attr_destroy         (attr);
    
    return resultID;
}


struct AThread AThread[1] =
{{
    StartThread,
}};
```

`Engine/Toolkit/Utils/Thread.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2019-1-30
 * Update   : 2019-1-30
 * Author   : scott.cgi
 */


#ifndef THREAD_H
#define THREAD_H


/**
 * Thread running function.
 */
typedef void* (*ThreadRun)(void* param);

/**
 * Manage and control thread.
 */
struct AThread
{
    /**
     * Start a thread with PTHREAD_CREATE_DETACHED.
     * the param will passed to ThreadRun.
     *
     * return 0 success start a thread, else return error id.
     */
    int (*StartThread)(ThreadRun Run, void* param);
};


extern struct AThread AThread[1];


#endif

```

`Engine/Toolkit/Utils/Tween.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-6-8
 * Update   : 2022-10-19
 * Author   : scott.cgi
 */

 
#include "Engine/Toolkit/Utils/Tween.h"
#include "Engine/Toolkit/Math/Math.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Toolkit/Utils/ArrayIntMap.h"
#include "Engine/Toolkit/Utils/ArrayQueue.h"


typedef struct
{
    /**
     * Target's actions queue, run each after over.
     */
    ArrayQueue(TweenAction*) queue  [1];

    /**
     * Target's current running actions.
     */
    ArrayList(TweenAction*)  current[1];

    /**
     * A queue action currently is running in current list.
     */
    TweenAction*             queueAction;
}
Tween;


static ArrayIntMap(tweenID, Tween*) tweenRunningMap[1] = AArrayIntMap_Init(Tween*,       25);
static ArrayList  (Tween*)          tweenCacheList [1] = AArrayList_Init  (Tween*,       25);
static ArrayList  (TweenAction*)    actionCacheList[1] = AArrayList_Init  (TweenAction*, 25);


static inline Tween* GetTween()
{
    Tween* tween = AArrayList_Pop(tweenCacheList, Tween*);

    if (tween == NULL)
    {
        tween = malloc(sizeof(Tween));

        AArrayQueue->Init(sizeof(TweenAction*), tween->queue);
        tween->queue->elementList->increase = 6;

        AArrayList->Init(sizeof(TweenAction*),  tween->current);
        tween->current->increase            = 6;
    }
    else
    {
        AArrayQueue->Clear(tween->queue);
        AArrayList ->Clear(tween->current);
    }

    tween->queueAction = NULL;

    return tween;
}


static TweenAction* GetAction()
{
    TweenAction* action = AArrayList_Pop(actionCacheList, TweenAction*);

    if (action == NULL)
    {
        action = malloc(sizeof(TweenAction));
        AArrayList->InitWithCapacity(sizeof(TweenActionValue), 6, action->actionValueList);
        action->actionValueList->increase = 6;
    }
    else
    {
        AArrayList->Clear(action->actionValueList);
    }

    AUserData_Init(action->userData);
    action->curTime    = 0.0f;
    action->duration   = 0.0f;
    action->OnComplete = NULL;
    action->isQueue    = true;
    action->target     = NULL;

    return action;
}


static TweenActionValue* AddTweenActionValue(TweenAction* action)
{
    TweenActionValue* actionValue = AArrayList_GetPtrAdd(action->actionValueList, TweenActionValue);
    actionValue->value            = 0.0f;
    actionValue->fromValue        = 0.0f;
    actionValue->toValue          = 0.0f;
    actionValue->OnGet            = NULL;
    actionValue->OnSet            = NULL;
    actionValue->isRelative       = true;
    actionValue->easeType         = TweenEaseType_Smooth;

    return actionValue;
}


static inline void SetActionValue(TweenAction* action)
{
    for (int i = 0; i < action->actionValueList->size; ++i)
    {
        TweenActionValue* actionValue = AArrayList_GetPtr(action->actionValueList, i, TweenActionValue);

        ALog_A
        (
            actionValue->OnGet != NULL && actionValue->OnSet != NULL,
            "ATween SetActionValue action OnSet and OnGet must not NULL."
        );

        actionValue->fromValue = actionValue->OnGet(action->target);

        if (actionValue->isRelative)
        {
            actionValue->toValue = actionValue->value + actionValue->fromValue;
        }
        else
        {
            actionValue->toValue = actionValue->value;
        }
    }
}


static void* RunActions(Array(TweenAction*)* actions, void* tweenID)
{
    Tween* tween;

    if (tweenID == NULL)
    {
         // not give tweenID, we use Tween ptr for it
        tween   = GetTween();
        tweenID = tween;

        AArrayIntMap_TryPut(tweenRunningMap, tweenID, tween);
    }
    else
    {
        int index = AArrayIntMap->GetIndex(tweenRunningMap, (intptr_t) tweenID);

        if (index < 0)
        {
            tween = GetTween();
            AArrayIntMap_InsertAt(tweenRunningMap, tweenID, -index - 1, tween);
        }
        else
        {
            tween = AArrayIntMap_GetAt(tweenRunningMap, index, Tween*);
        }
    }

//----------------------------------------------------------------------------------------------------------------------

    for (int i = 0; i < actions->length; ++i)
    {
        TweenAction* action = AArray_Get(actions, i, TweenAction*);

        if (action->isQueue)
        {
            AArrayQueue_Enqueue(tween->queue, action);
        }
        else
        {
            AArrayList_Add(tween->current, action);
            SetActionValue(action);
        }
    }

    return tweenID;
}


static void RemoveCurrentActionByIndex(Tween* tween, TweenAction* action, int index)
{
    if (action == tween->queueAction)
    {
        tween->queueAction = NULL;
    }

    AArrayList->RemoveByLast(tween->current, index);
    AArrayList_Add(actionCacheList, action);
}


static bool TryRemoveAction(void* tweenID, TweenAction* action)
{
    Tween* tween = AArrayIntMap_Get(tweenRunningMap, tweenID, Tween*);

    if (tween != NULL)
    {
        for (int i = 0; i < tween->current->size; ++i)
        {
            TweenAction* tweenAction = AArrayList_Get(tween->current, i, TweenAction*);

            if (action == tweenAction)
            {
                RemoveCurrentActionByIndex(tween, action, i);
                return true;
            }
        }

        for (int i = tween->queue->headIndex; i < tween->queue->elementList->size; ++i)
        {
            TweenAction* tweenAction = AArrayList_Get(tween->queue->elementList, i, TweenAction*);

            if (action == tweenAction)
            {
                AArrayQueue->RemoveAt(tween->queue, i);
                AArrayList_Add(actionCacheList, action);

                return true;
            }
        }
    }

    return false;
}


static bool TryRemoveAllActions(void* tweenID)
{
    int index = AArrayIntMap->GetIndex(tweenRunningMap, (intptr_t) tweenID);

    if (index >= 0)
    {
        Tween* tween = AArrayIntMap_GetAt(tweenRunningMap, index, Tween*);

        for (int i = 0; i < tween->current->size; ++i)
        {
            AArrayList_Add(actionCacheList, AArrayList_Get(tween->current, i, TweenAction*));
        }
        AArrayList->Clear(tween->current);

        TweenAction* action;
        while ((action = AArrayQueue_Dequeue(tween->queue, TweenAction*)))
        {
            AArrayList_Add(actionCacheList, action);
        }

        // if queueAction not NULL it must be in tweenData->current
        // so just set NULL
        tween->queueAction = NULL;

        return true;
    }

    return false;
}


static inline void SetActionComplete(TweenAction* action, bool isFireOnComplete)
{
    for (int k = 0; k < action->actionValueList->size; ++k)
    {
        TweenActionValue* actionValue = AArrayList_GetPtr(action->actionValueList, k, TweenActionValue);

        actionValue->OnSet
        (
            action->target,
            actionValue->toValue
        );
    }

    if (isFireOnComplete && action->OnComplete != NULL)
    {
        action->OnComplete(action);
    }
}


static bool TryCompleteAllActions(void* tweenID, bool isFireOnComplete)
{
    int index = AArrayIntMap->GetIndex(tweenRunningMap, (intptr_t) tweenID);

    if (index >= 0)
    {
        Tween* tween = AArrayIntMap_GetAt(tweenRunningMap, index, Tween*);

        for (int i = 0; i < tween->current->size; ++i)
        {
            TweenAction* action = AArrayList_Get(tween->current, i, TweenAction*);
            SetActionComplete(action, isFireOnComplete);
            AArrayList_Add(actionCacheList, action);
        }
        AArrayList->Clear(tween->current);

        TweenAction* action;
        while ((action = AArrayQueue_Dequeue(tween->queue, TweenAction*)))
        {
            SetActionComplete(action, isFireOnComplete);
            AArrayList_Add(actionCacheList, action);
        }

        // if queueAction not NULL it must be in tweenData->current
        // so just set NULL
        tween->queueAction = NULL;

        return true;
    }

    return false;
}


static bool HasAction(void* tweenID)
{
    int index = AArrayIntMap->GetIndex(tweenRunningMap, (intptr_t) tweenID);

    if (index >= 0)
    {
        Tween* tween = AArrayIntMap_GetAt(tweenRunningMap, index, Tween*);

        if (tween->current->size > 0 || tween->queue->elementList->size > 0)
        {
            return true;
        }

        return false;
    }

    return false;
}


static void Update(float deltaSeconds)
{
    for (int i = tweenRunningMap->elementList->size - 1; i > -1; --i)
    {
        Tween* tween = AArrayIntMap_GetAt(tweenRunningMap, i, Tween*);

        // get a queue action to run
        if (tween->queueAction == NULL)
        {
            tween->queueAction = AArrayQueue_Dequeue(tween->queue, TweenAction*);

            if (tween->queueAction != NULL)
            {
                // add the running queue action into current list
                AArrayList_Add(tween->current, tween->queueAction);
                SetActionValue(tween->queueAction);
            }
        }

        if (tween->current->size == 0)
        {
            // all actions complete so remove tweenData and push to cache
            AArrayList_Add        (tweenCacheList, tween);
            AArrayIntMap->RemoveAt(tweenRunningMap,    i);
            continue;
        }

        for (int j = tween->current->size - 1; j > -1; --j)
        {
            TweenAction* action = AArrayList_Get(tween->current, j, TweenAction*);

            if (action->curTime < action->duration)
            {
                for (int k = 0; k < action->actionValueList->size; ++k)
                {
                    TweenActionValue* actionValue = AArrayList_GetPtr(action->actionValueList, k, TweenActionValue);

                    actionValue->OnSet
                    (
                        action->target,
                        actionValue->fromValue + (actionValue->toValue - actionValue->fromValue) *
                        ATweenEase->Easing[actionValue->easeType](action->curTime / action->duration)
                    );
                }

                action->curTime += deltaSeconds;
            }
            else
            {
                for (int k = 0; k < action->actionValueList->size; ++k)
                {
                    TweenActionValue* actionValue = AArrayList_GetPtr(action->actionValueList, k, TweenActionValue);
                    actionValue->OnSet(action->target, actionValue->toValue);
                }

                // action complete
                if (action->OnComplete != NULL)
                {
                    action->OnComplete(action);
                }

                RemoveCurrentActionByIndex(tween, action, j);
            }
        }
    }
}


struct ATween ATween[1] =
{{
    GetAction,
    AddTweenActionValue,
    RunActions,
    TryRemoveAllActions,
    TryCompleteAllActions,
    TryRemoveAction,
    HasAction,
    Update,
}};

```

`Engine/Toolkit/Utils/Tween.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-6-8
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */


#ifndef TWEEN_H
#define TWEEN_H


#include <stddef.h>
#include <stdbool.h>
#include "Engine/Toolkit/Math/TweenEase.h"
#include "Engine/Toolkit/Utils/ArrayList.h"
#include "Engine/Toolkit/HeaderUtils/UserData.h"


/**
 * Get target value when TweenActionValue need to init.
 */
typedef float (*TweenActionValueOnGet)(void* target);

/**
 * Set target value when TweenActionValue already changed value in one frame.
 */
typedef void (*TweenActionValueOnSet)(void* target, float value);


/**
 * One value in TweenAction that can tween easing.
 */
typedef struct
{
    /**
     * The action will reach to this value that depends on isRelative.
     */
    float                 value;

    /**
     * The action start from this value.
     */
    float                 fromValue;

    /**
     * The final value action will reach to.
     */
    float                 toValue;

    /**
     * When TweenAction's target value need to be get.
     */
    TweenActionValueOnGet OnGet;

    /**
     * When TweenAction's target value need to be set.
     */
    TweenActionValueOnSet OnSet;

    /**
     * The value is relative or absolute, default true.
     */
    bool                  isRelative;

    /**
     * Default TweenEaseType_Smooth.
     */
    TweenEaseType         easeType;
}
TweenActionValue;


/**
 * Can tween easing a list of TweenActionValues.
 */
typedef struct TweenAction TweenAction;

/**
 * When TweenAction finished callback.
 */
typedef void (*TweenActionOnComplete)(TweenAction* action);


struct TweenAction
{
    UserData                    userData[1];

    /**
     * Target execute TweenAction.
     */
    void*                       target;

    /**
     * The action running duration time.
     */
    float                       duration;

    /**
     * The action running current position in duration time.
     */
    float                       curTime;

    /**
     * Means action running in queue or immediately, default true.
     */
    bool                        isQueue;

    /**
     * TweenActionValue list changing concurrently.
     */
    ArrayList(TweenActionValue) actionValueList[1];

    /**
     * When action complete callback.
     */
    TweenActionOnComplete       OnComplete;
};


/**
 * Manage and control all TweenActions.
 */
struct ATween
{
    /**
     * Control by ATween when action completed.
     *
     * userData  : NULL
     * target    : NULL
     * isQueue   : true
     * duration  : 0
     * OnComplete: NULL
     */
    TweenAction*      (*GetAction)            (void);

    /**
     * Add TweenActon's TweenActionValue.
     */
    TweenActionValue* (*AddTweenActionValue)  (TweenAction* action);

    /**
     * Bind TweenActions to tweenID and running.
     * if tweenID is NULL will generate tweenID value.
     *
     * return tweenID.
     */
    void*             (*RunActions)           (Array(TweenAction*)* actions, void* tweenID);

    /**
     * Remove tweenID's all actions immediately, return false when tweenID not in use.
     * we can or not cleanup tweenID bound data for actions,
     * but when tweenID not in use then must cleanup for reuse memory
     */
    bool              (*TryRemoveAllActions)  (void* tweenID);

    /**
     * Complete tweenID's all actions immediately, return false when tweenID not in use.
     * if isFireOnComplete true will fire callback.
     */
    bool              (*TryCompleteAllActions)(void* tweenID, bool isFireOnComplete);

    /**
     * Find TweenAction in current or queue, and remove it.
     * if tweenID not in use return false.
     * if not found TweenAction return false.
     */
    bool              (*TryRemoveAction)      (void* tweenID, TweenAction* action);

    /**
     * Whether the tweenID has action in current or queue.
     */
    bool              (*HasAction)            (void* tweenID);

    /**
     * Called every frame by loop.
     */
    void              (*Update)               (float deltaSeconds);
};


extern struct ATween ATween[1];


#endif

```

`Engine/Toolkit/Utils/TweenTool.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-6-24
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */


#include <string.h>
#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Toolkit/Utils/TweenTool.h"
#include "Engine/Toolkit/Platform/Log.h"


enum
{
    /**
     * Max number of TweenActions in context.
     */
    TweenAction_Length = 30,
};


static Array(TweenAction*) actionArr[1] =
{
    (TweenAction*[TweenAction_Length]) {},
    0
};


static TweenAction*      action      = NULL;
static TweenActionValue* actionValue = NULL;


#define CheckAction(tag) \
    ALog_A(action      != NULL, "ATweenTool " tag " TweenAction not created.");


#define CheckActionValue(tag) \
    ALog_A(actionValue != NULL, "ATweenTool " tag " TweenActionValue cannot NULL.");


static struct ATweenTool* AddAction()
{
    ALog_A
    (
        actionArr->length <= TweenAction_Length,
        "ATweenTool cannot cache TweenActions = %d more than %d",
        actionArr->length,
        TweenAction_Length
    );

    action      = ATween->GetAction();
    actionValue = NULL;

    AArray_Set
    (
        actionArr,
        actionArr->length++,
        action,
        TweenAction*
    );

    return ATweenTool;
}


static inline struct ATweenTool* SetValue(TweenActionValueGetSet* valueGetSet, float value)
{
    CheckAction("SetValue");

    actionValue        = ATween->AddTweenActionValue(action);
    actionValue->OnGet = valueGetSet->OnGet;
    actionValue->OnSet = valueGetSet->OnSet;
    actionValue->value = value;

    return ATweenTool;
}


static struct ATweenTool* SetDuration(float duration)
{
    CheckAction("SetDuration");
    action->duration = duration;

    return ATweenTool;
}


static struct ATweenTool* SetRelative(bool isRelative)
{
    CheckAction     ("SetRelative");
    CheckActionValue("SetRelative");
    actionValue->isRelative = isRelative;

    return ATweenTool;
}


static struct ATweenTool* SetEaseType(TweenEaseType easeType)
{
    CheckAction     ("SetEaseType");
    CheckActionValue("SetEaseType");
    actionValue->easeType = easeType;

    return ATweenTool;
}


static struct ATweenTool* AddInterval(float duration)
{
    AddAction();
    SetDuration(duration);

    return ATweenTool;
}


//----------------------------------------------------------------------------------------------------------------------


static struct ATweenTool* AddMoveX(float moveX, float duration)
{
    AddAction();
    SetValue(ATweenActionValueGetSetImpl->moveX, moveX);
    SetDuration(duration);

    return ATweenTool;
}


static struct ATweenTool* AddMoveY(float moveY, float duration)
{
    AddAction();
    SetValue(ATweenActionValueGetSetImpl->moveY, moveY);
    SetDuration(duration);

    return ATweenTool;
}


static struct ATweenTool* AddMove2(float moveX, float moveY, float duration, bool isRelative, TweenEaseType easeType)
{
    AddAction  ();

    SetValue   (ATweenActionValueGetSetImpl->moveX, moveX);
    SetRelative(isRelative);
    SetEaseType(easeType);

    SetValue   (ATweenActionValueGetSetImpl->moveY, moveY);
    SetRelative(isRelative);
    SetEaseType(easeType);

    SetDuration(duration);

    return ATweenTool;
}


static struct ATweenTool* AddMoveSame2(float move, float duration, bool  isRelative, TweenEaseType easeType)
{
    return AddMove2(move, move, duration, isRelative, easeType);
}


static struct ATweenTool* AddScaleX(float scaleX, float duration)
{
    AddAction();

    SetValue(ATweenActionValueGetSetImpl->scaleX, scaleX);
    SetDuration(duration);

    return ATweenTool;
}


static struct ATweenTool* AddScaleY(float scaleY, float duration)
{
    AddAction();

    SetValue(ATweenActionValueGetSetImpl->scaleY, scaleY);
    SetDuration(duration);

    return ATweenTool;
}


static struct ATweenTool* AddScale2(float scaleX, float scaleY, float duration, bool isRelative, TweenEaseType easeType)
{
    AddAction  ();

    SetValue   (ATweenActionValueGetSetImpl->scaleX, scaleX);
    SetRelative(isRelative);
    SetEaseType(easeType);

    SetValue   (ATweenActionValueGetSetImpl->scaleY, scaleY);
    SetRelative(isRelative);
    SetEaseType(easeType);

    SetDuration(duration);

    return ATweenTool;
}


static struct ATweenTool* AddScaleSame2(float scale, float duration, bool  isRelative, TweenEaseType  easeType)
{
    return AddScale2(scale, scale, duration, isRelative, easeType);
}


static struct ATweenTool* AddRotateZ(float rotateZ, float duration)
{
    AddAction();

    SetValue(ATweenActionValueGetSetImpl->rotateZ, rotateZ);
    SetDuration(duration);

    return ATweenTool;
}


static struct ATweenTool* AddFadeTo(float fadeTo, float duration)
{
    AddAction();

    SetValue(ATweenActionValueGetSetImpl->fadeTo, fadeTo);
    SetDuration(duration);

    return ATweenTool;
}


//----------------------------------------------------------------------------------------------------------------------


static struct ATweenTool* SetUserDataInt(int slotIndex, int value)
{
    CheckAction("SetUserDataInt");
    AUserData_SetSlotInt(action->userData, slotIndex, value);
    return ATweenTool;
}


static struct ATweenTool* SetUserDataFloat(int slotIndex, float value)
{
    CheckAction("SetUserDataFloat");
    AUserData_SetSlotFloat(action->userData, slotIndex, value);
    return ATweenTool;
}


static struct ATweenTool* SetUserDataPtr(int slotIndex, void* value)
{
    CheckAction("SetUserDataPtr");
    AUserData_SetSlotPtr(action->userData, slotIndex, value);
    return ATweenTool;
}


static struct ATweenTool* SetUserDataString(int slotIndex, char* value)
{
    CheckAction("SetUserDataString");
    AUserData_SetSlotString(action->userData, slotIndex, value);
    return ATweenTool;
}


//----------------------------------------------------------------------------------------------------------------------


static struct ATweenTool* SetQueue(bool isQueue)
{
    CheckAction("SetQueue");
    action->isQueue = isQueue;

    return ATweenTool;
}


static struct ATweenTool* SetOnComplete(TweenActionOnComplete OnComplete)
{
    CheckAction("SetOnComplete");
    action->OnComplete = OnComplete;

    return ATweenTool;
}


static struct ATweenTool* SetTarget(void* target)
{
    CheckAction("SetTarget");
    action->target = target;

    return ATweenTool;
}


static struct ATweenTool* GetAction(TweenAction** outActionPtr)
{
    CheckAction("GetAction");
    *outActionPtr = action;

    return ATweenTool;
}


//----------------------------------------------------------------------------------------------------------------------


static struct ATweenTool* SetMoveX(float moveX)
{
    return SetValue(ATweenActionValueGetSetImpl->moveX, moveX);
}


static struct ATweenTool* SetMoveY(float moveY)
{
    return SetValue(ATweenActionValueGetSetImpl->moveY, moveY);
}


struct ATweenTool* SetMove2(float moveX, float moveY, bool isRelative, TweenEaseType easeType)
{
    SetValue   (ATweenActionValueGetSetImpl->moveX, moveX);
    SetRelative(isRelative);
    SetEaseType(easeType);

    SetValue   (ATweenActionValueGetSetImpl->moveY, moveY);
    SetRelative(isRelative);
    SetEaseType(easeType);

    return ATweenTool;
}


struct ATweenTool* SetMoveSame2(float move, bool isRelative, TweenEaseType easeType)
{
    return SetMove2(move, move, isRelative, easeType);
}


static struct ATweenTool* SetScaleX(float scaleX)
{
    return SetValue(ATweenActionValueGetSetImpl->scaleX, scaleX);
}


static struct ATweenTool* SetScaleY(float scaleY)
{
    return SetValue(ATweenActionValueGetSetImpl->scaleY, scaleY);
}


struct ATweenTool* SetScale2(float scaleX, float scaleY, bool isRelative, TweenEaseType easeType)
{
    SetValue   (ATweenActionValueGetSetImpl->scaleX, scaleX);
    SetRelative(isRelative);
    SetEaseType(easeType);

    SetValue   (ATweenActionValueGetSetImpl->scaleY, scaleY);
    SetRelative(isRelative);
    SetEaseType(easeType);

    return ATweenTool;
}


struct ATweenTool* SetScaleSame2(float scale, bool isRelative, TweenEaseType easeType)
{
    return SetScale2(scale, scale, isRelative, easeType);
}


static struct ATweenTool* SetRotateZ(float rotateZ)
{
    return SetValue(ATweenActionValueGetSetImpl->rotateZ, rotateZ);
}


static struct ATweenTool* SetFadeTo(float fadeTo)
{
    return SetValue(ATweenActionValueGetSetImpl->fadeTo, fadeTo);
}


//----------------------------------------------------------------------------------------------------------------------


static void RunActions(void* target)
{
    ALog_A(target != NULL, "ATweenTool RunActions, target cannot NULL.");

    for (int i = 0; i < actionArr->length; ++i)
    {
        TweenAction* action = AArray_Get(actionArr, i, TweenAction*);

        if (action->actionValueList->size > 0)
        {
            action->target = target;
        }
    }

    ATween->RunActions(actionArr, target);

    actionArr->length = 0;
    action            = NULL;
    actionValue       = NULL;
}


static void* RunTargets()
{
    for (int i = 0; i < actionArr->length; ++i)
    {
        TweenAction* action = AArray_Get(actionArr, i, TweenAction*);

        if (action->actionValueList->size > 0)
        {
            ALog_A
            (
                action->target != NULL,
                "ATweenTool RunTargets, the [%d] action has actionValue, so must set target.",
                i
            );
        }
    }

    void* tweenID = ATween->RunActions(actionArr, NULL);

    actionArr->length = 0;
    action            = NULL;
    actionValue       = NULL;

    return tweenID;
}


struct ATweenTool ATweenTool[1] =
{{
    AddAction,
    AddInterval,

    AddMoveX,
    AddMoveY,
    AddMove2,
    AddMoveSame2,

    AddScaleX,
    AddScaleY,
    AddScale2,
    AddScaleSame2,

    AddRotateZ,
    AddFadeTo,

    SetDuration,
    SetQueue,
    SetOnComplete,
    SetTarget,
    SetUserDataInt,
    SetUserDataFloat,
    SetUserDataPtr,
    SetUserDataString,

    GetAction,

    SetMoveX,
    SetMoveY,
    SetMove2,
    SetMoveSame2,
    SetScaleX,
    SetScaleY,
    SetScale2,
    SetScaleSame2,
    SetRotateZ,
    SetFadeTo,

    SetRelative,
    SetEaseType,

    RunActions,
    RunTargets,
}};


#undef CheckAction
#undef CheckActionValue
```

`Engine/Toolkit/Utils/TweenTool.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-6-24
 * Update   : 2019-1-8
 * Author   : scott.cgi
 */

 
#ifndef TWEEN_TOOL_H
#define TWEEN_TOOL_H


#include <stdbool.h>
#include "Engine/Toolkit/Utils/Tween.h"


/**
 * Get and Set methods for get and set TweenActionValue.
 */
typedef struct
{
    TweenActionValueOnGet OnGet;
    TweenActionValueOnSet OnSet;
}
TweenActionValueGetSet;


/**
 * Various TweenActionValueGetSets need to be implemented.
 */
struct ATweenActionValueGetSetImpl
{
    TweenActionValueGetSet moveX  [1];
    TweenActionValueGetSet moveY  [1];

    TweenActionValueGetSet scaleX [1];
    TweenActionValueGetSet scaleY [1];

    TweenActionValueGetSet rotateZ[1];
    TweenActionValueGetSet fadeTo [1];
};


/**
 * Application must implement TweenActionValue get and set method.
 */
extern struct ATweenActionValueGetSetImpl ATweenActionValueGetSetImpl[1];


/**
 * Easy-to-use for tween, and can use chain calls.
 * cannot use typedef ATweenTool to avoid conflict with struct ATweenTool ATweenTool.
 */
struct ATweenTool
{
    /**
     * Add one TweenAction in context for chain setting,
     * the TweenAction can add several TweenActionValues.
     */
    struct ATweenTool* (*AddAction)  (void);

    /**
     * Add action with no actionValue just through duration time then callback.
     */
    struct ATweenTool* (*AddInterval)(float duration);

//----------------------------------------------------------------------------------------------------------------------

    /* Add one TweenAction with TweenActionValues. */

    struct ATweenTool* (*AddMoveX)     (float moveX,   float duration);
    struct ATweenTool* (*AddMoveY)     (float moveY,   float duration);

    struct ATweenTool* (*AddMove2)     (
                                           float         moveX,
                                           float         moveY,
                                           float         duration,
                                           bool          isRelative,
                                           TweenEaseType easeType
                                       );

    struct ATweenTool* (*AddMoveSame2) (float move,    float duration, bool isRelative, TweenEaseType easeType);

    struct ATweenTool* (*AddScaleX)    (float scaleX,  float duration);
    struct ATweenTool* (*AddScaleY)    (float scaleY,  float duration);

    struct ATweenTool* (*AddScale2)    (
                                           float             scaleX,
                                           float             scaleY,
                                           float             duration,
                                           bool              isRelative,
                                           TweenEaseType     easeType
                                       );
    struct ATweenTool* (*AddScaleSame2)(float scale,   float duration, bool isRelative, TweenEaseType  easeType);

    struct ATweenTool* (*AddRotateZ)   (float rotateZ, float duration);
    struct ATweenTool* (*AddFadeTo)    (float fadeTo,  float duration);

//----------------------------------------------------------------------------------------------------------------------

    /* Set TweenAction property for current context. */

    struct ATweenTool* (*SetDuration)      (float                 duration);
    struct ATweenTool* (*SetQueue)         (bool                  isQueue);
    struct ATweenTool* (*SetOnComplete)    (TweenActionOnComplete OnComplete);
    struct ATweenTool* (*SetTarget)        (void*                 target);

    struct ATweenTool* (*SetUserDataInt)   (int                   slotIndex, int   value);
    struct ATweenTool* (*SetUserDataFloat) (int                   slotIndex, float value);
    struct ATweenTool* (*SetUserDataPtr)   (int                   slotIndex, void* value);
    struct ATweenTool* (*SetUserDataString)(int                   slotIndex, char* value);

    /**
     * Get TweenAction in current context.
     */
    struct ATweenTool* (*GetAction)        (TweenAction**         outActionPtr);

//----------------------------------------------------------------------------------------------------------------------

    /* Set new TweenActionValue into context TweenAction. */

    struct ATweenTool* (*SetMoveX)     (float moveX);
    struct ATweenTool* (*SetMoveY)     (float moveY);

    struct ATweenTool* (*SetMove2)     (float moveX, float moveY,     bool isRelative, TweenEaseType easeType);
    struct ATweenTool* (*SetMoveSame2) (float move,  bool isRelative, TweenEaseType    easeType);

    struct ATweenTool* (*SetScaleX)    (float scaleX);
    struct ATweenTool* (*SetScaleY)    (float scaleY);

    struct ATweenTool* (*SetScale2)    (float scaleX,  float scaleY,    bool isRelative, TweenEaseType easeType);
    struct ATweenTool* (*SetScaleSame2)(float scale,   bool isRelative, TweenEaseType    easeType);

    struct ATweenTool* (*SetRotateZ)   (float rotateZ);
    struct ATweenTool* (*SetFadeTo)    (float fadeTo);

//----------------------------------------------------------------------------------------------------------------------

    /* Set TweenActionValue property for current context. */

    struct ATweenTool* (*SetRelative)(bool          isRelative);
    struct ATweenTool* (*SetEaseType)(TweenEaseType easeType);

//----------------------------------------------------------------------------------------------------------------------

    /**
     * Run all actions in current context, and set all actions target if has actionValue.
     * use target be tweenID.
     */
    void               (*RunActions)(void* target);

    /**
     * Run all actions in current context, and all actions must set owner's target if has actionValue.
     * all different targets will in same queue, run step by step.
     * return tweenID.
     */
    void*              (*RunTargets)(void);
};


extern struct ATweenTool ATweenTool[1];


#endif

```

`LICENSE`:

```
MIT License

Copyright (c) 2012 scott.cgi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<img src="./Docs/Images/Logo.png" width="176" height="228" alt="Mojoc Logo" title="Mojoc Logo" />


## Mojoc v0.7.1

Mojoc is an open-source, cross-platform, pure C game engine. It is based on OpenGLES3 and written in C99. It currently works on IOS and Android, but can easily be extended to other platforms, and will support more platforms in the future.

* Released versions in [releases](https://github.com/scottcgi/Mojoc/releases).
* Release changes in [ChangeLog](./ChangeLog.md).
* Documents in [Docs/Home](./Docs/Home.md).


## Architecture
![Mojoc Engine Architecture](./Docs/Images/Architecture.png "Mojoc Engine Architecture")


## License
Mojoc is licensed under the [MIT License](./LICENSE "Mojoc Under MIT License").


## Core Idea
Less is more, simple is better, simplify complex ideas.


## Features

* The only programming skill needed is the C99 language.
* In platform-independent code, Mojoc uses only the standard C library, no dependence on third-party libraries.
* Mojoc has its own unique coding style.
  * [Mojoc Code Style](./Docs/CodeStyle.md)
* Mojoc uses an extremely lightweight OOC (Object Oriented C) programming model. 
  * [Mojoc OOC Model](./Docs/OOC.md)
* Mojoc application architecture is based on components, state-machines and message-driven. 
  * [Mojoc Component Architecture](./Docs/ComponentArchitecture.md)
* More feature details. 
  * [Mojoc Code Details](./Docs/CodeDetails.md)
  
    
## Published Games
Mojoc has been used for a cross-platform Android and IOS game. 

  
## Samples
The samples will show all aspects of the Mojoc features. Each platform will provide native building project for native platform editor. For example: Android provides AndroidStudio project, IOS provides XCode project.

Currently there is only one sample, which is a simplfied version of the published game [SuperLittleRed](./Samples/SuperLittleRed). Please check out the [Quick Start](./Docs/QuickStart.md) guide for how to quickly run this sample.

The compiled and playable apk is here:

* [SuperLittleRed-2.2.0.apk](./Samples/Apk/SuperLittleRed-2.2.0.apk?raw=true) is a bow and arrow shooting game, very challenging for your operation.

<img src="./Docs/Images/SuperLittleRed-Sample.gif" width="400" height="225" alt="SuperLittleRed-Sample" title="SuperLittleRed-Sample" />



## FAQ

#### Why not C++?
  * There are plenty of C++ game engines, but pure C game engines are much rarer. I don't want to reinvent wheels, I hope to be different.
  * The core idea of the game engine I want to create is to be smaller and simple, which is consistent with the C language.
  * At the beginning, I had an idea of how to build a complex project with pure C language. I want to test the feasibility of the idea, that is Mojoc.
  * The C language is simple but powerful, it can do a lot of interesting things. **Why not C**?
    
#### What is the meaning of the name Mojoc? 
  ```
  Mojoc = Mojo + c
  ```
  The c stand for the C language.
    
#### Who designed the logo and what is its meaning?
  I designed it. The logo is an unknown creature made up of `"Mojoc"` letters.
  ```
  M : ears  
  OO: eyes  
  J : body  
  C : tail
  ```
  
#### How was Mojoc was born?

  Mojoc started in 2012 as a spare time project. At first, Mojoc used Eclipse + CDT + ADT + NDK for development, and was focused on Android platform. 
    
  During the development I experienced a lot of repetition and thinking. For a long time I was not very sure and clear about how to use the C language to simulate OOP and keep it simple and uniform. So I tried a lot of ideas, repeated the proces: wrote code, modified, refactored, changed ideas, deleted code, rewrote it again and so on.
  
  But in the end, I developed a unique rule set, the [Mojoc Code Style](./Docs/CodeStyle.md) and [Mojoc OOC Model](./Docs/OOC.md) that felt right and nice, then I followed the rules to develop Mojoc.


#### What kind of games can Mojoc do?

  For now, it is not recommended to use Mojoc to make games. To be honest, Mojoc is not yet quite perfect. There are many improvements and refinements left to be made, that I'm currently working on. But Mojoc's code architecture and programming model have already been established. 
  
  Therefore Mojoc is very suitable for learning and understanding of how to use the C language to build game engine.
  
  
## Roadmap
The roadmap shows the direction of Mojoc development.

#### Graphics Module
  * Create graphics layer compatible with Vulkan, Metal and D3D.
  * Create material system control shaders.
  * Support Primitive Restart and DrawInstance.
  * Support Sampler Objects and Immutable Textures.
  * Support dynamic Multi-Texture Unit rendering.
  
#### Extension Module
  * Support bitmap fonts.
  * Support simple unit tests for Mojoc features.
  
#### Physics Module
  * Support motion simulation after rigid body collision.
  * Support mutual restriction and linkage between rigid bodies.
  * Support more physical motion simulations.  
  
#### Toolkit Module  
  * Generic iteration interface, it's a step-by-step calculation that can be driven by coroutine.
  * Memory management strategy for many to one.
  * Plug-in function extensions.
  * More algorithm implementation.  
  
#### Other Modules  
  * Create UI module.
  * Create network module.
  
#### Others
  * Game editor implemented with Mojoc itself.
  * Game script language `"MojoScript"`, implemented with the C language and Toolkit module.  

## Support
  * Play Mojoc [Published Games](#published-games).
  * Star & Issue & Fork on GitHub, or share **Mojoc** project to anyone.
  * If the source code is **useful** or **helpful** for you, maybe buy me a coffee via **Sponsor Button**.
  
##  
:loop:

```

`Samples/SuperLittleRed/Android/app/build.gradle`:

```gradle
apply plugin: "com.android.application"

android {
    compileSdk 32
    defaultConfig {
        applicationId "com.Mojoc.Samples.SuperLittleRed"
        minSdk 30
        ndk {
            abiFilters "armeabi-v7a", "arm64-v8a"
            ndkVersion "26.1.10909125"
        }
        externalNativeBuild {
            cmake {
                arguments "-DANDROID_TOOLCHAIN=clang"
                cFlags    "-std=c99 -O3"
            }
        }
    }
    buildTypes {
        debug {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile("proguard-android.txt"), "proguard-rules.pro"
            jniDebuggable true
            pseudoLocalesEnabled true
        }
    }
    externalNativeBuild {
        cmake {
            path "../../Code/Build/Android/CMakeLists.txt"
        }
    }
    productFlavors {
    }
    namespace 'com.Mojoc.Samples.SuperLittleRed'
}

dependencies {
    implementation fileTree(include: ["*.jar"], dir: "libs")
}
```

`Samples/SuperLittleRed/Android/app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in /Users/scottcgi/Program/android-sdk/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# Add any project specific keep options here:

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}


-keepclassmembers class * extends android.app.Activity {
   public *;
}


-keepattributes *Annotation*
```

`Samples/SuperLittleRed/Android/app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.Mojoc.Samples.SuperLittleRed">

    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.INTERNET"              />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"  />
    <uses-permission android:name="android.permission.WAKE_LOCK"             />
    <uses-permission android:name="android.permission.VIBRATE"               />

    <application android:label      ="@string/app_name"
                 android:hasCode    ="true"
                 android:allowBackup="true"
                 android:noHistory  ="false">

        <!-- Our activity is the built-in NativeActivity framework class.
             This will take care of integrating with our NDK code. -->
        <activity android:name             ="com.Mojoc.Samples.SuperLittleRed.GameActivity"
                  android:label            ="@string/app_name"
                  android:configChanges     ="keyboardHidden|orientation|screenSize"
                  android:theme            ="@android:style/Theme.NoTitleBar.Fullscreen"
                  android:screenOrientation="sensorLandscape">

            <!-- Tell NativeActivity the name of or .so -->
            <meta-data android:name="android.app.lib_name"  android:value="SuperLittleRed" />

            <!-- Tell NativeActivity the entry of native code -->
            <meta-data android:name="android.app.func_name" android:value="ANativeActivity_OnCreate" />

            <intent-filter>
                <action   android:name="android.intent.action.MAIN" />
                <action   android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

        </activity>

    </application>

</manifest>


```

`Samples/SuperLittleRed/Android/app/src/main/assets/Animation/dizzy-star.atlas`:

```atlas

dizzy-star.png
size: 64,32
format: RGBA8888
filter: Linear,Linear
repeat: none
d1
  rotate: false
  xy: 2, 2
  size: 15, 16
  orig: 15, 16
  offset: 0, 0
  index: -1
s1
  rotate: false
  xy: 19, 4
  size: 15, 14
  orig: 15, 14
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/Animation/dizzy-star.json`:

```json
{
"skeleton": { "hash": "DTGc2BIg/GCGazxYgsps6iJwRnU", "spine": "3.5.14-beta", "width": 0, "height": 0 },
"bones": [
	{ "name": "root" },
	{ "name": "bone", "parent": "root", "length": 53.31 },
	{ "name": "bone2", "parent": "root", "length": 53.31 },
	{ "name": "bone3", "parent": "root", "length": 53.31 },
	{ "name": "bone4", "parent": "root", "length": 53.31 }
],
"slots": [
	{ "name": "1", "bone": "bone", "attachment": "1" },
	{ "name": "4", "bone": "bone4", "attachment": "1" },
	{ "name": "2", "bone": "bone2", "attachment": "1" },
	{ "name": "3", "bone": "bone3", "attachment": "1" }
],
"skins": {
	"default": {},
	"duck": {
		"1": {
			"1": { "name": "d1", "width": 15, "height": 16 }
		},
		"2": {
			"1": { "name": "d1", "width": 15, "height": 16 }
		},
		"3": {
			"1": { "name": "d1", "width": 15, "height": 16 }
		},
		"4": {
			"1": { "name": "d1", "width": 15, "height": 16 }
		}
	},
	"star": {
		"1": {
			"1": { "name": "s1", "rotation": -113.2, "width": 15, "height": 14 }
		},
		"2": {
			"1": { "name": "s1", "rotation": -113.2, "width": 15, "height": 14 }
		},
		"3": {
			"1": { "name": "s1", "rotation": -113.2, "width": 15, "height": 14 }
		},
		"4": {
			"1": { "name": "s1", "rotation": -113.2, "width": 15, "height": 14 }
		}
	}
},
"animations": {
	"animation": {
		"slots": {
			"1": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 0.3333, "color": "ffffffbe" },
					{ "time": 0.6667, "color": "ffffff7e" },
					{ "time": 1, "color": "ffffffbe" },
					{ "time": 1.3333, "color": "ffffffff" }
				]
			},
			"2": {
				"color": [
					{ "time": 0, "color": "ffffffbe" },
					{ "time": 0.3333, "color": "ffffff7e", "curve": "stepped" },
					{ "time": 0.6667, "color": "ffffff7e" },
					{ "time": 1, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffffbe" }
				]
			},
			"3": {
				"color": [
					{ "time": 0, "color": "ffffff7e" },
					{ "time": 0.3333, "color": "ffffffbe" },
					{ "time": 0.6667, "color": "ffffffff" },
					{ "time": 1, "color": "ffffffbe" },
					{ "time": 1.3333, "color": "ffffff7e" }
				]
			},
			"4": {
				"color": [
					{ "time": 0, "color": "ffffffbe" },
					{ "time": 0.3333, "color": "ffffffff" },
					{ "time": 0.6667, "color": "ffffffbe" },
					{ "time": 1, "color": "ffffff7e" },
					{ "time": 1.3333, "color": "ffffffbe" }
				]
			}
		},
		"bones": {
			"bone": {
				"translate": [
					{ "time": 0, "x": 0, "y": 20 },
					{ "time": 0.3333, "x": -25, "y": 20 },
					{ "time": 0.6667, "x": 0, "y": 20 },
					{ "time": 1, "x": 25, "y": 20 },
					{ "time": 1.3333, "x": 0, "y": 20 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 },
					{ "time": 0.3333, "x": 0.75, "y": 0.75 },
					{ "time": 0.6667, "x": 0.5, "y": 0.5 },
					{ "time": 1, "x": 0.75, "y": 0.75 },
					{ "time": 1.3333, "x": 1, "y": 1 }
				]
			},
			"bone2": {
				"translate": [
					{ "time": 0, "x": -25, "y": 20 },
					{ "time": 0.3333, "x": 0, "y": 20 },
					{ "time": 0.6667, "x": 25, "y": 20 },
					{ "time": 1, "x": 0, "y": 20 },
					{ "time": 1.3333, "x": -25, "y": 20 }
				],
				"scale": [
					{ "time": 0, "x": 0.75, "y": 0.75 },
					{ "time": 0.3333, "x": 0.5, "y": 0.5 },
					{ "time": 0.6667, "x": 0.75, "y": 0.75 },
					{ "time": 1, "x": 1, "y": 1 },
					{ "time": 1.3333, "x": 0.75, "y": 0.75 }
				]
			},
			"bone3": {
				"translate": [
					{ "time": 0, "x": 0, "y": 20 },
					{ "time": 0.3333, "x": 25, "y": 20 },
					{ "time": 0.6667, "x": 0, "y": 20 },
					{ "time": 1, "x": -25, "y": 20 },
					{ "time": 1.3333, "x": 0, "y": 20 }
				],
				"scale": [
					{ "time": 0, "x": 0.5, "y": 0.5 },
					{ "time": 0.3333, "x": 0.75, "y": 0.75 },
					{ "time": 0.6667, "x": 1, "y": 1 },
					{ "time": 1, "x": 0.75, "y": 0.75 },
					{ "time": 1.3333, "x": 0.5, "y": 0.5 }
				]
			},
			"bone4": {
				"translate": [
					{ "time": 0, "x": 25, "y": 20 },
					{ "time": 0.3333, "x": 0, "y": 20 },
					{ "time": 0.6667, "x": -25, "y": 20 },
					{ "time": 1, "x": 0, "y": 20 },
					{ "time": 1.3333, "x": 25, "y": 20 }
				],
				"scale": [
					{ "time": 0, "x": 0.75, "y": 0.75 },
					{ "time": 0.3333, "x": 1, "y": 1 },
					{ "time": 0.6667, "x": 0.75, "y": 0.75 },
					{ "time": 1, "x": 0.5, "y": 0.5 },
					{ "time": 1.3333, "x": 0.75, "y": 0.75 }
				]
			},
			"root": {
				"translate": [
					{ "time": 0, "x": 0, "y": -20 }
				]
			}
		},
		"drawOrder": [
			{ "time": 0 }
		]
	}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/Animation/hit-floor.atlas`:

```atlas

hit-floor.png
size: 2048,128
format: RGBA8888
filter: Linear,Linear
repeat: none
1
  rotate: false
  xy: 2, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
10
  rotate: false
  xy: 518, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
11
  rotate: false
  xy: 647, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
12
  rotate: false
  xy: 647, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
13
  rotate: false
  xy: 776, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
14
  rotate: false
  xy: 776, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
15
  rotate: false
  xy: 905, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
16
  rotate: false
  xy: 905, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
17
  rotate: false
  xy: 1034, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
18
  rotate: false
  xy: 1034, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
2
  rotate: false
  xy: 2, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
3
  rotate: false
  xy: 131, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
4
  rotate: false
  xy: 131, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
5
  rotate: false
  xy: 260, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
6
  rotate: false
  xy: 260, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
7
  rotate: false
  xy: 389, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
8
  rotate: false
  xy: 389, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
9
  rotate: false
  xy: 518, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/Animation/hit-floor.json`:

```json
{
"skeleton": { "hash": "71kAShBrxZc5a2wcMuXv4Y2+UQo", "spine": "3.5.14-beta", "width": 0, "height": 0 },
"bones": [
	{ "name": "root" },
	{ "name": "bone", "parent": "root", "length": 40.71, "y": 28.5 }
],
"slots": [
	{ "name": "1", "bone": "bone", "attachment": "12" }
],
"skins": {
	"default": {
		"1": {
			"1": { "width": 127, "height": 57 },
			"2": { "width": 127, "height": 57 },
			"3": { "width": 127, "height": 57 },
			"4": { "width": 127, "height": 57 },
			"5": { "width": 127, "height": 57 },
			"6": { "width": 127, "height": 57 },
			"7": { "width": 127, "height": 57 },
			"8": { "width": 127, "height": 57 },
			"9": { "width": 127, "height": 57 },
			"10": { "width": 127, "height": 57 },
			"11": { "width": 127, "height": 57 },
			"12": { "width": 127, "height": 57 },
			"13": { "width": 127, "height": 57 },
			"14": { "width": 127, "height": 57 },
			"15": { "width": 127, "height": 57 },
			"16": { "width": 127, "height": 57 },
			"17": { "width": 127, "height": 57 },
			"18": { "width": 127, "height": 57 }
		}
	}
},
"animations": {
	"animation": {
		"slots": {
			"1": {
				"attachment": [
					{ "time": 0, "name": "18" },
					{ "time": 0.0333, "name": "17" },
					{ "time": 0.0667, "name": "16" },
					{ "time": 0.1, "name": "15" },
					{ "time": 0.1333, "name": "14" },
					{ "time": 0.1667, "name": "13" },
					{ "time": 0.2, "name": "12" },
					{ "time": 0.2333, "name": "11" },
					{ "time": 0.2667, "name": "10" },
					{ "time": 0.3, "name": "9" },
					{ "time": 0.3333, "name": "8" },
					{ "time": 0.3667, "name": "7" },
					{ "time": 0.4, "name": "6" },
					{ "time": 0.4333, "name": "5" },
					{ "time": 0.4667, "name": "4" },
					{ "time": 0.5, "name": "2" },
					{ "time": 0.5333, "name": "2" },
					{ "time": 0.5667, "name": "1" },
					{ "time": 0.6, "name": null }
				]
			}
		}
	}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/Animation/hit.atlas`:

```atlas

hit.png
size: 1024,128
format: RGBA8888
filter: Linear,Linear
repeat: none
1
  rotate: false
  xy: 206, 79
  size: 90, 45
  orig: 90, 45
  offset: 0, 0
  index: -1
11
  rotate: false
  xy: 2, 79
  size: 100, 45
  orig: 100, 45
  offset: 0, 0
  index: -1
2
  rotate: false
  xy: 2, 23
  size: 90, 54
  orig: 90, 54
  offset: 0, 0
  index: -1
3
  rotate: false
  xy: 298, 75
  size: 90, 49
  orig: 90, 49
  offset: 0, 0
  index: -1
4
  rotate: false
  xy: 390, 78
  size: 90, 46
  orig: 90, 46
  offset: 0, 0
  index: -1
5
  rotate: false
  xy: 482, 79
  size: 90, 45
  orig: 90, 45
  offset: 0, 0
  index: -1
6
  rotate: false
  xy: 574, 82
  size: 90, 42
  orig: 90, 42
  offset: 0, 0
  index: -1
7
  rotate: false
  xy: 666, 83
  size: 90, 41
  orig: 90, 41
  offset: 0, 0
  index: -1
8
  rotate: false
  xy: 758, 84
  size: 90, 40
  orig: 90, 40
  offset: 0, 0
  index: -1
9
  rotate: false
  xy: 104, 81
  size: 100, 43
  orig: 100, 43
  offset: 0, 0
  index: -1
10
  rotate: false
  xy: 104, 81
  size: 100, 43
  orig: 100, 43
  offset: 0, 0
  index: -1
_1
  rotate: false
  xy: 912, 66
  size: 50, 58
  orig: 50, 58
  offset: 0, 0
  index: -1
_10
  rotate: false
  xy: 954, 2
  size: 50, 62
  orig: 50, 62
  offset: 0, 0
  index: -1
_11
  rotate: false
  xy: 850, 92
  size: 60, 32
  orig: 60, 32
  offset: 0, 0
  index: -1
_2
  rotate: false
  xy: 94, 22
  size: 50, 55
  orig: 50, 55
  offset: 0, 0
  index: -1
_3
  rotate: false
  xy: 146, 22
  size: 50, 57
  orig: 50, 57
  offset: 0, 0
  index: -1
_4
  rotate: false
  xy: 198, 22
  size: 50, 55
  orig: 50, 55
  offset: 0, 0
  index: -1
_5
  rotate: false
  xy: 850, 33
  size: 50, 57
  orig: 50, 57
  offset: 0, 0
  index: -1
_6
  rotate: false
  xy: 964, 66
  size: 50, 58
  orig: 50, 58
  offset: 0, 0
  index: -1
_7
  rotate: false
  xy: 902, 6
  size: 50, 58
  orig: 50, 58
  offset: 0, 0
  index: -1
_8
  rotate: false
  xy: 250, 17
  size: 50, 56
  orig: 50, 56
  offset: 0, 0
  index: -1
_9
  rotate: false
  xy: 302, 16
  size: 50, 57
  orig: 50, 57
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/Animation/hit.json`:

```json
{
"skeleton": { "hash": "ffi2g34bLa9rtLBtdmeTa8Rq0+o", "spine": "3.5.14-beta", "width": 100, "height": 45 },
"bones": [
	{ "name": "root" },
	{ "name": "bone", "parent": "root", "length": 47.17, "x": 15 }
],
"slots": [
	{ "name": "1", "bone": "bone", "attachment": "11" }
],
"skins": {
	"default": {},
	"die": {
		"1": {
			"1": { "width": 90, "height": 45 },
			"2": { "width": 90, "height": 54 },
			"3": { "width": 90, "height": 49 },
			"4": { "width": 90, "height": 46 },
			"5": { "width": 90, "height": 45 },
			"6": { "width": 90, "height": 42 },
			"7": { "width": 90, "height": 41 },
			"8": { "width": 90, "height": 40 },
			"9": { "width": 100, "height": 43 },
			"10": { "width": 100, "height": 43 },
			"11": { "width": 100, "height": 45 }
		}
	},
	"normal": {
		"1": {
			"1": { "name": "_1", "width": 50, "height": 58 },
			"2": { "name": "_2", "width": 50, "height": 55 },
			"3": { "name": "_3", "width": 50, "height": 57 },
			"4": { "name": "_4", "width": 50, "height": 55 },
			"5": { "name": "_5", "width": 50, "height": 57 },
			"6": { "name": "_6", "width": 50, "height": 58 },
			"7": { "name": "_7", "width": 50, "height": 58 },
			"8": { "name": "_8", "width": 50, "height": 56 },
			"9": { "name": "_9", "width": 50, "height": 57 },
			"10": { "name": "_10", "width": 50, "height": 62 },
			"11": { "name": "_11", "width": 60, "height": 32 }
		}
	}
},
"animations": {
	"animation": {
		"slots": {
			"1": {
				"attachment": [
					{ "time": 0, "name": "1" },
					{ "time": 0.0333, "name": "2" },
					{ "time": 0.0667, "name": "3" },
					{ "time": 0.1, "name": "4" },
					{ "time": 0.1333, "name": "5" },
					{ "time": 0.1667, "name": "6" },
					{ "time": 0.2, "name": "7" },
					{ "time": 0.2333, "name": "8" },
					{ "time": 0.3, "name": "9" },
					{ "time": 0.3667, "name": "10" },
					{ "time": 0.4333, "name": "11" },
					{ "time": 0.5, "name": null }
				]
			}
		}
	}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/Animation/redgirl.atlas`:

```atlas

redgirl.png
size: 512,128
format: RGBA8888
filter: Linear,Linear
repeat: none
Copper
  rotate: false
  xy: 270, 5
  size: 25, 75
  orig: 25, 75
  offset: 0, 0
  index: -1
Dragon
  rotate: false
  xy: 105, 57
  size: 32, 69
  orig: 32, 69
  offset: 0, 0
  index: -1
Gold
  rotate: false
  xy: 2, 51
  size: 32, 75
  orig: 32, 75
  offset: 0, 0
  index: -1
Heart
  rotate: false
  xy: 379, 7
  size: 22, 74
  orig: 22, 74
  offset: 0, 0
  index: -1
Ice
  rotate: false
  xy: 36, 52
  size: 30, 74
  orig: 30, 74
  offset: 0, 0
  index: -1
Iron
  rotate: false
  xy: 183, 9
  size: 27, 75
  orig: 27, 75
  offset: 0, 0
  index: -1
Lightning
  rotate: false
  xy: 68, 57
  size: 35, 69
  orig: 35, 69
  offset: 0, 0
  index: -1
Silver
  rotate: false
  xy: 212, 4
  size: 27, 80
  orig: 27, 80
  offset: 0, 0
  index: -1
Steel
  rotate: false
  xy: 241, 5
  size: 27, 75
  orig: 27, 75
  offset: 0, 0
  index: -1
Wood
  rotate: false
  xy: 353, 8
  size: 24, 73
  orig: 24, 73
  offset: 0, 0
  index: -1
armour-body-down
  rotate: false
  xy: 297, 35
  size: 22, 17
  orig: 22, 17
  offset: 0, 0
  index: -1
armour-body-up
  rotate: false
  xy: 322, 57
  size: 19, 17
  orig: 19, 17
  offset: 0, 0
  index: -1
armour-face
  rotate: false
  xy: 201, 86
  size: 50, 40
  orig: 50, 40
  offset: 0, 0
  index: -1
armour-lefthand-down
  rotate: false
  xy: 297, 2
  size: 15, 13
  orig: 15, 13
  offset: 0, 0
  index: -1
armour-lefthand-up
  rotate: false
  xy: 497, 109
  size: 13, 17
  orig: 13, 17
  offset: 0, 0
  index: -1
armour-leftleg-down
  rotate: false
  xy: 127, 37
  size: 10, 18
  orig: 10, 18
  offset: 0, 0
  index: -1
armour-righthand-down
  rotate: false
  xy: 438, 70
  size: 12, 15
  orig: 12, 15
  offset: 0, 0
  index: -1
armour-righthand-up
  rotate: false
  xy: 403, 69
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
armour-rightleg-down
  rotate: false
  xy: 403, 13
  size: 10, 18
  orig: 10, 18
  offset: 0, 0
  index: -1
body-down
  rotate: false
  xy: 44, 30
  size: 25, 20
  orig: 25, 20
  offset: 0, 0
  index: -1
body-up
  rotate: false
  xy: 163, 30
  size: 18, 16
  orig: 18, 16
  offset: 0, 0
  index: -1
bunny-body-down
  rotate: false
  xy: 71, 38
  size: 28, 17
  orig: 28, 17
  offset: 0, 0
  index: -1
bunny-body-up
  rotate: false
  xy: 297, 17
  size: 20, 16
  orig: 20, 16
  offset: 0, 0
  index: -1
bunny-face
  rotate: false
  xy: 253, 82
  size: 50, 44
  orig: 50, 44
  offset: 0, 0
  index: -1
bunny-lefthand-down
  rotate: false
  xy: 314, 2
  size: 14, 13
  orig: 14, 13
  offset: 0, 0
  index: -1
bunny-leftleg-down
  rotate: false
  xy: 319, 17
  size: 11, 16
  orig: 11, 16
  offset: 0, 0
  index: -1
bunny-righthand-down
  rotate: false
  xy: 420, 53
  size: 11, 14
  orig: 11, 14
  offset: 0, 0
  index: -1
bunny-rightleg-down
  rotate: false
  xy: 452, 71
  size: 11, 16
  orig: 11, 16
  offset: 0, 0
  index: -1
cloak-down
  rotate: false
  xy: 139, 48
  size: 42, 36
  orig: 42, 36
  offset: 0, 0
  index: -1
cloak-up
  rotate: false
  xy: 353, 83
  size: 44, 43
  orig: 44, 43
  offset: 0, 0
  index: -1
egypt-body-down
  rotate: false
  xy: 101, 34
  size: 24, 21
  orig: 24, 21
  offset: 0, 0
  index: -1
egypt-body-up
  rotate: false
  xy: 139, 32
  size: 22, 14
  orig: 22, 14
  offset: 0, 0
  index: -1
egypt-face
  rotate: false
  xy: 399, 87
  size: 48, 39
  orig: 48, 39
  offset: 0, 0
  index: -1
egypt-leftleg-down
  rotate: false
  xy: 343, 57
  size: 8, 17
  orig: 8, 17
  offset: 0, 0
  index: -1
egypt-righthand-down
  rotate: false
  xy: 455, 55
  size: 11, 14
  orig: 11, 14
  offset: 0, 0
  index: -1
egypt-rightleg-down
  rotate: false
  xy: 321, 35
  size: 11, 17
  orig: 11, 17
  offset: 0, 0
  index: -1
face
  rotate: false
  xy: 449, 89
  size: 46, 37
  orig: 46, 37
  offset: 0, 0
  index: -1
lefthand-down
  rotate: false
  xy: 465, 72
  size: 12, 15
  orig: 12, 15
  offset: 0, 0
  index: -1
lefthand-up
  rotate: false
  xy: 334, 39
  size: 12, 16
  orig: 12, 16
  offset: 0, 0
  index: -1
leftleg-down
  rotate: false
  xy: 64, 11
  size: 9, 17
  orig: 9, 17
  offset: 0, 0
  index: -1
leftleg-up
  rotate: false
  xy: 433, 53
  size: 9, 15
  orig: 9, 15
  offset: 0, 0
  index: -1
luffy-body-down
  rotate: false
  xy: 2, 8
  size: 25, 22
  orig: 25, 22
  offset: 0, 0
  index: -1
luffy-body-up
  rotate: false
  xy: 297, 54
  size: 23, 20
  orig: 23, 20
  offset: 0, 0
  index: -1
luffy-face
  rotate: false
  xy: 139, 86
  size: 60, 40
  orig: 60, 40
  offset: 0, 0
  index: -1
luffy-lefthand-down
  rotate: false
  xy: 403, 53
  size: 15, 14
  orig: 15, 14
  offset: 0, 0
  index: -1
luffy-lefthand-up
  rotate: false
  xy: 421, 71
  size: 15, 14
  orig: 15, 14
  offset: 0, 0
  index: -1
luffy-leftleg-down
  rotate: false
  xy: 403, 33
  size: 11, 18
  orig: 11, 18
  offset: 0, 0
  index: -1
luffy-righthand-down
  rotate: false
  xy: 497, 74
  size: 13, 14
  orig: 13, 14
  offset: 0, 0
  index: -1
luffy-righthand-up
  rotate: false
  xy: 497, 90
  size: 13, 17
  orig: 13, 17
  offset: 0, 0
  index: -1
luffy-rightleg-down
  rotate: false
  xy: 29, 12
  size: 12, 18
  orig: 12, 18
  offset: 0, 0
  index: -1
neck
  rotate: false
  xy: 29, 2
  size: 8, 8
  orig: 8, 8
  offset: 0, 0
  index: -1
righthand-down
  rotate: false
  xy: 468, 59
  size: 15, 11
  orig: 15, 11
  offset: 0, 0
  index: -1
righthand-up
  rotate: false
  xy: 479, 77
  size: 16, 10
  orig: 16, 10
  offset: 0, 0
  index: -1
rightleg-down
  rotate: false
  xy: 416, 34
  size: 8, 17
  orig: 8, 17
  offset: 0, 0
  index: -1
rightleg-up
  rotate: false
  xy: 444, 53
  size: 9, 15
  orig: 9, 15
  offset: 0, 0
  index: -1
swan-body-down
  rotate: false
  xy: 2, 32
  size: 40, 17
  orig: 40, 17
  offset: 0, 0
  index: -1
swan-body-up
  rotate: false
  xy: 43, 11
  size: 19, 17
  orig: 19, 17
  offset: 0, 0
  index: -1
swan-face
  rotate: false
  xy: 305, 76
  size: 46, 50
  orig: 46, 50
  offset: 0, 0
  index: -1
swan-leftleg-down
  rotate: false
  xy: 426, 34
  size: 8, 17
  orig: 8, 17
  offset: 0, 0
  index: -1
swan-rightleg-down
  rotate: false
  xy: 436, 34
  size: 10, 17
  orig: 10, 17
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/Animation/redgirl.json`:

```json
{
"skeleton": { "hash": "2Tt2moY3s7p3iveeQdrv3MP45n4", "spine": "3.7.91", "width": 55.07, "height": 80.34 },
"bones": [
	{ "name": "root" },
	{ "name": "body-down", "parent": "root", "length": 6.92, "rotation": -86.85, "x": 0.34, "y": 29.22 },
	{ "name": "body-up", "parent": "root", "length": 8.9, "rotation": -86.4, "x": -1.49, "y": 39.23 },
	{ "name": "righthand-up", "parent": "root", "length": 9.55, "rotation": -8.4, "x": 0.48, "y": 39.79 },
	{ "name": "righthand-down", "parent": "righthand-up", "length": 10.7, "rotation": 26.75, "x": 11.17, "y": 0.51 },
	{ "name": "bow", "parent": "righthand-down", "length": 6.78, "rotation": 2.25, "x": 16.32, "y": -0.96 },
	{ "name": "cloak-down", "parent": "body-down", "length": 15.43, "rotation": -14.99, "x": -18.44, "y": -5.67 },
	{ "name": "face", "parent": "root", "length": 13.68, "rotation": 90.9, "x": 0.09, "y": 46.6 },
	{ "name": "cloak-up", "parent": "face", "length": 14.02, "rotation": 11.57, "x": 12.44, "y": 2.23 },
	{ "name": "lefthand-up", "parent": "root", "length": 8.66, "rotation": -127.03, "x": -4.74, "y": 39.67 },
	{ "name": "lefthand-down", "parent": "lefthand-up", "length": 12.12, "rotation": 7.62, "x": 9.24, "y": -0.09 },
	{ "name": "leftleg-up", "parent": "body-down", "length": 9.23, "rotation": -9.9, "x": 4.7, "y": -4.35 },
	{ "name": "leftleg-down", "parent": "leftleg-up", "length": 12.42, "rotation": 4.09, "x": 10.36, "y": -0.05 },
	{ "name": "neck", "parent": "root", "length": 3.95, "rotation": -90, "x": -1.77, "y": 43.43 },
	{ "name": "rightleg-up", "parent": "body-down", "length": 8.54, "rotation": 4.05, "x": 5.02, "y": 3.99 },
	{ "name": "rightleg-down", "parent": "rightleg-up", "length": 12.42, "rotation": 1071.79, "x": 9.98, "y": -0.13 }
],
"slots": [
	{ "name": "bow", "bone": "bow", "attachment": "Bow" },
	{ "name": "cloak-down", "bone": "cloak-down", "attachment": "cloak-down" },
	{ "name": "leftleg-up", "bone": "leftleg-up", "attachment": "leftleg-up" },
	{ "name": "leftleg-down", "bone": "leftleg-down", "attachment": "leftleg-down" },
	{ "name": "rightleg-up", "bone": "rightleg-up", "attachment": "rightleg-up" },
	{ "name": "rightleg-down", "bone": "rightleg-down", "attachment": "rightleg-down" },
	{ "name": "righthand-up", "bone": "righthand-up", "attachment": "righthand-up" },
	{ "name": "righthand-down", "bone": "righthand-down", "attachment": "righthand-down" },
	{ "name": "body-down", "bone": "body-down", "attachment": "body-down" },
	{ "name": "neck", "bone": "neck", "attachment": "neck" },
	{ "name": "face", "bone": "face", "attachment": "face" },
	{ "name": "cloak-up", "bone": "cloak-up", "attachment": "cloak-up" },
	{ "name": "body-up", "bone": "body-up", "attachment": "body-up" },
	{ "name": "lefthand-up", "bone": "lefthand-up", "attachment": "lefthand-up" },
	{ "name": "lefthand-down", "bone": "lefthand-down", "attachment": "lefthand-down" },
	{ "name": "CollisionBox", "bone": "root", "color": "00ff00ff", "attachment": "CollisionBox" }
],
"skins": {
	"default": {
		"CollisionBox": {
			"CollisionBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -11.15, 11.87, 12.31, 11.87, 5.93, 73.19, -20.68, 72.42 ]
			}
		}
	},
	"ArmourCopper": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -9.85, "y": 4.2, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourDragon": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -14.2, "y": 5.34, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourGold": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -6.68, "y": 3.66, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourHeart": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -8.45, "y": 4.33, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourIce": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -10.87, "y": 3.22, "rotation": 339.4, "width": 30, "height": 74 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourIron": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -9.53, "y": 3.58, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourLightning": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -15.93, "y": 6.39, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourSilver": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.23, "y": 3.85, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourSteel": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -11.72, "y": 4.41, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourWood": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -9.08, "y": 5.43, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyCopper": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -9.85, "y": 4.2, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyDragon": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -14.03, "y": 3.68, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyGold": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -7.34, "y": -0.16, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyHeart": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -8.34, "y": 1, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyIce": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -11.57, "y": 0.85, "rotation": -20.6, "width": 30, "height": 74 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyIron": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -10.15, "y": 0.9, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyLightning": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -16.09, "y": 3.91, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnySilver": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.4, "y": 0.8, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnySteel": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -12.34, "y": 0.17, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyWood": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -9.72, "y": 2.68, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptCopper": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -9.85, "y": 4.2, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptDragon": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -13.99, "y": 4.29, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptGold": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -6.74, "y": 0.39, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptHeart": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -8.02, "y": 1.85, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptIce": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -11.42, "y": 1.77, "rotation": -20.6, "width": 30, "height": 74 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptIron": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -8.58, "y": 1.47, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptLightning": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -15.54, "y": 5.12, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptSilver": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.62, "y": 0.87, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptSteel": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -11.59, "y": 1.45, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptWood": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -9.35, "y": 2.99, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyCopper": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.29, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -10.58, "y": 1.57, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyDragon": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -13.84, "y": 4.67, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyGold": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -7.32, "y": 1.96, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyHeart": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -8.68, "y": 3, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyIce": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -10.96, "y": 2.27, "rotation": -20.6, "width": 30, "height": 74 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyIron": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -9.7, "y": 3.12, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyLightning": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -15.97, "y": 5.74, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffySilver": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.29, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.4, "y": 3.4, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffySteel": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -11.65, "y": 3.04, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyWood": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.32, "y": -1.33, "rotation": 84.77, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -9.81, "y": 3.97, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlCopper": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -9.85, "y": 4.2, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77061, 0, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 24.71, 27.34, 33.88, 19.07, 38.78, -4.3, 33.15, -13.8, 27.55, -11.92, 21.73, -9.97, 13.85, -7.33, 4.45, -0.44, 1.52, 13.89, 35.02, -3.32, 13.34, -2.39, 23.64, -3.29 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlDragon": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -15.24, "y": 4.87, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77021, 0.07302, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 24.64, 27.48, 33.81, 19.21, 38.7, -4.16, 33.08, -13.66, 27.48, -11.78, 21.66, -9.83, 13.78, -7.19, 4.37, -0.3, 1.07, 12.7, 34.95, -3.18, 13.27, -2.25, 23.57, -3.15 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlGold": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -7.34, "y": 1.9, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77998, 0.0786, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 1.87, 13.11, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlHeart": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -9.11, "y": 2.56, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.76531, 0.07303, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 1.8, 12.47, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlIce": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -11.13, "y": 2.53, "rotation": -20.6, "width": 30, "height": 74 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.76525, 0.08427, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 2.19, 12.56, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlIron": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -9.81, "y": 2.83, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77018, 0.07863, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 1.95, 12.71, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlLightning": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -16.16, "y": 5.21, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77015, 0.08425, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 2.15, 12.75, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlSilver": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.23, "y": 2.45, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.76528, 0.07865, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 1.99, 12.51, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlSteel": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -11.79, "y": 2.49, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77508, 0.07862, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 1.91, 12.91, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlWood": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -10.56, "y": 3.11, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77502, 0.08985, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 2.31, 12.99, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanCopper": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -10.6, "y": 1.26, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanDragon": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -14.51, "y": 4.99, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanGold": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -6.29, "y": 1.72, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanHeart": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -8.76, "y": 2.69, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanIce": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -10.63, "y": 2.78, "rotation": -20.6, "width": 30, "height": 74 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanIron": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -10.2, "y": 1.8, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanLightning": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -16.15, "y": 5.26, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanSilver": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.26, "y": 2.94, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanSteel": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -11.95, "y": 2.36, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanWood": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -9.33, "y": 3.51, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	}
},
"animations": {
	"attack": {
		"slots": {
			"lefthand-down": {
				"attachment": [
					{ "time": 0, "name": "lefthand-down" },
					{ "time": 0.1333, "name": "lefthand-down" },
					{ "time": 0.2667, "name": "lefthand-down" },
					{ "time": 0.4, "name": "lefthand-down" }
				]
			},
			"lefthand-up": {
				"attachment": [
					{ "time": 0, "name": "lefthand-up" },
					{ "time": 0.1333, "name": "lefthand-up" },
					{ "time": 0.2667, "name": "lefthand-up" },
					{ "time": 0.4, "name": "lefthand-up" }
				]
			},
			"righthand-down": {
				"attachment": [
					{ "time": 0, "name": "righthand-down" },
					{ "time": 0.1333, "name": "righthand-down" },
					{ "time": 0.2667, "name": "righthand-down" },
					{ "time": 0.4, "name": "righthand-down" }
				]
			}
		},
		"bones": {
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -44.17 },
					{ "time": 0.1333, "angle": -57.24 },
					{ "time": 0.2, "angle": -75.15 },
					{ "time": 0.2667, "angle": -57.24 },
					{ "time": 0.4, "angle": -44.17 }
				],
				"translate": [
					{ "time": 0, "x": 0.86, "y": 2.69 },
					{ "time": 0.1333, "x": 3.89, "y": 1.78 },
					{ "time": 0.2, "x": 7.22, "y": 2.08 },
					{ "time": 0.2667, "x": 3.89, "y": 1.78 },
					{ "time": 0.4, "x": 0.86, "y": 2.69 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.48, "curve": "stepped" },
					{ "time": 0.1333, "angle": -26.48, "curve": "stepped" },
					{ "time": 0.2, "angle": -26.48, "curve": "stepped" },
					{ "time": 0.2667, "angle": -26.48, "curve": "stepped" },
					{ "time": 0.4, "angle": -26.48 }
				],
				"translate": [
					{ "time": 0, "x": -0.41, "y": 1.56, "curve": "stepped" },
					{ "time": 0.1333, "x": -0.41, "y": 1.56, "curve": "stepped" },
					{ "time": 0.2, "x": -0.41, "y": 1.56, "curve": "stepped" },
					{ "time": 0.2667, "x": -0.41, "y": 1.56, "curve": "stepped" },
					{ "time": 0.4, "x": -0.41, "y": 1.56 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 11.11 },
					{ "time": 0.1333, "angle": 7.15 },
					{ "time": 0.2, "angle": 0.14 },
					{ "time": 0.2667, "angle": 7.15 },
					{ "time": 0.4, "angle": 11.11 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.1333, "x": -1.11, "y": -3.16 },
					{ "time": 0.2, "x": -1.19, "y": -12.67 },
					{ "time": 0.2667, "x": -1.11, "y": -3.16 },
					{ "time": 0.4, "x": 0, "y": 0 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 0.71 },
					{ "time": 0.1333, "angle": 4.73 },
					{ "time": 0.2, "angle": 10.72 },
					{ "time": 0.2667, "angle": 4.73 },
					{ "time": 0.4, "angle": 0.71 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 1.2 },
					{ "time": 0.1333, "angle": 25.28 },
					{ "time": 0.2, "angle": 59.79 },
					{ "time": 0.2667, "angle": 25.28 },
					{ "time": 0.4, "angle": 1.2 }
				],
				"translate": [
					{ "time": 0, "x": 1.35, "y": 0.83 },
					{ "time": 0.1333, "x": 3.56, "y": 1.92 },
					{ "time": 0.2, "x": 4.77, "y": 2.53 },
					{ "time": 0.2667, "x": 3.56, "y": 1.92 },
					{ "time": 0.4, "x": 1.35, "y": 0.83 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 9.32 },
					{ "time": 0.1333, "angle": -0.14 },
					{ "time": 0.2, "angle": -18.53 },
					{ "time": 0.2667, "angle": -0.14 },
					{ "time": 0.4, "angle": 9.32 }
				],
				"translate": [
					{ "time": 0, "x": 0.82, "y": -0.91 },
					{ "time": 0.1333, "x": 2.82, "y": -1.51 },
					{ "time": 0.2, "x": 7.67, "y": -2.42 },
					{ "time": 0.2667, "x": 2.82, "y": -1.51 },
					{ "time": 0.4, "x": 0.82, "y": -0.91 }
				],
				"scale": [
					{ "time": 0, "x": 1.113, "y": 1.113 },
					{ "time": 0.2, "x": 0.976, "y": 0.976 },
					{ "time": 0.4, "x": 1.113, "y": 1.113 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -0.32 },
					{ "time": 0.1333, "angle": -2.49 },
					{ "time": 0.2, "angle": -6.63 },
					{ "time": 0.2667, "angle": -2.49 },
					{ "time": 0.4, "angle": -0.32 }
				],
				"translate": [
					{ "time": 0, "x": -1.21, "y": -0.6 },
					{ "time": 0.1333, "x": 3.64, "y": 0 },
					{ "time": 0.2, "x": 9.7, "y": -2.12 },
					{ "time": 0.2667, "x": 3.64, "y": 0 },
					{ "time": 0.4, "x": -1.21, "y": -0.6 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -5.21 },
					{ "time": 0.1333, "angle": -8.04 },
					{ "time": 0.2, "angle": -9.71 },
					{ "time": 0.2667, "angle": -8.04 },
					{ "time": 0.4, "angle": -5.21 }
				],
				"translate": [
					{ "time": 0, "x": -2.09, "y": 4.22 },
					{ "time": 0.1333, "x": 0.15, "y": 4.72 },
					{ "time": 0.2, "x": 2.36, "y": 6.21 },
					{ "time": 0.2667, "x": 0.15, "y": 4.72 },
					{ "time": 0.4, "x": -2.09, "y": 4.22 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 4.42 },
					{ "time": 0.1333, "angle": 0.15 },
					{ "time": 0.2, "angle": -6.61 },
					{ "time": 0.2667, "angle": 0.15 },
					{ "time": 0.4, "angle": 4.42 }
				],
				"translate": [
					{ "time": 0, "x": 2.42, "y": -0.61, "curve": "stepped" },
					{ "time": 0.1333, "x": 2.42, "y": -0.61 },
					{ "time": 0.2, "x": 4.24, "y": -0.61 },
					{ "time": 0.2667, "x": 2.42, "y": -0.61, "curve": "stepped" },
					{ "time": 0.4, "x": 2.42, "y": -0.61 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 0.33 },
					{ "time": 0.1333, "angle": 364.6 },
					{ "time": 0.2, "angle": 371.35 },
					{ "time": 0.2667, "angle": 364.6 },
					{ "time": 0.4, "angle": 0.33 }
				],
				"translate": [
					{ "time": 0, "x": -0.07, "y": 0.98 },
					{ "time": 0.1333, "x": 0.17, "y": 1.33 },
					{ "time": 0.2, "x": 0.6, "y": 0.11 },
					{ "time": 0.2667, "x": 0.17, "y": 1.33 },
					{ "time": 0.4, "x": -0.07, "y": 0.98 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": -4.03 },
					{ "time": 0.1333, "angle": 360.23 },
					{ "time": 0.2, "angle": 366.99 },
					{ "time": 0.2667, "angle": 360.23 },
					{ "time": 0.4, "angle": -4.03 }
				],
				"translate": [
					{ "time": 0, "x": -0.31, "y": -0.06 },
					{ "time": 0.1333, "x": -0.61, "y": 0.28 },
					{ "time": 0.2, "x": -1.03, "y": -1.04 },
					{ "time": 0.2667, "x": -0.61, "y": 0.28 },
					{ "time": 0.4, "x": -0.31, "y": -0.06 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 360 },
					{ "time": 0.1333, "angle": 0, "curve": "stepped" },
					{ "time": 0.2, "angle": 0, "curve": "stepped" },
					{ "time": 0.2667, "angle": 0 },
					{ "time": 0.4, "angle": 360 }
				],
				"translate": [
					{ "time": 0, "x": 0.93, "y": -0.37 },
					{ "time": 0.1333, "x": 0.92, "y": -0.37 },
					{ "time": 0.2, "x": 0.92, "y": -0.37 },
					{ "time": 0.2667, "x": 0.92, "y": -0.37 },
					{ "time": 0.4, "x": 0.93, "y": -0.37 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 359.99 },
					{ "time": 0.1333, "angle": 360, "curve": "stepped" },
					{ "time": 0.2, "angle": 360, "curve": "stepped" },
					{ "time": 0.2667, "angle": 360 },
					{ "time": 0.4, "angle": 359.99 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1333, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.4, "x": 0, "y": 0 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 0.3, "y": 0.61 },
					{ "time": 0.1333, "x": 3.64, "y": 0.61 },
					{ "time": 0.2, "x": 6.97, "y": 1.21 },
					{ "time": 0.2667, "x": 3.64, "y": 0.61 },
					{ "time": 0.4, "x": 0.3, "y": 0.61 }
				]
			},
			"cloak-up": {
				"translate": [
					{ "time": 0, "x": 0.92, "y": 0.6 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -2.39238, -1.35028, -1.27872, 0.0833, 2.09261, 1.05291, 3.54564, 0.33106, 3.33067, -0.50987, 3.10725, -1.38391, 2.805, -2.56642, 1.89754, -4.01941, 0.13451, -5.01444, 1.98946, 0.49188, 2.08651, -2.69476, 2.10749, -1.17571 ],
							"curve": "stepped"
						},
						{
							"time": 0.1333,
							"vertices": [ -2.39238, -1.35028, -1.27872, 0.0833, 2.09261, 1.05291, 3.54564, 0.33106, 3.33067, -0.50987, 3.10725, -1.38391, 2.805, -2.56642, 1.89754, -4.01941, 0.13451, -5.01444, 1.98946, 0.49188, 2.08651, -2.69476, 2.10749, -1.17571 ],
							"curve": "stepped"
						},
						{
							"time": 0.2667,
							"vertices": [ -2.39238, -1.35028, -1.27872, 0.0833, 2.09261, 1.05291, 3.54564, 0.33106, 3.33067, -0.50987, 3.10725, -1.38391, 2.805, -2.56642, 1.89754, -4.01941, 0.13451, -5.01444, 1.98946, 0.49188, 2.08651, -2.69476, 2.10749, -1.17571 ],
							"curve": "stepped"
						},
						{
							"time": 0.4,
							"vertices": [ -2.39238, -1.35028, -1.27872, 0.0833, 2.09261, 1.05291, 3.54564, 0.33106, 3.33067, -0.50987, 3.10725, -1.38391, 2.805, -2.56642, 1.89754, -4.01941, 0.13451, -5.01444, 1.98946, 0.49188, 2.08651, -2.69476, 2.10749, -1.17571 ]
						}
					]
				}
			}
		}
	},
	"die": {
		"bones": {
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 },
					{ "time": 0.1667, "angle": 24.03 },
					{ "time": 0.3333, "angle": 22.64 },
					{ "time": 0.5, "angle": 27.52 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.1667, "x": -0.76, "y": -2.95 },
					{ "time": 0.3333, "x": 0.21, "y": -2.47 },
					{ "time": 0.5, "x": -0.81, "y": -2.63 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.72 },
					{ "time": 0.1667, "angle": -29.09 },
					{ "time": 0.3333, "angle": -6.55 },
					{ "time": 0.5, "angle": -30.3 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38 },
					{ "time": 0.5, "x": -1.88, "y": 1.95 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 },
					{ "time": 0.1667, "angle": 27.97 },
					{ "time": 0.3333, "angle": 35.75 },
					{ "time": 0.5, "angle": -25.22 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.1667, "x": -0.74, "y": -3.97 },
					{ "time": 0.3333, "x": 2.08, "y": -5.64 },
					{ "time": 0.5, "x": 0.41, "y": 0.17 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0.3333, "angle": 23.19 },
					{ "time": 0.5, "angle": 20.37 }
				],
				"translate": [
					{ "time": 0, "x": 0.61, "y": -4.26 },
					{ "time": 0.1667, "x": -1.93, "y": 4.8 },
					{ "time": 0.3333, "x": -2.51, "y": 0.79 },
					{ "time": 0.5, "x": -11.31, "y": -6.9 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -0.32 },
					{ "time": 0.5, "angle": -3.46 }
				],
				"translate": [
					{ "time": 0, "x": 0.8, "y": 2.09 },
					{ "time": 0.1667, "x": -4.72, "y": -0.84 },
					{ "time": 0.5, "x": 10.51, "y": -0.61 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -52.43 },
					{ "time": 0.1667, "angle": -2.76 },
					{ "time": 0.3333, "angle": 4.32 },
					{ "time": 0.5, "angle": -47.68 }
				],
				"translate": [
					{ "time": 0, "x": 1.44, "y": -0.49 },
					{ "time": 0.1667, "x": -2.09, "y": 6.27 },
					{ "time": 0.3333, "x": -5.55, "y": 0.08 },
					{ "time": 0.5, "x": -9.09, "y": -2.46 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 2.22 },
					{ "time": 0.3333, "angle": 45.85 },
					{ "time": 0.5, "angle": 53.29 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -3 },
					{ "time": 0.1667, "x": -2.61, "y": 5.73 },
					{ "time": 0.3333, "x": 0.71, "y": 1.96 },
					{ "time": 0.5, "x": -8.41, "y": -6.02 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": -56.84 },
					{ "time": 0.3333, "angle": 5.6 },
					{ "time": 0.5, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.94, "y": 0.15 },
					{ "time": 0.1667, "x": 1.9, "y": -4.47 },
					{ "time": 0.3333, "x": 1.68, "y": 0.44 },
					{ "time": 0.5, "x": 0.94, "y": 0.15 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 16.45 },
					{ "time": 0.1667, "angle": 0.83 },
					{ "time": 0.3333, "angle": 97.42 },
					{ "time": 0.5, "angle": 66.04 }
				],
				"translate": [
					{ "time": 0, "x": -0.3, "y": -3.01 },
					{ "time": 0.1667, "x": -1.59, "y": 4.52 },
					{ "time": 0.3333, "x": -5.48, "y": 3.54 },
					{ "time": 0.5, "x": -13.43, "y": -5.25 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 5.9 },
					{ "time": 0.1667, "angle": 4.39 },
					{ "time": 0.3333, "angle": 32.81 },
					{ "time": 0.5, "angle": 9.41 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.5, "x": -0.49, "y": -0.5 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.1667, "angle": 15.68 },
					{ "time": 0.3333, "angle": -11.05 },
					{ "time": 0.5, "angle": -0.97 }
				],
				"translate": [
					{ "time": 0, "x": -1, "y": -4 },
					{ "time": 0.1667, "x": -5.24, "y": 6.52 },
					{ "time": 0.3333, "x": -7.07, "y": 0.25 },
					{ "time": 0.5, "x": -12.98, "y": -5.51 }
				]
			},
			"neck": {
				"rotate": [
					{ "time": 0.5, "angle": -1.41 }
				],
				"translate": [
					{ "time": 0, "x": 0.9, "y": -0.74 },
					{ "time": 0.1667, "x": -1.58, "y": 7.89 },
					{ "time": 0.5, "x": -11.07, "y": -4.38 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": 7.72 },
					{ "time": 0.3333, "angle": 51.87 }
				],
				"translate": [
					{ "time": 0.1667, "x": 0.56, "y": 0.33 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": 55.41 },
					{ "time": 0.3333, "angle": 113.19 },
					{ "time": 0.3667, "angle": -168.41 },
					{ "time": 0.4, "angle": -114.16 },
					{ "time": 0.4333, "angle": -80.91 },
					{ "time": 0.5, "angle": -29.04 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.1667, "x": 6.01, "y": 22.42 },
					{ "time": 0.3333, "x": 25.41, "y": 23.64 },
					{ "time": 0.3667, "x": 6.34, "y": 19.41 },
					{ "time": 0.5, "x": -21.1, "y": -7.35 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0.1667, "angle": -42.91 }
				],
				"translate": [
					{ "time": 0.1667, "x": -1.14, "y": -2.21 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlDragon": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -9.99795, 13.63344, -11.08166, 11.92497, -12.38272, 9.80274, -11.37328, 6.9489, -13.78321, 0.42492, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlGold": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlHeart": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlIce": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlIron": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlLightning": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlSilver": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlSteel": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlWood": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			}
		}
	},
	"die_over": {
		"bones": {
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 27.52 }
				],
				"translate": [
					{ "time": 0, "x": -0.81, "y": -2.63 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -30.3 }
				],
				"translate": [
					{ "time": 0, "x": -1.88, "y": 1.95 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": -25.22 }
				],
				"translate": [
					{ "time": 0, "x": 0.41, "y": 0.17 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 20.37 }
				],
				"translate": [
					{ "time": 0, "x": -11.31, "y": -6.9 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -3.46 }
				],
				"translate": [
					{ "time": 0, "x": 10.51, "y": -0.61 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -47.68 }
				],
				"translate": [
					{ "time": 0, "x": -9.09, "y": -2.46 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 53.29 }
				],
				"translate": [
					{ "time": 0, "x": -7.92, "y": -6.65 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.94, "y": 0.15 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 66.04 }
				],
				"translate": [
					{ "time": 0, "x": -13.43, "y": -5.25 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 9.41 }
				],
				"translate": [
					{ "time": 0, "x": -0.49, "y": -0.5 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -0.97 }
				],
				"translate": [
					{ "time": 0, "x": -12.98, "y": -5.51 }
				]
			},
			"neck": {
				"rotate": [
					{ "time": 0, "angle": -1.41 }
				],
				"translate": [
					{ "time": 0, "x": -11.07, "y": -4.38 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 51.87 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": -29.04 }
				],
				"translate": [
					{ "time": 0, "x": -21.1, "y": -7.35 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": -42.91 }
				],
				"translate": [
					{ "time": 0, "x": -1.14, "y": -2.21 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlDragon": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlGold": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlHeart": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlIce": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlIron": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlLightning": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlSilver": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlSteel": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlWood": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			}
		}
	},
	"dizzy": {
		"slots": {
			"cloak-up": {
				"attachment": [
					{ "time": 0, "name": "cloak-up" },
					{ "time": 0.3, "name": "cloak-up" },
					{ "time": 0.3667, "name": "cloak-up" }
				]
			}
		},
		"bones": {
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1, "angle": 2.01 },
					{ "time": 0.1667, "angle": 5.76 },
					{ "time": 0.2, "angle": 4.1 },
					{ "time": 0.3, "angle": -5.47 },
					{ "time": 0.3667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.25 },
					{ "time": 0.1, "x": 0.51, "y": -0.79 },
					{ "time": 0.1667, "x": 2.09, "y": 0.58 },
					{ "time": 0.2, "x": 1.25, "y": -0.62 },
					{ "time": 0.3, "x": -2.43, "y": 0.28 },
					{ "time": 0.3667, "x": 0.62, "y": -0.25 }
				],
				"scale": [
					{ "time": 0.1, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.1667, "x": 1, "y": 1 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.1, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.1667, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.2, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.3, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.3667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.1, "x": -1, "y": 0.06, "curve": "stepped" },
					{ "time": 0.1667, "x": -1, "y": 0.06, "curve": "stepped" },
					{ "time": 0.2, "x": -1, "y": 0.06 },
					{ "time": 0.3, "x": -3, "y": 0.17, "curve": "stepped" },
					{ "time": 0.3667, "x": -3, "y": 0.17 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0, "angle": 0, "curve": "stepped" },
					{ "time": 0.1, "angle": 0, "curve": "stepped" },
					{ "time": 0.1667, "angle": 0 },
					{ "time": 0.2, "angle": 1.27 },
					{ "time": 0.3, "angle": -0.89 },
					{ "time": 0.3667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.3, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.3667, "x": 0, "y": 0 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.1, "angle": 5.16 },
					{ "time": 0.1667, "angle": 11.71 },
					{ "time": 0.2, "angle": -2.95 },
					{ "time": 0.3, "angle": -18.86 },
					{ "time": 0.3667, "angle": -3.1 }
				],
				"translate": [
					{ "time": 0, "x": -1, "y": -4 },
					{ "time": 0.1, "x": -1.91, "y": 4.34 },
					{ "time": 0.1667, "x": -0.65, "y": 9.9 },
					{ "time": 0.2, "x": -1.21, "y": 4.61 },
					{ "time": 0.3, "x": 1.32, "y": -9.96 },
					{ "time": 0.3667, "x": -1, "y": -4 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 380.99 },
					{ "time": 0.1, "angle": 33.93 },
					{ "time": 0.1667, "angle": 27.09 },
					{ "time": 0.2, "angle": 25.47 },
					{ "time": 0.3, "angle": 43.87 },
					{ "time": 0.3667, "angle": 380.99 }
				],
				"translate": [
					{ "time": 0, "x": -0.8, "y": 1.08 },
					{ "time": 0.1, "x": -2.1, "y": 2.76 },
					{ "time": 0.1667, "x": -2.61, "y": 2.82 },
					{ "time": 0.2, "x": -0.48, "y": 1.62 },
					{ "time": 0.3, "x": 1.45, "y": 1.37 },
					{ "time": 0.3667, "x": -0.79, "y": 1.08 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 16.45 },
					{ "time": 0.1, "angle": 1.57 },
					{ "time": 0.1667, "angle": 10.16 },
					{ "time": 0.2, "angle": 1.75 },
					{ "time": 0.3, "angle": -44.15 },
					{ "time": 0.3667, "angle": 16.45 }
				],
				"translate": [
					{ "time": 0, "x": -0.3, "y": -3.01 },
					{ "time": 0.1, "x": -0.14, "y": 5.1 },
					{ "time": 0.1667, "x": 1.11, "y": 11.56 },
					{ "time": 0.2, "x": -0.48, "y": 5.43 },
					{ "time": 0.3, "x": 1.65, "y": -8.54 },
					{ "time": 0.3667, "x": -0.3, "y": -3.01 }
				]
			},
			"neck": {
				"rotate": [
					{ "time": 0.1667, "angle": 10.27 },
					{ "time": 0.3, "angle": 6.7 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -5 },
					{ "time": 0.1, "x": -0.91, "y": 3.84 },
					{ "time": 0.1667, "x": -0.91, "y": 8.14 },
					{ "time": 0.2, "x": -0.91, "y": 3.84 },
					{ "time": 0.3, "x": 0.66, "y": -9.3 },
					{ "time": 0.3333, "x": 0, "y": -5 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 5.9 },
					{ "time": 0.1, "angle": 1.05 },
					{ "time": 0.1667, "angle": 2.81 },
					{ "time": 0.2, "angle": 21.67 },
					{ "time": 0.3, "angle": 120.93 },
					{ "time": 0.3667, "angle": 5.9 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2, "x": 0, "y": 0 },
					{ "time": 0.3, "x": 3.57, "y": -2.65 },
					{ "time": 0.3667, "x": 0, "y": 0 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": -7.48 },
					{ "time": 0.3, "angle": 1.13 },
					{ "time": 0.3667, "angle": 360 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -3 },
					{ "time": 0.1, "x": -0.91, "y": 5.34 },
					{ "time": 0.1667, "x": 0.09, "y": 10.31 },
					{ "time": 0.2, "x": -0.91, "y": 5.34 },
					{ "time": 0.3, "x": 0, "y": -6.31 },
					{ "time": 0.3667, "x": 0, "y": -3 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.72 },
					{ "time": 0.1, "angle": -33.78 },
					{ "time": 0.1667, "angle": -20.2 },
					{ "time": 0.2, "angle": -42.09 },
					{ "time": 0.3, "angle": -150.76 },
					{ "time": 0.3667, "angle": -26.72 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38 },
					{ "time": 0.1, "x": -0.98, "y": 2.62 },
					{ "time": 0.1667, "x": -1.37, "y": 2 },
					{ "time": 0.2, "x": -0.32, "y": 2.8 },
					{ "time": 0.3, "x": 4.23, "y": 2.15 },
					{ "time": 0.3667, "x": -0.4, "y": 1.38 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.1, "angle": 2.27 },
					{ "time": 0.1667, "angle": 3.56 },
					{ "time": 0.2, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.3, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.3667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.1, "x": -1, "y": 0.06, "curve": "stepped" },
					{ "time": 0.1667, "x": -1, "y": 0.06, "curve": "stepped" },
					{ "time": 0.2, "x": -1, "y": 0.06 },
					{ "time": 0.3, "x": -3, "y": 0.17, "curve": "stepped" },
					{ "time": 0.3667, "x": -3, "y": 0.17 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 0.68 },
					{ "time": 0.1, "angle": -0.97, "curve": "stepped" },
					{ "time": 0.1667, "angle": -0.97, "curve": "stepped" },
					{ "time": 0.2, "angle": -0.97 },
					{ "time": 0.3, "angle": -2.9 },
					{ "time": 0.3667, "angle": 0.68 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -4 },
					{ "time": 0.1, "x": -0.91, "y": 4.34 },
					{ "time": 0.1667, "x": 0.09, "y": 9.31 },
					{ "time": 0.2, "x": -0.91, "y": 4.34 },
					{ "time": 0.3, "x": 0.66, "y": -8.3 },
					{ "time": 0.3667, "x": 0, "y": -4 }
				],
				"scale": [
					{ "time": 0, "x": 0.873, "y": 0.873 },
					{ "time": 0.1, "x": 0.978, "y": 0.978 },
					{ "time": 0.1667, "x": 1.083, "y": 1.083 },
					{ "time": 0.2, "x": 0.978, "y": 0.978 },
					{ "time": 0.3, "x": 0.873, "y": 0.873, "curve": "stepped" },
					{ "time": 0.3667, "x": 0.873, "y": 0.873 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": 359.24 },
					{ "time": 0.1, "angle": -0.76, "curve": "stepped" },
					{ "time": 0.1667, "angle": -0.76, "curve": "stepped" },
					{ "time": 0.2, "angle": -0.76, "curve": "stepped" },
					{ "time": 0.3, "angle": -0.76 },
					{ "time": 0.3667, "angle": 359.25 }
				],
				"translate": [
					{ "time": 0, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.1, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.1667, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.2, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.3, "x": 0.8, "y": 2.09 },
					{ "time": 0.3667, "x": 0.8, "y": 2.09 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -52.43 },
					{ "time": 0.1, "angle": -57.84 },
					{ "time": 0.1667, "angle": -55.91 },
					{ "time": 0.2, "angle": -42.87 },
					{ "time": 0.3, "angle": 1.21 },
					{ "time": 0.3667, "angle": -52.43 }
				],
				"translate": [
					{ "time": 0, "x": 1.44, "y": -0.49 },
					{ "time": 0.1, "x": 1.03, "y": 8.02 },
					{ "time": 0.1667, "x": 2.29, "y": 12.95 },
					{ "time": 0.2, "x": -0.22, "y": 8.02 },
					{ "time": 0.3, "x": 2.76, "y": -7.91 },
					{ "time": 0.3667, "x": 1.44, "y": -0.49 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1, "angle": 1.49 },
					{ "time": 0.1667, "angle": 2.77 },
					{ "time": 0.2, "angle": 1.25 },
					{ "time": 0.3, "angle": 5.48 },
					{ "time": 0.3667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.94, "y": 0.15 },
					{ "time": 0.1, "x": 0.52, "y": -1.15 },
					{ "time": 0.1667, "x": 1.76, "y": -1.6 },
					{ "time": 0.2, "x": 1.34, "y": -0.31 },
					{ "time": 0.3, "x": -1.9, "y": -0.17 },
					{ "time": 0.3667, "x": 0.94, "y": 0.15 }
				],
				"scale": [
					{ "time": 0.1, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.1667, "x": 1, "y": 1 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1,
							"vertices": [ 1.45214, -5.10381, -4.58752, -2.31149, -0.1759, -0.90243, 2.49221, 3.97658, 2.87095, -0.16483, 1.94148, -2.95924, 2.36578, -3.99526, -0.13334, -1.62547, -0.51473, -5.56173, -2.77893, -0.70934, 5.14096, -1.19022, 1.3247, -1.58913 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 1.45214, -5.10381, -7.24404, -2.56515, -0.60842, 1.03589, 3.33197, 7.36813, 3.84983, 7.07662, 3.68433, 5.40708, 5.09281, 2.25571, -0.56585, 0.31285, -0.51473, -5.56173, -0.87792, 1.41053, 4.70844, 0.7481, 0.9269, 1.7135 ]
						},
						{
							"time": 0.2,
							"vertices": [ 1.45214, -5.10381, -8.1357, -9.20781, -2.21561, -8.47955, 2.42281, 1.24797, 2.94573, -3.53955, 1.0471, -6.55022, 2.29639, -6.72386, -0.13334, -1.62547, -0.51473, -5.56173, -3.38494, -5.59254, 4.82061, -4.31398, 1.50628, -3.92259 ]
						},
						{
							"time": 0.3,
							"vertices": [ 1.02593, -7.30143, -9.35658, -6.685, -9.81845, -17.09658, -7.55686, -2.78602, -6.47693, 0.31343, -4.38188, 2.17878, -3.16412, 0.8704, -3.79572, -6.04591, -0.28156, -4.78415, -9.00686, -7.91295, -0.71711, -0.97703, -4.12679, -2.86134 ]
						},
						{
							"time": 0.3667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			}
		}
	},
	"hurt": {
		"bones": {
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 5.9 },
					{ "time": 0.1333, "angle": 42.5 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": 39.44 }
				],
				"translate": [
					{ "time": 0, "x": 0.94, "y": 0.15 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": -3.45 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -3, "curve": "stepped" },
					{ "time": 0.1667, "x": 0, "y": -3 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 20.99 }
				],
				"translate": [
					{ "time": 0, "x": -0.8, "y": 1.08 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -52.43 },
					{ "time": 0.1667, "angle": -0.03 }
				],
				"translate": [
					{ "time": 0, "x": 1.44, "y": -0.49 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": -1.74 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.25 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.1667, "angle": 24.61 }
				],
				"translate": [
					{ "time": 0, "x": -1, "y": -4 },
					{ "time": 0.1667, "x": -4.04, "y": 0.87 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.72 },
					{ "time": 0.1667, "angle": 4.03 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 1.22, "y": -0.74 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 16.45 },
					{ "time": 0.1667, "angle": 47.79 }
				],
				"translate": [
					{ "time": 0, "x": -0.3, "y": -3.01 },
					{ "time": 0.1667, "x": -0.91, "y": 1.25 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -0.76 }
				],
				"translate": [
					{ "time": 0, "x": 0.8, "y": 2.09 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0.1667, "angle": 14.59 }
				],
				"translate": [
					{ "time": 0, "x": 0.61, "y": -4.26 },
					{ "time": 0.1667, "x": 0.61, "y": -1.83 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ -12.5609, 2.92764, -12.34742, 5.28117, -1.1706, 6.52669, 3.37356, 8.76792, 4.46022, 4.19279, 3.88077, 2.03028, 4.17696, -0.6569, -0.42682, -4.08251, -5.2239, -7.00069, -1.80355, 5.05317, 3.61145, -0.83132, 0.56606, 2.05305 ]
						}
					]
				}
			}
		}
	},
	"keep": {
		"bones": {
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": 22.4 },
					{ "time": 0.8333, "angle": 25.9 },
					{ "time": 1.3333, "angle": 22.4 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": 8.77 }
				],
				"translate": [
					{ "time": 0, "x": 4.5, "y": -2.78 }
				]
			},
			"body-down": {
				"translate": [
					{ "time": 0, "x": 0, "y": -0.22 },
					{ "time": 0.6667, "x": 0, "y": 0.78 },
					{ "time": 1.5, "x": 0, "y": -0.22 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 },
					{ "time": 0.6667, "x": 1.03, "y": 1.03 },
					{ "time": 1.5, "x": 1, "y": 1 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 4.63 }
				],
				"translate": [
					{ "time": 0, "x": 0.87, "y": 0.37 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 371.4 }
				],
				"translate": [
					{ "time": 0, "x": -1.77, "y": -0.93 }
				],
				"scale": [
					{ "time": 0, "x": 1.106, "y": 1.106 },
					{ "time": 0.6667, "x": 1.07, "y": 1.07 },
					{ "time": 1.5, "x": 1.106, "y": 1.106 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 11.33 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.62 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": -12.25 },
					{ "time": 0.8333, "angle": 349.53 },
					{ "time": 1.3333, "angle": -12.25 }
				],
				"translate": [
					{ "time": 0, "x": -2.11, "y": -2.11 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0.93 }
				],
				"translate": [
					{ "time": 0, "x": -0.58, "y": 0.07 },
					{ "time": 0.6667, "x": 0.94, "y": -0.12 },
					{ "time": 1.5, "x": -0.58, "y": 0.07 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 },
					{ "time": 0.6667, "x": 0.92, "y": 0.92 },
					{ "time": 1.5, "x": 1, "y": 1 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -22.59 }
				],
				"translate": [
					{ "time": 0, "x": -0.72, "y": 0.89 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 155.57 },
					{ "time": 0.8333, "angle": 156.3 },
					{ "time": 1.3333, "angle": 155.57 }
				],
				"translate": [
					{ "time": 0, "x": 1.64, "y": -2.11 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": 14.78 },
					{ "time": 0.6667, "angle": 17.6 },
					{ "time": 1.5, "angle": 14.78 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": -0.27, "y": 0.87 },
					{ "time": 0.6667, "x": 1.33, "y": 0.93 },
					{ "time": 1.5, "x": -0.27, "y": 0.87 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 },
					{ "time": 0.6667, "x": 0.93, "y": 0.938 },
					{ "time": 1.5, "x": 1, "y": 1 }
				]
			},
			"rightleg-up": {
				"translate": [
					{ "time": 0, "x": 1.26, "y": -0.07 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 0.3, "y": 0 }
				]
			}
		}
	},
	"keep2": {
		"slots": {
			"righthand-down": {
				"attachment": [
					{ "time": 0, "name": "righthand-down" }
				]
			},
			"rightleg-down": {
				"attachment": [
					{ "time": 0, "name": "rightleg-down" }
				]
			}
		},
		"bones": {
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 4.63 }
				],
				"translate": [
					{ "time": 0, "x": 0.87, "y": 0.37 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0.93 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 0.3, "y": 0 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -22.59 }
				],
				"translate": [
					{ "time": 0, "x": -0.72, "y": 0.89 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": 8.77 }
				],
				"translate": [
					{ "time": 0, "x": 4.5, "y": -2.78 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 18.74 }
				],
				"translate": [
					{ "time": 0, "x": -1.77, "y": -0.93 }
				],
				"scale": [
					{ "time": 0, "x": 1.106, "y": 1.106 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 155.57 }
				],
				"translate": [
					{ "time": 0, "x": 1.64, "y": -2.11 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": -12.25 }
				],
				"translate": [
					{ "time": 0, "x": -2.11, "y": -2.11 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 11.33 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.62 }
				]
			},
			"rightleg-up": {
				"translate": [
					{ "time": 0, "x": 1.26, "y": -0.07 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": 14.78 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": 22.45 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			},
			"body-down": {
				"translate": [
					{ "time": 0, "x": 0, "y": 0.84 }
				]
			}
		}
	},
	"ready": {
		"slots": {
			"cloak-up": {
				"attachment": [
					{ "time": 0, "name": "cloak-up" }
				]
			},
			"righthand-down": {
				"attachment": [
					{ "time": 0.2667, "name": "righthand-down" }
				]
			}
		},
		"bones": {
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -0.76 },
					{ "time": 0.0667, "angle": 1.39 },
					{ "time": 0.1333, "angle": 2.78 },
					{ "time": 0.2667, "angle": 8.77 }
				],
				"translate": [
					{ "time": 0, "x": 0.8, "y": 2.09 },
					{ "time": 0.0667, "x": 0.2, "y": -0.26 },
					{ "time": 0.1333, "x": 2.06, "y": -0.96 },
					{ "time": 0.2667, "x": 4.5, "y": -2.78 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 16.45 },
					{ "time": 0.0667, "angle": 72.25 },
					{ "time": 0.1333, "angle": 88.25 },
					{ "time": 0.2667, "angle": -12.25 }
				],
				"translate": [
					{ "time": 0, "x": -0.3, "y": -3.01 },
					{ "time": 0.0667, "x": -0.42, "y": 0.67 },
					{ "time": 0.1333, "x": -2.53, "y": 2.53 },
					{ "time": 0.2667, "x": -2.11, "y": -2.11 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 5.9 },
					{ "time": 0.0667, "angle": 25.27 },
					{ "time": 0.1333, "angle": 59.38 },
					{ "time": 0.2667, "angle": 155.57 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.2667, "x": 1.64, "y": -2.11 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 },
					{ "time": 0.0667, "angle": 0, "curve": "stepped" },
					{ "time": 0.1333, "angle": 0 },
					{ "time": 0.2667, "angle": 4.63 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.0667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1333, "x": 0, "y": 0 },
					{ "time": 0.2667, "x": 0.87, "y": 0.37 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.0667, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.1333, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.2667, "x": 1, "y": 1 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 0.68 },
					{ "time": 0.2667, "angle": 371.4 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -4 },
					{ "time": 0.0667, "x": -0.42, "y": -1.89 },
					{ "time": 0.1333, "x": -2.11, "y": -0.84 },
					{ "time": 0.2667, "x": -1.77, "y": -0.93 }
				],
				"scale": [
					{ "time": 0, "x": 0.873, "y": 0.873 },
					{ "time": 0.2667, "x": 1.106, "y": 1.106 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.1333, "angle": 9.83 },
					{ "time": 0.2667, "angle": 14.78 }
				],
				"translate": [
					{ "time": 0, "x": -1, "y": -4 },
					{ "time": 0.1333, "x": -2.11, "y": -0.84 },
					{ "time": 0.2667, "x": -2.95, "y": -0.84 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 0, "y": -5 },
					{ "time": 0.2667, "x": 0.3, "y": 0 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0, "curve": "stepped" },
					{ "time": 0.0667, "angle": 0, "curve": "stepped" },
					{ "time": 0.1333, "angle": 0, "curve": "stepped" },
					{ "time": 0.2667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.25 },
					{ "time": 0.0667, "x": -1.27, "y": -0.15 },
					{ "time": 0.1333, "x": -0.14, "y": -0.02 },
					{ "time": 0.2667, "x": 0.13, "y": 0 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -52.43 },
					{ "time": 0.0667, "angle": -33.39 },
					{ "time": 0.1333, "angle": 16.03 },
					{ "time": 0.2667, "angle": 22.45 }
				],
				"translate": [
					{ "time": 0, "x": 1.44, "y": -0.49 },
					{ "time": 0.0667, "x": 1.39, "y": 1.21 },
					{ "time": 0.1333, "x": -2.11, "y": -0.84 },
					{ "time": 0.2667, "x": -2.95, "y": -0.84 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.2667, "x": 1.26, "y": -0.07 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -3 },
					{ "time": 0.2667, "x": 0, "y": -0.22 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.72 },
					{ "time": 0.0667, "angle": 12.39 },
					{ "time": 0.2667, "angle": -22.59 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38 },
					{ "time": 0.0667, "x": -1.58, "y": -0.26 },
					{ "time": 0.2667, "x": -0.72, "y": 0.89 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 20.99 },
					{ "time": 0.1333, "angle": -6.16 },
					{ "time": 0.2667, "angle": 11.33 }
				],
				"translate": [
					{ "time": 0, "x": -0.8, "y": 1.08 },
					{ "time": 0.0667, "x": 0.42, "y": 0.07 },
					{ "time": 0.1333, "x": 0.81, "y": -1.22 },
					{ "time": 0.2667, "x": 0.62, "y": -0.62 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.0667, "angle": 6.44, "curve": "stepped" },
					{ "time": 0.1333, "angle": 6.44 },
					{ "time": 0.2667, "angle": 0.93 }
				],
				"translate": [
					{ "time": 0, "x": 0.69, "y": 0.19, "curve": "stepped" },
					{ "time": 0.0667, "x": 0.69, "y": 0.19 },
					{ "time": 0.1333, "x": 0.11, "y": 0.29 },
					{ "time": 0.2667, "x": -0.02, "y": 0.31 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.0667,
							"vertices": [ -1.53334, -0.89462, -3.83543, -0.79669, -0.4744, -2.41572, 2.03394, 0.74669, 2.70701, -2.28235, 2.59918, -2.55335, 3.51335, -3.01763, 1.08935, -2.62828, -0.02432, -3.21703, -0.88627, -2.56293, 4.43325, -3.27341, 1.36435, -2.6783 ]
						}
					]
				}
			}
		}
	},
	"shoot": {
		"slots": {
			"cloak-up": {
				"attachment": [
					{ "time": 0.1667, "name": "cloak-up" }
				]
			}
		},
		"bones": {
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 4.63 },
					{ "time": 0.1667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": 0.87, "y": 0.37 },
					{ "time": 0.1667, "x": -3, "y": 0.17 }
				],
				"scale": [
					{ "time": 0.1667, "x": 1, "y": 1 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0, "curve": "stepped" },
					{ "time": 0.1667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.1667, "x": 0.62, "y": -0.25 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": 8.77 },
					{ "time": 0.1, "angle": -0.76 }
				],
				"translate": [
					{ "time": 0, "x": 4.5, "y": -2.78 },
					{ "time": 0.1, "x": 0.8, "y": 2.09 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 155.57 },
					{ "time": 0.1667, "angle": 5.9 }
				],
				"translate": [
					{ "time": 0, "x": 1.64, "y": -2.11 },
					{ "time": 0.1667, "x": 0, "y": 0 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": 22.45 },
					{ "time": 0.1667, "angle": -52.43 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 },
					{ "time": 0.1667, "x": 1.44, "y": -0.49 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -22.59 },
					{ "time": 0.1667, "angle": -26.72 }
				],
				"translate": [
					{ "time": 0, "x": -0.72, "y": 0.89 },
					{ "time": 0.1667, "x": -0.4, "y": 1.38 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 18.74 },
					{ "time": 0.1667, "angle": 0.68 }
				],
				"translate": [
					{ "time": 0, "x": -1.77, "y": -0.93 },
					{ "time": 0.1667, "x": 0, "y": -4 }
				],
				"scale": [
					{ "time": 0, "x": 1.106, "y": 1.106 },
					{ "time": 0.1667, "x": 0.873, "y": 0.873 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": -12.25 },
					{ "time": 0.1667, "angle": 16.45 }
				],
				"translate": [
					{ "time": 0, "x": -2.11, "y": -2.11 },
					{ "time": 0.1667, "x": -0.3, "y": -3.01 }
				],
				"scale": [
					{ "time": 0.1667, "x": 1, "y": 1 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0.1667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0.84 },
					{ "time": 0.1667, "x": 0, "y": -3 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0.1667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": 1.26, "y": -0.07 },
					{ "time": 0.1667, "x": -3, "y": 0.17 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 11.33 },
					{ "time": 0.1667, "angle": 20.99 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.62 },
					{ "time": 0.1667, "x": -0.8, "y": 1.08 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0.1667, "angle": 0 }
				],
				"translate": [
					{ "time": 0.1667, "x": 0, "y": 0 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0.93 },
					{ "time": 0.1667, "angle": 0 }
				],
				"translate": [
					{ "time": 0.1667, "x": 0.94, "y": 0.15 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": 14.78 },
					{ "time": 0.1667, "angle": -3.1 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 },
					{ "time": 0.1667, "x": -1, "y": -4 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0.1667, "x": 0, "y": -5 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 0.92 },
					{ "time": 0.1667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1667, "x": 0, "y": 0 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0.1,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			}
		},
		"drawOrder": [
			{ "time": 0.1 }
		]
	},
	"shoot_fast": {
		"slots": {
			"cloak-up": {
				"attachment": [
					{ "time": 0.0667, "name": "cloak-up" }
				]
			}
		},
		"bones": {
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 4.63 },
					{ "time": 0.0667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": 0.87, "y": 0.37 },
					{ "time": 0.0667, "x": -3, "y": 0.17 }
				],
				"scale": [
					{ "time": 0.0667, "x": 1, "y": 1 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0, "curve": "stepped" },
					{ "time": 0.0667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.0667, "x": 0.62, "y": -0.25 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": 8.77 },
					{ "time": 0.0333, "angle": -0.76 }
				],
				"translate": [
					{ "time": 0, "x": 4.5, "y": -2.78 },
					{ "time": 0.0333, "x": 0.8, "y": 2.09 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 155.57 },
					{ "time": 0.0667, "angle": 5.9 }
				],
				"translate": [
					{ "time": 0, "x": 1.64, "y": -2.11 },
					{ "time": 0.0667, "x": 0, "y": 0 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": 22.45 },
					{ "time": 0.0667, "angle": -52.43 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 },
					{ "time": 0.0667, "x": 1.44, "y": -0.49 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -22.59 },
					{ "time": 0.0667, "angle": -26.72 }
				],
				"translate": [
					{ "time": 0, "x": -0.72, "y": 0.89 },
					{ "time": 0.0667, "x": -0.4, "y": 1.38 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 18.74 },
					{ "time": 0.0667, "angle": 0.68 }
				],
				"translate": [
					{ "time": 0, "x": -1.77, "y": -0.93 },
					{ "time": 0.0667, "x": 0, "y": -4 }
				],
				"scale": [
					{ "time": 0, "x": 1.106, "y": 1.106 },
					{ "time": 0.0667, "x": 0.873, "y": 0.873 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": -12.25 },
					{ "time": 0.0667, "angle": 16.45 }
				],
				"translate": [
					{ "time": 0, "x": -2.11, "y": -2.11 },
					{ "time": 0.0667, "x": -0.3, "y": -3.01 }
				],
				"scale": [
					{ "time": 0.0667, "x": 1, "y": 1 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0.0667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0.84 },
					{ "time": 0.0667, "x": 0, "y": -3 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0.0667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": 1.26, "y": -0.07 },
					{ "time": 0.0667, "x": -3, "y": 0.17 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 11.33 },
					{ "time": 0.0667, "angle": 20.99 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.62 },
					{ "time": 0.0667, "x": -0.8, "y": 1.08 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0.0667, "angle": 0 }
				],
				"translate": [
					{ "time": 0.0667, "x": 0, "y": 0 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0.93 },
					{ "time": 0.0667, "angle": 0 }
				],
				"translate": [
					{ "time": 0.0667, "x": 0.94, "y": 0.15 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": 14.78 },
					{ "time": 0.0667, "angle": -3.1 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 },
					{ "time": 0.0667, "x": -1, "y": -4 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0.0667, "x": 0, "y": -5 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 0.92 },
					{ "time": 0.0667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.0667, "x": 0, "y": 0 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0.0333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			}
		},
		"drawOrder": [
			{ "time": 0.0333 }
		]
	},
	"stand": {
		"slots": {
			"cloak-up": {
				"attachment": [
					{ "time": 0, "name": "cloak-up" },
					{ "time": 1.0667, "name": "cloak-up" }
				]
			}
		},
		"bones": {
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -52.43 },
					{ "time": 0.2667, "angle": -51.57 },
					{ "time": 0.5333, "angle": -49.13 },
					{ "time": 0.8, "angle": -51.57 },
					{ "time": 1.0667, "angle": -52.43 }
				],
				"translate": [
					{ "time": 0, "x": 1.44, "y": -0.49 },
					{ "time": 0.2667, "x": 1.94, "y": 1.68 },
					{ "time": 0.5333, "x": 1.65, "y": 3.31 },
					{ "time": 0.8, "x": 1.94, "y": 1.68 },
					{ "time": 1.0667, "x": 1.44, "y": -0.49 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.72, "curve": "stepped" },
					{ "time": 0.2667, "angle": -26.72 },
					{ "time": 0.5333, "angle": -23.74 },
					{ "time": 0.8, "angle": -26.72, "curve": "stepped" },
					{ "time": 1.0667, "angle": -26.72 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 0.2667, "x": -0.4, "y": 1.38 },
					{ "time": 0.5333, "x": -0.91, "y": 1.21 },
					{ "time": 0.8, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 1.0667, "x": -0.4, "y": 1.38 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 25.75 },
					{ "time": 0.2667, "angle": 30.75 },
					{ "time": 0.5333, "angle": 31.75 },
					{ "time": 0.8, "angle": 30.75 },
					{ "time": 1.0667, "angle": 25.75 }
				],
				"translate": [
					{ "time": 0, "x": -0.8, "y": 1.08 },
					{ "time": 0.2667, "x": -0.48, "y": 1.62 },
					{ "time": 0.5333, "x": -0.81, "y": 0.94 },
					{ "time": 0.8, "x": -0.48, "y": 1.62 },
					{ "time": 1.0667, "x": -0.8, "y": 1.08 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 16.45 },
					{ "time": 0.2667, "angle": 13.77 },
					{ "time": 0.5333, "angle": 8.3 },
					{ "time": 0.8, "angle": 13.77 },
					{ "time": 1.0667, "angle": 16.45 }
				],
				"translate": [
					{ "time": 0, "x": -0.3, "y": -3.01 },
					{ "time": 0.2667, "x": -0.89, "y": -0.91 },
					{ "time": 0.5333, "x": -0.6, "y": 0.89 },
					{ "time": 0.8, "x": -0.89, "y": -0.91 },
					{ "time": 1.0667, "x": -0.3, "y": -3.01 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -2 },
					{ "time": 0.2667, "x": 0, "y": -1 },
					{ "time": 0.5333, "x": 0, "y": 0 },
					{ "time": 0.8, "x": 0, "y": -1 },
					{ "time": 1.0667, "x": 0, "y": -2 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.2667, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.8, "angle": 2.27, "curve": "stepped" },
					{ "time": 1.0667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -1.99, "y": 0.11 },
					{ "time": 0.2667, "x": -1, "y": 0.06 },
					{ "time": 0.5333, "x": 0, "y": 0 },
					{ "time": 0.8, "x": -1, "y": 0.06 },
					{ "time": 1.0667, "x": -1.99, "y": 0.11 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.2667, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.8, "angle": 2.27, "curve": "stepped" },
					{ "time": 1.0667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -1.99, "y": 0.11 },
					{ "time": 0.2667, "x": -1, "y": 0.06 },
					{ "time": 0.5333, "x": 0, "y": 0 },
					{ "time": 0.8, "x": -1, "y": 0.06 },
					{ "time": 1.0667, "x": -1.99, "y": 0.11 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 0.68 },
					{ "time": 0.2667, "angle": -0.97 },
					{ "time": 0.5333, "angle": 0.71 },
					{ "time": 0.8, "angle": -0.97 },
					{ "time": 1.0667, "angle": 0.68 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -4 },
					{ "time": 0.2667, "x": 0, "y": -2 },
					{ "time": 0.5333, "x": 0, "y": 0 },
					{ "time": 0.8, "x": 0, "y": -2 },
					{ "time": 1.0667, "x": 0, "y": -4 }
				],
				"scale": [
					{ "time": 0, "x": 0.873, "y": 0.873 },
					{ "time": 0.5333, "x": 1.036, "y": 1.036 },
					{ "time": 1.0667, "x": 0.873, "y": 0.873 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.2667, "angle": -3.9 },
					{ "time": 0.5333, "angle": -3.04 },
					{ "time": 0.8, "angle": -3.9 },
					{ "time": 1.0667, "angle": -3.1 }
				],
				"translate": [
					{ "time": 0, "x": -1, "y": -4 },
					{ "time": 0.2667, "x": -1, "y": -2 },
					{ "time": 0.5333, "x": -1, "y": 0 },
					{ "time": 0.8, "x": -1, "y": -2 },
					{ "time": 1.0667, "x": -1, "y": -4 }
				]
			},
			"neck": {
				"rotate": [
					{ "time": 0.5333, "angle": 10.27 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -5 },
					{ "time": 0.5333, "x": 0, "y": 0 },
					{ "time": 0.8, "x": 0, "y": -1 },
					{ "time": 1.0667, "x": 0, "y": -5 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -0.76 },
					{ "time": 0.2667, "angle": -2.16 },
					{ "time": 0.5333, "angle": -6.08 },
					{ "time": 0.8, "angle": -2.16 },
					{ "time": 1.0667, "angle": -0.76 }
				],
				"translate": [
					{ "time": 0, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.2667, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.5333, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.8, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 1.0667, "x": 0.8, "y": 2.09 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 5.9 },
					{ "time": 0.2667, "angle": 2.29 },
					{ "time": 0.5333, "angle": 6.96 },
					{ "time": 0.8, "angle": 2.29 },
					{ "time": 1.0667, "angle": 5.9 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.5333, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.8, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 1.0667, "x": 0, "y": 0 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0.2667, "angle": 0, "curve": "stepped" },
					{ "time": 0.8, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.8, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 1.0667, "x": 0, "y": 0 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.49, "y": -0.44 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.12, "y": -0.29 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlDragon": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlGold": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlHeart": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlIce": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlIron": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlLightning": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlSilver": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlSteel": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlWood": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			}
		}
	},
	"walk": {
		"slots": {
			"body-down": {
				"attachment": [
					{ "time": 0, "name": "body-down" },
					{ "time": 0.1667, "name": "body-down" },
					{ "time": 0.3333, "name": "body-down" },
					{ "time": 0.5, "name": "body-down" },
					{ "time": 0.6667, "name": "body-down" }
				]
			},
			"cloak-up": {
				"attachment": [
					{ "time": 0, "name": "cloak-up" },
					{ "time": 0.6667, "name": "cloak-up" }
				]
			}
		},
		"bones": {
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 0.68 },
					{ "time": 0.1667, "angle": -0.97 },
					{ "time": 0.3333, "angle": 0.68 },
					{ "time": 0.5, "angle": -0.97 },
					{ "time": 0.6667, "angle": 0.68 }
				],
				"translate": [
					{ "time": 0, "x": -0.01, "y": -5 },
					{ "time": 0.1667, "x": -0.01, "y": -3 },
					{ "time": 0.3333, "x": -0.01, "y": -5 },
					{ "time": 0.5, "x": -0.01, "y": -3 },
					{ "time": 0.6667, "x": -0.01, "y": -5 }
				],
				"scale": [
					{ "time": 0, "x": 0.873, "y": 0.873, "curve": "stepped" },
					{ "time": 0.3333, "x": 0.873, "y": 0.873, "curve": "stepped" },
					{ "time": 0.6667, "x": 0.873, "y": 0.873 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -64.74 },
					{ "time": 0.1667, "angle": -58.16 },
					{ "time": 0.3333, "angle": -52.26 },
					{ "time": 0.5, "angle": -58.16 },
					{ "time": 0.6667, "angle": -64.74 }
				],
				"translate": [
					{ "time": 0, "x": 1.43, "y": -1.49 },
					{ "time": 0.1667, "x": 1.93, "y": 0.68 },
					{ "time": 0.3333, "x": 1.43, "y": -1.49 },
					{ "time": 0.5, "x": 1.93, "y": 0.68 },
					{ "time": 0.6667, "x": 1.43, "y": -1.49 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 9.66 },
					{ "time": 0.1667, "angle": 2.27 },
					{ "time": 0.3333, "angle": 36.51 },
					{ "time": 0.5, "angle": 2.27 },
					{ "time": 0.6667, "angle": 9.66 }
				],
				"translate": [
					{ "time": 0, "x": -2, "y": 0.1 },
					{ "time": 0.1667, "x": 0, "y": -0.01 },
					{ "time": 0.3333, "x": -0.97, "y": -3.19 },
					{ "time": 0.5, "x": 0, "y": -0.01 },
					{ "time": 0.6667, "x": -2, "y": 0.1 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -48.28 },
					{ "time": 0.1667, "angle": -26.72 },
					{ "time": 0.3333, "angle": -9.91 },
					{ "time": 0.5, "angle": -26.72 },
					{ "time": 0.6667, "angle": -48.28 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 0.1667, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 0.3333, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 0.5, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 0.6667, "x": -0.4, "y": 1.38 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -0.76 },
					{ "time": 0.1667, "angle": -2.16 },
					{ "time": 0.3333, "angle": -0.76 },
					{ "time": 0.5, "angle": -2.16 },
					{ "time": 0.6667, "angle": -0.76 }
				],
				"translate": [
					{ "time": 0, "x": 1.8, "y": 2.03 },
					{ "time": 0.1667, "x": 0.8, "y": 2.09 },
					{ "time": 0.3333, "x": 1.8, "y": 2.03 },
					{ "time": 0.5, "x": 0.8, "y": 2.09 },
					{ "time": 0.6667, "x": 1.8, "y": 2.03 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 32.54 },
					{ "time": 0.1667, "angle": 2.29 },
					{ "time": 0.3333, "angle": 24.14 },
					{ "time": 0.5, "angle": 2.29 },
					{ "time": 0.6667, "angle": 32.54 }
				],
				"translate": [
					{ "time": 0, "x": 0.7, "y": -0.79 },
					{ "time": 0.1667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.3333, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.5, "x": 0, "y": 0 },
					{ "time": 0.6667, "x": 0.7, "y": -0.79 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.1667, "angle": -3.9 },
					{ "time": 0.3333, "angle": -3.1 },
					{ "time": 0.5, "angle": -3.9 },
					{ "time": 0.6667, "angle": -3.1 }
				],
				"translate": [
					{ "time": 0, "x": -1.01, "y": -5 },
					{ "time": 0.1667, "x": -1.01, "y": -3 },
					{ "time": 0.3333, "x": -1.01, "y": -5 },
					{ "time": 0.5, "x": -1.01, "y": -3 },
					{ "time": 0.6667, "x": -1.01, "y": -5 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 37.75 },
					{ "time": 0.1667, "angle": 25.47 },
					{ "time": 0.3333, "angle": 14.12 },
					{ "time": 0.5, "angle": 25.47 },
					{ "time": 0.6667, "angle": 37.75 }
				],
				"translate": [
					{ "time": 0, "x": -0.8, "y": 1.08 },
					{ "time": 0.1667, "x": -0.48, "y": 1.62 },
					{ "time": 0.3333, "x": -0.81, "y": 0.94 },
					{ "time": 0.5, "x": -0.48, "y": 1.62 },
					{ "time": 0.6667, "x": -0.8, "y": 1.08 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 40.19 },
					{ "time": 0.1667, "angle": 17.17 },
					{ "time": 0.3333, "angle": -8.11 },
					{ "time": 0.5, "angle": 17.17 },
					{ "time": 0.6667, "angle": 40.19 }
				],
				"translate": [
					{ "time": 0, "x": -2.04, "y": -3.5 },
					{ "time": 0.1667, "x": -0.9, "y": -1.91 },
					{ "time": 0.3333, "x": 0.43, "y": -5.26 },
					{ "time": 0.5, "x": -0.91, "y": -2.67 },
					{ "time": 0.6667, "x": -2.04, "y": -3.5 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 0, "y": -5 },
					{ "time": 0.3333, "x": 0.01, "y": -3.42 },
					{ "time": 0.6667, "x": 0, "y": -5 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 18.89 },
					{ "time": 0.1667, "angle": 2.27 },
					{ "time": 0.3333, "angle": -27.16 },
					{ "time": 0.5, "angle": 2.27 },
					{ "time": 0.6667, "angle": 18.89 }
				],
				"translate": [
					{ "time": 0, "x": -0.66, "y": -2.22 },
					{ "time": 0.1667, "x": 0, "y": -0.01 },
					{ "time": 0.3333, "x": -2.18, "y": 1.6 },
					{ "time": 0.5, "x": 0, "y": -0.01 },
					{ "time": 0.6667, "x": -0.66, "y": -2.22 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0.1667, "angle": 0, "curve": "stepped" },
					{ "time": 0.5, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.5, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.6667, "x": 0, "y": 0 }
				]
			},
			"body-down": {
				"translate": [
					{ "time": 0, "x": 0, "y": -3 },
					{ "time": 0.1667, "x": 0, "y": -1 },
					{ "time": 0.3333, "x": 0, "y": -3 },
					{ "time": 0.5, "x": 0, "y": -1 },
					{ "time": 0.6667, "x": 0, "y": -3 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": -31.49 },
					{ "time": 0.1667, "angle": -0.06 },
					{ "time": 0.3333, "angle": -9.26 },
					{ "time": 0.5, "angle": -0.06 },
					{ "time": 0.6667, "angle": -31.49 }
				],
				"translate": [
					{ "time": 0, "x": -2, "y": 0.12 },
					{ "time": 0.1667, "x": -0.59, "y": 0.21 },
					{ "time": 0.3333, "x": 0, "y": 0.26 },
					{ "time": 0.5, "x": -0.59, "y": 0.21 },
					{ "time": 0.6667, "x": -2, "y": 0.12 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 0.42 }
				],
				"translate": [
					{ "time": 0.6667, "x": 0, "y": -0.38 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0, "curve": "stepped" },
					{ "time": 0.1667, "angle": 0 },
					{ "time": 0.3333, "angle": -21.48 },
					{ "time": 0.5, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": -0.46, "y": 0.23 },
					{ "time": 0.1667, "x": -0.4, "y": 0.07, "curve": "stepped" },
					{ "time": 0.3333, "x": -0.4, "y": 0.07 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlDragon": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlGold": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlHeart": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlIce": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlIron": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlLightning": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlSilver": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlSteel": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlWood": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			}
		}
	}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/Animation/wood.atlas`:

```atlas

wood.png
size: 128,64
format: RGBA8888
filter: Linear,Linear
repeat: none
arroy
  rotate: false
  xy: 42, 55
  size: 45, 7
  orig: 45, 7
  offset: 0, 0
  index: -1
body
  rotate: false
  xy: 2, 30
  size: 38, 32
  orig: 38, 32
  offset: 0, 0
  index: -1
l-hand
  rotate: false
  xy: 2, 8
  size: 23, 20
  orig: 23, 20
  offset: 0, 0
  index: -1
l-leg
  rotate: false
  xy: 27, 16
  size: 6, 12
  orig: 6, 12
  offset: 0, 0
  index: -1
r-hand
  rotate: false
  xy: 42, 33
  size: 22, 20
  orig: 22, 20
  offset: 0, 0
  index: -1
r-leg
  rotate: false
  xy: 27, 2
  size: 5, 12
  orig: 5, 12
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/Animation/wood.json`:

```json
{
"skeleton": { "hash": "X+fHLjV4Jesv+v3THiRqaKRJOx4", "spine": "3.6.04-beta", "width": 74.33, "height": 43.45 },
"bones": [
	{ "name": "root", "rotation": 0.9 },
	{ "name": "l-hand", "parent": "root", "length": 16.63, "rotation": 146.51, "x": -16.23, "y": 17.25 },
	{ "name": "arroy", "parent": "l-hand", "length": 17.73, "rotation": 93.26, "x": 11.33, "y": 1.7 },
	{ "name": "body", "parent": "root", "length": 11.59, "rotation": -91.35, "x": -0.58, "y": 18.94 },
	{ "name": "l-leg", "parent": "root", "length": 8.3, "rotation": -91.82, "x": -7.66, "y": 8.58 },
	{ "name": "r-hand", "parent": "root", "length": 16.45, "rotation": 35.44, "x": 15.17, "y": 16.76 },
	{ "name": "r-leg", "parent": "root", "length": 7.09, "rotation": -91.82, "x": 6.49, "y": 7.56 }
],
"slots": [
	{ "name": "arroy", "bone": "arroy", "attachment": "arroy" },
	{ "name": "r-hand", "bone": "r-hand", "attachment": "r-hand" },
	{ "name": "l-hand", "bone": "l-hand", "attachment": "l-hand" },
	{ "name": "l-leg", "bone": "l-leg", "attachment": "l-leg" },
	{ "name": "r-leg", "bone": "r-leg", "attachment": "r-leg" },
	{ "name": "body", "bone": "body", "attachment": "body" },
	{ "name": "CollisionBox", "bone": "body", "attachment": "CollisionBox" },
	{ "name": "AttackBox", "bone": "arroy", "attachment": "AttackBox" }
],
"skins": {
	"default": {
		"AttackBox": {
			"AttackBox": {
				"type": "boundingbox",
				"vertexCount": 3,
				"vertices": [ 20.52, -1.8, -9.96, 0.77, -10.11, -2.85 ]
			}
		},
		"CollisionBox": {
			"CollisionBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ 10.16, -15, 10.34, 13.84, -16.48, 17.32, -16.62, -16.98 ]
			}
		},
		"arroy": {
			"arroy": { "x": 0.64, "y": -2.32, "rotation": 179.45, "width": 45, "height": 7 }
		},
		"body": {
			"body": { "x": -3.99, "y": 0.68, "rotation": 90.35, "width": 38, "height": 32 }
		},
		"l-hand": {
			"l-hand": { "x": 6.99, "y": -1.16, "rotation": -146.51, "width": 23, "height": 20 }
		},
		"l-leg": {
			"l-leg": { "x": 2.32, "y": -0.26, "rotation": 91.82, "width": 6, "height": 12 }
		},
		"r-hand": {
			"r-hand": { "x": 6.32, "y": 0.6, "rotation": -35.44, "width": 22, "height": 20 }
		},
		"r-leg": {
			"r-leg": { "x": 1.59, "y": -0.42, "rotation": 91.82, "width": 5, "height": 12 }
		}
	}
},
"animations": {
	"attack": {
		"bones": {
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": 360, "curve": "stepped" },
					{ "time": 0.1667, "angle": 360 },
					{ "time": 0.3333, "angle": 48.09 },
					{ "time": 0.5, "angle": 360.36 },
					{ "time": 0.6667, "angle": 1.39 },
					{ "time": 0.8333, "angle": 360 }
				],
				"translate": [
					{ "time": 0, "x": 0.29, "y": 0, "curve": "stepped" },
					{ "time": 0.1667, "x": 0.29, "y": 0 },
					{ "time": 0.3333, "x": 6.73, "y": 5.77 },
					{ "time": 0.5, "x": -3.12, "y": -0.16 },
					{ "time": 0.6667, "x": 0.16, "y": 0 },
					{ "time": 0.8333, "x": 0.29, "y": 0 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.1667, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.5, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.6667, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.8333, "x": 1, "y": 1 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -53.5 },
					{ "time": 0.1667, "angle": -83.57 },
					{ "time": 0.3333, "angle": -1.6 },
					{ "time": 0.5, "angle": 278.37 },
					{ "time": 0.8333, "angle": -53.5 }
				],
				"translate": [
					{ "time": 0, "x": 0.08, "y": 3.42 },
					{ "time": 0.1667, "x": -1.51, "y": 0.83 },
					{ "time": 0.3333, "x": -2.3, "y": 12.34 },
					{ "time": 0.5, "x": -2.6, "y": 2.76 },
					{ "time": 0.8333, "x": 0.08, "y": 3.42 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": 325.52 },
					{ "time": 0.1667, "angle": -44.81 },
					{ "time": 0.3333, "angle": 3.8 },
					{ "time": 0.5, "angle": 358.48 },
					{ "time": 0.6667, "angle": -49.18 },
					{ "time": 0.8333, "angle": 325.52 }
				],
				"translate": [
					{ "time": 0, "x": -5.34, "y": 4.95 },
					{ "time": 0.1667, "x": -7.94, "y": 5.5 },
					{ "time": 0.3333, "x": -1.89, "y": 0.39 },
					{ "time": 0.5, "x": 1.92, "y": -0.15 },
					{ "time": 0.6667, "x": -9.67, "y": 7.04 },
					{ "time": 0.8333, "x": -5.34, "y": 4.95 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": 38.57 },
					{ "time": 0.1667, "angle": -20.08 },
					{ "time": 0.3333, "angle": -255.6 },
					{ "time": 0.5, "angle": -283.88 },
					{ "time": 0.6667, "angle": 8.03 },
					{ "time": 0.8333, "angle": 38.57 }
				],
				"translate": [
					{ "time": 0, "x": 1.83, "y": 6.97, "curve": "stepped" },
					{ "time": 0.1667, "x": 1.83, "y": 6.97 },
					{ "time": 0.3333, "x": 0.94, "y": 2.35 },
					{ "time": 0.5, "x": 1.69, "y": 2.05 },
					{ "time": 0.6667, "x": 1.83, "y": 10.08 },
					{ "time": 0.8333, "x": 1.83, "y": 6.97 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 352.52 },
					{ "time": 0.1667, "angle": -15.58 },
					{ "time": 0.3333, "angle": 19.32 },
					{ "time": 0.5, "angle": 361.75 },
					{ "time": 0.6667, "angle": -22.18 },
					{ "time": 0.8333, "angle": 352.52 }
				],
				"translate": [
					{ "time": 0, "x": 0.03, "y": 2, "curve": "stepped" },
					{ "time": 0.1667, "x": 0.03, "y": 2 },
					{ "time": 0.3333, "x": -1.57, "y": 0.63 },
					{ "time": 0.5, "x": -0.22, "y": -0.01 },
					{ "time": 0.6667, "x": 0.03, "y": 2, "curve": "stepped" },
					{ "time": 0.8333, "x": 0.03, "y": 2 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 21.94 },
					{ "time": 0.1667, "angle": -28.94 },
					{ "time": 0.8333, "angle": 21.94 }
				],
				"translate": [
					{ "time": 0, "x": -2.98, "y": -1.7 },
					{ "time": 0.1667, "x": -0.05, "y": 1.32 },
					{ "time": 0.8333, "x": -2.98, "y": -1.7 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": -0.23 }
				]
			}
		}
	},
	"die": {
		"bones": {
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": -0.91 },
					{ "time": 0.1667, "angle": -19.98 },
					{ "time": 0.3333, "angle": -65.43 },
					{ "time": 0.5, "angle": 270.93 }
				],
				"translate": [
					{ "time": 0, "x": 0.55, "y": -0.01 },
					{ "time": 0.1667, "x": -2.05, "y": 1.08 },
					{ "time": 0.3333, "x": 5.25, "y": 0.44 },
					{ "time": 0.5, "x": 12.48, "y": -4.89 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.1667, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.3333, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.5, "x": 1, "y": 1 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -86.55 },
					{ "time": 0.1667, "angle": -45.61 },
					{ "time": 0.3333, "angle": -57.21 },
					{ "time": 0.5, "angle": -34.86 }
				],
				"translate": [
					{ "time": 0, "x": 1.46, "y": 2.06 },
					{ "time": 0.1667, "x": -2.72, "y": 0.04 },
					{ "time": 0.3333, "x": 15.52, "y": -1.81 },
					{ "time": 0.5, "x": 16.39, "y": -13.31 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 45.02 },
					{ "time": 0.1667, "angle": -20.05, "curve": "stepped" },
					{ "time": 0.3333, "angle": -20.05 },
					{ "time": 0.5, "angle": 73.88 }
				],
				"translate": [
					{ "time": 0, "x": -3.99, "y": -1.69 },
					{ "time": 0.1667, "x": 16.47, "y": -18.76, "curve": "stepped" },
					{ "time": 0.3333, "x": 16.47, "y": -18.76 },
					{ "time": 0.5, "x": 13.85, "y": -11.77 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": -296.2 },
					{ "time": 0.1667, "angle": -14.1 },
					{ "time": 0.3333, "angle": -67.53 },
					{ "time": 0.5, "angle": -130.34 }
				],
				"translate": [
					{ "time": 0, "x": -0.09, "y": 3.74 },
					{ "time": 0.1667, "x": 1.22, "y": 11.88 },
					{ "time": 0.3333, "x": 9.92, "y": 34.19 },
					{ "time": 0.5, "x": 20.14, "y": -13.47 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 1.03 },
					{ "time": 0.1667, "angle": -20.06 },
					{ "time": 0.3333, "angle": -35.34 },
					{ "time": 0.5, "angle": -80.04 }
				],
				"translate": [
					{ "time": 0, "x": 1, "y": -0.86 },
					{ "time": 0.1667, "x": 0.25, "y": 4 },
					{ "time": 0.3333, "x": 16.1, "y": 16.28 },
					{ "time": 0.5, "x": 27.31, "y": -1.64 }
				],
				"scale": [
					{ "time": 0, "x": 1.023, "y": 1.023 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": -2.79 },
					{ "time": 0.1667, "angle": -53.48 },
					{ "time": 0.3333, "angle": 269.82 },
					{ "time": 0.5, "angle": 267.64 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -0.02 },
					{ "time": 0.1667, "x": -6.76, "y": 8.51 },
					{ "time": 0.3333, "x": 4.18, "y": 6.77 },
					{ "time": 0.5, "x": 13.91, "y": -5.39 }
				]
			}
		}
	},
	"die_over": {
		"slots": {
			"arroy": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			},
			"body": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			},
			"l-hand": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			},
			"l-leg": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			},
			"r-hand": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			},
			"r-leg": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			}
		},
		"bones": {
			"body": {
				"rotate": [
					{ "time": 0, "angle": -80.04 }
				],
				"translate": [
					{ "time": 0, "x": 27.31, "y": -1.64 }
				]
			},
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": 270.93 }
				],
				"translate": [
					{ "time": 0, "x": 12.48, "y": -4.89 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": -130.34 }
				],
				"translate": [
					{ "time": 0, "x": 20.14, "y": -13.47 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 73.88 }
				],
				"translate": [
					{ "time": 0, "x": 13.85, "y": -11.77 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -34.86 }
				],
				"translate": [
					{ "time": 0, "x": 16.39, "y": -13.31 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": 267.64 }
				],
				"translate": [
					{ "time": 0, "x": 13.91, "y": -5.39 }
				]
			}
		}
	},
	"dizzy": {
		"bones": {
			"root": {
				"rotate": [
					{ "time": 0, "angle": 9.1 },
					{ "time": 0.3333, "angle": -0.9 },
					{ "time": 0.6667, "angle": 344.1 },
					{ "time": 1, "angle": -0.9 },
					{ "time": 1.3333, "angle": 9.1 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -0.44 },
					{ "time": 0.3333, "x": 0, "y": 0.06 },
					{ "time": 0.6667, "x": 0, "y": -0.44 },
					{ "time": 1, "x": 0, "y": 0.06 },
					{ "time": 1.3333, "x": 0, "y": -0.44 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 1.42 },
					{ "time": 0.3333, "x": 0, "y": -0.08 },
					{ "time": 0.6667, "x": 0, "y": -1.58 },
					{ "time": 1, "x": 0, "y": -0.08 },
					{ "time": 1.3333, "x": 0, "y": 1.42 }
				]
			},
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -0.76 },
					{ "time": 0.3333, "x": 0, "y": 0.24 },
					{ "time": 0.6667, "x": 0, "y": 2.24 },
					{ "time": 1, "x": 0, "y": 0.24 },
					{ "time": 1.3333, "x": 0, "y": -0.76 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 42.2 },
					{ "time": 0.3333, "angle": 36.74 },
					{ "time": 0.6667, "angle": 31.74 },
					{ "time": 1, "angle": 36.74 },
					{ "time": 1.3333, "angle": 42.2 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": -308.42 },
					{ "time": 0.3333, "angle": 41.58 },
					{ "time": 0.6667, "angle": 31.58 },
					{ "time": 1, "angle": 41.58 },
					{ "time": 1.3333, "angle": -308.42 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -62.83 },
					{ "time": 0.3333, "angle": 317.18 },
					{ "time": 0.6667, "angle": -16.74 },
					{ "time": 1, "angle": 317.18 },
					{ "time": 1.3333, "angle": -62.83 }
				]
			}
		}
	},
	"hurt": {
		"bones": {
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 45.02 },
					{ "time": 0.1667, "angle": -20.05 },
					{ "time": 0.3333, "angle": 45.02 }
				],
				"translate": [
					{ "time": 0, "x": -3.99, "y": -1.69 },
					{ "time": 0.1667, "x": 16.47, "y": -18.76 },
					{ "time": 0.3333, "x": -3.99, "y": -1.69 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": -296.2 },
					{ "time": 0.3333, "angle": -14.1 },
					{ "time": 0.6667, "angle": -296.2 }
				],
				"translate": [
					{ "time": 0, "x": -0.09, "y": 3.74 },
					{ "time": 0.3333, "x": 1.22, "y": 11.88 },
					{ "time": 0.6667, "x": -0.09, "y": 3.74 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": -2.79 },
					{ "time": 0.1667, "angle": -53.48 },
					{ "time": 0.3333, "angle": -2.79 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -0.02 },
					{ "time": 0.1667, "x": -6.76, "y": 8.51 },
					{ "time": 0.3333, "x": 0, "y": -0.02 }
				]
			},
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": -0.91 },
					{ "time": 0.3333, "angle": -19.98 },
					{ "time": 0.6667, "angle": -0.91 }
				],
				"translate": [
					{ "time": 0, "x": 0.55, "y": -0.01 },
					{ "time": 0.3333, "x": -2.05, "y": 1.08 },
					{ "time": 0.6667, "x": 0.55, "y": -0.01 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.3333, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.6667, "x": 1, "y": 1 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -86.55 },
					{ "time": 0.3333, "angle": -45.61 },
					{ "time": 0.6667, "angle": -86.55 }
				],
				"translate": [
					{ "time": 0, "x": 1.46, "y": 2.06 },
					{ "time": 0.3333, "x": -2.72, "y": 0.04 },
					{ "time": 0.6667, "x": 1.46, "y": 2.06 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 1.03 },
					{ "time": 0.3333, "angle": -20.06 },
					{ "time": 0.6667, "angle": 1.03 }
				],
				"translate": [
					{ "time": 0, "x": 1, "y": -0.86 },
					{ "time": 0.3333, "x": 0.25, "y": 4 },
					{ "time": 0.6667, "x": 1, "y": -0.86 }
				],
				"scale": [
					{ "time": 0, "x": 1.023, "y": 1.023, "curve": "stepped" },
					{ "time": 0.6667, "x": 1.023, "y": 1.023 }
				]
			}
		}
	},
	"stand": {
		"slots": {
			"arroy": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			},
			"body": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			},
			"l-hand": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			},
			"l-leg": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			},
			"r-hand": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			},
			"r-leg": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			}
		},
		"bones": {
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": 50.25 },
					{ "time": 0.3333, "angle": 70.43 },
					{ "time": 0.6667, "angle": 50.25 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.414, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.4992, "x": 0, "y": 0 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 33.48 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -60.74 },
					{ "time": 0.3333, "angle": 279 },
					{ "time": 0.6667, "angle": -60.74 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.3333, "x": 0, "y": -2 },
					{ "time": 0.6667, "x": 0, "y": 0 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 },
					{ "time": 0.3333, "x": 0.95, "y": 0.95 },
					{ "time": 0.6667, "x": 1, "y": 1 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": -0.9 }
				]
			}
		}
	},
	"walk": {
		"bones": {
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": 325.52 },
					{ "time": 0.1667, "angle": -2.79 },
					{ "time": 0.3333, "angle": 3.8 },
					{ "time": 0.5, "angle": -2.79 },
					{ "time": 0.6667, "angle": 325.52 }
				],
				"translate": [
					{ "time": 0, "x": -5.34, "y": 1.42 },
					{ "time": 0.1667, "x": 0, "y": -0.18 },
					{ "time": 0.3333, "x": 0.16, "y": -0.16 },
					{ "time": 0.5, "x": 0, "y": -0.28 },
					{ "time": 0.6667, "x": -5.34, "y": 1.42 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": 38.57 },
					{ "time": 0.1667, "angle": -280.31 },
					{ "time": 0.3333, "angle": -301.06 },
					{ "time": 0.5, "angle": -280.31 },
					{ "time": 0.6667, "angle": 38.57 }
				],
				"translate": [
					{ "time": 0, "x": 1.83, "y": 6.97 },
					{ "time": 0.1667, "x": 3.34, "y": 2.83 },
					{ "time": 0.3333, "x": 0.63, "y": -0.1 },
					{ "time": 0.5, "x": 3.34, "y": 2.83 },
					{ "time": 0.6667, "x": 1.83, "y": 6.97 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 352.52 },
					{ "time": 0.1667, "angle": 0.49 },
					{ "time": 0.3333, "angle": 11.19 },
					{ "time": 0.5, "angle": 0.49 },
					{ "time": 0.6667, "angle": 352.52 }
				],
				"translate": [
					{ "time": 0, "x": 0.03, "y": 2 },
					{ "time": 0.1667, "x": 0.67, "y": -3.44 },
					{ "time": 0.3333, "x": -0.04, "y": 0.34 },
					{ "time": 0.5, "x": 0.67, "y": -3.44 },
					{ "time": 0.6667, "x": 0.03, "y": 2 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 21.94 },
					{ "time": 0.1667, "angle": 45.02 },
					{ "time": 0.3333, "angle": 31.36 },
					{ "time": 0.5, "angle": 45.02 },
					{ "time": 0.6667, "angle": 21.94 }
				],
				"translate": [
					{ "time": 0, "x": -2.98, "y": -1.7 },
					{ "time": 0.1667, "x": -3.99, "y": -1.69 },
					{ "time": 0.3333, "x": -2.9, "y": -1.85 },
					{ "time": 0.5, "x": -3.99, "y": -1.69 },
					{ "time": 0.6667, "x": -2.98, "y": -1.7 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -53.5 },
					{ "time": 0.1667, "angle": 277.11 },
					{ "time": 0.3333, "angle": -47.33 },
					{ "time": 0.5, "angle": 277.11 },
					{ "time": 0.6667, "angle": -53.5 }
				],
				"translate": [
					{ "time": 0, "x": 0.08, "y": 3.42 },
					{ "time": 0.1667, "x": -2.25, "y": 3.55 },
					{ "time": 0.3333, "x": -1.02, "y": 4.18 },
					{ "time": 0.5, "x": -2.25, "y": 3.55 },
					{ "time": 0.6667, "x": 0.08, "y": 3.42 }
				]
			},
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": 360 },
					{ "time": 0.1667, "angle": -0.91 },
					{ "time": 0.3333, "angle": 33.17 },
					{ "time": 0.5, "angle": -0.91 },
					{ "time": 0.6667, "angle": 360 }
				],
				"translate": [
					{ "time": 0, "x": 0.29, "y": 0 },
					{ "time": 0.1667, "x": 0.55, "y": -0.01 },
					{ "time": 0.3333, "x": 5.9, "y": 3.27 },
					{ "time": 0.5, "x": 0.55, "y": -0.01 },
					{ "time": 0.6667, "x": 0.29, "y": 0 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": -0.23 },
					{ "time": 0.1667, "angle": -0.75 },
					{ "time": 0.3333, "angle": -1.27 },
					{ "time": 0.5, "angle": -0.75 },
					{ "time": 0.6667, "angle": -0.23 }
				]
			}
		}
	}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/Font/TalkChar.atlas`:

```atlas

TalkChar.png
size: 256,128
format: RGBA8888
filter: Linear,Linear
repeat: none
!
  rotate: false
  xy: 2, 104
  size: 36, 17
  orig: 36, 17
  offset: 0, 0
  index: -1
%
  rotate: false
  xy: 220, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
+
  rotate: false
  xy: 164, 59
  size: 15, 20
  orig: 15, 20
  offset: 0, 0
  index: -1
-
  rotate: false
  xy: 40, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
0
  rotate: false
  xy: 40, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
1
  rotate: false
  xy: 58, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
2
  rotate: false
  xy: 76, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
3
  rotate: false
  xy: 94, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
4
  rotate: false
  xy: 112, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
5
  rotate: false
  xy: 130, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
6
  rotate: false
  xy: 148, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
7
  rotate: false
  xy: 166, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
8
  rotate: false
  xy: 184, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
9
  rotate: false
  xy: 202, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
@
  rotate: false
  xy: 2, 85
  size: 36, 17
  orig: 36, 17
  offset: 0, 0
  index: -1
A
  rotate: false
  xy: 2, 61
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
B
  rotate: false
  xy: 148, 33
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
C
  rotate: false
  xy: 176, 99
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
:
  rotate: false
  xy: 238, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
D
  rotate: false
  xy: 57, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
E
  rotate: false
  xy: 192, 99
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
F
  rotate: false
  xy: 126, 9
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
G
  rotate: false
  xy: 208, 99
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
H
  rotate: false
  xy: 2, 37
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
I
  rotate: false
  xy: 181, 57
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
J
  rotate: false
  xy: 224, 99
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
K
  rotate: false
  xy: 240, 99
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
L
  rotate: false
  xy: 140, 9
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
M
  rotate: false
  xy: 19, 61
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
N
  rotate: false
  xy: 196, 57
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
O
  rotate: false
  xy: 74, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
P
  rotate: false
  xy: 154, 9
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
Q
  rotate: false
  xy: 2, 13
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
R
  rotate: false
  xy: 211, 57
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
S
  rotate: false
  xy: 36, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
T
  rotate: false
  xy: 36, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
U
  rotate: false
  xy: 163, 33
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
V
  rotate: false
  xy: 19, 37
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
W
  rotate: false
  xy: 226, 57
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
X
  rotate: false
  xy: 52, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
Y
  rotate: false
  xy: 91, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
Z
  rotate: false
  xy: 52, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
_
  rotate: false
  xy: 2, 2
  size: 9, 9
  orig: 9, 9
  offset: 0, 0
  index: -1
a
  rotate: false
  xy: 68, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
b
  rotate: false
  xy: 68, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
c
  rotate: false
  xy: 177, 33
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
d
  rotate: false
  xy: 19, 13
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
e
  rotate: false
  xy: 241, 57
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
f
  rotate: false
  xy: 84, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
g
  rotate: false
  xy: 84, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
h
  rotate: false
  xy: 100, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
i
  rotate: false
  xy: 36, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
j
  rotate: false
  xy: 108, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
k
  rotate: false
  xy: 51, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
l
  rotate: false
  xy: 66, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
m
  rotate: false
  xy: 125, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
n
  rotate: false
  xy: 81, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
o
  rotate: false
  xy: 100, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
p
  rotate: false
  xy: 116, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
q
  rotate: false
  xy: 116, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
r
  rotate: false
  xy: 132, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
s
  rotate: false
  xy: 168, 9
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
t
  rotate: false
  xy: 142, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
u
  rotate: false
  xy: 96, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
v
  rotate: false
  xy: 111, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
w
  rotate: false
  xy: 132, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
x
  rotate: false
  xy: 148, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
y
  rotate: false
  xy: 159, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
z
  rotate: false
  xy: 191, 33
  size: 10, 22
  orig: 10, 22
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/Font/UINumber.atlas`:

```atlas

UINumber.png
size: 256,32
format: RGBA8888
filter: Linear,Linear
repeat: none
%
  rotate: false
  xy: 182, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
0
  rotate: false
  xy: 2, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
1
  rotate: false
  xy: 20, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
2
  rotate: false
  xy: 38, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
3
  rotate: false
  xy: 56, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
4
  rotate: false
  xy: 74, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
5
  rotate: false
  xy: 92, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
6
  rotate: false
  xy: 110, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
7
  rotate: false
  xy: 128, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
8
  rotate: false
  xy: 146, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
9
  rotate: false
  xy: 164, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
:
  rotate: false
  xy: 200, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/Font/hp.atlas`:

```atlas

hp.png
size: 256,64
format: RGBA8888
filter: Linear,Linear
repeat: none
%
  rotate: false
  xy: 34, 33
  size: 26, 29
  orig: 26, 29
  offset: 0, 0
  index: -1
-
  rotate: false
  xy: 78, 2
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
0
  rotate: false
  xy: 62, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
1
  rotate: false
  xy: 84, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
2
  rotate: false
  xy: 106, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
3
  rotate: false
  xy: 128, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
4
  rotate: false
  xy: 150, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
5
  rotate: false
  xy: 172, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
6
  rotate: false
  xy: 194, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
7
  rotate: false
  xy: 216, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
8
  rotate: false
  xy: 34, 2
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
9
  rotate: false
  xy: 56, 2
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
_
  rotate: false
  xy: 2, 32
  size: 30, 30
  orig: 30, 30
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/Stage/Stage11.atlas`:

```atlas

Stage11.png
size: 2048,2048
format: RGBA8888
filter: Linear,Linear
repeat: none
back1
  rotate: false
  xy: 2, 799
  size: 1024, 188
  orig: 1024, 188
  offset: 0, 0
  index: -1
back2
  rotate: false
  xy: 2, 164
  size: 1024, 124
  orig: 1024, 124
  offset: 0, 0
  index: -1
back3
  rotate: false
  xy: 2, 72
  size: 595, 90
  orig: 595, 90
  offset: 0, 0
  index: -1
before1
  rotate: false
  xy: 2, 290
  size: 1024, 163
  orig: 1024, 163
  offset: 0, 0
  index: -1
before2
  rotate: false
  xy: 964, 1554
  size: 1024, 312
  orig: 1024, 312
  offset: 0, 0
  index: -1
before3
  rotate: false
  xy: 2, 621
  size: 1024, 176
  orig: 1024, 176
  offset: 0, 0
  index: -1
before4
  rotate: false
  xy: 2, 1212
  size: 768, 112
  orig: 768, 112
  offset: 0, 0
  index: -1
cloud1
  rotate: false
  xy: 772, 1256
  size: 132, 68
  orig: 132, 68
  offset: 0, 0
  index: -1
cloud2
  rotate: false
  xy: 2, 2
  size: 128, 68
  orig: 128, 68
  offset: 0, 0
  index: -1
cloud3
  rotate: false
  xy: 599, 105
  size: 100, 57
  orig: 100, 57
  offset: 0, 0
  index: -1
middle1
  rotate: false
  xy: 2, 989
  size: 1024, 221
  orig: 1024, 221
  offset: 0, 0
  index: -1
middle2
  rotate: false
  xy: 964, 1264
  size: 1024, 288
  orig: 1024, 288
  offset: 0, 0
  index: -1
middle3
  rotate: false
  xy: 2, 455
  size: 1024, 164
  orig: 1024, 164
  offset: 0, 0
  index: -1
sky
  rotate: false
  xy: 2, 1326
  size: 960, 540
  orig: 960, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/Stage/Stage11.json`:

```json
{
"skeleton": { "hash": "ZUU61vQEYmzzCpUJlEQFFm3itN4", "spine": "3.6.04-beta", "width": 3836.22, "height": 544.5 },
"bones": [
	{ "name": "root" },
	{ "name": "Back", "parent": "root" },
	{ "name": "Before", "parent": "root" },
	{ "name": "Sky", "parent": "root" },
	{ "name": "Cloud1", "parent": "Sky", "x": 514.72, "y": 122.12 },
	{ "name": "Cloud2", "parent": "Sky", "x": 520.73, "y": 199.04 },
	{ "name": "Cloud3", "parent": "Sky", "x": 504.39, "y": 234.11 },
	{ "name": "Middle", "parent": "root" }
],
"slots": [
	{ "name": "Sky", "bone": "Sky", "attachment": "sky" },
	{ "name": "Cloud3", "bone": "Cloud3", "attachment": "cloud3" },
	{ "name": "Cloud2", "bone": "Cloud2", "attachment": "cloud2" },
	{ "name": "Cloud1", "bone": "Cloud1", "attachment": "cloud1" },
	{ "name": "back1", "bone": "Back", "attachment": "back1" },
	{ "name": "back2", "bone": "Back", "attachment": "back2" },
	{ "name": "back3", "bone": "Back", "attachment": "back3" },
	{ "name": "middle1", "bone": "Middle", "attachment": "middle1" },
	{ "name": "middle2", "bone": "Middle", "attachment": "middle2" },
	{ "name": "middle3", "bone": "Middle", "attachment": "middle3" },
	{ "name": "before1", "bone": "Before", "attachment": "before1" },
	{ "name": "before2", "bone": "Before", "attachment": "before2" },
	{ "name": "before3", "bone": "Before", "attachment": "before3" },
	{ "name": "before4", "bone": "Before", "attachment": "before4" },
	{ "name": "GroudPos", "bone": "root", "color": "00ff00ff", "attachment": "GroudPos" }
],
"skins": {
	"default": {
		"Cloud1": {
			"cloud1": { "y": -6.69, "scaleX": 0.5, "scaleY": 0.5, "width": 132, "height": 68 }
		},
		"Cloud2": {
			"cloud2": { "scaleX": 0.6, "scaleY": 0.6, "width": 128, "height": 68 }
		},
		"Cloud3": {
			"cloud3": { "x": 2.23, "scaleX": 0.4, "scaleY": 0.4, "width": 100, "height": 57 }
		},
		"GroudPos": {
			"GroudPos": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -1915.4, -160.87, -483.2, -161.96, 482.71, -162.27, 1915.63, -161.28 ]
			}
		},
		"Sky": {
			"sky": { "y": 3, "width": 960, "height": 540 }
		},
		"back1": {
			"back1": { "x": -735.2, "y": -67.24, "width": 1024, "height": 188 }
		},
		"back2": {
			"back2": { "x": 287.92, "y": -98.6, "width": 1024, "height": 124 }
		},
		"back3": {
			"back3": { "x": 1096.68, "y": -116.2, "width": 595, "height": 90 }
		},
		"before1": {
			"before1": { "x": -1408.22, "y": -189.83, "width": 1024, "height": 163 }
		},
		"before2": {
			"before2": { "x": -386.63, "y": -115.4, "width": 1024, "height": 312 }
		},
		"before3": {
			"before3": { "x": 636.8, "y": -183.5, "width": 1024, "height": 176 }
		},
		"before4": {
			"before4": { "x": 1532, "y": -215.5, "width": 768, "height": 112 }
		},
		"middle1": {
			"middle1": { "x": -958.09, "y": -64.03, "width": 1024, "height": 221 }
		},
		"middle2": {
			"middle2": { "x": 65.72, "y": -30.5, "width": 1024, "height": 288 }
		},
		"middle3": {
			"middle3": { "x": 1089.52, "y": -92.09, "width": 1024, "height": 164 }
		}
	}
},
"animations": {
	"ShowIn": {
		"bones": {
			"Back": {
				"translate": [
					{ "time": 0, "x": 0, "y": -385, "curve": "stepped" },
					{
						"time": 0.3333,
						"x": 0,
						"y": -385,
						"curve": [ 0.083, -1.11, 0.547, 1.26 ]
					},
					{ "time": 1.5, "x": 0, "y": 0 }
				]
			},
			"Before": {
				"translate": [
					{ "time": 0, "x": 0, "y": -385, "curve": "stepped" },
					{
						"time": 0.3333,
						"x": 0,
						"y": -385,
						"curve": [ 0.32, 0.31, 0.139, 1 ]
					},
					{ "time": 1.5, "x": 0, "y": 0 }
				]
			},
			"Middle": {
				"translate": [
					{ "time": 0, "x": 0, "y": -385, "curve": "stepped" },
					{
						"time": 0.3333,
						"x": 0,
						"y": -385,
						"curve": [ 0.321, -0.78, 0.088, 1.17 ]
					},
					{ "time": 1.5, "x": 0, "y": 0 }
				]
			}
		}
	},
	"animation": {}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/Texture/Arrow.atlas`:

```atlas

Arrow.png
size: 128,32
format: RGBA8888
filter: Linear,Linear
repeat: none
Copper
  rotate: false
  xy: 78, 20
  size: 10, 10
  orig: 10, 10
  offset: 0, 0
  index: -1
Dragon
  rotate: false
  xy: 49, 22
  size: 14, 8
  orig: 14, 8
  offset: 0, 0
  index: -1
Gold
  rotate: false
  xy: 2, 2
  size: 14, 12
  orig: 14, 12
  offset: 0, 0
  index: -1
Heart
  rotate: false
  xy: 18, 18
  size: 12, 12
  orig: 12, 12
  offset: 0, 0
  index: -1
Ice
  rotate: false
  xy: 32, 21
  size: 15, 9
  orig: 15, 9
  offset: 0, 0
  index: -1
Iron
  rotate: false
  xy: 65, 20
  size: 11, 10
  orig: 11, 10
  offset: 0, 0
  index: -1
Lightning
  rotate: false
  xy: 103, 21
  size: 9, 9
  orig: 9, 9
  offset: 0, 0
  index: -1
Silver
  rotate: false
  xy: 2, 16
  size: 14, 14
  orig: 14, 14
  offset: 0, 0
  index: -1
Steel
  rotate: false
  xy: 18, 5
  size: 11, 11
  orig: 11, 11
  offset: 0, 0
  index: -1
Wood
  rotate: false
  xy: 90, 21
  size: 11, 9
  orig: 11, 9
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/Texture/Drop.atlas`:

```atlas

Drop.png
size: 256,64
format: RGBA8888
filter: Linear,Linear
repeat: none
Coin
  rotate: false
  xy: 165, 24
  size: 30, 31
  orig: 30, 31
  offset: 0, 0
  index: -1
DropStone
  rotate: false
  xy: 2, 2
  size: 40, 53
  orig: 40, 53
  offset: 0, 0
  index: -1
DropWood
  rotate: false
  xy: 86, 25
  size: 40, 30
  orig: 40, 30
  offset: 0, 0
  index: -1
Heart
  rotate: false
  xy: 197, 29
  size: 30, 26
  orig: 30, 26
  offset: 0, 0
  index: -1
Stone
  rotate: false
  xy: 128, 22
  size: 35, 33
  orig: 35, 33
  offset: 0, 0
  index: -1
Wood
  rotate: false
  xy: 44, 22
  size: 40, 33
  orig: 40, 33
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/Curtain.atlas`:

```atlas

Curtain.png
size: 256,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
LCurtain
  rotate: false
  xy: 2, 2
  size: 240, 540
  orig: 240, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/Curtain.json`:

```json
{
"skeleton": { "hash": "CGONYPfuy4eXu5LYuNl5IW+qczw", "spine": "3.7.91", "width": 959.91, "height": 572.45 },
"bones": [
	{ "name": "root" },
	{ "name": "l-curtain", "parent": "root", "length": 197.06, "x": -360.4, "scaleX": 0.5, "scaleY": 0.53 },
	{ "name": "r-curtain", "parent": "root", "length": 197.06, "x": 360.38, "scaleX": -0.496, "scaleY": 0.53 }
],
"slots": [
	{ "name": "r-curtain", "bone": "r-curtain", "attachment": "LCurtain" },
	{ "name": "l-curtain", "bone": "l-curtain", "attachment": "LCurtain" }
],
"skins": {
	"default": {
		"l-curtain": {
			"LCurtain": {
				"type": "mesh",
				"uvs": [ 1, 0.51575, 1, 1, 0.77735, 1, 0.52132, 1, 0.25366, 1, 0, 1, 0, 0.51317, 0, 0, 0.25366, 0, 0.52132, 0, 0.77735, 0, 1, 0, 0.77735, 0.51317, 0.52132, 0.51317, 0.25366, 0.51317 ],
				"triangles": [ 6, 7, 8, 14, 6, 8, 14, 8, 9, 13, 14, 9, 13, 9, 10, 12, 10, 11, 13, 10, 12, 12, 11, 0, 4, 5, 6, 3, 4, 14, 4, 6, 14, 2, 3, 13, 3, 14, 13, 12, 2, 13, 12, 1, 2, 1, 12, 0 ],
				"vertices": [ 240, -17.05, 239.91, -540.04, 133.04, -540.02, 10.14, -540, -118.33, -539.98, -240.09, -539.96, -240, -14.18, -239.91, 540.04, -118.15, 540.02, 10.33, 540, 133.22, 539.98, 240.09, 539.96, 133.12, -14.24, 10.23, -14.22, -118.24, -14.2 ],
				"hull": 12
			}
		},
		"r-curtain": {
			"LCurtain": {
				"type": "mesh",
				"uvs": [ 1, 0.51575, 1, 1, 0.77735, 1, 0.52132, 1, 0.25366, 1, 0, 1, 0, 0.51317, 0, 0, 0.25366, 0, 0.52132, 0, 0.77735, 0, 1, 0, 0.77735, 0.51317, 0.52132, 0.51317, 0.25366, 0.51317 ],
				"triangles": [ 6, 7, 8, 14, 6, 8, 14, 8, 9, 13, 14, 9, 13, 9, 10, 12, 10, 11, 13, 10, 12, 12, 11, 0, 4, 5, 6, 3, 4, 14, 4, 6, 14, 2, 3, 13, 3, 14, 13, 12, 2, 13, 12, 1, 2, 1, 12, 0 ],
				"vertices": [ 240, -17.05, 239.91, -540.04, 133.04, -540.02, 10.14, -540, -118.34, -539.98, -240.09, -539.96, -240, -14.18, -239.91, 540.04, -118.15, 540.02, 10.33, 540, 133.22, 539.98, 240.09, 539.96, 133.13, -14.24, 10.23, -14.22, -118.24, -14.2 ],
				"hull": 12
			}
		}
	}
},
"animations": {
	"close": {
		"bones": {
			"l-curtain": {
				"translate": [
					{ "time": 0, "x": -4, "y": 0 },
					{
						"time": 0.6667,
						"x": 0,
						"y": 0,
						"curve": [ 0.463, 0.7, 1, 1 ]
					},
					{ "time": 0.9, "x": -110, "y": 0 }
				]
			},
			"r-curtain": {
				"translate": [
					{ "time": 0, "x": 3.62, "y": 0 },
					{
						"time": 0.6667,
						"x": 0.62,
						"y": 0,
						"curve": [ 0.463, 0.7, 1, 1 ]
					},
					{ "time": 0.9, "x": 110.62, "y": 0 }
				]
			}
		},
		"deform": {
			"default": {
				"l-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						},
						{
							"time": 0.1333,
							"vertices": [ 432.2832, 21.80872, 486.62573, 14.95862, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 390.20398, 8.76813, 333.15564, 16.073, 218.79541, -0.66461, 122.78381, 4.84912 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 220.87793, 20.74713, 272.8459, 8.93994, 199.18506, 7.25824, 148.25787, 5.20587, 58.98822, 1.5733, 0, 0, 0, 0, 0, 0, 65.47662, 1.40302, 68.54089, 2.10065, 137.61993, 3.41229, 183.75409, 5.3291, 161.31995, 0.92035, 100.78369, -0.17334, 56.42267, 3.74194 ]
						},
						{
							"time": 0.4,
							"vertices": [ 78.4137, 13.45746, 142.58795, 6.77069, 76.30096, 5.21155, 30.24377, 5.69977, -22.11847, 0.22119, 0, 0, 0, 0, 0, 0, -15.63007, 0.0509, -27.31067, 0.50397, -22.13428, 0.74847, 36.2912, 2.87231, 30.89807, 8.58154, -5.02191, 5.4386, -24.68402, 2.38983 ]
						},
						{
							"time": 0.5333,
							"vertices": [ -59.26178, 13.62079, -22.07806, 4.02905, -78.53424, 2.63367, -114.72119, 0.82611, -56.56842, 2.1051, 0, 0, 0, 0, 0, 0, -59.87054, -0.68683, -120.70618, -1.05316, -100.78241, -0.56183, -91.50854, 0.74432, -99.31848, 3.95477, -118.1604, 8.47052, -59.17517, 6.7312 ]
						},
						{
							"time": 0.6667,
							"vertices": [ -273.9226, -3.03149, -273.9226, -3.03149, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -273.9226, -3.03149, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ]
						}
					]
				},
				"r-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						},
						{
							"time": 0.1333,
							"vertices": [ 432.2832, 21.80872, 486.62573, 14.95862, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 390.20398, 8.76813, 333.15564, 16.073, 218.79541, -0.66461, 122.78381, 4.84912 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 220.87793, 20.74713, 272.8459, 8.93994, 199.18506, 7.25824, 148.25787, 5.20587, 58.98822, 1.5733, 0, 0, 0, 0, 0, 0, 65.47662, 1.40302, 68.54089, 2.10065, 137.61993, 3.41229, 183.75409, 5.3291, 161.31995, 0.92035, 100.78369, -0.17334, 56.42267, 3.74194 ]
						},
						{
							"time": 0.4,
							"vertices": [ 78.4137, 13.45746, 142.58795, 6.77069, 76.30096, 5.21155, 30.24377, 5.69977, -22.11847, 0.22119, 0, 0, 0, 0, 0, 0, -15.63007, 0.0509, -27.31067, 0.50397, -22.13428, 0.74847, 36.2912, 2.87231, 30.89807, 8.58154, -5.02191, 5.4386, -24.68402, 2.38983 ]
						},
						{
							"time": 0.5333,
							"vertices": [ -59.26178, 13.62079, -22.07806, 4.02905, -78.53424, 2.63367, -114.72119, 0.82611, -56.56842, 2.1051, 0, 0, 0, 0, 0, 0, -59.87054, -0.68683, -120.70618, -1.05316, -100.78241, -0.56183, -91.50854, 0.74432, -99.31848, 3.95477, -118.1604, 8.47052, -59.17517, 6.7312 ]
						},
						{
							"time": 0.6667,
							"vertices": [ -275.87817, -3.03149, -275.87817, -3.03149, -216.36029, -2.28912, -149.42908, -2.45532, -72.00098, -0.85242, -1.95557, 0, -1.95557, 0, -1.95557, 0, -72.00098, -0.85242, -149.76575, -1.5, -216.36029, -2.28912, -275.87817, -3.03149, -216.36029, -2.28912, -149.76575, -1.5, -72.00098, -0.85242 ]
						}
					]
				}
			}
		}
	},
	"stop": {
		"bones": {
			"l-curtain": {
				"translate": [
					{ "time": 0, "x": -4, "y": 0 }
				]
			},
			"r-curtain": {
				"translate": [
					{ "time": 0, "x": 3.62, "y": 0 }
				]
			}
		},
		"deform": {
			"default": {
				"l-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						}
					]
				},
				"r-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						}
					]
				}
			}
		}
	},
	"open": {
		"bones": {
			"l-curtain": {
				"translate": [
					{
						"time": 0,
						"x": -80,
						"y": 0,
						"curve": [ 0.695, 0.5, 1, 1 ]
					},
					{
						"time": 0.2333,
						"x": 0,
						"y": 0,
						"curve": [ 0.695, 0.5, 1, 1 ]
					},
					{ "time": 0.8667, "x": -4, "y": 0 }
				]
			},
			"r-curtain": {
				"translate": [
					{
						"time": 0,
						"x": 80.02,
						"y": 0,
						"curve": [ 0.695, 0.5, 1, 1 ]
					},
					{
						"time": 0.2333,
						"x": 2.02,
						"y": 0,
						"curve": [ 0.695, 0.5, 1, 1 ]
					},
					{ "time": 0.8667, "x": 4.02, "y": 0 }
				]
			}
		},
		"deform": {
			"default": {
				"l-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ -273.9226, -3.03149, -273.9226, -3.03149, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -273.9226, -3.03149, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ],
							"curve": "stepped"
						},
						{
							"time": 0.2333,
							"vertices": [ -273.9226, -3.03149, -273.9226, -3.03149, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -273.9226, -3.03149, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ],
							"curve": [ 0.695, 0.5, 1, 1 ]
						},
						{
							"time": 0.3667,
							"vertices": [ -127.65283, 4.47797, -154.5199, -0.56177, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -89.0246, -0.38568, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ]
						},
						{
							"time": 0.5,
							"vertices": [ 48.83887, 7.41809, -0.90668, 1.99701, -96.49017, -0.1228, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -47.71619, 0.32837, 87.4671, 2.55444, -71.02716, 4.2132, -147.81018, -1.5, -70.04541, -0.85242 ]
						},
						{
							"time": 0.6,
							"vertices": [ 220.45526, 12.83844, 163.06445, 4.72723, 103.35156, 3.20483, 72.82263, 3.77533, -54.71667, 1.96533, 0, 0, 0, 0, 0, 0, -29.05255, -0.1698, 87.90039, 2.4248, 187.9945, 4.2533, 277.06067, 5.7113, 139.19135, 0.02515, 85.33862, 2.38245, -52.19696, 4.57037 ]
						},
						{
							"time": 0.7333,
							"vertices": [ 440.79364, 16.5072, 393.609, 11.12878, 254.51349, 5.72198, 200.9253, 5.90826, 93.88397, 4.43976, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 290.35327, 2.5423, 213.44128, 4.51538, 96.40369, 7.0448 ]
						},
						{
							"time": 0.8667,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						}
					]
				},
				"r-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ -273.9226, -3.03149, -273.9226, -3.03149, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -273.9226, -3.03149, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ],
							"curve": "stepped"
						},
						{
							"time": 0.2333,
							"vertices": [ -273.9226, -3.03149, -273.9226, -3.03149, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -273.9226, -3.03149, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ],
							"curve": [ 0.695, 0.5, 1, 1 ]
						},
						{
							"time": 0.3667,
							"vertices": [ -127.65283, 4.47797, -154.5199, -0.56177, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -89.0246, -0.38568, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ]
						},
						{
							"time": 0.5,
							"vertices": [ 48.83887, 7.41809, -0.90668, 1.99701, -96.49017, -0.1228, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -47.71619, 0.32837, 87.4671, 2.55444, -71.02716, 4.2132, -147.81018, -1.5, -70.04541, -0.85242 ]
						},
						{
							"time": 0.6,
							"vertices": [ 220.45526, 12.83844, 163.06445, 4.72723, 103.35156, 3.20483, 72.82263, 3.77533, -54.71667, 1.96533, 0, 0, 0, 0, 0, 0, -29.05255, -0.1698, 87.90039, 2.4248, 187.9945, 4.2533, 277.06067, 5.7113, 139.19135, 0.02515, 85.33862, 2.38245, -52.19696, 4.57037 ]
						},
						{
							"time": 0.7333,
							"vertices": [ 440.79364, 16.5072, 393.609, 11.12878, 254.51349, 5.72198, 200.9253, 5.90826, 93.88397, 4.43976, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 290.35327, 2.5423, 213.44128, 4.51538, 96.40369, 7.0448 ]
						},
						{
							"time": 0.8667,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						}
					]
				}
			}
		}
	}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/HUD.atlas`:

```atlas

HUD.png
size: 1024,256
format: RGBA8888
filter: Linear,Linear
repeat: none
Coin
  rotate: false
  xy: 126, 106
  size: 30, 31
  orig: 30, 31
  offset: 0, 0
  index: -1
EnergyLength
  rotate: false
  xy: 1017, 186
  size: 5, 61
  orig: 5, 61
  offset: 0, 0
  index: -1
EnergySlot
  rotate: false
  xy: 2, 37
  size: 60, 135
  orig: 60, 135
  offset: 0, 0
  index: -1
Heart
  rotate: false
  xy: 964, 174
  size: 30, 26
  orig: 30, 26
  offset: 0, 0
  index: -1
Kill
  rotate: false
  xy: 163, 142
  size: 30, 30
  orig: 30, 30
  offset: 0, 0
  index: -1
Pointer
  rotate: false
  xy: 64, 39
  size: 17, 15
  orig: 17, 15
  offset: 0, 0
  index: -1
Stone
  rotate: false
  xy: 64, 56
  size: 43, 42
  orig: 43, 42
  offset: 0, 0
  index: -1
Stone2
  rotate: false
  xy: 126, 139
  size: 35, 33
  orig: 35, 33
  offset: 0, 0
  index: -1
Tombstone
  rotate: false
  xy: 64, 100
  size: 60, 72
  orig: 60, 72
  offset: 0, 0
  index: -1
Wood
  rotate: false
  xy: 964, 202
  size: 51, 45
  orig: 51, 45
  offset: 0, 0
  index: -1
Wood2
  rotate: false
  xy: 2, 2
  size: 40, 33
  orig: 40, 33
  offset: 0, 0
  index: -1
down
  rotate: false
  xy: 2, 206
  size: 960, 41
  orig: 960, 41
  offset: 0, 0
  index: -1
up
  rotate: false
  xy: 2, 174
  size: 960, 30
  orig: 960, 30
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/HUD.json`:

```json
{
"skeleton": { "hash": "B17rqM4AuFYMgBowFbHM5Vd+VjM", "spine": "3.7.91", "width": 1079, "height": 716.59 },
"bones": [
	{ "name": "root" },
	{ "name": "Right", "parent": "root", "x": 520.07, "y": 1.76 },
	{ "name": "Coin", "parent": "Right", "x": 0.93, "y": 156.24 },
	{ "name": "DownUp", "parent": "root" },
	{ "name": "Down", "parent": "DownUp" },
	{ "name": "Energy", "parent": "root", "x": -512, "y": 114 },
	{ "name": "EnergyLength", "parent": "Energy", "x": 2.45, "y": -52.68 },
	{ "name": "Heart", "parent": "Right", "x": 0.93, "y": 206.24 },
	{ "name": "Kill", "parent": "Right", "x": 0.93, "y": 106.24 },
	{ "name": "ScorePos", "parent": "root", "x": -467.45, "y": 240 },
	{ "name": "Stone", "parent": "Right", "x": 0.93, "y": 56.24 },
	{ "name": "Tombstone", "parent": "root", "y": 315 },
	{ "name": "Up", "parent": "DownUp" },
	{ "name": "Wood", "parent": "Right", "x": 0.93, "y": 6.24 },
	{ "name": "DownBtn", "parent": "root", "y": -60.58 },
	{ "name": "StoneRight", "parent": "DownBtn", "x": 265.2, "y": -268.5 },
	{ "name": "WoodRight", "parent": "DownBtn", "x": 348.23, "y": -276.33 },
	{ "name": "StoneLeft", "parent": "DownBtn", "x": -261.81, "y": -280.23 },
	{ "name": "WoodLeft", "parent": "DownBtn", "x": -335.51, "y": -273.2 }
],
"slots": [
	{ "name": "StoneRight", "bone": "StoneRight", "attachment": "Stone" },
	{ "name": "StoneLeft", "bone": "StoneLeft", "attachment": "Stone" },
	{ "name": "Wood", "bone": "Wood", "attachment": "Wood2" },
	{ "name": "WoodRight", "bone": "WoodRight", "attachment": "Wood" },
	{ "name": "WoodLeft", "bone": "WoodLeft", "attachment": "Wood" },
	{ "name": "EnergySlot", "bone": "Energy", "attachment": "EnergySlot" },
	{ "name": "EnergyLength", "bone": "EnergyLength", "attachment": "EnergyLength" },
	{ "name": "Tombstone", "bone": "Tombstone", "attachment": "Tombstone" },
	{ "name": "down", "bone": "Down", "attachment": "down" },
	{ "name": "Up", "bone": "Up", "attachment": "up" },
	{ "name": "StoneBoxRight", "bone": "StoneRight", "attachment": "StoneBox" },
	{ "name": "StoneBoxLeft", "bone": "StoneLeft", "attachment": "StoneBox" },
	{ "name": "WoodBoxRight", "bone": "WoodRight", "attachment": "WoodBox" },
	{ "name": "WoodBoxLeft", "bone": "WoodLeft", "attachment": "WoodBox" },
	{ "name": "Coin", "bone": "Coin", "attachment": "Coin" },
	{ "name": "Stone", "bone": "Stone", "attachment": "Stone2" },
	{ "name": "Heart", "bone": "Heart", "attachment": "Heart" },
	{ "name": "Kill", "bone": "Kill", "attachment": "Kill" },
	{ "name": "Pointer", "bone": "EnergyLength", "attachment": "Pointer" }
],
"skins": {
	"default": {
		"Coin": {
			"Coin": { "width": 30, "height": 31 }
		},
		"EnergyLength": {
			"EnergyLength": { "y": 30.5, "scaleY": 0.97, "width": 5, "height": 61 }
		},
		"EnergySlot": {
			"EnergySlot": { "width": 60, "height": 135 }
		},
		"Heart": {
			"Heart": { "width": 30, "height": 26 }
		},
		"Kill": {
			"Kill": { "width": 30, "height": 30 }
		},
		"Pointer": {
			"Pointer": { "x": 8, "y": 60.38, "width": 17, "height": 15 }
		},
		"Stone": {
			"Stone2": { "x": 0.5, "y": 0.5, "scaleX": 0.806, "scaleY": 0.806, "width": 35, "height": 33 }
		},
		"StoneBoxLeft": {
			"StoneBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -31, 21.6, 35.2, 19.65, 33.26, -22.27, -30.69, -20.73 ]
			}
		},
		"StoneBoxRight": {
			"StoneBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -31, 21.6, 35.2, 19.65, 33.26, -22.27, -30.69, -20.73 ]
			}
		},
		"StoneLeft": {
			"Stone": { "width": 43, "height": 42 }
		},
		"StoneRight": {
			"Stone": { "width": 43, "height": 42 }
		},
		"Tombstone": {
			"Tombstone": { "width": 60, "height": 72 }
		},
		"Up": {
			"up": { "y": 283.99, "width": 960, "height": 30 }
		},
		"Wood": {
			"Wood2": { "y": 0.5, "scaleX": 0.8, "scaleY": 0.8, "width": 40, "height": 33 }
		},
		"WoodBoxLeft": {
			"WoodBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -30.88, 19.58, 37.03, 20.2, 34.37, -21.43, -31.91, -20.4 ]
			}
		},
		"WoodBoxRight": {
			"WoodBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -30.88, 18.8, 37.03, 19.42, 34.37, -22.2, -31.91, -21.18 ]
			}
		},
		"WoodLeft": {
			"Wood": { "y": -3.02, "rotation": -16.43, "width": 51, "height": 45 }
		},
		"WoodRight": {
			"Wood": { "rotation": -5.03, "width": 51, "height": 45 }
		},
		"down": {
			"down": { "y": -288.68, "width": 960, "height": 41 }
		}
	}
},
"animations": {
	"ShowIn": {
		"bones": {
			"Energy": {
				"translate": [
					{
						"time": 0,
						"x": 0,
						"y": 0,
						"curve": [ 0.513, 0.67, 0.514, 1.62 ]
					},
					{ "time": 0.6667, "x": 72, "y": 0 }
				]
			},
			"Up": {
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.5, "x": 0, "y": -26.29 }
				]
			},
			"Down": {
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.5, "x": 0, "y": 38.26 }
				]
			},
			"Right": {
				"translate": [
					{
						"time": 0,
						"x": 0,
						"y": 0,
						"curve": [ 0.207, 0.29, 0.302, 1.71 ]
					},
					{ "time": 0.6667, "x": -64.09, "y": 0 }
				]
			},
			"DownBtn": {
				"translate": [
					{
						"time": 0,
						"x": 0,
						"y": -71.62,
						"curve": [ 0.186, 0.69, 0.143, 1.09 ]
					},
					{ "time": 1, "x": 0, "y": 97.69 }
				]
			}
		}
	},
	"animation": {}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIFail-zh.atlas`:

```atlas

UIFail-zh.png
size: 1024,512
format: RGBA8888
filter: Linear,Linear
repeat: none
Again
  rotate: false
  xy: 511, 400
  size: 102, 102
  orig: 102, 102
  offset: 0, 0
  index: -1
FailBG
  rotate: false
  xy: 2, 2
  size: 507, 500
  orig: 507, 500
  offset: 0, 0
  index: -1
Menu
  rotate: false
  xy: 511, 296
  size: 102, 102
  orig: 102, 102
  offset: 0, 0
  index: -1
Store
  rotate: false
  xy: 615, 399
  size: 101, 103
  orig: 101, 103
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIFail-zh.json`:

```json
{
"skeleton": { "hash": "i/hE4jAT5Zfvq0i4nbaMD3o0mAc", "spine": "3.7.91", "width": 507, "height": 500 },
"bones": [
	{ "name": "root" },
	{ "name": "Fail", "parent": "root" },
	{ "name": "Again", "parent": "Fail", "y": -147.89 },
	{ "name": "Hit", "parent": "Fail", "x": -79.72, "y": -28.71 },
	{ "name": "Kill", "parent": "Fail", "x": 60.89, "y": 38.24 },
	{ "name": "Menu", "parent": "Fail", "x": -130.1, "y": -147.9 },
	{ "name": "Score", "parent": "Fail", "x": -79.72, "y": 38.24 },
	{ "name": "Store", "parent": "Fail", "x": 129.17, "y": -151.64 },
	{ "name": "Time", "parent": "Fail", "x": 58.51, "y": -28.71 }
],
"slots": [
	{ "name": "FailBG", "bone": "Fail", "attachment": "FailBG" },
	{ "name": "Menu", "bone": "Menu", "attachment": "Menu" },
	{ "name": "Again", "bone": "Again", "attachment": "Again" },
	{ "name": "Store", "bone": "Store", "attachment": "Store" },
	{ "name": "MenuBox", "bone": "Menu", "attachment": "MenuBox" },
	{ "name": "AgainBox", "bone": "Again", "attachment": "AgainBox" },
	{ "name": "StoreBox", "bone": "Store", "attachment": "StoreBox" }
],
"skins": {
	"default": {
		"Again": {
			"Again": { "width": 102, "height": 102 }
		},
		"AgainBox": {
			"AgainBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -53.08, 45.13, 44.12, 47.35, 42.64, -46.88, -50.85, -46.88 ]
			}
		},
		"FailBG": {
			"FailBG": { "width": 507, "height": 500 }
		},
		"Menu": {
			"Menu": { "width": 102, "height": 102 }
		},
		"MenuBox": {
			"MenuBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -43.21, 46.72, 49.15, 45.42, 47.19, -46.67, -45.31, -46.67 ]
			}
		},
		"Store": {
			"Store": { "y": 3.71, "width": 101, "height": 103 }
		},
		"StoreBox": {
			"StoreBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -46.39, 55, 47.84, 53.52, 47, -42.1, -47.88, -41.46 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIFail.atlas`:

```atlas

UIFail.png
size: 1024,512
format: RGBA8888
filter: Linear,Linear
repeat: none
Again
  rotate: false
  xy: 511, 300
  size: 96, 98
  orig: 96, 98
  offset: 0, 0
  index: -1
FailBG
  rotate: false
  xy: 2, 2
  size: 507, 500
  orig: 507, 500
  offset: 0, 0
  index: -1
Menu
  rotate: false
  xy: 612, 404
  size: 96, 98
  orig: 96, 98
  offset: 0, 0
  index: -1
Store
  rotate: false
  xy: 511, 400
  size: 99, 102
  orig: 99, 102
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIFail.json`:

```json
{
"skeleton": { "hash": "V/6rfzALCxBO0FSMmaMtecPEAjw", "spine": "3.7.91", "width": 507, "height": 500 },
"bones": [
	{ "name": "root" },
	{ "name": "Fail", "parent": "root" },
	{ "name": "Again", "parent": "Fail", "y": -147.89 },
	{ "name": "Hit", "parent": "Fail", "x": -82.29, "y": -30.95 },
	{ "name": "Kill", "parent": "Fail", "x": 74.96, "y": 34.35 },
	{ "name": "Menu", "parent": "Fail", "x": -130.1, "y": -147.9 },
	{ "name": "Score", "parent": "Fail", "x": -82.29, "y": 34.35 },
	{ "name": "Store", "parent": "Fail", "x": 129.17, "y": -151.64 },
	{ "name": "Time", "parent": "Fail", "x": 74.96, "y": -30.95 }
],
"slots": [
	{ "name": "FailBG", "bone": "Fail", "attachment": "FailBG" },
	{ "name": "Menu", "bone": "Menu", "attachment": "Menu" },
	{ "name": "Again", "bone": "Again", "attachment": "Again" },
	{ "name": "Store", "bone": "Store", "attachment": "Store" },
	{ "name": "MenuBox", "bone": "Menu", "attachment": "MenuBox" },
	{ "name": "AgainBox", "bone": "Again", "attachment": "AgainBox" },
	{ "name": "StoreBox", "bone": "Store", "attachment": "StoreBox" }
],
"skins": {
	"default": {
		"Again": {
			"Again": { "width": 96, "height": 98 }
		},
		"AgainBox": {
			"AgainBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -53.08, 45.13, 44.12, 47.35, 42.64, -46.88, -50.85, -46.88 ]
			}
		},
		"FailBG": {
			"FailBG": { "x": 0.73, "width": 507, "height": 500 }
		},
		"Menu": {
			"Menu": { "width": 96, "height": 98 }
		},
		"MenuBox": {
			"MenuBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -43.21, 46.72, 49.15, 45.42, 47.19, -46.67, -45.31, -46.67 ]
			}
		},
		"Store": {
			"Store": { "y": 3.71, "width": 99, "height": 102 }
		},
		"StoreBox": {
			"StoreBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -46.39, 55, 47.84, 53.52, 47, -42.1, -47.88, -41.46 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIMenu-zh.atlas`:

```atlas

UIMenu-zh.png
size: 512,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
BG
  rotate: false
  xy: 2, 109
  size: 353, 536
  orig: 353, 536
  offset: 0, 0
  index: -1
Record
  rotate: false
  xy: 2, 55
  size: 145, 52
  orig: 145, 52
  offset: 0, 0
  index: -1
Shop
  rotate: false
  xy: 2, 2
  size: 145, 51
  orig: 145, 51
  offset: 0, 0
  index: -1
Start
  rotate: false
  xy: 357, 593
  size: 145, 52
  orig: 145, 52
  offset: 0, 0
  index: -1
Tutorial
  rotate: false
  xy: 149, 56
  size: 145, 51
  orig: 145, 51
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIMenu-zh.json`:

```json
{
"skeleton": { "hash": "YGafVpKxLFZq3hnrZ0OhTWo7+3E", "spine": "3.6.53", "width": 353, "height": 536 },
"bones": [
	{ "name": "root" },
	{ "name": "BG", "parent": "root" },
	{ "name": "Button", "parent": "BG" },
	{ "name": "Record", "parent": "Button", "y": -86 },
	{ "name": "Shop", "parent": "Button", "y": -12 },
	{ "name": "Start", "parent": "Button", "y": 73 },
	{ "name": "Tutorial", "parent": "Button", "y": -168 }
],
"slots": [
	{ "name": "BG", "bone": "BG", "attachment": "BG" },
	{ "name": "Start", "bone": "Start", "attachment": "Start" },
	{ "name": "Shop", "bone": "Shop", "attachment": "Shop" },
	{ "name": "StartBox", "bone": "Start", "attachment": "StartBox" },
	{ "name": "ShopBox", "bone": "Shop", "attachment": "ShopBox" },
	{ "name": "RecordBox", "bone": "Record", "attachment": "RecordBox" },
	{ "name": "TutorialBox", "bone": "Tutorial", "attachment": "TutorialBox" },
	{ "name": "Record", "bone": "Record", "attachment": "Record" },
	{ "name": "Tutorial", "bone": "Tutorial", "attachment": "Tutorial" }
],
"skins": {
	"default": {
		"BG": {
			"BG": { "width": 353, "height": 536 }
		},
		"Record": {
			"Record": { "y": -4, "width": 145, "height": 52 }
		},
		"RecordBox": {
			"RecordBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 22, 74.5, 22, 71.5, -28, -72.5, -26 ]
			}
		},
		"Shop": {
			"Shop": { "width": 145, "height": 51 }
		},
		"ShopBox": {
			"ShopBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 24, 77.5, 24, 77.5, -27, -71.5, -26 ]
			}
		},
		"Start": {
			"Start": { "y": -5, "width": 145, "height": 52 }
		},
		"StartBox": {
			"StartBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 19, 74.5, 19, 73.5, -27, -72.5, -30 ]
			}
		},
		"Tutorial": {
			"Tutorial": { "y": -2, "width": 145, "height": 51 }
		},
		"TutorialBox": {
			"TutorialBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -74.5, 25, 75.5, 23, 75.5, -26, -73.5, -28 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIMenu.atlas`:

```atlas

UIMenu.png
size: 512,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
BG
  rotate: false
  xy: 2, 109
  size: 358, 540
  orig: 358, 540
  offset: 0, 0
  index: -1
Record
  rotate: false
  xy: 2, 2
  size: 145, 51
  orig: 145, 51
  offset: 0, 0
  index: -1
Shop
  rotate: false
  xy: 149, 57
  size: 145, 50
  orig: 145, 50
  offset: 0, 0
  index: -1
Start
  rotate: false
  xy: 2, 55
  size: 145, 52
  orig: 145, 52
  offset: 0, 0
  index: -1
Tutorial
  rotate: false
  xy: 362, 597
  size: 145, 52
  orig: 145, 52
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIMenu.json`:

```json
{
"skeleton": { "hash": "+mj9k7aDyAEkSRGEQhi9lQIkds8", "spine": "3.6.53", "width": 358, "height": 540 },
"bones": [
	{ "name": "root" },
	{ "name": "BG", "parent": "root", "rotation": 0.09 },
	{ "name": "Button", "parent": "BG" },
	{ "name": "Record", "parent": "Button", "y": -86 },
	{ "name": "Shop", "parent": "Button", "y": -12 },
	{ "name": "Start", "parent": "Button", "y": 73 },
	{ "name": "Tutorial", "parent": "Button", "y": -168 }
],
"slots": [
	{ "name": "BG", "bone": "BG", "attachment": "BG" },
	{ "name": "Start", "bone": "Start", "attachment": "Start" },
	{ "name": "Shop", "bone": "Shop", "attachment": "Shop" },
	{ "name": "StartBox", "bone": "Start", "attachment": "StartBox" },
	{ "name": "ShopBox", "bone": "Shop", "attachment": "ShopBox" },
	{ "name": "RecordBox", "bone": "Record", "attachment": "RecordBox" },
	{ "name": "TutorialBox", "bone": "Tutorial", "attachment": "TutorialBox" },
	{ "name": "Record", "bone": "Record", "attachment": "Record" },
	{ "name": "Tutorial", "bone": "Tutorial", "attachment": "Tutorial" }
],
"skins": {
	"default": {
		"BG": {
			"BG": { "rotation": -0.09, "width": 358, "height": 540 }
		},
		"Record": {
			"Record": { "y": -4, "width": 145, "height": 51 }
		},
		"RecordBox": {
			"RecordBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 22, 74.5, 22, 71.5, -28, -72.5, -26 ]
			}
		},
		"Shop": {
			"Shop": { "width": 145, "height": 50 }
		},
		"ShopBox": {
			"ShopBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 24, 77.5, 24, 77.5, -27, -71.5, -26 ]
			}
		},
		"Start": {
			"Start": { "y": -5, "width": 145, "height": 52 }
		},
		"StartBox": {
			"StartBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 19, 74.5, 19, 73.5, -27, -72.5, -30 ]
			}
		},
		"Tutorial": {
			"Tutorial": { "y": -2, "width": 145, "height": 52 }
		},
		"TutorialBox": {
			"TutorialBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -74.5, 25, 75.5, 23, 75.5, -26, -73.5, -28 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIRecord-zh.atlas`:

```atlas

UIRecord-zh.png
size: 1024,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
Close
  rotate: false
  xy: 2, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
Record
  rotate: false
  xy: 2, 20
  size: 666, 540
  orig: 666, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIRecord-zh.json`:

```json
{
"skeleton": { "hash": "GstQOPnl6wgM5EecgXUFSZBoa0c", "spine": "3.7.91", "width": 666, "height": 540 },
"bones": [
	{ "name": "root" },
	{ "name": "Close", "parent": "root", "x": 166.06, "y": 197.27 },
	{ "name": "MaxKill", "parent": "root", "y": 47.75 },
	{ "name": "MaxRound", "parent": "root", "y": -36.94 },
	{ "name": "MaxRoundTime", "parent": "root", "y": -119.83 },
	{ "name": "MaxScore", "parent": "root", "y": 132.45 },
	{ "name": "PlayGameTime", "parent": "root", "y": -202.73 }
],
"slots": [
	{ "name": "BG", "bone": "root", "attachment": "Record" },
	{ "name": "Close", "bone": "Close", "attachment": "Close" },
	{ "name": "CloseBox", "bone": "Close", "attachment": "CloseBox" }
],
"skins": {
	"default": {
		"BG": {
			"Record": { "x": 30.72, "width": 666, "height": 540 }
		},
		"Close": {
			"Close": { "x": -1.59, "y": 1.43, "rotation": 6.11, "width": 16, "height": 16 }
		},
		"CloseBox": {
			"CloseBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -24.12, 23.7, 30.82, 25.66, 31.75, -22.99, -22.28, -24.92 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIRecord.atlas`:

```atlas

UIRecord.png
size: 1024,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
Close
  rotate: false
  xy: 2, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
Record
  rotate: false
  xy: 2, 20
  size: 666, 540
  orig: 666, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UIRecord.json`:

```json
{
"skeleton": { "hash": "I3VFIORr7f5+lbux93yYpZqB8/M", "spine": "3.7.91", "width": 666, "height": 540 },
"bones": [
	{ "name": "root" },
	{ "name": "Close", "parent": "root", "x": 166.06, "y": 197.27 },
	{ "name": "MaxKill", "parent": "root", "y": 47.75 },
	{ "name": "MaxRound", "parent": "root", "y": -36.94 },
	{ "name": "MaxRoundTime", "parent": "root", "y": -119.83 },
	{ "name": "MaxScore", "parent": "root", "y": 132.45 },
	{ "name": "PlayGameTime", "parent": "root", "y": -202.73 }
],
"slots": [
	{ "name": "BG", "bone": "root", "attachment": "Record" },
	{ "name": "Close", "bone": "Close", "attachment": "Close" },
	{ "name": "CloseBox", "bone": "Close", "attachment": "CloseBox" }
],
"skins": {
	"default": {
		"BG": {
			"Record": { "x": 30.72, "width": 666, "height": 540 }
		},
		"Close": {
			"Close": { "width": 16, "height": 16 }
		},
		"CloseBox": {
			"CloseBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -23.67, 24.24, 31.3, 25.14, 31.3, -23.51, -22.76, -24.42 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UITutorial-zh.atlas`:

```atlas

UITutorial-zh.png
size: 1024,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
Close
  rotate: false
  xy: 2, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
Tutorial
  rotate: false
  xy: 2, 20
  size: 826, 540
  orig: 826, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UITutorial-zh.json`:

```json
{
"skeleton": { "hash": "lqozmvch6CXXlsW1vGF0hAmfY/I", "spine": "3.7.91", "width": 826, "height": 540 },
"bones": [
	{ "name": "root" },
	{ "name": "Close", "parent": "root", "x": 313.85, "y": 188.19 }
],
"slots": [
	{ "name": "Tutorial", "bone": "root", "attachment": "Tutorial" },
	{ "name": "CloseBox", "bone": "Close", "attachment": "CloseBox" },
	{ "name": "Close", "bone": "Close", "attachment": "Close" }
],
"skins": {
	"default": {
		"Close": {
			"Close": { "x": 0.16, "y": 0.74, "scaleX": 1.1, "scaleY": 1.1, "width": 16, "height": 16 }
		},
		"CloseBox": {
			"CloseBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -35.15, 28.66, 44.85, 29.66, 45.85, -25.34, -36.15, -25.34 ]
			}
		},
		"Tutorial": {
			"Tutorial": { "width": 826, "height": 540 }
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UITutorial.atlas`:

```atlas

UITutorial.png
size: 1024,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
Close
  rotate: false
  xy: 2, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
Tutorial
  rotate: false
  xy: 2, 20
  size: 826, 540
  orig: 826, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/Android/app/src/main/assets/UI/UITutorial.json`:

```json
{
"skeleton": { "hash": "MqwUMTIgngKS9HEqMWPDQHcaSNc", "spine": "3.7.91", "width": 826, "height": 540 },
"bones": [
	{ "name": "root" },
	{ "name": "Close", "parent": "root", "x": 314.16, "y": 189.53 }
],
"slots": [
	{ "name": "Tutorial", "bone": "root", "attachment": "Tutorial" },
	{ "name": "CloseBox", "bone": "Close", "attachment": "CloseBox" },
	{ "name": "Close", "bone": "Close", "attachment": "Close" }
],
"skins": {
	"default": {
		"Close": {
			"Close": { "width": 16, "height": 16 }
		},
		"CloseBox": {
			"CloseBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -35.15, 39.49, 44.85, 40.49, 45.85, -14.51, -36.15, -14.51 ]
			}
		},
		"Tutorial": {
			"Tutorial": { "width": 826, "height": 540 }
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/Android/app/src/main/java/com/Mojoc/Samples/SuperLittleRed/GameActivity.java`:

```java

package com.Mojoc.Samples.SuperLittleRed;

import android.app.Activity;
import android.app.NativeActivity;
import android.os.Bundle;
import android.os.Handler;
import android.view.KeyEvent;
import android.view.View;
import android.widget.Toast;


/**
 * @author scott.cgi
 * @since  2015-3-2
 * Update  2019-8-4
 */
public class GameActivity extends NativeActivity {
    
    @Override
    protected void onCreate (Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
    }


    @Override
    protected void onResume() {
        this.immersive();
        super.onResume();
    }


    private void immersive() {
        this.getWindow().getDecorView().setSystemUiVisibility(
            View.SYSTEM_UI_FLAG_HIDE_NAVIGATION |
            View.SYSTEM_UI_FLAG_FULLSCREEN      |
            View.SYSTEM_UI_FLAG_IMMERSIVE       |
            View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
    }


    private long exitTime = 0;
    

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {

            if ((System.currentTimeMillis() - this.exitTime) > 2000) {
                Toast.makeText(GameActivity.this, this.getString(R.string.app_exit), Toast.LENGTH_SHORT).show();
                this.exitTime = System.currentTimeMillis();
            } else {
                this.onDestroy();
                final Activity local = this;

                // wait for onDestroy finish
                new Handler().postDelayed(new Runnable() {
                    @Override
                    public void run() {
                        local.finish();
                        System.exit(0);
                    }
                }, 1000);
            }

            return true;
        }

        return super.onKeyDown(keyCode, event);
    }
}

```

`Samples/SuperLittleRed/Android/app/src/main/res/values-zh-rCN/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Mojoc 小红帽丛林之战</string>
    <string name="app_exit">再次返回退出</string>
</resources>

```

`Samples/SuperLittleRed/Android/app/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Mojoc Super Little Red</string>
    <string name="app_exit">Back again to exit</string>
</resources>

```

`Samples/SuperLittleRed/Android/build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.2.1'
        // NOTE: Do not place your application dependencies here; they belong
    }

}

allprojects {
    repositories {
        google()
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}


```

`Samples/SuperLittleRed/Android/gradle.properties`:

```properties
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
android.defaults.buildfeatures.buildconfig=true
android.nonFinalResIds=false
android.nonTransitiveRClass=false
org.gradle.jvmargs=-Xmx1536m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

```

`Samples/SuperLittleRed/Android/settings.gradle`:

```gradle
include ":app"

```

`Samples/SuperLittleRed/Code/ADTool.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-2-25
 * Update   : 2019-7-31
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Platform/Platform.h"
#include "ADTool.h"


//------------------------
#ifdef IS_PLATFORM_ANDROID
//------------------------


#include "Engine/Application/Platform/Android/JniTool.h"


static void Show(ADType type)
{
}


static void Hide(ADType type)
{
}


//----------------------------
#elif defined(IS_PLATFORM_IOS)
//----------------------------


static void Show(ADType type)
{
}

static void Hide(ADType type)
{
}


//---------------------------
#endif // IS_PLATFORM_ANDROID
//---------------------------


struct AADTool AADTool[1] =
{{
    Show,
    Hide,
}};



```

`Samples/SuperLittleRed/Code/ADTool.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-2-25
 * Update   : 2019-7-31
 * Author   : scott.cgi
 */


#ifndef AD_TOOL_H
#define AD_TOOL_H


/**
 * The advertisement type.
 */
typedef enum
{
    ADType_Banner,
    ADType_Interstitial,
}
ADType;


/**
 * Control and manage AD.
 */
struct AADTool
{
    void (*Show)(ADType type);
    void (*Hide)(ADType type);
};


extern struct AADTool AADTool[1];


#endif

```

`Samples/SuperLittleRed/Code/AppInit.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2013-1-20
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#include <stdio.h>
#include <string.h>

#include "Engine/Toolkit/Utils/TweenTool.h"
#include "Engine/Audio/Platform/Audio.h"
#include "Engine/Application/Application.h"
#include "Engine/Application/Scheduler.h"
#include "Engine/Application/Platform/SystemInfo.h"
#include "Engine/Extension/Font.h"
#include "Engine/Toolkit/Utils/Coroutine.h"
#include "Engine/Graphics/OpenGL/Camera.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Graphics/Graphics.h"
#include "Engine/Graphics/OpenGL/Platform/gl3.h"
#include "Engine/Toolkit/Utils/FileTool.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/Sprite.h"

#include "GameMap.h"
#include "Hero.h"
#include "GameActor.h"
#include "EnemyAI.h"
#include "HUD.h"
#include "Tool.h"
#include "UI.h"
#include "GameData.h"
#include "AudioTool.h"
#include "ADTool.h"
#include "Config.h"


static const char* saveDataFileName = "MojocSampleSupperLittleRed";
static int         progressSize     = AppInit_FunctionsCount + Enemy_KindsNum * Enemy_EachKindInitNum;
static GLbitfield  clearBits        = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT;
static Font*       font;
static FontText*   loadingText;
static Scheduler*  loadingScheduler;
static Sprite*     logoSprite;


typedef void (*InitFunction)(void);
static InitFunction InitFunctions[AppInit_FunctionsCount];


static void LoadingUpdate(Scheduler* scheduler, float deltaSeconds)
{
    AFont->Draw(font);

    if (scheduler->isCancel)
    {
        ASprite->Release(logoSprite);
        free(logoSprite);
        logoSprite = NULL;
    }
    else if (logoSprite != NULL)
    {
        ASprite_Draw(logoSprite);
    }
}


static void LoadingRun(Coroutine* coroutine)
{
    static int progress = 0;

    ACoroutine_Begin();

    ATweenTool->AddFadeTo(1.0f, 2.5f)->SetEaseType(TweenEaseType_BounceOut)->RunActions(logoSprite->drawable);
    ACoroutine_YieldSeconds(3.5f);

    ATweenTool->AddFadeTo(-1.0f, 0.8f)->RunActions(logoSprite->drawable);
    ACoroutine_YieldSeconds(0.8f);

    for (; progress < progressSize; ++progress)
    {
        if (progress < AppInit_FunctionsCount)
        {
            InitFunctions[progress]();
        }
        else
        {
             AEnemyAI->CreateCache((progress - AppInit_FunctionsCount) / Enemy_EachKindInitNum);
        }

        char buff[5];
        sprintf(buff, "%d%%", (progress + 1) * 100 / progressSize);
        AFont->SetString(loadingText, buff);

        ADrawable_SetPositionX
        (
            loadingText->drawable,
            loadingText->drawable->width / 2
        );

        ACoroutine_YieldFrames(0);
    }

    ACoroutine_YieldSeconds(1.0f);
    ACoroutine_End();

    loadingScheduler->isCancel = true;
    AFont->Release(font);
    AHUD->Run();
}


static void InitLanguageCode()
{
    char outLanguageCode[2];
    ASystemInfo->GetLanguageCode(outLanguageCode);

    if (outLanguageCode[0] == 'z' && outLanguageCode[1] == 'h')
    {
        ATool->languageCode = LanguageCode_zh;
    }
}


static void InitWithSavedData()
{
    long  size;
    void* data = AFileTool->CreateDataFromRelative(saveDataFileName, &size);

    if (data != NULL)
    {
        memcpy(AGameData, data, (size_t) size);
        free(data);
    }

    ++AGameData->playGameCount;
}                                                              


static void OnReady()
{
    glEnable   (GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    AGraphics->SetUseVAO      (true);
    AGraphics->SetUseMapBuffer(true);

    memcpy
    (
        InitFunctions,
        (InitFunction[AppInit_FunctionsCount])
        {
            InitLanguageCode,
            InitWithSavedData,
            AGameMap->Init,
            AHero->Init,
            AGameActor->Init,
            AHUD->Init,
            AUI->Init,
            AEnemyAI->Init,
        },
        AppInit_FunctionsCount * sizeof(void*)
    );

    ATool->globalScaleX = AGLTool->screenWidth  / Screen_DesignWidth;
    ATool->globalScaleY = AGLTool->screenHeight / Screen_DesignHeight;

    font        = AFont->Get("Font/hp.atlas");
    loadingText = AFont->GetText(font);
    loadingText->alignment = FontTextAlignment_HorizontalRight;
    ADrawable_SetScale2(loadingText->drawable, ATool->globalScaleX, ATool->globalScaleY);

    logoSprite = ASprite->CreateWithFile("Texture/Logo.png");
    ADrawable_SetOpacity(logoSprite->drawable, 0.0f);

    loadingScheduler = AScheduler->Schedule(LoadingUpdate, 0.0f);
    ACoroutine->StartCoroutine(LoadingRun);

    AMath_RandomSeedByTime();
    AAudioTool->StartUIBG();
}


static void OnResized(int width, int height)
{
    ACamera->right  =  AGLTool->screenRatio;
    ACamera->left   = -AGLTool->screenRatio;
    ACamera->bottom = -1.0f;
    ACamera->top    =  1.0f;
    ACamera->near   =  1.0f;
    ACamera->far    =  11.0f;
    ACamera->SetOrthographic();

    ACamera->eyeX   =  0.0f;
    ACamera->eyeY   =  0.0f;
    ACamera->eyeZ   =  2.0f;

    ACamera->lookX  =  0.0f;
    ACamera->lookY  =  0.0f;
    ACamera->lookZ  = -1.0f;

    ACamera->upX    =  0.0f;
    ACamera->upY    =  1.0f;
    ACamera->upZ    =  0.0f;
    
    ACamera->SetLookAt();
}


static void OnPause()
{
    AAudio->SetLoopPause();
}


static void OnResume()
{
    AAudio->SetLoopResume();
}


static void OnDestroy()
{
}


static void OnSaveData(void* param)
{
    AFileTool->WriteDataToRelative(saveDataFileName, AGameData, sizeof(struct AGameData));
}


static void Update(Component* component, float deltaSeconds)
{
    glClear(clearBits);
}



void Application_MainImpl()
{
    AApplication->rootComponent->defaultState->Update = Update;

    AApplication->callbacks->OnReady    = OnReady;
    AApplication->callbacks->OnPause    = OnPause;
    AApplication->callbacks->OnResume   = OnResume;
    AApplication->callbacks->OnDestroy  = OnDestroy;
    AApplication->callbacks->OnResized  = OnResized;
    AApplication->callbacks->OnSaveData = OnSaveData;
}


```

`Samples/SuperLittleRed/Code/AudioTool.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-2-20
 * Update   : 2019-2-17
 * Author   : scott.cgi
 */


#include <stddef.h>
#include "Engine/Toolkit/Math/Math.h"
#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Application/Scheduler.h"
#include "Engine/Audio/Platform/Audio.h"
#include "AudioTool.h"
#include "GameMap.h"


static const char* ids[AudioID_Length] =
{
    "Audio/ClickBtn.aac",
    "Audio/CurtainSlideShow.aac",
    "Audio/CurtainSlideHide.aac",
    "Audio/Shoot.aac",
    "Audio/HurtEnemy.aac",
    "Audio/HurtGround.aac",
    "Audio/Drop.aac",
    "Audio/PickCoin.aac",
    "Audio/PickHeart.aac",
    "Audio/PickStone.aac",
    "Audio/PickWood.aac",
    "Audio/HurtHero.aac",
    "Audio/Over.aac",
    "Audio/CurtainRing.aac",
    "Audio/ShootFaster.aac",
    "Audio/FallDown.aac",
    "Audio/NoArrow.aac",
    "Audio/HeroDie.aac",
    "Audio/BG11.aac",
    "Audio/BG21.aac",
    "Audio/BG22.aac",
};


static AudioPlayer* uiBG     = NULL;
static AudioPlayer* gameBG   = NULL;
static float        volume   = 0.0f;
static float        maxBG    = 0.5f;
static float        interval = 0.05f;


static void VolumeUpdate(Scheduler* scheduler, float deltaSeconds)
{
    volume += interval;

    if (volume > maxBG)
    {
        volume = maxBG;
    }

    if (AUserData_GetSlotInt(scheduler->userData, 0) == 0)
    {
        AAudio->SetVolume(uiBG, volume);
    }
    else
    {
        AAudio->SetVolume(gameBG, volume);
    }

    if (volume == maxBG)
    {
        scheduler->isCancel = true;
        volume              = 0;
    }
}


static void StartUIBG()
{
    AudioID bgs[2] = {AudioID_BG21, AudioID_BG22};

    uiBG = AAudioTool->Play(bgs[AMath_RandomInt(0, 1)]);

    AAudio->SetLoop  (uiBG, true);
    AAudio->SetVolume(uiBG, 0);

    if (gameBG != NULL)
    {
        AAudio->Stop(gameBG);
    }

    AUserData_SetSlotInt(AScheduler->Schedule(VolumeUpdate, interval)->userData, 0, 0);
}


static void StartGameBG()
{
    AudioID bgs[1] = {AudioID_BG11};

    gameBG = AAudioTool->Play(bgs[AGameMap->mapIndex]);

    AAudio->SetLoop  (gameBG, true);
    AAudio->SetVolume(gameBG, 0);

    if (uiBG != NULL)
    {
        AAudio->Stop(uiBG);
    }

    AUserData_SetSlotInt(AScheduler->Schedule(VolumeUpdate, interval)->userData, 0, 1);
}


static AudioPlayer* Play(AudioID id)
{
    AudioPlayer* player = AAudio->GetPlayer((char*) ids[id]);

    AAudio->Play     (player);
    AAudio->SetVolume(player, 0.6f);
    return player;
}


static void PauseGameBG(void)
{
    AAudio->Pause(gameBG);
}


static void ResumeGameBG(void)
{
    AAudio->Play(gameBG);
}


struct AAudioTool AAudioTool[1] =
{{
    Play,
    StartUIBG,
    StartGameBG,
    PauseGameBG,
    ResumeGameBG,
}};

```

`Samples/SuperLittleRed/Code/AudioTool.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-2-20
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#ifndef AUDIO_TOOL_H
#define AUDIO_TOOL_H


#include "Engine/Audio/Platform/Audio.h"


typedef enum
{
    AudioID_ClickBtn,
    AudioID_CurtainSlideShow,
    AudioID_CurtainSlideHide,
    AudioID_Shoot,
    AudioID_HurtEnemy,
    AudioID_HurtGround,
    AudioID_Drop,
    AudioID_PickCoin,
    AudioID_PickHeart,
    AudioID_PickStone,
    AudioID_PickWood,
    AudioID_HurtHero,
    AudioID_Over,
    AudioID_CurtainRing,
    AudioID_ShootFast,
    AudioID_FallDown,
    AudioID_NoArrow,
    AudioID_HeroDie,
    AudioID_BG11,
    AudioID_BG21,
    AudioID_BG22,

    AudioID_Length,
}
AudioID;


struct AAudioTool
{
    AudioPlayer* (*Play)        (AudioID id);
    void         (*StartUIBG)   (void);
    void         (*StartGameBG) (void);
    void         (*PauseGameBG) (void);
    void         (*ResumeGameBG)(void);
};


extern struct AAudioTool AAudioTool[1];


#endif

```

`Samples/SuperLittleRed/Code/Build/Android/CMakeLists.txt`:

```txt
# Sets the minimum version of CMake required to build the native
# library. You should either keep the default value or only pass a
# value of 3.4.0 or lower.

cmake_minimum_required(VERSION 3.4.1)

set(CMAKE_VERBOSE_MAKEFILE ON)

#####################################################################

add_subdirectory(
    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../../../Mojoc/Engine/Build/Android/
    ${CMAKE_CURRENT_SOURCE_DIR}/../../../../../../Mojoc/Engine/Build/Android/Bin/
)

#####################################################################

include_directories(
     ${CMAKE_CURRENT_SOURCE_DIR}/../../../../../../Mojoc/
     ../../
)

#####################################################################

add_library(
    SuperLittleRed SHARED

    ../../AppInit.c
    ../../Tool.c
    ../../GameMap.c
    ../../Hero.c
    ../../Enemy.c
    ../../EnemyAI.c
    ../../GameActor.c
    ../../HUD.c
    ../../UI.c
    ../../GameData.c
    ../../AudioTool.c
    ../../ADTool.c
)


target_link_libraries(
    SuperLittleRed
    Mojoc
)
```

`Samples/SuperLittleRed/Code/Config.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 * 
 * Since    : 2015-4-13
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#ifndef CONFIG_H
#define CONFIG_H


#define APP_DEBUG
#define APP_SHOW_FPS_AND_DRAW_CALL
//#define APP_NO_ENEMY


enum
{
    Screen_DesignWidth     = 960,
    Screen_DesignHeight    = 540,
    
    Enemy_KindsNum         = 1,
    Enemy_EachKindInitNum  = 10,
    Enemy_KillIncrease     = 20,
    Enemy_TimeIncrease     = 15,
    Enemy_BossInterval     = 10,
    Enemy_BossHPX          = 5,
    Enemy_BossSpeedX       = 2,

    AppInit_FunctionsCount = 8,
};


static const float heroEnergyRecoverTime = 1.8f;
static const float enemyDoAITime         = 1.0f;
static const float enemyCreateTime       = 2.0f;


#endif

```

`Samples/SuperLittleRed/Code/Enemy.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-9-29
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/Utils/ArrayIntSet.h"
#include "Engine/Toolkit/Math/Vector.h"
#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Toolkit/Utils/TweenTool.h"
#include "Engine/Application/Scheduler.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Physics/PhysicsWorld.h"
#include "Engine/Toolkit/HeaderUtils/Struct.h"

#include "GameActor.h"
#include "GameMap.h"
#include "Hero.h"
#include "Tool.h"
#include "EnemyAI.h"
#include "GameData.h"
#include "HUD.h"
#include "Enemy.h"
#include "AudioTool.h"


static void Update(Component* component, float deltaSeconds)
{
    Enemy* enemy = AUserData_GetSlotPtrWithType(component->userData, 0, Enemy*);

    if (enemy->collisionBoxBody != NULL)
    {
        if (enemy->collisionBoxBody->state != PhysicsBodyState_Freeze)
        {
            ATool->UpdateBox(enemy->collisionBoxBody, enemy->collisionBoxDrawable);
        }
    }

    if (component->curState->id == EnemyState_Attack && enemy->attackBoxBody != NULL)
    {
        ATool->UpdateBox(enemy->attackBoxBody, enemy->attackBoxDrawable);
    }

    ASkeletonAnimationPlayer_Update(enemy->player, deltaSeconds);

    for (int i = 0; i < enemy->arrowSet->elementList->size; ++i)
    {
        Arrow* arrow = AArrayList_Get(enemy->arrowSet->elementList, i, Arrow*);
        ATool->UpdateArrowTail(arrow, deltaSeconds);
        ADrawable->Draw(arrow->sprite->drawable);
        ADrawable->Draw(arrow->tailDrawable);
    }

    ASkeletonAnimationPlayer_Update(enemy->hurtEffect,  deltaSeconds);
    ASkeletonAnimationPlayer_Update(enemy->dizzyEffect, deltaSeconds);

    #ifdef APP_DEBUG
    if (enemy->collisionBoxBody != NULL)
    {
        ADrawable->Draw(enemy->debugCollisionBoundingBox);
    }

    if (component->curState->id == EnemyState_Attack && enemy->attackBoxBody)
    {
        ADrawable->Draw(enemy->debugAttackBoundingBox);
    }
    #endif
}


static void HurtTextTweenActionOnComplete(TweenAction* tweenAction)
{
    AFont->ReleaseText(AUserData_GetSlotPtrWithType(tweenAction->userData, 0, FontText*));
}


static void WoodStopSchedulerUpdate(Scheduler* scheduler, float deltaSeconds)
{
    AUserData_GetSlotPtrWithType(scheduler->userData, 0, Enemy*)->isWoodStop = false;
}


static void WoodStopActionOnComplete(TweenAction* action)
{
    AUserData_GetSlotPtrWithType(action->userData, 0, Enemy*)->isWoodStop = false;
}


static void OnHurt(PhysicsBody* self, PhysicsBody* other, float deltaSeconds)
{
    Enemy* enemy = AUserData_GetSlotPtrWithType(self->userData, 0, Enemy*);

    if (enemy->component->curState->id >= EnemyState_Die)
    {
        return;
    }

    Drawable* enemyDrawable = AEnemy_GetDrawable(enemy);

    if (other->userID == CollisionBodyID_Wood)
    {
        if (enemy->isWoodStop == false)
        {
            enemy->isWoodStop = true;

            ATween->TryRemoveAllActions(enemyDrawable);

            // once stop action make sure stand on ground
            ATweenTool->AddMoveY   (AGameMap->groundY, enemy->hurtYDownTime)
                      ->SetEaseType(TweenEaseType_CubicIn)
                      ->SetRelative(false)
                      ->RunActions (enemyDrawable);

            if (AMath_Random() < 0.05f)
            {
                AComponent->SetState(enemy->component, EnemyState_Dizzy);
            }
            else if (AMath_Random() < 0.6f)
            {
                AComponent->SetState(enemy->component, EnemyState_Walk);

                if (AMath_Random() < 0.2f)
                {
                    float deltaX;

                    if (enemyDrawable->scaleX > 0.0f)
                    {
                        deltaX =  AMath_Random() * 0.1f;
                    }
                    else
                    {
                        deltaX = -AMath_Random() * 0.1f;
                    }

                    ATweenTool->AddMoveX      (deltaX, fabsf(deltaX) / enemy->speed)
                              ->SetEaseType   (TweenEaseType_Linear)
                              ->SetUserDataPtr(0, enemy)
                              ->SetOnComplete (WoodStopActionOnComplete)
                              ->SetQueue      (false)
                              ->RunActions    (enemyDrawable);

                    goto ScheduleOnce;
                }
            }
            else if (AMath_Random() < 0.9f)
            {
                AComponent->SetState(enemy->component, EnemyState_Attack);
            }
            else
            {
                AComponent->SetState(enemy->component, EnemyState_Stand);
            }

            ScheduleOnce:
            
            AUserData_SetSlotPtr
            (
                AScheduler->ScheduleOnce(WoodStopSchedulerUpdate, 0.5f)->userData,
                0,
                enemy
            );
        }

        return;
    }

//----------------------------------------------------------------------------------------------------------------------

    Arrow* arrow = AUserData_GetSlotPtrWithType(other->userData, 0, Arrow*);

    if (arrow->enemy != NULL && arrow->enemy != enemy)
    {
        return;
    }

//----------------------------------------------------------------------------------------------------------------------

    float hurtEffectPos;

    enemy->hp -= AMath_RandomInt(0, AHero->roundKillCount / Enemy_KillIncrease) + 1;

    if (enemy->hp > 0)
    {
        hurtEffectPos = 30;
        AComponent->SetState(enemy->component, EnemyState_Hurt);

        FontText* text = AFont->GetText(AGameActor->hpFont);
        ADrawable_SetParent(text->drawable, AGameMap->beforeDrawable);

        ADrawable_SetPosition2
        (
            text->drawable,
            ADrawable->ConvertBetweenLocalPositionX(enemyDrawable, 0.0f, AGameMap->beforeDrawable),
            other->positionY
        );

        AFont->SetInt(text, enemy->hp);

        ATweenTool->AddAction     ()

                  ->SetFadeTo     (0.0f)
                  ->SetRelative   (false)
                  ->SetEaseType   (TweenEaseType_ExponentialOut)

                  ->SetMoveY      (0.08f)
                  ->SetEaseType   (TweenEaseType_CubicIn)

                  ->SetMoveX      (0.1f * enemyDrawable->scaleX)
                  ->SetEaseType   (TweenEaseType_ExponentialOut)

                  ->SetScaleX     (0.5f)
                  ->SetRelative   (false)
                  ->SetEaseType   (TweenEaseType_CubicOut)

                  ->SetScaleY     (0.5f)
                  ->SetRelative   (false)
                  ->SetEaseType   (TweenEaseType_CubicOut)

                  ->SetDuration   (1.8f)
                  ->SetOnComplete (HurtTextTweenActionOnComplete)
                  ->SetUserDataPtr(0, text)

                  ->RunActions    (text->drawable);
    }
    else
    {
        hurtEffectPos = 40;
        ASkeleton ->SetSkin (enemy->hurtEffect->skeleton, "die");
        AComponent->SetState(enemy->component, EnemyState_Die);

        // if (AMath_Random() < 0.8f)
        {
            float random = AMath_Random();

            if (random < 0.20f)
            {
                AHUD->DropPickCoin(other, enemyDrawable->scaleX);
            }
            else if (random < 0.30f)
            {
                AHUD->DropPickHeart(other, enemyDrawable->scaleX);
            }
            else if (random < 0.65f)
            {
                AHUD->DropPickStone(other, enemyDrawable->scaleX);
            }
            else
            {
                AHUD->DropPickWood(other, enemyDrawable->scaleX);
            }

            AAudioTool->Play(AudioID_Drop);
        }
    }

//----------------------------------------------------------------------------------------------------------------------

    enemy->hurtEffect->loop      = 1;
    Drawable* hurtEffectDrawable = ASkeletonAnimationPlayer_GetDrawable(enemy->hurtEffect);

    ADrawable_SetPosition2
    (
        hurtEffectDrawable,
        other->positionX + AGLTool_ToGLWidth (hurtEffectPos) * enemyDrawable->scaleX,
        other->positionY + AGLTool_ToGLHeight(10.0f)
    );

    ADrawable_SetRotationZ
    (
        hurtEffectDrawable,
        ADrawable->GetFlipRotationZ(hurtEffectDrawable, other->rotationZ)
    );

//----------------------------------------------------------------------------------------------------------------------

    if (enemy->collisionBoxDrawable != NULL)
    {
        ATween->TryRemoveAllActions(enemyDrawable);

        float dir;
        if (AHero_GetDrawable()->scaleX > 0.0f)
        {
            dir =  1.0f;
        }
        else
        {
            dir = -1.0f;
        }

        if (enemy->component->curState->id == EnemyState_Die)
        {
            float sx = fabsf(other->velocityX) * enemy->dieMoveX;
            float sy = fabsf(other->velocityY) * enemy->dieMoveY;

            ATweenTool->AddMoveX   (dir * sx, enemy->dieXTime)
                      ->SetEaseType(enemy->dieMoveXEaseType)
                      ->SetQueue   (false)

                      ->AddMoveY   (sy, enemy->dieYUpTime)
                      ->SetEaseType(TweenEaseType_QuadraticIn)

                      ->AddMoveY   (AGameMap->groundY, enemy->dieYDownTime)
                      ->SetEaseType(enemy->dieMoveYEaseType)
                      ->SetRelative(false)

                      ->RunActions (enemyDrawable);
        }
        else
        {
            float sx = fabsf(other->velocityX) * enemy->hurtMoveX;
            float sy = fabsf(other->velocityY) * enemy->hurtMoveY;

            ATweenTool->AddMoveX   (dir * sx, enemy->hurtXTime)
                      ->SetEaseType(TweenEaseType_QuadraticOut)
                      ->SetQueue   (false)

                      ->AddMoveY   (sy, enemy->hurtYUpTime)
                      ->SetEaseType(TweenEaseType_QuadraticIn);

            if (enemy->hurtYDownTime != 0)
            {
                ATweenTool ->AddMoveY   (AGameMap->groundY, enemy->hurtYDownTime)
                           ->SetEaseType(TweenEaseType_QuadraticOut)
                           ->SetRelative(false);
            }

            ATweenTool->RunActions(enemyDrawable);
        }

        other->velocityX *= 0.5f;
        other->velocityY *= 0.5f;
    }
}


static void Destroy(Enemy* enemy)
{
    for (int i = 0; i < enemy->arrowSet->elementList->size; ++i)
    {
        Arrow* arrow = AArrayList_Get(enemy->arrowSet->elementList, i, Arrow*);
        ATween->TryCompleteAllActions(arrow->sprite->drawable, false);
        AHero->ResetArrow(arrow);
    }

    AArrayList->Clear(enemy->arrowSet->elementList);

    AArrayIntSet->TryRemove    (enemy->belongAI, (intptr_t) enemy);
    ATween->TryRemoveAllActions(AEnemy_GetDrawable(enemy));
    AComponent->RemoveObserver (AHero->component, enemy->component);

    if (enemy->collisionBoxBody != NULL)
    {
        enemy->collisionBoxBody->state = PhysicsBodyState_Freeze;
        ATool->InitBox(enemy->collisionBoxBody, 2.0f, 2.0f);
    }

    if (enemy->attackBoxBody != NULL)
    {
        enemy->attackBoxBody->state = PhysicsBodyState_Freeze;
        ATool->InitBox(enemy->attackBoxBody, 2.0f, 2.0f);
    }

    if (enemy->isBoss)
    {
        enemy->isBoss       = false;
        AEnemyAI->isHasBoss = false;
    }

    ADrawable_SetScaleSame2(AEnemy_GetDrawable(enemy), 1.0f);

    AArrayList_Add(AEnemyAI->enemyDeadList, enemy);

    --AEnemyAI->currentEnemyNum;
    
    AComponent->SetActive(enemy->component, false);
}


static void Reset(Enemy* enemy, float bornX, float bornY)
{
    AComponent->SetActive(enemy->component, true);

    ADrawable_SetParent    (AEnemy_GetDrawable(enemy), AGameMap->beforeDrawable);
    ADrawable_SetPosition2 (AEnemy_GetDrawable(enemy), bornX, bornY);
    AComponent->AddObserver(AHero->component, enemy->component);

    if (enemy->collisionBoxBody != NULL)
    {
        enemy->collisionBoxBody->state = PhysicsBodyState_Fixed;
        ATool->InitBox(enemy->collisionBoxBody, 2.0f, 2.0f);
    }

    if (enemy->attackBoxBody != NULL)
    {
        enemy->attackBoxBody->state = PhysicsBodyState_Fixed;
        ATool->InitBox(enemy->attackBoxBody, 2.0f, 2.0f);
    }

    AComponent->SetState(enemy->component, EnemyState_Stand);
    enemy->player->loop = -1;

    ADrawable_SetParent(ASkeletonAnimationPlayer_GetDrawable(enemy->hurtEffect), AGameMap->beforeDrawable);
}


static void ScheduleDestroy(Scheduler* scheduler, float deltaSeconds)
{
    Destroy(AUserData_GetSlotPtrWithType(scheduler->userData, 0, Enemy*));
}


static void OnActionOver(SkeletonAnimationPlayer* player)
{
    Enemy* enemy = AStruct_GetParent(player, Enemy);

    switch (enemy->component->curState->id)
    {
        case EnemyState_Dizzy:
            if (enemy->dizzyTime > 0)
            {
                --enemy->dizzyTime;
            }
            else
            {
                enemy->dizzyEffect->loop = 0;
                AComponent->SetState(enemy->component, EnemyState_Walk);
            }
            break;

        case EnemyState_Hurt:
            if (enemy->dizzyTime == 0 || enemy->component->curState->id != EnemyState_Dizzy)
            {
                AComponent->SetState(enemy->component, EnemyState_Walk);
            }
            else
            {
                AComponent->SetState(enemy->component, EnemyState_Dizzy);
            }
            break;

        case EnemyState_Attack:
            AComponent->SetState(enemy->component, EnemyState_Stand);
            break;

        case EnemyState_Die:
            AComponent->SetState(enemy->component, EnemyState_DieOver);
            break;

        case EnemyState_DieOver:
            AUserData_SetSlotPtr(AScheduler->ScheduleOnce(ScheduleDestroy, 0.0f)->userData, 0, enemy);
            enemy->player->loop = 0;
            break;

        default:
            break;
    }
}


static void Dizzy(Scheduler* scheduler, float deltaSeconds)
{
    Enemy* enemy = AUserData_GetSlotPtrWithType(scheduler->userData, 0, Enemy*);
    
    AComponent->SetState(enemy->component, EnemyState_Dizzy);

    ATween->TryRemoveAllActions(AEnemy_GetDrawable(enemy));

    if (enemy->type != EnemyType_Fly)
    {
        ATweenTool->AddMoveY   (0.05f, 0.2f)
                  ->SetEaseType(TweenEaseType_SineIn)
                  ->AddMoveY   (AGameMap->groundY, 0.3f)
                  ->SetRelative(false)
                  ->SetEaseType(TweenEaseType_BounceOut)
                  ->RunActions (AEnemy_GetDrawable(enemy));
    }
    else
    {
        ATweenTool->AddMoveY   (0.02f,  0.2f)
                  ->SetEaseType(TweenEaseType_SineIn)

                  ->AddMoveY   (-0.02f, 0.3f)
                  ->SetEaseType(TweenEaseType_BounceOut)
                  ->RunActions (AEnemy_GetDrawable(enemy));
    }

}



static bool OnMessage(Component* component, void* sender, int subject, void* extraData)
{
    if (sender == AHero->component)
    {
        Enemy*    enemy         = AUserData_GetSlotPtrWithType(component->userData, 0, Enemy*);
        Drawable* enemyDrawable = AEnemy_GetDrawable(enemy);

        if (enemy->component->curState->id >= EnemyState_Die)
        {
            return false;
        }

        switch (subject)
        {
            case HeroNotify_Die:
                break;

            case HeroNotify_Dizzy:
            {
                Drawable* heroDrawable = AHero_GetDrawable();
                float     posX         = ADrawable->ConvertBetweenLocalPositionX
                                         (
                                             heroDrawable->parent,
                                             heroDrawable->positionX,
                                             enemyDrawable->parent
                                         );

                if (fabsf(enemyDrawable->positionX - posX) < AGameData->dizzyDistance)
                {
                    AUserData_SetSlotPtr
                    (
                        AScheduler->ScheduleOnce
                        (
                            Dizzy,
                            fabsf(enemyDrawable->positionX - posX) / 3
                        )
                        ->userData,
                        0,
                        enemy
                    );
                }
                else
                {
                    ATween->TryRemoveAction(enemyDrawable, enemy->belongAIAction);
                    AComponent->SetState(enemy->component, EnemyState_Stand);
                }
                break;
            }

            default:
                break;
        }
    }
    else if(sender == AComponent)
    {
        Enemy* enemy = AUserData_GetSlotPtrWithType(component->userData, 0, Enemy*);

        switch (subject)
        {
            case ComponentMsg_OnEnter:
            {
                switch (component->curState->id)
                {
                    case EnemyState_Stand:
                        if (component->preState->id != EnemyState_DieOver)
                        {
                            ASkeletonAnimationPlayer->SetAnimationMix(enemy->player, "stand", 0.2f);
                        }
                        else
                        {
                            ASkeletonAnimationPlayer->SetAnimation(enemy->player, "stand");
                        }

                        enemy->dizzyEffect->loop = 0;
                        break;

                    case EnemyState_Walk:
                        ASkeletonAnimationPlayer->SetAnimationMix(enemy->player, "walk", 0.2f);
                        enemy->dizzyEffect->loop = 0;
                        break;

                    case EnemyState_Hurt:
                        ASkeletonAnimationPlayer->SetAnimation(enemy->player, "hurt");
                        AAudioTool->Play(AudioID_HurtEnemy);
                        break;

                    case EnemyState_Attack:
                        ASkeletonAnimationPlayer->SetAnimationMix(enemy->player, "attack", 0.1f);
                        if (enemy->attackBoxBody != NULL)
                        {
                            enemy->attackBoxBody->state = PhysicsBodyState_Fixed;
                        }
                        break;

                    case EnemyState_Die:
                        ASkeletonAnimationPlayer->SetAnimationMix(enemy->player, "die", 0.2f);
                        AAudioTool->Play(AudioID_HurtEnemy);
                        AHero->RoundScore();
                        break;

                    case EnemyState_DieOver:
                    {
                        ASkeletonAnimationPlayer->SetAnimation(enemy->player, "die_over");
                        enemy->dizzyEffect->loop = 0;

                        FontText* text         = AFont->GetText(AGameActor->hpFont);
                        Drawable* heroDrawable = AEnemy_GetDrawable(enemy);

                        AFont->SetString   (text, "_");
                        ADrawable_SetScale2(text->drawable, 0.0f, 0.0f);
                        ADrawable_SetParent(text->drawable, AGameMap->beforeDrawable);

                        float    offsetX   = AGLTool_ToGLWidth(20.0f);
                        Vector2 localA[1] = {{heroDrawable->scaleX > 0 ? -offsetX : offsetX, 0.0f}};
                        Vector2 localB[1];

                        ADrawable->ConvertBetweenLocalPositionV2
                        (
                           heroDrawable,
                           localA,
                           AGameMap->beforeDrawable,
                           localB
                        );

                        ADrawable_SetPosition2(text->drawable, localB->x, localB->y);

                        ATweenTool->AddAction     ()

                                  ->SetFadeTo     (0.0f)
                                  ->SetRelative   (false)
                                  ->SetEaseType   (TweenEaseType_Linear)

                                  ->SetMoveY      (0.1f)
                                  ->SetEaseType   (TweenEaseType_SineOut)

                                  ->SetScaleX     (1.0f)
                                  ->SetRelative   (false)
                                  ->SetEaseType   (TweenEaseType_QuinticOut)

                                  ->SetScaleY     (1.0f)
                                  ->SetRelative   (false)
                                  ->SetEaseType   (TweenEaseType_ExponentialOut)

                                  ->SetDuration   (1.4f)
                                  ->SetOnComplete (HurtTextTweenActionOnComplete)
                                  ->SetUserDataPtr(0, text)

                                  ->RunActions    (text->drawable);

                        break;
                    }

                    case EnemyState_Dizzy:
                    {
                        ADrawable_SetVisible(enemy->dizzyEffect->skeleton->drawable);
                        enemy->dizzyEffect->loop = -1;
                        enemy->dizzyTime         = AGameData->dizzyTime;

                        if (AMath_Random() > 0.5f)
                        {
                            ASkeleton->SetSkin(enemy->dizzyEffect->skeleton, "star");
                        }
                        else
                        {
                            ASkeleton->SetSkin(enemy->dizzyEffect->skeleton, "duck");
                        }

                        ADrawable_SetPosition2
                        (
                            enemy->dizzyEffect->skeleton->drawable,
                            AGLTool_ToGLWidth(enemy->dizzyX),
                            AGLTool_ToGLHeight(enemy->dizzyY)
                        );

                        ASkeletonAnimationPlayer->SetAnimation(enemy->player, "dizzy");

                        if (enemy->attackBoxBody != NULL)
                        {
                            enemy->attackBoxBody->state = PhysicsBodyState_Freeze;
                        }
                        break;
                    }

                    default:
                        break;
                }

                break;
            }

            case ComponentMsg_OnExit:
            {
                switch (component->curState->id)
                {
                    case EnemyState_Attack:
                        if (enemy->attackBoxBody != NULL)
                        {
                            enemy->attackBoxBody->state = PhysicsBodyState_Freeze;
                        }
                        break;

                    default:
                        break;
                }

                break;
            }

            default:
                break;
        }
    }

    return false;
}


static Enemy* Create(const char* filePath, float bornX, float bornY)
{
    Enemy* enemy = malloc(sizeof(Enemy));
    AComponent->Init(enemy->component);

    ASkeletonAnimationPlayer->Init(filePath,         "walk",      enemy->player);
    ASkeletonAnimationPlayer->Init("Animation/hit", "animation", enemy->hurtEffect);
    enemy->hurtEffect->loop = 0;
    ASkeleton->SetSkin(enemy->hurtEffect->skeleton, "normal");
    ADrawable_SetParent(ASkeletonAnimationPlayer_GetDrawable(enemy->hurtEffect), AGameMap->beforeDrawable);

    ASkeletonAnimationPlayer->Init("Animation/dizzy-star", "animation", enemy->dizzyEffect);
    enemy->dizzyEffect->loop = 0;
    Drawable* dizzyEffectDrawable  = ASkeletonAnimationPlayer_GetDrawable(enemy->dizzyEffect);
    ADrawable_SetParent   (dizzyEffectDrawable, AEnemy_GetDrawable(enemy));
    ADrawable_SetInvisible(dizzyEffectDrawable);

    AArrayIntSet->Init(enemy->arrowSet);

    enemy->belongAI             = NULL;
    enemy->belongAIAction       = NULL;
    enemy->attackBoxBody        = NULL;
    enemy->attackBoxDrawable    = NULL;
    enemy->collisionBoxBody     = NULL;
    enemy->collisionBoxDrawable = NULL;

    AUserData_SetSlotPtr(enemy->component->userData, 0, enemy);

    enemy->hp                   = 0;
    enemy->speed                = 0.0f;
    enemy->dizzyTime            = 0;
    enemy->dizzyY               = 0.0f;
    enemy->dizzyX               = 0.0f;
    enemy->hitDis               = 0;

    enemy->dieXTime             = 0.0f;
    enemy->dieYUpTime           = 0.0f;
    enemy->dieYDownTime         = 0.0f;
    enemy->dieMoveYEaseType     = TweenEaseType_CubicOut;
    enemy->dieMoveXEaseType     = TweenEaseType_CubicOut;

    enemy->hurtXTime            = 0.0f;
    enemy->hurtYUpTime          = 0.0f;
    enemy->hurtYDownTime        = 0.0f;

    enemy->hurtMoveX            = 0.01f;
    enemy->hurtMoveY            = 0.01f;

    enemy->dieMoveX             = 0.01f;
    enemy->dieMoveY             = 0.01f;

    enemy->isWoodStop           = false;
    enemy->type                 = EnemyType_NULL;
    enemy->isBoss               = false;

    Drawable* drawable          = AEnemy_GetDrawable(enemy);
    ADrawable_SetParent   (drawable, AGameMap->beforeDrawable);
    ADrawable_SetPosition2(drawable, bornX, bornY);


    SkeletonSlot* collisionSlot = ASkeletonAnimationPlayer_GetSlot(enemy->player, "CollisionBox");
    if (collisionSlot != NULL)
    {
        enemy->collisionBoxDrawable          = collisionSlot->bone->drawable;
        enemy->collisionBoxBody              = APhysicsWorld->AddBody
                                               (
                                                   PhysicsShape_Polygon,
                                                   ASkeletonSlot_GetBoundingBox(collisionSlot)->vertexArr
                                               );
        enemy->collisionBoxBody->OnCollision = OnHurt;
        enemy->collisionBoxBody->state       = PhysicsBodyState_Fixed;

        AUserData_SetSlotPtr(enemy->collisionBoxBody->userData, 0, enemy);
        APhysicsBody_SetCollisionGroup
        (
            enemy->collisionBoxBody,
            CollisionGroup_EnemyBody | CollisionGroup_EnemyAttack
        );
        ATool->InitBox(enemy->collisionBoxBody, 2.0f, 2.0f);

        #ifdef APP_DEBUG
        ASkeletonAnimationPlayer->InitSlotBoundingBoxDrawable
        (
            enemy->player,
            "CollisionBox",
            enemy->debugCollisionBoundingBox
        );
        #endif
    }

    SkeletonSlot* attackSlot = ASkeletonAnimationPlayer_GetSlot(enemy->player, "AttackBox");
    if (attackSlot != NULL)
    {
        enemy->attackBoxDrawable    = attackSlot->bone->drawable;
        enemy->attackBoxBody        = APhysicsWorld->AddBody
                                      (
                                          PhysicsShape_Polygon,
                                          ASkeletonSlot_GetBoundingBox(attackSlot)->vertexArr
                                      );
        enemy->attackBoxBody->state = PhysicsBodyState_Fixed;

        AUserData_SetSlotPtr(enemy->attackBoxBody->userData, 0, enemy);
        APhysicsBody_SetCollisionGroup
        (
            enemy->attackBoxBody,
            CollisionGroup_EnemyAttack | CollisionGroup_ArrowAttack
        );
        ATool->InitBox(enemy->attackBoxBody, 2.0f, 2.0f);

        #ifdef APP_DEBUG
        ASkeletonAnimationPlayer->InitSlotBoundingBoxDrawable
        (
             enemy->player,
             "AttackBox",
             enemy->debugAttackBoundingBox
        );
        #endif
    }

    if (AEnemyAI->isInit == false)
    {
        AComponent->AddObserver(AHero->component, enemy->component);
    }

    enemy->component->stateMap->elementList->increase = 10;
    enemy->player->OnActionOver                       = OnActionOver;

    AComponent->AddState(enemy->component, EnemyState_Stand,   OnMessage, Update);
    AComponent->AddState(enemy->component, EnemyState_Walk,    OnMessage, Update);
    AComponent->AddState(enemy->component, EnemyState_Hurt,    OnMessage, Update);
    AComponent->AddState(enemy->component, EnemyState_Attack,  OnMessage, Update);
    AComponent->AddState(enemy->component, EnemyState_Die,     OnMessage, Update);
    AComponent->AddState(enemy->component, EnemyState_DieOver, OnMessage, Update);
    AComponent->AddState(enemy->component, EnemyState_Dizzy,   OnMessage, Update);

    AComponent->SetState   (enemy->component,      EnemyState_Stand);
    AComponent->AppendChild(AGameActor->component, enemy->component);

    return enemy;
}


struct AEnemy AEnemy[1] =
{{
    Create,
    Reset,
    Destroy,
}};

```

`Samples/SuperLittleRed/Code/Enemy.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-9-29
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#ifndef ENEMY_H
#define ENEMY_H


#include "Engine/Extension/Spine/SkeletonAnimationPlayer.h"
#include "Engine/Physics/PhysicsBody.h"
#include "Engine/Application/Component.h"
#include "Engine/Toolkit/Utils/Tween.h"
#include "Engine/Toolkit/Utils/ArrayIntSet.h"
#include "Config.h"


enum
{
    EnemyState_Null,
    EnemyState_Stand,
    EnemyState_Walk,
    EnemyState_Hurt,
    EnemyState_Attack,
    EnemyState_Dizzy,
    EnemyState_Die,
    EnemyState_DieOver,
    EnemyState_Length,
};


typedef enum
{
    EnemyType_Wood,
    EnemyType_Pig,
    EnemyType_Stone,
    EnemyType_Wolf,
    EnemyType_Bear,
    EnemyType_Snake,
    EnemyType_Grass,
    EnemyType_Penguin,
    EnemyType_SnowBall,
    EnemyType_BigSnowMan,
    EnemyType_Fly,
    EnemyType_NULL,
}
EnemyType;


typedef struct
{
    EnemyType               type;

    Component               component  [1];
    SkeletonAnimationPlayer player     [1];
    SkeletonAnimationPlayer hurtEffect [1];
    SkeletonAnimationPlayer dizzyEffect[1];

    ArrayIntSet(Arrow*)     arrowSet   [1];
    ArrayIntSet(Enemy*)*    belongAI;
    TweenAction*            belongAIAction;

    int                     hp;
    float                   speed;
    int                     dizzyTime;

    float                   dieXTime;
    float                   dieYUpTime;
    float                   dieYDownTime;

    float                   hurtXTime;
    float                   hurtYUpTime;
    float                   hurtYDownTime;

    float                   hurtMoveX;
    float                   hurtMoveY;

    float                   dieMoveX;
    float                   dieMoveY;
    TweenEaseType           dieMoveYEaseType;
    TweenEaseType           dieMoveXEaseType;

    float                   dizzyY;
    float                   dizzyX;

    float                   hitDis;
    bool                    isWoodStop;
    bool                    isBoss;

    PhysicsBody*            attackBoxBody;
    Drawable*               attackBoxDrawable;
    PhysicsBody*            collisionBoxBody;
    Drawable*               collisionBoxDrawable;

    #ifdef APP_DEBUG
    Drawable                debugAttackBoundingBox   [1];
    Drawable                debugCollisionBoundingBox[1];
    #endif
}
Enemy;



struct AEnemy
{
    /**
     * filePath:
     *     Android: assets
     *     IOS    : NSBundle
     */
    Enemy* (*Create) (const char* filePath, float bornX, float bornY);
    void   (*Reset)  (Enemy*      enemy,    float bornX, float bornY);
    void   (*Destroy)(Enemy*      enemy);
};


extern struct AEnemy AEnemy[1];


static inline Drawable* AEnemy_GetDrawable(Enemy* enemy)
{
    return ASkeletonAnimationPlayer_GetDrawable(enemy->player);
}


static inline const char* AEnemy_GetPath(Enemy* enemy)
{
    return ASkeletonAnimationPlayer_GetPath(enemy->player);
}


#endif

```

`Samples/SuperLittleRed/Code/EnemyAI.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-4-29
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#include <stddef.h>
#include <string.h>

#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Toolkit/Utils/ArrayList.h"
#include "Engine/Toolkit/Utils/TweenTool.h"
#include "Engine/Application/Scheduler.h"
#include "Engine/Toolkit/Utils/ArrayIntSet.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Toolkit/Platform/Log.h"

#include "EnemyAI.h"
#include "Hero.h"
#include "GameMap.h"
#include "Enemy.h"
#include "GameData.h"


#define AskGod() \
    (AMath_Random() > AMath_Random())


static ArrayIntSet woodSet       [1];


static ArrayIntSet* enemySets[Enemy_KindsNum] =
{
    woodSet,
};


typedef enum
{
    AIResult_Skip,
    AIResult_Move,
}
AIResult;


typedef AIResult (*EnemyAI)(Enemy* enemy, Drawable* enemyDrawable, Drawable* heroDrawable, float deltaX);


static void DoEnemySetAI(ArrayIntSet* enemySet, EnemyAI enemyAI)
{
    for (int i = 0; i < enemySet->elementList->size; ++i)
    {
        Enemy*    enemy         = AArrayList_Get(enemySet->elementList, i, Enemy*);
        Drawable* enemyDrawable = AEnemy_GetDrawable(enemy);
        Drawable* heroDrawable  = AHero_GetDrawable();
        float     deltaX        = enemyDrawable->positionX - ADrawable->ConvertBetweenLocalPositionX
                                                             (
                                                                 heroDrawable->parent,
                                                                 heroDrawable->positionX,
                                                                 enemyDrawable->parent
                                                             );

        if (enemy->component->curState->id >= EnemyState_Dizzy)
        {
            continue;
        }
        else if (AHero->component->curState->id >= HeroState_Die)
        {
            continue;
        }


        if (deltaX * enemyDrawable->scaleX < 0)
        {
            ADrawable_SetScaleX(enemyDrawable, -enemyDrawable->scaleX);
        }

        deltaX          = -deltaX;
        AIResult result = AIResult_Skip;

        if (enemy->isWoodStop == false)
        {
            result = enemyAI(enemy, enemyDrawable, heroDrawable, deltaX);
        }

        if (deltaX > -enemy->hitDis && deltaX < enemy->hitDis)
        {
            ATween->TryRemoveAction(enemyDrawable, enemy->belongAIAction);
            AComponent->SetState(enemy->component, EnemyState_Attack);
            return;
        }

        if (result == AIResult_Move)
        {
            return;
        }

        if (enemy->component->curState->id != EnemyState_Walk)
        {
            AComponent->SetState(enemy->component, EnemyState_Walk);

            if (AskGod())
            {
                return;
            }
        }

        if (enemy->isWoodStop)
        {
            return;
        }

        ATween->TryRemoveAction(enemyDrawable, enemy->belongAIAction);

        ATweenTool->AddMoveX   (deltaX, fabsf(deltaX) / enemy->speed)
                  ->GetAction  (&enemy->belongAIAction)
                  ->SetEaseType(TweenEaseType_Linear)
                  ->RunActions (enemyDrawable);
    }
}


static void AttackOnComplete(TweenAction* action)
{
    Enemy* enemy = AUserData_GetSlotPtrWithType(action->userData, 0, Enemy*);

    if (enemy != NULL)
    {
        AComponent->SetState(enemy->component, EnemyState_Attack);
    }
}


static AIResult WoodAI(Enemy* enemy, Drawable* enemyDrawable, Drawable* heroDrawable, float deltaX)
{
    if (deltaX > -0.35f && deltaX < 0.35f && AskGod())
    {
        ATween->TryRemoveAllActions(enemyDrawable);

        if (AskGod())
        {
            ATweenTool->AddMoveX      (deltaX * 0.98f, 0.35f)
                      ->SetEaseType   (AskGod() ? TweenEaseType_QuadraticIn : TweenEaseType_CubicIn)
                      ->SetQueue      (false)
                      ->SetOnComplete (AttackOnComplete)
                      ->SetUserDataPtr(0, enemy)

                      ->AddMoveY      (0.04f, 0.25f)
                      ->SetEaseType   (AskGod() ? TweenEaseType_QuadraticIn : TweenEaseType_CubicIn)

                      ->AddMoveY      (AGameMap->groundY, 0.15f)
                      ->SetEaseType   (TweenEaseType_QuadraticOut)
                      ->SetRelative   (false)

                      ->RunActions    (enemyDrawable);
        }
        else
        {
            ATweenTool->AddMoveX      (deltaX * 0.98f, 0.35f)
                      ->SetEaseType   (AskGod() ? TweenEaseType_QuadraticOut : TweenEaseType_CubicOut)
                      ->SetQueue      (false)
                      ->SetOnComplete (AttackOnComplete)
                      ->SetUserDataPtr(0, enemy)

                      ->AddMoveY      (AGameMap->groundY, 0.15f)
                      ->SetEaseType   (AskGod() ? TweenEaseType_QuadraticOut : TweenEaseType_CubicOut)
                      ->SetRelative   (false)
                      ->RunActions    (enemyDrawable);
        }

        return AIResult_Move;
    }

    return AIResult_Skip;
}


//----------------------------------------------------------------------------------------------------------------------


static EnemyAI enemyAIs[Enemy_KindsNum] =
{
    WoodAI,
};


static void DoEnemyAI(Scheduler* scheduler, float deltaSeconds)
{
    if (AHero->component->curState->id >= HeroState_Die)
    {
        scheduler->isCancel = true;
    }
    else
    {
        for (int i = 0; i < Enemy_KindsNum; ++i)
        {
            DoEnemySetAI(enemySets[i], enemyAIs[i]);
        }
    }
}


//----------------------------------------------------------------------------------------------------------------------


static inline void RandomSmallEnemy(Enemy* enemy)
{
    if (AMath_Random() < 0.2f)
    {
        Drawable* drawable = AEnemy_GetDrawable(enemy);
        ADrawable_SetScaleSame2(drawable, 0.7f);
    }
}



static inline Enemy* CreateAndCache(const char* filePath, float bornX, float bornY)
{
    Enemy* enemy = NULL;

    if (AEnemyAI->isInit == false)
    {
        for (int i = 0; i < AEnemyAI->enemyDeadList->size; ++i)
        {
            Enemy* e = AArrayList_Get(AEnemyAI->enemyDeadList, i, Enemy*);

            if (strcmp(filePath, AEnemy_GetPath(e)) == 0)
            {
                enemy = e;
                AArrayList->Remove(AEnemyAI->enemyDeadList, i);
                break;
            }
        }
    }

    if (enemy == NULL)
    {
        enemy = AEnemy->Create(filePath, bornX, bornY);
    }
    else
    {
        AEnemy->Reset(enemy, bornX, bornY);
    }

    return enemy;
}


static Enemy* CreateWood(float x)
{
    Enemy* enemy         = CreateAndCache("Animation/wood", x, AGameMap->groundY);
    int    increase      = AHero->roundKillCount / Enemy_KillIncrease + 1;

    enemy->hp            = increase;
    enemy->speed         = AGLTool_ToGLWidth(35 + AMath_RandomInt(increase, increase * 3));
    enemy->dizzyY        = 50.0f;

    enemy->hitDis        = AGLTool_ToGLWidth(30);

    enemy->dieXTime      = 1.25f;
    enemy->dieYUpTime    = 0.35f;
    enemy->dieYDownTime  = 0.25f;

    enemy->hurtXTime     = 0.35f;
    enemy->hurtYUpTime   = 0.25f;
    enemy->hurtYDownTime = 0.15f;

    enemy->hurtMoveX     = 0.05f * AGameData->arrowPower;
    enemy->hurtMoveY     = 0.04f;

    enemy->dieMoveX      = 0.15f;
    enemy->dieMoveY      = 0.05f;

    enemy->type          = EnemyType_Wood;

    RandomSmallEnemy(enemy);

    return enemy;
}


//----------------------------------------------------------------------------------------------------------------------


typedef Enemy* (*Create)(float x);


static Create Creates[Enemy_KindsNum] =
{
    CreateWood,
};


//----------------------------------------------------------------------------------------------------------------------


static ArrayList(int) kinds[1]   = AArayList_InitFixed(int, Enemy_KindsNum, 0);
static int            eachKindNum;
static int            kindIndex;
static int            createNum;


static void CreateEnemy(Scheduler* scheduler, float deltaSeconds)
{
    if (AHero->component->curState->id >= HeroState_Die)
    {
        scheduler->isCancel = true;
    }
    else
    {
        int num1 =       AHero->roundKillCount /  Enemy_KillIncrease;
        int num2 = (int) AHero->roundTime      / (Enemy_TimeIncrease + num1 * 3) + 2;
        int num3 = AEnemyAI->isHasBoss ? num2  / 2 : num2;

        if (AEnemyAI->currentEnemyNum < num3)
        {
            float pos = AMath_RandomFloat(0.2f, 0.3f);

            if (AMath_Random() > 0.5f)
            {
                pos =  AGLTool->screenRatio + pos;
            }
            else
            {
                pos = -AGLTool->screenRatio - pos;
            }

            if (kinds->size > 0)
            {
                if (eachKindNum == Enemy_EachKindInitNum)
                {
                    // random one kind of enemy
                    int index = AMath_RandomInt(0, kinds->size - 1);

                    kindIndex = AArrayList_Get(kinds, index, int);

                    AArrayList->Remove(kinds, index);
                }

                --eachKindNum;

                if (eachKindNum == 0)
                {
                    // one kind of enemy show over
                    eachKindNum = Enemy_EachKindInitNum;
                }
            }
            else
            {
                // random enemy after all kinds of enemy showed
                kindIndex = AMath_RandomInt(0, Enemy_KindsNum - 1);
            }

            float  x        = ADrawable->ConvertToLocalPositionX(AGameMap->beforeDrawable, pos);
            Enemy* enemy    = Creates  [kindIndex](x);
            enemy->belongAI = enemySets[kindIndex];

            AArrayIntSet->TryAdd(enemySets[kindIndex], (intptr_t) enemy);
            ++AEnemyAI->currentEnemyNum;
            ++createNum;

            if (createNum % Enemy_BossInterval == 0)
            {
                enemy->isBoss       = true;
                enemy->hp          *= Enemy_BossHPX;
                enemy->speed       *= Enemy_BossSpeedX;
                AEnemyAI->isHasBoss = true;
                ADrawable_SetScaleSame2(AEnemy_GetDrawable(enemy), 1.3f);
            }
        }
    }
}


static void CreateCache(int kind)
{
    Enemy* enemy = Creates[kind](-2.0f);

    AArrayList_Add(AEnemyAI->enemyDeadList, enemy);
    AComponent->SetActive(enemy->component, false);
}


static void Init()
{
    AEnemyAI->currentEnemyNum = 0;
    AEnemyAI->isInit          = true;
    createNum                 = 0;

    AArrayList->Init(sizeof(Enemy*), AEnemyAI->enemyDeadList);

    for (int i = 0; i < Enemy_KindsNum; ++i)
    {
        AArrayIntSet->Init(enemySets[i]);
    }
}


static void Run()
{
    AEnemyAI->isInit    = false;
    AEnemyAI->isHasBoss = false;
    eachKindNum         = Enemy_EachKindInitNum;
    createNum           = 0;

    AArrayList->Clear(kinds);
    for (int i = 0; i < Enemy_KindsNum; ++i)
    {
        AArrayList_Add(kinds, i);
    }

    #ifndef APP_NO_ENEMY
    AScheduler->Schedule(DoEnemyAI,   enemyDoAITime);
    AScheduler->Schedule(CreateEnemy, enemyCreateTime);
    #endif
}


static void SetAllEnemy(int enemyStateID, float enemyMoveDis)
{
    float moveDis = enemyMoveDis;

    for (int i = 0; i < Enemy_KindsNum; ++i)
    {
        ArrayIntSet* enemySet = enemySets[i];

        for (int j = 0; j < enemySet->elementList->size; ++j)
        {
            Enemy* enemy = AArrayList_Get(enemySet->elementList, j, Enemy*);

            if (enemy->component->curState->id >= EnemyState_Die)
            {
                continue;
            }

            Drawable* enemyDrawable = AEnemy_GetDrawable(enemy);
            Drawable* heroDrawable  = AHero_GetDrawable();
            float     deltaX        = enemyDrawable->positionX - ADrawable->ConvertBetweenLocalPositionX
                                                                 (
                                                                    heroDrawable->parent,
                                                                    heroDrawable->positionX,
                                                                    enemyDrawable->parent
                                                                 );
            moveDis += enemyMoveDis;

            float dis;

            if (deltaX > 0.0f)
            {
                dis = moveDis;
            }
            else
            {
                dis = -moveDis;
            }

            if (deltaX * enemyDrawable->scaleX < 0)
            {
                ADrawable_SetScaleX(enemyDrawable, -enemyDrawable->scaleX);
            }

            ATween->TryRemoveAllActions(enemyDrawable);

            if (enemyStateID != EnemyState_Null)
            {
                AComponent->SetState(enemy->component, enemyStateID);
            }

            ATweenTool->AddMoveX   (dis, moveDis / enemy->speed)
                      ->SetQueue   (false)
                      ->SetEaseType(TweenEaseType_ExponentialOut)
                      ->RunActions (enemyDrawable);
        }
    }
}


static void Restart()
{
    for (int i = 0; i < Enemy_KindsNum; ++i)
    {
        ArrayIntSet* enemySet = enemySets[i];

        while (enemySet->elementList->size > 0)
        {
            AEnemy->Destroy(AArrayList_Get(enemySet->elementList, 0, Enemy*));
        }
    }

    Run();
}


struct AEnemyAI AEnemyAI[1] =
{{
    .Init        = Init,
    .Run         = Run,
    .CreateCache = CreateCache,
    .SetAllEnemy = SetAllEnemy,
    .Restart     = Restart,
}};


#undef AskGod
```

`Samples/SuperLittleRed/Code/EnemyAI.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-4-27
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#ifndef ENEMY_AI_H
#define ENEMY_AI_H


#include "Enemy.h"


struct AEnemyAI
{
    int               currentEnemyNum;
    ArrayList(Enemy*) enemyDeadList[1];
    bool              isInit;
    bool              isHasBoss;

    void (*Init)       (void);
    void (*Run)        (void);
    void (*CreateCache)(int kind);
    void (*SetAllEnemy)(int enemyStateID, float enemyMoveDis);
    void (*Restart)    (void);
};


extern struct AEnemyAI AEnemyAI[1];


#endif

```

`Samples/SuperLittleRed/Code/GameActor.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-6-23
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#include "Engine/Application/Application.h"
#include "Engine/Application/Scheduler.h"

#include "GameActor.h"
#include "Hero.h"
#include "GameMap.h"


static FontText* fpsText;
static FontText* drawCallsText;


static void UpdateAfter(Component* component, float deltaSeconds)
{
    AFont->Draw(AGameActor->hpFont);
    AFont->Draw(AGameActor->talkFont);
}


static void UpdateFPS(Scheduler* scheduler, float deltaSeconds)
{
    AFont->SetInt(fpsText, (int) (1.0f / deltaSeconds));
    AFont->SetInt(drawCallsText, ADrawable->GetDrawCalls());
}


static void Init()
{
    AComponent->Init(AGameActor->component);
    AGameActor->component->curState->UpdateAfter = UpdateAfter;

    AGameActor->talkFont = AFont->Get("Font/TalkChar.atlas");
    AGameActor->hpFont   = AFont->Get("Font/hp.atlas");

    #ifdef APP_SHOW_FPS_AND_DRAW_CALL
    fpsText = AFont->GetText(AGameActor->hpFont);
    ADrawable_SetPosition2(fpsText->drawable,  -0.05f, 0.9f);
    AFont->SetInt(fpsText, 1000000);

    drawCallsText = AFont->GetText(AGameActor->hpFont);
    ADrawable_SetPosition2(drawCallsText->drawable, 0.05f, 0.9f);
    AFont->SetInt(drawCallsText, 1000000);

    AScheduler->Schedule(UpdateFPS, 0.5f);
    #endif

}


static void Run()
{
    AApplication_AddChild(AGameActor->component, 40);
}


struct AGameActor AGameActor[1] =
{{
    .Init = Init,
    .Run  = Run,
}};

```

`Samples/SuperLittleRed/Code/GameActor.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2014-6-23
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#ifndef GAME_ACTOR_H
#define GAME_ACTOR_H


#include "Engine/Extension/Font.h"
#include "Engine/Application/Component.h"


struct AGameActor
{
   Component component[1];
   Font*     hpFont;
   Font*     talkFont;

   void (*Init)(void);
   void (*Run) (void);
};


extern struct AGameActor AGameActor[1];


#endif 

```

`Samples/SuperLittleRed/Code/GameData.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-1-7
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#include "GameData.h"


struct AGameData AGameData[1] =
{{
    .stone              = 0,
    .wood               = 0,
    .coin               = 0,

    .maxScore           = 0,
    .speed              = 1.2f,
    .maxHP              = 1,
    .maxEnergy          = 100,

    .recoverEnergy      = 5,
    .dizzyDistance      = 0.4f,
    .dizzyTime          = 2,

    .stonePower         = 0.05f,
    .woodTime           = 5.0f,

    .arrowSpeed         = 1.0f,
    .arrowPower         = 1.0f,

    .hitFloorCostEnergy = 10,
    .arrowCostEnergy    = 5,

    .tmp0               = 0,
    .playGameCount      = 0,
    .maxRoundCount      = 0,
    .maxRoundTime       = 0.0f,
    .maxRoundKillCount  = 0,

    .weaponIndex        = StoreWeapon_Wood,
    .dressIndex         = StoreDress_RedGirl,

    .buyWeapons         = {StoreWeapon_Wood,   -1, -1, -1, -1, -1, -1, -1, -1, -1},
    .buyDresses         = {StoreDress_RedGirl, -1, -1, -1, -1, -1},

    .maxProperty        =
    {
      1.7f,
      11.0f,
      200.0f,
      10.0f,
      0.9f,
      7.0f,
      0.15f,
      15.0f,
      1.5f,
      2.0f,
    },

    .increaseProperty   =
    {
        0.1f,
        2.0f,
        20.0f,
        1.0f,
        0.1f,
        1.0f,
        0.02f,
        2.0f,
        0.1f,
        0.2f,
    },
}};
```

`Samples/SuperLittleRed/Code/GameData.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-1-7
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#ifndef GAME_DATA_H
#define GAME_DATA_H


#include "UI.h"


struct AGameData
{
    int                     stone;
    int                     wood;
    int                     coin;
    int                     maxScore;

    float                   speed;
    float                   maxHP;
    int                     maxEnergy;
    int                     recoverEnergy;
    float                   dizzyDistance;
    int                     dizzyTime;
    float                   stonePower;
    float                   woodTime;
    float                   arrowSpeed;
    float                   arrowPower;

    int                     hitFloorCostEnergy;
    int                     arrowCostEnergy;

    int                     tmp0;
    int                     playGameCount;
    int                     maxRoundCount;
    float                   maxRoundTime;
    int                     maxRoundKillCount;

    int                     weaponIndex;
    int                     dressIndex;

    int                     buyWeapons      [StoreWeapon_Length];
    int                     buyDresses      [StoreDress_Length];

    float                   maxProperty     [StoreProperty_Length];
    float                   increaseProperty[StoreProperty_Length];
};


extern struct AGameData AGameData[1];


#endif

```

`Samples/SuperLittleRed/Code/GameMap.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-9-16
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Toolkit/Utils/TweenTool.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Physics/PhysicsWorld.h"
#include "Engine/Extension/Spine/SkeletonSlot.h"
#include "Engine/Application/Application.h"

#include "GameMap.h"
#include "Hero.h"
#include "Tool.h"


enum
{
    Cloud_Length = 3,
    Map_Length   = 1,
};


static Array(float)* groundPosVertex;
static PhysicsBody*  groundBody;
static Drawable*     cloud1Drawable = NULL;
static Drawable*     cloud2Drawable = NULL;
static Drawable*     cloud3Drawable = NULL;

#ifdef APP_DEBUG
static Drawable     debugDrawable[1];
#endif


static void Update(Component* component, float deltaSeconds)
{
    ASkeletonAnimationPlayer_Update(AGameMap->mapPlayer, deltaSeconds);

    #ifdef APP_DEBUG
    ADrawable->Draw(debugDrawable);
    #endif
}


// predefine
static void CloudAction(Drawable* cloudDrawable);


static void CloudActionOnComplete(TweenAction* action)
{
    Drawable* drawable = AUserData_GetSlotPtrWithType(action->userData, 0, Drawable*);
    ADrawable_SetPositionX(drawable, AGLTool->screenRatio + AGameMap->scaleX * drawable->width);
    CloudAction(drawable);
}


static void CloudAction(Drawable* cloudDrawable)
{
    float pos = -AGLTool->screenRatio - cloudDrawable->width * AGameMap->scaleX;

    if (cloudDrawable == cloud1Drawable)
    {
        ATweenTool->AddMoveX      (pos, 150.0f)
                  ->SetEaseType   (TweenEaseType_SineOut)
                  ->SetRelative   (false)
                  ->SetOnComplete (CloudActionOnComplete)
                  ->SetUserDataPtr(0, cloud1Drawable)
                  ->RunActions    (cloud1Drawable);
    }
    else if (cloudDrawable == cloud2Drawable)
    {
        ATweenTool->AddMoveX      (pos, 200.0f)
                  ->SetEaseType   (TweenEaseType_SineInOut)
                  ->SetRelative   (false)
                  ->SetOnComplete (CloudActionOnComplete)
                  ->SetUserDataPtr(0, cloud2Drawable)
                  ->RunActions    (cloud2Drawable);
    }
    else if (cloudDrawable == cloud3Drawable)
    {
        ATweenTool->AddInterval   (20.0f)
                  ->AddMoveX      (pos, 250.0f)
                  ->SetRelative   (false)
                  ->SetEaseType   (TweenEaseType_SineIn)
                  ->SetOnComplete (CloudActionOnComplete)
                  ->SetUserDataPtr(0, cloud3Drawable)
                  ->RunActions    (cloud3Drawable);
    }
}


static void OnActionOver(SkeletonAnimationPlayer* player)
{
    ASkeletonAnimationPlayer->SetAnimation(player, "animation");
    player->OnActionOver = NULL;

    ADrawable_SetParent(AHero_GetDrawable(), AGameMap->groundPosDrawable);

    Drawable* clouds[Cloud_Length] =
    {
        cloud1Drawable,
        cloud2Drawable,
        cloud3Drawable,
    };

    for (int i = 0; i < Cloud_Length; ++i)
    {
        Drawable* drawable = clouds[i];
        if (ATween->HasAction(drawable) == false)
        {
            CloudAction(drawable);
        }
    }
}


static const char* mapNames[Map_Length] =
{
    "Stage/Stage11",
};


static SkeletonAnimationPlayer* maps[Map_Length];


static void RandomMap()
{
    AGameMap->mapIndex                = AMath_RandomInt(0, Map_Length - 1);
    AGameMap->mapPlayer               = maps[AGameMap->mapIndex];
    AGameMap->mapPlayer->OnActionOver = OnActionOver;
    ASkeletonAnimationPlayer->SetAnimation(AGameMap->mapPlayer, "ShowIn");

    Drawable* drawable = ASkeletonAnimationPlayer_GetDrawable(AGameMap->mapPlayer);
    
    ADrawable_SetScale2
    (
        drawable,
        ATool->globalScaleX,
        ATool->globalScaleY
    );

    AGameMap->scaleX            = drawable->scaleX;
    AGameMap->scaleY            = drawable->scaleY;

    SkeletonSlot* groundPosSlot = ASkeletonAnimationPlayer_GetSlot(AGameMap->mapPlayer, "GroudPos");
    groundPosVertex             = ASkeletonSlot_GetBoundingBox(groundPosSlot)->vertexArr;

    AGameMap->groundPosData     = groundPosVertex->data;
    AGameMap->groundPosDrawable = groundPosSlot->bone->drawable;

    AGameMap->backDrawable      = ASkeletonAnimationPlayer_GetBone(AGameMap->mapPlayer, "Back")  ->drawable;
    AGameMap->middleDrawable    = ASkeletonAnimationPlayer_GetBone(AGameMap->mapPlayer, "Middle")->drawable;
    AGameMap->beforeDrawable    = ASkeletonAnimationPlayer_GetBone(AGameMap->mapPlayer, "Before")->drawable;
    AGameMap->skyDrawable       = ASkeletonAnimationPlayer_GetBone(AGameMap->mapPlayer, "Sky")   ->drawable;

    cloud1Drawable              = ASkeletonAnimationPlayer_GetBone(AGameMap->mapPlayer, "Cloud1")->drawable;
    cloud2Drawable              = ASkeletonAnimationPlayer_GetBone(AGameMap->mapPlayer, "Cloud2")->drawable;
    cloud3Drawable              = ASkeletonAnimationPlayer_GetBone(AGameMap->mapPlayer, "Cloud3")->drawable;

    AGameMap->moveAreaY         = AGameMap->groundPosData[1] * drawable->scaleY;
    AGameMap->groundY           = AGameMap->groundPosData[1];

    AGameMap->minX              = AGameMap->groundPosData[0];
    AGameMap->maxX              = AGameMap->groundPosData[6];

    groundBody                  = APhysicsWorld->AddBody
                                  (
                                     PhysicsShape_Line,
                                     AArray_Make
                                     (
                                         float, 4,
                                         AGameMap->groundPosData[0],
                                         AGameMap->groundPosData[1],
                                         AGameMap->groundPosData[6],
                                         AGameMap->groundPosData[1]
                                     )
                                  );

    groundBody->state = PhysicsBodyState_Fixed;
    APhysicsBody_SetCollisionGroup
    (
        groundBody,
        CollisionGroup_HeroBody | CollisionGroup_EnemyBody
    );

    #ifdef APP_DEBUG
    ASkeletonAnimationPlayer->InitSlotBoundingBoxDrawable(AGameMap->mapPlayer, "GroudPos", debugDrawable);
    #endif

    // arrow tail render requires AGameMap beforeDrawable mvpMatrix update
    ADrawable_AddState(AGameMap->beforeDrawable, DrawableState_IsUpdateMVPMatrix);
}


static void Init()
{
    AComponent->Init(AGameMap->component);
    AGameMap->component->curState->Update = Update;

    for (int i = 0; i < Map_Length; ++i)
    {
        maps[i] = ASkeletonAnimationPlayer->Create(mapNames[i], "ShowIn");
    }

    RandomMap();
}


static void Run()
{
    AApplication_AddChild(AGameMap->component, 10);
}


struct AGameMap AGameMap[1] =
{{
    .Init      = Init,
    .Run       = Run,
    .RandomMap = RandomMap,
}};

```

`Samples/SuperLittleRed/Code/GameMap.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-9-16
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#ifndef GAME_MAP_H
#define GAME_MAP_H


#include "Engine/Application/Component.h"
#include "Engine/Extension/Spine/SkeletonAnimationPlayer.h"


struct AGameMap
{
    Component                component[1];
    SkeletonAnimationPlayer* mapPlayer;
    int                      mapIndex;

    float                    scaleX;
    float                    scaleY;

    float                    minX;
    float                    maxX;

    float                    groundY;
    float                    moveAreaY;
    float*                   groundPosData;
    Drawable*                groundPosDrawable;

    Drawable*                backDrawable;
    Drawable*                middleDrawable;
    Drawable*                beforeDrawable;
    Drawable*                skyDrawable;

    void (*Init)     (void);
    void (*Run)      (void);
    void (*RandomMap)(void);
};


extern struct AGameMap AGameMap[1];


#endif

```

`Samples/SuperLittleRed/Code/HUD.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-12-2
 * Update   : 2019-2-18
 * Author   : scott.cgi
 */


#include <stdio.h>
#include <string.h>

#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Toolkit/Utils/ArrayIntSet.h"
#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Extension/Font.h"
#include "Engine/Graphics/OpenGL/GLPrimitive.h"
#include "Engine/Physics/PhysicsWorld.h"
#include "Engine/Application/Scheduler.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Toolkit/Utils/TweenTool.h"
#include "Engine/Application/Application.h"
#include "Engine/Graphics/OpenGL/SubMesh.h"
#include "Engine/Extension/DrawAtlas.h"
#include "Engine/Application/Platform/Vibrator.h"

#include "HUD.h"
#include "GameMap.h"
#include "Hero.h"
#include "GameActor.h"
#include "Tool.h"
#include "UI.h"
#include "GameData.h"
#include "EnemyAI.h"
#include "AudioTool.h"


static ArrayList  (DropCollisionItem*) collisionItemList[1] = AArrayList_Init  (DropCollisionItem*, 10);
static ArrayIntSet(drawable*)          dropSet          [1] = AArrayIntSet_Init(Drawable*,          10);

#ifdef APP_DEBUG
static ArrayIntSet(DropCollisionItem*) collisionItemDebugDrawSet[1] = AArrayIntSet_Init(DropCollisionItem*, 10);
#endif

static bool       isCostEnergy  = false;
static float      recoverTime   = 0.0f;
static FontText*  roundText     = NULL;
static FontText*  roundNumText  = NULL;
static FontText*  timeText      = NULL;
static DrawAtlas* dropDrawAtlas = NULL;
static Scheduler* timeScheduler = NULL;


static void Update(Component* component, float deltaSeconds)
{
    ADrawAtlas_Draw(dropDrawAtlas);
    ASkeletonAnimationPlayer_Update(AHUD->hudPlayer,     deltaSeconds);
    ASkeletonAnimationPlayer_Update(AHUD->curtainPlayer, deltaSeconds);

    #ifdef APP_DEBUG
    for (int i = 0; i < collisionItemDebugDrawSet->elementList->size; ++i)
    {
        DropCollisionItem* item = AArrayList_Get(collisionItemDebugDrawSet->elementList, i, DropCollisionItem*);

        if (item->body->state != PhysicsBodyState_Freeze)
        {
            ADrawable->Draw(item->debugDrawable);
        }
    }
    #endif

    if (isCostEnergy == false)
    {
        if (AHero->roundEnergy < AGameData->maxEnergy)
        {
            if (recoverTime > heroEnergyRecoverTime)
            {
                AHero->roundEnergy += AGameData->recoverEnergy;

                if (AHero->roundEnergy > AGameData->maxEnergy)
                {
                    AHero->roundEnergy = AGameData->maxEnergy;
                }

                float scaleY = (float) AHero->roundEnergy / (float) AGameData->maxEnergy;

                ATweenTool->AddScaleY  (scaleY, 0.35f)
                          ->SetRelative(false)
                          ->SetEaseType(TweenEaseType_SineInOut)
                          ->RunActions (AHUD->energyLengthDrawable);

                if (scaleY != 0.0f)
                {
                    ATweenTool->AddScaleY  (1.0f / scaleY, 0.35f)
                              ->SetRelative(false)
                              ->SetEaseType(TweenEaseType_SineInOut)
                              ->RunActions (AHUD->energyPointerDrawable);
                }

                recoverTime = 0.0f;
            }
            else
            {
                recoverTime += deltaSeconds;
            }
        }
    }
}


static void ScoreSchedulerUpdate(Scheduler* scheduler, float deltaSeconds)
{
    char buff[10];
    ATool->SetTimeToBuff(buff,     (int) AHero->roundTime);
    AFont->SetString    (timeText, buff);
}


static void OnHUDActionOver(SkeletonAnimationPlayer* player)
{
    ASkeletonAnimationPlayer->SetAnimation(player, "animation");
    player->OnActionOver = NULL;
    timeScheduler        = AScheduler->Schedule(ScoreSchedulerUpdate, 0.9f);

    ATweenTool->AddFadeTo  (1.0f, 1.0f)
              ->SetRelative(false)
              ->SetEaseType(TweenEaseType_ExponentialIn)
              ->RunActions (timeText->drawable);
}


static void HUDSchedulerUpdate(Scheduler* scheduler, float deltaSeconds)
{
    AHUD->Reset();
}


static SkeletonAnimationPlayerOnActionOver OnCurtainCallback;


static void OnCurtainActionOver(SkeletonAnimationPlayer* player)
{
    if (strcmp(player->curAnimationData->name, "close") == 0)
    {
        player->loop = 0;

        // play show animation
        ASkeletonAnimationPlayer->SetAnimation(AHUD->hudPlayer, "ShowIn");
        AHUD->hudPlayer->OnActionOver = OnHUDActionOver;
        AHUD->hudPlayer->loop         = -1;

        AScheduler->ScheduleOnce(HUDSchedulerUpdate, 0.1f);
    }
    else if (strcmp(player->curAnimationData->name, "open") == 0)
    {
        ASkeletonAnimationPlayer->SetAnimation(player, "stop");

        if (timeScheduler != NULL)
        {
            timeScheduler->isCancel = true;
            ADrawable_SetOpacity(timeText->drawable, 0.0f);
        }
    }

    player->OnActionOver = NULL;

    if (OnCurtainCallback != NULL)
    {
        OnCurtainCallback(player);
    }
}


static void OnInitActionOver(SkeletonAnimationPlayer* player)
{
    OnCurtainActionOver(player);
    AUI->Run();
    AUI->ShowMenu();
}


enum
{
    HUD_TextCount = 5,
};


static void Init()
{
    AComponent->Init(AHUD->component);
    AHUD->component->curState->Update = Update;

    ASkeletonAnimationPlayer->Init("UI/HUD", "ShowIn", AHUD->hudPlayer);
    AHUD->hudPlayer->OnActionOver = OnHUDActionOver;
    AHUD->hudPlayer->loop         = 0;

    ADrawable_SetScale2
    (
        ASkeletonAnimationPlayer_GetDrawable(AHUD->hudPlayer),
        ATool->globalScaleX,
        ATool->globalScaleY
    );

    ASkeletonAnimationPlayer->Init("UI/Curtain", "open", AHUD->curtainPlayer);
    AHUD->curtainPlayer->loop = 0;

    ADrawable_SetScale2
    (
        ASkeletonAnimationPlayer_GetDrawable(AHUD->curtainPlayer),
        ATool->globalScaleX,
        ATool->globalScaleY
    );

    AHUD->energyLengthDrawable  = ASkeletonAnimationPlayer_GetBone(AHUD->hudPlayer, "EnergyLength")->drawable;
    AHUD->energyDrawable        = ASkeletonAnimationPlayer_GetBone(AHUD->hudPlayer, "Energy")      ->drawable;
    AHUD->tombstoneDrawable     = ASkeletonAnimationPlayer_GetBone(AHUD->hudPlayer, "Tombstone")   ->drawable;
    AHUD->tombstoneHeight       = ASkeleton_GetSubMesh
                                  (
                                      AHUD->hudPlayer->skeleton,
                                      "Tombstone",
                                      "Tombstone"
                                  )
                                  ->drawable->height;

    AHUD->tombstoneBornY        = AHUD->tombstoneDrawable->positionY;
    AHUD->upDrawable            = ASkeletonAnimationPlayer_GetBone(AHUD->hudPlayer, "Up")  ->drawable;
    AHUD->downDrawable          = ASkeletonAnimationPlayer_GetBone(AHUD->hudPlayer, "Down")->drawable;

    ADrawable_SetInvisible(AHUD->tombstoneDrawable);

    AHUD->heartDrawable         = ASkeletonAnimationPlayer_GetBone   (AHUD->hudPlayer, "Heart")->drawable;
    AHUD->coinDrawable          = ASkeletonAnimationPlayer_GetBone   (AHUD->hudPlayer, "Coin") ->drawable;
    AHUD->stoneDrawable         = ASkeletonAnimationPlayer_GetBone   (AHUD->hudPlayer, "Stone")->drawable;
    AHUD->woodDrawable          = ASkeletonAnimationPlayer_GetBone   (AHUD->hudPlayer, "Wood") ->drawable;
    AHUD->killDrawable          = ASkeletonAnimationPlayer_GetBone   (AHUD->hudPlayer, "Kill") ->drawable;
    AHUD->energyPointerDrawable = ASkeletonAnimationPlayer_GetSubMesh(AHUD->hudPlayer, "Pointer", "Pointer")->drawable;

    roundText = AFont->GetText(AGameActor->talkFont);

    if (ATool->languageCode == LanguageCode_zh)
    {
        AFont->SetString(roundText, "@");
        ADrawable_SetPositionY(roundText->drawable, 0.204f);
    }
    else
    {
        AFont->SetString(roundText, "Round");
        ADrawable_SetPositionY(roundText->drawable, 0.2f);
    }

    const float scaleX = ATool->globalScaleX / 1.5f;
    const float scaleY = ATool->globalScaleX / 1.5f;

    ADrawable_SetScale2   (roundText->drawable, scaleX, scaleY);
    ADrawable_SetOpacity  (roundText->drawable, 0.0f);
    ADrawable_SetPositionX(roundText->drawable, -roundText->drawable->width * scaleX / 2);

    roundNumText = AFont->GetText(AGameActor->talkFont);
    ADrawable_SetScale2    (roundNumText->drawable, scaleX / 1.2f, scaleY / 1.2f);
    ADrawable_SetPositionY (roundNumText->drawable, 0.2018f);
    ADrawable_SetPositionX (roundNumText->drawable, -roundText->drawable->positionX);
    ADrawable_SetOpacity   (roundNumText->drawable, 0.0f);

    timeText = AFont->GetText(AGameActor->talkFont);
    ADrawable_SetOpacity(timeText->drawable, 0.0f);
    ADrawable_SetParent
    (
        timeText->drawable,
        ASkeletonAnimationPlayer_GetBone(AHUD->hudPlayer, "ScorePos")->drawable
    );

    Drawable* items[HUD_TextCount] =
    {
        AHUD->heartDrawable,
        AHUD->coinDrawable,
        AHUD->killDrawable,
        AHUD->stoneDrawable,
        AHUD->woodDrawable,
    };

    FontText** textPtrs[HUD_TextCount] =
    {
        &AHUD->heartText,
        &AHUD->coinText,
        &AHUD->killText,
        &AHUD->stoneText,
        &AHUD->woodText,
    };

    for (int i = 0; i < HUD_TextCount; ++i)
    {
        FontText* text  = AFont->GetText(AGameActor->talkFont);
        text->alignment = FontTextAlignment_HorizontalRight;

        ADrawable_SetParent
        (
            text->drawable,
            items[i]
        );
        
        ADrawable_SetPositionX(text->drawable, -AGLTool_ToGLWidth(20.0f));
        *textPtrs[i] = text;
    }

    dropDrawAtlas = ADrawAtlas->Get("Texture/Drop.atlas");
}


static void CostEnergyActionComplete(TweenAction* action)
{
    isCostEnergy = false;
}


static bool CostPower(int cost)
{
    if (AHero->roundEnergy >= cost)
    {
        AHero->roundEnergy -= cost;
        isCostEnergy        = true;

        if (AHero->roundEnergy > AGameData->maxEnergy)
        {
            AHero->roundEnergy = AGameData->maxEnergy;
        }
        
        float scaleY = (float) AHero->roundEnergy / (float) AGameData->maxEnergy;

        ATweenTool->AddScaleY    (scaleY, 0.2f)
                  ->SetRelative  (false)
                  ->SetEaseType  (TweenEaseType_SineInOut)
                  ->SetOnComplete(CostEnergyActionComplete)
                  ->RunActions   (AHUD->energyLengthDrawable);

        if (scaleY != 0.0f)
        {
            ATweenTool->AddScaleY(1.0f / scaleY, 0.2f)
                      ->SetRelative(false)
                      ->SetEaseType(TweenEaseType_SineInOut)
                      ->RunActions(AHUD->energyPointerDrawable);
        }

        return true;
    }
    else
    {
        ATool->ShakeX(AHUD->energyDrawable);

        FontText* text = AFont->GetText(AGameActor->talkFont);

        if (ATool->languageCode == LanguageCode_zh)
        {
            AFont->SetString(text, "!");
            ADrawable_SetScaleSame2(text->drawable, 1.2f);
        }
        else
        {
            AFont->SetString(text, "Weak");
        }

        AFont_SetTextColor(text, AColor_Make(0.81f, 0.78f, 0.75f,1.0f));
        ATool->FlyTextOnHero(text, 0.1f, 4.0f);
        
        return false;
    }
}


static void OpenCurtain(SkeletonAnimationPlayerOnActionOver callback)
{
    ASkeletonAnimationPlayer->SetAnimation(AHUD->curtainPlayer, "open");
    AHUD->curtainPlayer->loop         = -1;
    AHUD->curtainPlayer->OnActionOver = OnCurtainActionOver;

    AAudioTool->Play(AudioID_CurtainSlideShow);
    AAudioTool->StartUIBG();

    if (callback == NULL)
    {
        OnCurtainCallback = NULL;
    }
    else
    {
        OnCurtainCallback = callback;
    }
}


static void CloseCurtain(SkeletonAnimationPlayerOnActionOver callback)
{
    ASkeletonAnimationPlayer->SetAnimation(AHUD->curtainPlayer, "close");
    AHUD->curtainPlayer->loop         = -1;
    AHUD->curtainPlayer->OnActionOver = OnCurtainActionOver;

    AAudioTool->Play(AudioID_CurtainSlideHide);
    AAudioTool->Play(AudioID_CurtainRing);
    AAudioTool->StartGameBG();

    if (callback == NULL)
    {
        OnCurtainCallback = NULL;
    }
    else
    {
        OnCurtainCallback = callback;
    }

    ADrawable_SetParent    (roundText->drawable, AGameMap->beforeDrawable);

    ATweenTool->AddFadeTo  (1.0, 2.0f)
              ->SetEaseType(TweenEaseType_SineInOut)
              ->SetRelative(false)

              ->AddFadeTo  (0.0, 3.0f)
              ->SetEaseType(TweenEaseType_QuinticIn)
              ->SetRelative(false)

              ->RunActions (roundText->drawable);


    AFont->SetInt          (roundNumText, ++AHero->roundCount);
    ADrawable_SetParent    (roundNumText->drawable, AGameMap->beforeDrawable);

    ATweenTool->AddFadeTo  (1.0, 2.0f)
              ->SetEaseType(TweenEaseType_SineInOut)
              ->SetRelative(false)

              ->AddFadeTo  (0.0, 3.0f)
              ->SetEaseType(TweenEaseType_QuinticIn)
              ->SetRelative(false)

              ->RunActions (roundNumText->drawable);
}


static void Run()
{
    AApplication_AddChild(AHUD->component, 100);
    AHUD->curtainPlayer->OnActionOver = OnInitActionOver;
    AHUD->curtainPlayer->loop         = -1;

    AAudioTool->Play(AudioID_CurtainSlideShow);
}


static void Reset()
{
    AGameData->wood  = 0;
    AGameData->stone = 0;

    AFont->SetInt(AHUD->heartText, AHero->roundHP);
    AFont->SetInt(AHUD->coinText,  AGameData->coin);
    AFont->SetInt(AHUD->woodText,  AGameData->wood);
    AFont->SetInt(AHUD->stoneText, AGameData->stone);
    AFont->SetInt(AHUD->killText,  AHero->roundKillCount);

    ADrawable_SetScaleY(AHUD->energyLengthDrawable,  1.0f);
    ADrawable_SetScaleY(AHUD->energyPointerDrawable, 1.0f);

    AMath_RandomSeedByTime();
}


static void ClearDrop()
{
    while (dropSet->elementList->size > 0)
    {
        ATween->TryCompleteAllActions
        (
            AArrayList_Get(dropSet->elementList, dropSet->elementList->size - 1, Drawable*),
            true
        );
    }
}


static void OnStoneFade(TweenAction* action)
{
    SubMesh* subMesh = AUserData_GetSlotPtrWithType(action->userData, 0, SubMesh*);
    ADrawAtlas->ReleaseQuad(dropDrawAtlas, subMesh);
    AArrayIntSet->TryRemove(dropSet,       (intptr_t) subMesh->drawable);
}


static void OnStoneDown(TweenAction* action)
{
    AHero->hitFloor->loop = 1;

    ADrawable_SetPositionX
    (
        ASkeletonAnimationPlayer_GetDrawable(AHero->hitFloor),
        ADrawable->ConvertBetweenLocalPositionX
        (
            AGameMap->groundPosDrawable,
            AHero_GetDrawable()->positionX,
            AGameMap->beforeDrawable
        )
    );

    AEnemyAI->SetAllEnemy(EnemyState_Stand, AGameData->stonePower);
    AAudioTool->Play(AudioID_FallDown);
}


static inline void DropStoneWood
(
    const char*           name,
    float                 fadeTime,
    TweenActionOnComplete OnDown,
    TweenActionOnComplete OnFade,
    DropCollisionItem*    item
)
{
    SubMesh*  subMesh  = ADrawAtlas->GetQuad(dropDrawAtlas, name);
    Drawable* drawable = subMesh->drawable;
    float     posX     = ADrawable->ConvertBetweenLocalPositionX
                         (
                            AGameMap->groundPosDrawable,
                            AHero_GetDrawable()->positionX,
                            AGameMap->beforeDrawable
                         );

    float     posY     = ADrawable->ConvertToLocalPositionY(AGameMap->beforeDrawable, 1.0f + drawable->height / 2);

    ADrawable_SetParent   (drawable, AGameMap->beforeDrawable);
    ADrawable_SetPosition2(drawable, posX, posY);

    ATweenTool->AddMoveY      (AGameMap->groundY + drawable->height / 2 - AGLTool_ToGLHeight(0.5f), 0.35f)
              ->SetEaseType   (TweenEaseType_ExponentialIn)
              ->SetRelative   (false)
              ->SetUserDataPtr(0, item == NULL ? (void*) drawable : item)
              ->SetOnComplete (OnDown)

              ->AddFadeTo     (0.0f, fadeTime)
              ->SetRelative   (false)
              ->SetUserDataPtr(0, item == NULL ? (void*) subMesh  : item)
              ->SetEaseType   (TweenEaseType_ExponentialIn)
              ->SetOnComplete (OnFade)

              ->RunActions    (drawable);

    AArrayIntSet->TryAdd(dropSet, (intptr_t) drawable);

    if (item != NULL)
    {
        item->subMesh = subMesh;
    }
}


static void DropStone()
{
    DropStoneWood("DropStone", 2.0f, OnStoneDown, OnStoneFade, NULL);
}


#ifdef APP_DEBUG
static void ItemDebugRender(Drawable *drawable)
{
    AGLPrimitive->RenderPolygon
    (
        AUserData_GetSlotPtrWithType(drawable->userData, 0, DropCollisionItem*)->body->transformedVertexArr,
        AGameMap->beforeDrawable->mvpMatrix,
        COLOR_GREED_ARRAY,
        1.0f
    );
}
#endif


static inline void ClearItem(DropCollisionItem* item)
{
    item->body->state = PhysicsBodyState_Freeze;
    ADrawAtlas->ReleaseQuad(dropDrawAtlas, item->subMesh);

    AArrayList_Add(collisionItemList, item);
    AArrayIntSet->TryRemove(dropSet, (intptr_t) item->subMesh->drawable);

    #ifdef APP_DEBUG
    AArrayIntSet->TryRemove(collisionItemDebugDrawSet, (intptr_t) item);
    #endif
}


static void OnItemFade(TweenAction* action)
{
    ClearItem(AUserData_GetSlotPtrWithType(action->userData, 0, DropCollisionItem*));
}


static inline void UpdateItemBody(DropCollisionItem* item)
{
    item->body->positionX = item->subMesh->drawable->positionX;
    item->body->positionY = item->subMesh->drawable->positionY;
    item->body->state     = PhysicsBodyState_Fixed;
    APhysicsBody->Update(item->body, 0.0f);
}


static void OnItemDown(TweenAction* action)
{
    UpdateItemBody(AUserData_GetSlotPtrWithType(action->userData, 0, DropCollisionItem*));
}


static inline DropCollisionItem* DropItem(int bodySize, int bodyID, int collisionGroup)
{
    DropCollisionItem* item = NULL;

    for (int i = 0; i < collisionItemList->size; ++i)
    {
        DropCollisionItem* tmp = AArrayList_Get(collisionItemList, i, DropCollisionItem*);

        if (tmp->bodySize == bodySize && tmp->bodyID == bodyID && tmp->collisionGroup == collisionGroup)
        {
            item = tmp;
            AArrayList->Remove(collisionItemList, i);
            break;
        }
    }

    if (item == NULL)
    {
        item                 = malloc(sizeof(DropCollisionItem));
        item->bodyID         = bodyID;
        item->bodySize       = bodySize;
        item->collisionGroup = collisionGroup;

        float len  = AGLTool_ToGLWidth(bodySize);
        item->body = APhysicsWorld->AddBody
                     (
                        PhysicsShape_Polygon,
                        AArray_Make
                        (
                             float,  8,
                            -len,  len,
                             len,  len,
                             len, -len,
                            -len, -len,
                        )
                     );

        item->body->userID = bodyID;
        AUserData_SetSlotPtr(item->body->userData, 0, item);
        APhysicsBody_SetCollisionGroup(item->body, collisionGroup);

        #ifdef APP_DEBUG
        ADrawable->Init(item->debugDrawable);
        AUserData_SetSlotPtr(item->debugDrawable->userData, 0, item);
        item->debugDrawable->Render = ItemDebugRender;
        #endif
    }

    item->body->state = PhysicsBodyState_Freeze;

    #ifdef APP_DEBUG
    AArrayIntSet->TryAdd(collisionItemDebugDrawSet, (intptr_t) item);
    #endif

    return item;
}


static void OnWoodDown(TweenAction* action)
{
    AAudioTool->Play(AudioID_FallDown);
    OnItemDown(action);

    AHero->hitFloor->loop = 1;

    ADrawable_SetPositionX
    (
        ASkeletonAnimationPlayer_GetDrawable(AHero->hitFloor),
        ADrawable->ConvertBetweenLocalPositionX
        (
            AGameMap->groundPosDrawable,
            AHero_GetDrawable()->positionX,
            AGameMap->beforeDrawable
        )
    );
}


static void DropWood()
{
    DropStoneWood
    (
        "DropWood",
        AGameData->woodTime,
        OnWoodDown,
        OnItemFade,
        DropItem
        (
            18,
            CollisionBodyID_Wood,
            CollisionGroup_HeroAttack | CollisionGroup_ArrowAttack
        )
    );
}


static void DropCollisionItemSchedulerUpdate(Scheduler* scheduler, float deltaSeconds)
{
    float              time = AUserData_GetSlotFloat(scheduler->userData, 1);
    DropCollisionItem* item = AUserData_GetSlotPtrWithType(scheduler->userData, 0, DropCollisionItem*);

    if (time > 1.2f || item->body->state == PhysicsBodyState_Freeze)
    {
        scheduler->isCancel = true;
    }
    else
    {
        time += deltaSeconds;
        AUserData_SetSlotFloat(scheduler->userData, 1, time);
        UpdateItemBody(item);
    }
}


static void OnDropItemAfter(TweenAction* action)
{
    DropCollisionItem* item = AUserData_GetSlotPtrWithType(action->userData, 0, DropCollisionItem*);

    // update item body when item easing.
    Scheduler* scheduler = AScheduler->Schedule(DropCollisionItemSchedulerUpdate, 0.0f);

    AUserData_SetSlotPtr  (scheduler->userData, 0, item);
    AUserData_SetSlotFloat(scheduler->userData, 1, 0.0f);// time
    UpdateItemBody(item); // start collision test
}


static inline void DropHeartCoinStoneWood
(
    const char*        name,
    PhysicsBody*       arrowBody,
    float              enemyScaleX,
    DropCollisionItem* item
)
{
    SubMesh*  subMesh  = ADrawAtlas->GetQuad(dropDrawAtlas, name);
    Drawable* drawable = subMesh->drawable;

    ADrawable_SetParent    (drawable, AGameMap->beforeDrawable);
    ADrawable_SetPosition2 (drawable, arrowBody->positionX, arrowBody->positionY);
    ADrawable_SetScaleSame2(drawable, 0.2f);

    float scaleY = 0.7f;

    ATweenTool->AddMoveY      (AGameMap->groundY + drawable->height * scaleY / 2 - AGLTool_ToGLHeight(0.5f), 0.8f)
              ->SetEaseType   (TweenEaseType_BounceOut)
              ->SetRelative   (false)

              ->SetScaleSame2 (scaleY, false, TweenEaseType_QuarticOut)

              ->AddMoveX      (-0.11f * enemyScaleX * fabsf(arrowBody->velocityX), 1.2f)
              ->SetQueue      (false)
              ->SetEaseType   (TweenEaseType_CubicOut)

              ->AddFadeTo     (0.0, 15.0f)
              ->SetRelative   (false)
              ->SetEaseType   (TweenEaseType_ExponentialIn)
              ->SetUserDataPtr(0, item)
              ->SetOnComplete (OnItemFade)

              ->AddInterval   (0.5f)
              ->SetQueue      (false)
              ->SetUserDataPtr(0, item)
              ->SetOnComplete (OnDropItemAfter)

              ->RunActions    (drawable);

    AArrayIntSet->TryAdd(dropSet, (intptr_t) drawable);
    item->subMesh = subMesh;
}


static void DropPickHeart(PhysicsBody* arrowBody, float enemyScaleX)
{
    DropHeartCoinStoneWood
    (
        "Heart",
        arrowBody,
        enemyScaleX,
        DropItem
        (
            9,
            CollisionBodyID_Heart,
            CollisionGroup_EnemyAttack | CollisionGroup_ArrowAttack
        )
    );
}


static void DropPickCoin(PhysicsBody* arrowBody, float enemyScaleX)
{
    DropHeartCoinStoneWood
    (
        "Coin",
        arrowBody,
        enemyScaleX,
        DropItem
        (
            9,
            CollisionBodyID_Coin,
            CollisionGroup_EnemyAttack | CollisionGroup_ArrowAttack
        )
    );
}


static void DropPickStone(PhysicsBody* arrowBody, float enemyScaleX)
{
    DropHeartCoinStoneWood
    (
        "Stone",
        arrowBody,
        enemyScaleX,
        DropItem
        (
            9,
            CollisionBodyID_Stone,
            CollisionGroup_EnemyAttack | CollisionGroup_ArrowAttack
        )
    );
}


static void DropPickWood(PhysicsBody* arrowBody, float enemyScaleX)
{
    DropHeartCoinStoneWood
    (
        "Wood",
        arrowBody,
        enemyScaleX,
        DropItem
        (
            9,
            CollisionBodyID_Wood,
            CollisionGroup_EnemyAttack | CollisionGroup_ArrowAttack
        )
    );
}


static void OnItemGet(TweenAction* action)
{
    DropCollisionItem* item = AUserData_GetSlotPtrWithType(action->userData, 0, DropCollisionItem*);
    Drawable*          drawable;

    switch (item->bodyID)
    {
        case CollisionBodyID_Heart:
            AFont->SetInt(AHUD->heartText, ++AHero->roundHP);
            drawable = AHUD->heartDrawable;
            break;

        case CollisionBodyID_Coin:
            AFont->SetInt(AHUD->coinText,  ++AGameData->coin);
            drawable = AHUD->coinDrawable;
            break;

        case CollisionBodyID_Stone:
            AFont->SetInt(AHUD->stoneText, ++AGameData->stone);
            drawable = AHUD->stoneDrawable;
            break;

        case CollisionBodyID_Wood:
            AFont->SetInt(AHUD->woodText,  ++AGameData->wood);
            drawable = AHUD->woodDrawable;
            break;

        default:
            return;
    }

    ADrawAtlas->ReleaseQuad(dropDrawAtlas, AUserData_GetSlotPtrWithType(action->userData, 1, SubMesh*));

    ATweenTool->AddScaleSame2(1.25f, 0.1f, false, TweenEaseType_SineOut)
              ->AddScaleSame2(1.0f,  0.2f, false, TweenEaseType_ElasticOut)
              ->RunActions(drawable);
}


static void FlyItem(DropCollisionItem* item)
{
    const char* name;
    Drawable*   target;

    switch (item->bodyID)
    {
        case CollisionBodyID_Heart:
            name   = "Heart";
            target = AHUD->heartDrawable;
            AAudioTool->Play(AudioID_PickHeart);
            break;

        case CollisionBodyID_Coin:
            name   = "Coin";
            target = AHUD->coinDrawable;
            AAudioTool->Play(AudioID_PickCoin);
            break;

        case CollisionBodyID_Stone:
            name   = "Stone";
            target = AHUD->stoneDrawable;
            AAudioTool->Play(AudioID_PickStone);
            break;

        case CollisionBodyID_Wood:
            name   = "Wood";
            target = AHUD->woodDrawable;
            AAudioTool->Play(AudioID_PickWood);
            break;

        default:
            return;
    }

    Drawable* drawable = ADrawAtlas->GetQuad(dropDrawAtlas, name)->drawable;

    ADrawable_SetParent   (drawable, AGameMap->beforeDrawable);
    ADrawable_SetPosition2(drawable, item->subMesh->drawable->positionX, item->subMesh->drawable->positionY);

    ADrawable->ConvertToParent(drawable, target->parent);
    ADrawable_SetScaleSame2   (drawable, 0.5f);

    ATweenTool->AddMove2      (target->positionX, target->positionY, 1.2f, false, TweenEaseType_SineOut)
              ->SetUserDataPtr(0, item)
              ->SetUserDataPtr(1, drawable)
              ->SetOnComplete (OnItemGet)
              ->RunActions    (drawable);

    // item tween may not complete
    ATween->TryRemoveAllActions(item->subMesh->drawable);
    ClearItem(item);
}


struct AHUD AHUD[1] =
{{
    .Init          = Init,
    .Run           = Run,
    .CostPower     = CostPower,
    .OpenCurtain   = OpenCurtain,
    .CloseCurtain  = CloseCurtain,
    .Reset         = Reset,
    .DropStone     = DropStone,
    .DropWood      = DropWood,
    .ClearDrop     = ClearDrop,
    .DropPickHeart = DropPickHeart,
    .DropPickCoin  = DropPickCoin,
    .DropPickStone = DropPickStone,
    .DropPickWood  = DropPickWood,
    .FlyItem       = FlyItem,
}};

```

`Samples/SuperLittleRed/Code/HUD.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 * 
 * Since    : 2016-12-2
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#ifndef HUD_H
#define HUD_H


#include "Engine/Application/Component.h"
#include "Engine/Extension/Spine/SkeletonAnimationPlayer.h"
#include "Engine/Extension/Font.h"
#include "Engine/Physics/PhysicsBody.h"
#include "Config.h"


typedef struct
{
    SubMesh*     subMesh;
    PhysicsBody* body;
    int          bodySize;
    int          collisionGroup;
    int          bodyID;

    #ifdef APP_DEBUG
    Drawable     debugDrawable[1];
    #endif
}
DropCollisionItem;


struct AHUD
{
    Component               component    [1];
    SkeletonAnimationPlayer hudPlayer    [1];
    SkeletonAnimationPlayer curtainPlayer[1];

    Drawable*               energyLengthDrawable;
    Drawable*               energyDrawable;
    Drawable*               tombstoneDrawable;
    Drawable*               upDrawable;
    Drawable*               downDrawable;
    Drawable*               energyPointerDrawable;

    float                   tombstoneHeight;
    float                   tombstoneBornY;

    FontText*               heartText;
    FontText*               coinText;
    FontText*               woodText;
    FontText*               stoneText;
    FontText*               killText;

    Drawable*               heartDrawable;
    Drawable*               coinDrawable;
    Drawable*               stoneDrawable;
    Drawable*               woodDrawable;
    Drawable*               killDrawable;

    void (*Init)         (void);
    void (*Run)          (void);
    bool (*CostPower)    (int cost);
    void (*OpenCurtain)  (SkeletonAnimationPlayerOnActionOver callback);
    void (*CloseCurtain) (SkeletonAnimationPlayerOnActionOver callback);
    void (*Reset)        (void);

    void (*DropStone)    (void);
    void (*DropWood)     (void);

    void (*DropPickHeart)(PhysicsBody* arrowBody, float enemyScaleX);
    void (*DropPickCoin) (PhysicsBody* arrowBody, float enemyScaleX);
    void (*DropPickStone)(PhysicsBody* arrowBody, float enemyScaleX);
    void (*DropPickWood) (PhysicsBody* arrowBody, float enemyScaleX);

    void (*ClearDrop)    (void);
    void (*FlyItem)      (DropCollisionItem* item);
};


extern struct AHUD AHUD[1];


#endif

```

`Samples/SuperLittleRed/Code/Hero.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-9-17
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Application/Input.h"
#include "Engine/Toolkit/Utils/Array.h"
#include "Engine/Toolkit/Utils/ArrayIntSet.h"
#include "Engine/Extension/Font.h"
#include "Engine/Toolkit/Utils/TweenTool.h"
#include "Engine/Extension/Spine/SkeletonSlot.h"
#include "Engine/Physics/PhysicsWorld.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Graphics/OpenGL/GLPrimitive.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Graphics/OpenGL/SubMesh.h"
#include "Engine/Application/Scheduler.h"
#include "Engine/Application/Application.h"
#include "Engine/Extension/DrawAtlas.h"
#include "Engine/Application/Platform/Vibrator.h"

#include "Hero.h"
#include "GameMap.h"
#include "Config.h"
#include "Tool.h"
#include "HUD.h"
#include "EnemyAI.h"
#include "UI.h"
#include "GameData.h"
#include "AudioTool.h"
#include "Enemy.h"
#include "GameActor.h"


static DrawAtlas*          arrowPathDrawAtlas;
static const int           arrowPathCount       = 10;
static bool                isArrowPathShow      = false;
static SubMesh*            arrowPath[arrowPathCount];
static PhysicsBody         arrowPathBody[1];

static const float         arrowTailOpacity     =  0.6f;
static const float         arrowTailOpacityTime = -0.06f;

static ArrayIntSet(Arrow*) arrowSet [1] = AArrayIntSet_Init(Arrow*, 25);
static ArrayList  (Arrow*) arrowList[1] = AArrayList_Init  (Arrow*, 25);

#ifdef APP_DEBUG
static Drawable            debugCollisionBoundingBox[1];
#endif


static void Update(Component* component, float deltaSeconds)
{
    ASkeletonAnimationPlayer_Update(AHero->player,   deltaSeconds);
    ASkeletonAnimationPlayer_Update(AHero->hitFloor, deltaSeconds);
    ADrawAtlas_Draw(arrowPathDrawAtlas);

    if (AHero->component->curState->id < HeroState_Die)
    {
        AHero->roundTime += deltaSeconds;
    }

    if (AHero->collisionBoxBody != NULL)
    {
        if (AHero->collisionBoxBody->state != PhysicsBodyState_Freeze)
        {
            ATool->UpdateBox(AHero->collisionBoxBody, AHero->collisionBoxDrawable);
        }

        #ifdef APP_DEBUG
        ADrawable->Draw(debugCollisionBoundingBox);
        #endif
    }

    for (int i = 0; i < arrowSet->elementList->size; ++i)
    {
        Arrow*       arrow    = AArrayList_Get(arrowSet->elementList, i, Arrow*);
        PhysicsBody* body     = arrow->body;
        Drawable*    drawable = arrow->sprite->drawable;

        if (body->state != PhysicsBodyState_Freeze)
        {
            ADrawable_SetRotationZ(drawable, ADrawable->GetFlipRotationZ(drawable, body->rotationZ));
            ADrawable_SetPosition2(drawable, body->positionX, body->positionY);
            ATool->UpdateArrowTail(arrow, deltaSeconds);
        }

        ADrawable->Draw(drawable);
        ADrawable->Draw(arrow->tailDrawable);
    }
}


static void ResetArrow(Arrow* arrow)
{
    ADrawable_SetInvisible(arrow->sprite->drawable);

    ASprite->DeformByIndex
    (
        arrow->sprite,

        AArray_Make
        (
            float,
            2,
            arrow->deformX, arrow->deformX
        ),

        AArray_Make
        (
            float,
            2,
            arrow->deformU, arrow->deformU
        ),

        AArray_Make
        (
            int,
            2,
            4, 6
        )
    );

    // reset body to born state
    APhysicsBody->ResetVertices(arrow->body);

    AArrayList_Add(arrowList, arrow);
}


static void ArrowOnComplete(Arrow* arrow)
{
    if (arrow->hitType == ArrowHitType_Ground)
    {
        AArrayIntSet->TryRemove(arrowSet, (intptr_t) arrow);
    }
    else
    {
        AArrayIntSet->TryRemove(arrow->enemy->arrowSet, (intptr_t) arrow);
    }

    ResetArrow(arrow);
}


static void ArrowActionOnComplete(TweenAction* tweenAction)
{
    ArrowOnComplete(AUserData_GetSlotPtrWithType(tweenAction->userData, 0, Arrow*));
}


static void FreezeOnEnemy(Scheduler* scheduler, float deltaSeconds)
{
    Arrow* arrow = AUserData_GetSlotPtrWithType(scheduler->userData, 0, Arrow*);

    AArrayIntSet->TryRemove(arrowSet,               (intptr_t) arrow);
    AArrayIntSet->TryAdd   (arrow->enemy->arrowSet, (intptr_t) arrow);

    float fadeTime;

    if (arrow->enemy->hp < 0)
    {
        fadeTime = 1.0f;
    }
    else
    {
        fadeTime = 3.0f;
    }

    ATweenTool->AddFadeTo     (0.0f, fadeTime)
              ->SetRelative   (false)
              ->SetUserDataPtr(0, arrow)
              ->SetOnComplete (ArrowActionOnComplete)
              ->RunActions    (arrow->sprite->drawable);

    ADrawable->ConvertToParent
    (
        arrow->sprite->drawable,
        arrow->enemy->collisionBoxDrawable
    );

    arrow->body->state = PhysicsBodyState_Freeze;
}


static void FreezeOnOther(Scheduler* scheduler, float deltaSeconds)
{
    Arrow* arrow = AUserData_GetSlotPtrWithType(scheduler->userData, 0, Arrow*);

    ATweenTool->AddFadeTo     (0.0f, 5.0f)
              ->SetRelative   (false)
              ->SetUserDataPtr(0, arrow)
              ->SetOnComplete (ArrowActionOnComplete)
              ->RunActions    (arrow->sprite->drawable);

    arrow->body->state = PhysicsBodyState_Freeze;
}



static Color tailColors[StoreWeapon_Length] =
{
    {174 / 255.0f, 161 / 255.0f, 73  / 255.0f, 1.0f},
    {211 / 255.0f, 198 / 255.0f, 186 / 255.0f, 1.0f},
    {228 / 255.0f, 202 / 255.0f, 12  / 255.0f, 1.0f},
    {216 / 255.0f, 33  / 255.0f, 123 / 255.0f, 1.0f},
    {191 / 255.0f, 192 / 255.0f, 224 / 255.0f, 1.0f},
    {51  / 255.0f, 190 / 255.0f, 193 / 255.0f, 1.0f},
    {138 / 255.0f, 104 / 255.0f, 48  / 255.0f, 1.0f},
    {182 / 255.0f, 165 / 255.0f, 155 / 255.0f, 1.0f},
    {150 / 255.0f, 152 / 255.0f, 171 / 255.0f, 1.0f},
    {69  / 255.0f, 150 / 255.0f, 49  / 255.0f, 1.0f},
};


static inline void ArrowTail(Arrow* arrow, float opacity)
{
    Color* color = tailColors + AGameData->weaponIndex;
    color->a     = opacity;

    AGLPrimitive->RenderLines
    (
        AArray_MakeWithData(arrow->tailPos, arrow->tailPosCurCount << 1),
        AGameMap->beforeDrawable->mvpMatrix,
        color,
        3.8f
    );
}



static void ArrowTailRender(Drawable *drawable)
{
    Arrow* arrow = AUserData_GetSlotPtrWithType(drawable->userData, 0, Arrow*);

    #ifdef APP_DEBUG
    AGLPrimitive->RenderPolygon
    (
        arrow->body->transformedVertexArr,
        AGameMap->beforeDrawable->mvpMatrix,
        COLOR_GREED_ARRAY,
        1.0f
    );
    #endif

    ArrowTail(arrow, arrowTailOpacity);
}


static void ArrowTailDisappearRender(Drawable *drawable)
{
    Arrow* arrow   = AUserData_GetSlotPtrWithType(drawable->userData, 0, Arrow*);
    float  opacity = AUserData_GetSlotFloat(arrow->tailDrawable->userData, 1);

    if (opacity > 0.0f)
    {
        ArrowTail(arrow, opacity);
    }
}


static void ArrowTailDisappearDraw(Drawable* tailDrawable)
{
    AUserData_AddSlotFloat(tailDrawable->userData, 1, arrowTailOpacityTime);
}


static void SetDirection(float touchX)
{
    Drawable* heroDrawable = AHero_GetDrawable();
    
    if (touchX * heroDrawable->scaleX < 0)
    {
        ADrawable_SetScaleX(heroDrawable, -heroDrawable->scaleX);
    }
}


static void OnHit(PhysicsBody* self, PhysicsBody* other, float deltaSeconds)
{
    Arrow* arrow = AUserData_GetSlotPtrWithType(self->userData,  0, Arrow*);
    Enemy* enemy = AUserData_GetSlotPtrWithType(other->userData, 0, Enemy*);

    if (arrow->hitType != ArrowHitType_Null)
    {
        return;
    }
    else if (enemy != NULL)
    {
        if
        (
            arrow->enemy                   != NULL  ||
            enemy->collisionBoxDrawable    == NULL  ||
            enemy->component->curState->id == EnemyState_DieOver
        )
        {
            return;
        }

        arrow->enemy   = enemy;
        arrow->hitType = ArrowHitType_Enemy;
        
        // need to delay processing collision
        AUserData_SetSlotPtr(AScheduler->ScheduleOnce(FreezeOnEnemy, 0)->userData, 0, arrow);
    }
    else
    {
        arrow->enemy   = NULL;
        arrow->hitType = ArrowHitType_Ground;

        // need to delay processing collision
        AUserData_SetSlotPtr(AScheduler->ScheduleOnce(FreezeOnOther, 0)->userData, 0, arrow);

        ++AHero->roundMissCount;
        AAudioTool->Play(AudioID_HurtGround);
    }

    float deform   = AMath_RandomFloat(0.12f, 0.22f);
    arrow->deformX = deform * arrow->sprite->drawable->width;
    arrow->deformU = deform * arrow->sprite->uvWidth;

    ASprite->DeformByIndex
    (
        arrow->sprite,
        
        AArray_Make
        (
            float,
            2,
            -arrow->deformX, -arrow->deformX
        ),

        AArray_Make
        (
            float,
            2,
            -arrow->deformU, -arrow->deformU
        ),

        AArray_Make
        (
            int,
            2,
            4, 6
        )
    );

    ++AHero->roundArrowCount;

    arrow->tailDrawable->Render = ArrowTailDisappearRender;
    arrow->tailDrawable->Draw   = ArrowTailDisappearDraw;
}


static void StartArrowPath(const char* arrowName, Drawable* arrowDrawable)
{
    if (isArrowPathShow == false)
    {
        isArrowPathShow = true;

        for (int i = 0; i < arrowPathCount; ++i)
        {
            SubMesh* subMesh = ADrawAtlas->GetQuad(arrowPathDrawAtlas, arrowName);
            arrowPath[i]     = subMesh;
            // move to outside screen
            ADrawable_SetPosition2(subMesh->drawable, -10.0f, -10.0f);
        }
    }

}


static void DisplayArrowPath()
{
    if (isArrowPathShow)
    {
        for (int i = 0; i < arrowPathCount; ++i)
        {
            SubMesh* subMesh = arrowPath[i];

            // simulate path
            APhysicsBody->Update(arrowPathBody, 0.07f);

            if (arrowPathBody->positionY < AGameMap->groundY)
            {
                // hide when underground
                ADrawable_SetInvisible(subMesh->drawable);
            }
            else
            {
                ADrawable_SetVisible(subMesh->drawable);

                ADrawable_SetPosition2
                (
                    subMesh->drawable,
                    arrowPathBody->positionX, arrowPathBody->positionY
                );

                ADrawable_SetRotationZ
                (
                    subMesh->drawable,
                    ADrawable->GetFlipRotationZ(subMesh->drawable, arrowPathBody->rotationZ)
                );
            }
        }
    }
}


static void ReleaseArrowPath()
{
    if (isArrowPathShow)
    {
        isArrowPathShow = false;

        for (int i = 0; i < arrowPathCount; ++i)
        {
            ADrawAtlas->ReleaseQuad(arrowPathDrawAtlas, arrowPath[i]);
        }
    }
}


static float strength;

static float touchDownX;
static float touchDownY;
static int   touchDownID    = -1;

static float touchDownPreX;
static float touchDownPreY;
static int   touchDownPreID = -1;


static void FireArrow(Component* component, bool isMultiTouch, bool isUpdateState)
{
    Arrow* arrow = AUserData_GetSlotPtrWithType(AHero->component->userData, 0, Arrow*);

    if (AHUD->CostPower(AGameData->arrowCostEnergy))
    {
        if (arrow != NULL)
        {
            if (isMultiTouch == false)
            {
                ReleaseArrowPath();
            }

            Drawable* arrowDrawable = arrow->sprite->drawable;
            AUserData_SetSlotPtr(component->userData, 0, NULL);
            ADrawable_SetScaleY (arrowDrawable, 1.0f);

            // body under beforeDrawable matrix
            ADrawable->ConvertToParent(arrowDrawable, AGameMap->beforeDrawable);

            arrow->body->rotationZ = ADrawable->GetWorldRotationZ(arrowDrawable);
            arrow->body->velocityX = AMath_Cos(arrow->body->rotationZ) * strength;
            arrow->body->velocityY = AMath_Sin(arrow->body->rotationZ) * strength;
            arrow->body->positionX = arrowDrawable->positionX;
            arrow->body->positionY = arrowDrawable->positionY;
            arrow->body->state     = PhysicsBodyState_Normal;

            if (strength > 2.0f)
            {
                AAudioTool->Play(AudioID_ShootFast);
            }
            else
            {
                AAudioTool->Play(AudioID_Shoot);
            }
        }
        else
        {
            AAudioTool->Play(AudioID_NoArrow);
        }
    }

    if (isUpdateState && AHero->component->curState->id < HeroState_Die)
    {
        if (isMultiTouch == false)
        {
            AComponent->SetState(AHero->component, HeroState_Shoot);
        }
        else
        {
            AComponent->SetState(AHero->component, HeroState_Shoot_Fast);
        }
    }
}


static void ReadyMove(Component* component, float touchX, float touchY)
{
    Arrow* arrow = AUserData_GetSlotPtrWithType(component->userData, 0, Arrow*);

    if (arrow != NULL && AHero->roundEnergy >= AGameData->arrowCostEnergy)
    {
        float     deltaX        = (touchDownX - touchX) * (AHero_GetDrawable()->scaleX > 0 ? 1 : -1);
        float     deltaY        =  touchDownY - touchY;
        Drawable* arrowDrawable =  arrow->sprite->drawable;

        ADrawable_SetRotationZ(arrowDrawable, AMath_Atan2(deltaX, deltaY));
        ADrawable_SetScaleY   (arrowDrawable, 1.0f - fabsf(deltaX) * 0.25f);

        strength = AVector2_Length2
        (
            deltaX * 1.15f * AGameData->arrowSpeed,
            deltaY * 0.75f * AGameData->arrowSpeed
        );

        arrowPathBody->rotationZ = ADrawable->GetWorldRotationZ(arrowDrawable);
        arrowPathBody->velocityX = AMath_Cos(arrowPathBody->rotationZ) * strength;
        arrowPathBody->velocityY = AMath_Sin(arrowPathBody->rotationZ) * strength;

        // body path pos under beforeDrawable matrix
        Vector2 outLocal[1];

        ADrawable->ConvertBetweenLocalPositionV2
        (
            arrowDrawable->parent,
            AVector2_Make(arrowDrawable->positionX, arrowDrawable->positionY),
            AGameMap->beforeDrawable,
            outLocal
        );

        arrowPathBody->positionX = outLocal->x;
        arrowPathBody->positionY = outLocal->y;

        DisplayArrowPath();
    }
}


static void Ready(Component* component, bool isMultiTouch)
{
    if (AHero->roundEnergy >= AGameData->arrowCostEnergy)
    {
        Arrow*      arrow     = AArrayList_Pop(arrowList, Arrow*);
        const char* arrowName = AUIStore->weaponNames[AGameData->weaponIndex];
        char        buff[22];
        sprintf(buff, "Texture/%s.png", arrowName);

        if (arrow == NULL)
        {
            arrow        = malloc(sizeof(Arrow));
            arrow->enemy = NULL;
            arrow->body  = APhysicsWorld->AddBody
                           (
                               PhysicsShape_Line,
                               AArray_Make
                               (
                                   float, 4,
                                   0.0f, 0.0f,
                                   AGLTool_ToGLWidth(20.0f), 0.0f
                               )
                           );

            APhysicsBody_SetCollisionGroup
            (
                arrow->body,
                CollisionGroup_HeroAttack | CollisionGroup_ArrowAttack
            );

            AUserData_SetSlotPtr(arrow->body->userData, 0, arrow);
            arrow->body->OnCollision = OnHit;

            ASprite->InitWithFile(buff, arrow->sprite);
            arrow->halfWidth = arrow->sprite->drawable->width / 2.6f;
        }
        else
        {
            arrow->sprite->texture = ATexture->Get(buff);
            ADrawable_SetVisible(arrow->sprite->drawable);
            ADrawable_SetScale2 (arrow->sprite->drawable, 1.0f, 1.0f);
        }

        ATool->InitBox(arrow->body, 2.0f, -2.0f);
        arrow->body->state = PhysicsBodyState_Freeze;
        ADrawable_SetParent   (arrow->sprite->drawable, AHero->bowHandDrawable);
        ADrawable_SetPosition2(arrow->sprite->drawable, AGLTool_ToGLWidth(22), 0.0f);
        ADrawable_SetOpacity  (arrow->sprite->drawable, 0.0f);

        ADrawable_SetRotationZ
        (
            arrow->sprite->drawable,
            AMath_Atan2
            (
                touchDownX * (AHero_GetDrawable()->scaleX > 0 ? 1 : -1),
                touchDownY
            )
        );

        ATweenTool->AddFadeTo  (1.0f, 0.3f)
                  ->SetEaseType(TweenEaseType_SineInOut)
                  ->RunActions (arrow->sprite->drawable);

        arrow->hitType         = ArrowHitType_Null;
        arrow->enemy           = NULL;
        arrow->tailPosCurCount = 0;
        arrow->tailPosCurTime  = 0.0f;

        ADrawable->Init       (arrow->tailDrawable);
        AUserData_SetSlotPtr  (arrow->tailDrawable->userData, 0, arrow);
        AUserData_SetSlotFloat(arrow->tailDrawable->userData, 1, arrowTailOpacity);
        arrow->tailDrawable->Render = ArrowTailRender;
        arrow->tailDrawable->Draw   = NULL;

        AUserData_SetSlotPtr(component->userData, 0, arrow);
        AArrayIntSet->TryAdd(arrowSet, (intptr_t) arrow);

        if (isMultiTouch == false)
        {
            StartArrowPath(arrowName, arrow->sprite->drawable);
        }
        else
        {
            ReadyMove(component, touchDownPreX, touchDownPreY);
        }
    }
}


static bool OnReadyMessage(Component* component, Array(InputTouch*)* touchArr)
{
    InputTouch* touch;

    if (touchArr->length == 1)
    {
        touch = AArray_Get(touchArr, 0, InputTouch*);
    }
    else
    {
        for (int i = 0; i < touchArr->length; ++i)
        {
            touch = AArray_Get(touchArr, i, InputTouch*);

            if (touch->fingerID == touchDownID && touch->type == InputTouchType_Move)
            {
                ReadyMove(component, touch->x, touch->y);
                break;
            }
        }

        return false;
    }

    switch (touch->type)
    {
        case InputTouchType_Cancel:
            break;
        
        case InputTouchType_Down:
            if (touch->fingerID != touchDownID)
            {
                // after fire arrow will use this touch
                touchDownPreID = touch->fingerID;
                touchDownPreX  = touch->x;
                touchDownPreY  = touch->y;
            }
            break;

        case InputTouchType_Move:
        {
            if (touch->fingerID == touchDownID)
            {
                ReadyMove(component, touch->x, touch->y);
            }
            break;
        }

        case InputTouchType_Up:
        {
            if (touch->fingerID == touchDownID)
            {
                FireArrow(component, false, true);

                touchDownID    = touchDownPreID;
                touchDownX     = touchDownPreX;
                touchDownY     = touchDownPreY;
                touchDownPreID = -1;
            }
            else if (touch->fingerID == touchDownPreID)
            {
                FireArrow(component, true, true);

                touchDownPreID = -1;
                ReleaseArrowPath();

                if (touchDownID != -1)
                {
                    // record touch down for call the ReadyMove()
                    touch          = AInput->GetTouch(touchDownID);
                    touchDownPreX  = touch->x;
                    touchDownPreY  = touch->y;
                }
            }
            break;
        }
    }

    return false;
}


static inline bool OnKeepMessage(Component* component, Array(InputTouch*)* touchArr)
{
    return OnReadyMessage(component, touchArr);
}


static inline bool OnDizzyMessage(Array(InputTouch*)* touchArr)
{
    InputTouch* touch = AArray_Get(touchArr, 0, InputTouch*);

    switch (touch->type)
    {
        case InputTouchType_Move:
            break;
        
        case InputTouchType_Cancel:
            break;
        
        case InputTouchType_Down:
            touchDownPreID = touchDownID;
            touchDownX     = touchDownPreX;
            touchDownY     = touchDownPreY;

            touchDownX     = touch->x;
            touchDownY     = touch->y;
            touchDownID    = touch->fingerID;
            break;

        case InputTouchType_Up:
            if (touch->fingerID == touchDownID)
            {
                touchDownID    = touchDownPreID;
                touchDownX     = touchDownPreX;
                touchDownY     = touchDownPreY;
                touchDownPreID = -1;
            }
            else if (touch->fingerID == touchDownPreID)
            {
                touchDownPreID = -1;
            }
            break;
    }
    
    return false;
}


static void WalkOrReady(float touchX)
{
    Drawable* heroDrawable = AHero_GetDrawable();

    if
    (
        (touchX < -AGLTool->screenRatio * 0.7f) ||
        (touchX >  AGLTool->screenRatio * 0.7f)
    )
    {
        SetDirection(touchX);
        AComponent->SetState(AHero->component, HeroState_Walk);
    }
    else
    {
        if
        (
            (heroDrawable->scaleX > 0 && touchX < heroDrawable->positionX) ||
            (heroDrawable->scaleX < 0 && touchX > heroDrawable->positionX)
        )
        {
            AComponent->SetState(AHero->component, HeroState_Ready);
        }
    }
}


static bool isDizzyLocked = false;


/**
 * Handle stand and walk.
 */
static bool OnStandMessage(Array(InputTouch*)* touchArr)
{
    InputTouch* touch;

    if (touchArr->length == 1)
    {
        touch = AArray_Get(touchArr, 0, InputTouch*);
    }
    else
    {
        for (int i = 0; i < touchArr->length; ++i)
        {
            touch = AArray_Get(touchArr, i, InputTouch*);

            if (touch->fingerID == touchDownID && touch->type == InputTouchType_Move)
            {
                goto DoMove;
            }
        }

        return false;
    }

    switch (touch->type)
    {
        case InputTouchType_Cancel:
            break;  
        
        case InputTouchType_Down:
        {
            WalkOrReady(touch->x);

            touchDownPreID = touchDownID;
            touchDownPreX  = touchDownX;
            touchDownPreY  = touchDownY;

            touchDownX     = touch->x;
            touchDownY     = touch->y;
            touchDownID    = touch->fingerID;
            break;
        }

        case InputTouchType_Move:
        {
            if (touch->fingerID == touchDownID)
            {
                DoMove:
                
                if (isDizzyLocked == false)
                {
                    Drawable* heroDrawable = AHero_GetDrawable();
                    float     deltaX       = fabsf(touchDownX - touch->x);
                    float     deltaY       = touchDownY - touch->y;

                    if (deltaY > 0.08f && deltaX < 0.1f)
                    {
                        if
                        (
                            (heroDrawable->scaleX > 0 && touch->x > heroDrawable->positionX) ||
                            (heroDrawable->scaleX < 0 && touch->x < heroDrawable->positionX)
                        )
                        {
                            isDizzyLocked = true;
                            AComponent->SetState(AHero->component, HeroState_Dizzy);
                        }
                    }
                    else if (deltaY < 0.1f && deltaX > 0.1f)
                    {
                        ADrawable_SetScaleX (heroDrawable,    -heroDrawable->scaleX);
                        AComponent->SetState(AHero->component, HeroState_Ready);
                    }
                }
            }
            break;
        }

        case InputTouchType_Up:
        {
            if (touch->fingerID == touchDownID)
            {
                // block dizzy continues trigger
                isDizzyLocked  = false;
                touchDownID    = touchDownPreID;
                touchDownX     = touchDownPreX;
                touchDownY     = touchDownPreY;
                touchDownPreID = -1;
            }
            else if (touch->fingerID == touchDownPreID)
            {
                touchDownPreID = -1;
            }
            break;
        }
    }

    return false;
}


static inline bool OnWalkMessage(Array(InputTouch*)* touchArr)
{
    InputTouch* touch = AArray_Get(touchArr, 0, InputTouch*);

    switch (touch->type)
    {
        case InputTouchType_Up:
            if (touch->fingerID == touchDownID)
            {
                isDizzyLocked  = false;
                touchDownID    = touchDownPreID;
                touchDownX     = touchDownPreX;
                touchDownY     = touchDownPreY;
                touchDownPreID = -1;

                if (touchDownID == -1)
                {
                    AComponent->SetState(AHero->component, HeroState_Stand);
                }
                else
                {
                    SetDirection(touchDownX);
                }
            }
            else if (touch->fingerID == touchDownPreID)
            {
                touchDownPreID = -1;
            }
            break;

        default:
            OnStandMessage(touchArr);
            break;
    }

    return false;
}


static void WalkUpdate(Component* component, float deltaSeconds)
{
    Update(component, deltaSeconds);

    float     speed        = AGLTool_ToGLWidth(AGameData->speed);
    float     middleSpeed  = speed       * 0.69f;
    float     backSpeed    = middleSpeed * 0.52f;
    Drawable* heroDrawable = AHero_GetDrawable();

    if (touchDownX > 0)
    {
        if (heroDrawable->positionX < 0)
        {
            ADrawable_SetPositionX(heroDrawable, heroDrawable->positionX + speed);
        }
        else if (AGameMap->maxX > AGameMap->groundPosData[4])
        {
            AGameMap->maxX -= speed;
            AGameMap->minX -= speed;

            ADrawable_SetPositionX(AGameMap->beforeDrawable, AGameMap->beforeDrawable->positionX - speed);
            ADrawable_SetPositionX(AGameMap->middleDrawable, AGameMap->middleDrawable->positionX - middleSpeed);
            ADrawable_SetPositionX(AGameMap->backDrawable,   AGameMap->backDrawable->positionX   - backSpeed);
        }
        else if (heroDrawable->positionX < AGameMap->groundPosData[4])
        {
            ADrawable_SetPositionX(heroDrawable, heroDrawable->positionX + speed);
        }
    }
    else if (touchDownX < 0)
    {
        if (heroDrawable->positionX > 0)
        {
            ADrawable_SetPositionX(heroDrawable, heroDrawable->positionX - speed);
        }
        else if (AGameMap->minX < AGameMap->groundPosData[2])
        {
            AGameMap->minX += speed;
            AGameMap->maxX += speed;

            ADrawable_SetPositionX(AGameMap->beforeDrawable, AGameMap->beforeDrawable->positionX + speed);
            ADrawable_SetPositionX(AGameMap->middleDrawable, AGameMap->middleDrawable->positionX + middleSpeed);
            ADrawable_SetPositionX(AGameMap->backDrawable,   AGameMap->backDrawable->positionX   + backSpeed);
        }
        else if (heroDrawable->positionX > AGameMap->groundPosData[2])
        {
            ADrawable_SetPositionX(heroDrawable, heroDrawable->positionX - speed);
        }
    }
}


static inline bool OnShootFastMessage(Array(InputTouch*)* touchArr)
{
    InputTouch* touch = AArray_Get(touchArr, 0, InputTouch*);

    // just check if need to clear the touch
    switch (touch->type)
    {
        case InputTouchType_Up:
            if (touch->fingerID == touchDownID)
            {
                touchDownID = -1;
                AComponent->SetState(AHero->component, HeroState_Stand);
            }
            else if (touch->fingerID == touchDownPreID)
            {
                touchDownPreID = -1;
                AComponent->SetState(AHero->component, HeroState_Stand);
            }
            break;

        default:
            break;
    }

    return false;
}


static inline bool OnHurtMessage(Array(InputTouch*)* touchArr)
{
    InputTouch* touch = AArray_Get(touchArr, 0, InputTouch*);

    // just check if need to clear the touch
    switch (touch->type)
    {
        case InputTouchType_Up:
            if (touch->fingerID == touchDownID)
            {
                touchDownID    = touchDownPreID;
                touchDownX     = touchDownPreX;
                touchDownY     = touchDownPreY;
                touchDownPreID = -1;
            }
            else if (touch->fingerID == touchDownPreID)
            {
                touchDownPreID = -1;
            }
            break;

        default:
            break;
    }

    return false;
}


static void OnActionOver(SkeletonAnimationPlayer* player)
{
    switch (AHero->component->curState->id)
    {
        case HeroState_Shoot:
            if (touchDownID != -1)
            {
                SetDirection(touchDownX);
                AComponent->SetState(AHero->component, HeroState_Walk);
            }
            else
            {
                AComponent->SetState(AHero->component, HeroState_Stand);
            }
            break;

        case HeroState_Shoot_Fast:
            AComponent->SetState(AHero->component, HeroState_Ready);
            break;

        case HeroState_Hurt:
            if (touchDownID != -1)
            {
                // keep direction unchanged
                // so not call the SetDirection
                AComponent->SetState(AHero->component, HeroState_Walk);
            }
            else
            {
                AComponent->SetState(AHero->component, HeroState_Stand);
            }
            break;

        case HeroState_Dizzy:
        {
            if (touchDownID != -1)
            {
                // if touch down when dizzy animation
                // continue the touch down effect
                WalkOrReady(touchDownX);
            }
            else
            {
                AComponent->SetState(AHero->component, HeroState_Stand);
            }

            if (AHUD->CostPower(AGameData->hitFloorCostEnergy))
            {
                ATool->ShakeWorld();

                ADrawable_SetPositionX
                (
                    ASkeletonAnimationPlayer_GetDrawable(AHero->hitFloor),
                    ADrawable->ConvertBetweenLocalPositionX
                    (
                        AGameMap->groundPosDrawable,
                        AHero_GetDrawable()->positionX,
                        AGameMap->beforeDrawable
                    )
                );

                AHero->hitFloor->loop = 1;
                AComponent->Notify(AHero->component, HeroNotify_Dizzy, NULL);

                AAudioTool->Play(AudioID_FallDown);
                AVibrator->Vibrate(100);
            }
            else
            {
                // no power hit floor, release dizzy lock
                isDizzyLocked = false;
            }
            break;
        }

        case HeroState_Ready:
            AComponent->SetState(AHero->component, HeroState_Keep);
            break;

        case HeroState_Die:
            AComponent->SetState(AHero->component, HeroState_DieOver);
            AComponent->Notify  (AHero->component, HeroNotify_Die, NULL);
            break;

        default:
            break;
    }
}


static void CurtainPlayerCallBack(SkeletonAnimationPlayer* player)
{
    for (int i = 0; i < arrowSet->elementList->size; ++i)
    {
        Arrow* arrow       = AArrayList_Get(arrowSet->elementList, i, Arrow*);
        bool   isHasAction = ATween->TryCompleteAllActions(arrow->sprite->drawable, false);

        // arrow not collision yet
        if (isHasAction == false)
        {
            arrow->body->state = PhysicsBodyState_Freeze;
            ++AHero->roundMissCount;
            ++AHero->roundArrowCount;
        }

        ResetArrow(arrow);
    }

    AArrayList->Clear(arrowSet->elementList);

    AHUD->ClearDrop();
    AUI->ShowFail  ();
}


static void OpenCurtain(Scheduler* scheduler, float deltaSeconds)
{
    AAudioTool->Play(AudioID_Over);
    AHUD->OpenCurtain(CurtainPlayerCallBack);
}


static void TombstoneActionComplete(TweenAction* action)
{
    ATweenTool->AddFadeTo  (0.0f, 1.0f)
              ->SetRelative(false)
              ->RunActions (AHero_GetDrawable());

    AHero->hitFloor->loop = 1;

    ADrawable_SetPositionX
    (
        ASkeletonAnimationPlayer_GetDrawable(AHero->hitFloor),
        ADrawable->ConvertBetweenLocalPositionX
        (
            AGameMap->groundPosDrawable,
            AHero_GetDrawable()->positionX,
            AGameMap->beforeDrawable
        )
    );

    AEnemyAI  ->SetAllEnemy (EnemyState_Stand, 0.01f);
    AScheduler->ScheduleOnce(OpenCurtain, 1.0f);

    AAudioTool->Play(AudioID_FallDown);
}


static void DieActionComplete(TweenAction* action)
{
    ADrawable_SetVisible  (AHUD->tombstoneDrawable);
    ADrawable_SetPositionX(AHUD->tombstoneDrawable, AHero_GetDrawable()->positionX);

    ATweenTool->AddMoveY
                (
                    AGameMap->groundY + AHUD->tombstoneHeight / 2,
                    0.35f
                )
              ->SetEaseType  (TweenEaseType_ExponentialIn)
              ->SetRelative  (false)
              ->SetOnComplete(TombstoneActionComplete)
              ->RunActions   (AHUD->tombstoneDrawable);
}


static void OnHurt(PhysicsBody* self, PhysicsBody* other, float deltaSeconds)
{
    if
    (
        other->userID                  >= CollisionBodyID_Heart &&
        other->userID                  <= CollisionBodyID_Wood  &&
        AHero->component->curState->id <  HeroState_Die
    )
    {
        AHUD->FlyItem(AUserData_GetSlotPtrWithType(other->userData, 0, DropCollisionItem*));
        return;
    }

    if (AHero->component->curState->id < HeroState_Hurt && isDizzyLocked == false)
    {
        // fire arrow if needed
        FireArrow(AHero->component, false, false);

        Enemy* enemy = AUserData_GetSlotPtrWithType(other->userData, 0, Enemy*);

        if (enemy->component->curState->id >= EnemyState_Dizzy)
        {
            return;
        }

        float move;
        if (AEnemy_GetDrawable(enemy)->scaleX > 0.0f)
        {
            move = -0.08f;
        }
        else
        {
            move =  0.08f;
        }

        --AHero->roundHP;
        AFont->SetInt(AHUD->heartText, AHero->roundHP);

        if (AHero->roundHP > 0)
        {
            AComponent->SetState(AHero->component, HeroState_Hurt);

            ATweenTool->AddMoveX   (move, 0.3f)
                      ->SetEaseType(TweenEaseType_SineOut)
                      ->SetQueue   (false)

                      ->AddMoveY   (0.015f,  0.1f)
                      ->SetEaseType(TweenEaseType_SineOut)

                      ->AddMoveY   (-0.015f, 0.1f)
                      ->SetEaseType(TweenEaseType_SineOut)

                      ->RunActions (AHero_GetDrawable());
        }
        else
        {
            AComponent->SetState(AHero->component, HeroState_Die);

            ATweenTool->AddMoveX     (move * 2, 1.25f)
                      ->SetEaseType  (TweenEaseType_SineOut)
                      ->SetQueue     (false)
                      ->SetOnComplete(DieActionComplete)

                      ->AddMoveY     (0.02f,  0.15f)
                      ->SetEaseType  (TweenEaseType_SineOut)

                      ->AddMoveY     (-0.02f,  0.15f)
                      ->SetEaseType  (TweenEaseType_SineOut)

                      ->RunActions   (AHero_GetDrawable());
        }
    }
}


static bool OnMessage(Component* component, void* sender, int subject, void* extraData)
{
    if (sender == AApplication) // touch event
    {
        Array(InputTouch*)* touchArr = extraData;

        switch (component->curState->id)
        {
            case HeroState_Stand:
                OnStandMessage(touchArr);
                break;

            case HeroState_Walk:
                OnWalkMessage(touchArr);
                break;

            case HeroState_Ready:
                OnReadyMessage(component, touchArr);
                break;

            case HeroState_Keep:
                OnKeepMessage(component, touchArr);
                break;

            case HeroState_Shoot:
                OnStandMessage(touchArr);
                break;

            case HeroState_Shoot_Fast:
                OnShootFastMessage(touchArr);
                break;

            case HeroState_Dizzy:
                OnDizzyMessage(touchArr);
                break;

            case HeroState_Hurt:
                OnHurtMessage(touchArr);
                break;

            default:
                break;
        }
    }
    else if (sender == AComponent)  // Component msg
    {
        switch (subject)
        {
            case ComponentMsg_OnEnter:
            {
                switch (component->curState->id)
                {
                    case HeroState_Stand:
                        if (component->preState->id == HeroState_Walk || component->preState->id == HeroState_Shoot_Fast)
                        {
                            ASkeletonAnimationPlayer->SetAnimationMix(AHero->player, "stand", 0.2f);
                        }
                        else
                        {
                            ASkeletonAnimationPlayer->SetAnimation(AHero->player, "stand");
                        }
                        break;

                    case HeroState_Walk:
                        ASkeletonAnimationPlayer->SetAnimationMix(AHero->player, "walk", 0.1f);
                        break;

                    case HeroState_Shoot:
                        ASkeletonAnimationPlayer->SetAnimation(AHero->player, "shoot");
                        break;

                    case HeroState_Shoot_Fast:
                        ASkeletonAnimationPlayer->SetAnimation(AHero->player, "shoot_fast");
                        break;

                    case HeroState_Ready:
                        ASkeletonAnimationPlayer->SetAnimation(AHero->player, "ready");
                        
                        if (component->preState->id != HeroState_Shoot_Fast)
                        {
                            Ready(component, false);
                        }
                        else
                        {
                            Ready(component, true);
                        }
                        break;

                    case HeroState_Keep:
                        ASkeletonAnimationPlayer->SetAnimation(AHero->player, "keep");
                        break;

                    case HeroState_Hurt:
                        AAudioTool->Play(AudioID_HurtHero);
                        AVibrator->Vibrate(50);
                        ASkeletonAnimationPlayer->SetAnimation(AHero->player, "hurt");
                        break;

                    case HeroState_Dizzy:
                        ASkeletonAnimationPlayer->SetAnimation(AHero->player, "dizzy");
                        break;

                    case HeroState_Die:
                        AAudioTool->Play(AudioID_HeroDie);
                        AVibrator->Vibrate(50);
                        ASkeletonAnimationPlayer->SetAnimation(AHero->player, "die");
                        break;

                    case HeroState_DieOver:
                        ASkeletonAnimationPlayer->SetAnimation(AHero->player, "die_over");
                        break;

                    default:
                        break;
                }
            }
            break;

            default:
                break;
        }
    }

    return false;
}


static inline void InitProperty()
{
    AHero->roundHP         = (int) AGameData->maxHP; // for compatible with archived data, maxHP cannot use int
    AHero->roundEnergy     = AGameData->maxEnergy;

    AHero->roundKillCount  = 0;
    AHero->roundArrowCount = 0;
    AHero->roundMissCount  = 0;
    AHero->roundScore      = 0;
    AHero->roundTime       = 0.0f;

    AGameData->dressIndex  = AMath_RandomInt(0, StoreDress_Length  - 1);
    AGameData->weaponIndex = AMath_RandomInt(0, StoreWeapon_Length - 1);

    char buff[20];
    sprintf(buff, "%s%s", AUIStore->dressNames[AGameData->dressIndex], AUIStore->weaponNames[AGameData->weaponIndex]);
    ASkeleton->SetSkin(AHero->player->skeleton, buff);
}


static void Init()
{
    AComponent->Init(AHero->component);
    ASkeletonAnimationPlayer->Init("Animation/redgirl", "stand", AHero->player);

    Drawable* heroDrawable = AHero_GetDrawable();
    ADrawable_SetParent   (heroDrawable, AGameMap->beforeDrawable);
    ADrawable_SetPositionY(heroDrawable, AGameMap->groundY);

    SkeletonSlot* collisionSlot = ASkeletonAnimationPlayer_GetSlot(AHero->player, "CollisionBox");
    if (collisionSlot != NULL)
    {
        AHero->collisionBoxDrawable          = collisionSlot->bone->drawable;
        AHero->collisionBoxBody              = APhysicsWorld->AddBody
                                               (
                                                   PhysicsShape_Polygon,
                                                   ASkeletonSlot_GetBoundingBox(collisionSlot)->vertexArr
                                               );
        AHero->collisionBoxBody->OnCollision = OnHurt;
        AHero->collisionBoxBody->state       = PhysicsBodyState_Fixed;
        APhysicsBody_SetCollisionGroup
        (
            AHero->collisionBoxBody,
            CollisionGroup_HeroBody | CollisionGroup_HeroAttack | CollisionGroup_EnemyBody
        );

        #ifdef APP_DEBUG
        ASkeletonAnimationPlayer->InitSlotBoundingBoxDrawable
        (
            AHero->player,
            "CollisionBox",
            debugCollisionBoundingBox
        );
        #endif
    }

    AHero->bowHandDrawable      = ASkeletonAnimationPlayer_GetBone(AHero->player, "righthand-up")->drawable;
    AHero->player->OnActionOver = OnActionOver;

    ASkeletonAnimationPlayer->Init("Animation/hit-floor", "animation", AHero->hitFloor);
    AHero->hitFloor->loop       = 0;

    Drawable* hitFloorDrawable = ASkeletonAnimationPlayer_GetDrawable(AHero->hitFloor);
    ADrawable_SetParent   (hitFloorDrawable, AGameMap->beforeDrawable);
    ADrawable_SetPositionY(hitFloorDrawable, AGameMap->groundY);

    AHero->component->stateMap->elementList->increase = 10;

    AComponent->AddState(AHero->component, HeroState_Stand,      OnMessage, Update);
    AComponent->AddState(AHero->component, HeroState_Walk,       OnMessage, WalkUpdate);
    AComponent->AddState(AHero->component, HeroState_Shoot,      OnMessage, Update);
    AComponent->AddState(AHero->component, HeroState_Shoot_Fast, OnMessage, Update);
    AComponent->AddState(AHero->component, HeroState_Ready,      OnMessage, Update);
    AComponent->AddState(AHero->component, HeroState_Keep,       OnMessage, Update);
    AComponent->AddState(AHero->component, HeroState_Hurt,       OnMessage, Update);
    AComponent->AddState(AHero->component, HeroState_Dizzy,      OnMessage, Update);
    AComponent->AddState(AHero->component, HeroState_Die,        OnMessage, Update);
    AComponent->AddState(AHero->component, HeroState_DieOver,    OnMessage, Update);

    AComponent->SetState(AHero->component, HeroState_Stand);

    arrowPathDrawAtlas = ADrawAtlas->Get("Texture/Arrow.atlas");
    // all bodies under beforeDrawable matrix
    ADrawable_SetParent(arrowPathDrawAtlas->mesh->drawable, AGameMap->beforeDrawable);

    AHero->roundCount = 0;
}


static void Revive()
{
    InitProperty();

    ADrawable_SetParent   (ASkeletonAnimationPlayer_GetDrawable(AHero->hitFloor), AGameMap->beforeDrawable);
    ADrawable_SetPositionY(ASkeletonAnimationPlayer_GetDrawable(AHero->hitFloor), AGameMap->groundY);

    ADrawable_SetParent   (AHero_GetDrawable(),      AGameMap->beforeDrawable);
    ADrawable_SetPositionY(AHero_GetDrawable(),      AGameMap->groundY);
    ADrawable_SetPositionX(AHero_GetDrawable(),      0.0f);   
    ADrawable_SetOpacity  (AHero_GetDrawable(),      1.0f);

    ADrawable_SetPositionX(AGameMap->beforeDrawable, 0.0f);
    ADrawable_SetPositionX(AGameMap->middleDrawable, 0.0f);
    ADrawable_SetPositionX(AGameMap->backDrawable,   0.0f);

    ADrawable_SetInvisible(AHUD->tombstoneDrawable);
    ADrawable_SetPositionY(AHUD->tombstoneDrawable,  AHUD->tombstoneBornY);

    ADrawable_SetParent(arrowPathDrawAtlas->mesh->drawable, AGameMap->beforeDrawable);

    AGameMap->minX = AGameMap->groundPosData[0];
    AGameMap->maxX = AGameMap->groundPosData[6];

    touchDownID    = -1;
    touchDownPreID = -1;

    AComponent->SetState(AHero->component, HeroState_Stand);
}


static void Run()
{
    AApplication_AddChild(AHero->component, 60);
    AArrayIntSet->Clear(AHero->component->observerSet);
    InitProperty();
}


static void TalkTextTweenActionOnComplete(TweenAction* tweenAction)
{
    AFont->ReleaseText(AUserData_GetSlotPtrWithType(tweenAction->userData, 0, FontText*));
}


static void RoundScore()
{
    ++AHero->roundKillCount;
    AFont->SetInt(AHUD->killText, AHero->roundKillCount);

    int score = ((int) AHero->roundTime + AHero->roundKillCount) / (Enemy_KillIncrease + AEnemyAI->currentEnemyNum) + 1;

    AHero->roundScore += score;

    FontText* text = AFont->GetText(AGameActor->talkFont);
    char buff[12];
    sprintf(buff, "+%d", score);
    AFont->SetString(text, buff);
    AFont_SetTextColor(text, AColor_Make(0.72f, 0.99f, 0.38f, 1.0f));
    ATool->FlyTextOnHero(text, 0.045f, 3.0f);

    AHero->roundEnergy += score;
}


struct AHero AHero[1] =
{{
    .Init       = Init,
    .Run        = Run,
    .Revive     = Revive,
    .ResetArrow = ResetArrow,
    .RoundScore = RoundScore,
}};

```

`Samples/SuperLittleRed/Code/Hero.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-9-17
 * Update   : 2019-2-16
 * Author   : scott.cgi
 */


#ifndef HERO_H
#define HERO_H


#include "Engine/Extension/Spine/SkeletonAnimationPlayer.h"
#include "Engine/Physics/PhysicsBody.h"
#include "Engine/Application/Component.h"
#include "Engine/Graphics/OpenGL/Sprite.h"

#include "Enemy.h"
#include "Config.h"


enum
{
    HeroState_Stand = 1,
    HeroState_Walk,
    HeroState_Shoot,
    HeroState_Shoot_Fast,
    HeroState_Ready,
    HeroState_Keep,
    HeroState_Hurt,
    HeroState_Dizzy,
    HeroState_Die,
    HeroState_DieOver,
};


enum
{
    CollisionGroup_HeroBody    = 1,
    CollisionGroup_HeroAttack  = 1 << 1,
    CollisionGroup_EnemyBody   = 1 << 2,
    CollisionGroup_EnemyAttack = 1 << 3,
    CollisionGroup_ArrowAttack = 1 << 4,
};


enum
{
    CollisionBodyID_Heart,
    CollisionBodyID_Coin,
    CollisionBodyID_Stone,
    CollisionBodyID_Wood,
};


enum
{
    HeroNotify_Dizzy,
    HeroNotify_Die,
};


typedef enum
{
    ArrowHitType_Enemy,
    ArrowHitType_Ground,
    ArrowHitType_Null,
}
ArrowHitType;


enum
{
    ArrowTail_PosCount = 4,
    ArrowTail_PosLen   = ArrowTail_PosCount << 1,
};


typedef struct
{
    Sprite       sprite[1];
    PhysicsBody* body;
    Enemy*       enemy;
    ArrowHitType hitType;
    float        deformX;
    float        deformU;
    float        halfWidth;

    float        tailPos[ArrowTail_PosLen];
    int          tailPosCurCount;
    float        tailPosCurTime;
    Drawable     tailDrawable[1];
}
Arrow;


struct AHero
{
    Component               component[1];
    SkeletonAnimationPlayer player   [1];
    SkeletonAnimationPlayer hitFloor [1];

    int                     roundHP;
    int                     roundEnergy;
    int                     roundKillCount;
    int                     roundArrowCount;
    int                     roundMissCount;
    int                     roundCount;
    int                     roundScore;
    float                   roundTime;

    Drawable*               bowHandDrawable;
    PhysicsBody*            collisionBoxBody;
    Drawable*               collisionBoxDrawable;

    void (*Init)      (void);
    void (*Run)       (void);
    void (*Revive)    (void);
    void (*ResetArrow)(Arrow* arrow);
    void (*RoundScore)(void);
};


extern struct AHero AHero[1];


static inline Drawable* AHero_GetDrawable()
{
    return ASkeletonAnimationPlayer_GetDrawable(AHero->player);
}


#endif

```

`Samples/SuperLittleRed/Code/Tool.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-4-26
 * Update   : 2019-2-17
 * Author   : scott.cgi
 */


#include <stdio.h>
#include <string.h>

#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Toolkit/Utils/TweenTool.h"

#include "Tool.h"
#include "GameMap.h"
#include "HUD.h"


static void UpdateBox(PhysicsBody* body, Drawable* drawable)
{
    float* vertexData = body->vertexArr->data;
    float* posData    = body->transformedVertexArr->data;

    for (int i = 0; i < body->vertexArr->length; i += 2)
    {
        Vector2 world[1];

        ADrawable->ConvertBetweenLocalPositionV2
        (
            drawable,
            (Vector2*) (vertexData + i),
            AGameMap->beforeDrawable,
            world
        );

        posData[i]     = world->x;
        posData[i + 1] = world->y;
    }
}


static void InitBox(PhysicsBody* body, float x, float y)
{
    float* posData = body->transformedVertexArr->data;

    for (int i = 0; i < body->transformedVertexArr->length; i += 2)
    {
        posData[i]     += x;
        posData[i + 1] += y;
    }
}


static void ShakeX(Drawable* drawable)
{
    ATweenTool->AddMoveX   (-0.005f, 0.05f)
              ->SetEaseType(TweenEaseType_SineOut)

              ->AddMoveX   (0.01f, 0.08f)
              ->SetEaseType(TweenEaseType_SineOut)

              ->AddMoveX   (-0.008f, 0.12f)
              ->SetEaseType(TweenEaseType_SineOut)

              ->AddMoveX   (0.005f, 0.18f)
              ->SetEaseType(TweenEaseType_SineOut)

              ->AddMoveX   (-0.002f, 0.25f)
              ->SetEaseType(TweenEaseType_SineOut)

              ->RunActions (drawable);
}


static void ShakeZActionOnComplete(TweenAction* action)
{
    ATool->ShakeZ(AUserData_GetSlotPtrWithType(action->userData, 0, Drawable*));
}


static void ShakeZ(Drawable* drawable)
{
    ATweenTool->AddRotateZ    (90.0f, 0.8f)
              ->SetRelative   (false)
              ->SetEaseType   (TweenEaseType_SineInOut)

              ->AddRotateZ    (0.0f,  0.8f)
              ->SetRelative   (false)
              ->SetUserDataPtr(0, drawable)
              ->SetOnComplete (ShakeZActionOnComplete)
              ->SetEaseType   (TweenEaseType_SineInOut)

              ->RunActions    (drawable);
}


static void ScaleActionOnComplete(TweenAction* action)
{
    ATool->Scale2(AUserData_GetSlotPtrWithType(action->userData, 0, Drawable*));
}


static void Scale2(Drawable* drawable)
{
    ATweenTool->AddScaleSame2 (0.8f, 0.5f, false, TweenEaseType_SineInOut)
              ->AddScaleSame2 (1.0f, 0.5f, false, TweenEaseType_SineInOut)
              ->SetOnComplete (ScaleActionOnComplete)
              ->SetUserDataPtr(0, drawable)
              ->RunActions    (drawable);
}


static void SetTimeToBuff(char buff[], int seconds)
{
    int min = seconds / 60;
    int sec = seconds % 60;
    sprintf(buff, "%02d:%02d", min, sec);
}


// the number bigger the tail longer
static const float arrowTailPosTime = 0.018f;


static void UpdateArrowTail(Arrow* arrow, float deltaSeconds)
{
    // add tail pos
    if (arrow->tailPosCurTime >= arrowTailPosTime)
    {
        arrow->tailPosCurTime = 0;

        if (arrow->tailPosCurCount == ArrowTail_PosCount)
        {
            // from and to overlap so cannot use memcpy
            memmove(arrow->tailPos + 2, arrow->tailPos, (ArrowTail_PosLen - 2) * sizeof(float));
        }
        else
        {
            // from and to overlap so cannot use memcpy
            memmove
            (
                arrow->tailPos + 2,
                arrow->tailPos,
                (arrow->tailPosCurCount << 1) * sizeof(float)
            );
            ++arrow->tailPosCurCount;
        }

        arrow->tailPos[0] = arrow->body->positionX - arrow->halfWidth * AMath_Cos(arrow->body->rotationZ);
        arrow->tailPos[1] = arrow->body->positionY - arrow->halfWidth * AMath_Sin(arrow->body->rotationZ);
    }

    arrow->tailPosCurTime += deltaSeconds;
}


static void ShakeWorld()
{
    ATweenTool->AddMoveY   (0.01f, 0.1f)
              ->SetEaseType(TweenEaseType_SineInOut)

              ->AddMoveY   (-0.01f, 0.2f)
              ->SetEaseType(TweenEaseType_BounceOut)

              ->RunActions (AHero_GetDrawable());


    ATweenTool->AddMoveY   (-0.01f, 0.1f)
              ->SetEaseType(TweenEaseType_SineInOut)

              ->AddMoveY   (0.01f, 0.1f)
              ->SetEaseType(TweenEaseType_SineInOut)
              ->RunActions (AGameMap->beforeDrawable);


    ATweenTool->AddInterval(0.04f)

              ->AddMoveY   (-0.01f, 0.15f)
              ->SetEaseType(TweenEaseType_SineInOut)

              ->AddMoveY   (0.01f, 0.1f)
              ->SetEaseType(TweenEaseType_SineInOut)

              ->RunActions (AGameMap->middleDrawable);


    ATweenTool->AddInterval(0.08f)

              ->AddMoveY   (-0.01f, 0.2f)
              ->SetEaseType(TweenEaseType_SineInOut)

              ->AddMoveY   (0.01f, 0.1f)
              ->SetEaseType(TweenEaseType_BounceOut)

              ->RunActions (AGameMap->backDrawable);


    ATweenTool->AddInterval(0.1f)

              ->AddMoveY   (-0.01f, 0.25f)
              ->SetEaseType(TweenEaseType_SineInOut)

              ->AddMoveY   (0.01f, 0.1f)
              ->SetEaseType(TweenEaseType_SineInOut)

              ->RunActions (AGameMap->skyDrawable);


    ATweenTool->AddMoveY   (0.0015f, 0.2f)
              ->SetEaseType(TweenEaseType_SineOut)

              ->AddMoveY   (-0.0015f, 0.2f)
              ->SetEaseType(TweenEaseType_SineIn)

              ->RunActions (AHUD->upDrawable);


    ATweenTool->AddMoveY   (-0.002f, 0.2f)
              ->SetEaseType(TweenEaseType_SineOut)

              ->AddMoveY   (0.002f, 0.2f)
              ->SetEaseType(TweenEaseType_SineIn)

              ->RunActions (AHUD->downDrawable);
}


static void TalkTextTweenActionOnComplete(TweenAction* tweenAction)
{
    AFont->ReleaseText(AUserData_GetSlotPtrWithType(tweenAction->userData, 0, FontText*));
}


static void FlyTextOnHero(FontText* text, float y, float duration)
{
    ADrawable_SetParent(text->drawable, AGameMap->beforeDrawable);

    ADrawable_SetPosition2
    (
        text->drawable,
        ADrawable->ConvertBetweenLocalPositionX
        (
            AGameMap->groundPosDrawable,
            AHero_GetDrawable()->positionX - text->drawable->width / 2,
            AGameMap->beforeDrawable
        ),
        AHero_GetDrawable()->positionY + ASkeletonAnimationPlayer_GetHeight(AHero->player)
    );

    ATweenTool->AddAction     ()
              ->SetFadeTo     (0.0f)
              ->SetRelative   (false)
              ->SetEaseType   (TweenEaseType_ExponentialOut)
              ->SetMoveY      (y)
              ->SetEaseType   (TweenEaseType_ExponentialOut)
              ->SetDuration   (duration)
              ->SetOnComplete (TalkTextTweenActionOnComplete)
              ->SetUserDataPtr(0, text)
              ->RunActions    (text->drawable);
}


struct ATool ATool[1] =
{{
    1.0f,
    1.0f,
    LanguageCode_en,

    UpdateBox,
    InitBox,

    ShakeX,
    ShakeZ,
    Scale2,
    ShakeWorld,
    
    SetTimeToBuff,
    UpdateArrowTail,
    FlyTextOnHero,
}};

```

`Samples/SuperLittleRed/Code/Tool.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2015-4-26
 * Update   : 2019-2-17
 * Author   : scott.cgi
 */


#ifndef TOOL_H
#define TOOL_H


#include "Engine/Extension/Font.h"
#include "Engine/Graphics/Draw/Drawable.h"
#include "Engine/Physics/PhysicsBody.h"
#include "Hero.h"


typedef enum
{
    LanguageCode_zh,
    LanguageCode_en
}
LanguageCode;


struct ATool
{
    float        globalScaleX;
    float        globalScaleY;
    LanguageCode languageCode;

    void (*UpdateBox)      (PhysicsBody* body, Drawable* drawable);
    void (*InitBox)        (PhysicsBody* body, float x,  float y);

    void (*ShakeX)         (Drawable*    drawable);
    void (*ShakeZ)         (Drawable*    drawable);
    void (*Scale2)         (Drawable*    drawable);
    void (*ShakeWorld)     (void);

    void (*SetTimeToBuff)  (char      buff[], int   seconds);
    void (*UpdateArrowTail)(Arrow*    arrow,  float deltaSeconds);
    void (*FlyTextOnHero)  (FontText* text,   float y, float duration);
};


extern struct ATool ATool[1];


#endif

```

`Samples/SuperLittleRed/Code/UI.c`:

```c
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-12-20
 * Update   : 2019-2-17
 * Author   : scott.cgi
 */


#include <stdio.h>

#include "Engine/Application/Platform/Vibrator.h"
#include "Engine/Toolkit/Platform/Log.h"
#include "Engine/Extension/DrawAtlas.h"
#include "Engine/Application/Input.h"
#include "Engine/Application/Scheduler.h"
#include "Engine/Application/Application.h"
#include "Engine/Extension/Font.h"
#include "Engine/Extension/Spine/SkeletonBone.h"
#include "Engine/Extension/Spine/SkeletonSlot.h"
#include "Engine/Toolkit/Utils/TweenTool.h"
#include "Engine/Toolkit/HeaderUtils/Rect.h"
#include "Engine/Toolkit/Utils/Coroutine.h"
#include "Engine/Toolkit/HeaderUtils/UserData.h"
#include "Engine/Graphics/OpenGL/GLTool.h"
#include "Engine/Graphics/OpenGL/SubMesh.h"

#include "UI.h"
#include "Tool.h"
#include "HUD.h"
#include "Hero.h"
#include "EnemyAI.h"
#include "GameMap.h"
#include "GameActor.h"
#include "GameData.h"
#include "AudioTool.h"
#include "ADTool.h"


enum
{
    Fail_Again,
    Fail_Menu,

    Menu_Start,
    Menu_Record,
    Menu_Tutorial,

    HUD_StoneLeft,
    HUD_WoodLeft,
    HUD_StoneRight,
    HUD_WoodRight,

    Record_Close,
    Tutorial_Close,
};

enum
{
    ItemCount_Fail      = 2,
    ItemCount_Menu      = 3,
    ItemCount_HUD       = 4,
    ItemCount_Record    = 1,
    ItemCount_Tutorial  = 1,
    ItemCount_Language  = 4,
};


static Font*                    numFont;
static Font*                    talkFont;
static SkeletonAnimationPlayer* curPlayer         = NULL;
static SkeletonAnimationPlayer* prePlayer         = NULL;

static int                      curSelectBox      = -1;
static Drawable*                curUIDrawable     = NULL;
static FontText*                coinNumText       = NULL;

static ArrayList(FontText*)     uiTextList[1]     = AArrayList_Init(FontText*, 10);


static void Update(Component* component, float deltaSeconds)
{
    if (prePlayer != NULL)
    {
        ASkeletonAnimationPlayer_Update(prePlayer, deltaSeconds);
    }

    if (curPlayer != NULL)
    {
        ASkeletonAnimationPlayer_Update(curPlayer, deltaSeconds);
    }

    AFont->Draw(numFont);
    AFont->Draw(talkFont);
}


static bool inline TestBox(const char* slotName, float x, float y)
{
    SkeletonSlot* boxSlot = ASkeletonAnimationPlayer_GetSlot(curPlayer, slotName);
    float*        box     = (float*) ASkeletonSlot_GetBoundingBox(boxSlot)->vertexArr->data;
    Rect          rect[1];

    ADrawable->ConvertToWorldPositionV2(boxSlot->bone->drawable, (Vector2*)  box,      (Vector2*)           rect     );
    ADrawable->ConvertToWorldPositionV2(boxSlot->bone->drawable, (Vector2*) (box + 4), (Vector2*) ((float*) rect + 2));

    return ARect_TestPoint(rect, x, y);
}


static void inline ShowUI(SkeletonAnimationPlayer* player, TweenEaseType easeType, TweenActionOnComplete OnComplete)
{
    curPlayer = player;

    ADrawable_SetScale2
    (
        ASkeletonAnimationPlayer_GetDrawable(curPlayer),
        ATool->globalScaleX,
        ATool->globalScaleY
    );

    Drawable* drawable = ASkeletonAnimationPlayer_GetDrawable(curPlayer);

    ADrawable_SetPositionY
    (
        drawable,
        1.0f + ASkeletonAnimationPlayer_GetHeight(curPlayer) * drawable->scaleY / 2
    );

    ATweenTool->AddMoveY     (0.0f, GOLDEN_RATIO)
              ->SetEaseType  (easeType)
              ->SetRelative  (false)
              ->SetOnComplete(OnComplete)
              ->RunActions   (drawable);

    if (prePlayer != NULL)
    {
        ATweenTool->AddFadeTo  (0.0f, 0.25f)
                  ->SetEaseType(TweenEaseType_SineInOut)
                  ->SetRelative(false)
                  ->RunActions (ASkeletonAnimationPlayer_GetDrawable(prePlayer));
    }
}


static void inline CloseUI()
{
    for (int i = 0; i < uiTextList->size; ++i)
    {
        AFont->ReleaseText(AArrayList_Get(uiTextList, i, FontText*));
    }

    AArrayList->Clear(uiTextList);

    curPlayer     = NULL;
    curUIDrawable = NULL;
    curSelectBox  = -1;
}


/**
 * If attachmentNames NULL, will use slotName as attachmentName.
 */
static bool inline ClickUI
(
    const char* boneNames[],
    const char* slotNames[],
    const char* attachmentNames[],
    const int   selectBox[],
    int         length,
    InputTouch* touch
)
{
    const char* boneName = NULL;

    for (int i = 0; i < length; ++i)
    {
        // check SubMesh has same name with bone
        const char* name    = boneNames[i];
        SubMesh*    subMesh;

        if (attachmentNames == NULL)
        {
            subMesh = ASkeletonAnimationPlayer_GetSubMesh(curPlayer, name, name);
        }
        else
        {
            subMesh = ASkeletonAnimationPlayer_GetSubMesh(curPlayer, name, attachmentNames[i]);
        }

        if (subMesh != NULL && (ADrawable_CheckVisible(subMesh->drawable) == false))
        {
            continue;
        }

        if (TestBox(slotNames[i], touch->x, touch->y))
        {
            boneName     = name;
            curSelectBox = selectBox[i];
            break;
        }
    }

    if (boneName == NULL)
    {
        curSelectBox  = -1;
        curUIDrawable = NULL;
        return false;
    }
    else
    {
        curUIDrawable = ASkeletonAnimationPlayer_GetBone(curPlayer, boneName)->drawable;
        ATweenTool->AddScaleSame2(1.11f, 0.1f, false, TweenEaseType_SineInOut)
                  ->RunActions   (curUIDrawable);

        return true;
    }
}


static void inline CloseUITween(TweenActionOnComplete OnComplete)
{
    Drawable* drawable = ASkeletonAnimationPlayer_GetDrawable(curPlayer);

    ATweenTool->AddScaleSame2(0.0f, 0.5f, false, TweenEaseType_BackOut)
              ->SetOnComplete(OnComplete)
              ->RunActions   (drawable);

    if (OnComplete == NULL)
    {
        CloseUI();
    }

    if (prePlayer != NULL)
    {
        ATweenTool->AddFadeTo  (1.0f, GOLDEN_RATIO)
                  ->SetRelative(false)
                  ->SetEaseType(TweenEaseType_SineInOut)
                  ->RunActions (ASkeletonAnimationPlayer_GetDrawable(prePlayer));
    }
}


static void CostActionOnComplete(TweenAction* action)
{
    AFont->ReleaseText(AUserData_GetSlotPtrWithType(action->userData, 0, FontText*));
}


static inline void AddFontText(char* boneName, int num, bool isTime)
{
    FontText* text = AFont->GetText(numFont);
    AArrayList_Add(uiTextList, text);

    ADrawable_SetParent
    (
        text->drawable,
        ASkeletonAnimationPlayer_GetBone(curPlayer, boneName)->drawable
    );

    if (isTime)
    {
        char buff[10];
        ATool->SetTimeToBuff(buff, num);
        AFont->SetString    (text, buff);
    }
    else
    {
        AFont->SetInt(text, num);
    }

    ADrawable_SetScaleSame2(text->drawable, 1.2f);
    ADrawable_SetPositionX (text->drawable, -text->drawable->width / 2);
}


static void FailCloseOnComplete(TweenAction* action)
{
    CloseUI();

    AGameMap->RandomMap();

    AHUD->CloseCurtain(NULL);
    AEnemyAI->Restart();
    AHero->Revive();

    // reset outside screen
    ASkeleton->ResetBones(AHUD->hudPlayer->skeleton);

    AADTool->Hide(ADType_Banner);
}


static void StartRunGame(Coroutine* coroutine)
{
    ACoroutine_Begin();

    AGameMap->Run();
    ACoroutine_YieldSeconds(0.2f);
    AHUD->CloseCurtain(NULL);
    AHero->Run();
    AGameActor->Run();
    AEnemyAI->Run();

    ACoroutine_End();
}


static void MenuCloseOnComplete(TweenAction* action)
{
    CloseUI();

    static bool isFirst = true;

    if (isFirst)
    {
        isFirst = false;
        ACoroutine->StartCoroutine(StartRunGame);
    }
    else
    {
        FailCloseOnComplete(NULL);
    }
}


static void StoreCloseOnComplete(TweenAction* action)
{
    curUIDrawable = NULL;
    curSelectBox  = -1;
    curPlayer     = prePlayer;
    prePlayer     = NULL;

    AFont->ReleaseText(coinNumText);
}


static void RecordCloseOnComplete(TweenAction* action)
{
    curPlayer     = NULL;
    curUIDrawable = NULL;
    curSelectBox  = -1;
    curPlayer     = prePlayer;
    prePlayer     = NULL;
}


static void TutorialCloseOnComplete(TweenAction* action)
{
    curPlayer     = NULL;
    curUIDrawable = NULL;
    curSelectBox  = -1;
    curPlayer     = prePlayer;
    prePlayer     = NULL;
}


//----------------------------------------------------------------------------------------------------------------------


static void ShowTutorial(TweenActionOnComplete OnComplete)
{
    prePlayer = curPlayer;
    ShowUI(AUI->uiTutorialPlayer, TweenEaseType_BackInElasticOut, OnComplete);
}


static void ShowAD(TweenAction* action)
{
    const int num = 3;

    if (AHero->roundCount > num - 1 && AHero->roundCount % num == 0)
    {
        AADTool->Show(ADType_Interstitial);
    }
    else
    {
        AADTool->Show(ADType_Banner);
    }
}


static void ShowTutorialScheduler(Scheduler* scheduler, float deltaSeconds)
{
    ShowTutorial(ShowAD);
}


static void ShowFail()
{
    if (AHero->roundCount > AGameData->maxRoundCount)
    {
        AGameData->maxRoundCount = AHero->roundCount;
    }

    if (AHero->roundTime > AGameData->maxRoundTime)
    {
        AGameData->maxRoundTime = AHero->roundTime;
    }

    if (AHero->roundKillCount > AGameData->maxRoundKillCount)
    {
        AGameData->maxRoundKillCount = AHero->roundKillCount;
    }

    if (AGameData->maxScore < AHero->roundScore)
    {
        AGameData->maxScore = AHero->roundScore;
    }

    const char* names[] =
    {
        "Score",
        "Kill",
        "Hit",
        "Time",
    };

    int values[] =
    {
        AHero->roundScore,
        AHero->roundKillCount,
        AHero->roundArrowCount == 0 ? 0 :
        (AHero->roundArrowCount - AHero->roundMissCount) * 100 / AHero->roundArrowCount,
    };

    for (int i = 0; i < 4; ++i)
    {
        Drawable* posDrawable = ASkeletonAnimationPlayer_GetBone(AUI->uiFailPlayer, names[i])->drawable;
        FontText* text;

        text = AFont->GetText(numFont);
        ADrawable_SetParent  (text->drawable, posDrawable);
        AArrayList_Add       (uiTextList,     text);

        switch (i)
        {
            case 2:
            {
                char buff[6];
                sprintf(buff, "%d%%", values[i]);
                AFont->SetString(text, buff);
                break;
            }

            case 3:
            {
                char buff[10];
                ATool->SetTimeToBuff(buff, (int) AHero->roundTime);
                AFont->SetString    (text, buff);
                break;
            }

            default:
                AFont->SetInt(text, values[i]);
                break;
        }
    }

    if (AHero->roundKillCount < 2)
    {
        AScheduler->ScheduleOnce(ShowTutorialScheduler, 0.5f);
        ShowUI(AUI->uiFailPlayer, TweenEaseType_BackOut, NULL);
    }
    else
    {
        ShowUI(AUI->uiFailPlayer, TweenEaseType_BackOut, ShowAD);
    }
}


static void ShowMenu()
{
    ShowUI(AUI->uiMenuPlayer, TweenEaseType_BackOut, NULL);
}


static void ShowRecord()
{
    prePlayer = curPlayer;
    ShowUI(AUI->uiRecordPlayer, TweenEaseType_BounceOut, NULL);

    AddFontText("MaxScore",           AGameData->maxScore,          false);
    AddFontText("MaxKill",            AGameData->maxRoundKillCount, false);
    AddFontText("MaxRound",           AGameData->maxRoundCount,     false);
    AddFontText("MaxRoundTime", (int) AGameData->maxRoundTime,      true);
    AddFontText("PlayGameTime",       AGameData->playGameCount,     false);
}


//----------------------------------------------------------------------------------------------------------------------


static bool OnMessage(Component* component, void* sender, int subject, void* extraData)
{
    if (sender == AApplication)
    {
        InputTouch* touch = AArray_Get((Array(InputTouch*)*) extraData, 0, InputTouch*);

        if (touch->fingerID > 0 && curPlayer == NULL)
        {
            if (touch->type == InputTouchType_Down)
            {
                // hud btn support multitouch
                goto HUDTouch;
            }
        }

        switch (touch->type)
        {
            case InputTouchType_Cancel:
                break;
            
            case InputTouchType_Move:
                break;
            
            case InputTouchType_Up:
                if (curUIDrawable != NULL)
                {
                    ATweenTool->AddScaleSame2(1.0f, 0.1f, false, TweenEaseType_SineInOut)
                              ->RunActions   (curUIDrawable);

                    switch (curSelectBox)
                    {
                        case Fail_Again:
                            CloseUITween(FailCloseOnComplete);
                            AAudioTool->Play(AudioID_ClickBtn);
                            break;

                        case Fail_Menu:
                            CloseUITween(NULL);
                            ShowMenu();
                            AAudioTool->Play(AudioID_ClickBtn);
                            break;

                        case Menu_Start:
                            CloseUITween(MenuCloseOnComplete);
                            AAudioTool->Play(AudioID_ClickBtn);
                            break;

                        case Menu_Record:
                            ShowRecord();
                            AAudioTool->Play(AudioID_ClickBtn);
                            break;

                        case Menu_Tutorial:
                            ShowTutorial(NULL);
                            AAudioTool->Play(AudioID_ClickBtn);
                            break;

                        case HUD_StoneLeft:
                        case HUD_StoneRight:
                            if (AGameData->stone > 0)
                            {
                                AHUD->DropStone();
                                AFont->SetInt(AHUD->stoneText, --AGameData->stone);
                                AAudioTool->Play(AudioID_ClickBtn);
                                AVibrator->Vibrate(100);
                            }
                            else
                            {
                                ATool->ShakeX(curUIDrawable);
                            }

                            curUIDrawable = NULL;
                            curSelectBox  = -1;
                            break;

                        case HUD_WoodLeft:
                        case HUD_WoodRight:
                            if (AGameData->wood > 0)
                            {
                                AHUD->DropWood();
                                AFont->SetInt(AHUD->woodText, --AGameData->wood);
                                AAudioTool->Play(AudioID_ClickBtn);
                                AVibrator->Vibrate(100);
                            }
                            else
                            {
                                ATool->ShakeX(curUIDrawable);
                            }

                            curUIDrawable = NULL;
                            curSelectBox  = -1;
                            break;

                        case Record_Close:
                            CloseUITween(RecordCloseOnComplete);
                            AAudioTool->Play(AudioID_ClickBtn);
                            break;

                        case Tutorial_Close:
                            CloseUITween(TutorialCloseOnComplete);
                            AAudioTool->Play(AudioID_ClickBtn);
                            break;

                        default:
                            break;
                    }

                    return true;
                }
                break;

            case InputTouchType_Down:
                if (curPlayer == AUI->uiFailPlayer)
                {
                    ClickUI
                    (
                        (const char*[ItemCount_Fail])
                        {
                            "Again",
                            "Menu",
                        },

                        (const char*[ItemCount_Fail])
                        {
                            "AgainBox",
                            "MenuBox",
                        },

                        NULL,

                        (int[ItemCount_Fail])
                        {
                            Fail_Again,
                            Fail_Menu,
                        },

                        ItemCount_Fail,
                        touch
                    );
                }
                else if (curPlayer == AUI->uiMenuPlayer)
                {
                    ClickUI
                    (
                        (const char*[ItemCount_Menu])
                        {
                            "Start",
                            "Record",
                            "Tutorial",
                        },

                        (const char*[ItemCount_Menu])
                        {
                            "StartBox",
                            "RecordBox",
                            "TutorialBox",
                        },

                        NULL,
                        
                        (int[ItemCount_Menu])
                        {
                            Menu_Start,
                            Menu_Record,
                            Menu_Tutorial,
                        },

                        ItemCount_Menu,
                        touch
                    );
                }
                else if (curPlayer == AUI->uiRecordPlayer)
                {
                    ClickUI
                    (
                        (const char*[ItemCount_Record])
                        {
                            "Close",
                        },

                        (const char*[ItemCount_Record])
                        {
                            "CloseBox",
                        },

                        NULL,

                        (int[ItemCount_Record])
                        {
                            Record_Close,
                        },
                        
                        ItemCount_Record,
                        touch
                    );
                }
                else if (curPlayer == AUI->uiTutorialPlayer)
                {
                    ClickUI
                    (
                        (const char*[ItemCount_Tutorial])
                        {
                            "Close",
                        },

                        (const char*[ItemCount_Tutorial])
                        {
                            "CloseBox",
                        },

                        NULL,

                        (int[ItemCount_Tutorial])
                        {
                            Tutorial_Close,
                        },

                        ItemCount_Tutorial,
                        touch
                    );
                }
                else // click on HUD
                {
                    HUDTouch:

                    curPlayer = AHUD->hudPlayer;

                    if
                    (
                        ClickUI
                        (
                            (const char*[ItemCount_HUD])
                            {
                                "StoneLeft",
                                "WoodLeft",
                                "StoneRight",
                                "WoodRight",
                            },

                            (const char*[ItemCount_HUD])
                            {
                                "StoneBoxLeft",
                                "WoodBoxLeft",
                                "StoneBoxRight",
                                "WoodBoxRight",
                            },

                            (const char*[ItemCount_HUD])
                            {
                                "Stone",
                                "Wood",
                                "Stone",
                                "Wood",
                            },

                            (int[ItemCount_HUD])
                            {
                                HUD_StoneLeft,
                                HUD_WoodLeft,
                                HUD_StoneRight,
                                HUD_WoodRight,
                            },
                            
                            ItemCount_HUD,
                            touch
                        )
                    )
                    {
                        return true;
                    }

                    curPlayer = NULL;
                }

                if (curPlayer != NULL)
                {
                    return true;
                }

                break;
        }
    }

    return false;
}


//----------------------------------------------------------------------------------------------------------------------


static void Init()
{
    AComponent->Init(AUI->component);
    AUI->component->curState->Update    = Update;
    AUI->component->curState->OnMessage = OnMessage;

    SkeletonAnimationPlayer* uiSkeletonPlayers[ItemCount_Language] =
    {
        AUI->uiMenuPlayer,
        AUI->uiFailPlayer,
        AUI->uiTutorialPlayer,
        AUI->uiRecordPlayer,
    };

    const char* uiSkeletonPaths[ItemCount_Language] =
    {
        "UI/UIMenu",
        "UI/UIFail",
        "UI/UITutorial",
        "UI/UIRecord",
    };

    const char* uiSkeletonPathsZH[ItemCount_Language] =
    {
        "UI/UIMenu-zh",
        "UI/UIFail-zh",
        "UI/UITutorial-zh",
        "UI/UIRecord-zh",
    };

    for (int i = 0; i < ItemCount_Language; ++i)
    {
        if (ATool->languageCode == LanguageCode_zh)
        {
            ASkeletonAnimationPlayer->Init(uiSkeletonPathsZH[i], "animation", uiSkeletonPlayers[i]);

        }
        else if (ATool->languageCode == LanguageCode_en)
        {
            ASkeletonAnimationPlayer->Init(uiSkeletonPaths[i], "animation", uiSkeletonPlayers[i]);
        }
    }

    numFont   = AFont->Get("Font/UINumber.atlas");
    talkFont  = AFont->Get("Font/TalkChar.atlas");
}


static void Run()
{
    AApplication_AddChild(AUI->component, 110);
}


struct AUI AUI[1] =
{{
    .Init     = Init,
    .Run      = Run,
    .ShowFail = ShowFail,
    .ShowMenu = ShowMenu,
}};


struct AUIStore AUIStore[1] =
{{
    .weaponNames =
    {
        "Copper",
        "Dragon",
        "Gold",
        "Heart",
        "Ice",
        "Iron",
        "Lightning",
        "Silver",
        "Steel",
        "Wood",
    },

    .weaponBoxes =
    {
        "CopperBox",
        "DragonBox",
        "GoldBox",
        "HeartBox",
        "IceBox",
        "IronBox",
        "LightningBox",
        "SilverBox",
        "SteelBox",
        "WoodBox",
    },

    .weaponIcons =
    {
        "CopperIcon",
        "DragonIcon",
        "GoldIcon",
        "HeartIcon",
        "IceIcon",
        "IronIcon",
        "LightningIcon",
        "SilverIcon",
        "SteelIcon",
        "WoodIcon",
    },

    .weaponLocks =
    {
        "CopperLock",
        "DragonLock",
        "GoldLock",
        "HeartLock",
        "IceLock",
        "IronLock",
        "LightningLock",
        "SilverLock",
        "SteelLock",
        "WoodLock",
    },

    .dressNames =
    {
        "Armour",
        "RedGirl",
        "Bunny",
        "Egypt",
        "Luffy",
        "Swan",
    },

    .dressBoxes =
    {
        "ArmourBox",
        "RedGirlBox",
        "BunnyBox",
        "EgyptBox",
        "LuffyBox",
        "SwanBox",
    },

    .dressIcons =
    {
        "ArmourIcon",
        "RedGirlIcon",
        "BunnyIcon",
        "EgyptIcon",
        "LuffyIcon",
        "SwanIcon",
    },

    .dressLocks =
    {
        "ArmourLock",
        "RedGirlLock",
        "BunnyLock",
        "EgyptLock",
        "LuffyLock",
        "SwanLock",
    },

    .propertyNames =
    {
        "Speed",
        "HP",
        "Energy",
        "EnergyRecovery",
        "DizzyDistance",
        "DizzyTime",
        "StonePower",
        "WoodTime",
        "ArrowSpeed",
        "ArrowPower",
    },

    .propertyBoxes =
    {
        "SpeedBox",
        "HPBox",
        "EnergyBox",
        "EnergyRecoveryBox",
        "DizzyDistanceBox",
        "DizzyTimeBox",
        "StonePowerBox",
        "WoodTimeBox",
        "ArrowSpeedBox",
        "ArrowPowerBox",
    },
}};

```

`Samples/SuperLittleRed/Code/UI.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2016-12-20
 * Update   : 2019-2-18
 * Author   : scott.cgi
 */


#ifndef UI_H
#define UI_H


#include "Engine/Application/Component.h"
#include "Engine/Extension/Spine/SkeletonAnimationPlayer.h"


enum
{
    StoreWeapon_Copper,
    StoreWeapon_Dragon,
    StoreWeapon_Gold,
    StoreWeapon_Heart,
    StoreWeapon_Ice,
    StoreWeapon_Iron,
    StoreWeapon_Lightning,
    StoreWeapon_Silver,
    StoreWeapon_steel,
    StoreWeapon_Wood,
    StoreWeapon_Length,
};


enum
{
    StoreDress_Armour,
    StoreDress_RedGirl,
    StoreDress_Bunny,
    StoreDress_Egypt,
    StoreDress_Luffy,
    StoreDress_Swan,
    StoreDress_Length,
};


enum
{
    StoreProperty_Speed,
    StoreProperty_HP,
    StoreProperty_Energy,
    StoreProperty_EnergyRecovery,
    StoreProperty_DizzyDistance,
    StoreProperty_DizzyTime,
    StoreProperty_StonePower,
    StoreProperty_WoodTime,
    StoreProperty_ArrowSpeed,
    StoreProperty_ArrowPower,
    StoreProperty_Length,
};


struct AUIStore
{
    const char* weaponNames  [StoreWeapon_Length];
    const char* weaponBoxes  [StoreWeapon_Length];
    const char* weaponIcons  [StoreWeapon_Length];
    const char* weaponLocks  [StoreWeapon_Length];
    const char* dressNames   [StoreDress_Length];
    const char* dressBoxes   [StoreDress_Length];
    const char* dressIcons   [StoreDress_Length];
    const char* dressLocks   [StoreDress_Length];
    const char* propertyNames[StoreProperty_Length];
    const char* propertyBoxes[StoreProperty_Length];
};


extern struct AUIStore AUIStore[1];


struct AUI
{
    Component               component       [1];
    SkeletonAnimationPlayer uiFailPlayer    [1];
    SkeletonAnimationPlayer uiMenuPlayer    [1];
    SkeletonAnimationPlayer uiRecordPlayer  [1];
    SkeletonAnimationPlayer uiTutorialPlayer[1];

    void (*Init)    (void);
    void (*Run)     (void);
    void (*ShowFail)(void);
    void (*ShowMenu)(void);
};


extern struct AUI AUI[1];


#endif

```

`Samples/SuperLittleRed/IOS/Animation/dizzy-star.atlas`:

```atlas

dizzy-star.png
size: 64,32
format: RGBA8888
filter: Linear,Linear
repeat: none
d1
  rotate: false
  xy: 2, 2
  size: 15, 16
  orig: 15, 16
  offset: 0, 0
  index: -1
s1
  rotate: false
  xy: 19, 4
  size: 15, 14
  orig: 15, 14
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/Animation/dizzy-star.json`:

```json
{
"skeleton": { "hash": "DTGc2BIg/GCGazxYgsps6iJwRnU", "spine": "3.5.14-beta", "width": 0, "height": 0 },
"bones": [
	{ "name": "root" },
	{ "name": "bone", "parent": "root", "length": 53.31 },
	{ "name": "bone2", "parent": "root", "length": 53.31 },
	{ "name": "bone3", "parent": "root", "length": 53.31 },
	{ "name": "bone4", "parent": "root", "length": 53.31 }
],
"slots": [
	{ "name": "1", "bone": "bone", "attachment": "1" },
	{ "name": "4", "bone": "bone4", "attachment": "1" },
	{ "name": "2", "bone": "bone2", "attachment": "1" },
	{ "name": "3", "bone": "bone3", "attachment": "1" }
],
"skins": {
	"default": {},
	"duck": {
		"1": {
			"1": { "name": "d1", "width": 15, "height": 16 }
		},
		"2": {
			"1": { "name": "d1", "width": 15, "height": 16 }
		},
		"3": {
			"1": { "name": "d1", "width": 15, "height": 16 }
		},
		"4": {
			"1": { "name": "d1", "width": 15, "height": 16 }
		}
	},
	"star": {
		"1": {
			"1": { "name": "s1", "rotation": -113.2, "width": 15, "height": 14 }
		},
		"2": {
			"1": { "name": "s1", "rotation": -113.2, "width": 15, "height": 14 }
		},
		"3": {
			"1": { "name": "s1", "rotation": -113.2, "width": 15, "height": 14 }
		},
		"4": {
			"1": { "name": "s1", "rotation": -113.2, "width": 15, "height": 14 }
		}
	}
},
"animations": {
	"animation": {
		"slots": {
			"1": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 0.3333, "color": "ffffffbe" },
					{ "time": 0.6667, "color": "ffffff7e" },
					{ "time": 1, "color": "ffffffbe" },
					{ "time": 1.3333, "color": "ffffffff" }
				]
			},
			"2": {
				"color": [
					{ "time": 0, "color": "ffffffbe" },
					{ "time": 0.3333, "color": "ffffff7e", "curve": "stepped" },
					{ "time": 0.6667, "color": "ffffff7e" },
					{ "time": 1, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffffbe" }
				]
			},
			"3": {
				"color": [
					{ "time": 0, "color": "ffffff7e" },
					{ "time": 0.3333, "color": "ffffffbe" },
					{ "time": 0.6667, "color": "ffffffff" },
					{ "time": 1, "color": "ffffffbe" },
					{ "time": 1.3333, "color": "ffffff7e" }
				]
			},
			"4": {
				"color": [
					{ "time": 0, "color": "ffffffbe" },
					{ "time": 0.3333, "color": "ffffffff" },
					{ "time": 0.6667, "color": "ffffffbe" },
					{ "time": 1, "color": "ffffff7e" },
					{ "time": 1.3333, "color": "ffffffbe" }
				]
			}
		},
		"bones": {
			"bone": {
				"translate": [
					{ "time": 0, "x": 0, "y": 20 },
					{ "time": 0.3333, "x": -25, "y": 20 },
					{ "time": 0.6667, "x": 0, "y": 20 },
					{ "time": 1, "x": 25, "y": 20 },
					{ "time": 1.3333, "x": 0, "y": 20 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 },
					{ "time": 0.3333, "x": 0.75, "y": 0.75 },
					{ "time": 0.6667, "x": 0.5, "y": 0.5 },
					{ "time": 1, "x": 0.75, "y": 0.75 },
					{ "time": 1.3333, "x": 1, "y": 1 }
				]
			},
			"bone2": {
				"translate": [
					{ "time": 0, "x": -25, "y": 20 },
					{ "time": 0.3333, "x": 0, "y": 20 },
					{ "time": 0.6667, "x": 25, "y": 20 },
					{ "time": 1, "x": 0, "y": 20 },
					{ "time": 1.3333, "x": -25, "y": 20 }
				],
				"scale": [
					{ "time": 0, "x": 0.75, "y": 0.75 },
					{ "time": 0.3333, "x": 0.5, "y": 0.5 },
					{ "time": 0.6667, "x": 0.75, "y": 0.75 },
					{ "time": 1, "x": 1, "y": 1 },
					{ "time": 1.3333, "x": 0.75, "y": 0.75 }
				]
			},
			"bone3": {
				"translate": [
					{ "time": 0, "x": 0, "y": 20 },
					{ "time": 0.3333, "x": 25, "y": 20 },
					{ "time": 0.6667, "x": 0, "y": 20 },
					{ "time": 1, "x": -25, "y": 20 },
					{ "time": 1.3333, "x": 0, "y": 20 }
				],
				"scale": [
					{ "time": 0, "x": 0.5, "y": 0.5 },
					{ "time": 0.3333, "x": 0.75, "y": 0.75 },
					{ "time": 0.6667, "x": 1, "y": 1 },
					{ "time": 1, "x": 0.75, "y": 0.75 },
					{ "time": 1.3333, "x": 0.5, "y": 0.5 }
				]
			},
			"bone4": {
				"translate": [
					{ "time": 0, "x": 25, "y": 20 },
					{ "time": 0.3333, "x": 0, "y": 20 },
					{ "time": 0.6667, "x": -25, "y": 20 },
					{ "time": 1, "x": 0, "y": 20 },
					{ "time": 1.3333, "x": 25, "y": 20 }
				],
				"scale": [
					{ "time": 0, "x": 0.75, "y": 0.75 },
					{ "time": 0.3333, "x": 1, "y": 1 },
					{ "time": 0.6667, "x": 0.75, "y": 0.75 },
					{ "time": 1, "x": 0.5, "y": 0.5 },
					{ "time": 1.3333, "x": 0.75, "y": 0.75 }
				]
			},
			"root": {
				"translate": [
					{ "time": 0, "x": 0, "y": -20 }
				]
			}
		},
		"drawOrder": [
			{ "time": 0 }
		]
	}
}
}
```

`Samples/SuperLittleRed/IOS/Animation/hit-floor.atlas`:

```atlas

hit-floor.png
size: 2048,128
format: RGBA8888
filter: Linear,Linear
repeat: none
1
  rotate: false
  xy: 2, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
10
  rotate: false
  xy: 518, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
11
  rotate: false
  xy: 647, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
12
  rotate: false
  xy: 647, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
13
  rotate: false
  xy: 776, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
14
  rotate: false
  xy: 776, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
15
  rotate: false
  xy: 905, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
16
  rotate: false
  xy: 905, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
17
  rotate: false
  xy: 1034, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
18
  rotate: false
  xy: 1034, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
2
  rotate: false
  xy: 2, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
3
  rotate: false
  xy: 131, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
4
  rotate: false
  xy: 131, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
5
  rotate: false
  xy: 260, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
6
  rotate: false
  xy: 260, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
7
  rotate: false
  xy: 389, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
8
  rotate: false
  xy: 389, 2
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1
9
  rotate: false
  xy: 518, 61
  size: 127, 57
  orig: 127, 57
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/Animation/hit-floor.json`:

```json
{
"skeleton": { "hash": "71kAShBrxZc5a2wcMuXv4Y2+UQo", "spine": "3.5.14-beta", "width": 0, "height": 0 },
"bones": [
	{ "name": "root" },
	{ "name": "bone", "parent": "root", "length": 40.71, "y": 28.5 }
],
"slots": [
	{ "name": "1", "bone": "bone", "attachment": "12" }
],
"skins": {
	"default": {
		"1": {
			"1": { "width": 127, "height": 57 },
			"2": { "width": 127, "height": 57 },
			"3": { "width": 127, "height": 57 },
			"4": { "width": 127, "height": 57 },
			"5": { "width": 127, "height": 57 },
			"6": { "width": 127, "height": 57 },
			"7": { "width": 127, "height": 57 },
			"8": { "width": 127, "height": 57 },
			"9": { "width": 127, "height": 57 },
			"10": { "width": 127, "height": 57 },
			"11": { "width": 127, "height": 57 },
			"12": { "width": 127, "height": 57 },
			"13": { "width": 127, "height": 57 },
			"14": { "width": 127, "height": 57 },
			"15": { "width": 127, "height": 57 },
			"16": { "width": 127, "height": 57 },
			"17": { "width": 127, "height": 57 },
			"18": { "width": 127, "height": 57 }
		}
	}
},
"animations": {
	"animation": {
		"slots": {
			"1": {
				"attachment": [
					{ "time": 0, "name": "18" },
					{ "time": 0.0333, "name": "17" },
					{ "time": 0.0667, "name": "16" },
					{ "time": 0.1, "name": "15" },
					{ "time": 0.1333, "name": "14" },
					{ "time": 0.1667, "name": "13" },
					{ "time": 0.2, "name": "12" },
					{ "time": 0.2333, "name": "11" },
					{ "time": 0.2667, "name": "10" },
					{ "time": 0.3, "name": "9" },
					{ "time": 0.3333, "name": "8" },
					{ "time": 0.3667, "name": "7" },
					{ "time": 0.4, "name": "6" },
					{ "time": 0.4333, "name": "5" },
					{ "time": 0.4667, "name": "4" },
					{ "time": 0.5, "name": "2" },
					{ "time": 0.5333, "name": "2" },
					{ "time": 0.5667, "name": "1" },
					{ "time": 0.6, "name": null }
				]
			}
		}
	}
}
}
```

`Samples/SuperLittleRed/IOS/Animation/hit.atlas`:

```atlas

hit.png
size: 1024,128
format: RGBA8888
filter: Linear,Linear
repeat: none
1
  rotate: false
  xy: 206, 79
  size: 90, 45
  orig: 90, 45
  offset: 0, 0
  index: -1
11
  rotate: false
  xy: 2, 79
  size: 100, 45
  orig: 100, 45
  offset: 0, 0
  index: -1
2
  rotate: false
  xy: 2, 23
  size: 90, 54
  orig: 90, 54
  offset: 0, 0
  index: -1
3
  rotate: false
  xy: 298, 75
  size: 90, 49
  orig: 90, 49
  offset: 0, 0
  index: -1
4
  rotate: false
  xy: 390, 78
  size: 90, 46
  orig: 90, 46
  offset: 0, 0
  index: -1
5
  rotate: false
  xy: 482, 79
  size: 90, 45
  orig: 90, 45
  offset: 0, 0
  index: -1
6
  rotate: false
  xy: 574, 82
  size: 90, 42
  orig: 90, 42
  offset: 0, 0
  index: -1
7
  rotate: false
  xy: 666, 83
  size: 90, 41
  orig: 90, 41
  offset: 0, 0
  index: -1
8
  rotate: false
  xy: 758, 84
  size: 90, 40
  orig: 90, 40
  offset: 0, 0
  index: -1
9
  rotate: false
  xy: 104, 81
  size: 100, 43
  orig: 100, 43
  offset: 0, 0
  index: -1
10
  rotate: false
  xy: 104, 81
  size: 100, 43
  orig: 100, 43
  offset: 0, 0
  index: -1
_1
  rotate: false
  xy: 912, 66
  size: 50, 58
  orig: 50, 58
  offset: 0, 0
  index: -1
_10
  rotate: false
  xy: 954, 2
  size: 50, 62
  orig: 50, 62
  offset: 0, 0
  index: -1
_11
  rotate: false
  xy: 850, 92
  size: 60, 32
  orig: 60, 32
  offset: 0, 0
  index: -1
_2
  rotate: false
  xy: 94, 22
  size: 50, 55
  orig: 50, 55
  offset: 0, 0
  index: -1
_3
  rotate: false
  xy: 146, 22
  size: 50, 57
  orig: 50, 57
  offset: 0, 0
  index: -1
_4
  rotate: false
  xy: 198, 22
  size: 50, 55
  orig: 50, 55
  offset: 0, 0
  index: -1
_5
  rotate: false
  xy: 850, 33
  size: 50, 57
  orig: 50, 57
  offset: 0, 0
  index: -1
_6
  rotate: false
  xy: 964, 66
  size: 50, 58
  orig: 50, 58
  offset: 0, 0
  index: -1
_7
  rotate: false
  xy: 902, 6
  size: 50, 58
  orig: 50, 58
  offset: 0, 0
  index: -1
_8
  rotate: false
  xy: 250, 17
  size: 50, 56
  orig: 50, 56
  offset: 0, 0
  index: -1
_9
  rotate: false
  xy: 302, 16
  size: 50, 57
  orig: 50, 57
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/Animation/hit.json`:

```json
{
"skeleton": { "hash": "ffi2g34bLa9rtLBtdmeTa8Rq0+o", "spine": "3.5.14-beta", "width": 100, "height": 45 },
"bones": [
	{ "name": "root" },
	{ "name": "bone", "parent": "root", "length": 47.17, "x": 15 }
],
"slots": [
	{ "name": "1", "bone": "bone", "attachment": "11" }
],
"skins": {
	"default": {},
	"die": {
		"1": {
			"1": { "width": 90, "height": 45 },
			"2": { "width": 90, "height": 54 },
			"3": { "width": 90, "height": 49 },
			"4": { "width": 90, "height": 46 },
			"5": { "width": 90, "height": 45 },
			"6": { "width": 90, "height": 42 },
			"7": { "width": 90, "height": 41 },
			"8": { "width": 90, "height": 40 },
			"9": { "width": 100, "height": 43 },
			"10": { "width": 100, "height": 43 },
			"11": { "width": 100, "height": 45 }
		}
	},
	"normal": {
		"1": {
			"1": { "name": "_1", "width": 50, "height": 58 },
			"2": { "name": "_2", "width": 50, "height": 55 },
			"3": { "name": "_3", "width": 50, "height": 57 },
			"4": { "name": "_4", "width": 50, "height": 55 },
			"5": { "name": "_5", "width": 50, "height": 57 },
			"6": { "name": "_6", "width": 50, "height": 58 },
			"7": { "name": "_7", "width": 50, "height": 58 },
			"8": { "name": "_8", "width": 50, "height": 56 },
			"9": { "name": "_9", "width": 50, "height": 57 },
			"10": { "name": "_10", "width": 50, "height": 62 },
			"11": { "name": "_11", "width": 60, "height": 32 }
		}
	}
},
"animations": {
	"animation": {
		"slots": {
			"1": {
				"attachment": [
					{ "time": 0, "name": "1" },
					{ "time": 0.0333, "name": "2" },
					{ "time": 0.0667, "name": "3" },
					{ "time": 0.1, "name": "4" },
					{ "time": 0.1333, "name": "5" },
					{ "time": 0.1667, "name": "6" },
					{ "time": 0.2, "name": "7" },
					{ "time": 0.2333, "name": "8" },
					{ "time": 0.3, "name": "9" },
					{ "time": 0.3667, "name": "10" },
					{ "time": 0.4333, "name": "11" },
					{ "time": 0.5, "name": null }
				]
			}
		}
	}
}
}
```

`Samples/SuperLittleRed/IOS/Animation/redgirl.atlas`:

```atlas

redgirl.png
size: 512,128
format: RGBA8888
filter: Linear,Linear
repeat: none
Copper
  rotate: false
  xy: 270, 5
  size: 25, 75
  orig: 25, 75
  offset: 0, 0
  index: -1
Dragon
  rotate: false
  xy: 105, 57
  size: 32, 69
  orig: 32, 69
  offset: 0, 0
  index: -1
Gold
  rotate: false
  xy: 2, 51
  size: 32, 75
  orig: 32, 75
  offset: 0, 0
  index: -1
Heart
  rotate: false
  xy: 379, 7
  size: 22, 74
  orig: 22, 74
  offset: 0, 0
  index: -1
Ice
  rotate: false
  xy: 36, 52
  size: 30, 74
  orig: 30, 74
  offset: 0, 0
  index: -1
Iron
  rotate: false
  xy: 183, 9
  size: 27, 75
  orig: 27, 75
  offset: 0, 0
  index: -1
Lightning
  rotate: false
  xy: 68, 57
  size: 35, 69
  orig: 35, 69
  offset: 0, 0
  index: -1
Silver
  rotate: false
  xy: 212, 4
  size: 27, 80
  orig: 27, 80
  offset: 0, 0
  index: -1
Steel
  rotate: false
  xy: 241, 5
  size: 27, 75
  orig: 27, 75
  offset: 0, 0
  index: -1
Wood
  rotate: false
  xy: 353, 8
  size: 24, 73
  orig: 24, 73
  offset: 0, 0
  index: -1
armour-body-down
  rotate: false
  xy: 297, 35
  size: 22, 17
  orig: 22, 17
  offset: 0, 0
  index: -1
armour-body-up
  rotate: false
  xy: 322, 57
  size: 19, 17
  orig: 19, 17
  offset: 0, 0
  index: -1
armour-face
  rotate: false
  xy: 201, 86
  size: 50, 40
  orig: 50, 40
  offset: 0, 0
  index: -1
armour-lefthand-down
  rotate: false
  xy: 297, 2
  size: 15, 13
  orig: 15, 13
  offset: 0, 0
  index: -1
armour-lefthand-up
  rotate: false
  xy: 497, 109
  size: 13, 17
  orig: 13, 17
  offset: 0, 0
  index: -1
armour-leftleg-down
  rotate: false
  xy: 127, 37
  size: 10, 18
  orig: 10, 18
  offset: 0, 0
  index: -1
armour-righthand-down
  rotate: false
  xy: 438, 70
  size: 12, 15
  orig: 12, 15
  offset: 0, 0
  index: -1
armour-righthand-up
  rotate: false
  xy: 403, 69
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
armour-rightleg-down
  rotate: false
  xy: 403, 13
  size: 10, 18
  orig: 10, 18
  offset: 0, 0
  index: -1
body-down
  rotate: false
  xy: 44, 30
  size: 25, 20
  orig: 25, 20
  offset: 0, 0
  index: -1
body-up
  rotate: false
  xy: 163, 30
  size: 18, 16
  orig: 18, 16
  offset: 0, 0
  index: -1
bunny-body-down
  rotate: false
  xy: 71, 38
  size: 28, 17
  orig: 28, 17
  offset: 0, 0
  index: -1
bunny-body-up
  rotate: false
  xy: 297, 17
  size: 20, 16
  orig: 20, 16
  offset: 0, 0
  index: -1
bunny-face
  rotate: false
  xy: 253, 82
  size: 50, 44
  orig: 50, 44
  offset: 0, 0
  index: -1
bunny-lefthand-down
  rotate: false
  xy: 314, 2
  size: 14, 13
  orig: 14, 13
  offset: 0, 0
  index: -1
bunny-leftleg-down
  rotate: false
  xy: 319, 17
  size: 11, 16
  orig: 11, 16
  offset: 0, 0
  index: -1
bunny-righthand-down
  rotate: false
  xy: 420, 53
  size: 11, 14
  orig: 11, 14
  offset: 0, 0
  index: -1
bunny-rightleg-down
  rotate: false
  xy: 452, 71
  size: 11, 16
  orig: 11, 16
  offset: 0, 0
  index: -1
cloak-down
  rotate: false
  xy: 139, 48
  size: 42, 36
  orig: 42, 36
  offset: 0, 0
  index: -1
cloak-up
  rotate: false
  xy: 353, 83
  size: 44, 43
  orig: 44, 43
  offset: 0, 0
  index: -1
egypt-body-down
  rotate: false
  xy: 101, 34
  size: 24, 21
  orig: 24, 21
  offset: 0, 0
  index: -1
egypt-body-up
  rotate: false
  xy: 139, 32
  size: 22, 14
  orig: 22, 14
  offset: 0, 0
  index: -1
egypt-face
  rotate: false
  xy: 399, 87
  size: 48, 39
  orig: 48, 39
  offset: 0, 0
  index: -1
egypt-leftleg-down
  rotate: false
  xy: 343, 57
  size: 8, 17
  orig: 8, 17
  offset: 0, 0
  index: -1
egypt-righthand-down
  rotate: false
  xy: 455, 55
  size: 11, 14
  orig: 11, 14
  offset: 0, 0
  index: -1
egypt-rightleg-down
  rotate: false
  xy: 321, 35
  size: 11, 17
  orig: 11, 17
  offset: 0, 0
  index: -1
face
  rotate: false
  xy: 449, 89
  size: 46, 37
  orig: 46, 37
  offset: 0, 0
  index: -1
lefthand-down
  rotate: false
  xy: 465, 72
  size: 12, 15
  orig: 12, 15
  offset: 0, 0
  index: -1
lefthand-up
  rotate: false
  xy: 334, 39
  size: 12, 16
  orig: 12, 16
  offset: 0, 0
  index: -1
leftleg-down
  rotate: false
  xy: 64, 11
  size: 9, 17
  orig: 9, 17
  offset: 0, 0
  index: -1
leftleg-up
  rotate: false
  xy: 433, 53
  size: 9, 15
  orig: 9, 15
  offset: 0, 0
  index: -1
luffy-body-down
  rotate: false
  xy: 2, 8
  size: 25, 22
  orig: 25, 22
  offset: 0, 0
  index: -1
luffy-body-up
  rotate: false
  xy: 297, 54
  size: 23, 20
  orig: 23, 20
  offset: 0, 0
  index: -1
luffy-face
  rotate: false
  xy: 139, 86
  size: 60, 40
  orig: 60, 40
  offset: 0, 0
  index: -1
luffy-lefthand-down
  rotate: false
  xy: 403, 53
  size: 15, 14
  orig: 15, 14
  offset: 0, 0
  index: -1
luffy-lefthand-up
  rotate: false
  xy: 421, 71
  size: 15, 14
  orig: 15, 14
  offset: 0, 0
  index: -1
luffy-leftleg-down
  rotate: false
  xy: 403, 33
  size: 11, 18
  orig: 11, 18
  offset: 0, 0
  index: -1
luffy-righthand-down
  rotate: false
  xy: 497, 74
  size: 13, 14
  orig: 13, 14
  offset: 0, 0
  index: -1
luffy-righthand-up
  rotate: false
  xy: 497, 90
  size: 13, 17
  orig: 13, 17
  offset: 0, 0
  index: -1
luffy-rightleg-down
  rotate: false
  xy: 29, 12
  size: 12, 18
  orig: 12, 18
  offset: 0, 0
  index: -1
neck
  rotate: false
  xy: 29, 2
  size: 8, 8
  orig: 8, 8
  offset: 0, 0
  index: -1
righthand-down
  rotate: false
  xy: 468, 59
  size: 15, 11
  orig: 15, 11
  offset: 0, 0
  index: -1
righthand-up
  rotate: false
  xy: 479, 77
  size: 16, 10
  orig: 16, 10
  offset: 0, 0
  index: -1
rightleg-down
  rotate: false
  xy: 416, 34
  size: 8, 17
  orig: 8, 17
  offset: 0, 0
  index: -1
rightleg-up
  rotate: false
  xy: 444, 53
  size: 9, 15
  orig: 9, 15
  offset: 0, 0
  index: -1
swan-body-down
  rotate: false
  xy: 2, 32
  size: 40, 17
  orig: 40, 17
  offset: 0, 0
  index: -1
swan-body-up
  rotate: false
  xy: 43, 11
  size: 19, 17
  orig: 19, 17
  offset: 0, 0
  index: -1
swan-face
  rotate: false
  xy: 305, 76
  size: 46, 50
  orig: 46, 50
  offset: 0, 0
  index: -1
swan-leftleg-down
  rotate: false
  xy: 426, 34
  size: 8, 17
  orig: 8, 17
  offset: 0, 0
  index: -1
swan-rightleg-down
  rotate: false
  xy: 436, 34
  size: 10, 17
  orig: 10, 17
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/Animation/redgirl.json`:

```json
{
"skeleton": { "hash": "2Tt2moY3s7p3iveeQdrv3MP45n4", "spine": "3.7.91", "width": 55.07, "height": 80.34 },
"bones": [
	{ "name": "root" },
	{ "name": "body-down", "parent": "root", "length": 6.92, "rotation": -86.85, "x": 0.34, "y": 29.22 },
	{ "name": "body-up", "parent": "root", "length": 8.9, "rotation": -86.4, "x": -1.49, "y": 39.23 },
	{ "name": "righthand-up", "parent": "root", "length": 9.55, "rotation": -8.4, "x": 0.48, "y": 39.79 },
	{ "name": "righthand-down", "parent": "righthand-up", "length": 10.7, "rotation": 26.75, "x": 11.17, "y": 0.51 },
	{ "name": "bow", "parent": "righthand-down", "length": 6.78, "rotation": 2.25, "x": 16.32, "y": -0.96 },
	{ "name": "cloak-down", "parent": "body-down", "length": 15.43, "rotation": -14.99, "x": -18.44, "y": -5.67 },
	{ "name": "face", "parent": "root", "length": 13.68, "rotation": 90.9, "x": 0.09, "y": 46.6 },
	{ "name": "cloak-up", "parent": "face", "length": 14.02, "rotation": 11.57, "x": 12.44, "y": 2.23 },
	{ "name": "lefthand-up", "parent": "root", "length": 8.66, "rotation": -127.03, "x": -4.74, "y": 39.67 },
	{ "name": "lefthand-down", "parent": "lefthand-up", "length": 12.12, "rotation": 7.62, "x": 9.24, "y": -0.09 },
	{ "name": "leftleg-up", "parent": "body-down", "length": 9.23, "rotation": -9.9, "x": 4.7, "y": -4.35 },
	{ "name": "leftleg-down", "parent": "leftleg-up", "length": 12.42, "rotation": 4.09, "x": 10.36, "y": -0.05 },
	{ "name": "neck", "parent": "root", "length": 3.95, "rotation": -90, "x": -1.77, "y": 43.43 },
	{ "name": "rightleg-up", "parent": "body-down", "length": 8.54, "rotation": 4.05, "x": 5.02, "y": 3.99 },
	{ "name": "rightleg-down", "parent": "rightleg-up", "length": 12.42, "rotation": 1071.79, "x": 9.98, "y": -0.13 }
],
"slots": [
	{ "name": "bow", "bone": "bow", "attachment": "Bow" },
	{ "name": "cloak-down", "bone": "cloak-down", "attachment": "cloak-down" },
	{ "name": "leftleg-up", "bone": "leftleg-up", "attachment": "leftleg-up" },
	{ "name": "leftleg-down", "bone": "leftleg-down", "attachment": "leftleg-down" },
	{ "name": "rightleg-up", "bone": "rightleg-up", "attachment": "rightleg-up" },
	{ "name": "rightleg-down", "bone": "rightleg-down", "attachment": "rightleg-down" },
	{ "name": "righthand-up", "bone": "righthand-up", "attachment": "righthand-up" },
	{ "name": "righthand-down", "bone": "righthand-down", "attachment": "righthand-down" },
	{ "name": "body-down", "bone": "body-down", "attachment": "body-down" },
	{ "name": "neck", "bone": "neck", "attachment": "neck" },
	{ "name": "face", "bone": "face", "attachment": "face" },
	{ "name": "cloak-up", "bone": "cloak-up", "attachment": "cloak-up" },
	{ "name": "body-up", "bone": "body-up", "attachment": "body-up" },
	{ "name": "lefthand-up", "bone": "lefthand-up", "attachment": "lefthand-up" },
	{ "name": "lefthand-down", "bone": "lefthand-down", "attachment": "lefthand-down" },
	{ "name": "CollisionBox", "bone": "root", "color": "00ff00ff", "attachment": "CollisionBox" }
],
"skins": {
	"default": {
		"CollisionBox": {
			"CollisionBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -11.15, 11.87, 12.31, 11.87, 5.93, 73.19, -20.68, 72.42 ]
			}
		}
	},
	"ArmourCopper": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -9.85, "y": 4.2, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourDragon": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -14.2, "y": 5.34, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourGold": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -6.68, "y": 3.66, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourHeart": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -8.45, "y": 4.33, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourIce": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -10.87, "y": 3.22, "rotation": 339.4, "width": 30, "height": 74 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourIron": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -9.53, "y": 3.58, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourLightning": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -15.93, "y": 6.39, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourSilver": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.23, "y": 3.85, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourSteel": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -11.72, "y": 4.41, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"ArmourWood": {
		"body-down": {
			"body-down": { "name": "armour-body-down", "x": 5.98, "y": -1.53, "rotation": 86.85, "width": 22, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "armour-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -9.08, "y": 5.43, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"face": {
			"face": { "name": "armour-face", "x": 15.82, "y": 4.45, "rotation": -86, "width": 50, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "armour-lefthand-down", "x": 5.6, "y": -1.45, "rotation": 35.19, "width": 15, "height": 13 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "armour-lefthand-up", "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "armour-leftleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "armour-righthand-down", "x": 7.43, "y": -0.79, "rotation": 130.3, "width": 12, "height": 15 }
		},
		"righthand-up": {
			"righthand-up": { "name": "armour-righthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 16, "height": 16 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "armour-rightleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 10, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyCopper": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -9.85, "y": 4.2, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyDragon": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -14.03, "y": 3.68, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyGold": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -7.34, "y": -0.16, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyHeart": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -8.34, "y": 1, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyIce": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -11.57, "y": 0.85, "rotation": -20.6, "width": 30, "height": 74 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyIron": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -10.15, "y": 0.9, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyLightning": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -16.09, "y": 3.91, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnySilver": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.4, "y": 0.8, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnySteel": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -12.34, "y": 0.17, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"BunnyWood": {
		"body-down": {
			"body-down": { "name": "bunny-body-down", "x": 7.7, "y": -0.33, "rotation": 86.85, "width": 28, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "bunny-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 20, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -9.72, "y": 2.68, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"face": {
			"face": { "name": "bunny-face", "x": 18.61, "y": 4.35, "rotation": -90.9, "width": 50, "height": 44 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "bunny-righthand-down", "x": 8.13, "y": -0.81, "rotation": -61.35, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.45, "y": -1.46, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "bunny-rightleg-down", "x": 5.56, "y": -0.59, "rotation": 92.66, "width": 11, "height": 16 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "bunny-lefthand-down", "x": 8.72, "y": -1.69, "rotation": -149.99, "width": 14, "height": 13 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "bunny-leftleg-down", "x": 5.9, "y": -0.08, "rotation": 91, "width": 11, "height": 16 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptCopper": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -9.85, "y": 4.2, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptDragon": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -13.99, "y": 4.29, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptGold": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -6.74, "y": 0.39, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptHeart": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -8.02, "y": 1.85, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptIce": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -11.42, "y": 1.77, "rotation": -20.6, "width": 30, "height": 74 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptIron": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -8.58, "y": 1.47, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptLightning": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -15.54, "y": 5.12, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptSilver": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.62, "y": 0.87, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptSteel": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -11.59, "y": 1.45, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"EgyptWood": {
		"body-down": {
			"body-down": { "name": "egypt-body-down", "x": 9.11, "y": 0.14, "rotation": 86.85, "width": 24, "height": 21 }
		},
		"body-up": {
			"body-up": { "name": "egypt-body-up", "x": 3.04, "y": 0.51, "rotation": 86.4, "width": 22, "height": 14 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -9.35, "y": 2.99, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"face": {
			"face": { "name": "egypt-face", "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 48, "height": 39 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "egypt-righthand-down", "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 11, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.87, "y": -1.56, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "egypt-rightleg-down", "x": 5.14, "y": -0.61, "rotation": 96.96, "width": 11, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "egypt-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 91, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyCopper": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.29, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -10.58, "y": 1.57, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyDragon": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -13.84, "y": 4.67, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyGold": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -7.32, "y": 1.96, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyHeart": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -8.68, "y": 3, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyIce": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -10.96, "y": 2.27, "rotation": -20.6, "width": 30, "height": 74 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyIron": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -9.7, "y": 3.12, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyLightning": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -15.97, "y": 5.74, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffySilver": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.29, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.4, "y": 3.4, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffySteel": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.3, "y": -1.66, "rotation": 86.85, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -11.65, "y": 3.04, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"LuffyWood": {
		"body-down": {
			"body-down": { "name": "luffy-body-down", "x": 8.32, "y": -1.33, "rotation": 84.77, "width": 25, "height": 22 }
		},
		"body-up": {
			"body-up": { "name": "luffy-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 23, "height": 20 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -9.81, "y": 3.97, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"face": {
			"face": { "name": "luffy-face", "x": 17.15, "y": 5.74, "rotation": -86.53, "width": 60, "height": 40 }
		},
		"lefthand-down": {
			"lefthand-down": { "name": "luffy-righthand-down", "x": 5.07, "y": -1.98, "rotation": 119.41, "width": 13, "height": 14 }
		},
		"lefthand-up": {
			"lefthand-up": { "name": "luffy-righthand-up", "x": 6.05, "y": -1.89, "rotation": 487.03, "width": 13, "height": 17 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "luffy-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.61, "width": 12, "height": 18 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": -1.59, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "name": "luffy-lefthand-down", "x": 7.35, "y": -0.73, "rotation": 38.65, "width": 15, "height": 14 }
		},
		"righthand-up": {
			"righthand-up": { "name": "luffy-lefthand-up", "x": 7.73, "y": 0.72, "rotation": 47.9, "width": 15, "height": 14 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "luffy-leftleg-down", "x": 5.13, "y": -0.61, "rotation": 96.24, "width": 11, "height": 18 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlCopper": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -9.85, "y": 4.2, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77061, 0, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 24.71, 27.34, 33.88, 19.07, 38.78, -4.3, 33.15, -13.8, 27.55, -11.92, 21.73, -9.97, 13.85, -7.33, 4.45, -0.44, 1.52, 13.89, 35.02, -3.32, 13.34, -2.39, 23.64, -3.29 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlDragon": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -15.24, "y": 4.87, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77021, 0.07302, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 24.64, 27.48, 33.81, 19.21, 38.7, -4.16, 33.08, -13.66, 27.48, -11.78, 21.66, -9.83, 13.78, -7.19, 4.37, -0.3, 1.07, 12.7, 34.95, -3.18, 13.27, -2.25, 23.57, -3.15 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlGold": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -7.34, "y": 1.9, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77998, 0.0786, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 1.87, 13.11, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlHeart": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -9.11, "y": 2.56, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.76531, 0.07303, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 1.8, 12.47, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlIce": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -11.13, "y": 2.53, "rotation": -20.6, "width": 30, "height": 74 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.76525, 0.08427, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 2.19, 12.56, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlIron": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -9.81, "y": 2.83, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77018, 0.07863, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 1.95, 12.71, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlLightning": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -16.16, "y": 5.21, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77015, 0.08425, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 2.15, 12.75, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlSilver": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.23, "y": 2.45, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.76528, 0.07865, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 1.99, 12.51, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlSteel": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -11.79, "y": 2.49, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77508, 0.07862, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 1.91, 12.91, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"RedGirlWood": {
		"body-down": {
			"body-down": { "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 25, "height": 20 }
		},
		"body-up": {
			"body-up": { "x": 3.06, "y": 0.81, "rotation": 86.4, "width": 18, "height": 16 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -10.56, "y": 3.11, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"cloak-down": {
			"cloak-down": {
				"type": "mesh",
				"uvs": [ 1, 0.79774, 0.76237, 1, 0.19394, 1, 0, 0.79293, 0.07114, 0.65138, 0.14507, 0.50426, 0.2451, 0.30522, 0.39795, 0.09827, 0.77502, 0.08985, 0.23513, 0.90346, 0.35321, 0.32115, 0.2873, 0.59507 ],
				"triangles": [ 10, 6, 7, 10, 5, 6, 11, 5, 10, 4, 5, 11, 9, 4, 11, 3, 4, 9, 10, 7, 8, 0, 10, 8, 2, 3, 9, 0, 11, 10, 1, 11, 0, 9, 11, 1, 2, 9, 1 ],
				"vertices": [ 25.32, 27.45, 34.49, 19.18, 39.39, -4.19, 33.76, -13.69, 28.16, -11.81, 22.34, -9.86, 14.46, -7.22, 5.06, -0.33, 2.31, 12.99, 35.63, -3.21, 13.95, -2.28, 24.25, -3.18 ],
				"hull": 9
			}
		},
		"cloak-up": {
			"cloak-up": { "x": 0.43, "y": 1.95, "rotation": -102.47, "width": 44, "height": 43 }
		},
		"face": {
			"face": { "x": 14.85, "y": 2.13, "rotation": -90.9, "width": 46, "height": 37 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 9, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanCopper": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Copper", "x": -10.6, "y": 1.26, "rotation": 339.4, "width": 25, "height": 75 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanDragon": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Dragon", "x": -14.51, "y": 4.99, "rotation": -20.6, "width": 32, "height": 69 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanGold": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Gold", "x": -6.29, "y": 1.72, "rotation": -20.6, "width": 32, "height": 75 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanHeart": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Heart", "x": -8.76, "y": 2.69, "rotation": -20.6, "width": 22, "height": 74 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanIce": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Ice", "x": -10.63, "y": 2.78, "rotation": -20.6, "width": 30, "height": 74 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanIron": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Iron", "x": -10.2, "y": 1.8, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanLightning": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Lightning", "x": -16.15, "y": 5.26, "rotation": -20.6, "width": 35, "height": 69 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanSilver": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Silver", "x": -10.26, "y": 2.94, "rotation": -20.6, "width": 27, "height": 80 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanSteel": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Steel", "x": -11.95, "y": 2.36, "rotation": -20.6, "width": 27, "height": 75 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	},
	"SwanWood": {
		"body-down": {
			"body-down": { "name": "swan-body-down", "x": 8.57, "y": -0.61, "rotation": 86.85, "width": 40, "height": 17 }
		},
		"body-up": {
			"body-up": { "name": "swan-body-up", "x": 3.05, "y": 0.81, "rotation": 86.4, "width": 19, "height": 17 }
		},
		"bow": {
			"Bow": { "name": "Wood", "x": -9.33, "y": 3.51, "rotation": -20.6, "width": 24, "height": 73 }
		},
		"face": {
			"face": { "name": "swan-face", "x": 22.05, "y": 2.02, "rotation": -90.9, "width": 46, "height": 50 }
		},
		"lefthand-down": {
			"lefthand-down": { "x": 6.33, "y": -1.35, "rotation": 119.41, "width": 12, "height": 15 }
		},
		"lefthand-up": {
			"lefthand-up": { "x": 6.75, "y": -1.86, "rotation": 127.03, "width": 12, "height": 16 }
		},
		"leftleg-down": {
			"leftleg-down": { "name": "swan-rightleg-down", "x": 4.97, "y": -0.62, "rotation": 92.66, "width": 10, "height": 17 }
		},
		"leftleg-up": {
			"leftleg-up": { "x": 4.33, "y": -0.62, "rotation": 96.75, "width": 9, "height": 15 }
		},
		"neck": {
			"neck": { "x": 1, "rotation": 90, "width": 8, "height": 8 }
		},
		"righthand-down": {
			"righthand-down": { "x": 7.85, "y": -1.4, "rotation": -18.35, "width": 15, "height": 11 }
		},
		"righthand-up": {
			"righthand-up": { "x": 7.73, "y": 0.71, "rotation": 8.4, "width": 16, "height": 10 }
		},
		"rightleg-down": {
			"rightleg-down": { "name": "swan-leftleg-down", "x": 5.6, "y": -0.09, "rotation": 87.29, "width": 8, "height": 17 }
		},
		"rightleg-up": {
			"rightleg-up": { "x": 4.43, "y": 0.43, "rotation": 82.79, "width": 9, "height": 15 }
		}
	}
},
"animations": {
	"attack": {
		"slots": {
			"lefthand-down": {
				"attachment": [
					{ "time": 0, "name": "lefthand-down" },
					{ "time": 0.1333, "name": "lefthand-down" },
					{ "time": 0.2667, "name": "lefthand-down" },
					{ "time": 0.4, "name": "lefthand-down" }
				]
			},
			"lefthand-up": {
				"attachment": [
					{ "time": 0, "name": "lefthand-up" },
					{ "time": 0.1333, "name": "lefthand-up" },
					{ "time": 0.2667, "name": "lefthand-up" },
					{ "time": 0.4, "name": "lefthand-up" }
				]
			},
			"righthand-down": {
				"attachment": [
					{ "time": 0, "name": "righthand-down" },
					{ "time": 0.1333, "name": "righthand-down" },
					{ "time": 0.2667, "name": "righthand-down" },
					{ "time": 0.4, "name": "righthand-down" }
				]
			}
		},
		"bones": {
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -44.17 },
					{ "time": 0.1333, "angle": -57.24 },
					{ "time": 0.2, "angle": -75.15 },
					{ "time": 0.2667, "angle": -57.24 },
					{ "time": 0.4, "angle": -44.17 }
				],
				"translate": [
					{ "time": 0, "x": 0.86, "y": 2.69 },
					{ "time": 0.1333, "x": 3.89, "y": 1.78 },
					{ "time": 0.2, "x": 7.22, "y": 2.08 },
					{ "time": 0.2667, "x": 3.89, "y": 1.78 },
					{ "time": 0.4, "x": 0.86, "y": 2.69 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.48, "curve": "stepped" },
					{ "time": 0.1333, "angle": -26.48, "curve": "stepped" },
					{ "time": 0.2, "angle": -26.48, "curve": "stepped" },
					{ "time": 0.2667, "angle": -26.48, "curve": "stepped" },
					{ "time": 0.4, "angle": -26.48 }
				],
				"translate": [
					{ "time": 0, "x": -0.41, "y": 1.56, "curve": "stepped" },
					{ "time": 0.1333, "x": -0.41, "y": 1.56, "curve": "stepped" },
					{ "time": 0.2, "x": -0.41, "y": 1.56, "curve": "stepped" },
					{ "time": 0.2667, "x": -0.41, "y": 1.56, "curve": "stepped" },
					{ "time": 0.4, "x": -0.41, "y": 1.56 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 11.11 },
					{ "time": 0.1333, "angle": 7.15 },
					{ "time": 0.2, "angle": 0.14 },
					{ "time": 0.2667, "angle": 7.15 },
					{ "time": 0.4, "angle": 11.11 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.1333, "x": -1.11, "y": -3.16 },
					{ "time": 0.2, "x": -1.19, "y": -12.67 },
					{ "time": 0.2667, "x": -1.11, "y": -3.16 },
					{ "time": 0.4, "x": 0, "y": 0 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 0.71 },
					{ "time": 0.1333, "angle": 4.73 },
					{ "time": 0.2, "angle": 10.72 },
					{ "time": 0.2667, "angle": 4.73 },
					{ "time": 0.4, "angle": 0.71 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 1.2 },
					{ "time": 0.1333, "angle": 25.28 },
					{ "time": 0.2, "angle": 59.79 },
					{ "time": 0.2667, "angle": 25.28 },
					{ "time": 0.4, "angle": 1.2 }
				],
				"translate": [
					{ "time": 0, "x": 1.35, "y": 0.83 },
					{ "time": 0.1333, "x": 3.56, "y": 1.92 },
					{ "time": 0.2, "x": 4.77, "y": 2.53 },
					{ "time": 0.2667, "x": 3.56, "y": 1.92 },
					{ "time": 0.4, "x": 1.35, "y": 0.83 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 9.32 },
					{ "time": 0.1333, "angle": -0.14 },
					{ "time": 0.2, "angle": -18.53 },
					{ "time": 0.2667, "angle": -0.14 },
					{ "time": 0.4, "angle": 9.32 }
				],
				"translate": [
					{ "time": 0, "x": 0.82, "y": -0.91 },
					{ "time": 0.1333, "x": 2.82, "y": -1.51 },
					{ "time": 0.2, "x": 7.67, "y": -2.42 },
					{ "time": 0.2667, "x": 2.82, "y": -1.51 },
					{ "time": 0.4, "x": 0.82, "y": -0.91 }
				],
				"scale": [
					{ "time": 0, "x": 1.113, "y": 1.113 },
					{ "time": 0.2, "x": 0.976, "y": 0.976 },
					{ "time": 0.4, "x": 1.113, "y": 1.113 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -0.32 },
					{ "time": 0.1333, "angle": -2.49 },
					{ "time": 0.2, "angle": -6.63 },
					{ "time": 0.2667, "angle": -2.49 },
					{ "time": 0.4, "angle": -0.32 }
				],
				"translate": [
					{ "time": 0, "x": -1.21, "y": -0.6 },
					{ "time": 0.1333, "x": 3.64, "y": 0 },
					{ "time": 0.2, "x": 9.7, "y": -2.12 },
					{ "time": 0.2667, "x": 3.64, "y": 0 },
					{ "time": 0.4, "x": -1.21, "y": -0.6 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -5.21 },
					{ "time": 0.1333, "angle": -8.04 },
					{ "time": 0.2, "angle": -9.71 },
					{ "time": 0.2667, "angle": -8.04 },
					{ "time": 0.4, "angle": -5.21 }
				],
				"translate": [
					{ "time": 0, "x": -2.09, "y": 4.22 },
					{ "time": 0.1333, "x": 0.15, "y": 4.72 },
					{ "time": 0.2, "x": 2.36, "y": 6.21 },
					{ "time": 0.2667, "x": 0.15, "y": 4.72 },
					{ "time": 0.4, "x": -2.09, "y": 4.22 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 4.42 },
					{ "time": 0.1333, "angle": 0.15 },
					{ "time": 0.2, "angle": -6.61 },
					{ "time": 0.2667, "angle": 0.15 },
					{ "time": 0.4, "angle": 4.42 }
				],
				"translate": [
					{ "time": 0, "x": 2.42, "y": -0.61, "curve": "stepped" },
					{ "time": 0.1333, "x": 2.42, "y": -0.61 },
					{ "time": 0.2, "x": 4.24, "y": -0.61 },
					{ "time": 0.2667, "x": 2.42, "y": -0.61, "curve": "stepped" },
					{ "time": 0.4, "x": 2.42, "y": -0.61 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 0.33 },
					{ "time": 0.1333, "angle": 364.6 },
					{ "time": 0.2, "angle": 371.35 },
					{ "time": 0.2667, "angle": 364.6 },
					{ "time": 0.4, "angle": 0.33 }
				],
				"translate": [
					{ "time": 0, "x": -0.07, "y": 0.98 },
					{ "time": 0.1333, "x": 0.17, "y": 1.33 },
					{ "time": 0.2, "x": 0.6, "y": 0.11 },
					{ "time": 0.2667, "x": 0.17, "y": 1.33 },
					{ "time": 0.4, "x": -0.07, "y": 0.98 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": -4.03 },
					{ "time": 0.1333, "angle": 360.23 },
					{ "time": 0.2, "angle": 366.99 },
					{ "time": 0.2667, "angle": 360.23 },
					{ "time": 0.4, "angle": -4.03 }
				],
				"translate": [
					{ "time": 0, "x": -0.31, "y": -0.06 },
					{ "time": 0.1333, "x": -0.61, "y": 0.28 },
					{ "time": 0.2, "x": -1.03, "y": -1.04 },
					{ "time": 0.2667, "x": -0.61, "y": 0.28 },
					{ "time": 0.4, "x": -0.31, "y": -0.06 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 360 },
					{ "time": 0.1333, "angle": 0, "curve": "stepped" },
					{ "time": 0.2, "angle": 0, "curve": "stepped" },
					{ "time": 0.2667, "angle": 0 },
					{ "time": 0.4, "angle": 360 }
				],
				"translate": [
					{ "time": 0, "x": 0.93, "y": -0.37 },
					{ "time": 0.1333, "x": 0.92, "y": -0.37 },
					{ "time": 0.2, "x": 0.92, "y": -0.37 },
					{ "time": 0.2667, "x": 0.92, "y": -0.37 },
					{ "time": 0.4, "x": 0.93, "y": -0.37 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 359.99 },
					{ "time": 0.1333, "angle": 360, "curve": "stepped" },
					{ "time": 0.2, "angle": 360, "curve": "stepped" },
					{ "time": 0.2667, "angle": 360 },
					{ "time": 0.4, "angle": 359.99 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1333, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.4, "x": 0, "y": 0 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 0.3, "y": 0.61 },
					{ "time": 0.1333, "x": 3.64, "y": 0.61 },
					{ "time": 0.2, "x": 6.97, "y": 1.21 },
					{ "time": 0.2667, "x": 3.64, "y": 0.61 },
					{ "time": 0.4, "x": 0.3, "y": 0.61 }
				]
			},
			"cloak-up": {
				"translate": [
					{ "time": 0, "x": 0.92, "y": 0.6 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -2.39238, -1.35028, -1.27872, 0.0833, 2.09261, 1.05291, 3.54564, 0.33106, 3.33067, -0.50987, 3.10725, -1.38391, 2.805, -2.56642, 1.89754, -4.01941, 0.13451, -5.01444, 1.98946, 0.49188, 2.08651, -2.69476, 2.10749, -1.17571 ],
							"curve": "stepped"
						},
						{
							"time": 0.1333,
							"vertices": [ -2.39238, -1.35028, -1.27872, 0.0833, 2.09261, 1.05291, 3.54564, 0.33106, 3.33067, -0.50987, 3.10725, -1.38391, 2.805, -2.56642, 1.89754, -4.01941, 0.13451, -5.01444, 1.98946, 0.49188, 2.08651, -2.69476, 2.10749, -1.17571 ],
							"curve": "stepped"
						},
						{
							"time": 0.2667,
							"vertices": [ -2.39238, -1.35028, -1.27872, 0.0833, 2.09261, 1.05291, 3.54564, 0.33106, 3.33067, -0.50987, 3.10725, -1.38391, 2.805, -2.56642, 1.89754, -4.01941, 0.13451, -5.01444, 1.98946, 0.49188, 2.08651, -2.69476, 2.10749, -1.17571 ],
							"curve": "stepped"
						},
						{
							"time": 0.4,
							"vertices": [ -2.39238, -1.35028, -1.27872, 0.0833, 2.09261, 1.05291, 3.54564, 0.33106, 3.33067, -0.50987, 3.10725, -1.38391, 2.805, -2.56642, 1.89754, -4.01941, 0.13451, -5.01444, 1.98946, 0.49188, 2.08651, -2.69476, 2.10749, -1.17571 ]
						}
					]
				}
			}
		}
	},
	"die": {
		"bones": {
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 },
					{ "time": 0.1667, "angle": 24.03 },
					{ "time": 0.3333, "angle": 22.64 },
					{ "time": 0.5, "angle": 27.52 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.1667, "x": -0.76, "y": -2.95 },
					{ "time": 0.3333, "x": 0.21, "y": -2.47 },
					{ "time": 0.5, "x": -0.81, "y": -2.63 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.72 },
					{ "time": 0.1667, "angle": -29.09 },
					{ "time": 0.3333, "angle": -6.55 },
					{ "time": 0.5, "angle": -30.3 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38 },
					{ "time": 0.5, "x": -1.88, "y": 1.95 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 },
					{ "time": 0.1667, "angle": 27.97 },
					{ "time": 0.3333, "angle": 35.75 },
					{ "time": 0.5, "angle": -25.22 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.1667, "x": -0.74, "y": -3.97 },
					{ "time": 0.3333, "x": 2.08, "y": -5.64 },
					{ "time": 0.5, "x": 0.41, "y": 0.17 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0.3333, "angle": 23.19 },
					{ "time": 0.5, "angle": 20.37 }
				],
				"translate": [
					{ "time": 0, "x": 0.61, "y": -4.26 },
					{ "time": 0.1667, "x": -1.93, "y": 4.8 },
					{ "time": 0.3333, "x": -2.51, "y": 0.79 },
					{ "time": 0.5, "x": -11.31, "y": -6.9 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -0.32 },
					{ "time": 0.5, "angle": -3.46 }
				],
				"translate": [
					{ "time": 0, "x": 0.8, "y": 2.09 },
					{ "time": 0.1667, "x": -4.72, "y": -0.84 },
					{ "time": 0.5, "x": 10.51, "y": -0.61 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -52.43 },
					{ "time": 0.1667, "angle": -2.76 },
					{ "time": 0.3333, "angle": 4.32 },
					{ "time": 0.5, "angle": -47.68 }
				],
				"translate": [
					{ "time": 0, "x": 1.44, "y": -0.49 },
					{ "time": 0.1667, "x": -2.09, "y": 6.27 },
					{ "time": 0.3333, "x": -5.55, "y": 0.08 },
					{ "time": 0.5, "x": -9.09, "y": -2.46 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 2.22 },
					{ "time": 0.3333, "angle": 45.85 },
					{ "time": 0.5, "angle": 53.29 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -3 },
					{ "time": 0.1667, "x": -2.61, "y": 5.73 },
					{ "time": 0.3333, "x": 0.71, "y": 1.96 },
					{ "time": 0.5, "x": -8.41, "y": -6.02 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": -56.84 },
					{ "time": 0.3333, "angle": 5.6 },
					{ "time": 0.5, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.94, "y": 0.15 },
					{ "time": 0.1667, "x": 1.9, "y": -4.47 },
					{ "time": 0.3333, "x": 1.68, "y": 0.44 },
					{ "time": 0.5, "x": 0.94, "y": 0.15 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 16.45 },
					{ "time": 0.1667, "angle": 0.83 },
					{ "time": 0.3333, "angle": 97.42 },
					{ "time": 0.5, "angle": 66.04 }
				],
				"translate": [
					{ "time": 0, "x": -0.3, "y": -3.01 },
					{ "time": 0.1667, "x": -1.59, "y": 4.52 },
					{ "time": 0.3333, "x": -5.48, "y": 3.54 },
					{ "time": 0.5, "x": -13.43, "y": -5.25 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 5.9 },
					{ "time": 0.1667, "angle": 4.39 },
					{ "time": 0.3333, "angle": 32.81 },
					{ "time": 0.5, "angle": 9.41 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.5, "x": -0.49, "y": -0.5 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.1667, "angle": 15.68 },
					{ "time": 0.3333, "angle": -11.05 },
					{ "time": 0.5, "angle": -0.97 }
				],
				"translate": [
					{ "time": 0, "x": -1, "y": -4 },
					{ "time": 0.1667, "x": -5.24, "y": 6.52 },
					{ "time": 0.3333, "x": -7.07, "y": 0.25 },
					{ "time": 0.5, "x": -12.98, "y": -5.51 }
				]
			},
			"neck": {
				"rotate": [
					{ "time": 0.5, "angle": -1.41 }
				],
				"translate": [
					{ "time": 0, "x": 0.9, "y": -0.74 },
					{ "time": 0.1667, "x": -1.58, "y": 7.89 },
					{ "time": 0.5, "x": -11.07, "y": -4.38 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": 7.72 },
					{ "time": 0.3333, "angle": 51.87 }
				],
				"translate": [
					{ "time": 0.1667, "x": 0.56, "y": 0.33 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": 55.41 },
					{ "time": 0.3333, "angle": 113.19 },
					{ "time": 0.3667, "angle": -168.41 },
					{ "time": 0.4, "angle": -114.16 },
					{ "time": 0.4333, "angle": -80.91 },
					{ "time": 0.5, "angle": -29.04 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.1667, "x": 6.01, "y": 22.42 },
					{ "time": 0.3333, "x": 25.41, "y": 23.64 },
					{ "time": 0.3667, "x": 6.34, "y": 19.41 },
					{ "time": 0.5, "x": -21.1, "y": -7.35 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0.1667, "angle": -42.91 }
				],
				"translate": [
					{ "time": 0.1667, "x": -1.14, "y": -2.21 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlDragon": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -9.99795, 13.63344, -11.08166, 11.92497, -12.38272, 9.80274, -11.37328, 6.9489, -13.78321, 0.42492, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlGold": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlHeart": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlIce": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlIron": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlLightning": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlSilver": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlSteel": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlWood": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 4.25503, -1.04982, 1.43709, 1.78909, 2.3422, 3.5195, 4.75003, 6.97806, 5.43417, 7.67836, 5.91119, 6.64977, 7.28589, 5.44688, 4.6017, 2.82107, 4.17092, 1.70076, 1.9423, 2.93511, 6.93551, 2.66365, 4.55076, 3.08655 ]
						},
						{
							"time": 0.5,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -12.83998, 12.06168, -11.15253, 9.20941, -13.45586, 5.39769, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			}
		}
	},
	"die_over": {
		"bones": {
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 27.52 }
				],
				"translate": [
					{ "time": 0, "x": -0.81, "y": -2.63 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -30.3 }
				],
				"translate": [
					{ "time": 0, "x": -1.88, "y": 1.95 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": -25.22 }
				],
				"translate": [
					{ "time": 0, "x": 0.41, "y": 0.17 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 20.37 }
				],
				"translate": [
					{ "time": 0, "x": -11.31, "y": -6.9 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -3.46 }
				],
				"translate": [
					{ "time": 0, "x": 10.51, "y": -0.61 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -47.68 }
				],
				"translate": [
					{ "time": 0, "x": -9.09, "y": -2.46 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 53.29 }
				],
				"translate": [
					{ "time": 0, "x": -7.92, "y": -6.65 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.94, "y": 0.15 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 66.04 }
				],
				"translate": [
					{ "time": 0, "x": -13.43, "y": -5.25 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 9.41 }
				],
				"translate": [
					{ "time": 0, "x": -0.49, "y": -0.5 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -0.97 }
				],
				"translate": [
					{ "time": 0, "x": -12.98, "y": -5.51 }
				]
			},
			"neck": {
				"rotate": [
					{ "time": 0, "angle": -1.41 }
				],
				"translate": [
					{ "time": 0, "x": -11.07, "y": -4.38 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 51.87 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": -29.04 }
				],
				"translate": [
					{ "time": 0, "x": -21.1, "y": -7.35 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": -42.91 }
				],
				"translate": [
					{ "time": 0, "x": -1.14, "y": -2.21 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlDragon": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlGold": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlHeart": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlIce": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlIron": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlLightning": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlSilver": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlSteel": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			},
			"RedGirlWood": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ -14.49588, -6.21498, -16.79455, 3.29316, -16.16834, 13.02313, -12.82951, 16.45185, -12.89622, 14.74576, -11.71672, 10.66429, -10.18441, 7.86068, -15.3764, 1.34021, -14.74821, 2.03675, -16.73117, 10.80987, -12.56742, 8.43014, -13.4678, 9.827 ]
						}
					]
				}
			}
		}
	},
	"dizzy": {
		"slots": {
			"cloak-up": {
				"attachment": [
					{ "time": 0, "name": "cloak-up" },
					{ "time": 0.3, "name": "cloak-up" },
					{ "time": 0.3667, "name": "cloak-up" }
				]
			}
		},
		"bones": {
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1, "angle": 2.01 },
					{ "time": 0.1667, "angle": 5.76 },
					{ "time": 0.2, "angle": 4.1 },
					{ "time": 0.3, "angle": -5.47 },
					{ "time": 0.3667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.25 },
					{ "time": 0.1, "x": 0.51, "y": -0.79 },
					{ "time": 0.1667, "x": 2.09, "y": 0.58 },
					{ "time": 0.2, "x": 1.25, "y": -0.62 },
					{ "time": 0.3, "x": -2.43, "y": 0.28 },
					{ "time": 0.3667, "x": 0.62, "y": -0.25 }
				],
				"scale": [
					{ "time": 0.1, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.1667, "x": 1, "y": 1 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.1, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.1667, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.2, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.3, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.3667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.1, "x": -1, "y": 0.06, "curve": "stepped" },
					{ "time": 0.1667, "x": -1, "y": 0.06, "curve": "stepped" },
					{ "time": 0.2, "x": -1, "y": 0.06 },
					{ "time": 0.3, "x": -3, "y": 0.17, "curve": "stepped" },
					{ "time": 0.3667, "x": -3, "y": 0.17 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0, "angle": 0, "curve": "stepped" },
					{ "time": 0.1, "angle": 0, "curve": "stepped" },
					{ "time": 0.1667, "angle": 0 },
					{ "time": 0.2, "angle": 1.27 },
					{ "time": 0.3, "angle": -0.89 },
					{ "time": 0.3667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.3, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.3667, "x": 0, "y": 0 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.1, "angle": 5.16 },
					{ "time": 0.1667, "angle": 11.71 },
					{ "time": 0.2, "angle": -2.95 },
					{ "time": 0.3, "angle": -18.86 },
					{ "time": 0.3667, "angle": -3.1 }
				],
				"translate": [
					{ "time": 0, "x": -1, "y": -4 },
					{ "time": 0.1, "x": -1.91, "y": 4.34 },
					{ "time": 0.1667, "x": -0.65, "y": 9.9 },
					{ "time": 0.2, "x": -1.21, "y": 4.61 },
					{ "time": 0.3, "x": 1.32, "y": -9.96 },
					{ "time": 0.3667, "x": -1, "y": -4 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 380.99 },
					{ "time": 0.1, "angle": 33.93 },
					{ "time": 0.1667, "angle": 27.09 },
					{ "time": 0.2, "angle": 25.47 },
					{ "time": 0.3, "angle": 43.87 },
					{ "time": 0.3667, "angle": 380.99 }
				],
				"translate": [
					{ "time": 0, "x": -0.8, "y": 1.08 },
					{ "time": 0.1, "x": -2.1, "y": 2.76 },
					{ "time": 0.1667, "x": -2.61, "y": 2.82 },
					{ "time": 0.2, "x": -0.48, "y": 1.62 },
					{ "time": 0.3, "x": 1.45, "y": 1.37 },
					{ "time": 0.3667, "x": -0.79, "y": 1.08 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 16.45 },
					{ "time": 0.1, "angle": 1.57 },
					{ "time": 0.1667, "angle": 10.16 },
					{ "time": 0.2, "angle": 1.75 },
					{ "time": 0.3, "angle": -44.15 },
					{ "time": 0.3667, "angle": 16.45 }
				],
				"translate": [
					{ "time": 0, "x": -0.3, "y": -3.01 },
					{ "time": 0.1, "x": -0.14, "y": 5.1 },
					{ "time": 0.1667, "x": 1.11, "y": 11.56 },
					{ "time": 0.2, "x": -0.48, "y": 5.43 },
					{ "time": 0.3, "x": 1.65, "y": -8.54 },
					{ "time": 0.3667, "x": -0.3, "y": -3.01 }
				]
			},
			"neck": {
				"rotate": [
					{ "time": 0.1667, "angle": 10.27 },
					{ "time": 0.3, "angle": 6.7 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -5 },
					{ "time": 0.1, "x": -0.91, "y": 3.84 },
					{ "time": 0.1667, "x": -0.91, "y": 8.14 },
					{ "time": 0.2, "x": -0.91, "y": 3.84 },
					{ "time": 0.3, "x": 0.66, "y": -9.3 },
					{ "time": 0.3333, "x": 0, "y": -5 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 5.9 },
					{ "time": 0.1, "angle": 1.05 },
					{ "time": 0.1667, "angle": 2.81 },
					{ "time": 0.2, "angle": 21.67 },
					{ "time": 0.3, "angle": 120.93 },
					{ "time": 0.3667, "angle": 5.9 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2, "x": 0, "y": 0 },
					{ "time": 0.3, "x": 3.57, "y": -2.65 },
					{ "time": 0.3667, "x": 0, "y": 0 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": -7.48 },
					{ "time": 0.3, "angle": 1.13 },
					{ "time": 0.3667, "angle": 360 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -3 },
					{ "time": 0.1, "x": -0.91, "y": 5.34 },
					{ "time": 0.1667, "x": 0.09, "y": 10.31 },
					{ "time": 0.2, "x": -0.91, "y": 5.34 },
					{ "time": 0.3, "x": 0, "y": -6.31 },
					{ "time": 0.3667, "x": 0, "y": -3 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.72 },
					{ "time": 0.1, "angle": -33.78 },
					{ "time": 0.1667, "angle": -20.2 },
					{ "time": 0.2, "angle": -42.09 },
					{ "time": 0.3, "angle": -150.76 },
					{ "time": 0.3667, "angle": -26.72 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38 },
					{ "time": 0.1, "x": -0.98, "y": 2.62 },
					{ "time": 0.1667, "x": -1.37, "y": 2 },
					{ "time": 0.2, "x": -0.32, "y": 2.8 },
					{ "time": 0.3, "x": 4.23, "y": 2.15 },
					{ "time": 0.3667, "x": -0.4, "y": 1.38 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.1, "angle": 2.27 },
					{ "time": 0.1667, "angle": 3.56 },
					{ "time": 0.2, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.3, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.3667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.1, "x": -1, "y": 0.06, "curve": "stepped" },
					{ "time": 0.1667, "x": -1, "y": 0.06, "curve": "stepped" },
					{ "time": 0.2, "x": -1, "y": 0.06 },
					{ "time": 0.3, "x": -3, "y": 0.17, "curve": "stepped" },
					{ "time": 0.3667, "x": -3, "y": 0.17 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 0.68 },
					{ "time": 0.1, "angle": -0.97, "curve": "stepped" },
					{ "time": 0.1667, "angle": -0.97, "curve": "stepped" },
					{ "time": 0.2, "angle": -0.97 },
					{ "time": 0.3, "angle": -2.9 },
					{ "time": 0.3667, "angle": 0.68 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -4 },
					{ "time": 0.1, "x": -0.91, "y": 4.34 },
					{ "time": 0.1667, "x": 0.09, "y": 9.31 },
					{ "time": 0.2, "x": -0.91, "y": 4.34 },
					{ "time": 0.3, "x": 0.66, "y": -8.3 },
					{ "time": 0.3667, "x": 0, "y": -4 }
				],
				"scale": [
					{ "time": 0, "x": 0.873, "y": 0.873 },
					{ "time": 0.1, "x": 0.978, "y": 0.978 },
					{ "time": 0.1667, "x": 1.083, "y": 1.083 },
					{ "time": 0.2, "x": 0.978, "y": 0.978 },
					{ "time": 0.3, "x": 0.873, "y": 0.873, "curve": "stepped" },
					{ "time": 0.3667, "x": 0.873, "y": 0.873 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": 359.24 },
					{ "time": 0.1, "angle": -0.76, "curve": "stepped" },
					{ "time": 0.1667, "angle": -0.76, "curve": "stepped" },
					{ "time": 0.2, "angle": -0.76, "curve": "stepped" },
					{ "time": 0.3, "angle": -0.76 },
					{ "time": 0.3667, "angle": 359.25 }
				],
				"translate": [
					{ "time": 0, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.1, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.1667, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.2, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.3, "x": 0.8, "y": 2.09 },
					{ "time": 0.3667, "x": 0.8, "y": 2.09 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -52.43 },
					{ "time": 0.1, "angle": -57.84 },
					{ "time": 0.1667, "angle": -55.91 },
					{ "time": 0.2, "angle": -42.87 },
					{ "time": 0.3, "angle": 1.21 },
					{ "time": 0.3667, "angle": -52.43 }
				],
				"translate": [
					{ "time": 0, "x": 1.44, "y": -0.49 },
					{ "time": 0.1, "x": 1.03, "y": 8.02 },
					{ "time": 0.1667, "x": 2.29, "y": 12.95 },
					{ "time": 0.2, "x": -0.22, "y": 8.02 },
					{ "time": 0.3, "x": 2.76, "y": -7.91 },
					{ "time": 0.3667, "x": 1.44, "y": -0.49 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1, "angle": 1.49 },
					{ "time": 0.1667, "angle": 2.77 },
					{ "time": 0.2, "angle": 1.25 },
					{ "time": 0.3, "angle": 5.48 },
					{ "time": 0.3667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.94, "y": 0.15 },
					{ "time": 0.1, "x": 0.52, "y": -1.15 },
					{ "time": 0.1667, "x": 1.76, "y": -1.6 },
					{ "time": 0.2, "x": 1.34, "y": -0.31 },
					{ "time": 0.3, "x": -1.9, "y": -0.17 },
					{ "time": 0.3667, "x": 0.94, "y": 0.15 }
				],
				"scale": [
					{ "time": 0.1, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.1667, "x": 1, "y": 1 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1,
							"vertices": [ 1.45214, -5.10381, -4.58752, -2.31149, -0.1759, -0.90243, 2.49221, 3.97658, 2.87095, -0.16483, 1.94148, -2.95924, 2.36578, -3.99526, -0.13334, -1.62547, -0.51473, -5.56173, -2.77893, -0.70934, 5.14096, -1.19022, 1.3247, -1.58913 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 1.45214, -5.10381, -7.24404, -2.56515, -0.60842, 1.03589, 3.33197, 7.36813, 3.84983, 7.07662, 3.68433, 5.40708, 5.09281, 2.25571, -0.56585, 0.31285, -0.51473, -5.56173, -0.87792, 1.41053, 4.70844, 0.7481, 0.9269, 1.7135 ]
						},
						{
							"time": 0.2,
							"vertices": [ 1.45214, -5.10381, -8.1357, -9.20781, -2.21561, -8.47955, 2.42281, 1.24797, 2.94573, -3.53955, 1.0471, -6.55022, 2.29639, -6.72386, -0.13334, -1.62547, -0.51473, -5.56173, -3.38494, -5.59254, 4.82061, -4.31398, 1.50628, -3.92259 ]
						},
						{
							"time": 0.3,
							"vertices": [ 1.02593, -7.30143, -9.35658, -6.685, -9.81845, -17.09658, -7.55686, -2.78602, -6.47693, 0.31343, -4.38188, 2.17878, -3.16412, 0.8704, -3.79572, -6.04591, -0.28156, -4.78415, -9.00686, -7.91295, -0.71711, -0.97703, -4.12679, -2.86134 ]
						},
						{
							"time": 0.3667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			}
		}
	},
	"hurt": {
		"bones": {
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 5.9 },
					{ "time": 0.1333, "angle": 42.5 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": 39.44 }
				],
				"translate": [
					{ "time": 0, "x": 0.94, "y": 0.15 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": -3.45 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -3, "curve": "stepped" },
					{ "time": 0.1667, "x": 0, "y": -3 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 20.99 }
				],
				"translate": [
					{ "time": 0, "x": -0.8, "y": 1.08 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -52.43 },
					{ "time": 0.1667, "angle": -0.03 }
				],
				"translate": [
					{ "time": 0, "x": 1.44, "y": -0.49 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.1667, "angle": -1.74 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.25 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.1667, "angle": 24.61 }
				],
				"translate": [
					{ "time": 0, "x": -1, "y": -4 },
					{ "time": 0.1667, "x": -4.04, "y": 0.87 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.72 },
					{ "time": 0.1667, "angle": 4.03 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 1.22, "y": -0.74 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 16.45 },
					{ "time": 0.1667, "angle": 47.79 }
				],
				"translate": [
					{ "time": 0, "x": -0.3, "y": -3.01 },
					{ "time": 0.1667, "x": -0.91, "y": 1.25 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -0.76 }
				],
				"translate": [
					{ "time": 0, "x": 0.8, "y": 2.09 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0.1667, "angle": 14.59 }
				],
				"translate": [
					{ "time": 0, "x": 0.61, "y": -4.26 },
					{ "time": 0.1667, "x": 0.61, "y": -1.83 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ -12.5609, 2.92764, -12.34742, 5.28117, -1.1706, 6.52669, 3.37356, 8.76792, 4.46022, 4.19279, 3.88077, 2.03028, 4.17696, -0.6569, -0.42682, -4.08251, -5.2239, -7.00069, -1.80355, 5.05317, 3.61145, -0.83132, 0.56606, 2.05305 ]
						}
					]
				}
			}
		}
	},
	"keep": {
		"bones": {
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": 22.4 },
					{ "time": 0.8333, "angle": 25.9 },
					{ "time": 1.3333, "angle": 22.4 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": 8.77 }
				],
				"translate": [
					{ "time": 0, "x": 4.5, "y": -2.78 }
				]
			},
			"body-down": {
				"translate": [
					{ "time": 0, "x": 0, "y": -0.22 },
					{ "time": 0.6667, "x": 0, "y": 0.78 },
					{ "time": 1.5, "x": 0, "y": -0.22 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 },
					{ "time": 0.6667, "x": 1.03, "y": 1.03 },
					{ "time": 1.5, "x": 1, "y": 1 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 4.63 }
				],
				"translate": [
					{ "time": 0, "x": 0.87, "y": 0.37 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 371.4 }
				],
				"translate": [
					{ "time": 0, "x": -1.77, "y": -0.93 }
				],
				"scale": [
					{ "time": 0, "x": 1.106, "y": 1.106 },
					{ "time": 0.6667, "x": 1.07, "y": 1.07 },
					{ "time": 1.5, "x": 1.106, "y": 1.106 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 11.33 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.62 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": -12.25 },
					{ "time": 0.8333, "angle": 349.53 },
					{ "time": 1.3333, "angle": -12.25 }
				],
				"translate": [
					{ "time": 0, "x": -2.11, "y": -2.11 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0.93 }
				],
				"translate": [
					{ "time": 0, "x": -0.58, "y": 0.07 },
					{ "time": 0.6667, "x": 0.94, "y": -0.12 },
					{ "time": 1.5, "x": -0.58, "y": 0.07 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 },
					{ "time": 0.6667, "x": 0.92, "y": 0.92 },
					{ "time": 1.5, "x": 1, "y": 1 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -22.59 }
				],
				"translate": [
					{ "time": 0, "x": -0.72, "y": 0.89 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 155.57 },
					{ "time": 0.8333, "angle": 156.3 },
					{ "time": 1.3333, "angle": 155.57 }
				],
				"translate": [
					{ "time": 0, "x": 1.64, "y": -2.11 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": 14.78 },
					{ "time": 0.6667, "angle": 17.6 },
					{ "time": 1.5, "angle": 14.78 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": -0.27, "y": 0.87 },
					{ "time": 0.6667, "x": 1.33, "y": 0.93 },
					{ "time": 1.5, "x": -0.27, "y": 0.87 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 },
					{ "time": 0.6667, "x": 0.93, "y": 0.938 },
					{ "time": 1.5, "x": 1, "y": 1 }
				]
			},
			"rightleg-up": {
				"translate": [
					{ "time": 0, "x": 1.26, "y": -0.07 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 0.3, "y": 0 }
				]
			}
		}
	},
	"keep2": {
		"slots": {
			"righthand-down": {
				"attachment": [
					{ "time": 0, "name": "righthand-down" }
				]
			},
			"rightleg-down": {
				"attachment": [
					{ "time": 0, "name": "rightleg-down" }
				]
			}
		},
		"bones": {
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 4.63 }
				],
				"translate": [
					{ "time": 0, "x": 0.87, "y": 0.37 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0.93 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 0.3, "y": 0 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -22.59 }
				],
				"translate": [
					{ "time": 0, "x": -0.72, "y": 0.89 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": 8.77 }
				],
				"translate": [
					{ "time": 0, "x": 4.5, "y": -2.78 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 18.74 }
				],
				"translate": [
					{ "time": 0, "x": -1.77, "y": -0.93 }
				],
				"scale": [
					{ "time": 0, "x": 1.106, "y": 1.106 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 155.57 }
				],
				"translate": [
					{ "time": 0, "x": 1.64, "y": -2.11 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": -12.25 }
				],
				"translate": [
					{ "time": 0, "x": -2.11, "y": -2.11 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 11.33 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.62 }
				]
			},
			"rightleg-up": {
				"translate": [
					{ "time": 0, "x": 1.26, "y": -0.07 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": 14.78 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": 22.45 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			},
			"body-down": {
				"translate": [
					{ "time": 0, "x": 0, "y": 0.84 }
				]
			}
		}
	},
	"ready": {
		"slots": {
			"cloak-up": {
				"attachment": [
					{ "time": 0, "name": "cloak-up" }
				]
			},
			"righthand-down": {
				"attachment": [
					{ "time": 0.2667, "name": "righthand-down" }
				]
			}
		},
		"bones": {
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -0.76 },
					{ "time": 0.0667, "angle": 1.39 },
					{ "time": 0.1333, "angle": 2.78 },
					{ "time": 0.2667, "angle": 8.77 }
				],
				"translate": [
					{ "time": 0, "x": 0.8, "y": 2.09 },
					{ "time": 0.0667, "x": 0.2, "y": -0.26 },
					{ "time": 0.1333, "x": 2.06, "y": -0.96 },
					{ "time": 0.2667, "x": 4.5, "y": -2.78 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 16.45 },
					{ "time": 0.0667, "angle": 72.25 },
					{ "time": 0.1333, "angle": 88.25 },
					{ "time": 0.2667, "angle": -12.25 }
				],
				"translate": [
					{ "time": 0, "x": -0.3, "y": -3.01 },
					{ "time": 0.0667, "x": -0.42, "y": 0.67 },
					{ "time": 0.1333, "x": -2.53, "y": 2.53 },
					{ "time": 0.2667, "x": -2.11, "y": -2.11 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 5.9 },
					{ "time": 0.0667, "angle": 25.27 },
					{ "time": 0.1333, "angle": 59.38 },
					{ "time": 0.2667, "angle": 155.57 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.2667, "x": 1.64, "y": -2.11 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 },
					{ "time": 0.0667, "angle": 0, "curve": "stepped" },
					{ "time": 0.1333, "angle": 0 },
					{ "time": 0.2667, "angle": 4.63 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.0667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1333, "x": 0, "y": 0 },
					{ "time": 0.2667, "x": 0.87, "y": 0.37 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.0667, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.1333, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.2667, "x": 1, "y": 1 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 0.68 },
					{ "time": 0.2667, "angle": 371.4 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -4 },
					{ "time": 0.0667, "x": -0.42, "y": -1.89 },
					{ "time": 0.1333, "x": -2.11, "y": -0.84 },
					{ "time": 0.2667, "x": -1.77, "y": -0.93 }
				],
				"scale": [
					{ "time": 0, "x": 0.873, "y": 0.873 },
					{ "time": 0.2667, "x": 1.106, "y": 1.106 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.1333, "angle": 9.83 },
					{ "time": 0.2667, "angle": 14.78 }
				],
				"translate": [
					{ "time": 0, "x": -1, "y": -4 },
					{ "time": 0.1333, "x": -2.11, "y": -0.84 },
					{ "time": 0.2667, "x": -2.95, "y": -0.84 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 0, "y": -5 },
					{ "time": 0.2667, "x": 0.3, "y": 0 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0, "curve": "stepped" },
					{ "time": 0.0667, "angle": 0, "curve": "stepped" },
					{ "time": 0.1333, "angle": 0, "curve": "stepped" },
					{ "time": 0.2667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.25 },
					{ "time": 0.0667, "x": -1.27, "y": -0.15 },
					{ "time": 0.1333, "x": -0.14, "y": -0.02 },
					{ "time": 0.2667, "x": 0.13, "y": 0 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -52.43 },
					{ "time": 0.0667, "angle": -33.39 },
					{ "time": 0.1333, "angle": 16.03 },
					{ "time": 0.2667, "angle": 22.45 }
				],
				"translate": [
					{ "time": 0, "x": 1.44, "y": -0.49 },
					{ "time": 0.0667, "x": 1.39, "y": 1.21 },
					{ "time": 0.1333, "x": -2.11, "y": -0.84 },
					{ "time": 0.2667, "x": -2.95, "y": -0.84 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -3, "y": 0.17 },
					{ "time": 0.2667, "x": 1.26, "y": -0.07 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -3 },
					{ "time": 0.2667, "x": 0, "y": -0.22 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.72 },
					{ "time": 0.0667, "angle": 12.39 },
					{ "time": 0.2667, "angle": -22.59 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38 },
					{ "time": 0.0667, "x": -1.58, "y": -0.26 },
					{ "time": 0.2667, "x": -0.72, "y": 0.89 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 20.99 },
					{ "time": 0.1333, "angle": -6.16 },
					{ "time": 0.2667, "angle": 11.33 }
				],
				"translate": [
					{ "time": 0, "x": -0.8, "y": 1.08 },
					{ "time": 0.0667, "x": 0.42, "y": 0.07 },
					{ "time": 0.1333, "x": 0.81, "y": -1.22 },
					{ "time": 0.2667, "x": 0.62, "y": -0.62 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 },
					{ "time": 0.0667, "angle": 6.44, "curve": "stepped" },
					{ "time": 0.1333, "angle": 6.44 },
					{ "time": 0.2667, "angle": 0.93 }
				],
				"translate": [
					{ "time": 0, "x": 0.69, "y": 0.19, "curve": "stepped" },
					{ "time": 0.0667, "x": 0.69, "y": 0.19 },
					{ "time": 0.1333, "x": 0.11, "y": 0.29 },
					{ "time": 0.2667, "x": -0.02, "y": 0.31 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.0667,
							"vertices": [ -1.53334, -0.89462, -3.83543, -0.79669, -0.4744, -2.41572, 2.03394, 0.74669, 2.70701, -2.28235, 2.59918, -2.55335, 3.51335, -3.01763, 1.08935, -2.62828, -0.02432, -3.21703, -0.88627, -2.56293, 4.43325, -3.27341, 1.36435, -2.6783 ]
						}
					]
				}
			}
		}
	},
	"shoot": {
		"slots": {
			"cloak-up": {
				"attachment": [
					{ "time": 0.1667, "name": "cloak-up" }
				]
			}
		},
		"bones": {
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 4.63 },
					{ "time": 0.1667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": 0.87, "y": 0.37 },
					{ "time": 0.1667, "x": -3, "y": 0.17 }
				],
				"scale": [
					{ "time": 0.1667, "x": 1, "y": 1 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0, "curve": "stepped" },
					{ "time": 0.1667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.1667, "x": 0.62, "y": -0.25 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": 8.77 },
					{ "time": 0.1, "angle": -0.76 }
				],
				"translate": [
					{ "time": 0, "x": 4.5, "y": -2.78 },
					{ "time": 0.1, "x": 0.8, "y": 2.09 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 155.57 },
					{ "time": 0.1667, "angle": 5.9 }
				],
				"translate": [
					{ "time": 0, "x": 1.64, "y": -2.11 },
					{ "time": 0.1667, "x": 0, "y": 0 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": 22.45 },
					{ "time": 0.1667, "angle": -52.43 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 },
					{ "time": 0.1667, "x": 1.44, "y": -0.49 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -22.59 },
					{ "time": 0.1667, "angle": -26.72 }
				],
				"translate": [
					{ "time": 0, "x": -0.72, "y": 0.89 },
					{ "time": 0.1667, "x": -0.4, "y": 1.38 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 18.74 },
					{ "time": 0.1667, "angle": 0.68 }
				],
				"translate": [
					{ "time": 0, "x": -1.77, "y": -0.93 },
					{ "time": 0.1667, "x": 0, "y": -4 }
				],
				"scale": [
					{ "time": 0, "x": 1.106, "y": 1.106 },
					{ "time": 0.1667, "x": 0.873, "y": 0.873 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": -12.25 },
					{ "time": 0.1667, "angle": 16.45 }
				],
				"translate": [
					{ "time": 0, "x": -2.11, "y": -2.11 },
					{ "time": 0.1667, "x": -0.3, "y": -3.01 }
				],
				"scale": [
					{ "time": 0.1667, "x": 1, "y": 1 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0.1667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0.84 },
					{ "time": 0.1667, "x": 0, "y": -3 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0.1667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": 1.26, "y": -0.07 },
					{ "time": 0.1667, "x": -3, "y": 0.17 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 11.33 },
					{ "time": 0.1667, "angle": 20.99 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.62 },
					{ "time": 0.1667, "x": -0.8, "y": 1.08 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0.1667, "angle": 0 }
				],
				"translate": [
					{ "time": 0.1667, "x": 0, "y": 0 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0.93 },
					{ "time": 0.1667, "angle": 0 }
				],
				"translate": [
					{ "time": 0.1667, "x": 0.94, "y": 0.15 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": 14.78 },
					{ "time": 0.1667, "angle": -3.1 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 },
					{ "time": 0.1667, "x": -1, "y": -4 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0.1667, "x": 0, "y": -5 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 0.92 },
					{ "time": 0.1667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1667, "x": 0, "y": 0 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0.1,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			}
		},
		"drawOrder": [
			{ "time": 0.1 }
		]
	},
	"shoot_fast": {
		"slots": {
			"cloak-up": {
				"attachment": [
					{ "time": 0.0667, "name": "cloak-up" }
				]
			}
		},
		"bones": {
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 4.63 },
					{ "time": 0.0667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": 0.87, "y": 0.37 },
					{ "time": 0.0667, "x": -3, "y": 0.17 }
				],
				"scale": [
					{ "time": 0.0667, "x": 1, "y": 1 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0, "curve": "stepped" },
					{ "time": 0.0667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.0667, "x": 0.62, "y": -0.25 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": 8.77 },
					{ "time": 0.0333, "angle": -0.76 }
				],
				"translate": [
					{ "time": 0, "x": 4.5, "y": -2.78 },
					{ "time": 0.0333, "x": 0.8, "y": 2.09 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 155.57 },
					{ "time": 0.0667, "angle": 5.9 }
				],
				"translate": [
					{ "time": 0, "x": 1.64, "y": -2.11 },
					{ "time": 0.0667, "x": 0, "y": 0 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": 22.45 },
					{ "time": 0.0667, "angle": -52.43 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 },
					{ "time": 0.0667, "x": 1.44, "y": -0.49 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -22.59 },
					{ "time": 0.0667, "angle": -26.72 }
				],
				"translate": [
					{ "time": 0, "x": -0.72, "y": 0.89 },
					{ "time": 0.0667, "x": -0.4, "y": 1.38 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 18.74 },
					{ "time": 0.0667, "angle": 0.68 }
				],
				"translate": [
					{ "time": 0, "x": -1.77, "y": -0.93 },
					{ "time": 0.0667, "x": 0, "y": -4 }
				],
				"scale": [
					{ "time": 0, "x": 1.106, "y": 1.106 },
					{ "time": 0.0667, "x": 0.873, "y": 0.873 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": -12.25 },
					{ "time": 0.0667, "angle": 16.45 }
				],
				"translate": [
					{ "time": 0, "x": -2.11, "y": -2.11 },
					{ "time": 0.0667, "x": -0.3, "y": -3.01 }
				],
				"scale": [
					{ "time": 0.0667, "x": 1, "y": 1 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0.0667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0.84 },
					{ "time": 0.0667, "x": 0, "y": -3 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0.0667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": 1.26, "y": -0.07 },
					{ "time": 0.0667, "x": -3, "y": 0.17 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 11.33 },
					{ "time": 0.0667, "angle": 20.99 }
				],
				"translate": [
					{ "time": 0, "x": 0.62, "y": -0.62 },
					{ "time": 0.0667, "x": -0.8, "y": 1.08 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0.0667, "angle": 0 }
				],
				"translate": [
					{ "time": 0.0667, "x": 0, "y": 0 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0.93 },
					{ "time": 0.0667, "angle": 0 }
				],
				"translate": [
					{ "time": 0.0667, "x": 0.94, "y": 0.15 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": 14.78 },
					{ "time": 0.0667, "angle": -3.1 }
				],
				"translate": [
					{ "time": 0, "x": -2.95, "y": -0.84 },
					{ "time": 0.0667, "x": -1, "y": -4 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0.0667, "x": 0, "y": -5 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 0.92 },
					{ "time": 0.0667, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.0667, "x": 0, "y": 0 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0.0333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			}
		},
		"drawOrder": [
			{ "time": 0.0333 }
		]
	},
	"stand": {
		"slots": {
			"cloak-up": {
				"attachment": [
					{ "time": 0, "name": "cloak-up" },
					{ "time": 1.0667, "name": "cloak-up" }
				]
			}
		},
		"bones": {
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -52.43 },
					{ "time": 0.2667, "angle": -51.57 },
					{ "time": 0.5333, "angle": -49.13 },
					{ "time": 0.8, "angle": -51.57 },
					{ "time": 1.0667, "angle": -52.43 }
				],
				"translate": [
					{ "time": 0, "x": 1.44, "y": -0.49 },
					{ "time": 0.2667, "x": 1.94, "y": 1.68 },
					{ "time": 0.5333, "x": 1.65, "y": 3.31 },
					{ "time": 0.8, "x": 1.94, "y": 1.68 },
					{ "time": 1.0667, "x": 1.44, "y": -0.49 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -26.72, "curve": "stepped" },
					{ "time": 0.2667, "angle": -26.72 },
					{ "time": 0.5333, "angle": -23.74 },
					{ "time": 0.8, "angle": -26.72, "curve": "stepped" },
					{ "time": 1.0667, "angle": -26.72 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 0.2667, "x": -0.4, "y": 1.38 },
					{ "time": 0.5333, "x": -0.91, "y": 1.21 },
					{ "time": 0.8, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 1.0667, "x": -0.4, "y": 1.38 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 25.75 },
					{ "time": 0.2667, "angle": 30.75 },
					{ "time": 0.5333, "angle": 31.75 },
					{ "time": 0.8, "angle": 30.75 },
					{ "time": 1.0667, "angle": 25.75 }
				],
				"translate": [
					{ "time": 0, "x": -0.8, "y": 1.08 },
					{ "time": 0.2667, "x": -0.48, "y": 1.62 },
					{ "time": 0.5333, "x": -0.81, "y": 0.94 },
					{ "time": 0.8, "x": -0.48, "y": 1.62 },
					{ "time": 1.0667, "x": -0.8, "y": 1.08 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 16.45 },
					{ "time": 0.2667, "angle": 13.77 },
					{ "time": 0.5333, "angle": 8.3 },
					{ "time": 0.8, "angle": 13.77 },
					{ "time": 1.0667, "angle": 16.45 }
				],
				"translate": [
					{ "time": 0, "x": -0.3, "y": -3.01 },
					{ "time": 0.2667, "x": -0.89, "y": -0.91 },
					{ "time": 0.5333, "x": -0.6, "y": 0.89 },
					{ "time": 0.8, "x": -0.89, "y": -0.91 },
					{ "time": 1.0667, "x": -0.3, "y": -3.01 }
				]
			},
			"body-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -2 },
					{ "time": 0.2667, "x": 0, "y": -1 },
					{ "time": 0.5333, "x": 0, "y": 0 },
					{ "time": 0.8, "x": 0, "y": -1 },
					{ "time": 1.0667, "x": 0, "y": -2 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.2667, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.8, "angle": 2.27, "curve": "stepped" },
					{ "time": 1.0667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -1.99, "y": 0.11 },
					{ "time": 0.2667, "x": -1, "y": 0.06 },
					{ "time": 0.5333, "x": 0, "y": 0 },
					{ "time": 0.8, "x": -1, "y": 0.06 },
					{ "time": 1.0667, "x": -1.99, "y": 0.11 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.2667, "angle": 2.27, "curve": "stepped" },
					{ "time": 0.8, "angle": 2.27, "curve": "stepped" },
					{ "time": 1.0667, "angle": 2.27 }
				],
				"translate": [
					{ "time": 0, "x": -1.99, "y": 0.11 },
					{ "time": 0.2667, "x": -1, "y": 0.06 },
					{ "time": 0.5333, "x": 0, "y": 0 },
					{ "time": 0.8, "x": -1, "y": 0.06 },
					{ "time": 1.0667, "x": -1.99, "y": 0.11 }
				]
			},
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 0.68 },
					{ "time": 0.2667, "angle": -0.97 },
					{ "time": 0.5333, "angle": 0.71 },
					{ "time": 0.8, "angle": -0.97 },
					{ "time": 1.0667, "angle": 0.68 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -4 },
					{ "time": 0.2667, "x": 0, "y": -2 },
					{ "time": 0.5333, "x": 0, "y": 0 },
					{ "time": 0.8, "x": 0, "y": -2 },
					{ "time": 1.0667, "x": 0, "y": -4 }
				],
				"scale": [
					{ "time": 0, "x": 0.873, "y": 0.873 },
					{ "time": 0.5333, "x": 1.036, "y": 1.036 },
					{ "time": 1.0667, "x": 0.873, "y": 0.873 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.2667, "angle": -3.9 },
					{ "time": 0.5333, "angle": -3.04 },
					{ "time": 0.8, "angle": -3.9 },
					{ "time": 1.0667, "angle": -3.1 }
				],
				"translate": [
					{ "time": 0, "x": -1, "y": -4 },
					{ "time": 0.2667, "x": -1, "y": -2 },
					{ "time": 0.5333, "x": -1, "y": 0 },
					{ "time": 0.8, "x": -1, "y": -2 },
					{ "time": 1.0667, "x": -1, "y": -4 }
				]
			},
			"neck": {
				"rotate": [
					{ "time": 0.5333, "angle": 10.27 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -5 },
					{ "time": 0.5333, "x": 0, "y": 0 },
					{ "time": 0.8, "x": 0, "y": -1 },
					{ "time": 1.0667, "x": 0, "y": -5 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -0.76 },
					{ "time": 0.2667, "angle": -2.16 },
					{ "time": 0.5333, "angle": -6.08 },
					{ "time": 0.8, "angle": -2.16 },
					{ "time": 1.0667, "angle": -0.76 }
				],
				"translate": [
					{ "time": 0, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.2667, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.5333, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 0.8, "x": 0.8, "y": 2.09, "curve": "stepped" },
					{ "time": 1.0667, "x": 0.8, "y": 2.09 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 5.9 },
					{ "time": 0.2667, "angle": 2.29 },
					{ "time": 0.5333, "angle": 6.96 },
					{ "time": 0.8, "angle": 2.29 },
					{ "time": 1.0667, "angle": 5.9 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.5333, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.8, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 1.0667, "x": 0, "y": 0 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0.2667, "angle": 0, "curve": "stepped" },
					{ "time": 0.8, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.2667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.8, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 1.0667, "x": 0, "y": 0 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.49, "y": -0.44 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0.12, "y": -0.29 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlDragon": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlGold": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlHeart": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlIce": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlIron": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlLightning": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlSilver": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlSteel": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlWood": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.5333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 1.95362, -12.01363, 0.88757, -2.67981, 2.67833, -2.12355, 2.23429, -1.51979, 3.50062, -2.35602, 0.49579, -3.07751, 0.49579, -3.07751, 0.39266, -7.29717, 2.74411, -3.09847, 1.24525, -3.08445 ]
						},
						{
							"time": 0.8,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 1.0667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			}
		}
	},
	"walk": {
		"slots": {
			"body-down": {
				"attachment": [
					{ "time": 0, "name": "body-down" },
					{ "time": 0.1667, "name": "body-down" },
					{ "time": 0.3333, "name": "body-down" },
					{ "time": 0.5, "name": "body-down" },
					{ "time": 0.6667, "name": "body-down" }
				]
			},
			"cloak-up": {
				"attachment": [
					{ "time": 0, "name": "cloak-up" },
					{ "time": 0.6667, "name": "cloak-up" }
				]
			}
		},
		"bones": {
			"body-up": {
				"rotate": [
					{ "time": 0, "angle": 0.68 },
					{ "time": 0.1667, "angle": -0.97 },
					{ "time": 0.3333, "angle": 0.68 },
					{ "time": 0.5, "angle": -0.97 },
					{ "time": 0.6667, "angle": 0.68 }
				],
				"translate": [
					{ "time": 0, "x": -0.01, "y": -5 },
					{ "time": 0.1667, "x": -0.01, "y": -3 },
					{ "time": 0.3333, "x": -0.01, "y": -5 },
					{ "time": 0.5, "x": -0.01, "y": -3 },
					{ "time": 0.6667, "x": -0.01, "y": -5 }
				],
				"scale": [
					{ "time": 0, "x": 0.873, "y": 0.873, "curve": "stepped" },
					{ "time": 0.3333, "x": 0.873, "y": 0.873, "curve": "stepped" },
					{ "time": 0.6667, "x": 0.873, "y": 0.873 }
				]
			},
			"righthand-up": {
				"rotate": [
					{ "time": 0, "angle": -64.74 },
					{ "time": 0.1667, "angle": -58.16 },
					{ "time": 0.3333, "angle": -52.26 },
					{ "time": 0.5, "angle": -58.16 },
					{ "time": 0.6667, "angle": -64.74 }
				],
				"translate": [
					{ "time": 0, "x": 1.43, "y": -1.49 },
					{ "time": 0.1667, "x": 1.93, "y": 0.68 },
					{ "time": 0.3333, "x": 1.43, "y": -1.49 },
					{ "time": 0.5, "x": 1.93, "y": 0.68 },
					{ "time": 0.6667, "x": 1.43, "y": -1.49 }
				]
			},
			"leftleg-up": {
				"rotate": [
					{ "time": 0, "angle": 9.66 },
					{ "time": 0.1667, "angle": 2.27 },
					{ "time": 0.3333, "angle": 36.51 },
					{ "time": 0.5, "angle": 2.27 },
					{ "time": 0.6667, "angle": 9.66 }
				],
				"translate": [
					{ "time": 0, "x": -2, "y": 0.1 },
					{ "time": 0.1667, "x": 0, "y": -0.01 },
					{ "time": 0.3333, "x": -0.97, "y": -3.19 },
					{ "time": 0.5, "x": 0, "y": -0.01 },
					{ "time": 0.6667, "x": -2, "y": 0.1 }
				]
			},
			"righthand-down": {
				"rotate": [
					{ "time": 0, "angle": -48.28 },
					{ "time": 0.1667, "angle": -26.72 },
					{ "time": 0.3333, "angle": -9.91 },
					{ "time": 0.5, "angle": -26.72 },
					{ "time": 0.6667, "angle": -48.28 }
				],
				"translate": [
					{ "time": 0, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 0.1667, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 0.3333, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 0.5, "x": -0.4, "y": 1.38, "curve": "stepped" },
					{ "time": 0.6667, "x": -0.4, "y": 1.38 }
				]
			},
			"cloak-down": {
				"rotate": [
					{ "time": 0, "angle": -0.76 },
					{ "time": 0.1667, "angle": -2.16 },
					{ "time": 0.3333, "angle": -0.76 },
					{ "time": 0.5, "angle": -2.16 },
					{ "time": 0.6667, "angle": -0.76 }
				],
				"translate": [
					{ "time": 0, "x": 1.8, "y": 2.03 },
					{ "time": 0.1667, "x": 0.8, "y": 2.09 },
					{ "time": 0.3333, "x": 1.8, "y": 2.03 },
					{ "time": 0.5, "x": 0.8, "y": 2.09 },
					{ "time": 0.6667, "x": 1.8, "y": 2.03 }
				]
			},
			"lefthand-down": {
				"rotate": [
					{ "time": 0, "angle": 32.54 },
					{ "time": 0.1667, "angle": 2.29 },
					{ "time": 0.3333, "angle": 24.14 },
					{ "time": 0.5, "angle": 2.29 },
					{ "time": 0.6667, "angle": 32.54 }
				],
				"translate": [
					{ "time": 0, "x": 0.7, "y": -0.79 },
					{ "time": 0.1667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.3333, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.5, "x": 0, "y": 0 },
					{ "time": 0.6667, "x": 0.7, "y": -0.79 }
				]
			},
			"face": {
				"rotate": [
					{ "time": 0, "angle": -3.1 },
					{ "time": 0.1667, "angle": -3.9 },
					{ "time": 0.3333, "angle": -3.1 },
					{ "time": 0.5, "angle": -3.9 },
					{ "time": 0.6667, "angle": -3.1 }
				],
				"translate": [
					{ "time": 0, "x": -1.01, "y": -5 },
					{ "time": 0.1667, "x": -1.01, "y": -3 },
					{ "time": 0.3333, "x": -1.01, "y": -5 },
					{ "time": 0.5, "x": -1.01, "y": -3 },
					{ "time": 0.6667, "x": -1.01, "y": -5 }
				]
			},
			"bow": {
				"rotate": [
					{ "time": 0, "angle": 37.75 },
					{ "time": 0.1667, "angle": 25.47 },
					{ "time": 0.3333, "angle": 14.12 },
					{ "time": 0.5, "angle": 25.47 },
					{ "time": 0.6667, "angle": 37.75 }
				],
				"translate": [
					{ "time": 0, "x": -0.8, "y": 1.08 },
					{ "time": 0.1667, "x": -0.48, "y": 1.62 },
					{ "time": 0.3333, "x": -0.81, "y": 0.94 },
					{ "time": 0.5, "x": -0.48, "y": 1.62 },
					{ "time": 0.6667, "x": -0.8, "y": 1.08 }
				]
			},
			"lefthand-up": {
				"rotate": [
					{ "time": 0, "angle": 40.19 },
					{ "time": 0.1667, "angle": 17.17 },
					{ "time": 0.3333, "angle": -8.11 },
					{ "time": 0.5, "angle": 17.17 },
					{ "time": 0.6667, "angle": 40.19 }
				],
				"translate": [
					{ "time": 0, "x": -2.04, "y": -3.5 },
					{ "time": 0.1667, "x": -0.9, "y": -1.91 },
					{ "time": 0.3333, "x": 0.43, "y": -5.26 },
					{ "time": 0.5, "x": -0.91, "y": -2.67 },
					{ "time": 0.6667, "x": -2.04, "y": -3.5 }
				]
			},
			"neck": {
				"translate": [
					{ "time": 0, "x": 0, "y": -5 },
					{ "time": 0.3333, "x": 0.01, "y": -3.42 },
					{ "time": 0.6667, "x": 0, "y": -5 }
				]
			},
			"rightleg-up": {
				"rotate": [
					{ "time": 0, "angle": 18.89 },
					{ "time": 0.1667, "angle": 2.27 },
					{ "time": 0.3333, "angle": -27.16 },
					{ "time": 0.5, "angle": 2.27 },
					{ "time": 0.6667, "angle": 18.89 }
				],
				"translate": [
					{ "time": 0, "x": -0.66, "y": -2.22 },
					{ "time": 0.1667, "x": 0, "y": -0.01 },
					{ "time": 0.3333, "x": -2.18, "y": 1.6 },
					{ "time": 0.5, "x": 0, "y": -0.01 },
					{ "time": 0.6667, "x": -0.66, "y": -2.22 }
				]
			},
			"cloak-up": {
				"rotate": [
					{ "time": 0.1667, "angle": 0, "curve": "stepped" },
					{ "time": 0.5, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.1667, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.5, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.6667, "x": 0, "y": 0 }
				]
			},
			"body-down": {
				"translate": [
					{ "time": 0, "x": 0, "y": -3 },
					{ "time": 0.1667, "x": 0, "y": -1 },
					{ "time": 0.3333, "x": 0, "y": -3 },
					{ "time": 0.5, "x": 0, "y": -1 },
					{ "time": 0.6667, "x": 0, "y": -3 }
				]
			},
			"leftleg-down": {
				"rotate": [
					{ "time": 0, "angle": -31.49 },
					{ "time": 0.1667, "angle": -0.06 },
					{ "time": 0.3333, "angle": -9.26 },
					{ "time": 0.5, "angle": -0.06 },
					{ "time": 0.6667, "angle": -31.49 }
				],
				"translate": [
					{ "time": 0, "x": -2, "y": 0.12 },
					{ "time": 0.1667, "x": -0.59, "y": 0.21 },
					{ "time": 0.3333, "x": 0, "y": 0.26 },
					{ "time": 0.5, "x": -0.59, "y": 0.21 },
					{ "time": 0.6667, "x": -2, "y": 0.12 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": 0.42 }
				],
				"translate": [
					{ "time": 0.6667, "x": 0, "y": -0.38 }
				]
			},
			"rightleg-down": {
				"rotate": [
					{ "time": 0, "angle": 0, "curve": "stepped" },
					{ "time": 0.1667, "angle": 0 },
					{ "time": 0.3333, "angle": -21.48 },
					{ "time": 0.5, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": -0.46, "y": 0.23 },
					{ "time": 0.1667, "x": -0.4, "y": 0.07, "curve": "stepped" },
					{ "time": 0.3333, "x": -0.4, "y": 0.07 }
				]
			}
		},
		"deform": {
			"RedGirlCopper": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlDragon": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlGold": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlHeart": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlIce": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlIron": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlLightning": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlSilver": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlSteel": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			},
			"RedGirlWood": {
				"cloak-down": {
					"cloak-down": [
						{
							"time": 0,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.1667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.3333,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						},
						{
							"time": 0.5,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, 2.17802, -7.51506, 0.11748, -3.44865, 1.61634, -3.46266, 1.17938, -2.10948, 2.59839, -2.64735, 0.49579, -3.07751, 0.49579, -3.07751, -1.26374, -6.88319, 2.74411, -3.09847, 0.19035, -3.67415 ]
						},
						{
							"time": 0.6667,
							"vertices": [ 0.49579, -3.07751, -2.58178, -3.57321, -1.53722, -5.84259, 0.40511, -2.3691, 0.99363, -4.94333, 1.06411, -4.67981, 2.20617, -4.51737, 0.49579, -3.07751, 0.49579, -3.07751, -1.85565, -5.61254, 3.55228, -4.82987, 0.42534, -4.89394 ]
						}
					]
				}
			}
		}
	}
}
}
```

`Samples/SuperLittleRed/IOS/Animation/wood.atlas`:

```atlas

wood.png
size: 128,64
format: RGBA8888
filter: Linear,Linear
repeat: none
arroy
  rotate: false
  xy: 42, 55
  size: 45, 7
  orig: 45, 7
  offset: 0, 0
  index: -1
body
  rotate: false
  xy: 2, 30
  size: 38, 32
  orig: 38, 32
  offset: 0, 0
  index: -1
l-hand
  rotate: false
  xy: 2, 8
  size: 23, 20
  orig: 23, 20
  offset: 0, 0
  index: -1
l-leg
  rotate: false
  xy: 27, 16
  size: 6, 12
  orig: 6, 12
  offset: 0, 0
  index: -1
r-hand
  rotate: false
  xy: 42, 33
  size: 22, 20
  orig: 22, 20
  offset: 0, 0
  index: -1
r-leg
  rotate: false
  xy: 27, 2
  size: 5, 12
  orig: 5, 12
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/Animation/wood.json`:

```json
{
"skeleton": { "hash": "X+fHLjV4Jesv+v3THiRqaKRJOx4", "spine": "3.6.04-beta", "width": 74.33, "height": 43.45 },
"bones": [
	{ "name": "root", "rotation": 0.9 },
	{ "name": "l-hand", "parent": "root", "length": 16.63, "rotation": 146.51, "x": -16.23, "y": 17.25 },
	{ "name": "arroy", "parent": "l-hand", "length": 17.73, "rotation": 93.26, "x": 11.33, "y": 1.7 },
	{ "name": "body", "parent": "root", "length": 11.59, "rotation": -91.35, "x": -0.58, "y": 18.94 },
	{ "name": "l-leg", "parent": "root", "length": 8.3, "rotation": -91.82, "x": -7.66, "y": 8.58 },
	{ "name": "r-hand", "parent": "root", "length": 16.45, "rotation": 35.44, "x": 15.17, "y": 16.76 },
	{ "name": "r-leg", "parent": "root", "length": 7.09, "rotation": -91.82, "x": 6.49, "y": 7.56 }
],
"slots": [
	{ "name": "arroy", "bone": "arroy", "attachment": "arroy" },
	{ "name": "r-hand", "bone": "r-hand", "attachment": "r-hand" },
	{ "name": "l-hand", "bone": "l-hand", "attachment": "l-hand" },
	{ "name": "l-leg", "bone": "l-leg", "attachment": "l-leg" },
	{ "name": "r-leg", "bone": "r-leg", "attachment": "r-leg" },
	{ "name": "body", "bone": "body", "attachment": "body" },
	{ "name": "CollisionBox", "bone": "body", "attachment": "CollisionBox" },
	{ "name": "AttackBox", "bone": "arroy", "attachment": "AttackBox" }
],
"skins": {
	"default": {
		"AttackBox": {
			"AttackBox": {
				"type": "boundingbox",
				"vertexCount": 3,
				"vertices": [ 20.52, -1.8, -9.96, 0.77, -10.11, -2.85 ]
			}
		},
		"CollisionBox": {
			"CollisionBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ 10.16, -15, 10.34, 13.84, -16.48, 17.32, -16.62, -16.98 ]
			}
		},
		"arroy": {
			"arroy": { "x": 0.64, "y": -2.32, "rotation": 179.45, "width": 45, "height": 7 }
		},
		"body": {
			"body": { "x": -3.99, "y": 0.68, "rotation": 90.35, "width": 38, "height": 32 }
		},
		"l-hand": {
			"l-hand": { "x": 6.99, "y": -1.16, "rotation": -146.51, "width": 23, "height": 20 }
		},
		"l-leg": {
			"l-leg": { "x": 2.32, "y": -0.26, "rotation": 91.82, "width": 6, "height": 12 }
		},
		"r-hand": {
			"r-hand": { "x": 6.32, "y": 0.6, "rotation": -35.44, "width": 22, "height": 20 }
		},
		"r-leg": {
			"r-leg": { "x": 1.59, "y": -0.42, "rotation": 91.82, "width": 5, "height": 12 }
		}
	}
},
"animations": {
	"attack": {
		"bones": {
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": 360, "curve": "stepped" },
					{ "time": 0.1667, "angle": 360 },
					{ "time": 0.3333, "angle": 48.09 },
					{ "time": 0.5, "angle": 360.36 },
					{ "time": 0.6667, "angle": 1.39 },
					{ "time": 0.8333, "angle": 360 }
				],
				"translate": [
					{ "time": 0, "x": 0.29, "y": 0, "curve": "stepped" },
					{ "time": 0.1667, "x": 0.29, "y": 0 },
					{ "time": 0.3333, "x": 6.73, "y": 5.77 },
					{ "time": 0.5, "x": -3.12, "y": -0.16 },
					{ "time": 0.6667, "x": 0.16, "y": 0 },
					{ "time": 0.8333, "x": 0.29, "y": 0 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.1667, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.5, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.6667, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.8333, "x": 1, "y": 1 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -53.5 },
					{ "time": 0.1667, "angle": -83.57 },
					{ "time": 0.3333, "angle": -1.6 },
					{ "time": 0.5, "angle": 278.37 },
					{ "time": 0.8333, "angle": -53.5 }
				],
				"translate": [
					{ "time": 0, "x": 0.08, "y": 3.42 },
					{ "time": 0.1667, "x": -1.51, "y": 0.83 },
					{ "time": 0.3333, "x": -2.3, "y": 12.34 },
					{ "time": 0.5, "x": -2.6, "y": 2.76 },
					{ "time": 0.8333, "x": 0.08, "y": 3.42 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": 325.52 },
					{ "time": 0.1667, "angle": -44.81 },
					{ "time": 0.3333, "angle": 3.8 },
					{ "time": 0.5, "angle": 358.48 },
					{ "time": 0.6667, "angle": -49.18 },
					{ "time": 0.8333, "angle": 325.52 }
				],
				"translate": [
					{ "time": 0, "x": -5.34, "y": 4.95 },
					{ "time": 0.1667, "x": -7.94, "y": 5.5 },
					{ "time": 0.3333, "x": -1.89, "y": 0.39 },
					{ "time": 0.5, "x": 1.92, "y": -0.15 },
					{ "time": 0.6667, "x": -9.67, "y": 7.04 },
					{ "time": 0.8333, "x": -5.34, "y": 4.95 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": 38.57 },
					{ "time": 0.1667, "angle": -20.08 },
					{ "time": 0.3333, "angle": -255.6 },
					{ "time": 0.5, "angle": -283.88 },
					{ "time": 0.6667, "angle": 8.03 },
					{ "time": 0.8333, "angle": 38.57 }
				],
				"translate": [
					{ "time": 0, "x": 1.83, "y": 6.97, "curve": "stepped" },
					{ "time": 0.1667, "x": 1.83, "y": 6.97 },
					{ "time": 0.3333, "x": 0.94, "y": 2.35 },
					{ "time": 0.5, "x": 1.69, "y": 2.05 },
					{ "time": 0.6667, "x": 1.83, "y": 10.08 },
					{ "time": 0.8333, "x": 1.83, "y": 6.97 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 352.52 },
					{ "time": 0.1667, "angle": -15.58 },
					{ "time": 0.3333, "angle": 19.32 },
					{ "time": 0.5, "angle": 361.75 },
					{ "time": 0.6667, "angle": -22.18 },
					{ "time": 0.8333, "angle": 352.52 }
				],
				"translate": [
					{ "time": 0, "x": 0.03, "y": 2, "curve": "stepped" },
					{ "time": 0.1667, "x": 0.03, "y": 2 },
					{ "time": 0.3333, "x": -1.57, "y": 0.63 },
					{ "time": 0.5, "x": -0.22, "y": -0.01 },
					{ "time": 0.6667, "x": 0.03, "y": 2, "curve": "stepped" },
					{ "time": 0.8333, "x": 0.03, "y": 2 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 21.94 },
					{ "time": 0.1667, "angle": -28.94 },
					{ "time": 0.8333, "angle": 21.94 }
				],
				"translate": [
					{ "time": 0, "x": -2.98, "y": -1.7 },
					{ "time": 0.1667, "x": -0.05, "y": 1.32 },
					{ "time": 0.8333, "x": -2.98, "y": -1.7 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": -0.23 }
				]
			}
		}
	},
	"die": {
		"bones": {
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": -0.91 },
					{ "time": 0.1667, "angle": -19.98 },
					{ "time": 0.3333, "angle": -65.43 },
					{ "time": 0.5, "angle": 270.93 }
				],
				"translate": [
					{ "time": 0, "x": 0.55, "y": -0.01 },
					{ "time": 0.1667, "x": -2.05, "y": 1.08 },
					{ "time": 0.3333, "x": 5.25, "y": 0.44 },
					{ "time": 0.5, "x": 12.48, "y": -4.89 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.1667, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.3333, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.5, "x": 1, "y": 1 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -86.55 },
					{ "time": 0.1667, "angle": -45.61 },
					{ "time": 0.3333, "angle": -57.21 },
					{ "time": 0.5, "angle": -34.86 }
				],
				"translate": [
					{ "time": 0, "x": 1.46, "y": 2.06 },
					{ "time": 0.1667, "x": -2.72, "y": 0.04 },
					{ "time": 0.3333, "x": 15.52, "y": -1.81 },
					{ "time": 0.5, "x": 16.39, "y": -13.31 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 45.02 },
					{ "time": 0.1667, "angle": -20.05, "curve": "stepped" },
					{ "time": 0.3333, "angle": -20.05 },
					{ "time": 0.5, "angle": 73.88 }
				],
				"translate": [
					{ "time": 0, "x": -3.99, "y": -1.69 },
					{ "time": 0.1667, "x": 16.47, "y": -18.76, "curve": "stepped" },
					{ "time": 0.3333, "x": 16.47, "y": -18.76 },
					{ "time": 0.5, "x": 13.85, "y": -11.77 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": -296.2 },
					{ "time": 0.1667, "angle": -14.1 },
					{ "time": 0.3333, "angle": -67.53 },
					{ "time": 0.5, "angle": -130.34 }
				],
				"translate": [
					{ "time": 0, "x": -0.09, "y": 3.74 },
					{ "time": 0.1667, "x": 1.22, "y": 11.88 },
					{ "time": 0.3333, "x": 9.92, "y": 34.19 },
					{ "time": 0.5, "x": 20.14, "y": -13.47 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 1.03 },
					{ "time": 0.1667, "angle": -20.06 },
					{ "time": 0.3333, "angle": -35.34 },
					{ "time": 0.5, "angle": -80.04 }
				],
				"translate": [
					{ "time": 0, "x": 1, "y": -0.86 },
					{ "time": 0.1667, "x": 0.25, "y": 4 },
					{ "time": 0.3333, "x": 16.1, "y": 16.28 },
					{ "time": 0.5, "x": 27.31, "y": -1.64 }
				],
				"scale": [
					{ "time": 0, "x": 1.023, "y": 1.023 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": -2.79 },
					{ "time": 0.1667, "angle": -53.48 },
					{ "time": 0.3333, "angle": 269.82 },
					{ "time": 0.5, "angle": 267.64 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -0.02 },
					{ "time": 0.1667, "x": -6.76, "y": 8.51 },
					{ "time": 0.3333, "x": 4.18, "y": 6.77 },
					{ "time": 0.5, "x": 13.91, "y": -5.39 }
				]
			}
		}
	},
	"die_over": {
		"slots": {
			"arroy": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			},
			"body": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			},
			"l-hand": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			},
			"l-leg": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			},
			"r-hand": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			},
			"r-leg": {
				"color": [
					{ "time": 0, "color": "ffffffff" },
					{ "time": 1.3333, "color": "ffffff00" }
				]
			}
		},
		"bones": {
			"body": {
				"rotate": [
					{ "time": 0, "angle": -80.04 }
				],
				"translate": [
					{ "time": 0, "x": 27.31, "y": -1.64 }
				]
			},
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": 270.93 }
				],
				"translate": [
					{ "time": 0, "x": 12.48, "y": -4.89 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": -130.34 }
				],
				"translate": [
					{ "time": 0, "x": 20.14, "y": -13.47 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 73.88 }
				],
				"translate": [
					{ "time": 0, "x": 13.85, "y": -11.77 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -34.86 }
				],
				"translate": [
					{ "time": 0, "x": 16.39, "y": -13.31 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": 267.64 }
				],
				"translate": [
					{ "time": 0, "x": 13.91, "y": -5.39 }
				]
			}
		}
	},
	"dizzy": {
		"bones": {
			"root": {
				"rotate": [
					{ "time": 0, "angle": 9.1 },
					{ "time": 0.3333, "angle": -0.9 },
					{ "time": 0.6667, "angle": 344.1 },
					{ "time": 1, "angle": -0.9 },
					{ "time": 1.3333, "angle": 9.1 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -0.44 },
					{ "time": 0.3333, "x": 0, "y": 0.06 },
					{ "time": 0.6667, "x": 0, "y": -0.44 },
					{ "time": 1, "x": 0, "y": 0.06 },
					{ "time": 1.3333, "x": 0, "y": -0.44 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 1.42 },
					{ "time": 0.3333, "x": 0, "y": -0.08 },
					{ "time": 0.6667, "x": 0, "y": -1.58 },
					{ "time": 1, "x": 0, "y": -0.08 },
					{ "time": 1.3333, "x": 0, "y": 1.42 }
				]
			},
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -0.76 },
					{ "time": 0.3333, "x": 0, "y": 0.24 },
					{ "time": 0.6667, "x": 0, "y": 2.24 },
					{ "time": 1, "x": 0, "y": 0.24 },
					{ "time": 1.3333, "x": 0, "y": -0.76 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 42.2 },
					{ "time": 0.3333, "angle": 36.74 },
					{ "time": 0.6667, "angle": 31.74 },
					{ "time": 1, "angle": 36.74 },
					{ "time": 1.3333, "angle": 42.2 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": -308.42 },
					{ "time": 0.3333, "angle": 41.58 },
					{ "time": 0.6667, "angle": 31.58 },
					{ "time": 1, "angle": 41.58 },
					{ "time": 1.3333, "angle": -308.42 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -62.83 },
					{ "time": 0.3333, "angle": 317.18 },
					{ "time": 0.6667, "angle": -16.74 },
					{ "time": 1, "angle": 317.18 },
					{ "time": 1.3333, "angle": -62.83 }
				]
			}
		}
	},
	"hurt": {
		"bones": {
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 45.02 },
					{ "time": 0.1667, "angle": -20.05 },
					{ "time": 0.3333, "angle": 45.02 }
				],
				"translate": [
					{ "time": 0, "x": -3.99, "y": -1.69 },
					{ "time": 0.1667, "x": 16.47, "y": -18.76 },
					{ "time": 0.3333, "x": -3.99, "y": -1.69 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": -296.2 },
					{ "time": 0.3333, "angle": -14.1 },
					{ "time": 0.6667, "angle": -296.2 }
				],
				"translate": [
					{ "time": 0, "x": -0.09, "y": 3.74 },
					{ "time": 0.3333, "x": 1.22, "y": 11.88 },
					{ "time": 0.6667, "x": -0.09, "y": 3.74 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": -2.79 },
					{ "time": 0.1667, "angle": -53.48 },
					{ "time": 0.3333, "angle": -2.79 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": -0.02 },
					{ "time": 0.1667, "x": -6.76, "y": 8.51 },
					{ "time": 0.3333, "x": 0, "y": -0.02 }
				]
			},
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": -0.91 },
					{ "time": 0.3333, "angle": -19.98 },
					{ "time": 0.6667, "angle": -0.91 }
				],
				"translate": [
					{ "time": 0, "x": 0.55, "y": -0.01 },
					{ "time": 0.3333, "x": -2.05, "y": 1.08 },
					{ "time": 0.6667, "x": 0.55, "y": -0.01 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.3333, "x": 1, "y": 1, "curve": "stepped" },
					{ "time": 0.6667, "x": 1, "y": 1 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -86.55 },
					{ "time": 0.3333, "angle": -45.61 },
					{ "time": 0.6667, "angle": -86.55 }
				],
				"translate": [
					{ "time": 0, "x": 1.46, "y": 2.06 },
					{ "time": 0.3333, "x": -2.72, "y": 0.04 },
					{ "time": 0.6667, "x": 1.46, "y": 2.06 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 1.03 },
					{ "time": 0.3333, "angle": -20.06 },
					{ "time": 0.6667, "angle": 1.03 }
				],
				"translate": [
					{ "time": 0, "x": 1, "y": -0.86 },
					{ "time": 0.3333, "x": 0.25, "y": 4 },
					{ "time": 0.6667, "x": 1, "y": -0.86 }
				],
				"scale": [
					{ "time": 0, "x": 1.023, "y": 1.023, "curve": "stepped" },
					{ "time": 0.6667, "x": 1.023, "y": 1.023 }
				]
			}
		}
	},
	"stand": {
		"slots": {
			"arroy": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			},
			"body": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			},
			"l-hand": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			},
			"l-leg": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			},
			"r-hand": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			},
			"r-leg": {
				"color": [
					{ "time": 0, "color": "ffffffff" }
				]
			}
		},
		"bones": {
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			},
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": 50.25 },
					{ "time": 0.3333, "angle": 70.43 },
					{ "time": 0.6667, "angle": 50.25 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.414, "x": 0, "y": 0, "curve": "stepped" },
					{ "time": 0.4992, "x": 0, "y": 0 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 33.48 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -60.74 },
					{ "time": 0.3333, "angle": 279 },
					{ "time": 0.6667, "angle": -60.74 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 0 }
				],
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.3333, "x": 0, "y": -2 },
					{ "time": 0.6667, "x": 0, "y": 0 }
				],
				"scale": [
					{ "time": 0, "x": 1, "y": 1 },
					{ "time": 0.3333, "x": 0.95, "y": 0.95 },
					{ "time": 0.6667, "x": 1, "y": 1 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": -0.9 }
				]
			}
		}
	},
	"walk": {
		"bones": {
			"l-leg": {
				"rotate": [
					{ "time": 0, "angle": 325.52 },
					{ "time": 0.1667, "angle": -2.79 },
					{ "time": 0.3333, "angle": 3.8 },
					{ "time": 0.5, "angle": -2.79 },
					{ "time": 0.6667, "angle": 325.52 }
				],
				"translate": [
					{ "time": 0, "x": -5.34, "y": 1.42 },
					{ "time": 0.1667, "x": 0, "y": -0.18 },
					{ "time": 0.3333, "x": 0.16, "y": -0.16 },
					{ "time": 0.5, "x": 0, "y": -0.28 },
					{ "time": 0.6667, "x": -5.34, "y": 1.42 }
				]
			},
			"l-hand": {
				"rotate": [
					{ "time": 0, "angle": 38.57 },
					{ "time": 0.1667, "angle": -280.31 },
					{ "time": 0.3333, "angle": -301.06 },
					{ "time": 0.5, "angle": -280.31 },
					{ "time": 0.6667, "angle": 38.57 }
				],
				"translate": [
					{ "time": 0, "x": 1.83, "y": 6.97 },
					{ "time": 0.1667, "x": 3.34, "y": 2.83 },
					{ "time": 0.3333, "x": 0.63, "y": -0.1 },
					{ "time": 0.5, "x": 3.34, "y": 2.83 },
					{ "time": 0.6667, "x": 1.83, "y": 6.97 }
				]
			},
			"body": {
				"rotate": [
					{ "time": 0, "angle": 352.52 },
					{ "time": 0.1667, "angle": 0.49 },
					{ "time": 0.3333, "angle": 11.19 },
					{ "time": 0.5, "angle": 0.49 },
					{ "time": 0.6667, "angle": 352.52 }
				],
				"translate": [
					{ "time": 0, "x": 0.03, "y": 2 },
					{ "time": 0.1667, "x": 0.67, "y": -3.44 },
					{ "time": 0.3333, "x": -0.04, "y": 0.34 },
					{ "time": 0.5, "x": 0.67, "y": -3.44 },
					{ "time": 0.6667, "x": 0.03, "y": 2 }
				]
			},
			"arroy": {
				"rotate": [
					{ "time": 0, "angle": 21.94 },
					{ "time": 0.1667, "angle": 45.02 },
					{ "time": 0.3333, "angle": 31.36 },
					{ "time": 0.5, "angle": 45.02 },
					{ "time": 0.6667, "angle": 21.94 }
				],
				"translate": [
					{ "time": 0, "x": -2.98, "y": -1.7 },
					{ "time": 0.1667, "x": -3.99, "y": -1.69 },
					{ "time": 0.3333, "x": -2.9, "y": -1.85 },
					{ "time": 0.5, "x": -3.99, "y": -1.69 },
					{ "time": 0.6667, "x": -2.98, "y": -1.7 }
				]
			},
			"r-hand": {
				"rotate": [
					{ "time": 0, "angle": -53.5 },
					{ "time": 0.1667, "angle": 277.11 },
					{ "time": 0.3333, "angle": -47.33 },
					{ "time": 0.5, "angle": 277.11 },
					{ "time": 0.6667, "angle": -53.5 }
				],
				"translate": [
					{ "time": 0, "x": 0.08, "y": 3.42 },
					{ "time": 0.1667, "x": -2.25, "y": 3.55 },
					{ "time": 0.3333, "x": -1.02, "y": 4.18 },
					{ "time": 0.5, "x": -2.25, "y": 3.55 },
					{ "time": 0.6667, "x": 0.08, "y": 3.42 }
				]
			},
			"r-leg": {
				"rotate": [
					{ "time": 0, "angle": 360 },
					{ "time": 0.1667, "angle": -0.91 },
					{ "time": 0.3333, "angle": 33.17 },
					{ "time": 0.5, "angle": -0.91 },
					{ "time": 0.6667, "angle": 360 }
				],
				"translate": [
					{ "time": 0, "x": 0.29, "y": 0 },
					{ "time": 0.1667, "x": 0.55, "y": -0.01 },
					{ "time": 0.3333, "x": 5.9, "y": 3.27 },
					{ "time": 0.5, "x": 0.55, "y": -0.01 },
					{ "time": 0.6667, "x": 0.29, "y": 0 }
				]
			},
			"root": {
				"rotate": [
					{ "time": 0, "angle": -0.23 },
					{ "time": 0.1667, "angle": -0.75 },
					{ "time": 0.3333, "angle": -1.27 },
					{ "time": 0.5, "angle": -0.75 },
					{ "time": 0.6667, "angle": -0.23 }
				]
			}
		}
	}
}
}
```

`Samples/SuperLittleRed/IOS/AppDelegate.swift`:

```swift
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-3-13
 * Update   : 2019-2-21
 * Author   : scott.cgi
 */


import UIKit


@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        AApplication.Init()
        
        return true
    }

    func applicationWillResignActive(_ application: UIApplication) {
        // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.
        
        AApplication.Pause()
    }

    func applicationDidEnterBackground(_ application: UIApplication) {
        // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
        
        AApplication.SaveData(nil)
    }

    func applicationWillEnterForeground(_ application: UIApplication) {
        // Called as part of the transition from the background to the active state; here you can undo many of the changes made on entering the background.
    }

    func applicationDidBecomeActive(_ application: UIApplication) {
        // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
        
        AApplication.Resume()
    }

    func applicationWillTerminate(_ application: UIApplication) {
        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:
        
        AApplication.SaveData(nil)
        AApplication.Destroy()
    }
}


```

`Samples/SuperLittleRed/IOS/Assets.xcassets/AppIcon.appiconset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "iphone",
      "size" : "20x20",
      "scale" : "2x"
    },
    {
      "idiom" : "iphone",
      "size" : "20x20",
      "scale" : "3x"
    },
    {
      "idiom" : "iphone",
      "size" : "29x29",
      "scale" : "2x"
    },
    {
      "idiom" : "iphone",
      "size" : "29x29",
      "scale" : "3x"
    },
    {
      "idiom" : "iphone",
      "size" : "40x40",
      "scale" : "2x"
    },
    {
      "idiom" : "iphone",
      "size" : "40x40",
      "scale" : "3x"
    },
    {
      "idiom" : "iphone",
      "size" : "60x60",
      "scale" : "2x"
    },
    {
      "idiom" : "iphone",
      "size" : "60x60",
      "scale" : "3x"
    },
    {
      "idiom" : "ios-marketing",
      "size" : "1024x1024",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
```

`Samples/SuperLittleRed/IOS/Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
```

`Samples/SuperLittleRed/IOS/Base.lproj/LaunchScreen.storyboard`:

```storyboard
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <device id="retina4_7" orientation="landscape">
        <adaptation id="fullscreen"/>
    </device>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="14490.49"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="667" height="375"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <viewLayoutGuide key="safeArea" id="3iz-UD-f3I"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <color key="tintColor" white="0.0" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
</document>

```

`Samples/SuperLittleRed/IOS/Base.lproj/Main.storyboard`:

```storyboard
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12118" systemVersion="16F73" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" colorMatched="YES" initialViewController="BV1-FR-VrT">
    <device id="retina4_7" orientation="landscape">
        <adaptation id="fullscreen"/>
    </device>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12086"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--Game View Controller-->
        <scene sceneID="tXr-a1-R10">
            <objects>
                <viewController id="BV1-FR-VrT" customClass="GameViewController" customModule="Mojoc" customModuleProvider="target" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="8aa-yV-Osq"/>
                        <viewControllerLayoutGuide type="bottom" id="qHh-Mt-9TT"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="3se-qz-xqx" customClass="GLKView">
                        <rect key="frame" x="0.0" y="0.0" width="667" height="375"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" red="0.0" green="0.0" blue="0.0" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="SZV-WD-TEh" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>

```

`Samples/SuperLittleRed/IOS/Font/TalkChar.atlas`:

```atlas

TalkChar.png
size: 256,128
format: RGBA8888
filter: Linear,Linear
repeat: none
!
  rotate: false
  xy: 2, 104
  size: 36, 17
  orig: 36, 17
  offset: 0, 0
  index: -1
%
  rotate: false
  xy: 220, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
+
  rotate: false
  xy: 164, 59
  size: 15, 20
  orig: 15, 20
  offset: 0, 0
  index: -1
-
  rotate: false
  xy: 40, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
0
  rotate: false
  xy: 40, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
1
  rotate: false
  xy: 58, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
2
  rotate: false
  xy: 76, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
3
  rotate: false
  xy: 94, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
4
  rotate: false
  xy: 112, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
5
  rotate: false
  xy: 130, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
6
  rotate: false
  xy: 148, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
7
  rotate: false
  xy: 166, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
8
  rotate: false
  xy: 184, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
9
  rotate: false
  xy: 202, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
@
  rotate: false
  xy: 2, 85
  size: 36, 17
  orig: 36, 17
  offset: 0, 0
  index: -1
A
  rotate: false
  xy: 2, 61
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
B
  rotate: false
  xy: 148, 33
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
C
  rotate: false
  xy: 176, 99
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
:
  rotate: false
  xy: 238, 81
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
D
  rotate: false
  xy: 57, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
E
  rotate: false
  xy: 192, 99
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
F
  rotate: false
  xy: 126, 9
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
G
  rotate: false
  xy: 208, 99
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
H
  rotate: false
  xy: 2, 37
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
I
  rotate: false
  xy: 181, 57
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
J
  rotate: false
  xy: 224, 99
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
K
  rotate: false
  xy: 240, 99
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
L
  rotate: false
  xy: 140, 9
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
M
  rotate: false
  xy: 19, 61
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
N
  rotate: false
  xy: 196, 57
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
O
  rotate: false
  xy: 74, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
P
  rotate: false
  xy: 154, 9
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
Q
  rotate: false
  xy: 2, 13
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
R
  rotate: false
  xy: 211, 57
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
S
  rotate: false
  xy: 36, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
T
  rotate: false
  xy: 36, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
U
  rotate: false
  xy: 163, 33
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
V
  rotate: false
  xy: 19, 37
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
W
  rotate: false
  xy: 226, 57
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
X
  rotate: false
  xy: 52, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
Y
  rotate: false
  xy: 91, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
Z
  rotate: false
  xy: 52, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
_
  rotate: false
  xy: 2, 2
  size: 9, 9
  orig: 9, 9
  offset: 0, 0
  index: -1
a
  rotate: false
  xy: 68, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
b
  rotate: false
  xy: 68, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
c
  rotate: false
  xy: 177, 33
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
d
  rotate: false
  xy: 19, 13
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
e
  rotate: false
  xy: 241, 57
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
f
  rotate: false
  xy: 84, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
g
  rotate: false
  xy: 84, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
h
  rotate: false
  xy: 100, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
i
  rotate: false
  xy: 36, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
j
  rotate: false
  xy: 108, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
k
  rotate: false
  xy: 51, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
l
  rotate: false
  xy: 66, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
m
  rotate: false
  xy: 125, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
n
  rotate: false
  xy: 81, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
o
  rotate: false
  xy: 100, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
p
  rotate: false
  xy: 116, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
q
  rotate: false
  xy: 116, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
r
  rotate: false
  xy: 132, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
s
  rotate: false
  xy: 168, 9
  size: 12, 22
  orig: 12, 22
  offset: 0, 0
  index: -1
t
  rotate: false
  xy: 142, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
u
  rotate: false
  xy: 96, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
v
  rotate: false
  xy: 111, 9
  size: 13, 22
  orig: 13, 22
  offset: 0, 0
  index: -1
w
  rotate: false
  xy: 132, 33
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
x
  rotate: false
  xy: 148, 57
  size: 14, 22
  orig: 14, 22
  offset: 0, 0
  index: -1
y
  rotate: false
  xy: 159, 99
  size: 15, 22
  orig: 15, 22
  offset: 0, 0
  index: -1
z
  rotate: false
  xy: 191, 33
  size: 10, 22
  orig: 10, 22
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/Font/UINumber.atlas`:

```atlas

UINumber.png
size: 256,32
format: RGBA8888
filter: Linear,Linear
repeat: none
%
  rotate: false
  xy: 182, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
0
  rotate: false
  xy: 2, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
1
  rotate: false
  xy: 20, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
2
  rotate: false
  xy: 38, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
3
  rotate: false
  xy: 56, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
4
  rotate: false
  xy: 74, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
5
  rotate: false
  xy: 92, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
6
  rotate: false
  xy: 110, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
7
  rotate: false
  xy: 128, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
8
  rotate: false
  xy: 146, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
9
  rotate: false
  xy: 164, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
:
  rotate: false
  xy: 200, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/Font/hp.atlas`:

```atlas

hp.png
size: 256,64
format: RGBA8888
filter: Linear,Linear
repeat: none
%
  rotate: false
  xy: 34, 33
  size: 26, 29
  orig: 26, 29
  offset: 0, 0
  index: -1
-
  rotate: false
  xy: 78, 2
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
0
  rotate: false
  xy: 62, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
1
  rotate: false
  xy: 84, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
2
  rotate: false
  xy: 106, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
3
  rotate: false
  xy: 128, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
4
  rotate: false
  xy: 150, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
5
  rotate: false
  xy: 172, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
6
  rotate: false
  xy: 194, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
7
  rotate: false
  xy: 216, 33
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
8
  rotate: false
  xy: 34, 2
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
9
  rotate: false
  xy: 56, 2
  size: 20, 29
  orig: 20, 29
  offset: 0, 0
  index: -1
_
  rotate: false
  xy: 2, 32
  size: 30, 30
  orig: 30, 30
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/GameViewController.swift`:

```swift
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-3-13
 * Update   : 2019-5-8
 * Author   : scott.cgi
 */


import GLKit
import OpenGLES


class GameViewController: GLKViewController {
    var context: EAGLContext? = nil

    deinit {
        EAGLContext.setCurrent(nil)
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        self.context = EAGLContext(api: .openGLES3)
        
        if (self.context == nil) {
            print("Failed to create ES context.")
        }

        EAGLContext.setCurrent(self.context)

        let view                      = self.view as! GLKView
        view.context                  = self.context!
        view.drawableDepthFormat      = .format24
        view.drawableColorFormat      = .RGBA8888
        view.isMultipleTouchEnabled   = true
        self.preferredFramesPerSecond = 60

        AApplication.Ready(
            Int32(view.bounds.size.width  * view.contentScaleFactor),
            Int32(view.bounds.size.height * view.contentScaleFactor)
        )
    }

    // delay system edge gestures to let app touches can be processed first
    override var preferredScreenEdgesDeferringSystemGestures: UIRectEdge {
        return .all;
    }


    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        if self.isViewLoaded && (self.view.window != nil) {
            self.view    = nil
            self.context = nil
            EAGLContext.setCurrent(nil)
        }
    }


    override func glkView(_ view: GLKView, drawIn rect: CGRect) {
        // application main loop
        AApplication.Loop()
    }


//----------------------------------------------------------------------------------------------------------------------


    static let fingerCount   = 10
    // the fingerId is UITouch index 
    var        fingerTouches = [UITouch?](repeating: nil, count: Int(fingerCount))
    var        fingerIds     = UnsafeMutablePointer<Int32>.allocate(capacity: fingerCount)
    var        pixelXs       = UnsafeMutablePointer<Float>.allocate(capacity: fingerCount)
    var        pixelYs       = UnsafeMutablePointer<Float>.allocate(capacity: fingerCount)

    func touchesHandle(_ touches: Set<UITouch>, _ inputTouchType: InputTouchType) {
        var count         = 0;
        var fingerId:Int? = nil

        for touch in touches {
            if (inputTouchType == InputTouchType_Down) {
                fingerId = fingerTouches.firstIndex(of: nil)
                // record touch with fingerId
                fingerTouches[fingerId!] = touch
            } else {
                // get the touch's fingerId
                fingerId = fingerTouches.firstIndex(of: touch)

                if (inputTouchType != InputTouchType_Move) {
                    // remove touch with fingerId when InputTouchType_Up or InputTouchType_Cancel
                    fingerTouches[fingerId!] = nil
                }
            }

            let pos          = touch.location(in: self.view)
            fingerIds[count] = Int32(fingerId!)
            pixelXs  [count] = Float(pos.x * self.view.contentScaleFactor)
            pixelYs  [count] = Float(pos.y * self.view.contentScaleFactor)

            count += 1
        }

        AApplication.Touches(
            fingerIds,
            pixelXs,
            pixelYs,
            Int32(count),
            inputTouchType
        )
    }


    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?) {
        self.touchesHandle(touches, InputTouchType_Down)
    }
    
    
    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?) {
        self.touchesHandle(touches, InputTouchType_Move)
    }
    
    
    override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?) {
        self.touchesHandle(touches, InputTouchType_Up)
    }
    
    
    override func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?) {
        self.touchesHandle(touches, InputTouchType_Cancel)
    }
}



```

`Samples/SuperLittleRed/IOS/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleDisplayName</key>
	<string>Mojoc Super Little Red</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>0.0.0</string>
	<key>CFBundleVersion</key>
	<string>0</string>
	<key>LSApplicationCategoryType</key>
	<string></string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>armv7</string>
	</array>
	<key>UIRequiresFullScreen</key>
	<true/>
	<key>UIStatusBarHidden</key>
	<true/>
	<key>UIStatusBarStyle</key>
	<string>UIStatusBarStyleDefault</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
</dict>
</plist>

```

`Samples/SuperLittleRed/IOS/Stage/Stage11.atlas`:

```atlas

Stage11.png
size: 2048,2048
format: RGBA8888
filter: Linear,Linear
repeat: none
back1
  rotate: false
  xy: 2, 799
  size: 1024, 188
  orig: 1024, 188
  offset: 0, 0
  index: -1
back2
  rotate: false
  xy: 2, 164
  size: 1024, 124
  orig: 1024, 124
  offset: 0, 0
  index: -1
back3
  rotate: false
  xy: 2, 72
  size: 595, 90
  orig: 595, 90
  offset: 0, 0
  index: -1
before1
  rotate: false
  xy: 2, 290
  size: 1024, 163
  orig: 1024, 163
  offset: 0, 0
  index: -1
before2
  rotate: false
  xy: 964, 1554
  size: 1024, 312
  orig: 1024, 312
  offset: 0, 0
  index: -1
before3
  rotate: false
  xy: 2, 621
  size: 1024, 176
  orig: 1024, 176
  offset: 0, 0
  index: -1
before4
  rotate: false
  xy: 2, 1212
  size: 768, 112
  orig: 768, 112
  offset: 0, 0
  index: -1
cloud1
  rotate: false
  xy: 772, 1256
  size: 132, 68
  orig: 132, 68
  offset: 0, 0
  index: -1
cloud2
  rotate: false
  xy: 2, 2
  size: 128, 68
  orig: 128, 68
  offset: 0, 0
  index: -1
cloud3
  rotate: false
  xy: 599, 105
  size: 100, 57
  orig: 100, 57
  offset: 0, 0
  index: -1
middle1
  rotate: false
  xy: 2, 989
  size: 1024, 221
  orig: 1024, 221
  offset: 0, 0
  index: -1
middle2
  rotate: false
  xy: 964, 1264
  size: 1024, 288
  orig: 1024, 288
  offset: 0, 0
  index: -1
middle3
  rotate: false
  xy: 2, 455
  size: 1024, 164
  orig: 1024, 164
  offset: 0, 0
  index: -1
sky
  rotate: false
  xy: 2, 1326
  size: 960, 540
  orig: 960, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/Stage/Stage11.json`:

```json
{
"skeleton": { "hash": "ZUU61vQEYmzzCpUJlEQFFm3itN4", "spine": "3.6.04-beta", "width": 3836.22, "height": 544.5 },
"bones": [
	{ "name": "root" },
	{ "name": "Back", "parent": "root" },
	{ "name": "Before", "parent": "root" },
	{ "name": "Sky", "parent": "root" },
	{ "name": "Cloud1", "parent": "Sky", "x": 514.72, "y": 122.12 },
	{ "name": "Cloud2", "parent": "Sky", "x": 520.73, "y": 199.04 },
	{ "name": "Cloud3", "parent": "Sky", "x": 504.39, "y": 234.11 },
	{ "name": "Middle", "parent": "root" }
],
"slots": [
	{ "name": "Sky", "bone": "Sky", "attachment": "sky" },
	{ "name": "Cloud3", "bone": "Cloud3", "attachment": "cloud3" },
	{ "name": "Cloud2", "bone": "Cloud2", "attachment": "cloud2" },
	{ "name": "Cloud1", "bone": "Cloud1", "attachment": "cloud1" },
	{ "name": "back1", "bone": "Back", "attachment": "back1" },
	{ "name": "back2", "bone": "Back", "attachment": "back2" },
	{ "name": "back3", "bone": "Back", "attachment": "back3" },
	{ "name": "middle1", "bone": "Middle", "attachment": "middle1" },
	{ "name": "middle2", "bone": "Middle", "attachment": "middle2" },
	{ "name": "middle3", "bone": "Middle", "attachment": "middle3" },
	{ "name": "before1", "bone": "Before", "attachment": "before1" },
	{ "name": "before2", "bone": "Before", "attachment": "before2" },
	{ "name": "before3", "bone": "Before", "attachment": "before3" },
	{ "name": "before4", "bone": "Before", "attachment": "before4" },
	{ "name": "GroudPos", "bone": "root", "color": "00ff00ff", "attachment": "GroudPos" }
],
"skins": {
	"default": {
		"Cloud1": {
			"cloud1": { "y": -6.69, "scaleX": 0.5, "scaleY": 0.5, "width": 132, "height": 68 }
		},
		"Cloud2": {
			"cloud2": { "scaleX": 0.6, "scaleY": 0.6, "width": 128, "height": 68 }
		},
		"Cloud3": {
			"cloud3": { "x": 2.23, "scaleX": 0.4, "scaleY": 0.4, "width": 100, "height": 57 }
		},
		"GroudPos": {
			"GroudPos": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -1915.4, -160.87, -483.2, -161.96, 482.71, -162.27, 1915.63, -161.28 ]
			}
		},
		"Sky": {
			"sky": { "y": 3, "width": 960, "height": 540 }
		},
		"back1": {
			"back1": { "x": -735.2, "y": -67.24, "width": 1024, "height": 188 }
		},
		"back2": {
			"back2": { "x": 287.92, "y": -98.6, "width": 1024, "height": 124 }
		},
		"back3": {
			"back3": { "x": 1096.68, "y": -116.2, "width": 595, "height": 90 }
		},
		"before1": {
			"before1": { "x": -1408.22, "y": -189.83, "width": 1024, "height": 163 }
		},
		"before2": {
			"before2": { "x": -386.63, "y": -115.4, "width": 1024, "height": 312 }
		},
		"before3": {
			"before3": { "x": 636.8, "y": -183.5, "width": 1024, "height": 176 }
		},
		"before4": {
			"before4": { "x": 1532, "y": -215.5, "width": 768, "height": 112 }
		},
		"middle1": {
			"middle1": { "x": -958.09, "y": -64.03, "width": 1024, "height": 221 }
		},
		"middle2": {
			"middle2": { "x": 65.72, "y": -30.5, "width": 1024, "height": 288 }
		},
		"middle3": {
			"middle3": { "x": 1089.52, "y": -92.09, "width": 1024, "height": 164 }
		}
	}
},
"animations": {
	"ShowIn": {
		"bones": {
			"Back": {
				"translate": [
					{ "time": 0, "x": 0, "y": -385, "curve": "stepped" },
					{
						"time": 0.3333,
						"x": 0,
						"y": -385,
						"curve": [ 0.083, -1.11, 0.547, 1.26 ]
					},
					{ "time": 1.5, "x": 0, "y": 0 }
				]
			},
			"Before": {
				"translate": [
					{ "time": 0, "x": 0, "y": -385, "curve": "stepped" },
					{
						"time": 0.3333,
						"x": 0,
						"y": -385,
						"curve": [ 0.32, 0.31, 0.139, 1 ]
					},
					{ "time": 1.5, "x": 0, "y": 0 }
				]
			},
			"Middle": {
				"translate": [
					{ "time": 0, "x": 0, "y": -385, "curve": "stepped" },
					{
						"time": 0.3333,
						"x": 0,
						"y": -385,
						"curve": [ 0.321, -0.78, 0.088, 1.17 ]
					},
					{ "time": 1.5, "x": 0, "y": 0 }
				]
			}
		}
	},
	"animation": {}
}
}
```

`Samples/SuperLittleRed/IOS/SuperLittleRed-Bridging-Header.h`:

```h
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2017-3-14
 * Update   : 2019-2-21
 * Author   : scott.cgi
 */

#ifndef BRIDGING_HEADER_H
#define BRIDGING_HEADER_H


#import "Engine/Application/Application.h"
#import "Engine/Application/Input.h"


#endif

```

`Samples/SuperLittleRed/IOS/SuperLittleRed.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 46;
	objects = {

/* Begin PBXBuildFile section */
		1706CBFA230FBAD10039B44D /* ADTool.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CBF8230FBAD10039B44D /* ADTool.c */; };
		1706CD41230FBB290039B44D /* PhysicsWorld.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC23230FBB280039B44D /* PhysicsWorld.c */; };
		1706CD42230FBB290039B44D /* Physics.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC24230FBB280039B44D /* Physics.c */; };
		1706CD43230FBB290039B44D /* PhysicsBody.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC26230FBB280039B44D /* PhysicsBody.c */; };
		1706CD44230FBB290039B44D /* PhysicsCollision.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC28230FBB280039B44D /* PhysicsCollision.c */; };
		1706CD4A230FBB2A0039B44D /* libpng.a in Frameworks */ = {isa = PBXBuildFile; fileRef = 1706CC41230FBB280039B44D /* libpng.a */; };
		1706CD4B230FBB2A0039B44D /* Extension.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC43230FBB290039B44D /* Extension.c */; };
		1706CD4C230FBB2A0039B44D /* Skeleton.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC46230FBB290039B44D /* Skeleton.c */; };
		1706CD4D230FBB2A0039B44D /* SkeletonData.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC47230FBB290039B44D /* SkeletonData.c */; };
		1706CD4E230FBB2A0039B44D /* SkeletonBone.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC48230FBB290039B44D /* SkeletonBone.c */; };
		1706CD4F230FBB2A0039B44D /* SkeletonAnimationPlayer.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC49230FBB290039B44D /* SkeletonAnimationPlayer.c */; };
		1706CD50230FBB2A0039B44D /* SkeletonTimeline.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC4A230FBB290039B44D /* SkeletonTimeline.c */; };
		1706CD51230FBB2A0039B44D /* SkeletonSlot.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC4C230FBB290039B44D /* SkeletonSlot.c */; };
		1706CD52230FBB2A0039B44D /* Font.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC51230FBB290039B44D /* Font.c */; };
		1706CD53230FBB2A0039B44D /* TextureAtlas.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC52230FBB290039B44D /* TextureAtlas.c */; };
		1706CD54230FBB2A0039B44D /* DrawAtlas.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC53230FBB290039B44D /* DrawAtlas.c */; };
		1706CD55230FBB2A0039B44D /* Vibrator.m in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC60230FBB290039B44D /* Vibrator.m */; };
		1706CD56230FBB2A0039B44D /* SystemInfo.m in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC61230FBB290039B44D /* SystemInfo.m */; };
		1706CD57230FBB2A0039B44D /* Vibrator.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC64230FBB290039B44D /* Vibrator.c */; };
		1706CD58230FBB2A0039B44D /* JniTool.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC65230FBB290039B44D /* JniTool.c */; };
		1706CD59230FBB2A0039B44D /* SystemInfo.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC66230FBB290039B44D /* SystemInfo.c */; };
		1706CD5A230FBB2A0039B44D /* NativeGlue.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC67230FBB290039B44D /* NativeGlue.c */; };
		1706CD5B230FBB2A0039B44D /* Component.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC68230FBB290039B44D /* Component.c */; };
		1706CD5C230FBB2A0039B44D /* Input.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC69230FBB290039B44D /* Input.c */; };
		1706CD5D230FBB2A0039B44D /* Scheduler.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC6B230FBB290039B44D /* Scheduler.c */; };
		1706CD5E230FBB2A0039B44D /* Application.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC6C230FBB290039B44D /* Application.c */; };
		1706CD5F230FBB2A0039B44D /* TweenDrawable.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC6F230FBB290039B44D /* TweenDrawable.c */; };
		1706CD60230FBB2A0039B44D /* Graphics.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC70230FBB290039B44D /* Graphics.c */; };
		1706CD61230FBB2A0039B44D /* Image.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC72230FBB290039B44D /* Image.c */; };
		1706CD62230FBB2A0039B44D /* Quad.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC79230FBB290039B44D /* Quad.c */; };
		1706CD63230FBB2A0039B44D /* Drawable.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC7A230FBB290039B44D /* Drawable.c */; };
		1706CD64230FBB2A0039B44D /* Color.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC7B230FBB290039B44D /* Color.c */; };
		1706CD65230FBB2A0039B44D /* Sprite.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC7D230FBB290039B44D /* Sprite.c */; };
		1706CD66230FBB2A0039B44D /* EGLTool.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC85230FBB290039B44D /* EGLTool.c */; };
		1706CD67230FBB2A0039B44D /* Texture.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC86230FBB290039B44D /* Texture.c */; };
		1706CD68230FBB2A0039B44D /* SubMesh.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC8C230FBB290039B44D /* SubMesh.c */; };
		1706CD69230FBB2A0039B44D /* GLTool.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC8D230FBB290039B44D /* GLTool.c */; };
		1706CD6A230FBB2A0039B44D /* ShaderPrimitive.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC90230FBB290039B44D /* ShaderPrimitive.c */; };
		1706CD6B230FBB2A0039B44D /* ShaderMesh.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC92230FBB290039B44D /* ShaderMesh.c */; };
		1706CD6C230FBB2A0039B44D /* ShaderSprite.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC94230FBB290039B44D /* ShaderSprite.c */; };
		1706CD6D230FBB2A0039B44D /* Shader.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC96230FBB290039B44D /* Shader.c */; };
		1706CD6E230FBB2A0039B44D /* GLInfo.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC98230FBB290039B44D /* GLInfo.c */; };
		1706CD6F230FBB2A0039B44D /* Camera.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC99230FBB290039B44D /* Camera.c */; };
		1706CD70230FBB2A0039B44D /* GLPrimitive.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC9A230FBB290039B44D /* GLPrimitive.c */; };
		1706CD71230FBB2A0039B44D /* Mesh.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CC9B230FBB290039B44D /* Mesh.c */; };
		1706CD72230FBB2A0039B44D /* Audio.m in Sources */ = {isa = PBXBuildFile; fileRef = 1706CCA0230FBB290039B44D /* Audio.m */; };
		1706CD73230FBB2A0039B44D /* Audio.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CCA2230FBB290039B44D /* Audio.c */; };
		1706CD74230FBB2A0039B44D /* CMakeLists.txt in Resources */ = {isa = PBXBuildFile; fileRef = 1706CCA5230FBB290039B44D /* CMakeLists.txt */; };
		1706CDB6230FBB2A0039B44D /* cmake_install.cmake in Resources */ = {isa = PBXBuildFile; fileRef = 1706CD07230FBB290039B44D /* cmake_install.cmake */; };
		1706CDB8230FBB2A0039B44D /* File.m in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD0E230FBB290039B44D /* File.m */; };
		1706CDB9230FBB2A0039B44D /* File.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD11230FBB290039B44D /* File.c */; };
		1706CDBA230FBB2A0039B44D /* Json.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD14230FBB290039B44D /* Json.c */; };
		1706CDBB230FBB2A0039B44D /* Thread.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD16230FBB290039B44D /* Thread.c */; };
		1706CDBC230FBB2A0039B44D /* Array.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD1A230FBB290039B44D /* Array.c */; };
		1706CDBD230FBB2A0039B44D /* ArrayQueue.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD1B230FBB290039B44D /* ArrayQueue.c */; };
		1706CDBE230FBB2A0039B44D /* TweenTool.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD1D230FBB290039B44D /* TweenTool.c */; };
		1706CDBF230FBB2A0039B44D /* ArrayStrSet.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD1E230FBB290039B44D /* ArrayStrSet.c */; };
		1706CDC0230FBB2A0039B44D /* ArrayList.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD1F230FBB290039B44D /* ArrayList.c */; };
		1706CDC1230FBB2A0039B44D /* ArrayIntSet.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD20230FBB290039B44D /* ArrayIntSet.c */; };
		1706CDC2230FBB2A0039B44D /* Tween.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD23230FBB290039B44D /* Tween.c */; };
		1706CDC3230FBB2A0039B44D /* ArrayStrMap.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD24230FBB290039B44D /* ArrayStrMap.c */; };
		1706CDC4230FBB2A0039B44D /* ArrayIntMap.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD28230FBB290039B44D /* ArrayIntMap.c */; };
		1706CDC5230FBB2A0039B44D /* BufferReader.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD29230FBB290039B44D /* BufferReader.c */; };
		1706CDC6230FBB2A0039B44D /* FileTool.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD2C230FBB290039B44D /* FileTool.c */; };
		1706CDC7230FBB2A0039B44D /* Coroutine.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD2E230FBB290039B44D /* Coroutine.c */; };
		1706CDC8230FBB2A0039B44D /* Math.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD31230FBB290039B44D /* Math.c */; };
		1706CDC9230FBB2A0039B44D /* TweenEase.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD33230FBB290039B44D /* TweenEase.c */; };
		1706CDCA230FBB2A0039B44D /* Matrix.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD37230FBB290039B44D /* Matrix.c */; };
		1706CDCB230FBB2A0039B44D /* Toolkit.c in Sources */ = {isa = PBXBuildFile; fileRef = 1706CD40230FBB290039B44D /* Toolkit.c */; };
		17431E061EB8C90A00991D80 /* OpenAL.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 17431E051EB8C90A00991D80 /* OpenAL.framework */; };
		17A541AA1E76F8BE00EB9D00 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 17A541A91E76F8BE00EB9D00 /* AppDelegate.swift */; };
		17A541B01E76F8BF00EB9D00 /* GameViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = 17A541AF1E76F8BF00EB9D00 /* GameViewController.swift */; };
		17A541B31E76F8BF00EB9D00 /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 17A541B11E76F8BF00EB9D00 /* Main.storyboard */; };
		17A541B51E76F8BF00EB9D00 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 17A541B41E76F8BF00EB9D00 /* Assets.xcassets */; };
		17A541B81E76F8BF00EB9D00 /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 17A541B61E76F8BF00EB9D00 /* LaunchScreen.storyboard */; };
		17A541C01E76F94200EB9D00 /* .gitignore in Resources */ = {isa = PBXBuildFile; fileRef = 17A541BF1E76F94200EB9D00 /* .gitignore */; };
		17A543761E76FA0A00EB9D00 /* OpenGLES.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 17A543751E76FA0A00EB9D00 /* OpenGLES.framework */; };
		17A5438E1E798D2A00EB9D00 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 17A5438D1E798D2A00EB9D00 /* Foundation.framework */; };
		17A5439E1E7C287700EB9D00 /* Animation in Resources */ = {isa = PBXBuildFile; fileRef = 17A543981E7C287700EB9D00 /* Animation */; };
		17A5439F1E7C287700EB9D00 /* Audio in Resources */ = {isa = PBXBuildFile; fileRef = 17A543991E7C287700EB9D00 /* Audio */; };
		17A543A01E7C287700EB9D00 /* Font in Resources */ = {isa = PBXBuildFile; fileRef = 17A5439A1E7C287700EB9D00 /* Font */; };
		17A543A11E7C287700EB9D00 /* Stage in Resources */ = {isa = PBXBuildFile; fileRef = 17A5439B1E7C287700EB9D00 /* Stage */; };
		17A543A21E7C287700EB9D00 /* Texture in Resources */ = {isa = PBXBuildFile; fileRef = 17A5439C1E7C287700EB9D00 /* Texture */; };
		17A543A31E7C287700EB9D00 /* UI in Resources */ = {isa = PBXBuildFile; fileRef = 17A5439D1E7C287700EB9D00 /* UI */; };
		17EA45DF1EE84DC200ECD84B /* AppInit.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45C51EE84DC200ECD84B /* AppInit.c */; };
		17EA45E01EE84DC200ECD84B /* AudioTool.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45C61EE84DC200ECD84B /* AudioTool.c */; };
		17EA45E21EE84DC200ECD84B /* Enemy.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45CD1EE84DC200ECD84B /* Enemy.c */; };
		17EA45E31EE84DC200ECD84B /* EnemyAI.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45CF1EE84DC200ECD84B /* EnemyAI.c */; };
		17EA45E41EE84DC200ECD84B /* GameActor.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45D11EE84DC200ECD84B /* GameActor.c */; };
		17EA45E51EE84DC200ECD84B /* GameData.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45D31EE84DC200ECD84B /* GameData.c */; };
		17EA45E61EE84DC200ECD84B /* GameMap.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45D51EE84DC200ECD84B /* GameMap.c */; };
		17EA45E71EE84DC200ECD84B /* Hero.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45D71EE84DC200ECD84B /* Hero.c */; };
		17EA45E81EE84DC200ECD84B /* HUD.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45D91EE84DC200ECD84B /* HUD.c */; };
		17EA45E91EE84DC200ECD84B /* Tool.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45DB1EE84DC200ECD84B /* Tool.c */; };
		17EA45EA1EE84DC200ECD84B /* UI.c in Sources */ = {isa = PBXBuildFile; fileRef = 17EA45DD1EE84DC200ECD84B /* UI.c */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		1706CBF8230FBAD10039B44D /* ADTool.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ADTool.c; sourceTree = "<group>"; };
		1706CBF9230FBAD10039B44D /* ADTool.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ADTool.h; sourceTree = "<group>"; };
		1706CC21230FBB280039B44D /* PhysicsConfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsConfig.h; sourceTree = "<group>"; };
		1706CC22230FBB280039B44D /* PhysicsBody.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsBody.h; sourceTree = "<group>"; };
		1706CC23230FBB280039B44D /* PhysicsWorld.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = PhysicsWorld.c; sourceTree = "<group>"; };
		1706CC24230FBB280039B44D /* Physics.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Physics.c; sourceTree = "<group>"; };
		1706CC25230FBB280039B44D /* PhysicsCollision.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsCollision.h; sourceTree = "<group>"; };
		1706CC26230FBB280039B44D /* PhysicsBody.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = PhysicsBody.c; sourceTree = "<group>"; };
		1706CC27230FBB280039B44D /* PhysicsWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsWorld.h; sourceTree = "<group>"; };
		1706CC28230FBB280039B44D /* PhysicsCollision.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = PhysicsCollision.c; sourceTree = "<group>"; };
		1706CC29230FBB280039B44D /* Physics.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Physics.h; sourceTree = "<group>"; };
		1706CC2E230FBB280039B44D /* png.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = png.h; sourceTree = "<group>"; };
		1706CC2F230FBB280039B44D /* pnglibconf.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = pnglibconf.h; sourceTree = "<group>"; };
		1706CC30230FBB280039B44D /* pngconf.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = pngconf.h; sourceTree = "<group>"; };
		1706CC32230FBB280039B44D /* png.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = png.h; sourceTree = "<group>"; };
		1706CC33230FBB280039B44D /* pnglibconf.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = pnglibconf.h; sourceTree = "<group>"; };
		1706CC34230FBB280039B44D /* pngconf.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = pngconf.h; sourceTree = "<group>"; };
		1706CC37230FBB280039B44D /* libpng_i386.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libpng_i386.a; sourceTree = "<group>"; };
		1706CC38230FBB280039B44D /* libpng.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libpng.a; sourceTree = "<group>"; };
		1706CC3B230FBB280039B44D /* libpng.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libpng.a; sourceTree = "<group>"; };
		1706CC3D230FBB280039B44D /* libpng.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libpng.a; sourceTree = "<group>"; };
		1706CC3F230FBB280039B44D /* libpng.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libpng.a; sourceTree = "<group>"; };
		1706CC41230FBB280039B44D /* libpng.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libpng.a; sourceTree = "<group>"; };
		1706CC43230FBB290039B44D /* Extension.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Extension.c; sourceTree = "<group>"; };
		1706CC45230FBB290039B44D /* SkeletonSlot.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SkeletonSlot.h; sourceTree = "<group>"; };
		1706CC46230FBB290039B44D /* Skeleton.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Skeleton.c; sourceTree = "<group>"; };
		1706CC47230FBB290039B44D /* SkeletonData.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = SkeletonData.c; sourceTree = "<group>"; };
		1706CC48230FBB290039B44D /* SkeletonBone.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = SkeletonBone.c; sourceTree = "<group>"; };
		1706CC49230FBB290039B44D /* SkeletonAnimationPlayer.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = SkeletonAnimationPlayer.c; sourceTree = "<group>"; };
		1706CC4A230FBB290039B44D /* SkeletonTimeline.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = SkeletonTimeline.c; sourceTree = "<group>"; };
		1706CC4B230FBB290039B44D /* Skeleton.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Skeleton.h; sourceTree = "<group>"; };
		1706CC4C230FBB290039B44D /* SkeletonSlot.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = SkeletonSlot.c; sourceTree = "<group>"; };
		1706CC4D230FBB290039B44D /* SkeletonData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SkeletonData.h; sourceTree = "<group>"; };
		1706CC4E230FBB290039B44D /* SkeletonAnimationPlayer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SkeletonAnimationPlayer.h; sourceTree = "<group>"; };
		1706CC4F230FBB290039B44D /* SkeletonBone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SkeletonBone.h; sourceTree = "<group>"; };
		1706CC50230FBB290039B44D /* SkeletonTimeline.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SkeletonTimeline.h; sourceTree = "<group>"; };
		1706CC51230FBB290039B44D /* Font.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Font.c; sourceTree = "<group>"; };
		1706CC52230FBB290039B44D /* TextureAtlas.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = TextureAtlas.c; sourceTree = "<group>"; };
		1706CC53230FBB290039B44D /* DrawAtlas.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = DrawAtlas.c; sourceTree = "<group>"; };
		1706CC54230FBB290039B44D /* Extension.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Extension.h; sourceTree = "<group>"; };
		1706CC55230FBB290039B44D /* Font.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Font.h; sourceTree = "<group>"; };
		1706CC56230FBB290039B44D /* TextureAtlas.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TextureAtlas.h; sourceTree = "<group>"; };
		1706CC57230FBB290039B44D /* DrawAtlas.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DrawAtlas.h; sourceTree = "<group>"; };
		1706CC59230FBB290039B44D /* Input.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Input.h; sourceTree = "<group>"; };
		1706CC5A230FBB290039B44D /* Application.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Application.h; sourceTree = "<group>"; };
		1706CC5B230FBB290039B44D /* Scheduler.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Scheduler.h; sourceTree = "<group>"; };
		1706CC5D230FBB290039B44D /* SystemInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SystemInfo.h; sourceTree = "<group>"; };
		1706CC5E230FBB290039B44D /* Vibrator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Vibrator.h; sourceTree = "<group>"; };
		1706CC60230FBB290039B44D /* Vibrator.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = Vibrator.m; sourceTree = "<group>"; };
		1706CC61230FBB290039B44D /* SystemInfo.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SystemInfo.m; sourceTree = "<group>"; };
		1706CC63230FBB290039B44D /* JniTool.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JniTool.h; sourceTree = "<group>"; };
		1706CC64230FBB290039B44D /* Vibrator.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Vibrator.c; sourceTree = "<group>"; };
		1706CC65230FBB290039B44D /* JniTool.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = JniTool.c; sourceTree = "<group>"; };
		1706CC66230FBB290039B44D /* SystemInfo.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = SystemInfo.c; sourceTree = "<group>"; };
		1706CC67230FBB290039B44D /* NativeGlue.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = NativeGlue.c; sourceTree = "<group>"; };
		1706CC68230FBB290039B44D /* Component.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Component.c; sourceTree = "<group>"; };
		1706CC69230FBB290039B44D /* Input.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Input.c; sourceTree = "<group>"; };
		1706CC6A230FBB290039B44D /* Component.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Component.h; sourceTree = "<group>"; };
		1706CC6B230FBB290039B44D /* Scheduler.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Scheduler.c; sourceTree = "<group>"; };
		1706CC6C230FBB290039B44D /* Application.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Application.c; sourceTree = "<group>"; };
		1706CC6F230FBB290039B44D /* TweenDrawable.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = TweenDrawable.c; sourceTree = "<group>"; };
		1706CC70230FBB290039B44D /* Graphics.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Graphics.c; sourceTree = "<group>"; };
		1706CC72230FBB290039B44D /* Image.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Image.c; sourceTree = "<group>"; };
		1706CC73230FBB290039B44D /* Image.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Image.h; sourceTree = "<group>"; };
		1706CC74230FBB290039B44D /* Graphics.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Graphics.h; sourceTree = "<group>"; };
		1706CC76230FBB290039B44D /* Drawable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Drawable.h; sourceTree = "<group>"; };
		1706CC77230FBB290039B44D /* Quad.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Quad.h; sourceTree = "<group>"; };
		1706CC78230FBB290039B44D /* Color.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Color.h; sourceTree = "<group>"; };
		1706CC79230FBB290039B44D /* Quad.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Quad.c; sourceTree = "<group>"; };
		1706CC7A230FBB290039B44D /* Drawable.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Drawable.c; sourceTree = "<group>"; };
		1706CC7B230FBB290039B44D /* Color.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Color.c; sourceTree = "<group>"; };
		1706CC7D230FBB290039B44D /* Sprite.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Sprite.c; sourceTree = "<group>"; };
		1706CC7E230FBB290039B44D /* GLTool.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GLTool.h; sourceTree = "<group>"; };
		1706CC7F230FBB290039B44D /* SubMesh.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SubMesh.h; sourceTree = "<group>"; };
		1706CC80230FBB290039B44D /* Camera.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Camera.h; sourceTree = "<group>"; };
		1706CC82230FBB290039B44D /* egl.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = egl.h; sourceTree = "<group>"; };
		1706CC83230FBB290039B44D /* EGLTool.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EGLTool.h; sourceTree = "<group>"; };
		1706CC84230FBB290039B44D /* gl3.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = gl3.h; sourceTree = "<group>"; };
		1706CC85230FBB290039B44D /* EGLTool.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = EGLTool.c; sourceTree = "<group>"; };
		1706CC86230FBB290039B44D /* Texture.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Texture.c; sourceTree = "<group>"; };
		1706CC87230FBB290039B44D /* GLInfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GLInfo.h; sourceTree = "<group>"; };
		1706CC88230FBB290039B44D /* Mesh.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Mesh.h; sourceTree = "<group>"; };
		1706CC89230FBB290039B44D /* GLPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GLPrimitive.h; sourceTree = "<group>"; };
		1706CC8A230FBB290039B44D /* MeshDefine.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MeshDefine.h; sourceTree = "<group>"; };
		1706CC8B230FBB290039B44D /* Sprite.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Sprite.h; sourceTree = "<group>"; };
		1706CC8C230FBB290039B44D /* SubMesh.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = SubMesh.c; sourceTree = "<group>"; };
		1706CC8D230FBB290039B44D /* GLTool.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = GLTool.c; sourceTree = "<group>"; };
		1706CC8F230FBB290039B44D /* Shader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Shader.h; sourceTree = "<group>"; };
		1706CC90230FBB290039B44D /* ShaderPrimitive.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ShaderPrimitive.c; sourceTree = "<group>"; };
		1706CC91230FBB290039B44D /* ShaderSprite.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ShaderSprite.h; sourceTree = "<group>"; };
		1706CC92230FBB290039B44D /* ShaderMesh.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ShaderMesh.c; sourceTree = "<group>"; };
		1706CC93230FBB290039B44D /* ShaderMesh.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ShaderMesh.h; sourceTree = "<group>"; };
		1706CC94230FBB290039B44D /* ShaderSprite.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ShaderSprite.c; sourceTree = "<group>"; };
		1706CC95230FBB290039B44D /* ShaderPrimitive.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ShaderPrimitive.h; sourceTree = "<group>"; };
		1706CC96230FBB290039B44D /* Shader.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Shader.c; sourceTree = "<group>"; };
		1706CC97230FBB290039B44D /* Texture.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Texture.h; sourceTree = "<group>"; };
		1706CC98230FBB290039B44D /* GLInfo.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = GLInfo.c; sourceTree = "<group>"; };
		1706CC99230FBB290039B44D /* Camera.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Camera.c; sourceTree = "<group>"; };
		1706CC9A230FBB290039B44D /* GLPrimitive.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = GLPrimitive.c; sourceTree = "<group>"; };
		1706CC9B230FBB290039B44D /* Mesh.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Mesh.c; sourceTree = "<group>"; };
		1706CC9E230FBB290039B44D /* Audio.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Audio.h; sourceTree = "<group>"; };
		1706CCA0230FBB290039B44D /* Audio.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = Audio.m; sourceTree = "<group>"; };
		1706CCA2230FBB290039B44D /* Audio.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Audio.c; sourceTree = "<group>"; };
		1706CCA5230FBB290039B44D /* CMakeLists.txt */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = CMakeLists.txt; sourceTree = "<group>"; };
		1706CCB1230FBB290039B44D /* Extension.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Extension.c.o; sourceTree = "<group>"; };
		1706CCB3230FBB290039B44D /* SkeletonData.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = SkeletonData.c.o; sourceTree = "<group>"; };
		1706CCB4230FBB290039B44D /* Skeleton.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Skeleton.c.o; sourceTree = "<group>"; };
		1706CCB5230FBB290039B44D /* SkeletonTimeline.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = SkeletonTimeline.c.o; sourceTree = "<group>"; };
		1706CCB6230FBB290039B44D /* SkeletonAnimationPlayer.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = SkeletonAnimationPlayer.c.o; sourceTree = "<group>"; };
		1706CCB7230FBB290039B44D /* SkeletonBone.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = SkeletonBone.c.o; sourceTree = "<group>"; };
		1706CCB8230FBB290039B44D /* SkeletonSlot.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = SkeletonSlot.c.o; sourceTree = "<group>"; };
		1706CCB9230FBB290039B44D /* Font.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Font.c.o; sourceTree = "<group>"; };
		1706CCBA230FBB290039B44D /* DrawAtlas.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = DrawAtlas.c.o; sourceTree = "<group>"; };
		1706CCBC230FBB290039B44D /* Particle.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Particle.c.o; sourceTree = "<group>"; };
		1706CCBD230FBB290039B44D /* ParticleEmitterData.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ParticleEmitterData.c.o; sourceTree = "<group>"; };
		1706CCBE230FBB290039B44D /* ParticleEmitter.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ParticleEmitter.c.o; sourceTree = "<group>"; };
		1706CCBF230FBB290039B44D /* TextureAtlas.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = TextureAtlas.c.o; sourceTree = "<group>"; };
		1706CCC3230FBB290039B44D /* Audio.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Audio.c.o; sourceTree = "<group>"; };
		1706CCC5230FBB290039B44D /* Physics.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Physics.c.o; sourceTree = "<group>"; };
		1706CCC6230FBB290039B44D /* PhysicsBody.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = PhysicsBody.c.o; sourceTree = "<group>"; };
		1706CCC7230FBB290039B44D /* PhysicsWorld.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = PhysicsWorld.c.o; sourceTree = "<group>"; };
		1706CCC8230FBB290039B44D /* PhysicsCollision.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = PhysicsCollision.c.o; sourceTree = "<group>"; };
		1706CCCA230FBB290039B44D /* Input.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Input.c.o; sourceTree = "<group>"; };
		1706CCCD230FBB290039B44D /* Vibrator.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Vibrator.c.o; sourceTree = "<group>"; };
		1706CCCE230FBB290039B44D /* SystemInfo.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = SystemInfo.c.o; sourceTree = "<group>"; };
		1706CCCF230FBB290039B44D /* JniTool.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = JniTool.c.o; sourceTree = "<group>"; };
		1706CCD0230FBB290039B44D /* DeviceInfo.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = DeviceInfo.c.o; sourceTree = "<group>"; };
		1706CCD1230FBB290039B44D /* NativeGlue.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = NativeGlue.c.o; sourceTree = "<group>"; };
		1706CCD2230FBB290039B44D /* Scheduler.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Scheduler.c.o; sourceTree = "<group>"; };
		1706CCD3230FBB290039B44D /* Component.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Component.c.o; sourceTree = "<group>"; };
		1706CCD4230FBB290039B44D /* Application.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Application.c.o; sourceTree = "<group>"; };
		1706CCD7230FBB290039B44D /* TweenDrawable.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = TweenDrawable.c.o; sourceTree = "<group>"; };
		1706CCD9230FBB290039B44D /* Image.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Image.c.o; sourceTree = "<group>"; };
		1706CCDA230FBB290039B44D /* Graphics.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Graphics.c.o; sourceTree = "<group>"; };
		1706CCDC230FBB290039B44D /* Quad.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Quad.c.o; sourceTree = "<group>"; };
		1706CCDD230FBB290039B44D /* Drawable.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Drawable.c.o; sourceTree = "<group>"; };
		1706CCDE230FBB290039B44D /* Color.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Color.c.o; sourceTree = "<group>"; };
		1706CCE0230FBB290039B44D /* Camera.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Camera.c.o; sourceTree = "<group>"; };
		1706CCE1230FBB290039B44D /* GLTool.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = GLTool.c.o; sourceTree = "<group>"; };
		1706CCE2230FBB290039B44D /* GLInfo.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = GLInfo.c.o; sourceTree = "<group>"; };
		1706CCE3230FBB290039B44D /* Mesh.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Mesh.c.o; sourceTree = "<group>"; };
		1706CCE4230FBB290039B44D /* Texture.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Texture.c.o; sourceTree = "<group>"; };
		1706CCE6230FBB290039B44D /* EGLTool.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = EGLTool.c.o; sourceTree = "<group>"; };
		1706CCE7230FBB290039B44D /* Sprite.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Sprite.c.o; sourceTree = "<group>"; };
		1706CCE8230FBB290039B44D /* SubMesh.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = SubMesh.c.o; sourceTree = "<group>"; };
		1706CCEA230FBB290039B44D /* ShaderPrimitive.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ShaderPrimitive.c.o; sourceTree = "<group>"; };
		1706CCEB230FBB290039B44D /* ShaderSprite.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ShaderSprite.c.o; sourceTree = "<group>"; };
		1706CCEC230FBB290039B44D /* Shader.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Shader.c.o; sourceTree = "<group>"; };
		1706CCED230FBB290039B44D /* ShaderMesh.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ShaderMesh.c.o; sourceTree = "<group>"; };
		1706CCEE230FBB290039B44D /* GLPrimitive.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = GLPrimitive.c.o; sourceTree = "<group>"; };
		1706CCF2230FBB290039B44D /* File.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = File.c.o; sourceTree = "<group>"; };
		1706CCF4230FBB290039B44D /* Thread.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Thread.c.o; sourceTree = "<group>"; };
		1706CCF5230FBB290039B44D /* Tween.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Tween.c.o; sourceTree = "<group>"; };
		1706CCF6230FBB290039B44D /* FileTool.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = FileTool.c.o; sourceTree = "<group>"; };
		1706CCF7230FBB290039B44D /* ArrayQueue.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ArrayQueue.c.o; sourceTree = "<group>"; };
		1706CCF8230FBB290039B44D /* BufferReader.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = BufferReader.c.o; sourceTree = "<group>"; };
		1706CCF9230FBB290039B44D /* ArrayStrSet.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ArrayStrSet.c.o; sourceTree = "<group>"; };
		1706CCFA230FBB290039B44D /* ArrayIntSet.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ArrayIntSet.c.o; sourceTree = "<group>"; };
		1706CCFB230FBB290039B44D /* Coroutine.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Coroutine.c.o; sourceTree = "<group>"; };
		1706CCFC230FBB290039B44D /* ArrayIntMap.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ArrayIntMap.c.o; sourceTree = "<group>"; };
		1706CCFD230FBB290039B44D /* Array.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Array.c.o; sourceTree = "<group>"; };
		1706CCFE230FBB290039B44D /* ArrayStrMap.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ArrayStrMap.c.o; sourceTree = "<group>"; };
		1706CCFF230FBB290039B44D /* TweenTool.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = TweenTool.c.o; sourceTree = "<group>"; };
		1706CD00230FBB290039B44D /* Json.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Json.c.o; sourceTree = "<group>"; };
		1706CD01230FBB290039B44D /* ArrayList.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = ArrayList.c.o; sourceTree = "<group>"; };
		1706CD03230FBB290039B44D /* Math.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Math.c.o; sourceTree = "<group>"; };
		1706CD04230FBB290039B44D /* Matrix.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Matrix.c.o; sourceTree = "<group>"; };
		1706CD05230FBB290039B44D /* TweenEase.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = TweenEase.c.o; sourceTree = "<group>"; };
		1706CD06230FBB290039B44D /* Toolkit.c.o */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.objfile"; path = Toolkit.c.o; sourceTree = "<group>"; };
		1706CD07230FBB290039B44D /* cmake_install.cmake */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = cmake_install.cmake; sourceTree = "<group>"; };
		1706CD08230FBB290039B44D /* libMojoc.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; path = libMojoc.a; sourceTree = "<group>"; };
		1706CD0A230FBB290039B44D /* Toolkit.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Toolkit.h; sourceTree = "<group>"; };
		1706CD0C230FBB290039B44D /* File.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = File.h; sourceTree = "<group>"; };
		1706CD0E230FBB290039B44D /* File.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = File.m; sourceTree = "<group>"; };
		1706CD0F230FBB290039B44D /* Log.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Log.h; sourceTree = "<group>"; };
		1706CD11230FBB290039B44D /* File.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = File.c; sourceTree = "<group>"; };
		1706CD12230FBB290039B44D /* Platform.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Platform.h; sourceTree = "<group>"; };
		1706CD14230FBB290039B44D /* Json.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Json.c; sourceTree = "<group>"; };
		1706CD15230FBB290039B44D /* Tween.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Tween.h; sourceTree = "<group>"; };
		1706CD16230FBB290039B44D /* Thread.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Thread.c; sourceTree = "<group>"; };
		1706CD17230FBB290039B44D /* ArrayStrMap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ArrayStrMap.h; sourceTree = "<group>"; };
		1706CD18230FBB290039B44D /* BufferReader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = BufferReader.h; sourceTree = "<group>"; };
		1706CD19230FBB290039B44D /* ArrayIntMap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ArrayIntMap.h; sourceTree = "<group>"; };
		1706CD1A230FBB290039B44D /* Array.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Array.c; sourceTree = "<group>"; };
		1706CD1B230FBB290039B44D /* ArrayQueue.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ArrayQueue.c; sourceTree = "<group>"; };
		1706CD1C230FBB290039B44D /* FileTool.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FileTool.h; sourceTree = "<group>"; };
		1706CD1D230FBB290039B44D /* TweenTool.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = TweenTool.c; sourceTree = "<group>"; };
		1706CD1E230FBB290039B44D /* ArrayStrSet.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ArrayStrSet.c; sourceTree = "<group>"; };
		1706CD1F230FBB290039B44D /* ArrayList.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ArrayList.c; sourceTree = "<group>"; };
		1706CD20230FBB290039B44D /* ArrayIntSet.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ArrayIntSet.c; sourceTree = "<group>"; };
		1706CD21230FBB290039B44D /* Coroutine.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Coroutine.h; sourceTree = "<group>"; };
		1706CD22230FBB290039B44D /* Thread.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Thread.h; sourceTree = "<group>"; };
		1706CD23230FBB290039B44D /* Tween.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Tween.c; sourceTree = "<group>"; };
		1706CD24230FBB290039B44D /* ArrayStrMap.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ArrayStrMap.c; sourceTree = "<group>"; };
		1706CD25230FBB290039B44D /* Json.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Json.h; sourceTree = "<group>"; };
		1706CD26230FBB290039B44D /* ArrayQueue.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ArrayQueue.h; sourceTree = "<group>"; };
		1706CD27230FBB290039B44D /* Array.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Array.h; sourceTree = "<group>"; };
		1706CD28230FBB290039B44D /* ArrayIntMap.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ArrayIntMap.c; sourceTree = "<group>"; };
		1706CD29230FBB290039B44D /* BufferReader.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = BufferReader.c; sourceTree = "<group>"; };
		1706CD2A230FBB290039B44D /* ArrayStrSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ArrayStrSet.h; sourceTree = "<group>"; };
		1706CD2B230FBB290039B44D /* ArrayList.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ArrayList.h; sourceTree = "<group>"; };
		1706CD2C230FBB290039B44D /* FileTool.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = FileTool.c; sourceTree = "<group>"; };
		1706CD2D230FBB290039B44D /* TweenTool.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TweenTool.h; sourceTree = "<group>"; };
		1706CD2E230FBB290039B44D /* Coroutine.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Coroutine.c; sourceTree = "<group>"; };
		1706CD2F230FBB290039B44D /* ArrayIntSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ArrayIntSet.h; sourceTree = "<group>"; };
		1706CD31230FBB290039B44D /* Math.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Math.c; sourceTree = "<group>"; };
		1706CD32230FBB290039B44D /* Matrix.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Matrix.h; sourceTree = "<group>"; };
		1706CD33230FBB290039B44D /* TweenEase.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = TweenEase.c; sourceTree = "<group>"; };
		1706CD34230FBB290039B44D /* Math.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Math.h; sourceTree = "<group>"; };
		1706CD35230FBB290039B44D /* Vector.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Vector.h; sourceTree = "<group>"; };
		1706CD36230FBB290039B44D /* TweenEase.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TweenEase.h; sourceTree = "<group>"; };
		1706CD37230FBB290039B44D /* Matrix.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Matrix.c; sourceTree = "<group>"; };
		1706CD39230FBB290039B44D /* Define.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Define.h; sourceTree = "<group>"; };
		1706CD3A230FBB290039B44D /* UserData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UserData.h; sourceTree = "<group>"; };
		1706CD3B230FBB290039B44D /* ArrayRange.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ArrayRange.h; sourceTree = "<group>"; };
		1706CD3C230FBB290039B44D /* Bitwise.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Bitwise.h; sourceTree = "<group>"; };
		1706CD3D230FBB290039B44D /* Struct.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Struct.h; sourceTree = "<group>"; };
		1706CD3E230FBB290039B44D /* Rect.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Rect.h; sourceTree = "<group>"; };
		1706CD3F230FBB290039B44D /* String.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = String.h; sourceTree = "<group>"; };
		1706CD40230FBB290039B44D /* Toolkit.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Toolkit.c; sourceTree = "<group>"; };
		17431E051EB8C90A00991D80 /* OpenAL.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OpenAL.framework; path = System/Library/Frameworks/OpenAL.framework; sourceTree = SDKROOT; };
		17A541A61E76F8BE00EB9D00 /* SuperLittleRed.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = SuperLittleRed.app; sourceTree = BUILT_PRODUCTS_DIR; };
		17A541A91E76F8BE00EB9D00 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		17A541AF1E76F8BF00EB9D00 /* GameViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GameViewController.swift; sourceTree = "<group>"; };
		17A541B21E76F8BF00EB9D00 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		17A541B41E76F8BF00EB9D00 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		17A541B71E76F8BF00EB9D00 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		17A541B91E76F8BF00EB9D00 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = Info.plist; sourceTree = "<group>"; };
		17A541BF1E76F94200EB9D00 /* .gitignore */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; path = .gitignore; sourceTree = "<group>"; };
		17A543751E76FA0A00EB9D00 /* OpenGLES.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OpenGLES.framework; path = System/Library/Frameworks/OpenGLES.framework; sourceTree = SDKROOT; };
		17A543771E76FA1900EB9D00 /* libz.1.2.8.tbd */ = {isa = PBXFileReference; lastKnownFileType = "sourcecode.text-based-dylib-definition"; name = libz.1.2.8.tbd; path = usr/lib/libz.1.2.8.tbd; sourceTree = SDKROOT; };
		17A5438A1E7704AF00EB9D00 /* SuperLittleRed-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "SuperLittleRed-Bridging-Header.h"; sourceTree = "<group>"; };
		17A5438D1E798D2A00EB9D00 /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = System/Library/Frameworks/Foundation.framework; sourceTree = SDKROOT; };
		17A543981E7C287700EB9D00 /* Animation */ = {isa = PBXFileReference; lastKnownFileType = text; path = Animation; sourceTree = "<group>"; };
		17A543991E7C287700EB9D00 /* Audio */ = {isa = PBXFileReference; lastKnownFileType = text; path = Audio; sourceTree = "<group>"; };
		17A5439A1E7C287700EB9D00 /* Font */ = {isa = PBXFileReference; lastKnownFileType = text; path = Font; sourceTree = "<group>"; };
		17A5439B1E7C287700EB9D00 /* Stage */ = {isa = PBXFileReference; lastKnownFileType = text; path = Stage; sourceTree = "<group>"; };
		17A5439C1E7C287700EB9D00 /* Texture */ = {isa = PBXFileReference; lastKnownFileType = text; path = Texture; sourceTree = "<group>"; };
		17A5439D1E7C287700EB9D00 /* UI */ = {isa = PBXFileReference; lastKnownFileType = text; path = UI; sourceTree = "<group>"; };
		17EA45C51EE84DC200ECD84B /* AppInit.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = AppInit.c; sourceTree = "<group>"; };
		17EA45C61EE84DC200ECD84B /* AudioTool.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = AudioTool.c; sourceTree = "<group>"; };
		17EA45C71EE84DC200ECD84B /* AudioTool.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AudioTool.h; sourceTree = "<group>"; };
		17EA45CC1EE84DC200ECD84B /* Config.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Config.h; sourceTree = "<group>"; };
		17EA45CD1EE84DC200ECD84B /* Enemy.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Enemy.c; sourceTree = "<group>"; };
		17EA45CE1EE84DC200ECD84B /* Enemy.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Enemy.h; sourceTree = "<group>"; };
		17EA45CF1EE84DC200ECD84B /* EnemyAI.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = EnemyAI.c; sourceTree = "<group>"; };
		17EA45D01EE84DC200ECD84B /* EnemyAI.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EnemyAI.h; sourceTree = "<group>"; };
		17EA45D11EE84DC200ECD84B /* GameActor.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = GameActor.c; sourceTree = "<group>"; };
		17EA45D21EE84DC200ECD84B /* GameActor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameActor.h; sourceTree = "<group>"; };
		17EA45D31EE84DC200ECD84B /* GameData.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = GameData.c; sourceTree = "<group>"; };
		17EA45D41EE84DC200ECD84B /* GameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameData.h; sourceTree = "<group>"; };
		17EA45D51EE84DC200ECD84B /* GameMap.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = GameMap.c; sourceTree = "<group>"; };
		17EA45D61EE84DC200ECD84B /* GameMap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameMap.h; sourceTree = "<group>"; };
		17EA45D71EE84DC200ECD84B /* Hero.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Hero.c; sourceTree = "<group>"; };
		17EA45D81EE84DC200ECD84B /* Hero.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Hero.h; sourceTree = "<group>"; };
		17EA45D91EE84DC200ECD84B /* HUD.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = HUD.c; sourceTree = "<group>"; };
		17EA45DA1EE84DC200ECD84B /* HUD.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = HUD.h; sourceTree = "<group>"; };
		17EA45DB1EE84DC200ECD84B /* Tool.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = Tool.c; sourceTree = "<group>"; };
		17EA45DC1EE84DC200ECD84B /* Tool.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Tool.h; sourceTree = "<group>"; };
		17EA45DD1EE84DC200ECD84B /* UI.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = UI.c; sourceTree = "<group>"; };
		17EA45DE1EE84DC200ECD84B /* UI.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UI.h; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		17A541A31E76F8BE00EB9D00 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				17431E061EB8C90A00991D80 /* OpenAL.framework in Frameworks */,
				17A5438E1E798D2A00EB9D00 /* Foundation.framework in Frameworks */,
				1706CD4A230FBB2A0039B44D /* libpng.a in Frameworks */,
				17A543761E76FA0A00EB9D00 /* OpenGLES.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		1706CC20230FBB280039B44D /* Physics */ = {
			isa = PBXGroup;
			children = (
				1706CC21230FBB280039B44D /* PhysicsConfig.h */,
				1706CC22230FBB280039B44D /* PhysicsBody.h */,
				1706CC23230FBB280039B44D /* PhysicsWorld.c */,
				1706CC24230FBB280039B44D /* Physics.c */,
				1706CC25230FBB280039B44D /* PhysicsCollision.h */,
				1706CC26230FBB280039B44D /* PhysicsBody.c */,
				1706CC27230FBB280039B44D /* PhysicsWorld.h */,
				1706CC28230FBB280039B44D /* PhysicsCollision.c */,
				1706CC29230FBB280039B44D /* Physics.h */,
			);
			path = Physics;
			sourceTree = "<group>";
		};
		1706CC2A230FBB280039B44D /* ThirdParty */ = {
			isa = PBXGroup;
			children = (
				1706CC2B230FBB280039B44D /* PNG */,
			);
			path = ThirdParty;
			sourceTree = "<group>";
		};
		1706CC2B230FBB280039B44D /* PNG */ = {
			isa = PBXGroup;
			children = (
				1706CC2C230FBB280039B44D /* Include */,
				1706CC35230FBB280039B44D /* Prebuilt */,
			);
			path = PNG;
			sourceTree = "<group>";
		};
		1706CC2C230FBB280039B44D /* Include */ = {
			isa = PBXGroup;
			children = (
				1706CC2D230FBB280039B44D /* IOS */,
				1706CC31230FBB280039B44D /* Android */,
			);
			path = Include;
			sourceTree = "<group>";
		};
		1706CC2D230FBB280039B44D /* IOS */ = {
			isa = PBXGroup;
			children = (
				1706CC2E230FBB280039B44D /* png.h */,
				1706CC2F230FBB280039B44D /* pnglibconf.h */,
				1706CC30230FBB280039B44D /* pngconf.h */,
			);
			path = IOS;
			sourceTree = "<group>";
		};
		1706CC31230FBB280039B44D /* Android */ = {
			isa = PBXGroup;
			children = (
				1706CC32230FBB280039B44D /* png.h */,
				1706CC33230FBB280039B44D /* pnglibconf.h */,
				1706CC34230FBB280039B44D /* pngconf.h */,
			);
			path = Android;
			sourceTree = "<group>";
		};
		1706CC35230FBB280039B44D /* Prebuilt */ = {
			isa = PBXGroup;
			children = (
				1706CC36230FBB280039B44D /* IOS */,
				1706CC39230FBB280039B44D /* Android */,
			);
			path = Prebuilt;
			sourceTree = "<group>";
		};
		1706CC36230FBB280039B44D /* IOS */ = {
			isa = PBXGroup;
			children = (
				1706CC37230FBB280039B44D /* libpng_i386.a */,
				1706CC38230FBB280039B44D /* libpng.a */,
			);
			path = IOS;
			sourceTree = "<group>";
		};
		1706CC39230FBB280039B44D /* Android */ = {
			isa = PBXGroup;
			children = (
				1706CC3A230FBB280039B44D /* armeabi-v7a */,
				1706CC3C230FBB280039B44D /* x86 */,
				1706CC3E230FBB280039B44D /* arm64-v8a */,
				1706CC40230FBB280039B44D /* armeabi */,
			);
			path = Android;
			sourceTree = "<group>";
		};
		1706CC3A230FBB280039B44D /* armeabi-v7a */ = {
			isa = PBXGroup;
			children = (
				1706CC3B230FBB280039B44D /* libpng.a */,
			);
			path = "armeabi-v7a";
			sourceTree = "<group>";
		};
		1706CC3C230FBB280039B44D /* x86 */ = {
			isa = PBXGroup;
			children = (
				1706CC3D230FBB280039B44D /* libpng.a */,
			);
			path = x86;
			sourceTree = "<group>";
		};
		1706CC3E230FBB280039B44D /* arm64-v8a */ = {
			isa = PBXGroup;
			children = (
				1706CC3F230FBB280039B44D /* libpng.a */,
			);
			path = "arm64-v8a";
			sourceTree = "<group>";
		};
		1706CC40230FBB280039B44D /* armeabi */ = {
			isa = PBXGroup;
			children = (
				1706CC41230FBB280039B44D /* libpng.a */,
			);
			path = armeabi;
			sourceTree = "<group>";
		};
		1706CC42230FBB290039B44D /* Extension */ = {
			isa = PBXGroup;
			children = (
				1706CC43230FBB290039B44D /* Extension.c */,
				1706CC44230FBB290039B44D /* Spine */,
				1706CC51230FBB290039B44D /* Font.c */,
				1706CC52230FBB290039B44D /* TextureAtlas.c */,
				1706CC53230FBB290039B44D /* DrawAtlas.c */,
				1706CC54230FBB290039B44D /* Extension.h */,
				1706CC55230FBB290039B44D /* Font.h */,
				1706CC56230FBB290039B44D /* TextureAtlas.h */,
				1706CC57230FBB290039B44D /* DrawAtlas.h */,
			);
			path = Extension;
			sourceTree = "<group>";
		};
		1706CC44230FBB290039B44D /* Spine */ = {
			isa = PBXGroup;
			children = (
				1706CC45230FBB290039B44D /* SkeletonSlot.h */,
				1706CC46230FBB290039B44D /* Skeleton.c */,
				1706CC47230FBB290039B44D /* SkeletonData.c */,
				1706CC48230FBB290039B44D /* SkeletonBone.c */,
				1706CC49230FBB290039B44D /* SkeletonAnimationPlayer.c */,
				1706CC4A230FBB290039B44D /* SkeletonTimeline.c */,
				1706CC4B230FBB290039B44D /* Skeleton.h */,
				1706CC4C230FBB290039B44D /* SkeletonSlot.c */,
				1706CC4D230FBB290039B44D /* SkeletonData.h */,
				1706CC4E230FBB290039B44D /* SkeletonAnimationPlayer.h */,
				1706CC4F230FBB290039B44D /* SkeletonBone.h */,
				1706CC50230FBB290039B44D /* SkeletonTimeline.h */,
			);
			path = Spine;
			sourceTree = "<group>";
		};
		1706CC58230FBB290039B44D /* Application */ = {
			isa = PBXGroup;
			children = (
				1706CC59230FBB290039B44D /* Input.h */,
				1706CC5A230FBB290039B44D /* Application.h */,
				1706CC5B230FBB290039B44D /* Scheduler.h */,
				1706CC5C230FBB290039B44D /* Platform */,
				1706CC68230FBB290039B44D /* Component.c */,
				1706CC69230FBB290039B44D /* Input.c */,
				1706CC6A230FBB290039B44D /* Component.h */,
				1706CC6B230FBB290039B44D /* Scheduler.c */,
				1706CC6C230FBB290039B44D /* Application.c */,
			);
			path = Application;
			sourceTree = "<group>";
		};
		1706CC5C230FBB290039B44D /* Platform */ = {
			isa = PBXGroup;
			children = (
				1706CC5D230FBB290039B44D /* SystemInfo.h */,
				1706CC5E230FBB290039B44D /* Vibrator.h */,
				1706CC5F230FBB290039B44D /* IOS */,
				1706CC62230FBB290039B44D /* Android */,
			);
			path = Platform;
			sourceTree = "<group>";
		};
		1706CC5F230FBB290039B44D /* IOS */ = {
			isa = PBXGroup;
			children = (
				1706CC60230FBB290039B44D /* Vibrator.m */,
				1706CC61230FBB290039B44D /* SystemInfo.m */,
			);
			path = IOS;
			sourceTree = "<group>";
		};
		1706CC62230FBB290039B44D /* Android */ = {
			isa = PBXGroup;
			children = (
				1706CC63230FBB290039B44D /* JniTool.h */,
				1706CC64230FBB290039B44D /* Vibrator.c */,
				1706CC65230FBB290039B44D /* JniTool.c */,
				1706CC66230FBB290039B44D /* SystemInfo.c */,
				1706CC67230FBB290039B44D /* NativeGlue.c */,
			);
			path = Android;
			sourceTree = "<group>";
		};
		1706CC6D230FBB290039B44D /* Graphics */ = {
			isa = PBXGroup;
			children = (
				1706CC6E230FBB290039B44D /* Tween */,
				1706CC70230FBB290039B44D /* Graphics.c */,
				1706CC71230FBB290039B44D /* Utils */,
				1706CC74230FBB290039B44D /* Graphics.h */,
				1706CC75230FBB290039B44D /* Draw */,
				1706CC7C230FBB290039B44D /* OpenGL */,
			);
			path = Graphics;
			sourceTree = "<group>";
		};
		1706CC6E230FBB290039B44D /* Tween */ = {
			isa = PBXGroup;
			children = (
				1706CC6F230FBB290039B44D /* TweenDrawable.c */,
			);
			path = Tween;
			sourceTree = "<group>";
		};
		1706CC71230FBB290039B44D /* Utils */ = {
			isa = PBXGroup;
			children = (
				1706CC72230FBB290039B44D /* Image.c */,
				1706CC73230FBB290039B44D /* Image.h */,
			);
			path = Utils;
			sourceTree = "<group>";
		};
		1706CC75230FBB290039B44D /* Draw */ = {
			isa = PBXGroup;
			children = (
				1706CC76230FBB290039B44D /* Drawable.h */,
				1706CC77230FBB290039B44D /* Quad.h */,
				1706CC78230FBB290039B44D /* Color.h */,
				1706CC79230FBB290039B44D /* Quad.c */,
				1706CC7A230FBB290039B44D /* Drawable.c */,
				1706CC7B230FBB290039B44D /* Color.c */,
			);
			path = Draw;
			sourceTree = "<group>";
		};
		1706CC7C230FBB290039B44D /* OpenGL */ = {
			isa = PBXGroup;
			children = (
				1706CC7D230FBB290039B44D /* Sprite.c */,
				1706CC7E230FBB290039B44D /* GLTool.h */,
				1706CC7F230FBB290039B44D /* SubMesh.h */,
				1706CC80230FBB290039B44D /* Camera.h */,
				1706CC81230FBB290039B44D /* Platform */,
				1706CC86230FBB290039B44D /* Texture.c */,
				1706CC87230FBB290039B44D /* GLInfo.h */,
				1706CC88230FBB290039B44D /* Mesh.h */,
				1706CC89230FBB290039B44D /* GLPrimitive.h */,
				1706CC8A230FBB290039B44D /* MeshDefine.h */,
				1706CC8B230FBB290039B44D /* Sprite.h */,
				1706CC8C230FBB290039B44D /* SubMesh.c */,
				1706CC8D230FBB290039B44D /* GLTool.c */,
				1706CC8E230FBB290039B44D /* Shader */,
				1706CC97230FBB290039B44D /* Texture.h */,
				1706CC98230FBB290039B44D /* GLInfo.c */,
				1706CC99230FBB290039B44D /* Camera.c */,
				1706CC9A230FBB290039B44D /* GLPrimitive.c */,
				1706CC9B230FBB290039B44D /* Mesh.c */,
			);
			path = OpenGL;
			sourceTree = "<group>";
		};
		1706CC81230FBB290039B44D /* Platform */ = {
			isa = PBXGroup;
			children = (
				1706CC82230FBB290039B44D /* egl.h */,
				1706CC83230FBB290039B44D /* EGLTool.h */,
				1706CC84230FBB290039B44D /* gl3.h */,
				1706CC85230FBB290039B44D /* EGLTool.c */,
			);
			path = Platform;
			sourceTree = "<group>";
		};
		1706CC8E230FBB290039B44D /* Shader */ = {
			isa = PBXGroup;
			children = (
				1706CC8F230FBB290039B44D /* Shader.h */,
				1706CC90230FBB290039B44D /* ShaderPrimitive.c */,
				1706CC91230FBB290039B44D /* ShaderSprite.h */,
				1706CC92230FBB290039B44D /* ShaderMesh.c */,
				1706CC93230FBB290039B44D /* ShaderMesh.h */,
				1706CC94230FBB290039B44D /* ShaderSprite.c */,
				1706CC95230FBB290039B44D /* ShaderPrimitive.h */,
				1706CC96230FBB290039B44D /* Shader.c */,
			);
			path = Shader;
			sourceTree = "<group>";
		};
		1706CC9C230FBB290039B44D /* Audio */ = {
			isa = PBXGroup;
			children = (
				1706CC9D230FBB290039B44D /* Platform */,
			);
			path = Audio;
			sourceTree = "<group>";
		};
		1706CC9D230FBB290039B44D /* Platform */ = {
			isa = PBXGroup;
			children = (
				1706CC9E230FBB290039B44D /* Audio.h */,
				1706CC9F230FBB290039B44D /* IOS */,
				1706CCA1230FBB290039B44D /* Android */,
			);
			path = Platform;
			sourceTree = "<group>";
		};
		1706CC9F230FBB290039B44D /* IOS */ = {
			isa = PBXGroup;
			children = (
				1706CCA0230FBB290039B44D /* Audio.m */,
			);
			path = IOS;
			sourceTree = "<group>";
		};
		1706CCA1230FBB290039B44D /* Android */ = {
			isa = PBXGroup;
			children = (
				1706CCA2230FBB290039B44D /* Audio.c */,
			);
			path = Android;
			sourceTree = "<group>";
		};
		1706CCA3230FBB290039B44D /* Build */ = {
			isa = PBXGroup;
			children = (
				1706CCA4230FBB290039B44D /* Android */,
			);
			path = Build;
			sourceTree = "<group>";
		};
		1706CCA4230FBB290039B44D /* Android */ = {
			isa = PBXGroup;
			children = (
				1706CCA5230FBB290039B44D /* CMakeLists.txt */,
				1706CCA6230FBB290039B44D /* Bin */,
			);
			path = Android;
			sourceTree = "<group>";
		};
		1706CCA6230FBB290039B44D /* Bin */ = {
			isa = PBXGroup;
			children = (
				1706CCA7230FBB290039B44D /* CMakeFiles */,
				1706CD07230FBB290039B44D /* cmake_install.cmake */,
				1706CD08230FBB290039B44D /* libMojoc.a */,
			);
			path = Bin;
			sourceTree = "<group>";
		};
		1706CCA7230FBB290039B44D /* CMakeFiles */ = {
			isa = PBXGroup;
			children = (
				1706CCA8230FBB290039B44D /* Mojoc.dir */,
			);
			path = CMakeFiles;
			sourceTree = "<group>";
		};
		1706CCA8230FBB290039B44D /* Mojoc.dir */ = {
			isa = PBXGroup;
			children = (
				1706CCA9230FBB290039B44D /* Users */,
			);
			path = Mojoc.dir;
			sourceTree = "<group>";
		};
		1706CCA9230FBB290039B44D /* Users */ = {
			isa = PBXGroup;
			children = (
				1706CCAA230FBB290039B44D /* scottcgi */,
			);
			path = Users;
			sourceTree = "<group>";
		};
		1706CCAA230FBB290039B44D /* scottcgi */ = {
			isa = PBXGroup;
			children = (
				1706CCAB230FBB290039B44D /* My */,
			);
			path = scottcgi;
			sourceTree = "<group>";
		};
		1706CCAB230FBB290039B44D /* My */ = {
			isa = PBXGroup;
			children = (
				1706CCAC230FBB290039B44D /* Programs */,
			);
			path = My;
			sourceTree = "<group>";
		};
		1706CCAC230FBB290039B44D /* Programs */ = {
			isa = PBXGroup;
			children = (
				1706CCAD230FBB290039B44D /* Git */,
			);
			path = Programs;
			sourceTree = "<group>";
		};
		1706CCAD230FBB290039B44D /* Git */ = {
			isa = PBXGroup;
			children = (
				1706CCAE230FBB290039B44D /* Mojoc */,
			);
			path = Git;
			sourceTree = "<group>";
		};
		1706CCAE230FBB290039B44D /* Mojoc */ = {
			isa = PBXGroup;
			children = (
				1706CCAF230FBB290039B44D /* Engine */,
			);
			path = Mojoc;
			sourceTree = "<group>";
		};
		1706CCAF230FBB290039B44D /* Engine */ = {
			isa = PBXGroup;
			children = (
				1706CCB0230FBB290039B44D /* Extension */,
				1706CCC0230FBB290039B44D /* Audio */,
				1706CCC4230FBB290039B44D /* Physics */,
				1706CCC9230FBB290039B44D /* Application */,
				1706CCD5230FBB290039B44D /* Graphics */,
				1706CCEF230FBB290039B44D /* Toolkit */,
			);
			path = Engine;
			sourceTree = "<group>";
		};
		1706CCB0230FBB290039B44D /* Extension */ = {
			isa = PBXGroup;
			children = (
				1706CCB1230FBB290039B44D /* Extension.c.o */,
				1706CCB2230FBB290039B44D /* Spine */,
				1706CCB9230FBB290039B44D /* Font.c.o */,
				1706CCBA230FBB290039B44D /* DrawAtlas.c.o */,
				1706CCBB230FBB290039B44D /* Particle */,
				1706CCBF230FBB290039B44D /* TextureAtlas.c.o */,
			);
			path = Extension;
			sourceTree = "<group>";
		};
		1706CCB2230FBB290039B44D /* Spine */ = {
			isa = PBXGroup;
			children = (
				1706CCB3230FBB290039B44D /* SkeletonData.c.o */,
				1706CCB4230FBB290039B44D /* Skeleton.c.o */,
				1706CCB5230FBB290039B44D /* SkeletonTimeline.c.o */,
				1706CCB6230FBB290039B44D /* SkeletonAnimationPlayer.c.o */,
				1706CCB7230FBB290039B44D /* SkeletonBone.c.o */,
				1706CCB8230FBB290039B44D /* SkeletonSlot.c.o */,
			);
			path = Spine;
			sourceTree = "<group>";
		};
		1706CCBB230FBB290039B44D /* Particle */ = {
			isa = PBXGroup;
			children = (
				1706CCBC230FBB290039B44D /* Particle.c.o */,
				1706CCBD230FBB290039B44D /* ParticleEmitterData.c.o */,
				1706CCBE230FBB290039B44D /* ParticleEmitter.c.o */,
			);
			path = Particle;
			sourceTree = "<group>";
		};
		1706CCC0230FBB290039B44D /* Audio */ = {
			isa = PBXGroup;
			children = (
				1706CCC1230FBB290039B44D /* Platform */,
			);
			path = Audio;
			sourceTree = "<group>";
		};
		1706CCC1230FBB290039B44D /* Platform */ = {
			isa = PBXGroup;
			children = (
				1706CCC2230FBB290039B44D /* Android */,
			);
			path = Platform;
			sourceTree = "<group>";
		};
		1706CCC2230FBB290039B44D /* Android */ = {
			isa = PBXGroup;
			children = (
				1706CCC3230FBB290039B44D /* Audio.c.o */,
			);
			path = Android;
			sourceTree = "<group>";
		};
		1706CCC4230FBB290039B44D /* Physics */ = {
			isa = PBXGroup;
			children = (
				1706CCC5230FBB290039B44D /* Physics.c.o */,
				1706CCC6230FBB290039B44D /* PhysicsBody.c.o */,
				1706CCC7230FBB290039B44D /* PhysicsWorld.c.o */,
				1706CCC8230FBB290039B44D /* PhysicsCollision.c.o */,
			);
			path = Physics;
			sourceTree = "<group>";
		};
		1706CCC9230FBB290039B44D /* Application */ = {
			isa = PBXGroup;
			children = (
				1706CCCA230FBB290039B44D /* Input.c.o */,
				1706CCCB230FBB290039B44D /* Platform */,
				1706CCD2230FBB290039B44D /* Scheduler.c.o */,
				1706CCD3230FBB290039B44D /* Component.c.o */,
				1706CCD4230FBB290039B44D /* Application.c.o */,
			);
			path = Application;
			sourceTree = "<group>";
		};
		1706CCCB230FBB290039B44D /* Platform */ = {
			isa = PBXGroup;
			children = (
				1706CCCC230FBB290039B44D /* Android */,
			);
			path = Platform;
			sourceTree = "<group>";
		};
		1706CCCC230FBB290039B44D /* Android */ = {
			isa = PBXGroup;
			children = (
				1706CCCD230FBB290039B44D /* Vibrator.c.o */,
				1706CCCE230FBB290039B44D /* SystemInfo.c.o */,
				1706CCCF230FBB290039B44D /* JniTool.c.o */,
				1706CCD0230FBB290039B44D /* DeviceInfo.c.o */,
				1706CCD1230FBB290039B44D /* NativeGlue.c.o */,
			);
			path = Android;
			sourceTree = "<group>";
		};
		1706CCD5230FBB290039B44D /* Graphics */ = {
			isa = PBXGroup;
			children = (
				1706CCD6230FBB290039B44D /* Tween */,
				1706CCD8230FBB290039B44D /* Utils */,
				1706CCDA230FBB290039B44D /* Graphics.c.o */,
				1706CCDB230FBB290039B44D /* Draw */,
				1706CCDF230FBB290039B44D /* OpenGL */,
			);
			path = Graphics;
			sourceTree = "<group>";
		};
		1706CCD6230FBB290039B44D /* Tween */ = {
			isa = PBXGroup;
			children = (
				1706CCD7230FBB290039B44D /* TweenDrawable.c.o */,
			);
			path = Tween;
			sourceTree = "<group>";
		};
		1706CCD8230FBB290039B44D /* Utils */ = {
			isa = PBXGroup;
			children = (
				1706CCD9230FBB290039B44D /* Image.c.o */,
			);
			path = Utils;
			sourceTree = "<group>";
		};
		1706CCDB230FBB290039B44D /* Draw */ = {
			isa = PBXGroup;
			children = (
				1706CCDC230FBB290039B44D /* Quad.c.o */,
				1706CCDD230FBB290039B44D /* Drawable.c.o */,
				1706CCDE230FBB290039B44D /* Color.c.o */,
			);
			path = Draw;
			sourceTree = "<group>";
		};
		1706CCDF230FBB290039B44D /* OpenGL */ = {
			isa = PBXGroup;
			children = (
				1706CCE0230FBB290039B44D /* Camera.c.o */,
				1706CCE1230FBB290039B44D /* GLTool.c.o */,
				1706CCE2230FBB290039B44D /* GLInfo.c.o */,
				1706CCE3230FBB290039B44D /* Mesh.c.o */,
				1706CCE4230FBB290039B44D /* Texture.c.o */,
				1706CCE5230FBB290039B44D /* Platform */,
				1706CCE7230FBB290039B44D /* Sprite.c.o */,
				1706CCE8230FBB290039B44D /* SubMesh.c.o */,
				1706CCE9230FBB290039B44D /* Shader */,
				1706CCEE230FBB290039B44D /* GLPrimitive.c.o */,
			);
			path = OpenGL;
			sourceTree = "<group>";
		};
		1706CCE5230FBB290039B44D /* Platform */ = {
			isa = PBXGroup;
			children = (
				1706CCE6230FBB290039B44D /* EGLTool.c.o */,
			);
			path = Platform;
			sourceTree = "<group>";
		};
		1706CCE9230FBB290039B44D /* Shader */ = {
			isa = PBXGroup;
			children = (
				1706CCEA230FBB290039B44D /* ShaderPrimitive.c.o */,
				1706CCEB230FBB290039B44D /* ShaderSprite.c.o */,
				1706CCEC230FBB290039B44D /* Shader.c.o */,
				1706CCED230FBB290039B44D /* ShaderMesh.c.o */,
			);
			path = Shader;
			sourceTree = "<group>";
		};
		1706CCEF230FBB290039B44D /* Toolkit */ = {
			isa = PBXGroup;
			children = (
				1706CCF0230FBB290039B44D /* Platform */,
				1706CCF3230FBB290039B44D /* Utils */,
				1706CD02230FBB290039B44D /* Math */,
				1706CD06230FBB290039B44D /* Toolkit.c.o */,
			);
			path = Toolkit;
			sourceTree = "<group>";
		};
		1706CCF0230FBB290039B44D /* Platform */ = {
			isa = PBXGroup;
			children = (
				1706CCF1230FBB290039B44D /* Android */,
			);
			path = Platform;
			sourceTree = "<group>";
		};
		1706CCF1230FBB290039B44D /* Android */ = {
			isa = PBXGroup;
			children = (
				1706CCF2230FBB290039B44D /* File.c.o */,
			);
			path = Android;
			sourceTree = "<group>";
		};
		1706CCF3230FBB290039B44D /* Utils */ = {
			isa = PBXGroup;
			children = (
				1706CCF4230FBB290039B44D /* Thread.c.o */,
				1706CCF5230FBB290039B44D /* Tween.c.o */,
				1706CCF6230FBB290039B44D /* FileTool.c.o */,
				1706CCF7230FBB290039B44D /* ArrayQueue.c.o */,
				1706CCF8230FBB290039B44D /* BufferReader.c.o */,
				1706CCF9230FBB290039B44D /* ArrayStrSet.c.o */,
				1706CCFA230FBB290039B44D /* ArrayIntSet.c.o */,
				1706CCFB230FBB290039B44D /* Coroutine.c.o */,
				1706CCFC230FBB290039B44D /* ArrayIntMap.c.o */,
				1706CCFD230FBB290039B44D /* Array.c.o */,
				1706CCFE230FBB290039B44D /* ArrayStrMap.c.o */,
				1706CCFF230FBB290039B44D /* TweenTool.c.o */,
				1706CD00230FBB290039B44D /* Json.c.o */,
				1706CD01230FBB290039B44D /* ArrayList.c.o */,
			);
			path = Utils;
			sourceTree = "<group>";
		};
		1706CD02230FBB290039B44D /* Math */ = {
			isa = PBXGroup;
			children = (
				1706CD03230FBB290039B44D /* Math.c.o */,
				1706CD04230FBB290039B44D /* Matrix.c.o */,
				1706CD05230FBB290039B44D /* TweenEase.c.o */,
			);
			path = Math;
			sourceTree = "<group>";
		};
		1706CD09230FBB290039B44D /* Toolkit */ = {
			isa = PBXGroup;
			children = (
				1706CD0A230FBB290039B44D /* Toolkit.h */,
				1706CD0B230FBB290039B44D /* Platform */,
				1706CD13230FBB290039B44D /* Utils */,
				1706CD30230FBB290039B44D /* Math */,
				1706CD38230FBB290039B44D /* HeaderUtils */,
				1706CD40230FBB290039B44D /* Toolkit.c */,
			);
			path = Toolkit;
			sourceTree = "<group>";
		};
		1706CD0B230FBB290039B44D /* Platform */ = {
			isa = PBXGroup;
			children = (
				1706CD0C230FBB290039B44D /* File.h */,
				1706CD0D230FBB290039B44D /* IOS */,
				1706CD0F230FBB290039B44D /* Log.h */,
				1706CD10230FBB290039B44D /* Android */,
				1706CD12230FBB290039B44D /* Platform.h */,
			);
			path = Platform;
			sourceTree = "<group>";
		};
		1706CD0D230FBB290039B44D /* IOS */ = {
			isa = PBXGroup;
			children = (
				1706CD0E230FBB290039B44D /* File.m */,
			);
			path = IOS;
			sourceTree = "<group>";
		};
		1706CD10230FBB290039B44D /* Android */ = {
			isa = PBXGroup;
			children = (
				1706CD11230FBB290039B44D /* File.c */,
			);
			path = Android;
			sourceTree = "<group>";
		};
		1706CD13230FBB290039B44D /* Utils */ = {
			isa = PBXGroup;
			children = (
				1706CD14230FBB290039B44D /* Json.c */,
				1706CD15230FBB290039B44D /* Tween.h */,
				1706CD16230FBB290039B44D /* Thread.c */,
				1706CD17230FBB290039B44D /* ArrayStrMap.h */,
				1706CD18230FBB290039B44D /* BufferReader.h */,
				1706CD19230FBB290039B44D /* ArrayIntMap.h */,
				1706CD1A230FBB290039B44D /* Array.c */,
				1706CD1B230FBB290039B44D /* ArrayQueue.c */,
				1706CD1C230FBB290039B44D /* FileTool.h */,
				1706CD1D230FBB290039B44D /* TweenTool.c */,
				1706CD1E230FBB290039B44D /* ArrayStrSet.c */,
				1706CD1F230FBB290039B44D /* ArrayList.c */,
				1706CD20230FBB290039B44D /* ArrayIntSet.c */,
				1706CD21230FBB290039B44D /* Coroutine.h */,
				1706CD22230FBB290039B44D /* Thread.h */,
				1706CD23230FBB290039B44D /* Tween.c */,
				1706CD24230FBB290039B44D /* ArrayStrMap.c */,
				1706CD25230FBB290039B44D /* Json.h */,
				1706CD26230FBB290039B44D /* ArrayQueue.h */,
				1706CD27230FBB290039B44D /* Array.h */,
				1706CD28230FBB290039B44D /* ArrayIntMap.c */,
				1706CD29230FBB290039B44D /* BufferReader.c */,
				1706CD2A230FBB290039B44D /* ArrayStrSet.h */,
				1706CD2B230FBB290039B44D /* ArrayList.h */,
				1706CD2C230FBB290039B44D /* FileTool.c */,
				1706CD2D230FBB290039B44D /* TweenTool.h */,
				1706CD2E230FBB290039B44D /* Coroutine.c */,
				1706CD2F230FBB290039B44D /* ArrayIntSet.h */,
			);
			path = Utils;
			sourceTree = "<group>";
		};
		1706CD30230FBB290039B44D /* Math */ = {
			isa = PBXGroup;
			children = (
				1706CD31230FBB290039B44D /* Math.c */,
				1706CD32230FBB290039B44D /* Matrix.h */,
				1706CD33230FBB290039B44D /* TweenEase.c */,
				1706CD34230FBB290039B44D /* Math.h */,
				1706CD35230FBB290039B44D /* Vector.h */,
				1706CD36230FBB290039B44D /* TweenEase.h */,
				1706CD37230FBB290039B44D /* Matrix.c */,
			);
			path = Math;
			sourceTree = "<group>";
		};
		1706CD38230FBB290039B44D /* HeaderUtils */ = {
			isa = PBXGroup;
			children = (
				1706CD39230FBB290039B44D /* Define.h */,
				1706CD3A230FBB290039B44D /* UserData.h */,
				1706CD3B230FBB290039B44D /* ArrayRange.h */,
				1706CD3C230FBB290039B44D /* Bitwise.h */,
				1706CD3D230FBB290039B44D /* Struct.h */,
				1706CD3E230FBB290039B44D /* Rect.h */,
				1706CD3F230FBB290039B44D /* String.h */,
			);
			path = HeaderUtils;
			sourceTree = "<group>";
		};
		17A5419D1E76F8BE00EB9D00 = {
			isa = PBXGroup;
			children = (
				17A541BF1E76F94200EB9D00 /* .gitignore */,
				17A541A81E76F8BE00EB9D00 /* SuperLittleRed */,
				17A541A71E76F8BE00EB9D00 /* Products */,
				17A543741E76FA0A00EB9D00 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		17A541A71E76F8BE00EB9D00 /* Products */ = {
			isa = PBXGroup;
			children = (
				17A541A61E76F8BE00EB9D00 /* SuperLittleRed.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		17A541A81E76F8BE00EB9D00 /* SuperLittleRed */ = {
			isa = PBXGroup;
			children = (
				17EA45EB1EE84DD300ECD84B /* Engine */,
				17EA45C41EE84DC200ECD84B /* Code */,
				17A543981E7C287700EB9D00 /* Animation */,
				17A543991E7C287700EB9D00 /* Audio */,
				17A5439A1E7C287700EB9D00 /* Font */,
				17A5439B1E7C287700EB9D00 /* Stage */,
				17A5439C1E7C287700EB9D00 /* Texture */,
				17A5439D1E7C287700EB9D00 /* UI */,
				17A541B41E76F8BF00EB9D00 /* Assets.xcassets */,
				17A541B11E76F8BF00EB9D00 /* Main.storyboard */,
				17A541B61E76F8BF00EB9D00 /* LaunchScreen.storyboard */,
				17A541B91E76F8BF00EB9D00 /* Info.plist */,
				17A541A91E76F8BE00EB9D00 /* AppDelegate.swift */,
				17A541AF1E76F8BF00EB9D00 /* GameViewController.swift */,
				17A5438A1E7704AF00EB9D00 /* SuperLittleRed-Bridging-Header.h */,
			);
			name = SuperLittleRed;
			sourceTree = "<group>";
		};
		17A543741E76FA0A00EB9D00 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				17431E051EB8C90A00991D80 /* OpenAL.framework */,
				17A5438D1E798D2A00EB9D00 /* Foundation.framework */,
				17A543771E76FA1900EB9D00 /* libz.1.2.8.tbd */,
				17A543751E76FA0A00EB9D00 /* OpenGLES.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		17EA45C41EE84DC200ECD84B /* Code */ = {
			isa = PBXGroup;
			children = (
				1706CBF8230FBAD10039B44D /* ADTool.c */,
				1706CBF9230FBAD10039B44D /* ADTool.h */,
				17EA45C51EE84DC200ECD84B /* AppInit.c */,
				17EA45C61EE84DC200ECD84B /* AudioTool.c */,
				17EA45C71EE84DC200ECD84B /* AudioTool.h */,
				17EA45CC1EE84DC200ECD84B /* Config.h */,
				17EA45CD1EE84DC200ECD84B /* Enemy.c */,
				17EA45CE1EE84DC200ECD84B /* Enemy.h */,
				17EA45CF1EE84DC200ECD84B /* EnemyAI.c */,
				17EA45D01EE84DC200ECD84B /* EnemyAI.h */,
				17EA45D11EE84DC200ECD84B /* GameActor.c */,
				17EA45D21EE84DC200ECD84B /* GameActor.h */,
				17EA45D31EE84DC200ECD84B /* GameData.c */,
				17EA45D41EE84DC200ECD84B /* GameData.h */,
				17EA45D51EE84DC200ECD84B /* GameMap.c */,
				17EA45D61EE84DC200ECD84B /* GameMap.h */,
				17EA45D71EE84DC200ECD84B /* Hero.c */,
				17EA45D81EE84DC200ECD84B /* Hero.h */,
				17EA45D91EE84DC200ECD84B /* HUD.c */,
				17EA45DA1EE84DC200ECD84B /* HUD.h */,
				17EA45DB1EE84DC200ECD84B /* Tool.c */,
				17EA45DC1EE84DC200ECD84B /* Tool.h */,
				17EA45DD1EE84DC200ECD84B /* UI.c */,
				17EA45DE1EE84DC200ECD84B /* UI.h */,
			);
			name = Code;
			path = ../Code;
			sourceTree = "<group>";
		};
		17EA45EB1EE84DD300ECD84B /* Engine */ = {
			isa = PBXGroup;
			children = (
				1706CC58230FBB290039B44D /* Application */,
				1706CC9C230FBB290039B44D /* Audio */,
				1706CCA3230FBB290039B44D /* Build */,
				1706CC42230FBB290039B44D /* Extension */,
				1706CC6D230FBB290039B44D /* Graphics */,
				1706CC20230FBB280039B44D /* Physics */,
				1706CC2A230FBB280039B44D /* ThirdParty */,
				1706CD09230FBB290039B44D /* Toolkit */,
			);
			name = Engine;
			path = ../../../Engine;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		17A541A51E76F8BE00EB9D00 /* SuperLittleRed */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 17A541BC1E76F8BF00EB9D00 /* Build configuration list for PBXNativeTarget "SuperLittleRed" */;
			buildPhases = (
				17A541A21E76F8BE00EB9D00 /* Sources */,
				17A541A31E76F8BE00EB9D00 /* Frameworks */,
				17A541A41E76F8BE00EB9D00 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = SuperLittleRed;
			productName = SuperLittleRed;
			productReference = 17A541A61E76F8BE00EB9D00 /* SuperLittleRed.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		17A5419E1E76F8BE00EB9D00 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastSwiftUpdateCheck = 0820;
				LastUpgradeCheck = 1240;
				ORGANIZATIONNAME = scott.cgi;
				TargetAttributes = {
					17A541A51E76F8BE00EB9D00 = {
						CreatedOnToolsVersion = 8.2.1;
						DevelopmentTeam = UJ447HWZSX;
						LastSwiftMigration = 1030;
						ProvisioningStyle = Automatic;
					};
				};
			};
			buildConfigurationList = 17A541A11E76F8BE00EB9D00 /* Build configuration list for PBXProject "SuperLittleRed" */;
			compatibilityVersion = "Xcode 3.2";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 17A5419D1E76F8BE00EB9D00;
			productRefGroup = 17A541A71E76F8BE00EB9D00 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				17A541A51E76F8BE00EB9D00 /* SuperLittleRed */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		17A541A41E76F8BE00EB9D00 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				17A543A21E7C287700EB9D00 /* Texture in Resources */,
				1706CDB6230FBB2A0039B44D /* cmake_install.cmake in Resources */,
				17A543A11E7C287700EB9D00 /* Stage in Resources */,
				17A5439F1E7C287700EB9D00 /* Audio in Resources */,
				17A5439E1E7C287700EB9D00 /* Animation in Resources */,
				17A541B31E76F8BF00EB9D00 /* Main.storyboard in Resources */,
				1706CD74230FBB2A0039B44D /* CMakeLists.txt in Resources */,
				17A541B51E76F8BF00EB9D00 /* Assets.xcassets in Resources */,
				17A543A01E7C287700EB9D00 /* Font in Resources */,
				17A541B81E76F8BF00EB9D00 /* LaunchScreen.storyboard in Resources */,
				17A541C01E76F94200EB9D00 /* .gitignore in Resources */,
				17A543A31E7C287700EB9D00 /* UI in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		17A541A21E76F8BE00EB9D00 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				1706CD52230FBB2A0039B44D /* Font.c in Sources */,
				1706CD4C230FBB2A0039B44D /* Skeleton.c in Sources */,
				1706CD6A230FBB2A0039B44D /* ShaderPrimitive.c in Sources */,
				1706CD51230FBB2A0039B44D /* SkeletonSlot.c in Sources */,
				1706CD54230FBB2A0039B44D /* DrawAtlas.c in Sources */,
				1706CDB8230FBB2A0039B44D /* File.m in Sources */,
				1706CDCA230FBB2A0039B44D /* Matrix.c in Sources */,
				1706CD60230FBB2A0039B44D /* Graphics.c in Sources */,
				1706CDBE230FBB2A0039B44D /* TweenTool.c in Sources */,
				17EA45E81EE84DC200ECD84B /* HUD.c in Sources */,
				1706CD43230FBB290039B44D /* PhysicsBody.c in Sources */,
				1706CD72230FBB2A0039B44D /* Audio.m in Sources */,
				1706CD4B230FBB2A0039B44D /* Extension.c in Sources */,
				17EA45E91EE84DC200ECD84B /* Tool.c in Sources */,
				17EA45E31EE84DC200ECD84B /* EnemyAI.c in Sources */,
				1706CD61230FBB2A0039B44D /* Image.c in Sources */,
				17EA45E01EE84DC200ECD84B /* AudioTool.c in Sources */,
				17EA45E21EE84DC200ECD84B /* Enemy.c in Sources */,
				17EA45DF1EE84DC200ECD84B /* AppInit.c in Sources */,
				1706CD71230FBB2A0039B44D /* Mesh.c in Sources */,
				1706CDC3230FBB2A0039B44D /* ArrayStrMap.c in Sources */,
				1706CD5C230FBB2A0039B44D /* Input.c in Sources */,
				1706CD64230FBB2A0039B44D /* Color.c in Sources */,
				17EA45E41EE84DC200ECD84B /* GameActor.c in Sources */,
				1706CD70230FBB2A0039B44D /* GLPrimitive.c in Sources */,
				1706CD69230FBB2A0039B44D /* GLTool.c in Sources */,
				1706CDBC230FBB2A0039B44D /* Array.c in Sources */,
				1706CD68230FBB2A0039B44D /* SubMesh.c in Sources */,
				1706CD4E230FBB2A0039B44D /* SkeletonBone.c in Sources */,
				1706CD6F230FBB2A0039B44D /* Camera.c in Sources */,
				1706CD6D230FBB2A0039B44D /* Shader.c in Sources */,
				1706CD41230FBB290039B44D /* PhysicsWorld.c in Sources */,
				17EA45E71EE84DC200ECD84B /* Hero.c in Sources */,
				1706CD73230FBB2A0039B44D /* Audio.c in Sources */,
				1706CDC8230FBB2A0039B44D /* Math.c in Sources */,
				1706CD66230FBB2A0039B44D /* EGLTool.c in Sources */,
				1706CD4D230FBB2A0039B44D /* SkeletonData.c in Sources */,
				17EA45EA1EE84DC200ECD84B /* UI.c in Sources */,
				1706CDC9230FBB2A0039B44D /* TweenEase.c in Sources */,
				1706CD50230FBB2A0039B44D /* SkeletonTimeline.c in Sources */,
				1706CDC6230FBB2A0039B44D /* FileTool.c in Sources */,
				1706CD62230FBB2A0039B44D /* Quad.c in Sources */,
				17A541B01E76F8BF00EB9D00 /* GameViewController.swift in Sources */,
				1706CDBD230FBB2A0039B44D /* ArrayQueue.c in Sources */,
				1706CDBB230FBB2A0039B44D /* Thread.c in Sources */,
				17A541AA1E76F8BE00EB9D00 /* AppDelegate.swift in Sources */,
				1706CDC2230FBB2A0039B44D /* Tween.c in Sources */,
				1706CD5A230FBB2A0039B44D /* NativeGlue.c in Sources */,
				17EA45E51EE84DC200ECD84B /* GameData.c in Sources */,
				1706CD44230FBB290039B44D /* PhysicsCollision.c in Sources */,
				1706CD55230FBB2A0039B44D /* Vibrator.m in Sources */,
				1706CDB9230FBB2A0039B44D /* File.c in Sources */,
				1706CD65230FBB2A0039B44D /* Sprite.c in Sources */,
				1706CDC0230FBB2A0039B44D /* ArrayList.c in Sources */,
				1706CD6E230FBB2A0039B44D /* GLInfo.c in Sources */,
				1706CD6B230FBB2A0039B44D /* ShaderMesh.c in Sources */,
				1706CD5E230FBB2A0039B44D /* Application.c in Sources */,
				1706CD4F230FBB2A0039B44D /* SkeletonAnimationPlayer.c in Sources */,
				1706CD58230FBB2A0039B44D /* JniTool.c in Sources */,
				1706CD63230FBB2A0039B44D /* Drawable.c in Sources */,
				1706CD42230FBB290039B44D /* Physics.c in Sources */,
				1706CDC1230FBB2A0039B44D /* ArrayIntSet.c in Sources */,
				1706CD5D230FBB2A0039B44D /* Scheduler.c in Sources */,
				17EA45E61EE84DC200ECD84B /* GameMap.c in Sources */,
				1706CD5F230FBB2A0039B44D /* TweenDrawable.c in Sources */,
				1706CBFA230FBAD10039B44D /* ADTool.c in Sources */,
				1706CD59230FBB2A0039B44D /* SystemInfo.c in Sources */,
				1706CD67230FBB2A0039B44D /* Texture.c in Sources */,
				1706CD5B230FBB2A0039B44D /* Component.c in Sources */,
				1706CD56230FBB2A0039B44D /* SystemInfo.m in Sources */,
				1706CDC7230FBB2A0039B44D /* Coroutine.c in Sources */,
				1706CDBF230FBB2A0039B44D /* ArrayStrSet.c in Sources */,
				1706CD6C230FBB2A0039B44D /* ShaderSprite.c in Sources */,
				1706CDCB230FBB2A0039B44D /* Toolkit.c in Sources */,
				1706CDBA230FBB2A0039B44D /* Json.c in Sources */,
				1706CD53230FBB2A0039B44D /* TextureAtlas.c in Sources */,
				1706CDC4230FBB2A0039B44D /* ArrayIntMap.c in Sources */,
				1706CDC5230FBB2A0039B44D /* BufferReader.c in Sources */,
				1706CD57230FBB2A0039B44D /* Vibrator.c in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXVariantGroup section */
		17A541B11E76F8BF00EB9D00 /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				17A541B21E76F8BF00EB9D00 /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		17A541B61E76F8BF00EB9D00 /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				17A541B71E76F8BF00EB9D00 /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		17A541BA1E76F8BF00EB9D00 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "compiler-default";
				CLANG_CXX_LIBRARY = "compiler-default";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = c99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				HEADER_SEARCH_PATHS = (
					../Code/,
					../../../,
				);
				IPHONEOS_DEPLOYMENT_TARGET = 11.4;
				LIBRARY_SEARCH_PATHS = "../../../Engine/ThirdParty/**";
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OBJC_BRIDGING_HEADER = "SuperLittleRed/SuperLittleRed-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		17A541BB1E76F8BF00EB9D00 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_LOCALIZABILITY_NONLOCALIZED = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "compiler-default";
				CLANG_CXX_LIBRARY = "compiler-default";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = c99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				HEADER_SEARCH_PATHS = (
					../Code/,
					../../../,
				);
				IPHONEOS_DEPLOYMENT_TARGET = 11.4;
				LIBRARY_SEARCH_PATHS = "../../../Engine/ThirdParty/**";
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SWIFT_OBJC_BRIDGING_HEADER = "SuperLittleRed/SuperLittleRed-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Owholemodule";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		17A541BD1E76F8BF00EB9D00 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				DEVELOPMENT_TEAM = UJ447HWZSX;
				INFOPLIST_FILE = "$(SRCROOT)/Info.plist";
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks";
				LIBRARY_SEARCH_PATHS = "$(inherited)";
				PRODUCT_BUNDLE_IDENTIFIER = com.Mojoc.Samples.SuperLittleRed;
				PRODUCT_MODULE_NAME = Mojoc;
				PRODUCT_NAME = "$(TARGET_NAME)";
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_OBJC_BRIDGING_HEADER = "SuperLittleRed-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		17A541BE1E76F8BF00EB9D00 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				DEVELOPMENT_TEAM = UJ447HWZSX;
				INFOPLIST_FILE = "$(SRCROOT)/Info.plist";
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				LD_RUNPATH_SEARCH_PATHS = "$(inherited) @executable_path/Frameworks";
				LIBRARY_SEARCH_PATHS = "$(inherited)";
				PRODUCT_BUNDLE_IDENTIFIER = com.Mojoc.Samples.SuperLittleRed;
				PRODUCT_MODULE_NAME = Mojoc;
				PRODUCT_NAME = "$(TARGET_NAME)";
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_OBJC_BRIDGING_HEADER = "SuperLittleRed-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		17A541A11E76F8BE00EB9D00 /* Build configuration list for PBXProject "SuperLittleRed" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				17A541BA1E76F8BF00EB9D00 /* Debug */,
				17A541BB1E76F8BF00EB9D00 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		17A541BC1E76F8BF00EB9D00 /* Build configuration list for PBXNativeTarget "SuperLittleRed" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				17A541BD1E76F8BF00EB9D00 /* Debug */,
				17A541BE1E76F8BF00EB9D00 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 17A5419E1E76F8BE00EB9D00 /* Project object */;
}

```

`Samples/SuperLittleRed/IOS/SuperLittleRed.xcodeproj/project.xcworkspace/contents.xcworkspacedata`:

```xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:SuperLittleRed.xcodeproj">
   </FileRef>
</Workspace>

```

`Samples/SuperLittleRed/IOS/Texture/Arrow.atlas`:

```atlas

Arrow.png
size: 128,32
format: RGBA8888
filter: Linear,Linear
repeat: none
Copper
  rotate: false
  xy: 78, 20
  size: 10, 10
  orig: 10, 10
  offset: 0, 0
  index: -1
Dragon
  rotate: false
  xy: 49, 22
  size: 14, 8
  orig: 14, 8
  offset: 0, 0
  index: -1
Gold
  rotate: false
  xy: 2, 2
  size: 14, 12
  orig: 14, 12
  offset: 0, 0
  index: -1
Heart
  rotate: false
  xy: 18, 18
  size: 12, 12
  orig: 12, 12
  offset: 0, 0
  index: -1
Ice
  rotate: false
  xy: 32, 21
  size: 15, 9
  orig: 15, 9
  offset: 0, 0
  index: -1
Iron
  rotate: false
  xy: 65, 20
  size: 11, 10
  orig: 11, 10
  offset: 0, 0
  index: -1
Lightning
  rotate: false
  xy: 103, 21
  size: 9, 9
  orig: 9, 9
  offset: 0, 0
  index: -1
Silver
  rotate: false
  xy: 2, 16
  size: 14, 14
  orig: 14, 14
  offset: 0, 0
  index: -1
Steel
  rotate: false
  xy: 18, 5
  size: 11, 11
  orig: 11, 11
  offset: 0, 0
  index: -1
Wood
  rotate: false
  xy: 90, 21
  size: 11, 9
  orig: 11, 9
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/Texture/Drop.atlas`:

```atlas

Drop.png
size: 256,64
format: RGBA8888
filter: Linear,Linear
repeat: none
Coin
  rotate: false
  xy: 165, 24
  size: 30, 31
  orig: 30, 31
  offset: 0, 0
  index: -1
DropStone
  rotate: false
  xy: 2, 2
  size: 40, 53
  orig: 40, 53
  offset: 0, 0
  index: -1
DropWood
  rotate: false
  xy: 86, 25
  size: 40, 30
  orig: 40, 30
  offset: 0, 0
  index: -1
Heart
  rotate: false
  xy: 197, 29
  size: 30, 26
  orig: 30, 26
  offset: 0, 0
  index: -1
Stone
  rotate: false
  xy: 128, 22
  size: 35, 33
  orig: 35, 33
  offset: 0, 0
  index: -1
Wood
  rotate: false
  xy: 44, 22
  size: 40, 33
  orig: 40, 33
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/Curtain.atlas`:

```atlas

Curtain.png
size: 256,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
LCurtain
  rotate: false
  xy: 2, 2
  size: 240, 540
  orig: 240, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/Curtain.json`:

```json
{
"skeleton": { "hash": "CGONYPfuy4eXu5LYuNl5IW+qczw", "spine": "3.7.91", "width": 959.91, "height": 572.45 },
"bones": [
	{ "name": "root" },
	{ "name": "l-curtain", "parent": "root", "length": 197.06, "x": -360.4, "scaleX": 0.5, "scaleY": 0.53 },
	{ "name": "r-curtain", "parent": "root", "length": 197.06, "x": 360.38, "scaleX": -0.496, "scaleY": 0.53 }
],
"slots": [
	{ "name": "r-curtain", "bone": "r-curtain", "attachment": "LCurtain" },
	{ "name": "l-curtain", "bone": "l-curtain", "attachment": "LCurtain" }
],
"skins": {
	"default": {
		"l-curtain": {
			"LCurtain": {
				"type": "mesh",
				"uvs": [ 1, 0.51575, 1, 1, 0.77735, 1, 0.52132, 1, 0.25366, 1, 0, 1, 0, 0.51317, 0, 0, 0.25366, 0, 0.52132, 0, 0.77735, 0, 1, 0, 0.77735, 0.51317, 0.52132, 0.51317, 0.25366, 0.51317 ],
				"triangles": [ 6, 7, 8, 14, 6, 8, 14, 8, 9, 13, 14, 9, 13, 9, 10, 12, 10, 11, 13, 10, 12, 12, 11, 0, 4, 5, 6, 3, 4, 14, 4, 6, 14, 2, 3, 13, 3, 14, 13, 12, 2, 13, 12, 1, 2, 1, 12, 0 ],
				"vertices": [ 240, -17.05, 239.91, -540.04, 133.04, -540.02, 10.14, -540, -118.33, -539.98, -240.09, -539.96, -240, -14.18, -239.91, 540.04, -118.15, 540.02, 10.33, 540, 133.22, 539.98, 240.09, 539.96, 133.12, -14.24, 10.23, -14.22, -118.24, -14.2 ],
				"hull": 12
			}
		},
		"r-curtain": {
			"LCurtain": {
				"type": "mesh",
				"uvs": [ 1, 0.51575, 1, 1, 0.77735, 1, 0.52132, 1, 0.25366, 1, 0, 1, 0, 0.51317, 0, 0, 0.25366, 0, 0.52132, 0, 0.77735, 0, 1, 0, 0.77735, 0.51317, 0.52132, 0.51317, 0.25366, 0.51317 ],
				"triangles": [ 6, 7, 8, 14, 6, 8, 14, 8, 9, 13, 14, 9, 13, 9, 10, 12, 10, 11, 13, 10, 12, 12, 11, 0, 4, 5, 6, 3, 4, 14, 4, 6, 14, 2, 3, 13, 3, 14, 13, 12, 2, 13, 12, 1, 2, 1, 12, 0 ],
				"vertices": [ 240, -17.05, 239.91, -540.04, 133.04, -540.02, 10.14, -540, -118.34, -539.98, -240.09, -539.96, -240, -14.18, -239.91, 540.04, -118.15, 540.02, 10.33, 540, 133.22, 539.98, 240.09, 539.96, 133.13, -14.24, 10.23, -14.22, -118.24, -14.2 ],
				"hull": 12
			}
		}
	}
},
"animations": {
	"close": {
		"bones": {
			"l-curtain": {
				"translate": [
					{ "time": 0, "x": -4, "y": 0 },
					{
						"time": 0.6667,
						"x": 0,
						"y": 0,
						"curve": [ 0.463, 0.7, 1, 1 ]
					},
					{ "time": 0.9, "x": -110, "y": 0 }
				]
			},
			"r-curtain": {
				"translate": [
					{ "time": 0, "x": 3.62, "y": 0 },
					{
						"time": 0.6667,
						"x": 0.62,
						"y": 0,
						"curve": [ 0.463, 0.7, 1, 1 ]
					},
					{ "time": 0.9, "x": 110.62, "y": 0 }
				]
			}
		},
		"deform": {
			"default": {
				"l-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						},
						{
							"time": 0.1333,
							"vertices": [ 432.2832, 21.80872, 486.62573, 14.95862, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 390.20398, 8.76813, 333.15564, 16.073, 218.79541, -0.66461, 122.78381, 4.84912 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 220.87793, 20.74713, 272.8459, 8.93994, 199.18506, 7.25824, 148.25787, 5.20587, 58.98822, 1.5733, 0, 0, 0, 0, 0, 0, 65.47662, 1.40302, 68.54089, 2.10065, 137.61993, 3.41229, 183.75409, 5.3291, 161.31995, 0.92035, 100.78369, -0.17334, 56.42267, 3.74194 ]
						},
						{
							"time": 0.4,
							"vertices": [ 78.4137, 13.45746, 142.58795, 6.77069, 76.30096, 5.21155, 30.24377, 5.69977, -22.11847, 0.22119, 0, 0, 0, 0, 0, 0, -15.63007, 0.0509, -27.31067, 0.50397, -22.13428, 0.74847, 36.2912, 2.87231, 30.89807, 8.58154, -5.02191, 5.4386, -24.68402, 2.38983 ]
						},
						{
							"time": 0.5333,
							"vertices": [ -59.26178, 13.62079, -22.07806, 4.02905, -78.53424, 2.63367, -114.72119, 0.82611, -56.56842, 2.1051, 0, 0, 0, 0, 0, 0, -59.87054, -0.68683, -120.70618, -1.05316, -100.78241, -0.56183, -91.50854, 0.74432, -99.31848, 3.95477, -118.1604, 8.47052, -59.17517, 6.7312 ]
						},
						{
							"time": 0.6667,
							"vertices": [ -273.9226, -3.03149, -273.9226, -3.03149, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -273.9226, -3.03149, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ]
						}
					]
				},
				"r-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						},
						{
							"time": 0.1333,
							"vertices": [ 432.2832, 21.80872, 486.62573, 14.95862, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 390.20398, 8.76813, 333.15564, 16.073, 218.79541, -0.66461, 122.78381, 4.84912 ]
						},
						{
							"time": 0.2667,
							"vertices": [ 220.87793, 20.74713, 272.8459, 8.93994, 199.18506, 7.25824, 148.25787, 5.20587, 58.98822, 1.5733, 0, 0, 0, 0, 0, 0, 65.47662, 1.40302, 68.54089, 2.10065, 137.61993, 3.41229, 183.75409, 5.3291, 161.31995, 0.92035, 100.78369, -0.17334, 56.42267, 3.74194 ]
						},
						{
							"time": 0.4,
							"vertices": [ 78.4137, 13.45746, 142.58795, 6.77069, 76.30096, 5.21155, 30.24377, 5.69977, -22.11847, 0.22119, 0, 0, 0, 0, 0, 0, -15.63007, 0.0509, -27.31067, 0.50397, -22.13428, 0.74847, 36.2912, 2.87231, 30.89807, 8.58154, -5.02191, 5.4386, -24.68402, 2.38983 ]
						},
						{
							"time": 0.5333,
							"vertices": [ -59.26178, 13.62079, -22.07806, 4.02905, -78.53424, 2.63367, -114.72119, 0.82611, -56.56842, 2.1051, 0, 0, 0, 0, 0, 0, -59.87054, -0.68683, -120.70618, -1.05316, -100.78241, -0.56183, -91.50854, 0.74432, -99.31848, 3.95477, -118.1604, 8.47052, -59.17517, 6.7312 ]
						},
						{
							"time": 0.6667,
							"vertices": [ -275.87817, -3.03149, -275.87817, -3.03149, -216.36029, -2.28912, -149.42908, -2.45532, -72.00098, -0.85242, -1.95557, 0, -1.95557, 0, -1.95557, 0, -72.00098, -0.85242, -149.76575, -1.5, -216.36029, -2.28912, -275.87817, -3.03149, -216.36029, -2.28912, -149.76575, -1.5, -72.00098, -0.85242 ]
						}
					]
				}
			}
		}
	},
	"stop": {
		"bones": {
			"l-curtain": {
				"translate": [
					{ "time": 0, "x": -4, "y": 0 }
				]
			},
			"r-curtain": {
				"translate": [
					{ "time": 0, "x": 3.62, "y": 0 }
				]
			}
		},
		"deform": {
			"default": {
				"l-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						}
					]
				},
				"r-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						}
					]
				}
			}
		}
	},
	"open": {
		"bones": {
			"l-curtain": {
				"translate": [
					{
						"time": 0,
						"x": -80,
						"y": 0,
						"curve": [ 0.695, 0.5, 1, 1 ]
					},
					{
						"time": 0.2333,
						"x": 0,
						"y": 0,
						"curve": [ 0.695, 0.5, 1, 1 ]
					},
					{ "time": 0.8667, "x": -4, "y": 0 }
				]
			},
			"r-curtain": {
				"translate": [
					{
						"time": 0,
						"x": 80.02,
						"y": 0,
						"curve": [ 0.695, 0.5, 1, 1 ]
					},
					{
						"time": 0.2333,
						"x": 2.02,
						"y": 0,
						"curve": [ 0.695, 0.5, 1, 1 ]
					},
					{ "time": 0.8667, "x": 4.02, "y": 0 }
				]
			}
		},
		"deform": {
			"default": {
				"l-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ -273.9226, -3.03149, -273.9226, -3.03149, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -273.9226, -3.03149, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ],
							"curve": "stepped"
						},
						{
							"time": 0.2333,
							"vertices": [ -273.9226, -3.03149, -273.9226, -3.03149, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -273.9226, -3.03149, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ],
							"curve": [ 0.695, 0.5, 1, 1 ]
						},
						{
							"time": 0.3667,
							"vertices": [ -127.65283, 4.47797, -154.5199, -0.56177, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -89.0246, -0.38568, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ]
						},
						{
							"time": 0.5,
							"vertices": [ 48.83887, 7.41809, -0.90668, 1.99701, -96.49017, -0.1228, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -47.71619, 0.32837, 87.4671, 2.55444, -71.02716, 4.2132, -147.81018, -1.5, -70.04541, -0.85242 ]
						},
						{
							"time": 0.6,
							"vertices": [ 220.45526, 12.83844, 163.06445, 4.72723, 103.35156, 3.20483, 72.82263, 3.77533, -54.71667, 1.96533, 0, 0, 0, 0, 0, 0, -29.05255, -0.1698, 87.90039, 2.4248, 187.9945, 4.2533, 277.06067, 5.7113, 139.19135, 0.02515, 85.33862, 2.38245, -52.19696, 4.57037 ]
						},
						{
							"time": 0.7333,
							"vertices": [ 440.79364, 16.5072, 393.609, 11.12878, 254.51349, 5.72198, 200.9253, 5.90826, 93.88397, 4.43976, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 290.35327, 2.5423, 213.44128, 4.51538, 96.40369, 7.0448 ]
						},
						{
							"time": 0.8667,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						}
					]
				},
				"r-curtain": {
					"LCurtain": [
						{
							"time": 0,
							"vertices": [ -273.9226, -3.03149, -273.9226, -3.03149, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -273.9226, -3.03149, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ],
							"curve": "stepped"
						},
						{
							"time": 0.2333,
							"vertices": [ -273.9226, -3.03149, -273.9226, -3.03149, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -273.9226, -3.03149, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ],
							"curve": [ 0.695, 0.5, 1, 1 ]
						},
						{
							"time": 0.3667,
							"vertices": [ -127.65283, 4.47797, -154.5199, -0.56177, -214.40472, -2.28912, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -214.40472, -2.28912, -89.0246, -0.38568, -214.40472, -2.28912, -147.81018, -1.5, -70.04541, -0.85242 ]
						},
						{
							"time": 0.5,
							"vertices": [ 48.83887, 7.41809, -0.90668, 1.99701, -96.49017, -0.1228, -147.47351, -2.45532, -70.04541, -0.85242, 0, 0, 0, 0, 0, 0, -70.04541, -0.85242, -147.81018, -1.5, -47.71619, 0.32837, 87.4671, 2.55444, -71.02716, 4.2132, -147.81018, -1.5, -70.04541, -0.85242 ]
						},
						{
							"time": 0.6,
							"vertices": [ 220.45526, 12.83844, 163.06445, 4.72723, 103.35156, 3.20483, 72.82263, 3.77533, -54.71667, 1.96533, 0, 0, 0, 0, 0, 0, -29.05255, -0.1698, 87.90039, 2.4248, 187.9945, 4.2533, 277.06067, 5.7113, 139.19135, 0.02515, 85.33862, 2.38245, -52.19696, 4.57037 ]
						},
						{
							"time": 0.7333,
							"vertices": [ 440.79364, 16.5072, 393.609, 11.12878, 254.51349, 5.72198, 200.9253, 5.90826, 93.88397, 4.43976, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 290.35327, 2.5423, 213.44128, 4.51538, 96.40369, 7.0448 ]
						},
						{
							"time": 0.8667,
							"vertices": [ 498.60168, 25.37219, 498.9975, 10.24884, 346.6902, 7.25641, 221.94989, 8.89258, 122.80988, 7.5553, 0, 0, 0, 0, 0, 0, 119.5481, 2.30463, 216.00305, 4.55774, 339.15643, 6.77045, 497.39905, 9.38007, 345.5274, 11.36322, 218.79541, -0.66461, 122.78381, 4.84912 ]
						}
					]
				}
			}
		}
	}
}
}
```

`Samples/SuperLittleRed/IOS/UI/HUD.atlas`:

```atlas

HUD.png
size: 1024,256
format: RGBA8888
filter: Linear,Linear
repeat: none
Coin
  rotate: false
  xy: 126, 106
  size: 30, 31
  orig: 30, 31
  offset: 0, 0
  index: -1
EnergyLength
  rotate: false
  xy: 1017, 186
  size: 5, 61
  orig: 5, 61
  offset: 0, 0
  index: -1
EnergySlot
  rotate: false
  xy: 2, 37
  size: 60, 135
  orig: 60, 135
  offset: 0, 0
  index: -1
Heart
  rotate: false
  xy: 964, 174
  size: 30, 26
  orig: 30, 26
  offset: 0, 0
  index: -1
Kill
  rotate: false
  xy: 163, 142
  size: 30, 30
  orig: 30, 30
  offset: 0, 0
  index: -1
Pointer
  rotate: false
  xy: 64, 39
  size: 17, 15
  orig: 17, 15
  offset: 0, 0
  index: -1
Stone
  rotate: false
  xy: 64, 56
  size: 43, 42
  orig: 43, 42
  offset: 0, 0
  index: -1
Stone2
  rotate: false
  xy: 126, 139
  size: 35, 33
  orig: 35, 33
  offset: 0, 0
  index: -1
Tombstone
  rotate: false
  xy: 64, 100
  size: 60, 72
  orig: 60, 72
  offset: 0, 0
  index: -1
Wood
  rotate: false
  xy: 964, 202
  size: 51, 45
  orig: 51, 45
  offset: 0, 0
  index: -1
Wood2
  rotate: false
  xy: 2, 2
  size: 40, 33
  orig: 40, 33
  offset: 0, 0
  index: -1
down
  rotate: false
  xy: 2, 206
  size: 960, 41
  orig: 960, 41
  offset: 0, 0
  index: -1
up
  rotate: false
  xy: 2, 174
  size: 960, 30
  orig: 960, 30
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/HUD.json`:

```json
{
"skeleton": { "hash": "B17rqM4AuFYMgBowFbHM5Vd+VjM", "spine": "3.7.91", "width": 1079, "height": 716.59 },
"bones": [
	{ "name": "root" },
	{ "name": "Right", "parent": "root", "x": 520.07, "y": 1.76 },
	{ "name": "Coin", "parent": "Right", "x": 0.93, "y": 156.24 },
	{ "name": "DownUp", "parent": "root" },
	{ "name": "Down", "parent": "DownUp" },
	{ "name": "Energy", "parent": "root", "x": -512, "y": 114 },
	{ "name": "EnergyLength", "parent": "Energy", "x": 2.45, "y": -52.68 },
	{ "name": "Heart", "parent": "Right", "x": 0.93, "y": 206.24 },
	{ "name": "Kill", "parent": "Right", "x": 0.93, "y": 106.24 },
	{ "name": "ScorePos", "parent": "root", "x": -467.45, "y": 240 },
	{ "name": "Stone", "parent": "Right", "x": 0.93, "y": 56.24 },
	{ "name": "Tombstone", "parent": "root", "y": 315 },
	{ "name": "Up", "parent": "DownUp" },
	{ "name": "Wood", "parent": "Right", "x": 0.93, "y": 6.24 },
	{ "name": "DownBtn", "parent": "root", "y": -60.58 },
	{ "name": "StoneRight", "parent": "DownBtn", "x": 265.2, "y": -268.5 },
	{ "name": "WoodRight", "parent": "DownBtn", "x": 348.23, "y": -276.33 },
	{ "name": "StoneLeft", "parent": "DownBtn", "x": -261.81, "y": -280.23 },
	{ "name": "WoodLeft", "parent": "DownBtn", "x": -335.51, "y": -273.2 }
],
"slots": [
	{ "name": "StoneRight", "bone": "StoneRight", "attachment": "Stone" },
	{ "name": "StoneLeft", "bone": "StoneLeft", "attachment": "Stone" },
	{ "name": "Wood", "bone": "Wood", "attachment": "Wood2" },
	{ "name": "WoodRight", "bone": "WoodRight", "attachment": "Wood" },
	{ "name": "WoodLeft", "bone": "WoodLeft", "attachment": "Wood" },
	{ "name": "EnergySlot", "bone": "Energy", "attachment": "EnergySlot" },
	{ "name": "EnergyLength", "bone": "EnergyLength", "attachment": "EnergyLength" },
	{ "name": "Tombstone", "bone": "Tombstone", "attachment": "Tombstone" },
	{ "name": "down", "bone": "Down", "attachment": "down" },
	{ "name": "Up", "bone": "Up", "attachment": "up" },
	{ "name": "StoneBoxRight", "bone": "StoneRight", "attachment": "StoneBox" },
	{ "name": "StoneBoxLeft", "bone": "StoneLeft", "attachment": "StoneBox" },
	{ "name": "WoodBoxRight", "bone": "WoodRight", "attachment": "WoodBox" },
	{ "name": "WoodBoxLeft", "bone": "WoodLeft", "attachment": "WoodBox" },
	{ "name": "Coin", "bone": "Coin", "attachment": "Coin" },
	{ "name": "Stone", "bone": "Stone", "attachment": "Stone2" },
	{ "name": "Heart", "bone": "Heart", "attachment": "Heart" },
	{ "name": "Kill", "bone": "Kill", "attachment": "Kill" },
	{ "name": "Pointer", "bone": "EnergyLength", "attachment": "Pointer" }
],
"skins": {
	"default": {
		"Coin": {
			"Coin": { "width": 30, "height": 31 }
		},
		"EnergyLength": {
			"EnergyLength": { "y": 30.5, "scaleY": 0.97, "width": 5, "height": 61 }
		},
		"EnergySlot": {
			"EnergySlot": { "width": 60, "height": 135 }
		},
		"Heart": {
			"Heart": { "width": 30, "height": 26 }
		},
		"Kill": {
			"Kill": { "width": 30, "height": 30 }
		},
		"Pointer": {
			"Pointer": { "x": 8, "y": 60.38, "width": 17, "height": 15 }
		},
		"Stone": {
			"Stone2": { "x": 0.5, "y": 0.5, "scaleX": 0.806, "scaleY": 0.806, "width": 35, "height": 33 }
		},
		"StoneBoxLeft": {
			"StoneBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -31, 21.6, 35.2, 19.65, 33.26, -22.27, -30.69, -20.73 ]
			}
		},
		"StoneBoxRight": {
			"StoneBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -31, 21.6, 35.2, 19.65, 33.26, -22.27, -30.69, -20.73 ]
			}
		},
		"StoneLeft": {
			"Stone": { "width": 43, "height": 42 }
		},
		"StoneRight": {
			"Stone": { "width": 43, "height": 42 }
		},
		"Tombstone": {
			"Tombstone": { "width": 60, "height": 72 }
		},
		"Up": {
			"up": { "y": 283.99, "width": 960, "height": 30 }
		},
		"Wood": {
			"Wood2": { "y": 0.5, "scaleX": 0.8, "scaleY": 0.8, "width": 40, "height": 33 }
		},
		"WoodBoxLeft": {
			"WoodBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -30.88, 19.58, 37.03, 20.2, 34.37, -21.43, -31.91, -20.4 ]
			}
		},
		"WoodBoxRight": {
			"WoodBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -30.88, 18.8, 37.03, 19.42, 34.37, -22.2, -31.91, -21.18 ]
			}
		},
		"WoodLeft": {
			"Wood": { "y": -3.02, "rotation": -16.43, "width": 51, "height": 45 }
		},
		"WoodRight": {
			"Wood": { "rotation": -5.03, "width": 51, "height": 45 }
		},
		"down": {
			"down": { "y": -288.68, "width": 960, "height": 41 }
		}
	}
},
"animations": {
	"ShowIn": {
		"bones": {
			"Energy": {
				"translate": [
					{
						"time": 0,
						"x": 0,
						"y": 0,
						"curve": [ 0.513, 0.67, 0.514, 1.62 ]
					},
					{ "time": 0.6667, "x": 72, "y": 0 }
				]
			},
			"Up": {
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.5, "x": 0, "y": -26.29 }
				]
			},
			"Down": {
				"translate": [
					{ "time": 0, "x": 0, "y": 0 },
					{ "time": 0.5, "x": 0, "y": 38.26 }
				]
			},
			"Right": {
				"translate": [
					{
						"time": 0,
						"x": 0,
						"y": 0,
						"curve": [ 0.207, 0.29, 0.302, 1.71 ]
					},
					{ "time": 0.6667, "x": -64.09, "y": 0 }
				]
			},
			"DownBtn": {
				"translate": [
					{
						"time": 0,
						"x": 0,
						"y": -71.62,
						"curve": [ 0.186, 0.69, 0.143, 1.09 ]
					},
					{ "time": 1, "x": 0, "y": 97.69 }
				]
			}
		}
	},
	"animation": {}
}
}
```

`Samples/SuperLittleRed/IOS/UI/UIFail-zh.atlas`:

```atlas

UIFail-zh.png
size: 1024,512
format: RGBA8888
filter: Linear,Linear
repeat: none
Again
  rotate: false
  xy: 511, 400
  size: 102, 102
  orig: 102, 102
  offset: 0, 0
  index: -1
FailBG
  rotate: false
  xy: 2, 2
  size: 507, 500
  orig: 507, 500
  offset: 0, 0
  index: -1
Menu
  rotate: false
  xy: 511, 296
  size: 102, 102
  orig: 102, 102
  offset: 0, 0
  index: -1
Store
  rotate: false
  xy: 615, 399
  size: 101, 103
  orig: 101, 103
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/UIFail-zh.json`:

```json
{
"skeleton": { "hash": "i/hE4jAT5Zfvq0i4nbaMD3o0mAc", "spine": "3.7.91", "width": 507, "height": 500 },
"bones": [
	{ "name": "root" },
	{ "name": "Fail", "parent": "root" },
	{ "name": "Again", "parent": "Fail", "y": -147.89 },
	{ "name": "Hit", "parent": "Fail", "x": -79.72, "y": -28.71 },
	{ "name": "Kill", "parent": "Fail", "x": 60.89, "y": 38.24 },
	{ "name": "Menu", "parent": "Fail", "x": -130.1, "y": -147.9 },
	{ "name": "Score", "parent": "Fail", "x": -79.72, "y": 38.24 },
	{ "name": "Store", "parent": "Fail", "x": 129.17, "y": -151.64 },
	{ "name": "Time", "parent": "Fail", "x": 58.51, "y": -28.71 }
],
"slots": [
	{ "name": "FailBG", "bone": "Fail", "attachment": "FailBG" },
	{ "name": "Menu", "bone": "Menu", "attachment": "Menu" },
	{ "name": "Again", "bone": "Again", "attachment": "Again" },
	{ "name": "Store", "bone": "Store", "attachment": "Store" },
	{ "name": "MenuBox", "bone": "Menu", "attachment": "MenuBox" },
	{ "name": "AgainBox", "bone": "Again", "attachment": "AgainBox" },
	{ "name": "StoreBox", "bone": "Store", "attachment": "StoreBox" }
],
"skins": {
	"default": {
		"Again": {
			"Again": { "width": 102, "height": 102 }
		},
		"AgainBox": {
			"AgainBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -53.08, 45.13, 44.12, 47.35, 42.64, -46.88, -50.85, -46.88 ]
			}
		},
		"FailBG": {
			"FailBG": { "width": 507, "height": 500 }
		},
		"Menu": {
			"Menu": { "width": 102, "height": 102 }
		},
		"MenuBox": {
			"MenuBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -43.21, 46.72, 49.15, 45.42, 47.19, -46.67, -45.31, -46.67 ]
			}
		},
		"Store": {
			"Store": { "y": 3.71, "width": 101, "height": 103 }
		},
		"StoreBox": {
			"StoreBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -46.39, 55, 47.84, 53.52, 47, -42.1, -47.88, -41.46 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/IOS/UI/UIFail.atlas`:

```atlas

UIFail.png
size: 1024,512
format: RGBA8888
filter: Linear,Linear
repeat: none
Again
  rotate: false
  xy: 511, 300
  size: 96, 98
  orig: 96, 98
  offset: 0, 0
  index: -1
FailBG
  rotate: false
  xy: 2, 2
  size: 507, 500
  orig: 507, 500
  offset: 0, 0
  index: -1
Menu
  rotate: false
  xy: 612, 404
  size: 96, 98
  orig: 96, 98
  offset: 0, 0
  index: -1
Store
  rotate: false
  xy: 511, 400
  size: 99, 102
  orig: 99, 102
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/UIFail.json`:

```json
{
"skeleton": { "hash": "V/6rfzALCxBO0FSMmaMtecPEAjw", "spine": "3.7.91", "width": 507, "height": 500 },
"bones": [
	{ "name": "root" },
	{ "name": "Fail", "parent": "root" },
	{ "name": "Again", "parent": "Fail", "y": -147.89 },
	{ "name": "Hit", "parent": "Fail", "x": -82.29, "y": -30.95 },
	{ "name": "Kill", "parent": "Fail", "x": 74.96, "y": 34.35 },
	{ "name": "Menu", "parent": "Fail", "x": -130.1, "y": -147.9 },
	{ "name": "Score", "parent": "Fail", "x": -82.29, "y": 34.35 },
	{ "name": "Store", "parent": "Fail", "x": 129.17, "y": -151.64 },
	{ "name": "Time", "parent": "Fail", "x": 74.96, "y": -30.95 }
],
"slots": [
	{ "name": "FailBG", "bone": "Fail", "attachment": "FailBG" },
	{ "name": "Menu", "bone": "Menu", "attachment": "Menu" },
	{ "name": "Again", "bone": "Again", "attachment": "Again" },
	{ "name": "Store", "bone": "Store", "attachment": "Store" },
	{ "name": "MenuBox", "bone": "Menu", "attachment": "MenuBox" },
	{ "name": "AgainBox", "bone": "Again", "attachment": "AgainBox" },
	{ "name": "StoreBox", "bone": "Store", "attachment": "StoreBox" }
],
"skins": {
	"default": {
		"Again": {
			"Again": { "width": 96, "height": 98 }
		},
		"AgainBox": {
			"AgainBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -53.08, 45.13, 44.12, 47.35, 42.64, -46.88, -50.85, -46.88 ]
			}
		},
		"FailBG": {
			"FailBG": { "x": 0.73, "width": 507, "height": 500 }
		},
		"Menu": {
			"Menu": { "width": 96, "height": 98 }
		},
		"MenuBox": {
			"MenuBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -43.21, 46.72, 49.15, 45.42, 47.19, -46.67, -45.31, -46.67 ]
			}
		},
		"Store": {
			"Store": { "y": 3.71, "width": 99, "height": 102 }
		},
		"StoreBox": {
			"StoreBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -46.39, 55, 47.84, 53.52, 47, -42.1, -47.88, -41.46 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/IOS/UI/UIMenu-zh.atlas`:

```atlas

UIMenu-zh.png
size: 512,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
BG
  rotate: false
  xy: 2, 109
  size: 353, 536
  orig: 353, 536
  offset: 0, 0
  index: -1
Record
  rotate: false
  xy: 2, 55
  size: 145, 52
  orig: 145, 52
  offset: 0, 0
  index: -1
Shop
  rotate: false
  xy: 2, 2
  size: 145, 51
  orig: 145, 51
  offset: 0, 0
  index: -1
Start
  rotate: false
  xy: 357, 593
  size: 145, 52
  orig: 145, 52
  offset: 0, 0
  index: -1
Tutorial
  rotate: false
  xy: 149, 56
  size: 145, 51
  orig: 145, 51
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/UIMenu-zh.json`:

```json
{
"skeleton": { "hash": "YGafVpKxLFZq3hnrZ0OhTWo7+3E", "spine": "3.6.53", "width": 353, "height": 536 },
"bones": [
	{ "name": "root" },
	{ "name": "BG", "parent": "root" },
	{ "name": "Button", "parent": "BG" },
	{ "name": "Record", "parent": "Button", "y": -86 },
	{ "name": "Shop", "parent": "Button", "y": -12 },
	{ "name": "Start", "parent": "Button", "y": 73 },
	{ "name": "Tutorial", "parent": "Button", "y": -168 }
],
"slots": [
	{ "name": "BG", "bone": "BG", "attachment": "BG" },
	{ "name": "Start", "bone": "Start", "attachment": "Start" },
	{ "name": "Shop", "bone": "Shop", "attachment": "Shop" },
	{ "name": "StartBox", "bone": "Start", "attachment": "StartBox" },
	{ "name": "ShopBox", "bone": "Shop", "attachment": "ShopBox" },
	{ "name": "RecordBox", "bone": "Record", "attachment": "RecordBox" },
	{ "name": "TutorialBox", "bone": "Tutorial", "attachment": "TutorialBox" },
	{ "name": "Record", "bone": "Record", "attachment": "Record" },
	{ "name": "Tutorial", "bone": "Tutorial", "attachment": "Tutorial" }
],
"skins": {
	"default": {
		"BG": {
			"BG": { "width": 353, "height": 536 }
		},
		"Record": {
			"Record": { "y": -4, "width": 145, "height": 52 }
		},
		"RecordBox": {
			"RecordBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 22, 74.5, 22, 71.5, -28, -72.5, -26 ]
			}
		},
		"Shop": {
			"Shop": { "width": 145, "height": 51 }
		},
		"ShopBox": {
			"ShopBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 24, 77.5, 24, 77.5, -27, -71.5, -26 ]
			}
		},
		"Start": {
			"Start": { "y": -5, "width": 145, "height": 52 }
		},
		"StartBox": {
			"StartBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 19, 74.5, 19, 73.5, -27, -72.5, -30 ]
			}
		},
		"Tutorial": {
			"Tutorial": { "y": -2, "width": 145, "height": 51 }
		},
		"TutorialBox": {
			"TutorialBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -74.5, 25, 75.5, 23, 75.5, -26, -73.5, -28 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/IOS/UI/UIMenu.atlas`:

```atlas

UIMenu.png
size: 512,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
BG
  rotate: false
  xy: 2, 109
  size: 358, 540
  orig: 358, 540
  offset: 0, 0
  index: -1
Record
  rotate: false
  xy: 2, 2
  size: 145, 51
  orig: 145, 51
  offset: 0, 0
  index: -1
Shop
  rotate: false
  xy: 149, 57
  size: 145, 50
  orig: 145, 50
  offset: 0, 0
  index: -1
Start
  rotate: false
  xy: 2, 55
  size: 145, 52
  orig: 145, 52
  offset: 0, 0
  index: -1
Tutorial
  rotate: false
  xy: 362, 597
  size: 145, 52
  orig: 145, 52
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/UIMenu.json`:

```json
{
"skeleton": { "hash": "+mj9k7aDyAEkSRGEQhi9lQIkds8", "spine": "3.6.53", "width": 358, "height": 540 },
"bones": [
	{ "name": "root" },
	{ "name": "BG", "parent": "root", "rotation": 0.09 },
	{ "name": "Button", "parent": "BG" },
	{ "name": "Record", "parent": "Button", "y": -86 },
	{ "name": "Shop", "parent": "Button", "y": -12 },
	{ "name": "Start", "parent": "Button", "y": 73 },
	{ "name": "Tutorial", "parent": "Button", "y": -168 }
],
"slots": [
	{ "name": "BG", "bone": "BG", "attachment": "BG" },
	{ "name": "Start", "bone": "Start", "attachment": "Start" },
	{ "name": "Shop", "bone": "Shop", "attachment": "Shop" },
	{ "name": "StartBox", "bone": "Start", "attachment": "StartBox" },
	{ "name": "ShopBox", "bone": "Shop", "attachment": "ShopBox" },
	{ "name": "RecordBox", "bone": "Record", "attachment": "RecordBox" },
	{ "name": "TutorialBox", "bone": "Tutorial", "attachment": "TutorialBox" },
	{ "name": "Record", "bone": "Record", "attachment": "Record" },
	{ "name": "Tutorial", "bone": "Tutorial", "attachment": "Tutorial" }
],
"skins": {
	"default": {
		"BG": {
			"BG": { "rotation": -0.09, "width": 358, "height": 540 }
		},
		"Record": {
			"Record": { "y": -4, "width": 145, "height": 51 }
		},
		"RecordBox": {
			"RecordBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 22, 74.5, 22, 71.5, -28, -72.5, -26 ]
			}
		},
		"Shop": {
			"Shop": { "width": 145, "height": 50 }
		},
		"ShopBox": {
			"ShopBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 24, 77.5, 24, 77.5, -27, -71.5, -26 ]
			}
		},
		"Start": {
			"Start": { "y": -5, "width": 145, "height": 52 }
		},
		"StartBox": {
			"StartBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -72.5, 19, 74.5, 19, 73.5, -27, -72.5, -30 ]
			}
		},
		"Tutorial": {
			"Tutorial": { "y": -2, "width": 145, "height": 52 }
		},
		"TutorialBox": {
			"TutorialBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -74.5, 25, 75.5, 23, 75.5, -26, -73.5, -28 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/IOS/UI/UIRecord-zh.atlas`:

```atlas

UIRecord-zh.png
size: 1024,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
Close
  rotate: false
  xy: 2, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
Record
  rotate: false
  xy: 2, 20
  size: 666, 540
  orig: 666, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/UIRecord-zh.json`:

```json
{
"skeleton": { "hash": "GstQOPnl6wgM5EecgXUFSZBoa0c", "spine": "3.7.91", "width": 666, "height": 540 },
"bones": [
	{ "name": "root" },
	{ "name": "Close", "parent": "root", "x": 166.06, "y": 197.27 },
	{ "name": "MaxKill", "parent": "root", "y": 47.75 },
	{ "name": "MaxRound", "parent": "root", "y": -36.94 },
	{ "name": "MaxRoundTime", "parent": "root", "y": -119.83 },
	{ "name": "MaxScore", "parent": "root", "y": 132.45 },
	{ "name": "PlayGameTime", "parent": "root", "y": -202.73 }
],
"slots": [
	{ "name": "BG", "bone": "root", "attachment": "Record" },
	{ "name": "Close", "bone": "Close", "attachment": "Close" },
	{ "name": "CloseBox", "bone": "Close", "attachment": "CloseBox" }
],
"skins": {
	"default": {
		"BG": {
			"Record": { "x": 30.72, "width": 666, "height": 540 }
		},
		"Close": {
			"Close": { "x": -1.59, "y": 1.43, "rotation": 6.11, "width": 16, "height": 16 }
		},
		"CloseBox": {
			"CloseBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -24.12, 23.7, 30.82, 25.66, 31.75, -22.99, -22.28, -24.92 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/IOS/UI/UIRecord.atlas`:

```atlas

UIRecord.png
size: 1024,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
Close
  rotate: false
  xy: 2, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
Record
  rotate: false
  xy: 2, 20
  size: 666, 540
  orig: 666, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/UIRecord.json`:

```json
{
"skeleton": { "hash": "I3VFIORr7f5+lbux93yYpZqB8/M", "spine": "3.7.91", "width": 666, "height": 540 },
"bones": [
	{ "name": "root" },
	{ "name": "Close", "parent": "root", "x": 166.06, "y": 197.27 },
	{ "name": "MaxKill", "parent": "root", "y": 47.75 },
	{ "name": "MaxRound", "parent": "root", "y": -36.94 },
	{ "name": "MaxRoundTime", "parent": "root", "y": -119.83 },
	{ "name": "MaxScore", "parent": "root", "y": 132.45 },
	{ "name": "PlayGameTime", "parent": "root", "y": -202.73 }
],
"slots": [
	{ "name": "BG", "bone": "root", "attachment": "Record" },
	{ "name": "Close", "bone": "Close", "attachment": "Close" },
	{ "name": "CloseBox", "bone": "Close", "attachment": "CloseBox" }
],
"skins": {
	"default": {
		"BG": {
			"Record": { "x": 30.72, "width": 666, "height": 540 }
		},
		"Close": {
			"Close": { "width": 16, "height": 16 }
		},
		"CloseBox": {
			"CloseBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -23.67, 24.24, 31.3, 25.14, 31.3, -23.51, -22.76, -24.42 ]
			}
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/IOS/UI/UITutorial-zh.atlas`:

```atlas

UITutorial-zh.png
size: 1024,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
Close
  rotate: false
  xy: 2, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
Tutorial
  rotate: false
  xy: 2, 20
  size: 826, 540
  orig: 826, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/UITutorial-zh.json`:

```json
{
"skeleton": { "hash": "lqozmvch6CXXlsW1vGF0hAmfY/I", "spine": "3.7.91", "width": 826, "height": 540 },
"bones": [
	{ "name": "root" },
	{ "name": "Close", "parent": "root", "x": 313.85, "y": 188.19 }
],
"slots": [
	{ "name": "Tutorial", "bone": "root", "attachment": "Tutorial" },
	{ "name": "CloseBox", "bone": "Close", "attachment": "CloseBox" },
	{ "name": "Close", "bone": "Close", "attachment": "Close" }
],
"skins": {
	"default": {
		"Close": {
			"Close": { "x": 0.16, "y": 0.74, "scaleX": 1.1, "scaleY": 1.1, "width": 16, "height": 16 }
		},
		"CloseBox": {
			"CloseBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -35.15, 28.66, 44.85, 29.66, 45.85, -25.34, -36.15, -25.34 ]
			}
		},
		"Tutorial": {
			"Tutorial": { "width": 826, "height": 540 }
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/IOS/UI/UITutorial.atlas`:

```atlas

UITutorial.png
size: 1024,1024
format: RGBA8888
filter: Linear,Linear
repeat: none
Close
  rotate: false
  xy: 2, 2
  size: 16, 16
  orig: 16, 16
  offset: 0, 0
  index: -1
Tutorial
  rotate: false
  xy: 2, 20
  size: 826, 540
  orig: 826, 540
  offset: 0, 0
  index: -1

```

`Samples/SuperLittleRed/IOS/UI/UITutorial.json`:

```json
{
"skeleton": { "hash": "MqwUMTIgngKS9HEqMWPDQHcaSNc", "spine": "3.7.91", "width": 826, "height": 540 },
"bones": [
	{ "name": "root" },
	{ "name": "Close", "parent": "root", "x": 314.16, "y": 189.53 }
],
"slots": [
	{ "name": "Tutorial", "bone": "root", "attachment": "Tutorial" },
	{ "name": "CloseBox", "bone": "Close", "attachment": "CloseBox" },
	{ "name": "Close", "bone": "Close", "attachment": "Close" }
],
"skins": {
	"default": {
		"Close": {
			"Close": { "width": 16, "height": 16 }
		},
		"CloseBox": {
			"CloseBox": {
				"type": "boundingbox",
				"vertexCount": 4,
				"vertices": [ -35.15, 39.49, 44.85, 40.49, 45.85, -14.51, -36.15, -14.51 ]
			}
		},
		"Tutorial": {
			"Tutorial": { "width": 826, "height": 540 }
		}
	}
},
"animations": {
	"animation": {}
}
}
```

`Samples/SuperLittleRed/IOS/en.lproj/InfoPlist.strings`:

```strings
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2019-7-23
 * Update   : 2019-7-23
 * Author   : scott.cgi
 */

"CFBundleDisplayName" = "Mojoc Super Little Red";

```

`Samples/SuperLittleRed/IOS/zh-Hans.lproj/InfoPlist.strings`:

```strings
/*
 * Copyright (c) scott.cgi All Rights Reserved.
 *
 * This source code belongs to project Mojoc, which is a pure C Game Engine hosted on GitHub.
 * The Mojoc Game Engine is licensed under the MIT License, and will continue to be iterated with coding passion.
 *
 * License  : https://github.com/scottcgi/Mojoc/blob/master/LICENSE
 * GitHub   : https://github.com/scottcgi/Mojoc
 * CodeStyle: https://github.com/scottcgi/Mojoc/blob/master/Docs/CodeStyle.md
 *
 * Since    : 2019-7-23
 * Update   : 2019-7-23
 * Author   : scott.cgi
 */

"CFBundleDisplayName" = "Mojoc 小红帽丛林之战";

```

`ThirdPartyBuild/PNG/Android/app/CMakeLists.txt`:

```txt
# Sets the minimum version of CMake required to build the native
# library. You should either keep the default value or only pass a
# value of 3.4.0 or lower.

cmake_minimum_required(VERSION 3.4.1)
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -O3 -std=c99")

# Creates and names a library, sets it as either STATIC
# or SHARED, and provides the relative paths to its source code.
# You can define multiple libraries, and CMake builds it for you.
# Gradle automatically packages shared libraries with your APK.

include_directories(
    src/main/cpp/
)

add_library(
    png STATIC

    ../../Code/pngget.c
    ../../Code/pngread.c
    ../../Code/pngrutil.c
    ../../Code/pngtrans.c
    ../../Code/pngwtran.c
    ../../Code/png.c
    ../../Code/pngmem.c
    ../../Code/pngrio.c
    ../../Code/pngset.c
    ../../Code/pngwio.c
    ../../Code/pngwutil.c
    ../../Code/pngerror.c
    ../../Code/pngpread.c
    ../../Code/pngrtran.c
    ../../Code/pngwrite.c
)

set_target_properties(
    png
    PROPERTIES
    ARCHIVE_OUTPUT_DIRECTORY
    "${CMAKE_CURRENT_SOURCE_DIR}/${ANDROID_ABI}"
)

target_link_libraries(
    png
    z
)

add_library(
    native-lib SHARED
    src/main/cpp/native-lib.cpp
)

target_link_libraries(
    native-lib
    png
)
```

`ThirdPartyBuild/PNG/Android/app/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 25
    buildToolsVersion "25.0.3"
    defaultConfig {
        applicationId "com.Mojoc.LibPNG"
        minSdkVersion 18
        targetSdkVersion 25
        versionCode 1
        versionName "1.0"
        externalNativeBuild {
            ndk {
                abiFilters 'armeabi-v7a', 'arm64-v8a', 'armeabi', 'x86'
            }
            externalNativeBuild {
                cmake {
                    arguments '-DANDROID_TOOLCHAIN=clang', '-DANDROID_STL=system'
                    cFlags '-std=c99', '-DPNG_ARM_NEON_OPT=0'
                }
            }
        }
    }
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
        debug {
            minifyEnabled true
        }
    }
    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }
}

dependencies {
    compile fileTree(include: ['*.jar'], dir: 'libs')
    androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', {
        exclude group: 'com.android.support', module: 'support-annotations'
    })
    testCompile 'junit:junit:4.12'
}

```

`ThirdPartyBuild/PNG/Android/app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in /Users/scottcgi/Program/android-sdk/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# Add any project specific keep options here:

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

```

`ThirdPartyBuild/PNG/Android/app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="com.Mojoc.LibPNG">

</manifest>
```

`ThirdPartyBuild/PNG/Android/build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:2.3.3'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

`ThirdPartyBuild/PNG/Android/gradle.properties`:

```properties
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

```

`ThirdPartyBuild/PNG/Android/settings.gradle`:

```gradle
include ':app'

```

`ThirdPartyBuild/PNG/Code/libpng1.6.28.txt`:

```txt
libpng version 1.6.28
```

`ThirdPartyBuild/PNG/Code/png.c`:

```c

/* png.c - location for general purpose libpng functions
 *
 * Last changed in libpng 1.6.28 [January 5, 2017]
 * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

#include "pngpriv.h"

/* Generate a compiler error if there is an old png.h in the search path. */
typedef png_libpng_version_1_6_28 Your_png_h_is_not_version_1_6_28;

/* Tells libpng that we have already handled the first "num_bytes" bytes
 * of the PNG file signature.  If the PNG data is embedded into another
 * stream we can set num_bytes = 8 so that libpng will not attempt to read
 * or write any of the magic bytes before it starts on the IHDR.
 */

#ifdef PNG_READ_SUPPORTED
void PNGAPI
png_set_sig_bytes(png_structrp png_ptr, int num_bytes)
{
   unsigned int nb = (unsigned int)num_bytes;

   png_debug(1, "in png_set_sig_bytes");

   if (png_ptr == NULL)
      return;

   if (num_bytes < 0)
      nb = 0;

   if (nb > 8)
      png_error(png_ptr, "Too many bytes for PNG signature");

   png_ptr->sig_bytes = (png_byte)nb;
}

/* Checks whether the supplied bytes match the PNG signature.  We allow
 * checking less than the full 8-byte signature so that those apps that
 * already read the first few bytes of a file to determine the file type
 * can simply check the remaining bytes for extra assurance.  Returns
 * an integer less than, equal to, or greater than zero if sig is found,
 * respectively, to be less than, to match, or be greater than the correct
 * PNG signature (this is the same behavior as strcmp, memcmp, etc).
 */
int PNGAPI
png_sig_cmp(png_const_bytep sig, png_size_t start, png_size_t num_to_check)
{
   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};

   if (num_to_check > 8)
      num_to_check = 8;

   else if (num_to_check < 1)
      return (-1);

   if (start > 7)
      return (-1);

   if (start + num_to_check > 8)
      num_to_check = 8 - start;

   return ((int)(memcmp(&sig[start], &png_signature[start], num_to_check)));
}

#endif /* READ */

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
/* Function to allocate memory for zlib */
PNG_FUNCTION(voidpf /* PRIVATE */,
png_zalloc,(voidpf png_ptr, uInt items, uInt size),PNG_ALLOCATED)
{
   png_alloc_size_t num_bytes = size;

   if (png_ptr == NULL)
      return NULL;

   if (items >= (~(png_alloc_size_t)0)/size)
   {
      png_warning (png_voidcast(png_structrp, png_ptr),
          "Potential overflow in png_zalloc()");
      return NULL;
   }

   num_bytes *= items;
   return png_malloc_warn(png_voidcast(png_structrp, png_ptr), num_bytes);
}

/* Function to free memory for zlib */
void /* PRIVATE */
png_zfree(voidpf png_ptr, voidpf ptr)
{
   png_free(png_voidcast(png_const_structrp,png_ptr), ptr);
}

/* Reset the CRC variable to 32 bits of 1's.  Care must be taken
 * in case CRC is > 32 bits to leave the top bits 0.
 */
void /* PRIVATE */
png_reset_crc(png_structrp png_ptr)
{
   /* The cast is safe because the crc is a 32-bit value. */
   png_ptr->crc = (png_uint_32)crc32(0, Z_NULL, 0);
}

/* Calculate the CRC over a section of data.  We can only pass as
 * much data to this routine as the largest single buffer size.  We
 * also check that this data will actually be used before going to the
 * trouble of calculating it.
 */
void /* PRIVATE */
png_calculate_crc(png_structrp png_ptr, png_const_bytep ptr, png_size_t length)
{
   int need_crc = 1;

   if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)
   {
      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
         need_crc = 0;
   }

   else /* critical */
   {
      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)
         need_crc = 0;
   }

   /* 'uLong' is defined in zlib.h as unsigned long; this means that on some
    * systems it is a 64-bit value.  crc32, however, returns 32 bits so the
    * following cast is safe.  'uInt' may be no more than 16 bits, so it is
    * necessary to perform a loop here.
    */
   if (need_crc != 0 && length > 0)
   {
      uLong crc = png_ptr->crc; /* Should never issue a warning */

      do
      {
         uInt safe_length = (uInt)length;
#ifndef __COVERITY__
         if (safe_length == 0)
            safe_length = (uInt)-1; /* evil, but safe */
#endif

         crc = crc32(crc, ptr, safe_length);

         /* The following should never issue compiler warnings; if they do the
          * target system has characteristics that will probably violate other
          * assumptions within the libpng code.
          */
         ptr += safe_length;
         length -= safe_length;
      }
      while (length > 0);

      /* And the following is always safe because the crc is only 32 bits. */
      png_ptr->crc = (png_uint_32)crc;
   }
}

/* Check a user supplied version number, called from both read and write
 * functions that create a png_struct.
 */
int
png_user_version_check(png_structrp png_ptr, png_const_charp user_png_ver)
{
   /* Libpng versions 1.0.0 and later are binary compatible if the version
    * string matches through the second '.'; we must recompile any
    * applications that use any older library version.
    */

   if (user_png_ver != NULL)
   {
      int i = -1;
      int found_dots = 0;

      do
      {
         i++;
         if (user_png_ver[i] != PNG_LIBPNG_VER_STRING[i])
            png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
         if (user_png_ver[i] == '.')
            found_dots++;
      } while (found_dots < 2 && user_png_ver[i] != 0 &&
            PNG_LIBPNG_VER_STRING[i] != 0);
   }

   else
      png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;

   if ((png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH) != 0)
   {
#ifdef PNG_WARNINGS_SUPPORTED
      size_t pos = 0;
      char m[128];

      pos = png_safecat(m, (sizeof m), pos,
          "Application built with libpng-");
      pos = png_safecat(m, (sizeof m), pos, user_png_ver);
      pos = png_safecat(m, (sizeof m), pos, " but running with ");
      pos = png_safecat(m, (sizeof m), pos, PNG_LIBPNG_VER_STRING);
      PNG_UNUSED(pos)

      png_warning(png_ptr, m);
#endif

#ifdef PNG_ERROR_NUMBERS_SUPPORTED
      png_ptr->flags = 0;
#endif

      return 0;
   }

   /* Success return. */
   return 1;
}

/* Generic function to create a png_struct for either read or write - this
 * contains the common initialization.
 */
PNG_FUNCTION(png_structp /* PRIVATE */,
png_create_png_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
    png_malloc_ptr malloc_fn, png_free_ptr free_fn),PNG_ALLOCATED)
{
   png_struct create_struct;
#  ifdef PNG_SETJMP_SUPPORTED
      jmp_buf create_jmp_buf;
#  endif

   /* This temporary stack-allocated structure is used to provide a place to
    * build enough context to allow the user provided memory allocator (if any)
    * to be called.
    */
   memset(&create_struct, 0, (sizeof create_struct));

   /* Added at libpng-1.2.6 */
#  ifdef PNG_USER_LIMITS_SUPPORTED
      create_struct.user_width_max = PNG_USER_WIDTH_MAX;
      create_struct.user_height_max = PNG_USER_HEIGHT_MAX;

#     ifdef PNG_USER_CHUNK_CACHE_MAX
      /* Added at libpng-1.2.43 and 1.4.0 */
      create_struct.user_chunk_cache_max = PNG_USER_CHUNK_CACHE_MAX;
#     endif

#     ifdef PNG_USER_CHUNK_MALLOC_MAX
      /* Added at libpng-1.2.43 and 1.4.1, required only for read but exists
       * in png_struct regardless.
       */
      create_struct.user_chunk_malloc_max = PNG_USER_CHUNK_MALLOC_MAX;
#     endif
#  endif

   /* The following two API calls simply set fields in png_struct, so it is safe
    * to do them now even though error handling is not yet set up.
    */
#  ifdef PNG_USER_MEM_SUPPORTED
      png_set_mem_fn(&create_struct, mem_ptr, malloc_fn, free_fn);
#  else
      PNG_UNUSED(mem_ptr)
      PNG_UNUSED(malloc_fn)
      PNG_UNUSED(free_fn)
#  endif

   /* (*error_fn) can return control to the caller after the error_ptr is set,
    * this will result in a memory leak unless the error_fn does something
    * extremely sophisticated.  The design lacks merit but is implicit in the
    * API.
    */
   png_set_error_fn(&create_struct, error_ptr, error_fn, warn_fn);

#  ifdef PNG_SETJMP_SUPPORTED
      if (!setjmp(create_jmp_buf))
#  endif
      {
#  ifdef PNG_SETJMP_SUPPORTED
         /* Temporarily fake out the longjmp information until we have
          * successfully completed this function.  This only works if we have
          * setjmp() support compiled in, but it is safe - this stuff should
          * never happen.
          */
         create_struct.jmp_buf_ptr = &create_jmp_buf;
         create_struct.jmp_buf_size = 0; /*stack allocation*/
         create_struct.longjmp_fn = longjmp;
#  endif
         /* Call the general version checker (shared with read and write code):
          */
         if (png_user_version_check(&create_struct, user_png_ver) != 0)
         {
            png_structrp png_ptr = png_voidcast(png_structrp,
                png_malloc_warn(&create_struct, (sizeof *png_ptr)));

            if (png_ptr != NULL)
            {
               /* png_ptr->zstream holds a back-pointer to the png_struct, so
                * this can only be done now:
                */
               create_struct.zstream.zalloc = png_zalloc;
               create_struct.zstream.zfree = png_zfree;
               create_struct.zstream.opaque = png_ptr;

#              ifdef PNG_SETJMP_SUPPORTED
               /* Eliminate the local error handling: */
               create_struct.jmp_buf_ptr = NULL;
               create_struct.jmp_buf_size = 0;
               create_struct.longjmp_fn = 0;
#              endif

               *png_ptr = create_struct;

               /* This is the successful return point */
               return png_ptr;
            }
         }
      }

   /* A longjmp because of a bug in the application storage allocator or a
    * simple failure to allocate the png_struct.
    */
   return NULL;
}

/* Allocate the memory for an info_struct for the application. */
PNG_FUNCTION(png_infop,PNGAPI
png_create_info_struct,(png_const_structrp png_ptr),PNG_ALLOCATED)
{
   png_inforp info_ptr;

   png_debug(1, "in png_create_info_struct");

   if (png_ptr == NULL)
      return NULL;

   /* Use the internal API that does not (or at least should not) error out, so
    * that this call always returns ok.  The application typically sets up the
    * error handling *after* creating the info_struct because this is the way it
    * has always been done in 'example.c'.
    */
   info_ptr = png_voidcast(png_inforp, png_malloc_base(png_ptr,
       (sizeof *info_ptr)));

   if (info_ptr != NULL)
      memset(info_ptr, 0, (sizeof *info_ptr));

   return info_ptr;
}

/* This function frees the memory associated with a single info struct.
 * Normally, one would use either png_destroy_read_struct() or
 * png_destroy_write_struct() to free an info struct, but this may be
 * useful for some applications.  From libpng 1.6.0 this function is also used
 * internally to implement the png_info release part of the 'struct' destroy
 * APIs.  This ensures that all possible approaches free the same data (all of
 * it).
 */
void PNGAPI
png_destroy_info_struct(png_const_structrp png_ptr, png_infopp info_ptr_ptr)
{
   png_inforp info_ptr = NULL;

   png_debug(1, "in png_destroy_info_struct");

   if (png_ptr == NULL)
      return;

   if (info_ptr_ptr != NULL)
      info_ptr = *info_ptr_ptr;

   if (info_ptr != NULL)
   {
      /* Do this first in case of an error below; if the app implements its own
       * memory management this can lead to png_free calling png_error, which
       * will abort this routine and return control to the app error handler.
       * An infinite loop may result if it then tries to free the same info
       * ptr.
       */
      *info_ptr_ptr = NULL;

      png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);
      memset(info_ptr, 0, (sizeof *info_ptr));
      png_free(png_ptr, info_ptr);
   }
}

/* Initialize the info structure.  This is now an internal function (0.89)
 * and applications using it are urged to use png_create_info_struct()
 * instead.  Use deprecated in 1.6.0, internal use removed (used internally it
 * is just a memset).
 *
 * NOTE: it is almost inconceivable that this API is used because it bypasses
 * the user-memory mechanism and the user error handling/warning mechanisms in
 * those cases where it does anything other than a memset.
 */
PNG_FUNCTION(void,PNGAPI
png_info_init_3,(png_infopp ptr_ptr, png_size_t png_info_struct_size),
    PNG_DEPRECATED)
{
   png_inforp info_ptr = *ptr_ptr;

   png_debug(1, "in png_info_init_3");

   if (info_ptr == NULL)
      return;

   if ((sizeof (png_info)) > png_info_struct_size)
   {
      *ptr_ptr = NULL;
      /* The following line is why this API should not be used: */
      free(info_ptr);
      info_ptr = png_voidcast(png_inforp, png_malloc_base(NULL,
          (sizeof *info_ptr)));
      if (info_ptr == NULL)
         return;
      *ptr_ptr = info_ptr;
   }

   /* Set everything to 0 */
   memset(info_ptr, 0, (sizeof *info_ptr));
}

/* The following API is not called internally */
void PNGAPI
png_data_freer(png_const_structrp png_ptr, png_inforp info_ptr,
    int freer, png_uint_32 mask)
{
   png_debug(1, "in png_data_freer");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (freer == PNG_DESTROY_WILL_FREE_DATA)
      info_ptr->free_me |= mask;

   else if (freer == PNG_USER_WILL_FREE_DATA)
      info_ptr->free_me &= ~mask;

   else
      png_error(png_ptr, "Unknown freer parameter in png_data_freer");
}

void PNGAPI
png_free_data(png_const_structrp png_ptr, png_inforp info_ptr, png_uint_32 mask,
    int num)
{
   png_debug(1, "in png_free_data");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

#ifdef PNG_TEXT_SUPPORTED
   /* Free text item num or (if num == -1) all text items */
   if (info_ptr->text != NULL &&
       ((mask & PNG_FREE_TEXT) & info_ptr->free_me) != 0)
   {
      if (num != -1)
      {
         png_free(png_ptr, info_ptr->text[num].key);
         info_ptr->text[num].key = NULL;
      }

      else
      {
         int i;

         for (i = 0; i < info_ptr->num_text; i++)
            png_free(png_ptr, info_ptr->text[i].key);

         png_free(png_ptr, info_ptr->text);
         info_ptr->text = NULL;
         info_ptr->num_text = 0;
         info_ptr->max_text = 0;
      }
   }
#endif

#ifdef PNG_tRNS_SUPPORTED
   /* Free any tRNS entry */
   if (((mask & PNG_FREE_TRNS) & info_ptr->free_me) != 0)
   {
      info_ptr->valid &= ~PNG_INFO_tRNS;
      png_free(png_ptr, info_ptr->trans_alpha);
      info_ptr->trans_alpha = NULL;
      info_ptr->num_trans = 0;
   }
#endif

#ifdef PNG_sCAL_SUPPORTED
   /* Free any sCAL entry */
   if (((mask & PNG_FREE_SCAL) & info_ptr->free_me) != 0)
   {
      png_free(png_ptr, info_ptr->scal_s_width);
      png_free(png_ptr, info_ptr->scal_s_height);
      info_ptr->scal_s_width = NULL;
      info_ptr->scal_s_height = NULL;
      info_ptr->valid &= ~PNG_INFO_sCAL;
   }
#endif

#ifdef PNG_pCAL_SUPPORTED
   /* Free any pCAL entry */
   if (((mask & PNG_FREE_PCAL) & info_ptr->free_me) != 0)
   {
      png_free(png_ptr, info_ptr->pcal_purpose);
      png_free(png_ptr, info_ptr->pcal_units);
      info_ptr->pcal_purpose = NULL;
      info_ptr->pcal_units = NULL;

      if (info_ptr->pcal_params != NULL)
         {
            int i;

            for (i = 0; i < info_ptr->pcal_nparams; i++)
               png_free(png_ptr, info_ptr->pcal_params[i]);

            png_free(png_ptr, info_ptr->pcal_params);
            info_ptr->pcal_params = NULL;
         }
      info_ptr->valid &= ~PNG_INFO_pCAL;
   }
#endif

#ifdef PNG_iCCP_SUPPORTED
   /* Free any profile entry */
   if (((mask & PNG_FREE_ICCP) & info_ptr->free_me) != 0)
   {
      png_free(png_ptr, info_ptr->iccp_name);
      png_free(png_ptr, info_ptr->iccp_profile);
      info_ptr->iccp_name = NULL;
      info_ptr->iccp_profile = NULL;
      info_ptr->valid &= ~PNG_INFO_iCCP;
   }
#endif

#ifdef PNG_sPLT_SUPPORTED
   /* Free a given sPLT entry, or (if num == -1) all sPLT entries */
   if (info_ptr->splt_palettes != NULL &&
       ((mask & PNG_FREE_SPLT) & info_ptr->free_me) != 0)
   {
      if (num != -1)
      {
         png_free(png_ptr, info_ptr->splt_palettes[num].name);
         png_free(png_ptr, info_ptr->splt_palettes[num].entries);
         info_ptr->splt_palettes[num].name = NULL;
         info_ptr->splt_palettes[num].entries = NULL;
      }

      else
      {
         int i;

         for (i = 0; i < info_ptr->splt_palettes_num; i++)
         {
            png_free(png_ptr, info_ptr->splt_palettes[i].name);
            png_free(png_ptr, info_ptr->splt_palettes[i].entries);
         }

         png_free(png_ptr, info_ptr->splt_palettes);
         info_ptr->splt_palettes = NULL;
         info_ptr->splt_palettes_num = 0;
         info_ptr->valid &= ~PNG_INFO_sPLT;
      }
   }
#endif

#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
   if (info_ptr->unknown_chunks != NULL &&
       ((mask & PNG_FREE_UNKN) & info_ptr->free_me) != 0)
   {
      if (num != -1)
      {
          png_free(png_ptr, info_ptr->unknown_chunks[num].data);
          info_ptr->unknown_chunks[num].data = NULL;
      }

      else
      {
         int i;

         for (i = 0; i < info_ptr->unknown_chunks_num; i++)
            png_free(png_ptr, info_ptr->unknown_chunks[i].data);

         png_free(png_ptr, info_ptr->unknown_chunks);
         info_ptr->unknown_chunks = NULL;
         info_ptr->unknown_chunks_num = 0;
      }
   }
#endif

#ifdef PNG_hIST_SUPPORTED
   /* Free any hIST entry */
   if (((mask & PNG_FREE_HIST) & info_ptr->free_me) != 0)
   {
      png_free(png_ptr, info_ptr->hist);
      info_ptr->hist = NULL;
      info_ptr->valid &= ~PNG_INFO_hIST;
   }
#endif

   /* Free any PLTE entry that was internally allocated */
   if (((mask & PNG_FREE_PLTE) & info_ptr->free_me) != 0)
   {
      png_free(png_ptr, info_ptr->palette);
      info_ptr->palette = NULL;
      info_ptr->valid &= ~PNG_INFO_PLTE;
      info_ptr->num_palette = 0;
   }

#ifdef PNG_INFO_IMAGE_SUPPORTED
   /* Free any image bits attached to the info structure */
   if (((mask & PNG_FREE_ROWS) & info_ptr->free_me) != 0)
   {
      if (info_ptr->row_pointers != NULL)
      {
         png_uint_32 row;
         for (row = 0; row < info_ptr->height; row++)
            png_free(png_ptr, info_ptr->row_pointers[row]);

         png_free(png_ptr, info_ptr->row_pointers);
         info_ptr->row_pointers = NULL;
      }
      info_ptr->valid &= ~PNG_INFO_IDAT;
   }
#endif

   if (num != -1)
      mask &= ~PNG_FREE_MUL;

   info_ptr->free_me &= ~mask;
}
#endif /* READ || WRITE */

/* This function returns a pointer to the io_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy() or png_read_destroy() are called.
 */
png_voidp PNGAPI
png_get_io_ptr(png_const_structrp png_ptr)
{
   if (png_ptr == NULL)
      return (NULL);

   return (png_ptr->io_ptr);
}

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
#  ifdef PNG_STDIO_SUPPORTED
/* Initialize the default input/output functions for the PNG file.  If you
 * use your own read or write routines, you can call either png_set_read_fn()
 * or png_set_write_fn() instead of png_init_io().  If you have defined
 * PNG_NO_STDIO or otherwise disabled PNG_STDIO_SUPPORTED, you must use a
 * function of your own because "FILE *" isn't necessarily available.
 */
void PNGAPI
png_init_io(png_structrp png_ptr, png_FILE_p fp)
{
   png_debug(1, "in png_init_io");

   if (png_ptr == NULL)
      return;

   png_ptr->io_ptr = (png_voidp)fp;
}
#  endif

#  ifdef PNG_SAVE_INT_32_SUPPORTED
/* PNG signed integers are saved in 32-bit 2's complement format.  ANSI C-90
 * defines a cast of a signed integer to an unsigned integer either to preserve
 * the value, if it is positive, or to calculate:
 *
 *     (UNSIGNED_MAX+1) + integer
 *
 * Where UNSIGNED_MAX is the appropriate maximum unsigned value, so when the
 * negative integral value is added the result will be an unsigned value
 * correspnding to the 2's complement representation.
 */
void PNGAPI
png_save_int_32(png_bytep buf, png_int_32 i)
{
   png_save_uint_32(buf, (png_uint_32)i);
}
#  endif

#  ifdef PNG_TIME_RFC1123_SUPPORTED
/* Convert the supplied time into an RFC 1123 string suitable for use in
 * a "Creation Time" or other text-based time string.
 */
int PNGAPI
png_convert_to_rfc1123_buffer(char out[29], png_const_timep ptime)
{
   static PNG_CONST char short_months[12][4] =
        {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

   if (out == NULL)
      return 0;

   if (ptime->year > 9999 /* RFC1123 limitation */ ||
       ptime->month == 0    ||  ptime->month > 12  ||
       ptime->day   == 0    ||  ptime->day   > 31  ||
       ptime->hour  > 23    ||  ptime->minute > 59 ||
       ptime->second > 60)
      return 0;

   {
      size_t pos = 0;
      char number_buf[5]; /* enough for a four-digit year */

#     define APPEND_STRING(string) pos = png_safecat(out, 29, pos, (string))
#     define APPEND_NUMBER(format, value)\
         APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))
#     define APPEND(ch) if (pos < 28) out[pos++] = (ch)

      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, (unsigned)ptime->day);
      APPEND(' ');
      APPEND_STRING(short_months[(ptime->month - 1)]);
      APPEND(' ');
      APPEND_NUMBER(PNG_NUMBER_FORMAT_u, ptime->year);
      APPEND(' ');
      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->hour);
      APPEND(':');
      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->minute);
      APPEND(':');
      APPEND_NUMBER(PNG_NUMBER_FORMAT_02u, (unsigned)ptime->second);
      APPEND_STRING(" +0000"); /* This reliably terminates the buffer */
      PNG_UNUSED (pos)

#     undef APPEND
#     undef APPEND_NUMBER
#     undef APPEND_STRING
   }

   return 1;
}

#    if PNG_LIBPNG_VER < 10700
/* To do: remove the following from libpng-1.7 */
/* Original API that uses a private buffer in png_struct.
 * Deprecated because it causes png_struct to carry a spurious temporary
 * buffer (png_struct::time_buffer), better to have the caller pass this in.
 */
png_const_charp PNGAPI
png_convert_to_rfc1123(png_structrp png_ptr, png_const_timep ptime)
{
   if (png_ptr != NULL)
   {
      /* The only failure above if png_ptr != NULL is from an invalid ptime */
      if (png_convert_to_rfc1123_buffer(png_ptr->time_buffer, ptime) == 0)
         png_warning(png_ptr, "Ignoring invalid time value");

      else
         return png_ptr->time_buffer;
   }

   return NULL;
}
#    endif /* LIBPNG_VER < 10700 */
#  endif /* TIME_RFC1123 */

#endif /* READ || WRITE */

png_const_charp PNGAPI
png_get_copyright(png_const_structrp png_ptr)
{
   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
#ifdef PNG_STRING_COPYRIGHT
   return PNG_STRING_COPYRIGHT
#else
#  ifdef __STDC__
   return PNG_STRING_NEWLINE \
      "libpng version 1.6.28 - January 5, 2017" PNG_STRING_NEWLINE \
      "Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson" \
      PNG_STRING_NEWLINE \
      "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
      "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
      PNG_STRING_NEWLINE;
#  else
   return "libpng version 1.6.28 - January 5, 2017\
      Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson\
      Copyright (c) 1996-1997 Andreas Dilger\
      Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.";
#  endif
#endif
}

/* The following return the library version as a short string in the
 * format 1.0.0 through 99.99.99zz.  To get the version of *.h files
 * used with your application, print out PNG_LIBPNG_VER_STRING, which
 * is defined in png.h.
 * Note: now there is no difference between png_get_libpng_ver() and
 * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,
 * it is guaranteed that png.c uses the correct version of png.h.
 */
png_const_charp PNGAPI
png_get_libpng_ver(png_const_structrp png_ptr)
{
   /* Version of *.c files used when building libpng */
   return png_get_header_ver(png_ptr);
}

png_const_charp PNGAPI
png_get_header_ver(png_const_structrp png_ptr)
{
   /* Version of *.h files used when building libpng */
   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
   return PNG_LIBPNG_VER_STRING;
}

png_const_charp PNGAPI
png_get_header_version(png_const_structrp png_ptr)
{
   /* Returns longer string containing both version and date */
   PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
#ifdef __STDC__
   return PNG_HEADER_VERSION_STRING
#  ifndef PNG_READ_SUPPORTED
      " (NO READ SUPPORT)"
#  endif
      PNG_STRING_NEWLINE;
#else
   return PNG_HEADER_VERSION_STRING;
#endif
}

#ifdef PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
/* NOTE: this routine is not used internally! */
/* Build a grayscale palette.  Palette is assumed to be 1 << bit_depth
 * large of png_color.  This lets grayscale images be treated as
 * paletted.  Most useful for gamma correction and simplification
 * of code.  This API is not used internally.
 */
void PNGAPI
png_build_grayscale_palette(int bit_depth, png_colorp palette)
{
   int num_palette;
   int color_inc;
   int i;
   int v;

   png_debug(1, "in png_do_build_grayscale_palette");

   if (palette == NULL)
      return;

   switch (bit_depth)
   {
      case 1:
         num_palette = 2;
         color_inc = 0xff;
         break;

      case 2:
         num_palette = 4;
         color_inc = 0x55;
         break;

      case 4:
         num_palette = 16;
         color_inc = 0x11;
         break;

      case 8:
         num_palette = 256;
         color_inc = 1;
         break;

      default:
         num_palette = 0;
         color_inc = 0;
         break;
   }

   for (i = 0, v = 0; i < num_palette; i++, v += color_inc)
   {
      palette[i].red = (png_byte)(v & 0xff);
      palette[i].green = (png_byte)(v & 0xff);
      palette[i].blue = (png_byte)(v & 0xff);
   }
}
#endif

#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
int PNGAPI
png_handle_as_unknown(png_const_structrp png_ptr, png_const_bytep chunk_name)
{
   /* Check chunk_name and return "keep" value if it's on the list, else 0 */
   png_const_bytep p, p_end;

   if (png_ptr == NULL || chunk_name == NULL || png_ptr->num_chunk_list == 0)
      return PNG_HANDLE_CHUNK_AS_DEFAULT;

   p_end = png_ptr->chunk_list;
   p = p_end + png_ptr->num_chunk_list*5; /* beyond end */

   /* The code is the fifth byte after each four byte string.  Historically this
    * code was always searched from the end of the list, this is no longer
    * necessary because the 'set' routine handles duplicate entries correcty.
    */
   do /* num_chunk_list > 0, so at least one */
   {
      p -= 5;

      if (memcmp(chunk_name, p, 4) == 0)
         return p[4];
   }
   while (p > p_end);

   /* This means that known chunks should be processed and unknown chunks should
    * be handled according to the value of png_ptr->unknown_default; this can be
    * confusing because, as a result, there are two levels of defaulting for
    * unknown chunks.
    */
   return PNG_HANDLE_CHUNK_AS_DEFAULT;
}

#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED) ||\
   defined(PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
int /* PRIVATE */
png_chunk_unknown_handling(png_const_structrp png_ptr, png_uint_32 chunk_name)
{
   png_byte chunk_string[5];

   PNG_CSTRING_FROM_CHUNK(chunk_string, chunk_name);
   return png_handle_as_unknown(png_ptr, chunk_string);
}
#endif /* READ_UNKNOWN_CHUNKS || HANDLE_AS_UNKNOWN */
#endif /* SET_UNKNOWN_CHUNKS */

#ifdef PNG_READ_SUPPORTED
/* This function, added to libpng-1.0.6g, is untested. */
int PNGAPI
png_reset_zstream(png_structrp png_ptr)
{
   if (png_ptr == NULL)
      return Z_STREAM_ERROR;

   /* WARNING: this resets the window bits to the maximum! */
   return (inflateReset(&png_ptr->zstream));
}
#endif /* READ */

/* This function was added to libpng-1.0.7 */
png_uint_32 PNGAPI
png_access_version_number(void)
{
   /* Version of *.c files used when building libpng */
   return((png_uint_32)PNG_LIBPNG_VER);
}

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
/* Ensure that png_ptr->zstream.msg holds some appropriate error message string.
 * If it doesn't 'ret' is used to set it to something appropriate, even in cases
 * like Z_OK or Z_STREAM_END where the error code is apparently a success code.
 */
void /* PRIVATE */
png_zstream_error(png_structrp png_ptr, int ret)
{
   /* Translate 'ret' into an appropriate error string, priority is given to the
    * one in zstream if set.  This always returns a string, even in cases like
    * Z_OK or Z_STREAM_END where the error code is a success code.
    */
   if (png_ptr->zstream.msg == NULL) switch (ret)
   {
      default:
      case Z_OK:
         png_ptr->zstream.msg = PNGZ_MSG_CAST("unexpected zlib return code");
         break;

      case Z_STREAM_END:
         /* Normal exit */
         png_ptr->zstream.msg = PNGZ_MSG_CAST("unexpected end of LZ stream");
         break;

      case Z_NEED_DICT:
         /* This means the deflate stream did not have a dictionary; this
          * indicates a bogus PNG.
          */
         png_ptr->zstream.msg = PNGZ_MSG_CAST("missing LZ dictionary");
         break;

      case Z_ERRNO:
         /* gz APIs only: should not happen */
         png_ptr->zstream.msg = PNGZ_MSG_CAST("zlib IO error");
         break;

      case Z_STREAM_ERROR:
         /* internal libpng error */
         png_ptr->zstream.msg = PNGZ_MSG_CAST("bad parameters to zlib");
         break;

      case Z_DATA_ERROR:
         png_ptr->zstream.msg = PNGZ_MSG_CAST("damaged LZ stream");
         break;

      case Z_MEM_ERROR:
         png_ptr->zstream.msg = PNGZ_MSG_CAST("insufficient memory");
         break;

      case Z_BUF_ERROR:
         /* End of input or output; not a problem if the caller is doing
          * incremental read or write.
          */
         png_ptr->zstream.msg = PNGZ_MSG_CAST("truncated");
         break;

      case Z_VERSION_ERROR:
         png_ptr->zstream.msg = PNGZ_MSG_CAST("unsupported zlib version");
         break;

      case PNG_UNEXPECTED_ZLIB_RETURN:
         /* Compile errors here mean that zlib now uses the value co-opted in
          * pngpriv.h for PNG_UNEXPECTED_ZLIB_RETURN; update the switch above
          * and change pngpriv.h.  Note that this message is "... return",
          * whereas the default/Z_OK one is "... return code".
          */
         png_ptr->zstream.msg = PNGZ_MSG_CAST("unexpected zlib return");
         break;
   }
}

/* png_convert_size: a PNGAPI but no longer in png.h, so deleted
 * at libpng 1.5.5!
 */

/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) */
#ifdef PNG_GAMMA_SUPPORTED /* always set if COLORSPACE */
static int
png_colorspace_check_gamma(png_const_structrp png_ptr,
    png_colorspacerp colorspace, png_fixed_point gAMA, int from)
   /* This is called to check a new gamma value against an existing one.  The
    * routine returns false if the new gamma value should not be written.
    *
    * 'from' says where the new gamma value comes from:
    *
    *    0: the new gamma value is the libpng estimate for an ICC profile
    *    1: the new gamma value comes from a gAMA chunk
    *    2: the new gamma value comes from an sRGB chunk
    */
{
   png_fixed_point gtest;

   if ((colorspace->flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&
       (png_muldiv(&gtest, colorspace->gamma, PNG_FP_1, gAMA) == 0  ||
      png_gamma_significant(gtest) != 0))
   {
      /* Either this is an sRGB image, in which case the calculated gamma
       * approximation should match, or this is an image with a profile and the
       * value libpng calculates for the gamma of the profile does not match the
       * value recorded in the file.  The former, sRGB, case is an error, the
       * latter is just a warning.
       */
      if ((colorspace->flags & PNG_COLORSPACE_FROM_sRGB) != 0 || from == 2)
      {
         png_chunk_report(png_ptr, "gamma value does not match sRGB",
             PNG_CHUNK_ERROR);
         /* Do not overwrite an sRGB value */
         return from == 2;
      }

      else /* sRGB tag not involved */
      {
         png_chunk_report(png_ptr, "gamma value does not match libpng estimate",
             PNG_CHUNK_WARNING);
         return from == 1;
      }
   }

   return 1;
}

void /* PRIVATE */
png_colorspace_set_gamma(png_const_structrp png_ptr,
    png_colorspacerp colorspace, png_fixed_point gAMA)
{
   /* Changed in libpng-1.5.4 to limit the values to ensure overflow can't
    * occur.  Since the fixed point representation is asymetrical it is
    * possible for 1/gamma to overflow the limit of 21474 and this means the
    * gamma value must be at least 5/100000 and hence at most 20000.0.  For
    * safety the limits here are a little narrower.  The values are 0.00016 to
    * 6250.0, which are truly ridiculous gamma values (and will produce
    * displays that are all black or all white.)
    *
    * In 1.6.0 this test replaces the ones in pngrutil.c, in the gAMA chunk
    * handling code, which only required the value to be >0.
    */
   png_const_charp errmsg;

   if (gAMA < 16 || gAMA > 625000000)
      errmsg = "gamma value out of range";

#  ifdef PNG_READ_gAMA_SUPPORTED
   /* Allow the application to set the gamma value more than once */
   else if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&
      (colorspace->flags & PNG_COLORSPACE_FROM_gAMA) != 0)
      errmsg = "duplicate";
#  endif

   /* Do nothing if the colorspace is already invalid */
   else if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)
      return;

   else
   {
      if (png_colorspace_check_gamma(png_ptr, colorspace, gAMA,
          1/*from gAMA*/) != 0)
      {
         /* Store this gamma value. */
         colorspace->gamma = gAMA;
         colorspace->flags |=
            (PNG_COLORSPACE_HAVE_GAMMA | PNG_COLORSPACE_FROM_gAMA);
      }

      /* At present if the check_gamma test fails the gamma of the colorspace is
       * not updated however the colorspace is not invalidated.  This
       * corresponds to the case where the existing gamma comes from an sRGB
       * chunk or profile.  An error message has already been output.
       */
      return;
   }

   /* Error exit - errmsg has been set. */
   colorspace->flags |= PNG_COLORSPACE_INVALID;
   png_chunk_report(png_ptr, errmsg, PNG_CHUNK_WRITE_ERROR);
}

void /* PRIVATE */
png_colorspace_sync_info(png_const_structrp png_ptr, png_inforp info_ptr)
{
   if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)
   {
      /* Everything is invalid */
      info_ptr->valid &= ~(PNG_INFO_gAMA|PNG_INFO_cHRM|PNG_INFO_sRGB|
         PNG_INFO_iCCP);

#     ifdef PNG_COLORSPACE_SUPPORTED
      /* Clean up the iCCP profile now if it won't be used. */
      png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, -1/*not used*/);
#     else
      PNG_UNUSED(png_ptr)
#     endif
   }

   else
   {
#     ifdef PNG_COLORSPACE_SUPPORTED
      /* Leave the INFO_iCCP flag set if the pngset.c code has already set
       * it; this allows a PNG to contain a profile which matches sRGB and
       * yet still have that profile retrievable by the application.
       */
      if ((info_ptr->colorspace.flags & PNG_COLORSPACE_MATCHES_sRGB) != 0)
         info_ptr->valid |= PNG_INFO_sRGB;

      else
         info_ptr->valid &= ~PNG_INFO_sRGB;

      if ((info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)
         info_ptr->valid |= PNG_INFO_cHRM;

      else
         info_ptr->valid &= ~PNG_INFO_cHRM;
#     endif

      if ((info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) != 0)
         info_ptr->valid |= PNG_INFO_gAMA;

      else
         info_ptr->valid &= ~PNG_INFO_gAMA;
   }
}

#ifdef PNG_READ_SUPPORTED
void /* PRIVATE */
png_colorspace_sync(png_const_structrp png_ptr, png_inforp info_ptr)
{
   if (info_ptr == NULL) /* reduce code size; check here not in the caller */
      return;

   info_ptr->colorspace = png_ptr->colorspace;
   png_colorspace_sync_info(png_ptr, info_ptr);
}
#endif
#endif /* GAMMA */

#ifdef PNG_COLORSPACE_SUPPORTED
/* Added at libpng-1.5.5 to support read and write of true CIEXYZ values for
 * cHRM, as opposed to using chromaticities.  These internal APIs return
 * non-zero on a parameter error.  The X, Y and Z values are required to be
 * positive and less than 1.0.
 */
static int
png_xy_from_XYZ(png_xy *xy, const png_XYZ *XYZ)
{
   png_int_32 d, dwhite, whiteX, whiteY;

   d = XYZ->red_X + XYZ->red_Y + XYZ->red_Z;
   if (png_muldiv(&xy->redx, XYZ->red_X, PNG_FP_1, d) == 0)
      return 1;
   if (png_muldiv(&xy->redy, XYZ->red_Y, PNG_FP_1, d) == 0)
      return 1;
   dwhite = d;
   whiteX = XYZ->red_X;
   whiteY = XYZ->red_Y;

   d = XYZ->green_X + XYZ->green_Y + XYZ->green_Z;
   if (png_muldiv(&xy->greenx, XYZ->green_X, PNG_FP_1, d) == 0)
      return 1;
   if (png_muldiv(&xy->greeny, XYZ->green_Y, PNG_FP_1, d) == 0)
      return 1;
   dwhite += d;
   whiteX += XYZ->green_X;
   whiteY += XYZ->green_Y;

   d = XYZ->blue_X + XYZ->blue_Y + XYZ->blue_Z;
   if (png_muldiv(&xy->bluex, XYZ->blue_X, PNG_FP_1, d) == 0)
      return 1;
   if (png_muldiv(&xy->bluey, XYZ->blue_Y, PNG_FP_1, d) == 0)
      return 1;
   dwhite += d;
   whiteX += XYZ->blue_X;
   whiteY += XYZ->blue_Y;

   /* The reference white is simply the sum of the end-point (X,Y,Z) vectors,
    * thus:
    */
   if (png_muldiv(&xy->whitex, whiteX, PNG_FP_1, dwhite) == 0)
      return 1;
   if (png_muldiv(&xy->whitey, whiteY, PNG_FP_1, dwhite) == 0)
      return 1;

   return 0;
}

static int
png_XYZ_from_xy(png_XYZ *XYZ, const png_xy *xy)
{
   png_fixed_point red_inverse, green_inverse, blue_scale;
   png_fixed_point left, right, denominator;

   /* Check xy and, implicitly, z.  Note that wide gamut color spaces typically
    * have end points with 0 tristimulus values (these are impossible end
    * points, but they are used to cover the possible colors).  We check
    * xy->whitey against 5, not 0, to avoid a possible integer overflow.
    */
   if (xy->redx   < 0 || xy->redx > PNG_FP_1) return 1;
   if (xy->redy   < 0 || xy->redy > PNG_FP_1-xy->redx) return 1;
   if (xy->greenx < 0 || xy->greenx > PNG_FP_1) return 1;
   if (xy->greeny < 0 || xy->greeny > PNG_FP_1-xy->greenx) return 1;
   if (xy->bluex  < 0 || xy->bluex > PNG_FP_1) return 1;
   if (xy->bluey  < 0 || xy->bluey > PNG_FP_1-xy->bluex) return 1;
   if (xy->whitex < 0 || xy->whitex > PNG_FP_1) return 1;
   if (xy->whitey < 5 || xy->whitey > PNG_FP_1-xy->whitex) return 1;

   /* The reverse calculation is more difficult because the original tristimulus
    * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8
    * derived values were recorded in the cHRM chunk;
    * (red,green,blue,white)x(x,y).  This loses one degree of freedom and
    * therefore an arbitrary ninth value has to be introduced to undo the
    * original transformations.
    *
    * Think of the original end-points as points in (X,Y,Z) space.  The
    * chromaticity values (c) have the property:
    *
    *           C
    *   c = ---------
    *       X + Y + Z
    *
    * For each c (x,y,z) from the corresponding original C (X,Y,Z).  Thus the
    * three chromaticity values (x,y,z) for each end-point obey the
    * relationship:
    *
    *   x + y + z = 1
    *
    * This describes the plane in (X,Y,Z) space that intersects each axis at the
    * value 1.0; call this the chromaticity plane.  Thus the chromaticity
    * calculation has scaled each end-point so that it is on the x+y+z=1 plane
    * and chromaticity is the intersection of the vector from the origin to the
    * (X,Y,Z) value with the chromaticity plane.
    *
    * To fully invert the chromaticity calculation we would need the three
    * end-point scale factors, (red-scale, green-scale, blue-scale), but these
    * were not recorded.  Instead we calculated the reference white (X,Y,Z) and
    * recorded the chromaticity of this.  The reference white (X,Y,Z) would have
    * given all three of the scale factors since:
    *
    *    color-C = color-c * color-scale
    *    white-C = red-C + green-C + blue-C
    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale
    *
    * But cHRM records only white-x and white-y, so we have lost the white scale
    * factor:
    *
    *    white-C = white-c*white-scale
    *
    * To handle this the inverse transformation makes an arbitrary assumption
    * about white-scale:
    *
    *    Assume: white-Y = 1.0
    *    Hence:  white-scale = 1/white-y
    *    Or:     red-Y + green-Y + blue-Y = 1.0
    *
    * Notice the last statement of the assumption gives an equation in three of
    * the nine values we want to calculate.  8 more equations come from the
    * above routine as summarised at the top above (the chromaticity
    * calculation):
    *
    *    Given: color-x = color-X / (color-X + color-Y + color-Z)
    *    Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0
    *
    * This is 9 simultaneous equations in the 9 variables "color-C" and can be
    * solved by Cramer's rule.  Cramer's rule requires calculating 10 9x9 matrix
    * determinants, however this is not as bad as it seems because only 28 of
    * the total of 90 terms in the various matrices are non-zero.  Nevertheless
    * Cramer's rule is notoriously numerically unstable because the determinant
    * calculation involves the difference of large, but similar, numbers.  It is
    * difficult to be sure that the calculation is stable for real world values
    * and it is certain that it becomes unstable where the end points are close
    * together.
    *
    * So this code uses the perhaps slightly less optimal but more
    * understandable and totally obvious approach of calculating color-scale.
    *
    * This algorithm depends on the precision in white-scale and that is
    * (1/white-y), so we can immediately see that as white-y approaches 0 the
    * accuracy inherent in the cHRM chunk drops off substantially.
    *
    * libpng arithmetic: a simple inversion of the above equations
    * ------------------------------------------------------------
    *
    *    white_scale = 1/white-y
    *    white-X = white-x * white-scale
    *    white-Y = 1.0
    *    white-Z = (1 - white-x - white-y) * white_scale
    *
    *    white-C = red-C + green-C + blue-C
    *            = red-c*red-scale + green-c*green-scale + blue-c*blue-scale
    *
    * This gives us three equations in (red-scale,green-scale,blue-scale) where
    * all the coefficients are now known:
    *
    *    red-x*red-scale + green-x*green-scale + blue-x*blue-scale
    *       = white-x/white-y
    *    red-y*red-scale + green-y*green-scale + blue-y*blue-scale = 1
    *    red-z*red-scale + green-z*green-scale + blue-z*blue-scale
    *       = (1 - white-x - white-y)/white-y
    *
    * In the last equation color-z is (1 - color-x - color-y) so we can add all
    * three equations together to get an alternative third:
    *
    *    red-scale + green-scale + blue-scale = 1/white-y = white-scale
    *
    * So now we have a Cramer's rule solution where the determinants are just
    * 3x3 - far more tractible.  Unfortunately 3x3 determinants still involve
    * multiplication of three coefficients so we can't guarantee to avoid
    * overflow in the libpng fixed point representation.  Using Cramer's rule in
    * floating point is probably a good choice here, but it's not an option for
    * fixed point.  Instead proceed to simplify the first two equations by
    * eliminating what is likely to be the largest value, blue-scale:
    *
    *    blue-scale = white-scale - red-scale - green-scale
    *
    * Hence:
    *
    *    (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =
    *                (white-x - blue-x)*white-scale
    *
    *    (red-y - blue-y)*red-scale + (green-y - blue-y)*green-scale =
    *                1 - blue-y*white-scale
    *
    * And now we can trivially solve for (red-scale,green-scale):
    *
    *    green-scale =
    *                (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale
    *                -----------------------------------------------------------
    *                                  green-x - blue-x
    *
    *    red-scale =
    *                1 - blue-y*white-scale - (green-y - blue-y) * green-scale
    *                ---------------------------------------------------------
    *                                  red-y - blue-y
    *
    * Hence:
    *
    *    red-scale =
    *          ( (green-x - blue-x) * (white-y - blue-y) -
    *            (green-y - blue-y) * (white-x - blue-x) ) / white-y
    * -------------------------------------------------------------------------
    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)
    *
    *    green-scale =
    *          ( (red-y - blue-y) * (white-x - blue-x) -
    *            (red-x - blue-x) * (white-y - blue-y) ) / white-y
    * -------------------------------------------------------------------------
    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)
    *
    * Accuracy:
    * The input values have 5 decimal digits of accuracy.  The values are all in
    * the range 0 < value < 1, so simple products are in the same range but may
    * need up to 10 decimal digits to preserve the original precision and avoid
    * underflow.  Because we are using a 32-bit signed representation we cannot
    * match this; the best is a little over 9 decimal digits, less than 10.
    *
    * The approach used here is to preserve the maximum precision within the
    * signed representation.  Because the red-scale calculation above uses the
    * difference between two products of values that must be in the range -1..+1
    * it is sufficient to divide the product by 7; ceil(100,000/32767*2).  The
    * factor is irrelevant in the calculation because it is applied to both
    * numerator and denominator.
    *
    * Note that the values of the differences of the products of the
    * chromaticities in the above equations tend to be small, for example for
    * the sRGB chromaticities they are:
    *
    * red numerator:    -0.04751
    * green numerator:  -0.08788
    * denominator:      -0.2241 (without white-y multiplication)
    *
    *  The resultant Y coefficients from the chromaticities of some widely used
    *  color space definitions are (to 15 decimal places):
    *
    *  sRGB
    *    0.212639005871510 0.715168678767756 0.072192315360734
    *  Kodak ProPhoto
    *    0.288071128229293 0.711843217810102 0.000085653960605
    *  Adobe RGB
    *    0.297344975250536 0.627363566255466 0.075291458493998
    *  Adobe Wide Gamut RGB
    *    0.258728243040113 0.724682314948566 0.016589442011321
    */
   /* By the argument, above overflow should be impossible here. The return
    * value of 2 indicates an internal error to the caller.
    */
   if (png_muldiv(&left, xy->greenx-xy->bluex, xy->redy - xy->bluey, 7) == 0)
      return 2;
   if (png_muldiv(&right, xy->greeny-xy->bluey, xy->redx - xy->bluex, 7) == 0)
      return 2;
   denominator = left - right;

   /* Now find the red numerator. */
   if (png_muldiv(&left, xy->greenx-xy->bluex, xy->whitey-xy->bluey, 7) == 0)
      return 2;
   if (png_muldiv(&right, xy->greeny-xy->bluey, xy->whitex-xy->bluex, 7) == 0)
      return 2;

   /* Overflow is possible here and it indicates an extreme set of PNG cHRM
    * chunk values.  This calculation actually returns the reciprocal of the
    * scale value because this allows us to delay the multiplication of white-y
    * into the denominator, which tends to produce a small number.
    */
   if (png_muldiv(&red_inverse, xy->whitey, denominator, left-right) == 0 ||
       red_inverse <= xy->whitey /* r+g+b scales = white scale */)
      return 1;

   /* Similarly for green_inverse: */
   if (png_muldiv(&left, xy->redy-xy->bluey, xy->whitex-xy->bluex, 7) == 0)
      return 2;
   if (png_muldiv(&right, xy->redx-xy->bluex, xy->whitey-xy->bluey, 7) == 0)
      return 2;
   if (png_muldiv(&green_inverse, xy->whitey, denominator, left-right) == 0 ||
       green_inverse <= xy->whitey)
      return 1;

   /* And the blue scale, the checks above guarantee this can't overflow but it
    * can still produce 0 for extreme cHRM values.
    */
   blue_scale = png_reciprocal(xy->whitey) - png_reciprocal(red_inverse) -
       png_reciprocal(green_inverse);
   if (blue_scale <= 0)
      return 1;


   /* And fill in the png_XYZ: */
   if (png_muldiv(&XYZ->red_X, xy->redx, PNG_FP_1, red_inverse) == 0)
      return 1;
   if (png_muldiv(&XYZ->red_Y, xy->redy, PNG_FP_1, red_inverse) == 0)
      return 1;
   if (png_muldiv(&XYZ->red_Z, PNG_FP_1 - xy->redx - xy->redy, PNG_FP_1,
       red_inverse) == 0)
      return 1;

   if (png_muldiv(&XYZ->green_X, xy->greenx, PNG_FP_1, green_inverse) == 0)
      return 1;
   if (png_muldiv(&XYZ->green_Y, xy->greeny, PNG_FP_1, green_inverse) == 0)
      return 1;
   if (png_muldiv(&XYZ->green_Z, PNG_FP_1 - xy->greenx - xy->greeny, PNG_FP_1,
       green_inverse) == 0)
      return 1;

   if (png_muldiv(&XYZ->blue_X, xy->bluex, blue_scale, PNG_FP_1) == 0)
      return 1;
   if (png_muldiv(&XYZ->blue_Y, xy->bluey, blue_scale, PNG_FP_1) == 0)
      return 1;
   if (png_muldiv(&XYZ->blue_Z, PNG_FP_1 - xy->bluex - xy->bluey, blue_scale,
       PNG_FP_1) == 0)
      return 1;

   return 0; /*success*/
}

static int
png_XYZ_normalize(png_XYZ *XYZ)
{
   png_int_32 Y;

   if (XYZ->red_Y < 0 || XYZ->green_Y < 0 || XYZ->blue_Y < 0 ||
      XYZ->red_X < 0 || XYZ->green_X < 0 || XYZ->blue_X < 0 ||
      XYZ->red_Z < 0 || XYZ->green_Z < 0 || XYZ->blue_Z < 0)
      return 1;

   /* Normalize by scaling so the sum of the end-point Y values is PNG_FP_1.
    * IMPLEMENTATION NOTE: ANSI requires signed overflow not to occur, therefore
    * relying on addition of two positive values producing a negative one is not
    * safe.
    */
   Y = XYZ->red_Y;
   if (0x7fffffff - Y < XYZ->green_X)
      return 1;
   Y += XYZ->green_Y;
   if (0x7fffffff - Y < XYZ->blue_X)
      return 1;
   Y += XYZ->blue_Y;

   if (Y != PNG_FP_1)
   {
      if (png_muldiv(&XYZ->red_X, XYZ->red_X, PNG_FP_1, Y) == 0)
         return 1;
      if (png_muldiv(&XYZ->red_Y, XYZ->red_Y, PNG_FP_1, Y) == 0)
         return 1;
      if (png_muldiv(&XYZ->red_Z, XYZ->red_Z, PNG_FP_1, Y) == 0)
         return 1;

      if (png_muldiv(&XYZ->green_X, XYZ->green_X, PNG_FP_1, Y) == 0)
         return 1;
      if (png_muldiv(&XYZ->green_Y, XYZ->green_Y, PNG_FP_1, Y) == 0)
         return 1;
      if (png_muldiv(&XYZ->green_Z, XYZ->green_Z, PNG_FP_1, Y) == 0)
         return 1;

      if (png_muldiv(&XYZ->blue_X, XYZ->blue_X, PNG_FP_1, Y) == 0)
         return 1;
      if (png_muldiv(&XYZ->blue_Y, XYZ->blue_Y, PNG_FP_1, Y) == 0)
         return 1;
      if (png_muldiv(&XYZ->blue_Z, XYZ->blue_Z, PNG_FP_1, Y) == 0)
         return 1;
   }

   return 0;
}

static int
png_colorspace_endpoints_match(const png_xy *xy1, const png_xy *xy2, int delta)
{
   /* Allow an error of +/-0.01 (absolute value) on each chromaticity */
   if (PNG_OUT_OF_RANGE(xy1->whitex, xy2->whitex,delta) ||
       PNG_OUT_OF_RANGE(xy1->whitey, xy2->whitey,delta) ||
       PNG_OUT_OF_RANGE(xy1->redx,   xy2->redx,  delta) ||
       PNG_OUT_OF_RANGE(xy1->redy,   xy2->redy,  delta) ||
       PNG_OUT_OF_RANGE(xy1->greenx, xy2->greenx,delta) ||
       PNG_OUT_OF_RANGE(xy1->greeny, xy2->greeny,delta) ||
       PNG_OUT_OF_RANGE(xy1->bluex,  xy2->bluex, delta) ||
       PNG_OUT_OF_RANGE(xy1->bluey,  xy2->bluey, delta))
      return 0;
   return 1;
}

/* Added in libpng-1.6.0, a different check for the validity of a set of cHRM
 * chunk chromaticities.  Earlier checks used to simply look for the overflow
 * condition (where the determinant of the matrix to solve for XYZ ends up zero
 * because the chromaticity values are not all distinct.)  Despite this it is
 * theoretically possible to produce chromaticities that are apparently valid
 * but that rapidly degrade to invalid, potentially crashing, sets because of
 * arithmetic inaccuracies when calculations are performed on them.  The new
 * check is to round-trip xy -> XYZ -> xy and then check that the result is
 * within a small percentage of the original.
 */
static int
png_colorspace_check_xy(png_XYZ *XYZ, const png_xy *xy)
{
   int result;
   png_xy xy_test;

   /* As a side-effect this routine also returns the XYZ endpoints. */
   result = png_XYZ_from_xy(XYZ, xy);
   if (result != 0)
      return result;

   result = png_xy_from_XYZ(&xy_test, XYZ);
   if (result != 0)
      return result;

   if (png_colorspace_endpoints_match(xy, &xy_test,
       5/*actually, the math is pretty accurate*/) != 0)
      return 0;

   /* Too much slip */
   return 1;
}

/* This is the check going the other way.  The XYZ is modified to normalize it
 * (another side-effect) and the xy chromaticities are returned.
 */
static int
png_colorspace_check_XYZ(png_xy *xy, png_XYZ *XYZ)
{
   int result;
   png_XYZ XYZtemp;

   result = png_XYZ_normalize(XYZ);
   if (result != 0)
      return result;

   result = png_xy_from_XYZ(xy, XYZ);
   if (result != 0)
      return result;

   XYZtemp = *XYZ;
   return png_colorspace_check_xy(&XYZtemp, xy);
}

/* Used to check for an endpoint match against sRGB */
static const png_xy sRGB_xy = /* From ITU-R BT.709-3 */
{
   /* color      x       y */
   /* red   */ 64000, 33000,
   /* green */ 30000, 60000,
   /* blue  */ 15000,  6000,
   /* white */ 31270, 32900
};

static int
png_colorspace_set_xy_and_XYZ(png_const_structrp png_ptr,
    png_colorspacerp colorspace, const png_xy *xy, const png_XYZ *XYZ,
    int preferred)
{
   if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)
      return 0;

   /* The consistency check is performed on the chromaticities; this factors out
    * variations because of the normalization (or not) of the end point Y
    * values.
    */
   if (preferred < 2 &&
       (colorspace->flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)
   {
      /* The end points must be reasonably close to any we already have.  The
       * following allows an error of up to +/-.001
       */
      if (png_colorspace_endpoints_match(xy, &colorspace->end_points_xy,
          100) == 0)
      {
         colorspace->flags |= PNG_COLORSPACE_INVALID;
         png_benign_error(png_ptr, "inconsistent chromaticities");
         return 0; /* failed */
      }

      /* Only overwrite with preferred values */
      if (preferred == 0)
         return 1; /* ok, but no change */
   }

   colorspace->end_points_xy = *xy;
   colorspace->end_points_XYZ = *XYZ;
   colorspace->flags |= PNG_COLORSPACE_HAVE_ENDPOINTS;

   /* The end points are normally quoted to two decimal digits, so allow +/-0.01
    * on this test.
    */
   if (png_colorspace_endpoints_match(xy, &sRGB_xy, 1000) != 0)
      colorspace->flags |= PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB;

   else
      colorspace->flags &= PNG_COLORSPACE_CANCEL(
         PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB);

   return 2; /* ok and changed */
}

int /* PRIVATE */
png_colorspace_set_chromaticities(png_const_structrp png_ptr,
    png_colorspacerp colorspace, const png_xy *xy, int preferred)
{
   /* We must check the end points to ensure they are reasonable - in the past
    * color management systems have crashed as a result of getting bogus
    * colorant values, while this isn't the fault of libpng it is the
    * responsibility of libpng because PNG carries the bomb and libpng is in a
    * position to protect against it.
    */
   png_XYZ XYZ;

   switch (png_colorspace_check_xy(&XYZ, xy))
   {
      case 0: /* success */
         return png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, xy, &XYZ,
             preferred);

      case 1:
         /* We can't invert the chromaticities so we can't produce value XYZ
          * values.  Likely as not a color management system will fail too.
          */
         colorspace->flags |= PNG_COLORSPACE_INVALID;
         png_benign_error(png_ptr, "invalid chromaticities");
         break;

      default:
         /* libpng is broken; this should be a warning but if it happens we
          * want error reports so for the moment it is an error.
          */
         colorspace->flags |= PNG_COLORSPACE_INVALID;
         png_error(png_ptr, "internal error checking chromaticities");
   }

   return 0; /* failed */
}

int /* PRIVATE */
png_colorspace_set_endpoints(png_const_structrp png_ptr,
    png_colorspacerp colorspace, const png_XYZ *XYZ_in, int preferred)
{
   png_XYZ XYZ = *XYZ_in;
   png_xy xy;

   switch (png_colorspace_check_XYZ(&xy, &XYZ))
   {
      case 0:
         return png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, &xy, &XYZ,
             preferred);

      case 1:
         /* End points are invalid. */
         colorspace->flags |= PNG_COLORSPACE_INVALID;
         png_benign_error(png_ptr, "invalid end points");
         break;

      default:
         colorspace->flags |= PNG_COLORSPACE_INVALID;
         png_error(png_ptr, "internal error checking chromaticities");
   }

   return 0; /* failed */
}

#if defined(PNG_sRGB_SUPPORTED) || defined(PNG_iCCP_SUPPORTED)
/* Error message generation */
static char
png_icc_tag_char(png_uint_32 byte)
{
   byte &= 0xff;
   if (byte >= 32 && byte <= 126)
      return (char)byte;
   else
      return '?';
}

static void
png_icc_tag_name(char *name, png_uint_32 tag)
{
   name[0] = '\'';
   name[1] = png_icc_tag_char(tag >> 24);
   name[2] = png_icc_tag_char(tag >> 16);
   name[3] = png_icc_tag_char(tag >>  8);
   name[4] = png_icc_tag_char(tag      );
   name[5] = '\'';
}

static int
is_ICC_signature_char(png_alloc_size_t it)
{
   return it == 32 || (it >= 48 && it <= 57) || (it >= 65 && it <= 90) ||
      (it >= 97 && it <= 122);
}

static int
is_ICC_signature(png_alloc_size_t it)
{
   return is_ICC_signature_char(it >> 24) /* checks all the top bits */ &&
      is_ICC_signature_char((it >> 16) & 0xff) &&
      is_ICC_signature_char((it >> 8) & 0xff) &&
      is_ICC_signature_char(it & 0xff);
}

static int
png_icc_profile_error(png_const_structrp png_ptr, png_colorspacerp colorspace,
    png_const_charp name, png_alloc_size_t value, png_const_charp reason)
{
   size_t pos;
   char message[196]; /* see below for calculation */

   if (colorspace != NULL)
      colorspace->flags |= PNG_COLORSPACE_INVALID;

   pos = png_safecat(message, (sizeof message), 0, "profile '"); /* 9 chars */
   pos = png_safecat(message, pos+79, pos, name); /* Truncate to 79 chars */
   pos = png_safecat(message, (sizeof message), pos, "': "); /* +2 = 90 */
   if (is_ICC_signature(value) != 0)
   {
      /* So 'value' is at most 4 bytes and the following cast is safe */
      png_icc_tag_name(message+pos, (png_uint_32)value);
      pos += 6; /* total +8; less than the else clause */
      message[pos++] = ':';
      message[pos++] = ' ';
   }
#  ifdef PNG_WARNINGS_SUPPORTED
   else
      {
         char number[PNG_NUMBER_BUFFER_SIZE]; /* +24 = 114*/

         pos = png_safecat(message, (sizeof message), pos,
             png_format_number(number, number+(sizeof number),
             PNG_NUMBER_FORMAT_x, value));
         pos = png_safecat(message, (sizeof message), pos, "h: "); /*+2 = 116*/
      }
#  endif
   /* The 'reason' is an arbitrary message, allow +79 maximum 195 */
   pos = png_safecat(message, (sizeof message), pos, reason);
   PNG_UNUSED(pos)

   /* This is recoverable, but make it unconditionally an app_error on write to
    * avoid writing invalid ICC profiles into PNG files (i.e., we handle them
    * on read, with a warning, but on write unless the app turns off
    * application errors the PNG won't be written.)
    */
   png_chunk_report(png_ptr, message,
       (colorspace != NULL) ? PNG_CHUNK_ERROR : PNG_CHUNK_WRITE_ERROR);

   return 0;
}
#endif /* sRGB || iCCP */

#ifdef PNG_sRGB_SUPPORTED
int /* PRIVATE */
png_colorspace_set_sRGB(png_const_structrp png_ptr, png_colorspacerp colorspace,
    int intent)
{
   /* sRGB sets known gamma, end points and (from the chunk) intent. */
   /* IMPORTANT: these are not necessarily the values found in an ICC profile
    * because ICC profiles store values adapted to a D50 environment; it is
    * expected that the ICC profile mediaWhitePointTag will be D50; see the
    * checks and code elsewhere to understand this better.
    *
    * These XYZ values, which are accurate to 5dp, produce rgb to gray
    * coefficients of (6968,23435,2366), which are reduced (because they add up
    * to 32769 not 32768) to (6968,23434,2366).  These are the values that
    * libpng has traditionally used (and are the best values given the 15bit
    * algorithm used by the rgb to gray code.)
    */
   static const png_XYZ sRGB_XYZ = /* D65 XYZ (*not* the D50 adapted values!) */
   {
      /* color      X      Y      Z */
      /* red   */ 41239, 21264,  1933,
      /* green */ 35758, 71517, 11919,
      /* blue  */ 18048,  7219, 95053
   };

   /* Do nothing if the colorspace is already invalidated. */
   if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)
      return 0;

   /* Check the intent, then check for existing settings.  It is valid for the
    * PNG file to have cHRM or gAMA chunks along with sRGB, but the values must
    * be consistent with the correct values.  If, however, this function is
    * called below because an iCCP chunk matches sRGB then it is quite
    * conceivable that an older app recorded incorrect gAMA and cHRM because of
    * an incorrect calculation based on the values in the profile - this does
    * *not* invalidate the profile (though it still produces an error, which can
    * be ignored.)
    */
   if (intent < 0 || intent >= PNG_sRGB_INTENT_LAST)
      return png_icc_profile_error(png_ptr, colorspace, "sRGB",
          (unsigned)intent, "invalid sRGB rendering intent");

   if ((colorspace->flags & PNG_COLORSPACE_HAVE_INTENT) != 0 &&
       colorspace->rendering_intent != intent)
      return png_icc_profile_error(png_ptr, colorspace, "sRGB",
         (unsigned)intent, "inconsistent rendering intents");

   if ((colorspace->flags & PNG_COLORSPACE_FROM_sRGB) != 0)
   {
      png_benign_error(png_ptr, "duplicate sRGB information ignored");
      return 0;
   }

   /* If the standard sRGB cHRM chunk does not match the one from the PNG file
    * warn but overwrite the value with the correct one.
    */
   if ((colorspace->flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0 &&
       !png_colorspace_endpoints_match(&sRGB_xy, &colorspace->end_points_xy,
       100))
      png_chunk_report(png_ptr, "cHRM chunk does not match sRGB",
         PNG_CHUNK_ERROR);

   /* This check is just done for the error reporting - the routine always
    * returns true when the 'from' argument corresponds to sRGB (2).
    */
   (void)png_colorspace_check_gamma(png_ptr, colorspace, PNG_GAMMA_sRGB_INVERSE,
       2/*from sRGB*/);

   /* intent: bugs in GCC force 'int' to be used as the parameter type. */
   colorspace->rendering_intent = (png_uint_16)intent;
   colorspace->flags |= PNG_COLORSPACE_HAVE_INTENT;

   /* endpoints */
   colorspace->end_points_xy = sRGB_xy;
   colorspace->end_points_XYZ = sRGB_XYZ;
   colorspace->flags |=
      (PNG_COLORSPACE_HAVE_ENDPOINTS|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB);

   /* gamma */
   colorspace->gamma = PNG_GAMMA_sRGB_INVERSE;
   colorspace->flags |= PNG_COLORSPACE_HAVE_GAMMA;

   /* Finally record that we have an sRGB profile */
   colorspace->flags |=
      (PNG_COLORSPACE_MATCHES_sRGB|PNG_COLORSPACE_FROM_sRGB);

   return 1; /* set */
}
#endif /* sRGB */

#ifdef PNG_iCCP_SUPPORTED
/* Encoded value of D50 as an ICC XYZNumber.  From the ICC 2010 spec the value
 * is XYZ(0.9642,1.0,0.8249), which scales to:
 *
 *    (63189.8112, 65536, 54060.6464)
 */
static const png_byte D50_nCIEXYZ[12] =
   { 0x00, 0x00, 0xf6, 0xd6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d };

static int /* bool */
icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,
    png_const_charp name, png_uint_32 profile_length)
{
   if (profile_length < 132)
      return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
          "too short");

   return 1;
}

#ifdef PNG_READ_iCCP_SUPPORTED
int /* PRIVATE */
png_icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,
    png_const_charp name, png_uint_32 profile_length)
{
   if (!icc_check_length(png_ptr, colorspace, name, profile_length))
      return 0;

   /* This needs to be here because the 'normal' check is in
    * png_decompress_chunk, yet this happens after the attempt to
    * png_malloc_base the required data.  We only need this on read; on write
    * the caller supplies the profile buffer so libpng doesn't allocate it.  See
    * the call to icc_check_length below (the write case).
    */
#  ifdef PNG_SET_USER_LIMITS_SUPPORTED
      else if (png_ptr->user_chunk_malloc_max > 0 &&
               png_ptr->user_chunk_malloc_max < profile_length)
         return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
             "exceeds application limits");
#  elif PNG_USER_CHUNK_MALLOC_MAX > 0
      else if (PNG_USER_CHUNK_MALLOC_MAX < profile_length)
         return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
             "exceeds libpng limits");
#  else /* !SET_USER_LIMITS */
      /* This will get compiled out on all 32-bit and better systems. */
      else if (PNG_SIZE_MAX < profile_length)
         return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
             "exceeds system limits");
#  endif /* !SET_USER_LIMITS */

   return 1;
}
#endif /* READ_iCCP */

int /* PRIVATE */
png_icc_check_header(png_const_structrp png_ptr, png_colorspacerp colorspace,
    png_const_charp name, png_uint_32 profile_length,
    png_const_bytep profile/* first 132 bytes only */, int color_type)
{
   png_uint_32 temp;

   /* Length check; this cannot be ignored in this code because profile_length
    * is used later to check the tag table, so even if the profile seems over
    * long profile_length from the caller must be correct.  The caller can fix
    * this up on read or write by just passing in the profile header length.
    */
   temp = png_get_uint_32(profile);
   if (temp != profile_length)
      return png_icc_profile_error(png_ptr, colorspace, name, temp,
          "length does not match profile");

   temp = (png_uint_32) (*(profile+8));
   if (temp > 3 && (profile_length & 3))
      return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
          "invalid length");

   temp = png_get_uint_32(profile+128); /* tag count: 12 bytes/tag */
   if (temp > 357913930 || /* (2^32-4-132)/12: maximum possible tag count */
      profile_length < 132+12*temp) /* truncated tag table */
      return png_icc_profile_error(png_ptr, colorspace, name, temp,
          "tag count too large");

   /* The 'intent' must be valid or we can't store it, ICC limits the intent to
    * 16 bits.
    */
   temp = png_get_uint_32(profile+64);
   if (temp >= 0xffff) /* The ICC limit */
      return png_icc_profile_error(png_ptr, colorspace, name, temp,
          "invalid rendering intent");

   /* This is just a warning because the profile may be valid in future
    * versions.
    */
   if (temp >= PNG_sRGB_INTENT_LAST)
      (void)png_icc_profile_error(png_ptr, NULL, name, temp,
          "intent outside defined range");

   /* At this point the tag table can't be checked because it hasn't necessarily
    * been loaded; however, various header fields can be checked.  These checks
    * are for values permitted by the PNG spec in an ICC profile; the PNG spec
    * restricts the profiles that can be passed in an iCCP chunk (they must be
    * appropriate to processing PNG data!)
    */

   /* Data checks (could be skipped).  These checks must be independent of the
    * version number; however, the version number doesn't accomodate changes in
    * the header fields (just the known tags and the interpretation of the
    * data.)
    */
   temp = png_get_uint_32(profile+36); /* signature 'ascp' */
   if (temp != 0x61637370)
      return png_icc_profile_error(png_ptr, colorspace, name, temp,
          "invalid signature");

   /* Currently the PCS illuminant/adopted white point (the computational
    * white point) are required to be D50,
    * however the profile contains a record of the illuminant so perhaps ICC
    * expects to be able to change this in the future (despite the rationale in
    * the introduction for using a fixed PCS adopted white.)  Consequently the
    * following is just a warning.
    */
   if (memcmp(profile+68, D50_nCIEXYZ, 12) != 0)
      (void)png_icc_profile_error(png_ptr, NULL, name, 0/*no tag value*/,
          "PCS illuminant is not D50");

   /* The PNG spec requires this:
    * "If the iCCP chunk is present, the image samples conform to the colour
    * space represented by the embedded ICC profile as defined by the
    * International Color Consortium [ICC]. The colour space of the ICC profile
    * shall be an RGB colour space for colour images (PNG colour types 2, 3, and
    * 6), or a greyscale colour space for greyscale images (PNG colour types 0
    * and 4)."
    *
    * This checking code ensures the embedded profile (on either read or write)
    * conforms to the specification requirements.  Notice that an ICC 'gray'
    * color-space profile contains the information to transform the monochrome
    * data to XYZ or L*a*b (according to which PCS the profile uses) and this
    * should be used in preference to the standard libpng K channel replication
    * into R, G and B channels.
    *
    * Previously it was suggested that an RGB profile on grayscale data could be
    * handled.  However it it is clear that using an RGB profile in this context
    * must be an error - there is no specification of what it means.  Thus it is
    * almost certainly more correct to ignore the profile.
    */
   temp = png_get_uint_32(profile+16); /* data colour space field */
   switch (temp)
   {
      case 0x52474220: /* 'RGB ' */
         if ((color_type & PNG_COLOR_MASK_COLOR) == 0)
            return png_icc_profile_error(png_ptr, colorspace, name, temp,
                "RGB color space not permitted on grayscale PNG");
         break;

      case 0x47524159: /* 'GRAY' */
         if ((color_type & PNG_COLOR_MASK_COLOR) != 0)
            return png_icc_profile_error(png_ptr, colorspace, name, temp,
                "Gray color space not permitted on RGB PNG");
         break;

      default:
         return png_icc_profile_error(png_ptr, colorspace, name, temp,
             "invalid ICC profile color space");
   }

   /* It is up to the application to check that the profile class matches the
    * application requirements; the spec provides no guidance, but it's pretty
    * weird if the profile is not scanner ('scnr'), monitor ('mntr'), printer
    * ('prtr') or 'spac' (for generic color spaces).  Issue a warning in these
    * cases.  Issue an error for device link or abstract profiles - these don't
    * contain the records necessary to transform the color-space to anything
    * other than the target device (and not even that for an abstract profile).
    * Profiles of these classes may not be embedded in images.
    */
   temp = png_get_uint_32(profile+12); /* profile/device class */
   switch (temp)
   {
      case 0x73636e72: /* 'scnr' */
      case 0x6d6e7472: /* 'mntr' */
      case 0x70727472: /* 'prtr' */
      case 0x73706163: /* 'spac' */
         /* All supported */
         break;

      case 0x61627374: /* 'abst' */
         /* May not be embedded in an image */
         return png_icc_profile_error(png_ptr, colorspace, name, temp,
             "invalid embedded Abstract ICC profile");

      case 0x6c696e6b: /* 'link' */
         /* DeviceLink profiles cannot be interpreted in a non-device specific
          * fashion, if an app uses the AToB0Tag in the profile the results are
          * undefined unless the result is sent to the intended device,
          * therefore a DeviceLink profile should not be found embedded in a
          * PNG.
          */
         return png_icc_profile_error(png_ptr, colorspace, name, temp,
             "unexpected DeviceLink ICC profile class");

      case 0x6e6d636c: /* 'nmcl' */
         /* A NamedColor profile is also device specific, however it doesn't
          * contain an AToB0 tag that is open to misinterpretation.  Almost
          * certainly it will fail the tests below.
          */
         (void)png_icc_profile_error(png_ptr, NULL, name, temp,
             "unexpected NamedColor ICC profile class");
         break;

      default:
         /* To allow for future enhancements to the profile accept unrecognized
          * profile classes with a warning, these then hit the test below on the
          * tag content to ensure they are backward compatible with one of the
          * understood profiles.
          */
         (void)png_icc_profile_error(png_ptr, NULL, name, temp,
             "unrecognized ICC profile class");
         break;
   }

   /* For any profile other than a device link one the PCS must be encoded
    * either in XYZ or Lab.
    */
   temp = png_get_uint_32(profile+20);
   switch (temp)
   {
      case 0x58595a20: /* 'XYZ ' */
      case 0x4c616220: /* 'Lab ' */
         break;

      default:
         return png_icc_profile_error(png_ptr, colorspace, name, temp,
             "unexpected ICC PCS encoding");
   }

   return 1;
}

int /* PRIVATE */
png_icc_check_tag_table(png_const_structrp png_ptr, png_colorspacerp colorspace,
    png_const_charp name, png_uint_32 profile_length,
    png_const_bytep profile /* header plus whole tag table */)
{
   png_uint_32 tag_count = png_get_uint_32(profile+128);
   png_uint_32 itag;
   png_const_bytep tag = profile+132; /* The first tag */

   /* First scan all the tags in the table and add bits to the icc_info value
    * (temporarily in 'tags').
    */
   for (itag=0; itag < tag_count; ++itag, tag += 12)
   {
      png_uint_32 tag_id = png_get_uint_32(tag+0);
      png_uint_32 tag_start = png_get_uint_32(tag+4); /* must be aligned */
      png_uint_32 tag_length = png_get_uint_32(tag+8);/* not padded */

      /* The ICC specification does not exclude zero length tags, therefore the
       * start might actually be anywhere if there is no data, but this would be
       * a clear abuse of the intent of the standard so the start is checked for
       * being in range.  All defined tag types have an 8 byte header - a 4 byte
       * type signature then 0.
       */
      if ((tag_start & 3) != 0)
      {
         /* CNHP730S.icc shipped with Microsoft Windows 64 violates this, it is
          * only a warning here because libpng does not care about the
          * alignment.
          */
         (void)png_icc_profile_error(png_ptr, NULL, name, tag_id,
             "ICC profile tag start not a multiple of 4");
      }

      /* This is a hard error; potentially it can cause read outside the
       * profile.
       */
      if (tag_start > profile_length || tag_length > profile_length - tag_start)
         return png_icc_profile_error(png_ptr, colorspace, name, tag_id,
             "ICC profile tag outside profile");
   }

   return 1; /* success, maybe with warnings */
}

#ifdef PNG_sRGB_SUPPORTED
#if PNG_sRGB_PROFILE_CHECKS >= 0
/* Information about the known ICC sRGB profiles */
static const struct
{
   png_uint_32 adler, crc, length;
   png_uint_32 md5[4];
   png_byte    have_md5;
   png_byte    is_broken;
   png_uint_16 intent;

#  define PNG_MD5(a,b,c,d) { a, b, c, d }, (a!=0)||(b!=0)||(c!=0)||(d!=0)
#  define PNG_ICC_CHECKSUM(adler, crc, md5, intent, broke, date, length, fname)\
      { adler, crc, length, md5, broke, intent },

} png_sRGB_checks[] =
{
   /* This data comes from contrib/tools/checksum-icc run on downloads of
    * all four ICC sRGB profiles from www.color.org.
    */
   /* adler32, crc32, MD5[4], intent, date, length, file-name */
   PNG_ICC_CHECKSUM(0x0a3fd9f6, 0x3b8772b9,
       PNG_MD5(0x29f83dde, 0xaff255ae, 0x7842fae4, 0xca83390d), 0, 0,
       "2009/03/27 21:36:31", 3048, "sRGB_IEC61966-2-1_black_scaled.icc")

   /* ICC sRGB v2 perceptual no black-compensation: */
   PNG_ICC_CHECKSUM(0x4909e5e1, 0x427ebb21,
       PNG_MD5(0xc95bd637, 0xe95d8a3b, 0x0df38f99, 0xc1320389), 1, 0,
       "2009/03/27 21:37:45", 3052, "sRGB_IEC61966-2-1_no_black_scaling.icc")

   PNG_ICC_CHECKSUM(0xfd2144a1, 0x306fd8ae,
       PNG_MD5(0xfc663378, 0x37e2886b, 0xfd72e983, 0x8228f1b8), 0, 0,
       "2009/08/10 17:28:01", 60988, "sRGB_v4_ICC_preference_displayclass.icc")

   /* ICC sRGB v4 perceptual */
   PNG_ICC_CHECKSUM(0x209c35d2, 0xbbef7812,
       PNG_MD5(0x34562abf, 0x994ccd06, 0x6d2c5721, 0xd0d68c5d), 0, 0,
       "2007/07/25 00:05:37", 60960, "sRGB_v4_ICC_preference.icc")

   /* The following profiles have no known MD5 checksum. If there is a match
    * on the (empty) MD5 the other fields are used to attempt a match and
    * a warning is produced.  The first two of these profiles have a 'cprt' tag
    * which suggests that they were also made by Hewlett Packard.
    */
   PNG_ICC_CHECKSUM(0xa054d762, 0x5d5129ce,
       PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 1, 0,
       "2004/07/21 18:57:42", 3024, "sRGB_IEC61966-2-1_noBPC.icc")

   /* This is a 'mntr' (display) profile with a mediaWhitePointTag that does not
    * match the D50 PCS illuminant in the header (it is in fact the D65 values,
    * so the white point is recorded as the un-adapted value.)  The profiles
    * below only differ in one byte - the intent - and are basically the same as
    * the previous profile except for the mediaWhitePointTag error and a missing
    * chromaticAdaptationTag.
    */
   PNG_ICC_CHECKSUM(0xf784f3fb, 0x182ea552,
       PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 0, 1/*broken*/,
       "1998/02/09 06:49:00", 3144, "HP-Microsoft sRGB v2 perceptual")

   PNG_ICC_CHECKSUM(0x0398f3fc, 0xf29e526d,
       PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 1, 1/*broken*/,
       "1998/02/09 06:49:00", 3144, "HP-Microsoft sRGB v2 media-relative")
};

static int
png_compare_ICC_profile_with_sRGB(png_const_structrp png_ptr,
    png_const_bytep profile, uLong adler)
{
   /* The quick check is to verify just the MD5 signature and trust the
    * rest of the data.  Because the profile has already been verified for
    * correctness this is safe.  png_colorspace_set_sRGB will check the 'intent'
    * field too, so if the profile has been edited with an intent not defined
    * by sRGB (but maybe defined by a later ICC specification) the read of
    * the profile will fail at that point.
    */

   png_uint_32 length = 0;
   png_uint_32 intent = 0x10000; /* invalid */
#if PNG_sRGB_PROFILE_CHECKS > 1
   uLong crc = 0; /* the value for 0 length data */
#endif
   unsigned int i;

#ifdef PNG_SET_OPTION_SUPPORTED
   /* First see if PNG_SKIP_sRGB_CHECK_PROFILE has been set to "on" */
   if (((png_ptr->options >> PNG_SKIP_sRGB_CHECK_PROFILE) & 3) ==
               PNG_OPTION_ON)
      return 0;
#endif

   for (i=0; i < (sizeof png_sRGB_checks) / (sizeof png_sRGB_checks[0]); ++i)
   {
      if (png_get_uint_32(profile+84) == png_sRGB_checks[i].md5[0] &&
         png_get_uint_32(profile+88) == png_sRGB_checks[i].md5[1] &&
         png_get_uint_32(profile+92) == png_sRGB_checks[i].md5[2] &&
         png_get_uint_32(profile+96) == png_sRGB_checks[i].md5[3])
      {
         /* This may be one of the old HP profiles without an MD5, in that
          * case we can only use the length and Adler32 (note that these
          * are not used by default if there is an MD5!)
          */
#        if PNG_sRGB_PROFILE_CHECKS == 0
            if (png_sRGB_checks[i].have_md5 != 0)
               return 1+png_sRGB_checks[i].is_broken;
#        endif

         /* Profile is unsigned or more checks have been configured in. */
         if (length == 0)
         {
            length = png_get_uint_32(profile);
            intent = png_get_uint_32(profile+64);
         }

         /* Length *and* intent must match */
         if (length == (png_uint_32) png_sRGB_checks[i].length &&
            intent == (png_uint_32) png_sRGB_checks[i].intent)
         {
            /* Now calculate the adler32 if not done already. */
            if (adler == 0)
            {
               adler = adler32(0, NULL, 0);
               adler = adler32(adler, profile, length);
            }

            if (adler == png_sRGB_checks[i].adler)
            {
               /* These basic checks suggest that the data has not been
                * modified, but if the check level is more than 1 perform
                * our own crc32 checksum on the data.
                */
#              if PNG_sRGB_PROFILE_CHECKS > 1
                  if (crc == 0)
                  {
                     crc = crc32(0, NULL, 0);
                     crc = crc32(crc, profile, length);
                  }

                  /* So this check must pass for the 'return' below to happen.
                   */
                  if (crc == png_sRGB_checks[i].crc)
#              endif
               {
                  if (png_sRGB_checks[i].is_broken != 0)
                  {
                     /* These profiles are known to have bad data that may cause
                      * problems if they are used, therefore attempt to
                      * discourage their use, skip the 'have_md5' warning below,
                      * which is made irrelevant by this error.
                      */
                     png_chunk_report(png_ptr, "known incorrect sRGB profile",
                         PNG_CHUNK_ERROR);
                  }

                  /* Warn that this being done; this isn't even an error since
                   * the profile is perfectly valid, but it would be nice if
                   * people used the up-to-date ones.
                   */
                  else if (png_sRGB_checks[i].have_md5 == 0)
                  {
                     png_chunk_report(png_ptr,
                         "out-of-date sRGB profile with no signature",
                         PNG_CHUNK_WARNING);
                  }

                  return 1+png_sRGB_checks[i].is_broken;
               }
            }

# if PNG_sRGB_PROFILE_CHECKS > 0
         /* The signature matched, but the profile had been changed in some
          * way.  This probably indicates a data error or uninformed hacking.
          * Fall through to "no match".
          */
         png_chunk_report(png_ptr,
             "Not recognizing known sRGB profile that has been edited",
             PNG_CHUNK_WARNING);
         break;
# endif
         }
      }
   }

   return 0; /* no match */
}

void /* PRIVATE */
png_icc_set_sRGB(png_const_structrp png_ptr,
    png_colorspacerp colorspace, png_const_bytep profile, uLong adler)
{
   /* Is this profile one of the known ICC sRGB profiles?  If it is, just set
    * the sRGB information.
    */
   if (png_compare_ICC_profile_with_sRGB(png_ptr, profile, adler) != 0)
      (void)png_colorspace_set_sRGB(png_ptr, colorspace,
         (int)/*already checked*/png_get_uint_32(profile+64));
}
#endif /* PNG_sRGB_PROFILE_CHECKS >= 0 */
#endif /* sRGB */

int /* PRIVATE */
png_colorspace_set_ICC(png_const_structrp png_ptr, png_colorspacerp colorspace,
    png_const_charp name, png_uint_32 profile_length, png_const_bytep profile,
    int color_type)
{
   if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)
      return 0;

   if (icc_check_length(png_ptr, colorspace, name, profile_length) != 0 &&
       png_icc_check_header(png_ptr, colorspace, name, profile_length, profile,
           color_type) != 0 &&
       png_icc_check_tag_table(png_ptr, colorspace, name, profile_length,
           profile) != 0)
   {
#     if defined(PNG_sRGB_SUPPORTED) && PNG_sRGB_PROFILE_CHECKS >= 0
         /* If no sRGB support, don't try storing sRGB information */
         png_icc_set_sRGB(png_ptr, colorspace, profile, 0);
#     endif
      return 1;
   }

   /* Failure case */
   return 0;
}
#endif /* iCCP */

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
void /* PRIVATE */
png_colorspace_set_rgb_coefficients(png_structrp png_ptr)
{
   /* Set the rgb_to_gray coefficients from the colorspace. */
   if (png_ptr->rgb_to_gray_coefficients_set == 0 &&
      (png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)
   {
      /* png_set_background has not been called, get the coefficients from the Y
       * values of the colorspace colorants.
       */
      png_fixed_point r = png_ptr->colorspace.end_points_XYZ.red_Y;
      png_fixed_point g = png_ptr->colorspace.end_points_XYZ.green_Y;
      png_fixed_point b = png_ptr->colorspace.end_points_XYZ.blue_Y;
      png_fixed_point total = r+g+b;

      if (total > 0 &&
         r >= 0 && png_muldiv(&r, r, 32768, total) && r >= 0 && r <= 32768 &&
         g >= 0 && png_muldiv(&g, g, 32768, total) && g >= 0 && g <= 32768 &&
         b >= 0 && png_muldiv(&b, b, 32768, total) && b >= 0 && b <= 32768 &&
         r+g+b <= 32769)
      {
         /* We allow 0 coefficients here.  r+g+b may be 32769 if two or
          * all of the coefficients were rounded up.  Handle this by
          * reducing the *largest* coefficient by 1; this matches the
          * approach used for the default coefficients in pngrtran.c
          */
         int add = 0;

         if (r+g+b > 32768)
            add = -1;
         else if (r+g+b < 32768)
            add = 1;

         if (add != 0)
         {
            if (g >= r && g >= b)
               g += add;
            else if (r >= g && r >= b)
               r += add;
            else
               b += add;
         }

         /* Check for an internal error. */
         if (r+g+b != 32768)
            png_error(png_ptr,
                "internal error handling cHRM coefficients");

         else
         {
            png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;
            png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;
         }
      }

      /* This is a png_error at present even though it could be ignored -
       * it should never happen, but it is important that if it does, the
       * bug is fixed.
       */
      else
         png_error(png_ptr, "internal error handling cHRM->XYZ");
   }
}
#endif /* READ_RGB_TO_GRAY */

#endif /* COLORSPACE */

#ifdef __GNUC__
/* This exists solely to work round a warning from GNU C. */
static int /* PRIVATE */
png_gt(size_t a, size_t b)
{
   return a > b;
}
#else
#   define png_gt(a,b) ((a) > (b))
#endif

void /* PRIVATE */
png_check_IHDR(png_const_structrp png_ptr,
    png_uint_32 width, png_uint_32 height, int bit_depth,
    int color_type, int interlace_type, int compression_type,
    int filter_type)
{
   int error = 0;

   /* Check for width and height valid values */
   if (width == 0)
   {
      png_warning(png_ptr, "Image width is zero in IHDR");
      error = 1;
   }

   if (width > PNG_UINT_31_MAX)
   {
      png_warning(png_ptr, "Invalid image width in IHDR");
      error = 1;
   }

   if (png_gt(((width + 7) & (~7U)),
       ((PNG_SIZE_MAX
           - 48        /* big_row_buf hack */
           - 1)        /* filter byte */
           / 8)        /* 8-byte RGBA pixels */
           - 1))       /* extra max_pixel_depth pad */
   {
      /* The size of the row must be within the limits of this architecture.
       * Because the read code can perform arbitrary transformations the
       * maximum size is checked here.  Because the code in png_read_start_row
       * adds extra space "for safety's sake" in several places a conservative
       * limit is used here.
       *
       * NOTE: it would be far better to check the size that is actually used,
       * but the effect in the real world is minor and the changes are more
       * extensive, therefore much more dangerous and much more difficult to
       * write in a way that avoids compiler warnings.
       */
      png_warning(png_ptr, "Image width is too large for this architecture");
      error = 1;
   }

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (width > png_ptr->user_width_max)
#else
   if (width > PNG_USER_WIDTH_MAX)
#endif
   {
      png_warning(png_ptr, "Image width exceeds user limit in IHDR");
      error = 1;
   }

   if (height == 0)
   {
      png_warning(png_ptr, "Image height is zero in IHDR");
      error = 1;
   }

   if (height > PNG_UINT_31_MAX)
   {
      png_warning(png_ptr, "Invalid image height in IHDR");
      error = 1;
   }

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (height > png_ptr->user_height_max)
#else
   if (height > PNG_USER_HEIGHT_MAX)
#endif
   {
      png_warning(png_ptr, "Image height exceeds user limit in IHDR");
      error = 1;
   }

   /* Check other values */
   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
       bit_depth != 8 && bit_depth != 16)
   {
      png_warning(png_ptr, "Invalid bit depth in IHDR");
      error = 1;
   }

   if (color_type < 0 || color_type == 1 ||
       color_type == 5 || color_type > 6)
   {
      png_warning(png_ptr, "Invalid color type in IHDR");
      error = 1;
   }

   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
       ((color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
   {
      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
      error = 1;
   }

   if (interlace_type >= PNG_INTERLACE_LAST)
   {
      png_warning(png_ptr, "Unknown interlace method in IHDR");
      error = 1;
   }

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
   {
      png_warning(png_ptr, "Unknown compression method in IHDR");
      error = 1;
   }

#ifdef PNG_MNG_FEATURES_SUPPORTED
   /* Accept filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not read a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA
    */
   if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) != 0 &&
       png_ptr->mng_features_permitted != 0)
      png_warning(png_ptr, "MNG features are not allowed in a PNG datastream");

   if (filter_type != PNG_FILTER_TYPE_BASE)
   {
      if (!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) != 0 &&
          (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
          ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&
          (color_type == PNG_COLOR_TYPE_RGB ||
          color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
      {
         png_warning(png_ptr, "Unknown filter method in IHDR");
         error = 1;
      }

      if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) != 0)
      {
         png_warning(png_ptr, "Invalid filter method in IHDR");
         error = 1;
      }
   }

#else
   if (filter_type != PNG_FILTER_TYPE_BASE)
   {
      png_warning(png_ptr, "Unknown filter method in IHDR");
      error = 1;
   }
#endif

   if (error == 1)
      png_error(png_ptr, "Invalid IHDR data");
}

#if defined(PNG_sCAL_SUPPORTED) || defined(PNG_pCAL_SUPPORTED)
/* ASCII to fp functions */
/* Check an ASCII formated floating point value, see the more detailed
 * comments in pngpriv.h
 */
/* The following is used internally to preserve the sticky flags */
#define png_fp_add(state, flags) ((state) |= (flags))
#define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))

int /* PRIVATE */
png_check_fp_number(png_const_charp string, png_size_t size, int *statep,
    png_size_tp whereami)
{
   int state = *statep;
   png_size_t i = *whereami;

   while (i < size)
   {
      int type;
      /* First find the type of the next character */
      switch (string[i])
      {
      case 43:  type = PNG_FP_SAW_SIGN;                   break;
      case 45:  type = PNG_FP_SAW_SIGN + PNG_FP_NEGATIVE; break;
      case 46:  type = PNG_FP_SAW_DOT;                    break;
      case 48:  type = PNG_FP_SAW_DIGIT;                  break;
      case 49: case 50: case 51: case 52:
      case 53: case 54: case 55: case 56:
      case 57:  type = PNG_FP_SAW_DIGIT + PNG_FP_NONZERO; break;
      case 69:
      case 101: type = PNG_FP_SAW_E;                      break;
      default:  goto PNG_FP_End;
      }

      /* Now deal with this type according to the current
       * state, the type is arranged to not overlap the
       * bits of the PNG_FP_STATE.
       */
      switch ((state & PNG_FP_STATE) + (type & PNG_FP_SAW_ANY))
      {
      case PNG_FP_INTEGER + PNG_FP_SAW_SIGN:
         if ((state & PNG_FP_SAW_ANY) != 0)
            goto PNG_FP_End; /* not a part of the number */

         png_fp_add(state, type);
         break;

      case PNG_FP_INTEGER + PNG_FP_SAW_DOT:
         /* Ok as trailer, ok as lead of fraction. */
         if ((state & PNG_FP_SAW_DOT) != 0) /* two dots */
            goto PNG_FP_End;

         else if ((state & PNG_FP_SAW_DIGIT) != 0) /* trailing dot? */
            png_fp_add(state, type);

         else
            png_fp_set(state, PNG_FP_FRACTION | type);

         break;

      case PNG_FP_INTEGER + PNG_FP_SAW_DIGIT:
         if ((state & PNG_FP_SAW_DOT) != 0) /* delayed fraction */
            png_fp_set(state, PNG_FP_FRACTION | PNG_FP_SAW_DOT);

         png_fp_add(state, type | PNG_FP_WAS_VALID);

         break;

      case PNG_FP_INTEGER + PNG_FP_SAW_E:
         if ((state & PNG_FP_SAW_DIGIT) == 0)
            goto PNG_FP_End;

         png_fp_set(state, PNG_FP_EXPONENT);

         break;

   /* case PNG_FP_FRACTION + PNG_FP_SAW_SIGN:
         goto PNG_FP_End; ** no sign in fraction */

   /* case PNG_FP_FRACTION + PNG_FP_SAW_DOT:
         goto PNG_FP_End; ** Because SAW_DOT is always set */

      case PNG_FP_FRACTION + PNG_FP_SAW_DIGIT:
         png_fp_add(state, type | PNG_FP_WAS_VALID);
         break;

      case PNG_FP_FRACTION + PNG_FP_SAW_E:
         /* This is correct because the trailing '.' on an
          * integer is handled above - so we can only get here
          * with the sequence ".E" (with no preceding digits).
          */
         if ((state & PNG_FP_SAW_DIGIT) == 0)
            goto PNG_FP_End;

         png_fp_set(state, PNG_FP_EXPONENT);

         break;

      case PNG_FP_EXPONENT + PNG_FP_SAW_SIGN:
         if ((state & PNG_FP_SAW_ANY) != 0)
            goto PNG_FP_End; /* not a part of the number */

         png_fp_add(state, PNG_FP_SAW_SIGN);

         break;

   /* case PNG_FP_EXPONENT + PNG_FP_SAW_DOT:
         goto PNG_FP_End; */

      case PNG_FP_EXPONENT + PNG_FP_SAW_DIGIT:
         png_fp_add(state, PNG_FP_SAW_DIGIT | PNG_FP_WAS_VALID);

         break;

   /* case PNG_FP_EXPONEXT + PNG_FP_SAW_E:
         goto PNG_FP_End; */

      default: goto PNG_FP_End; /* I.e. break 2 */
      }

      /* The character seems ok, continue. */
      ++i;
   }

PNG_FP_End:
   /* Here at the end, update the state and return the correct
    * return code.
    */
   *statep = state;
   *whereami = i;

   return (state & PNG_FP_SAW_DIGIT) != 0;
}


/* The same but for a complete string. */
int
png_check_fp_string(png_const_charp string, png_size_t size)
{
   int        state=0;
   png_size_t char_index=0;

   if (png_check_fp_number(string, size, &state, &char_index) != 0 &&
      (char_index == size || string[char_index] == 0))
      return state /* must be non-zero - see above */;

   return 0; /* i.e. fail */
}
#endif /* pCAL || sCAL */

#ifdef PNG_sCAL_SUPPORTED
#  ifdef PNG_FLOATING_POINT_SUPPORTED
/* Utility used below - a simple accurate power of ten from an integral
 * exponent.
 */
static double
png_pow10(int power)
{
   int recip = 0;
   double d = 1;

   /* Handle negative exponent with a reciprocal at the end because
    * 10 is exact whereas .1 is inexact in base 2
    */
   if (power < 0)
   {
      if (power < DBL_MIN_10_EXP) return 0;
      recip = 1, power = -power;
   }

   if (power > 0)
   {
      /* Decompose power bitwise. */
      double mult = 10;
      do
      {
         if (power & 1) d *= mult;
         mult *= mult;
         power >>= 1;
      }
      while (power > 0);

      if (recip != 0) d = 1/d;
   }
   /* else power is 0 and d is 1 */

   return d;
}

/* Function to format a floating point value in ASCII with a given
 * precision.
 */
void /* PRIVATE */
png_ascii_from_fp(png_const_structrp png_ptr, png_charp ascii, png_size_t size,
    double fp, unsigned int precision)
{
   /* We use standard functions from math.h, but not printf because
    * that would require stdio.  The caller must supply a buffer of
    * sufficient size or we will png_error.  The tests on size and
    * the space in ascii[] consumed are indicated below.
    */
   if (precision < 1)
      precision = DBL_DIG;

   /* Enforce the limit of the implementation precision too. */
   if (precision > DBL_DIG+1)
      precision = DBL_DIG+1;

   /* Basic sanity checks */
   if (size >= precision+5) /* See the requirements below. */
   {
      if (fp < 0)
      {
         fp = -fp;
         *ascii++ = 45; /* '-'  PLUS 1 TOTAL 1 */
         --size;
      }

      if (fp >= DBL_MIN && fp <= DBL_MAX)
      {
         int exp_b10;   /* A base 10 exponent */
         double base;   /* 10^exp_b10 */

         /* First extract a base 10 exponent of the number,
          * the calculation below rounds down when converting
          * from base 2 to base 10 (multiply by log10(2) -
          * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to
          * be increased.  Note that the arithmetic shift
          * performs a floor() unlike C arithmetic - using a
          * C multiply would break the following for negative
          * exponents.
          */
         (void)frexp(fp, &exp_b10); /* exponent to base 2 */

         exp_b10 = (exp_b10 * 77) >> 8; /* <= exponent to base 10 */

         /* Avoid underflow here. */
         base = png_pow10(exp_b10); /* May underflow */

         while (base < DBL_MIN || base < fp)
         {
            /* And this may overflow. */
            double test = png_pow10(exp_b10+1);

            if (test <= DBL_MAX)
               ++exp_b10, base = test;

            else
               break;
         }

         /* Normalize fp and correct exp_b10, after this fp is in the
          * range [.1,1) and exp_b10 is both the exponent and the digit
          * *before* which the decimal point should be inserted
          * (starting with 0 for the first digit).  Note that this
          * works even if 10^exp_b10 is out of range because of the
          * test on DBL_MAX above.
          */
         fp /= base;
         while (fp >= 1) fp /= 10, ++exp_b10;

         /* Because of the code above fp may, at this point, be
          * less than .1, this is ok because the code below can
          * handle the leading zeros this generates, so no attempt
          * is made to correct that here.
          */

         {
            unsigned int czero, clead, cdigits;
            char exponent[10];

            /* Allow up to two leading zeros - this will not lengthen
             * the number compared to using E-n.
             */
            if (exp_b10 < 0 && exp_b10 > -3) /* PLUS 3 TOTAL 4 */
            {
               czero = (unsigned int)(-exp_b10); /* PLUS 2 digits: TOTAL 3 */
               exp_b10 = 0;      /* Dot added below before first output. */
            }
            else
               czero = 0;    /* No zeros to add */

            /* Generate the digit list, stripping trailing zeros and
             * inserting a '.' before a digit if the exponent is 0.
             */
            clead = czero; /* Count of leading zeros */
            cdigits = 0;   /* Count of digits in list. */

            do
            {
               double d;

               fp *= 10;
               /* Use modf here, not floor and subtract, so that
                * the separation is done in one step.  At the end
                * of the loop don't break the number into parts so
                * that the final digit is rounded.
                */
               if (cdigits+czero+1 < precision+clead)
                  fp = modf(fp, &d);

               else
               {
                  d = floor(fp + .5);

                  if (d > 9)
                  {
                     /* Rounding up to 10, handle that here. */
                     if (czero > 0)
                     {
                        --czero, d = 1;
                        if (cdigits == 0) --clead;
                     }
                     else
                     {
                        while (cdigits > 0 && d > 9)
                        {
                           int ch = *--ascii;

                           if (exp_b10 != (-1))
                              ++exp_b10;

                           else if (ch == 46)
                           {
                              ch = *--ascii, ++size;
                              /* Advance exp_b10 to '1', so that the
                               * decimal point happens after the
                               * previous digit.
                               */
                              exp_b10 = 1;
                           }

                           --cdigits;
                           d = ch - 47;  /* I.e. 1+(ch-48) */
                        }

                        /* Did we reach the beginning? If so adjust the
                         * exponent but take into account the leading
                         * decimal point.
                         */
                        if (d > 9)  /* cdigits == 0 */
                        {
                           if (exp_b10 == (-1))
                           {
                              /* Leading decimal point (plus zeros?), if
                               * we lose the decimal point here it must
                               * be reentered below.
                               */
                              int ch = *--ascii;

                              if (ch == 46)
                                 ++size, exp_b10 = 1;

                              /* Else lost a leading zero, so 'exp_b10' is
                               * still ok at (-1)
                               */
                           }
                           else
                              ++exp_b10;

                           /* In all cases we output a '1' */
                           d = 1;
                        }
                     }
                  }
                  fp = 0; /* Guarantees termination below. */
               }

               if (d == 0)
               {
                  ++czero;
                  if (cdigits == 0) ++clead;
               }
               else
               {
                  /* Included embedded zeros in the digit count. */
                  cdigits += czero - clead;
                  clead = 0;

                  while (czero > 0)
                  {
                     /* exp_b10 == (-1) means we just output the decimal
                      * place - after the DP don't adjust 'exp_b10' any
                      * more!
                      */
                     if (exp_b10 != (-1))
                     {
                        if (exp_b10 == 0) *ascii++ = 46, --size;
                        /* PLUS 1: TOTAL 4 */
                        --exp_b10;
                     }
                     *ascii++ = 48, --czero;
                  }

                  if (exp_b10 != (-1))
                  {
                     if (exp_b10 == 0)
                        *ascii++ = 46, --size; /* counted above */

                     --exp_b10;
                  }
                  *ascii++ = (char)(48 + (int)d), ++cdigits;
               }
            }
            while (cdigits+czero < precision+clead && fp > DBL_MIN);

            /* The total output count (max) is now 4+precision */

            /* Check for an exponent, if we don't need one we are
             * done and just need to terminate the string.  At
             * this point exp_b10==(-1) is effectively if flag - it got
             * to '-1' because of the decrement after outputting
             * the decimal point above (the exponent required is
             * *not* -1!)
             */
            if (exp_b10 >= (-1) && exp_b10 <= 2)
            {
               /* The following only happens if we didn't output the
                * leading zeros above for negative exponent, so this
                * doesn't add to the digit requirement.  Note that the
                * two zeros here can only be output if the two leading
                * zeros were *not* output, so this doesn't increase
                * the output count.
                */
               while (--exp_b10 >= 0) *ascii++ = 48;

               *ascii = 0;

               /* Total buffer requirement (including the '\0') is
                * 5+precision - see check at the start.
                */
               return;
            }

            /* Here if an exponent is required, adjust size for
             * the digits we output but did not count.  The total
             * digit output here so far is at most 1+precision - no
             * decimal point and no leading or trailing zeros have
             * been output.
             */
            size -= cdigits;

            *ascii++ = 69, --size;    /* 'E': PLUS 1 TOTAL 2+precision */

            /* The following use of an unsigned temporary avoids ambiguities in
             * the signed arithmetic on exp_b10 and permits GCC at least to do
             * better optimization.
             */
            {
               unsigned int uexp_b10;

               if (exp_b10 < 0)
               {
                  *ascii++ = 45, --size; /* '-': PLUS 1 TOTAL 3+precision */
                  uexp_b10 = (unsigned int)(-exp_b10);
               }

               else
                  uexp_b10 = (unsigned int)exp_b10;

               cdigits = 0;

               while (uexp_b10 > 0)
               {
                  exponent[cdigits++] = (char)(48 + uexp_b10 % 10);
                  uexp_b10 /= 10;
               }
            }

            /* Need another size check here for the exponent digits, so
             * this need not be considered above.
             */
            if (size > cdigits)
            {
               while (cdigits > 0) *ascii++ = exponent[--cdigits];

               *ascii = 0;

               return;
            }
         }
      }
      else if (!(fp >= DBL_MIN))
      {
         *ascii++ = 48; /* '0' */
         *ascii = 0;
         return;
      }
      else
      {
         *ascii++ = 105; /* 'i' */
         *ascii++ = 110; /* 'n' */
         *ascii++ = 102; /* 'f' */
         *ascii = 0;
         return;
      }
   }

   /* Here on buffer too small. */
   png_error(png_ptr, "ASCII conversion buffer too small");
}

#  endif /* FLOATING_POINT */

#  ifdef PNG_FIXED_POINT_SUPPORTED
/* Function to format a fixed point value in ASCII.
 */
void /* PRIVATE */
png_ascii_from_fixed(png_const_structrp png_ptr, png_charp ascii,
    png_size_t size, png_fixed_point fp)
{
   /* Require space for 10 decimal digits, a decimal point, a minus sign and a
    * trailing \0, 13 characters:
    */
   if (size > 12)
   {
      png_uint_32 num;

      /* Avoid overflow here on the minimum integer. */
      if (fp < 0)
         *ascii++ = 45, num = (png_uint_32)(-fp);
      else
         num = (png_uint_32)fp;

      if (num <= 0x80000000) /* else overflowed */
      {
         unsigned int ndigits = 0, first = 16 /* flag value */;
         char digits[10];

         while (num)
         {
            /* Split the low digit off num: */
            unsigned int tmp = num/10;
            num -= tmp*10;
            digits[ndigits++] = (char)(48 + num);
            /* Record the first non-zero digit, note that this is a number
             * starting at 1, it's not actually the array index.
             */
            if (first == 16 && num > 0)
               first = ndigits;
            num = tmp;
         }

         if (ndigits > 0)
         {
            while (ndigits > 5) *ascii++ = digits[--ndigits];
            /* The remaining digits are fractional digits, ndigits is '5' or
             * smaller at this point.  It is certainly not zero.  Check for a
             * non-zero fractional digit:
             */
            if (first <= 5)
            {
               unsigned int i;
               *ascii++ = 46; /* decimal point */
               /* ndigits may be <5 for small numbers, output leading zeros
                * then ndigits digits to first:
                */
               i = 5;
               while (ndigits < i) *ascii++ = 48, --i;
               while (ndigits >= first) *ascii++ = digits[--ndigits];
               /* Don't output the trailing zeros! */
            }
         }
         else
            *ascii++ = 48;

         /* And null terminate the string: */
         *ascii = 0;
         return;
      }
   }

   /* Here on buffer too small. */
   png_error(png_ptr, "ASCII conversion buffer too small");
}
#   endif /* FIXED_POINT */
#endif /* SCAL */

#if defined(PNG_FLOATING_POINT_SUPPORTED) && \
   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \
   (defined(PNG_gAMA_SUPPORTED) || defined(PNG_cHRM_SUPPORTED) || \
   defined(PNG_sCAL_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) || \
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)) || \
   (defined(PNG_sCAL_SUPPORTED) && \
   defined(PNG_FLOATING_ARITHMETIC_SUPPORTED))
png_fixed_point
png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
   double r = floor(100000 * fp + .5);

   if (r > 2147483647. || r < -2147483648.)
      png_fixed_error(png_ptr, text);

#  ifndef PNG_ERROR_TEXT_SUPPORTED
   PNG_UNUSED(text)
#  endif

   return (png_fixed_point)r;
}
#endif

#if defined(PNG_GAMMA_SUPPORTED) || defined(PNG_COLORSPACE_SUPPORTED) ||\
    defined(PNG_INCH_CONVERSIONS_SUPPORTED) || defined(PNG_READ_pHYs_SUPPORTED)
/* muldiv functions */
/* This API takes signed arguments and rounds the result to the nearest
 * integer (or, for a fixed point number - the standard argument - to
 * the nearest .00001).  Overflow and divide by zero are signalled in
 * the result, a boolean - true on success, false on overflow.
 */
int
png_muldiv(png_fixed_point_p res, png_fixed_point a, png_int_32 times,
    png_int_32 divisor)
{
   /* Return a * times / divisor, rounded. */
   if (divisor != 0)
   {
      if (a == 0 || times == 0)
      {
         *res = 0;
         return 1;
      }
      else
      {
#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
         double r = a;
         r *= times;
         r /= divisor;
         r = floor(r+.5);

         /* A png_fixed_point is a 32-bit integer. */
         if (r <= 2147483647. && r >= -2147483648.)
         {
            *res = (png_fixed_point)r;
            return 1;
         }
#else
         int negative = 0;
         png_uint_32 A, T, D;
         png_uint_32 s16, s32, s00;

         if (a < 0)
            negative = 1, A = -a;
         else
            A = a;

         if (times < 0)
            negative = !negative, T = -times;
         else
            T = times;

         if (divisor < 0)
            negative = !negative, D = -divisor;
         else
            D = divisor;

         /* Following can't overflow because the arguments only
          * have 31 bits each, however the result may be 32 bits.
          */
         s16 = (A >> 16) * (T & 0xffff) +
                           (A & 0xffff) * (T >> 16);
         /* Can't overflow because the a*times bit is only 30
          * bits at most.
          */
         s32 = (A >> 16) * (T >> 16) + (s16 >> 16);
         s00 = (A & 0xffff) * (T & 0xffff);

         s16 = (s16 & 0xffff) << 16;
         s00 += s16;

         if (s00 < s16)
            ++s32; /* carry */

         if (s32 < D) /* else overflow */
         {
            /* s32.s00 is now the 64-bit product, do a standard
             * division, we know that s32 < D, so the maximum
             * required shift is 31.
             */
            int bitshift = 32;
            png_fixed_point result = 0; /* NOTE: signed */

            while (--bitshift >= 0)
            {
               png_uint_32 d32, d00;

               if (bitshift > 0)
                  d32 = D >> (32-bitshift), d00 = D << bitshift;

               else
                  d32 = 0, d00 = D;

               if (s32 > d32)
               {
                  if (s00 < d00) --s32; /* carry */
                  s32 -= d32, s00 -= d00, result += 1<<bitshift;
               }

               else
                  if (s32 == d32 && s00 >= d00)
                     s32 = 0, s00 -= d00, result += 1<<bitshift;
            }

            /* Handle the rounding. */
            if (s00 >= (D >> 1))
               ++result;

            if (negative != 0)
               result = -result;

            /* Check for overflow. */
            if ((negative != 0 && result <= 0) ||
                (negative == 0 && result >= 0))
            {
               *res = result;
               return 1;
            }
         }
#endif
      }
   }

   return 0;
}
#endif /* READ_GAMMA || INCH_CONVERSIONS */

#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)
/* The following is for when the caller doesn't much care about the
 * result.
 */
png_fixed_point
png_muldiv_warn(png_const_structrp png_ptr, png_fixed_point a, png_int_32 times,
    png_int_32 divisor)
{
   png_fixed_point result;

   if (png_muldiv(&result, a, times, divisor) != 0)
      return result;

   png_warning(png_ptr, "fixed point overflow ignored");
   return 0;
}
#endif

#ifdef PNG_GAMMA_SUPPORTED /* more fixed point functions for gamma */
/* Calculate a reciprocal, return 0 on div-by-zero or overflow. */
png_fixed_point
png_reciprocal(png_fixed_point a)
{
#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
   double r = floor(1E10/a+.5);

   if (r <= 2147483647. && r >= -2147483648.)
      return (png_fixed_point)r;
#else
   png_fixed_point res;

   if (png_muldiv(&res, 100000, 100000, a) != 0)
      return res;
#endif

   return 0; /* error/overflow */
}

/* This is the shared test on whether a gamma value is 'significant' - whether
 * it is worth doing gamma correction.
 */
int /* PRIVATE */
png_gamma_significant(png_fixed_point gamma_val)
{
   return gamma_val < PNG_FP_1 - PNG_GAMMA_THRESHOLD_FIXED ||
       gamma_val > PNG_FP_1 + PNG_GAMMA_THRESHOLD_FIXED;
}
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
#ifdef PNG_16BIT_SUPPORTED
/* A local convenience routine. */
static png_fixed_point
png_product2(png_fixed_point a, png_fixed_point b)
{
   /* The required result is 1/a * 1/b; the following preserves accuracy. */
#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
   double r = a * 1E-5;
   r *= b;
   r = floor(r+.5);

   if (r <= 2147483647. && r >= -2147483648.)
      return (png_fixed_point)r;
#else
   png_fixed_point res;

   if (png_muldiv(&res, a, b, 100000) != 0)
      return res;
#endif

   return 0; /* overflow */
}
#endif /* 16BIT */

/* The inverse of the above. */
png_fixed_point
png_reciprocal2(png_fixed_point a, png_fixed_point b)
{
   /* The required result is 1/a * 1/b; the following preserves accuracy. */
#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
   if (a != 0 && b != 0)
   {
      double r = 1E15/a;
      r /= b;
      r = floor(r+.5);

      if (r <= 2147483647. && r >= -2147483648.)
         return (png_fixed_point)r;
   }
#else
   /* This may overflow because the range of png_fixed_point isn't symmetric,
    * but this API is only used for the product of file and screen gamma so it
    * doesn't matter that the smallest number it can produce is 1/21474, not
    * 1/100000
    */
   png_fixed_point res = png_product2(a, b);

   if (res != 0)
      return png_reciprocal(res);
#endif

   return 0; /* overflow */
}
#endif /* READ_GAMMA */

#ifdef PNG_READ_GAMMA_SUPPORTED /* gamma table code */
#ifndef PNG_FLOATING_ARITHMETIC_SUPPORTED
/* Fixed point gamma.
 *
 * The code to calculate the tables used below can be found in the shell script
 * contrib/tools/intgamma.sh
 *
 * To calculate gamma this code implements fast log() and exp() calls using only
 * fixed point arithmetic.  This code has sufficient precision for either 8-bit
 * or 16-bit sample values.
 *
 * The tables used here were calculated using simple 'bc' programs, but C double
 * precision floating point arithmetic would work fine.
 *
 * 8-bit log table
 *   This is a table of -log(value/255)/log(2) for 'value' in the range 128 to
 *   255, so it's the base 2 logarithm of a normalized 8-bit floating point
 *   mantissa.  The numbers are 32-bit fractions.
 */
static const png_uint_32
png_8bit_l2[128] =
{
   4270715492U, 4222494797U, 4174646467U, 4127164793U, 4080044201U, 4033279239U,
   3986864580U, 3940795015U, 3895065449U, 3849670902U, 3804606499U, 3759867474U,
   3715449162U, 3671346997U, 3627556511U, 3584073329U, 3540893168U, 3498011834U,
   3455425220U, 3413129301U, 3371120137U, 3329393864U, 3287946700U, 3246774933U,
   3205874930U, 3165243125U, 3124876025U, 3084770202U, 3044922296U, 3005329011U,
   2965987113U, 2926893432U, 2888044853U, 2849438323U, 2811070844U, 2772939474U,
   2735041326U, 2697373562U, 2659933400U, 2622718104U, 2585724991U, 2548951424U,
   2512394810U, 2476052606U, 2439922311U, 2404001468U, 2368287663U, 2332778523U,
   2297471715U, 2262364947U, 2227455964U, 2192742551U, 2158222529U, 2123893754U,
   2089754119U, 2055801552U, 2022034013U, 1988449497U, 1955046031U, 1921821672U,
   1888774511U, 1855902668U, 1823204291U, 1790677560U, 1758320682U, 1726131893U,
   1694109454U, 1662251657U, 1630556815U, 1599023271U, 1567649391U, 1536433567U,
   1505374214U, 1474469770U, 1443718700U, 1413119487U, 1382670639U, 1352370686U,
   1322218179U, 1292211689U, 1262349810U, 1232631153U, 1203054352U, 1173618059U,
   1144320946U, 1115161701U, 1086139034U, 1057251672U, 1028498358U, 999877854U,
   971388940U, 943030410U, 914801076U, 886699767U, 858725327U, 830876614U,
   803152505U, 775551890U, 748073672U, 720716771U, 693480120U, 666362667U,
   639363374U, 612481215U, 585715177U, 559064263U, 532527486U, 506103872U,
   479792461U, 453592303U, 427502463U, 401522014U, 375650043U, 349885648U,
   324227938U, 298676034U, 273229066U, 247886176U, 222646516U, 197509248U,
   172473545U, 147538590U, 122703574U, 97967701U, 73330182U, 48790236U,
   24347096U, 0U

#if 0
   /* The following are the values for 16-bit tables - these work fine for the
    * 8-bit conversions but produce very slightly larger errors in the 16-bit
    * log (about 1.2 as opposed to 0.7 absolute error in the final value).  To
    * use these all the shifts below must be adjusted appropriately.
    */
   65166, 64430, 63700, 62976, 62257, 61543, 60835, 60132, 59434, 58741, 58054,
   57371, 56693, 56020, 55352, 54689, 54030, 53375, 52726, 52080, 51439, 50803,
   50170, 49542, 48918, 48298, 47682, 47070, 46462, 45858, 45257, 44661, 44068,
   43479, 42894, 42312, 41733, 41159, 40587, 40020, 39455, 38894, 38336, 37782,
   37230, 36682, 36137, 35595, 35057, 34521, 33988, 33459, 32932, 32408, 31887,
   31369, 30854, 30341, 29832, 29325, 28820, 28319, 27820, 27324, 26830, 26339,
   25850, 25364, 24880, 24399, 23920, 23444, 22970, 22499, 22029, 21562, 21098,
   20636, 20175, 19718, 19262, 18808, 18357, 17908, 17461, 17016, 16573, 16132,
   15694, 15257, 14822, 14390, 13959, 13530, 13103, 12678, 12255, 11834, 11415,
   10997, 10582, 10168, 9756, 9346, 8937, 8531, 8126, 7723, 7321, 6921, 6523,
   6127, 5732, 5339, 4947, 4557, 4169, 3782, 3397, 3014, 2632, 2251, 1872, 1495,
   1119, 744, 372
#endif
};

static png_int_32
png_log8bit(unsigned int x)
{
   unsigned int lg2 = 0;
   /* Each time 'x' is multiplied by 2, 1 must be subtracted off the final log,
    * because the log is actually negate that means adding 1.  The final
    * returned value thus has the range 0 (for 255 input) to 7.994 (for 1
    * input), return -1 for the overflow (log 0) case, - so the result is
    * always at most 19 bits.
    */
   if ((x &= 0xff) == 0)
      return -1;

   if ((x & 0xf0) == 0)
      lg2  = 4, x <<= 4;

   if ((x & 0xc0) == 0)
      lg2 += 2, x <<= 2;

   if ((x & 0x80) == 0)
      lg2 += 1, x <<= 1;

   /* result is at most 19 bits, so this cast is safe: */
   return (png_int_32)((lg2 << 16) + ((png_8bit_l2[x-128]+32768)>>16));
}

/* The above gives exact (to 16 binary places) log2 values for 8-bit images,
 * for 16-bit images we use the most significant 8 bits of the 16-bit value to
 * get an approximation then multiply the approximation by a correction factor
 * determined by the remaining up to 8 bits.  This requires an additional step
 * in the 16-bit case.
 *
 * We want log2(value/65535), we have log2(v'/255), where:
 *
 *    value = v' * 256 + v''
 *          = v' * f
 *
 * So f is value/v', which is equal to (256+v''/v') since v' is in the range 128
 * to 255 and v'' is in the range 0 to 255 f will be in the range 256 to less
 * than 258.  The final factor also needs to correct for the fact that our 8-bit
 * value is scaled by 255, whereas the 16-bit values must be scaled by 65535.
 *
 * This gives a final formula using a calculated value 'x' which is value/v' and
 * scaling by 65536 to match the above table:
 *
 *   log2(x/257) * 65536
 *
 * Since these numbers are so close to '1' we can use simple linear
 * interpolation between the two end values 256/257 (result -368.61) and 258/257
 * (result 367.179).  The values used below are scaled by a further 64 to give
 * 16-bit precision in the interpolation:
 *
 * Start (256): -23591
 * Zero  (257):      0
 * End   (258):  23499
 */
#ifdef PNG_16BIT_SUPPORTED
static png_int_32
png_log16bit(png_uint_32 x)
{
   unsigned int lg2 = 0;

   /* As above, but now the input has 16 bits. */
   if ((x &= 0xffff) == 0)
      return -1;

   if ((x & 0xff00) == 0)
      lg2  = 8, x <<= 8;

   if ((x & 0xf000) == 0)
      lg2 += 4, x <<= 4;

   if ((x & 0xc000) == 0)
      lg2 += 2, x <<= 2;

   if ((x & 0x8000) == 0)
      lg2 += 1, x <<= 1;

   /* Calculate the base logarithm from the top 8 bits as a 28-bit fractional
    * value.
    */
   lg2 <<= 28;
   lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;

   /* Now we need to interpolate the factor, this requires a division by the top
    * 8 bits.  Do this with maximum precision.
    */
   x = ((x << 16) + (x >> 9)) / (x >> 8);

   /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,
    * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly
    * 16 bits to interpolate to get the low bits of the result.  Round the
    * answer.  Note that the end point values are scaled by 64 to retain overall
    * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust
    * the overall scaling by 6-12.  Round at every step.
    */
   x -= 1U << 24;

   if (x <= 65536U) /* <= '257' */
      lg2 += ((23591U * (65536U-x)) + (1U << (16+6-12-1))) >> (16+6-12);

   else
      lg2 -= ((23499U * (x-65536U)) + (1U << (16+6-12-1))) >> (16+6-12);

   /* Safe, because the result can't have more than 20 bits: */
   return (png_int_32)((lg2 + 2048) >> 12);
}
#endif /* 16BIT */

/* The 'exp()' case must invert the above, taking a 20-bit fixed point
 * logarithmic value and returning a 16 or 8-bit number as appropriate.  In
 * each case only the low 16 bits are relevant - the fraction - since the
 * integer bits (the top 4) simply determine a shift.
 *
 * The worst case is the 16-bit distinction between 65535 and 65534. This
 * requires perhaps spurious accuracy in the decoding of the logarithm to
 * distinguish log2(65535/65534.5) - 10^-5 or 17 bits.  There is little chance
 * of getting this accuracy in practice.
 *
 * To deal with this the following exp() function works out the exponent of the
 * frational part of the logarithm by using an accurate 32-bit value from the
 * top four fractional bits then multiplying in the remaining bits.
 */
static const png_uint_32
png_32bit_exp[16] =
{
   /* NOTE: the first entry is deliberately set to the maximum 32-bit value. */
   4294967295U, 4112874773U, 3938502376U, 3771522796U, 3611622603U, 3458501653U,
   3311872529U, 3171459999U, 3037000500U, 2908241642U, 2784941738U, 2666869345U,
   2553802834U, 2445529972U, 2341847524U, 2242560872U
};

/* Adjustment table; provided to explain the numbers in the code below. */
#if 0
for (i=11;i>=0;--i){ print i, " ", (1 - e(-(2^i)/65536*l(2))) * 2^(32-i), "\n"}
   11 44937.64284865548751208448
   10 45180.98734845585101160448
    9 45303.31936980687359311872
    8 45364.65110595323018870784
    7 45395.35850361789624614912
    6 45410.72259715102037508096
    5 45418.40724413220722311168
    4 45422.25021786898173001728
    3 45424.17186732298419044352
    2 45425.13273269940811464704
    1 45425.61317555035558641664
    0 45425.85339951654943850496
#endif

static png_uint_32
png_exp(png_fixed_point x)
{
   if (x > 0 && x <= 0xfffff) /* Else overflow or zero (underflow) */
   {
      /* Obtain a 4-bit approximation */
      png_uint_32 e = png_32bit_exp[(x >> 12) & 0x0f];

      /* Incorporate the low 12 bits - these decrease the returned value by
       * multiplying by a number less than 1 if the bit is set.  The multiplier
       * is determined by the above table and the shift. Notice that the values
       * converge on 45426 and this is used to allow linear interpolation of the
       * low bits.
       */
      if (x & 0x800)
         e -= (((e >> 16) * 44938U) +  16U) >> 5;

      if (x & 0x400)
         e -= (((e >> 16) * 45181U) +  32U) >> 6;

      if (x & 0x200)
         e -= (((e >> 16) * 45303U) +  64U) >> 7;

      if (x & 0x100)
         e -= (((e >> 16) * 45365U) + 128U) >> 8;

      if (x & 0x080)
         e -= (((e >> 16) * 45395U) + 256U) >> 9;

      if (x & 0x040)
         e -= (((e >> 16) * 45410U) + 512U) >> 10;

      /* And handle the low 6 bits in a single block. */
      e -= (((e >> 16) * 355U * (x & 0x3fU)) + 256U) >> 9;

      /* Handle the upper bits of x. */
      e >>= x >> 16;
      return e;
   }

   /* Check for overflow */
   if (x <= 0)
      return png_32bit_exp[0];

   /* Else underflow */
   return 0;
}

static png_byte
png_exp8bit(png_fixed_point lg2)
{
   /* Get a 32-bit value: */
   png_uint_32 x = png_exp(lg2);

   /* Convert the 32-bit value to 0..255 by multiplying by 256-1. Note that the
    * second, rounding, step can't overflow because of the first, subtraction,
    * step.
    */
   x -= x >> 8;
   return (png_byte)(((x + 0x7fffffU) >> 24) & 0xff);
}

#ifdef PNG_16BIT_SUPPORTED
static png_uint_16
png_exp16bit(png_fixed_point lg2)
{
   /* Get a 32-bit value: */
   png_uint_32 x = png_exp(lg2);

   /* Convert the 32-bit value to 0..65535 by multiplying by 65536-1: */
   x -= x >> 16;
   return (png_uint_16)((x + 32767U) >> 16);
}
#endif /* 16BIT */
#endif /* FLOATING_ARITHMETIC */

png_byte
png_gamma_8bit_correct(unsigned int value, png_fixed_point gamma_val)
{
   if (value > 0 && value < 255)
   {
#     ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
         /* 'value' is unsigned, ANSI-C90 requires the compiler to correctly
          * convert this to a floating point value.  This includes values that
          * would overflow if 'value' were to be converted to 'int'.
          *
          * Apparently GCC, however, does an intermediate conversion to (int)
          * on some (ARM) but not all (x86) platforms, possibly because of
          * hardware FP limitations.  (E.g. if the hardware conversion always
          * assumes the integer register contains a signed value.)  This results
          * in ANSI-C undefined behavior for large values.
          *
          * Other implementations on the same machine might actually be ANSI-C90
          * conformant and therefore compile spurious extra code for the large
          * values.
          *
          * We can be reasonably sure that an unsigned to float conversion
          * won't be faster than an int to float one.  Therefore this code
          * assumes responsibility for the undefined behavior, which it knows
          * can't happen because of the check above.
          *
          * Note the argument to this routine is an (unsigned int) because, on
          * 16-bit platforms, it is assigned a value which might be out of
          * range for an (int); that would result in undefined behavior in the
          * caller if the *argument* ('value') were to be declared (int).
          */
         double r = floor(255*pow((int)/*SAFE*/value/255.,gamma_val*.00001)+.5);
         return (png_byte)r;
#     else
         png_int_32 lg2 = png_log8bit(value);
         png_fixed_point res;

         if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1) != 0)
            return png_exp8bit(res);

         /* Overflow. */
         value = 0;
#     endif
   }

   return (png_byte)(value & 0xff);
}

#ifdef PNG_16BIT_SUPPORTED
png_uint_16
png_gamma_16bit_correct(unsigned int value, png_fixed_point gamma_val)
{
   if (value > 0 && value < 65535)
   {
# ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
      /* The same (unsigned int)->(double) constraints apply here as above,
       * however in this case the (unsigned int) to (int) conversion can
       * overflow on an ANSI-C90 compliant system so the cast needs to ensure
       * that this is not possible.
       */
      double r = floor(65535*pow((png_int_32)value/65535.,
          gamma_val*.00001)+.5);
      return (png_uint_16)r;
# else
      png_int_32 lg2 = png_log16bit(value);
      png_fixed_point res;

      if (png_muldiv(&res, gamma_val, lg2, PNG_FP_1) != 0)
         return png_exp16bit(res);

      /* Overflow. */
      value = 0;
# endif
   }

   return (png_uint_16)value;
}
#endif /* 16BIT */

/* This does the right thing based on the bit_depth field of the
 * png_struct, interpreting values as 8-bit or 16-bit.  While the result
 * is nominally a 16-bit value if bit depth is 8 then the result is
 * 8-bit (as are the arguments.)
 */
png_uint_16 /* PRIVATE */
png_gamma_correct(png_structrp png_ptr, unsigned int value,
    png_fixed_point gamma_val)
{
   if (png_ptr->bit_depth == 8)
      return png_gamma_8bit_correct(value, gamma_val);

#ifdef PNG_16BIT_SUPPORTED
   else
      return png_gamma_16bit_correct(value, gamma_val);
#else
      /* should not reach this */
      return 0;
#endif /* 16BIT */
}

#ifdef PNG_16BIT_SUPPORTED
/* Internal function to build a single 16-bit table - the table consists of
 * 'num' 256 entry subtables, where 'num' is determined by 'shift' - the amount
 * to shift the input values right (or 16-number_of_signifiant_bits).
 *
 * The caller is responsible for ensuring that the table gets cleaned up on
 * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument
 * should be somewhere that will be cleaned.
 */
static void
png_build_16bit_table(png_structrp png_ptr, png_uint_16pp *ptable,
    PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)
{
   /* Various values derived from 'shift': */
   PNG_CONST unsigned int num = 1U << (8U - shift);
#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
   /* CSE the division and work round wacky GCC warnings (see the comments
    * in png_gamma_8bit_correct for where these come from.)
    */
   PNG_CONST double fmax = 1./(((png_int_32)1 << (16U - shift))-1);
#endif
   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;
   PNG_CONST unsigned int max_by_2 = 1U << (15U-shift);
   unsigned int i;

   png_uint_16pp table = *ptable =
       (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));

   for (i = 0; i < num; i++)
   {
      png_uint_16p sub_table = table[i] =
          (png_uint_16p)png_malloc(png_ptr, 256 * (sizeof (png_uint_16)));

      /* The 'threshold' test is repeated here because it can arise for one of
       * the 16-bit tables even if the others don't hit it.
       */
      if (png_gamma_significant(gamma_val) != 0)
      {
         /* The old code would overflow at the end and this would cause the
          * 'pow' function to return a result >1, resulting in an
          * arithmetic error.  This code follows the spec exactly; ig is
          * the recovered input sample, it always has 8-16 bits.
          *
          * We want input * 65535/max, rounded, the arithmetic fits in 32
          * bits (unsigned) so long as max <= 32767.
          */
         unsigned int j;
         for (j = 0; j < 256; j++)
         {
            png_uint_32 ig = (j << (8-shift)) + i;
#           ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
               /* Inline the 'max' scaling operation: */
               /* See png_gamma_8bit_correct for why the cast to (int) is
                * required here.
                */
               double d = floor(65535.*pow(ig*fmax, gamma_val*.00001)+.5);
               sub_table[j] = (png_uint_16)d;
#           else
               if (shift != 0)
                  ig = (ig * 65535U + max_by_2)/max;

               sub_table[j] = png_gamma_16bit_correct(ig, gamma_val);
#           endif
         }
      }
      else
      {
         /* We must still build a table, but do it the fast way. */
         unsigned int j;

         for (j = 0; j < 256; j++)
         {
            png_uint_32 ig = (j << (8-shift)) + i;

            if (shift != 0)
               ig = (ig * 65535U + max_by_2)/max;

            sub_table[j] = (png_uint_16)ig;
         }
      }
   }
}

/* NOTE: this function expects the *inverse* of the overall gamma transformation
 * required.
 */
static void
png_build_16to8_table(png_structrp png_ptr, png_uint_16pp *ptable,
    PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)
{
   PNG_CONST unsigned int num = 1U << (8U - shift);
   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;
   unsigned int i;
   png_uint_32 last;

   png_uint_16pp table = *ptable =
       (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));

   /* 'num' is the number of tables and also the number of low bits of low
    * bits of the input 16-bit value used to select a table.  Each table is
    * itself indexed by the high 8 bits of the value.
    */
   for (i = 0; i < num; i++)
      table[i] = (png_uint_16p)png_malloc(png_ptr,
          256 * (sizeof (png_uint_16)));

   /* 'gamma_val' is set to the reciprocal of the value calculated above, so
    * pow(out,g) is an *input* value.  'last' is the last input value set.
    *
    * In the loop 'i' is used to find output values.  Since the output is
    * 8-bit there are only 256 possible values.  The tables are set up to
    * select the closest possible output value for each input by finding
    * the input value at the boundary between each pair of output values
    * and filling the table up to that boundary with the lower output
    * value.
    *
    * The boundary values are 0.5,1.5..253.5,254.5.  Since these are 9-bit
    * values the code below uses a 16-bit value in i; the values start at
    * 128.5 (for 0.5) and step by 257, for a total of 254 values (the last
    * entries are filled with 255).  Start i at 128 and fill all 'last'
    * table entries <= 'max'
    */
   last = 0;
   for (i = 0; i < 255; ++i) /* 8-bit output value */
   {
      /* Find the corresponding maximum input value */
      png_uint_16 out = (png_uint_16)(i * 257U); /* 16-bit output value */

      /* Find the boundary value in 16 bits: */
      png_uint_32 bound = png_gamma_16bit_correct(out+128U, gamma_val);

      /* Adjust (round) to (16-shift) bits: */
      bound = (bound * max + 32768U)/65535U + 1U;

      while (last < bound)
      {
         table[last & (0xffU >> shift)][last >> (8U - shift)] = out;
         last++;
      }
   }

   /* And fill in the final entries. */
   while (last < (num << 8))
   {
      table[last & (0xff >> shift)][last >> (8U - shift)] = 65535U;
      last++;
   }
}
#endif /* 16BIT */

/* Build a single 8-bit table: same as the 16-bit case but much simpler (and
 * typically much faster).  Note that libpng currently does no sBIT processing
 * (apparently contrary to the spec) so a 256-entry table is always generated.
 */
static void
png_build_8bit_table(png_structrp png_ptr, png_bytepp ptable,
    PNG_CONST png_fixed_point gamma_val)
{
   unsigned int i;
   png_bytep table = *ptable = (png_bytep)png_malloc(png_ptr, 256);

   if (png_gamma_significant(gamma_val) != 0)
      for (i=0; i<256; i++)
         table[i] = png_gamma_8bit_correct(i, gamma_val);

   else
      for (i=0; i<256; ++i)
         table[i] = (png_byte)(i & 0xff);
}

/* Used from png_read_destroy and below to release the memory used by the gamma
 * tables.
 */
void /* PRIVATE */
png_destroy_gamma_table(png_structrp png_ptr)
{
   png_free(png_ptr, png_ptr->gamma_table);
   png_ptr->gamma_table = NULL;

#ifdef PNG_16BIT_SUPPORTED
   if (png_ptr->gamma_16_table != NULL)
   {
      int i;
      int istop = (1 << (8 - png_ptr->gamma_shift));
      for (i = 0; i < istop; i++)
      {
         png_free(png_ptr, png_ptr->gamma_16_table[i]);
      }
   png_free(png_ptr, png_ptr->gamma_16_table);
   png_ptr->gamma_16_table = NULL;
   }
#endif /* 16BIT */

#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
   png_free(png_ptr, png_ptr->gamma_from_1);
   png_ptr->gamma_from_1 = NULL;
   png_free(png_ptr, png_ptr->gamma_to_1);
   png_ptr->gamma_to_1 = NULL;

#ifdef PNG_16BIT_SUPPORTED
   if (png_ptr->gamma_16_from_1 != NULL)
   {
      int i;
      int istop = (1 << (8 - png_ptr->gamma_shift));
      for (i = 0; i < istop; i++)
      {
         png_free(png_ptr, png_ptr->gamma_16_from_1[i]);
      }
   png_free(png_ptr, png_ptr->gamma_16_from_1);
   png_ptr->gamma_16_from_1 = NULL;
   }
   if (png_ptr->gamma_16_to_1 != NULL)
   {
      int i;
      int istop = (1 << (8 - png_ptr->gamma_shift));
      for (i = 0; i < istop; i++)
      {
         png_free(png_ptr, png_ptr->gamma_16_to_1[i]);
      }
   png_free(png_ptr, png_ptr->gamma_16_to_1);
   png_ptr->gamma_16_to_1 = NULL;
   }
#endif /* 16BIT */
#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
}

/* We build the 8- or 16-bit gamma tables here.  Note that for 16-bit
 * tables, we don't make a full table if we are reducing to 8-bit in
 * the future.  Note also how the gamma_16 tables are segmented so that
 * we don't need to allocate > 64K chunks for a full 16-bit table.
 */
void /* PRIVATE */
png_build_gamma_table(png_structrp png_ptr, int bit_depth)
{
   png_debug(1, "in png_build_gamma_table");

   /* Remove any existing table; this copes with multiple calls to
    * png_read_update_info. The warning is because building the gamma tables
    * multiple times is a performance hit - it's harmless but the ability to
    * call png_read_update_info() multiple times is new in 1.5.6 so it seems
    * sensible to warn if the app introduces such a hit.
    */
   if (png_ptr->gamma_table != NULL || png_ptr->gamma_16_table != NULL)
   {
      png_warning(png_ptr, "gamma table being rebuilt");
      png_destroy_gamma_table(png_ptr);
   }

   if (bit_depth <= 8)
   {
      png_build_8bit_table(png_ptr, &png_ptr->gamma_table,
          png_ptr->screen_gamma > 0 ?
          png_reciprocal2(png_ptr->colorspace.gamma,
          png_ptr->screen_gamma) : PNG_FP_1);

#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
      if ((png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY)) != 0)
      {
         png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1,
             png_reciprocal(png_ptr->colorspace.gamma));

         png_build_8bit_table(png_ptr, &png_ptr->gamma_from_1,
             png_ptr->screen_gamma > 0 ?
             png_reciprocal(png_ptr->screen_gamma) :
             png_ptr->colorspace.gamma/* Probably doing rgb_to_gray */);
      }
#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
   }
#ifdef PNG_16BIT_SUPPORTED
   else
   {
      png_byte shift, sig_bit;

      if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
      {
         sig_bit = png_ptr->sig_bit.red;

         if (png_ptr->sig_bit.green > sig_bit)
            sig_bit = png_ptr->sig_bit.green;

         if (png_ptr->sig_bit.blue > sig_bit)
            sig_bit = png_ptr->sig_bit.blue;
      }
      else
         sig_bit = png_ptr->sig_bit.gray;

      /* 16-bit gamma code uses this equation:
       *
       *   ov = table[(iv & 0xff) >> gamma_shift][iv >> 8]
       *
       * Where 'iv' is the input color value and 'ov' is the output value -
       * pow(iv, gamma).
       *
       * Thus the gamma table consists of up to 256 256-entry tables.  The table
       * is selected by the (8-gamma_shift) most significant of the low 8 bits
       * of the color value then indexed by the upper 8 bits:
       *
       *   table[low bits][high 8 bits]
       *
       * So the table 'n' corresponds to all those 'iv' of:
       *
       *   <all high 8-bit values><n << gamma_shift>..<(n+1 << gamma_shift)-1>
       *
       */
      if (sig_bit > 0 && sig_bit < 16U)
         /* shift == insignificant bits */
         shift = (png_byte)((16U - sig_bit) & 0xff);

      else
         shift = 0; /* keep all 16 bits */

      if ((png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8)) != 0)
      {
         /* PNG_MAX_GAMMA_8 is the number of bits to keep - effectively
          * the significant bits in the *input* when the output will
          * eventually be 8 bits.  By default it is 11.
          */
         if (shift < (16U - PNG_MAX_GAMMA_8))
            shift = (16U - PNG_MAX_GAMMA_8);
      }

      if (shift > 8U)
         shift = 8U; /* Guarantees at least one table! */

      png_ptr->gamma_shift = shift;

      /* NOTE: prior to 1.5.4 this test used to include PNG_BACKGROUND (now
       * PNG_COMPOSE).  This effectively smashed the background calculation for
       * 16-bit output because the 8-bit table assumes the result will be
       * reduced to 8 bits.
       */
      if ((png_ptr->transformations & (PNG_16_TO_8 | PNG_SCALE_16_TO_8)) != 0)
          png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,
          png_ptr->screen_gamma > 0 ? png_product2(png_ptr->colorspace.gamma,
          png_ptr->screen_gamma) : PNG_FP_1);

      else
          png_build_16bit_table(png_ptr, &png_ptr->gamma_16_table, shift,
          png_ptr->screen_gamma > 0 ? png_reciprocal2(png_ptr->colorspace.gamma,
          png_ptr->screen_gamma) : PNG_FP_1);

#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
      if ((png_ptr->transformations & (PNG_COMPOSE | PNG_RGB_TO_GRAY)) != 0)
      {
         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_to_1, shift,
             png_reciprocal(png_ptr->colorspace.gamma));

         /* Notice that the '16 from 1' table should be full precision, however
          * the lookup on this table still uses gamma_shift, so it can't be.
          * TODO: fix this.
          */
         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_from_1, shift,
             png_ptr->screen_gamma > 0 ? png_reciprocal(png_ptr->screen_gamma) :
             png_ptr->colorspace.gamma/* Probably doing rgb_to_gray */);
      }
#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
   }
#endif /* 16BIT */
}
#endif /* READ_GAMMA */

/* HARDWARE OR SOFTWARE OPTION SUPPORT */
#ifdef PNG_SET_OPTION_SUPPORTED
int PNGAPI
png_set_option(png_structrp png_ptr, int option, int onoff)
{
   if (png_ptr != NULL && option >= 0 && option < PNG_OPTION_NEXT &&
      (option & 1) == 0)
   {
      png_uint_32 mask = 3 << option;
      png_uint_32 setting = (2 + (onoff != 0)) << option;
      png_uint_32 current = png_ptr->options;

      png_ptr->options = (png_uint_32)(((current & ~mask) | setting) & 0xff);

      return (current & mask) >> option;
   }

   return PNG_OPTION_INVALID;
}
#endif

/* sRGB support */
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\
   defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)
/* sRGB conversion tables; these are machine generated with the code in
 * contrib/tools/makesRGB.c.  The actual sRGB transfer curve defined in the
 * specification (see the article at http://en.wikipedia.org/wiki/SRGB)
 * is used, not the gamma=1/2.2 approximation use elsewhere in libpng.
 * The sRGB to linear table is exact (to the nearest 16-bit linear fraction).
 * The inverse (linear to sRGB) table has accuracies as follows:
 *
 * For all possible (255*65535+1) input values:
 *
 *    error: -0.515566 - 0.625971, 79441 (0.475369%) of readings inexact
 *
 * For the input values corresponding to the 65536 16-bit values:
 *
 *    error: -0.513727 - 0.607759, 308 (0.469978%) of readings inexact
 *
 * In all cases the inexact readings are only off by one.
 */

#ifdef PNG_SIMPLIFIED_READ_SUPPORTED
/* The convert-to-sRGB table is only currently required for read. */
const png_uint_16 png_sRGB_table[256] =
{
   0,20,40,60,80,99,119,139,
   159,179,199,219,241,264,288,313,
   340,367,396,427,458,491,526,562,
   599,637,677,718,761,805,851,898,
   947,997,1048,1101,1156,1212,1270,1330,
   1391,1453,1517,1583,1651,1720,1790,1863,
   1937,2013,2090,2170,2250,2333,2418,2504,
   2592,2681,2773,2866,2961,3058,3157,3258,
   3360,3464,3570,3678,3788,3900,4014,4129,
   4247,4366,4488,4611,4736,4864,4993,5124,
   5257,5392,5530,5669,5810,5953,6099,6246,
   6395,6547,6700,6856,7014,7174,7335,7500,
   7666,7834,8004,8177,8352,8528,8708,8889,
   9072,9258,9445,9635,9828,10022,10219,10417,
   10619,10822,11028,11235,11446,11658,11873,12090,
   12309,12530,12754,12980,13209,13440,13673,13909,
   14146,14387,14629,14874,15122,15371,15623,15878,
   16135,16394,16656,16920,17187,17456,17727,18001,
   18277,18556,18837,19121,19407,19696,19987,20281,
   20577,20876,21177,21481,21787,22096,22407,22721,
   23038,23357,23678,24002,24329,24658,24990,25325,
   25662,26001,26344,26688,27036,27386,27739,28094,
   28452,28813,29176,29542,29911,30282,30656,31033,
   31412,31794,32179,32567,32957,33350,33745,34143,
   34544,34948,35355,35764,36176,36591,37008,37429,
   37852,38278,38706,39138,39572,40009,40449,40891,
   41337,41785,42236,42690,43147,43606,44069,44534,
   45002,45473,45947,46423,46903,47385,47871,48359,
   48850,49344,49841,50341,50844,51349,51858,52369,
   52884,53401,53921,54445,54971,55500,56032,56567,
   57105,57646,58190,58737,59287,59840,60396,60955,
   61517,62082,62650,63221,63795,64372,64952,65535
};
#endif /* SIMPLIFIED_READ */

/* The base/delta tables are required for both read and write (but currently
 * only the simplified versions.)
 */
const png_uint_16 png_sRGB_base[512] =
{
   128,1782,3383,4644,5675,6564,7357,8074,
   8732,9346,9921,10463,10977,11466,11935,12384,
   12816,13233,13634,14024,14402,14769,15125,15473,
   15812,16142,16466,16781,17090,17393,17690,17981,
   18266,18546,18822,19093,19359,19621,19879,20133,
   20383,20630,20873,21113,21349,21583,21813,22041,
   22265,22487,22707,22923,23138,23350,23559,23767,
   23972,24175,24376,24575,24772,24967,25160,25352,
   25542,25730,25916,26101,26284,26465,26645,26823,
   27000,27176,27350,27523,27695,27865,28034,28201,
   28368,28533,28697,28860,29021,29182,29341,29500,
   29657,29813,29969,30123,30276,30429,30580,30730,
   30880,31028,31176,31323,31469,31614,31758,31902,
   32045,32186,32327,32468,32607,32746,32884,33021,
   33158,33294,33429,33564,33697,33831,33963,34095,
   34226,34357,34486,34616,34744,34873,35000,35127,
   35253,35379,35504,35629,35753,35876,35999,36122,
   36244,36365,36486,36606,36726,36845,36964,37083,
   37201,37318,37435,37551,37668,37783,37898,38013,
   38127,38241,38354,38467,38580,38692,38803,38915,
   39026,39136,39246,39356,39465,39574,39682,39790,
   39898,40005,40112,40219,40325,40431,40537,40642,
   40747,40851,40955,41059,41163,41266,41369,41471,
   41573,41675,41777,41878,41979,42079,42179,42279,
   42379,42478,42577,42676,42775,42873,42971,43068,
   43165,43262,43359,43456,43552,43648,43743,43839,
   43934,44028,44123,44217,44311,44405,44499,44592,
   44685,44778,44870,44962,45054,45146,45238,45329,
   45420,45511,45601,45692,45782,45872,45961,46051,
   46140,46229,46318,46406,46494,46583,46670,46758,
   46846,46933,47020,47107,47193,47280,47366,47452,
   47538,47623,47709,47794,47879,47964,48048,48133,
   48217,48301,48385,48468,48552,48635,48718,48801,
   48884,48966,49048,49131,49213,49294,49376,49458,
   49539,49620,49701,49782,49862,49943,50023,50103,
   50183,50263,50342,50422,50501,50580,50659,50738,
   50816,50895,50973,51051,51129,51207,51285,51362,
   51439,51517,51594,51671,51747,51824,51900,51977,
   52053,52129,52205,52280,52356,52432,52507,52582,
   52657,52732,52807,52881,52956,53030,53104,53178,
   53252,53326,53400,53473,53546,53620,53693,53766,
   53839,53911,53984,54056,54129,54201,54273,54345,
   54417,54489,54560,54632,54703,54774,54845,54916,
   54987,55058,55129,55199,55269,55340,55410,55480,
   55550,55620,55689,55759,55828,55898,55967,56036,
   56105,56174,56243,56311,56380,56448,56517,56585,
   56653,56721,56789,56857,56924,56992,57059,57127,
   57194,57261,57328,57395,57462,57529,57595,57662,
   57728,57795,57861,57927,57993,58059,58125,58191,
   58256,58322,58387,58453,58518,58583,58648,58713,
   58778,58843,58908,58972,59037,59101,59165,59230,
   59294,59358,59422,59486,59549,59613,59677,59740,
   59804,59867,59930,59993,60056,60119,60182,60245,
   60308,60370,60433,60495,60558,60620,60682,60744,
   60806,60868,60930,60992,61054,61115,61177,61238,
   61300,61361,61422,61483,61544,61605,61666,61727,
   61788,61848,61909,61969,62030,62090,62150,62211,
   62271,62331,62391,62450,62510,62570,62630,62689,
   62749,62808,62867,62927,62986,63045,63104,63163,
   63222,63281,63340,63398,63457,63515,63574,63632,
   63691,63749,63807,63865,63923,63981,64039,64097,
   64155,64212,64270,64328,64385,64443,64500,64557,
   64614,64672,64729,64786,64843,64900,64956,65013,
   65070,65126,65183,65239,65296,65352,65409,65465
};

const png_byte png_sRGB_delta[512] =
{
   207,201,158,129,113,100,90,82,77,72,68,64,61,59,56,54,
   52,50,49,47,46,45,43,42,41,40,39,39,38,37,36,36,
   35,34,34,33,33,32,32,31,31,30,30,30,29,29,28,28,
   28,27,27,27,27,26,26,26,25,25,25,25,24,24,24,24,
   23,23,23,23,23,22,22,22,22,22,22,21,21,21,21,21,
   21,20,20,20,20,20,20,20,20,19,19,19,19,19,19,19,
   19,18,18,18,18,18,18,18,18,18,18,17,17,17,17,17,
   17,17,17,17,17,17,16,16,16,16,16,16,16,16,16,16,
   16,16,16,16,15,15,15,15,15,15,15,15,15,15,15,15,
   15,15,15,15,14,14,14,14,14,14,14,14,14,14,14,14,
   14,14,14,14,14,14,14,13,13,13,13,13,13,13,13,13,
   13,13,13,13,13,13,13,13,13,13,13,13,13,13,12,12,
   12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
   12,12,12,12,12,12,12,12,12,12,12,12,11,11,11,11,
   11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
   11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
   11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
   10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
   10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
   10,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
   9,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
   8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
   7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
};
#endif /* SIMPLIFIED READ/WRITE sRGB support */

/* SIMPLIFIED READ/WRITE SUPPORT */
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\
   defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)
static int
png_image_free_function(png_voidp argument)
{
   png_imagep image = png_voidcast(png_imagep, argument);
   png_controlp cp = image->opaque;
   png_control c;

   /* Double check that we have a png_ptr - it should be impossible to get here
    * without one.
    */
   if (cp->png_ptr == NULL)
      return 0;

   /* First free any data held in the control structure. */
#  ifdef PNG_STDIO_SUPPORTED
      if (cp->owned_file != 0)
      {
         FILE *fp = png_voidcast(FILE*, cp->png_ptr->io_ptr);
         cp->owned_file = 0;

         /* Ignore errors here. */
         if (fp != NULL)
         {
            cp->png_ptr->io_ptr = NULL;
            (void)fclose(fp);
         }
      }
#  endif

   /* Copy the control structure so that the original, allocated, version can be
    * safely freed.  Notice that a png_error here stops the remainder of the
    * cleanup, but this is probably fine because that would indicate bad memory
    * problems anyway.
    */
   c = *cp;
   image->opaque = &c;
   png_free(c.png_ptr, cp);

   /* Then the structures, calling the correct API. */
   if (c.for_write != 0)
   {
#     ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
         png_destroy_write_struct(&c.png_ptr, &c.info_ptr);
#     else
         png_error(c.png_ptr, "simplified write not supported");
#     endif
   }
   else
   {
#     ifdef PNG_SIMPLIFIED_READ_SUPPORTED
         png_destroy_read_struct(&c.png_ptr, &c.info_ptr, NULL);
#     else
         png_error(c.png_ptr, "simplified read not supported");
#     endif
   }

   /* Success. */
   return 1;
}

void PNGAPI
png_image_free(png_imagep image)
{
   /* Safely call the real function, but only if doing so is safe at this point
    * (if not inside an error handling context).  Otherwise assume
    * png_safe_execute will call this API after the return.
    */
   if (image != NULL && image->opaque != NULL &&
      image->opaque->error_buf == NULL)
   {
      /* Ignore errors here: */
      (void)png_safe_execute(image, png_image_free_function, image);
      image->opaque = NULL;
   }
}

int /* PRIVATE */
png_image_error(png_imagep image, png_const_charp error_message)
{
   /* Utility to log an error. */
   png_safecat(image->message, (sizeof image->message), 0, error_message);
   image->warning_or_error |= PNG_IMAGE_ERROR;
   png_image_free(image);
   return 0;
}

#endif /* SIMPLIFIED READ/WRITE */
#endif /* READ || WRITE */

```

`ThirdPartyBuild/PNG/Code/png.h`:

```h

/* png.h - header file for PNG reference library
 *
 * libpng version 1.6.28, January 5, 2017
 *
 * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license (See LICENSE, below)
 *
 * Authors and maintainers:
 *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
 *   libpng versions 0.89, June 1996, through 0.96, May 1997: Andreas Dilger
 *   libpng versions 0.97, January 1998, through 1.6.28, January 5, 2017:
 *     Glenn Randers-Pehrson.
 *   See also "Contributing Authors", below.
 */

/*
 * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
 *
 * If you modify libpng you may insert additional notices immediately following
 * this sentence.
 *
 * This code is released under the libpng license.
 *
 * libpng versions 1.0.7, July 1, 2000 through 1.6.28, January 5, 2017 are
 * Copyright (c) 2000-2002, 2004, 2006-2017 Glenn Randers-Pehrson, are
 * derived from libpng-1.0.6, and are distributed according to the same
 * disclaimer and license as libpng-1.0.6 with the following individuals
 * added to the list of Contributing Authors:
 *
 *    Simon-Pierre Cadieux
 *    Eric S. Raymond
 *    Mans Rullgard
 *    Cosmin Truta
 *    Gilles Vollant
 *    James Yu
 *    Mandar Sahastrabuddhe
 *
 * and with the following additions to the disclaimer:
 *
 *    There is no warranty against interference with your enjoyment of the
 *    library or against infringement.  There is no warranty that our
 *    efforts or the library will fulfill any of your particular purposes
 *    or needs.  This library is provided with all faults, and the entire
 *    risk of satisfactory quality, performance, accuracy, and effort is with
 *    the user.
 *
 * Some files in the "contrib" directory and some configure-generated
 * files that are distributed with libpng have other copyright owners and
 * are released under other open source licenses.
 *
 * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
 * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from
 * libpng-0.96, and are distributed according to the same disclaimer and
 * license as libpng-0.96, with the following individuals added to the list
 * of Contributing Authors:
 *
 *    Tom Lane
 *    Glenn Randers-Pehrson
 *    Willem van Schaik
 *
 * libpng versions 0.89, June 1996, through 0.96, May 1997, are
 * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,
 * and are distributed according to the same disclaimer and license as
 * libpng-0.88, with the following individuals added to the list of
 * Contributing Authors:
 *
 *    John Bowler
 *    Kevin Bracey
 *    Sam Bushell
 *    Magnus Holmgren
 *    Greg Roelofs
 *    Tom Tanner
 *
 * Some files in the "scripts" directory have other copyright owners
 * but are released under this license.
 *
 * libpng versions 0.5, May 1995, through 0.88, January 1996, are
 * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
 *
 * For the purposes of this copyright and license, "Contributing Authors"
 * is defined as the following set of individuals:
 *
 *    Andreas Dilger
 *    Dave Martindale
 *    Guy Eric Schalnat
 *    Paul Schmidt
 *    Tim Wegner
 *
 * The PNG Reference Library is supplied "AS IS".  The Contributing Authors
 * and Group 42, Inc. disclaim all warranties, expressed or implied,
 * including, without limitation, the warranties of merchantability and of
 * fitness for any purpose.  The Contributing Authors and Group 42, Inc.
 * assume no liability for direct, indirect, incidental, special, exemplary,
 * or consequential damages, which may result from the use of the PNG
 * Reference Library, even if advised of the possibility of such damage.
 *
 * Permission is hereby granted to use, copy, modify, and distribute this
 * source code, or portions hereof, for any purpose, without fee, subject
 * to the following restrictions:
 *
 *   1. The origin of this source code must not be misrepresented.
 *
 *   2. Altered versions must be plainly marked as such and must not
 *      be misrepresented as being the original source.
 *
 *   3. This Copyright notice may not be removed or altered from any
 *      source or altered source distribution.
 *
 * The Contributing Authors and Group 42, Inc. specifically permit, without
 * fee, and encourage the use of this source code as a component to
 * supporting the PNG file format in commercial products.  If you use this
 * source code in a product, acknowledgment is not required but would be
 * appreciated.
 *
 * END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.
 *
 * TRADEMARK:
 *
 * The name "libpng" has not been registered by the Copyright owner
 * as a trademark in any jurisdiction.  However, because libpng has
 * been distributed and maintained world-wide, continually since 1995,
 * the Copyright owner claims "common-law trademark protection" in any
 * jurisdiction where common-law trademark is recognized.
 *
 * OSI CERTIFICATION:
 *
 * Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is
 * a certification mark of the Open Source Initiative. OSI has not addressed
 * the additional disclaimers inserted at version 1.0.7.
 *
 * EXPORT CONTROL:
 *
 * The Copyright owner believes that the Export Control Classification
 * Number (ECCN) for libpng is EAR99, which means not subject to export
 * controls or International Traffic in Arms Regulations (ITAR) because
 * it is open source, publicly available software, that does not contain
 * any encryption software.  See the EAR, paragraphs 734.3(b)(3) and
 * 734.7(b).
 */

/*
 * A "png_get_copyright" function is available, for convenient use in "about"
 * boxes and the like:
 *
 *    printf("%s", png_get_copyright(NULL));
 *
 * Also, the PNG logo (in PNG format, of course) is supplied in the
 * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
 */

/*
 * The contributing authors would like to thank all those who helped
 * with testing, bug fixes, and patience.  This wouldn't have been
 * possible without all of you.
 *
 * Thanks to Frank J. T. Wojcik for helping with the documentation.
 */

/* Note about libpng version numbers:
 *
 *    Due to various miscommunications, unforeseen code incompatibilities
 *    and occasional factors outside the authors' control, version numbering
 *    on the library has not always been consistent and straightforward.
 *    The following table summarizes matters since version 0.89c, which was
 *    the first widely used release:
 *
 *    source                 png.h  png.h  shared-lib
 *    version                string   int  version
 *    -------                ------ -----  ----------
 *    0.89c "1.0 beta 3"     0.89      89  1.0.89
 *    0.90  "1.0 beta 4"     0.90      90  0.90  [should have been 2.0.90]
 *    0.95  "1.0 beta 5"     0.95      95  0.95  [should have been 2.0.95]
 *    0.96  "1.0 beta 6"     0.96      96  0.96  [should have been 2.0.96]
 *    0.97b "1.00.97 beta 7" 1.00.97   97  1.0.1 [should have been 2.0.97]
 *    0.97c                  0.97      97  2.0.97
 *    0.98                   0.98      98  2.0.98
 *    0.99                   0.99      98  2.0.99
 *    0.99a-m                0.99      99  2.0.99
 *    1.00                   1.00     100  2.1.0 [100 should be 10000]
 *    1.0.0      (from here on, the   100  2.1.0 [100 should be 10000]
 *    1.0.1       png.h string is   10001  2.1.0
 *    1.0.1a-e    identical to the  10002  from here on, the shared library
 *    1.0.2       source version)   10002  is 2.V where V is the source code
 *    1.0.2a-b                      10003  version, except as noted.
 *    1.0.3                         10003
 *    1.0.3a-d                      10004
 *    1.0.4                         10004
 *    1.0.4a-f                      10005
 *    1.0.5 (+ 2 patches)           10005
 *    1.0.5a-d                      10006
 *    1.0.5e-r                      10100 (not source compatible)
 *    1.0.5s-v                      10006 (not binary compatible)
 *    1.0.6 (+ 3 patches)           10006 (still binary incompatible)
 *    1.0.6d-f                      10007 (still binary incompatible)
 *    1.0.6g                        10007
 *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)
 *    1.0.6i                        10007  10.6i
 *    1.0.6j                        10007  2.1.0.6j (incompatible with 1.0.0)
 *    1.0.7beta11-14        DLLNUM  10007  2.1.0.7beta11-14 (binary compatible)
 *    1.0.7beta15-18           1    10007  2.1.0.7beta15-18 (binary compatible)
 *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)
 *    1.0.7                    1    10007  (still compatible)
 *    ...
 *    1.0.19                  10    10019  10.so.0.19[.0]
 *    ...
 *    1.2.57                  13    10257  12.so.0.57[.0]
 *    ...
 *    1.5.28                  15    10527  15.so.15.28[.0]
 *    ...
 *    1.6.28                  16    10628  16.so.16.28[.0]
 *
 *    Henceforth the source version will match the shared-library major
 *    and minor numbers; the shared-library major version number will be
 *    used for changes in backward compatibility, as it is intended.  The
 *    PNG_LIBPNG_VER macro, which is not used within libpng but is available
 *    for applications, is an unsigned integer of the form xyyzz corresponding
 *    to the source version x.y.z (leading zeros in y and z).  Beta versions
 *    were given the previous public release number plus a letter, until
 *    version 1.0.6j; from then on they were given the upcoming public
 *    release number plus "betaNN" or "rcNN".
 *
 *    Binary incompatibility exists only when applications make direct access
 *    to the info_ptr or png_ptr members through png.h, and the compiled
 *    application is loaded with a different version of the library.
 *
 *    DLLNUM will change each time there are forward or backward changes
 *    in binary compatibility (e.g., when a new feature is added).
 *
 * See libpng.txt or libpng.3 for more information.  The PNG specification
 * is available as a W3C Recommendation and as an ISO Specification,
 * <http://www.w3.org/TR/2003/REC-PNG-20031110/
 */

/*
 * Y2K compliance in libpng:
 * =========================
 *
 *    January 5, 2017
 *
 *    Since the PNG Development group is an ad-hoc body, we can't make
 *    an official declaration.
 *
 *    This is your unofficial assurance that libpng from version 0.71 and
 *    upward through 1.6.28 are Y2K compliant.  It is my belief that
 *    earlier versions were also Y2K compliant.
 *
 *    Libpng only has two year fields.  One is a 2-byte unsigned integer
 *    that will hold years up to 65535.  The other, which is deprecated,
 *    holds the date in text format, and will hold years up to 9999.
 *
 *    The integer is
 *        "png_uint_16 year" in png_time_struct.
 *
 *    The string is
 *        "char time_buffer[29]" in png_struct.  This is no longer used
 *    in libpng-1.6.x and will be removed from libpng-1.7.0.
 *
 *    There are seven time-related functions:
 *        png.c: png_convert_to_rfc_1123_buffer() in png.c
 *          (formerly png_convert_to_rfc_1123() prior to libpng-1.5.x and
 *          png_convert_to_rfc_1152() in error prior to libpng-0.98)
 *        png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c
 *        png_convert_from_time_t() in pngwrite.c
 *        png_get_tIME() in pngget.c
 *        png_handle_tIME() in pngrutil.c, called in pngread.c
 *        png_set_tIME() in pngset.c
 *        png_write_tIME() in pngwutil.c, called in pngwrite.c
 *
 *    All handle dates properly in a Y2K environment.  The
 *    png_convert_from_time_t() function calls gmtime() to convert from system
 *    clock time, which returns (year - 1900), which we properly convert to
 *    the full 4-digit year.  There is a possibility that libpng applications
 *    are not passing 4-digit years into the png_convert_to_rfc_1123_buffer()
 *    function, or that they are incorrectly passing only a 2-digit year
 *    instead of "year - 1900" into the png_convert_from_struct_tm() function,
 *    but this is not under our control.  The libpng documentation has always
 *    stated that it works with 4-digit years, and the APIs have been
 *    documented as such.
 *
 *    The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
 *    integer to hold the year, and can hold years as large as 65535.
 *
 *    zlib, upon which libpng depends, is also Y2K compliant.  It contains
 *    no date-related code.
 *
 *       Glenn Randers-Pehrson
 *       libpng maintainer
 *       PNG Development Group
 */

#ifndef PNG_H
#define PNG_H

/* This is not the place to learn how to use libpng. The file libpng-manual.txt
 * describes how to use libpng, and the file example.c summarizes it
 * with some code on which to build.  This file is useful for looking
 * at the actual function definitions and structure components.  If that
 * file has been stripped from your copy of libpng, you can find it at
 * <http://www.libpng.org/pub/png/libpng-manual.txt>
 *
 * If you just need to read a PNG file and don't want to read the documentation
 * skip to the end of this file and read the section entitled 'simplified API'.
 */

/* Version information for png.h - this should match the version in png.c */
#define PNG_LIBPNG_VER_STRING "1.6.28"
#define PNG_HEADER_VERSION_STRING " libpng version 1.6.28 - January 5, 2017\n"

#define PNG_LIBPNG_VER_SONUM   16
#define PNG_LIBPNG_VER_DLLNUM  16

/* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
#define PNG_LIBPNG_VER_MAJOR   1
#define PNG_LIBPNG_VER_MINOR   6
#define PNG_LIBPNG_VER_RELEASE 28

/* This should match the numeric part of the final component of
 * PNG_LIBPNG_VER_STRING, omitting any leading zero:
 */

#define PNG_LIBPNG_VER_BUILD  0

/* Release Status */
#define PNG_LIBPNG_BUILD_ALPHA    1
#define PNG_LIBPNG_BUILD_BETA     2
#define PNG_LIBPNG_BUILD_RC       3
#define PNG_LIBPNG_BUILD_STABLE   4
#define PNG_LIBPNG_BUILD_RELEASE_STATUS_MASK 7

/* Release-Specific Flags */
#define PNG_LIBPNG_BUILD_PATCH    8 /* Can be OR'ed with
                                       PNG_LIBPNG_BUILD_STABLE only */
#define PNG_LIBPNG_BUILD_PRIVATE 16 /* Cannot be OR'ed with
                                       PNG_LIBPNG_BUILD_SPECIAL */
#define PNG_LIBPNG_BUILD_SPECIAL 32 /* Cannot be OR'ed with
                                       PNG_LIBPNG_BUILD_PRIVATE */

#define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_STABLE

/* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
 * We must not include leading zeros.
 * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
 * version 1.0.0 was mis-numbered 100 instead of 10000).  From
 * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
 */
#define PNG_LIBPNG_VER 10628 /* 1.6.28 */

/* Library configuration: these options cannot be changed after
 * the library has been built.
 */
#ifndef PNGLCONF_H
/* If pnglibconf.h is missing, you can
 * copy scripts/pnglibconf.h.prebuilt to pnglibconf.h
 */
#   include "pnglibconf.h"
#endif

#ifndef PNG_VERSION_INFO_ONLY
/* Machine specific configuration. */
#  include "pngconf.h"
#endif

/*
 * Added at libpng-1.2.8
 *
 * Ref MSDN: Private as priority over Special
 * VS_FF_PRIVATEBUILD File *was not* built using standard release
 * procedures. If this value is given, the StringFileInfo block must
 * contain a PrivateBuild string.
 *
 * VS_FF_SPECIALBUILD File *was* built by the original company using
 * standard release procedures but is a variation of the standard
 * file of the same version number. If this value is given, the
 * StringFileInfo block must contain a SpecialBuild string.
 */

#ifdef PNG_USER_PRIVATEBUILD /* From pnglibconf.h */
#  define PNG_LIBPNG_BUILD_TYPE \
       (PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_PRIVATE)
#else
#  ifdef PNG_LIBPNG_SPECIALBUILD
#    define PNG_LIBPNG_BUILD_TYPE \
         (PNG_LIBPNG_BUILD_BASE_TYPE | PNG_LIBPNG_BUILD_SPECIAL)
#  else
#    define PNG_LIBPNG_BUILD_TYPE (PNG_LIBPNG_BUILD_BASE_TYPE)
#  endif
#endif

#ifndef PNG_VERSION_INFO_ONLY

/* Inhibit C++ name-mangling for libpng functions but not for system calls. */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* Version information for C files, stored in png.c.  This had better match
 * the version above.
 */
#define png_libpng_ver png_get_header_ver(NULL)

/* This file is arranged in several sections:
 *
 * 1. [omitted]
 * 2. Any configuration options that can be specified by for the application
 *    code when it is built.  (Build time configuration is in pnglibconf.h)
 * 3. Type definitions (base types are defined in pngconf.h), structure
 *    definitions.
 * 4. Exported library functions.
 * 5. Simplified API.
 * 6. Implementation options.
 *
 * The library source code has additional files (principally pngpriv.h) that
 * allow configuration of the library.
 */

/* Section 1: [omitted] */

/* Section 2: run time configuration
 * See pnglibconf.h for build time configuration
 *
 * Run time configuration allows the application to choose between
 * implementations of certain arithmetic APIs.  The default is set
 * at build time and recorded in pnglibconf.h, but it is safe to
 * override these (and only these) settings.  Note that this won't
 * change what the library does, only application code, and the
 * settings can (and probably should) be made on a per-file basis
 * by setting the #defines before including png.h
 *
 * Use macros to read integers from PNG data or use the exported
 * functions?
 *   PNG_USE_READ_MACROS: use the macros (see below)  Note that
 *     the macros evaluate their argument multiple times.
 *   PNG_NO_USE_READ_MACROS: call the relevant library function.
 *
 * Use the alternative algorithm for compositing alpha samples that
 * does not use division?
 *   PNG_READ_COMPOSITE_NODIV_SUPPORTED: use the 'no division'
 *      algorithm.
 *   PNG_NO_READ_COMPOSITE_NODIV: use the 'division' algorithm.
 *
 * How to handle benign errors if PNG_ALLOW_BENIGN_ERRORS is
 * false?
 *   PNG_ALLOW_BENIGN_ERRORS: map calls to the benign error
 *      APIs to png_warning.
 * Otherwise the calls are mapped to png_error.
 */

/* Section 3: type definitions, including structures and compile time
 * constants.
 * See pngconf.h for base types that vary by machine/system
 */

/* This triggers a compiler error in png.c, if png.c and png.h
 * do not agree upon the version number.
 */
typedef char* png_libpng_version_1_6_28;

/* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.
 *
 * png_struct is the cache of information used while reading or writing a single
 * PNG file.  One of these is always required, although the simplified API
 * (below) hides the creation and destruction of it.
 */
typedef struct png_struct_def png_struct;
typedef const png_struct * png_const_structp;
typedef png_struct * png_structp;
typedef png_struct * * png_structpp;

/* png_info contains information read from or to be written to a PNG file.  One
 * or more of these must exist while reading or creating a PNG file.  The
 * information is not used by libpng during read but is used to control what
 * gets written when a PNG file is created.  "png_get_" function calls read
 * information during read and "png_set_" functions calls write information
 * when creating a PNG.
 * been moved into a separate header file that is not accessible to
 * applications.  Read libpng-manual.txt or libpng.3 for more info.
 */
typedef struct png_info_def png_info;
typedef png_info * png_infop;
typedef const png_info * png_const_infop;
typedef png_info * * png_infopp;

/* Types with names ending 'p' are pointer types.  The corresponding types with
 * names ending 'rp' are identical pointer types except that the pointer is
 * marked 'restrict', which means that it is the only pointer to the object
 * passed to the function.  Applications should not use the 'restrict' types;
 * it is always valid to pass 'p' to a pointer with a function argument of the
 * corresponding 'rp' type.  Different compilers have different rules with
 * regard to type matching in the presence of 'restrict'.  For backward
 * compatibility libpng callbacks never have 'restrict' in their parameters and,
 * consequentially, writing portable application code is extremely difficult if
 * an attempt is made to use 'restrict'.
 */
typedef png_struct * PNG_RESTRICT png_structrp;
typedef const png_struct * PNG_RESTRICT png_const_structrp;
typedef png_info * PNG_RESTRICT png_inforp;
typedef const png_info * PNG_RESTRICT png_const_inforp;

/* Three color definitions.  The order of the red, green, and blue, (and the
 * exact size) is not important, although the size of the fields need to
 * be png_byte or png_uint_16 (as defined below).
 */
typedef struct png_color_struct
{
   png_byte red;
   png_byte green;
   png_byte blue;
} png_color;
typedef png_color * png_colorp;
typedef const png_color * png_const_colorp;
typedef png_color * * png_colorpp;

typedef struct png_color_16_struct
{
   png_byte index;    /* used for palette files */
   png_uint_16 red;   /* for use in red green blue files */
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 gray;  /* for use in grayscale files */
} png_color_16;
typedef png_color_16 * png_color_16p;
typedef const png_color_16 * png_const_color_16p;
typedef png_color_16 * * png_color_16pp;

typedef struct png_color_8_struct
{
   png_byte red;   /* for use in red green blue files */
   png_byte green;
   png_byte blue;
   png_byte gray;  /* for use in grayscale files */
   png_byte alpha; /* for alpha channel files */
} png_color_8;
typedef png_color_8 * png_color_8p;
typedef const png_color_8 * png_const_color_8p;
typedef png_color_8 * * png_color_8pp;

/*
 * The following two structures are used for the in-core representation
 * of sPLT chunks.
 */
typedef struct png_sPLT_entry_struct
{
   png_uint_16 red;
   png_uint_16 green;
   png_uint_16 blue;
   png_uint_16 alpha;
   png_uint_16 frequency;
} png_sPLT_entry;
typedef png_sPLT_entry * png_sPLT_entryp;
typedef const png_sPLT_entry * png_const_sPLT_entryp;
typedef png_sPLT_entry * * png_sPLT_entrypp;

/*  When the depth of the sPLT palette is 8 bits, the color and alpha samples
 *  occupy the LSB of their respective members, and the MSB of each member
 *  is zero-filled.  The frequency member always occupies the full 16 bits.
 */

typedef struct png_sPLT_struct
{
   png_charp name;           /* palette name */
   png_byte depth;           /* depth of palette samples */
   png_sPLT_entryp entries;  /* palette entries */
   png_int_32 nentries;      /* number of palette entries */
} png_sPLT_t;
typedef png_sPLT_t * png_sPLT_tp;
typedef const png_sPLT_t * png_const_sPLT_tp;
typedef png_sPLT_t * * png_sPLT_tpp;

#ifdef PNG_TEXT_SUPPORTED
/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,
 * and whether that contents is compressed or not.  The "key" field
 * points to a regular zero-terminated C string.  The "text" fields can be a
 * regular C string, an empty string, or a NULL pointer.
 * However, the structure returned by png_get_text() will always contain
 * the "text" field as a regular zero-terminated C string (possibly
 * empty), never a NULL pointer, so it can be safely used in printf() and
 * other string-handling functions.  Note that the "itxt_length", "lang", and
 * "lang_key" members of the structure only exist when the library is built
 * with iTXt chunk support.  Prior to libpng-1.4.0 the library was built by
 * default without iTXt support. Also note that when iTXt *is* supported,
 * the "lang" and "lang_key" fields contain NULL pointers when the
 * "compression" field contains * PNG_TEXT_COMPRESSION_NONE or
 * PNG_TEXT_COMPRESSION_zTXt. Note that the "compression value" is not the
 * same as what appears in the PNG tEXt/zTXt/iTXt chunk's "compression flag"
 * which is always 0 or 1, or its "compression method" which is always 0.
 */
typedef struct png_text_struct
{
   int  compression;       /* compression value:
                             -1: tEXt, none
                              0: zTXt, deflate
                              1: iTXt, none
                              2: iTXt, deflate  */
   png_charp key;          /* keyword, 1-79 character description of "text" */
   png_charp text;         /* comment, may be an empty string (ie "")
                              or a NULL pointer */
   png_size_t text_length; /* length of the text string */
   png_size_t itxt_length; /* length of the itxt string */
   png_charp lang;         /* language code, 0-79 characters
                              or a NULL pointer */
   png_charp lang_key;     /* keyword translated UTF-8 string, 0 or more
                              chars or a NULL pointer */
} png_text;
typedef png_text * png_textp;
typedef const png_text * png_const_textp;
typedef png_text * * png_textpp;
#endif

/* Supported compression types for text in PNG files (tEXt, and zTXt).
 * The values of the PNG_TEXT_COMPRESSION_ defines should NOT be changed. */
#define PNG_TEXT_COMPRESSION_NONE_WR -3
#define PNG_TEXT_COMPRESSION_zTXt_WR -2
#define PNG_TEXT_COMPRESSION_NONE    -1
#define PNG_TEXT_COMPRESSION_zTXt     0
#define PNG_ITXT_COMPRESSION_NONE     1
#define PNG_ITXT_COMPRESSION_zTXt     2
#define PNG_TEXT_COMPRESSION_LAST     3  /* Not a valid value */

/* png_time is a way to hold the time in an machine independent way.
 * Two conversions are provided, both from time_t and struct tm.  There
 * is no portable way to convert to either of these structures, as far
 * as I know.  If you know of a portable way, send it to me.  As a side
 * note - PNG has always been Year 2000 compliant!
 */
typedef struct png_time_struct
{
   png_uint_16 year; /* full year, as in, 1995 */
   png_byte month;   /* month of year, 1 - 12 */
   png_byte day;     /* day of month, 1 - 31 */
   png_byte hour;    /* hour of day, 0 - 23 */
   png_byte minute;  /* minute of hour, 0 - 59 */
   png_byte second;  /* second of minute, 0 - 60 (for leap seconds) */
} png_time;
typedef png_time * png_timep;
typedef const png_time * png_const_timep;
typedef png_time * * png_timepp;

#if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) ||\
   defined(PNG_USER_CHUNKS_SUPPORTED)
/* png_unknown_chunk is a structure to hold queued chunks for which there is
 * no specific support.  The idea is that we can use this to queue
 * up private chunks for output even though the library doesn't actually
 * know about their semantics.
 *
 * The data in the structure is set by libpng on read and used on write.
 */
typedef struct png_unknown_chunk_t
{
   png_byte name[5]; /* Textual chunk name with '\0' terminator */
   png_byte *data;   /* Data, should not be modified on read! */
   png_size_t size;

   /* On write 'location' must be set using the flag values listed below.
    * Notice that on read it is set by libpng however the values stored have
    * more bits set than are listed below.  Always treat the value as a
    * bitmask.  On write set only one bit - setting multiple bits may cause the
    * chunk to be written in multiple places.
    */
   png_byte location; /* mode of operation at read time */
}
png_unknown_chunk;

typedef png_unknown_chunk * png_unknown_chunkp;
typedef const png_unknown_chunk * png_const_unknown_chunkp;
typedef png_unknown_chunk * * png_unknown_chunkpp;
#endif

/* Flag values for the unknown chunk location byte. */
#define PNG_HAVE_IHDR  0x01
#define PNG_HAVE_PLTE  0x02
#define PNG_AFTER_IDAT 0x08

/* Maximum positive integer used in PNG is (2^31)-1 */
#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
#define PNG_UINT_32_MAX ((png_uint_32)(-1))
#define PNG_SIZE_MAX ((png_size_t)(-1))

/* These are constants for fixed point values encoded in the
 * PNG specification manner (x100000)
 */
#define PNG_FP_1    100000
#define PNG_FP_HALF  50000
#define PNG_FP_MAX  ((png_fixed_point)0x7fffffffL)
#define PNG_FP_MIN  (-PNG_FP_MAX)

/* These describe the color_type field in png_info. */
/* color type masks */
#define PNG_COLOR_MASK_PALETTE    1
#define PNG_COLOR_MASK_COLOR      2
#define PNG_COLOR_MASK_ALPHA      4

/* color types.  Note that not all combinations are legal */
#define PNG_COLOR_TYPE_GRAY 0
#define PNG_COLOR_TYPE_PALETTE  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_PALETTE)
#define PNG_COLOR_TYPE_RGB        (PNG_COLOR_MASK_COLOR)
#define PNG_COLOR_TYPE_RGB_ALPHA  (PNG_COLOR_MASK_COLOR | PNG_COLOR_MASK_ALPHA)
#define PNG_COLOR_TYPE_GRAY_ALPHA (PNG_COLOR_MASK_ALPHA)
/* aliases */
#define PNG_COLOR_TYPE_RGBA  PNG_COLOR_TYPE_RGB_ALPHA
#define PNG_COLOR_TYPE_GA  PNG_COLOR_TYPE_GRAY_ALPHA

/* This is for compression type. PNG 1.0-1.2 only define the single type. */
#define PNG_COMPRESSION_TYPE_BASE 0 /* Deflate method 8, 32K window */
#define PNG_COMPRESSION_TYPE_DEFAULT PNG_COMPRESSION_TYPE_BASE

/* This is for filter type. PNG 1.0-1.2 only define the single type. */
#define PNG_FILTER_TYPE_BASE      0 /* Single row per-byte filtering */
#define PNG_INTRAPIXEL_DIFFERENCING 64 /* Used only in MNG datastreams */
#define PNG_FILTER_TYPE_DEFAULT   PNG_FILTER_TYPE_BASE

/* These are for the interlacing type.  These values should NOT be changed. */
#define PNG_INTERLACE_NONE        0 /* Non-interlaced image */
#define PNG_INTERLACE_ADAM7       1 /* Adam7 interlacing */
#define PNG_INTERLACE_LAST        2 /* Not a valid value */

/* These are for the oFFs chunk.  These values should NOT be changed. */
#define PNG_OFFSET_PIXEL          0 /* Offset in pixels */
#define PNG_OFFSET_MICROMETER     1 /* Offset in micrometers (1/10^6 meter) */
#define PNG_OFFSET_LAST           2 /* Not a valid value */

/* These are for the pCAL chunk.  These values should NOT be changed. */
#define PNG_EQUATION_LINEAR       0 /* Linear transformation */
#define PNG_EQUATION_BASE_E       1 /* Exponential base e transform */
#define PNG_EQUATION_ARBITRARY    2 /* Arbitrary base exponential transform */
#define PNG_EQUATION_HYPERBOLIC   3 /* Hyperbolic sine transformation */
#define PNG_EQUATION_LAST         4 /* Not a valid value */

/* These are for the sCAL chunk.  These values should NOT be changed. */
#define PNG_SCALE_UNKNOWN         0 /* unknown unit (image scale) */
#define PNG_SCALE_METER           1 /* meters per pixel */
#define PNG_SCALE_RADIAN          2 /* radians per pixel */
#define PNG_SCALE_LAST            3 /* Not a valid value */

/* These are for the pHYs chunk.  These values should NOT be changed. */
#define PNG_RESOLUTION_UNKNOWN    0 /* pixels/unknown unit (aspect ratio) */
#define PNG_RESOLUTION_METER      1 /* pixels/meter */
#define PNG_RESOLUTION_LAST       2 /* Not a valid value */

/* These are for the sRGB chunk.  These values should NOT be changed. */
#define PNG_sRGB_INTENT_PERCEPTUAL 0
#define PNG_sRGB_INTENT_RELATIVE   1
#define PNG_sRGB_INTENT_SATURATION 2
#define PNG_sRGB_INTENT_ABSOLUTE   3
#define PNG_sRGB_INTENT_LAST       4 /* Not a valid value */

/* This is for text chunks */
#define PNG_KEYWORD_MAX_LENGTH     79

/* Maximum number of entries in PLTE/sPLT/tRNS arrays */
#define PNG_MAX_PALETTE_LENGTH    256

/* These determine if an ancillary chunk's data has been successfully read
 * from the PNG header, or if the application has filled in the corresponding
 * data in the info_struct to be written into the output file.  The values
 * of the PNG_INFO_<chunk> defines should NOT be changed.
 */
#define PNG_INFO_gAMA 0x0001U
#define PNG_INFO_sBIT 0x0002U
#define PNG_INFO_cHRM 0x0004U
#define PNG_INFO_PLTE 0x0008U
#define PNG_INFO_tRNS 0x0010U
#define PNG_INFO_bKGD 0x0020U
#define PNG_INFO_hIST 0x0040U
#define PNG_INFO_pHYs 0x0080U
#define PNG_INFO_oFFs 0x0100U
#define PNG_INFO_tIME 0x0200U
#define PNG_INFO_pCAL 0x0400U
#define PNG_INFO_sRGB 0x0800U  /* GR-P, 0.96a */
#define PNG_INFO_iCCP 0x1000U  /* ESR, 1.0.6 */
#define PNG_INFO_sPLT 0x2000U  /* ESR, 1.0.6 */
#define PNG_INFO_sCAL 0x4000U  /* ESR, 1.0.6 */
#define PNG_INFO_IDAT 0x8000U  /* ESR, 1.0.6 */

/* This is used for the transformation routines, as some of them
 * change these values for the row.  It also should enable using
 * the routines for other purposes.
 */
typedef struct png_row_info_struct
{
   png_uint_32 width;    /* width of row */
   png_size_t rowbytes;  /* number of bytes in row */
   png_byte color_type;  /* color type of row */
   png_byte bit_depth;   /* bit depth of row */
   png_byte channels;    /* number of channels (1, 2, 3, or 4) */
   png_byte pixel_depth; /* bits per pixel (depth * channels) */
} png_row_info;

typedef png_row_info * png_row_infop;
typedef png_row_info * * png_row_infopp;

/* These are the function types for the I/O functions and for the functions
 * that allow the user to override the default I/O functions with his or her
 * own.  The png_error_ptr type should match that of user-supplied warning
 * and error functions, while the png_rw_ptr type should match that of the
 * user read/write data functions.  Note that the 'write' function must not
 * modify the buffer it is passed. The 'read' function, on the other hand, is
 * expected to return the read data in the buffer.
 */
typedef PNG_CALLBACK(void, *png_error_ptr, (png_structp, png_const_charp));
typedef PNG_CALLBACK(void, *png_rw_ptr, (png_structp, png_bytep, png_size_t));
typedef PNG_CALLBACK(void, *png_flush_ptr, (png_structp));
typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32,
    int));
typedef PNG_CALLBACK(void, *png_write_status_ptr, (png_structp, png_uint_32,
    int));

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
typedef PNG_CALLBACK(void, *png_progressive_info_ptr, (png_structp, png_infop));
typedef PNG_CALLBACK(void, *png_progressive_end_ptr, (png_structp, png_infop));

/* The following callback receives png_uint_32 row_number, int pass for the
 * png_bytep data of the row.  When transforming an interlaced image the
 * row number is the row number within the sub-image of the interlace pass, so
 * the value will increase to the height of the sub-image (not the full image)
 * then reset to 0 for the next pass.
 *
 * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
 * find the output pixel (x,y) given an interlaced sub-image pixel
 * (row,col,pass).  (See below for these macros.)
 */
typedef PNG_CALLBACK(void, *png_progressive_row_ptr, (png_structp, png_bytep,
    png_uint_32, int));
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
typedef PNG_CALLBACK(void, *png_user_transform_ptr, (png_structp, png_row_infop,
    png_bytep));
#endif

#ifdef PNG_USER_CHUNKS_SUPPORTED
typedef PNG_CALLBACK(int, *png_user_chunk_ptr, (png_structp,
    png_unknown_chunkp));
#endif
#ifdef PNG_UNKNOWN_CHUNKS_SUPPORTED
/* not used anywhere */
/* typedef PNG_CALLBACK(void, *png_unknown_chunk_ptr, (png_structp)); */
#endif

#ifdef PNG_SETJMP_SUPPORTED
/* This must match the function definition in <setjmp.h>, and the application
 * must include this before png.h to obtain the definition of jmp_buf.  The
 * function is required to be PNG_NORETURN, but this is not checked.  If the
 * function does return the application will crash via an abort() or similar
 * system level call.
 *
 * If you get a warning here while building the library you may need to make
 * changes to ensure that pnglibconf.h records the calling convention used by
 * your compiler.  This may be very difficult - try using a different compiler
 * to build the library!
 */
PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), PNGARG((jmp_buf, int)), typedef);
#endif

/* Transform masks for the high-level interface */
#define PNG_TRANSFORM_IDENTITY       0x0000    /* read and write */
#define PNG_TRANSFORM_STRIP_16       0x0001    /* read only */
#define PNG_TRANSFORM_STRIP_ALPHA    0x0002    /* read only */
#define PNG_TRANSFORM_PACKING        0x0004    /* read and write */
#define PNG_TRANSFORM_PACKSWAP       0x0008    /* read and write */
#define PNG_TRANSFORM_EXPAND         0x0010    /* read only */
#define PNG_TRANSFORM_INVERT_MONO    0x0020    /* read and write */
#define PNG_TRANSFORM_SHIFT          0x0040    /* read and write */
#define PNG_TRANSFORM_BGR            0x0080    /* read and write */
#define PNG_TRANSFORM_SWAP_ALPHA     0x0100    /* read and write */
#define PNG_TRANSFORM_SWAP_ENDIAN    0x0200    /* read and write */
#define PNG_TRANSFORM_INVERT_ALPHA   0x0400    /* read and write */
#define PNG_TRANSFORM_STRIP_FILLER   0x0800    /* write only */
/* Added to libpng-1.2.34 */
#define PNG_TRANSFORM_STRIP_FILLER_BEFORE PNG_TRANSFORM_STRIP_FILLER
#define PNG_TRANSFORM_STRIP_FILLER_AFTER 0x1000 /* write only */
/* Added to libpng-1.4.0 */
#define PNG_TRANSFORM_GRAY_TO_RGB   0x2000      /* read only */
/* Added to libpng-1.5.4 */
#define PNG_TRANSFORM_EXPAND_16     0x4000      /* read only */
#if INT_MAX >= 0x8000 /* else this might break */
#define PNG_TRANSFORM_SCALE_16      0x8000      /* read only */
#endif

/* Flags for MNG supported features */
#define PNG_FLAG_MNG_EMPTY_PLTE     0x01
#define PNG_FLAG_MNG_FILTER_64      0x04
#define PNG_ALL_MNG_FEATURES        0x05

/* NOTE: prior to 1.5 these functions had no 'API' style declaration,
 * this allowed the zlib default functions to be used on Windows
 * platforms.  In 1.5 the zlib default malloc (which just calls malloc and
 * ignores the first argument) should be completely compatible with the
 * following.
 */
typedef PNG_CALLBACK(png_voidp, *png_malloc_ptr, (png_structp,
    png_alloc_size_t));
typedef PNG_CALLBACK(void, *png_free_ptr, (png_structp, png_voidp));

/* Section 4: exported functions
 * Here are the function definitions most commonly used.  This is not
 * the place to find out how to use libpng.  See libpng-manual.txt for the
 * full explanation, see example.c for the summary.  This just provides
 * a simple one line description of the use of each function.
 *
 * The PNG_EXPORT() and PNG_EXPORTA() macros used below are defined in
 * pngconf.h and in the *.dfn files in the scripts directory.
 *
 *   PNG_EXPORT(ordinal, type, name, (args));
 *
 *       ordinal:    ordinal that is used while building
 *                   *.def files. The ordinal value is only
 *                   relevant when preprocessing png.h with
 *                   the *.dfn files for building symbol table
 *                   entries, and are removed by pngconf.h.
 *       type:       return type of the function
 *       name:       function name
 *       args:       function arguments, with types
 *
 * When we wish to append attributes to a function prototype we use
 * the PNG_EXPORTA() macro instead.
 *
 *   PNG_EXPORTA(ordinal, type, name, (args), attributes);
 *
 *       ordinal, type, name, and args: same as in PNG_EXPORT().
 *       attributes: function attributes
 */

/* Returns the version number of the library */
PNG_EXPORT(1, png_uint_32, png_access_version_number, (void));

/* Tell lib we have already handled the first <num_bytes> magic bytes.
 * Handling more than 8 bytes from the beginning of the file is an error.
 */
PNG_EXPORT(2, void, png_set_sig_bytes, (png_structrp png_ptr, int num_bytes));

/* Check sig[start] through sig[start + num_to_check - 1] to see if it's a
 * PNG file.  Returns zero if the supplied bytes match the 8-byte PNG
 * signature, and non-zero otherwise.  Having num_to_check == 0 or
 * start > 7 will always fail (ie return non-zero).
 */
PNG_EXPORT(3, int, png_sig_cmp, (png_const_bytep sig, png_size_t start,
    png_size_t num_to_check));

/* Simple signature checking function.  This is the same as calling
 * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).
 */
#define png_check_sig(sig, n) !png_sig_cmp((sig), 0, (n))

/* Allocate and initialize png_ptr struct for reading, and any other memory. */
PNG_EXPORTA(4, png_structp, png_create_read_struct,
    (png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn),
    PNG_ALLOCATED);

/* Allocate and initialize png_ptr struct for writing, and any other memory */
PNG_EXPORTA(5, png_structp, png_create_write_struct,
    (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn),
    PNG_ALLOCATED);

PNG_EXPORT(6, png_size_t, png_get_compression_buffer_size,
    (png_const_structrp png_ptr));

PNG_EXPORT(7, void, png_set_compression_buffer_size, (png_structrp png_ptr,
    png_size_t size));

/* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp
 * match up.
 */
#ifdef PNG_SETJMP_SUPPORTED
/* This function returns the jmp_buf built in to *png_ptr.  It must be
 * supplied with an appropriate 'longjmp' function to use on that jmp_buf
 * unless the default error function is overridden in which case NULL is
 * acceptable.  The size of the jmp_buf is checked against the actual size
 * allocated by the library - the call will return NULL on a mismatch
 * indicating an ABI mismatch.
 */
PNG_EXPORT(8, jmp_buf*, png_set_longjmp_fn, (png_structrp png_ptr,
    png_longjmp_ptr longjmp_fn, size_t jmp_buf_size));
#  define png_jmpbuf(png_ptr) \
      (*png_set_longjmp_fn((png_ptr), longjmp, (sizeof (jmp_buf))))
#else
#  define png_jmpbuf(png_ptr) \
      (LIBPNG_WAS_COMPILED_WITH__PNG_NO_SETJMP)
#endif
/* This function should be used by libpng applications in place of
 * longjmp(png_ptr->jmpbuf, val).  If longjmp_fn() has been set, it
 * will use it; otherwise it will call PNG_ABORT().  This function was
 * added in libpng-1.5.0.
 */
PNG_EXPORTA(9, void, png_longjmp, (png_const_structrp png_ptr, int val),
    PNG_NORETURN);

#ifdef PNG_READ_SUPPORTED
/* Reset the compression stream */
PNG_EXPORTA(10, int, png_reset_zstream, (png_structrp png_ptr), PNG_DEPRECATED);
#endif

/* New functions added in libpng-1.0.2 (not enabled by default until 1.2.0) */
#ifdef PNG_USER_MEM_SUPPORTED
PNG_EXPORTA(11, png_structp, png_create_read_struct_2,
    (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn,
    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn),
    PNG_ALLOCATED);
PNG_EXPORTA(12, png_structp, png_create_write_struct_2,
    (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn,
    png_voidp mem_ptr, png_malloc_ptr malloc_fn, png_free_ptr free_fn),
    PNG_ALLOCATED);
#endif

/* Write the PNG file signature. */
PNG_EXPORT(13, void, png_write_sig, (png_structrp png_ptr));

/* Write a PNG chunk - size, type, (optional) data, CRC. */
PNG_EXPORT(14, void, png_write_chunk, (png_structrp png_ptr, png_const_bytep
    chunk_name, png_const_bytep data, png_size_t length));

/* Write the start of a PNG chunk - length and chunk name. */
PNG_EXPORT(15, void, png_write_chunk_start, (png_structrp png_ptr,
    png_const_bytep chunk_name, png_uint_32 length));

/* Write the data of a PNG chunk started with png_write_chunk_start(). */
PNG_EXPORT(16, void, png_write_chunk_data, (png_structrp png_ptr,
    png_const_bytep data, png_size_t length));

/* Finish a chunk started with png_write_chunk_start() (includes CRC). */
PNG_EXPORT(17, void, png_write_chunk_end, (png_structrp png_ptr));

/* Allocate and initialize the info structure */
PNG_EXPORTA(18, png_infop, png_create_info_struct, (png_const_structrp png_ptr),
    PNG_ALLOCATED);

/* DEPRECATED: this function allowed init structures to be created using the
 * default allocation method (typically malloc).  Use is deprecated in 1.6.0 and
 * the API will be removed in the future.
 */
PNG_EXPORTA(19, void, png_info_init_3, (png_infopp info_ptr,
    png_size_t png_info_struct_size), PNG_DEPRECATED);

/* Writes all the PNG information before the image. */
PNG_EXPORT(20, void, png_write_info_before_PLTE,
    (png_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(21, void, png_write_info,
    (png_structrp png_ptr, png_const_inforp info_ptr));

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the information before the actual image data. */
PNG_EXPORT(22, void, png_read_info,
    (png_structrp png_ptr, png_inforp info_ptr));
#endif

#ifdef PNG_TIME_RFC1123_SUPPORTED
   /* Convert to a US string format: there is no localization support in this
    * routine.  The original implementation used a 29 character buffer in
    * png_struct, this will be removed in future versions.
    */
#if PNG_LIBPNG_VER < 10700
/* To do: remove this from libpng17 (and from libpng17/png.c and pngstruct.h) */
PNG_EXPORTA(23, png_const_charp, png_convert_to_rfc1123, (png_structrp png_ptr,
    png_const_timep ptime),PNG_DEPRECATED);
#endif
PNG_EXPORT(241, int, png_convert_to_rfc1123_buffer, (char out[29],
    png_const_timep ptime));
#endif

#ifdef PNG_CONVERT_tIME_SUPPORTED
/* Convert from a struct tm to png_time */
PNG_EXPORT(24, void, png_convert_from_struct_tm, (png_timep ptime,
    const struct tm * ttime));

/* Convert from time_t to png_time.  Uses gmtime() */
PNG_EXPORT(25, void, png_convert_from_time_t, (png_timep ptime, time_t ttime));
#endif /* CONVERT_tIME */

#ifdef PNG_READ_EXPAND_SUPPORTED
/* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */
PNG_EXPORT(26, void, png_set_expand, (png_structrp png_ptr));
PNG_EXPORT(27, void, png_set_expand_gray_1_2_4_to_8, (png_structrp png_ptr));
PNG_EXPORT(28, void, png_set_palette_to_rgb, (png_structrp png_ptr));
PNG_EXPORT(29, void, png_set_tRNS_to_alpha, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_EXPAND_16_SUPPORTED
/* Expand to 16-bit channels, forces conversion of palette to RGB and expansion
 * of a tRNS chunk if present.
 */
PNG_EXPORT(221, void, png_set_expand_16, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
/* Use blue, green, red order for pixels. */
PNG_EXPORT(30, void, png_set_bgr, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
/* Expand the grayscale to 24-bit RGB if necessary. */
PNG_EXPORT(31, void, png_set_gray_to_rgb, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
/* Reduce RGB to grayscale. */
#define PNG_ERROR_ACTION_NONE  1
#define PNG_ERROR_ACTION_WARN  2
#define PNG_ERROR_ACTION_ERROR 3
#define PNG_RGB_TO_GRAY_DEFAULT (-1)/*for red/green coefficients*/

PNG_FP_EXPORT(32, void, png_set_rgb_to_gray, (png_structrp png_ptr,
    int error_action, double red, double green))
PNG_FIXED_EXPORT(33, void, png_set_rgb_to_gray_fixed, (png_structrp png_ptr,
    int error_action, png_fixed_point red, png_fixed_point green))

PNG_EXPORT(34, png_byte, png_get_rgb_to_gray_status, (png_const_structrp
    png_ptr));
#endif

#ifdef PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
PNG_EXPORT(35, void, png_build_grayscale_palette, (int bit_depth,
    png_colorp palette));
#endif

#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
/* How the alpha channel is interpreted - this affects how the color channels
 * of a PNG file are returned to the calling application when an alpha channel,
 * or a tRNS chunk in a palette file, is present.
 *
 * This has no effect on the way pixels are written into a PNG output
 * datastream. The color samples in a PNG datastream are never premultiplied
 * with the alpha samples.
 *
 * The default is to return data according to the PNG specification: the alpha
 * channel is a linear measure of the contribution of the pixel to the
 * corresponding composited pixel, and the color channels are unassociated
 * (not premultiplied).  The gamma encoded color channels must be scaled
 * according to the contribution and to do this it is necessary to undo
 * the encoding, scale the color values, perform the composition and reencode
 * the values.  This is the 'PNG' mode.
 *
 * The alternative is to 'associate' the alpha with the color information by
 * storing color channel values that have been scaled by the alpha.
 * image.  These are the 'STANDARD', 'ASSOCIATED' or 'PREMULTIPLIED' modes
 * (the latter being the two common names for associated alpha color channels).
 *
 * For the 'OPTIMIZED' mode, a pixel is treated as opaque only if the alpha
 * value is equal to the maximum value.
 *
 * The final choice is to gamma encode the alpha channel as well.  This is
 * broken because, in practice, no implementation that uses this choice
 * correctly undoes the encoding before handling alpha composition.  Use this
 * choice only if other serious errors in the software or hardware you use
 * mandate it; the typical serious error is for dark halos to appear around
 * opaque areas of the composited PNG image because of arithmetic overflow.
 *
 * The API function png_set_alpha_mode specifies which of these choices to use
 * with an enumerated 'mode' value and the gamma of the required output:
 */
#define PNG_ALPHA_PNG           0 /* according to the PNG standard */
#define PNG_ALPHA_STANDARD      1 /* according to Porter/Duff */
#define PNG_ALPHA_ASSOCIATED    1 /* as above; this is the normal practice */
#define PNG_ALPHA_PREMULTIPLIED 1 /* as above */
#define PNG_ALPHA_OPTIMIZED     2 /* 'PNG' for opaque pixels, else 'STANDARD' */
#define PNG_ALPHA_BROKEN        3 /* the alpha channel is gamma encoded */

PNG_FP_EXPORT(227, void, png_set_alpha_mode, (png_structrp png_ptr, int mode,
    double output_gamma))
PNG_FIXED_EXPORT(228, void, png_set_alpha_mode_fixed, (png_structrp png_ptr,
    int mode, png_fixed_point output_gamma))
#endif

#if defined(PNG_GAMMA_SUPPORTED) || defined(PNG_READ_ALPHA_MODE_SUPPORTED)
/* The output_gamma value is a screen gamma in libpng terminology: it expresses
 * how to decode the output values, not how they are encoded.
 */
#define PNG_DEFAULT_sRGB -1       /* sRGB gamma and color space */
#define PNG_GAMMA_MAC_18 -2       /* Old Mac '1.8' gamma and color space */
#define PNG_GAMMA_sRGB   220000   /* Television standards--matches sRGB gamma */
#define PNG_GAMMA_LINEAR PNG_FP_1 /* Linear */
#endif

/* The following are examples of calls to png_set_alpha_mode to achieve the
 * required overall gamma correction and, where necessary, alpha
 * premultiplication.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
 *    This is the default libpng handling of the alpha channel - it is not
 *    pre-multiplied into the color components.  In addition the call states
 *    that the output is for a sRGB system and causes all PNG files without gAMA
 *    chunks to be assumed to be encoded using sRGB.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
 *    In this case the output is assumed to be something like an sRGB conformant
 *    display preceeded by a power-law lookup table of power 1.45.  This is how
 *    early Mac systems behaved.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_GAMMA_LINEAR);
 *    This is the classic Jim Blinn approach and will work in academic
 *    environments where everything is done by the book.  It has the shortcoming
 *    of assuming that input PNG data with no gamma information is linear - this
 *    is unlikely to be correct unless the PNG files where generated locally.
 *    Most of the time the output precision will be so low as to show
 *    significant banding in dark areas of the image.
 *
 * png_set_expand_16(pp);
 * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_DEFAULT_sRGB);
 *    This is a somewhat more realistic Jim Blinn inspired approach.  PNG files
 *    are assumed to have the sRGB encoding if not marked with a gamma value and
 *    the output is always 16 bits per component.  This permits accurate scaling
 *    and processing of the data.  If you know that your input PNG files were
 *    generated locally you might need to replace PNG_DEFAULT_sRGB with the
 *    correct value for your system.
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_OPTIMIZED, PNG_DEFAULT_sRGB);
 *    If you just need to composite the PNG image onto an existing background
 *    and if you control the code that does this you can use the optimization
 *    setting.  In this case you just copy completely opaque pixels to the
 *    output.  For pixels that are not completely transparent (you just skip
 *    those) you do the composition math using png_composite or png_composite_16
 *    below then encode the resultant 8-bit or 16-bit values to match the output
 *    encoding.
 *
 * Other cases
 *    If neither the PNG nor the standard linear encoding work for you because
 *    of the software or hardware you use then you have a big problem.  The PNG
 *    case will probably result in halos around the image.  The linear encoding
 *    will probably result in a washed out, too bright, image (it's actually too
 *    contrasty.)  Try the ALPHA_OPTIMIZED mode above - this will probably
 *    substantially reduce the halos.  Alternatively try:
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_BROKEN, PNG_DEFAULT_sRGB);
 *    This option will also reduce the halos, but there will be slight dark
 *    halos round the opaque parts of the image where the background is light.
 *    In the OPTIMIZED mode the halos will be light halos where the background
 *    is dark.  Take your pick - the halos are unavoidable unless you can get
 *    your hardware/software fixed!  (The OPTIMIZED approach is slightly
 *    faster.)
 *
 * When the default gamma of PNG files doesn't match the output gamma.
 *    If you have PNG files with no gamma information png_set_alpha_mode allows
 *    you to provide a default gamma, but it also sets the ouput gamma to the
 *    matching value.  If you know your PNG files have a gamma that doesn't
 *    match the output you can take advantage of the fact that
 *    png_set_alpha_mode always sets the output gamma but only sets the PNG
 *    default if it is not already set:
 *
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_DEFAULT_sRGB);
 * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
 *    The first call sets both the default and the output gamma values, the
 *    second call overrides the output gamma without changing the default.  This
 *    is easier than achieving the same effect with png_set_gamma.  You must use
 *    PNG_ALPHA_PNG for the first call - internal checking in png_set_alpha will
 *    fire if more than one call to png_set_alpha_mode and png_set_background is
 *    made in the same read operation, however multiple calls with PNG_ALPHA_PNG
 *    are ignored.
 */

#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
PNG_EXPORT(36, void, png_set_strip_alpha, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
PNG_EXPORT(37, void, png_set_swap_alpha, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
PNG_EXPORT(38, void, png_set_invert_alpha, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
/* Add a filler byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. */
PNG_EXPORT(39, void, png_set_filler, (png_structrp png_ptr, png_uint_32 filler,
    int flags));
/* The values of the PNG_FILLER_ defines should NOT be changed */
#  define PNG_FILLER_BEFORE 0
#  define PNG_FILLER_AFTER 1
/* Add an alpha byte to 8-bit or 16-bit Gray or 24-bit or 48-bit RGB images. */
PNG_EXPORT(40, void, png_set_add_alpha, (png_structrp png_ptr,
    png_uint_32 filler, int flags));
#endif /* READ_FILLER || WRITE_FILLER */

#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
/* Swap bytes in 16-bit depth files. */
PNG_EXPORT(41, void, png_set_swap, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
/* Use 1 byte per pixel in 1, 2, or 4-bit depth files. */
PNG_EXPORT(42, void, png_set_packing, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED) || \
    defined(PNG_WRITE_PACKSWAP_SUPPORTED)
/* Swap packing order of pixels in bytes. */
PNG_EXPORT(43, void, png_set_packswap, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
/* Converts files to legal bit depths. */
PNG_EXPORT(44, void, png_set_shift, (png_structrp png_ptr, png_const_color_8p
    true_bits));
#endif

#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
    defined(PNG_WRITE_INTERLACING_SUPPORTED)
/* Have the code handle the interlacing.  Returns the number of passes.
 * MUST be called before png_read_update_info or png_start_read_image,
 * otherwise it will not have the desired effect.  Note that it is still
 * necessary to call png_read_row or png_read_rows png_get_image_height
 * times for each pass.
*/
PNG_EXPORT(45, int, png_set_interlace_handling, (png_structrp png_ptr));
#endif

#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
/* Invert monochrome files */
PNG_EXPORT(46, void, png_set_invert_mono, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_BACKGROUND_SUPPORTED
/* Handle alpha and tRNS by replacing with a background color.  Prior to
 * libpng-1.5.4 this API must not be called before the PNG file header has been
 * read.  Doing so will result in unexpected behavior and possible warnings or
 * errors if the PNG file contains a bKGD chunk.
 */
PNG_FP_EXPORT(47, void, png_set_background, (png_structrp png_ptr,
    png_const_color_16p background_color, int background_gamma_code,
    int need_expand, double background_gamma))
PNG_FIXED_EXPORT(215, void, png_set_background_fixed, (png_structrp png_ptr,
    png_const_color_16p background_color, int background_gamma_code,
    int need_expand, png_fixed_point background_gamma))
#endif
#ifdef PNG_READ_BACKGROUND_SUPPORTED
#  define PNG_BACKGROUND_GAMMA_UNKNOWN 0
#  define PNG_BACKGROUND_GAMMA_SCREEN  1
#  define PNG_BACKGROUND_GAMMA_FILE    2
#  define PNG_BACKGROUND_GAMMA_UNIQUE  3
#endif

#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
/* Scale a 16-bit depth file down to 8-bit, accurately. */
PNG_EXPORT(229, void, png_set_scale_16, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
#define PNG_READ_16_TO_8_SUPPORTED /* Name prior to 1.5.4 */
/* Strip the second byte of information from a 16-bit depth file. */
PNG_EXPORT(48, void, png_set_strip_16, (png_structrp png_ptr));
#endif

#ifdef PNG_READ_QUANTIZE_SUPPORTED
/* Turn on quantizing, and reduce the palette to the number of colors
 * available.
 */
PNG_EXPORT(49, void, png_set_quantize, (png_structrp png_ptr,
    png_colorp palette, int num_palette, int maximum_colors,
    png_const_uint_16p histogram, int full_quantize));
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
/* The threshold on gamma processing is configurable but hard-wired into the
 * library.  The following is the floating point variant.
 */
#define PNG_GAMMA_THRESHOLD (PNG_GAMMA_THRESHOLD_FIXED*.00001)

/* Handle gamma correction. Screen_gamma=(display_exponent).
 * NOTE: this API simply sets the screen and file gamma values. It will
 * therefore override the value for gamma in a PNG file if it is called after
 * the file header has been read - use with care  - call before reading the PNG
 * file for best results!
 *
 * These routines accept the same gamma values as png_set_alpha_mode (described
 * above).  The PNG_GAMMA_ defines and PNG_DEFAULT_sRGB can be passed to either
 * API (floating point or fixed.)  Notice, however, that the 'file_gamma' value
 * is the inverse of a 'screen gamma' value.
 */
PNG_FP_EXPORT(50, void, png_set_gamma, (png_structrp png_ptr,
    double screen_gamma, double override_file_gamma))
PNG_FIXED_EXPORT(208, void, png_set_gamma_fixed, (png_structrp png_ptr,
    png_fixed_point screen_gamma, png_fixed_point override_file_gamma))
#endif

#ifdef PNG_WRITE_FLUSH_SUPPORTED
/* Set how many lines between output flushes - 0 for no flushing */
PNG_EXPORT(51, void, png_set_flush, (png_structrp png_ptr, int nrows));
/* Flush the current PNG output buffer */
PNG_EXPORT(52, void, png_write_flush, (png_structrp png_ptr));
#endif

/* Optional update palette with requested transformations */
PNG_EXPORT(53, void, png_start_read_image, (png_structrp png_ptr));

/* Optional call to update the users info structure */
PNG_EXPORT(54, void, png_read_update_info, (png_structrp png_ptr,
    png_inforp info_ptr));

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read one or more rows of image data. */
PNG_EXPORT(55, void, png_read_rows, (png_structrp png_ptr, png_bytepp row,
    png_bytepp display_row, png_uint_32 num_rows));
#endif

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read a row of data. */
PNG_EXPORT(56, void, png_read_row, (png_structrp png_ptr, png_bytep row,
    png_bytep display_row));
#endif

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the whole image into memory at once. */
PNG_EXPORT(57, void, png_read_image, (png_structrp png_ptr, png_bytepp image));
#endif

/* Write a row of image data */
PNG_EXPORT(58, void, png_write_row, (png_structrp png_ptr,
    png_const_bytep row));

/* Write a few rows of image data: (*row) is not written; however, the type
 * is declared as writeable to maintain compatibility with previous versions
 * of libpng and to allow the 'display_row' array from read_rows to be passed
 * unchanged to write_rows.
 */
PNG_EXPORT(59, void, png_write_rows, (png_structrp png_ptr, png_bytepp row,
    png_uint_32 num_rows));

/* Write the image data */
PNG_EXPORT(60, void, png_write_image, (png_structrp png_ptr, png_bytepp image));

/* Write the end of the PNG file. */
PNG_EXPORT(61, void, png_write_end, (png_structrp png_ptr,
    png_inforp info_ptr));

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the end of the PNG file. */
PNG_EXPORT(62, void, png_read_end, (png_structrp png_ptr, png_inforp info_ptr));
#endif

/* Free any memory associated with the png_info_struct */
PNG_EXPORT(63, void, png_destroy_info_struct, (png_const_structrp png_ptr,
    png_infopp info_ptr_ptr));

/* Free any memory associated with the png_struct and the png_info_structs */
PNG_EXPORT(64, void, png_destroy_read_struct, (png_structpp png_ptr_ptr,
    png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr));

/* Free any memory associated with the png_struct and the png_info_structs */
PNG_EXPORT(65, void, png_destroy_write_struct, (png_structpp png_ptr_ptr,
    png_infopp info_ptr_ptr));

/* Set the libpng method of handling chunk CRC errors */
PNG_EXPORT(66, void, png_set_crc_action, (png_structrp png_ptr, int crit_action,
    int ancil_action));

/* Values for png_set_crc_action() say how to handle CRC errors in
 * ancillary and critical chunks, and whether to use the data contained
 * therein.  Note that it is impossible to "discard" data in a critical
 * chunk.  For versions prior to 0.90, the action was always error/quit,
 * whereas in version 0.90 and later, the action for CRC errors in ancillary
 * chunks is warn/discard.  These values should NOT be changed.
 *
 *      value                       action:critical     action:ancillary
 */
#define PNG_CRC_DEFAULT       0  /* error/quit          warn/discard data */
#define PNG_CRC_ERROR_QUIT    1  /* error/quit          error/quit        */
#define PNG_CRC_WARN_DISCARD  2  /* (INVALID)           warn/discard data */
#define PNG_CRC_WARN_USE      3  /* warn/use data       warn/use data     */
#define PNG_CRC_QUIET_USE     4  /* quiet/use data      quiet/use data    */
#define PNG_CRC_NO_CHANGE     5  /* use current value   use current value */

#ifdef PNG_WRITE_SUPPORTED
/* These functions give the user control over the scan-line filtering in
 * libpng and the compression methods used by zlib.  These functions are
 * mainly useful for testing, as the defaults should work with most users.
 * Those users who are tight on memory or want faster performance at the
 * expense of compression can modify them.  See the compression library
 * header file (zlib.h) for an explination of the compression functions.
 */

/* Set the filtering method(s) used by libpng.  Currently, the only valid
 * value for "method" is 0.
 */
PNG_EXPORT(67, void, png_set_filter, (png_structrp png_ptr, int method,
    int filters));
#endif /* WRITE */

/* Flags for png_set_filter() to say which filters to use.  The flags
 * are chosen so that they don't conflict with real filter types
 * below, in case they are supplied instead of the #defined constants.
 * These values should NOT be changed.
 */
#define PNG_NO_FILTERS     0x00
#define PNG_FILTER_NONE    0x08
#define PNG_FILTER_SUB     0x10
#define PNG_FILTER_UP      0x20
#define PNG_FILTER_AVG     0x40
#define PNG_FILTER_PAETH   0x80
#define PNG_FAST_FILTERS (PNG_FILTER_NONE | PNG_FILTER_SUB | PNG_FILTER_UP)
#define PNG_ALL_FILTERS (PNG_FAST_FILTERS | PNG_FILTER_AVG | PNG_FILTER_PAETH)

/* Filter values (not flags) - used in pngwrite.c, pngwutil.c for now.
 * These defines should NOT be changed.
 */
#define PNG_FILTER_VALUE_NONE  0
#define PNG_FILTER_VALUE_SUB   1
#define PNG_FILTER_VALUE_UP    2
#define PNG_FILTER_VALUE_AVG   3
#define PNG_FILTER_VALUE_PAETH 4
#define PNG_FILTER_VALUE_LAST  5

#ifdef PNG_WRITE_SUPPORTED
#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED /* DEPRECATED */
PNG_FP_EXPORT(68, void, png_set_filter_heuristics, (png_structrp png_ptr,
    int heuristic_method, int num_weights, png_const_doublep filter_weights,
    png_const_doublep filter_costs))
PNG_FIXED_EXPORT(209, void, png_set_filter_heuristics_fixed,
    (png_structrp png_ptr, int heuristic_method, int num_weights,
    png_const_fixed_point_p filter_weights,
    png_const_fixed_point_p filter_costs))
#endif /* WRITE_WEIGHTED_FILTER */

/* The following are no longer used and will be removed from libpng-1.7: */
#define PNG_FILTER_HEURISTIC_DEFAULT    0  /* Currently "UNWEIGHTED" */
#define PNG_FILTER_HEURISTIC_UNWEIGHTED 1  /* Used by libpng < 0.95 */
#define PNG_FILTER_HEURISTIC_WEIGHTED   2  /* Experimental feature */
#define PNG_FILTER_HEURISTIC_LAST       3  /* Not a valid value */

/* Set the library compression level.  Currently, valid values range from
 * 0 - 9, corresponding directly to the zlib compression levels 0 - 9
 * (0 - no compression, 9 - "maximal" compression).  Note that tests have
 * shown that zlib compression levels 3-6 usually perform as well as level 9
 * for PNG images, and do considerably fewer caclulations.  In the future,
 * these values may not correspond directly to the zlib compression levels.
 */
#ifdef PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
PNG_EXPORT(69, void, png_set_compression_level, (png_structrp png_ptr,
    int level));

PNG_EXPORT(70, void, png_set_compression_mem_level, (png_structrp png_ptr,
    int mem_level));

PNG_EXPORT(71, void, png_set_compression_strategy, (png_structrp png_ptr,
    int strategy));

/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 */
PNG_EXPORT(72, void, png_set_compression_window_bits, (png_structrp png_ptr,
    int window_bits));

PNG_EXPORT(73, void, png_set_compression_method, (png_structrp png_ptr,
    int method));
#endif /* WRITE_CUSTOMIZE_COMPRESSION */

#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
/* Also set zlib parameters for compressing non-IDAT chunks */
PNG_EXPORT(222, void, png_set_text_compression_level, (png_structrp png_ptr,
    int level));

PNG_EXPORT(223, void, png_set_text_compression_mem_level, (png_structrp png_ptr,
    int mem_level));

PNG_EXPORT(224, void, png_set_text_compression_strategy, (png_structrp png_ptr,
    int strategy));

/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 */
PNG_EXPORT(225, void, png_set_text_compression_window_bits,
    (png_structrp png_ptr, int window_bits));

PNG_EXPORT(226, void, png_set_text_compression_method, (png_structrp png_ptr,
    int method));
#endif /* WRITE_CUSTOMIZE_ZTXT_COMPRESSION */
#endif /* WRITE */

/* These next functions are called for input/output, memory, and error
 * handling.  They are in the file pngrio.c, pngwio.c, and pngerror.c,
 * and call standard C I/O routines such as fread(), fwrite(), and
 * fprintf().  These functions can be made to use other I/O routines
 * at run time for those applications that need to handle I/O in a
 * different manner by calling png_set_???_fn().  See libpng-manual.txt for
 * more information.
 */

#ifdef PNG_STDIO_SUPPORTED
/* Initialize the input/output for the PNG file to the default functions. */
PNG_EXPORT(74, void, png_init_io, (png_structrp png_ptr, png_FILE_p fp));
#endif

/* Replace the (error and abort), and warning functions with user
 * supplied functions.  If no messages are to be printed you must still
 * write and use replacement functions. The replacement error_fn should
 * still do a longjmp to the last setjmp location if you are using this
 * method of error handling.  If error_fn or warning_fn is NULL, the
 * default function will be used.
 */

PNG_EXPORT(75, void, png_set_error_fn, (png_structrp png_ptr,
    png_voidp error_ptr, png_error_ptr error_fn, png_error_ptr warning_fn));

/* Return the user pointer associated with the error functions */
PNG_EXPORT(76, png_voidp, png_get_error_ptr, (png_const_structrp png_ptr));

/* Replace the default data output functions with a user supplied one(s).
 * If buffered output is not used, then output_flush_fn can be set to NULL.
 * If PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile time
 * output_flush_fn will be ignored (and thus can be NULL).
 * It is probably a mistake to use NULL for output_flush_fn if
 * write_data_fn is not also NULL unless you have built libpng with
 * PNG_WRITE_FLUSH_SUPPORTED undefined, because in this case libpng's
 * default flush function, which uses the standard *FILE structure, will
 * be used.
 */
PNG_EXPORT(77, void, png_set_write_fn, (png_structrp png_ptr, png_voidp io_ptr,
    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn));

/* Replace the default data input function with a user supplied one. */
PNG_EXPORT(78, void, png_set_read_fn, (png_structrp png_ptr, png_voidp io_ptr,
    png_rw_ptr read_data_fn));

/* Return the user pointer associated with the I/O functions */
PNG_EXPORT(79, png_voidp, png_get_io_ptr, (png_const_structrp png_ptr));

PNG_EXPORT(80, void, png_set_read_status_fn, (png_structrp png_ptr,
    png_read_status_ptr read_row_fn));

PNG_EXPORT(81, void, png_set_write_status_fn, (png_structrp png_ptr,
    png_write_status_ptr write_row_fn));

#ifdef PNG_USER_MEM_SUPPORTED
/* Replace the default memory allocation functions with user supplied one(s). */
PNG_EXPORT(82, void, png_set_mem_fn, (png_structrp png_ptr, png_voidp mem_ptr,
    png_malloc_ptr malloc_fn, png_free_ptr free_fn));
/* Return the user pointer associated with the memory functions */
PNG_EXPORT(83, png_voidp, png_get_mem_ptr, (png_const_structrp png_ptr));
#endif

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
PNG_EXPORT(84, void, png_set_read_user_transform_fn, (png_structrp png_ptr,
    png_user_transform_ptr read_user_transform_fn));
#endif

#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
PNG_EXPORT(85, void, png_set_write_user_transform_fn, (png_structrp png_ptr,
    png_user_transform_ptr write_user_transform_fn));
#endif

#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
PNG_EXPORT(86, void, png_set_user_transform_info, (png_structrp png_ptr,
    png_voidp user_transform_ptr, int user_transform_depth,
    int user_transform_channels));
/* Return the user pointer associated with the user transform functions */
PNG_EXPORT(87, png_voidp, png_get_user_transform_ptr,
    (png_const_structrp png_ptr));
#endif

#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED
/* Return information about the row currently being processed.  Note that these
 * APIs do not fail but will return unexpected results if called outside a user
 * transform callback.  Also note that when transforming an interlaced image the
 * row number is the row number within the sub-image of the interlace pass, so
 * the value will increase to the height of the sub-image (not the full image)
 * then reset to 0 for the next pass.
 *
 * Use PNG_ROW_FROM_PASS_ROW(row, pass) and PNG_COL_FROM_PASS_COL(col, pass) to
 * find the output pixel (x,y) given an interlaced sub-image pixel
 * (row,col,pass).  (See below for these macros.)
 */
PNG_EXPORT(217, png_uint_32, png_get_current_row_number, (png_const_structrp));
PNG_EXPORT(218, png_byte, png_get_current_pass_number, (png_const_structrp));
#endif

#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
/* This callback is called only for *unknown* chunks.  If
 * PNG_HANDLE_AS_UNKNOWN_SUPPORTED is set then it is possible to set known
 * chunks to be treated as unknown, however in this case the callback must do
 * any processing required by the chunk (e.g. by calling the appropriate
 * png_set_ APIs.)
 *
 * There is no write support - on write, by default, all the chunks in the
 * 'unknown' list are written in the specified position.
 *
 * The integer return from the callback function is interpreted thus:
 *
 * negative: An error occurred; png_chunk_error will be called.
 *     zero: The chunk was not handled, the chunk will be saved. A critical
 *           chunk will cause an error at this point unless it is to be saved.
 * positive: The chunk was handled, libpng will ignore/discard it.
 *
 * See "INTERACTION WTIH USER CHUNK CALLBACKS" below for important notes about
 * how this behavior will change in libpng 1.7
 */
PNG_EXPORT(88, void, png_set_read_user_chunk_fn, (png_structrp png_ptr,
    png_voidp user_chunk_ptr, png_user_chunk_ptr read_user_chunk_fn));
#endif

#ifdef PNG_USER_CHUNKS_SUPPORTED
PNG_EXPORT(89, png_voidp, png_get_user_chunk_ptr, (png_const_structrp png_ptr));
#endif

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
/* Sets the function callbacks for the push reader, and a pointer to a
 * user-defined structure available to the callback functions.
 */
PNG_EXPORT(90, void, png_set_progressive_read_fn, (png_structrp png_ptr,
    png_voidp progressive_ptr, png_progressive_info_ptr info_fn,
    png_progressive_row_ptr row_fn, png_progressive_end_ptr end_fn));

/* Returns the user pointer associated with the push read functions */
PNG_EXPORT(91, png_voidp, png_get_progressive_ptr,
    (png_const_structrp png_ptr));

/* Function to be called when data becomes available */
PNG_EXPORT(92, void, png_process_data, (png_structrp png_ptr,
    png_inforp info_ptr, png_bytep buffer, png_size_t buffer_size));

/* A function which may be called *only* within png_process_data to stop the
 * processing of any more data.  The function returns the number of bytes
 * remaining, excluding any that libpng has cached internally.  A subsequent
 * call to png_process_data must supply these bytes again.  If the argument
 * 'save' is set to true the routine will first save all the pending data and
 * will always return 0.
 */
PNG_EXPORT(219, png_size_t, png_process_data_pause, (png_structrp, int save));

/* A function which may be called *only* outside (after) a call to
 * png_process_data.  It returns the number of bytes of data to skip in the
 * input.  Normally it will return 0, but if it returns a non-zero value the
 * application must skip than number of bytes of input data and pass the
 * following data to the next call to png_process_data.
 */
PNG_EXPORT(220, png_uint_32, png_process_data_skip, (png_structrp));

/* Function that combines rows.  'new_row' is a flag that should come from
 * the callback and be non-NULL if anything needs to be done; the library
 * stores its own version of the new data internally and ignores the passed
 * in value.
 */
PNG_EXPORT(93, void, png_progressive_combine_row, (png_const_structrp png_ptr,
    png_bytep old_row, png_const_bytep new_row));
#endif /* PROGRESSIVE_READ */

PNG_EXPORTA(94, png_voidp, png_malloc, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED);
/* Added at libpng version 1.4.0 */
PNG_EXPORTA(95, png_voidp, png_calloc, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED);

/* Added at libpng version 1.2.4 */
PNG_EXPORTA(96, png_voidp, png_malloc_warn, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED);

/* Frees a pointer allocated by png_malloc() */
PNG_EXPORT(97, void, png_free, (png_const_structrp png_ptr, png_voidp ptr));

/* Free data that was allocated internally */
PNG_EXPORT(98, void, png_free_data, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 free_me, int num));

/* Reassign responsibility for freeing existing data, whether allocated
 * by libpng or by the application; this works on the png_info structure passed
 * in, it does not change the state for other png_info structures.
 *
 * It is unlikely that this function works correctly as of 1.6.0 and using it
 * may result either in memory leaks or double free of allocated data.
 */
PNG_EXPORT(99, void, png_data_freer, (png_const_structrp png_ptr,
    png_inforp info_ptr, int freer, png_uint_32 mask));

/* Assignments for png_data_freer */
#define PNG_DESTROY_WILL_FREE_DATA 1
#define PNG_SET_WILL_FREE_DATA 1
#define PNG_USER_WILL_FREE_DATA 2
/* Flags for png_ptr->free_me and info_ptr->free_me */
#define PNG_FREE_HIST 0x0008U
#define PNG_FREE_ICCP 0x0010U
#define PNG_FREE_SPLT 0x0020U
#define PNG_FREE_ROWS 0x0040U
#define PNG_FREE_PCAL 0x0080U
#define PNG_FREE_SCAL 0x0100U
#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
#  define PNG_FREE_UNKN 0x0200U
#endif
/*      PNG_FREE_LIST 0x0400U   removed in 1.6.0 because it is ignored */
#define PNG_FREE_PLTE 0x1000U
#define PNG_FREE_TRNS 0x2000U
#define PNG_FREE_TEXT 0x4000U
#define PNG_FREE_ALL  0x7fffU
#define PNG_FREE_MUL  0x4220U /* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */

#ifdef PNG_USER_MEM_SUPPORTED
PNG_EXPORTA(100, png_voidp, png_malloc_default, (png_const_structrp png_ptr,
    png_alloc_size_t size), PNG_ALLOCATED PNG_DEPRECATED);
PNG_EXPORTA(101, void, png_free_default, (png_const_structrp png_ptr,
    png_voidp ptr), PNG_DEPRECATED);
#endif

#ifdef PNG_ERROR_TEXT_SUPPORTED
/* Fatal error in PNG image of libpng - can't continue */
PNG_EXPORTA(102, void, png_error, (png_const_structrp png_ptr,
    png_const_charp error_message), PNG_NORETURN);

/* The same, but the chunk name is prepended to the error string. */
PNG_EXPORTA(103, void, png_chunk_error, (png_const_structrp png_ptr,
    png_const_charp error_message), PNG_NORETURN);

#else
/* Fatal error in PNG image of libpng - can't continue */
PNG_EXPORTA(104, void, png_err, (png_const_structrp png_ptr), PNG_NORETURN);
#  define png_error(s1,s2) png_err(s1)
#  define png_chunk_error(s1,s2) png_err(s1)
#endif

#ifdef PNG_WARNINGS_SUPPORTED
/* Non-fatal error in libpng.  Can continue, but may have a problem. */
PNG_EXPORT(105, void, png_warning, (png_const_structrp png_ptr,
    png_const_charp warning_message));

/* Non-fatal error in libpng, chunk name is prepended to message. */
PNG_EXPORT(106, void, png_chunk_warning, (png_const_structrp png_ptr,
    png_const_charp warning_message));
#else
#  define png_warning(s1,s2) ((void)(s1))
#  define png_chunk_warning(s1,s2) ((void)(s1))
#endif

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
/* Benign error in libpng.  Can continue, but may have a problem.
 * User can choose whether to handle as a fatal error or as a warning. */
PNG_EXPORT(107, void, png_benign_error, (png_const_structrp png_ptr,
    png_const_charp warning_message));

#ifdef PNG_READ_SUPPORTED
/* Same, chunk name is prepended to message (only during read) */
PNG_EXPORT(108, void, png_chunk_benign_error, (png_const_structrp png_ptr,
    png_const_charp warning_message));
#endif

PNG_EXPORT(109, void, png_set_benign_errors,
    (png_structrp png_ptr, int allowed));
#else
#  ifdef PNG_ALLOW_BENIGN_ERRORS
#    define png_benign_error png_warning
#    define png_chunk_benign_error png_chunk_warning
#  else
#    define png_benign_error png_error
#    define png_chunk_benign_error png_chunk_error
#  endif
#endif

/* The png_set_<chunk> functions are for storing values in the png_info_struct.
 * Similarly, the png_get_<chunk> calls are used to read values from the
 * png_info_struct, either storing the parameters in the passed variables, or
 * setting pointers into the png_info_struct where the data is stored.  The
 * png_get_<chunk> functions return a non-zero value if the data was available
 * in info_ptr, or return zero and do not change any of the parameters if the
 * data was not available.
 *
 * These functions should be used instead of directly accessing png_info
 * to avoid problems with future changes in the size and internal layout of
 * png_info_struct.
 */
/* Returns "flag" if chunk data is valid in info_ptr. */
PNG_EXPORT(110, png_uint_32, png_get_valid, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 flag));

/* Returns number of bytes needed to hold a transformed row. */
PNG_EXPORT(111, png_size_t, png_get_rowbytes, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

#ifdef PNG_INFO_IMAGE_SUPPORTED
/* Returns row_pointers, which is an array of pointers to scanlines that was
 * returned from png_read_png().
 */
PNG_EXPORT(112, png_bytepp, png_get_rows, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Set row_pointers, which is an array of pointers to scanlines for use
 * by png_write_png().
 */
PNG_EXPORT(113, void, png_set_rows, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_bytepp row_pointers));
#endif

/* Returns number of color channels in image. */
PNG_EXPORT(114, png_byte, png_get_channels, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

#ifdef PNG_EASY_ACCESS_SUPPORTED
/* Returns image width in pixels. */
PNG_EXPORT(115, png_uint_32, png_get_image_width, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image height in pixels. */
PNG_EXPORT(116, png_uint_32, png_get_image_height, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image bit_depth. */
PNG_EXPORT(117, png_byte, png_get_bit_depth, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image color_type. */
PNG_EXPORT(118, png_byte, png_get_color_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image filter_type. */
PNG_EXPORT(119, png_byte, png_get_filter_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image interlace_type. */
PNG_EXPORT(120, png_byte, png_get_interlace_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image compression_type. */
PNG_EXPORT(121, png_byte, png_get_compression_type, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));

/* Returns image resolution in pixels per meter, from pHYs chunk data. */
PNG_EXPORT(122, png_uint_32, png_get_pixels_per_meter,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(123, png_uint_32, png_get_x_pixels_per_meter,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(124, png_uint_32, png_get_y_pixels_per_meter,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

/* Returns pixel aspect ratio, computed from pHYs chunk data.  */
PNG_FP_EXPORT(125, float, png_get_pixel_aspect_ratio,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
PNG_FIXED_EXPORT(210, png_fixed_point, png_get_pixel_aspect_ratio_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))

/* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
PNG_EXPORT(126, png_int_32, png_get_x_offset_pixels,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(127, png_int_32, png_get_y_offset_pixels,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(128, png_int_32, png_get_x_offset_microns,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));
PNG_EXPORT(129, png_int_32, png_get_y_offset_microns,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

#endif /* EASY_ACCESS */

#ifdef PNG_READ_SUPPORTED
/* Returns pointer to signature string read from PNG header */
PNG_EXPORT(130, png_const_bytep, png_get_signature, (png_const_structrp png_ptr,
    png_const_inforp info_ptr));
#endif

#ifdef PNG_bKGD_SUPPORTED
PNG_EXPORT(131, png_uint_32, png_get_bKGD, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_color_16p *background));
#endif

#ifdef PNG_bKGD_SUPPORTED
PNG_EXPORT(132, void, png_set_bKGD, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_color_16p background));
#endif

#ifdef PNG_cHRM_SUPPORTED
PNG_FP_EXPORT(133, png_uint_32, png_get_cHRM, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, double *white_x, double *white_y, double *red_x,
    double *red_y, double *green_x, double *green_y, double *blue_x,
    double *blue_y))
PNG_FP_EXPORT(230, png_uint_32, png_get_cHRM_XYZ, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, double *red_X, double *red_Y, double *red_Z,
    double *green_X, double *green_Y, double *green_Z, double *blue_X,
    double *blue_Y, double *blue_Z))
PNG_FIXED_EXPORT(134, png_uint_32, png_get_cHRM_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *int_white_x, png_fixed_point *int_white_y,
    png_fixed_point *int_red_x, png_fixed_point *int_red_y,
    png_fixed_point *int_green_x, png_fixed_point *int_green_y,
    png_fixed_point *int_blue_x, png_fixed_point *int_blue_y))
PNG_FIXED_EXPORT(231, png_uint_32, png_get_cHRM_XYZ_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,
    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,
    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,
    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,
    png_fixed_point *int_blue_Z))
#endif

#ifdef PNG_cHRM_SUPPORTED
PNG_FP_EXPORT(135, void, png_set_cHRM, (png_const_structrp png_ptr,
    png_inforp info_ptr,
    double white_x, double white_y, double red_x, double red_y, double green_x,
    double green_y, double blue_x, double blue_y))
PNG_FP_EXPORT(232, void, png_set_cHRM_XYZ, (png_const_structrp png_ptr,
    png_inforp info_ptr, double red_X, double red_Y, double red_Z,
    double green_X, double green_Y, double green_Z, double blue_X,
    double blue_Y, double blue_Z))
PNG_FIXED_EXPORT(136, void, png_set_cHRM_fixed, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_white_x,
    png_fixed_point int_white_y, png_fixed_point int_red_x,
    png_fixed_point int_red_y, png_fixed_point int_green_x,
    png_fixed_point int_green_y, png_fixed_point int_blue_x,
    png_fixed_point int_blue_y))
PNG_FIXED_EXPORT(233, void, png_set_cHRM_XYZ_fixed, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_red_X, png_fixed_point int_red_Y,
    png_fixed_point int_red_Z, png_fixed_point int_green_X,
    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
    png_fixed_point int_blue_Z))
#endif

#ifdef PNG_gAMA_SUPPORTED
PNG_FP_EXPORT(137, png_uint_32, png_get_gAMA, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, double *file_gamma))
PNG_FIXED_EXPORT(138, png_uint_32, png_get_gAMA_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *int_file_gamma))
#endif

#ifdef PNG_gAMA_SUPPORTED
PNG_FP_EXPORT(139, void, png_set_gAMA, (png_const_structrp png_ptr,
    png_inforp info_ptr, double file_gamma))
PNG_FIXED_EXPORT(140, void, png_set_gAMA_fixed, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_fixed_point int_file_gamma))
#endif

#ifdef PNG_hIST_SUPPORTED
PNG_EXPORT(141, png_uint_32, png_get_hIST, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_16p *hist));
#endif

#ifdef PNG_hIST_SUPPORTED
PNG_EXPORT(142, void, png_set_hIST, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_uint_16p hist));
#endif

PNG_EXPORT(143, png_uint_32, png_get_IHDR, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 *width, png_uint_32 *height,
    int *bit_depth, int *color_type, int *interlace_method,
    int *compression_method, int *filter_method));

PNG_EXPORT(144, void, png_set_IHDR, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 width, png_uint_32 height, int bit_depth,
    int color_type, int interlace_method, int compression_method,
    int filter_method));

#ifdef PNG_oFFs_SUPPORTED
PNG_EXPORT(145, png_uint_32, png_get_oFFs, (png_const_structrp png_ptr,
   png_const_inforp info_ptr, png_int_32 *offset_x, png_int_32 *offset_y,
   int *unit_type));
#endif

#ifdef PNG_oFFs_SUPPORTED
PNG_EXPORT(146, void, png_set_oFFs, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_int_32 offset_x, png_int_32 offset_y,
    int unit_type));
#endif

#ifdef PNG_pCAL_SUPPORTED
PNG_EXPORT(147, png_uint_32, png_get_pCAL, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_charp *purpose, png_int_32 *X0,
    png_int_32 *X1, int *type, int *nparams, png_charp *units,
    png_charpp *params));
#endif

#ifdef PNG_pCAL_SUPPORTED
PNG_EXPORT(148, void, png_set_pCAL, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_charp purpose, png_int_32 X0, png_int_32 X1,
    int type, int nparams, png_const_charp units, png_charpp params));
#endif

#ifdef PNG_pHYs_SUPPORTED
PNG_EXPORT(149, png_uint_32, png_get_pHYs, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
    int *unit_type));
#endif

#ifdef PNG_pHYs_SUPPORTED
PNG_EXPORT(150, void, png_set_pHYs, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 res_x, png_uint_32 res_y, int unit_type));
#endif

PNG_EXPORT(151, png_uint_32, png_get_PLTE, (png_const_structrp png_ptr,
   png_inforp info_ptr, png_colorp *palette, int *num_palette));

PNG_EXPORT(152, void, png_set_PLTE, (png_structrp png_ptr,
    png_inforp info_ptr, png_const_colorp palette, int num_palette));

#ifdef PNG_sBIT_SUPPORTED
PNG_EXPORT(153, png_uint_32, png_get_sBIT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_color_8p *sig_bit));
#endif

#ifdef PNG_sBIT_SUPPORTED
PNG_EXPORT(154, void, png_set_sBIT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_color_8p sig_bit));
#endif

#ifdef PNG_sRGB_SUPPORTED
PNG_EXPORT(155, png_uint_32, png_get_sRGB, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, int *file_srgb_intent));
#endif

#ifdef PNG_sRGB_SUPPORTED
PNG_EXPORT(156, void, png_set_sRGB, (png_const_structrp png_ptr,
    png_inforp info_ptr, int srgb_intent));
PNG_EXPORT(157, void, png_set_sRGB_gAMA_and_cHRM, (png_const_structrp png_ptr,
    png_inforp info_ptr, int srgb_intent));
#endif

#ifdef PNG_iCCP_SUPPORTED
PNG_EXPORT(158, png_uint_32, png_get_iCCP, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_charpp name, int *compression_type,
    png_bytepp profile, png_uint_32 *proflen));
#endif

#ifdef PNG_iCCP_SUPPORTED
PNG_EXPORT(159, void, png_set_iCCP, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_charp name, int compression_type,
    png_const_bytep profile, png_uint_32 proflen));
#endif

#ifdef PNG_sPLT_SUPPORTED
PNG_EXPORT(160, int, png_get_sPLT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_sPLT_tpp entries));
#endif

#ifdef PNG_sPLT_SUPPORTED
PNG_EXPORT(161, void, png_set_sPLT, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_sPLT_tp entries, int nentries));
#endif

#ifdef PNG_TEXT_SUPPORTED
/* png_get_text also returns the number of text chunks in *num_text */
PNG_EXPORT(162, int, png_get_text, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_textp *text_ptr, int *num_text));
#endif

/* Note while png_set_text() will accept a structure whose text,
 * language, and  translated keywords are NULL pointers, the structure
 * returned by png_get_text will always contain regular
 * zero-terminated C strings.  They might be empty strings but
 * they will never be NULL pointers.
 */

#ifdef PNG_TEXT_SUPPORTED
PNG_EXPORT(163, void, png_set_text, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_textp text_ptr, int num_text));
#endif

#ifdef PNG_tIME_SUPPORTED
PNG_EXPORT(164, png_uint_32, png_get_tIME, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_timep *mod_time));
#endif

#ifdef PNG_tIME_SUPPORTED
PNG_EXPORT(165, void, png_set_tIME, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_timep mod_time));
#endif

#ifdef PNG_tRNS_SUPPORTED
PNG_EXPORT(166, png_uint_32, png_get_tRNS, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_bytep *trans_alpha, int *num_trans,
    png_color_16p *trans_color));
#endif

#ifdef PNG_tRNS_SUPPORTED
PNG_EXPORT(167, void, png_set_tRNS, (png_structrp png_ptr,
    png_inforp info_ptr, png_const_bytep trans_alpha, int num_trans,
    png_const_color_16p trans_color));
#endif

#ifdef PNG_sCAL_SUPPORTED
PNG_FP_EXPORT(168, png_uint_32, png_get_sCAL, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, int *unit, double *width, double *height))
#if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || \
   defined(PNG_FLOATING_POINT_SUPPORTED)
/* NOTE: this API is currently implemented using floating point arithmetic,
 * consequently it can only be used on systems with floating point support.
 * In any case the range of values supported by png_fixed_point is small and it
 * is highly recommended that png_get_sCAL_s be used instead.
 */
PNG_FIXED_EXPORT(214, png_uint_32, png_get_sCAL_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr, int *unit,
    png_fixed_point *width, png_fixed_point *height))
#endif
PNG_EXPORT(169, png_uint_32, png_get_sCAL_s,
    (png_const_structrp png_ptr, png_const_inforp info_ptr, int *unit,
    png_charpp swidth, png_charpp sheight));

PNG_FP_EXPORT(170, void, png_set_sCAL, (png_const_structrp png_ptr,
    png_inforp info_ptr, int unit, double width, double height))
PNG_FIXED_EXPORT(213, void, png_set_sCAL_fixed, (png_const_structrp png_ptr,
   png_inforp info_ptr, int unit, png_fixed_point width,
   png_fixed_point height))
PNG_EXPORT(171, void, png_set_sCAL_s, (png_const_structrp png_ptr,
    png_inforp info_ptr, int unit,
    png_const_charp swidth, png_const_charp sheight));
#endif /* sCAL */

#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
/* Provide the default handling for all unknown chunks or, optionally, for
 * specific unknown chunks.
 *
 * NOTE: prior to 1.6.0 the handling specified for particular chunks on read was
 * ignored and the default was used, the per-chunk setting only had an effect on
 * write.  If you wish to have chunk-specific handling on read in code that must
 * work on earlier versions you must use a user chunk callback to specify the
 * desired handling (keep or discard.)
 *
 * The 'keep' parameter is a PNG_HANDLE_CHUNK_ value as listed below.  The
 * parameter is interpreted as follows:
 *
 * READ:
 *    PNG_HANDLE_CHUNK_AS_DEFAULT:
 *       Known chunks: do normal libpng processing, do not keep the chunk (but
 *          see the comments below about PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
 *       Unknown chunks: for a specific chunk use the global default, when used
 *          as the default discard the chunk data.
 *    PNG_HANDLE_CHUNK_NEVER:
 *       Discard the chunk data.
 *    PNG_HANDLE_CHUNK_IF_SAFE:
 *       Keep the chunk data if the chunk is not critical else raise a chunk
 *       error.
 *    PNG_HANDLE_CHUNK_ALWAYS:
 *       Keep the chunk data.
 *
 * If the chunk data is saved it can be retrieved using png_get_unknown_chunks,
 * below.  Notice that specifying "AS_DEFAULT" as a global default is equivalent
 * to specifying "NEVER", however when "AS_DEFAULT" is used for specific chunks
 * it simply resets the behavior to the libpng default.
 *
 * INTERACTION WTIH USER CHUNK CALLBACKS:
 * The per-chunk handling is always used when there is a png_user_chunk_ptr
 * callback and the callback returns 0; the chunk is then always stored *unless*
 * it is critical and the per-chunk setting is other than ALWAYS.  Notice that
 * the global default is *not* used in this case.  (In effect the per-chunk
 * value is incremented to at least IF_SAFE.)
 *
 * IMPORTANT NOTE: this behavior will change in libpng 1.7 - the global and
 * per-chunk defaults will be honored.  If you want to preserve the current
 * behavior when your callback returns 0 you must set PNG_HANDLE_CHUNK_IF_SAFE
 * as the default - if you don't do this libpng 1.6 will issue a warning.
 *
 * If you want unhandled unknown chunks to be discarded in libpng 1.6 and
 * earlier simply return '1' (handled).
 *
 * PNG_HANDLE_AS_UNKNOWN_SUPPORTED:
 *    If this is *not* set known chunks will always be handled by libpng and
 *    will never be stored in the unknown chunk list.  Known chunks listed to
 *    png_set_keep_unknown_chunks will have no effect.  If it is set then known
 *    chunks listed with a keep other than AS_DEFAULT will *never* be processed
 *    by libpng, in addition critical chunks must either be processed by the
 *    callback or saved.
 *
 *    The IHDR and IEND chunks must not be listed.  Because this turns off the
 *    default handling for chunks that would otherwise be recognized the
 *    behavior of libpng transformations may well become incorrect!
 *
 * WRITE:
 *    When writing chunks the options only apply to the chunks specified by
 *    png_set_unknown_chunks (below), libpng will *always* write known chunks
 *    required by png_set_ calls and will always write the core critical chunks
 *    (as required for PLTE).
 *
 *    Each chunk in the png_set_unknown_chunks list is looked up in the
 *    png_set_keep_unknown_chunks list to find the keep setting, this is then
 *    interpreted as follows:
 *
 *    PNG_HANDLE_CHUNK_AS_DEFAULT:
 *       Write safe-to-copy chunks and write other chunks if the global
 *       default is set to _ALWAYS, otherwise don't write this chunk.
 *    PNG_HANDLE_CHUNK_NEVER:
 *       Do not write the chunk.
 *    PNG_HANDLE_CHUNK_IF_SAFE:
 *       Write the chunk if it is safe-to-copy, otherwise do not write it.
 *    PNG_HANDLE_CHUNK_ALWAYS:
 *       Write the chunk.
 *
 * Note that the default behavior is effectively the opposite of the read case -
 * in read unknown chunks are not stored by default, in write they are written
 * by default.  Also the behavior of PNG_HANDLE_CHUNK_IF_SAFE is very different
 * - on write the safe-to-copy bit is checked, on read the critical bit is
 * checked and on read if the chunk is critical an error will be raised.
 *
 * num_chunks:
 * ===========
 *    If num_chunks is positive, then the "keep" parameter specifies the manner
 *    for handling only those chunks appearing in the chunk_list array,
 *    otherwise the chunk list array is ignored.
 *
 *    If num_chunks is 0 the "keep" parameter specifies the default behavior for
 *    unknown chunks, as described above.
 *
 *    If num_chunks is negative, then the "keep" parameter specifies the manner
 *    for handling all unknown chunks plus all chunks recognized by libpng
 *    except for the IHDR, PLTE, tRNS, IDAT, and IEND chunks (which continue to
 *    be processed by libpng.
 */
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
PNG_EXPORT(172, void, png_set_keep_unknown_chunks, (png_structrp png_ptr,
    int keep, png_const_bytep chunk_list, int num_chunks));
#endif /* HANDLE_AS_UNKNOWN */

/* The "keep" PNG_HANDLE_CHUNK_ parameter for the specified chunk is returned;
 * the result is therefore true (non-zero) if special handling is required,
 * false for the default handling.
 */
PNG_EXPORT(173, int, png_handle_as_unknown, (png_const_structrp png_ptr,
    png_const_bytep chunk_name));
#endif /* SET_UNKNOWN_CHUNKS */

#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
PNG_EXPORT(174, void, png_set_unknown_chunks, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_unknown_chunkp unknowns,
    int num_unknowns));
   /* NOTE: prior to 1.6.0 this routine set the 'location' field of the added
    * unknowns to the location currently stored in the png_struct.  This is
    * invariably the wrong value on write.  To fix this call the following API
    * for each chunk in the list with the correct location.  If you know your
    * code won't be compiled on earlier versions you can rely on
    * png_set_unknown_chunks(write-ptr, png_get_unknown_chunks(read-ptr)) doing
    * the correct thing.
    */

PNG_EXPORT(175, void, png_set_unknown_chunk_location,
    (png_const_structrp png_ptr, png_inforp info_ptr, int chunk, int location));

PNG_EXPORT(176, int, png_get_unknown_chunks, (png_const_structrp png_ptr,
    png_inforp info_ptr, png_unknown_chunkpp entries));
#endif

/* Png_free_data() will turn off the "valid" flag for anything it frees.
 * If you need to turn it off for a chunk that your application has freed,
 * you can use png_set_invalid(png_ptr, info_ptr, PNG_INFO_CHNK);
 */
PNG_EXPORT(177, void, png_set_invalid, (png_const_structrp png_ptr,
    png_inforp info_ptr, int mask));

#ifdef PNG_INFO_IMAGE_SUPPORTED
/* The "params" pointer is currently not used and is for future expansion. */
#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
PNG_EXPORT(178, void, png_read_png, (png_structrp png_ptr, png_inforp info_ptr,
    int transforms, png_voidp params));
#endif
#ifdef PNG_WRITE_SUPPORTED
PNG_EXPORT(179, void, png_write_png, (png_structrp png_ptr, png_inforp info_ptr,
    int transforms, png_voidp params));
#endif
#endif

PNG_EXPORT(180, png_const_charp, png_get_copyright,
    (png_const_structrp png_ptr));
PNG_EXPORT(181, png_const_charp, png_get_header_ver,
    (png_const_structrp png_ptr));
PNG_EXPORT(182, png_const_charp, png_get_header_version,
    (png_const_structrp png_ptr));
PNG_EXPORT(183, png_const_charp, png_get_libpng_ver,
    (png_const_structrp png_ptr));

#ifdef PNG_MNG_FEATURES_SUPPORTED
PNG_EXPORT(184, png_uint_32, png_permit_mng_features, (png_structrp png_ptr,
    png_uint_32 mng_features_permitted));
#endif

/* For use in png_set_keep_unknown, added to version 1.2.6 */
#define PNG_HANDLE_CHUNK_AS_DEFAULT   0
#define PNG_HANDLE_CHUNK_NEVER        1
#define PNG_HANDLE_CHUNK_IF_SAFE      2
#define PNG_HANDLE_CHUNK_ALWAYS       3
#define PNG_HANDLE_CHUNK_LAST         4

/* Strip the prepended error numbers ("#nnn ") from error and warning
 * messages before passing them to the error or warning handler.
 */
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
PNG_EXPORT(185, void, png_set_strip_error_numbers, (png_structrp png_ptr,
    png_uint_32 strip_mode));
#endif

/* Added in libpng-1.2.6 */
#ifdef PNG_SET_USER_LIMITS_SUPPORTED
PNG_EXPORT(186, void, png_set_user_limits, (png_structrp png_ptr,
    png_uint_32 user_width_max, png_uint_32 user_height_max));
PNG_EXPORT(187, png_uint_32, png_get_user_width_max,
    (png_const_structrp png_ptr));
PNG_EXPORT(188, png_uint_32, png_get_user_height_max,
    (png_const_structrp png_ptr));
/* Added in libpng-1.4.0 */
PNG_EXPORT(189, void, png_set_chunk_cache_max, (png_structrp png_ptr,
    png_uint_32 user_chunk_cache_max));
PNG_EXPORT(190, png_uint_32, png_get_chunk_cache_max,
    (png_const_structrp png_ptr));
/* Added in libpng-1.4.1 */
PNG_EXPORT(191, void, png_set_chunk_malloc_max, (png_structrp png_ptr,
    png_alloc_size_t user_chunk_cache_max));
PNG_EXPORT(192, png_alloc_size_t, png_get_chunk_malloc_max,
    (png_const_structrp png_ptr));
#endif

#if defined(PNG_INCH_CONVERSIONS_SUPPORTED)
PNG_EXPORT(193, png_uint_32, png_get_pixels_per_inch,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

PNG_EXPORT(194, png_uint_32, png_get_x_pixels_per_inch,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

PNG_EXPORT(195, png_uint_32, png_get_y_pixels_per_inch,
    (png_const_structrp png_ptr, png_const_inforp info_ptr));

PNG_FP_EXPORT(196, float, png_get_x_offset_inches,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
#ifdef PNG_FIXED_POINT_SUPPORTED /* otherwise not implemented. */
PNG_FIXED_EXPORT(211, png_fixed_point, png_get_x_offset_inches_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
#endif

PNG_FP_EXPORT(197, float, png_get_y_offset_inches, (png_const_structrp png_ptr,
    png_const_inforp info_ptr))
#ifdef PNG_FIXED_POINT_SUPPORTED /* otherwise not implemented. */
PNG_FIXED_EXPORT(212, png_fixed_point, png_get_y_offset_inches_fixed,
    (png_const_structrp png_ptr, png_const_inforp info_ptr))
#endif

#  ifdef PNG_pHYs_SUPPORTED
PNG_EXPORT(198, png_uint_32, png_get_pHYs_dpi, (png_const_structrp png_ptr,
    png_const_inforp info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
    int *unit_type));
#  endif /* pHYs */
#endif  /* INCH_CONVERSIONS */

/* Added in libpng-1.4.0 */
#ifdef PNG_IO_STATE_SUPPORTED
PNG_EXPORT(199, png_uint_32, png_get_io_state, (png_const_structrp png_ptr));

/* Removed from libpng 1.6; use png_get_io_chunk_type. */
PNG_REMOVED(200, png_const_bytep, png_get_io_chunk_name, (png_structrp png_ptr),
    PNG_DEPRECATED)

PNG_EXPORT(216, png_uint_32, png_get_io_chunk_type,
    (png_const_structrp png_ptr));

/* The flags returned by png_get_io_state() are the following: */
#  define PNG_IO_NONE        0x0000   /* no I/O at this moment */
#  define PNG_IO_READING     0x0001   /* currently reading */
#  define PNG_IO_WRITING     0x0002   /* currently writing */
#  define PNG_IO_SIGNATURE   0x0010   /* currently at the file signature */
#  define PNG_IO_CHUNK_HDR   0x0020   /* currently at the chunk header */
#  define PNG_IO_CHUNK_DATA  0x0040   /* currently at the chunk data */
#  define PNG_IO_CHUNK_CRC   0x0080   /* currently at the chunk crc */
#  define PNG_IO_MASK_OP     0x000f   /* current operation: reading/writing */
#  define PNG_IO_MASK_LOC    0x00f0   /* current location: sig/hdr/data/crc */
#endif /* IO_STATE */

/* Interlace support.  The following macros are always defined so that if
 * libpng interlace handling is turned off the macros may be used to handle
 * interlaced images within the application.
 */
#define PNG_INTERLACE_ADAM7_PASSES 7

/* Two macros to return the first row and first column of the original,
 * full, image which appears in a given pass.  'pass' is in the range 0
 * to 6 and the result is in the range 0 to 7.
 */
#define PNG_PASS_START_ROW(pass) (((1&~(pass))<<(3-((pass)>>1)))&7)
#define PNG_PASS_START_COL(pass) (((1& (pass))<<(3-(((pass)+1)>>1)))&7)

/* A macro to return the offset between pixels in the output row for a pair of
 * pixels in the input - effectively the inverse of the 'COL_SHIFT' macro that
 * follows.  Note that ROW_OFFSET is the offset from one row to the next whereas
 * COL_OFFSET is from one column to the next, within a row.
 */
#define PNG_PASS_ROW_OFFSET(pass) ((pass)>2?(8>>(((pass)-1)>>1)):8)
#define PNG_PASS_COL_OFFSET(pass) (1<<((7-(pass))>>1))

/* Two macros to help evaluate the number of rows or columns in each
 * pass.  This is expressed as a shift - effectively log2 of the number or
 * rows or columns in each 8x8 tile of the original image.
 */
#define PNG_PASS_ROW_SHIFT(pass) ((pass)>2?(8-(pass))>>1:3)
#define PNG_PASS_COL_SHIFT(pass) ((pass)>1?(7-(pass))>>1:3)

/* Hence two macros to determine the number of rows or columns in a given
 * pass of an image given its height or width.  In fact these macros may
 * return non-zero even though the sub-image is empty, because the other
 * dimension may be empty for a small image.
 */
#define PNG_PASS_ROWS(height, pass) (((height)+(((1<<PNG_PASS_ROW_SHIFT(pass))\
   -1)-PNG_PASS_START_ROW(pass)))>>PNG_PASS_ROW_SHIFT(pass))
#define PNG_PASS_COLS(width, pass) (((width)+(((1<<PNG_PASS_COL_SHIFT(pass))\
   -1)-PNG_PASS_START_COL(pass)))>>PNG_PASS_COL_SHIFT(pass))

/* For the reader row callbacks (both progressive and sequential) it is
 * necessary to find the row in the output image given a row in an interlaced
 * image, so two more macros:
 */
#define PNG_ROW_FROM_PASS_ROW(y_in, pass) \
   (((y_in)<<PNG_PASS_ROW_SHIFT(pass))+PNG_PASS_START_ROW(pass))
#define PNG_COL_FROM_PASS_COL(x_in, pass) \
   (((x_in)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))

/* Two macros which return a boolean (0 or 1) saying whether the given row
 * or column is in a particular pass.  These use a common utility macro that
 * returns a mask for a given pass - the offset 'off' selects the row or
 * column version.  The mask has the appropriate bit set for each column in
 * the tile.
 */
#define PNG_PASS_MASK(pass,off) ( \
   ((0x110145AF>>(((7-(off))-(pass))<<2)) & 0xF) | \
   ((0x01145AF0>>(((7-(off))-(pass))<<2)) & 0xF0))

#define PNG_ROW_IN_INTERLACE_PASS(y, pass) \
   ((PNG_PASS_MASK(pass,0) >> ((y)&7)) & 1)
#define PNG_COL_IN_INTERLACE_PASS(x, pass) \
   ((PNG_PASS_MASK(pass,1) >> ((x)&7)) & 1)

#ifdef PNG_READ_COMPOSITE_NODIV_SUPPORTED
/* With these routines we avoid an integer divide, which will be slower on
 * most machines.  However, it does take more operations than the corresponding
 * divide method, so it may be slower on a few RISC systems.  There are two
 * shifts (by 8 or 16 bits) and an addition, versus a single integer divide.
 *
 * Note that the rounding factors are NOT supposed to be the same!  128 and
 * 32768 are correct for the NODIV code; 127 and 32767 are correct for the
 * standard method.
 *
 * [Optimized code by Greg Roelofs and Mark Adler...blame us for bugs. :-) ]
 */

 /* fg and bg should be in `gamma 1.0' space; alpha is the opacity */

#  define png_composite(composite, fg, alpha, bg)        \
   {                                                     \
      png_uint_16 temp = (png_uint_16)((png_uint_16)(fg) \
          * (png_uint_16)(alpha)                         \
          + (png_uint_16)(bg)*(png_uint_16)(255          \
          - (png_uint_16)(alpha)) + 128);                \
      (composite) = (png_byte)(((temp + (temp >> 8)) >> 8) & 0xff); \
   }

#  define png_composite_16(composite, fg, alpha, bg)     \
   {                                                     \
      png_uint_32 temp = (png_uint_32)((png_uint_32)(fg) \
          * (png_uint_32)(alpha)                         \
          + (png_uint_32)(bg)*(65535                     \
          - (png_uint_32)(alpha)) + 32768);              \
      (composite) = (png_uint_16)(0xffff & ((temp + (temp >> 16)) >> 16)); \
   }

#else  /* Standard method using integer division */

#  define png_composite(composite, fg, alpha, bg)                      \
   (composite) =                                                       \
       (png_byte)(0xff & (((png_uint_16)(fg) * (png_uint_16)(alpha) +  \
       (png_uint_16)(bg) * (png_uint_16)(255 - (png_uint_16)(alpha)) + \
       127) / 255))

#  define png_composite_16(composite, fg, alpha, bg)                       \
   (composite) =                                                           \
       (png_uint_16)(0xffff & (((png_uint_32)(fg) * (png_uint_32)(alpha) + \
       (png_uint_32)(bg)*(png_uint_32)(65535 - (png_uint_32)(alpha)) +     \
       32767) / 65535))
#endif /* READ_COMPOSITE_NODIV */

#ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED
PNG_EXPORT(201, png_uint_32, png_get_uint_32, (png_const_bytep buf));
PNG_EXPORT(202, png_uint_16, png_get_uint_16, (png_const_bytep buf));
PNG_EXPORT(203, png_int_32, png_get_int_32, (png_const_bytep buf));
#endif

PNG_EXPORT(204, png_uint_32, png_get_uint_31, (png_const_structrp png_ptr,
    png_const_bytep buf));
/* No png_get_int_16 -- may be added if there's a real need for it. */

/* Place a 32-bit number into a buffer in PNG byte order (big-endian). */
#ifdef PNG_WRITE_INT_FUNCTIONS_SUPPORTED
PNG_EXPORT(205, void, png_save_uint_32, (png_bytep buf, png_uint_32 i));
#endif
#ifdef PNG_SAVE_INT_32_SUPPORTED
PNG_EXPORT(206, void, png_save_int_32, (png_bytep buf, png_int_32 i));
#endif

/* Place a 16-bit number into a buffer in PNG byte order.
 * The parameter is declared unsigned int, not png_uint_16,
 * just to avoid potential problems on pre-ANSI C compilers.
 */
#ifdef PNG_WRITE_INT_FUNCTIONS_SUPPORTED
PNG_EXPORT(207, void, png_save_uint_16, (png_bytep buf, unsigned int i));
/* No png_save_int_16 -- may be added if there's a real need for it. */
#endif

#ifdef PNG_USE_READ_MACROS
/* Inline macros to do direct reads of bytes from the input buffer.
 * The png_get_int_32() routine assumes we are using two's complement
 * format for negative values, which is almost certainly true.
 */
#  define PNG_get_uint_32(buf) \
   (((png_uint_32)(*(buf)) << 24) + \
    ((png_uint_32)(*((buf) + 1)) << 16) + \
    ((png_uint_32)(*((buf) + 2)) << 8) + \
    ((png_uint_32)(*((buf) + 3))))

   /* From libpng-1.4.0 until 1.4.4, the png_get_uint_16 macro (but not the
    * function) incorrectly returned a value of type png_uint_32.
    */
#  define PNG_get_uint_16(buf) \
   ((png_uint_16) \
    (((unsigned int)(*(buf)) << 8) + \
    ((unsigned int)(*((buf) + 1)))))

#  define PNG_get_int_32(buf) \
   ((png_int_32)((*(buf) & 0x80) \
    ? -((png_int_32)(((png_get_uint_32(buf)^0xffffffffU)+1U)&0x7fffffffU)) \
    : (png_int_32)png_get_uint_32(buf)))

/* If PNG_PREFIX is defined the same thing as below happens in pnglibconf.h,
 * but defining a macro name prefixed with PNG_PREFIX.
 */
#  ifndef PNG_PREFIX
#    define png_get_uint_32(buf) PNG_get_uint_32(buf)
#    define png_get_uint_16(buf) PNG_get_uint_16(buf)
#    define png_get_int_32(buf)  PNG_get_int_32(buf)
#  endif
#else
#  ifdef PNG_PREFIX
   /* No macros; revert to the (redefined) function */
#    define PNG_get_uint_32 (png_get_uint_32)
#    define PNG_get_uint_16 (png_get_uint_16)
#    define PNG_get_int_32  (png_get_int_32)
#  endif
#endif

#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
PNG_EXPORT(242, void, png_set_check_for_invalid_index,
    (png_structrp png_ptr, int allowed));
#  ifdef PNG_GET_PALETTE_MAX_SUPPORTED
PNG_EXPORT(243, int, png_get_palette_max, (png_const_structp png_ptr,
    png_const_infop info_ptr));
#  endif
#endif /* CHECK_FOR_INVALID_INDEX */

/*******************************************************************************
 * Section 5: SIMPLIFIED API
 *******************************************************************************
 *
 * Please read the documentation in libpng-manual.txt (TODO: write said
 * documentation) if you don't understand what follows.
 *
 * The simplified API hides the details of both libpng and the PNG file format
 * itself.  It allows PNG files to be read into a very limited number of
 * in-memory bitmap formats or to be written from the same formats.  If these
 * formats do not accomodate your needs then you can, and should, use the more
 * sophisticated APIs above - these support a wide variety of in-memory formats
 * and a wide variety of sophisticated transformations to those formats as well
 * as a wide variety of APIs to manipulate ancillary information.
 *
 * To read a PNG file using the simplified API:
 *
 * 1) Declare a 'png_image' structure (see below) on the stack, set the
 *    version field to PNG_IMAGE_VERSION and the 'opaque' pointer to NULL
 *    (this is REQUIRED, your program may crash if you don't do it.)
 * 2) Call the appropriate png_image_begin_read... function.
 * 3) Set the png_image 'format' member to the required sample format.
 * 4) Allocate a buffer for the image and, if required, the color-map.
 * 5) Call png_image_finish_read to read the image and, if required, the
 *    color-map into your buffers.
 *
 * There are no restrictions on the format of the PNG input itself; all valid
 * color types, bit depths, and interlace methods are acceptable, and the
 * input image is transformed as necessary to the requested in-memory format
 * during the png_image_finish_read() step.  The only caveat is that if you
 * request a color-mapped image from a PNG that is full-color or makes
 * complex use of an alpha channel the transformation is extremely lossy and the
 * result may look terrible.
 *
 * To write a PNG file using the simplified API:
 *
 * 1) Declare a 'png_image' structure on the stack and memset() it to all zero.
 * 2) Initialize the members of the structure that describe the image, setting
 *    the 'format' member to the format of the image samples.
 * 3) Call the appropriate png_image_write... function with a pointer to the
 *    image and, if necessary, the color-map to write the PNG data.
 *
 * png_image is a structure that describes the in-memory format of an image
 * when it is being read or defines the in-memory format of an image that you
 * need to write:
 */
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) || \
    defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)

#define PNG_IMAGE_VERSION 1

typedef struct png_control *png_controlp;
typedef struct
{
   png_controlp opaque;    /* Initialize to NULL, free with png_image_free */
   png_uint_32  version;   /* Set to PNG_IMAGE_VERSION */
   png_uint_32  width;     /* Image width in pixels (columns) */
   png_uint_32  height;    /* Image height in pixels (rows) */
   png_uint_32  format;    /* Image format as defined below */
   png_uint_32  flags;     /* A bit mask containing informational flags */
   png_uint_32  colormap_entries;
                           /* Number of entries in the color-map */

   /* In the event of an error or warning the following field will be set to a
    * non-zero value and the 'message' field will contain a '\0' terminated
    * string with the libpng error or warning message.  If both warnings and
    * an error were encountered, only the error is recorded.  If there
    * are multiple warnings, only the first one is recorded.
    *
    * The upper 30 bits of this value are reserved, the low two bits contain
    * a value as follows:
    */
#  define PNG_IMAGE_WARNING 1
#  define PNG_IMAGE_ERROR 2
   /*
    * The result is a two-bit code such that a value more than 1 indicates
    * a failure in the API just called:
    *
    *    0 - no warning or error
    *    1 - warning
    *    2 - error
    *    3 - error preceded by warning
    */
#  define PNG_IMAGE_FAILED(png_cntrl) ((((png_cntrl).warning_or_error)&0x03)>1)

   png_uint_32  warning_or_error;

   char         message[64];
} png_image, *png_imagep;

/* The samples of the image have one to four channels whose components have
 * original values in the range 0 to 1.0:
 *
 * 1: A single gray or luminance channel (G).
 * 2: A gray/luminance channel and an alpha channel (GA).
 * 3: Three red, green, blue color channels (RGB).
 * 4: Three color channels and an alpha channel (RGBA).
 *
 * The components are encoded in one of two ways:
 *
 * a) As a small integer, value 0..255, contained in a single byte.  For the
 * alpha channel the original value is simply value/255.  For the color or
 * luminance channels the value is encoded according to the sRGB specification
 * and matches the 8-bit format expected by typical display devices.
 *
 * The color/gray channels are not scaled (pre-multiplied) by the alpha
 * channel and are suitable for passing to color management software.
 *
 * b) As a value in the range 0..65535, contained in a 2-byte integer.  All
 * channels can be converted to the original value by dividing by 65535; all
 * channels are linear.  Color channels use the RGB encoding (RGB end-points) of
 * the sRGB specification.  This encoding is identified by the
 * PNG_FORMAT_FLAG_LINEAR flag below.
 *
 * When the simplified API needs to convert between sRGB and linear colorspaces,
 * the actual sRGB transfer curve defined in the sRGB specification (see the
 * article at http://en.wikipedia.org/wiki/SRGB) is used, not the gamma=1/2.2
 * approximation used elsewhere in libpng.
 *
 * When an alpha channel is present it is expected to denote pixel coverage
 * of the color or luminance channels and is returned as an associated alpha
 * channel: the color/gray channels are scaled (pre-multiplied) by the alpha
 * value.
 *
 * The samples are either contained directly in the image data, between 1 and 8
 * bytes per pixel according to the encoding, or are held in a color-map indexed
 * by bytes in the image data.  In the case of a color-map the color-map entries
 * are individual samples, encoded as above, and the image data has one byte per
 * pixel to select the relevant sample from the color-map.
 */

/* PNG_FORMAT_*
 *
 * #defines to be used in png_image::format.  Each #define identifies a
 * particular layout of sample data and, if present, alpha values.  There are
 * separate defines for each of the two component encodings.
 *
 * A format is built up using single bit flag values.  All combinations are
 * valid.  Formats can be built up from the flag values or you can use one of
 * the predefined values below.  When testing formats always use the FORMAT_FLAG
 * macros to test for individual features - future versions of the library may
 * add new flags.
 *
 * When reading or writing color-mapped images the format should be set to the
 * format of the entries in the color-map then png_image_{read,write}_colormap
 * called to read or write the color-map and set the format correctly for the
 * image data.  Do not set the PNG_FORMAT_FLAG_COLORMAP bit directly!
 *
 * NOTE: libpng can be built with particular features disabled. If you see
 * compiler errors because the definition of one of the following flags has been
 * compiled out it is because libpng does not have the required support.  It is
 * possible, however, for the libpng configuration to enable the format on just
 * read or just write; in that case you may see an error at run time.  You can
 * guard against this by checking for the definition of the appropriate
 * "_SUPPORTED" macro, one of:
 *
 *    PNG_SIMPLIFIED_{READ,WRITE}_{BGR,AFIRST}_SUPPORTED
 */
#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2-byte channels else 1-byte */
#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */

#ifdef PNG_FORMAT_BGR_SUPPORTED
#  define PNG_FORMAT_FLAG_BGR    0x10U /* BGR colors, else order is RGB */
#endif

#ifdef PNG_FORMAT_AFIRST_SUPPORTED
#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
#endif

/* Commonly used formats have predefined macros.
 *
 * First the single byte (sRGB) formats:
 */
#define PNG_FORMAT_GRAY 0
#define PNG_FORMAT_GA   PNG_FORMAT_FLAG_ALPHA
#define PNG_FORMAT_AG   (PNG_FORMAT_GA|PNG_FORMAT_FLAG_AFIRST)
#define PNG_FORMAT_RGB  PNG_FORMAT_FLAG_COLOR
#define PNG_FORMAT_BGR  (PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_BGR)
#define PNG_FORMAT_RGBA (PNG_FORMAT_RGB|PNG_FORMAT_FLAG_ALPHA)
#define PNG_FORMAT_ARGB (PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_AFIRST)
#define PNG_FORMAT_BGRA (PNG_FORMAT_BGR|PNG_FORMAT_FLAG_ALPHA)
#define PNG_FORMAT_ABGR (PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_AFIRST)

/* Then the linear 2-byte formats.  When naming these "Y" is used to
 * indicate a luminance (gray) channel.
 */
#define PNG_FORMAT_LINEAR_Y PNG_FORMAT_FLAG_LINEAR
#define PNG_FORMAT_LINEAR_Y_ALPHA (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_ALPHA)
#define PNG_FORMAT_LINEAR_RGB (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR)
#define PNG_FORMAT_LINEAR_RGB_ALPHA \
   (PNG_FORMAT_FLAG_LINEAR|PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA)

/* With color-mapped formats the image data is one byte for each pixel, the byte
 * is an index into the color-map which is formatted as above.  To obtain a
 * color-mapped format it is sufficient just to add the PNG_FOMAT_FLAG_COLORMAP
 * to one of the above definitions, or you can use one of the definitions below.
 */
#define PNG_FORMAT_RGB_COLORMAP  (PNG_FORMAT_RGB|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_BGR_COLORMAP  (PNG_FORMAT_BGR|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_RGBA_COLORMAP (PNG_FORMAT_RGBA|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_ARGB_COLORMAP (PNG_FORMAT_ARGB|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_BGRA_COLORMAP (PNG_FORMAT_BGRA|PNG_FORMAT_FLAG_COLORMAP)
#define PNG_FORMAT_ABGR_COLORMAP (PNG_FORMAT_ABGR|PNG_FORMAT_FLAG_COLORMAP)

/* PNG_IMAGE macros
 *
 * These are convenience macros to derive information from a png_image
 * structure.  The PNG_IMAGE_SAMPLE_ macros return values appropriate to the
 * actual image sample values - either the entries in the color-map or the
 * pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values
 * for the pixels and will always return 1 for color-mapped formats.  The
 * remaining macros return information about the rows in the image and the
 * complete image.
 *
 * NOTE: All the macros that take a png_image::format parameter are compile time
 * constants if the format parameter is, itself, a constant.  Therefore these
 * macros can be used in array declarations and case labels where required.
 * Similarly the macros are also pre-processor constants (sizeof is not used) so
 * they can be used in #if tests.
 *
 * First the information about the samples.
 */
#define PNG_IMAGE_SAMPLE_CHANNELS(fmt)\
   (((fmt)&(PNG_FORMAT_FLAG_COLOR|PNG_FORMAT_FLAG_ALPHA))+1)
   /* Return the total number of channels in a given format: 1..4 */

#define PNG_IMAGE_SAMPLE_COMPONENT_SIZE(fmt)\
   ((((fmt) & PNG_FORMAT_FLAG_LINEAR) >> 2)+1)
   /* Return the size in bytes of a single component of a pixel or color-map
    * entry (as appropriate) in the image: 1 or 2.
    */

#define PNG_IMAGE_SAMPLE_SIZE(fmt)\
   (PNG_IMAGE_SAMPLE_CHANNELS(fmt) * PNG_IMAGE_SAMPLE_COMPONENT_SIZE(fmt))
   /* This is the size of the sample data for one sample.  If the image is
    * color-mapped it is the size of one color-map entry (and image pixels are
    * one byte in size), otherwise it is the size of one image pixel.
    */

#define PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(fmt)\
   (PNG_IMAGE_SAMPLE_CHANNELS(fmt) * 256)
   /* The maximum size of the color-map required by the format expressed in a
    * count of components.  This can be used to compile-time allocate a
    * color-map:
    *
    * png_uint_16 colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(linear_fmt)];
    *
    * png_byte colormap[PNG_IMAGE_MAXIMUM_COLORMAP_COMPONENTS(sRGB_fmt)];
    *
    * Alternatively use the PNG_IMAGE_COLORMAP_SIZE macro below to use the
    * information from one of the png_image_begin_read_ APIs and dynamically
    * allocate the required memory.
    */

/* Corresponding information about the pixels */
#define PNG_IMAGE_PIXEL_(test,fmt)\
   (((fmt)&PNG_FORMAT_FLAG_COLORMAP)?1:test(fmt))

#define PNG_IMAGE_PIXEL_CHANNELS(fmt)\
   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_CHANNELS,fmt)
   /* The number of separate channels (components) in a pixel; 1 for a
    * color-mapped image.
    */

#define PNG_IMAGE_PIXEL_COMPONENT_SIZE(fmt)\
   PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_COMPONENT_SIZE,fmt)
   /* The size, in bytes, of each component in a pixel; 1 for a color-mapped
    * image.
    */

#define PNG_IMAGE_PIXEL_SIZE(fmt) PNG_IMAGE_PIXEL_(PNG_IMAGE_SAMPLE_SIZE,fmt)
   /* The size, in bytes, of a complete pixel; 1 for a color-mapped image. */

/* Information about the whole row, or whole image */
#define PNG_IMAGE_ROW_STRIDE(image)\
   (PNG_IMAGE_PIXEL_CHANNELS((image).format) * (image).width)
   /* Return the total number of components in a single row of the image; this
    * is the minimum 'row stride', the minimum count of components between each
    * row.  For a color-mapped image this is the minimum number of bytes in a
    * row.
    *
    * WARNING: this macro overflows for some images with more than one component
    * and very large image widths.  libpng will refuse to process an image where
    * this macro would overflow.
    */

#define PNG_IMAGE_BUFFER_SIZE(image, row_stride)\
   (PNG_IMAGE_PIXEL_COMPONENT_SIZE((image).format)*(image).height*(row_stride))
   /* Return the size, in bytes, of an image buffer given a png_image and a row
    * stride - the number of components to leave space for in each row.
    *
    * WARNING: this macro overflows a 32-bit integer for some large PNG images,
    * libpng will refuse to process an image where such an overflow would occur.
    */

#define PNG_IMAGE_SIZE(image)\
   PNG_IMAGE_BUFFER_SIZE(image, PNG_IMAGE_ROW_STRIDE(image))
   /* Return the size, in bytes, of the image in memory given just a png_image;
    * the row stride is the minimum stride required for the image.
    */

#define PNG_IMAGE_COLORMAP_SIZE(image)\
   (PNG_IMAGE_SAMPLE_SIZE((image).format) * (image).colormap_entries)
   /* Return the size, in bytes, of the color-map of this image.  If the image
    * format is not a color-map format this will return a size sufficient for
    * 256 entries in the given format; check PNG_FORMAT_FLAG_COLORMAP if
    * you don't want to allocate a color-map in this case.
    */

/* PNG_IMAGE_FLAG_*
 *
 * Flags containing additional information about the image are held in the
 * 'flags' field of png_image.
 */
#define PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB 0x01
   /* This indicates the the RGB values of the in-memory bitmap do not
    * correspond to the red, green and blue end-points defined by sRGB.
    */

#define PNG_IMAGE_FLAG_FAST 0x02
   /* On write emphasise speed over compression; the resultant PNG file will be
    * larger but will be produced significantly faster, particular for large
    * images.  Do not use this option for images which will be distributed, only
    * used it when producing intermediate files that will be read back in
    * repeatedly.  For a typical 24-bit image the option will double the read
    * speed at the cost of increasing the image size by 25%, however for many
    * more compressible images the PNG file can be 10 times larger with only a
    * slight speed gain.
    */

#define PNG_IMAGE_FLAG_16BIT_sRGB 0x04
   /* On read if the image is a 16-bit per component image and there is no gAMA
    * or sRGB chunk assume that the components are sRGB encoded.  Notice that
    * images output by the simplified API always have gamma information; setting
    * this flag only affects the interpretation of 16-bit images from an
    * external source.  It is recommended that the application expose this flag
    * to the user; the user can normally easily recognize the difference between
    * linear and sRGB encoding.  This flag has no effect on write - the data
    * passed to the write APIs must have the correct encoding (as defined
    * above.)
    *
    * If the flag is not set (the default) input 16-bit per component data is
    * assumed to be linear.
    *
    * NOTE: the flag can only be set after the png_image_begin_read_ call,
    * because that call initializes the 'flags' field.
    */

#ifdef PNG_SIMPLIFIED_READ_SUPPORTED
/* READ APIs
 * ---------
 *
 * The png_image passed to the read APIs must have been initialized by setting
 * the png_controlp field 'opaque' to NULL (or, safer, memset the whole thing.)
 */
#ifdef PNG_STDIO_SUPPORTED
PNG_EXPORT(234, int, png_image_begin_read_from_file, (png_imagep image,
   const char *file_name));
   /* The named file is opened for read and the image header is filled in
    * from the PNG header in the file.
    */

PNG_EXPORT(235, int, png_image_begin_read_from_stdio, (png_imagep image,
   FILE* file));
   /* The PNG header is read from the stdio FILE object. */
#endif /* STDIO */

PNG_EXPORT(236, int, png_image_begin_read_from_memory, (png_imagep image,
   png_const_voidp memory, png_size_t size));
   /* The PNG header is read from the given memory buffer. */

PNG_EXPORT(237, int, png_image_finish_read, (png_imagep image,
   png_const_colorp background, void *buffer, png_int_32 row_stride,
   void *colormap));
   /* Finish reading the image into the supplied buffer and clean up the
    * png_image structure.
    *
    * row_stride is the step, in byte or 2-byte units as appropriate,
    * between adjacent rows.  A positive stride indicates that the top-most row
    * is first in the buffer - the normal top-down arrangement.  A negative
    * stride indicates that the bottom-most row is first in the buffer.
    *
    * background need only be supplied if an alpha channel must be removed from
    * a png_byte format and the removal is to be done by compositing on a solid
    * color; otherwise it may be NULL and any composition will be done directly
    * onto the buffer.  The value is an sRGB color to use for the background,
    * for grayscale output the green channel is used.
    *
    * background must be supplied when an alpha channel must be removed from a
    * single byte color-mapped output format, in other words if:
    *
    * 1) The original format from png_image_begin_read_from_* had
    *    PNG_FORMAT_FLAG_ALPHA set.
    * 2) The format set by the application does not.
    * 3) The format set by the application has PNG_FORMAT_FLAG_COLORMAP set and
    *    PNG_FORMAT_FLAG_LINEAR *not* set.
    *
    * For linear output removing the alpha channel is always done by compositing
    * on black and background is ignored.
    *
    * colormap must be supplied when PNG_FORMAT_FLAG_COLORMAP is set.  It must
    * be at least the size (in bytes) returned by PNG_IMAGE_COLORMAP_SIZE.
    * image->colormap_entries will be updated to the actual number of entries
    * written to the colormap; this may be less than the original value.
    */

PNG_EXPORT(238, void, png_image_free, (png_imagep image));
   /* Free any data allocated by libpng in image->opaque, setting the pointer to
    * NULL.  May be called at any time after the structure is initialized.
    */
#endif /* SIMPLIFIED_READ */

#ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
/* WRITE APIS
 * ----------
 * For write you must initialize a png_image structure to describe the image to
 * be written.  To do this use memset to set the whole structure to 0 then
 * initialize fields describing your image.
 *
 * version: must be set to PNG_IMAGE_VERSION
 * opaque: must be initialized to NULL
 * width: image width in pixels
 * height: image height in rows
 * format: the format of the data (image and color-map) you wish to write
 * flags: set to 0 unless one of the defined flags applies; set
 *    PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB for color format images where the RGB
 *    values do not correspond to the colors in sRGB.
 * colormap_entries: set to the number of entries in the color-map (0 to 256)
 */
#ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
PNG_EXPORT(239, int, png_image_write_to_file, (png_imagep image,
   const char *file, int convert_to_8bit, const void *buffer,
   png_int_32 row_stride, const void *colormap));
   /* Write the image to the named file. */

PNG_EXPORT(240, int, png_image_write_to_stdio, (png_imagep image, FILE *file,
   int convert_to_8_bit, const void *buffer, png_int_32 row_stride,
   const void *colormap));
   /* Write the image to the given (FILE*). */
#endif /* SIMPLIFIED_WRITE_STDIO */

/* With all write APIs if image is in one of the linear formats with 16-bit
 * data then setting convert_to_8_bit will cause the output to be an 8-bit PNG
 * gamma encoded according to the sRGB specification, otherwise a 16-bit linear
 * encoded PNG file is written.
 *
 * With color-mapped data formats the colormap parameter point to a color-map
 * with at least image->colormap_entries encoded in the specified format.  If
 * the format is linear the written PNG color-map will be converted to sRGB
 * regardless of the convert_to_8_bit flag.
 *
 * With all APIs row_stride is handled as in the read APIs - it is the spacing
 * from one row to the next in component sized units (1 or 2 bytes) and if
 * negative indicates a bottom-up row layout in the buffer.  If row_stride is
 * zero, libpng will calculate it for you from the image width and number of
 * channels.
 *
 * Note that the write API does not support interlacing, sub-8-bit pixels or
 * most ancillary chunks.  If you need to write text chunks (e.g. for copyright
 * notices) you need to use one of the other APIs.
 */

PNG_EXPORT(245, int, png_image_write_to_memory, (png_imagep image, void *memory,
   png_alloc_size_t * PNG_RESTRICT memory_bytes, int convert_to_8_bit,
   const void *buffer, png_int_32 row_stride, const void *colormap));
   /* Write the image to the given memory buffer.  The function both writes the
    * whole PNG data stream to *memory and updates *memory_bytes with the count
    * of bytes written.
    *
    * 'memory' may be NULL.  In this case *memory_bytes is not read however on
    * success the number of bytes which would have been written will still be
    * stored in *memory_bytes.  On failure *memory_bytes will contain 0.
    *
    * If 'memory' is not NULL it must point to memory[*memory_bytes] of
    * writeable memory.
    *
    * If the function returns success memory[*memory_bytes] (if 'memory' is not
    * NULL) contains the written PNG data.  *memory_bytes will always be less
    * than or equal to the original value.
    *
    * If the function returns false and *memory_bytes was not changed an error
    * occured during write.  If *memory_bytes was changed, or is not 0 if
    * 'memory' was NULL, the write would have succeeded but for the memory
    * buffer being too small.  *memory_bytes contains the required number of
    * bytes and will be bigger that the original value.
    */

#define png_image_write_get_memory_size(image, size, convert_to_8_bit, buffer,\
   row_stride, colormap)\
   png_image_write_to_memory(&(image), 0, &(size), convert_to_8_bit, buffer,\
         row_stride, colormap)
   /* Return the amount of memory in 'size' required to compress this image.
    * The png_image structure 'image' must be filled in as in the above
    * function and must not be changed before the actual write call, the buffer
    * and all other parameters must also be identical to that in the final
    * write call.  The 'size' variable need not be initialized.
    *
    * NOTE: the macro returns true/false, if false is returned 'size' will be
    * set to zero and the write failed and probably will fail if tried again.
    */

/* You can pre-allocate the buffer by making sure it is of sufficient size
 * regardless of the amount of compression achieved.  The buffer size will
 * always be bigger than the original image and it will never be filled.  The
 * following macros are provided to assist in allocating the buffer.
 */
#define PNG_IMAGE_DATA_SIZE(image) (PNG_IMAGE_SIZE(image)+(image).height)
   /* The number of uncompressed bytes in the PNG byte encoding of the image;
    * uncompressing the PNG IDAT data will give this number of bytes.
    *
    * NOTE: while PNG_IMAGE_SIZE cannot overflow for an image in memory this
    * macro can because of the extra bytes used in the PNG byte encoding.  You
    * need to avoid this macro if your image size approaches 2^30 in width or
    * height.  The same goes for the remainder of these macros; they all produce
    * bigger numbers than the actual in-memory image size.
    */
#ifndef PNG_ZLIB_MAX_SIZE
#  define PNG_ZLIB_MAX_SIZE(b) ((b)+(((b)+7U)>>3)+(((b)+63U)>>6)+11U)
   /* An upper bound on the number of compressed bytes given 'b' uncompressed
    * bytes.  This is based on deflateBounds() in zlib; different
    * implementations of zlib compression may conceivably produce more data so
    * if your zlib implementation is not zlib itself redefine this macro
    * appropriately.
    */
#endif

#define PNG_IMAGE_COMPRESSED_SIZE_MAX(image)\
   PNG_ZLIB_MAX_SIZE((png_alloc_size_t)PNG_IMAGE_DATA_SIZE(image))
   /* An upper bound on the size of the data in the PNG IDAT chunks. */

#define PNG_IMAGE_PNG_SIZE_MAX_(image, image_size)\
   ((8U/*sig*/+25U/*IHDR*/+16U/*gAMA*/+44U/*cHRM*/+12U/*IEND*/+\
    (((image).format&PNG_FORMAT_FLAG_COLORMAP)?/*colormap: PLTE, tRNS*/\
    12U+3U*(image).colormap_entries/*PLTE data*/+\
    (((image).format&PNG_FORMAT_FLAG_ALPHA)?\
    12U/*tRNS*/+(image).colormap_entries:0U):0U)+\
    12U)+(12U*((image_size)/PNG_ZBUF_SIZE))/*IDAT*/+(image_size))
   /* A helper for the following macro; if your compiler cannot handle the
    * following macro use this one with the result of
    * PNG_IMAGE_COMPRESSED_SIZE_MAX(image) as the second argument (most
    * compilers should handle this just fine.)
    */

#define PNG_IMAGE_PNG_SIZE_MAX(image)\
   PNG_IMAGE_PNG_SIZE_MAX_(image, PNG_IMAGE_COMPRESSED_SIZE_MAX(image))
   /* An upper bound on the total length of the PNG data stream for 'image'.
    * The result is of type png_alloc_size_t, on 32-bit systems this may
    * overflow even though PNG_IMAGE_DATA_SIZE does not overflow; the write will
    * run out of buffer space but return a corrected size which should work.
    */
#endif /* SIMPLIFIED_WRITE */
/*******************************************************************************
 *  END OF SIMPLIFIED API
 ******************************************************************************/
#endif /* SIMPLIFIED_{READ|WRITE} */

/*******************************************************************************
 * Section 6: IMPLEMENTATION OPTIONS
 *******************************************************************************
 *
 * Support for arbitrary implementation-specific optimizations.  The API allows
 * particular options to be turned on or off.  'Option' is the number of the
 * option and 'onoff' is 0 (off) or non-0 (on).  The value returned is given
 * by the PNG_OPTION_ defines below.
 *
 * HARDWARE: normally hardware capabilites, such as the Intel SSE instructions,
 *           are detected at run time, however sometimes it may be impossible
 *           to do this in user mode, in which case it is necessary to discover
 *           the capabilities in an OS specific way.  Such capabilities are
 *           listed here when libpng has support for them and must be turned
 *           ON by the application if present.
 *
 * SOFTWARE: sometimes software optimizations actually result in performance
 *           decrease on some architectures or systems, or with some sets of
 *           PNG images.  'Software' options allow such optimizations to be
 *           selected at run time.
 */
#ifdef PNG_SET_OPTION_SUPPORTED
#ifdef PNG_ARM_NEON_API_SUPPORTED
#  define PNG_ARM_NEON   0 /* HARDWARE: ARM Neon SIMD instructions supported */
#endif
#define PNG_MAXIMUM_INFLATE_WINDOW 2 /* SOFTWARE: force maximum window */
#define PNG_SKIP_sRGB_CHECK_PROFILE 4 /* SOFTWARE: Check ICC profile for sRGB */
#ifdef PNG_MIPS_MSA_API_SUPPORTED
#  define PNG_MIPS_MSA   6 /* HARDWARE: MIPS Msa SIMD instructions supported */
#endif
#define PNG_IGNORE_ADLER32 8
#define PNG_OPTION_NEXT  10 /* Next option - numbers must be even */

/* Return values: NOTE: there are four values and 'off' is *not* zero */
#define PNG_OPTION_UNSET   0 /* Unset - defaults to off */
#define PNG_OPTION_INVALID 1 /* Option number out of range */
#define PNG_OPTION_OFF     2
#define PNG_OPTION_ON      3

PNG_EXPORT(244, int, png_set_option, (png_structrp png_ptr, int option,
   int onoff));
#endif /* SET_OPTION */

/*******************************************************************************
 *  END OF HARDWARE AND SOFTWARE OPTIONS
 ******************************************************************************/

/* Maintainer: Put new public prototypes here ^, in libpng.3, in project
 * defs, and in scripts/symbols.def.
 */

/* The last ordinal number (this is the *last* one already used; the next
 * one to use is one more than this.)
 */
#ifdef PNG_EXPORT_LAST_ORDINAL
  PNG_EXPORT_LAST_ORDINAL(245);
#endif

#ifdef __cplusplus
}
#endif

#endif /* PNG_VERSION_INFO_ONLY */
/* Do not put anything past this line */
#endif /* PNG_H */

```

`ThirdPartyBuild/PNG/Code/pngconf.h`:

```h

/* pngconf.h - machine configurable file for libpng
 *
 * libpng version 1.6.28, January 5, 2017
 *
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * Any machine specific code is near the front of this file, so if you
 * are configuring libpng for a machine, you may want to read the section
 * starting here down to where it starts to typedef png_color, png_text,
 * and png_info.
 */

#ifndef PNGCONF_H
#define PNGCONF_H

#ifndef PNG_BUILDING_SYMBOL_TABLE /* else includes may cause problems */

/* From libpng 1.6.0 libpng requires an ANSI X3.159-1989 ("ISOC90") compliant C
 * compiler for correct compilation.  The following header files are required by
 * the standard.  If your compiler doesn't provide these header files, or they
 * do not match the standard, you will need to provide/improve them.
 */
#include <limits.h>
#include <stddef.h>

/* Library header files.  These header files are all defined by ISOC90; libpng
 * expects conformant implementations, however, an ISOC90 conformant system need
 * not provide these header files if the functionality cannot be implemented.
 * In this case it will be necessary to disable the relevant parts of libpng in
 * the build of pnglibconf.h.
 *
 * Prior to 1.6.0 string.h was included here; the API changes in 1.6.0 to not
 * include this unnecessary header file.
 */

#ifdef PNG_STDIO_SUPPORTED
   /* Required for the definition of FILE: */
#  include <stdio.h>
#endif

#ifdef PNG_SETJMP_SUPPORTED
   /* Required for the definition of jmp_buf and the declaration of longjmp: */
#  include <setjmp.h>
#endif

#ifdef PNG_CONVERT_tIME_SUPPORTED
   /* Required for struct tm: */
#  include <time.h>
#endif

#endif /* PNG_BUILDING_SYMBOL_TABLE */

/* Prior to 1.6.0 it was possible to turn off 'const' in declarations using
 * PNG_NO_CONST; this is no longer supported except for data declarations which
 * apparently still cause problems in 2011 on some compilers.
 */
#define PNG_CONST const /* backward compatibility only */

/* This controls optimization of the reading of 16-bit and 32-bit values
 * from PNG files.  It can be set on a per-app-file basis - it
 * just changes whether a macro is used when the function is called.
 * The library builder sets the default; if read functions are not
 * built into the library the macro implementation is forced on.
 */
#ifndef PNG_READ_INT_FUNCTIONS_SUPPORTED
#  define PNG_USE_READ_MACROS
#endif
#if !defined(PNG_NO_USE_READ_MACROS) && !defined(PNG_USE_READ_MACROS)
#  if PNG_DEFAULT_READ_MACROS
#    define PNG_USE_READ_MACROS
#  endif
#endif

/* COMPILER SPECIFIC OPTIONS.
 *
 * These options are provided so that a variety of difficult compilers
 * can be used.  Some are fixed at build time (e.g. PNG_API_RULE
 * below) but still have compiler specific implementations, others
 * may be changed on a per-file basis when compiling against libpng.
 */

/* The PNGARG macro was used in versions of libpng prior to 1.6.0 to protect
 * against legacy (pre ISOC90) compilers that did not understand function
 * prototypes.  It is not required for modern C compilers.
 */
#ifndef PNGARG
#  define PNGARG(arglist) arglist
#endif

/* Function calling conventions.
 * =============================
 * Normally it is not necessary to specify to the compiler how to call
 * a function - it just does it - however on x86 systems derived from
 * Microsoft and Borland C compilers ('IBM PC', 'DOS', 'Windows' systems
 * and some others) there are multiple ways to call a function and the
 * default can be changed on the compiler command line.  For this reason
 * libpng specifies the calling convention of every exported function and
 * every function called via a user supplied function pointer.  This is
 * done in this file by defining the following macros:
 *
 * PNGAPI    Calling convention for exported functions.
 * PNGCBAPI  Calling convention for user provided (callback) functions.
 * PNGCAPI   Calling convention used by the ANSI-C library (required
 *           for longjmp callbacks and sometimes used internally to
 *           specify the calling convention for zlib).
 *
 * These macros should never be overridden.  If it is necessary to
 * change calling convention in a private build this can be done
 * by setting PNG_API_RULE (which defaults to 0) to one of the values
 * below to select the correct 'API' variants.
 *
 * PNG_API_RULE=0 Use PNGCAPI - the 'C' calling convention - throughout.
 *                This is correct in every known environment.
 * PNG_API_RULE=1 Use the operating system convention for PNGAPI and
 *                the 'C' calling convention (from PNGCAPI) for
 *                callbacks (PNGCBAPI).  This is no longer required
 *                in any known environment - if it has to be used
 *                please post an explanation of the problem to the
 *                libpng mailing list.
 *
 * These cases only differ if the operating system does not use the C
 * calling convention, at present this just means the above cases
 * (x86 DOS/Windows systems) and, even then, this does not apply to
 * Cygwin running on those systems.
 *
 * Note that the value must be defined in pnglibconf.h so that what
 * the application uses to call the library matches the conventions
 * set when building the library.
 */

/* Symbol export
 * =============
 * When building a shared library it is almost always necessary to tell
 * the compiler which symbols to export.  The png.h macro 'PNG_EXPORT'
 * is used to mark the symbols.  On some systems these symbols can be
 * extracted at link time and need no special processing by the compiler,
 * on other systems the symbols are flagged by the compiler and just
 * the declaration requires a special tag applied (unfortunately) in a
 * compiler dependent way.  Some systems can do either.
 *
 * A small number of older systems also require a symbol from a DLL to
 * be flagged to the program that calls it.  This is a problem because
 * we do not know in the header file included by application code that
 * the symbol will come from a shared library, as opposed to a statically
 * linked one.  For this reason the application must tell us by setting
 * the magic flag PNG_USE_DLL to turn on the special processing before
 * it includes png.h.
 *
 * Four additional macros are used to make this happen:
 *
 * PNG_IMPEXP The magic (if any) to cause a symbol to be exported from
 *            the build or imported if PNG_USE_DLL is set - compiler
 *            and system specific.
 *
 * PNG_EXPORT_TYPE(type) A macro that pre or appends PNG_IMPEXP to
 *                       'type', compiler specific.
 *
 * PNG_DLL_EXPORT Set to the magic to use during a libpng build to
 *                make a symbol exported from the DLL.  Not used in the
 *                public header files; see pngpriv.h for how it is used
 *                in the libpng build.
 *
 * PNG_DLL_IMPORT Set to the magic to force the libpng symbols to come
 *                from a DLL - used to define PNG_IMPEXP when
 *                PNG_USE_DLL is set.
 */

/* System specific discovery.
 * ==========================
 * This code is used at build time to find PNG_IMPEXP, the API settings
 * and PNG_EXPORT_TYPE(), it may also set a macro to indicate the DLL
 * import processing is possible.  On Windows systems it also sets
 * compiler-specific macros to the values required to change the calling
 * conventions of the various functions.
 */
#if defined(_Windows) || defined(_WINDOWS) || defined(WIN32) ||\
    defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
  /* Windows system (DOS doesn't support DLLs).  Includes builds under Cygwin or
   * MinGW on any architecture currently supported by Windows.  Also includes
   * Watcom builds but these need special treatment because they are not
   * compatible with GCC or Visual C because of different calling conventions.
   */
#  if PNG_API_RULE == 2
   /* If this line results in an error, either because __watcall is not
    * understood or because of a redefine just below you cannot use *this*
    * build of the library with the compiler you are using.  *This* build was
    * build using Watcom and applications must also be built using Watcom!
    */
#    define PNGCAPI __watcall
#  endif

#  if defined(__GNUC__) || (defined(_MSC_VER) && (_MSC_VER >= 800))
#    define PNGCAPI __cdecl
#    if PNG_API_RULE == 1
   /* If this line results in an error __stdcall is not understood and
    * PNG_API_RULE should not have been set to '1'.
    */
#      define PNGAPI __stdcall
#    endif
#  else
   /* An older compiler, or one not detected (erroneously) above,
    * if necessary override on the command line to get the correct
    * variants for the compiler.
    */
#    ifndef PNGCAPI
#      define PNGCAPI _cdecl
#    endif
#    if PNG_API_RULE == 1 && !defined(PNGAPI)
#      define PNGAPI _stdcall
#    endif
#  endif /* compiler/api */

  /* NOTE: PNGCBAPI always defaults to PNGCAPI. */

#  if defined(PNGAPI) && !defined(PNG_USER_PRIVATEBUILD)
#     error "PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed"
#  endif

#  if (defined(_MSC_VER) && _MSC_VER < 800) ||\
      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
   /* older Borland and MSC
    * compilers used '__export' and required this to be after
    * the type.
    */
#    ifndef PNG_EXPORT_TYPE
#      define PNG_EXPORT_TYPE(type) type PNG_IMPEXP
#    endif
#    define PNG_DLL_EXPORT __export
#  else /* newer compiler */
#    define PNG_DLL_EXPORT __declspec(dllexport)
#    ifndef PNG_DLL_IMPORT
#      define PNG_DLL_IMPORT __declspec(dllimport)
#    endif
#  endif /* compiler */

#else /* !Windows */
#  if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
#    define PNGAPI _System
#  else /* !Windows/x86 && !OS/2 */
   /* Use the defaults, or define PNG*API on the command line (but
    * this will have to be done for every compile!)
    */
#  endif /* other system, !OS/2 */
#endif /* !Windows/x86 */

/* Now do all the defaulting . */
#ifndef PNGCAPI
#  define PNGCAPI
#endif
#ifndef PNGCBAPI
#  define PNGCBAPI PNGCAPI
#endif
#ifndef PNGAPI
#  define PNGAPI PNGCAPI
#endif

/* PNG_IMPEXP may be set on the compilation system command line or (if not set)
 * then in an internal header file when building the library, otherwise (when
 * using the library) it is set here.
 */
#ifndef PNG_IMPEXP
#  if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
   /* This forces use of a DLL, disallowing static linking */
#    define PNG_IMPEXP PNG_DLL_IMPORT
#  endif

#  ifndef PNG_IMPEXP
#    define PNG_IMPEXP
#  endif
#endif

/* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
 * 'attributes' as a storage class - the attributes go at the start of the
 * function definition, and attributes are always appended regardless of the
 * compiler.  This considerably simplifies these macros but may cause problems
 * if any compilers both need function attributes and fail to handle them as
 * a storage class (this is unlikely.)
 */
#ifndef PNG_FUNCTION
#  define PNG_FUNCTION(type, name, args, attributes) attributes type name args
#endif

#ifndef PNG_EXPORT_TYPE
#  define PNG_EXPORT_TYPE(type) PNG_IMPEXP type
#endif

   /* The ordinal value is only relevant when preprocessing png.h for symbol
    * table entries, so we discard it here.  See the .dfn files in the
    * scripts directory.
    */

#ifndef PNG_EXPORTA
#  define PNG_EXPORTA(ordinal, type, name, args, attributes) \
      PNG_FUNCTION(PNG_EXPORT_TYPE(type), (PNGAPI name), PNGARG(args), \
      PNG_LINKAGE_API attributes)
#endif

/* ANSI-C (C90) does not permit a macro to be invoked with an empty argument,
 * so make something non-empty to satisfy the requirement:
 */
#define PNG_EMPTY /*empty list*/

#define PNG_EXPORT(ordinal, type, name, args) \
   PNG_EXPORTA(ordinal, type, name, args, PNG_EMPTY)

/* Use PNG_REMOVED to comment out a removed interface. */
#ifndef PNG_REMOVED
#  define PNG_REMOVED(ordinal, type, name, args, attributes)
#endif

#ifndef PNG_CALLBACK
#  define PNG_CALLBACK(type, name, args) type (PNGCBAPI name) PNGARG(args)
#endif

/* Support for compiler specific function attributes.  These are used
 * so that where compiler support is available incorrect use of API
 * functions in png.h will generate compiler warnings.
 *
 * Added at libpng-1.2.41.
 */

#ifndef PNG_NO_PEDANTIC_WARNINGS
#  ifndef PNG_PEDANTIC_WARNINGS_SUPPORTED
#    define PNG_PEDANTIC_WARNINGS_SUPPORTED
#  endif
#endif

#ifdef PNG_PEDANTIC_WARNINGS_SUPPORTED
  /* Support for compiler specific function attributes.  These are used
   * so that where compiler support is available, incorrect use of API
   * functions in png.h will generate compiler warnings.  Added at libpng
   * version 1.2.41.  Disabling these removes the warnings but may also produce
   * less efficient code.
   */
#  if defined(__clang__) && defined(__has_attribute)
   /* Clang defines both __clang__ and __GNUC__. Check __clang__ first. */
#    if !defined(PNG_USE_RESULT) && __has_attribute(__warn_unused_result__)
#      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
#    endif
#    if !defined(PNG_NORETURN) && __has_attribute(__noreturn__)
#      define PNG_NORETURN __attribute__((__noreturn__))
#    endif
#    if !defined(PNG_ALLOCATED) && __has_attribute(__malloc__)
#      define PNG_ALLOCATED __attribute__((__malloc__))
#    endif
#    if !defined(PNG_DEPRECATED) && __has_attribute(__deprecated__)
#      define PNG_DEPRECATED __attribute__((__deprecated__))
#    endif
#    if !defined(PNG_PRIVATE)
#      ifdef __has_extension
#        if __has_extension(attribute_unavailable_with_message)
#          define PNG_PRIVATE __attribute__((__unavailable__(\
             "This function is not exported by libpng.")))
#        endif
#      endif
#    endif
#    ifndef PNG_RESTRICT
#      define PNG_RESTRICT __restrict
#    endif

#  elif defined(__GNUC__)
#    ifndef PNG_USE_RESULT
#      define PNG_USE_RESULT __attribute__((__warn_unused_result__))
#    endif
#    ifndef PNG_NORETURN
#      define PNG_NORETURN   __attribute__((__noreturn__))
#    endif
#    if __GNUC__ >= 3
#      ifndef PNG_ALLOCATED
#        define PNG_ALLOCATED  __attribute__((__malloc__))
#      endif
#      ifndef PNG_DEPRECATED
#        define PNG_DEPRECATED __attribute__((__deprecated__))
#      endif
#      ifndef PNG_PRIVATE
#        if 0 /* Doesn't work so we use deprecated instead*/
#          define PNG_PRIVATE \
            __attribute__((warning("This function is not exported by libpng.")))
#        else
#          define PNG_PRIVATE \
            __attribute__((__deprecated__))
#        endif
#      endif
#      if ((__GNUC__ > 3) || !defined(__GNUC_MINOR__) || (__GNUC_MINOR__ >= 1))
#        ifndef PNG_RESTRICT
#          define PNG_RESTRICT __restrict
#        endif
#      endif /* __GNUC__.__GNUC_MINOR__ > 3.0 */
#    endif /* __GNUC__ >= 3 */

#  elif defined(_MSC_VER)  && (_MSC_VER >= 1300)
#    ifndef PNG_USE_RESULT
#      define PNG_USE_RESULT /* not supported */
#    endif
#    ifndef PNG_NORETURN
#      define PNG_NORETURN   __declspec(noreturn)
#    endif
#    ifndef PNG_ALLOCATED
#      if (_MSC_VER >= 1400)
#        define PNG_ALLOCATED __declspec(restrict)
#      endif
#    endif
#    ifndef PNG_DEPRECATED
#      define PNG_DEPRECATED __declspec(deprecated)
#    endif
#    ifndef PNG_PRIVATE
#      define PNG_PRIVATE __declspec(deprecated)
#    endif
#    ifndef PNG_RESTRICT
#      if (_MSC_VER >= 1400)
#        define PNG_RESTRICT __restrict
#      endif
#    endif

#  elif defined(__WATCOMC__)
#    ifndef PNG_RESTRICT
#      define PNG_RESTRICT __restrict
#    endif
#  endif
#endif /* PNG_PEDANTIC_WARNINGS */

#ifndef PNG_DEPRECATED
#  define PNG_DEPRECATED  /* Use of this function is deprecated */
#endif
#ifndef PNG_USE_RESULT
#  define PNG_USE_RESULT  /* The result of this function must be checked */
#endif
#ifndef PNG_NORETURN
#  define PNG_NORETURN    /* This function does not return */
#endif
#ifndef PNG_ALLOCATED
#  define PNG_ALLOCATED   /* The result of the function is new memory */
#endif
#ifndef PNG_PRIVATE
#  define PNG_PRIVATE     /* This is a private libpng function */
#endif
#ifndef PNG_RESTRICT
#  define PNG_RESTRICT    /* The C99 "restrict" feature */
#endif

#ifndef PNG_FP_EXPORT     /* A floating point API. */
#  ifdef PNG_FLOATING_POINT_SUPPORTED
#     define PNG_FP_EXPORT(ordinal, type, name, args)\
         PNG_EXPORT(ordinal, type, name, args);
#  else                   /* No floating point APIs */
#     define PNG_FP_EXPORT(ordinal, type, name, args)
#  endif
#endif
#ifndef PNG_FIXED_EXPORT  /* A fixed point API. */
#  ifdef PNG_FIXED_POINT_SUPPORTED
#     define PNG_FIXED_EXPORT(ordinal, type, name, args)\
         PNG_EXPORT(ordinal, type, name, args);
#  else                   /* No fixed point APIs */
#     define PNG_FIXED_EXPORT(ordinal, type, name, args)
#  endif
#endif

#ifndef PNG_BUILDING_SYMBOL_TABLE
/* Some typedefs to get us started.  These should be safe on most of the common
 * platforms.
 *
 * png_uint_32 and png_int_32 may, currently, be larger than required to hold a
 * 32-bit value however this is not normally advisable.
 *
 * png_uint_16 and png_int_16 should always be two bytes in size - this is
 * verified at library build time.
 *
 * png_byte must always be one byte in size.
 *
 * The checks below use constants from limits.h, as defined by the ISOC90
 * standard.
 */
#if CHAR_BIT == 8 && UCHAR_MAX == 255
   typedef unsigned char png_byte;
#else
#  error "libpng requires 8-bit bytes"
#endif

#if INT_MIN == -32768 && INT_MAX == 32767
   typedef int png_int_16;
#elif SHRT_MIN == -32768 && SHRT_MAX == 32767
   typedef short png_int_16;
#else
#  error "libpng requires a signed 16-bit type"
#endif

#if UINT_MAX == 65535
   typedef unsigned int png_uint_16;
#elif USHRT_MAX == 65535
   typedef unsigned short png_uint_16;
#else
#  error "libpng requires an unsigned 16-bit type"
#endif

#if INT_MIN < -2147483646 && INT_MAX > 2147483646
   typedef int png_int_32;
#elif LONG_MIN < -2147483646 && LONG_MAX > 2147483646
   typedef long int png_int_32;
#else
#  error "libpng requires a signed 32-bit (or more) type"
#endif

#if UINT_MAX > 4294967294U
   typedef unsigned int png_uint_32;
#elif ULONG_MAX > 4294967294U
   typedef unsigned long int png_uint_32;
#else
#  error "libpng requires an unsigned 32-bit (or more) type"
#endif

/* Prior to 1.6.0 it was possible to disable the use of size_t, 1.6.0, however,
 * requires an ISOC90 compiler and relies on consistent behavior of sizeof.
 */
typedef size_t png_size_t;
typedef ptrdiff_t png_ptrdiff_t;

/* libpng needs to know the maximum value of 'size_t' and this controls the
 * definition of png_alloc_size_t, below.  This maximum value of size_t limits
 * but does not control the maximum allocations the library makes - there is
 * direct application control of this through png_set_user_limits().
 */
#ifndef PNG_SMALL_SIZE_T
   /* Compiler specific tests for systems where size_t is known to be less than
    * 32 bits (some of these systems may no longer work because of the lack of
    * 'far' support; see above.)
    */
#  if (defined(__TURBOC__) && !defined(__FLAT__)) ||\
   (defined(_MSC_VER) && defined(MAXSEG_64K))
#     define PNG_SMALL_SIZE_T
#  endif
#endif

/* png_alloc_size_t is guaranteed to be no smaller than png_size_t, and no
 * smaller than png_uint_32.  Casts from png_size_t or png_uint_32 to
 * png_alloc_size_t are not necessary; in fact, it is recommended not to use
 * them at all so that the compiler can complain when something turns out to be
 * problematic.
 *
 * Casts in the other direction (from png_alloc_size_t to png_size_t or
 * png_uint_32) should be explicitly applied; however, we do not expect to
 * encounter practical situations that require such conversions.
 *
 * PNG_SMALL_SIZE_T must be defined if the maximum value of size_t is less than
 * 4294967295 - i.e. less than the maximum value of png_uint_32.
 */
#ifdef PNG_SMALL_SIZE_T
   typedef png_uint_32 png_alloc_size_t;
#else
   typedef png_size_t png_alloc_size_t;
#endif

/* Prior to 1.6.0 libpng offered limited support for Microsoft C compiler
 * implementations of Intel CPU specific support of user-mode segmented address
 * spaces, where 16-bit pointers address more than 65536 bytes of memory using
 * separate 'segment' registers.  The implementation requires two different
 * types of pointer (only one of which includes the segment value.)
 *
 * If required this support is available in version 1.2 of libpng and may be
 * available in versions through 1.5, although the correctness of the code has
 * not been verified recently.
 */

/* Typedef for floating-point numbers that are converted to fixed-point with a
 * multiple of 100,000, e.g., gamma
 */
typedef png_int_32 png_fixed_point;

/* Add typedefs for pointers */
typedef void                  * png_voidp;
typedef const void            * png_const_voidp;
typedef png_byte              * png_bytep;
typedef const png_byte        * png_const_bytep;
typedef png_uint_32           * png_uint_32p;
typedef const png_uint_32     * png_const_uint_32p;
typedef png_int_32            * png_int_32p;
typedef const png_int_32      * png_const_int_32p;
typedef png_uint_16           * png_uint_16p;
typedef const png_uint_16     * png_const_uint_16p;
typedef png_int_16            * png_int_16p;
typedef const png_int_16      * png_const_int_16p;
typedef char                  * png_charp;
typedef const char            * png_const_charp;
typedef png_fixed_point       * png_fixed_point_p;
typedef const png_fixed_point * png_const_fixed_point_p;
typedef png_size_t            * png_size_tp;
typedef const png_size_t      * png_const_size_tp;

#ifdef PNG_STDIO_SUPPORTED
typedef FILE            * png_FILE_p;
#endif

#ifdef PNG_FLOATING_POINT_SUPPORTED
typedef double       * png_doublep;
typedef const double * png_const_doublep;
#endif

/* Pointers to pointers; i.e. arrays */
typedef png_byte        * * png_bytepp;
typedef png_uint_32     * * png_uint_32pp;
typedef png_int_32      * * png_int_32pp;
typedef png_uint_16     * * png_uint_16pp;
typedef png_int_16      * * png_int_16pp;
typedef const char      * * png_const_charpp;
typedef char            * * png_charpp;
typedef png_fixed_point * * png_fixed_point_pp;
#ifdef PNG_FLOATING_POINT_SUPPORTED
typedef double          * * png_doublepp;
#endif

/* Pointers to pointers to pointers; i.e., pointer to array */
typedef char            * * * png_charppp;

#endif /* PNG_BUILDING_SYMBOL_TABLE */

#endif /* PNGCONF_H */

```

`ThirdPartyBuild/PNG/Code/pngdebug.h`:

```h

/* pngdebug.h - Debugging macros for libpng, also used in pngtest.c
 *
 * Last changed in libpng 1.6.8 [December 19, 2013]
 * Copyright (c) 1998-2002,2004,2006-2013 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

/* Define PNG_DEBUG at compile time for debugging information.  Higher
 * numbers for PNG_DEBUG mean more debugging information.  This has
 * only been added since version 0.95 so it is not implemented throughout
 * libpng yet, but more support will be added as needed.
 *
 * png_debug[1-2]?(level, message ,arg{0-2})
 *   Expands to a statement (either a simple expression or a compound
 *   do..while(0) statement) that outputs a message with parameter
 *   substitution if PNG_DEBUG is defined to 2 or more.  If PNG_DEBUG
 *   is undefined, 0 or 1 every png_debug expands to a simple expression
 *   (actually ((void)0)).
 *
 *   level: level of detail of message, starting at 0.  A level 'n'
 *          message is preceded by 'n' 3-space indentations (not implemented
 *          on Microsoft compilers unless PNG_DEBUG_FILE is also
 *          defined, to allow debug DLL compilation with no standard IO).
 *   message: a printf(3) style text string.  A trailing '\n' is added
 *            to the message.
 *   arg: 0 to 2 arguments for printf(3) style substitution in message.
 */
#ifndef PNGDEBUG_H
#define PNGDEBUG_H
/* These settings control the formatting of messages in png.c and pngerror.c */
/* Moved to pngdebug.h at 1.5.0 */
#  ifndef PNG_LITERAL_SHARP
#    define PNG_LITERAL_SHARP 0x23
#  endif
#  ifndef PNG_LITERAL_LEFT_SQUARE_BRACKET
#    define PNG_LITERAL_LEFT_SQUARE_BRACKET 0x5b
#  endif
#  ifndef PNG_LITERAL_RIGHT_SQUARE_BRACKET
#    define PNG_LITERAL_RIGHT_SQUARE_BRACKET 0x5d
#  endif
#  ifndef PNG_STRING_NEWLINE
#    define PNG_STRING_NEWLINE "\n"
#  endif

#ifdef PNG_DEBUG
#  if (PNG_DEBUG > 0)
#    if !defined(PNG_DEBUG_FILE) && defined(_MSC_VER)
#      include <crtdbg.h>
#      if (PNG_DEBUG > 1)
#        ifndef _DEBUG
#          define _DEBUG
#        endif
#        ifndef png_debug
#          define png_debug(l,m)  _RPT0(_CRT_WARN,m PNG_STRING_NEWLINE)
#        endif
#        ifndef png_debug1
#          define png_debug1(l,m,p1)  _RPT1(_CRT_WARN,m PNG_STRING_NEWLINE,p1)
#        endif
#        ifndef png_debug2
#          define png_debug2(l,m,p1,p2) \
             _RPT2(_CRT_WARN,m PNG_STRING_NEWLINE,p1,p2)
#        endif
#      endif
#    else /* PNG_DEBUG_FILE || !_MSC_VER */
#      ifndef PNG_STDIO_SUPPORTED
#        include <stdio.h> /* not included yet */
#      endif
#      ifndef PNG_DEBUG_FILE
#        define PNG_DEBUG_FILE stderr
#      endif /* PNG_DEBUG_FILE */

#      if (PNG_DEBUG > 1)
#        ifdef __STDC__
#          ifndef png_debug
#            define png_debug(l,m) \
       do { \
       int num_tabs=l; \
       fprintf(PNG_DEBUG_FILE,"%s" m PNG_STRING_NEWLINE,(num_tabs==1 ? "   " : \
         (num_tabs==2 ? "      " : (num_tabs>2 ? "         " : "")))); \
       } while (0)
#          endif
#          ifndef png_debug1
#            define png_debug1(l,m,p1) \
       do { \
       int num_tabs=l; \
       fprintf(PNG_DEBUG_FILE,"%s" m PNG_STRING_NEWLINE,(num_tabs==1 ? "   " : \
         (num_tabs==2 ? "      " : (num_tabs>2 ? "         " : ""))),p1); \
       } while (0)
#          endif
#          ifndef png_debug2
#            define png_debug2(l,m,p1,p2) \
       do { \
       int num_tabs=l; \
       fprintf(PNG_DEBUG_FILE,"%s" m PNG_STRING_NEWLINE,(num_tabs==1 ? "   " : \
         (num_tabs==2 ? "      " : (num_tabs>2 ? "         " : ""))),p1,p2);\
       } while (0)
#          endif
#        else /* __STDC __ */
#          ifndef png_debug
#            define png_debug(l,m) \
       do { \
       int num_tabs=l; \
       char format[256]; \
       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
         m,PNG_STRING_NEWLINE); \
       fprintf(PNG_DEBUG_FILE,format); \
       } while (0)
#          endif
#          ifndef png_debug1
#            define png_debug1(l,m,p1) \
       do { \
       int num_tabs=l; \
       char format[256]; \
       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
         m,PNG_STRING_NEWLINE); \
       fprintf(PNG_DEBUG_FILE,format,p1); \
       } while (0)
#          endif
#          ifndef png_debug2
#            define png_debug2(l,m,p1,p2) \
       do { \
       int num_tabs=l; \
       char format[256]; \
       snprintf(format,256,"%s%s%s",(num_tabs==1 ? "\t" : \
         (num_tabs==2 ? "\t\t":(num_tabs>2 ? "\t\t\t":""))), \
         m,PNG_STRING_NEWLINE); \
       fprintf(PNG_DEBUG_FILE,format,p1,p2); \
       } while (0)
#          endif
#        endif /* __STDC __ */
#      endif /* (PNG_DEBUG > 1) */

#    endif /* _MSC_VER */
#  endif /* (PNG_DEBUG > 0) */
#endif /* PNG_DEBUG */
#ifndef png_debug
#  define png_debug(l, m) ((void)0)
#endif
#ifndef png_debug1
#  define png_debug1(l, m, p1) ((void)0)
#endif
#ifndef png_debug2
#  define png_debug2(l, m, p1, p2) ((void)0)
#endif
#endif /* PNGDEBUG_H */

```

`ThirdPartyBuild/PNG/Code/pngerror.c`:

```c

/* pngerror.c - stub functions for i/o and memory allocation
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This file provides a location for all error handling.  Users who
 * need special error handling are expected to write replacement functions
 * and use png_set_error_fn() to use those functions.  See the instructions
 * at each function.
 */

#include "pngpriv.h"

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)

static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,
    png_const_charp error_message)),PNG_NORETURN);

#ifdef PNG_WARNINGS_SUPPORTED
static void /* PRIVATE */
png_default_warning PNGARG((png_const_structrp png_ptr,
    png_const_charp warning_message));
#endif /* WARNINGS */

/* This function is called whenever there is a fatal error.  This function
 * should not be changed.  If there is a need to handle errors differently,
 * you should supply a replacement error function and use png_set_error_fn()
 * to replace the error function at run-time.
 */
#ifdef PNG_ERROR_TEXT_SUPPORTED
PNG_FUNCTION(void,PNGAPI
png_error,(png_const_structrp png_ptr, png_const_charp error_message),
    PNG_NORETURN)
{
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   char msg[16];
   if (png_ptr != NULL)
   {
      if ((png_ptr->flags &
         (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT)) != 0)
      {
         if (*error_message == PNG_LITERAL_SHARP)
         {
            /* Strip "#nnnn " from beginning of error message. */
            int offset;
            for (offset = 1; offset<15; offset++)
               if (error_message[offset] == ' ')
                  break;

            if ((png_ptr->flags & PNG_FLAG_STRIP_ERROR_TEXT) != 0)
            {
               int i;
               for (i = 0; i < offset - 1; i++)
                  msg[i] = error_message[i + 1];
               msg[i - 1] = '\0';
               error_message = msg;
            }

            else
               error_message += offset;
         }

         else
         {
            if ((png_ptr->flags & PNG_FLAG_STRIP_ERROR_TEXT) != 0)
            {
               msg[0] = '0';
               msg[1] = '\0';
               error_message = msg;
            }
         }
      }
   }
#endif
   if (png_ptr != NULL && png_ptr->error_fn != NULL)
      (*(png_ptr->error_fn))(png_constcast(png_structrp,png_ptr),
          error_message);

   /* If the custom handler doesn't exist, or if it returns,
      use the default handler, which will not return. */
   png_default_error(png_ptr, error_message);
}
#else
PNG_FUNCTION(void,PNGAPI
png_err,(png_const_structrp png_ptr),PNG_NORETURN)
{
   /* Prior to 1.5.2 the error_fn received a NULL pointer, expressed
    * erroneously as '\0', instead of the empty string "".  This was
    * apparently an error, introduced in libpng-1.2.20, and png_default_error
    * will crash in this case.
    */
   if (png_ptr != NULL && png_ptr->error_fn != NULL)
      (*(png_ptr->error_fn))(png_constcast(png_structrp,png_ptr), "");

   /* If the custom handler doesn't exist, or if it returns,
      use the default handler, which will not return. */
   png_default_error(png_ptr, "");
}
#endif /* ERROR_TEXT */

/* Utility to safely appends strings to a buffer.  This never errors out so
 * error checking is not required in the caller.
 */
size_t
png_safecat(png_charp buffer, size_t bufsize, size_t pos,
    png_const_charp string)
{
   if (buffer != NULL && pos < bufsize)
   {
      if (string != NULL)
         while (*string != '\0' && pos < bufsize-1)
           buffer[pos++] = *string++;

      buffer[pos] = '\0';
   }

   return pos;
}

#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_TIME_RFC1123_SUPPORTED)
/* Utility to dump an unsigned value into a buffer, given a start pointer and
 * and end pointer (which should point just *beyond* the end of the buffer!)
 * Returns the pointer to the start of the formatted string.
 */
png_charp
png_format_number(png_const_charp start, png_charp end, int format,
    png_alloc_size_t number)
{
   int count = 0;    /* number of digits output */
   int mincount = 1; /* minimum number required */
   int output = 0;   /* digit output (for the fixed point format) */

   *--end = '\0';

   /* This is written so that the loop always runs at least once, even with
    * number zero.
    */
   while (end > start && (number != 0 || count < mincount))
   {

      static const char digits[] = "0123456789ABCDEF";

      switch (format)
      {
         case PNG_NUMBER_FORMAT_fixed:
            /* Needs five digits (the fraction) */
            mincount = 5;
            if (output != 0 || number % 10 != 0)
            {
               *--end = digits[number % 10];
               output = 1;
            }
            number /= 10;
            break;

         case PNG_NUMBER_FORMAT_02u:
            /* Expects at least 2 digits. */
            mincount = 2;
            /* FALL THROUGH */

         case PNG_NUMBER_FORMAT_u:
            *--end = digits[number % 10];
            number /= 10;
            break;

         case PNG_NUMBER_FORMAT_02x:
            /* This format expects at least two digits */
            mincount = 2;
            /* FALL THROUGH */

         case PNG_NUMBER_FORMAT_x:
            *--end = digits[number & 0xf];
            number >>= 4;
            break;

         default: /* an error */
            number = 0;
            break;
      }

      /* Keep track of the number of digits added */
      ++count;

      /* Float a fixed number here: */
      if ((format == PNG_NUMBER_FORMAT_fixed) && (count == 5) && (end > start))
      {
         /* End of the fraction, but maybe nothing was output?  In that case
          * drop the decimal point.  If the number is a true zero handle that
          * here.
          */
         if (output != 0)
            *--end = '.';
         else if (number == 0) /* and !output */
            *--end = '0';
      }
   }

   return end;
}
#endif

#ifdef PNG_WARNINGS_SUPPORTED
/* This function is called whenever there is a non-fatal error.  This function
 * should not be changed.  If there is a need to handle warnings differently,
 * you should supply a replacement warning function and use
 * png_set_error_fn() to replace the warning function at run-time.
 */
void PNGAPI
png_warning(png_const_structrp png_ptr, png_const_charp warning_message)
{
   int offset = 0;
   if (png_ptr != NULL)
   {
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if ((png_ptr->flags &
       (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT)) != 0)
#endif
      {
         if (*warning_message == PNG_LITERAL_SHARP)
         {
            for (offset = 1; offset < 15; offset++)
               if (warning_message[offset] == ' ')
                  break;
         }
      }
   }
   if (png_ptr != NULL && png_ptr->warning_fn != NULL)
      (*(png_ptr->warning_fn))(png_constcast(png_structrp,png_ptr),
          warning_message + offset);
   else
      png_default_warning(png_ptr, warning_message + offset);
}

/* These functions support 'formatted' warning messages with up to
 * PNG_WARNING_PARAMETER_COUNT parameters.  In the format string the parameter
 * is introduced by @<number>, where 'number' starts at 1.  This follows the
 * standard established by X/Open for internationalizable error messages.
 */
void
png_warning_parameter(png_warning_parameters p, int number,
    png_const_charp string)
{
   if (number > 0 && number <= PNG_WARNING_PARAMETER_COUNT)
      (void)png_safecat(p[number-1], (sizeof p[number-1]), 0, string);
}

void
png_warning_parameter_unsigned(png_warning_parameters p, int number, int format,
    png_alloc_size_t value)
{
   char buffer[PNG_NUMBER_BUFFER_SIZE];
   png_warning_parameter(p, number, PNG_FORMAT_NUMBER(buffer, format, value));
}

void
png_warning_parameter_signed(png_warning_parameters p, int number, int format,
    png_int_32 value)
{
   png_alloc_size_t u;
   png_charp str;
   char buffer[PNG_NUMBER_BUFFER_SIZE];

   /* Avoid overflow by doing the negate in a png_alloc_size_t: */
   u = (png_alloc_size_t)value;
   if (value < 0)
      u = ~u + 1;

   str = PNG_FORMAT_NUMBER(buffer, format, u);

   if (value < 0 && str > buffer)
      *--str = '-';

   png_warning_parameter(p, number, str);
}

void
png_formatted_warning(png_const_structrp png_ptr, png_warning_parameters p,
    png_const_charp message)
{
   /* The internal buffer is just 192 bytes - enough for all our messages,
    * overflow doesn't happen because this code checks!  If someone figures
    * out how to send us a message longer than 192 bytes, all that will
    * happen is that the message will be truncated appropriately.
    */
   size_t i = 0; /* Index in the msg[] buffer: */
   char msg[192];

   /* Each iteration through the following loop writes at most one character
    * to msg[i++] then returns here to validate that there is still space for
    * the trailing '\0'.  It may (in the case of a parameter) read more than
    * one character from message[]; it must check for '\0' and continue to the
    * test if it finds the end of string.
    */
   while (i<(sizeof msg)-1 && *message != '\0')
   {
      /* '@' at end of string is now just printed (previously it was skipped);
       * it is an error in the calling code to terminate the string with @.
       */
      if (p != NULL && *message == '@' && message[1] != '\0')
      {
         int parameter_char = *++message; /* Consume the '@' */
         static const char valid_parameters[] = "123456789";
         int parameter = 0;

         /* Search for the parameter digit, the index in the string is the
          * parameter to use.
          */
         while (valid_parameters[parameter] != parameter_char &&
            valid_parameters[parameter] != '\0')
            ++parameter;

         /* If the parameter digit is out of range it will just get printed. */
         if (parameter < PNG_WARNING_PARAMETER_COUNT)
         {
            /* Append this parameter */
            png_const_charp parm = p[parameter];
            png_const_charp pend = p[parameter] + (sizeof p[parameter]);

            /* No need to copy the trailing '\0' here, but there is no guarantee
             * that parm[] has been initialized, so there is no guarantee of a
             * trailing '\0':
             */
            while (i<(sizeof msg)-1 && *parm != '\0' && parm < pend)
               msg[i++] = *parm++;

            /* Consume the parameter digit too: */
            ++message;
            continue;
         }

         /* else not a parameter and there is a character after the @ sign; just
          * copy that.  This is known not to be '\0' because of the test above.
          */
      }

      /* At this point *message can't be '\0', even in the bad parameter case
       * above where there is a lone '@' at the end of the message string.
       */
      msg[i++] = *message++;
   }

   /* i is always less than (sizeof msg), so: */
   msg[i] = '\0';

   /* And this is the formatted message. It may be larger than
    * PNG_MAX_ERROR_TEXT, but that is only used for 'chunk' errors and these
    * are not (currently) formatted.
    */
   png_warning(png_ptr, msg);
}
#endif /* WARNINGS */

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
void PNGAPI
png_benign_error(png_const_structrp png_ptr, png_const_charp error_message)
{
   if ((png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN) != 0)
   {
#     ifdef PNG_READ_SUPPORTED
         if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&
            png_ptr->chunk_name != 0)
            png_chunk_warning(png_ptr, error_message);
         else
#     endif
      png_warning(png_ptr, error_message);
   }

   else
   {
#     ifdef PNG_READ_SUPPORTED
         if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&
            png_ptr->chunk_name != 0)
            png_chunk_error(png_ptr, error_message);
         else
#     endif
      png_error(png_ptr, error_message);
   }

#  ifndef PNG_ERROR_TEXT_SUPPORTED
      PNG_UNUSED(error_message)
#  endif
}

void /* PRIVATE */
png_app_warning(png_const_structrp png_ptr, png_const_charp error_message)
{
   if ((png_ptr->flags & PNG_FLAG_APP_WARNINGS_WARN) != 0)
      png_warning(png_ptr, error_message);
   else
      png_error(png_ptr, error_message);

#  ifndef PNG_ERROR_TEXT_SUPPORTED
      PNG_UNUSED(error_message)
#  endif
}

void /* PRIVATE */
png_app_error(png_const_structrp png_ptr, png_const_charp error_message)
{
   if ((png_ptr->flags & PNG_FLAG_APP_ERRORS_WARN) != 0)
      png_warning(png_ptr, error_message);
   else
      png_error(png_ptr, error_message);

#  ifndef PNG_ERROR_TEXT_SUPPORTED
      PNG_UNUSED(error_message)
#  endif
}
#endif /* BENIGN_ERRORS */

#define PNG_MAX_ERROR_TEXT 196 /* Currently limited by profile_error in png.c */
#if defined(PNG_WARNINGS_SUPPORTED) || \
   (defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED))
/* These utilities are used internally to build an error message that relates
 * to the current chunk.  The chunk name comes from png_ptr->chunk_name,
 * which is used to prefix the message.  The message is limited in length
 * to 63 bytes. The name characters are output as hex digits wrapped in []
 * if the character is invalid.
 */
#define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
static PNG_CONST char png_digit[16] = {
   '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'A', 'B', 'C', 'D', 'E', 'F'
};

static void /* PRIVATE */
png_format_buffer(png_const_structrp png_ptr, png_charp buffer, png_const_charp
    error_message)
{
   png_uint_32 chunk_name = png_ptr->chunk_name;
   int iout = 0, ishift = 24;

   while (ishift >= 0)
   {
      int c = (int)(chunk_name >> ishift) & 0xff;

      ishift -= 8;
      if (isnonalpha(c) != 0)
      {
         buffer[iout++] = PNG_LITERAL_LEFT_SQUARE_BRACKET;
         buffer[iout++] = png_digit[(c & 0xf0) >> 4];
         buffer[iout++] = png_digit[c & 0x0f];
         buffer[iout++] = PNG_LITERAL_RIGHT_SQUARE_BRACKET;
      }

      else
      {
         buffer[iout++] = (char)c;
      }
   }

   if (error_message == NULL)
      buffer[iout] = '\0';

   else
   {
      int iin = 0;

      buffer[iout++] = ':';
      buffer[iout++] = ' ';

      while (iin < PNG_MAX_ERROR_TEXT-1 && error_message[iin] != '\0')
         buffer[iout++] = error_message[iin++];

      /* iin < PNG_MAX_ERROR_TEXT, so the following is safe: */
      buffer[iout] = '\0';
   }
}
#endif /* WARNINGS || ERROR_TEXT */

#if defined(PNG_READ_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED)
PNG_FUNCTION(void,PNGAPI
png_chunk_error,(png_const_structrp png_ptr, png_const_charp error_message),
    PNG_NORETURN)
{
   char msg[18+PNG_MAX_ERROR_TEXT];
   if (png_ptr == NULL)
      png_error(png_ptr, error_message);

   else
   {
      png_format_buffer(png_ptr, msg, error_message);
      png_error(png_ptr, msg);
   }
}
#endif /* READ && ERROR_TEXT */

#ifdef PNG_WARNINGS_SUPPORTED
void PNGAPI
png_chunk_warning(png_const_structrp png_ptr, png_const_charp warning_message)
{
   char msg[18+PNG_MAX_ERROR_TEXT];
   if (png_ptr == NULL)
      png_warning(png_ptr, warning_message);

   else
   {
      png_format_buffer(png_ptr, msg, warning_message);
      png_warning(png_ptr, msg);
   }
}
#endif /* WARNINGS */

#ifdef PNG_READ_SUPPORTED
#ifdef PNG_BENIGN_ERRORS_SUPPORTED
void PNGAPI
png_chunk_benign_error(png_const_structrp png_ptr, png_const_charp
    error_message)
{
   if ((png_ptr->flags & PNG_FLAG_BENIGN_ERRORS_WARN) != 0)
      png_chunk_warning(png_ptr, error_message);

   else
      png_chunk_error(png_ptr, error_message);

#  ifndef PNG_ERROR_TEXT_SUPPORTED
      PNG_UNUSED(error_message)
#  endif
}
#endif
#endif /* READ */

void /* PRIVATE */
png_chunk_report(png_const_structrp png_ptr, png_const_charp message, int error)
{
#  ifndef PNG_WARNINGS_SUPPORTED
      PNG_UNUSED(message)
#  endif

   /* This is always supported, but for just read or just write it
    * unconditionally does the right thing.
    */
#  if defined(PNG_READ_SUPPORTED) && defined(PNG_WRITE_SUPPORTED)
      if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)
#  endif

#  ifdef PNG_READ_SUPPORTED
      {
         if (error < PNG_CHUNK_ERROR)
            png_chunk_warning(png_ptr, message);

         else
            png_chunk_benign_error(png_ptr, message);
      }
#  endif

#  if defined(PNG_READ_SUPPORTED) && defined(PNG_WRITE_SUPPORTED)
      else if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)
#  endif

#  ifdef PNG_WRITE_SUPPORTED
      {
         if (error < PNG_CHUNK_WRITE_ERROR)
            png_app_warning(png_ptr, message);

         else
            png_app_error(png_ptr, message);
      }
#  endif
}

#ifdef PNG_ERROR_TEXT_SUPPORTED
#ifdef PNG_FLOATING_POINT_SUPPORTED
PNG_FUNCTION(void,
png_fixed_error,(png_const_structrp png_ptr, png_const_charp name),PNG_NORETURN)
{
#  define fixed_message "fixed point overflow in "
#  define fixed_message_ln ((sizeof fixed_message)-1)
   unsigned int  iin;
   char msg[fixed_message_ln+PNG_MAX_ERROR_TEXT];
   memcpy(msg, fixed_message, fixed_message_ln);
   iin = 0;
   if (name != NULL)
      while (iin < (PNG_MAX_ERROR_TEXT-1) && name[iin] != 0)
      {
         msg[fixed_message_ln + iin] = name[iin];
         ++iin;
      }
   msg[fixed_message_ln + iin] = 0;
   png_error(png_ptr, msg);
}
#endif
#endif

#ifdef PNG_SETJMP_SUPPORTED
/* This API only exists if ANSI-C style error handling is used,
 * otherwise it is necessary for png_default_error to be overridden.
 */
jmp_buf* PNGAPI
png_set_longjmp_fn(png_structrp png_ptr, png_longjmp_ptr longjmp_fn,
    size_t jmp_buf_size)
{
   /* From libpng 1.6.0 the app gets one chance to set a 'jmpbuf_size' value
    * and it must not change after that.  Libpng doesn't care how big the
    * buffer is, just that it doesn't change.
    *
    * If the buffer size is no *larger* than the size of jmp_buf when libpng is
    * compiled a built in jmp_buf is returned; this preserves the pre-1.6.0
    * semantics that this call will not fail.  If the size is larger, however,
    * the buffer is allocated and this may fail, causing the function to return
    * NULL.
    */
   if (png_ptr == NULL)
      return NULL;

   if (png_ptr->jmp_buf_ptr == NULL)
   {
      png_ptr->jmp_buf_size = 0; /* not allocated */

      if (jmp_buf_size <= (sizeof png_ptr->jmp_buf_local))
         png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local;

      else
      {
         png_ptr->jmp_buf_ptr = png_voidcast(jmp_buf *,
             png_malloc_warn(png_ptr, jmp_buf_size));

         if (png_ptr->jmp_buf_ptr == NULL)
            return NULL; /* new NULL return on OOM */

         png_ptr->jmp_buf_size = jmp_buf_size;
      }
   }

   else /* Already allocated: check the size */
   {
      size_t size = png_ptr->jmp_buf_size;

      if (size == 0)
      {
         size = (sizeof png_ptr->jmp_buf_local);
         if (png_ptr->jmp_buf_ptr != &png_ptr->jmp_buf_local)
         {
            /* This is an internal error in libpng: somehow we have been left
             * with a stack allocated jmp_buf when the application regained
             * control.  It's always possible to fix this up, but for the moment
             * this is a png_error because that makes it easy to detect.
             */
            png_error(png_ptr, "Libpng jmp_buf still allocated");
            /* png_ptr->jmp_buf_ptr = &png_ptr->jmp_buf_local; */
         }
      }

      if (size != jmp_buf_size)
      {
         png_warning(png_ptr, "Application jmp_buf size changed");
         return NULL; /* caller will probably crash: no choice here */
      }
   }

   /* Finally fill in the function, now we have a satisfactory buffer. It is
    * valid to change the function on every call.
    */
   png_ptr->longjmp_fn = longjmp_fn;
   return png_ptr->jmp_buf_ptr;
}

void /* PRIVATE */
png_free_jmpbuf(png_structrp png_ptr)
{
   if (png_ptr != NULL)
   {
      jmp_buf *jb = png_ptr->jmp_buf_ptr;

      /* A size of 0 is used to indicate a local, stack, allocation of the
       * pointer; used here and in png.c
       */
      if (jb != NULL && png_ptr->jmp_buf_size > 0)
      {

         /* This stuff is so that a failure to free the error control structure
          * does not leave libpng in a state with no valid error handling: the
          * free always succeeds, if there is an error it gets ignored.
          */
         if (jb != &png_ptr->jmp_buf_local)
         {
            /* Make an internal, libpng, jmp_buf to return here */
            jmp_buf free_jmp_buf;

            if (!setjmp(free_jmp_buf))
            {
               png_ptr->jmp_buf_ptr = &free_jmp_buf; /* come back here */
               png_ptr->jmp_buf_size = 0; /* stack allocation */
               png_ptr->longjmp_fn = longjmp;
               png_free(png_ptr, jb); /* Return to setjmp on error */
            }
         }
      }

      /* *Always* cancel everything out: */
      png_ptr->jmp_buf_size = 0;
      png_ptr->jmp_buf_ptr = NULL;
      png_ptr->longjmp_fn = 0;
   }
}
#endif

/* This is the default error handling function.  Note that replacements for
 * this function MUST NOT RETURN, or the program will likely crash.  This
 * function is used by default, or if the program supplies NULL for the
 * error function pointer in png_set_error_fn().
 */
static PNG_FUNCTION(void /* PRIVATE */,
png_default_error,(png_const_structrp png_ptr, png_const_charp error_message),
    PNG_NORETURN)
{
#ifdef PNG_CONSOLE_IO_SUPPORTED
#ifdef PNG_ERROR_NUMBERS_SUPPORTED
   /* Check on NULL only added in 1.5.4 */
   if (error_message != NULL && *error_message == PNG_LITERAL_SHARP)
   {
      /* Strip "#nnnn " from beginning of error message. */
      int offset;
      char error_number[16];
      for (offset = 0; offset<15; offset++)
      {
         error_number[offset] = error_message[offset + 1];
         if (error_message[offset] == ' ')
            break;
      }

      if ((offset > 1) && (offset < 15))
      {
         error_number[offset - 1] = '\0';
         fprintf(stderr, "libpng error no. %s: %s",
             error_number, error_message + offset + 1);
         fprintf(stderr, PNG_STRING_NEWLINE);
      }

      else
      {
         fprintf(stderr, "libpng error: %s, offset=%d",
             error_message, offset);
         fprintf(stderr, PNG_STRING_NEWLINE);
      }
   }
   else
#endif
   {
      fprintf(stderr, "libpng error: %s", error_message ? error_message :
         "undefined");
      fprintf(stderr, PNG_STRING_NEWLINE);
   }
#else
   PNG_UNUSED(error_message) /* Make compiler happy */
#endif
   png_longjmp(png_ptr, 1);
}

PNG_FUNCTION(void,PNGAPI
png_longjmp,(png_const_structrp png_ptr, int val),PNG_NORETURN)
{
#ifdef PNG_SETJMP_SUPPORTED
   if (png_ptr != NULL && png_ptr->longjmp_fn != NULL &&
       png_ptr->jmp_buf_ptr != NULL)
      png_ptr->longjmp_fn(*png_ptr->jmp_buf_ptr, val);
#else
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(val)
#endif

   /* If control reaches this point, png_longjmp() must not return. The only
    * choice is to terminate the whole process (or maybe the thread); to do
    * this the ANSI-C abort() function is used unless a different method is
    * implemented by overriding the default configuration setting for
    * PNG_ABORT().
    */
   PNG_ABORT();
}

#ifdef PNG_WARNINGS_SUPPORTED
/* This function is called when there is a warning, but the library thinks
 * it can continue anyway.  Replacement functions don't have to do anything
 * here if you don't want them to.  In the default configuration, png_ptr is
 * not used, but it is passed in case it may be useful.
 */
static void /* PRIVATE */
png_default_warning(png_const_structrp png_ptr, png_const_charp warning_message)
{
#ifdef PNG_CONSOLE_IO_SUPPORTED
#  ifdef PNG_ERROR_NUMBERS_SUPPORTED
   if (*warning_message == PNG_LITERAL_SHARP)
   {
      int offset;
      char warning_number[16];
      for (offset = 0; offset < 15; offset++)
      {
         warning_number[offset] = warning_message[offset + 1];
         if (warning_message[offset] == ' ')
            break;
      }

      if ((offset > 1) && (offset < 15))
      {
         warning_number[offset + 1] = '\0';
         fprintf(stderr, "libpng warning no. %s: %s",
             warning_number, warning_message + offset);
         fprintf(stderr, PNG_STRING_NEWLINE);
      }

      else
      {
         fprintf(stderr, "libpng warning: %s",
             warning_message);
         fprintf(stderr, PNG_STRING_NEWLINE);
      }
   }
   else
#  endif

   {
      fprintf(stderr, "libpng warning: %s", warning_message);
      fprintf(stderr, PNG_STRING_NEWLINE);
   }
#else
   PNG_UNUSED(warning_message) /* Make compiler happy */
#endif
   PNG_UNUSED(png_ptr) /* Make compiler happy */
}
#endif /* WARNINGS */

/* This function is called when the application wants to use another method
 * of handling errors and warnings.  Note that the error function MUST NOT
 * return to the calling routine or serious problems will occur.  The return
 * method used in the default routine calls longjmp(png_ptr->jmp_buf_ptr, 1)
 */
void PNGAPI
png_set_error_fn(png_structrp png_ptr, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warning_fn)
{
   if (png_ptr == NULL)
      return;

   png_ptr->error_ptr = error_ptr;
   png_ptr->error_fn = error_fn;
#ifdef PNG_WARNINGS_SUPPORTED
   png_ptr->warning_fn = warning_fn;
#else
   PNG_UNUSED(warning_fn)
#endif
}


/* This function returns a pointer to the error_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy and png_read_destroy are called.
 */
png_voidp PNGAPI
png_get_error_ptr(png_const_structrp png_ptr)
{
   if (png_ptr == NULL)
      return NULL;

   return ((png_voidp)png_ptr->error_ptr);
}


#ifdef PNG_ERROR_NUMBERS_SUPPORTED
void PNGAPI
png_set_strip_error_numbers(png_structrp png_ptr, png_uint_32 strip_mode)
{
   if (png_ptr != NULL)
   {
      png_ptr->flags &=
         ((~(PNG_FLAG_STRIP_ERROR_NUMBERS |
         PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);
   }
}
#endif

#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\
   defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)
   /* Currently the above both depend on SETJMP_SUPPORTED, however it would be
    * possible to implement without setjmp support just so long as there is some
    * way to handle the error return here:
    */
PNG_FUNCTION(void /* PRIVATE */, (PNGCBAPI
png_safe_error),(png_structp png_nonconst_ptr, png_const_charp error_message),
    PNG_NORETURN)
{
   const png_const_structrp png_ptr = png_nonconst_ptr;
   png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);

   /* An error is always logged here, overwriting anything (typically a warning)
    * that is already there:
    */
   if (image != NULL)
   {
      png_safecat(image->message, (sizeof image->message), 0, error_message);
      image->warning_or_error |= PNG_IMAGE_ERROR;

      /* Retrieve the jmp_buf from within the png_control, making this work for
       * C++ compilation too is pretty tricky: C++ wants a pointer to the first
       * element of a jmp_buf, but C doesn't tell us the type of that.
       */
      if (image->opaque != NULL && image->opaque->error_buf != NULL)
         longjmp(png_control_jmp_buf(image->opaque), 1);

      /* Missing longjmp buffer, the following is to help debugging: */
      {
         size_t pos = png_safecat(image->message, (sizeof image->message), 0,
             "bad longjmp: ");
         png_safecat(image->message, (sizeof image->message), pos,
             error_message);
      }
   }

   /* Here on an internal programming error. */
   abort();
}

#ifdef PNG_WARNINGS_SUPPORTED
void /* PRIVATE */ PNGCBAPI
png_safe_warning(png_structp png_nonconst_ptr, png_const_charp warning_message)
{
   const png_const_structrp png_ptr = png_nonconst_ptr;
   png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);

   /* A warning is only logged if there is no prior warning or error. */
   if (image->warning_or_error == 0)
   {
      png_safecat(image->message, (sizeof image->message), 0, warning_message);
      image->warning_or_error |= PNG_IMAGE_WARNING;
   }
}
#endif

int /* PRIVATE */
png_safe_execute(png_imagep image_in, int (*function)(png_voidp), png_voidp arg)
{
   volatile png_imagep image = image_in;
   volatile int result;
   volatile png_voidp saved_error_buf;
   jmp_buf safe_jmpbuf;

   /* Safely execute function(arg) with png_error returning to this function. */
   saved_error_buf = image->opaque->error_buf;
   result = setjmp(safe_jmpbuf) == 0;

   if (result != 0)
   {

      image->opaque->error_buf = safe_jmpbuf;
      result = function(arg);
   }

   image->opaque->error_buf = saved_error_buf;

   /* And do the cleanup prior to any failure return. */
   if (result == 0)
      png_image_free(image);

   return result;
}
#endif /* SIMPLIFIED READ || SIMPLIFIED_WRITE */
#endif /* READ || WRITE */

```

`ThirdPartyBuild/PNG/Code/pngget.c`:

```c

/* pngget.c - retrieval of values from info struct
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 */

#include "pngpriv.h"

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)

png_uint_32 PNGAPI
png_get_valid(png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_uint_32 flag)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->valid & flag);

   return(0);
}

png_size_t PNGAPI
png_get_rowbytes(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->rowbytes);

   return(0);
}

#ifdef PNG_INFO_IMAGE_SUPPORTED
png_bytepp PNGAPI
png_get_rows(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->row_pointers);

   return(0);
}
#endif

#ifdef PNG_EASY_ACCESS_SUPPORTED
/* Easy access to info, added in libpng-0.99 */
png_uint_32 PNGAPI
png_get_image_width(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->width;

   return (0);
}

png_uint_32 PNGAPI
png_get_image_height(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->height;

   return (0);
}

png_byte PNGAPI
png_get_bit_depth(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->bit_depth;

   return (0);
}

png_byte PNGAPI
png_get_color_type(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->color_type;

   return (0);
}

png_byte PNGAPI
png_get_filter_type(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;

   return (0);
}

png_byte PNGAPI
png_get_interlace_type(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->interlace_type;

   return (0);
}

png_byte PNGAPI
png_get_compression_type(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->compression_type;

   return (0);
}

png_uint_32 PNGAPI
png_get_x_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp
   info_ptr)
{
#ifdef PNG_pHYs_SUPPORTED
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_pHYs) != 0)
      {
         png_debug1(1, "in %s retrieval function",
             "png_get_x_pixels_per_meter");

         if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)
            return (info_ptr->x_pixels_per_unit);
      }
#else
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(info_ptr)
#endif

   return (0);
}

png_uint_32 PNGAPI
png_get_y_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp
    info_ptr)
{
#ifdef PNG_pHYs_SUPPORTED
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_pHYs) != 0)
   {
      png_debug1(1, "in %s retrieval function",
          "png_get_y_pixels_per_meter");

      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER)
         return (info_ptr->y_pixels_per_unit);
   }
#else
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(info_ptr)
#endif

   return (0);
}

png_uint_32 PNGAPI
png_get_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
#ifdef PNG_pHYs_SUPPORTED
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_pHYs) != 0)
   {
      png_debug1(1, "in %s retrieval function", "png_get_pixels_per_meter");

      if (info_ptr->phys_unit_type == PNG_RESOLUTION_METER &&
          info_ptr->x_pixels_per_unit == info_ptr->y_pixels_per_unit)
         return (info_ptr->x_pixels_per_unit);
   }
#else
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(info_ptr)
#endif

   return (0);
}

#ifdef PNG_FLOATING_POINT_SUPPORTED
float PNGAPI
png_get_pixel_aspect_ratio(png_const_structrp png_ptr, png_const_inforp
   info_ptr)
{
#ifdef PNG_READ_pHYs_SUPPORTED
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_pHYs) != 0)
   {
      png_debug1(1, "in %s retrieval function", "png_get_aspect_ratio");

      if (info_ptr->x_pixels_per_unit != 0)
         return ((float)((float)info_ptr->y_pixels_per_unit
             /(float)info_ptr->x_pixels_per_unit));
   }
#else
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(info_ptr)
#endif

   return ((float)0.0);
}
#endif

#ifdef PNG_FIXED_POINT_SUPPORTED
png_fixed_point PNGAPI
png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr,
    png_const_inforp info_ptr)
{
#ifdef PNG_READ_pHYs_SUPPORTED
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_pHYs) != 0 &&
       info_ptr->x_pixels_per_unit > 0 && info_ptr->y_pixels_per_unit > 0 &&
       info_ptr->x_pixels_per_unit <= PNG_UINT_31_MAX &&
       info_ptr->y_pixels_per_unit <= PNG_UINT_31_MAX)
   {
      png_fixed_point res;

      png_debug1(1, "in %s retrieval function", "png_get_aspect_ratio_fixed");

      /* The following casts work because a PNG 4 byte integer only has a valid
       * range of 0..2^31-1; otherwise the cast might overflow.
       */
      if (png_muldiv(&res, (png_int_32)info_ptr->y_pixels_per_unit, PNG_FP_1,
          (png_int_32)info_ptr->x_pixels_per_unit) != 0)
         return res;
   }
#else
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(info_ptr)
#endif

   return 0;
}
#endif

png_int_32 PNGAPI
png_get_x_offset_microns(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
#ifdef PNG_oFFs_SUPPORTED
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_oFFs) != 0)
   {
      png_debug1(1, "in %s retrieval function", "png_get_x_offset_microns");

      if (info_ptr->offset_unit_type == PNG_OFFSET_MICROMETER)
         return (info_ptr->x_offset);
   }
#else
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(info_ptr)
#endif

   return (0);
}

png_int_32 PNGAPI
png_get_y_offset_microns(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
#ifdef PNG_oFFs_SUPPORTED
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_oFFs) != 0)
   {
      png_debug1(1, "in %s retrieval function", "png_get_y_offset_microns");

      if (info_ptr->offset_unit_type == PNG_OFFSET_MICROMETER)
         return (info_ptr->y_offset);
   }
#else
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(info_ptr)
#endif

   return (0);
}

png_int_32 PNGAPI
png_get_x_offset_pixels(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
#ifdef PNG_oFFs_SUPPORTED
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_oFFs) != 0)
   {
      png_debug1(1, "in %s retrieval function", "png_get_x_offset_pixels");

      if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)
         return (info_ptr->x_offset);
   }
#else
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(info_ptr)
#endif

   return (0);
}

png_int_32 PNGAPI
png_get_y_offset_pixels(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
#ifdef PNG_oFFs_SUPPORTED
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_oFFs) != 0)
   {
      png_debug1(1, "in %s retrieval function", "png_get_y_offset_pixels");

      if (info_ptr->offset_unit_type == PNG_OFFSET_PIXEL)
         return (info_ptr->y_offset);
   }
#else
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(info_ptr)
#endif

   return (0);
}

#ifdef PNG_INCH_CONVERSIONS_SUPPORTED
static png_uint_32
ppi_from_ppm(png_uint_32 ppm)
{
#if 0
   /* The conversion is *(2.54/100), in binary (32 digits):
    * .00000110100000001001110101001001
    */
   png_uint_32 t1001, t1101;
   ppm >>= 1;                  /* .1 */
   t1001 = ppm + (ppm >> 3);   /* .1001 */
   t1101 = t1001 + (ppm >> 1); /* .1101 */
   ppm >>= 20;                 /* .000000000000000000001 */
   t1101 += t1101 >> 15;       /* .1101000000000001101 */
   t1001 >>= 11;               /* .000000000001001 */
   t1001 += t1001 >> 12;       /* .000000000001001000000001001 */
   ppm += t1001;               /* .000000000001001000001001001 */
   ppm += t1101;               /* .110100000001001110101001001 */
   return (ppm + 16) >> 5;/* .00000110100000001001110101001001 */
#else
   /* The argument is a PNG unsigned integer, so it is not permitted
    * to be bigger than 2^31.
    */
   png_fixed_point result;
   if (ppm <= PNG_UINT_31_MAX && png_muldiv(&result, (png_int_32)ppm, 127,
       5000) != 0)
      return (png_uint_32)result;

   /* Overflow. */
   return 0;
#endif
}

png_uint_32 PNGAPI
png_get_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   return ppi_from_ppm(png_get_pixels_per_meter(png_ptr, info_ptr));
}

png_uint_32 PNGAPI
png_get_x_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   return ppi_from_ppm(png_get_x_pixels_per_meter(png_ptr, info_ptr));
}

png_uint_32 PNGAPI
png_get_y_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   return ppi_from_ppm(png_get_y_pixels_per_meter(png_ptr, info_ptr));
}

#ifdef PNG_FIXED_POINT_SUPPORTED
static png_fixed_point
png_fixed_inches_from_microns(png_const_structrp png_ptr, png_int_32 microns)
{
   /* Convert from metres * 1,000,000 to inches * 100,000, meters to
    * inches is simply *(100/2.54), so we want *(10/2.54) == 500/127.
    * Notice that this can overflow - a warning is output and 0 is
    * returned.
    */
   return png_muldiv_warn(png_ptr, microns, 500, 127);
}

png_fixed_point PNGAPI
png_get_x_offset_inches_fixed(png_const_structrp png_ptr,
    png_const_inforp info_ptr)
{
   return png_fixed_inches_from_microns(png_ptr,
       png_get_x_offset_microns(png_ptr, info_ptr));
}
#endif

#ifdef PNG_FIXED_POINT_SUPPORTED
png_fixed_point PNGAPI
png_get_y_offset_inches_fixed(png_const_structrp png_ptr,
    png_const_inforp info_ptr)
{
   return png_fixed_inches_from_microns(png_ptr,
       png_get_y_offset_microns(png_ptr, info_ptr));
}
#endif

#ifdef PNG_FLOATING_POINT_SUPPORTED
float PNGAPI
png_get_x_offset_inches(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   /* To avoid the overflow do the conversion directly in floating
    * point.
    */
   return (float)(png_get_x_offset_microns(png_ptr, info_ptr) * .00003937);
}
#endif

#ifdef PNG_FLOATING_POINT_SUPPORTED
float PNGAPI
png_get_y_offset_inches(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   /* To avoid the overflow do the conversion directly in floating
    * point.
    */
   return (float)(png_get_y_offset_microns(png_ptr, info_ptr) * .00003937);
}
#endif

#ifdef PNG_pHYs_SUPPORTED
png_uint_32 PNGAPI
png_get_pHYs_dpi(png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
{
   png_uint_32 retval = 0;

   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_pHYs) != 0)
   {
      png_debug1(1, "in %s retrieval function", "pHYs");

      if (res_x != NULL)
      {
         *res_x = info_ptr->x_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }

      if (res_y != NULL)
      {
         *res_y = info_ptr->y_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }

      if (unit_type != NULL)
      {
         *unit_type = (int)info_ptr->phys_unit_type;
         retval |= PNG_INFO_pHYs;

         if (*unit_type == 1)
         {
            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);
            if (res_y != NULL) *res_y = (png_uint_32)(*res_y * .0254 + .50);
         }
      }
   }

   return (retval);
}
#endif /* pHYs */
#endif /* INCH_CONVERSIONS */

/* png_get_channels really belongs in here, too, but it's been around longer */

#endif /* EASY_ACCESS */


png_byte PNGAPI
png_get_channels(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->channels);

   return (0);
}

#ifdef PNG_READ_SUPPORTED
png_const_bytep PNGAPI
png_get_signature(png_const_structrp png_ptr, png_const_inforp info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return(info_ptr->signature);

   return (NULL);
}
#endif

#ifdef PNG_bKGD_SUPPORTED
png_uint_32 PNGAPI
png_get_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,
    png_color_16p *background)
{
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_bKGD) != 0 &&
       background != NULL)
   {
      png_debug1(1, "in %s retrieval function", "bKGD");

      *background = &(info_ptr->background);
      return (PNG_INFO_bKGD);
   }

   return (0);
}
#endif

#ifdef PNG_cHRM_SUPPORTED
/* The XYZ APIs were added in 1.5.5 to take advantage of the code added at the
 * same time to correct the rgb grayscale coefficient defaults obtained from the
 * cHRM chunk in 1.5.4
 */
#  ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_cHRM(png_const_structrp png_ptr, png_const_inforp info_ptr,
    double *white_x, double *white_y, double *red_x, double *red_y,
    double *green_x, double *green_y, double *blue_x, double *blue_y)
{
   /* Quiet API change: this code used to only return the end points if a cHRM
    * chunk was present, but the end points can also come from iCCP or sRGB
    * chunks, so in 1.6.0 the png_get_ APIs return the end points regardless and
    * the png_set_ APIs merely check that set end points are mutually
    * consistent.
    */
   if (png_ptr != NULL && info_ptr != NULL &&
      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)
   {
      png_debug1(1, "in %s retrieval function", "cHRM");

      if (white_x != NULL)
         *white_x = png_float(png_ptr,
             info_ptr->colorspace.end_points_xy.whitex, "cHRM white X");
      if (white_y != NULL)
         *white_y = png_float(png_ptr,
             info_ptr->colorspace.end_points_xy.whitey, "cHRM white Y");
      if (red_x != NULL)
         *red_x = png_float(png_ptr, info_ptr->colorspace.end_points_xy.redx,
             "cHRM red X");
      if (red_y != NULL)
         *red_y = png_float(png_ptr, info_ptr->colorspace.end_points_xy.redy,
             "cHRM red Y");
      if (green_x != NULL)
         *green_x = png_float(png_ptr,
             info_ptr->colorspace.end_points_xy.greenx, "cHRM green X");
      if (green_y != NULL)
         *green_y = png_float(png_ptr,
             info_ptr->colorspace.end_points_xy.greeny, "cHRM green Y");
      if (blue_x != NULL)
         *blue_x = png_float(png_ptr, info_ptr->colorspace.end_points_xy.bluex,
             "cHRM blue X");
      if (blue_y != NULL)
         *blue_y = png_float(png_ptr, info_ptr->colorspace.end_points_xy.bluey,
             "cHRM blue Y");
      return (PNG_INFO_cHRM);
   }

   return (0);
}

png_uint_32 PNGAPI
png_get_cHRM_XYZ(png_const_structrp png_ptr, png_const_inforp info_ptr,
    double *red_X, double *red_Y, double *red_Z, double *green_X,
    double *green_Y, double *green_Z, double *blue_X, double *blue_Y,
    double *blue_Z)
{
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)
   {
      png_debug1(1, "in %s retrieval function", "cHRM_XYZ(float)");

      if (red_X != NULL)
         *red_X = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_X,
             "cHRM red X");
      if (red_Y != NULL)
         *red_Y = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_Y,
             "cHRM red Y");
      if (red_Z != NULL)
         *red_Z = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_Z,
             "cHRM red Z");
      if (green_X != NULL)
         *green_X = png_float(png_ptr,
             info_ptr->colorspace.end_points_XYZ.green_X, "cHRM green X");
      if (green_Y != NULL)
         *green_Y = png_float(png_ptr,
             info_ptr->colorspace.end_points_XYZ.green_Y, "cHRM green Y");
      if (green_Z != NULL)
         *green_Z = png_float(png_ptr,
             info_ptr->colorspace.end_points_XYZ.green_Z, "cHRM green Z");
      if (blue_X != NULL)
         *blue_X = png_float(png_ptr,
             info_ptr->colorspace.end_points_XYZ.blue_X, "cHRM blue X");
      if (blue_Y != NULL)
         *blue_Y = png_float(png_ptr,
             info_ptr->colorspace.end_points_XYZ.blue_Y, "cHRM blue Y");
      if (blue_Z != NULL)
         *blue_Z = png_float(png_ptr,
             info_ptr->colorspace.end_points_XYZ.blue_Z, "cHRM blue Z");
      return (PNG_INFO_cHRM);
   }

   return (0);
}
#  endif

#  ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_cHRM_XYZ_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,
    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,
    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,
    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,
    png_fixed_point *int_blue_Z)
{
   if (png_ptr != NULL && info_ptr != NULL &&
      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)
   {
      png_debug1(1, "in %s retrieval function", "cHRM_XYZ");

      if (int_red_X != NULL)
         *int_red_X = info_ptr->colorspace.end_points_XYZ.red_X;
      if (int_red_Y != NULL)
         *int_red_Y = info_ptr->colorspace.end_points_XYZ.red_Y;
      if (int_red_Z != NULL)
         *int_red_Z = info_ptr->colorspace.end_points_XYZ.red_Z;
      if (int_green_X != NULL)
         *int_green_X = info_ptr->colorspace.end_points_XYZ.green_X;
      if (int_green_Y != NULL)
         *int_green_Y = info_ptr->colorspace.end_points_XYZ.green_Y;
      if (int_green_Z != NULL)
         *int_green_Z = info_ptr->colorspace.end_points_XYZ.green_Z;
      if (int_blue_X != NULL)
         *int_blue_X = info_ptr->colorspace.end_points_XYZ.blue_X;
      if (int_blue_Y != NULL)
         *int_blue_Y = info_ptr->colorspace.end_points_XYZ.blue_Y;
      if (int_blue_Z != NULL)
         *int_blue_Z = info_ptr->colorspace.end_points_XYZ.blue_Z;
      return (PNG_INFO_cHRM);
   }

   return (0);
}

png_uint_32 PNGAPI
png_get_cHRM_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,
    png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,
    png_fixed_point *blue_x, png_fixed_point *blue_y)
{
   png_debug1(1, "in %s retrieval function", "cHRM");

   if (png_ptr != NULL && info_ptr != NULL &&
      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)
   {
      if (white_x != NULL)
         *white_x = info_ptr->colorspace.end_points_xy.whitex;
      if (white_y != NULL)
         *white_y = info_ptr->colorspace.end_points_xy.whitey;
      if (red_x != NULL)
         *red_x = info_ptr->colorspace.end_points_xy.redx;
      if (red_y != NULL)
         *red_y = info_ptr->colorspace.end_points_xy.redy;
      if (green_x != NULL)
         *green_x = info_ptr->colorspace.end_points_xy.greenx;
      if (green_y != NULL)
         *green_y = info_ptr->colorspace.end_points_xy.greeny;
      if (blue_x != NULL)
         *blue_x = info_ptr->colorspace.end_points_xy.bluex;
      if (blue_y != NULL)
         *blue_y = info_ptr->colorspace.end_points_xy.bluey;
      return (PNG_INFO_cHRM);
   }

   return (0);
}
#  endif
#endif

#ifdef PNG_gAMA_SUPPORTED
#  ifdef PNG_FIXED_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_gAMA_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_fixed_point *file_gamma)
{
   png_debug1(1, "in %s retrieval function", "gAMA");

   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&
       file_gamma != NULL)
   {
      *file_gamma = info_ptr->colorspace.gamma;
      return (PNG_INFO_gAMA);
   }

   return (0);
}
#  endif

#  ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_gAMA(png_const_structrp png_ptr, png_const_inforp info_ptr,
    double *file_gamma)
{
   png_debug1(1, "in %s retrieval function", "gAMA(float)");

   if (png_ptr != NULL && info_ptr != NULL &&
      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&
      file_gamma != NULL)
   {
      *file_gamma = png_float(png_ptr, info_ptr->colorspace.gamma,
          "png_get_gAMA");
      return (PNG_INFO_gAMA);
   }

   return (0);
}
#  endif
#endif

#ifdef PNG_sRGB_SUPPORTED
png_uint_32 PNGAPI
png_get_sRGB(png_const_structrp png_ptr, png_const_inforp info_ptr,
    int *file_srgb_intent)
{
   png_debug1(1, "in %s retrieval function", "sRGB");

   if (png_ptr != NULL && info_ptr != NULL &&
      (info_ptr->valid & PNG_INFO_sRGB) != 0 && file_srgb_intent != NULL)
   {
      *file_srgb_intent = info_ptr->colorspace.rendering_intent;
      return (PNG_INFO_sRGB);
   }

   return (0);
}
#endif

#ifdef PNG_iCCP_SUPPORTED
png_uint_32 PNGAPI
png_get_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,
    png_charpp name, int *compression_type,
    png_bytepp profile, png_uint_32 *proflen)
{
   png_debug1(1, "in %s retrieval function", "iCCP");

   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_iCCP) != 0 &&
       name != NULL && compression_type != NULL && profile != NULL &&
           proflen != NULL)
   {
      *name = info_ptr->iccp_name;
      *profile = info_ptr->iccp_profile;
      *proflen = png_get_uint_32(info_ptr->iccp_profile);
      /* This is somewhat irrelevant since the profile data returned has
       * actually been uncompressed.
       */
      *compression_type = PNG_COMPRESSION_TYPE_BASE;
      return (PNG_INFO_iCCP);
   }

   return (0);
}
#endif

#ifdef PNG_sPLT_SUPPORTED
int PNGAPI
png_get_sPLT(png_const_structrp png_ptr, png_inforp info_ptr,
    png_sPLT_tpp spalettes)
{
   if (png_ptr != NULL && info_ptr != NULL && spalettes != NULL)
   {
      *spalettes = info_ptr->splt_palettes;
      return info_ptr->splt_palettes_num;
   }

   return (0);
}
#endif

#ifdef PNG_hIST_SUPPORTED
png_uint_32 PNGAPI
png_get_hIST(png_const_structrp png_ptr, png_inforp info_ptr,
    png_uint_16p *hist)
{
   png_debug1(1, "in %s retrieval function", "hIST");

   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_hIST) != 0 && hist != NULL)
   {
      *hist = info_ptr->hist;
      return (PNG_INFO_hIST);
   }

   return (0);
}
#endif

png_uint_32 PNGAPI
png_get_IHDR(png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_uint_32 *width, png_uint_32 *height, int *bit_depth,
    int *color_type, int *interlace_type, int *compression_type,
    int *filter_type)
{
   png_debug1(1, "in %s retrieval function", "IHDR");

   if (png_ptr == NULL || info_ptr == NULL)
      return (0);

   if (width != NULL)
       *width = info_ptr->width;

   if (height != NULL)
       *height = info_ptr->height;

   if (bit_depth != NULL)
       *bit_depth = info_ptr->bit_depth;

   if (color_type != NULL)
       *color_type = info_ptr->color_type;

   if (compression_type != NULL)
      *compression_type = info_ptr->compression_type;

   if (filter_type != NULL)
      *filter_type = info_ptr->filter_type;

   if (interlace_type != NULL)
      *interlace_type = info_ptr->interlace_type;

   /* This is redundant if we can be sure that the info_ptr values were all
    * assigned in png_set_IHDR().  We do the check anyhow in case an
    * application has ignored our advice not to mess with the members
    * of info_ptr directly.
    */
   png_check_IHDR(png_ptr, info_ptr->width, info_ptr->height,
       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
       info_ptr->compression_type, info_ptr->filter_type);

   return (1);
}

#ifdef PNG_oFFs_SUPPORTED
png_uint_32 PNGAPI
png_get_oFFs(png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)
{
   png_debug1(1, "in %s retrieval function", "oFFs");

   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_oFFs) != 0 &&
       offset_x != NULL && offset_y != NULL && unit_type != NULL)
   {
      *offset_x = info_ptr->x_offset;
      *offset_y = info_ptr->y_offset;
      *unit_type = (int)info_ptr->offset_unit_type;
      return (PNG_INFO_oFFs);
   }

   return (0);
}
#endif

#ifdef PNG_pCAL_SUPPORTED
png_uint_32 PNGAPI
png_get_pCAL(png_const_structrp png_ptr, png_inforp info_ptr,
    png_charp *purpose, png_int_32 *X0, png_int_32 *X1, int *type, int *nparams,
    png_charp *units, png_charpp *params)
{
   png_debug1(1, "in %s retrieval function", "pCAL");

   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_pCAL) != 0 &&
       purpose != NULL && X0 != NULL && X1 != NULL && type != NULL &&
       nparams != NULL && units != NULL && params != NULL)
   {
      *purpose = info_ptr->pcal_purpose;
      *X0 = info_ptr->pcal_X0;
      *X1 = info_ptr->pcal_X1;
      *type = (int)info_ptr->pcal_type;
      *nparams = (int)info_ptr->pcal_nparams;
      *units = info_ptr->pcal_units;
      *params = info_ptr->pcal_params;
      return (PNG_INFO_pCAL);
   }

   return (0);
}
#endif

#ifdef PNG_sCAL_SUPPORTED
#  ifdef PNG_FIXED_POINT_SUPPORTED
#    if defined(PNG_FLOATING_ARITHMETIC_SUPPORTED) || \
         defined(PNG_FLOATING_POINT_SUPPORTED)
png_uint_32 PNGAPI
png_get_sCAL_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
    int *unit, png_fixed_point *width, png_fixed_point *height)
{
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL) != 0)
   {
      *unit = info_ptr->scal_unit;
      /*TODO: make this work without FP support; the API is currently eliminated
       * if neither floating point APIs nor internal floating point arithmetic
       * are enabled.
       */
      *width = png_fixed(png_ptr, atof(info_ptr->scal_s_width), "sCAL width");
      *height = png_fixed(png_ptr, atof(info_ptr->scal_s_height),
          "sCAL height");
      return (PNG_INFO_sCAL);
   }

   return(0);
}
#    endif /* FLOATING_ARITHMETIC */
#  endif /* FIXED_POINT */
#  ifdef PNG_FLOATING_POINT_SUPPORTED
png_uint_32 PNGAPI
png_get_sCAL(png_const_structrp png_ptr, png_const_inforp info_ptr,
    int *unit, double *width, double *height)
{
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL) != 0)
   {
      *unit = info_ptr->scal_unit;
      *width = atof(info_ptr->scal_s_width);
      *height = atof(info_ptr->scal_s_height);
      return (PNG_INFO_sCAL);
   }

   return(0);
}
#  endif /* FLOATING POINT */
png_uint_32 PNGAPI
png_get_sCAL_s(png_const_structrp png_ptr, png_const_inforp info_ptr,
    int *unit, png_charpp width, png_charpp height)
{
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sCAL) != 0)
   {
      *unit = info_ptr->scal_unit;
      *width = info_ptr->scal_s_width;
      *height = info_ptr->scal_s_height;
      return (PNG_INFO_sCAL);
   }

   return(0);
}
#endif /* sCAL */

#ifdef PNG_pHYs_SUPPORTED
png_uint_32 PNGAPI
png_get_pHYs(png_const_structrp png_ptr, png_const_inforp info_ptr,
    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
{
   png_uint_32 retval = 0;

   png_debug1(1, "in %s retrieval function", "pHYs");

   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_pHYs) != 0)
   {
      if (res_x != NULL)
      {
         *res_x = info_ptr->x_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }

      if (res_y != NULL)
      {
         *res_y = info_ptr->y_pixels_per_unit;
         retval |= PNG_INFO_pHYs;
      }

      if (unit_type != NULL)
      {
         *unit_type = (int)info_ptr->phys_unit_type;
         retval |= PNG_INFO_pHYs;
      }
   }

   return (retval);
}
#endif /* pHYs */

png_uint_32 PNGAPI
png_get_PLTE(png_const_structrp png_ptr, png_inforp info_ptr,
    png_colorp *palette, int *num_palette)
{
   png_debug1(1, "in %s retrieval function", "PLTE");

   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_PLTE) != 0 && palette != NULL)
   {
      *palette = info_ptr->palette;
      *num_palette = info_ptr->num_palette;
      png_debug1(3, "num_palette = %d", *num_palette);
      return (PNG_INFO_PLTE);
   }

   return (0);
}

#ifdef PNG_sBIT_SUPPORTED
png_uint_32 PNGAPI
png_get_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,
    png_color_8p *sig_bit)
{
   png_debug1(1, "in %s retrieval function", "sBIT");

   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_sBIT) != 0 && sig_bit != NULL)
   {
      *sig_bit = &(info_ptr->sig_bit);
      return (PNG_INFO_sBIT);
   }

   return (0);
}
#endif

#ifdef PNG_TEXT_SUPPORTED
int PNGAPI
png_get_text(png_const_structrp png_ptr, png_inforp info_ptr,
    png_textp *text_ptr, int *num_text)
{
   if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)
   {
      png_debug1(1, "in 0x%lx retrieval function",
         (unsigned long)png_ptr->chunk_name);

      if (text_ptr != NULL)
         *text_ptr = info_ptr->text;

      if (num_text != NULL)
         *num_text = info_ptr->num_text;

      return info_ptr->num_text;
   }

   if (num_text != NULL)
      *num_text = 0;

   return(0);
}
#endif

#ifdef PNG_tIME_SUPPORTED
png_uint_32 PNGAPI
png_get_tIME(png_const_structrp png_ptr, png_inforp info_ptr,
    png_timep *mod_time)
{
   png_debug1(1, "in %s retrieval function", "tIME");

   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_tIME) != 0 && mod_time != NULL)
   {
      *mod_time = &(info_ptr->mod_time);
      return (PNG_INFO_tIME);
   }

   return (0);
}
#endif

#ifdef PNG_tRNS_SUPPORTED
png_uint_32 PNGAPI
png_get_tRNS(png_const_structrp png_ptr, png_inforp info_ptr,
    png_bytep *trans_alpha, int *num_trans, png_color_16p *trans_color)
{
   png_uint_32 retval = 0;
   if (png_ptr != NULL && info_ptr != NULL &&
       (info_ptr->valid & PNG_INFO_tRNS) != 0)
   {
      png_debug1(1, "in %s retrieval function", "tRNS");

      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         if (trans_alpha != NULL)
         {
            *trans_alpha = info_ptr->trans_alpha;
            retval |= PNG_INFO_tRNS;
         }

         if (trans_color != NULL)
            *trans_color = &(info_ptr->trans_color);
      }

      else /* if (info_ptr->color_type != PNG_COLOR_TYPE_PALETTE) */
      {
         if (trans_color != NULL)
         {
            *trans_color = &(info_ptr->trans_color);
            retval |= PNG_INFO_tRNS;
         }

         if (trans_alpha != NULL)
            *trans_alpha = NULL;
      }

      if (num_trans != NULL)
      {
         *num_trans = info_ptr->num_trans;
         retval |= PNG_INFO_tRNS;
      }
   }

   return (retval);
}
#endif

#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
int PNGAPI
png_get_unknown_chunks(png_const_structrp png_ptr, png_inforp info_ptr,
    png_unknown_chunkpp unknowns)
{
   if (png_ptr != NULL && info_ptr != NULL && unknowns != NULL)
   {
      *unknowns = info_ptr->unknown_chunks;
      return info_ptr->unknown_chunks_num;
   }

   return (0);
}
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
png_byte PNGAPI
png_get_rgb_to_gray_status (png_const_structrp png_ptr)
{
   return (png_byte)(png_ptr ? png_ptr->rgb_to_gray_status : 0);
}
#endif

#ifdef PNG_USER_CHUNKS_SUPPORTED
png_voidp PNGAPI
png_get_user_chunk_ptr(png_const_structrp png_ptr)
{
   return (png_ptr ? png_ptr->user_chunk_ptr : NULL);
}
#endif

png_size_t PNGAPI
png_get_compression_buffer_size(png_const_structrp png_ptr)
{
   if (png_ptr == NULL)
      return 0;

#ifdef PNG_WRITE_SUPPORTED
   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)
#endif
   {
#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
      return png_ptr->IDAT_read_size;
#else
      return PNG_IDAT_READ_SIZE;
#endif
   }

#ifdef PNG_WRITE_SUPPORTED
   else
      return png_ptr->zbuffer_size;
#endif
}

#ifdef PNG_SET_USER_LIMITS_SUPPORTED
/* These functions were added to libpng 1.2.6 and were enabled
 * by default in libpng-1.4.0 */
png_uint_32 PNGAPI
png_get_user_width_max (png_const_structrp png_ptr)
{
   return (png_ptr ? png_ptr->user_width_max : 0);
}

png_uint_32 PNGAPI
png_get_user_height_max (png_const_structrp png_ptr)
{
   return (png_ptr ? png_ptr->user_height_max : 0);
}

/* This function was added to libpng 1.4.0 */
png_uint_32 PNGAPI
png_get_chunk_cache_max (png_const_structrp png_ptr)
{
   return (png_ptr ? png_ptr->user_chunk_cache_max : 0);
}

/* This function was added to libpng 1.4.1 */
png_alloc_size_t PNGAPI
png_get_chunk_malloc_max (png_const_structrp png_ptr)
{
   return (png_ptr ? png_ptr->user_chunk_malloc_max : 0);
}
#endif /* SET_USER_LIMITS */

/* These functions were added to libpng 1.4.0 */
#ifdef PNG_IO_STATE_SUPPORTED
png_uint_32 PNGAPI
png_get_io_state (png_const_structrp png_ptr)
{
   return png_ptr->io_state;
}

png_uint_32 PNGAPI
png_get_io_chunk_type (png_const_structrp png_ptr)
{
   return png_ptr->chunk_name;
}
#endif /* IO_STATE */

#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
#  ifdef PNG_GET_PALETTE_MAX_SUPPORTED
int PNGAPI
png_get_palette_max(png_const_structp png_ptr, png_const_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return png_ptr->num_palette_max;

   return (-1);
}
#  endif
#endif

#endif /* READ || WRITE */

```

`ThirdPartyBuild/PNG/Code/pnginfo.h`:

```h

/* pnginfo.h - header file for PNG reference library
 *
 * Last changed in libpng 1.6.1 [March 28, 2013]
 * Copyright (c) 1998-2002,2004,2006-2013 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

 /* png_info is a structure that holds the information in a PNG file so
 * that the application can find out the characteristics of the image.
 * If you are reading the file, this structure will tell you what is
 * in the PNG file.  If you are writing the file, fill in the information
 * you want to put into the PNG file, using png_set_*() functions, then
 * call png_write_info().
 *
 * The names chosen should be very close to the PNG specification, so
 * consult that document for information about the meaning of each field.
 *
 * With libpng < 0.95, it was only possible to directly set and read the
 * the values in the png_info_struct, which meant that the contents and
 * order of the values had to remain fixed.  With libpng 0.95 and later,
 * however, there are now functions that abstract the contents of
 * png_info_struct from the application, so this makes it easier to use
 * libpng with dynamic libraries, and even makes it possible to use
 * libraries that don't have all of the libpng ancillary chunk-handing
 * functionality.  In libpng-1.5.0 this was moved into a separate private
 * file that is not visible to applications.
 *
 * The following members may have allocated storage attached that should be
 * cleaned up before the structure is discarded: palette, trans, text,
 * pcal_purpose, pcal_units, pcal_params, hist, iccp_name, iccp_profile,
 * splt_palettes, scal_unit, row_pointers, and unknowns.   By default, these
 * are automatically freed when the info structure is deallocated, if they were
 * allocated internally by libpng.  This behavior can be changed by means
 * of the png_data_freer() function.
 *
 * More allocation details: all the chunk-reading functions that
 * change these members go through the corresponding png_set_*
 * functions.  A function to clear these members is available: see
 * png_free_data().  The png_set_* functions do not depend on being
 * able to point info structure members to any of the storage they are
 * passed (they make their own copies), EXCEPT that the png_set_text
 * functions use the same storage passed to them in the text_ptr or
 * itxt_ptr structure argument, and the png_set_rows and png_set_unknowns
 * functions do not make their own copies.
 */
#ifndef PNGINFO_H
#define PNGINFO_H

struct png_info_def
{
   /* The following are necessary for every PNG file */
   png_uint_32 width;  /* width of image in pixels (from IHDR) */
   png_uint_32 height; /* height of image in pixels (from IHDR) */
   png_uint_32 valid;  /* valid chunk data (see PNG_INFO_ below) */
   png_size_t rowbytes; /* bytes needed to hold an untransformed row */
   png_colorp palette;      /* array of color values (valid & PNG_INFO_PLTE) */
   png_uint_16 num_palette; /* number of color entries in "palette" (PLTE) */
   png_uint_16 num_trans;   /* number of transparent palette color (tRNS) */
   png_byte bit_depth;      /* 1, 2, 4, 8, or 16 bits/channel (from IHDR) */
   png_byte color_type;     /* see PNG_COLOR_TYPE_ below (from IHDR) */
   /* The following three should have been named *_method not *_type */
   png_byte compression_type; /* must be PNG_COMPRESSION_TYPE_BASE (IHDR) */
   png_byte filter_type;    /* must be PNG_FILTER_TYPE_BASE (from IHDR) */
   png_byte interlace_type; /* One of PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */

   /* The following are set by png_set_IHDR, called from the application on
    * write, but the are never actually used by the write code.
    */
   png_byte channels;       /* number of data channels per pixel (1, 2, 3, 4) */
   png_byte pixel_depth;    /* number of bits per pixel */
   png_byte spare_byte;     /* to align the data, and for future use */

#ifdef PNG_READ_SUPPORTED
   /* This is never set during write */
   png_byte signature[8];   /* magic bytes read by libpng from start of file */
#endif

   /* The rest of the data is optional.  If you are reading, check the
    * valid field to see if the information in these are valid.  If you
    * are writing, set the valid field to those chunks you want written,
    * and initialize the appropriate fields below.
    */

#if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)
   /* png_colorspace only contains 'flags' if neither GAMMA or COLORSPACE are
    * defined.  When COLORSPACE is switched on all the colorspace-defining
    * chunks should be enabled, when GAMMA is switched on all the gamma-defining
    * chunks should be enabled.  If this is not done it becomes possible to read
    * inconsistent PNG files and assign a probably incorrect interpretation to
    * the information.  (In other words, by carefully choosing which chunks to
    * recognize the system configuration can select an interpretation for PNG
    * files containing ambiguous data and this will result in inconsistent
    * behavior between different libpng builds!)
    */
   png_colorspace colorspace;
#endif

#ifdef PNG_iCCP_SUPPORTED
   /* iCCP chunk data. */
   png_charp iccp_name;     /* profile name */
   png_bytep iccp_profile;  /* International Color Consortium profile data */
   png_uint_32 iccp_proflen;  /* ICC profile data length */
#endif

#ifdef PNG_TEXT_SUPPORTED
   /* The tEXt, and zTXt chunks contain human-readable textual data in
    * uncompressed, compressed, and optionally compressed forms, respectively.
    * The data in "text" is an array of pointers to uncompressed,
    * null-terminated C strings. Each chunk has a keyword that describes the
    * textual data contained in that chunk.  Keywords are not required to be
    * unique, and the text string may be empty.  Any number of text chunks may
    * be in an image.
    */
   int num_text; /* number of comments read or comments to write */
   int max_text; /* current size of text array */
   png_textp text; /* array of comments read or comments to write */
#endif /* TEXT */

#ifdef PNG_tIME_SUPPORTED
   /* The tIME chunk holds the last time the displayed image data was
    * modified.  See the png_time struct for the contents of this struct.
    */
   png_time mod_time;
#endif

#ifdef PNG_sBIT_SUPPORTED
   /* The sBIT chunk specifies the number of significant high-order bits
    * in the pixel data.  Values are in the range [1, bit_depth], and are
    * only specified for the channels in the pixel data.  The contents of
    * the low-order bits is not specified.  Data is valid if
    * (valid & PNG_INFO_sBIT) is non-zero.
    */
   png_color_8 sig_bit; /* significant bits in color channels */
#endif

#if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_EXPAND_SUPPORTED) || \
defined(PNG_READ_BACKGROUND_SUPPORTED)
   /* The tRNS chunk supplies transparency data for paletted images and
    * other image types that don't need a full alpha channel.  There are
    * "num_trans" transparency values for a paletted image, stored in the
    * same order as the palette colors, starting from index 0.  Values
    * for the data are in the range [0, 255], ranging from fully transparent
    * to fully opaque, respectively.  For non-paletted images, there is a
    * single color specified that should be treated as fully transparent.
    * Data is valid if (valid & PNG_INFO_tRNS) is non-zero.
    */
   png_bytep trans_alpha;    /* alpha values for paletted image */
   png_color_16 trans_color; /* transparent color for non-palette image */
#endif

#if defined(PNG_bKGD_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
   /* The bKGD chunk gives the suggested image background color if the
    * display program does not have its own background color and the image
    * is needs to composited onto a background before display.  The colors
    * in "background" are normally in the same color space/depth as the
    * pixel data.  Data is valid if (valid & PNG_INFO_bKGD) is non-zero.
    */
   png_color_16 background;
#endif

#ifdef PNG_oFFs_SUPPORTED
   /* The oFFs chunk gives the offset in "offset_unit_type" units rightwards
    * and downwards from the top-left corner of the display, page, or other
    * application-specific co-ordinate space.  See the PNG_OFFSET_ defines
    * below for the unit types.  Valid if (valid & PNG_INFO_oFFs) non-zero.
    */
   png_int_32 x_offset; /* x offset on page */
   png_int_32 y_offset; /* y offset on page */
   png_byte offset_unit_type; /* offset units type */
#endif

#ifdef PNG_pHYs_SUPPORTED
   /* The pHYs chunk gives the physical pixel density of the image for
    * display or printing in "phys_unit_type" units (see PNG_RESOLUTION_
    * defines below).  Data is valid if (valid & PNG_INFO_pHYs) is non-zero.
    */
   png_uint_32 x_pixels_per_unit; /* horizontal pixel density */
   png_uint_32 y_pixels_per_unit; /* vertical pixel density */
   png_byte phys_unit_type; /* resolution type (see PNG_RESOLUTION_ below) */
#endif

#ifdef PNG_hIST_SUPPORTED
   /* The hIST chunk contains the relative frequency or importance of the
    * various palette entries, so that a viewer can intelligently select a
    * reduced-color palette, if required.  Data is an array of "num_palette"
    * values in the range [0,65535]. Data valid if (valid & PNG_INFO_hIST)
    * is non-zero.
    */
   png_uint_16p hist;
#endif

#ifdef PNG_pCAL_SUPPORTED
   /* The pCAL chunk describes a transformation between the stored pixel
    * values and original physical data values used to create the image.
    * The integer range [0, 2^bit_depth - 1] maps to the floating-point
    * range given by [pcal_X0, pcal_X1], and are further transformed by a
    * (possibly non-linear) transformation function given by "pcal_type"
    * and "pcal_params" into "pcal_units".  Please see the PNG_EQUATION_
    * defines below, and the PNG-Group's PNG extensions document for a
    * complete description of the transformations and how they should be
    * implemented, and for a description of the ASCII parameter strings.
    * Data values are valid if (valid & PNG_INFO_pCAL) non-zero.
    */
   png_charp pcal_purpose;  /* pCAL chunk description string */
   png_int_32 pcal_X0;      /* minimum value */
   png_int_32 pcal_X1;      /* maximum value */
   png_charp pcal_units;    /* Latin-1 string giving physical units */
   png_charpp pcal_params;  /* ASCII strings containing parameter values */
   png_byte pcal_type;      /* equation type (see PNG_EQUATION_ below) */
   png_byte pcal_nparams;   /* number of parameters given in pcal_params */
#endif

/* New members added in libpng-1.0.6 */
   png_uint_32 free_me;     /* flags items libpng is responsible for freeing */

#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
   /* Storage for unknown chunks that the library doesn't recognize. */
   png_unknown_chunkp unknown_chunks;

   /* The type of this field is limited by the type of
    * png_struct::user_chunk_cache_max, else overflow can occur.
    */
   int                unknown_chunks_num;
#endif

#ifdef PNG_sPLT_SUPPORTED
   /* Data on sPLT chunks (there may be more than one). */
   png_sPLT_tp splt_palettes;
   int         splt_palettes_num; /* Match type returned by png_get API */
#endif

#ifdef PNG_sCAL_SUPPORTED
   /* The sCAL chunk describes the actual physical dimensions of the
    * subject matter of the graphic.  The chunk contains a unit specification
    * a byte value, and two ASCII strings representing floating-point
    * values.  The values are width and height corresponsing to one pixel
    * in the image.  Data values are valid if (valid & PNG_INFO_sCAL) is
    * non-zero.
    */
   png_byte scal_unit;         /* unit of physical scale */
   png_charp scal_s_width;     /* string containing height */
   png_charp scal_s_height;    /* string containing width */
#endif

#ifdef PNG_INFO_IMAGE_SUPPORTED
   /* Memory has been allocated if (valid & PNG_ALLOCATED_INFO_ROWS)
      non-zero */
   /* Data valid if (valid & PNG_INFO_IDAT) non-zero */
   png_bytepp row_pointers;        /* the image bits */
#endif

};
#endif /* PNGINFO_H */

```

`ThirdPartyBuild/PNG/Code/pnglibconf.h`:

```h
/* libpng 1.6.28 STANDARD API DEFINITION */

/* pnglibconf.h - library build configuration */

/* Libpng version 1.6.28 - January 5, 2017 */

/* Copyright (c) 1998-2015 Glenn Randers-Pehrson */

/* This code is released under the libpng license. */
/* For conditions of distribution and use, see the disclaimer */
/* and license in png.h */

/* pnglibconf.h */
/* Machine generated file: DO NOT EDIT */
/* Derived from: scripts/pnglibconf.dfa */
#ifndef PNGLCONF_H
#define PNGLCONF_H
/* options */
#define PNG_16BIT_SUPPORTED
#define PNG_ALIGNED_MEMORY_SUPPORTED
/*#undef PNG_ARM_NEON_API_SUPPORTED*/
/*#undef PNG_ARM_NEON_CHECK_SUPPORTED*/
#define PNG_BENIGN_ERRORS_SUPPORTED
#define PNG_BENIGN_READ_ERRORS_SUPPORTED
/*#undef PNG_BENIGN_WRITE_ERRORS_SUPPORTED*/
#define PNG_BUILD_GRAYSCALE_PALETTE_SUPPORTED
#define PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
#define PNG_COLORSPACE_SUPPORTED
#define PNG_CONSOLE_IO_SUPPORTED
#define PNG_CONVERT_tIME_SUPPORTED
#define PNG_EASY_ACCESS_SUPPORTED
/*#undef PNG_ERROR_NUMBERS_SUPPORTED*/
#define PNG_ERROR_TEXT_SUPPORTED
#define PNG_FIXED_POINT_SUPPORTED
#define PNG_FLOATING_ARITHMETIC_SUPPORTED
#define PNG_FLOATING_POINT_SUPPORTED
#define PNG_FORMAT_AFIRST_SUPPORTED
#define PNG_FORMAT_BGR_SUPPORTED
#define PNG_GAMMA_SUPPORTED
#define PNG_GET_PALETTE_MAX_SUPPORTED
#define PNG_HANDLE_AS_UNKNOWN_SUPPORTED
#define PNG_INCH_CONVERSIONS_SUPPORTED
#define PNG_INFO_IMAGE_SUPPORTED
#define PNG_IO_STATE_SUPPORTED
#define PNG_MNG_FEATURES_SUPPORTED
#define PNG_POINTER_INDEXING_SUPPORTED
#define PNG_PROGRESSIVE_READ_SUPPORTED
#define PNG_READ_16BIT_SUPPORTED
#define PNG_READ_ALPHA_MODE_SUPPORTED
#define PNG_READ_ANCILLARY_CHUNKS_SUPPORTED
#define PNG_READ_BACKGROUND_SUPPORTED
#define PNG_READ_BGR_SUPPORTED
#define PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
#define PNG_READ_COMPOSITE_NODIV_SUPPORTED
#define PNG_READ_COMPRESSED_TEXT_SUPPORTED
#define PNG_READ_EXPAND_16_SUPPORTED
#define PNG_READ_EXPAND_SUPPORTED
#define PNG_READ_FILLER_SUPPORTED
#define PNG_READ_GAMMA_SUPPORTED
#define PNG_READ_GET_PALETTE_MAX_SUPPORTED
#define PNG_READ_GRAY_TO_RGB_SUPPORTED
#define PNG_READ_INTERLACING_SUPPORTED
#define PNG_READ_INT_FUNCTIONS_SUPPORTED
#define PNG_READ_INVERT_ALPHA_SUPPORTED
#define PNG_READ_INVERT_SUPPORTED
#define PNG_READ_OPT_PLTE_SUPPORTED
#define PNG_READ_PACKSWAP_SUPPORTED
#define PNG_READ_PACK_SUPPORTED
#define PNG_READ_QUANTIZE_SUPPORTED
#define PNG_READ_RGB_TO_GRAY_SUPPORTED
#define PNG_READ_SCALE_16_TO_8_SUPPORTED
#define PNG_READ_SHIFT_SUPPORTED
#define PNG_READ_STRIP_16_TO_8_SUPPORTED
#define PNG_READ_STRIP_ALPHA_SUPPORTED
#define PNG_READ_SUPPORTED
#define PNG_READ_SWAP_ALPHA_SUPPORTED
#define PNG_READ_SWAP_SUPPORTED
#define PNG_READ_TEXT_SUPPORTED
#define PNG_READ_TRANSFORMS_SUPPORTED
#define PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_READ_USER_CHUNKS_SUPPORTED
#define PNG_READ_USER_TRANSFORM_SUPPORTED
#define PNG_READ_bKGD_SUPPORTED
#define PNG_READ_cHRM_SUPPORTED
#define PNG_READ_gAMA_SUPPORTED
#define PNG_READ_hIST_SUPPORTED
#define PNG_READ_iCCP_SUPPORTED
#define PNG_READ_iTXt_SUPPORTED
#define PNG_READ_oFFs_SUPPORTED
#define PNG_READ_pCAL_SUPPORTED
#define PNG_READ_pHYs_SUPPORTED
#define PNG_READ_sBIT_SUPPORTED
#define PNG_READ_sCAL_SUPPORTED
#define PNG_READ_sPLT_SUPPORTED
#define PNG_READ_sRGB_SUPPORTED
#define PNG_READ_tEXt_SUPPORTED
#define PNG_READ_tIME_SUPPORTED
#define PNG_READ_tRNS_SUPPORTED
#define PNG_READ_zTXt_SUPPORTED
#define PNG_SAVE_INT_32_SUPPORTED
#define PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_SEQUENTIAL_READ_SUPPORTED
#define PNG_SETJMP_SUPPORTED
#define PNG_SET_OPTION_SUPPORTED
#define PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_SET_USER_LIMITS_SUPPORTED
#define PNG_SIMPLIFIED_READ_AFIRST_SUPPORTED
#define PNG_SIMPLIFIED_READ_BGR_SUPPORTED
#define PNG_SIMPLIFIED_READ_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_BGR_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
#define PNG_SIMPLIFIED_WRITE_SUPPORTED
#define PNG_STDIO_SUPPORTED
#define PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_TEXT_SUPPORTED
#define PNG_TIME_RFC1123_SUPPORTED
#define PNG_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_USER_CHUNKS_SUPPORTED
#define PNG_USER_LIMITS_SUPPORTED
#define PNG_USER_MEM_SUPPORTED
#define PNG_USER_TRANSFORM_INFO_SUPPORTED
#define PNG_USER_TRANSFORM_PTR_SUPPORTED
#define PNG_WARNINGS_SUPPORTED
#define PNG_WRITE_16BIT_SUPPORTED
#define PNG_WRITE_ANCILLARY_CHUNKS_SUPPORTED
#define PNG_WRITE_BGR_SUPPORTED
#define PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
#define PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
#define PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
#define PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
#define PNG_WRITE_FILLER_SUPPORTED
#define PNG_WRITE_FILTER_SUPPORTED
#define PNG_WRITE_FLUSH_SUPPORTED
#define PNG_WRITE_GET_PALETTE_MAX_SUPPORTED
#define PNG_WRITE_INTERLACING_SUPPORTED
#define PNG_WRITE_INT_FUNCTIONS_SUPPORTED
#define PNG_WRITE_INVERT_ALPHA_SUPPORTED
#define PNG_WRITE_INVERT_SUPPORTED
#define PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
#define PNG_WRITE_PACKSWAP_SUPPORTED
#define PNG_WRITE_PACK_SUPPORTED
#define PNG_WRITE_SHIFT_SUPPORTED
#define PNG_WRITE_SUPPORTED
#define PNG_WRITE_SWAP_ALPHA_SUPPORTED
#define PNG_WRITE_SWAP_SUPPORTED
#define PNG_WRITE_TEXT_SUPPORTED
#define PNG_WRITE_TRANSFORMS_SUPPORTED
#define PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
#define PNG_WRITE_USER_TRANSFORM_SUPPORTED
#define PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
#define PNG_WRITE_bKGD_SUPPORTED
#define PNG_WRITE_cHRM_SUPPORTED
#define PNG_WRITE_gAMA_SUPPORTED
#define PNG_WRITE_hIST_SUPPORTED
#define PNG_WRITE_iCCP_SUPPORTED
#define PNG_WRITE_iTXt_SUPPORTED
#define PNG_WRITE_oFFs_SUPPORTED
#define PNG_WRITE_pCAL_SUPPORTED
#define PNG_WRITE_pHYs_SUPPORTED
#define PNG_WRITE_sBIT_SUPPORTED
#define PNG_WRITE_sCAL_SUPPORTED
#define PNG_WRITE_sPLT_SUPPORTED
#define PNG_WRITE_sRGB_SUPPORTED
#define PNG_WRITE_tEXt_SUPPORTED
#define PNG_WRITE_tIME_SUPPORTED
#define PNG_WRITE_tRNS_SUPPORTED
#define PNG_WRITE_zTXt_SUPPORTED
#define PNG_bKGD_SUPPORTED
#define PNG_cHRM_SUPPORTED
#define PNG_gAMA_SUPPORTED
#define PNG_hIST_SUPPORTED
#define PNG_iCCP_SUPPORTED
#define PNG_iTXt_SUPPORTED
#define PNG_oFFs_SUPPORTED
#define PNG_pCAL_SUPPORTED
#define PNG_pHYs_SUPPORTED
#define PNG_sBIT_SUPPORTED
#define PNG_sCAL_SUPPORTED
#define PNG_sPLT_SUPPORTED
#define PNG_sRGB_SUPPORTED
#define PNG_tEXt_SUPPORTED
#define PNG_tIME_SUPPORTED
#define PNG_tRNS_SUPPORTED
#define PNG_zTXt_SUPPORTED
/* end of options */
/* settings */
#define PNG_API_RULE 0
#define PNG_DEFAULT_READ_MACROS 1
#define PNG_GAMMA_THRESHOLD_FIXED 5000
#define PNG_IDAT_READ_SIZE PNG_ZBUF_SIZE
#define PNG_INFLATE_BUF_SIZE 1024
#define PNG_LINKAGE_API extern
#define PNG_LINKAGE_CALLBACK extern
#define PNG_LINKAGE_DATA extern
#define PNG_LINKAGE_FUNCTION extern
#define PNG_MAX_GAMMA_8 11
#define PNG_QUANTIZE_BLUE_BITS 5
#define PNG_QUANTIZE_GREEN_BITS 5
#define PNG_QUANTIZE_RED_BITS 5
#define PNG_TEXT_Z_DEFAULT_COMPRESSION (-1)
#define PNG_TEXT_Z_DEFAULT_STRATEGY 0
#define PNG_USER_CHUNK_CACHE_MAX 1000
#define PNG_USER_CHUNK_MALLOC_MAX 8000000
#define PNG_USER_HEIGHT_MAX 1000000
#define PNG_USER_WIDTH_MAX 1000000
#define PNG_ZBUF_SIZE 8192
#define PNG_ZLIB_VERNUM 0 /* unknown */
#define PNG_Z_DEFAULT_COMPRESSION (-1)
#define PNG_Z_DEFAULT_NOFILTER_STRATEGY 0
#define PNG_Z_DEFAULT_STRATEGY 1
#define PNG_sCAL_PRECISION 5
#define PNG_sRGB_PROFILE_CHECKS 2
/* end of settings */
#endif /* PNGLCONF_H */

```

`ThirdPartyBuild/PNG/Code/pngmem.c`:

```c

/* pngmem.c - stub functions for memory allocation
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2002,2004,2006-2014,2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This file provides a location for all memory allocation.  Users who
 * need special memory handling are expected to supply replacement
 * functions for png_malloc() and png_free(), and to use
 * png_create_read_struct_2() and png_create_write_struct_2() to
 * identify the replacement functions.
 */

#include "pngpriv.h"

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)
/* Free a png_struct */
void /* PRIVATE */
png_destroy_png_struct(png_structrp png_ptr)
{
   if (png_ptr != NULL)
   {
      /* png_free might call png_error and may certainly call
       * png_get_mem_ptr, so fake a temporary png_struct to support this.
       */
      png_struct dummy_struct = *png_ptr;
      memset(png_ptr, 0, (sizeof *png_ptr));
      png_free(&dummy_struct, png_ptr);

#     ifdef PNG_SETJMP_SUPPORTED
         /* We may have a jmp_buf left to deallocate. */
         png_free_jmpbuf(&dummy_struct);
#     endif
   }
}

/* Allocate memory.  For reasonable files, size should never exceed
 * 64K.  However, zlib may allocate more than 64K if you don't tell
 * it not to.  See zconf.h and png.h for more information.  zlib does
 * need to allocate exactly 64K, so whatever you call here must
 * have the ability to do that.
 */
PNG_FUNCTION(png_voidp,PNGAPI
png_calloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
{
   png_voidp ret;

   ret = png_malloc(png_ptr, size);

   if (ret != NULL)
      memset(ret, 0, size);

   return ret;
}

/* png_malloc_base, an internal function added at libpng 1.6.0, does the work of
 * allocating memory, taking into account limits and PNG_USER_MEM_SUPPORTED.
 * Checking and error handling must happen outside this routine; it returns NULL
 * if the allocation cannot be done (for any reason.)
 */
PNG_FUNCTION(png_voidp /* PRIVATE */,
png_malloc_base,(png_const_structrp png_ptr, png_alloc_size_t size),
    PNG_ALLOCATED)
{
   /* Moved to png_malloc_base from png_malloc_default in 1.6.0; the DOS
    * allocators have also been removed in 1.6.0, so any 16-bit system now has
    * to implement a user memory handler.  This checks to be sure it isn't
    * called with big numbers.
    */
#ifndef PNG_USER_MEM_SUPPORTED
   PNG_UNUSED(png_ptr)
#endif

   /* Some compilers complain that this is always true.  However, it
    * can be false when integer overflow happens.
    */
   if (size > 0 && size <= PNG_SIZE_MAX
#     ifdef PNG_MAX_MALLOC_64K
         && size <= 65536U
#     endif
      )
   {
#ifdef PNG_USER_MEM_SUPPORTED
      if (png_ptr != NULL && png_ptr->malloc_fn != NULL)
         return png_ptr->malloc_fn(png_constcast(png_structrp,png_ptr), size);

      else
#endif
         return malloc((size_t)size); /* checked for truncation above */
   }

   else
      return NULL;
}

#if defined(PNG_TEXT_SUPPORTED) || defined(PNG_sPLT_SUPPORTED) ||\
   defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED)
/* This is really here only to work round a spurious warning in GCC 4.6 and 4.7
 * that arises because of the checks in png_realloc_array that are repeated in
 * png_malloc_array.
 */
static png_voidp
png_malloc_array_checked(png_const_structrp png_ptr, int nelements,
    size_t element_size)
{
   png_alloc_size_t req = (png_alloc_size_t)nelements; /* known to be > 0 */

   if (req <= PNG_SIZE_MAX/element_size)
      return png_malloc_base(png_ptr, req * element_size);

   /* The failure case when the request is too large */
   return NULL;
}

PNG_FUNCTION(png_voidp /* PRIVATE */,
png_malloc_array,(png_const_structrp png_ptr, int nelements,
    size_t element_size),PNG_ALLOCATED)
{
   if (nelements <= 0 || element_size == 0)
      png_error(png_ptr, "internal error: array alloc");

   return png_malloc_array_checked(png_ptr, nelements, element_size);
}

PNG_FUNCTION(png_voidp /* PRIVATE */,
png_realloc_array,(png_const_structrp png_ptr, png_const_voidp old_array,
    int old_elements, int add_elements, size_t element_size),PNG_ALLOCATED)
{
   /* These are internal errors: */
   if (add_elements <= 0 || element_size == 0 || old_elements < 0 ||
      (old_array == NULL && old_elements > 0))
      png_error(png_ptr, "internal error: array realloc");

   /* Check for overflow on the elements count (so the caller does not have to
    * check.)
    */
   if (add_elements <= INT_MAX - old_elements)
   {
      png_voidp new_array = png_malloc_array_checked(png_ptr,
          old_elements+add_elements, element_size);

      if (new_array != NULL)
      {
         /* Because png_malloc_array worked the size calculations below cannot
          * overflow.
          */
         if (old_elements > 0)
            memcpy(new_array, old_array, element_size*(unsigned)old_elements);

         memset((char*)new_array + element_size*(unsigned)old_elements, 0,
             element_size*(unsigned)add_elements);

         return new_array;
      }
   }

   return NULL; /* error */
}
#endif /* TEXT || sPLT || STORE_UNKNOWN_CHUNKS */

/* Various functions that have different error handling are derived from this.
 * png_malloc always exists, but if PNG_USER_MEM_SUPPORTED is defined a separate
 * function png_malloc_default is also provided.
 */
PNG_FUNCTION(png_voidp,PNGAPI
png_malloc,(png_const_structrp png_ptr, png_alloc_size_t size),PNG_ALLOCATED)
{
   png_voidp ret;

   if (png_ptr == NULL)
      return NULL;

   ret = png_malloc_base(png_ptr, size);

   if (ret == NULL)
       png_error(png_ptr, "Out of memory"); /* 'm' means png_malloc */

   return ret;
}

#ifdef PNG_USER_MEM_SUPPORTED
PNG_FUNCTION(png_voidp,PNGAPI
png_malloc_default,(png_const_structrp png_ptr, png_alloc_size_t size),
    PNG_ALLOCATED PNG_DEPRECATED)
{
   png_voidp ret;

   if (png_ptr == NULL)
      return NULL;

   /* Passing 'NULL' here bypasses the application provided memory handler. */
   ret = png_malloc_base(NULL/*use malloc*/, size);

   if (ret == NULL)
      png_error(png_ptr, "Out of Memory"); /* 'M' means png_malloc_default */

   return ret;
}
#endif /* USER_MEM */

/* This function was added at libpng version 1.2.3.  The png_malloc_warn()
 * function will issue a png_warning and return NULL instead of issuing a
 * png_error, if it fails to allocate the requested memory.
 */
PNG_FUNCTION(png_voidp,PNGAPI
png_malloc_warn,(png_const_structrp png_ptr, png_alloc_size_t size),
    PNG_ALLOCATED)
{
   if (png_ptr != NULL)
   {
      png_voidp ret = png_malloc_base(png_ptr, size);

      if (ret != NULL)
         return ret;

      png_warning(png_ptr, "Out of memory");
   }

   return NULL;
}

/* Free a pointer allocated by png_malloc().  If ptr is NULL, return
 * without taking any action.
 */
void PNGAPI
png_free(png_const_structrp png_ptr, png_voidp ptr)
{
   if (png_ptr == NULL || ptr == NULL)
      return;

#ifdef PNG_USER_MEM_SUPPORTED
   if (png_ptr->free_fn != NULL)
      png_ptr->free_fn(png_constcast(png_structrp,png_ptr), ptr);

   else
      png_free_default(png_ptr, ptr);
}

PNG_FUNCTION(void,PNGAPI
png_free_default,(png_const_structrp png_ptr, png_voidp ptr),PNG_DEPRECATED)
{
   if (png_ptr == NULL || ptr == NULL)
      return;
#endif /* USER_MEM */

   free(ptr);
}

#ifdef PNG_USER_MEM_SUPPORTED
/* This function is called when the application wants to use another method
 * of allocating and freeing memory.
 */
void PNGAPI
png_set_mem_fn(png_structrp png_ptr, png_voidp mem_ptr, png_malloc_ptr
  malloc_fn, png_free_ptr free_fn)
{
   if (png_ptr != NULL)
   {
      png_ptr->mem_ptr = mem_ptr;
      png_ptr->malloc_fn = malloc_fn;
      png_ptr->free_fn = free_fn;
   }
}

/* This function returns a pointer to the mem_ptr associated with the user
 * functions.  The application should free any memory associated with this
 * pointer before png_write_destroy and png_read_destroy are called.
 */
png_voidp PNGAPI
png_get_mem_ptr(png_const_structrp png_ptr)
{
   if (png_ptr == NULL)
      return NULL;

   return png_ptr->mem_ptr;
}
#endif /* USER_MEM */
#endif /* READ || WRITE */

```

`ThirdPartyBuild/PNG/Code/pngpread.c`:

```c

/* pngpread.c - read a png file in push mode
 *
 * Last changed in libpng 1.6.24 [August 4, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

#include "pngpriv.h"

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED

/* Push model modes */
#define PNG_READ_SIG_MODE   0
#define PNG_READ_CHUNK_MODE 1
#define PNG_READ_IDAT_MODE  2
#define PNG_READ_tEXt_MODE  4
#define PNG_READ_zTXt_MODE  5
#define PNG_READ_DONE_MODE  6
#define PNG_READ_iTXt_MODE  7
#define PNG_ERROR_MODE      8

#define PNG_PUSH_SAVE_BUFFER_IF_FULL \
if (png_ptr->push_length + 4 > png_ptr->buffer_size) \
   { png_push_save_buffer(png_ptr); return; }
#define PNG_PUSH_SAVE_BUFFER_IF_LT(N) \
if (png_ptr->buffer_size < N) \
   { png_push_save_buffer(png_ptr); return; }

void PNGAPI
png_process_data(png_structrp png_ptr, png_inforp info_ptr,
    png_bytep buffer, png_size_t buffer_size)
{
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   png_push_restore_buffer(png_ptr, buffer, buffer_size);

   while (png_ptr->buffer_size)
   {
      png_process_some_data(png_ptr, info_ptr);
   }
}

png_size_t PNGAPI
png_process_data_pause(png_structrp png_ptr, int save)
{
   if (png_ptr != NULL)
   {
      /* It's easiest for the caller if we do the save; then the caller doesn't
       * have to supply the same data again:
       */
      if (save != 0)
         png_push_save_buffer(png_ptr);
      else
      {
         /* This includes any pending saved bytes: */
         png_size_t remaining = png_ptr->buffer_size;
         png_ptr->buffer_size = 0;

         /* So subtract the saved buffer size, unless all the data
          * is actually 'saved', in which case we just return 0
          */
         if (png_ptr->save_buffer_size < remaining)
            return remaining - png_ptr->save_buffer_size;
      }
   }

   return 0;
}

png_uint_32 PNGAPI
png_process_data_skip(png_structrp png_ptr)
{
/* TODO: Deprecate and remove this API.
 * Somewhere the implementation of this seems to have been lost,
 * or abandoned.  It was only to support some internal back-door access
 * to png_struct) in libpng-1.4.x.
 */
   png_app_warning(png_ptr,
"png_process_data_skip is not implemented in any current version of libpng");
   return 0;
}

/* What we do with the incoming data depends on what we were previously
 * doing before we ran out of data...
 */
void /* PRIVATE */
png_process_some_data(png_structrp png_ptr, png_inforp info_ptr)
{
   if (png_ptr == NULL)
      return;

   switch (png_ptr->process_mode)
   {
      case PNG_READ_SIG_MODE:
      {
         png_push_read_sig(png_ptr, info_ptr);
         break;
      }

      case PNG_READ_CHUNK_MODE:
      {
         png_push_read_chunk(png_ptr, info_ptr);
         break;
      }

      case PNG_READ_IDAT_MODE:
      {
         png_push_read_IDAT(png_ptr);
         break;
      }

      default:
      {
         png_ptr->buffer_size = 0;
         break;
      }
   }
}

/* Read any remaining signature bytes from the stream and compare them with
 * the correct PNG signature.  It is possible that this routine is called
 * with bytes already read from the signature, either because they have been
 * checked by the calling application, or because of multiple calls to this
 * routine.
 */
void /* PRIVATE */
png_push_read_sig(png_structrp png_ptr, png_inforp info_ptr)
{
   png_size_t num_checked = png_ptr->sig_bytes, /* SAFE, does not exceed 8 */
       num_to_check = 8 - num_checked;

   if (png_ptr->buffer_size < num_to_check)
   {
      num_to_check = png_ptr->buffer_size;
   }

   png_push_fill_buffer(png_ptr, &(info_ptr->signature[num_checked]),
       num_to_check);
   png_ptr->sig_bytes = (png_byte)(png_ptr->sig_bytes + num_to_check);

   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check))
   {
      if (num_checked < 4 &&
          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))
         png_error(png_ptr, "Not a PNG file");

      else
         png_error(png_ptr, "PNG file corrupted by ASCII conversion");
   }
   else
   {
      if (png_ptr->sig_bytes >= 8)
      {
         png_ptr->process_mode = PNG_READ_CHUNK_MODE;
      }
   }
}

void /* PRIVATE */
png_push_read_chunk(png_structrp png_ptr, png_inforp info_ptr)
{
   png_uint_32 chunk_name;
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
   int keep; /* unknown handling method */
#endif

   /* First we make sure we have enough data for the 4-byte chunk name
    * and the 4-byte chunk length before proceeding with decoding the
    * chunk data.  To fully decode each of these chunks, we also make
    * sure we have enough data in the buffer for the 4-byte CRC at the
    * end of every chunk (except IDAT, which is handled separately).
    */
   if ((png_ptr->mode & PNG_HAVE_CHUNK_HEADER) == 0)
   {
      png_byte chunk_length[4];
      png_byte chunk_tag[4];

      PNG_PUSH_SAVE_BUFFER_IF_LT(8)
      png_push_fill_buffer(png_ptr, chunk_length, 4);
      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
      png_reset_crc(png_ptr);
      png_crc_read(png_ptr, chunk_tag, 4);
      png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);
      png_check_chunk_name(png_ptr, png_ptr->chunk_name);
      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
   }

   chunk_name = png_ptr->chunk_name;

   if (chunk_name == png_IDAT)
   {
      if ((png_ptr->mode & PNG_AFTER_IDAT) != 0)
         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;

      /* If we reach an IDAT chunk, this means we have read all of the
       * header chunks, and we can start reading the image (or if this
       * is called after the image has been read - we have an error).
       */
      if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
         png_error(png_ptr, "Missing IHDR before IDAT");

      else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
          (png_ptr->mode & PNG_HAVE_PLTE) == 0)
         png_error(png_ptr, "Missing PLTE before IDAT");

      png_ptr->process_mode = PNG_READ_IDAT_MODE;

      if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
         if ((png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT) == 0)
            if (png_ptr->push_length == 0)
               return;

      png_ptr->mode |= PNG_HAVE_IDAT;

      if ((png_ptr->mode & PNG_AFTER_IDAT) != 0)
         png_benign_error(png_ptr, "Too many IDATs found");
   }

   if (chunk_name == png_IHDR)
   {
      if (png_ptr->push_length != 13)
         png_error(png_ptr, "Invalid IHDR length");

      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);
   }

   else if (chunk_name == png_IEND)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);

      png_ptr->process_mode = PNG_READ_DONE_MODE;
      png_push_have_end(png_ptr, info_ptr);
   }

#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
   else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length, keep);

      if (chunk_name == png_PLTE)
         png_ptr->mode |= PNG_HAVE_PLTE;
   }
#endif

   else if (chunk_name == png_PLTE)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);
   }

   else if (chunk_name == png_IDAT)
   {
      png_ptr->idat_size = png_ptr->push_length;
      png_ptr->process_mode = PNG_READ_IDAT_MODE;
      png_push_have_info(png_ptr, info_ptr);
      png_ptr->zstream.avail_out =
          (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
          png_ptr->iwidth) + 1;
      png_ptr->zstream.next_out = png_ptr->row_buf;
      return;
   }

#ifdef PNG_READ_gAMA_SUPPORTED
   else if (png_ptr->chunk_name == png_gAMA)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_sBIT_SUPPORTED
   else if (png_ptr->chunk_name == png_sBIT)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_cHRM_SUPPORTED
   else if (png_ptr->chunk_name == png_cHRM)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_sRGB_SUPPORTED
   else if (chunk_name == png_sRGB)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_iCCP_SUPPORTED
   else if (png_ptr->chunk_name == png_iCCP)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_sPLT_SUPPORTED
   else if (chunk_name == png_sPLT)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_tRNS_SUPPORTED
   else if (chunk_name == png_tRNS)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_bKGD_SUPPORTED
   else if (chunk_name == png_bKGD)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_hIST_SUPPORTED
   else if (chunk_name == png_hIST)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_pHYs_SUPPORTED
   else if (chunk_name == png_pHYs)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_oFFs_SUPPORTED
   else if (chunk_name == png_oFFs)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif

#ifdef PNG_READ_pCAL_SUPPORTED
   else if (chunk_name == png_pCAL)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_sCAL_SUPPORTED
   else if (chunk_name == png_sCAL)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_tIME_SUPPORTED
   else if (chunk_name == png_tIME)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_tEXt_SUPPORTED
   else if (chunk_name == png_tEXt)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_zTXt_SUPPORTED
   else if (chunk_name == png_zTXt)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);
   }

#endif
#ifdef PNG_READ_iTXt_SUPPORTED
   else if (chunk_name == png_iTXt)
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);
   }
#endif

   else
   {
      PNG_PUSH_SAVE_BUFFER_IF_FULL
      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length,
          PNG_HANDLE_CHUNK_AS_DEFAULT);
   }

   png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
}

void PNGCBAPI
png_push_fill_buffer(png_structp png_ptr, png_bytep buffer, png_size_t length)
{
   png_bytep ptr;

   if (png_ptr == NULL)
      return;

   ptr = buffer;
   if (png_ptr->save_buffer_size != 0)
   {
      png_size_t save_size;

      if (length < png_ptr->save_buffer_size)
         save_size = length;

      else
         save_size = png_ptr->save_buffer_size;

      memcpy(ptr, png_ptr->save_buffer_ptr, save_size);
      length -= save_size;
      ptr += save_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->save_buffer_size -= save_size;
      png_ptr->save_buffer_ptr += save_size;
   }
   if (length != 0 && png_ptr->current_buffer_size != 0)
   {
      png_size_t save_size;

      if (length < png_ptr->current_buffer_size)
         save_size = length;

      else
         save_size = png_ptr->current_buffer_size;

      memcpy(ptr, png_ptr->current_buffer_ptr, save_size);
      png_ptr->buffer_size -= save_size;
      png_ptr->current_buffer_size -= save_size;
      png_ptr->current_buffer_ptr += save_size;
   }
}

void /* PRIVATE */
png_push_save_buffer(png_structrp png_ptr)
{
   if (png_ptr->save_buffer_size != 0)
   {
      if (png_ptr->save_buffer_ptr != png_ptr->save_buffer)
      {
         png_size_t i, istop;
         png_bytep sp;
         png_bytep dp;

         istop = png_ptr->save_buffer_size;
         for (i = 0, sp = png_ptr->save_buffer_ptr, dp = png_ptr->save_buffer;
             i < istop; i++, sp++, dp++)
         {
            *dp = *sp;
         }
      }
   }
   if (png_ptr->save_buffer_size + png_ptr->current_buffer_size >
       png_ptr->save_buffer_max)
   {
      png_size_t new_max;
      png_bytep old_buffer;

      if (png_ptr->save_buffer_size > PNG_SIZE_MAX -
          (png_ptr->current_buffer_size + 256))
      {
         png_error(png_ptr, "Potential overflow of save_buffer");
      }

      new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;
      old_buffer = png_ptr->save_buffer;
      png_ptr->save_buffer = (png_bytep)png_malloc_warn(png_ptr,
          (png_size_t)new_max);

      if (png_ptr->save_buffer == NULL)
      {
         png_free(png_ptr, old_buffer);
         png_error(png_ptr, "Insufficient memory for save_buffer");
      }

      if (old_buffer)
         memcpy(png_ptr->save_buffer, old_buffer, png_ptr->save_buffer_size);
      else if (png_ptr->save_buffer_size)
         png_error(png_ptr, "save_buffer error");
      png_free(png_ptr, old_buffer);
      png_ptr->save_buffer_max = new_max;
   }
   if (png_ptr->current_buffer_size)
   {
      memcpy(png_ptr->save_buffer + png_ptr->save_buffer_size,
         png_ptr->current_buffer_ptr, png_ptr->current_buffer_size);
      png_ptr->save_buffer_size += png_ptr->current_buffer_size;
      png_ptr->current_buffer_size = 0;
   }
   png_ptr->save_buffer_ptr = png_ptr->save_buffer;
   png_ptr->buffer_size = 0;
}

void /* PRIVATE */
png_push_restore_buffer(png_structrp png_ptr, png_bytep buffer,
    png_size_t buffer_length)
{
   png_ptr->current_buffer = buffer;
   png_ptr->current_buffer_size = buffer_length;
   png_ptr->buffer_size = buffer_length + png_ptr->save_buffer_size;
   png_ptr->current_buffer_ptr = png_ptr->current_buffer;
}

void /* PRIVATE */
png_push_read_IDAT(png_structrp png_ptr)
{
   if ((png_ptr->mode & PNG_HAVE_CHUNK_HEADER) == 0)
   {
      png_byte chunk_length[4];
      png_byte chunk_tag[4];

      /* TODO: this code can be commoned up with the same code in push_read */
      PNG_PUSH_SAVE_BUFFER_IF_LT(8)
      png_push_fill_buffer(png_ptr, chunk_length, 4);
      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);
      png_reset_crc(png_ptr);
      png_crc_read(png_ptr, chunk_tag, 4);
      png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);
      png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;

      if (png_ptr->chunk_name != png_IDAT)
      {
         png_ptr->process_mode = PNG_READ_CHUNK_MODE;

         if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)
            png_error(png_ptr, "Not enough compressed data");

         return;
      }

      png_ptr->idat_size = png_ptr->push_length;
   }

   if (png_ptr->idat_size != 0 && png_ptr->save_buffer_size != 0)
   {
      png_size_t save_size = png_ptr->save_buffer_size;
      png_uint_32 idat_size = png_ptr->idat_size;

      /* We want the smaller of 'idat_size' and 'current_buffer_size', but they
       * are of different types and we don't know which variable has the fewest
       * bits.  Carefully select the smaller and cast it to the type of the
       * larger - this cannot overflow.  Do not cast in the following test - it
       * will break on either 16-bit or 64-bit platforms.
       */
      if (idat_size < save_size)
         save_size = (png_size_t)idat_size;

      else
         idat_size = (png_uint_32)save_size;

      png_calculate_crc(png_ptr, png_ptr->save_buffer_ptr, save_size);

      png_process_IDAT_data(png_ptr, png_ptr->save_buffer_ptr, save_size);

      png_ptr->idat_size -= idat_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->save_buffer_size -= save_size;
      png_ptr->save_buffer_ptr += save_size;
   }

   if (png_ptr->idat_size != 0 && png_ptr->current_buffer_size != 0)
   {
      png_size_t save_size = png_ptr->current_buffer_size;
      png_uint_32 idat_size = png_ptr->idat_size;

      /* We want the smaller of 'idat_size' and 'current_buffer_size', but they
       * are of different types and we don't know which variable has the fewest
       * bits.  Carefully select the smaller and cast it to the type of the
       * larger - this cannot overflow.
       */
      if (idat_size < save_size)
         save_size = (png_size_t)idat_size;

      else
         idat_size = (png_uint_32)save_size;

      png_calculate_crc(png_ptr, png_ptr->current_buffer_ptr, save_size);

      png_process_IDAT_data(png_ptr, png_ptr->current_buffer_ptr, save_size);

      png_ptr->idat_size -= idat_size;
      png_ptr->buffer_size -= save_size;
      png_ptr->current_buffer_size -= save_size;
      png_ptr->current_buffer_ptr += save_size;
   }

   if (png_ptr->idat_size == 0)
   {
      PNG_PUSH_SAVE_BUFFER_IF_LT(4)
      png_crc_finish(png_ptr, 0);
      png_ptr->mode &= ~PNG_HAVE_CHUNK_HEADER;
      png_ptr->mode |= PNG_AFTER_IDAT;
      png_ptr->zowner = 0;
   }
}

void /* PRIVATE */
png_process_IDAT_data(png_structrp png_ptr, png_bytep buffer,
    png_size_t buffer_length)
{
   /* The caller checks for a non-zero buffer length. */
   if (!(buffer_length > 0) || buffer == NULL)
      png_error(png_ptr, "No IDAT data (internal error)");

   /* This routine must process all the data it has been given
    * before returning, calling the row callback as required to
    * handle the uncompressed results.
    */
   png_ptr->zstream.next_in = buffer;
   /* TODO: WARNING: TRUNCATION ERROR: DANGER WILL ROBINSON: */
   png_ptr->zstream.avail_in = (uInt)buffer_length;

   /* Keep going until the decompressed data is all processed
    * or the stream marked as finished.
    */
   while (png_ptr->zstream.avail_in > 0 &&
      (png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)
   {
      int ret;

      /* We have data for zlib, but we must check that zlib
       * has someplace to put the results.  It doesn't matter
       * if we don't expect any results -- it may be the input
       * data is just the LZ end code.
       */
      if (!(png_ptr->zstream.avail_out > 0))
      {
         /* TODO: WARNING: TRUNCATION ERROR: DANGER WILL ROBINSON: */
         png_ptr->zstream.avail_out = (uInt)(PNG_ROWBYTES(png_ptr->pixel_depth,
             png_ptr->iwidth) + 1);

         png_ptr->zstream.next_out = png_ptr->row_buf;
      }

      /* Using Z_SYNC_FLUSH here means that an unterminated
       * LZ stream (a stream with a missing end code) can still
       * be handled, otherwise (Z_NO_FLUSH) a future zlib
       * implementation might defer output and therefore
       * change the current behavior (see comments in inflate.c
       * for why this doesn't happen at present with zlib 1.2.5).
       */
      ret = PNG_INFLATE(png_ptr, Z_SYNC_FLUSH);

      /* Check for any failure before proceeding. */
      if (ret != Z_OK && ret != Z_STREAM_END)
      {
         /* Terminate the decompression. */
         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;
         png_ptr->zowner = 0;

         /* This may be a truncated stream (missing or
          * damaged end code).  Treat that as a warning.
          */
         if (png_ptr->row_number >= png_ptr->num_rows ||
             png_ptr->pass > 6)
            png_warning(png_ptr, "Truncated compressed data in IDAT");

         else
         {
            if (ret == Z_DATA_ERROR)
               png_benign_error(png_ptr, "IDAT: ADLER32 checksum mismatch");
            else
               png_error(png_ptr, "Decompression error in IDAT");
         }

         /* Skip the check on unprocessed input */
         return;
      }

      /* Did inflate output any data? */
      if (png_ptr->zstream.next_out != png_ptr->row_buf)
      {
         /* Is this unexpected data after the last row?
          * If it is, artificially terminate the LZ output
          * here.
          */
         if (png_ptr->row_number >= png_ptr->num_rows ||
             png_ptr->pass > 6)
         {
            /* Extra data. */
            png_warning(png_ptr, "Extra compressed data in IDAT");
            png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;
            png_ptr->zowner = 0;

            /* Do no more processing; skip the unprocessed
             * input check below.
             */
            return;
         }

         /* Do we have a complete row? */
         if (png_ptr->zstream.avail_out == 0)
            png_push_process_row(png_ptr);
      }

      /* And check for the end of the stream. */
      if (ret == Z_STREAM_END)
         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;
   }

   /* All the data should have been processed, if anything
    * is left at this point we have bytes of IDAT data
    * after the zlib end code.
    */
   if (png_ptr->zstream.avail_in > 0)
      png_warning(png_ptr, "Extra compression data in IDAT");
}

void /* PRIVATE */
png_push_process_row(png_structrp png_ptr)
{
   /* 1.5.6: row_info moved out of png_struct to a local here. */
   png_row_info row_info;

   row_info.width = png_ptr->iwidth; /* NOTE: width of current interlaced row */
   row_info.color_type = png_ptr->color_type;
   row_info.bit_depth = png_ptr->bit_depth;
   row_info.channels = png_ptr->channels;
   row_info.pixel_depth = png_ptr->pixel_depth;
   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);

   if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)
   {
      if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)
         png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,
            png_ptr->prev_row + 1, png_ptr->row_buf[0]);
      else
         png_error(png_ptr, "bad adaptive filter value");
   }

   /* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
    * 1.5.6, while the buffer really is this big in current versions of libpng
    * it may not be in the future, so this was changed just to copy the
    * interlaced row count:
    */
   memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1);

#ifdef PNG_READ_TRANSFORMS_SUPPORTED
   if (png_ptr->transformations != 0)
      png_do_read_transformations(png_ptr, &row_info);
#endif

   /* The transformed pixel depth should match the depth now in row_info. */
   if (png_ptr->transformed_pixel_depth == 0)
   {
      png_ptr->transformed_pixel_depth = row_info.pixel_depth;
      if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
         png_error(png_ptr, "progressive row overflow");
   }

   else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)
      png_error(png_ptr, "internal progressive row size calculation error");


#ifdef PNG_READ_INTERLACING_SUPPORTED
   /* Expand interlaced rows to full size */
   if (png_ptr->interlaced != 0 &&
       (png_ptr->transformations & PNG_INTERLACE) != 0)
   {
      if (png_ptr->pass < 6)
         png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass,
             png_ptr->transformations);

      switch (png_ptr->pass)
      {
         case 0:
         {
            int i;
            for (i = 0; i < 8 && png_ptr->pass == 0; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr); /* Updates png_ptr->pass */
            }

            if (png_ptr->pass == 2) /* Pass 1 might be empty */
            {
               for (i = 0; i < 4 && png_ptr->pass == 2; i++)
               {
                  png_push_have_row(png_ptr, NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }

            if (png_ptr->pass == 4 && png_ptr->height <= 4)
            {
               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
               {
                  png_push_have_row(png_ptr, NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }

            if (png_ptr->pass == 6 && png_ptr->height <= 4)
            {
                png_push_have_row(png_ptr, NULL);
                png_read_push_finish_row(png_ptr);
            }

            break;
         }

         case 1:
         {
            int i;
            for (i = 0; i < 8 && png_ptr->pass == 1; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }

            if (png_ptr->pass == 2) /* Skip top 4 generated rows */
            {
               for (i = 0; i < 4 && png_ptr->pass == 2; i++)
               {
                  png_push_have_row(png_ptr, NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }

            break;
         }

         case 2:
         {
            int i;

            for (i = 0; i < 4 && png_ptr->pass == 2; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }

            for (i = 0; i < 4 && png_ptr->pass == 2; i++)
            {
               png_push_have_row(png_ptr, NULL);
               png_read_push_finish_row(png_ptr);
            }

            if (png_ptr->pass == 4) /* Pass 3 might be empty */
            {
               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
               {
                  png_push_have_row(png_ptr, NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }

            break;
         }

         case 3:
         {
            int i;

            for (i = 0; i < 4 && png_ptr->pass == 3; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }

            if (png_ptr->pass == 4) /* Skip top two generated rows */
            {
               for (i = 0; i < 2 && png_ptr->pass == 4; i++)
               {
                  png_push_have_row(png_ptr, NULL);
                  png_read_push_finish_row(png_ptr);
               }
            }

            break;
         }

         case 4:
         {
            int i;

            for (i = 0; i < 2 && png_ptr->pass == 4; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }

            for (i = 0; i < 2 && png_ptr->pass == 4; i++)
            {
               png_push_have_row(png_ptr, NULL);
               png_read_push_finish_row(png_ptr);
            }

            if (png_ptr->pass == 6) /* Pass 5 might be empty */
            {
               png_push_have_row(png_ptr, NULL);
               png_read_push_finish_row(png_ptr);
            }

            break;
         }

         case 5:
         {
            int i;

            for (i = 0; i < 2 && png_ptr->pass == 5; i++)
            {
               png_push_have_row(png_ptr, png_ptr->row_buf + 1);
               png_read_push_finish_row(png_ptr);
            }

            if (png_ptr->pass == 6) /* Skip top generated row */
            {
               png_push_have_row(png_ptr, NULL);
               png_read_push_finish_row(png_ptr);
            }

            break;
         }

         default:
         case 6:
         {
            png_push_have_row(png_ptr, png_ptr->row_buf + 1);
            png_read_push_finish_row(png_ptr);

            if (png_ptr->pass != 6)
               break;

            png_push_have_row(png_ptr, NULL);
            png_read_push_finish_row(png_ptr);
         }
      }
   }
   else
#endif
   {
      png_push_have_row(png_ptr, png_ptr->row_buf + 1);
      png_read_push_finish_row(png_ptr);
   }
}

void /* PRIVATE */
png_read_push_finish_row(png_structrp png_ptr)
{
#ifdef PNG_READ_INTERLACING_SUPPORTED
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   static PNG_CONST png_byte png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   static PNG_CONST png_byte png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};

   /* Start of interlace block in the y direction */
   static PNG_CONST png_byte png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};

   /* Offset to next interlace block in the y direction */
   static PNG_CONST png_byte png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};

   /* Height of interlace block.  This is not currently used - if you need
    * it, uncomment it here and in png.h
   static PNG_CONST png_byte png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
   */
#endif

   png_ptr->row_number++;
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

#ifdef PNG_READ_INTERLACING_SUPPORTED
   if (png_ptr->interlaced != 0)
   {
      png_ptr->row_number = 0;
      memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);

      do
      {
         png_ptr->pass++;
         if ((png_ptr->pass == 1 && png_ptr->width < 5) ||
             (png_ptr->pass == 3 && png_ptr->width < 3) ||
             (png_ptr->pass == 5 && png_ptr->width < 2))
            png_ptr->pass++;

         if (png_ptr->pass > 7)
            png_ptr->pass--;

         if (png_ptr->pass >= 7)
            break;

         png_ptr->iwidth = (png_ptr->width +
             png_pass_inc[png_ptr->pass] - 1 -
             png_pass_start[png_ptr->pass]) /
             png_pass_inc[png_ptr->pass];

         if ((png_ptr->transformations & PNG_INTERLACE) != 0)
            break;

         png_ptr->num_rows = (png_ptr->height +
             png_pass_yinc[png_ptr->pass] - 1 -
             png_pass_ystart[png_ptr->pass]) /
             png_pass_yinc[png_ptr->pass];

      } while (png_ptr->iwidth == 0 || png_ptr->num_rows == 0);
   }
#endif /* READ_INTERLACING */
}

void /* PRIVATE */
png_push_have_info(png_structrp png_ptr, png_inforp info_ptr)
{
   if (png_ptr->info_fn != NULL)
      (*(png_ptr->info_fn))(png_ptr, info_ptr);
}

void /* PRIVATE */
png_push_have_end(png_structrp png_ptr, png_inforp info_ptr)
{
   if (png_ptr->end_fn != NULL)
      (*(png_ptr->end_fn))(png_ptr, info_ptr);
}

void /* PRIVATE */
png_push_have_row(png_structrp png_ptr, png_bytep row)
{
   if (png_ptr->row_fn != NULL)
      (*(png_ptr->row_fn))(png_ptr, row, png_ptr->row_number,
          (int)png_ptr->pass);
}

#ifdef PNG_READ_INTERLACING_SUPPORTED
void PNGAPI
png_progressive_combine_row(png_const_structrp png_ptr, png_bytep old_row,
    png_const_bytep new_row)
{
   if (png_ptr == NULL)
      return;

   /* new_row is a flag here - if it is NULL then the app callback was called
    * from an empty row (see the calls to png_struct::row_fn below), otherwise
    * it must be png_ptr->row_buf+1
    */
   if (new_row != NULL)
      png_combine_row(png_ptr, old_row, 1/*blocky display*/);
}
#endif /* READ_INTERLACING */

void PNGAPI
png_set_progressive_read_fn(png_structrp png_ptr, png_voidp progressive_ptr,
    png_progressive_info_ptr info_fn, png_progressive_row_ptr row_fn,
    png_progressive_end_ptr end_fn)
{
   if (png_ptr == NULL)
      return;

   png_ptr->info_fn = info_fn;
   png_ptr->row_fn = row_fn;
   png_ptr->end_fn = end_fn;

   png_set_read_fn(png_ptr, progressive_ptr, png_push_fill_buffer);
}

png_voidp PNGAPI
png_get_progressive_ptr(png_const_structrp png_ptr)
{
   if (png_ptr == NULL)
      return (NULL);

   return png_ptr->io_ptr;
}
#endif /* PROGRESSIVE_READ */

```

`ThirdPartyBuild/PNG/Code/pngpriv.h`:

```h

/* pngpriv.h - private declarations for use inside libpng
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

/* The symbols declared in this file (including the functions declared
 * as extern) are PRIVATE.  They are not part of the libpng public
 * interface, and are not recommended for use by regular applications.
 * Some of them may become public in the future; others may stay private,
 * change in an incompatible way, or even disappear.
 * Although the libpng users are not forbidden to include this header,
 * they should be well aware of the issues that may arise from doing so.
 */

#ifndef PNGPRIV_H
#define PNGPRIV_H

/* Feature Test Macros.  The following are defined here to ensure that correctly
 * implemented libraries reveal the APIs libpng needs to build and hide those
 * that are not needed and potentially damaging to the compilation.
 *
 * Feature Test Macros must be defined before any system header is included (see
 * POSIX 1003.1 2.8.2 "POSIX Symbols."
 *
 * These macros only have an effect if the operating system supports either
 * POSIX 1003.1 or C99, or both.  On other operating systems (particularly
 * Windows/Visual Studio) there is no effect; the OS specific tests below are
 * still required (as of 2011-05-02.)
 */
#define _POSIX_SOURCE 1 /* Just the POSIX 1003.1 and C89 APIs */

#ifndef PNG_VERSION_INFO_ONLY
/* Standard library headers not required by png.h: */
#  include <stdlib.h>
#  include <string.h>
#endif

#define PNGLIB_BUILD /*libpng is being built, not used*/

/* If HAVE_CONFIG_H is defined during the build then the build system must
 * provide an appropriate "config.h" file on the include path.  The header file
 * must provide definitions as required below (search for "HAVE_CONFIG_H");
 * see configure.ac for more details of the requirements.  The macro
 * "PNG_NO_CONFIG_H" is provided for maintainers to test for dependencies on
 * 'configure'; define this macro to prevent the configure build including the
 * configure generated config.h.  Libpng is expected to compile without *any*
 * special build system support on a reasonably ANSI-C compliant system.
 */
#if defined(HAVE_CONFIG_H) && !defined(PNG_NO_CONFIG_H)
#  include <config.h>

   /* Pick up the definition of 'restrict' from config.h if it was read: */
#  define PNG_RESTRICT restrict
#endif

/* To support symbol prefixing it is necessary to know *before* including png.h
 * whether the fixed point (and maybe other) APIs are exported, because if they
 * are not internal definitions may be required.  This is handled below just
 * before png.h is included, but load the configuration now if it is available.
 */
#ifndef PNGLCONF_H
#  include "pnglibconf.h"
#endif

/* Local renames may change non-exported API functions from png.h */
#if defined(PNG_PREFIX) && !defined(PNGPREFIX_H)
#  include "pngprefix.h"
#endif

#ifdef PNG_USER_CONFIG
#  include "pngusr.h"
   /* These should have been defined in pngusr.h */
#  ifndef PNG_USER_PRIVATEBUILD
#    define PNG_USER_PRIVATEBUILD "Custom libpng build"
#  endif
#  ifndef PNG_USER_DLLFNAME_POSTFIX
#    define PNG_USER_DLLFNAME_POSTFIX "Cb"
#  endif
#endif

/* Compile time options.
 * =====================
 * In a multi-arch build the compiler may compile the code several times for the
 * same object module, producing different binaries for different architectures.
 * When this happens configure-time setting of the target host options cannot be
 * done and this interferes with the handling of the ARM NEON optimizations, and
 * possibly other similar optimizations.  Put additional tests here; in general
 * this is needed when the same option can be changed at both compile time and
 * run time depending on the target OS (i.e. iOS vs Android.)
 *
 * NOTE: symbol prefixing does not pass $(CFLAGS) to the preprocessor, because
 * this is not possible with certain compilers (Oracle SUN OS CC), as a result
 * it is necessary to ensure that all extern functions that *might* be used
 * regardless of $(CFLAGS) get declared in this file.  The test on __ARM_NEON__
 * below is one example of this behavior because it is controlled by the
 * presence or not of -mfpu=neon on the GCC command line, it is possible to do
 * this in $(CC), e.g. "CC=gcc -mfpu=neon", but people who build libpng rarely
 * do this.
 */
#ifndef PNG_ARM_NEON_OPT
   /* ARM NEON optimizations are being controlled by the compiler settings,
    * typically the target FPU.  If the FPU has been set to NEON (-mfpu=neon
    * with GCC) then the compiler will define __ARM_NEON__ and we can rely
    * unconditionally on NEON instructions not crashing, otherwise we must
    * disable use of NEON instructions.
    *
    * NOTE: at present these optimizations depend on 'ALIGNED_MEMORY', so they
    * can only be turned on automatically if that is supported too.  If
    * PNG_ARM_NEON_OPT is set in CPPFLAGS (to >0) then arm/arm_init.c will fail
    * to compile with an appropriate #error if ALIGNED_MEMORY has been turned
    * off.
    *
    * Note that gcc-4.9 defines __ARM_NEON instead of the deprecated
    * __ARM_NEON__, so we check both variants.
    *
    * To disable ARM_NEON optimizations entirely, and skip compiling the
    * associated assembler code, pass --enable-arm-neon=no to configure
    * or put -DPNG_ARM_NEON_OPT=0 in CPPFLAGS.
    */
#  if (defined(__ARM_NEON__) || defined(__ARM_NEON)) && \
   defined(PNG_ALIGNED_MEMORY_SUPPORTED)
#     define PNG_ARM_NEON_OPT 2
#  else
#     define PNG_ARM_NEON_OPT 0
#  endif
#endif

#if PNG_ARM_NEON_OPT > 0
   /* NEON optimizations are to be at least considered by libpng, so enable the
    * callbacks to do this.
    */
#  define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_neon

   /* By default the 'intrinsics' code in arm/filter_neon_intrinsics.c is used
    * if possible - if __ARM_NEON__ is set and the compiler version is not known
    * to be broken.  This is controlled by PNG_ARM_NEON_IMPLEMENTATION which can
    * be:
    *
    *    1  The intrinsics code (the default with __ARM_NEON__)
    *    2  The hand coded assembler (the default without __ARM_NEON__)
    *
    * It is possible to set PNG_ARM_NEON_IMPLEMENTATION in CPPFLAGS, however
    * this is *NOT* supported and may cease to work even after a minor revision
    * to libpng.  It *is* valid to do this for testing purposes, e.g. speed
    * testing or a new compiler, but the results should be communicated to the
    * libpng implementation list for incorporation in the next minor release.
    */
#  ifndef PNG_ARM_NEON_IMPLEMENTATION
#     if defined(__ARM_NEON__) || defined(__ARM_NEON)
#        if defined(__clang__)
            /* At present it is unknown by the libpng developers which versions
             * of clang support the intrinsics, however some or perhaps all
             * versions do not work with the assembler so this may be
             * irrelevant, so just use the default (do nothing here.)
             */
#        elif defined(__GNUC__)
            /* GCC 4.5.4 NEON support is known to be broken.  4.6.3 is known to
             * work, so if this *is* GCC, or G++, look for a version >4.5
             */
#           if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 6)
#              define PNG_ARM_NEON_IMPLEMENTATION 2
#           endif /* no GNUC support */
#        endif /* __GNUC__ */
#     else /* !defined __ARM_NEON__ */
         /* The 'intrinsics' code simply won't compile without this -mfpu=neon:
          */
#        define PNG_ARM_NEON_IMPLEMENTATION 2
#     endif /* __ARM_NEON__ */
#  endif /* !PNG_ARM_NEON_IMPLEMENTATION */

#  ifndef PNG_ARM_NEON_IMPLEMENTATION
      /* Use the intrinsics code by default. */
#     define PNG_ARM_NEON_IMPLEMENTATION 1
#  endif
#endif /* PNG_ARM_NEON_OPT > 0 */

#ifndef PNG_MIPS_MSA_OPT
#  if defined(__mips_msa) && (__mips_isa_rev >= 5) && defined(PNG_ALIGNED_MEMORY_SUPPORTED)
#     define PNG_MIPS_MSA_OPT 2
#  else
#     define PNG_MIPS_MSA_OPT 0
#  endif
#endif

#if PNG_MIPS_MSA_OPT > 0
#  define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_msa
#  ifndef PNG_MIPS_MSA_IMPLEMENTATION
#     if defined(__mips_msa)
#        if defined(__clang__)
#        elif defined(__GNUC__)
#           if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 7)
#              define PNG_MIPS_MSA_IMPLEMENTATION 2
#           endif /* no GNUC support */
#        endif /* __GNUC__ */
#     else /* !defined __mips_msa */
#        define PNG_MIPS_MSA_IMPLEMENTATION 2
#     endif /* __mips_msa */
#  endif /* !PNG_MIPS_MSA_IMPLEMENTATION */

#  ifndef PNG_MIPS_MSA_IMPLEMENTATION
#     define PNG_MIPS_MSA_IMPLEMENTATION 1
#  endif
#endif /* PNG_MIPS_MSA_OPT > 0 */


/* Is this a build of a DLL where compilation of the object modules requires
 * different preprocessor settings to those required for a simple library?  If
 * so PNG_BUILD_DLL must be set.
 *
 * If libpng is used inside a DLL but that DLL does not export the libpng APIs
 * PNG_BUILD_DLL must not be set.  To avoid the code below kicking in build a
 * static library of libpng then link the DLL against that.
 */
#ifndef PNG_BUILD_DLL
#  ifdef DLL_EXPORT
      /* This is set by libtool when files are compiled for a DLL; libtool
       * always compiles twice, even on systems where it isn't necessary.  Set
       * PNG_BUILD_DLL in case it is necessary:
       */
#     define PNG_BUILD_DLL
#  else
#     ifdef _WINDLL
         /* This is set by the Microsoft Visual Studio IDE in projects that
          * build a DLL.  It can't easily be removed from those projects (it
          * isn't visible in the Visual Studio UI) so it is a fairly reliable
          * indication that PNG_IMPEXP needs to be set to the DLL export
          * attributes.
          */
#        define PNG_BUILD_DLL
#     else
#        ifdef __DLL__
            /* This is set by the Borland C system when compiling for a DLL
             * (as above.)
             */
#           define PNG_BUILD_DLL
#        else
            /* Add additional compiler cases here. */
#        endif
#     endif
#  endif
#endif /* Setting PNG_BUILD_DLL if required */

/* See pngconf.h for more details: the builder of the library may set this on
 * the command line to the right thing for the specific compilation system or it
 * may be automagically set above (at present we know of no system where it does
 * need to be set on the command line.)
 *
 * PNG_IMPEXP must be set here when building the library to prevent pngconf.h
 * setting it to the "import" setting for a DLL build.
 */
#ifndef PNG_IMPEXP
#  ifdef PNG_BUILD_DLL
#     define PNG_IMPEXP PNG_DLL_EXPORT
#  else
      /* Not building a DLL, or the DLL doesn't require specific export
       * definitions.
       */
#     define PNG_IMPEXP
#  endif
#endif

/* No warnings for private or deprecated functions in the build: */
#ifndef PNG_DEPRECATED
#  define PNG_DEPRECATED
#endif
#ifndef PNG_PRIVATE
#  define PNG_PRIVATE
#endif

/* Symbol preprocessing support.
 *
 * To enable listing global, but internal, symbols the following macros should
 * always be used to declare an extern data or function object in this file.
 */
#ifndef PNG_INTERNAL_DATA
#  define PNG_INTERNAL_DATA(type, name, array) PNG_LINKAGE_DATA type name array
#endif

#ifndef PNG_INTERNAL_FUNCTION
#  define PNG_INTERNAL_FUNCTION(type, name, args, attributes)\
      PNG_LINKAGE_FUNCTION PNG_FUNCTION(type, name, args, PNG_EMPTY attributes)
#endif

#ifndef PNG_INTERNAL_CALLBACK
#  define PNG_INTERNAL_CALLBACK(type, name, args, attributes)\
      PNG_LINKAGE_CALLBACK PNG_FUNCTION(type, (PNGCBAPI name), args,\
         PNG_EMPTY attributes)
#endif

/* If floating or fixed point APIs are disabled they may still be compiled
 * internally.  To handle this make sure they are declared as the appropriate
 * internal extern function (otherwise the symbol prefixing stuff won't work and
 * the functions will be used without definitions.)
 *
 * NOTE: although all the API functions are declared here they are not all
 * actually built!  Because the declarations are still made it is necessary to
 * fake out types that they depend on.
 */
#ifndef PNG_FP_EXPORT
#  ifndef PNG_FLOATING_POINT_SUPPORTED
#     define PNG_FP_EXPORT(ordinal, type, name, args)\
         PNG_INTERNAL_FUNCTION(type, name, args, PNG_EMPTY);
#     ifndef PNG_VERSION_INFO_ONLY
         typedef struct png_incomplete png_double;
         typedef png_double*           png_doublep;
         typedef const png_double*     png_const_doublep;
         typedef png_double**          png_doublepp;
#     endif
#  endif
#endif
#ifndef PNG_FIXED_EXPORT
#  ifndef PNG_FIXED_POINT_SUPPORTED
#     define PNG_FIXED_EXPORT(ordinal, type, name, args)\
         PNG_INTERNAL_FUNCTION(type, name, args, PNG_EMPTY);
#  endif
#endif

#include "png.h"

/* pngconf.h does not set PNG_DLL_EXPORT unless it is required, so: */
#ifndef PNG_DLL_EXPORT
#  define PNG_DLL_EXPORT
#endif

/* This is a global switch to set the compilation for an installed system
 * (a release build).  It can be set for testing debug builds to ensure that
 * they will compile when the build type is switched to RC or STABLE, the
 * default is just to use PNG_LIBPNG_BUILD_BASE_TYPE.  Set this in CPPFLAGS
 * with either:
 *
 *   -DPNG_RELEASE_BUILD Turns on the release compile path
 *   -DPNG_RELEASE_BUILD=0 Turns it off
 * or in your pngusr.h with
 *   #define PNG_RELEASE_BUILD=1 Turns on the release compile path
 *   #define PNG_RELEASE_BUILD=0 Turns it off
 */
#ifndef PNG_RELEASE_BUILD
#  define PNG_RELEASE_BUILD (PNG_LIBPNG_BUILD_BASE_TYPE >= PNG_LIBPNG_BUILD_RC)
#endif

/* SECURITY and SAFETY:
 *
 * libpng is built with support for internal limits on image dimensions and
 * memory usage.  These are documented in scripts/pnglibconf.dfa of the
 * source and recorded in the machine generated header file pnglibconf.h.
 */

/* If you are running on a machine where you cannot allocate more
 * than 64K of memory at once, uncomment this.  While libpng will not
 * normally need that much memory in a chunk (unless you load up a very
 * large file), zlib needs to know how big of a chunk it can use, and
 * libpng thus makes sure to check any memory allocation to verify it
 * will fit into memory.
 *
 * zlib provides 'MAXSEG_64K' which, if defined, indicates the
 * same limit and pngconf.h (already included) sets the limit
 * if certain operating systems are detected.
 */
#if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)
#  define PNG_MAX_MALLOC_64K
#endif

#ifndef PNG_UNUSED
/* Unused formal parameter warnings are silenced using the following macro
 * which is expected to have no bad effects on performance (optimizing
 * compilers will probably remove it entirely).  Note that if you replace
 * it with something other than whitespace, you must include the terminating
 * semicolon.
 */
#  define PNG_UNUSED(param) (void)param;
#endif

/* Just a little check that someone hasn't tried to define something
 * contradictory.
 */
#if (PNG_ZBUF_SIZE > 65536L) && defined(PNG_MAX_MALLOC_64K)
#  undef PNG_ZBUF_SIZE
#  define PNG_ZBUF_SIZE 65536L
#endif

/* If warnings or errors are turned off the code is disabled or redirected here.
 * From 1.5.4 functions have been added to allow very limited formatting of
 * error and warning messages - this code will also be disabled here.
 */
#ifdef PNG_WARNINGS_SUPPORTED
#  define PNG_WARNING_PARAMETERS(p) png_warning_parameters p;
#else
#  define png_warning_parameter(p,number,string) ((void)0)
#  define png_warning_parameter_unsigned(p,number,format,value) ((void)0)
#  define png_warning_parameter_signed(p,number,format,value) ((void)0)
#  define png_formatted_warning(pp,p,message) ((void)(pp))
#  define PNG_WARNING_PARAMETERS(p)
#endif
#ifndef PNG_ERROR_TEXT_SUPPORTED
#  define png_fixed_error(s1,s2) png_err(s1)
#endif

/* C allows up-casts from (void*) to any pointer and (const void*) to any
 * pointer to a const object.  C++ regards this as a type error and requires an
 * explicit, static, cast and provides the static_cast<> rune to ensure that
 * const is not cast away.
 */
#ifdef __cplusplus
#  define png_voidcast(type, value) static_cast<type>(value)
#  define png_constcast(type, value) const_cast<type>(value)
#  define png_aligncast(type, value) \
   static_cast<type>(static_cast<void*>(value))
#  define png_aligncastconst(type, value) \
   static_cast<type>(static_cast<const void*>(value))
#else
#  define png_voidcast(type, value) (value)
#  define png_constcast(type, value) ((type)(value))
#  define png_aligncast(type, value) ((void*)(value))
#  define png_aligncastconst(type, value) ((const void*)(value))
#endif /* __cplusplus */

/* Some fixed point APIs are still required even if not exported because
 * they get used by the corresponding floating point APIs.  This magic
 * deals with this:
 */
#ifdef PNG_FIXED_POINT_SUPPORTED
#  define PNGFAPI PNGAPI
#else
#  define PNGFAPI /* PRIVATE */
#endif

#ifndef PNG_VERSION_INFO_ONLY
/* Other defines specific to compilers can go here.  Try to keep
 * them inside an appropriate ifdef/endif pair for portability.
 */
#if defined(PNG_FLOATING_POINT_SUPPORTED) ||\
    defined(PNG_FLOATING_ARITHMETIC_SUPPORTED)
   /* png.c requires the following ANSI-C constants if the conversion of
    * floating point to ASCII is implemented therein:
    *
    *  DBL_DIG  Maximum number of decimal digits (can be set to any constant)
    *  DBL_MIN  Smallest normalized fp number (can be set to an arbitrary value)
    *  DBL_MAX  Maximum floating point number (can be set to an arbitrary value)
    */
#  include <float.h>

#  if (defined(__MWERKS__) && defined(macintosh)) || defined(applec) || \
    defined(THINK_C) || defined(__SC__) || defined(TARGET_OS_MAC)
   /* We need to check that <math.h> hasn't already been included earlier
    * as it seems it doesn't agree with <fp.h>, yet we should really use
    * <fp.h> if possible.
    */
#    if !defined(__MATH_H__) && !defined(__MATH_H) && !defined(__cmath__)
#      include <fp.h>
#    endif
#  else
#    include <math.h>
#  endif
#  if defined(_AMIGA) && defined(__SASC) && defined(_M68881)
   /* Amiga SAS/C: We must include builtin FPU functions when compiling using
    * MATH=68881
    */
#    include <m68881.h>
#  endif
#endif

/* This provides the non-ANSI (far) memory allocation routines. */
#if defined(__TURBOC__) && defined(__MSDOS__)
#  include <mem.h>
#  include <alloc.h>
#endif

#if defined(WIN32) || defined(_Windows) || defined(_WINDOWS) || \
    defined(_WIN32) || defined(__WIN32__)
#  include <windows.h>  /* defines _WINDOWS_ macro */
#endif
#endif /* PNG_VERSION_INFO_ONLY */

/* Moved here around 1.5.0beta36 from pngconf.h */
/* Users may want to use these so they are not private.  Any library
 * functions that are passed far data must be model-independent.
 */

/* Memory model/platform independent fns */
#ifndef PNG_ABORT
#  ifdef _WINDOWS_
#    define PNG_ABORT() ExitProcess(0)
#  else
#    define PNG_ABORT() abort()
#  endif
#endif

/* These macros may need to be architecture dependent. */
#define PNG_ALIGN_NONE   0 /* do not use data alignment */
#define PNG_ALIGN_ALWAYS 1 /* assume unaligned accesses are OK */
#ifdef offsetof
#  define PNG_ALIGN_OFFSET 2 /* use offsetof to determine alignment */
#else
#  define PNG_ALIGN_OFFSET -1 /* prevent the use of this */
#endif
#define PNG_ALIGN_SIZE   3 /* use sizeof to determine alignment */

#ifndef PNG_ALIGN_TYPE
   /* Default to using aligned access optimizations and requiring alignment to a
    * multiple of the data type size.  Override in a compiler specific fashion
    * if necessary by inserting tests here:
    */
#  define PNG_ALIGN_TYPE PNG_ALIGN_SIZE
#endif

#if PNG_ALIGN_TYPE == PNG_ALIGN_SIZE
   /* This is used because in some compiler implementations non-aligned
    * structure members are supported, so the offsetof approach below fails.
    * Set PNG_ALIGN_SIZE=0 for compiler combinations where unaligned access
    * is good for performance.  Do not do this unless you have tested the result
    * and understand it.
    */
#  define png_alignof(type) (sizeof (type))
#else
#  if PNG_ALIGN_TYPE == PNG_ALIGN_OFFSET
#     define png_alignof(type) offsetof(struct{char c; type t;}, t)
#  else
#     if PNG_ALIGN_TYPE == PNG_ALIGN_ALWAYS
#        define png_alignof(type) (1)
#     endif
      /* Else leave png_alignof undefined to prevent use thereof */
#  endif
#endif

/* This implicitly assumes alignment is always to a power of 2. */
#ifdef png_alignof
#  define png_isaligned(ptr, type)\
   (((type)((const char*)ptr-(const char*)0) & \
   (type)(png_alignof(type)-1)) == 0)
#else
#  define png_isaligned(ptr, type) 0
#endif

/* End of memory model/platform independent support */
/* End of 1.5.0beta36 move from pngconf.h */

/* CONSTANTS and UTILITY MACROS
 * These are used internally by libpng and not exposed in the API
 */

/* Various modes of operation.  Note that after an init, mode is set to
 * zero automatically when the structure is created.  Three of these
 * are defined in png.h because they need to be visible to applications
 * that call png_set_unknown_chunk().
 */
/* #define PNG_HAVE_IHDR            0x01U (defined in png.h) */
/* #define PNG_HAVE_PLTE            0x02U (defined in png.h) */
#define PNG_HAVE_IDAT               0x04U
/* #define PNG_AFTER_IDAT           0x08U (defined in png.h) */
#define PNG_HAVE_IEND               0x10U
                   /*               0x20U (unused) */
                   /*               0x40U (unused) */
                   /*               0x80U (unused) */
#define PNG_HAVE_CHUNK_HEADER      0x100U
#define PNG_WROTE_tIME             0x200U
#define PNG_WROTE_INFO_BEFORE_PLTE 0x400U
#define PNG_BACKGROUND_IS_GRAY     0x800U
#define PNG_HAVE_PNG_SIGNATURE    0x1000U
#define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000U /* Have another chunk after IDAT */
                   /*             0x4000U (unused) */
#define PNG_IS_READ_STRUCT        0x8000U /* Else is a write struct */

/* Flags for the transformations the PNG library does on the image data */
#define PNG_BGR                 0x0001U
#define PNG_INTERLACE           0x0002U
#define PNG_PACK                0x0004U
#define PNG_SHIFT               0x0008U
#define PNG_SWAP_BYTES          0x0010U
#define PNG_INVERT_MONO         0x0020U
#define PNG_QUANTIZE            0x0040U
#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
#define PNG_BACKGROUND_EXPAND   0x0100U
#define PNG_EXPAND_16           0x0200U    /* Added to libpng 1.5.2 */
#define PNG_16_TO_8             0x0400U    /* Becomes 'chop' in 1.5.4 */
#define PNG_RGBA                0x0800U
#define PNG_EXPAND              0x1000U
#define PNG_GAMMA               0x2000U
#define PNG_GRAY_TO_RGB         0x4000U
#define PNG_FILLER              0x8000U
#define PNG_PACKSWAP           0x10000U
#define PNG_SWAP_ALPHA         0x20000U
#define PNG_STRIP_ALPHA        0x40000U
#define PNG_INVERT_ALPHA       0x80000U
#define PNG_USER_TRANSFORM    0x100000U
#define PNG_RGB_TO_GRAY_ERR   0x200000U
#define PNG_RGB_TO_GRAY_WARN  0x400000U
#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
#define PNG_ADD_ALPHA        0x1000000U /* Added to libpng-1.2.7 */
#define PNG_EXPAND_tRNS      0x2000000U /* Added to libpng-1.2.9 */
#define PNG_SCALE_16_TO_8    0x4000000U /* Added to libpng-1.5.4 */
                       /*    0x8000000U unused */
                       /*   0x10000000U unused */
                       /*   0x20000000U unused */
                       /*   0x40000000U unused */
/* Flags for png_create_struct */
#define PNG_STRUCT_PNG   0x0001U
#define PNG_STRUCT_INFO  0x0002U

/* Flags for the png_ptr->flags rather than declaring a byte for each one */
#define PNG_FLAG_ZLIB_CUSTOM_STRATEGY     0x0001U
#define PNG_FLAG_ZSTREAM_INITIALIZED      0x0002U /* Added to libpng-1.6.0 */
                                  /*      0x0004U    unused */
#define PNG_FLAG_ZSTREAM_ENDED            0x0008U /* Added to libpng-1.6.0 */
                                  /*      0x0010U    unused */
                                  /*      0x0020U    unused */
#define PNG_FLAG_ROW_INIT                 0x0040U
#define PNG_FLAG_FILLER_AFTER             0x0080U
#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
#define PNG_FLAG_CRC_CRITICAL_USE         0x0400U
#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800U
#define PNG_FLAG_ASSUME_sRGB              0x1000U /* Added to libpng-1.5.4 */
#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000U /* Added to libpng-1.5.4 */
#define PNG_FLAG_DETECT_UNINITIALIZED     0x4000U /* Added to libpng-1.5.4 */
/* #define PNG_FLAG_KEEP_UNKNOWN_CHUNKS      0x8000U */
/* #define PNG_FLAG_KEEP_UNSAFE_CHUNKS      0x10000U */
#define PNG_FLAG_LIBRARY_MISMATCH        0x20000U
#define PNG_FLAG_STRIP_ERROR_NUMBERS     0x40000U
#define PNG_FLAG_STRIP_ERROR_TEXT        0x80000U
#define PNG_FLAG_BENIGN_ERRORS_WARN     0x100000U /* Added to libpng-1.4.0 */
#define PNG_FLAG_APP_WARNINGS_WARN      0x200000U /* Added to libpng-1.6.0 */
#define PNG_FLAG_APP_ERRORS_WARN        0x400000U /* Added to libpng-1.6.0 */
                                  /*    0x800000U    unused */
                                  /*   0x1000000U    unused */
                                  /*   0x2000000U    unused */
                                  /*   0x4000000U    unused */
                                  /*   0x8000000U    unused */
                                  /*  0x10000000U    unused */
                                  /*  0x20000000U    unused */
                                  /*  0x40000000U    unused */

#define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
                                     PNG_FLAG_CRC_ANCILLARY_NOWARN)

#define PNG_FLAG_CRC_CRITICAL_MASK  (PNG_FLAG_CRC_CRITICAL_USE | \
                                     PNG_FLAG_CRC_CRITICAL_IGNORE)

#define PNG_FLAG_CRC_MASK           (PNG_FLAG_CRC_ANCILLARY_MASK | \
                                     PNG_FLAG_CRC_CRITICAL_MASK)

/* Save typing and make code easier to understand */

#define PNG_COLOR_DIST(c1, c2) (abs((int)((c1).red) - (int)((c2).red)) + \
   abs((int)((c1).green) - (int)((c2).green)) + \
   abs((int)((c1).blue) - (int)((c2).blue)))

/* Added to libpng-1.6.0: scale a 16-bit value in the range 0..65535 to 0..255
 * by dividing by 257 *with rounding*.  This macro is exact for the given range.
 * See the discourse in pngrtran.c png_do_scale_16_to_8.  The values in the
 * macro were established by experiment (modifying the added value).  The macro
 * has a second variant that takes a value already scaled by 255 and divides by
 * 65535 - this has a maximum error of .502.  Over the range 0..65535*65535 it
 * only gives off-by-one errors and only for 0.5% (1 in 200) of the values.
 */
#define PNG_DIV65535(v24) (((v24) + 32895) >> 16)
#define PNG_DIV257(v16) PNG_DIV65535((png_uint_32)(v16) * 255)

/* Added to libpng-1.2.6 JB */
#define PNG_ROWBYTES(pixel_bits, width) \
    ((pixel_bits) >= 8 ? \
    ((png_size_t)(width) * (((png_size_t)(pixel_bits)) >> 3)) : \
    (( ((png_size_t)(width) * ((png_size_t)(pixel_bits))) + 7) >> 3) )

/* This returns the number of trailing bits in the last byte of a row, 0 if the
 * last byte is completely full of pixels.  It is, in principle, (pixel_bits x
 * width) % 8, but that would overflow for large 'width'.  The second macro is
 * the same except that it returns the number of unused bits in the last byte;
 * (8-TRAILBITS), but 0 when TRAILBITS is 0.
 *
 * NOTE: these macros are intended to be self-evidently correct and never
 * overflow on the assumption that pixel_bits is in the range 0..255.  The
 * arguments are evaluated only once and they can be signed (e.g. as a result of
 * the integral promotions).  The result of the expression always has type
 * (png_uint_32), however the compiler always knows it is in the range 0..7.
 */
#define PNG_TRAILBITS(pixel_bits, width) \
    (((pixel_bits) * ((width) % (png_uint_32)8)) % 8)

#define PNG_PADBITS(pixel_bits, width) \
    ((8 - PNG_TRAILBITS(pixel_bits, width)) % 8)

/* PNG_OUT_OF_RANGE returns true if value is outside the range
 * ideal-delta..ideal+delta.  Each argument is evaluated twice.
 * "ideal" and "delta" should be constants, normally simple
 * integers, "value" a variable. Added to libpng-1.2.6 JB
 */
#define PNG_OUT_OF_RANGE(value, ideal, delta) \
   ( (value) < (ideal)-(delta) || (value) > (ideal)+(delta) )

/* Conversions between fixed and floating point, only defined if
 * required (to make sure the code doesn't accidentally use float
 * when it is supposedly disabled.)
 */
#ifdef PNG_FLOATING_POINT_SUPPORTED
/* The floating point conversion can't overflow, though it can and
 * does lose accuracy relative to the original fixed point value.
 * In practice this doesn't matter because png_fixed_point only
 * stores numbers with very low precision.  The png_ptr and s
 * arguments are unused by default but are there in case error
 * checking becomes a requirement.
 */
#define png_float(png_ptr, fixed, s) (.00001 * (fixed))

/* The fixed point conversion performs range checking and evaluates
 * its argument multiple times, so must be used with care.  The
 * range checking uses the PNG specification values for a signed
 * 32-bit fixed point value except that the values are deliberately
 * rounded-to-zero to an integral value - 21474 (21474.83 is roughly
 * (2^31-1) * 100000). 's' is a string that describes the value being
 * converted.
 *
 * NOTE: this macro will raise a png_error if the range check fails,
 * therefore it is normally only appropriate to use this on values
 * that come from API calls or other sources where an out of range
 * error indicates a programming error, not a data error!
 *
 * NOTE: by default this is off - the macro is not used - because the
 * function call saves a lot of code.
 */
#ifdef PNG_FIXED_POINT_MACRO_SUPPORTED
#define png_fixed(png_ptr, fp, s) ((fp) <= 21474 && (fp) >= -21474 ?\
    ((png_fixed_point)(100000 * (fp))) : (png_fixed_error(png_ptr, s),0))
#endif
/* else the corresponding function is defined below, inside the scope of the
 * cplusplus test.
 */
#endif

/* Constants for known chunk types.  If you need to add a chunk, define the name
 * here.  For historical reasons these constants have the form png_<name>; i.e.
 * the prefix is lower case.  Please use decimal values as the parameters to
 * match the ISO PNG specification and to avoid relying on the C locale
 * interpretation of character values.
 *
 * Prior to 1.5.6 these constants were strings, as of 1.5.6 png_uint_32 values
 * are computed and a new macro (PNG_STRING_FROM_CHUNK) added to allow a string
 * to be generated if required.
 *
 * PNG_32b correctly produces a value shifted by up to 24 bits, even on
 * architectures where (int) is only 16 bits.
 */
#define PNG_32b(b,s) ((png_uint_32)(b) << (s))
#define PNG_U32(b1,b2,b3,b4) \
   (PNG_32b(b1,24) | PNG_32b(b2,16) | PNG_32b(b3,8) | PNG_32b(b4,0))

/* Constants for known chunk types.
 *
 * MAINTAINERS: If you need to add a chunk, define the name here.
 * For historical reasons these constants have the form png_<name>; i.e.
 * the prefix is lower case.  Please use decimal values as the parameters to
 * match the ISO PNG specification and to avoid relying on the C locale
 * interpretation of character values.  Please keep the list sorted.
 *
 * Notice that PNG_U32 is used to define a 32-bit value for the 4 byte chunk
 * type.  In fact the specification does not express chunk types this way,
 * however using a 32-bit value means that the chunk type can be read from the
 * stream using exactly the same code as used for a 32-bit unsigned value and
 * can be examined far more efficiently (using one arithmetic compare).
 *
 * Prior to 1.5.6 the chunk type constants were expressed as C strings.  The
 * libpng API still uses strings for 'unknown' chunks and a macro,
 * PNG_STRING_FROM_CHUNK, allows a string to be generated if required.  Notice
 * that for portable code numeric values must still be used; the string "IHDR"
 * is not portable and neither is PNG_U32('I', 'H', 'D', 'R').
 *
 * In 1.7.0 the definitions will be made public in png.h to avoid having to
 * duplicate the same definitions in application code.
 */
#define png_IDAT PNG_U32( 73,  68,  65,  84)
#define png_IEND PNG_U32( 73,  69,  78,  68)
#define png_IHDR PNG_U32( 73,  72,  68,  82)
#define png_PLTE PNG_U32( 80,  76,  84,  69)
#define png_bKGD PNG_U32( 98,  75,  71,  68)
#define png_cHRM PNG_U32( 99,  72,  82,  77)
#define png_fRAc PNG_U32(102,  82,  65,  99) /* registered, not defined */
#define png_gAMA PNG_U32(103,  65,  77,  65)
#define png_gIFg PNG_U32(103,  73,  70, 103)
#define png_gIFt PNG_U32(103,  73,  70, 116) /* deprecated */
#define png_gIFx PNG_U32(103,  73,  70, 120)
#define png_hIST PNG_U32(104,  73,  83,  84)
#define png_iCCP PNG_U32(105,  67,  67,  80)
#define png_iTXt PNG_U32(105,  84,  88, 116)
#define png_oFFs PNG_U32(111,  70,  70, 115)
#define png_pCAL PNG_U32(112,  67,  65,  76)
#define png_pHYs PNG_U32(112,  72,  89, 115)
#define png_sBIT PNG_U32(115,  66,  73,  84)
#define png_sCAL PNG_U32(115,  67,  65,  76)
#define png_sPLT PNG_U32(115,  80,  76,  84)
#define png_sRGB PNG_U32(115,  82,  71,  66)
#define png_sTER PNG_U32(115,  84,  69,  82)
#define png_tEXt PNG_U32(116,  69,  88, 116)
#define png_tIME PNG_U32(116,  73,  77,  69)
#define png_tRNS PNG_U32(116,  82,  78,  83)
#define png_zTXt PNG_U32(122,  84,  88, 116)

/* The following will work on (signed char*) strings, whereas the get_uint_32
 * macro will fail on top-bit-set values because of the sign extension.
 */
#define PNG_CHUNK_FROM_STRING(s)\
   PNG_U32(0xff & (s)[0], 0xff & (s)[1], 0xff & (s)[2], 0xff & (s)[3])

/* This uses (char), not (png_byte) to avoid warnings on systems where (char) is
 * signed and the argument is a (char[])  This macro will fail miserably on
 * systems where (char) is more than 8 bits.
 */
#define PNG_STRING_FROM_CHUNK(s,c)\
   (void)(((char*)(s))[0]=(char)(((c)>>24) & 0xff), \
   ((char*)(s))[1]=(char)(((c)>>16) & 0xff),\
   ((char*)(s))[2]=(char)(((c)>>8) & 0xff), \
   ((char*)(s))[3]=(char)((c & 0xff)))

/* Do the same but terminate with a null character. */
#define PNG_CSTRING_FROM_CHUNK(s,c)\
   (void)(PNG_STRING_FROM_CHUNK(s,c), ((char*)(s))[4] = 0)

/* Test on flag values as defined in the spec (section 5.4): */
#define PNG_CHUNK_ANCILLARY(c)   (1 & ((c) >> 29))
#define PNG_CHUNK_CRITICAL(c)     (!PNG_CHUNK_ANCILLARY(c))
#define PNG_CHUNK_PRIVATE(c)      (1 & ((c) >> 21))
#define PNG_CHUNK_RESERVED(c)     (1 & ((c) >> 13))
#define PNG_CHUNK_SAFE_TO_COPY(c) (1 & ((c) >>  5))

/* Gamma values (new at libpng-1.5.4): */
#define PNG_GAMMA_MAC_OLD 151724  /* Assume '1.8' is really 2.2/1.45! */
#define PNG_GAMMA_MAC_INVERSE 65909
#define PNG_GAMMA_sRGB_INVERSE 45455

/* Almost everything below is C specific; the #defines above can be used in
 * non-C code (so long as it is C-preprocessed) the rest of this stuff cannot.
 */
#ifndef PNG_VERSION_INFO_ONLY

#include "pngstruct.h"
#include "pnginfo.h"

/* Validate the include paths - the include path used to generate pnglibconf.h
 * must match that used in the build, or we must be using pnglibconf.h.prebuilt:
 */
#if PNG_ZLIB_VERNUM != 0 && PNG_ZLIB_VERNUM != ZLIB_VERNUM
#  error ZLIB_VERNUM != PNG_ZLIB_VERNUM \
      "-I (include path) error: see the notes in pngpriv.h"
   /* This means that when pnglibconf.h was built the copy of zlib.h that it
    * used is not the same as the one being used here.  Because the build of
    * libpng makes decisions to use inflateInit2 and inflateReset2 based on the
    * zlib version number and because this affects handling of certain broken
    * PNG files the -I directives must match.
    *
    * The most likely explanation is that you passed a -I in CFLAGS. This will
    * not work; all the preprocessor directories and in particular all the -I
    * directives must be in CPPFLAGS.
    */
#endif

/* This is used for 16-bit gamma tables -- only the top level pointers are
 * const; this could be changed:
 */
typedef const png_uint_16p * png_const_uint_16pp;

/* Added to libpng-1.5.7: sRGB conversion tables */
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\
   defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)
#ifdef PNG_SIMPLIFIED_READ_SUPPORTED
PNG_INTERNAL_DATA(const png_uint_16, png_sRGB_table, [256]);
   /* Convert from an sRGB encoded value 0..255 to a 16-bit linear value,
    * 0..65535.  This table gives the closest 16-bit answers (no errors).
    */
#endif

PNG_INTERNAL_DATA(const png_uint_16, png_sRGB_base, [512]);
PNG_INTERNAL_DATA(const png_byte, png_sRGB_delta, [512]);

#define PNG_sRGB_FROM_LINEAR(linear) \
  ((png_byte)(0xff & ((png_sRGB_base[(linear)>>15] \
   + ((((linear) & 0x7fff)*png_sRGB_delta[(linear)>>15])>>12)) >> 8)))
   /* Given a value 'linear' in the range 0..255*65535 calculate the 8-bit sRGB
    * encoded value with maximum error 0.646365.  Note that the input is not a
    * 16-bit value; it has been multiplied by 255! */
#endif /* SIMPLIFIED_READ/WRITE */


/* Inhibit C++ name-mangling for libpng functions but not for system calls. */
#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* Internal functions; these are not exported from a DLL however because they
 * are used within several of the C source files they have to be C extern.
 *
 * All of these functions must be declared with PNG_INTERNAL_FUNCTION.
 */

/* Zlib support */
#define PNG_UNEXPECTED_ZLIB_RETURN (-7)
PNG_INTERNAL_FUNCTION(void, png_zstream_error,(png_structrp png_ptr, int ret),
   PNG_EMPTY);
   /* Used by the zlib handling functions to ensure that z_stream::msg is always
    * set before they return.
    */

#ifdef PNG_WRITE_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_free_buffer_list,(png_structrp png_ptr,
   png_compression_bufferp *list),PNG_EMPTY);
   /* Free the buffer list used by the compressed write code. */
#endif

#if defined(PNG_FLOATING_POINT_SUPPORTED) && \
   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \
   (defined(PNG_gAMA_SUPPORTED) || defined(PNG_cHRM_SUPPORTED) || \
   defined(PNG_sCAL_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) || \
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)) || \
   (defined(PNG_sCAL_SUPPORTED) && \
   defined(PNG_FLOATING_ARITHMETIC_SUPPORTED))
PNG_INTERNAL_FUNCTION(png_fixed_point,png_fixed,(png_const_structrp png_ptr,
   double fp, png_const_charp text),PNG_EMPTY);
#endif

/* Check the user version string for compatibility, returns false if the version
 * numbers aren't compatible.
 */
PNG_INTERNAL_FUNCTION(int,png_user_version_check,(png_structrp png_ptr,
   png_const_charp user_png_ver),PNG_EMPTY);

/* Internal base allocator - no messages, NULL on failure to allocate.  This
 * does, however, call the application provided allocator and that could call
 * png_error (although that would be a bug in the application implementation.)
 */
PNG_INTERNAL_FUNCTION(png_voidp,png_malloc_base,(png_const_structrp png_ptr,
   png_alloc_size_t size),PNG_ALLOCATED);

#if defined(PNG_TEXT_SUPPORTED) || defined(PNG_sPLT_SUPPORTED) ||\
   defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED)
/* Internal array allocator, outputs no error or warning messages on failure,
 * just returns NULL.
 */
PNG_INTERNAL_FUNCTION(png_voidp,png_malloc_array,(png_const_structrp png_ptr,
   int nelements, size_t element_size),PNG_ALLOCATED);

/* The same but an existing array is extended by add_elements.  This function
 * also memsets the new elements to 0 and copies the old elements.  The old
 * array is not freed or altered.
 */
PNG_INTERNAL_FUNCTION(png_voidp,png_realloc_array,(png_const_structrp png_ptr,
   png_const_voidp array, int old_elements, int add_elements,
   size_t element_size),PNG_ALLOCATED);
#endif /* text, sPLT or unknown chunks */

/* Magic to create a struct when there is no struct to call the user supplied
 * memory allocators.  Because error handling has not been set up the memory
 * handlers can't safely call png_error, but this is an obscure and undocumented
 * restriction so libpng has to assume that the 'free' handler, at least, might
 * call png_error.
 */
PNG_INTERNAL_FUNCTION(png_structp,png_create_png_struct,
   (png_const_charp user_png_ver, png_voidp error_ptr, png_error_ptr error_fn,
    png_error_ptr warn_fn, png_voidp mem_ptr, png_malloc_ptr malloc_fn,
    png_free_ptr free_fn),PNG_ALLOCATED);

/* Free memory from internal libpng struct */
PNG_INTERNAL_FUNCTION(void,png_destroy_png_struct,(png_structrp png_ptr),
   PNG_EMPTY);

/* Free an allocated jmp_buf (always succeeds) */
PNG_INTERNAL_FUNCTION(void,png_free_jmpbuf,(png_structrp png_ptr),PNG_EMPTY);

/* Function to allocate memory for zlib.  PNGAPI is disallowed. */
PNG_INTERNAL_FUNCTION(voidpf,png_zalloc,(voidpf png_ptr, uInt items, uInt size),
   PNG_ALLOCATED);

/* Function to free memory for zlib.  PNGAPI is disallowed. */
PNG_INTERNAL_FUNCTION(void,png_zfree,(voidpf png_ptr, voidpf ptr),PNG_EMPTY);

/* Next four functions are used internally as callbacks.  PNGCBAPI is required
 * but not PNG_EXPORT.  PNGAPI added at libpng version 1.2.3, changed to
 * PNGCBAPI at 1.5.0
 */

PNG_INTERNAL_FUNCTION(void PNGCBAPI,png_default_read_data,(png_structp png_ptr,
    png_bytep data, png_size_t length),PNG_EMPTY);

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
PNG_INTERNAL_FUNCTION(void PNGCBAPI,png_push_fill_buffer,(png_structp png_ptr,
    png_bytep buffer, png_size_t length),PNG_EMPTY);
#endif

PNG_INTERNAL_FUNCTION(void PNGCBAPI,png_default_write_data,(png_structp png_ptr,
    png_bytep data, png_size_t length),PNG_EMPTY);

#ifdef PNG_WRITE_FLUSH_SUPPORTED
#  ifdef PNG_STDIO_SUPPORTED
PNG_INTERNAL_FUNCTION(void PNGCBAPI,png_default_flush,(png_structp png_ptr),
   PNG_EMPTY);
#  endif
#endif

/* Reset the CRC variable */
PNG_INTERNAL_FUNCTION(void,png_reset_crc,(png_structrp png_ptr),PNG_EMPTY);

/* Write the "data" buffer to whatever output you are using */
PNG_INTERNAL_FUNCTION(void,png_write_data,(png_structrp png_ptr,
    png_const_bytep data, png_size_t length),PNG_EMPTY);

/* Read and check the PNG file signature */
PNG_INTERNAL_FUNCTION(void,png_read_sig,(png_structrp png_ptr,
   png_inforp info_ptr),PNG_EMPTY);

/* Read the chunk header (length + type name) */
PNG_INTERNAL_FUNCTION(png_uint_32,png_read_chunk_header,(png_structrp png_ptr),
   PNG_EMPTY);

/* Read data from whatever input you are using into the "data" buffer */
PNG_INTERNAL_FUNCTION(void,png_read_data,(png_structrp png_ptr, png_bytep data,
    png_size_t length),PNG_EMPTY);

/* Read bytes into buf, and update png_ptr->crc */
PNG_INTERNAL_FUNCTION(void,png_crc_read,(png_structrp png_ptr, png_bytep buf,
    png_uint_32 length),PNG_EMPTY);

/* Read "skip" bytes, read the file crc, and (optionally) verify png_ptr->crc */
PNG_INTERNAL_FUNCTION(int,png_crc_finish,(png_structrp png_ptr,
   png_uint_32 skip),PNG_EMPTY);

/* Read the CRC from the file and compare it to the libpng calculated CRC */
PNG_INTERNAL_FUNCTION(int,png_crc_error,(png_structrp png_ptr),PNG_EMPTY);

/* Calculate the CRC over a section of data.  Note that we are only
 * passing a maximum of 64K on systems that have this as a memory limit,
 * since this is the maximum buffer size we can specify.
 */
PNG_INTERNAL_FUNCTION(void,png_calculate_crc,(png_structrp png_ptr,
   png_const_bytep ptr, png_size_t length),PNG_EMPTY);

#ifdef PNG_WRITE_FLUSH_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_flush,(png_structrp png_ptr),PNG_EMPTY);
#endif

/* Write various chunks */

/* Write the IHDR chunk, and update the png_struct with the necessary
 * information.
 */
PNG_INTERNAL_FUNCTION(void,png_write_IHDR,(png_structrp png_ptr,
   png_uint_32 width, png_uint_32 height, int bit_depth, int color_type,
   int compression_method, int filter_method, int interlace_method),PNG_EMPTY);

PNG_INTERNAL_FUNCTION(void,png_write_PLTE,(png_structrp png_ptr,
   png_const_colorp palette, png_uint_32 num_pal),PNG_EMPTY);

PNG_INTERNAL_FUNCTION(void,png_compress_IDAT,(png_structrp png_ptr,
   png_const_bytep row_data, png_alloc_size_t row_data_length, int flush),
   PNG_EMPTY);

PNG_INTERNAL_FUNCTION(void,png_write_IEND,(png_structrp png_ptr),PNG_EMPTY);

#ifdef PNG_WRITE_gAMA_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_gAMA_fixed,(png_structrp png_ptr,
    png_fixed_point file_gamma),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_sBIT_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_sBIT,(png_structrp png_ptr,
    png_const_color_8p sbit, int color_type),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_cHRM_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_cHRM_fixed,(png_structrp png_ptr,
    const png_xy *xy), PNG_EMPTY);
   /* The xy value must have been previously validated */
#endif

#ifdef PNG_WRITE_sRGB_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_sRGB,(png_structrp png_ptr,
    int intent),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_iCCP_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_iCCP,(png_structrp png_ptr,
   png_const_charp name, png_const_bytep profile), PNG_EMPTY);
   /* The profile must have been previously validated for correctness, the
    * length comes from the first four bytes.  Only the base, deflate,
    * compression is supported.
    */
#endif

#ifdef PNG_WRITE_sPLT_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_sPLT,(png_structrp png_ptr,
    png_const_sPLT_tp palette),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_tRNS_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_tRNS,(png_structrp png_ptr,
    png_const_bytep trans, png_const_color_16p values, int number,
    int color_type),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_bKGD_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_bKGD,(png_structrp png_ptr,
    png_const_color_16p values, int color_type),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_hIST_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_hIST,(png_structrp png_ptr,
    png_const_uint_16p hist, int num_hist),PNG_EMPTY);
#endif

/* Chunks that have keywords */
#ifdef PNG_WRITE_tEXt_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_tEXt,(png_structrp png_ptr,
   png_const_charp key, png_const_charp text, png_size_t text_len),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_zTXt_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_zTXt,(png_structrp png_ptr, png_const_charp
    key, png_const_charp text, int compression),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_iTXt_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_iTXt,(png_structrp png_ptr,
    int compression, png_const_charp key, png_const_charp lang,
    png_const_charp lang_key, png_const_charp text),PNG_EMPTY);
#endif

#ifdef PNG_TEXT_SUPPORTED  /* Added at version 1.0.14 and 1.2.4 */
PNG_INTERNAL_FUNCTION(int,png_set_text_2,(png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_textp text_ptr, int num_text),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_oFFs_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_oFFs,(png_structrp png_ptr,
    png_int_32 x_offset, png_int_32 y_offset, int unit_type),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_pCAL_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_pCAL,(png_structrp png_ptr,
    png_charp purpose, png_int_32 X0, png_int_32 X1, int type, int nparams,
    png_const_charp units, png_charpp params),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_pHYs_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_pHYs,(png_structrp png_ptr,
    png_uint_32 x_pixels_per_unit, png_uint_32 y_pixels_per_unit,
    int unit_type),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_tIME_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_tIME,(png_structrp png_ptr,
    png_const_timep mod_time),PNG_EMPTY);
#endif

#ifdef PNG_WRITE_sCAL_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_write_sCAL_s,(png_structrp png_ptr,
    int unit, png_const_charp width, png_const_charp height),PNG_EMPTY);
#endif

/* Called when finished processing a row of data */
PNG_INTERNAL_FUNCTION(void,png_write_finish_row,(png_structrp png_ptr),
    PNG_EMPTY);

/* Internal use only.   Called before first row of data */
PNG_INTERNAL_FUNCTION(void,png_write_start_row,(png_structrp png_ptr),
    PNG_EMPTY);

/* Combine a row of data, dealing with alpha, etc. if requested.  'row' is an
 * array of png_ptr->width pixels.  If the image is not interlaced or this
 * is the final pass this just does a memcpy, otherwise the "display" flag
 * is used to determine whether to copy pixels that are not in the current pass.
 *
 * Because 'png_do_read_interlace' (below) replicates pixels this allows this
 * function to achieve the documented 'blocky' appearance during interlaced read
 * if display is 1 and the 'sparkle' appearance, where existing pixels in 'row'
 * are not changed if they are not in the current pass, when display is 0.
 *
 * 'display' must be 0 or 1, otherwise the memcpy will be done regardless.
 *
 * The API always reads from the png_struct row buffer and always assumes that
 * it is full width (png_do_read_interlace has already been called.)
 *
 * This function is only ever used to write to row buffers provided by the
 * caller of the relevant libpng API and the row must have already been
 * transformed by the read transformations.
 *
 * The PNG_USE_COMPILE_TIME_MASKS option causes generation of pre-computed
 * bitmasks for use within the code, otherwise runtime generated masks are used.
 * The default is compile time masks.
 */
#ifndef PNG_USE_COMPILE_TIME_MASKS
#  define PNG_USE_COMPILE_TIME_MASKS 1
#endif
PNG_INTERNAL_FUNCTION(void,png_combine_row,(png_const_structrp png_ptr,
    png_bytep row, int display),PNG_EMPTY);

#ifdef PNG_READ_INTERLACING_SUPPORTED
/* Expand an interlaced row: the 'row_info' describes the pass data that has
 * been read in and must correspond to the pixels in 'row', the pixels are
 * expanded (moved apart) in 'row' to match the final layout, when doing this
 * the pixels are *replicated* to the intervening space.  This is essential for
 * the correct operation of png_combine_row, above.
 */
PNG_INTERNAL_FUNCTION(void,png_do_read_interlace,(png_row_infop row_info,
    png_bytep row, int pass, png_uint_32 transformations),PNG_EMPTY);
#endif

/* GRR TO DO (2.0 or whenever):  simplify other internal calling interfaces */

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
/* Grab pixels out of a row for an interlaced pass */
PNG_INTERNAL_FUNCTION(void,png_do_write_interlace,(png_row_infop row_info,
    png_bytep row, int pass),PNG_EMPTY);
#endif

/* Unfilter a row: check the filter value before calling this, there is no point
 * calling it for PNG_FILTER_VALUE_NONE.
 */
PNG_INTERNAL_FUNCTION(void,png_read_filter_row,(png_structrp pp, png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row, int filter),PNG_EMPTY);

#if PNG_ARM_NEON_OPT > 0
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_up_neon,(png_row_infop row_info,
    png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub3_neon,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub4_neon,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg3_neon,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg4_neon,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth3_neon,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth4_neon,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
#endif

#if PNG_MIPS_MSA_OPT > 0
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_up_msa,(png_row_infop row_info,
    png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub3_msa,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub4_msa,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg3_msa,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg4_msa,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth3_msa,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth4_msa,(png_row_infop
    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
#endif

/* Choose the best filter to use and filter the row data */
PNG_INTERNAL_FUNCTION(void,png_write_find_filter,(png_structrp png_ptr,
    png_row_infop row_info),PNG_EMPTY);

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_read_IDAT_data,(png_structrp png_ptr,
   png_bytep output, png_alloc_size_t avail_out),PNG_EMPTY);
   /* Read 'avail_out' bytes of data from the IDAT stream.  If the output buffer
    * is NULL the function checks, instead, for the end of the stream.  In this
    * case a benign error will be issued if the stream end is not found or if
    * extra data has to be consumed.
    */
PNG_INTERNAL_FUNCTION(void,png_read_finish_IDAT,(png_structrp png_ptr),
   PNG_EMPTY);
   /* This cleans up when the IDAT LZ stream does not end when the last image
    * byte is read; there is still some pending input.
    */

PNG_INTERNAL_FUNCTION(void,png_read_finish_row,(png_structrp png_ptr),
   PNG_EMPTY);
   /* Finish a row while reading, dealing with interlacing passes, etc. */
#endif /* SEQUENTIAL_READ */

/* Initialize the row buffers, etc. */
PNG_INTERNAL_FUNCTION(void,png_read_start_row,(png_structrp png_ptr),PNG_EMPTY);

#if ZLIB_VERNUM >= 0x1240
PNG_INTERNAL_FUNCTION(int,png_zlib_inflate,(png_structrp png_ptr, int flush),
      PNG_EMPTY);
#  define PNG_INFLATE(pp, flush) png_zlib_inflate(pp, flush)
#else /* Zlib < 1.2.4 */
#  define PNG_INFLATE(pp, flush) inflate(&(pp)->zstream, flush)
#endif /* Zlib < 1.2.4 */

#ifdef PNG_READ_TRANSFORMS_SUPPORTED
/* Optional call to update the users info structure */
PNG_INTERNAL_FUNCTION(void,png_read_transform_info,(png_structrp png_ptr,
    png_inforp info_ptr),PNG_EMPTY);
#endif

/* Shared transform functions, defined in pngtran.c */
#if defined(PNG_WRITE_FILLER_SUPPORTED) || \
    defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
PNG_INTERNAL_FUNCTION(void,png_do_strip_channel,(png_row_infop row_info,
    png_bytep row, int at_start),PNG_EMPTY);
#endif

#ifdef PNG_16BIT_SUPPORTED
#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
PNG_INTERNAL_FUNCTION(void,png_do_swap,(png_row_infop row_info,
    png_bytep row),PNG_EMPTY);
#endif
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED) || \
    defined(PNG_WRITE_PACKSWAP_SUPPORTED)
PNG_INTERNAL_FUNCTION(void,png_do_packswap,(png_row_infop row_info,
    png_bytep row),PNG_EMPTY);
#endif

#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
PNG_INTERNAL_FUNCTION(void,png_do_invert,(png_row_infop row_info,
    png_bytep row),PNG_EMPTY);
#endif

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
PNG_INTERNAL_FUNCTION(void,png_do_bgr,(png_row_infop row_info,
    png_bytep row),PNG_EMPTY);
#endif

/* The following decodes the appropriate chunks, and does error correction,
 * then calls the appropriate callback for the chunk if it is valid.
 */

/* Decode the IHDR chunk */
PNG_INTERNAL_FUNCTION(void,png_handle_IHDR,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_handle_PLTE,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_handle_IEND,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);

#ifdef PNG_READ_bKGD_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_bKGD,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_cHRM_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_cHRM,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_gAMA_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_gAMA,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_hIST_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_hIST,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_iCCP_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_iCCP,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif /* READ_iCCP */

#ifdef PNG_READ_iTXt_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_iTXt,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_oFFs_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_oFFs,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_pCAL_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_pCAL,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_pHYs_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_pHYs,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_sBIT_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_sBIT,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_sCAL_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_sCAL,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_sPLT_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_sPLT,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif /* READ_sPLT */

#ifdef PNG_READ_sRGB_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_sRGB,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_tEXt_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_tEXt,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_tIME_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_tIME,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_tRNS_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_tRNS,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

#ifdef PNG_READ_zTXt_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_handle_zTXt,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
#endif

PNG_INTERNAL_FUNCTION(void,png_check_chunk_name,(png_structrp png_ptr,
    png_uint_32 chunk_name),PNG_EMPTY);

PNG_INTERNAL_FUNCTION(void,png_handle_unknown,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length, int keep),PNG_EMPTY);
   /* This is the function that gets called for unknown chunks.  The 'keep'
    * argument is either non-zero for a known chunk that has been set to be
    * handled as unknown or zero for an unknown chunk.  By default the function
    * just skips the chunk or errors out if it is critical.
    */

#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED) ||\
    defined(PNG_HANDLE_AS_UNKNOWN_SUPPORTED)
PNG_INTERNAL_FUNCTION(int,png_chunk_unknown_handling,
    (png_const_structrp png_ptr, png_uint_32 chunk_name),PNG_EMPTY);
   /* Exactly as the API png_handle_as_unknown() except that the argument is a
    * 32-bit chunk name, not a string.
    */
#endif /* READ_UNKNOWN_CHUNKS || HANDLE_AS_UNKNOWN */

/* Handle the transformations for reading and writing */
#ifdef PNG_READ_TRANSFORMS_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_do_read_transformations,(png_structrp png_ptr,
   png_row_infop row_info),PNG_EMPTY);
#endif
#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_do_write_transformations,(png_structrp png_ptr,
   png_row_infop row_info),PNG_EMPTY);
#endif

#ifdef PNG_READ_TRANSFORMS_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_init_read_transformations,(png_structrp png_ptr),
    PNG_EMPTY);
#endif

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_push_read_chunk,(png_structrp png_ptr,
    png_inforp info_ptr),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_read_sig,(png_structrp png_ptr,
    png_inforp info_ptr),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_check_crc,(png_structrp png_ptr),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_save_buffer,(png_structrp png_ptr),
    PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_restore_buffer,(png_structrp png_ptr,
    png_bytep buffer, png_size_t buffer_length),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_read_IDAT,(png_structrp png_ptr),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_process_IDAT_data,(png_structrp png_ptr,
    png_bytep buffer, png_size_t buffer_length),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_process_row,(png_structrp png_ptr),
    PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_handle_unknown,(png_structrp png_ptr,
   png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_have_info,(png_structrp png_ptr,
   png_inforp info_ptr),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_have_end,(png_structrp png_ptr,
   png_inforp info_ptr),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_have_row,(png_structrp png_ptr,
    png_bytep row),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_read_end,(png_structrp png_ptr,
    png_inforp info_ptr),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_process_some_data,(png_structrp png_ptr,
    png_inforp info_ptr),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_read_push_finish_row,(png_structrp png_ptr),
    PNG_EMPTY);
#  ifdef PNG_READ_tEXt_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_push_handle_tEXt,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_read_tEXt,(png_structrp png_ptr,
    png_inforp info_ptr),PNG_EMPTY);
#  endif
#  ifdef PNG_READ_zTXt_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_push_handle_zTXt,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_read_zTXt,(png_structrp png_ptr,
    png_inforp info_ptr),PNG_EMPTY);
#  endif
#  ifdef PNG_READ_iTXt_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_push_handle_iTXt,(png_structrp png_ptr,
    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_push_read_iTXt,(png_structrp png_ptr,
    png_inforp info_ptr),PNG_EMPTY);
#  endif

#endif /* PROGRESSIVE_READ */

/* Added at libpng version 1.6.0 */
#ifdef PNG_GAMMA_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_colorspace_set_gamma,(png_const_structrp png_ptr,
    png_colorspacerp colorspace, png_fixed_point gAMA), PNG_EMPTY);
   /* Set the colorspace gamma with a value provided by the application or by
    * the gAMA chunk on read.  The value will override anything set by an ICC
    * profile.
    */

PNG_INTERNAL_FUNCTION(void,png_colorspace_sync_info,(png_const_structrp png_ptr,
    png_inforp info_ptr), PNG_EMPTY);
   /* Synchronize the info 'valid' flags with the colorspace */

PNG_INTERNAL_FUNCTION(void,png_colorspace_sync,(png_const_structrp png_ptr,
    png_inforp info_ptr), PNG_EMPTY);
   /* Copy the png_struct colorspace to the info_struct and call the above to
    * synchronize the flags.  Checks for NULL info_ptr and does nothing.
    */
#endif

/* Added at libpng version 1.4.0 */
#ifdef PNG_COLORSPACE_SUPPORTED
/* These internal functions are for maintaining the colorspace structure within
 * a png_info or png_struct (or, indeed, both).
 */
PNG_INTERNAL_FUNCTION(int,png_colorspace_set_chromaticities,
   (png_const_structrp png_ptr, png_colorspacerp colorspace, const png_xy *xy,
    int preferred), PNG_EMPTY);

PNG_INTERNAL_FUNCTION(int,png_colorspace_set_endpoints,
   (png_const_structrp png_ptr, png_colorspacerp colorspace, const png_XYZ *XYZ,
    int preferred), PNG_EMPTY);

#ifdef PNG_sRGB_SUPPORTED
PNG_INTERNAL_FUNCTION(int,png_colorspace_set_sRGB,(png_const_structrp png_ptr,
   png_colorspacerp colorspace, int intent), PNG_EMPTY);
   /* This does set the colorspace gAMA and cHRM values too, but doesn't set the
    * flags to write them, if it returns false there was a problem and an error
    * message has already been output (but the colorspace may still need to be
    * synced to record the invalid flag).
    */
#endif /* sRGB */

#ifdef PNG_iCCP_SUPPORTED
PNG_INTERNAL_FUNCTION(int,png_colorspace_set_ICC,(png_const_structrp png_ptr,
   png_colorspacerp colorspace, png_const_charp name,
   png_uint_32 profile_length, png_const_bytep profile, int color_type),
   PNG_EMPTY);
   /* The 'name' is used for information only */

/* Routines for checking parts of an ICC profile. */
#ifdef PNG_READ_iCCP_SUPPORTED
PNG_INTERNAL_FUNCTION(int,png_icc_check_length,(png_const_structrp png_ptr,
   png_colorspacerp colorspace, png_const_charp name,
   png_uint_32 profile_length), PNG_EMPTY);
#endif /* READ_iCCP */
PNG_INTERNAL_FUNCTION(int,png_icc_check_header,(png_const_structrp png_ptr,
   png_colorspacerp colorspace, png_const_charp name,
   png_uint_32 profile_length,
   png_const_bytep profile /* first 132 bytes only */, int color_type),
   PNG_EMPTY);
PNG_INTERNAL_FUNCTION(int,png_icc_check_tag_table,(png_const_structrp png_ptr,
   png_colorspacerp colorspace, png_const_charp name,
   png_uint_32 profile_length,
   png_const_bytep profile /* header plus whole tag table */), PNG_EMPTY);
#ifdef PNG_sRGB_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_icc_set_sRGB,(
   png_const_structrp png_ptr, png_colorspacerp colorspace,
   png_const_bytep profile, uLong adler), PNG_EMPTY);
   /* 'adler' is the Adler32 checksum of the uncompressed profile data. It may
    * be zero to indicate that it is not available.  It is used, if provided,
    * as a fast check on the profile when checking to see if it is sRGB.
    */
#endif
#endif /* iCCP */

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_colorspace_set_rgb_coefficients,
   (png_structrp png_ptr), PNG_EMPTY);
   /* Set the rgb_to_gray coefficients from the colorspace Y values */
#endif /* READ_RGB_TO_GRAY */
#endif /* COLORSPACE */

/* Added at libpng version 1.4.0 */
PNG_INTERNAL_FUNCTION(void,png_check_IHDR,(png_const_structrp png_ptr,
    png_uint_32 width, png_uint_32 height, int bit_depth,
    int color_type, int interlace_type, int compression_type,
    int filter_type),PNG_EMPTY);

/* Added at libpng version 1.5.10 */
#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
PNG_INTERNAL_FUNCTION(void,png_do_check_palette_indexes,
   (png_structrp png_ptr, png_row_infop row_info),PNG_EMPTY);
#endif

#if defined(PNG_FLOATING_POINT_SUPPORTED) && defined(PNG_ERROR_TEXT_SUPPORTED)
PNG_INTERNAL_FUNCTION(void,png_fixed_error,(png_const_structrp png_ptr,
   png_const_charp name),PNG_NORETURN);
#endif

/* Puts 'string' into 'buffer' at buffer[pos], taking care never to overwrite
 * the end.  Always leaves the buffer nul terminated.  Never errors out (and
 * there is no error code.)
 */
PNG_INTERNAL_FUNCTION(size_t,png_safecat,(png_charp buffer, size_t bufsize,
   size_t pos, png_const_charp string),PNG_EMPTY);

/* Various internal functions to handle formatted warning messages, currently
 * only implemented for warnings.
 */
#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_TIME_RFC1123_SUPPORTED)
/* Utility to dump an unsigned value into a buffer, given a start pointer and
 * and end pointer (which should point just *beyond* the end of the buffer!)
 * Returns the pointer to the start of the formatted string.  This utility only
 * does unsigned values.
 */
PNG_INTERNAL_FUNCTION(png_charp,png_format_number,(png_const_charp start,
   png_charp end, int format, png_alloc_size_t number),PNG_EMPTY);

/* Convenience macro that takes an array: */
#define PNG_FORMAT_NUMBER(buffer,format,number) \
   png_format_number(buffer, buffer + (sizeof buffer), format, number)

/* Suggested size for a number buffer (enough for 64 bits and a sign!) */
#define PNG_NUMBER_BUFFER_SIZE 24

/* These are the integer formats currently supported, the name is formed from
 * the standard printf(3) format string.
 */
#define PNG_NUMBER_FORMAT_u     1 /* chose unsigned API! */
#define PNG_NUMBER_FORMAT_02u   2
#define PNG_NUMBER_FORMAT_d     1 /* chose signed API! */
#define PNG_NUMBER_FORMAT_02d   2
#define PNG_NUMBER_FORMAT_x     3
#define PNG_NUMBER_FORMAT_02x   4
#define PNG_NUMBER_FORMAT_fixed 5 /* choose the signed API */
#endif

#ifdef PNG_WARNINGS_SUPPORTED
/* New defines and members adding in libpng-1.5.4 */
#  define PNG_WARNING_PARAMETER_SIZE 32
#  define PNG_WARNING_PARAMETER_COUNT 8 /* Maximum 9; see pngerror.c */

/* An l-value of this type has to be passed to the APIs below to cache the
 * values of the parameters to a formatted warning message.
 */
typedef char png_warning_parameters[PNG_WARNING_PARAMETER_COUNT][
   PNG_WARNING_PARAMETER_SIZE];

PNG_INTERNAL_FUNCTION(void,png_warning_parameter,(png_warning_parameters p,
   int number, png_const_charp string),PNG_EMPTY);
   /* Parameters are limited in size to PNG_WARNING_PARAMETER_SIZE characters,
    * including the trailing '\0'.
    */
PNG_INTERNAL_FUNCTION(void,png_warning_parameter_unsigned,
   (png_warning_parameters p, int number, int format, png_alloc_size_t value),
   PNG_EMPTY);
   /* Use png_alloc_size_t because it is an unsigned type as big as any we
    * need to output.  Use the following for a signed value.
    */
PNG_INTERNAL_FUNCTION(void,png_warning_parameter_signed,
   (png_warning_parameters p, int number, int format, png_int_32 value),
   PNG_EMPTY);

PNG_INTERNAL_FUNCTION(void,png_formatted_warning,(png_const_structrp png_ptr,
   png_warning_parameters p, png_const_charp message),PNG_EMPTY);
   /* 'message' follows the X/Open approach of using @1, @2 to insert
    * parameters previously supplied using the above functions.  Errors in
    * specifying the parameters will simply result in garbage substitutions.
    */
#endif

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
/* Application errors (new in 1.6); use these functions (declared below) for
 * errors in the parameters or order of API function calls on read.  The
 * 'warning' should be used for an error that can be handled completely; the
 * 'error' for one which can be handled safely but which may lose application
 * information or settings.
 *
 * By default these both result in a png_error call prior to release, while in a
 * released version the 'warning' is just a warning.  However if the application
 * explicitly disables benign errors (explicitly permitting the code to lose
 * information) they both turn into warnings.
 *
 * If benign errors aren't supported they end up as the corresponding base call
 * (png_warning or png_error.)
 */
PNG_INTERNAL_FUNCTION(void,png_app_warning,(png_const_structrp png_ptr,
   png_const_charp message),PNG_EMPTY);
   /* The application provided invalid parameters to an API function or called
    * an API function at the wrong time, libpng can completely recover.
    */

PNG_INTERNAL_FUNCTION(void,png_app_error,(png_const_structrp png_ptr,
   png_const_charp message),PNG_EMPTY);
   /* As above but libpng will ignore the call, or attempt some other partial
    * recovery from the error.
    */
#else
#  define png_app_warning(pp,s) png_warning(pp,s)
#  define png_app_error(pp,s) png_error(pp,s)
#endif

PNG_INTERNAL_FUNCTION(void,png_chunk_report,(png_const_structrp png_ptr,
   png_const_charp message, int error),PNG_EMPTY);
   /* Report a recoverable issue in chunk data.  On read this is used to report
    * a problem found while reading a particular chunk and the
    * png_chunk_benign_error or png_chunk_warning function is used as
    * appropriate.  On write this is used to report an error that comes from
    * data set via an application call to a png_set_ API and png_app_error or
    * png_app_warning is used as appropriate.
    *
    * The 'error' parameter must have one of the following values:
    */
#define PNG_CHUNK_WARNING     0 /* never an error */
#define PNG_CHUNK_WRITE_ERROR 1 /* an error only on write */
#define PNG_CHUNK_ERROR       2 /* always an error */

/* ASCII to FP interfaces, currently only implemented if sCAL
 * support is required.
 */
#if defined(PNG_sCAL_SUPPORTED)
/* MAX_DIGITS is actually the maximum number of characters in an sCAL
 * width or height, derived from the precision (number of significant
 * digits - a build time settable option) and assumptions about the
 * maximum ridiculous exponent.
 */
#define PNG_sCAL_MAX_DIGITS (PNG_sCAL_PRECISION+1/*.*/+1/*E*/+10/*exponent*/)

#ifdef PNG_FLOATING_POINT_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_ascii_from_fp,(png_const_structrp png_ptr,
   png_charp ascii, png_size_t size, double fp, unsigned int precision),
   PNG_EMPTY);
#endif /* FLOATING_POINT */

#ifdef PNG_FIXED_POINT_SUPPORTED
PNG_INTERNAL_FUNCTION(void,png_ascii_from_fixed,(png_const_structrp png_ptr,
   png_charp ascii, png_size_t size, png_fixed_point fp),PNG_EMPTY);
#endif /* FIXED_POINT */
#endif /* sCAL */

#if defined(PNG_sCAL_SUPPORTED) || defined(PNG_pCAL_SUPPORTED)
/* An internal API to validate the format of a floating point number.
 * The result is the index of the next character.  If the number is
 * not valid it will be the index of a character in the supposed number.
 *
 * The format of a number is defined in the PNG extensions specification
 * and this API is strictly conformant to that spec, not anyone elses!
 *
 * The format as a regular expression is:
 *
 * [+-]?[0-9]+.?([Ee][+-]?[0-9]+)?
 *
 * or:
 *
 * [+-]?.[0-9]+(.[0-9]+)?([Ee][+-]?[0-9]+)?
 *
 * The complexity is that either integer or fraction must be present and the
 * fraction is permitted to have no digits only if the integer is present.
 *
 * NOTE: The dangling E problem.
 *   There is a PNG valid floating point number in the following:
 *
 *       PNG floating point numbers are not greedy.
 *
 *   Working this out requires *TWO* character lookahead (because of the
 *   sign), the parser does not do this - it will fail at the 'r' - this
 *   doesn't matter for PNG sCAL chunk values, but it requires more care
 *   if the value were ever to be embedded in something more complex.  Use
 *   ANSI-C strtod if you need the lookahead.
 */
/* State table for the parser. */
#define PNG_FP_INTEGER    0  /* before or in integer */
#define PNG_FP_FRACTION   1  /* before or in fraction */
#define PNG_FP_EXPONENT   2  /* before or in exponent */
#define PNG_FP_STATE      3  /* mask for the above */
#define PNG_FP_SAW_SIGN   4  /* Saw +/- in current state */
#define PNG_FP_SAW_DIGIT  8  /* Saw a digit in current state */
#define PNG_FP_SAW_DOT   16  /* Saw a dot in current state */
#define PNG_FP_SAW_E     32  /* Saw an E (or e) in current state */
#define PNG_FP_SAW_ANY   60  /* Saw any of the above 4 */

/* These three values don't affect the parser.  They are set but not used.
 */
#define PNG_FP_WAS_VALID 64  /* Preceding substring is a valid fp number */
#define PNG_FP_NEGATIVE 128  /* A negative number, including "-0" */
#define PNG_FP_NONZERO  256  /* A non-zero value */
#define PNG_FP_STICKY   448  /* The above three flags */

/* This is available for the caller to store in 'state' if required.  Do not
 * call the parser after setting it (the parser sometimes clears it.)
 */
#define PNG_FP_INVALID  512  /* Available for callers as a distinct value */

/* Result codes for the parser (boolean - true meants ok, false means
 * not ok yet.)
 */
#define PNG_FP_MAYBE      0  /* The number may be valid in the future */
#define PNG_FP_OK         1  /* The number is valid */

/* Tests on the sticky non-zero and negative flags.  To pass these checks
 * the state must also indicate that the whole number is valid - this is
 * achieved by testing PNG_FP_SAW_DIGIT (see the implementation for why this
 * is equivalent to PNG_FP_OK above.)
 */
#define PNG_FP_NZ_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NEGATIVE | PNG_FP_NONZERO)
   /* NZ_MASK: the string is valid and a non-zero negative value */
#define PNG_FP_Z_MASK (PNG_FP_SAW_DIGIT | PNG_FP_NONZERO)
   /* Z MASK: the string is valid and a non-zero value. */
   /* PNG_FP_SAW_DIGIT: the string is valid. */
#define PNG_FP_IS_ZERO(state) (((state) & PNG_FP_Z_MASK) == PNG_FP_SAW_DIGIT)
#define PNG_FP_IS_POSITIVE(state) (((state) & PNG_FP_NZ_MASK) == PNG_FP_Z_MASK)
#define PNG_FP_IS_NEGATIVE(state) (((state) & PNG_FP_NZ_MASK) == PNG_FP_NZ_MASK)

/* The actual parser.  This can be called repeatedly. It updates
 * the index into the string and the state variable (which must
 * be initialized to 0).  It returns a result code, as above.  There
 * is no point calling the parser any more if it fails to advance to
 * the end of the string - it is stuck on an invalid character (or
 * terminated by '\0').
 *
 * Note that the pointer will consume an E or even an E+ and then leave
 * a 'maybe' state even though a preceding integer.fraction is valid.
 * The PNG_FP_WAS_VALID flag indicates that a preceding substring was
 * a valid number.  It's possible to recover from this by calling
 * the parser again (from the start, with state 0) but with a string
 * that omits the last character (i.e. set the size to the index of
 * the problem character.)  This has not been tested within libpng.
 */
PNG_INTERNAL_FUNCTION(int,png_check_fp_number,(png_const_charp string,
   png_size_t size, int *statep, png_size_tp whereami),PNG_EMPTY);

/* This is the same but it checks a complete string and returns true
 * only if it just contains a floating point number.  As of 1.5.4 this
 * function also returns the state at the end of parsing the number if
 * it was valid (otherwise it returns 0.)  This can be used for testing
 * for negative or zero values using the sticky flag.
 */
PNG_INTERNAL_FUNCTION(int,png_check_fp_string,(png_const_charp string,
   png_size_t size),PNG_EMPTY);
#endif /* pCAL || sCAL */

#if defined(PNG_GAMMA_SUPPORTED) ||\
    defined(PNG_INCH_CONVERSIONS_SUPPORTED) || defined(PNG_READ_pHYs_SUPPORTED)
/* Added at libpng version 1.5.0 */
/* This is a utility to provide a*times/div (rounded) and indicate
 * if there is an overflow.  The result is a boolean - false (0)
 * for overflow, true (1) if no overflow, in which case *res
 * holds the result.
 */
PNG_INTERNAL_FUNCTION(int,png_muldiv,(png_fixed_point_p res, png_fixed_point a,
   png_int_32 multiplied_by, png_int_32 divided_by),PNG_EMPTY);
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)
/* Same deal, but issue a warning on overflow and return 0. */
PNG_INTERNAL_FUNCTION(png_fixed_point,png_muldiv_warn,
   (png_const_structrp png_ptr, png_fixed_point a, png_int_32 multiplied_by,
   png_int_32 divided_by),PNG_EMPTY);
#endif

#ifdef PNG_GAMMA_SUPPORTED
/* Calculate a reciprocal - used for gamma values.  This returns
 * 0 if the argument is 0 in order to maintain an undefined value;
 * there are no warnings.
 */
PNG_INTERNAL_FUNCTION(png_fixed_point,png_reciprocal,(png_fixed_point a),
   PNG_EMPTY);

#ifdef PNG_READ_GAMMA_SUPPORTED
/* The same but gives a reciprocal of the product of two fixed point
 * values.  Accuracy is suitable for gamma calculations but this is
 * not exact - use png_muldiv for that.  Only required at present on read.
 */
PNG_INTERNAL_FUNCTION(png_fixed_point,png_reciprocal2,(png_fixed_point a,
   png_fixed_point b),PNG_EMPTY);
#endif

/* Return true if the gamma value is significantly different from 1.0 */
PNG_INTERNAL_FUNCTION(int,png_gamma_significant,(png_fixed_point gamma_value),
   PNG_EMPTY);
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
/* Internal fixed point gamma correction.  These APIs are called as
 * required to convert single values - they don't need to be fast,
 * they are not used when processing image pixel values.
 *
 * While the input is an 'unsigned' value it must actually be the
 * correct bit value - 0..255 or 0..65535 as required.
 */
PNG_INTERNAL_FUNCTION(png_uint_16,png_gamma_correct,(png_structrp png_ptr,
   unsigned int value, png_fixed_point gamma_value),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(png_uint_16,png_gamma_16bit_correct,(unsigned int value,
   png_fixed_point gamma_value),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(png_byte,png_gamma_8bit_correct,(unsigned int value,
   png_fixed_point gamma_value),PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_destroy_gamma_table,(png_structrp png_ptr),
   PNG_EMPTY);
PNG_INTERNAL_FUNCTION(void,png_build_gamma_table,(png_structrp png_ptr,
   int bit_depth),PNG_EMPTY);
#endif

/* SIMPLIFIED READ/WRITE SUPPORT */
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) ||\
   defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)
/* The internal structure that png_image::opaque points to. */
typedef struct png_control
{
   png_structp png_ptr;
   png_infop   info_ptr;
   png_voidp   error_buf;           /* Always a jmp_buf at present. */

   png_const_bytep memory;          /* Memory buffer. */
   png_size_t      size;            /* Size of the memory buffer. */

   unsigned int for_write       :1; /* Otherwise it is a read structure */
   unsigned int owned_file      :1; /* We own the file in io_ptr */
} png_control;

/* Return the pointer to the jmp_buf from a png_control: necessary because C
 * does not reveal the type of the elements of jmp_buf.
 */
#ifdef __cplusplus
#  define png_control_jmp_buf(pc) (((jmp_buf*)((pc)->error_buf))[0])
#else
#  define png_control_jmp_buf(pc) ((pc)->error_buf)
#endif

/* Utility to safely execute a piece of libpng code catching and logging any
 * errors that might occur.  Returns true on success, false on failure (either
 * of the function or as a result of a png_error.)
 */
PNG_INTERNAL_CALLBACK(void,png_safe_error,(png_structp png_ptr,
   png_const_charp error_message),PNG_NORETURN);

#ifdef PNG_WARNINGS_SUPPORTED
PNG_INTERNAL_CALLBACK(void,png_safe_warning,(png_structp png_ptr,
   png_const_charp warning_message),PNG_EMPTY);
#else
#  define png_safe_warning 0/*dummy argument*/
#endif

PNG_INTERNAL_FUNCTION(int,png_safe_execute,(png_imagep image,
   int (*function)(png_voidp), png_voidp arg),PNG_EMPTY);

/* Utility to log an error; this also cleans up the png_image; the function
 * always returns 0 (false).
 */
PNG_INTERNAL_FUNCTION(int,png_image_error,(png_imagep image,
   png_const_charp error_message),PNG_EMPTY);

#ifndef PNG_SIMPLIFIED_READ_SUPPORTED
/* png_image_free is used by the write code but not exported */
PNG_INTERNAL_FUNCTION(void, png_image_free, (png_imagep image), PNG_EMPTY);
#endif /* !SIMPLIFIED_READ */

#endif /* SIMPLIFIED READ/WRITE */

/* These are initialization functions for hardware specific PNG filter
 * optimizations; list these here then select the appropriate one at compile
 * time using the macro PNG_FILTER_OPTIMIZATIONS.  If the macro is not defined
 * the generic code is used.
 */
#ifdef PNG_FILTER_OPTIMIZATIONS
PNG_INTERNAL_FUNCTION(void, PNG_FILTER_OPTIMIZATIONS, (png_structp png_ptr,
   unsigned int bpp), PNG_EMPTY);
   /* Just declare the optimization that will be used */
#else
   /* List *all* the possible optimizations here - this branch is required if
    * the builder of libpng passes the definition of PNG_FILTER_OPTIMIZATIONS in
    * CFLAGS in place of CPPFLAGS *and* uses symbol prefixing.
    */
#  if PNG_ARM_NEON_OPT > 0
PNG_INTERNAL_FUNCTION(void, png_init_filter_functions_neon,
   (png_structp png_ptr, unsigned int bpp), PNG_EMPTY);
#endif

#if PNG_MIPS_MSA_OPT > 0
PNG_INTERNAL_FUNCTION(void, png_init_filter_functions_msa,
   (png_structp png_ptr, unsigned int bpp), PNG_EMPTY);
#endif
#endif

PNG_INTERNAL_FUNCTION(png_uint_32, png_check_keyword, (png_structrp png_ptr,
   png_const_charp key, png_bytep new_key), PNG_EMPTY);

/* Maintainer: Put new private prototypes here ^ */

#include "pngdebug.h"

#ifdef __cplusplus
}
#endif

#endif /* PNG_VERSION_INFO_ONLY */
#endif /* PNGPRIV_H */

```

`ThirdPartyBuild/PNG/Code/pngread.c`:

```c

/* pngread.c - read a PNG file
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This file contains routines that an application calls directly to
 * read a PNG file or stream.
 */

#include "pngpriv.h"
#if defined(PNG_SIMPLIFIED_READ_SUPPORTED) && defined(PNG_STDIO_SUPPORTED)
#  include <errno.h>
#endif

#ifdef PNG_READ_SUPPORTED

/* Create a PNG structure for reading, and allocate any memory needed. */
PNG_FUNCTION(png_structp,PNGAPI
png_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
{
#ifndef PNG_USER_MEM_SUPPORTED
   png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
        error_fn, warn_fn, NULL, NULL, NULL);
#else
   return png_create_read_struct_2(user_png_ver, error_ptr, error_fn,
        warn_fn, NULL, NULL, NULL);
}

/* Alternate create PNG structure for reading, and allocate any memory
 * needed.
 */
PNG_FUNCTION(png_structp,PNGAPI
png_create_read_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
    png_malloc_ptr malloc_fn, png_free_ptr free_fn),PNG_ALLOCATED)
{
   png_structp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
       error_fn, warn_fn, mem_ptr, malloc_fn, free_fn);
#endif /* USER_MEM */

   if (png_ptr != NULL)
   {
      png_ptr->mode = PNG_IS_READ_STRUCT;

      /* Added in libpng-1.6.0; this can be used to detect a read structure if
       * required (it will be zero in a write structure.)
       */
#     ifdef PNG_SEQUENTIAL_READ_SUPPORTED
         png_ptr->IDAT_read_size = PNG_IDAT_READ_SIZE;
#     endif

#     ifdef PNG_BENIGN_READ_ERRORS_SUPPORTED
         png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;

         /* In stable builds only warn if an application error can be completely
          * handled.
          */
#        if PNG_RELEASE_BUILD
            png_ptr->flags |= PNG_FLAG_APP_WARNINGS_WARN;
#        endif
#     endif

      /* TODO: delay this, it can be done in png_init_io (if the app doesn't
       * do it itself) avoiding setting the default function if it is not
       * required.
       */
      png_set_read_fn(png_ptr, NULL, NULL);
   }

   return png_ptr;
}


#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the information before the actual image data.  This has been
 * changed in v0.90 to allow reading a file that already has the magic
 * bytes read from the stream.  You can tell libpng how many bytes have
 * been read from the beginning of the stream (up to the maximum of 8)
 * via png_set_sig_bytes(), and we will only check the remaining bytes
 * here.  The application can then have access to the signature bytes we
 * read if it is determined that this isn't a valid PNG file.
 */
void PNGAPI
png_read_info(png_structrp png_ptr, png_inforp info_ptr)
{
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
   int keep;
#endif

   png_debug(1, "in png_read_info");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   /* Read and check the PNG file signature. */
   png_read_sig(png_ptr, info_ptr);

   for (;;)
   {
      png_uint_32 length = png_read_chunk_header(png_ptr);
      png_uint_32 chunk_name = png_ptr->chunk_name;

      /* IDAT logic needs to happen here to simplify getting the two flags
       * right.
       */
      if (chunk_name == png_IDAT)
      {
         if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
            png_chunk_error(png_ptr, "Missing IHDR before IDAT");

         else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
             (png_ptr->mode & PNG_HAVE_PLTE) == 0)
            png_chunk_error(png_ptr, "Missing PLTE before IDAT");

         else if ((png_ptr->mode & PNG_AFTER_IDAT) != 0)
            png_chunk_benign_error(png_ptr, "Too many IDATs found");

         png_ptr->mode |= PNG_HAVE_IDAT;
      }

      else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
      {
         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;
         png_ptr->mode |= PNG_AFTER_IDAT;
      }

      /* This should be a binary subdivision search or a hash for
       * matching the chunk name rather than a linear search.
       */
      if (chunk_name == png_IHDR)
         png_handle_IHDR(png_ptr, info_ptr, length);

      else if (chunk_name == png_IEND)
         png_handle_IEND(png_ptr, info_ptr, length);

#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
      else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)
      {
         png_handle_unknown(png_ptr, info_ptr, length, keep);

         if (chunk_name == png_PLTE)
            png_ptr->mode |= PNG_HAVE_PLTE;

         else if (chunk_name == png_IDAT)
         {
            png_ptr->idat_size = 0; /* It has been consumed */
            break;
         }
      }
#endif
      else if (chunk_name == png_PLTE)
         png_handle_PLTE(png_ptr, info_ptr, length);

      else if (chunk_name == png_IDAT)
      {
         png_ptr->idat_size = length;
         break;
      }

#ifdef PNG_READ_bKGD_SUPPORTED
      else if (chunk_name == png_bKGD)
         png_handle_bKGD(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_cHRM_SUPPORTED
      else if (chunk_name == png_cHRM)
         png_handle_cHRM(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_gAMA_SUPPORTED
      else if (chunk_name == png_gAMA)
         png_handle_gAMA(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_hIST_SUPPORTED
      else if (chunk_name == png_hIST)
         png_handle_hIST(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_oFFs_SUPPORTED
      else if (chunk_name == png_oFFs)
         png_handle_oFFs(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_pCAL_SUPPORTED
      else if (chunk_name == png_pCAL)
         png_handle_pCAL(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_sCAL_SUPPORTED
      else if (chunk_name == png_sCAL)
         png_handle_sCAL(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_pHYs_SUPPORTED
      else if (chunk_name == png_pHYs)
         png_handle_pHYs(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_sBIT_SUPPORTED
      else if (chunk_name == png_sBIT)
         png_handle_sBIT(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_sRGB_SUPPORTED
      else if (chunk_name == png_sRGB)
         png_handle_sRGB(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_iCCP_SUPPORTED
      else if (chunk_name == png_iCCP)
         png_handle_iCCP(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_sPLT_SUPPORTED
      else if (chunk_name == png_sPLT)
         png_handle_sPLT(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_tEXt_SUPPORTED
      else if (chunk_name == png_tEXt)
         png_handle_tEXt(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_tIME_SUPPORTED
      else if (chunk_name == png_tIME)
         png_handle_tIME(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_tRNS_SUPPORTED
      else if (chunk_name == png_tRNS)
         png_handle_tRNS(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_zTXt_SUPPORTED
      else if (chunk_name == png_zTXt)
         png_handle_zTXt(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_iTXt_SUPPORTED
      else if (chunk_name == png_iTXt)
         png_handle_iTXt(png_ptr, info_ptr, length);
#endif

      else
         png_handle_unknown(png_ptr, info_ptr, length,
             PNG_HANDLE_CHUNK_AS_DEFAULT);
   }
}
#endif /* SEQUENTIAL_READ */

/* Optional call to update the users info_ptr structure */
void PNGAPI
png_read_update_info(png_structrp png_ptr, png_inforp info_ptr)
{
   png_debug(1, "in png_read_update_info");

   if (png_ptr != NULL)
   {
      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
      {
         png_read_start_row(png_ptr);

#        ifdef PNG_READ_TRANSFORMS_SUPPORTED
            png_read_transform_info(png_ptr, info_ptr);
#        else
            PNG_UNUSED(info_ptr)
#        endif
      }

      /* New in 1.6.0 this avoids the bug of doing the initializations twice */
      else
         png_app_error(png_ptr,
             "png_read_update_info/png_start_read_image: duplicate call");
   }
}

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Initialize palette, background, etc, after transformations
 * are set, but before any reading takes place.  This allows
 * the user to obtain a gamma-corrected palette, for example.
 * If the user doesn't call this, we will do it ourselves.
 */
void PNGAPI
png_start_read_image(png_structrp png_ptr)
{
   png_debug(1, "in png_start_read_image");

   if (png_ptr != NULL)
   {
      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
         png_read_start_row(png_ptr);

      /* New in 1.6.0 this avoids the bug of doing the initializations twice */
      else
         png_app_error(png_ptr,
             "png_start_read_image/png_read_update_info: duplicate call");
   }
}
#endif /* SEQUENTIAL_READ */

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
#ifdef PNG_MNG_FEATURES_SUPPORTED
/* Undoes intrapixel differencing,
 * NOTE: this is apparently only supported in the 'sequential' reader.
 */
static void
png_do_read_intrapixel(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_read_intrapixel");

   if (
       (row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)
   {
      int bytes_per_pixel;
      png_uint_32 row_width = row_info->width;

      if (row_info->bit_depth == 8)
      {
         png_bytep rp;
         png_uint_32 i;

         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
            bytes_per_pixel = 3;

         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            bytes_per_pixel = 4;

         else
            return;

         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
         {
            *(rp) = (png_byte)((256 + *rp + *(rp + 1)) & 0xff);
            *(rp+2) = (png_byte)((256 + *(rp + 2) + *(rp + 1)) & 0xff);
         }
      }
      else if (row_info->bit_depth == 16)
      {
         png_bytep rp;
         png_uint_32 i;

         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
            bytes_per_pixel = 6;

         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            bytes_per_pixel = 8;

         else
            return;

         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
         {
            png_uint_32 s0   = (png_uint_32)(*(rp    ) << 8) | *(rp + 1);
            png_uint_32 s1   = (png_uint_32)(*(rp + 2) << 8) | *(rp + 3);
            png_uint_32 s2   = (png_uint_32)(*(rp + 4) << 8) | *(rp + 5);
            png_uint_32 red  = (s0 + s1 + 65536) & 0xffff;
            png_uint_32 blue = (s2 + s1 + 65536) & 0xffff;
            *(rp    ) = (png_byte)((red >> 8) & 0xff);
            *(rp + 1) = (png_byte)(red & 0xff);
            *(rp + 4) = (png_byte)((blue >> 8) & 0xff);
            *(rp + 5) = (png_byte)(blue & 0xff);
         }
      }
   }
}
#endif /* MNG_FEATURES */

void PNGAPI
png_read_row(png_structrp png_ptr, png_bytep row, png_bytep dsp_row)
{
   png_row_info row_info;

   if (png_ptr == NULL)
      return;

   png_debug2(1, "in png_read_row (row %lu, pass %d)",
       (unsigned long)png_ptr->row_number, png_ptr->pass);

   /* png_read_start_row sets the information (in particular iwidth) for this
    * interlace pass.
    */
   if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
      png_read_start_row(png_ptr);

   /* 1.5.6: row_info moved out of png_struct to a local here. */
   row_info.width = png_ptr->iwidth; /* NOTE: width of current interlaced row */
   row_info.color_type = png_ptr->color_type;
   row_info.bit_depth = png_ptr->bit_depth;
   row_info.channels = png_ptr->channels;
   row_info.pixel_depth = png_ptr->pixel_depth;
   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);

#ifdef PNG_WARNINGS_SUPPORTED
   if (png_ptr->row_number == 0 && png_ptr->pass == 0)
   {
   /* Check for transforms that have been set but were defined out */
#if defined(PNG_WRITE_INVERT_SUPPORTED) && !defined(PNG_READ_INVERT_SUPPORTED)
   if ((png_ptr->transformations & PNG_INVERT_MONO) != 0)
      png_warning(png_ptr, "PNG_READ_INVERT_SUPPORTED is not defined");
#endif

#if defined(PNG_WRITE_FILLER_SUPPORTED) && !defined(PNG_READ_FILLER_SUPPORTED)
   if ((png_ptr->transformations & PNG_FILLER) != 0)
      png_warning(png_ptr, "PNG_READ_FILLER_SUPPORTED is not defined");
#endif

#if defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \
    !defined(PNG_READ_PACKSWAP_SUPPORTED)
   if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
      png_warning(png_ptr, "PNG_READ_PACKSWAP_SUPPORTED is not defined");
#endif

#if defined(PNG_WRITE_PACK_SUPPORTED) && !defined(PNG_READ_PACK_SUPPORTED)
   if ((png_ptr->transformations & PNG_PACK) != 0)
      png_warning(png_ptr, "PNG_READ_PACK_SUPPORTED is not defined");
#endif

#if defined(PNG_WRITE_SHIFT_SUPPORTED) && !defined(PNG_READ_SHIFT_SUPPORTED)
   if ((png_ptr->transformations & PNG_SHIFT) != 0)
      png_warning(png_ptr, "PNG_READ_SHIFT_SUPPORTED is not defined");
#endif

#if defined(PNG_WRITE_BGR_SUPPORTED) && !defined(PNG_READ_BGR_SUPPORTED)
   if ((png_ptr->transformations & PNG_BGR) != 0)
      png_warning(png_ptr, "PNG_READ_BGR_SUPPORTED is not defined");
#endif

#if defined(PNG_WRITE_SWAP_SUPPORTED) && !defined(PNG_READ_SWAP_SUPPORTED)
   if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)
      png_warning(png_ptr, "PNG_READ_SWAP_SUPPORTED is not defined");
#endif
   }
#endif /* WARNINGS */

#ifdef PNG_READ_INTERLACING_SUPPORTED
   /* If interlaced and we do not need a new row, combine row and return.
    * Notice that the pixels we have from previous rows have been transformed
    * already; we can only combine like with like (transformed or
    * untransformed) and, because of the libpng API for interlaced images, this
    * means we must transform before de-interlacing.
    */
   if (png_ptr->interlaced != 0 &&
       (png_ptr->transformations & PNG_INTERLACE) != 0)
   {
      switch (png_ptr->pass)
      {
         case 0:
            if (png_ptr->row_number & 0x07)
            {
               if (dsp_row != NULL)
                  png_combine_row(png_ptr, dsp_row, 1/*display*/);
               png_read_finish_row(png_ptr);
               return;
            }
            break;

         case 1:
            if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)
            {
               if (dsp_row != NULL)
                  png_combine_row(png_ptr, dsp_row, 1/*display*/);

               png_read_finish_row(png_ptr);
               return;
            }
            break;

         case 2:
            if ((png_ptr->row_number & 0x07) != 4)
            {
               if (dsp_row != NULL && (png_ptr->row_number & 4))
                  png_combine_row(png_ptr, dsp_row, 1/*display*/);

               png_read_finish_row(png_ptr);
               return;
            }
            break;

         case 3:
            if ((png_ptr->row_number & 3) || png_ptr->width < 3)
            {
               if (dsp_row != NULL)
                  png_combine_row(png_ptr, dsp_row, 1/*display*/);

               png_read_finish_row(png_ptr);
               return;
            }
            break;

         case 4:
            if ((png_ptr->row_number & 3) != 2)
            {
               if (dsp_row != NULL && (png_ptr->row_number & 2))
                  png_combine_row(png_ptr, dsp_row, 1/*display*/);

               png_read_finish_row(png_ptr);
               return;
            }
            break;

         case 5:
            if ((png_ptr->row_number & 1) || png_ptr->width < 2)
            {
               if (dsp_row != NULL)
                  png_combine_row(png_ptr, dsp_row, 1/*display*/);

               png_read_finish_row(png_ptr);
               return;
            }
            break;

         default:
         case 6:
            if ((png_ptr->row_number & 1) == 0)
            {
               png_read_finish_row(png_ptr);
               return;
            }
            break;
      }
   }
#endif

   if ((png_ptr->mode & PNG_HAVE_IDAT) == 0)
      png_error(png_ptr, "Invalid attempt to read row data");

   /* Fill the row with IDAT data: */
   png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);

   if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)
   {
      if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)
         png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,
             png_ptr->prev_row + 1, png_ptr->row_buf[0]);
      else
         png_error(png_ptr, "bad adaptive filter value");
   }

   /* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
    * 1.5.6, while the buffer really is this big in current versions of libpng
    * it may not be in the future, so this was changed just to copy the
    * interlaced count:
    */
   memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1);

#ifdef PNG_MNG_FEATURES_SUPPORTED
   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) != 0 &&
       (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
   {
      /* Intrapixel differencing */
      png_do_read_intrapixel(&row_info, png_ptr->row_buf + 1);
   }
#endif

#ifdef PNG_READ_TRANSFORMS_SUPPORTED
   if (png_ptr->transformations)
      png_do_read_transformations(png_ptr, &row_info);
#endif

   /* The transformed pixel depth should match the depth now in row_info. */
   if (png_ptr->transformed_pixel_depth == 0)
   {
      png_ptr->transformed_pixel_depth = row_info.pixel_depth;
      if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
         png_error(png_ptr, "sequential row overflow");
   }

   else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)
      png_error(png_ptr, "internal sequential row size calculation error");

#ifdef PNG_READ_INTERLACING_SUPPORTED
   /* Expand interlaced rows to full size */
   if (png_ptr->interlaced != 0 &&
      (png_ptr->transformations & PNG_INTERLACE) != 0)
   {
      if (png_ptr->pass < 6)
         png_do_read_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass,
             png_ptr->transformations);

      if (dsp_row != NULL)
         png_combine_row(png_ptr, dsp_row, 1/*display*/);

      if (row != NULL)
         png_combine_row(png_ptr, row, 0/*row*/);
   }

   else
#endif
   {
      if (row != NULL)
         png_combine_row(png_ptr, row, -1/*ignored*/);

      if (dsp_row != NULL)
         png_combine_row(png_ptr, dsp_row, -1/*ignored*/);
   }
   png_read_finish_row(png_ptr);

   if (png_ptr->read_row_fn != NULL)
      (*(png_ptr->read_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);

}
#endif /* SEQUENTIAL_READ */

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read one or more rows of image data.  If the image is interlaced,
 * and png_set_interlace_handling() has been called, the rows need to
 * contain the contents of the rows from the previous pass.  If the
 * image has alpha or transparency, and png_handle_alpha()[*] has been
 * called, the rows contents must be initialized to the contents of the
 * screen.
 *
 * "row" holds the actual image, and pixels are placed in it
 * as they arrive.  If the image is displayed after each pass, it will
 * appear to "sparkle" in.  "display_row" can be used to display a
 * "chunky" progressive image, with finer detail added as it becomes
 * available.  If you do not want this "chunky" display, you may pass
 * NULL for display_row.  If you do not want the sparkle display, and
 * you have not called png_handle_alpha(), you may pass NULL for rows.
 * If you have called png_handle_alpha(), and the image has either an
 * alpha channel or a transparency chunk, you must provide a buffer for
 * rows.  In this case, you do not have to provide a display_row buffer
 * also, but you may.  If the image is not interlaced, or if you have
 * not called png_set_interlace_handling(), the display_row buffer will
 * be ignored, so pass NULL to it.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng
 */

void PNGAPI
png_read_rows(png_structrp png_ptr, png_bytepp row,
    png_bytepp display_row, png_uint_32 num_rows)
{
   png_uint_32 i;
   png_bytepp rp;
   png_bytepp dp;

   png_debug(1, "in png_read_rows");

   if (png_ptr == NULL)
      return;

   rp = row;
   dp = display_row;
   if (rp != NULL && dp != NULL)
      for (i = 0; i < num_rows; i++)
      {
         png_bytep rptr = *rp++;
         png_bytep dptr = *dp++;

         png_read_row(png_ptr, rptr, dptr);
      }

   else if (rp != NULL)
      for (i = 0; i < num_rows; i++)
      {
         png_bytep rptr = *rp;
         png_read_row(png_ptr, rptr, NULL);
         rp++;
      }

   else if (dp != NULL)
      for (i = 0; i < num_rows; i++)
      {
         png_bytep dptr = *dp;
         png_read_row(png_ptr, NULL, dptr);
         dp++;
      }
}
#endif /* SEQUENTIAL_READ */

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the entire image.  If the image has an alpha channel or a tRNS
 * chunk, and you have called png_handle_alpha()[*], you will need to
 * initialize the image to the current image that PNG will be overlaying.
 * We set the num_rows again here, in case it was incorrectly set in
 * png_read_start_row() by a call to png_read_update_info() or
 * png_start_read_image() if png_set_interlace_handling() wasn't called
 * prior to either of these functions like it should have been.  You can
 * only call this function once.  If you desire to have an image for
 * each pass of a interlaced image, use png_read_rows() instead.
 *
 * [*] png_handle_alpha() does not exist yet, as of this version of libpng
 */
void PNGAPI
png_read_image(png_structrp png_ptr, png_bytepp image)
{
   png_uint_32 i, image_height;
   int pass, j;
   png_bytepp rp;

   png_debug(1, "in png_read_image");

   if (png_ptr == NULL)
      return;

#ifdef PNG_READ_INTERLACING_SUPPORTED
   if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
   {
      pass = png_set_interlace_handling(png_ptr);
      /* And make sure transforms are initialized. */
      png_start_read_image(png_ptr);
   }
   else
   {
      if (png_ptr->interlaced != 0 &&
          (png_ptr->transformations & PNG_INTERLACE) == 0)
      {
         /* Caller called png_start_read_image or png_read_update_info without
          * first turning on the PNG_INTERLACE transform.  We can fix this here,
          * but the caller should do it!
          */
         png_warning(png_ptr, "Interlace handling should be turned on when "
             "using png_read_image");
         /* Make sure this is set correctly */
         png_ptr->num_rows = png_ptr->height;
      }

      /* Obtain the pass number, which also turns on the PNG_INTERLACE flag in
       * the above error case.
       */
      pass = png_set_interlace_handling(png_ptr);
   }
#else
   if (png_ptr->interlaced)
      png_error(png_ptr,
          "Cannot read interlaced image -- interlace handler disabled");

   pass = 1;
#endif

   image_height=png_ptr->height;

   for (j = 0; j < pass; j++)
   {
      rp = image;
      for (i = 0; i < image_height; i++)
      {
         png_read_row(png_ptr, *rp, NULL);
         rp++;
      }
   }
}
#endif /* SEQUENTIAL_READ */

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
/* Read the end of the PNG file.  Will not read past the end of the
 * file, will verify the end is accurate, and will read any comments
 * or time information at the end of the file, if info is not NULL.
 */
void PNGAPI
png_read_end(png_structrp png_ptr, png_inforp info_ptr)
{
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
   int keep;
#endif

   png_debug(1, "in png_read_end");

   if (png_ptr == NULL)
      return;

   /* If png_read_end is called in the middle of reading the rows there may
    * still be pending IDAT data and an owned zstream.  Deal with this here.
    */
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
   if (png_chunk_unknown_handling(png_ptr, png_IDAT) == 0)
#endif
      png_read_finish_IDAT(png_ptr);

#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
   /* Report invalid palette index; added at libng-1.5.10 */
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
       png_ptr->num_palette_max > png_ptr->num_palette)
      png_benign_error(png_ptr, "Read palette index exceeding num_palette");
#endif

   do
   {
      png_uint_32 length = png_read_chunk_header(png_ptr);
      png_uint_32 chunk_name = png_ptr->chunk_name;

      if (chunk_name != png_IDAT)
         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;

      if (chunk_name == png_IEND)
         png_handle_IEND(png_ptr, info_ptr, length);

      else if (chunk_name == png_IHDR)
         png_handle_IHDR(png_ptr, info_ptr, length);

      else if (info_ptr == NULL)
         png_crc_finish(png_ptr, length);

#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
      else if ((keep = png_chunk_unknown_handling(png_ptr, chunk_name)) != 0)
      {
         if (chunk_name == png_IDAT)
         {
            if ((length > 0 && !(png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED))
                || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT) != 0)
               png_benign_error(png_ptr, ".Too many IDATs found");
         }
         png_handle_unknown(png_ptr, info_ptr, length, keep);
         if (chunk_name == png_PLTE)
            png_ptr->mode |= PNG_HAVE_PLTE;
      }
#endif

      else if (chunk_name == png_IDAT)
      {
         /* Zero length IDATs are legal after the last IDAT has been
          * read, but not after other chunks have been read.  1.6 does not
          * always read all the deflate data; specifically it cannot be relied
          * upon to read the Adler32 at the end.  If it doesn't ignore IDAT
          * chunks which are longer than zero as well:
          */
         if ((length > 0 && !(png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED))
             || (png_ptr->mode & PNG_HAVE_CHUNK_AFTER_IDAT) != 0)
            png_benign_error(png_ptr, "..Too many IDATs found");

         png_crc_finish(png_ptr, length);
      }
      else if (chunk_name == png_PLTE)
         png_handle_PLTE(png_ptr, info_ptr, length);

#ifdef PNG_READ_bKGD_SUPPORTED
      else if (chunk_name == png_bKGD)
         png_handle_bKGD(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_cHRM_SUPPORTED
      else if (chunk_name == png_cHRM)
         png_handle_cHRM(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_gAMA_SUPPORTED
      else if (chunk_name == png_gAMA)
         png_handle_gAMA(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_hIST_SUPPORTED
      else if (chunk_name == png_hIST)
         png_handle_hIST(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_oFFs_SUPPORTED
      else if (chunk_name == png_oFFs)
         png_handle_oFFs(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_pCAL_SUPPORTED
      else if (chunk_name == png_pCAL)
         png_handle_pCAL(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_sCAL_SUPPORTED
      else if (chunk_name == png_sCAL)
         png_handle_sCAL(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_pHYs_SUPPORTED
      else if (chunk_name == png_pHYs)
         png_handle_pHYs(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_sBIT_SUPPORTED
      else if (chunk_name == png_sBIT)
         png_handle_sBIT(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_sRGB_SUPPORTED
      else if (chunk_name == png_sRGB)
         png_handle_sRGB(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_iCCP_SUPPORTED
      else if (chunk_name == png_iCCP)
         png_handle_iCCP(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_sPLT_SUPPORTED
      else if (chunk_name == png_sPLT)
         png_handle_sPLT(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_tEXt_SUPPORTED
      else if (chunk_name == png_tEXt)
         png_handle_tEXt(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_tIME_SUPPORTED
      else if (chunk_name == png_tIME)
         png_handle_tIME(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_tRNS_SUPPORTED
      else if (chunk_name == png_tRNS)
         png_handle_tRNS(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_zTXt_SUPPORTED
      else if (chunk_name == png_zTXt)
         png_handle_zTXt(png_ptr, info_ptr, length);
#endif

#ifdef PNG_READ_iTXt_SUPPORTED
      else if (chunk_name == png_iTXt)
         png_handle_iTXt(png_ptr, info_ptr, length);
#endif

      else
         png_handle_unknown(png_ptr, info_ptr, length,
             PNG_HANDLE_CHUNK_AS_DEFAULT);
   } while ((png_ptr->mode & PNG_HAVE_IEND) == 0);
}
#endif /* SEQUENTIAL_READ */

/* Free all memory used in the read struct */
static void
png_read_destroy(png_structrp png_ptr)
{
   png_debug(1, "in png_read_destroy");

#ifdef PNG_READ_GAMMA_SUPPORTED
   png_destroy_gamma_table(png_ptr);
#endif

   png_free(png_ptr, png_ptr->big_row_buf);
   png_ptr->big_row_buf = NULL;
   png_free(png_ptr, png_ptr->big_prev_row);
   png_ptr->big_prev_row = NULL;
   png_free(png_ptr, png_ptr->read_buffer);
   png_ptr->read_buffer = NULL;

#ifdef PNG_READ_QUANTIZE_SUPPORTED
   png_free(png_ptr, png_ptr->palette_lookup);
   png_ptr->palette_lookup = NULL;
   png_free(png_ptr, png_ptr->quantize_index);
   png_ptr->quantize_index = NULL;
#endif

   if ((png_ptr->free_me & PNG_FREE_PLTE) != 0)
   {
      png_zfree(png_ptr, png_ptr->palette);
      png_ptr->palette = NULL;
   }
   png_ptr->free_me &= ~PNG_FREE_PLTE;

#if defined(PNG_tRNS_SUPPORTED) || \
    defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
   if ((png_ptr->free_me & PNG_FREE_TRNS) != 0)
   {
      png_free(png_ptr, png_ptr->trans_alpha);
      png_ptr->trans_alpha = NULL;
   }
   png_ptr->free_me &= ~PNG_FREE_TRNS;
#endif

   inflateEnd(&png_ptr->zstream);

#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
   png_free(png_ptr, png_ptr->save_buffer);
   png_ptr->save_buffer = NULL;
#endif

#if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) && \
   defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   png_free(png_ptr, png_ptr->unknown_chunk.data);
   png_ptr->unknown_chunk.data = NULL;
#endif

#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
   png_free(png_ptr, png_ptr->chunk_list);
   png_ptr->chunk_list = NULL;
#endif

   /* NOTE: the 'setjmp' buffer may still be allocated and the memory and error
    * callbacks are still set at this point.  They are required to complete the
    * destruction of the png_struct itself.
    */
}

/* Free all memory used by the read */
void PNGAPI
png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,
    png_infopp end_info_ptr_ptr)
{
   png_structrp png_ptr = NULL;

   png_debug(1, "in png_destroy_read_struct");

   if (png_ptr_ptr != NULL)
      png_ptr = *png_ptr_ptr;

   if (png_ptr == NULL)
      return;

   /* libpng 1.6.0: use the API to destroy info structs to ensure consistent
    * behavior.  Prior to 1.6.0 libpng did extra 'info' destruction in this API.
    * The extra was, apparently, unnecessary yet this hides memory leak bugs.
    */
   png_destroy_info_struct(png_ptr, end_info_ptr_ptr);
   png_destroy_info_struct(png_ptr, info_ptr_ptr);

   *png_ptr_ptr = NULL;
   png_read_destroy(png_ptr);
   png_destroy_png_struct(png_ptr);
}

void PNGAPI
png_set_read_status_fn(png_structrp png_ptr, png_read_status_ptr read_row_fn)
{
   if (png_ptr == NULL)
      return;

   png_ptr->read_row_fn = read_row_fn;
}


#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
#ifdef PNG_INFO_IMAGE_SUPPORTED
void PNGAPI
png_read_png(png_structrp png_ptr, png_inforp info_ptr,
    int transforms, voidp params)
{
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   /* png_read_info() gives us all of the information from the
    * PNG file before the first IDAT (image data chunk).
    */
   png_read_info(png_ptr, info_ptr);
   if (info_ptr->height > PNG_UINT_32_MAX/(sizeof (png_bytep)))
      png_error(png_ptr, "Image is too high to process with png_read_png()");

   /* -------------- image transformations start here ------------------- */
   /* libpng 1.6.10: add code to cause a png_app_error if a selected TRANSFORM
    * is not implemented.  This will only happen in de-configured (non-default)
    * libpng builds.  The results can be unexpected - png_read_png may return
    * short or mal-formed rows because the transform is skipped.
    */

   /* Tell libpng to strip 16-bit/color files down to 8 bits per color.
    */
   if ((transforms & PNG_TRANSFORM_SCALE_16) != 0)
      /* Added at libpng-1.5.4. "strip_16" produces the same result that it
       * did in earlier versions, while "scale_16" is now more accurate.
       */
#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
      png_set_scale_16(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_SCALE_16 not supported");
#endif

   /* If both SCALE and STRIP are required pngrtran will effectively cancel the
    * latter by doing SCALE first.  This is ok and allows apps not to check for
    * which is supported to get the right answer.
    */
   if ((transforms & PNG_TRANSFORM_STRIP_16) != 0)
#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
      png_set_strip_16(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_STRIP_16 not supported");
#endif

   /* Strip alpha bytes from the input data without combining with
    * the background (not recommended).
    */
   if ((transforms & PNG_TRANSFORM_STRIP_ALPHA) != 0)
#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
      png_set_strip_alpha(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_STRIP_ALPHA not supported");
#endif

   /* Extract multiple pixels with bit depths of 1, 2, or 4 from a single
    * byte into separate bytes (useful for paletted and grayscale images).
    */
   if ((transforms & PNG_TRANSFORM_PACKING) != 0)
#ifdef PNG_READ_PACK_SUPPORTED
      png_set_packing(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_PACKING not supported");
#endif

   /* Change the order of packed pixels to least significant bit first
    * (not useful if you are using png_set_packing).
    */
   if ((transforms & PNG_TRANSFORM_PACKSWAP) != 0)
#ifdef PNG_READ_PACKSWAP_SUPPORTED
      png_set_packswap(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_PACKSWAP not supported");
#endif

   /* Expand paletted colors into true RGB triplets
    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
    * Expand paletted or RGB images with transparency to full alpha
    * channels so the data will be available as RGBA quartets.
    */
   if ((transforms & PNG_TRANSFORM_EXPAND) != 0)
#ifdef PNG_READ_EXPAND_SUPPORTED
      png_set_expand(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_EXPAND not supported");
#endif

   /* We don't handle background color or gamma transformation or quantizing.
    */

   /* Invert monochrome files to have 0 as white and 1 as black
    */
   if ((transforms & PNG_TRANSFORM_INVERT_MONO) != 0)
#ifdef PNG_READ_INVERT_SUPPORTED
      png_set_invert_mono(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_INVERT_MONO not supported");
#endif

   /* If you want to shift the pixel values from the range [0,255] or
    * [0,65535] to the original [0,7] or [0,31], or whatever range the
    * colors were originally in:
    */
   if ((transforms & PNG_TRANSFORM_SHIFT) != 0)
#ifdef PNG_READ_SHIFT_SUPPORTED
      if ((info_ptr->valid & PNG_INFO_sBIT) != 0)
         png_set_shift(png_ptr, &info_ptr->sig_bit);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_SHIFT not supported");
#endif

   /* Flip the RGB pixels to BGR (or RGBA to BGRA) */
   if ((transforms & PNG_TRANSFORM_BGR) != 0)
#ifdef PNG_READ_BGR_SUPPORTED
      png_set_bgr(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_BGR not supported");
#endif

   /* Swap the RGBA or GA data to ARGB or AG (or BGRA to ABGR) */
   if ((transforms & PNG_TRANSFORM_SWAP_ALPHA) != 0)
#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
      png_set_swap_alpha(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_SWAP_ALPHA not supported");
#endif

   /* Swap bytes of 16-bit files to least significant byte first */
   if ((transforms & PNG_TRANSFORM_SWAP_ENDIAN) != 0)
#ifdef PNG_READ_SWAP_SUPPORTED
      png_set_swap(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_SWAP_ENDIAN not supported");
#endif

/* Added at libpng-1.2.41 */
   /* Invert the alpha channel from opacity to transparency */
   if ((transforms & PNG_TRANSFORM_INVERT_ALPHA) != 0)
#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
      png_set_invert_alpha(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_INVERT_ALPHA not supported");
#endif

/* Added at libpng-1.2.41 */
   /* Expand grayscale image to RGB */
   if ((transforms & PNG_TRANSFORM_GRAY_TO_RGB) != 0)
#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
      png_set_gray_to_rgb(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_GRAY_TO_RGB not supported");
#endif

/* Added at libpng-1.5.4 */
   if ((transforms & PNG_TRANSFORM_EXPAND_16) != 0)
#ifdef PNG_READ_EXPAND_16_SUPPORTED
      png_set_expand_16(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_EXPAND_16 not supported");
#endif

   /* We don't handle adding filler bytes */

   /* We use png_read_image and rely on that for interlace handling, but we also
    * call png_read_update_info therefore must turn on interlace handling now:
    */
   (void)png_set_interlace_handling(png_ptr);

   /* Optional call to gamma correct and add the background to the palette
    * and update info structure.  REQUIRED if you are expecting libpng to
    * update the palette for you (i.e., you selected such a transform above).
    */
   png_read_update_info(png_ptr, info_ptr);

   /* -------------- image transformations end here ------------------- */

   png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);
   if (info_ptr->row_pointers == NULL)
   {
      png_uint_32 iptr;

      info_ptr->row_pointers = png_voidcast(png_bytepp, png_malloc(png_ptr,
          info_ptr->height * (sizeof (png_bytep))));

      for (iptr=0; iptr<info_ptr->height; iptr++)
         info_ptr->row_pointers[iptr] = NULL;

      info_ptr->free_me |= PNG_FREE_ROWS;

      for (iptr = 0; iptr < info_ptr->height; iptr++)
         info_ptr->row_pointers[iptr] = png_voidcast(png_bytep,
             png_malloc(png_ptr, info_ptr->rowbytes));
   }

   png_read_image(png_ptr, info_ptr->row_pointers);
   info_ptr->valid |= PNG_INFO_IDAT;

   /* Read rest of file, and get additional chunks in info_ptr - REQUIRED */
   png_read_end(png_ptr, info_ptr);

   PNG_UNUSED(params)
}
#endif /* INFO_IMAGE */
#endif /* SEQUENTIAL_READ */

#ifdef PNG_SIMPLIFIED_READ_SUPPORTED
/* SIMPLIFIED READ
 *
 * This code currently relies on the sequential reader, though it could easily
 * be made to work with the progressive one.
 */
/* Arguments to png_image_finish_read: */

/* Encoding of PNG data (used by the color-map code) */
#  define P_NOTSET  0 /* File encoding not yet known */
#  define P_sRGB    1 /* 8-bit encoded to sRGB gamma */
#  define P_LINEAR  2 /* 16-bit linear: not encoded, NOT pre-multiplied! */
#  define P_FILE    3 /* 8-bit encoded to file gamma, not sRGB or linear */
#  define P_LINEAR8 4 /* 8-bit linear: only from a file value */

/* Color-map processing: after libpng has run on the PNG image further
 * processing may be needed to convert the data to color-map indices.
 */
#define PNG_CMAP_NONE      0
#define PNG_CMAP_GA        1 /* Process GA data to a color-map with alpha */
#define PNG_CMAP_TRANS     2 /* Process GA data to a background index */
#define PNG_CMAP_RGB       3 /* Process RGB data */
#define PNG_CMAP_RGB_ALPHA 4 /* Process RGBA data */

/* The following document where the background is for each processing case. */
#define PNG_CMAP_NONE_BACKGROUND      256
#define PNG_CMAP_GA_BACKGROUND        231
#define PNG_CMAP_TRANS_BACKGROUND     254
#define PNG_CMAP_RGB_BACKGROUND       256
#define PNG_CMAP_RGB_ALPHA_BACKGROUND 216

typedef struct
{
   /* Arguments: */
   png_imagep image;
   png_voidp  buffer;
   png_int_32 row_stride;
   png_voidp  colormap;
   png_const_colorp background;
   /* Local variables: */
   png_voidp       local_row;
   png_voidp       first_row;
   ptrdiff_t       row_bytes;           /* step between rows */
   int             file_encoding;       /* E_ values above */
   png_fixed_point gamma_to_linear;     /* For P_FILE, reciprocal of gamma */
   int             colormap_processing; /* PNG_CMAP_ values above */
} png_image_read_control;

/* Do all the *safe* initialization - 'safe' means that png_error won't be
 * called, so setting up the jmp_buf is not required.  This means that anything
 * called from here must *not* call png_malloc - it has to call png_malloc_warn
 * instead so that control is returned safely back to this routine.
 */
static int
png_image_read_init(png_imagep image)
{
   if (image->opaque == NULL)
   {
      png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, image,
          png_safe_error, png_safe_warning);

      /* And set the rest of the structure to NULL to ensure that the various
       * fields are consistent.
       */
      memset(image, 0, (sizeof *image));
      image->version = PNG_IMAGE_VERSION;

      if (png_ptr != NULL)
      {
         png_infop info_ptr = png_create_info_struct(png_ptr);

         if (info_ptr != NULL)
         {
            png_controlp control = png_voidcast(png_controlp,
                png_malloc_warn(png_ptr, (sizeof *control)));

            if (control != NULL)
            {
               memset(control, 0, (sizeof *control));

               control->png_ptr = png_ptr;
               control->info_ptr = info_ptr;
               control->for_write = 0;

               image->opaque = control;
               return 1;
            }

            /* Error clean up */
            png_destroy_info_struct(png_ptr, &info_ptr);
         }

         png_destroy_read_struct(&png_ptr, NULL, NULL);
      }

      return png_image_error(image, "png_image_read: out of memory");
   }

   return png_image_error(image, "png_image_read: opaque pointer not NULL");
}

/* Utility to find the base format of a PNG file from a png_struct. */
static png_uint_32
png_image_format(png_structrp png_ptr)
{
   png_uint_32 format = 0;

   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
      format |= PNG_FORMAT_FLAG_COLOR;

   if ((png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
      format |= PNG_FORMAT_FLAG_ALPHA;

   /* Use png_ptr here, not info_ptr, because by examination png_handle_tRNS
    * sets the png_struct fields; that's all we are interested in here.  The
    * precise interaction with an app call to png_set_tRNS and PNG file reading
    * is unclear.
    */
   else if (png_ptr->num_trans > 0)
      format |= PNG_FORMAT_FLAG_ALPHA;

   if (png_ptr->bit_depth == 16)
      format |= PNG_FORMAT_FLAG_LINEAR;

   if ((png_ptr->color_type & PNG_COLOR_MASK_PALETTE) != 0)
      format |= PNG_FORMAT_FLAG_COLORMAP;

   return format;
}

/* Is the given gamma significantly different from sRGB?  The test is the same
 * one used in pngrtran.c when deciding whether to do gamma correction.  The
 * arithmetic optimizes the division by using the fact that the inverse of the
 * file sRGB gamma is 2.2
 */
static int
png_gamma_not_sRGB(png_fixed_point g)
{
   if (g < PNG_FP_1)
   {
      /* An uninitialized gamma is assumed to be sRGB for the simplified API. */
      if (g == 0)
         return 0;

      return png_gamma_significant((g * 11 + 2)/5 /* i.e. *2.2, rounded */);
   }

   return 1;
}

/* Do the main body of a 'png_image_begin_read' function; read the PNG file
 * header and fill in all the information.  This is executed in a safe context,
 * unlike the init routine above.
 */
static int
png_image_read_header(png_voidp argument)
{
   png_imagep image = png_voidcast(png_imagep, argument);
   png_structrp png_ptr = image->opaque->png_ptr;
   png_inforp info_ptr = image->opaque->info_ptr;

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
   png_set_benign_errors(png_ptr, 1/*warn*/);
#endif
   png_read_info(png_ptr, info_ptr);

   /* Do this the fast way; just read directly out of png_struct. */
   image->width = png_ptr->width;
   image->height = png_ptr->height;

   {
      png_uint_32 format = png_image_format(png_ptr);

      image->format = format;

#ifdef PNG_COLORSPACE_SUPPORTED
      /* Does the colorspace match sRGB?  If there is no color endpoint
       * (colorant) information assume yes, otherwise require the
       * 'ENDPOINTS_MATCHP_sRGB' colorspace flag to have been set.  If the
       * colorspace has been determined to be invalid ignore it.
       */
      if ((format & PNG_FORMAT_FLAG_COLOR) != 0 && ((png_ptr->colorspace.flags
         & (PNG_COLORSPACE_HAVE_ENDPOINTS|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB|
            PNG_COLORSPACE_INVALID)) == PNG_COLORSPACE_HAVE_ENDPOINTS))
         image->flags |= PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB;
#endif
   }

   /* We need the maximum number of entries regardless of the format the
    * application sets here.
    */
   {
      png_uint_32 cmap_entries;

      switch (png_ptr->color_type)
      {
         case PNG_COLOR_TYPE_GRAY:
            cmap_entries = 1U << png_ptr->bit_depth;
            break;

         case PNG_COLOR_TYPE_PALETTE:
            cmap_entries = (png_uint_32)png_ptr->num_palette;
            break;

         default:
            cmap_entries = 256;
            break;
      }

      if (cmap_entries > 256)
         cmap_entries = 256;

      image->colormap_entries = cmap_entries;
   }

   return 1;
}

#ifdef PNG_STDIO_SUPPORTED
int PNGAPI
png_image_begin_read_from_stdio(png_imagep image, FILE* file)
{
   if (image != NULL && image->version == PNG_IMAGE_VERSION)
   {
      if (file != NULL)
      {
         if (png_image_read_init(image) != 0)
         {
            /* This is slightly evil, but png_init_io doesn't do anything other
             * than this and we haven't changed the standard IO functions so
             * this saves a 'safe' function.
             */
            image->opaque->png_ptr->io_ptr = file;
            return png_safe_execute(image, png_image_read_header, image);
         }
      }

      else
         return png_image_error(image,
             "png_image_begin_read_from_stdio: invalid argument");
   }

   else if (image != NULL)
      return png_image_error(image,
          "png_image_begin_read_from_stdio: incorrect PNG_IMAGE_VERSION");

   return 0;
}

int PNGAPI
png_image_begin_read_from_file(png_imagep image, const char *file_name)
{
   if (image != NULL && image->version == PNG_IMAGE_VERSION)
   {
      if (file_name != NULL)
      {
         FILE *fp = fopen(file_name, "rb");

         if (fp != NULL)
         {
            if (png_image_read_init(image) != 0)
            {
               image->opaque->png_ptr->io_ptr = fp;
               image->opaque->owned_file = 1;
               return png_safe_execute(image, png_image_read_header, image);
            }

            /* Clean up: just the opened file. */
            (void)fclose(fp);
         }

         else
            return png_image_error(image, strerror(errno));
      }

      else
         return png_image_error(image,
             "png_image_begin_read_from_file: invalid argument");
   }

   else if (image != NULL)
      return png_image_error(image,
          "png_image_begin_read_from_file: incorrect PNG_IMAGE_VERSION");

   return 0;
}
#endif /* STDIO */

static void PNGCBAPI
png_image_memory_read(png_structp png_ptr, png_bytep out, png_size_t need)
{
   if (png_ptr != NULL)
   {
      png_imagep image = png_voidcast(png_imagep, png_ptr->io_ptr);
      if (image != NULL)
      {
         png_controlp cp = image->opaque;
         if (cp != NULL)
         {
            png_const_bytep memory = cp->memory;
            png_size_t size = cp->size;

            if (memory != NULL && size >= need)
            {
               memcpy(out, memory, need);
               cp->memory = memory + need;
               cp->size = size - need;
               return;
            }

            png_error(png_ptr, "read beyond end of data");
         }
      }

      png_error(png_ptr, "invalid memory read");
   }
}

int PNGAPI png_image_begin_read_from_memory(png_imagep image,
    png_const_voidp memory, png_size_t size)
{
   if (image != NULL && image->version == PNG_IMAGE_VERSION)
   {
      if (memory != NULL && size > 0)
      {
         if (png_image_read_init(image) != 0)
         {
            /* Now set the IO functions to read from the memory buffer and
             * store it into io_ptr.  Again do this in-place to avoid calling a
             * libpng function that requires error handling.
             */
            image->opaque->memory = png_voidcast(png_const_bytep, memory);
            image->opaque->size = size;
            image->opaque->png_ptr->io_ptr = image;
            image->opaque->png_ptr->read_data_fn = png_image_memory_read;

            return png_safe_execute(image, png_image_read_header, image);
         }
      }

      else
         return png_image_error(image,
             "png_image_begin_read_from_memory: invalid argument");
   }

   else if (image != NULL)
      return png_image_error(image,
          "png_image_begin_read_from_memory: incorrect PNG_IMAGE_VERSION");

   return 0;
}

/* Utility function to skip chunks that are not used by the simplified image
 * read functions and an appropriate macro to call it.
 */
#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
static void
png_image_skip_unused_chunks(png_structrp png_ptr)
{
   /* Prepare the reader to ignore all recognized chunks whose data will not
    * be used, i.e., all chunks recognized by libpng except for those
    * involved in basic image reading:
    *
    *    IHDR, PLTE, IDAT, IEND
    *
    * Or image data handling:
    *
    *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.
    *
    * This provides a small performance improvement and eliminates any
    * potential vulnerability to security problems in the unused chunks.
    *
    * At present the iCCP chunk data isn't used, so iCCP chunk can be ignored
    * too.  This allows the simplified API to be compiled without iCCP support,
    * however if the support is there the chunk is still checked to detect
    * errors (which are unfortunately quite common.)
    */
   {
         static PNG_CONST png_byte chunks_to_process[] = {
            98,  75,  71,  68, '\0',  /* bKGD */
            99,  72,  82,  77, '\0',  /* cHRM */
           103,  65,  77,  65, '\0',  /* gAMA */
#        ifdef PNG_READ_iCCP_SUPPORTED
           105,  67,  67,  80, '\0',  /* iCCP */
#        endif
           115,  66,  73,  84, '\0',  /* sBIT */
           115,  82,  71,  66, '\0',  /* sRGB */
           };

       /* Ignore unknown chunks and all other chunks except for the
        * IHDR, PLTE, tRNS, IDAT, and IEND chunks.
        */
       png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_NEVER,
           NULL, -1);

       /* But do not ignore image data handling chunks */
       png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,
           chunks_to_process, (int)/*SAFE*/(sizeof chunks_to_process)/5);
   }
}

#  define PNG_SKIP_CHUNKS(p) png_image_skip_unused_chunks(p)
#else
#  define PNG_SKIP_CHUNKS(p) ((void)0)
#endif /* HANDLE_AS_UNKNOWN */

/* The following macro gives the exact rounded answer for all values in the
 * range 0..255 (it actually divides by 51.2, but the rounding still generates
 * the correct numbers 0..5
 */
#define PNG_DIV51(v8) (((v8) * 5 + 130) >> 8)

/* Utility functions to make particular color-maps */
static void
set_file_encoding(png_image_read_control *display)
{
   png_fixed_point g = display->image->opaque->png_ptr->colorspace.gamma;
   if (png_gamma_significant(g) != 0)
   {
      if (png_gamma_not_sRGB(g) != 0)
      {
         display->file_encoding = P_FILE;
         display->gamma_to_linear = png_reciprocal(g);
      }

      else
         display->file_encoding = P_sRGB;
   }

   else
      display->file_encoding = P_LINEAR8;
}

static unsigned int
decode_gamma(png_image_read_control *display, png_uint_32 value, int encoding)
{
   if (encoding == P_FILE) /* double check */
      encoding = display->file_encoding;

   if (encoding == P_NOTSET) /* must be the file encoding */
   {
      set_file_encoding(display);
      encoding = display->file_encoding;
   }

   switch (encoding)
   {
      case P_FILE:
         value = png_gamma_16bit_correct(value*257, display->gamma_to_linear);
         break;

      case P_sRGB:
         value = png_sRGB_table[value];
         break;

      case P_LINEAR:
         break;

      case P_LINEAR8:
         value *= 257;
         break;

#ifdef __GNUC__
      default:
         png_error(display->image->opaque->png_ptr,
             "unexpected encoding (internal error)");
#endif
   }

   return value;
}

static png_uint_32
png_colormap_compose(png_image_read_control *display,
    png_uint_32 foreground, int foreground_encoding, png_uint_32 alpha,
    png_uint_32 background, int encoding)
{
   /* The file value is composed on the background, the background has the given
    * encoding and so does the result, the file is encoded with P_FILE and the
    * file and alpha are 8-bit values.  The (output) encoding will always be
    * P_LINEAR or P_sRGB.
    */
   png_uint_32 f = decode_gamma(display, foreground, foreground_encoding);
   png_uint_32 b = decode_gamma(display, background, encoding);

   /* The alpha is always an 8-bit value (it comes from the palette), the value
    * scaled by 255 is what PNG_sRGB_FROM_LINEAR requires.
    */
   f = f * alpha + b * (255-alpha);

   if (encoding == P_LINEAR)
   {
      /* Scale to 65535; divide by 255, approximately (in fact this is extremely
       * accurate, it divides by 255.00000005937181414556, with no overflow.)
       */
      f *= 257; /* Now scaled by 65535 */
      f += f >> 16;
      f = (f+32768) >> 16;
   }

   else /* P_sRGB */
      f = PNG_sRGB_FROM_LINEAR(f);

   return f;
}

/* NOTE: P_LINEAR values to this routine must be 16-bit, but P_FILE values must
 * be 8-bit.
 */
static void
png_create_colormap_entry(png_image_read_control *display,
    png_uint_32 ip, png_uint_32 red, png_uint_32 green, png_uint_32 blue,
    png_uint_32 alpha, int encoding)
{
   png_imagep image = display->image;
   const int output_encoding = (image->format & PNG_FORMAT_FLAG_LINEAR) != 0 ?
       P_LINEAR : P_sRGB;
   const int convert_to_Y = (image->format & PNG_FORMAT_FLAG_COLOR) == 0 &&
       (red != green || green != blue);

   if (ip > 255)
      png_error(image->opaque->png_ptr, "color-map index out of range");

   /* Update the cache with whether the file gamma is significantly different
    * from sRGB.
    */
   if (encoding == P_FILE)
   {
      if (display->file_encoding == P_NOTSET)
         set_file_encoding(display);

      /* Note that the cached value may be P_FILE too, but if it is then the
       * gamma_to_linear member has been set.
       */
      encoding = display->file_encoding;
   }

   if (encoding == P_FILE)
   {
      png_fixed_point g = display->gamma_to_linear;

      red = png_gamma_16bit_correct(red*257, g);
      green = png_gamma_16bit_correct(green*257, g);
      blue = png_gamma_16bit_correct(blue*257, g);

      if (convert_to_Y != 0 || output_encoding == P_LINEAR)
      {
         alpha *= 257;
         encoding = P_LINEAR;
      }

      else
      {
         red = PNG_sRGB_FROM_LINEAR(red * 255);
         green = PNG_sRGB_FROM_LINEAR(green * 255);
         blue = PNG_sRGB_FROM_LINEAR(blue * 255);
         encoding = P_sRGB;
      }
   }

   else if (encoding == P_LINEAR8)
   {
      /* This encoding occurs quite frequently in test cases because PngSuite
       * includes a gAMA 1.0 chunk with most images.
       */
      red *= 257;
      green *= 257;
      blue *= 257;
      alpha *= 257;
      encoding = P_LINEAR;
   }

   else if (encoding == P_sRGB &&
       (convert_to_Y  != 0 || output_encoding == P_LINEAR))
   {
      /* The values are 8-bit sRGB values, but must be converted to 16-bit
       * linear.
       */
      red = png_sRGB_table[red];
      green = png_sRGB_table[green];
      blue = png_sRGB_table[blue];
      alpha *= 257;
      encoding = P_LINEAR;
   }

   /* This is set if the color isn't gray but the output is. */
   if (encoding == P_LINEAR)
   {
      if (convert_to_Y != 0)
      {
         /* NOTE: these values are copied from png_do_rgb_to_gray */
         png_uint_32 y = (png_uint_32)6968 * red  + (png_uint_32)23434 * green +
            (png_uint_32)2366 * blue;

         if (output_encoding == P_LINEAR)
            y = (y + 16384) >> 15;

         else
         {
            /* y is scaled by 32768, we need it scaled by 255: */
            y = (y + 128) >> 8;
            y *= 255;
            y = PNG_sRGB_FROM_LINEAR((y + 64) >> 7);
            alpha = PNG_DIV257(alpha);
            encoding = P_sRGB;
         }

         blue = red = green = y;
      }

      else if (output_encoding == P_sRGB)
      {
         red = PNG_sRGB_FROM_LINEAR(red * 255);
         green = PNG_sRGB_FROM_LINEAR(green * 255);
         blue = PNG_sRGB_FROM_LINEAR(blue * 255);
         alpha = PNG_DIV257(alpha);
         encoding = P_sRGB;
      }
   }

   if (encoding != output_encoding)
      png_error(image->opaque->png_ptr, "bad encoding (internal error)");

   /* Store the value. */
   {
#     ifdef PNG_FORMAT_AFIRST_SUPPORTED
         const int afirst = (image->format & PNG_FORMAT_FLAG_AFIRST) != 0 &&
            (image->format & PNG_FORMAT_FLAG_ALPHA) != 0;
#     else
#        define afirst 0
#     endif
#     ifdef PNG_FORMAT_BGR_SUPPORTED
         const int bgr = (image->format & PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;
#     else
#        define bgr 0
#     endif

      if (output_encoding == P_LINEAR)
      {
         png_uint_16p entry = png_voidcast(png_uint_16p, display->colormap);

         entry += ip * PNG_IMAGE_SAMPLE_CHANNELS(image->format);

         /* The linear 16-bit values must be pre-multiplied by the alpha channel
          * value, if less than 65535 (this is, effectively, composite on black
          * if the alpha channel is removed.)
          */
         switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
         {
            case 4:
               entry[afirst ? 0 : 3] = (png_uint_16)alpha;
               /* FALL THROUGH */

            case 3:
               if (alpha < 65535)
               {
                  if (alpha > 0)
                  {
                     blue = (blue * alpha + 32767U)/65535U;
                     green = (green * alpha + 32767U)/65535U;
                     red = (red * alpha + 32767U)/65535U;
                  }

                  else
                     red = green = blue = 0;
               }
               entry[afirst + (2 ^ bgr)] = (png_uint_16)blue;
               entry[afirst + 1] = (png_uint_16)green;
               entry[afirst + bgr] = (png_uint_16)red;
               break;

            case 2:
               entry[1 ^ afirst] = (png_uint_16)alpha;
               /* FALL THROUGH */

            case 1:
               if (alpha < 65535)
               {
                  if (alpha > 0)
                     green = (green * alpha + 32767U)/65535U;

                  else
                     green = 0;
               }
               entry[afirst] = (png_uint_16)green;
               break;

            default:
               break;
         }
      }

      else /* output encoding is P_sRGB */
      {
         png_bytep entry = png_voidcast(png_bytep, display->colormap);

         entry += ip * PNG_IMAGE_SAMPLE_CHANNELS(image->format);

         switch (PNG_IMAGE_SAMPLE_CHANNELS(image->format))
         {
            case 4:
               entry[afirst ? 0 : 3] = (png_byte)alpha;
            case 3:
               entry[afirst + (2 ^ bgr)] = (png_byte)blue;
               entry[afirst + 1] = (png_byte)green;
               entry[afirst + bgr] = (png_byte)red;
               break;

            case 2:
               entry[1 ^ afirst] = (png_byte)alpha;
            case 1:
               entry[afirst] = (png_byte)green;
               break;

            default:
               break;
         }
      }

#     ifdef afirst
#        undef afirst
#     endif
#     ifdef bgr
#        undef bgr
#     endif
   }
}

static int
make_gray_file_colormap(png_image_read_control *display)
{
   unsigned int i;

   for (i=0; i<256; ++i)
      png_create_colormap_entry(display, i, i, i, i, 255, P_FILE);

   return (int)i;
}

static int
make_gray_colormap(png_image_read_control *display)
{
   unsigned int i;

   for (i=0; i<256; ++i)
      png_create_colormap_entry(display, i, i, i, i, 255, P_sRGB);

   return (int)i;
}
#define PNG_GRAY_COLORMAP_ENTRIES 256

static int
make_ga_colormap(png_image_read_control *display)
{
   unsigned int i, a;

   /* Alpha is retained, the output will be a color-map with entries
    * selected by six levels of alpha.  One transparent entry, 6 gray
    * levels for all the intermediate alpha values, leaving 230 entries
    * for the opaque grays.  The color-map entries are the six values
    * [0..5]*51, the GA processing uses PNG_DIV51(value) to find the
    * relevant entry.
    *
    * if (alpha > 229) // opaque
    * {
    *    // The 231 entries are selected to make the math below work:
    *    base = 0;
    *    entry = (231 * gray + 128) >> 8;
    * }
    * else if (alpha < 26) // transparent
    * {
    *    base = 231;
    *    entry = 0;
    * }
    * else // partially opaque
    * {
    *    base = 226 + 6 * PNG_DIV51(alpha);
    *    entry = PNG_DIV51(gray);
    * }
    */
   i = 0;
   while (i < 231)
   {
      unsigned int gray = (i * 256 + 115) / 231;
      png_create_colormap_entry(display, i++, gray, gray, gray, 255, P_sRGB);
   }

   /* 255 is used here for the component values for consistency with the code
    * that undoes premultiplication in pngwrite.c.
    */
   png_create_colormap_entry(display, i++, 255, 255, 255, 0, P_sRGB);

   for (a=1; a<5; ++a)
   {
      unsigned int g;

      for (g=0; g<6; ++g)
         png_create_colormap_entry(display, i++, g*51, g*51, g*51, a*51,
             P_sRGB);
   }

   return (int)i;
}

#define PNG_GA_COLORMAP_ENTRIES 256

static int
make_rgb_colormap(png_image_read_control *display)
{
   unsigned int i, r;

   /* Build a 6x6x6 opaque RGB cube */
   for (i=r=0; r<6; ++r)
   {
      unsigned int g;

      for (g=0; g<6; ++g)
      {
         unsigned int b;

         for (b=0; b<6; ++b)
            png_create_colormap_entry(display, i++, r*51, g*51, b*51, 255,
                P_sRGB);
      }
   }

   return (int)i;
}

#define PNG_RGB_COLORMAP_ENTRIES 216

/* Return a palette index to the above palette given three 8-bit sRGB values. */
#define PNG_RGB_INDEX(r,g,b) \
   ((png_byte)(6 * (6 * PNG_DIV51(r) + PNG_DIV51(g)) + PNG_DIV51(b)))

static int
png_image_read_colormap(png_voidp argument)
{
   png_image_read_control *display =
      png_voidcast(png_image_read_control*, argument);
   const png_imagep image = display->image;

   const png_structrp png_ptr = image->opaque->png_ptr;
   const png_uint_32 output_format = image->format;
   const int output_encoding = (output_format & PNG_FORMAT_FLAG_LINEAR) != 0 ?
      P_LINEAR : P_sRGB;

   unsigned int cmap_entries;
   unsigned int output_processing;        /* Output processing option */
   unsigned int data_encoding = P_NOTSET; /* Encoding libpng must produce */

   /* Background information; the background color and the index of this color
    * in the color-map if it exists (else 256).
    */
   unsigned int background_index = 256;
   png_uint_32 back_r, back_g, back_b;

   /* Flags to accumulate things that need to be done to the input. */
   int expand_tRNS = 0;

   /* Exclude the NYI feature of compositing onto a color-mapped buffer; it is
    * very difficult to do, the results look awful, and it is difficult to see
    * what possible use it is because the application can't control the
    * color-map.
    */
   if (((png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0 ||
         png_ptr->num_trans > 0) /* alpha in input */ &&
      ((output_format & PNG_FORMAT_FLAG_ALPHA) == 0) /* no alpha in output */)
   {
      if (output_encoding == P_LINEAR) /* compose on black */
         back_b = back_g = back_r = 0;

      else if (display->background == NULL /* no way to remove it */)
         png_error(png_ptr,
             "background color must be supplied to remove alpha/transparency");

      /* Get a copy of the background color (this avoids repeating the checks
       * below.)  The encoding is 8-bit sRGB or 16-bit linear, depending on the
       * output format.
       */
      else
      {
         back_g = display->background->green;
         if ((output_format & PNG_FORMAT_FLAG_COLOR) != 0)
         {
            back_r = display->background->red;
            back_b = display->background->blue;
         }
         else
            back_b = back_r = back_g;
      }
   }

   else if (output_encoding == P_LINEAR)
      back_b = back_r = back_g = 65535;

   else
      back_b = back_r = back_g = 255;

   /* Default the input file gamma if required - this is necessary because
    * libpng assumes that if no gamma information is present the data is in the
    * output format, but the simplified API deduces the gamma from the input
    * format.
    */
   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) == 0)
   {
      /* Do this directly, not using the png_colorspace functions, to ensure
       * that it happens even if the colorspace is invalid (though probably if
       * it is the setting will be ignored)  Note that the same thing can be
       * achieved at the application interface with png_set_gAMA.
       */
      if (png_ptr->bit_depth == 16 &&
         (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)
         png_ptr->colorspace.gamma = PNG_GAMMA_LINEAR;

      else
         png_ptr->colorspace.gamma = PNG_GAMMA_sRGB_INVERSE;

      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;
   }

   /* Decide what to do based on the PNG color type of the input data.  The
    * utility function png_create_colormap_entry deals with most aspects of the
    * output transformations; this code works out how to produce bytes of
    * color-map entries from the original format.
    */
   switch (png_ptr->color_type)
   {
      case PNG_COLOR_TYPE_GRAY:
         if (png_ptr->bit_depth <= 8)
         {
            /* There at most 256 colors in the output, regardless of
             * transparency.
             */
            unsigned int step, i, val, trans = 256/*ignore*/, back_alpha = 0;

            cmap_entries = 1U << png_ptr->bit_depth;
            if (cmap_entries > image->colormap_entries)
               png_error(png_ptr, "gray[8] color-map: too few entries");

            step = 255 / (cmap_entries - 1);
            output_processing = PNG_CMAP_NONE;

            /* If there is a tRNS chunk then this either selects a transparent
             * value or, if the output has no alpha, the background color.
             */
            if (png_ptr->num_trans > 0)
            {
               trans = png_ptr->trans_color.gray;

               if ((output_format & PNG_FORMAT_FLAG_ALPHA) == 0)
                  back_alpha = output_encoding == P_LINEAR ? 65535 : 255;
            }

            /* png_create_colormap_entry just takes an RGBA and writes the
             * corresponding color-map entry using the format from 'image',
             * including the required conversion to sRGB or linear as
             * appropriate.  The input values are always either sRGB (if the
             * gamma correction flag is 0) or 0..255 scaled file encoded values
             * (if the function must gamma correct them).
             */
            for (i=val=0; i<cmap_entries; ++i, val += step)
            {
               /* 'i' is a file value.  While this will result in duplicated
                * entries for 8-bit non-sRGB encoded files it is necessary to
                * have non-gamma corrected values to do tRNS handling.
                */
               if (i != trans)
                  png_create_colormap_entry(display, i, val, val, val, 255,
                      P_FILE/*8-bit with file gamma*/);

               /* Else this entry is transparent.  The colors don't matter if
                * there is an alpha channel (back_alpha == 0), but it does no
                * harm to pass them in; the values are not set above so this
                * passes in white.
                *
                * NOTE: this preserves the full precision of the application
                * supplied background color when it is used.
                */
               else
                  png_create_colormap_entry(display, i, back_r, back_g, back_b,
                      back_alpha, output_encoding);
            }

            /* We need libpng to preserve the original encoding. */
            data_encoding = P_FILE;

            /* The rows from libpng, while technically gray values, are now also
             * color-map indices; however, they may need to be expanded to 1
             * byte per pixel.  This is what png_set_packing does (i.e., it
             * unpacks the bit values into bytes.)
             */
            if (png_ptr->bit_depth < 8)
               png_set_packing(png_ptr);
         }

         else /* bit depth is 16 */
         {
            /* The 16-bit input values can be converted directly to 8-bit gamma
             * encoded values; however, if a tRNS chunk is present 257 color-map
             * entries are required.  This means that the extra entry requires
             * special processing; add an alpha channel, sacrifice gray level
             * 254 and convert transparent (alpha==0) entries to that.
             *
             * Use libpng to chop the data to 8 bits.  Convert it to sRGB at the
             * same time to minimize quality loss.  If a tRNS chunk is present
             * this means libpng must handle it too; otherwise it is impossible
             * to do the exact match on the 16-bit value.
             *
             * If the output has no alpha channel *and* the background color is
             * gray then it is possible to let libpng handle the substitution by
             * ensuring that the corresponding gray level matches the background
             * color exactly.
             */
            data_encoding = P_sRGB;

            if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)
               png_error(png_ptr, "gray[16] color-map: too few entries");

            cmap_entries = (unsigned int)make_gray_colormap(display);

            if (png_ptr->num_trans > 0)
            {
               unsigned int back_alpha;

               if ((output_format & PNG_FORMAT_FLAG_ALPHA) != 0)
                  back_alpha = 0;

               else
               {
                  if (back_r == back_g && back_g == back_b)
                  {
                     /* Background is gray; no special processing will be
                      * required.
                      */
                     png_color_16 c;
                     png_uint_32 gray = back_g;

                     if (output_encoding == P_LINEAR)
                     {
                        gray = PNG_sRGB_FROM_LINEAR(gray * 255);

                        /* And make sure the corresponding palette entry
                         * matches.
                         */
                        png_create_colormap_entry(display, gray, back_g, back_g,
                            back_g, 65535, P_LINEAR);
                     }

                     /* The background passed to libpng, however, must be the
                      * sRGB value.
                      */
                     c.index = 0; /*unused*/
                     c.gray = c.red = c.green = c.blue = (png_uint_16)gray;

                     /* NOTE: does this work without expanding tRNS to alpha?
                      * It should be the color->gray case below apparently
                      * doesn't.
                      */
                     png_set_background_fixed(png_ptr, &c,
                         PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
                         0/*gamma: not used*/);

                     output_processing = PNG_CMAP_NONE;
                     break;
                  }
#ifdef __COVERITY__
                 /* Coverity claims that output_encoding cannot be 2 (P_LINEAR)
                  * here.
                  */
                  back_alpha = 255;
#else
                  back_alpha = output_encoding == P_LINEAR ? 65535 : 255;
#endif
               }

               /* output_processing means that the libpng-processed row will be
                * 8-bit GA and it has to be processing to single byte color-map
                * values.  Entry 254 is replaced by either a completely
                * transparent entry or by the background color at full
                * precision (and the background color is not a simple gray
                * level in this case.)
                */
               expand_tRNS = 1;
               output_processing = PNG_CMAP_TRANS;
               background_index = 254;

               /* And set (overwrite) color-map entry 254 to the actual
                * background color at full precision.
                */
               png_create_colormap_entry(display, 254, back_r, back_g, back_b,
                   back_alpha, output_encoding);
            }

            else
               output_processing = PNG_CMAP_NONE;
         }
         break;

      case PNG_COLOR_TYPE_GRAY_ALPHA:
         /* 8-bit or 16-bit PNG with two channels - gray and alpha.  A minimum
          * of 65536 combinations.  If, however, the alpha channel is to be
          * removed there are only 256 possibilities if the background is gray.
          * (Otherwise there is a subset of the 65536 possibilities defined by
          * the triangle between black, white and the background color.)
          *
          * Reduce 16-bit files to 8-bit and sRGB encode the result.  No need to
          * worry about tRNS matching - tRNS is ignored if there is an alpha
          * channel.
          */
         data_encoding = P_sRGB;

         if ((output_format & PNG_FORMAT_FLAG_ALPHA) != 0)
         {
            if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)
               png_error(png_ptr, "gray+alpha color-map: too few entries");

            cmap_entries = (unsigned int)make_ga_colormap(display);

            background_index = PNG_CMAP_GA_BACKGROUND;
            output_processing = PNG_CMAP_GA;
         }

         else /* alpha is removed */
         {
            /* Alpha must be removed as the PNG data is processed when the
             * background is a color because the G and A channels are
             * independent and the vector addition (non-parallel vectors) is a
             * 2-D problem.
             *
             * This can be reduced to the same algorithm as above by making a
             * colormap containing gray levels (for the opaque grays), a
             * background entry (for a transparent pixel) and a set of four six
             * level color values, one set for each intermediate alpha value.
             * See the comments in make_ga_colormap for how this works in the
             * per-pixel processing.
             *
             * If the background is gray, however, we only need a 256 entry gray
             * level color map.  It is sufficient to make the entry generated
             * for the background color be exactly the color specified.
             */
            if ((output_format & PNG_FORMAT_FLAG_COLOR) == 0 ||
               (back_r == back_g && back_g == back_b))
            {
               /* Background is gray; no special processing will be required. */
               png_color_16 c;
               png_uint_32 gray = back_g;

               if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)
                  png_error(png_ptr, "gray-alpha color-map: too few entries");

               cmap_entries = (unsigned int)make_gray_colormap(display);

               if (output_encoding == P_LINEAR)
               {
                  gray = PNG_sRGB_FROM_LINEAR(gray * 255);

                  /* And make sure the corresponding palette entry matches. */
                  png_create_colormap_entry(display, gray, back_g, back_g,
                      back_g, 65535, P_LINEAR);
               }

               /* The background passed to libpng, however, must be the sRGB
                * value.
                */
               c.index = 0; /*unused*/
               c.gray = c.red = c.green = c.blue = (png_uint_16)gray;

               png_set_background_fixed(png_ptr, &c,
                   PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
                   0/*gamma: not used*/);

               output_processing = PNG_CMAP_NONE;
            }

            else
            {
               png_uint_32 i, a;

               /* This is the same as png_make_ga_colormap, above, except that
                * the entries are all opaque.
                */
               if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)
                  png_error(png_ptr, "ga-alpha color-map: too few entries");

               i = 0;
               while (i < 231)
               {
                  png_uint_32 gray = (i * 256 + 115) / 231;
                  png_create_colormap_entry(display, i++, gray, gray, gray,
                      255, P_sRGB);
               }

               /* NOTE: this preserves the full precision of the application
                * background color.
                */
               background_index = i;
               png_create_colormap_entry(display, i++, back_r, back_g, back_b,
#ifdef __COVERITY__
                   /* Coverity claims that output_encoding
                    * cannot be 2 (P_LINEAR) here.
                    */ 255U,
#else
                    output_encoding == P_LINEAR ? 65535U : 255U,
#endif
                    output_encoding);

               /* For non-opaque input composite on the sRGB background - this
                * requires inverting the encoding for each component.  The input
                * is still converted to the sRGB encoding because this is a
                * reasonable approximate to the logarithmic curve of human
                * visual sensitivity, at least over the narrow range which PNG
                * represents.  Consequently 'G' is always sRGB encoded, while
                * 'A' is linear.  We need the linear background colors.
                */
               if (output_encoding == P_sRGB) /* else already linear */
               {
                  /* This may produce a value not exactly matching the
                   * background, but that's ok because these numbers are only
                   * used when alpha != 0
                   */
                  back_r = png_sRGB_table[back_r];
                  back_g = png_sRGB_table[back_g];
                  back_b = png_sRGB_table[back_b];
               }

               for (a=1; a<5; ++a)
               {
                  unsigned int g;

                  /* PNG_sRGB_FROM_LINEAR expects a 16-bit linear value scaled
                   * by an 8-bit alpha value (0..255).
                   */
                  png_uint_32 alpha = 51 * a;
                  png_uint_32 back_rx = (255-alpha) * back_r;
                  png_uint_32 back_gx = (255-alpha) * back_g;
                  png_uint_32 back_bx = (255-alpha) * back_b;

                  for (g=0; g<6; ++g)
                  {
                     png_uint_32 gray = png_sRGB_table[g*51] * alpha;

                     png_create_colormap_entry(display, i++,
                         PNG_sRGB_FROM_LINEAR(gray + back_rx),
                         PNG_sRGB_FROM_LINEAR(gray + back_gx),
                         PNG_sRGB_FROM_LINEAR(gray + back_bx), 255, P_sRGB);
                  }
               }

               cmap_entries = i;
               output_processing = PNG_CMAP_GA;
            }
         }
         break;

      case PNG_COLOR_TYPE_RGB:
      case PNG_COLOR_TYPE_RGB_ALPHA:
         /* Exclude the case where the output is gray; we can always handle this
          * with the cases above.
          */
         if ((output_format & PNG_FORMAT_FLAG_COLOR) == 0)
         {
            /* The color-map will be grayscale, so we may as well convert the
             * input RGB values to a simple grayscale and use the grayscale
             * code above.
             *
             * NOTE: calling this apparently damages the recognition of the
             * transparent color in background color handling; call
             * png_set_tRNS_to_alpha before png_set_background_fixed.
             */
            png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE, -1,
                -1);
            data_encoding = P_sRGB;

            /* The output will now be one or two 8-bit gray or gray+alpha
             * channels.  The more complex case arises when the input has alpha.
             */
            if ((png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
               png_ptr->num_trans > 0) &&
               (output_format & PNG_FORMAT_FLAG_ALPHA) != 0)
            {
               /* Both input and output have an alpha channel, so no background
                * processing is required; just map the GA bytes to the right
                * color-map entry.
                */
               expand_tRNS = 1;

               if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)
                  png_error(png_ptr, "rgb[ga] color-map: too few entries");

               cmap_entries = (unsigned int)make_ga_colormap(display);
               background_index = PNG_CMAP_GA_BACKGROUND;
               output_processing = PNG_CMAP_GA;
            }

            else
            {
               /* Either the input or the output has no alpha channel, so there
                * will be no non-opaque pixels in the color-map; it will just be
                * grayscale.
                */
               if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)
                  png_error(png_ptr, "rgb[gray] color-map: too few entries");

               /* Ideally this code would use libpng to do the gamma correction,
                * but if an input alpha channel is to be removed we will hit the
                * libpng bug in gamma+compose+rgb-to-gray (the double gamma
                * correction bug).  Fix this by dropping the gamma correction in
                * this case and doing it in the palette; this will result in
                * duplicate palette entries, but that's better than the
                * alternative of double gamma correction.
                */
               if ((png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
                  png_ptr->num_trans > 0) &&
                  png_gamma_not_sRGB(png_ptr->colorspace.gamma) != 0)
               {
                  cmap_entries = (unsigned int)make_gray_file_colormap(display);
                  data_encoding = P_FILE;
               }

               else
                  cmap_entries = (unsigned int)make_gray_colormap(display);

               /* But if the input has alpha or transparency it must be removed
                */
               if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
                  png_ptr->num_trans > 0)
               {
                  png_color_16 c;
                  png_uint_32 gray = back_g;

                  /* We need to ensure that the application background exists in
                   * the colormap and that completely transparent pixels map to
                   * it.  Achieve this simply by ensuring that the entry
                   * selected for the background really is the background color.
                   */
                  if (data_encoding == P_FILE) /* from the fixup above */
                  {
                     /* The app supplied a gray which is in output_encoding, we
                      * need to convert it to a value of the input (P_FILE)
                      * encoding then set this palette entry to the required
                      * output encoding.
                      */
                     if (output_encoding == P_sRGB)
                        gray = png_sRGB_table[gray]; /* now P_LINEAR */

                     gray = PNG_DIV257(png_gamma_16bit_correct(gray,
                         png_ptr->colorspace.gamma)); /* now P_FILE */

                     /* And make sure the corresponding palette entry contains
                      * exactly the required sRGB value.
                      */
                     png_create_colormap_entry(display, gray, back_g, back_g,
                         back_g, 0/*unused*/, output_encoding);
                  }

                  else if (output_encoding == P_LINEAR)
                  {
                     gray = PNG_sRGB_FROM_LINEAR(gray * 255);

                     /* And make sure the corresponding palette entry matches.
                      */
                     png_create_colormap_entry(display, gray, back_g, back_g,
                        back_g, 0/*unused*/, P_LINEAR);
                  }

                  /* The background passed to libpng, however, must be the
                   * output (normally sRGB) value.
                   */
                  c.index = 0; /*unused*/
                  c.gray = c.red = c.green = c.blue = (png_uint_16)gray;

                  /* NOTE: the following is apparently a bug in libpng. Without
                   * it the transparent color recognition in
                   * png_set_background_fixed seems to go wrong.
                   */
                  expand_tRNS = 1;
                  png_set_background_fixed(png_ptr, &c,
                      PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
                      0/*gamma: not used*/);
               }

               output_processing = PNG_CMAP_NONE;
            }
         }

         else /* output is color */
         {
            /* We could use png_quantize here so long as there is no transparent
             * color or alpha; png_quantize ignores alpha.  Easier overall just
             * to do it once and using PNG_DIV51 on the 6x6x6 reduced RGB cube.
             * Consequently we always want libpng to produce sRGB data.
             */
            data_encoding = P_sRGB;

            /* Is there any transparency or alpha? */
            if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
               png_ptr->num_trans > 0)
            {
               /* Is there alpha in the output too?  If so all four channels are
                * processed into a special RGB cube with alpha support.
                */
               if ((output_format & PNG_FORMAT_FLAG_ALPHA) != 0)
               {
                  png_uint_32 r;

                  if (PNG_RGB_COLORMAP_ENTRIES+1+27 > image->colormap_entries)
                     png_error(png_ptr, "rgb+alpha color-map: too few entries");

                  cmap_entries = (unsigned int)make_rgb_colormap(display);

                  /* Add a transparent entry. */
                  png_create_colormap_entry(display, cmap_entries, 255, 255,
                      255, 0, P_sRGB);

                  /* This is stored as the background index for the processing
                   * algorithm.
                   */
                  background_index = cmap_entries++;

                  /* Add 27 r,g,b entries each with alpha 0.5. */
                  for (r=0; r<256; r = (r << 1) | 0x7f)
                  {
                     png_uint_32 g;

                     for (g=0; g<256; g = (g << 1) | 0x7f)
                     {
                        png_uint_32 b;

                        /* This generates components with the values 0, 127 and
                         * 255
                         */
                        for (b=0; b<256; b = (b << 1) | 0x7f)
                           png_create_colormap_entry(display, cmap_entries++,
                               r, g, b, 128, P_sRGB);
                     }
                  }

                  expand_tRNS = 1;
                  output_processing = PNG_CMAP_RGB_ALPHA;
               }

               else
               {
                  /* Alpha/transparency must be removed.  The background must
                   * exist in the color map (achieved by setting adding it after
                   * the 666 color-map).  If the standard processing code will
                   * pick up this entry automatically that's all that is
                   * required; libpng can be called to do the background
                   * processing.
                   */
                  unsigned int sample_size =
                     PNG_IMAGE_SAMPLE_SIZE(output_format);
                  png_uint_32 r, g, b; /* sRGB background */

                  if (PNG_RGB_COLORMAP_ENTRIES+1+27 > image->colormap_entries)
                     png_error(png_ptr, "rgb-alpha color-map: too few entries");

                  cmap_entries = (unsigned int)make_rgb_colormap(display);

                  png_create_colormap_entry(display, cmap_entries, back_r,
                      back_g, back_b, 0/*unused*/, output_encoding);

                  if (output_encoding == P_LINEAR)
                  {
                     r = PNG_sRGB_FROM_LINEAR(back_r * 255);
                     g = PNG_sRGB_FROM_LINEAR(back_g * 255);
                     b = PNG_sRGB_FROM_LINEAR(back_b * 255);
                  }

                  else
                  {
                     r = back_r;
                     g = back_g;
                     b = back_g;
                  }

                  /* Compare the newly-created color-map entry with the one the
                   * PNG_CMAP_RGB algorithm will use.  If the two entries don't
                   * match, add the new one and set this as the background
                   * index.
                   */
                  if (memcmp((png_const_bytep)display->colormap +
                      sample_size * cmap_entries,
                      (png_const_bytep)display->colormap +
                          sample_size * PNG_RGB_INDEX(r,g,b),
                     sample_size) != 0)
                  {
                     /* The background color must be added. */
                     background_index = cmap_entries++;

                     /* Add 27 r,g,b entries each with created by composing with
                      * the background at alpha 0.5.
                      */
                     for (r=0; r<256; r = (r << 1) | 0x7f)
                     {
                        for (g=0; g<256; g = (g << 1) | 0x7f)
                        {
                           /* This generates components with the values 0, 127
                            * and 255
                            */
                           for (b=0; b<256; b = (b << 1) | 0x7f)
                              png_create_colormap_entry(display, cmap_entries++,
                                  png_colormap_compose(display, r, P_sRGB, 128,
                                      back_r, output_encoding),
                                  png_colormap_compose(display, g, P_sRGB, 128,
                                      back_g, output_encoding),
                                  png_colormap_compose(display, b, P_sRGB, 128,
                                      back_b, output_encoding),
                                  0/*unused*/, output_encoding);
                        }
                     }

                     expand_tRNS = 1;
                     output_processing = PNG_CMAP_RGB_ALPHA;
                  }

                  else /* background color is in the standard color-map */
                  {
                     png_color_16 c;

                     c.index = 0; /*unused*/
                     c.red = (png_uint_16)back_r;
                     c.gray = c.green = (png_uint_16)back_g;
                     c.blue = (png_uint_16)back_b;

                     png_set_background_fixed(png_ptr, &c,
                         PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
                         0/*gamma: not used*/);

                     output_processing = PNG_CMAP_RGB;
                  }
               }
            }

            else /* no alpha or transparency in the input */
            {
               /* Alpha in the output is irrelevant, simply map the opaque input
                * pixels to the 6x6x6 color-map.
                */
               if (PNG_RGB_COLORMAP_ENTRIES > image->colormap_entries)
                  png_error(png_ptr, "rgb color-map: too few entries");

               cmap_entries = (unsigned int)make_rgb_colormap(display);
               output_processing = PNG_CMAP_RGB;
            }
         }
         break;

      case PNG_COLOR_TYPE_PALETTE:
         /* It's already got a color-map.  It may be necessary to eliminate the
          * tRNS entries though.
          */
         {
            unsigned int num_trans = png_ptr->num_trans;
            png_const_bytep trans = num_trans > 0 ? png_ptr->trans_alpha : NULL;
            png_const_colorp colormap = png_ptr->palette;
            const int do_background = trans != NULL &&
               (output_format & PNG_FORMAT_FLAG_ALPHA) == 0;
            unsigned int i;

            /* Just in case: */
            if (trans == NULL)
               num_trans = 0;

            output_processing = PNG_CMAP_NONE;
            data_encoding = P_FILE; /* Don't change from color-map indices */
            cmap_entries = (unsigned int)png_ptr->num_palette;
            if (cmap_entries > 256)
               cmap_entries = 256;

            if (cmap_entries > (unsigned int)image->colormap_entries)
               png_error(png_ptr, "palette color-map: too few entries");

            for (i=0; i < cmap_entries; ++i)
            {
               if (do_background != 0 && i < num_trans && trans[i] < 255)
               {
                  if (trans[i] == 0)
                     png_create_colormap_entry(display, i, back_r, back_g,
                         back_b, 0, output_encoding);

                  else
                  {
                     /* Must compose the PNG file color in the color-map entry
                      * on the sRGB color in 'back'.
                      */
                     png_create_colormap_entry(display, i,
                         png_colormap_compose(display, colormap[i].red,
                             P_FILE, trans[i], back_r, output_encoding),
                         png_colormap_compose(display, colormap[i].green,
                             P_FILE, trans[i], back_g, output_encoding),
                         png_colormap_compose(display, colormap[i].blue,
                             P_FILE, trans[i], back_b, output_encoding),
                         output_encoding == P_LINEAR ? trans[i] * 257U :
                             trans[i],
                         output_encoding);
                  }
               }

               else
                  png_create_colormap_entry(display, i, colormap[i].red,
                      colormap[i].green, colormap[i].blue,
                      i < num_trans ? trans[i] : 255U, P_FILE/*8-bit*/);
            }

            /* The PNG data may have indices packed in fewer than 8 bits, it
             * must be expanded if so.
             */
            if (png_ptr->bit_depth < 8)
               png_set_packing(png_ptr);
         }
         break;

      default:
         png_error(png_ptr, "invalid PNG color type");
         /*NOT REACHED*/
   }

   /* Now deal with the output processing */
   if (expand_tRNS != 0 && png_ptr->num_trans > 0 &&
       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) == 0)
      png_set_tRNS_to_alpha(png_ptr);

   switch (data_encoding)
   {
      case P_sRGB:
         /* Change to 8-bit sRGB */
         png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, PNG_GAMMA_sRGB);
         /* FALL THROUGH */

      case P_FILE:
         if (png_ptr->bit_depth > 8)
            png_set_scale_16(png_ptr);
         break;

#ifdef __GNUC__
      default:
         png_error(png_ptr, "bad data option (internal error)");
#endif
   }

   if (cmap_entries > 256 || cmap_entries > image->colormap_entries)
      png_error(png_ptr, "color map overflow (BAD internal error)");

   image->colormap_entries = cmap_entries;

   /* Double check using the recorded background index */
   switch (output_processing)
   {
      case PNG_CMAP_NONE:
         if (background_index != PNG_CMAP_NONE_BACKGROUND)
            goto bad_background;
         break;

      case PNG_CMAP_GA:
         if (background_index != PNG_CMAP_GA_BACKGROUND)
            goto bad_background;
         break;

      case PNG_CMAP_TRANS:
         if (background_index >= cmap_entries ||
            background_index != PNG_CMAP_TRANS_BACKGROUND)
            goto bad_background;
         break;

      case PNG_CMAP_RGB:
         if (background_index != PNG_CMAP_RGB_BACKGROUND)
            goto bad_background;
         break;

      case PNG_CMAP_RGB_ALPHA:
         if (background_index != PNG_CMAP_RGB_ALPHA_BACKGROUND)
            goto bad_background;
         break;

      default:
         png_error(png_ptr, "bad processing option (internal error)");

      bad_background:
         png_error(png_ptr, "bad background index (internal error)");
   }

   display->colormap_processing = (int)output_processing;

   return 1/*ok*/;
}

/* The final part of the color-map read called from png_image_finish_read. */
static int
png_image_read_and_map(png_voidp argument)
{
   png_image_read_control *display = png_voidcast(png_image_read_control*,
       argument);
   png_imagep image = display->image;
   png_structrp png_ptr = image->opaque->png_ptr;
   int passes;

   /* Called when the libpng data must be transformed into the color-mapped
    * form.  There is a local row buffer in display->local and this routine must
    * do the interlace handling.
    */
   switch (png_ptr->interlaced)
   {
      case PNG_INTERLACE_NONE:
         passes = 1;
         break;

      case PNG_INTERLACE_ADAM7:
         passes = PNG_INTERLACE_ADAM7_PASSES;
         break;

      default:
         png_error(png_ptr, "unknown interlace type");
   }

   {
      png_uint_32  height = image->height;
      png_uint_32  width = image->width;
      int          proc = display->colormap_processing;
      png_bytep    first_row = png_voidcast(png_bytep, display->first_row);
      ptrdiff_t    step_row = display->row_bytes;
      int pass;

      for (pass = 0; pass < passes; ++pass)
      {
         unsigned int     startx, stepx, stepy;
         png_uint_32      y;

         if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)
         {
            /* The row may be empty for a short image: */
            if (PNG_PASS_COLS(width, pass) == 0)
               continue;

            startx = PNG_PASS_START_COL(pass);
            stepx = PNG_PASS_COL_OFFSET(pass);
            y = PNG_PASS_START_ROW(pass);
            stepy = PNG_PASS_ROW_OFFSET(pass);
         }

         else
         {
            y = 0;
            startx = 0;
            stepx = stepy = 1;
         }

         for (; y<height; y += stepy)
         {
            png_bytep inrow = png_voidcast(png_bytep, display->local_row);
            png_bytep outrow = first_row + y * step_row;
            png_const_bytep end_row = outrow + width;

            /* Read read the libpng data into the temporary buffer. */
            png_read_row(png_ptr, inrow, NULL);

            /* Now process the row according to the processing option, note
             * that the caller verifies that the format of the libpng output
             * data is as required.
             */
            outrow += startx;
            switch (proc)
            {
               case PNG_CMAP_GA:
                  for (; outrow < end_row; outrow += stepx)
                  {
                     /* The data is always in the PNG order */
                     unsigned int gray = *inrow++;
                     unsigned int alpha = *inrow++;
                     unsigned int entry;

                     /* NOTE: this code is copied as a comment in
                      * make_ga_colormap above.  Please update the
                      * comment if you change this code!
                      */
                     if (alpha > 229) /* opaque */
                     {
                        entry = (231 * gray + 128) >> 8;
                     }
                     else if (alpha < 26) /* transparent */
                     {
                        entry = 231;
                     }
                     else /* partially opaque */
                     {
                        entry = 226 + 6 * PNG_DIV51(alpha) + PNG_DIV51(gray);
                     }

                     *outrow = (png_byte)entry;
                  }
                  break;

               case PNG_CMAP_TRANS:
                  for (; outrow < end_row; outrow += stepx)
                  {
                     png_byte gray = *inrow++;
                     png_byte alpha = *inrow++;

                     if (alpha == 0)
                        *outrow = PNG_CMAP_TRANS_BACKGROUND;

                     else if (gray != PNG_CMAP_TRANS_BACKGROUND)
                        *outrow = gray;

                     else
                        *outrow = (png_byte)(PNG_CMAP_TRANS_BACKGROUND+1);
                  }
                  break;

               case PNG_CMAP_RGB:
                  for (; outrow < end_row; outrow += stepx)
                  {
                     *outrow = PNG_RGB_INDEX(inrow[0], inrow[1], inrow[2]);
                     inrow += 3;
                  }
                  break;

               case PNG_CMAP_RGB_ALPHA:
                  for (; outrow < end_row; outrow += stepx)
                  {
                     unsigned int alpha = inrow[3];

                     /* Because the alpha entries only hold alpha==0.5 values
                      * split the processing at alpha==0.25 (64) and 0.75
                      * (196).
                      */

                     if (alpha >= 196)
                        *outrow = PNG_RGB_INDEX(inrow[0], inrow[1],
                            inrow[2]);

                     else if (alpha < 64)
                        *outrow = PNG_CMAP_RGB_ALPHA_BACKGROUND;

                     else
                     {
                        /* Likewise there are three entries for each of r, g
                         * and b.  We could select the entry by popcount on
                         * the top two bits on those architectures that
                         * support it, this is what the code below does,
                         * crudely.
                         */
                        unsigned int back_i = PNG_CMAP_RGB_ALPHA_BACKGROUND+1;

                        /* Here are how the values map:
                         *
                         * 0x00 .. 0x3f -> 0
                         * 0x40 .. 0xbf -> 1
                         * 0xc0 .. 0xff -> 2
                         *
                         * So, as above with the explicit alpha checks, the
                         * breakpoints are at 64 and 196.
                         */
                        if (inrow[0] & 0x80) back_i += 9; /* red */
                        if (inrow[0] & 0x40) back_i += 9;
                        if (inrow[0] & 0x80) back_i += 3; /* green */
                        if (inrow[0] & 0x40) back_i += 3;
                        if (inrow[0] & 0x80) back_i += 1; /* blue */
                        if (inrow[0] & 0x40) back_i += 1;

                        *outrow = (png_byte)back_i;
                     }

                     inrow += 4;
                  }
                  break;

               default:
                  break;
            }
         }
      }
   }

   return 1;
}

static int
png_image_read_colormapped(png_voidp argument)
{
   png_image_read_control *display = png_voidcast(png_image_read_control*,
       argument);
   png_imagep image = display->image;
   png_controlp control = image->opaque;
   png_structrp png_ptr = control->png_ptr;
   png_inforp info_ptr = control->info_ptr;

   int passes = 0; /* As a flag */

   PNG_SKIP_CHUNKS(png_ptr);

   /* Update the 'info' structure and make sure the result is as required; first
    * make sure to turn on the interlace handling if it will be required
    * (because it can't be turned on *after* the call to png_read_update_info!)
    */
   if (display->colormap_processing == PNG_CMAP_NONE)
      passes = png_set_interlace_handling(png_ptr);

   png_read_update_info(png_ptr, info_ptr);

   /* The expected output can be deduced from the colormap_processing option. */
   switch (display->colormap_processing)
   {
      case PNG_CMAP_NONE:
         /* Output must be one channel and one byte per pixel, the output
          * encoding can be anything.
          */
         if ((info_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
            info_ptr->color_type == PNG_COLOR_TYPE_GRAY) &&
            info_ptr->bit_depth == 8)
            break;

         goto bad_output;

      case PNG_CMAP_TRANS:
      case PNG_CMAP_GA:
         /* Output must be two channels and the 'G' one must be sRGB, the latter
          * can be checked with an exact number because it should have been set
          * to this number above!
          */
         if (info_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
            info_ptr->bit_depth == 8 &&
            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&
            image->colormap_entries == 256)
            break;

         goto bad_output;

      case PNG_CMAP_RGB:
         /* Output must be 8-bit sRGB encoded RGB */
         if (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&
            info_ptr->bit_depth == 8 &&
            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&
            image->colormap_entries == 216)
            break;

         goto bad_output;

      case PNG_CMAP_RGB_ALPHA:
         /* Output must be 8-bit sRGB encoded RGBA */
         if (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
            info_ptr->bit_depth == 8 &&
            png_ptr->screen_gamma == PNG_GAMMA_sRGB &&
            image->colormap_entries == 244 /* 216 + 1 + 27 */)
            break;

         /* goto bad_output; */
         /* FALL THROUGH */

      default:
      bad_output:
         png_error(png_ptr, "bad color-map processing (internal error)");
   }

   /* Now read the rows.  Do this here if it is possible to read directly into
    * the output buffer, otherwise allocate a local row buffer of the maximum
    * size libpng requires and call the relevant processing routine safely.
    */
   {
      png_voidp first_row = display->buffer;
      ptrdiff_t row_bytes = display->row_stride;

      /* The following expression is designed to work correctly whether it gives
       * a signed or an unsigned result.
       */
      if (row_bytes < 0)
      {
         char *ptr = png_voidcast(char*, first_row);
         ptr += (image->height-1) * (-row_bytes);
         first_row = png_voidcast(png_voidp, ptr);
      }

      display->first_row = first_row;
      display->row_bytes = row_bytes;
   }

   if (passes == 0)
   {
      int result;
      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));

      display->local_row = row;
      result = png_safe_execute(image, png_image_read_and_map, display);
      display->local_row = NULL;
      png_free(png_ptr, row);

      return result;
   }

   else
   {
      png_alloc_size_t row_bytes = (png_alloc_size_t)display->row_bytes;

      while (--passes >= 0)
      {
         png_uint_32      y = image->height;
         png_bytep        row = png_voidcast(png_bytep, display->first_row);

         for (; y > 0; --y)
         {
            png_read_row(png_ptr, row, NULL);
            row += row_bytes;
         }
      }

      return 1;
   }
}

/* Just the row reading part of png_image_read. */
static int
png_image_read_composite(png_voidp argument)
{
   png_image_read_control *display = png_voidcast(png_image_read_control*,
       argument);
   png_imagep image = display->image;
   png_structrp png_ptr = image->opaque->png_ptr;
   int passes;

   switch (png_ptr->interlaced)
   {
      case PNG_INTERLACE_NONE:
         passes = 1;
         break;

      case PNG_INTERLACE_ADAM7:
         passes = PNG_INTERLACE_ADAM7_PASSES;
         break;

      default:
         png_error(png_ptr, "unknown interlace type");
   }

   {
      png_uint_32  height = image->height;
      png_uint_32  width = image->width;
      ptrdiff_t    step_row = display->row_bytes;
      unsigned int channels =
          (image->format & PNG_FORMAT_FLAG_COLOR) != 0 ? 3 : 1;
      int pass;

      for (pass = 0; pass < passes; ++pass)
      {
         unsigned int     startx, stepx, stepy;
         png_uint_32      y;

         if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)
         {
            /* The row may be empty for a short image: */
            if (PNG_PASS_COLS(width, pass) == 0)
               continue;

            startx = PNG_PASS_START_COL(pass) * channels;
            stepx = PNG_PASS_COL_OFFSET(pass) * channels;
            y = PNG_PASS_START_ROW(pass);
            stepy = PNG_PASS_ROW_OFFSET(pass);
         }

         else
         {
            y = 0;
            startx = 0;
            stepx = channels;
            stepy = 1;
         }

         for (; y<height; y += stepy)
         {
            png_bytep inrow = png_voidcast(png_bytep, display->local_row);
            png_bytep outrow;
            png_const_bytep end_row;

            /* Read the row, which is packed: */
            png_read_row(png_ptr, inrow, NULL);

            outrow = png_voidcast(png_bytep, display->first_row);
            outrow += y * step_row;
            end_row = outrow + width * channels;

            /* Now do the composition on each pixel in this row. */
            outrow += startx;
            for (; outrow < end_row; outrow += stepx)
            {
               png_byte alpha = inrow[channels];

               if (alpha > 0) /* else no change to the output */
               {
                  unsigned int c;

                  for (c=0; c<channels; ++c)
                  {
                     png_uint_32 component = inrow[c];

                     if (alpha < 255) /* else just use component */
                     {
                        /* This is PNG_OPTIMIZED_ALPHA, the component value
                         * is a linear 8-bit value.  Combine this with the
                         * current outrow[c] value which is sRGB encoded.
                         * Arithmetic here is 16-bits to preserve the output
                         * values correctly.
                         */
                        component *= 257*255; /* =65535 */
                        component += (255-alpha)*png_sRGB_table[outrow[c]];

                        /* So 'component' is scaled by 255*65535 and is
                         * therefore appropriate for the sRGB to linear
                         * conversion table.
                         */
                        component = PNG_sRGB_FROM_LINEAR(component);
                     }

                     outrow[c] = (png_byte)component;
                  }
               }

               inrow += channels+1; /* components and alpha channel */
            }
         }
      }
   }

   return 1;
}

/* The do_local_background case; called when all the following transforms are to
 * be done:
 *
 * PNG_RGB_TO_GRAY
 * PNG_COMPOSITE
 * PNG_GAMMA
 *
 * This is a work-around for the fact that both the PNG_RGB_TO_GRAY and
 * PNG_COMPOSITE code performs gamma correction, so we get double gamma
 * correction.  The fix-up is to prevent the PNG_COMPOSITE operation from
 * happening inside libpng, so this routine sees an 8 or 16-bit gray+alpha
 * row and handles the removal or pre-multiplication of the alpha channel.
 */
static int
png_image_read_background(png_voidp argument)
{
   png_image_read_control *display = png_voidcast(png_image_read_control*,
       argument);
   png_imagep image = display->image;
   png_structrp png_ptr = image->opaque->png_ptr;
   png_inforp info_ptr = image->opaque->info_ptr;
   png_uint_32 height = image->height;
   png_uint_32 width = image->width;
   int pass, passes;

   /* Double check the convoluted logic below.  We expect to get here with
    * libpng doing rgb to gray and gamma correction but background processing
    * left to the png_image_read_background function.  The rows libpng produce
    * might be 8 or 16-bit but should always have two channels; gray plus alpha.
    */
   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)
      png_error(png_ptr, "lost rgb to gray");

   if ((png_ptr->transformations & PNG_COMPOSE) != 0)
      png_error(png_ptr, "unexpected compose");

   if (png_get_channels(png_ptr, info_ptr) != 2)
      png_error(png_ptr, "lost/gained channels");

   /* Expect the 8-bit case to always remove the alpha channel */
   if ((image->format & PNG_FORMAT_FLAG_LINEAR) == 0 &&
      (image->format & PNG_FORMAT_FLAG_ALPHA) != 0)
      png_error(png_ptr, "unexpected 8-bit transformation");

   switch (png_ptr->interlaced)
   {
      case PNG_INTERLACE_NONE:
         passes = 1;
         break;

      case PNG_INTERLACE_ADAM7:
         passes = PNG_INTERLACE_ADAM7_PASSES;
         break;

      default:
         png_error(png_ptr, "unknown interlace type");
   }

   /* Use direct access to info_ptr here because otherwise the simplified API
    * would require PNG_EASY_ACCESS_SUPPORTED (just for this.)  Note this is
    * checking the value after libpng expansions, not the original value in the
    * PNG.
    */
   switch (info_ptr->bit_depth)
   {
      case 8:
         /* 8-bit sRGB gray values with an alpha channel; the alpha channel is
          * to be removed by composing on a background: either the row if
          * display->background is NULL or display->background->green if not.
          * Unlike the code above ALPHA_OPTIMIZED has *not* been done.
          */
         {
            png_bytep first_row = png_voidcast(png_bytep, display->first_row);
            ptrdiff_t step_row = display->row_bytes;

            for (pass = 0; pass < passes; ++pass)
            {
               png_bytep row = png_voidcast(png_bytep, display->first_row);
               unsigned int     startx, stepx, stepy;
               png_uint_32      y;

               if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)
               {
                  /* The row may be empty for a short image: */
                  if (PNG_PASS_COLS(width, pass) == 0)
                     continue;

                  startx = PNG_PASS_START_COL(pass);
                  stepx = PNG_PASS_COL_OFFSET(pass);
                  y = PNG_PASS_START_ROW(pass);
                  stepy = PNG_PASS_ROW_OFFSET(pass);
               }

               else
               {
                  y = 0;
                  startx = 0;
                  stepx = stepy = 1;
               }

               if (display->background == NULL)
               {
                  for (; y<height; y += stepy)
                  {
                     png_bytep inrow = png_voidcast(png_bytep,
                         display->local_row);
                     png_bytep outrow = first_row + y * step_row;
                     png_const_bytep end_row = outrow + width;

                     /* Read the row, which is packed: */
                     png_read_row(png_ptr, inrow, NULL);

                     /* Now do the composition on each pixel in this row. */
                     outrow += startx;
                     for (; outrow < end_row; outrow += stepx)
                     {
                        png_byte alpha = inrow[1];

                        if (alpha > 0) /* else no change to the output */
                        {
                           png_uint_32 component = inrow[0];

                           if (alpha < 255) /* else just use component */
                           {
                              /* Since PNG_OPTIMIZED_ALPHA was not set it is
                               * necessary to invert the sRGB transfer
                               * function and multiply the alpha out.
                               */
                              component = png_sRGB_table[component] * alpha;
                              component += png_sRGB_table[outrow[0]] *
                                 (255-alpha);
                              component = PNG_sRGB_FROM_LINEAR(component);
                           }

                           outrow[0] = (png_byte)component;
                        }

                        inrow += 2; /* gray and alpha channel */
                     }
                  }
               }

               else /* constant background value */
               {
                  png_byte background8 = display->background->green;
                  png_uint_16 background = png_sRGB_table[background8];

                  for (; y<height; y += stepy)
                  {
                     png_bytep inrow = png_voidcast(png_bytep,
                         display->local_row);
                     png_bytep outrow = first_row + y * step_row;
                     png_const_bytep end_row = outrow + width;

                     /* Read the row, which is packed: */
                     png_read_row(png_ptr, inrow, NULL);

                     /* Now do the composition on each pixel in this row. */
                     outrow += startx;
                     for (; outrow < end_row; outrow += stepx)
                     {
                        png_byte alpha = inrow[1];

                        if (alpha > 0) /* else use background */
                        {
                           png_uint_32 component = inrow[0];

                           if (alpha < 255) /* else just use component */
                           {
                              component = png_sRGB_table[component] * alpha;
                              component += background * (255-alpha);
                              component = PNG_sRGB_FROM_LINEAR(component);
                           }

                           outrow[0] = (png_byte)component;
                        }

                        else
                           outrow[0] = background8;

                        inrow += 2; /* gray and alpha channel */
                     }

                     row += display->row_bytes;
                  }
               }
            }
         }
         break;

      case 16:
         /* 16-bit linear with pre-multiplied alpha; the pre-multiplication must
          * still be done and, maybe, the alpha channel removed.  This code also
          * handles the alpha-first option.
          */
         {
            png_uint_16p first_row = png_voidcast(png_uint_16p,
                display->first_row);
            /* The division by two is safe because the caller passed in a
             * stride which was multiplied by 2 (below) to get row_bytes.
             */
            ptrdiff_t    step_row = display->row_bytes / 2;
            unsigned int preserve_alpha = (image->format &
                PNG_FORMAT_FLAG_ALPHA) != 0;
            unsigned int outchannels = 1U+preserve_alpha;
            int swap_alpha = 0;

#           ifdef PNG_SIMPLIFIED_READ_AFIRST_SUPPORTED
               if (preserve_alpha != 0 &&
                   (image->format & PNG_FORMAT_FLAG_AFIRST) != 0)
                  swap_alpha = 1;
#           endif

            for (pass = 0; pass < passes; ++pass)
            {
               unsigned int     startx, stepx, stepy;
               png_uint_32      y;

               /* The 'x' start and step are adjusted to output components here.
                */
               if (png_ptr->interlaced == PNG_INTERLACE_ADAM7)
               {
                  /* The row may be empty for a short image: */
                  if (PNG_PASS_COLS(width, pass) == 0)
                     continue;

                  startx = PNG_PASS_START_COL(pass) * outchannels;
                  stepx = PNG_PASS_COL_OFFSET(pass) * outchannels;
                  y = PNG_PASS_START_ROW(pass);
                  stepy = PNG_PASS_ROW_OFFSET(pass);
               }

               else
               {
                  y = 0;
                  startx = 0;
                  stepx = outchannels;
                  stepy = 1;
               }

               for (; y<height; y += stepy)
               {
                  png_const_uint_16p inrow;
                  png_uint_16p outrow = first_row + y*step_row;
                  png_uint_16p end_row = outrow + width * outchannels;

                  /* Read the row, which is packed: */
                  png_read_row(png_ptr, png_voidcast(png_bytep,
                      display->local_row), NULL);
                  inrow = png_voidcast(png_const_uint_16p, display->local_row);

                  /* Now do the pre-multiplication on each pixel in this row.
                   */
                  outrow += startx;
                  for (; outrow < end_row; outrow += stepx)
                  {
                     png_uint_32 component = inrow[0];
                     png_uint_16 alpha = inrow[1];

                     if (alpha > 0) /* else 0 */
                     {
                        if (alpha < 65535) /* else just use component */
                        {
                           component *= alpha;
                           component += 32767;
                           component /= 65535;
                        }
                     }

                     else
                        component = 0;

                     outrow[swap_alpha] = (png_uint_16)component;
                     if (preserve_alpha != 0)
                        outrow[1 ^ swap_alpha] = alpha;

                     inrow += 2; /* components and alpha channel */
                  }
               }
            }
         }
         break;

#ifdef __GNUC__
      default:
         png_error(png_ptr, "unexpected bit depth");
#endif
   }

   return 1;
}

/* The guts of png_image_finish_read as a png_safe_execute callback. */
static int
png_image_read_direct(png_voidp argument)
{
   png_image_read_control *display = png_voidcast(png_image_read_control*,
       argument);
   png_imagep image = display->image;
   png_structrp png_ptr = image->opaque->png_ptr;
   png_inforp info_ptr = image->opaque->info_ptr;

   png_uint_32 format = image->format;
   int linear = (format & PNG_FORMAT_FLAG_LINEAR) != 0;
   int do_local_compose = 0;
   int do_local_background = 0; /* to avoid double gamma correction bug */
   int passes = 0;

   /* Add transforms to ensure the correct output format is produced then check
    * that the required implementation support is there.  Always expand; always
    * need 8 bits minimum, no palette and expanded tRNS.
    */
   png_set_expand(png_ptr);

   /* Now check the format to see if it was modified. */
   {
      png_uint_32 base_format = png_image_format(png_ptr) &
         ~PNG_FORMAT_FLAG_COLORMAP /* removed by png_set_expand */;
      png_uint_32 change = format ^ base_format;
      png_fixed_point output_gamma;
      int mode; /* alpha mode */

      /* Do this first so that we have a record if rgb to gray is happening. */
      if ((change & PNG_FORMAT_FLAG_COLOR) != 0)
      {
         /* gray<->color transformation required. */
         if ((format & PNG_FORMAT_FLAG_COLOR) != 0)
            png_set_gray_to_rgb(png_ptr);

         else
         {
            /* libpng can't do both rgb to gray and
             * background/pre-multiplication if there is also significant gamma
             * correction, because both operations require linear colors and
             * the code only supports one transform doing the gamma correction.
             * Handle this by doing the pre-multiplication or background
             * operation in this code, if necessary.
             *
             * TODO: fix this by rewriting pngrtran.c (!)
             *
             * For the moment (given that fixing this in pngrtran.c is an
             * enormous change) 'do_local_background' is used to indicate that
             * the problem exists.
             */
            if ((base_format & PNG_FORMAT_FLAG_ALPHA) != 0)
               do_local_background = 1/*maybe*/;

            png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE,
                PNG_RGB_TO_GRAY_DEFAULT, PNG_RGB_TO_GRAY_DEFAULT);
         }

         change &= ~PNG_FORMAT_FLAG_COLOR;
      }

      /* Set the gamma appropriately, linear for 16-bit input, sRGB otherwise.
       */
      {
         png_fixed_point input_gamma_default;

         if ((base_format & PNG_FORMAT_FLAG_LINEAR) != 0 &&
             (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)
            input_gamma_default = PNG_GAMMA_LINEAR;
         else
            input_gamma_default = PNG_DEFAULT_sRGB;

         /* Call png_set_alpha_mode to set the default for the input gamma; the
          * output gamma is set by a second call below.
          */
         png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, input_gamma_default);
      }

      if (linear != 0)
      {
         /* If there *is* an alpha channel in the input it must be multiplied
          * out; use PNG_ALPHA_STANDARD, otherwise just use PNG_ALPHA_PNG.
          */
         if ((base_format & PNG_FORMAT_FLAG_ALPHA) != 0)
            mode = PNG_ALPHA_STANDARD; /* associated alpha */

         else
            mode = PNG_ALPHA_PNG;

         output_gamma = PNG_GAMMA_LINEAR;
      }

      else
      {
         mode = PNG_ALPHA_PNG;
         output_gamma = PNG_DEFAULT_sRGB;
      }

      /* If 'do_local_background' is set check for the presence of gamma
       * correction; this is part of the work-round for the libpng bug
       * described above.
       *
       * TODO: fix libpng and remove this.
       */
      if (do_local_background != 0)
      {
         png_fixed_point gtest;

         /* This is 'png_gamma_threshold' from pngrtran.c; the test used for
          * gamma correction, the screen gamma hasn't been set on png_struct
          * yet; it's set below.  png_struct::gamma, however, is set to the
          * final value.
          */
         if (png_muldiv(&gtest, output_gamma, png_ptr->colorspace.gamma,
             PNG_FP_1) != 0 && png_gamma_significant(gtest) == 0)
            do_local_background = 0;

         else if (mode == PNG_ALPHA_STANDARD)
         {
            do_local_background = 2/*required*/;
            mode = PNG_ALPHA_PNG; /* prevent libpng doing it */
         }

         /* else leave as 1 for the checks below */
      }

      /* If the bit-depth changes then handle that here. */
      if ((change & PNG_FORMAT_FLAG_LINEAR) != 0)
      {
         if (linear != 0 /*16-bit output*/)
            png_set_expand_16(png_ptr);

         else /* 8-bit output */
            png_set_scale_16(png_ptr);

         change &= ~PNG_FORMAT_FLAG_LINEAR;
      }

      /* Now the background/alpha channel changes. */
      if ((change & PNG_FORMAT_FLAG_ALPHA) != 0)
      {
         /* Removing an alpha channel requires composition for the 8-bit
          * formats; for the 16-bit it is already done, above, by the
          * pre-multiplication and the channel just needs to be stripped.
          */
         if ((base_format & PNG_FORMAT_FLAG_ALPHA) != 0)
         {
            /* If RGB->gray is happening the alpha channel must be left and the
             * operation completed locally.
             *
             * TODO: fix libpng and remove this.
             */
            if (do_local_background != 0)
               do_local_background = 2/*required*/;

            /* 16-bit output: just remove the channel */
            else if (linear != 0) /* compose on black (well, pre-multiply) */
               png_set_strip_alpha(png_ptr);

            /* 8-bit output: do an appropriate compose */
            else if (display->background != NULL)
            {
               png_color_16 c;

               c.index = 0; /*unused*/
               c.red = display->background->red;
               c.green = display->background->green;
               c.blue = display->background->blue;
               c.gray = display->background->green;

               /* This is always an 8-bit sRGB value, using the 'green' channel
                * for gray is much better than calculating the luminance here;
                * we can get off-by-one errors in that calculation relative to
                * the app expectations and that will show up in transparent
                * pixels.
                */
               png_set_background_fixed(png_ptr, &c,
                   PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
                   0/*gamma: not used*/);
            }

            else /* compose on row: implemented below. */
            {
               do_local_compose = 1;
               /* This leaves the alpha channel in the output, so it has to be
                * removed by the code below.  Set the encoding to the 'OPTIMIZE'
                * one so the code only has to hack on the pixels that require
                * composition.
                */
               mode = PNG_ALPHA_OPTIMIZED;
            }
         }

         else /* output needs an alpha channel */
         {
            /* This is tricky because it happens before the swap operation has
             * been accomplished; however, the swap does *not* swap the added
             * alpha channel (weird API), so it must be added in the correct
             * place.
             */
            png_uint_32 filler; /* opaque filler */
            int where;

            if (linear != 0)
               filler = 65535;

            else
               filler = 255;

#ifdef PNG_FORMAT_AFIRST_SUPPORTED
            if ((format & PNG_FORMAT_FLAG_AFIRST) != 0)
            {
               where = PNG_FILLER_BEFORE;
               change &= ~PNG_FORMAT_FLAG_AFIRST;
            }

            else
#endif
            where = PNG_FILLER_AFTER;

            png_set_add_alpha(png_ptr, filler, where);
         }

         /* This stops the (irrelevant) call to swap_alpha below. */
         change &= ~PNG_FORMAT_FLAG_ALPHA;
      }

      /* Now set the alpha mode correctly; this is always done, even if there is
       * no alpha channel in either the input or the output because it correctly
       * sets the output gamma.
       */
      png_set_alpha_mode_fixed(png_ptr, mode, output_gamma);

#     ifdef PNG_FORMAT_BGR_SUPPORTED
         if ((change & PNG_FORMAT_FLAG_BGR) != 0)
         {
            /* Check only the output format; PNG is never BGR; don't do this if
             * the output is gray, but fix up the 'format' value in that case.
             */
            if ((format & PNG_FORMAT_FLAG_COLOR) != 0)
               png_set_bgr(png_ptr);

            else
               format &= ~PNG_FORMAT_FLAG_BGR;

            change &= ~PNG_FORMAT_FLAG_BGR;
         }
#     endif

#     ifdef PNG_FORMAT_AFIRST_SUPPORTED
         if ((change & PNG_FORMAT_FLAG_AFIRST) != 0)
         {
            /* Only relevant if there is an alpha channel - it's particularly
             * important to handle this correctly because do_local_compose may
             * be set above and then libpng will keep the alpha channel for this
             * code to remove.
             */
            if ((format & PNG_FORMAT_FLAG_ALPHA) != 0)
            {
               /* Disable this if doing a local background,
                * TODO: remove this when local background is no longer required.
                */
               if (do_local_background != 2)
                  png_set_swap_alpha(png_ptr);
            }

            else
               format &= ~PNG_FORMAT_FLAG_AFIRST;

            change &= ~PNG_FORMAT_FLAG_AFIRST;
         }
#     endif

      /* If the *output* is 16-bit then we need to check for a byte-swap on this
       * architecture.
       */
      if (linear != 0)
      {
         PNG_CONST png_uint_16 le = 0x0001;

         if ((*(png_const_bytep) & le) != 0)
            png_set_swap(png_ptr);
      }

      /* If change is not now 0 some transformation is missing - error out. */
      if (change != 0)
         png_error(png_ptr, "png_read_image: unsupported transformation");
   }

   PNG_SKIP_CHUNKS(png_ptr);

   /* Update the 'info' structure and make sure the result is as required; first
    * make sure to turn on the interlace handling if it will be required
    * (because it can't be turned on *after* the call to png_read_update_info!)
    *
    * TODO: remove the do_local_background fixup below.
    */
   if (do_local_compose == 0 && do_local_background != 2)
      passes = png_set_interlace_handling(png_ptr);

   png_read_update_info(png_ptr, info_ptr);

   {
      png_uint_32 info_format = 0;

      if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
         info_format |= PNG_FORMAT_FLAG_COLOR;

      if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
      {
         /* do_local_compose removes this channel below. */
         if (do_local_compose == 0)
         {
            /* do_local_background does the same if required. */
            if (do_local_background != 2 ||
               (format & PNG_FORMAT_FLAG_ALPHA) != 0)
               info_format |= PNG_FORMAT_FLAG_ALPHA;
         }
      }

      else if (do_local_compose != 0) /* internal error */
         png_error(png_ptr, "png_image_read: alpha channel lost");

      if (info_ptr->bit_depth == 16)
         info_format |= PNG_FORMAT_FLAG_LINEAR;

#ifdef PNG_FORMAT_BGR_SUPPORTED
      if ((png_ptr->transformations & PNG_BGR) != 0)
         info_format |= PNG_FORMAT_FLAG_BGR;
#endif

#ifdef PNG_FORMAT_AFIRST_SUPPORTED
         if (do_local_background == 2)
         {
            if ((format & PNG_FORMAT_FLAG_AFIRST) != 0)
               info_format |= PNG_FORMAT_FLAG_AFIRST;
         }

         if ((png_ptr->transformations & PNG_SWAP_ALPHA) != 0 ||
            ((png_ptr->transformations & PNG_ADD_ALPHA) != 0 &&
            (png_ptr->flags & PNG_FLAG_FILLER_AFTER) == 0))
         {
            if (do_local_background == 2)
               png_error(png_ptr, "unexpected alpha swap transformation");

            info_format |= PNG_FORMAT_FLAG_AFIRST;
         }
#     endif

      /* This is actually an internal error. */
      if (info_format != format)
         png_error(png_ptr, "png_read_image: invalid transformations");
   }

   /* Now read the rows.  If do_local_compose is set then it is necessary to use
    * a local row buffer.  The output will be GA, RGBA or BGRA and must be
    * converted to G, RGB or BGR as appropriate.  The 'local_row' member of the
    * display acts as a flag.
    */
   {
      png_voidp first_row = display->buffer;
      ptrdiff_t row_bytes = display->row_stride;

      if (linear != 0)
         row_bytes *= 2;

      /* The following expression is designed to work correctly whether it gives
       * a signed or an unsigned result.
       */
      if (row_bytes < 0)
      {
         char *ptr = png_voidcast(char*, first_row);
         ptr += (image->height-1) * (-row_bytes);
         first_row = png_voidcast(png_voidp, ptr);
      }

      display->first_row = first_row;
      display->row_bytes = row_bytes;
   }

   if (do_local_compose != 0)
   {
      int result;
      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));

      display->local_row = row;
      result = png_safe_execute(image, png_image_read_composite, display);
      display->local_row = NULL;
      png_free(png_ptr, row);

      return result;
   }

   else if (do_local_background == 2)
   {
      int result;
      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));

      display->local_row = row;
      result = png_safe_execute(image, png_image_read_background, display);
      display->local_row = NULL;
      png_free(png_ptr, row);

      return result;
   }

   else
   {
      png_alloc_size_t row_bytes = (png_alloc_size_t)display->row_bytes;

      while (--passes >= 0)
      {
         png_uint_32      y = image->height;
         png_bytep        row = png_voidcast(png_bytep, display->first_row);

         for (; y > 0; --y)
         {
            png_read_row(png_ptr, row, NULL);
            row += row_bytes;
         }
      }

      return 1;
   }
}

int PNGAPI
png_image_finish_read(png_imagep image, png_const_colorp background,
    void *buffer, png_int_32 row_stride, void *colormap)
{
   if (image != NULL && image->version == PNG_IMAGE_VERSION)
   {
      /* Check for row_stride overflow.  This check is not performed on the
       * original PNG format because it may not occur in the output PNG format
       * and libpng deals with the issues of reading the original.
       */
      const unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image->format);

      /* The following checks just the 'row_stride' calculation to ensure it
       * fits in a signed 32-bit value.  Because channels/components can be
       * either 1 or 2 bytes in size the length of a row can still overflow 32
       * bits; this is just to verify that the 'row_stride' argument can be
       * represented.
       */
      if (image->width <= 0x7fffffffU/channels) /* no overflow */
      {
         png_uint_32 check;
         const png_uint_32 png_row_stride = image->width * channels;

         if (row_stride == 0)
            row_stride = (png_int_32)/*SAFE*/png_row_stride;

         if (row_stride < 0)
            check = (png_uint_32)(-row_stride);

         else
            check = (png_uint_32)row_stride;

         /* This verifies 'check', the absolute value of the actual stride
          * passed in and detects overflow in the application calculation (i.e.
          * if the app did actually pass in a non-zero 'row_stride'.
          */
         if (image->opaque != NULL && buffer != NULL && check >= png_row_stride)
         {
            /* Now check for overflow of the image buffer calculation; this
             * limits the whole image size to 32 bits for API compatibility with
             * the current, 32-bit, PNG_IMAGE_BUFFER_SIZE macro.
             *
             * The PNG_IMAGE_BUFFER_SIZE macro is:
             *
             *    (PNG_IMAGE_PIXEL_COMPONENT_SIZE(fmt)*height*(row_stride))
             *
             * And the component size is always 1 or 2, so make sure that the
             * number of *bytes* that the application is saying are available
             * does actually fit into a 32-bit number.
             *
             * NOTE: this will be changed in 1.7 because PNG_IMAGE_BUFFER_SIZE
             * will be changed to use png_alloc_size_t; bigger images can be
             * accomodated on 64-bit systems.
             */
            if (image->height <=
                0xffffffffU/PNG_IMAGE_PIXEL_COMPONENT_SIZE(image->format)/check)
            {
               if ((image->format & PNG_FORMAT_FLAG_COLORMAP) == 0 ||
                  (image->colormap_entries > 0 && colormap != NULL))
               {
                  int result;
                  png_image_read_control display;

                  memset(&display, 0, (sizeof display));
                  display.image = image;
                  display.buffer = buffer;
                  display.row_stride = row_stride;
                  display.colormap = colormap;
                  display.background = background;
                  display.local_row = NULL;

                  /* Choose the correct 'end' routine; for the color-map case
                   * all the setup has already been done.
                   */
                  if ((image->format & PNG_FORMAT_FLAG_COLORMAP) != 0)
                     result =
                         png_safe_execute(image,
                             png_image_read_colormap, &display) &&
                             png_safe_execute(image,
                             png_image_read_colormapped, &display);

                  else
                     result =
                        png_safe_execute(image,
                            png_image_read_direct, &display);

                  png_image_free(image);
                  return result;
               }

               else
                  return png_image_error(image,
                      "png_image_finish_read[color-map]: no color-map");
            }

            else
               return png_image_error(image,
                   "png_image_finish_read: image too large");
         }

         else
            return png_image_error(image,
                "png_image_finish_read: invalid argument");
      }

      else
         return png_image_error(image,
             "png_image_finish_read: row_stride too large");
   }

   else if (image != NULL)
      return png_image_error(image,
          "png_image_finish_read: damaged PNG_IMAGE_VERSION");

   return 0;
}

#endif /* SIMPLIFIED_READ */
#endif /* READ */

```

`ThirdPartyBuild/PNG/Code/pngrio.c`:

```c

/* pngrio.c - functions for data input
 *
 * Last changed in libpng 1.6.24 [August 4, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This file provides a location for all input.  Users who need
 * special handling are expected to write a function that has the same
 * arguments as this and performs a similar function, but that possibly
 * has a different input method.  Note that you shouldn't change this
 * function, but rather write a replacement function and then make
 * libpng use it at run time with png_set_read_fn(...).
 */

#include "pngpriv.h"

#ifdef PNG_READ_SUPPORTED

/* Read the data from whatever input you are using.  The default routine
 * reads from a file pointer.  Note that this routine sometimes gets called
 * with very small lengths, so you should implement some kind of simple
 * buffering if you are using unbuffered reads.  This should never be asked
 * to read more than 64K on a 16-bit machine.
 */
void /* PRIVATE */
png_read_data(png_structrp png_ptr, png_bytep data, png_size_t length)
{
   png_debug1(4, "reading %d bytes", (int)length);

   if (png_ptr->read_data_fn != NULL)
      (*(png_ptr->read_data_fn))(png_ptr, data, length);

   else
      png_error(png_ptr, "Call to NULL read function");
}

#ifdef PNG_STDIO_SUPPORTED
/* This is the function that does the actual reading of data.  If you are
 * not reading from a standard C stream, you should create a replacement
 * read_data function and use it at run time with png_set_read_fn(), rather
 * than changing the library.
 */
void PNGCBAPI
png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_size_t check;

   if (png_ptr == NULL)
      return;

   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
    * instead of an int, which is what fread() actually returns.
    */
   check = fread(data, 1, length, png_voidcast(png_FILE_p, png_ptr->io_ptr));

   if (check != length)
      png_error(png_ptr, "Read Error");
}
#endif

/* This function allows the application to supply a new input function
 * for libpng if standard C streams aren't being used.
 *
 * This function takes as its arguments:
 *
 * png_ptr      - pointer to a png input data structure
 *
 * io_ptr       - pointer to user supplied structure containing info about
 *                the input functions.  May be NULL.
 *
 * read_data_fn - pointer to a new input function that takes as its
 *                arguments a pointer to a png_struct, a pointer to
 *                a location where input data can be stored, and a 32-bit
 *                unsigned int that is the number of bytes to be read.
 *                To exit and output any fatal error messages the new write
 *                function should call png_error(png_ptr, "Error msg").
 *                May be NULL, in which case libpng's default function will
 *                be used.
 */
void PNGAPI
png_set_read_fn(png_structrp png_ptr, png_voidp io_ptr,
    png_rw_ptr read_data_fn)
{
   if (png_ptr == NULL)
      return;

   png_ptr->io_ptr = io_ptr;

#ifdef PNG_STDIO_SUPPORTED
   if (read_data_fn != NULL)
      png_ptr->read_data_fn = read_data_fn;

   else
      png_ptr->read_data_fn = png_default_read_data;
#else
   png_ptr->read_data_fn = read_data_fn;
#endif

#ifdef PNG_WRITE_SUPPORTED
   /* It is an error to write to a read device */
   if (png_ptr->write_data_fn != NULL)
   {
      png_ptr->write_data_fn = NULL;
      png_warning(png_ptr,
          "Can't set both read_data_fn and write_data_fn in the"
          " same structure");
   }
#endif

#ifdef PNG_WRITE_FLUSH_SUPPORTED
   png_ptr->output_flush_fn = NULL;
#endif
}
#endif /* READ */

```

`ThirdPartyBuild/PNG/Code/pngrtran.c`:

```c

/* pngrtran.c - transforms the data in a row for PNG readers
 *
 * Last changed in libpng 1.6.24 [August 4, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This file contains functions optionally called by an application
 * in order to tell libpng how to handle data when reading a PNG.
 * Transformations that are used in both reading and writing are
 * in pngtrans.c.
 */

#include "pngpriv.h"

#ifdef PNG_READ_SUPPORTED

/* Set the action on getting a CRC error for an ancillary or critical chunk. */
void PNGAPI
png_set_crc_action(png_structrp png_ptr, int crit_action, int ancil_action)
{
   png_debug(1, "in png_set_crc_action");

   if (png_ptr == NULL)
      return;

   /* Tell libpng how we react to CRC errors in critical chunks */
   switch (crit_action)
   {
      case PNG_CRC_NO_CHANGE:                        /* Leave setting as is */
         break;

      case PNG_CRC_WARN_USE:                               /* Warn/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE;
         break;

      case PNG_CRC_QUIET_USE:                             /* Quiet/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_CRITICAL_USE |
                           PNG_FLAG_CRC_CRITICAL_IGNORE;
         break;

      case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */
         png_warning(png_ptr,
             "Can't discard critical data on CRC error");
      case PNG_CRC_ERROR_QUIT:                                /* Error/quit */

      case PNG_CRC_DEFAULT:
      default:
         png_ptr->flags &= ~PNG_FLAG_CRC_CRITICAL_MASK;
         break;
   }

   /* Tell libpng how we react to CRC errors in ancillary chunks */
   switch (ancil_action)
   {
      case PNG_CRC_NO_CHANGE:                       /* Leave setting as is */
         break;

      case PNG_CRC_WARN_USE:                              /* Warn/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE;
         break;

      case PNG_CRC_QUIET_USE:                            /* Quiet/use data */
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_USE |
                           PNG_FLAG_CRC_ANCILLARY_NOWARN;
         break;

      case PNG_CRC_ERROR_QUIT:                               /* Error/quit */
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         png_ptr->flags |= PNG_FLAG_CRC_ANCILLARY_NOWARN;
         break;

      case PNG_CRC_WARN_DISCARD:                      /* Warn/discard data */

      case PNG_CRC_DEFAULT:
      default:
         png_ptr->flags &= ~PNG_FLAG_CRC_ANCILLARY_MASK;
         break;
   }
}

#ifdef PNG_READ_TRANSFORMS_SUPPORTED
/* Is it OK to set a transformation now?  Only if png_start_read_image or
 * png_read_update_info have not been called.  It is not necessary for the IHDR
 * to have been read in all cases; the need_IHDR parameter allows for this
 * check too.
 */
static int
png_rtran_ok(png_structrp png_ptr, int need_IHDR)
{
   if (png_ptr != NULL)
   {
      if ((png_ptr->flags & PNG_FLAG_ROW_INIT) != 0)
         png_app_error(png_ptr,
             "invalid after png_start_read_image or png_read_update_info");

      else if (need_IHDR && (png_ptr->mode & PNG_HAVE_IHDR) == 0)
         png_app_error(png_ptr, "invalid before the PNG header has been read");

      else
      {
         /* Turn on failure to initialize correctly for all transforms. */
         png_ptr->flags |= PNG_FLAG_DETECT_UNINITIALIZED;

         return 1; /* Ok */
      }
   }

   return 0; /* no png_error possible! */
}
#endif

#ifdef PNG_READ_BACKGROUND_SUPPORTED
/* Handle alpha and tRNS via a background color */
void PNGFAPI
png_set_background_fixed(png_structrp png_ptr,
    png_const_color_16p background_color, int background_gamma_code,
    int need_expand, png_fixed_point background_gamma)
{
   png_debug(1, "in png_set_background_fixed");

   if (png_rtran_ok(png_ptr, 0) == 0 || background_color == NULL)
      return;

   if (background_gamma_code == PNG_BACKGROUND_GAMMA_UNKNOWN)
   {
      png_warning(png_ptr, "Application must supply a known background gamma");
      return;
   }

   png_ptr->transformations |= PNG_COMPOSE | PNG_STRIP_ALPHA;
   png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
   png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;

   png_ptr->background = *background_color;
   png_ptr->background_gamma = background_gamma;
   png_ptr->background_gamma_type = (png_byte)(background_gamma_code);
   if (need_expand != 0)
      png_ptr->transformations |= PNG_BACKGROUND_EXPAND;
   else
      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;
}

#  ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_background(png_structrp png_ptr,
    png_const_color_16p background_color, int background_gamma_code,
    int need_expand, double background_gamma)
{
   png_set_background_fixed(png_ptr, background_color, background_gamma_code,
      need_expand, png_fixed(png_ptr, background_gamma, "png_set_background"));
}
#  endif /* FLOATING_POINT */
#endif /* READ_BACKGROUND */

/* Scale 16-bit depth files to 8-bit depth.  If both of these are set then the
 * one that pngrtran does first (scale) happens.  This is necessary to allow the
 * TRANSFORM and API behavior to be somewhat consistent, and it's simpler.
 */
#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
void PNGAPI
png_set_scale_16(png_structrp png_ptr)
{
   png_debug(1, "in png_set_scale_16");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   png_ptr->transformations |= PNG_SCALE_16_TO_8;
}
#endif

#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
/* Chop 16-bit depth files to 8-bit depth */
void PNGAPI
png_set_strip_16(png_structrp png_ptr)
{
   png_debug(1, "in png_set_strip_16");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   png_ptr->transformations |= PNG_16_TO_8;
}
#endif

#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
void PNGAPI
png_set_strip_alpha(png_structrp png_ptr)
{
   png_debug(1, "in png_set_strip_alpha");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   png_ptr->transformations |= PNG_STRIP_ALPHA;
}
#endif

#if defined(PNG_READ_ALPHA_MODE_SUPPORTED) || defined(PNG_READ_GAMMA_SUPPORTED)
static png_fixed_point
translate_gamma_flags(png_structrp png_ptr, png_fixed_point output_gamma,
    int is_screen)
{
   /* Check for flag values.  The main reason for having the old Mac value as a
    * flag is that it is pretty near impossible to work out what the correct
    * value is from Apple documentation - a working Mac system is needed to
    * discover the value!
    */
   if (output_gamma == PNG_DEFAULT_sRGB ||
      output_gamma == PNG_FP_1 / PNG_DEFAULT_sRGB)
   {
      /* If there is no sRGB support this just sets the gamma to the standard
       * sRGB value.  (This is a side effect of using this function!)
       */
#     ifdef PNG_READ_sRGB_SUPPORTED
         png_ptr->flags |= PNG_FLAG_ASSUME_sRGB;
#     else
         PNG_UNUSED(png_ptr)
#     endif
      if (is_screen != 0)
         output_gamma = PNG_GAMMA_sRGB;
      else
         output_gamma = PNG_GAMMA_sRGB_INVERSE;
   }

   else if (output_gamma == PNG_GAMMA_MAC_18 ||
      output_gamma == PNG_FP_1 / PNG_GAMMA_MAC_18)
   {
      if (is_screen != 0)
         output_gamma = PNG_GAMMA_MAC_OLD;
      else
         output_gamma = PNG_GAMMA_MAC_INVERSE;
   }

   return output_gamma;
}

#  ifdef PNG_FLOATING_POINT_SUPPORTED
static png_fixed_point
convert_gamma_value(png_structrp png_ptr, double output_gamma)
{
   /* The following silently ignores cases where fixed point (times 100,000)
    * gamma values are passed to the floating point API.  This is safe and it
    * means the fixed point constants work just fine with the floating point
    * API.  The alternative would just lead to undetected errors and spurious
    * bug reports.  Negative values fail inside the _fixed API unless they
    * correspond to the flag values.
    */
   if (output_gamma > 0 && output_gamma < 128)
      output_gamma *= PNG_FP_1;

   /* This preserves -1 and -2 exactly: */
   output_gamma = floor(output_gamma + .5);

   if (output_gamma > PNG_FP_MAX || output_gamma < PNG_FP_MIN)
      png_fixed_error(png_ptr, "gamma value");

   return (png_fixed_point)output_gamma;
}
#  endif
#endif /* READ_ALPHA_MODE || READ_GAMMA */

#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
void PNGFAPI
png_set_alpha_mode_fixed(png_structrp png_ptr, int mode,
    png_fixed_point output_gamma)
{
   int compose = 0;
   png_fixed_point file_gamma;

   png_debug(1, "in png_set_alpha_mode");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   output_gamma = translate_gamma_flags(png_ptr, output_gamma, 1/*screen*/);

   /* Validate the value to ensure it is in a reasonable range. The value
    * is expected to be 1 or greater, but this range test allows for some
    * viewing correction values.  The intent is to weed out users of this API
    * who use the inverse of the gamma value accidentally!  Since some of these
    * values are reasonable this may have to be changed:
    *
    * 1.6.x: changed from 0.07..3 to 0.01..100 (to accomodate the optimal 16-bit
    * gamma of 36, and its reciprocal.)
    */
   if (output_gamma < 1000 || output_gamma > 10000000)
      png_error(png_ptr, "output gamma out of expected range");

   /* The default file gamma is the inverse of the output gamma; the output
    * gamma may be changed below so get the file value first:
    */
   file_gamma = png_reciprocal(output_gamma);

   /* There are really 8 possibilities here, composed of any combination
    * of:
    *
    *    premultiply the color channels
    *    do not encode non-opaque pixels
    *    encode the alpha as well as the color channels
    *
    * The differences disappear if the input/output ('screen') gamma is 1.0,
    * because then the encoding is a no-op and there is only the choice of
    * premultiplying the color channels or not.
    *
    * png_set_alpha_mode and png_set_background interact because both use
    * png_compose to do the work.  Calling both is only useful when
    * png_set_alpha_mode is used to set the default mode - PNG_ALPHA_PNG - along
    * with a default gamma value.  Otherwise PNG_COMPOSE must not be set.
    */
   switch (mode)
   {
      case PNG_ALPHA_PNG:        /* default: png standard */
         /* No compose, but it may be set by png_set_background! */
         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
         break;

      case PNG_ALPHA_ASSOCIATED: /* color channels premultiplied */
         compose = 1;
         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
         /* The output is linear: */
         output_gamma = PNG_FP_1;
         break;

      case PNG_ALPHA_OPTIMIZED:  /* associated, non-opaque pixels linear */
         compose = 1;
         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
         png_ptr->flags |= PNG_FLAG_OPTIMIZE_ALPHA;
         /* output_gamma records the encoding of opaque pixels! */
         break;

      case PNG_ALPHA_BROKEN:     /* associated, non-linear, alpha encoded */
         compose = 1;
         png_ptr->transformations |= PNG_ENCODE_ALPHA;
         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
         break;

      default:
         png_error(png_ptr, "invalid alpha mode");
   }

   /* Only set the default gamma if the file gamma has not been set (this has
    * the side effect that the gamma in a second call to png_set_alpha_mode will
    * be ignored.)
    */
   if (png_ptr->colorspace.gamma == 0)
   {
      png_ptr->colorspace.gamma = file_gamma;
      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;
   }

   /* But always set the output gamma: */
   png_ptr->screen_gamma = output_gamma;

   /* Finally, if pre-multiplying, set the background fields to achieve the
    * desired result.
    */
   if (compose != 0)
   {
      /* And obtain alpha pre-multiplication by composing on black: */
      memset(&png_ptr->background, 0, (sizeof png_ptr->background));
      png_ptr->background_gamma = png_ptr->colorspace.gamma; /* just in case */
      png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_FILE;
      png_ptr->transformations &= ~PNG_BACKGROUND_EXPAND;

      if ((png_ptr->transformations & PNG_COMPOSE) != 0)
         png_error(png_ptr,
             "conflicting calls to set alpha mode and background");

      png_ptr->transformations |= PNG_COMPOSE;
   }
}

#  ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_alpha_mode(png_structrp png_ptr, int mode, double output_gamma)
{
   png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
       output_gamma));
}
#  endif
#endif

#ifdef PNG_READ_QUANTIZE_SUPPORTED
/* Dither file to 8-bit.  Supply a palette, the current number
 * of elements in the palette, the maximum number of elements
 * allowed, and a histogram if possible.  If the current number
 * of colors is greater than the maximum number, the palette will be
 * modified to fit in the maximum number.  "full_quantize" indicates
 * whether we need a quantizing cube set up for RGB images, or if we
 * simply are reducing the number of colors in a paletted image.
 */

typedef struct png_dsort_struct
{
   struct png_dsort_struct * next;
   png_byte left;
   png_byte right;
} png_dsort;
typedef png_dsort *   png_dsortp;
typedef png_dsort * * png_dsortpp;

void PNGAPI
png_set_quantize(png_structrp png_ptr, png_colorp palette,
    int num_palette, int maximum_colors, png_const_uint_16p histogram,
    int full_quantize)
{
   png_debug(1, "in png_set_quantize");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   png_ptr->transformations |= PNG_QUANTIZE;

   if (full_quantize == 0)
   {
      int i;

      png_ptr->quantize_index = (png_bytep)png_malloc(png_ptr,
          (png_uint_32)((png_uint_32)num_palette * (sizeof (png_byte))));
      for (i = 0; i < num_palette; i++)
         png_ptr->quantize_index[i] = (png_byte)i;
   }

   if (num_palette > maximum_colors)
   {
      if (histogram != NULL)
      {
         /* This is easy enough, just throw out the least used colors.
          * Perhaps not the best solution, but good enough.
          */

         int i;

         /* Initialize an array to sort colors */
         png_ptr->quantize_sort = (png_bytep)png_malloc(png_ptr,
             (png_uint_32)((png_uint_32)num_palette * (sizeof (png_byte))));

         /* Initialize the quantize_sort array */
         for (i = 0; i < num_palette; i++)
            png_ptr->quantize_sort[i] = (png_byte)i;

         /* Find the least used palette entries by starting a
          * bubble sort, and running it until we have sorted
          * out enough colors.  Note that we don't care about
          * sorting all the colors, just finding which are
          * least used.
          */

         for (i = num_palette - 1; i >= maximum_colors; i--)
         {
            int done; /* To stop early if the list is pre-sorted */
            int j;

            done = 1;
            for (j = 0; j < i; j++)
            {
               if (histogram[png_ptr->quantize_sort[j]]
                   < histogram[png_ptr->quantize_sort[j + 1]])
               {
                  png_byte t;

                  t = png_ptr->quantize_sort[j];
                  png_ptr->quantize_sort[j] = png_ptr->quantize_sort[j + 1];
                  png_ptr->quantize_sort[j + 1] = t;
                  done = 0;
               }
            }

            if (done != 0)
               break;
         }

         /* Swap the palette around, and set up a table, if necessary */
         if (full_quantize != 0)
         {
            int j = num_palette;

            /* Put all the useful colors within the max, but don't
             * move the others.
             */
            for (i = 0; i < maximum_colors; i++)
            {
               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)
               {
                  do
                     j--;
                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);

                  palette[i] = palette[j];
               }
            }
         }
         else
         {
            int j = num_palette;

            /* Move all the used colors inside the max limit, and
             * develop a translation table.
             */
            for (i = 0; i < maximum_colors; i++)
            {
               /* Only move the colors we need to */
               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)
               {
                  png_color tmp_color;

                  do
                     j--;
                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);

                  tmp_color = palette[j];
                  palette[j] = palette[i];
                  palette[i] = tmp_color;
                  /* Indicate where the color went */
                  png_ptr->quantize_index[j] = (png_byte)i;
                  png_ptr->quantize_index[i] = (png_byte)j;
               }
            }

            /* Find closest color for those colors we are not using */
            for (i = 0; i < num_palette; i++)
            {
               if ((int)png_ptr->quantize_index[i] >= maximum_colors)
               {
                  int min_d, k, min_k, d_index;

                  /* Find the closest color to one we threw out */
                  d_index = png_ptr->quantize_index[i];
                  min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);
                  for (k = 1, min_k = 0; k < maximum_colors; k++)
                  {
                     int d;

                     d = PNG_COLOR_DIST(palette[d_index], palette[k]);

                     if (d < min_d)
                     {
                        min_d = d;
                        min_k = k;
                     }
                  }
                  /* Point to closest color */
                  png_ptr->quantize_index[i] = (png_byte)min_k;
               }
            }
         }
         png_free(png_ptr, png_ptr->quantize_sort);
         png_ptr->quantize_sort = NULL;
      }
      else
      {
         /* This is much harder to do simply (and quickly).  Perhaps
          * we need to go through a median cut routine, but those
          * don't always behave themselves with only a few colors
          * as input.  So we will just find the closest two colors,
          * and throw out one of them (chosen somewhat randomly).
          * [We don't understand this at all, so if someone wants to
          *  work on improving it, be our guest - AED, GRP]
          */
         int i;
         int max_d;
         int num_new_palette;
         png_dsortp t;
         png_dsortpp hash;

         t = NULL;

         /* Initialize palette index arrays */
         png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,
             (png_uint_32)((png_uint_32)num_palette * (sizeof (png_byte))));
         png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,
             (png_uint_32)((png_uint_32)num_palette * (sizeof (png_byte))));

         /* Initialize the sort array */
         for (i = 0; i < num_palette; i++)
         {
            png_ptr->index_to_palette[i] = (png_byte)i;
            png_ptr->palette_to_index[i] = (png_byte)i;
         }

         hash = (png_dsortpp)png_calloc(png_ptr, (png_uint_32)(769 *
             (sizeof (png_dsortp))));

         num_new_palette = num_palette;

         /* Initial wild guess at how far apart the farthest pixel
          * pair we will be eliminating will be.  Larger
          * numbers mean more areas will be allocated, Smaller
          * numbers run the risk of not saving enough data, and
          * having to do this all over again.
          *
          * I have not done extensive checking on this number.
          */
         max_d = 96;

         while (num_new_palette > maximum_colors)
         {
            for (i = 0; i < num_new_palette - 1; i++)
            {
               int j;

               for (j = i + 1; j < num_new_palette; j++)
               {
                  int d;

                  d = PNG_COLOR_DIST(palette[i], palette[j]);

                  if (d <= max_d)
                  {

                     t = (png_dsortp)png_malloc_warn(png_ptr,
                         (png_uint_32)(sizeof (png_dsort)));

                     if (t == NULL)
                         break;

                     t->next = hash[d];
                     t->left = (png_byte)i;
                     t->right = (png_byte)j;
                     hash[d] = t;
                  }
               }
               if (t == NULL)
                  break;
            }

            if (t != NULL)
            for (i = 0; i <= max_d; i++)
            {
               if (hash[i] != NULL)
               {
                  png_dsortp p;

                  for (p = hash[i]; p; p = p->next)
                  {
                     if ((int)png_ptr->index_to_palette[p->left]
                         < num_new_palette &&
                         (int)png_ptr->index_to_palette[p->right]
                         < num_new_palette)
                     {
                        int j, next_j;

                        if (num_new_palette & 0x01)
                        {
                           j = p->left;
                           next_j = p->right;
                        }
                        else
                        {
                           j = p->right;
                           next_j = p->left;
                        }

                        num_new_palette--;
                        palette[png_ptr->index_to_palette[j]]
                            = palette[num_new_palette];
                        if (full_quantize == 0)
                        {
                           int k;

                           for (k = 0; k < num_palette; k++)
                           {
                              if (png_ptr->quantize_index[k] ==
                                  png_ptr->index_to_palette[j])
                                 png_ptr->quantize_index[k] =
                                     png_ptr->index_to_palette[next_j];

                              if ((int)png_ptr->quantize_index[k] ==
                                  num_new_palette)
                                 png_ptr->quantize_index[k] =
                                     png_ptr->index_to_palette[j];
                           }
                        }

                        png_ptr->index_to_palette[png_ptr->palette_to_index
                            [num_new_palette]] = png_ptr->index_to_palette[j];

                        png_ptr->palette_to_index[png_ptr->index_to_palette[j]]
                            = png_ptr->palette_to_index[num_new_palette];

                        png_ptr->index_to_palette[j] =
                            (png_byte)num_new_palette;

                        png_ptr->palette_to_index[num_new_palette] =
                            (png_byte)j;
                     }
                     if (num_new_palette <= maximum_colors)
                        break;
                  }
                  if (num_new_palette <= maximum_colors)
                     break;
               }
            }

            for (i = 0; i < 769; i++)
            {
               if (hash[i] != NULL)
               {
                  png_dsortp p = hash[i];
                  while (p)
                  {
                     t = p->next;
                     png_free(png_ptr, p);
                     p = t;
                  }
               }
               hash[i] = 0;
            }
            max_d += 96;
         }
         png_free(png_ptr, hash);
         png_free(png_ptr, png_ptr->palette_to_index);
         png_free(png_ptr, png_ptr->index_to_palette);
         png_ptr->palette_to_index = NULL;
         png_ptr->index_to_palette = NULL;
      }
      num_palette = maximum_colors;
   }
   if (png_ptr->palette == NULL)
   {
      png_ptr->palette = palette;
   }
   png_ptr->num_palette = (png_uint_16)num_palette;

   if (full_quantize != 0)
   {
      int i;
      png_bytep distance;
      int total_bits = PNG_QUANTIZE_RED_BITS + PNG_QUANTIZE_GREEN_BITS +
          PNG_QUANTIZE_BLUE_BITS;
      int num_red = (1 << PNG_QUANTIZE_RED_BITS);
      int num_green = (1 << PNG_QUANTIZE_GREEN_BITS);
      int num_blue = (1 << PNG_QUANTIZE_BLUE_BITS);
      png_size_t num_entries = ((png_size_t)1 << total_bits);

      png_ptr->palette_lookup = (png_bytep)png_calloc(png_ptr,
          (png_uint_32)(num_entries * (sizeof (png_byte))));

      distance = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_entries *
          (sizeof (png_byte))));

      memset(distance, 0xff, num_entries * (sizeof (png_byte)));

      for (i = 0; i < num_palette; i++)
      {
         int ir, ig, ib;
         int r = (palette[i].red >> (8 - PNG_QUANTIZE_RED_BITS));
         int g = (palette[i].green >> (8 - PNG_QUANTIZE_GREEN_BITS));
         int b = (palette[i].blue >> (8 - PNG_QUANTIZE_BLUE_BITS));

         for (ir = 0; ir < num_red; ir++)
         {
            /* int dr = abs(ir - r); */
            int dr = ((ir > r) ? ir - r : r - ir);
            int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +
                PNG_QUANTIZE_GREEN_BITS));

            for (ig = 0; ig < num_green; ig++)
            {
               /* int dg = abs(ig - g); */
               int dg = ((ig > g) ? ig - g : g - ig);
               int dt = dr + dg;
               int dm = ((dr > dg) ? dr : dg);
               int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);

               for (ib = 0; ib < num_blue; ib++)
               {
                  int d_index = index_g | ib;
                  /* int db = abs(ib - b); */
                  int db = ((ib > b) ? ib - b : b - ib);
                  int dmax = ((dm > db) ? dm : db);
                  int d = dmax + dt + db;

                  if (d < (int)distance[d_index])
                  {
                     distance[d_index] = (png_byte)d;
                     png_ptr->palette_lookup[d_index] = (png_byte)i;
                  }
               }
            }
         }
      }

      png_free(png_ptr, distance);
   }
}
#endif /* READ_QUANTIZE */

#ifdef PNG_READ_GAMMA_SUPPORTED
void PNGFAPI
png_set_gamma_fixed(png_structrp png_ptr, png_fixed_point scrn_gamma,
    png_fixed_point file_gamma)
{
   png_debug(1, "in png_set_gamma_fixed");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   /* New in libpng-1.5.4 - reserve particular negative values as flags. */
   scrn_gamma = translate_gamma_flags(png_ptr, scrn_gamma, 1/*screen*/);
   file_gamma = translate_gamma_flags(png_ptr, file_gamma, 0/*file*/);

   /* Checking the gamma values for being >0 was added in 1.5.4 along with the
    * premultiplied alpha support; this actually hides an undocumented feature
    * of the previous implementation which allowed gamma processing to be
    * disabled in background handling.  There is no evidence (so far) that this
    * was being used; however, png_set_background itself accepted and must still
    * accept '0' for the gamma value it takes, because it isn't always used.
    *
    * Since this is an API change (albeit a very minor one that removes an
    * undocumented API feature) the following checks were only enabled in
    * libpng-1.6.0.
    */
   if (file_gamma <= 0)
      png_error(png_ptr, "invalid file gamma in png_set_gamma");

   if (scrn_gamma <= 0)
      png_error(png_ptr, "invalid screen gamma in png_set_gamma");

   /* Set the gamma values unconditionally - this overrides the value in the PNG
    * file if a gAMA chunk was present.  png_set_alpha_mode provides a
    * different, easier, way to default the file gamma.
    */
   png_ptr->colorspace.gamma = file_gamma;
   png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;
   png_ptr->screen_gamma = scrn_gamma;
}

#  ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_gamma(png_structrp png_ptr, double scrn_gamma, double file_gamma)
{
   png_set_gamma_fixed(png_ptr, convert_gamma_value(png_ptr, scrn_gamma),
       convert_gamma_value(png_ptr, file_gamma));
}
#  endif /* FLOATING_POINT */
#endif /* READ_GAMMA */

#ifdef PNG_READ_EXPAND_SUPPORTED
/* Expand paletted images to RGB, expand grayscale images of
 * less than 8-bit depth to 8-bit depth, and expand tRNS chunks
 * to alpha channels.
 */
void PNGAPI
png_set_expand(png_structrp png_ptr)
{
   png_debug(1, "in png_set_expand");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
}

/* GRR 19990627:  the following three functions currently are identical
 *  to png_set_expand().  However, it is entirely reasonable that someone
 *  might wish to expand an indexed image to RGB but *not* expand a single,
 *  fully transparent palette entry to a full alpha channel--perhaps instead
 *  convert tRNS to the grayscale/RGB format (16-bit RGB value), or replace
 *  the transparent color with a particular RGB value, or drop tRNS entirely.
 *  IOW, a future version of the library may make the transformations flag
 *  a bit more fine-grained, with separate bits for each of these three
 *  functions.
 *
 *  More to the point, these functions make it obvious what libpng will be
 *  doing, whereas "expand" can (and does) mean any number of things.
 *
 *  GRP 20060307: In libpng-1.2.9, png_set_gray_1_2_4_to_8() was modified
 *  to expand only the sample depth but not to expand the tRNS to alpha
 *  and its name was changed to png_set_expand_gray_1_2_4_to_8().
 */

/* Expand paletted images to RGB. */
void PNGAPI
png_set_palette_to_rgb(png_structrp png_ptr)
{
   png_debug(1, "in png_set_palette_to_rgb");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
}

/* Expand grayscale images of less than 8-bit depth to 8 bits. */
void PNGAPI
png_set_expand_gray_1_2_4_to_8(png_structrp png_ptr)
{
   png_debug(1, "in png_set_expand_gray_1_2_4_to_8");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   png_ptr->transformations |= PNG_EXPAND;
}

/* Expand tRNS chunks to alpha channels. */
void PNGAPI
png_set_tRNS_to_alpha(png_structrp png_ptr)
{
   png_debug(1, "in png_set_tRNS_to_alpha");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   png_ptr->transformations |= (PNG_EXPAND | PNG_EXPAND_tRNS);
}
#endif /* READ_EXPAND */

#ifdef PNG_READ_EXPAND_16_SUPPORTED
/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise
 * it may not work correctly.)
 */
void PNGAPI
png_set_expand_16(png_structrp png_ptr)
{
   png_debug(1, "in png_set_expand_16");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   png_ptr->transformations |= (PNG_EXPAND_16 | PNG_EXPAND | PNG_EXPAND_tRNS);
}
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
void PNGAPI
png_set_gray_to_rgb(png_structrp png_ptr)
{
   png_debug(1, "in png_set_gray_to_rgb");

   if (png_rtran_ok(png_ptr, 0) == 0)
      return;

   /* Because rgb must be 8 bits or more: */
   png_set_expand_gray_1_2_4_to_8(png_ptr);
   png_ptr->transformations |= PNG_GRAY_TO_RGB;
}
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
void PNGFAPI
png_set_rgb_to_gray_fixed(png_structrp png_ptr, int error_action,
    png_fixed_point red, png_fixed_point green)
{
   png_debug(1, "in png_set_rgb_to_gray");

   /* Need the IHDR here because of the check on color_type below. */
   /* TODO: fix this */
   if (png_rtran_ok(png_ptr, 1) == 0)
      return;

   switch (error_action)
   {
      case PNG_ERROR_ACTION_NONE:
         png_ptr->transformations |= PNG_RGB_TO_GRAY;
         break;

      case PNG_ERROR_ACTION_WARN:
         png_ptr->transformations |= PNG_RGB_TO_GRAY_WARN;
         break;

      case PNG_ERROR_ACTION_ERROR:
         png_ptr->transformations |= PNG_RGB_TO_GRAY_ERR;
         break;

      default:
         png_error(png_ptr, "invalid error action to rgb_to_gray");
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
#ifdef PNG_READ_EXPAND_SUPPORTED
      png_ptr->transformations |= PNG_EXPAND;
#else
   {
      /* Make this an error in 1.6 because otherwise the application may assume
       * that it just worked and get a memory overwrite.
       */
      png_error(png_ptr,
          "Cannot do RGB_TO_GRAY without EXPAND_SUPPORTED");

      /* png_ptr->transformations &= ~PNG_RGB_TO_GRAY; */
   }
#endif
   {
      if (red >= 0 && green >= 0 && red + green <= PNG_FP_1)
      {
         png_uint_16 red_int, green_int;

         /* NOTE: this calculation does not round, but this behavior is retained
          * for consistency; the inaccuracy is very small.  The code here always
          * overwrites the coefficients, regardless of whether they have been
          * defaulted or set already.
          */
         red_int = (png_uint_16)(((png_uint_32)red*32768)/100000);
         green_int = (png_uint_16)(((png_uint_32)green*32768)/100000);

         png_ptr->rgb_to_gray_red_coeff   = red_int;
         png_ptr->rgb_to_gray_green_coeff = green_int;
         png_ptr->rgb_to_gray_coefficients_set = 1;
      }

      else
      {
         if (red >= 0 && green >= 0)
            png_app_warning(png_ptr,
                "ignoring out of range rgb_to_gray coefficients");

         /* Use the defaults, from the cHRM chunk if set, else the historical
          * values which are close to the sRGB/HDTV/ITU-Rec 709 values.  See
          * png_do_rgb_to_gray for more discussion of the values.  In this case
          * the coefficients are not marked as 'set' and are not overwritten if
          * something has already provided a default.
          */
         if (png_ptr->rgb_to_gray_red_coeff == 0 &&
             png_ptr->rgb_to_gray_green_coeff == 0)
         {
            png_ptr->rgb_to_gray_red_coeff   = 6968;
            png_ptr->rgb_to_gray_green_coeff = 23434;
            /* png_ptr->rgb_to_gray_blue_coeff  = 2366; */
         }
      }
   }
}

#ifdef PNG_FLOATING_POINT_SUPPORTED
/* Convert a RGB image to a grayscale of the same width.  This allows us,
 * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.
 */

void PNGAPI
png_set_rgb_to_gray(png_structrp png_ptr, int error_action, double red,
    double green)
{
   png_set_rgb_to_gray_fixed(png_ptr, error_action,
       png_fixed(png_ptr, red, "rgb to gray red coefficient"),
      png_fixed(png_ptr, green, "rgb to gray green coefficient"));
}
#endif /* FLOATING POINT */

#endif /* RGB_TO_GRAY */

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
void PNGAPI
png_set_read_user_transform_fn(png_structrp png_ptr, png_user_transform_ptr
    read_user_transform_fn)
{
   png_debug(1, "in png_set_read_user_transform_fn");

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
   png_ptr->transformations |= PNG_USER_TRANSFORM;
   png_ptr->read_user_transform_fn = read_user_transform_fn;
#endif
}
#endif

#ifdef PNG_READ_TRANSFORMS_SUPPORTED
#ifdef PNG_READ_GAMMA_SUPPORTED
/* In the case of gamma transformations only do transformations on images where
 * the [file] gamma and screen_gamma are not close reciprocals, otherwise it
 * slows things down slightly, and also needlessly introduces small errors.
 */
static int /* PRIVATE */
png_gamma_threshold(png_fixed_point screen_gamma, png_fixed_point file_gamma)
{
   /* PNG_GAMMA_THRESHOLD is the threshold for performing gamma
    * correction as a difference of the overall transform from 1.0
    *
    * We want to compare the threshold with s*f - 1, if we get
    * overflow here it is because of wacky gamma values so we
    * turn on processing anyway.
    */
   png_fixed_point gtest;
   return !png_muldiv(&gtest, screen_gamma, file_gamma, PNG_FP_1) ||
       png_gamma_significant(gtest);
}
#endif

/* Initialize everything needed for the read.  This includes modifying
 * the palette.
 */

/* For the moment 'png_init_palette_transformations' and
 * 'png_init_rgb_transformations' only do some flag canceling optimizations.
 * The intent is that these two routines should have palette or rgb operations
 * extracted from 'png_init_read_transformations'.
 */
static void /* PRIVATE */
png_init_palette_transformations(png_structrp png_ptr)
{
   /* Called to handle the (input) palette case.  In png_do_read_transformations
    * the first step is to expand the palette if requested, so this code must
    * take care to only make changes that are invariant with respect to the
    * palette expansion, or only do them if there is no expansion.
    *
    * STRIP_ALPHA has already been handled in the caller (by setting num_trans
    * to 0.)
    */
   int input_has_alpha = 0;
   int input_has_transparency = 0;

   if (png_ptr->num_trans > 0)
   {
      int i;

      /* Ignore if all the entries are opaque (unlikely!) */
      for (i=0; i<png_ptr->num_trans; ++i)
      {
         if (png_ptr->trans_alpha[i] == 255)
            continue;
         else if (png_ptr->trans_alpha[i] == 0)
            input_has_transparency = 1;
         else
         {
            input_has_transparency = 1;
            input_has_alpha = 1;
            break;
         }
      }
   }

   /* If no alpha we can optimize. */
   if (input_has_alpha == 0)
   {
      /* Any alpha means background and associative alpha processing is
       * required, however if the alpha is 0 or 1 throughout OPTIMIZE_ALPHA
       * and ENCODE_ALPHA are irrelevant.
       */
      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;

      if (input_has_transparency == 0)
         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
   }

#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
   /* png_set_background handling - deals with the complexity of whether the
    * background color is in the file format or the screen format in the case
    * where an 'expand' will happen.
    */

   /* The following code cannot be entered in the alpha pre-multiplication case
    * because PNG_BACKGROUND_EXPAND is cancelled below.
    */
   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) != 0 &&
       (png_ptr->transformations & PNG_EXPAND) != 0)
   {
      {
         png_ptr->background.red   =
             png_ptr->palette[png_ptr->background.index].red;
         png_ptr->background.green =
             png_ptr->palette[png_ptr->background.index].green;
         png_ptr->background.blue  =
             png_ptr->palette[png_ptr->background.index].blue;

#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
        if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0)
        {
           if ((png_ptr->transformations & PNG_EXPAND_tRNS) == 0)
           {
              /* Invert the alpha channel (in tRNS) unless the pixels are
               * going to be expanded, in which case leave it for later
               */
              int i, istop = png_ptr->num_trans;

              for (i=0; i<istop; i++)
                 png_ptr->trans_alpha[i] = (png_byte)(255 -
                    png_ptr->trans_alpha[i]);
           }
        }
#endif /* READ_INVERT_ALPHA */
      }
   } /* background expand and (therefore) no alpha association. */
#endif /* READ_EXPAND && READ_BACKGROUND */
}

static void /* PRIVATE */
png_init_rgb_transformations(png_structrp png_ptr)
{
   /* Added to libpng-1.5.4: check the color type to determine whether there
    * is any alpha or transparency in the image and simply cancel the
    * background and alpha mode stuff if there isn't.
    */
   int input_has_alpha = (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0;
   int input_has_transparency = png_ptr->num_trans > 0;

   /* If no alpha we can optimize. */
   if (input_has_alpha == 0)
   {
      /* Any alpha means background and associative alpha processing is
       * required, however if the alpha is 0 or 1 throughout OPTIMIZE_ALPHA
       * and ENCODE_ALPHA are irrelevant.
       */
#     ifdef PNG_READ_ALPHA_MODE_SUPPORTED
         png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
         png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
#     endif

      if (input_has_transparency == 0)
         png_ptr->transformations &= ~(PNG_COMPOSE | PNG_BACKGROUND_EXPAND);
   }

#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
   /* png_set_background handling - deals with the complexity of whether the
    * background color is in the file format or the screen format in the case
    * where an 'expand' will happen.
    */

   /* The following code cannot be entered in the alpha pre-multiplication case
    * because PNG_BACKGROUND_EXPAND is cancelled below.
    */
   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) != 0 &&
       (png_ptr->transformations & PNG_EXPAND) != 0 &&
       (png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)
       /* i.e., GRAY or GRAY_ALPHA */
   {
      {
         /* Expand background and tRNS chunks */
         int gray = png_ptr->background.gray;
         int trans_gray = png_ptr->trans_color.gray;

         switch (png_ptr->bit_depth)
         {
            case 1:
               gray *= 0xff;
               trans_gray *= 0xff;
               break;

            case 2:
               gray *= 0x55;
               trans_gray *= 0x55;
               break;

            case 4:
               gray *= 0x11;
               trans_gray *= 0x11;
               break;

            default:

            case 8:
               /* FALL THROUGH (Already 8 bits) */

            case 16:
               /* Already a full 16 bits */
               break;
         }

         png_ptr->background.red = png_ptr->background.green =
            png_ptr->background.blue = (png_uint_16)gray;

         if ((png_ptr->transformations & PNG_EXPAND_tRNS) == 0)
         {
            png_ptr->trans_color.red = png_ptr->trans_color.green =
               png_ptr->trans_color.blue = (png_uint_16)trans_gray;
         }
      }
   } /* background expand and (therefore) no alpha association. */
#endif /* READ_EXPAND && READ_BACKGROUND */
}

void /* PRIVATE */
png_init_read_transformations(png_structrp png_ptr)
{
   png_debug(1, "in png_init_read_transformations");

   /* This internal function is called from png_read_start_row in pngrutil.c
    * and it is called before the 'rowbytes' calculation is done, so the code
    * in here can change or update the transformations flags.
    *
    * First do updates that do not depend on the details of the PNG image data
    * being processed.
    */

#ifdef PNG_READ_GAMMA_SUPPORTED
   /* Prior to 1.5.4 these tests were performed from png_set_gamma, 1.5.4 adds
    * png_set_alpha_mode and this is another source for a default file gamma so
    * the test needs to be performed later - here.  In addition prior to 1.5.4
    * the tests were repeated for the PALETTE color type here - this is no
    * longer necessary (and doesn't seem to have been necessary before.)
    */
   {
      /* The following temporary indicates if overall gamma correction is
       * required.
       */
      int gamma_correction = 0;

      if (png_ptr->colorspace.gamma != 0) /* has been set */
      {
         if (png_ptr->screen_gamma != 0) /* screen set too */
            gamma_correction = png_gamma_threshold(png_ptr->colorspace.gamma,
                png_ptr->screen_gamma);

         else
            /* Assume the output matches the input; a long time default behavior
             * of libpng, although the standard has nothing to say about this.
             */
            png_ptr->screen_gamma = png_reciprocal(png_ptr->colorspace.gamma);
      }

      else if (png_ptr->screen_gamma != 0)
         /* The converse - assume the file matches the screen, note that this
          * perhaps undesireable default can (from 1.5.4) be changed by calling
          * png_set_alpha_mode (even if the alpha handling mode isn't required
          * or isn't changed from the default.)
          */
         png_ptr->colorspace.gamma = png_reciprocal(png_ptr->screen_gamma);

      else /* neither are set */
         /* Just in case the following prevents any processing - file and screen
          * are both assumed to be linear and there is no way to introduce a
          * third gamma value other than png_set_background with 'UNIQUE', and,
          * prior to 1.5.4
          */
         png_ptr->screen_gamma = png_ptr->colorspace.gamma = PNG_FP_1;

      /* We have a gamma value now. */
      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;

      /* Now turn the gamma transformation on or off as appropriate.  Notice
       * that PNG_GAMMA just refers to the file->screen correction.  Alpha
       * composition may independently cause gamma correction because it needs
       * linear data (e.g. if the file has a gAMA chunk but the screen gamma
       * hasn't been specified.)  In any case this flag may get turned off in
       * the code immediately below if the transform can be handled outside the
       * row loop.
       */
      if (gamma_correction != 0)
         png_ptr->transformations |= PNG_GAMMA;

      else
         png_ptr->transformations &= ~PNG_GAMMA;
   }
#endif

   /* Certain transformations have the effect of preventing other
    * transformations that happen afterward in png_do_read_transformations;
    * resolve the interdependencies here.  From the code of
    * png_do_read_transformations the order is:
    *
    *  1) PNG_EXPAND (including PNG_EXPAND_tRNS)
    *  2) PNG_STRIP_ALPHA (if no compose)
    *  3) PNG_RGB_TO_GRAY
    *  4) PNG_GRAY_TO_RGB iff !PNG_BACKGROUND_IS_GRAY
    *  5) PNG_COMPOSE
    *  6) PNG_GAMMA
    *  7) PNG_STRIP_ALPHA (if compose)
    *  8) PNG_ENCODE_ALPHA
    *  9) PNG_SCALE_16_TO_8
    * 10) PNG_16_TO_8
    * 11) PNG_QUANTIZE (converts to palette)
    * 12) PNG_EXPAND_16
    * 13) PNG_GRAY_TO_RGB iff PNG_BACKGROUND_IS_GRAY
    * 14) PNG_INVERT_MONO
    * 15) PNG_INVERT_ALPHA
    * 16) PNG_SHIFT
    * 17) PNG_PACK
    * 18) PNG_BGR
    * 19) PNG_PACKSWAP
    * 20) PNG_FILLER (includes PNG_ADD_ALPHA)
    * 21) PNG_SWAP_ALPHA
    * 22) PNG_SWAP_BYTES
    * 23) PNG_USER_TRANSFORM [must be last]
    */
#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0 &&
       (png_ptr->transformations & PNG_COMPOSE) == 0)
   {
      /* Stripping the alpha channel happens immediately after the 'expand'
       * transformations, before all other transformation, so it cancels out
       * the alpha handling.  It has the side effect negating the effect of
       * PNG_EXPAND_tRNS too:
       */
      png_ptr->transformations &= ~(PNG_BACKGROUND_EXPAND | PNG_ENCODE_ALPHA |
         PNG_EXPAND_tRNS);
      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;

      /* Kill the tRNS chunk itself too.  Prior to 1.5.4 this did not happen
       * so transparency information would remain just so long as it wasn't
       * expanded.  This produces unexpected API changes if the set of things
       * that do PNG_EXPAND_tRNS changes (perfectly possible given the
       * documentation - which says ask for what you want, accept what you
       * get.)  This makes the behavior consistent from 1.5.4:
       */
      png_ptr->num_trans = 0;
   }
#endif /* STRIP_ALPHA supported, no COMPOSE */

#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
   /* If the screen gamma is about 1.0 then the OPTIMIZE_ALPHA and ENCODE_ALPHA
    * settings will have no effect.
    */
   if (png_gamma_significant(png_ptr->screen_gamma) == 0)
   {
      png_ptr->transformations &= ~PNG_ENCODE_ALPHA;
      png_ptr->flags &= ~PNG_FLAG_OPTIMIZE_ALPHA;
   }
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
   /* Make sure the coefficients for the rgb to gray conversion are set
    * appropriately.
    */
   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)
      png_colorspace_set_rgb_coefficients(png_ptr);
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
#if defined(PNG_READ_EXPAND_SUPPORTED) && defined(PNG_READ_BACKGROUND_SUPPORTED)
   /* Detect gray background and attempt to enable optimization for
    * gray --> RGB case.
    *
    * Note:  if PNG_BACKGROUND_EXPAND is set and color_type is either RGB or
    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
    * background color might actually be gray yet not be flagged as such.
    * This is not a problem for the current code, which uses
    * PNG_BACKGROUND_IS_GRAY only to decide when to do the
    * png_do_gray_to_rgb() transformation.
    *
    * TODO: this code needs to be revised to avoid the complexity and
    * interdependencies.  The color type of the background should be recorded in
    * png_set_background, along with the bit depth, then the code has a record
    * of exactly what color space the background is currently in.
    */
   if ((png_ptr->transformations & PNG_BACKGROUND_EXPAND) != 0)
   {
      /* PNG_BACKGROUND_EXPAND: the background is in the file color space, so if
       * the file was grayscale the background value is gray.
       */
      if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)
         png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
   }

   else if ((png_ptr->transformations & PNG_COMPOSE) != 0)
   {
      /* PNG_COMPOSE: png_set_background was called with need_expand false,
       * so the color is in the color space of the output or png_set_alpha_mode
       * was called and the color is black.  Ignore RGB_TO_GRAY because that
       * happens before GRAY_TO_RGB.
       */
      if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)
      {
         if (png_ptr->background.red == png_ptr->background.green &&
             png_ptr->background.red == png_ptr->background.blue)
         {
            png_ptr->mode |= PNG_BACKGROUND_IS_GRAY;
            png_ptr->background.gray = png_ptr->background.red;
         }
      }
   }
#endif /* READ_EXPAND && READ_BACKGROUND */
#endif /* READ_GRAY_TO_RGB */

   /* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations
    * can be performed directly on the palette, and some (such as rgb to gray)
    * can be optimized inside the palette.  This is particularly true of the
    * composite (background and alpha) stuff, which can be pretty much all done
    * in the palette even if the result is expanded to RGB or gray afterward.
    *
    * NOTE: this is Not Yet Implemented, the code behaves as in 1.5.1 and
    * earlier and the palette stuff is actually handled on the first row.  This
    * leads to the reported bug that the palette returned by png_get_PLTE is not
    * updated.
    */
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      png_init_palette_transformations(png_ptr);

   else
      png_init_rgb_transformations(png_ptr);

#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
   defined(PNG_READ_EXPAND_16_SUPPORTED)
   if ((png_ptr->transformations & PNG_EXPAND_16) != 0 &&
       (png_ptr->transformations & PNG_COMPOSE) != 0 &&
       (png_ptr->transformations & PNG_BACKGROUND_EXPAND) == 0 &&
       png_ptr->bit_depth != 16)
   {
      /* TODO: fix this.  Because the expand_16 operation is after the compose
       * handling the background color must be 8, not 16, bits deep, but the
       * application will supply a 16-bit value so reduce it here.
       *
       * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at
       * present, so that case is ok (until do_expand_16 is moved.)
       *
       * NOTE: this discards the low 16 bits of the user supplied background
       * color, but until expand_16 works properly there is no choice!
       */
#     define CHOP(x) (x)=((png_uint_16)PNG_DIV257(x))
      CHOP(png_ptr->background.red);
      CHOP(png_ptr->background.green);
      CHOP(png_ptr->background.blue);
      CHOP(png_ptr->background.gray);
#     undef CHOP
   }
#endif /* READ_BACKGROUND && READ_EXPAND_16 */

#if defined(PNG_READ_BACKGROUND_SUPPORTED) && \
   (defined(PNG_READ_SCALE_16_TO_8_SUPPORTED) || \
   defined(PNG_READ_STRIP_16_TO_8_SUPPORTED))
   if ((png_ptr->transformations & (PNG_16_TO_8|PNG_SCALE_16_TO_8)) != 0 &&
       (png_ptr->transformations & PNG_COMPOSE) != 0 &&
       (png_ptr->transformations & PNG_BACKGROUND_EXPAND) == 0 &&
       png_ptr->bit_depth == 16)
   {
      /* On the other hand, if a 16-bit file is to be reduced to 8-bits per
       * component this will also happen after PNG_COMPOSE and so the background
       * color must be pre-expanded here.
       *
       * TODO: fix this too.
       */
      png_ptr->background.red = (png_uint_16)(png_ptr->background.red * 257);
      png_ptr->background.green =
         (png_uint_16)(png_ptr->background.green * 257);
      png_ptr->background.blue = (png_uint_16)(png_ptr->background.blue * 257);
      png_ptr->background.gray = (png_uint_16)(png_ptr->background.gray * 257);
   }
#endif

   /* NOTE: below 'PNG_READ_ALPHA_MODE_SUPPORTED' is presumed to also enable the
    * background support (see the comments in scripts/pnglibconf.dfa), this
    * allows pre-multiplication of the alpha channel to be implemented as
    * compositing on black.  This is probably sub-optimal and has been done in
    * 1.5.4 betas simply to enable external critique and testing (i.e. to
    * implement the new API quickly, without lots of internal changes.)
    */

#ifdef PNG_READ_GAMMA_SUPPORTED
#  ifdef PNG_READ_BACKGROUND_SUPPORTED
      /* Includes ALPHA_MODE */
      png_ptr->background_1 = png_ptr->background;
#  endif

   /* This needs to change - in the palette image case a whole set of tables are
    * built when it would be quicker to just calculate the correct value for
    * each palette entry directly.  Also, the test is too tricky - why check
    * PNG_RGB_TO_GRAY if PNG_GAMMA is not set?  The answer seems to be that
    * PNG_GAMMA is cancelled even if the gamma is known?  The test excludes the
    * PNG_COMPOSE case, so apparently if there is no *overall* gamma correction
    * the gamma tables will not be built even if composition is required on a
    * gamma encoded value.
    *
    * In 1.5.4 this is addressed below by an additional check on the individual
    * file gamma - if it is not 1.0 both RGB_TO_GRAY and COMPOSE need the
    * tables.
    */
   if ((png_ptr->transformations & PNG_GAMMA) != 0 ||
       ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0 &&
        (png_gamma_significant(png_ptr->colorspace.gamma) != 0 ||
         png_gamma_significant(png_ptr->screen_gamma) != 0)) ||
        ((png_ptr->transformations & PNG_COMPOSE) != 0 &&
         (png_gamma_significant(png_ptr->colorspace.gamma) != 0 ||
          png_gamma_significant(png_ptr->screen_gamma) != 0
#  ifdef PNG_READ_BACKGROUND_SUPPORTED
         || (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_UNIQUE &&
           png_gamma_significant(png_ptr->background_gamma) != 0)
#  endif
        )) || ((png_ptr->transformations & PNG_ENCODE_ALPHA) != 0 &&
       png_gamma_significant(png_ptr->screen_gamma) != 0))
   {
      png_build_gamma_table(png_ptr, png_ptr->bit_depth);

#ifdef PNG_READ_BACKGROUND_SUPPORTED
      if ((png_ptr->transformations & PNG_COMPOSE) != 0)
      {
         /* Issue a warning about this combination: because RGB_TO_GRAY is
          * optimized to do the gamma transform if present yet do_background has
          * to do the same thing if both options are set a
          * double-gamma-correction happens.  This is true in all versions of
          * libpng to date.
          */
         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)
            png_warning(png_ptr,
                "libpng does not support gamma+background+rgb_to_gray");

         if ((png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) != 0)
         {
            /* We don't get to here unless there is a tRNS chunk with non-opaque
             * entries - see the checking code at the start of this function.
             */
            png_color back, back_1;
            png_colorp palette = png_ptr->palette;
            int num_palette = png_ptr->num_palette;
            int i;
            if (png_ptr->background_gamma_type == PNG_BACKGROUND_GAMMA_FILE)
            {

               back.red = png_ptr->gamma_table[png_ptr->background.red];
               back.green = png_ptr->gamma_table[png_ptr->background.green];
               back.blue = png_ptr->gamma_table[png_ptr->background.blue];

               back_1.red = png_ptr->gamma_to_1[png_ptr->background.red];
               back_1.green = png_ptr->gamma_to_1[png_ptr->background.green];
               back_1.blue = png_ptr->gamma_to_1[png_ptr->background.blue];
            }
            else
            {
               png_fixed_point g, gs;

               switch (png_ptr->background_gamma_type)
               {
                  case PNG_BACKGROUND_GAMMA_SCREEN:
                     g = (png_ptr->screen_gamma);
                     gs = PNG_FP_1;
                     break;

                  case PNG_BACKGROUND_GAMMA_FILE:
                     g = png_reciprocal(png_ptr->colorspace.gamma);
                     gs = png_reciprocal2(png_ptr->colorspace.gamma,
                         png_ptr->screen_gamma);
                     break;

                  case PNG_BACKGROUND_GAMMA_UNIQUE:
                     g = png_reciprocal(png_ptr->background_gamma);
                     gs = png_reciprocal2(png_ptr->background_gamma,
                         png_ptr->screen_gamma);
                     break;
                  default:
                     g = PNG_FP_1;    /* back_1 */
                     gs = PNG_FP_1;   /* back */
                     break;
               }

               if (png_gamma_significant(gs) != 0)
               {
                  back.red = png_gamma_8bit_correct(png_ptr->background.red,
                      gs);
                  back.green = png_gamma_8bit_correct(png_ptr->background.green,
                      gs);
                  back.blue = png_gamma_8bit_correct(png_ptr->background.blue,
                      gs);
               }

               else
               {
                  back.red   = (png_byte)png_ptr->background.red;
                  back.green = (png_byte)png_ptr->background.green;
                  back.blue  = (png_byte)png_ptr->background.blue;
               }

               if (png_gamma_significant(g) != 0)
               {
                  back_1.red = png_gamma_8bit_correct(png_ptr->background.red,
                      g);
                  back_1.green = png_gamma_8bit_correct(
                      png_ptr->background.green, g);
                  back_1.blue = png_gamma_8bit_correct(png_ptr->background.blue,
                      g);
               }

               else
               {
                  back_1.red   = (png_byte)png_ptr->background.red;
                  back_1.green = (png_byte)png_ptr->background.green;
                  back_1.blue  = (png_byte)png_ptr->background.blue;
               }
            }

            for (i = 0; i < num_palette; i++)
            {
               if (i < (int)png_ptr->num_trans &&
                   png_ptr->trans_alpha[i] != 0xff)
               {
                  if (png_ptr->trans_alpha[i] == 0)
                  {
                     palette[i] = back;
                  }
                  else /* if (png_ptr->trans_alpha[i] != 0xff) */
                  {
                     png_byte v, w;

                     v = png_ptr->gamma_to_1[palette[i].red];
                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.red);
                     palette[i].red = png_ptr->gamma_from_1[w];

                     v = png_ptr->gamma_to_1[palette[i].green];
                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.green);
                     palette[i].green = png_ptr->gamma_from_1[w];

                     v = png_ptr->gamma_to_1[palette[i].blue];
                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.blue);
                     palette[i].blue = png_ptr->gamma_from_1[w];
                  }
               }
               else
               {
                  palette[i].red = png_ptr->gamma_table[palette[i].red];
                  palette[i].green = png_ptr->gamma_table[palette[i].green];
                  palette[i].blue = png_ptr->gamma_table[palette[i].blue];
               }
            }

            /* Prevent the transformations being done again.
             *
             * NOTE: this is highly dubious; it removes the transformations in
             * place.  This seems inconsistent with the general treatment of the
             * transformations elsewhere.
             */
            png_ptr->transformations &= ~(PNG_COMPOSE | PNG_GAMMA);
         } /* color_type == PNG_COLOR_TYPE_PALETTE */

         /* if (png_ptr->background_gamma_type!=PNG_BACKGROUND_GAMMA_UNKNOWN) */
         else /* color_type != PNG_COLOR_TYPE_PALETTE */
         {
            int gs_sig, g_sig;
            png_fixed_point g = PNG_FP_1;  /* Correction to linear */
            png_fixed_point gs = PNG_FP_1; /* Correction to screen */

            switch (png_ptr->background_gamma_type)
            {
               case PNG_BACKGROUND_GAMMA_SCREEN:
                  g = png_ptr->screen_gamma;
                  /* gs = PNG_FP_1; */
                  break;

               case PNG_BACKGROUND_GAMMA_FILE:
                  g = png_reciprocal(png_ptr->colorspace.gamma);
                  gs = png_reciprocal2(png_ptr->colorspace.gamma,
                      png_ptr->screen_gamma);
                  break;

               case PNG_BACKGROUND_GAMMA_UNIQUE:
                  g = png_reciprocal(png_ptr->background_gamma);
                  gs = png_reciprocal2(png_ptr->background_gamma,
                      png_ptr->screen_gamma);
                  break;

               default:
                  png_error(png_ptr, "invalid background gamma type");
            }

            g_sig = png_gamma_significant(g);
            gs_sig = png_gamma_significant(gs);

            if (g_sig != 0)
               png_ptr->background_1.gray = png_gamma_correct(png_ptr,
                   png_ptr->background.gray, g);

            if (gs_sig != 0)
               png_ptr->background.gray = png_gamma_correct(png_ptr,
                   png_ptr->background.gray, gs);

            if ((png_ptr->background.red != png_ptr->background.green) ||
                (png_ptr->background.red != png_ptr->background.blue) ||
                (png_ptr->background.red != png_ptr->background.gray))
            {
               /* RGB or RGBA with color background */
               if (g_sig != 0)
               {
                  png_ptr->background_1.red = png_gamma_correct(png_ptr,
                      png_ptr->background.red, g);

                  png_ptr->background_1.green = png_gamma_correct(png_ptr,
                      png_ptr->background.green, g);

                  png_ptr->background_1.blue = png_gamma_correct(png_ptr,
                      png_ptr->background.blue, g);
               }

               if (gs_sig != 0)
               {
                  png_ptr->background.red = png_gamma_correct(png_ptr,
                      png_ptr->background.red, gs);

                  png_ptr->background.green = png_gamma_correct(png_ptr,
                      png_ptr->background.green, gs);

                  png_ptr->background.blue = png_gamma_correct(png_ptr,
                      png_ptr->background.blue, gs);
               }
            }

            else
            {
               /* GRAY, GRAY ALPHA, RGB, or RGBA with gray background */
               png_ptr->background_1.red = png_ptr->background_1.green
                   = png_ptr->background_1.blue = png_ptr->background_1.gray;

               png_ptr->background.red = png_ptr->background.green
                   = png_ptr->background.blue = png_ptr->background.gray;
            }

            /* The background is now in screen gamma: */
            png_ptr->background_gamma_type = PNG_BACKGROUND_GAMMA_SCREEN;
         } /* color_type != PNG_COLOR_TYPE_PALETTE */
      }/* png_ptr->transformations & PNG_BACKGROUND */

      else
      /* Transformation does not include PNG_BACKGROUND */
#endif /* READ_BACKGROUND */
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE
#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
         /* RGB_TO_GRAY needs to have non-gamma-corrected values! */
         && ((png_ptr->transformations & PNG_EXPAND) == 0 ||
         (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0)
#endif
         )
      {
         png_colorp palette = png_ptr->palette;
         int num_palette = png_ptr->num_palette;
         int i;

         /* NOTE: there are other transformations that should probably be in
          * here too.
          */
         for (i = 0; i < num_palette; i++)
         {
            palette[i].red = png_ptr->gamma_table[palette[i].red];
            palette[i].green = png_ptr->gamma_table[palette[i].green];
            palette[i].blue = png_ptr->gamma_table[palette[i].blue];
         }

         /* Done the gamma correction. */
         png_ptr->transformations &= ~PNG_GAMMA;
      } /* color_type == PALETTE && !PNG_BACKGROUND transformation */
   }
#ifdef PNG_READ_BACKGROUND_SUPPORTED
   else
#endif
#endif /* READ_GAMMA */

#ifdef PNG_READ_BACKGROUND_SUPPORTED
   /* No GAMMA transformation (see the hanging else 4 lines above) */
   if ((png_ptr->transformations & PNG_COMPOSE) != 0 &&
       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
   {
      int i;
      int istop = (int)png_ptr->num_trans;
      png_color back;
      png_colorp palette = png_ptr->palette;

      back.red   = (png_byte)png_ptr->background.red;
      back.green = (png_byte)png_ptr->background.green;
      back.blue  = (png_byte)png_ptr->background.blue;

      for (i = 0; i < istop; i++)
      {
         if (png_ptr->trans_alpha[i] == 0)
         {
            palette[i] = back;
         }

         else if (png_ptr->trans_alpha[i] != 0xff)
         {
            /* The png_composite() macro is defined in png.h */
            png_composite(palette[i].red, palette[i].red,
                png_ptr->trans_alpha[i], back.red);

            png_composite(palette[i].green, palette[i].green,
                png_ptr->trans_alpha[i], back.green);

            png_composite(palette[i].blue, palette[i].blue,
                png_ptr->trans_alpha[i], back.blue);
         }
      }

      png_ptr->transformations &= ~PNG_COMPOSE;
   }
#endif /* READ_BACKGROUND */

#ifdef PNG_READ_SHIFT_SUPPORTED
   if ((png_ptr->transformations & PNG_SHIFT) != 0 &&
       (png_ptr->transformations & PNG_EXPAND) == 0 &&
       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE))
   {
      int i;
      int istop = png_ptr->num_palette;
      int shift = 8 - png_ptr->sig_bit.red;

      png_ptr->transformations &= ~PNG_SHIFT;

      /* significant bits can be in the range 1 to 7 for a meaninful result, if
       * the number of significant bits is 0 then no shift is done (this is an
       * error condition which is silently ignored.)
       */
      if (shift > 0 && shift < 8)
         for (i=0; i<istop; ++i)
         {
            int component = png_ptr->palette[i].red;

            component >>= shift;
            png_ptr->palette[i].red = (png_byte)component;
         }

      shift = 8 - png_ptr->sig_bit.green;
      if (shift > 0 && shift < 8)
         for (i=0; i<istop; ++i)
         {
            int component = png_ptr->palette[i].green;

            component >>= shift;
            png_ptr->palette[i].green = (png_byte)component;
         }

      shift = 8 - png_ptr->sig_bit.blue;
      if (shift > 0 && shift < 8)
         for (i=0; i<istop; ++i)
         {
            int component = png_ptr->palette[i].blue;

            component >>= shift;
            png_ptr->palette[i].blue = (png_byte)component;
         }
   }
#endif /* READ_SHIFT */
}

/* Modify the info structure to reflect the transformations.  The
 * info should be updated so a PNG file could be written with it,
 * assuming the transformations result in valid PNG data.
 */
void /* PRIVATE */
png_read_transform_info(png_structrp png_ptr, png_inforp info_ptr)
{
   png_debug(1, "in png_read_transform_info");

#ifdef PNG_READ_EXPAND_SUPPORTED
   if ((png_ptr->transformations & PNG_EXPAND) != 0)
   {
      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         /* This check must match what actually happens in
          * png_do_expand_palette; if it ever checks the tRNS chunk to see if
          * it is all opaque we must do the same (at present it does not.)
          */
         if (png_ptr->num_trans > 0)
            info_ptr->color_type = PNG_COLOR_TYPE_RGB_ALPHA;

         else
            info_ptr->color_type = PNG_COLOR_TYPE_RGB;

         info_ptr->bit_depth = 8;
         info_ptr->num_trans = 0;

         if (png_ptr->palette == NULL)
            png_error (png_ptr, "Palette is NULL in indexed image");
      }
      else
      {
         if (png_ptr->num_trans != 0)
         {
            if ((png_ptr->transformations & PNG_EXPAND_tRNS) != 0)
               info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
         }
         if (info_ptr->bit_depth < 8)
            info_ptr->bit_depth = 8;

         info_ptr->num_trans = 0;
      }
   }
#endif

#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
   /* The following is almost certainly wrong unless the background value is in
    * the screen space!
    */
   if ((png_ptr->transformations & PNG_COMPOSE) != 0)
      info_ptr->background = png_ptr->background;
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
   /* The following used to be conditional on PNG_GAMMA (prior to 1.5.4),
    * however it seems that the code in png_init_read_transformations, which has
    * been called before this from png_read_update_info->png_read_start_row
    * sometimes does the gamma transform and cancels the flag.
    *
    * TODO: this looks wrong; the info_ptr should end up with a gamma equal to
    * the screen_gamma value.  The following probably results in weirdness if
    * the info_ptr is used by the app after the rows have been read.
    */
   info_ptr->colorspace.gamma = png_ptr->colorspace.gamma;
#endif

   if (info_ptr->bit_depth == 16)
   {
#  ifdef PNG_READ_16BIT_SUPPORTED
#     ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
         if ((png_ptr->transformations & PNG_SCALE_16_TO_8) != 0)
            info_ptr->bit_depth = 8;
#     endif

#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
         if ((png_ptr->transformations & PNG_16_TO_8) != 0)
            info_ptr->bit_depth = 8;
#     endif

#  else
      /* No 16-bit support: force chopping 16-bit input down to 8, in this case
       * the app program can chose if both APIs are available by setting the
       * correct scaling to use.
       */
#     ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
         /* For compatibility with previous versions use the strip method by
          * default.  This code works because if PNG_SCALE_16_TO_8 is already
          * set the code below will do that in preference to the chop.
          */
         png_ptr->transformations |= PNG_16_TO_8;
         info_ptr->bit_depth = 8;
#     else

#        ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
            png_ptr->transformations |= PNG_SCALE_16_TO_8;
            info_ptr->bit_depth = 8;
#        else

            CONFIGURATION ERROR: you must enable at least one 16 to 8 method
#        endif
#    endif
#endif /* !READ_16BIT */
   }

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)
      info_ptr->color_type = (png_byte)(info_ptr->color_type |
         PNG_COLOR_MASK_COLOR);
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)
      info_ptr->color_type = (png_byte)(info_ptr->color_type &
         ~PNG_COLOR_MASK_COLOR);
#endif

#ifdef PNG_READ_QUANTIZE_SUPPORTED
   if ((png_ptr->transformations & PNG_QUANTIZE) != 0)
   {
      if (((info_ptr->color_type == PNG_COLOR_TYPE_RGB) ||
          (info_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)) &&
          png_ptr->palette_lookup != 0 && info_ptr->bit_depth == 8)
      {
         info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
      }
   }
#endif

#ifdef PNG_READ_EXPAND_16_SUPPORTED
   if ((png_ptr->transformations & PNG_EXPAND_16) != 0 &&
       info_ptr->bit_depth == 8 &&
       info_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      info_ptr->bit_depth = 16;
   }
#endif

#ifdef PNG_READ_PACK_SUPPORTED
   if ((png_ptr->transformations & PNG_PACK) != 0 &&
       (info_ptr->bit_depth < 8))
      info_ptr->bit_depth = 8;
#endif

   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      info_ptr->channels = 1;

   else if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
      info_ptr->channels = 3;

   else
      info_ptr->channels = 1;

#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0)
   {
      info_ptr->color_type = (png_byte)(info_ptr->color_type &
         ~PNG_COLOR_MASK_ALPHA);
      info_ptr->num_trans = 0;
   }
#endif

   if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
      info_ptr->channels++;

#ifdef PNG_READ_FILLER_SUPPORTED
   /* STRIP_ALPHA and FILLER allowed:  MASK_ALPHA bit stripped above */
   if ((png_ptr->transformations & PNG_FILLER) != 0 &&
       (info_ptr->color_type == PNG_COLOR_TYPE_RGB ||
       info_ptr->color_type == PNG_COLOR_TYPE_GRAY))
   {
      info_ptr->channels++;
      /* If adding a true alpha channel not just filler */
      if ((png_ptr->transformations & PNG_ADD_ALPHA) != 0)
         info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
   }
#endif

#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED) && \
defined(PNG_READ_USER_TRANSFORM_SUPPORTED)
   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
   {
      if (png_ptr->user_transform_depth != 0)
         info_ptr->bit_depth = png_ptr->user_transform_depth;

      if (png_ptr->user_transform_channels != 0)
         info_ptr->channels = png_ptr->user_transform_channels;
   }
#endif

   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *
       info_ptr->bit_depth);

   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);

   /* Adding in 1.5.4: cache the above value in png_struct so that we can later
    * check in png_rowbytes that the user buffer won't get overwritten.  Note
    * that the field is not always set - if png_read_update_info isn't called
    * the application has to either not do any transforms or get the calculation
    * right itself.
    */
   png_ptr->info_rowbytes = info_ptr->rowbytes;

#ifndef PNG_READ_EXPAND_SUPPORTED
   if (png_ptr != NULL)
      return;
#endif
}

#ifdef PNG_READ_PACK_SUPPORTED
/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
 * without changing the actual values.  Thus, if you had a row with
 * a bit depth of 1, you would end up with bytes that only contained
 * the numbers 0 or 1.  If you would rather they contain 0 and 255, use
 * png_do_shift() after this.
 */
static void
png_do_unpack(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_unpack");

   if (row_info->bit_depth < 8)
   {
      png_uint_32 i;
      png_uint_32 row_width=row_info->width;

      switch (row_info->bit_depth)
      {
         case 1:
         {
            png_bytep sp = row + (png_size_t)((row_width - 1) >> 3);
            png_bytep dp = row + (png_size_t)row_width - 1;
            png_uint_32 shift = 7U - ((row_width + 7U) & 0x07);
            for (i = 0; i < row_width; i++)
            {
               *dp = (png_byte)((*sp >> shift) & 0x01);

               if (shift == 7)
               {
                  shift = 0;
                  sp--;
               }

               else
                  shift++;

               dp--;
            }
            break;
         }

         case 2:
         {

            png_bytep sp = row + (png_size_t)((row_width - 1) >> 2);
            png_bytep dp = row + (png_size_t)row_width - 1;
            png_uint_32 shift = ((3U - ((row_width + 3U) & 0x03)) << 1);
            for (i = 0; i < row_width; i++)
            {
               *dp = (png_byte)((*sp >> shift) & 0x03);

               if (shift == 6)
               {
                  shift = 0;
                  sp--;
               }

               else
                  shift += 2;

               dp--;
            }
            break;
         }

         case 4:
         {
            png_bytep sp = row + (png_size_t)((row_width - 1) >> 1);
            png_bytep dp = row + (png_size_t)row_width - 1;
            png_uint_32 shift = ((1U - ((row_width + 1U) & 0x01)) << 2);
            for (i = 0; i < row_width; i++)
            {
               *dp = (png_byte)((*sp >> shift) & 0x0f);

               if (shift == 4)
               {
                  shift = 0;
                  sp--;
               }

               else
                  shift = 4;

               dp--;
            }
            break;
         }

         default:
            break;
      }
      row_info->bit_depth = 8;
      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
      row_info->rowbytes = row_width * row_info->channels;
   }
}
#endif

#ifdef PNG_READ_SHIFT_SUPPORTED
/* Reverse the effects of png_do_shift.  This routine merely shifts the
 * pixels back to their significant bits values.  Thus, if you have
 * a row of bit depth 8, but only 5 are significant, this will shift
 * the values back to 0 through 31.
 */
static void
png_do_unshift(png_row_infop row_info, png_bytep row,
    png_const_color_8p sig_bits)
{
   int color_type;

   png_debug(1, "in png_do_unshift");

   /* The palette case has already been handled in the _init routine. */
   color_type = row_info->color_type;

   if (color_type != PNG_COLOR_TYPE_PALETTE)
   {
      int shift[4];
      int channels = 0;
      int bit_depth = row_info->bit_depth;

      if ((color_type & PNG_COLOR_MASK_COLOR) != 0)
      {
         shift[channels++] = bit_depth - sig_bits->red;
         shift[channels++] = bit_depth - sig_bits->green;
         shift[channels++] = bit_depth - sig_bits->blue;
      }

      else
      {
         shift[channels++] = bit_depth - sig_bits->gray;
      }

      if ((color_type & PNG_COLOR_MASK_ALPHA) != 0)
      {
         shift[channels++] = bit_depth - sig_bits->alpha;
      }

      {
         int c, have_shift;

         for (c = have_shift = 0; c < channels; ++c)
         {
            /* A shift of more than the bit depth is an error condition but it
             * gets ignored here.
             */
            if (shift[c] <= 0 || shift[c] >= bit_depth)
               shift[c] = 0;

            else
               have_shift = 1;
         }

         if (have_shift == 0)
            return;
      }

      switch (bit_depth)
      {
         default:
         /* Must be 1bpp gray: should not be here! */
            /* NOTREACHED */
            break;

         case 2:
         /* Must be 2bpp gray */
         /* assert(channels == 1 && shift[0] == 1) */
         {
            png_bytep bp = row;
            png_bytep bp_end = bp + row_info->rowbytes;

            while (bp < bp_end)
            {
               int b = (*bp >> 1) & 0x55;
               *bp++ = (png_byte)b;
            }
            break;
         }

         case 4:
         /* Must be 4bpp gray */
         /* assert(channels == 1) */
         {
            png_bytep bp = row;
            png_bytep bp_end = bp + row_info->rowbytes;
            int gray_shift = shift[0];
            int mask =  0xf >> gray_shift;

            mask |= mask << 4;

            while (bp < bp_end)
            {
               int b = (*bp >> gray_shift) & mask;
               *bp++ = (png_byte)b;
            }
            break;
         }

         case 8:
         /* Single byte components, G, GA, RGB, RGBA */
         {
            png_bytep bp = row;
            png_bytep bp_end = bp + row_info->rowbytes;
            int channel = 0;

            while (bp < bp_end)
            {
               int b = *bp >> shift[channel];
               if (++channel >= channels)
                  channel = 0;
               *bp++ = (png_byte)b;
            }
            break;
         }

#ifdef PNG_READ_16BIT_SUPPORTED
         case 16:
         /* Double byte components, G, GA, RGB, RGBA */
         {
            png_bytep bp = row;
            png_bytep bp_end = bp + row_info->rowbytes;
            int channel = 0;

            while (bp < bp_end)
            {
               int value = (bp[0] << 8) + bp[1];

               value >>= shift[channel];
               if (++channel >= channels)
                  channel = 0;
               *bp++ = (png_byte)(value >> 8);
               *bp++ = (png_byte)value;
            }
            break;
         }
#endif
      }
   }
}
#endif

#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
/* Scale rows of bit depth 16 down to 8 accurately */
static void
png_do_scale_16_to_8(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_scale_16_to_8");

   if (row_info->bit_depth == 16)
   {
      png_bytep sp = row; /* source */
      png_bytep dp = row; /* destination */
      png_bytep ep = sp + row_info->rowbytes; /* end+1 */

      while (sp < ep)
      {
         /* The input is an array of 16-bit components, these must be scaled to
          * 8 bits each.  For a 16-bit value V the required value (from the PNG
          * specification) is:
          *
          *    (V * 255) / 65535
          *
          * This reduces to round(V / 257), or floor((V + 128.5)/257)
          *
          * Represent V as the two byte value vhi.vlo.  Make a guess that the
          * result is the top byte of V, vhi, then the correction to this value
          * is:
          *
          *    error = floor(((V-vhi.vhi) + 128.5) / 257)
          *          = floor(((vlo-vhi) + 128.5) / 257)
          *
          * This can be approximated using integer arithmetic (and a signed
          * shift):
          *
          *    error = (vlo-vhi+128) >> 8;
          *
          * The approximate differs from the exact answer only when (vlo-vhi) is
          * 128; it then gives a correction of +1 when the exact correction is
          * 0.  This gives 128 errors.  The exact answer (correct for all 16-bit
          * input values) is:
          *
          *    error = (vlo-vhi+128)*65535 >> 24;
          *
          * An alternative arithmetic calculation which also gives no errors is:
          *
          *    (V * 255 + 32895) >> 16
          */

         png_int_32 tmp = *sp++; /* must be signed! */
         tmp += (((int)*sp++ - tmp + 128) * 65535) >> 24;
         *dp++ = (png_byte)tmp;
      }

      row_info->bit_depth = 8;
      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
      row_info->rowbytes = row_info->width * row_info->channels;
   }
}
#endif

#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
static void
/* Simply discard the low byte.  This was the default behavior prior
 * to libpng-1.5.4.
 */
png_do_chop(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_chop");

   if (row_info->bit_depth == 16)
   {
      png_bytep sp = row; /* source */
      png_bytep dp = row; /* destination */
      png_bytep ep = sp + row_info->rowbytes; /* end+1 */

      while (sp < ep)
      {
         *dp++ = *sp;
         sp += 2; /* skip low byte */
      }

      row_info->bit_depth = 8;
      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
      row_info->rowbytes = row_info->width * row_info->channels;
   }
}
#endif

#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
static void
png_do_read_swap_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_read_swap_alpha");

   {
      png_uint_32 row_width = row_info->width;
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         /* This converts from RGBA to ARGB */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save;
            }
         }

#ifdef PNG_READ_16BIT_SUPPORTED
         /* This converts from RRGGBBAA to AARRGGBB */
         else
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save[2];
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save[0] = *(--sp);
               save[1] = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save[0];
               *(--dp) = save[1];
            }
         }
#endif
      }

      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         /* This converts from GA to AG */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save;
            }
         }

#ifdef PNG_READ_16BIT_SUPPORTED
         /* This converts from GGAA to AAGG */
         else
         {
            png_bytep sp = row + row_info->rowbytes;
            png_bytep dp = sp;
            png_byte save[2];
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               save[0] = *(--sp);
               save[1] = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = save[0];
               *(--dp) = save[1];
            }
         }
#endif
      }
   }
}
#endif

#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
static void
png_do_read_invert_alpha(png_row_infop row_info, png_bytep row)
{
   png_uint_32 row_width;
   png_debug(1, "in png_do_read_invert_alpha");

   row_width = row_info->width;
   if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
   {
      if (row_info->bit_depth == 8)
      {
         /* This inverts the alpha channel in RGBA */
         png_bytep sp = row + row_info->rowbytes;
         png_bytep dp = sp;
         png_uint_32 i;

         for (i = 0; i < row_width; i++)
         {
            *(--dp) = (png_byte)(255 - *(--sp));

/*          This does nothing:
            *(--dp) = *(--sp);
            *(--dp) = *(--sp);
            *(--dp) = *(--sp);
            We can replace it with:
*/
            sp-=3;
            dp=sp;
         }
      }

#ifdef PNG_READ_16BIT_SUPPORTED
      /* This inverts the alpha channel in RRGGBBAA */
      else
      {
         png_bytep sp = row + row_info->rowbytes;
         png_bytep dp = sp;
         png_uint_32 i;

         for (i = 0; i < row_width; i++)
         {
            *(--dp) = (png_byte)(255 - *(--sp));
            *(--dp) = (png_byte)(255 - *(--sp));

/*          This does nothing:
            *(--dp) = *(--sp);
            *(--dp) = *(--sp);
            *(--dp) = *(--sp);
            *(--dp) = *(--sp);
            *(--dp) = *(--sp);
            *(--dp) = *(--sp);
            We can replace it with:
*/
            sp-=6;
            dp=sp;
         }
      }
#endif
   }
   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
   {
      if (row_info->bit_depth == 8)
      {
         /* This inverts the alpha channel in GA */
         png_bytep sp = row + row_info->rowbytes;
         png_bytep dp = sp;
         png_uint_32 i;

         for (i = 0; i < row_width; i++)
         {
            *(--dp) = (png_byte)(255 - *(--sp));
            *(--dp) = *(--sp);
         }
      }

#ifdef PNG_READ_16BIT_SUPPORTED
      else
      {
         /* This inverts the alpha channel in GGAA */
         png_bytep sp  = row + row_info->rowbytes;
         png_bytep dp = sp;
         png_uint_32 i;

         for (i = 0; i < row_width; i++)
         {
            *(--dp) = (png_byte)(255 - *(--sp));
            *(--dp) = (png_byte)(255 - *(--sp));
/*
            *(--dp) = *(--sp);
            *(--dp) = *(--sp);
*/
            sp-=2;
            dp=sp;
         }
      }
#endif
   }
}
#endif

#ifdef PNG_READ_FILLER_SUPPORTED
/* Add filler channel if we have RGB color */
static void
png_do_read_filler(png_row_infop row_info, png_bytep row,
    png_uint_32 filler, png_uint_32 flags)
{
   png_uint_32 i;
   png_uint_32 row_width = row_info->width;

#ifdef PNG_READ_16BIT_SUPPORTED
   png_byte hi_filler = (png_byte)(filler>>8);
#endif
   png_byte lo_filler = (png_byte)filler;

   png_debug(1, "in png_do_read_filler");

   if (
       row_info->color_type == PNG_COLOR_TYPE_GRAY)
   {
      if (row_info->bit_depth == 8)
      {
         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
         {
            /* This changes the data from G to GX */
            png_bytep sp = row + (png_size_t)row_width;
            png_bytep dp =  sp + (png_size_t)row_width;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = lo_filler;
               *(--dp) = *(--sp);
            }
            *(--dp) = lo_filler;
            row_info->channels = 2;
            row_info->pixel_depth = 16;
            row_info->rowbytes = row_width * 2;
         }

         else
         {
            /* This changes the data from G to XG */
            png_bytep sp = row + (png_size_t)row_width;
            png_bytep dp = sp  + (png_size_t)row_width;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = lo_filler;
            }
            row_info->channels = 2;
            row_info->pixel_depth = 16;
            row_info->rowbytes = row_width * 2;
         }
      }

#ifdef PNG_READ_16BIT_SUPPORTED
      else if (row_info->bit_depth == 16)
      {
         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
         {
            /* This changes the data from GG to GGXX */
            png_bytep sp = row + (png_size_t)row_width * 2;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = lo_filler;
               *(--dp) = hi_filler;
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
            }
            *(--dp) = lo_filler;
            *(--dp) = hi_filler;
            row_info->channels = 2;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }

         else
         {
            /* This changes the data from GG to XXGG */
            png_bytep sp = row + (png_size_t)row_width * 2;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = lo_filler;
               *(--dp) = hi_filler;
            }
            row_info->channels = 2;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }
      }
#endif
   } /* COLOR_TYPE == GRAY */
   else if (row_info->color_type == PNG_COLOR_TYPE_RGB)
   {
      if (row_info->bit_depth == 8)
      {
         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
         {
            /* This changes the data from RGB to RGBX */
            png_bytep sp = row + (png_size_t)row_width * 3;
            png_bytep dp = sp  + (png_size_t)row_width;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = lo_filler;
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
            }
            *(--dp) = lo_filler;
            row_info->channels = 4;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }

         else
         {
            /* This changes the data from RGB to XRGB */
            png_bytep sp = row + (png_size_t)row_width * 3;
            png_bytep dp = sp + (png_size_t)row_width;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = lo_filler;
            }
            row_info->channels = 4;
            row_info->pixel_depth = 32;
            row_info->rowbytes = row_width * 4;
         }
      }

#ifdef PNG_READ_16BIT_SUPPORTED
      else if (row_info->bit_depth == 16)
      {
         if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
         {
            /* This changes the data from RRGGBB to RRGGBBXX */
            png_bytep sp = row + (png_size_t)row_width * 6;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 1; i < row_width; i++)
            {
               *(--dp) = lo_filler;
               *(--dp) = hi_filler;
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
            }
            *(--dp) = lo_filler;
            *(--dp) = hi_filler;
            row_info->channels = 4;
            row_info->pixel_depth = 64;
            row_info->rowbytes = row_width * 8;
         }

         else
         {
            /* This changes the data from RRGGBB to XXRRGGBB */
            png_bytep sp = row + (png_size_t)row_width * 6;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 0; i < row_width; i++)
            {
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = *(--sp);
               *(--dp) = lo_filler;
               *(--dp) = hi_filler;
            }

            row_info->channels = 4;
            row_info->pixel_depth = 64;
            row_info->rowbytes = row_width * 8;
         }
      }
#endif
   } /* COLOR_TYPE == RGB */
}
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
/* Expand grayscale files to RGB, with or without alpha */
static void
png_do_gray_to_rgb(png_row_infop row_info, png_bytep row)
{
   png_uint_32 i;
   png_uint_32 row_width = row_info->width;

   png_debug(1, "in png_do_gray_to_rgb");

   if (row_info->bit_depth >= 8 &&
       (row_info->color_type & PNG_COLOR_MASK_COLOR) == 0)
   {
      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (row_info->bit_depth == 8)
         {
            /* This changes G to RGB */
            png_bytep sp = row + (png_size_t)row_width - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *sp;
               *(dp--) = *sp;
               *(dp--) = *(sp--);
            }
         }

         else
         {
            /* This changes GG to RRGGBB */
            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 4;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *(sp--);
               *(dp--) = *(sp--);
            }
         }
      }

      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (row_info->bit_depth == 8)
         {
            /* This changes GA to RGBA */
            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 2;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *(sp--);
               *(dp--) = *sp;
               *(dp--) = *sp;
               *(dp--) = *(sp--);
            }
         }

         else
         {
            /* This changes GGAA to RRGGBBAA */
            png_bytep sp = row + (png_size_t)row_width * 4 - 1;
            png_bytep dp = sp  + (png_size_t)row_width * 4;
            for (i = 0; i < row_width; i++)
            {
               *(dp--) = *(sp--);
               *(dp--) = *(sp--);
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *sp;
               *(dp--) = *(sp - 1);
               *(dp--) = *(sp--);
               *(dp--) = *(sp--);
            }
         }
      }
      row_info->channels = (png_byte)(row_info->channels + 2);
      row_info->color_type |= PNG_COLOR_MASK_COLOR;
      row_info->pixel_depth = (png_byte)(row_info->channels *
          row_info->bit_depth);
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
   }
}
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
/* Reduce RGB files to grayscale, with or without alpha
 * using the equation given in Poynton's ColorFAQ of 1998-01-04 at
 * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008 but
 * versions dated 1998 through November 2002 have been archived at
 * http://web.archive.org/web/20000816232553/http://www.inforamp.net/
 * ~poynton/notes/colour_and_gamma/ColorFAQ.txt )
 * Charles Poynton poynton at poynton.com
 *
 *     Y = 0.212671 * R + 0.715160 * G + 0.072169 * B
 *
 *  which can be expressed with integers as
 *
 *     Y = (6969 * R + 23434 * G + 2365 * B)/32768
 *
 * Poynton's current link (as of January 2003 through July 2011):
 * <http://www.poynton.com/notes/colour_and_gamma/>
 * has changed the numbers slightly:
 *
 *     Y = 0.2126*R + 0.7152*G + 0.0722*B
 *
 *  which can be expressed with integers as
 *
 *     Y = (6966 * R + 23436 * G + 2366 * B)/32768
 *
 *  Historically, however, libpng uses numbers derived from the ITU-R Rec 709
 *  end point chromaticities and the D65 white point.  Depending on the
 *  precision used for the D65 white point this produces a variety of different
 *  numbers, however if the four decimal place value used in ITU-R Rec 709 is
 *  used (0.3127,0.3290) the Y calculation would be:
 *
 *     Y = (6968 * R + 23435 * G + 2366 * B)/32768
 *
 *  While this is correct the rounding results in an overflow for white, because
 *  the sum of the rounded coefficients is 32769, not 32768.  Consequently
 *  libpng uses, instead, the closest non-overflowing approximation:
 *
 *     Y = (6968 * R + 23434 * G + 2366 * B)/32768
 *
 *  Starting with libpng-1.5.5, if the image being converted has a cHRM chunk
 *  (including an sRGB chunk) then the chromaticities are used to calculate the
 *  coefficients.  See the chunk handling in pngrutil.c for more information.
 *
 *  In all cases the calculation is to be done in a linear colorspace.  If no
 *  gamma information is available to correct the encoding of the original RGB
 *  values this results in an implicit assumption that the original PNG RGB
 *  values were linear.
 *
 *  Other integer coefficents can be used via png_set_rgb_to_gray().  Because
 *  the API takes just red and green coefficients the blue coefficient is
 *  calculated to make the sum 32768.  This will result in different rounding
 *  to that used above.
 */
static int
png_do_rgb_to_gray(png_structrp png_ptr, png_row_infop row_info, png_bytep row)

{
   int rgb_error = 0;

   png_debug(1, "in png_do_rgb_to_gray");

   if ((row_info->color_type & PNG_COLOR_MASK_PALETTE) == 0 &&
       (row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)
   {
      PNG_CONST png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;
      PNG_CONST png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;
      PNG_CONST png_uint_32 bc = 32768 - rc - gc;
      PNG_CONST png_uint_32 row_width = row_info->width;
      PNG_CONST int have_alpha =
         (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0;

      if (row_info->bit_depth == 8)
      {
#ifdef PNG_READ_GAMMA_SUPPORTED
         /* Notice that gamma to/from 1 are not necessarily inverses (if
          * there is an overall gamma correction).  Prior to 1.5.5 this code
          * checked the linearized values for equality; this doesn't match
          * the documentation, the original values must be checked.
          */
         if (png_ptr->gamma_from_1 != NULL && png_ptr->gamma_to_1 != NULL)
         {
            png_bytep sp = row;
            png_bytep dp = row;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               png_byte red   = *(sp++);
               png_byte green = *(sp++);
               png_byte blue  = *(sp++);

               if (red != green || red != blue)
               {
                  red = png_ptr->gamma_to_1[red];
                  green = png_ptr->gamma_to_1[green];
                  blue = png_ptr->gamma_to_1[blue];

                  rgb_error |= 1;
                  *(dp++) = png_ptr->gamma_from_1[
                      (rc*red + gc*green + bc*blue + 16384)>>15];
               }

               else
               {
                  /* If there is no overall correction the table will not be
                   * set.
                   */
                  if (png_ptr->gamma_table != NULL)
                     red = png_ptr->gamma_table[red];

                  *(dp++) = red;
               }

               if (have_alpha != 0)
                  *(dp++) = *(sp++);
            }
         }
         else
#endif
         {
            png_bytep sp = row;
            png_bytep dp = row;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               png_byte red   = *(sp++);
               png_byte green = *(sp++);
               png_byte blue  = *(sp++);

               if (red != green || red != blue)
               {
                  rgb_error |= 1;
                  /* NOTE: this is the historical approach which simply
                   * truncates the results.
                   */
                  *(dp++) = (png_byte)((rc*red + gc*green + bc*blue)>>15);
               }

               else
                  *(dp++) = red;

               if (have_alpha != 0)
                  *(dp++) = *(sp++);
            }
         }
      }

      else /* RGB bit_depth == 16 */
      {
#ifdef PNG_READ_GAMMA_SUPPORTED
         if (png_ptr->gamma_16_to_1 != NULL && png_ptr->gamma_16_from_1 != NULL)
         {
            png_bytep sp = row;
            png_bytep dp = row;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               png_uint_16 red, green, blue, w;
               png_byte hi,lo;

               hi=*(sp)++; lo=*(sp)++; red   = (png_uint_16)((hi << 8) | (lo));
               hi=*(sp)++; lo=*(sp)++; green = (png_uint_16)((hi << 8) | (lo));
               hi=*(sp)++; lo=*(sp)++; blue  = (png_uint_16)((hi << 8) | (lo));

               if (red == green && red == blue)
               {
                  if (png_ptr->gamma_16_table != NULL)
                     w = png_ptr->gamma_16_table[(red & 0xff)
                         >> png_ptr->gamma_shift][red >> 8];

                  else
                     w = red;
               }

               else
               {
                  png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red & 0xff)
                      >> png_ptr->gamma_shift][red>>8];
                  png_uint_16 green_1 =
                      png_ptr->gamma_16_to_1[(green & 0xff) >>
                      png_ptr->gamma_shift][green>>8];
                  png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue & 0xff)
                      >> png_ptr->gamma_shift][blue>>8];
                  png_uint_16 gray16  = (png_uint_16)((rc*red_1 + gc*green_1
                      + bc*blue_1 + 16384)>>15);
                  w = png_ptr->gamma_16_from_1[(gray16 & 0xff) >>
                      png_ptr->gamma_shift][gray16 >> 8];
                  rgb_error |= 1;
               }

               *(dp++) = (png_byte)((w>>8) & 0xff);
               *(dp++) = (png_byte)(w & 0xff);

               if (have_alpha != 0)
               {
                  *(dp++) = *(sp++);
                  *(dp++) = *(sp++);
               }
            }
         }
         else
#endif
         {
            png_bytep sp = row;
            png_bytep dp = row;
            png_uint_32 i;

            for (i = 0; i < row_width; i++)
            {
               png_uint_16 red, green, blue, gray16;
               png_byte hi,lo;

               hi=*(sp)++; lo=*(sp)++; red   = (png_uint_16)((hi << 8) | (lo));
               hi=*(sp)++; lo=*(sp)++; green = (png_uint_16)((hi << 8) | (lo));
               hi=*(sp)++; lo=*(sp)++; blue  = (png_uint_16)((hi << 8) | (lo));

               if (red != green || red != blue)
                  rgb_error |= 1;

               /* From 1.5.5 in the 16-bit case do the accurate conversion even
                * in the 'fast' case - this is because this is where the code
                * ends up when handling linear 16-bit data.
                */
               gray16  = (png_uint_16)((rc*red + gc*green + bc*blue + 16384) >>
                  15);
               *(dp++) = (png_byte)((gray16 >> 8) & 0xff);
               *(dp++) = (png_byte)(gray16 & 0xff);

               if (have_alpha != 0)
               {
                  *(dp++) = *(sp++);
                  *(dp++) = *(sp++);
               }
            }
         }
      }

      row_info->channels = (png_byte)(row_info->channels - 2);
      row_info->color_type = (png_byte)(row_info->color_type &
          ~PNG_COLOR_MASK_COLOR);
      row_info->pixel_depth = (png_byte)(row_info->channels *
          row_info->bit_depth);
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
   }
   return rgb_error;
}
#endif

#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
/* Replace any alpha or transparency with the supplied background color.
 * "background" is already in the screen gamma, while "background_1" is
 * at a gamma of 1.0.  Paletted files have already been taken care of.
 */
static void
png_do_compose(png_row_infop row_info, png_bytep row, png_structrp png_ptr)
{
#ifdef PNG_READ_GAMMA_SUPPORTED
   png_const_bytep gamma_table = png_ptr->gamma_table;
   png_const_bytep gamma_from_1 = png_ptr->gamma_from_1;
   png_const_bytep gamma_to_1 = png_ptr->gamma_to_1;
   png_const_uint_16pp gamma_16 = png_ptr->gamma_16_table;
   png_const_uint_16pp gamma_16_from_1 = png_ptr->gamma_16_from_1;
   png_const_uint_16pp gamma_16_to_1 = png_ptr->gamma_16_to_1;
   int gamma_shift = png_ptr->gamma_shift;
   int optimize = (png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0;
#endif

   png_bytep sp;
   png_uint_32 i;
   png_uint_32 row_width = row_info->width;
   int shift;

   png_debug(1, "in png_do_compose");

   {
      switch (row_info->color_type)
      {
         case PNG_COLOR_TYPE_GRAY:
         {
            switch (row_info->bit_depth)
            {
               case 1:
               {
                  sp = row;
                  shift = 7;
                  for (i = 0; i < row_width; i++)
                  {
                     if ((png_uint_16)((*sp >> shift) & 0x01)
                        == png_ptr->trans_color.gray)
                     {
                        unsigned int tmp = *sp & (0x7f7f >> (7 - shift));
                        tmp |=
                            (unsigned int)(png_ptr->background.gray << shift);
                        *sp = (png_byte)(tmp & 0xff);
                     }

                     if (shift == 0)
                     {
                        shift = 7;
                        sp++;
                     }

                     else
                        shift--;
                  }
                  break;
               }

               case 2:
               {
#ifdef PNG_READ_GAMMA_SUPPORTED
                  if (gamma_table != NULL)
                  {
                     sp = row;
                     shift = 6;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x03)
                            == png_ptr->trans_color.gray)
                        {
                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
                           tmp |=
                              (unsigned int)png_ptr->background.gray << shift;
                           *sp = (png_byte)(tmp & 0xff);
                        }

                        else
                        {
                           unsigned int p = (*sp >> shift) & 0x03;
                           unsigned int g = (gamma_table [p | (p << 2) |
                               (p << 4) | (p << 6)] >> 6) & 0x03;
                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
                           tmp |= (unsigned int)(g << shift);
                           *sp = (png_byte)(tmp & 0xff);
                        }

                        if (shift == 0)
                        {
                           shift = 6;
                           sp++;
                        }

                        else
                           shift -= 2;
                     }
                  }

                  else
#endif
                  {
                     sp = row;
                     shift = 6;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x03)
                            == png_ptr->trans_color.gray)
                        {
                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
                           tmp |=
                               (unsigned int)png_ptr->background.gray << shift;
                           *sp = (png_byte)(tmp & 0xff);
                        }

                        if (shift == 0)
                        {
                           shift = 6;
                           sp++;
                        }

                        else
                           shift -= 2;
                     }
                  }
                  break;
               }

               case 4:
               {
#ifdef PNG_READ_GAMMA_SUPPORTED
                  if (gamma_table != NULL)
                  {
                     sp = row;
                     shift = 4;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x0f)
                            == png_ptr->trans_color.gray)
                        {
                           unsigned int tmp = *sp & (0x0f0f >> (4 - shift));
                           tmp |= 
                              (unsigned int)(png_ptr->background.gray << shift);
                           *sp = (png_byte)(tmp & 0xff);
                        }

                        else
                        {
                           unsigned int p = (*sp >> shift) & 0x0f;
                           unsigned int g = (gamma_table[p | (p << 4)] >> 4) &
                              0x0f;
                           unsigned int tmp = *sp & (0x0f0f >> (4 - shift));
                           tmp |= (unsigned int)(g << shift);
                           *sp = (png_byte)(tmp & 0xff);
                        }

                        if (shift == 0)
                        {
                           shift = 4;
                           sp++;
                        }

                        else
                           shift -= 4;
                     }
                  }

                  else
#endif
                  {
                     sp = row;
                     shift = 4;
                     for (i = 0; i < row_width; i++)
                     {
                        if ((png_uint_16)((*sp >> shift) & 0x0f)
                            == png_ptr->trans_color.gray)
                        {
                           unsigned int tmp = *sp & (0x0f0f >> (4 - shift));
                           tmp |=
                              (unsigned int)(png_ptr->background.gray << shift);
                           *sp = (png_byte)(tmp & 0xff);
                        }

                        if (shift == 0)
                        {
                           shift = 4;
                           sp++;
                        }

                        else
                           shift -= 4;
                     }
                  }
                  break;
               }

               case 8:
               {
#ifdef PNG_READ_GAMMA_SUPPORTED
                  if (gamma_table != NULL)
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp++)
                     {
                        if (*sp == png_ptr->trans_color.gray)
                           *sp = (png_byte)png_ptr->background.gray;

                        else
                           *sp = gamma_table[*sp];
                     }
                  }
                  else
#endif
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp++)
                     {
                        if (*sp == png_ptr->trans_color.gray)
                           *sp = (png_byte)png_ptr->background.gray;
                     }
                  }
                  break;
               }

               case 16:
               {
#ifdef PNG_READ_GAMMA_SUPPORTED
                  if (gamma_16 != NULL)
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp += 2)
                     {
                        png_uint_16 v;

                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));

                        if (v == png_ptr->trans_color.gray)
                        {
                           /* Background is already in screen gamma */
                           *sp = (png_byte)((png_ptr->background.gray >> 8)
                                & 0xff);
                           *(sp + 1) = (png_byte)(png_ptr->background.gray
                                & 0xff);
                        }

                        else
                        {
                           v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                           *sp = (png_byte)((v >> 8) & 0xff);
                           *(sp + 1) = (png_byte)(v & 0xff);
                        }
                     }
                  }
                  else
#endif
                  {
                     sp = row;
                     for (i = 0; i < row_width; i++, sp += 2)
                     {
                        png_uint_16 v;

                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));

                        if (v == png_ptr->trans_color.gray)
                        {
                           *sp = (png_byte)((png_ptr->background.gray >> 8)
                                & 0xff);
                           *(sp + 1) = (png_byte)(png_ptr->background.gray
                                & 0xff);
                        }
                     }
                  }
                  break;
               }

               default:
                  break;
            }
            break;
         }

         case PNG_COLOR_TYPE_RGB:
         {
            if (row_info->bit_depth == 8)
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_table != NULL)
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 3)
                  {
                     if (*sp == png_ptr->trans_color.red &&
                         *(sp + 1) == png_ptr->trans_color.green &&
                         *(sp + 2) == png_ptr->trans_color.blue)
                     {
                        *sp = (png_byte)png_ptr->background.red;
                        *(sp + 1) = (png_byte)png_ptr->background.green;
                        *(sp + 2) = (png_byte)png_ptr->background.blue;
                     }

                     else
                     {
                        *sp = gamma_table[*sp];
                        *(sp + 1) = gamma_table[*(sp + 1)];
                        *(sp + 2) = gamma_table[*(sp + 2)];
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 3)
                  {
                     if (*sp == png_ptr->trans_color.red &&
                         *(sp + 1) == png_ptr->trans_color.green &&
                         *(sp + 2) == png_ptr->trans_color.blue)
                     {
                        *sp = (png_byte)png_ptr->background.red;
                        *(sp + 1) = (png_byte)png_ptr->background.green;
                        *(sp + 2) = (png_byte)png_ptr->background.blue;
                     }
                  }
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_16 != NULL)
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 6)
                  {
                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));

                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
                         + *(sp + 3));

                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
                         + *(sp + 5));

                     if (r == png_ptr->trans_color.red &&
                         g == png_ptr->trans_color.green &&
                         b == png_ptr->trans_color.blue)
                     {
                        /* Background is already in screen gamma */
                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
                                & 0xff);
                        *(sp + 3) = (png_byte)(png_ptr->background.green
                                & 0xff);
                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
                                & 0xff);
                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
                     }

                     else
                     {
                        png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                        *sp = (png_byte)((v >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(v & 0xff);

                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
                        *(sp + 3) = (png_byte)(v & 0xff);

                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
                        *(sp + 5) = (png_byte)(v & 0xff);
                     }
                  }
               }

               else
#endif
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 6)
                  {
                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));

                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
                         + *(sp + 3));

                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
                         + *(sp + 5));

                     if (r == png_ptr->trans_color.red &&
                         g == png_ptr->trans_color.green &&
                         b == png_ptr->trans_color.blue)
                     {
                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
                                & 0xff);
                        *(sp + 3) = (png_byte)(png_ptr->background.green
                                & 0xff);
                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
                                & 0xff);
                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
                     }
                  }
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_GRAY_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
                   gamma_table != NULL)
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 2)
                  {
                     png_uint_16 a = *(sp + 1);

                     if (a == 0xff)
                        *sp = gamma_table[*sp];

                     else if (a == 0)
                     {
                        /* Background is already in screen gamma */
                        *sp = (png_byte)png_ptr->background.gray;
                     }

                     else
                     {
                        png_byte v, w;

                        v = gamma_to_1[*sp];
                        png_composite(w, v, a, png_ptr->background_1.gray);
                        if (optimize == 0)
                           w = gamma_from_1[w];
                        *sp = w;
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 2)
                  {
                     png_byte a = *(sp + 1);

                     if (a == 0)
                        *sp = (png_byte)png_ptr->background.gray;

                     else if (a < 0xff)
                        png_composite(*sp, *sp, a, png_ptr->background.gray);
                  }
               }
            }
            else /* if (png_ptr->bit_depth == 16) */
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
                   gamma_16_to_1 != NULL)
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 4)
                  {
                     png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
                         + *(sp + 3));

                     if (a == (png_uint_16)0xffff)
                     {
                        png_uint_16 v;

                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                        *sp = (png_byte)((v >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(v & 0xff);
                     }

                     else if (a == 0)
                     {
                        /* Background is already in screen gamma */
                        *sp = (png_byte)((png_ptr->background.gray >> 8)
                                & 0xff);
                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
                     }

                     else
                     {
                        png_uint_16 g, v, w;

                        g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
                        png_composite_16(v, g, a, png_ptr->background_1.gray);
                        if (optimize != 0)
                           w = v;
                        else
                           w = gamma_16_from_1[(v & 0xff) >>
                               gamma_shift][v >> 8];
                        *sp = (png_byte)((w >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(w & 0xff);
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 4)
                  {
                     png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
                         + *(sp + 3));

                     if (a == 0)
                     {
                        *sp = (png_byte)((png_ptr->background.gray >> 8)
                                & 0xff);
                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
                     }

                     else if (a < 0xffff)
                     {
                        png_uint_16 g, v;

                        g = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                        png_composite_16(v, g, a, png_ptr->background.gray);
                        *sp = (png_byte)((v >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(v & 0xff);
                     }
                  }
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_RGB_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
                   gamma_table != NULL)
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 4)
                  {
                     png_byte a = *(sp + 3);

                     if (a == 0xff)
                     {
                        *sp = gamma_table[*sp];
                        *(sp + 1) = gamma_table[*(sp + 1)];
                        *(sp + 2) = gamma_table[*(sp + 2)];
                     }

                     else if (a == 0)
                     {
                        /* Background is already in screen gamma */
                        *sp = (png_byte)png_ptr->background.red;
                        *(sp + 1) = (png_byte)png_ptr->background.green;
                        *(sp + 2) = (png_byte)png_ptr->background.blue;
                     }

                     else
                     {
                        png_byte v, w;

                        v = gamma_to_1[*sp];
                        png_composite(w, v, a, png_ptr->background_1.red);
                        if (optimize == 0) w = gamma_from_1[w];
                        *sp = w;

                        v = gamma_to_1[*(sp + 1)];
                        png_composite(w, v, a, png_ptr->background_1.green);
                        if (optimize == 0) w = gamma_from_1[w];
                        *(sp + 1) = w;

                        v = gamma_to_1[*(sp + 2)];
                        png_composite(w, v, a, png_ptr->background_1.blue);
                        if (optimize == 0) w = gamma_from_1[w];
                        *(sp + 2) = w;
                     }
                  }
               }
               else
#endif
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 4)
                  {
                     png_byte a = *(sp + 3);

                     if (a == 0)
                     {
                        *sp = (png_byte)png_ptr->background.red;
                        *(sp + 1) = (png_byte)png_ptr->background.green;
                        *(sp + 2) = (png_byte)png_ptr->background.blue;
                     }

                     else if (a < 0xff)
                     {
                        png_composite(*sp, *sp, a, png_ptr->background.red);

                        png_composite(*(sp + 1), *(sp + 1), a,
                            png_ptr->background.green);

                        png_composite(*(sp + 2), *(sp + 2), a,
                            png_ptr->background.blue);
                     }
                  }
               }
            }
            else /* if (row_info->bit_depth == 16) */
            {
#ifdef PNG_READ_GAMMA_SUPPORTED
               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
                   gamma_16_to_1 != NULL)
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 8)
                  {
                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
                         << 8) + (png_uint_16)(*(sp + 7)));

                     if (a == (png_uint_16)0xffff)
                     {
                        png_uint_16 v;

                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
                        *sp = (png_byte)((v >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(v & 0xff);

                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
                        *(sp + 3) = (png_byte)(v & 0xff);

                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
                        *(sp + 5) = (png_byte)(v & 0xff);
                     }

                     else if (a == 0)
                     {
                        /* Background is already in screen gamma */
                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
                                & 0xff);
                        *(sp + 3) = (png_byte)(png_ptr->background.green
                                & 0xff);
                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
                                & 0xff);
                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
                     }

                     else
                     {
                        png_uint_16 v, w;

                        v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
                        png_composite_16(w, v, a, png_ptr->background_1.red);
                        if (optimize == 0)
                           w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>
                                8];
                        *sp = (png_byte)((w >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(w & 0xff);

                        v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];
                        png_composite_16(w, v, a, png_ptr->background_1.green);
                        if (optimize == 0)
                           w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>
                                8];

                        *(sp + 2) = (png_byte)((w >> 8) & 0xff);
                        *(sp + 3) = (png_byte)(w & 0xff);

                        v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];
                        png_composite_16(w, v, a, png_ptr->background_1.blue);
                        if (optimize == 0)
                           w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>
                                8];

                        *(sp + 4) = (png_byte)((w >> 8) & 0xff);
                        *(sp + 5) = (png_byte)(w & 0xff);
                     }
                  }
               }

               else
#endif
               {
                  sp = row;
                  for (i = 0; i < row_width; i++, sp += 8)
                  {
                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
                         << 8) + (png_uint_16)(*(sp + 7)));

                     if (a == 0)
                     {
                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
                                & 0xff);
                        *(sp + 3) = (png_byte)(png_ptr->background.green
                                & 0xff);
                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
                                & 0xff);
                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
                     }

                     else if (a < 0xffff)
                     {
                        png_uint_16 v;

                        png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
                        png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
                            + *(sp + 3));
                        png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
                            + *(sp + 5));

                        png_composite_16(v, r, a, png_ptr->background.red);
                        *sp = (png_byte)((v >> 8) & 0xff);
                        *(sp + 1) = (png_byte)(v & 0xff);

                        png_composite_16(v, g, a, png_ptr->background.green);
                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
                        *(sp + 3) = (png_byte)(v & 0xff);

                        png_composite_16(v, b, a, png_ptr->background.blue);
                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
                        *(sp + 5) = (png_byte)(v & 0xff);
                     }
                  }
               }
            }
            break;
         }

         default:
            break;
      }
   }
}
#endif /* READ_BACKGROUND || READ_ALPHA_MODE */

#ifdef PNG_READ_GAMMA_SUPPORTED
/* Gamma correct the image, avoiding the alpha channel.  Make sure
 * you do this after you deal with the transparency issue on grayscale
 * or RGB images. If your bit depth is 8, use gamma_table, if it
 * is 16, use gamma_16_table and gamma_shift.  Build these with
 * build_gamma_table().
 */
static void
png_do_gamma(png_row_infop row_info, png_bytep row, png_structrp png_ptr)
{
   png_const_bytep gamma_table = png_ptr->gamma_table;
   png_const_uint_16pp gamma_16_table = png_ptr->gamma_16_table;
   int gamma_shift = png_ptr->gamma_shift;

   png_bytep sp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_gamma");

   if (((row_info->bit_depth <= 8 && gamma_table != NULL) ||
       (row_info->bit_depth == 16 && gamma_16_table != NULL)))
   {
      switch (row_info->color_type)
      {
         case PNG_COLOR_TYPE_RGB:
         {
            if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp++;
                  *sp = gamma_table[*sp];
                  sp++;
                  *sp = gamma_table[*sp];
                  sp++;
               }
            }

            else /* if (row_info->bit_depth == 16) */
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v;

                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;

                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;

                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_RGB_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp++;

                  *sp = gamma_table[*sp];
                  sp++;

                  *sp = gamma_table[*sp];
                  sp++;

                  sp++;
               }
            }

            else /* if (row_info->bit_depth == 16) */
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;

                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;

                  v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 4;
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_GRAY_ALPHA:
         {
            if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp += 2;
               }
            }

            else /* if (row_info->bit_depth == 16) */
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 4;
               }
            }
            break;
         }

         case PNG_COLOR_TYPE_GRAY:
         {
            if (row_info->bit_depth == 2)
            {
               sp = row;
               for (i = 0; i < row_width; i += 4)
               {
                  int a = *sp & 0xc0;
                  int b = *sp & 0x30;
                  int c = *sp & 0x0c;
                  int d = *sp & 0x03;

                  *sp = (png_byte)(
                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
                      ((((int)gamma_table[(d<<6)|(d<<4)|(d<<2)|d])>>6) ));
                  sp++;
               }
            }

            if (row_info->bit_depth == 4)
            {
               sp = row;
               for (i = 0; i < row_width; i += 2)
               {
                  int msb = *sp & 0xf0;
                  int lsb = *sp & 0x0f;

                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)
                      | (((int)gamma_table[(lsb << 4) | lsb]) >> 4));
                  sp++;
               }
            }

            else if (row_info->bit_depth == 8)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  *sp = gamma_table[*sp];
                  sp++;
               }
            }

            else if (row_info->bit_depth == 16)
            {
               sp = row;
               for (i = 0; i < row_width; i++)
               {
                  png_uint_16 v = gamma_16_table[*(sp + 1) >> gamma_shift][*sp];
                  *sp = (png_byte)((v >> 8) & 0xff);
                  *(sp + 1) = (png_byte)(v & 0xff);
                  sp += 2;
               }
            }
            break;
         }

         default:
            break;
      }
   }
}
#endif

#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
/* Encode the alpha channel to the output gamma (the input channel is always
 * linear.)  Called only with color types that have an alpha channel.  Needs the
 * from_1 tables.
 */
static void
png_do_encode_alpha(png_row_infop row_info, png_bytep row, png_structrp png_ptr)
{
   png_uint_32 row_width = row_info->width;

   png_debug(1, "in png_do_encode_alpha");

   if ((row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0)
   {
      if (row_info->bit_depth == 8)
      {
         PNG_CONST png_bytep table = png_ptr->gamma_from_1;

         if (table != NULL)
         {
            PNG_CONST int step =
               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 4 : 2;

            /* The alpha channel is the last component: */
            row += step - 1;

            for (; row_width > 0; --row_width, row += step)
               *row = table[*row];

            return;
         }
      }

      else if (row_info->bit_depth == 16)
      {
         PNG_CONST png_uint_16pp table = png_ptr->gamma_16_from_1;
         PNG_CONST int gamma_shift = png_ptr->gamma_shift;

         if (table != NULL)
         {
            PNG_CONST int step =
               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 8 : 4;

            /* The alpha channel is the last component: */
            row += step - 2;

            for (; row_width > 0; --row_width, row += step)
            {
               png_uint_16 v;

               v = table[*(row + 1) >> gamma_shift][*row];
               *row = (png_byte)((v >> 8) & 0xff);
               *(row + 1) = (png_byte)(v & 0xff);
            }

            return;
         }
      }
   }

   /* Only get to here if called with a weird row_info; no harm has been done,
    * so just issue a warning.
    */
   png_warning(png_ptr, "png_do_encode_alpha: unexpected call");
}
#endif

#ifdef PNG_READ_EXPAND_SUPPORTED
/* Expands a palette row to an RGB or RGBA row depending
 * upon whether you supply trans and num_trans.
 */
static void
png_do_expand_palette(png_row_infop row_info, png_bytep row,
    png_const_colorp palette, png_const_bytep trans_alpha, int num_trans)
{
   int shift, value;
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_expand_palette");

   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (row_info->bit_depth < 8)
      {
         switch (row_info->bit_depth)
         {
            case 1:
            {
               sp = row + (png_size_t)((row_width - 1) >> 3);
               dp = row + (png_size_t)row_width - 1;
               shift = 7 - (int)((row_width + 7) & 0x07);
               for (i = 0; i < row_width; i++)
               {
                  if ((*sp >> shift) & 0x01)
                     *dp = 1;

                  else
                     *dp = 0;

                  if (shift == 7)
                  {
                     shift = 0;
                     sp--;
                  }

                  else
                     shift++;

                  dp--;
               }
               break;
            }

            case 2:
            {
               sp = row + (png_size_t)((row_width - 1) >> 2);
               dp = row + (png_size_t)row_width - 1;
               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
               for (i = 0; i < row_width; i++)
               {
                  value = (*sp >> shift) & 0x03;
                  *dp = (png_byte)value;
                  if (shift == 6)
                  {
                     shift = 0;
                     sp--;
                  }

                  else
                     shift += 2;

                  dp--;
               }
               break;
            }

            case 4:
            {
               sp = row + (png_size_t)((row_width - 1) >> 1);
               dp = row + (png_size_t)row_width - 1;
               shift = (int)((row_width & 0x01) << 2);
               for (i = 0; i < row_width; i++)
               {
                  value = (*sp >> shift) & 0x0f;
                  *dp = (png_byte)value;
                  if (shift == 4)
                  {
                     shift = 0;
                     sp--;
                  }

                  else
                     shift += 4;

                  dp--;
               }
               break;
            }

            default:
               break;
         }
         row_info->bit_depth = 8;
         row_info->pixel_depth = 8;
         row_info->rowbytes = row_width;
      }

      if (row_info->bit_depth == 8)
      {
         {
            if (num_trans > 0)
            {
               sp = row + (png_size_t)row_width - 1;
               dp = row + (png_size_t)(row_width << 2) - 1;

               for (i = 0; i < row_width; i++)
               {
                  if ((int)(*sp) >= num_trans)
                     *dp-- = 0xff;

                  else
                     *dp-- = trans_alpha[*sp];

                  *dp-- = palette[*sp].blue;
                  *dp-- = palette[*sp].green;
                  *dp-- = palette[*sp].red;
                  sp--;
               }
               row_info->bit_depth = 8;
               row_info->pixel_depth = 32;
               row_info->rowbytes = row_width * 4;
               row_info->color_type = 6;
               row_info->channels = 4;
            }

            else
            {
               sp = row + (png_size_t)row_width - 1;
               dp = row + (png_size_t)(row_width * 3) - 1;

               for (i = 0; i < row_width; i++)
               {
                  *dp-- = palette[*sp].blue;
                  *dp-- = palette[*sp].green;
                  *dp-- = palette[*sp].red;
                  sp--;
               }

               row_info->bit_depth = 8;
               row_info->pixel_depth = 24;
               row_info->rowbytes = row_width * 3;
               row_info->color_type = 2;
               row_info->channels = 3;
            }
         }
      }
   }
}

/* If the bit depth < 8, it is expanded to 8.  Also, if the already
 * expanded transparency value is supplied, an alpha channel is built.
 */
static void
png_do_expand(png_row_infop row_info, png_bytep row,
    png_const_color_16p trans_color)
{
   int shift, value;
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_expand");

   {
      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
      {
         unsigned int gray = trans_color != NULL ? trans_color->gray : 0;

         if (row_info->bit_depth < 8)
         {
            switch (row_info->bit_depth)
            {
               case 1:
               {
                  gray = (gray & 0x01) * 0xff;
                  sp = row + (png_size_t)((row_width - 1) >> 3);
                  dp = row + (png_size_t)row_width - 1;
                  shift = 7 - (int)((row_width + 7) & 0x07);
                  for (i = 0; i < row_width; i++)
                  {
                     if ((*sp >> shift) & 0x01)
                        *dp = 0xff;

                     else
                        *dp = 0;

                     if (shift == 7)
                     {
                        shift = 0;
                        sp--;
                     }

                     else
                        shift++;

                     dp--;
                  }
                  break;
               }

               case 2:
               {
                  gray = (gray & 0x03) * 0x55;
                  sp = row + (png_size_t)((row_width - 1) >> 2);
                  dp = row + (png_size_t)row_width - 1;
                  shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
                  for (i = 0; i < row_width; i++)
                  {
                     value = (*sp >> shift) & 0x03;
                     *dp = (png_byte)(value | (value << 2) | (value << 4) |
                        (value << 6));
                     if (shift == 6)
                     {
                        shift = 0;
                        sp--;
                     }

                     else
                        shift += 2;

                     dp--;
                  }
                  break;
               }

               case 4:
               {
                  gray = (gray & 0x0f) * 0x11;
                  sp = row + (png_size_t)((row_width - 1) >> 1);
                  dp = row + (png_size_t)row_width - 1;
                  shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
                  for (i = 0; i < row_width; i++)
                  {
                     value = (*sp >> shift) & 0x0f;
                     *dp = (png_byte)(value | (value << 4));
                     if (shift == 4)
                     {
                        shift = 0;
                        sp--;
                     }

                     else
                        shift = 4;

                     dp--;
                  }
                  break;
               }

               default:
                  break;
            }

            row_info->bit_depth = 8;
            row_info->pixel_depth = 8;
            row_info->rowbytes = row_width;
         }

         if (trans_color != NULL)
         {
            if (row_info->bit_depth == 8)
            {
               gray = gray & 0xff;
               sp = row + (png_size_t)row_width - 1;
               dp = row + (png_size_t)(row_width << 1) - 1;

               for (i = 0; i < row_width; i++)
               {
                  if ((*sp & 0xffU) == gray)
                     *dp-- = 0;

                  else
                     *dp-- = 0xff;

                  *dp-- = *sp--;
               }
            }

            else if (row_info->bit_depth == 16)
            {
               unsigned int gray_high = (gray >> 8) & 0xff;
               unsigned int gray_low = gray & 0xff;
               sp = row + row_info->rowbytes - 1;
               dp = row + (row_info->rowbytes << 1) - 1;
               for (i = 0; i < row_width; i++)
               {
                  if ((*(sp - 1) & 0xffU) == gray_high &&
                      (*(sp) & 0xffU) == gray_low)
                  {
                     *dp-- = 0;
                     *dp-- = 0;
                  }

                  else
                  {
                     *dp-- = 0xff;
                     *dp-- = 0xff;
                  }

                  *dp-- = *sp--;
                  *dp-- = *sp--;
               }
            }

            row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
            row_info->channels = 2;
            row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
            row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
                row_width);
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_RGB &&
          trans_color != NULL)
      {
         if (row_info->bit_depth == 8)
         {
            png_byte red = (png_byte)(trans_color->red & 0xff);
            png_byte green = (png_byte)(trans_color->green & 0xff);
            png_byte blue = (png_byte)(trans_color->blue & 0xff);
            sp = row + (png_size_t)row_info->rowbytes - 1;
            dp = row + (png_size_t)(row_width << 2) - 1;
            for (i = 0; i < row_width; i++)
            {
               if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)
                  *dp-- = 0;

               else
                  *dp-- = 0xff;

               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
            }
         }
         else if (row_info->bit_depth == 16)
         {
            png_byte red_high = (png_byte)((trans_color->red >> 8) & 0xff);
            png_byte green_high = (png_byte)((trans_color->green >> 8) & 0xff);
            png_byte blue_high = (png_byte)((trans_color->blue >> 8) & 0xff);
            png_byte red_low = (png_byte)(trans_color->red & 0xff);
            png_byte green_low = (png_byte)(trans_color->green & 0xff);
            png_byte blue_low = (png_byte)(trans_color->blue & 0xff);
            sp = row + row_info->rowbytes - 1;
            dp = row + (png_size_t)(row_width << 3) - 1;
            for (i = 0; i < row_width; i++)
            {
               if (*(sp - 5) == red_high &&
                   *(sp - 4) == red_low &&
                   *(sp - 3) == green_high &&
                   *(sp - 2) == green_low &&
                   *(sp - 1) == blue_high &&
                   *(sp    ) == blue_low)
               {
                  *dp-- = 0;
                  *dp-- = 0;
               }

               else
               {
                  *dp-- = 0xff;
                  *dp-- = 0xff;
               }

               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
               *dp-- = *sp--;
            }
         }
         row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
         row_info->channels = 4;
         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
      }
   }
}
#endif

#ifdef PNG_READ_EXPAND_16_SUPPORTED
/* If the bit depth is 8 and the color type is not a palette type expand the
 * whole row to 16 bits.  Has no effect otherwise.
 */
static void
png_do_expand_16(png_row_infop row_info, png_bytep row)
{
   if (row_info->bit_depth == 8 &&
      row_info->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      /* The row have a sequence of bytes containing [0..255] and we need
       * to turn it into another row containing [0..65535], to do this we
       * calculate:
       *
       *  (input / 255) * 65535
       *
       *  Which happens to be exactly input * 257 and this can be achieved
       *  simply by byte replication in place (copying backwards).
       */
      png_byte *sp = row + row_info->rowbytes; /* source, last byte + 1 */
      png_byte *dp = sp + row_info->rowbytes;  /* destination, end + 1 */
      while (dp > sp)
         dp[-2] = dp[-1] = *--sp, dp -= 2;

      row_info->rowbytes *= 2;
      row_info->bit_depth = 16;
      row_info->pixel_depth = (png_byte)(row_info->channels * 16);
   }
}
#endif

#ifdef PNG_READ_QUANTIZE_SUPPORTED
static void
png_do_quantize(png_row_infop row_info, png_bytep row,
    png_const_bytep palette_lookup, png_const_bytep quantize_lookup)
{
   png_bytep sp, dp;
   png_uint_32 i;
   png_uint_32 row_width=row_info->width;

   png_debug(1, "in png_do_quantize");

   if (row_info->bit_depth == 8)
   {
      if (row_info->color_type == PNG_COLOR_TYPE_RGB && palette_lookup)
      {
         int r, g, b, p;
         sp = row;
         dp = row;
         for (i = 0; i < row_width; i++)
         {
            r = *sp++;
            g = *sp++;
            b = *sp++;

            /* This looks real messy, but the compiler will reduce
             * it down to a reasonable formula.  For example, with
             * 5 bits per color, we get:
             * p = (((r >> 3) & 0x1f) << 10) |
             *    (((g >> 3) & 0x1f) << 5) |
             *    ((b >> 3) & 0x1f);
             */
            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &
                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<
                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |
                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &
                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<
                (PNG_QUANTIZE_BLUE_BITS)) |
                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &
                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));

            *dp++ = palette_lookup[p];
         }

         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
         row_info->channels = 1;
         row_info->pixel_depth = row_info->bit_depth;
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
      }

      else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA &&
         palette_lookup != NULL)
      {
         int r, g, b, p;
         sp = row;
         dp = row;
         for (i = 0; i < row_width; i++)
         {
            r = *sp++;
            g = *sp++;
            b = *sp++;
            sp++;

            p = (((r >> (8 - PNG_QUANTIZE_RED_BITS)) &
                ((1 << PNG_QUANTIZE_RED_BITS) - 1)) <<
                (PNG_QUANTIZE_GREEN_BITS + PNG_QUANTIZE_BLUE_BITS)) |
                (((g >> (8 - PNG_QUANTIZE_GREEN_BITS)) &
                ((1 << PNG_QUANTIZE_GREEN_BITS) - 1)) <<
                (PNG_QUANTIZE_BLUE_BITS)) |
                ((b >> (8 - PNG_QUANTIZE_BLUE_BITS)) &
                ((1 << PNG_QUANTIZE_BLUE_BITS) - 1));

            *dp++ = palette_lookup[p];
         }

         row_info->color_type = PNG_COLOR_TYPE_PALETTE;
         row_info->channels = 1;
         row_info->pixel_depth = row_info->bit_depth;
         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
      }

      else if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
         quantize_lookup)
      {
         sp = row;

         for (i = 0; i < row_width; i++, sp++)
         {
            *sp = quantize_lookup[*sp];
         }
      }
   }
}
#endif /* READ_QUANTIZE */

/* Transform the row.  The order of transformations is significant,
 * and is very touchy.  If you add a transformation, take care to
 * decide how it fits in with the other transformations here.
 */
void /* PRIVATE */
png_do_read_transformations(png_structrp png_ptr, png_row_infop row_info)
{
   png_debug(1, "in png_do_read_transformations");

   if (png_ptr->row_buf == NULL)
   {
      /* Prior to 1.5.4 this output row/pass where the NULL pointer is, but this
       * error is incredibly rare and incredibly easy to debug without this
       * information.
       */
      png_error(png_ptr, "NULL row buffer");
   }

   /* The following is debugging; prior to 1.5.4 the code was never compiled in;
    * in 1.5.4 PNG_FLAG_DETECT_UNINITIALIZED was added and the macro
    * PNG_WARN_UNINITIALIZED_ROW removed.  In 1.6 the new flag is set only for
    * all transformations, however in practice the ROW_INIT always gets done on
    * demand, if necessary.
    */
   if ((png_ptr->flags & PNG_FLAG_DETECT_UNINITIALIZED) != 0 &&
       (png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
   {
      /* Application has failed to call either png_read_start_image() or
       * png_read_update_info() after setting transforms that expand pixels.
       * This check added to libpng-1.2.19 (but not enabled until 1.5.4).
       */
      png_error(png_ptr, "Uninitialized row");
   }

#ifdef PNG_READ_EXPAND_SUPPORTED
   if ((png_ptr->transformations & PNG_EXPAND) != 0)
   {
      if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_do_expand_palette(row_info, png_ptr->row_buf + 1,
             png_ptr->palette, png_ptr->trans_alpha, png_ptr->num_trans);
      }

      else
      {
         if (png_ptr->num_trans != 0 &&
             (png_ptr->transformations & PNG_EXPAND_tRNS) != 0)
            png_do_expand(row_info, png_ptr->row_buf + 1,
                &(png_ptr->trans_color));

         else
            png_do_expand(row_info, png_ptr->row_buf + 1,
                NULL);
      }
   }
#endif

#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0 &&
       (png_ptr->transformations & PNG_COMPOSE) == 0 &&
       (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
       row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
          0 /* at_start == false, because SWAP_ALPHA happens later */);
#endif

#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
   if ((png_ptr->transformations & PNG_RGB_TO_GRAY) != 0)
   {
      int rgb_error =
          png_do_rgb_to_gray(png_ptr, row_info,
              png_ptr->row_buf + 1);

      if (rgb_error != 0)
      {
         png_ptr->rgb_to_gray_status=1;
         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
             PNG_RGB_TO_GRAY_WARN)
            png_warning(png_ptr, "png_do_rgb_to_gray found nongray pixel");

         if ((png_ptr->transformations & PNG_RGB_TO_GRAY) ==
             PNG_RGB_TO_GRAY_ERR)
            png_error(png_ptr, "png_do_rgb_to_gray found nongray pixel");
      }
   }
#endif

/* From Andreas Dilger e-mail to png-implement, 26 March 1998:
 *
 *   In most cases, the "simple transparency" should be done prior to doing
 *   gray-to-RGB, or you will have to test 3x as many bytes to check if a
 *   pixel is transparent.  You would also need to make sure that the
 *   transparency information is upgraded to RGB.
 *
 *   To summarize, the current flow is:
 *   - Gray + simple transparency -> compare 1 or 2 gray bytes and composite
 *                                   with background "in place" if transparent,
 *                                   convert to RGB if necessary
 *   - Gray + alpha -> composite with gray background and remove alpha bytes,
 *                                   convert to RGB if necessary
 *
 *   To support RGB backgrounds for gray images we need:
 *   - Gray + simple transparency -> convert to RGB + simple transparency,
 *                                   compare 3 or 6 bytes and composite with
 *                                   background "in place" if transparent
 *                                   (3x compare/pixel compared to doing
 *                                   composite with gray bkgrnd)
 *   - Gray + alpha -> convert to RGB + alpha, composite with background and
 *                                   remove alpha bytes (3x float
 *                                   operations/pixel compared with composite
 *                                   on gray background)
 *
 *  Greg's change will do this.  The reason it wasn't done before is for
 *  performance, as this increases the per-pixel operations.  If we would check
 *  in advance if the background was gray or RGB, and position the gray-to-RGB
 *  transform appropriately, then it would save a lot of work/time.
 */

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   /* If gray -> RGB, do so now only if background is non-gray; else do later
    * for performance reasons
    */
   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0 &&
       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY) == 0)
      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
#endif

#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
   if ((png_ptr->transformations & PNG_COMPOSE) != 0)
      png_do_compose(row_info, png_ptr->row_buf + 1, png_ptr);
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
   if ((png_ptr->transformations & PNG_GAMMA) != 0 &&
#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
      /* Because RGB_TO_GRAY does the gamma transform. */
      (png_ptr->transformations & PNG_RGB_TO_GRAY) == 0 &&
#endif
#if defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
      /* Because PNG_COMPOSE does the gamma transform if there is something to
       * do (if there is an alpha channel or transparency.)
       */
       !((png_ptr->transformations & PNG_COMPOSE) != 0 &&
       ((png_ptr->num_trans != 0) ||
       (png_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)) &&
#endif
      /* Because png_init_read_transformations transforms the palette, unless
       * RGB_TO_GRAY will do the transform.
       */
       (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE))
      png_do_gamma(row_info, png_ptr->row_buf + 1, png_ptr);
#endif

#ifdef PNG_READ_STRIP_ALPHA_SUPPORTED
   if ((png_ptr->transformations & PNG_STRIP_ALPHA) != 0 &&
       (png_ptr->transformations & PNG_COMPOSE) != 0 &&
       (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA ||
       row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA))
      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
          0 /* at_start == false, because SWAP_ALPHA happens later */);
#endif

#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
   if ((png_ptr->transformations & PNG_ENCODE_ALPHA) != 0 &&
       (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0)
      png_do_encode_alpha(row_info, png_ptr->row_buf + 1, png_ptr);
#endif

#ifdef PNG_READ_SCALE_16_TO_8_SUPPORTED
   if ((png_ptr->transformations & PNG_SCALE_16_TO_8) != 0)
      png_do_scale_16_to_8(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_STRIP_16_TO_8_SUPPORTED
   /* There is no harm in doing both of these because only one has any effect,
    * by putting the 'scale' option first if the app asks for scale (either by
    * calling the API or in a TRANSFORM flag) this is what happens.
    */
   if ((png_ptr->transformations & PNG_16_TO_8) != 0)
      png_do_chop(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_QUANTIZE_SUPPORTED
   if ((png_ptr->transformations & PNG_QUANTIZE) != 0)
   {
      png_do_quantize(row_info, png_ptr->row_buf + 1,
          png_ptr->palette_lookup, png_ptr->quantize_index);

      if (row_info->rowbytes == 0)
         png_error(png_ptr, "png_do_quantize returned rowbytes=0");
   }
#endif /* READ_QUANTIZE */

#ifdef PNG_READ_EXPAND_16_SUPPORTED
   /* Do the expansion now, after all the arithmetic has been done.  Notice
    * that previous transformations can handle the PNG_EXPAND_16 flag if this
    * is efficient (particularly true in the case of gamma correction, where
    * better accuracy results faster!)
    */
   if ((png_ptr->transformations & PNG_EXPAND_16) != 0)
      png_do_expand_16(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   /* NOTE: moved here in 1.5.4 (from much later in this list.) */
   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0 &&
       (png_ptr->mode & PNG_BACKGROUND_IS_GRAY) != 0)
      png_do_gray_to_rgb(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_INVERT_SUPPORTED
   if ((png_ptr->transformations & PNG_INVERT_MONO) != 0)
      png_do_invert(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
   if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0)
      png_do_read_invert_alpha(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_SHIFT_SUPPORTED
   if ((png_ptr->transformations & PNG_SHIFT) != 0)
      png_do_unshift(row_info, png_ptr->row_buf + 1,
          &(png_ptr->shift));
#endif

#ifdef PNG_READ_PACK_SUPPORTED
   if ((png_ptr->transformations & PNG_PACK) != 0)
      png_do_unpack(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED
   /* Added at libpng-1.5.10 */
   if (row_info->color_type == PNG_COLOR_TYPE_PALETTE &&
       png_ptr->num_palette_max >= 0)
      png_do_check_palette_indexes(png_ptr, row_info);
#endif

#ifdef PNG_READ_BGR_SUPPORTED
   if ((png_ptr->transformations & PNG_BGR) != 0)
      png_do_bgr(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_PACKSWAP_SUPPORTED
   if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
      png_do_packswap(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_FILLER_SUPPORTED
   if ((png_ptr->transformations & PNG_FILLER) != 0)
      png_do_read_filler(row_info, png_ptr->row_buf + 1,
          (png_uint_32)png_ptr->filler, png_ptr->flags);
#endif

#ifdef PNG_READ_SWAP_ALPHA_SUPPORTED
   if ((png_ptr->transformations & PNG_SWAP_ALPHA) != 0)
      png_do_read_swap_alpha(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_READ_16BIT_SUPPORTED
#ifdef PNG_READ_SWAP_SUPPORTED
   if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)
      png_do_swap(row_info, png_ptr->row_buf + 1);
#endif
#endif

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
   {
      if (png_ptr->read_user_transform_fn != NULL)
         (*(png_ptr->read_user_transform_fn)) /* User read transform function */
             (png_ptr,     /* png_ptr */
             row_info,     /* row_info: */
                /*  png_uint_32 width;       width of row */
                /*  png_size_t rowbytes;     number of bytes in row */
                /*  png_byte color_type;     color type of pixels */
                /*  png_byte bit_depth;      bit depth of samples */
                /*  png_byte channels;       number of channels (1-4) */
                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
             png_ptr->row_buf + 1);    /* start of pixel data for row */
#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
      if (png_ptr->user_transform_depth != 0)
         row_info->bit_depth = png_ptr->user_transform_depth;

      if (png_ptr->user_transform_channels != 0)
         row_info->channels = png_ptr->user_transform_channels;
#endif
      row_info->pixel_depth = (png_byte)(row_info->bit_depth *
          row_info->channels);

      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_info->width);
   }
#endif
}

#endif /* READ_TRANSFORMS */
#endif /* READ */

```

`ThirdPartyBuild/PNG/Code/pngrutil.c`:

```c

/* pngrutil.c - utilities to read a PNG file
 *
 * Last changed in libpng 1.6.27 [January 5, 2017]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This file contains routines that are only called from within
 * libpng itself during the course of reading an image.
 */

#include "pngpriv.h"

#ifdef PNG_READ_SUPPORTED

png_uint_32 PNGAPI
png_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)
{
   png_uint_32 uval = png_get_uint_32(buf);

   if (uval > PNG_UINT_31_MAX)
      png_error(png_ptr, "PNG unsigned integer out of range");

   return (uval);
}

#if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_READ_cHRM_SUPPORTED)
/* The following is a variation on the above for use with the fixed
 * point values used for gAMA and cHRM.  Instead of png_error it
 * issues a warning and returns (-1) - an invalid value because both
 * gAMA and cHRM use *unsigned* integers for fixed point values.
 */
#define PNG_FIXED_ERROR (-1)

static png_fixed_point /* PRIVATE */
png_get_fixed_point(png_structrp png_ptr, png_const_bytep buf)
{
   png_uint_32 uval = png_get_uint_32(buf);

   if (uval <= PNG_UINT_31_MAX)
      return (png_fixed_point)uval; /* known to be in range */

   /* The caller can turn off the warning by passing NULL. */
   if (png_ptr != NULL)
      png_warning(png_ptr, "PNG fixed point integer out of range");

   return PNG_FIXED_ERROR;
}
#endif

#ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED
/* NOTE: the read macros will obscure these definitions, so that if
 * PNG_USE_READ_MACROS is set the library will not use them internally,
 * but the APIs will still be available externally.
 *
 * The parentheses around "PNGAPI function_name" in the following three
 * functions are necessary because they allow the macros to co-exist with
 * these (unused but exported) functions.
 */

/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
png_uint_32 (PNGAPI
png_get_uint_32)(png_const_bytep buf)
{
   png_uint_32 uval =
       ((png_uint_32)(*(buf    )) << 24) +
       ((png_uint_32)(*(buf + 1)) << 16) +
       ((png_uint_32)(*(buf + 2)) <<  8) +
       ((png_uint_32)(*(buf + 3))      ) ;

   return uval;
}

/* Grab a signed 32-bit integer from a buffer in big-endian format.  The
 * data is stored in the PNG file in two's complement format and there
 * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore
 * the following code does a two's complement to native conversion.
 */
png_int_32 (PNGAPI
png_get_int_32)(png_const_bytep buf)
{
   png_uint_32 uval = png_get_uint_32(buf);
   if ((uval & 0x80000000) == 0) /* non-negative */
      return (png_int_32)uval;

   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */
   if ((uval & 0x80000000) == 0) /* no overflow */
      return -(png_int_32)uval;
   /* The following has to be safe; this function only gets called on PNG data
    * and if we get here that data is invalid.  0 is the most safe value and
    * if not then an attacker would surely just generate a PNG with 0 instead.
    */
   return 0;
}

/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
png_uint_16 (PNGAPI
png_get_uint_16)(png_const_bytep buf)
{
   /* ANSI-C requires an int value to accomodate at least 16 bits so this
    * works and allows the compiler not to worry about possible narrowing
    * on 32-bit systems.  (Pre-ANSI systems did not make integers smaller
    * than 16 bits either.)
    */
   unsigned int val =
       ((unsigned int)(*buf) << 8) +
       ((unsigned int)(*(buf + 1)));

   return (png_uint_16)val;
}

#endif /* READ_INT_FUNCTIONS */

/* Read and check the PNG file signature */
void /* PRIVATE */
png_read_sig(png_structrp png_ptr, png_inforp info_ptr)
{
   png_size_t num_checked, num_to_check;

   /* Exit if the user application does not expect a signature. */
   if (png_ptr->sig_bytes >= 8)
      return;

   num_checked = png_ptr->sig_bytes;
   num_to_check = 8 - num_checked;

#ifdef PNG_IO_STATE_SUPPORTED
   png_ptr->io_state = PNG_IO_READING | PNG_IO_SIGNATURE;
#endif

   /* The signature must be serialized in a single I/O call. */
   png_read_data(png_ptr, &(info_ptr->signature[num_checked]), num_to_check);
   png_ptr->sig_bytes = 8;

   if (png_sig_cmp(info_ptr->signature, num_checked, num_to_check) != 0)
   {
      if (num_checked < 4 &&
          png_sig_cmp(info_ptr->signature, num_checked, num_to_check - 4))
         png_error(png_ptr, "Not a PNG file");
      else
         png_error(png_ptr, "PNG file corrupted by ASCII conversion");
   }
   if (num_checked < 3)
      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
}

/* Read the chunk header (length + type name).
 * Put the type name into png_ptr->chunk_name, and return the length.
 */
png_uint_32 /* PRIVATE */
png_read_chunk_header(png_structrp png_ptr)
{
   png_byte buf[8];
   png_uint_32 length;

#ifdef PNG_IO_STATE_SUPPORTED
   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;
#endif

   /* Read the length and the chunk name.
    * This must be performed in a single I/O call.
    */
   png_read_data(png_ptr, buf, 8);
   length = png_get_uint_31(png_ptr, buf);

   /* Put the chunk name into png_ptr->chunk_name. */
   png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);

   png_debug2(0, "Reading %lx chunk, length = %lu",
       (unsigned long)png_ptr->chunk_name, (unsigned long)length);

   /* Reset the crc and run it over the chunk name. */
   png_reset_crc(png_ptr);
   png_calculate_crc(png_ptr, buf + 4, 4);

   /* Check to see if chunk name is valid. */
   png_check_chunk_name(png_ptr, png_ptr->chunk_name);

#ifdef PNG_IO_STATE_SUPPORTED
   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;
#endif

   return length;
}

/* Read data, and (optionally) run it through the CRC. */
void /* PRIVATE */
png_crc_read(png_structrp png_ptr, png_bytep buf, png_uint_32 length)
{
   if (png_ptr == NULL)
      return;

   png_read_data(png_ptr, buf, length);
   png_calculate_crc(png_ptr, buf, length);
}

/* Optionally skip data and then check the CRC.  Depending on whether we
 * are reading an ancillary or critical chunk, and how the program has set
 * things up, we may calculate the CRC on the data and print a message.
 * Returns '1' if there was a CRC error, '0' otherwise.
 */
int /* PRIVATE */
png_crc_finish(png_structrp png_ptr, png_uint_32 skip)
{
   /* The size of the local buffer for inflate is a good guess as to a
    * reasonable size to use for buffering reads from the application.
    */
   while (skip > 0)
   {
      png_uint_32 len;
      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];

      len = (sizeof tmpbuf);
      if (len > skip)
         len = skip;
      skip -= len;

      png_crc_read(png_ptr, tmpbuf, len);
   }

   if (png_crc_error(png_ptr) != 0)
   {
      if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?
          (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0 :
          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE) != 0)
      {
         png_chunk_warning(png_ptr, "CRC error");
      }

      else
         png_chunk_error(png_ptr, "CRC error");

      return (1);
   }

   return (0);
}

/* Compare the CRC stored in the PNG file with that calculated by libpng from
 * the data it has read thus far.
 */
int /* PRIVATE */
png_crc_error(png_structrp png_ptr)
{
   png_byte crc_bytes[4];
   png_uint_32 crc;
   int need_crc = 1;

   if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)
   {
      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
         need_crc = 0;
   }

   else /* critical */
   {
      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)
         need_crc = 0;
   }

#ifdef PNG_IO_STATE_SUPPORTED
   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;
#endif

   /* The chunk CRC must be serialized in a single I/O call. */
   png_read_data(png_ptr, crc_bytes, 4);

   if (need_crc != 0)
   {
      crc = png_get_uint_32(crc_bytes);
      return ((int)(crc != png_ptr->crc));
   }

   else
      return (0);
}

#if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\
    defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_sCAL_SUPPORTED) ||\
    defined(PNG_READ_sPLT_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) ||\
    defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)
/* Manage the read buffer; this simply reallocates the buffer if it is not small
 * enough (or if it is not allocated).  The routine returns a pointer to the
 * buffer; if an error occurs and 'warn' is set the routine returns NULL, else
 * it will call png_error (via png_malloc) on failure.  (warn == 2 means
 * 'silent').
 */
static png_bytep
png_read_buffer(png_structrp png_ptr, png_alloc_size_t new_size, int warn)
{
   png_bytep buffer = png_ptr->read_buffer;

   if (buffer != NULL && new_size > png_ptr->read_buffer_size)
   {
      png_ptr->read_buffer = NULL;
      png_ptr->read_buffer = NULL;
      png_ptr->read_buffer_size = 0;
      png_free(png_ptr, buffer);
      buffer = NULL;
   }

   if (buffer == NULL)
   {
      buffer = png_voidcast(png_bytep, png_malloc_base(png_ptr, new_size));

      if (buffer != NULL)
      {
         png_ptr->read_buffer = buffer;
         png_ptr->read_buffer_size = new_size;
      }

      else if (warn < 2) /* else silent */
      {
         if (warn != 0)
             png_chunk_warning(png_ptr, "insufficient memory to read chunk");

         else
             png_chunk_error(png_ptr, "insufficient memory to read chunk");
      }
   }

   return buffer;
}
#endif /* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ */

/* png_inflate_claim: claim the zstream for some nefarious purpose that involves
 * decompression.  Returns Z_OK on success, else a zlib error code.  It checks
 * the owner but, in final release builds, just issues a warning if some other
 * chunk apparently owns the stream.  Prior to release it does a png_error.
 */
static int
png_inflate_claim(png_structrp png_ptr, png_uint_32 owner)
{
   if (png_ptr->zowner != 0)
   {
      char msg[64];

      PNG_STRING_FROM_CHUNK(msg, png_ptr->zowner);
      /* So the message that results is "<chunk> using zstream"; this is an
       * internal error, but is very useful for debugging.  i18n requirements
       * are minimal.
       */
      (void)png_safecat(msg, (sizeof msg), 4, " using zstream");
#if PNG_RELEASE_BUILD
      png_chunk_warning(png_ptr, msg);
      png_ptr->zowner = 0;
#else
      png_chunk_error(png_ptr, msg);
#endif
   }

   /* Implementation note: unlike 'png_deflate_claim' this internal function
    * does not take the size of the data as an argument.  Some efficiency could
    * be gained by using this when it is known *if* the zlib stream itself does
    * not record the number; however, this is an illusion: the original writer
    * of the PNG may have selected a lower window size, and we really must
    * follow that because, for systems with with limited capabilities, we
    * would otherwise reject the application's attempts to use a smaller window
    * size (zlib doesn't have an interface to say "this or lower"!).
    *
    * inflateReset2 was added to zlib 1.2.4; before this the window could not be
    * reset, therefore it is necessary to always allocate the maximum window
    * size with earlier zlibs just in case later compressed chunks need it.
    */
   {
      int ret; /* zlib return code */
#if ZLIB_VERNUM >= 0x1240
      int window_bits = 0;

# if defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_MAXIMUM_INFLATE_WINDOW)
      if (((png_ptr->options >> PNG_MAXIMUM_INFLATE_WINDOW) & 3) ==
          PNG_OPTION_ON)
      {
         window_bits = 15;
         png_ptr->zstream_start = 0; /* fixed window size */
      }

      else
      {
         png_ptr->zstream_start = 1;
      }
# endif

#endif /* ZLIB_VERNUM >= 0x1240 */

      /* Set this for safety, just in case the previous owner left pointers to
       * memory allocations.
       */
      png_ptr->zstream.next_in = NULL;
      png_ptr->zstream.avail_in = 0;
      png_ptr->zstream.next_out = NULL;
      png_ptr->zstream.avail_out = 0;

      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
      {
#if ZLIB_VERNUM >= 0x1240
         ret = inflateReset2(&png_ptr->zstream, window_bits);
#else
         ret = inflateReset(&png_ptr->zstream);
#endif
      }

      else
      {
#if ZLIB_VERNUM >= 0x1240
         ret = inflateInit2(&png_ptr->zstream, window_bits);
#else
         ret = inflateInit(&png_ptr->zstream);
#endif

         if (ret == Z_OK)
            png_ptr->flags |= PNG_FLAG_ZSTREAM_INITIALIZED;
      }

#if ZLIB_VERNUM >= 0x1281 && \
   defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_IGNORE_ADLER32)
      if (((png_ptr->options >> PNG_IGNORE_ADLER32) & 3) == PNG_OPTION_ON)
         /* Turn off validation of the ADLER32 checksum in IDAT chunks */
         ret = inflateValidate(&png_ptr->zstream, 0);
#endif

      if (ret == Z_OK)
         png_ptr->zowner = owner;

      else
         png_zstream_error(png_ptr, ret);

      return ret;
   }

#ifdef window_bits
# undef window_bits
#endif
}

#if ZLIB_VERNUM >= 0x1240
/* Handle the start of the inflate stream if we called inflateInit2(strm,0);
 * in this case some zlib versions skip validation of the CINFO field and, in
 * certain circumstances, libpng may end up displaying an invalid image, in
 * contrast to implementations that call zlib in the normal way (e.g. libpng
 * 1.5).
 */
int /* PRIVATE */
png_zlib_inflate(png_structrp png_ptr, int flush)
{
   if (png_ptr->zstream_start && png_ptr->zstream.avail_in > 0)
   {
      if ((*png_ptr->zstream.next_in >> 4) > 7)
      {
         png_ptr->zstream.msg = "invalid window size (libpng)";
         return Z_DATA_ERROR;
      }

      png_ptr->zstream_start = 0;
   }

   return inflate(&png_ptr->zstream, flush);
}
#endif /* Zlib >= 1.2.4 */

#ifdef PNG_READ_COMPRESSED_TEXT_SUPPORTED
#if defined(PNG_READ_zTXt_SUPPORTED) || defined (PNG_READ_iTXt_SUPPORTED)
/* png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to
 * allow the caller to do multiple calls if required.  If the 'finish' flag is
 * set Z_FINISH will be passed to the final inflate() call and Z_STREAM_END must
 * be returned or there has been a problem, otherwise Z_SYNC_FLUSH is used and
 * Z_OK or Z_STREAM_END will be returned on success.
 *
 * The input and output sizes are updated to the actual amounts of data consumed
 * or written, not the amount available (as in a z_stream).  The data pointers
 * are not changed, so the next input is (data+input_size) and the next
 * available output is (output+output_size).
 */
static int
png_inflate(png_structrp png_ptr, png_uint_32 owner, int finish,
    /* INPUT: */ png_const_bytep input, png_uint_32p input_size_ptr,
    /* OUTPUT: */ png_bytep output, png_alloc_size_t *output_size_ptr)
{
   if (png_ptr->zowner == owner) /* Else not claimed */
   {
      int ret;
      png_alloc_size_t avail_out = *output_size_ptr;
      png_uint_32 avail_in = *input_size_ptr;

      /* zlib can't necessarily handle more than 65535 bytes at once (i.e. it
       * can't even necessarily handle 65536 bytes) because the type uInt is
       * "16 bits or more".  Consequently it is necessary to chunk the input to
       * zlib.  This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the
       * maximum value that can be stored in a uInt.)  It is possible to set
       * ZLIB_IO_MAX to a lower value in pngpriv.h and this may sometimes have
       * a performance advantage, because it reduces the amount of data accessed
       * at each step and that may give the OS more time to page it in.
       */
      png_ptr->zstream.next_in = PNGZ_INPUT_CAST(input);
      /* avail_in and avail_out are set below from 'size' */
      png_ptr->zstream.avail_in = 0;
      png_ptr->zstream.avail_out = 0;

      /* Read directly into the output if it is available (this is set to
       * a local buffer below if output is NULL).
       */
      if (output != NULL)
         png_ptr->zstream.next_out = output;

      do
      {
         uInt avail;
         Byte local_buffer[PNG_INFLATE_BUF_SIZE];

         /* zlib INPUT BUFFER */
         /* The setting of 'avail_in' used to be outside the loop; by setting it
          * inside it is possible to chunk the input to zlib and simply rely on
          * zlib to advance the 'next_in' pointer.  This allows arbitrary
          * amounts of data to be passed through zlib at the unavoidable cost of
          * requiring a window save (memcpy of up to 32768 output bytes)
          * every ZLIB_IO_MAX input bytes.
          */
         avail_in += png_ptr->zstream.avail_in; /* not consumed last time */

         avail = ZLIB_IO_MAX;

         if (avail_in < avail)
            avail = (uInt)avail_in; /* safe: < than ZLIB_IO_MAX */

         avail_in -= avail;
         png_ptr->zstream.avail_in = avail;

         /* zlib OUTPUT BUFFER */
         avail_out += png_ptr->zstream.avail_out; /* not written last time */

         avail = ZLIB_IO_MAX; /* maximum zlib can process */

         if (output == NULL)
         {
            /* Reset the output buffer each time round if output is NULL and
             * make available the full buffer, up to 'remaining_space'
             */
            png_ptr->zstream.next_out = local_buffer;
            if ((sizeof local_buffer) < avail)
               avail = (sizeof local_buffer);
         }

         if (avail_out < avail)
            avail = (uInt)avail_out; /* safe: < ZLIB_IO_MAX */

         png_ptr->zstream.avail_out = avail;
         avail_out -= avail;

         /* zlib inflate call */
         /* In fact 'avail_out' may be 0 at this point, that happens at the end
          * of the read when the final LZ end code was not passed at the end of
          * the previous chunk of input data.  Tell zlib if we have reached the
          * end of the output buffer.
          */
         ret = PNG_INFLATE(png_ptr, avail_out > 0 ? Z_NO_FLUSH :
             (finish ? Z_FINISH : Z_SYNC_FLUSH));
      } while (ret == Z_OK);

      /* For safety kill the local buffer pointer now */
      if (output == NULL)
         png_ptr->zstream.next_out = NULL;

      /* Claw back the 'size' and 'remaining_space' byte counts. */
      avail_in += png_ptr->zstream.avail_in;
      avail_out += png_ptr->zstream.avail_out;

      /* Update the input and output sizes; the updated values are the amount
       * consumed or written, effectively the inverse of what zlib uses.
       */
      if (avail_out > 0)
         *output_size_ptr -= avail_out;

      if (avail_in > 0)
         *input_size_ptr -= avail_in;

      /* Ensure png_ptr->zstream.msg is set (even in the success case!) */
      png_zstream_error(png_ptr, ret);
      return ret;
   }

   else
   {
      /* This is a bad internal error.  The recovery assigns to the zstream msg
       * pointer, which is not owned by the caller, but this is safe; it's only
       * used on errors!
       */
      png_ptr->zstream.msg = PNGZ_MSG_CAST("zstream unclaimed");
      return Z_STREAM_ERROR;
   }
}

/*
 * Decompress trailing data in a chunk.  The assumption is that read_buffer
 * points at an allocated area holding the contents of a chunk with a
 * trailing compressed part.  What we get back is an allocated area
 * holding the original prefix part and an uncompressed version of the
 * trailing part (the malloc area passed in is freed).
 */
static int
png_decompress_chunk(png_structrp png_ptr,
    png_uint_32 chunklength, png_uint_32 prefix_size,
    png_alloc_size_t *newlength /* must be initialized to the maximum! */,
    int terminate /*add a '\0' to the end of the uncompressed data*/)
{
   /* TODO: implement different limits for different types of chunk.
    *
    * The caller supplies *newlength set to the maximum length of the
    * uncompressed data, but this routine allocates space for the prefix and
    * maybe a '\0' terminator too.  We have to assume that 'prefix_size' is
    * limited only by the maximum chunk size.
    */
   png_alloc_size_t limit = PNG_SIZE_MAX;

# ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_malloc_max > 0 &&
       png_ptr->user_chunk_malloc_max < limit)
      limit = png_ptr->user_chunk_malloc_max;
# elif PNG_USER_CHUNK_MALLOC_MAX > 0
   if (PNG_USER_CHUNK_MALLOC_MAX < limit)
      limit = PNG_USER_CHUNK_MALLOC_MAX;
# endif

   if (limit >= prefix_size + (terminate != 0))
   {
      int ret;

      limit -= prefix_size + (terminate != 0);

      if (limit < *newlength)
         *newlength = limit;

      /* Now try to claim the stream. */
      ret = png_inflate_claim(png_ptr, png_ptr->chunk_name);

      if (ret == Z_OK)
      {
         png_uint_32 lzsize = chunklength - prefix_size;

         ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,
             /* input: */ png_ptr->read_buffer + prefix_size, &lzsize,
             /* output: */ NULL, newlength);

         if (ret == Z_STREAM_END)
         {
            /* Use 'inflateReset' here, not 'inflateReset2' because this
             * preserves the previously decided window size (otherwise it would
             * be necessary to store the previous window size.)  In practice
             * this doesn't matter anyway, because png_inflate will call inflate
             * with Z_FINISH in almost all cases, so the window will not be
             * maintained.
             */
            if (inflateReset(&png_ptr->zstream) == Z_OK)
            {
               /* Because of the limit checks above we know that the new,
                * expanded, size will fit in a size_t (let alone an
                * png_alloc_size_t).  Use png_malloc_base here to avoid an
                * extra OOM message.
                */
               png_alloc_size_t new_size = *newlength;
               png_alloc_size_t buffer_size = prefix_size + new_size +
                   (terminate != 0);
               png_bytep text = png_voidcast(png_bytep, png_malloc_base(png_ptr,
                   buffer_size));

               if (text != NULL)
               {
                  ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,
                      png_ptr->read_buffer + prefix_size, &lzsize,
                      text + prefix_size, newlength);

                  if (ret == Z_STREAM_END)
                  {
                     if (new_size == *newlength)
                     {
                        if (terminate != 0)
                           text[prefix_size + *newlength] = 0;

                        if (prefix_size > 0)
                           memcpy(text, png_ptr->read_buffer, prefix_size);

                        {
                           png_bytep old_ptr = png_ptr->read_buffer;

                           png_ptr->read_buffer = text;
                           png_ptr->read_buffer_size = buffer_size;
                           text = old_ptr; /* freed below */
                        }
                     }

                     else
                     {
                        /* The size changed on the second read, there can be no
                         * guarantee that anything is correct at this point.
                         * The 'msg' pointer has been set to "unexpected end of
                         * LZ stream", which is fine, but return an error code
                         * that the caller won't accept.
                         */
                        ret = PNG_UNEXPECTED_ZLIB_RETURN;
                     }
                  }

                  else if (ret == Z_OK)
                     ret = PNG_UNEXPECTED_ZLIB_RETURN; /* for safety */

                  /* Free the text pointer (this is the old read_buffer on
                   * success)
                   */
                  png_free(png_ptr, text);

                  /* This really is very benign, but it's still an error because
                   * the extra space may otherwise be used as a Trojan Horse.
                   */
                  if (ret == Z_STREAM_END &&
                      chunklength - prefix_size != lzsize)
                     png_chunk_benign_error(png_ptr, "extra compressed data");
               }

               else
               {
                  /* Out of memory allocating the buffer */
                  ret = Z_MEM_ERROR;
                  png_zstream_error(png_ptr, Z_MEM_ERROR);
               }
            }

            else
            {
               /* inflateReset failed, store the error message */
               png_zstream_error(png_ptr, ret);

               if (ret == Z_STREAM_END)
                  ret = PNG_UNEXPECTED_ZLIB_RETURN;
            }
         }

         else if (ret == Z_OK)
            ret = PNG_UNEXPECTED_ZLIB_RETURN;

         /* Release the claimed stream */
         png_ptr->zowner = 0;
      }

      else /* the claim failed */ if (ret == Z_STREAM_END) /* impossible! */
         ret = PNG_UNEXPECTED_ZLIB_RETURN;

      return ret;
   }

   else
   {
      /* Application/configuration limits exceeded */
      png_zstream_error(png_ptr, Z_MEM_ERROR);
      return Z_MEM_ERROR;
   }
}
#endif /* READ_zTXt || READ_iTXt */
#endif /* READ_COMPRESSED_TEXT */

#ifdef PNG_READ_iCCP_SUPPORTED
/* Perform a partial read and decompress, producing 'avail_out' bytes and
 * reading from the current chunk as required.
 */
static int
png_inflate_read(png_structrp png_ptr, png_bytep read_buffer, uInt read_size,
    png_uint_32p chunk_bytes, png_bytep next_out, png_alloc_size_t *out_size,
    int finish)
{
   if (png_ptr->zowner == png_ptr->chunk_name)
   {
      int ret;

      /* next_in and avail_in must have been initialized by the caller. */
      png_ptr->zstream.next_out = next_out;
      png_ptr->zstream.avail_out = 0; /* set in the loop */

      do
      {
         if (png_ptr->zstream.avail_in == 0)
         {
            if (read_size > *chunk_bytes)
               read_size = (uInt)*chunk_bytes;
            *chunk_bytes -= read_size;

            if (read_size > 0)
               png_crc_read(png_ptr, read_buffer, read_size);

            png_ptr->zstream.next_in = read_buffer;
            png_ptr->zstream.avail_in = read_size;
         }

         if (png_ptr->zstream.avail_out == 0)
         {
            uInt avail = ZLIB_IO_MAX;
            if (avail > *out_size)
               avail = (uInt)*out_size;
            *out_size -= avail;

            png_ptr->zstream.avail_out = avail;
         }

         /* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all
          * the available output is produced; this allows reading of truncated
          * streams.
          */
         ret = PNG_INFLATE(png_ptr, *chunk_bytes > 0 ?
             Z_NO_FLUSH : (finish ? Z_FINISH : Z_SYNC_FLUSH));
      }
      while (ret == Z_OK && (*out_size > 0 || png_ptr->zstream.avail_out > 0));

      *out_size += png_ptr->zstream.avail_out;
      png_ptr->zstream.avail_out = 0; /* Should not be required, but is safe */

      /* Ensure the error message pointer is always set: */
      png_zstream_error(png_ptr, ret);
      return ret;
   }

   else
   {
      png_ptr->zstream.msg = PNGZ_MSG_CAST("zstream unclaimed");
      return Z_STREAM_ERROR;
   }
}
#endif /* READ_iCCP */

/* Read and check the IDHR chunk */

void /* PRIVATE */
png_handle_IHDR(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_byte buf[13];
   png_uint_32 width, height;
   int bit_depth, color_type, compression_type, filter_type;
   int interlace_type;

   png_debug(1, "in png_handle_IHDR");

   if ((png_ptr->mode & PNG_HAVE_IHDR) != 0)
      png_chunk_error(png_ptr, "out of place");

   /* Check the length */
   if (length != 13)
      png_chunk_error(png_ptr, "invalid");

   png_ptr->mode |= PNG_HAVE_IHDR;

   png_crc_read(png_ptr, buf, 13);
   png_crc_finish(png_ptr, 0);

   width = png_get_uint_31(png_ptr, buf);
   height = png_get_uint_31(png_ptr, buf + 4);
   bit_depth = buf[8];
   color_type = buf[9];
   compression_type = buf[10];
   filter_type = buf[11];
   interlace_type = buf[12];

   /* Set internal variables */
   png_ptr->width = width;
   png_ptr->height = height;
   png_ptr->bit_depth = (png_byte)bit_depth;
   png_ptr->interlaced = (png_byte)interlace_type;
   png_ptr->color_type = (png_byte)color_type;
#ifdef PNG_MNG_FEATURES_SUPPORTED
   png_ptr->filter_type = (png_byte)filter_type;
#endif
   png_ptr->compression_type = (png_byte)compression_type;

   /* Find number of channels */
   switch (png_ptr->color_type)
   {
      default: /* invalid, png_set_IHDR calls png_error */
      case PNG_COLOR_TYPE_GRAY:
      case PNG_COLOR_TYPE_PALETTE:
         png_ptr->channels = 1;
         break;

      case PNG_COLOR_TYPE_RGB:
         png_ptr->channels = 3;
         break;

      case PNG_COLOR_TYPE_GRAY_ALPHA:
         png_ptr->channels = 2;
         break;

      case PNG_COLOR_TYPE_RGB_ALPHA:
         png_ptr->channels = 4;
         break;
   }

   /* Set up other useful info */
   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth * png_ptr->channels);
   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);
   png_debug1(3, "bit_depth = %d", png_ptr->bit_depth);
   png_debug1(3, "channels = %d", png_ptr->channels);
   png_debug1(3, "rowbytes = %lu", (unsigned long)png_ptr->rowbytes);
   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,
       color_type, interlace_type, compression_type, filter_type);
}

/* Read and check the palette */
void /* PRIVATE */
png_handle_PLTE(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_color palette[PNG_MAX_PALETTE_LENGTH];
   int max_palette_length, num, i;
#ifdef PNG_POINTER_INDEXING_SUPPORTED
   png_colorp pal_ptr;
#endif

   png_debug(1, "in png_handle_PLTE");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   /* Moved to before the 'after IDAT' check below because otherwise duplicate
    * PLTE chunks are potentially ignored (the spec says there shall not be more
    * than one PLTE, the error is not treated as benign, so this check trumps
    * the requirement that PLTE appears before IDAT.)
    */
   else if ((png_ptr->mode & PNG_HAVE_PLTE) != 0)
      png_chunk_error(png_ptr, "duplicate");

   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
   {
      /* This is benign because the non-benign error happened before, when an
       * IDAT was encountered in a color-mapped image with no PLTE.
       */
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   png_ptr->mode |= PNG_HAVE_PLTE;

   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "ignored in grayscale PNG");
      return;
   }

#ifndef PNG_READ_OPT_PLTE_SUPPORTED
   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      png_crc_finish(png_ptr, length);
      return;
   }
#endif

   if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)
   {
      png_crc_finish(png_ptr, length);

      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
         png_chunk_benign_error(png_ptr, "invalid");

      else
         png_chunk_error(png_ptr, "invalid");

      return;
   }

   /* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH */
   num = (int)length / 3;

   /* If the palette has 256 or fewer entries but is too large for the bit
    * depth, we don't issue an error, to preserve the behavior of previous
    * libpng versions. We silently truncate the unused extra palette entries
    * here.
    */
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      max_palette_length = (1 << png_ptr->bit_depth);
   else
      max_palette_length = PNG_MAX_PALETTE_LENGTH;

   if (num > max_palette_length)
      num = max_palette_length;

#ifdef PNG_POINTER_INDEXING_SUPPORTED
   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)
   {
      png_byte buf[3];

      png_crc_read(png_ptr, buf, 3);
      pal_ptr->red = buf[0];
      pal_ptr->green = buf[1];
      pal_ptr->blue = buf[2];
   }
#else
   for (i = 0; i < num; i++)
   {
      png_byte buf[3];

      png_crc_read(png_ptr, buf, 3);
      /* Don't depend upon png_color being any order */
      palette[i].red = buf[0];
      palette[i].green = buf[1];
      palette[i].blue = buf[2];
   }
#endif

   /* If we actually need the PLTE chunk (ie for a paletted image), we do
    * whatever the normal CRC configuration tells us.  However, if we
    * have an RGB image, the PLTE can be considered ancillary, so
    * we will act as though it is.
    */
#ifndef PNG_READ_OPT_PLTE_SUPPORTED
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
#endif
   {
      png_crc_finish(png_ptr, (png_uint_32) (length - (unsigned int)num * 3));
   }

#ifndef PNG_READ_OPT_PLTE_SUPPORTED
   else if (png_crc_error(png_ptr) != 0)  /* Only if we have a CRC error */
   {
      /* If we don't want to use the data from an ancillary chunk,
       * we have two options: an error abort, or a warning and we
       * ignore the data in this chunk (which should be OK, since
       * it's considered ancillary for a RGB or RGBA image).
       *
       * IMPLEMENTATION NOTE: this is only here because png_crc_finish uses the
       * chunk type to determine whether to check the ancillary or the critical
       * flags.
       */
      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE) == 0)
      {
         if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) != 0)
            return;

         else
            png_chunk_error(png_ptr, "CRC error");
      }

      /* Otherwise, we (optionally) emit a warning and use the chunk. */
      else if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0)
         png_chunk_warning(png_ptr, "CRC error");
   }
#endif

   /* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its
    * own copy of the palette.  This has the side effect that when png_start_row
    * is called (this happens after any call to png_read_update_info) the
    * info_ptr palette gets changed.  This is extremely unexpected and
    * confusing.
    *
    * Fix this by not sharing the palette in this way.
    */
   png_set_PLTE(png_ptr, info_ptr, palette, num);

   /* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before
    * IDAT.  Prior to 1.6.0 this was not checked; instead the code merely
    * checked the apparent validity of a tRNS chunk inserted before PLTE on a
    * palette PNG.  1.6.0 attempts to rigorously follow the standard and
    * therefore does a benign error if the erroneous condition is detected *and*
    * cancels the tRNS if the benign error returns.  The alternative is to
    * amend the standard since it would be rather hypocritical of the standards
    * maintainers to ignore it.
    */
#ifdef PNG_READ_tRNS_SUPPORTED
   if (png_ptr->num_trans > 0 ||
       (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0))
   {
      /* Cancel this because otherwise it would be used if the transforms
       * require it.  Don't cancel the 'valid' flag because this would prevent
       * detection of duplicate chunks.
       */
      png_ptr->num_trans = 0;

      if (info_ptr != NULL)
         info_ptr->num_trans = 0;

      png_chunk_benign_error(png_ptr, "tRNS must be after");
   }
#endif

#ifdef PNG_READ_hIST_SUPPORTED
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)
      png_chunk_benign_error(png_ptr, "hIST must be after");
#endif

#ifdef PNG_READ_bKGD_SUPPORTED
   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)
      png_chunk_benign_error(png_ptr, "bKGD must be after");
#endif
}

void /* PRIVATE */
png_handle_IEND(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_debug(1, "in png_handle_IEND");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0 ||
       (png_ptr->mode & PNG_HAVE_IDAT) == 0)
      png_chunk_error(png_ptr, "out of place");

   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);

   png_crc_finish(png_ptr, length);

   if (length != 0)
      png_chunk_benign_error(png_ptr, "invalid");

   PNG_UNUSED(info_ptr)
}

#ifdef PNG_READ_gAMA_SUPPORTED
void /* PRIVATE */
png_handle_gAMA(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_fixed_point igamma;
   png_byte buf[4];

   png_debug(1, "in png_handle_gAMA");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   if (length != 4)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "invalid");
      return;
   }

   png_crc_read(png_ptr, buf, 4);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   igamma = png_get_fixed_point(NULL, buf);

   png_colorspace_set_gamma(png_ptr, &png_ptr->colorspace, igamma);
   png_colorspace_sync(png_ptr, info_ptr);
}
#endif

#ifdef PNG_READ_sBIT_SUPPORTED
void /* PRIVATE */
png_handle_sBIT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   unsigned int truelen, i;
   png_byte sample_depth;
   png_byte buf[4];

   png_debug(1, "in png_handle_sBIT");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "duplicate");
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      truelen = 3;
      sample_depth = 8;
   }

   else
   {
      truelen = png_ptr->channels;
      sample_depth = png_ptr->bit_depth;
   }

   if (length != truelen || length > 4)
   {
      png_chunk_benign_error(png_ptr, "invalid");
      png_crc_finish(png_ptr, length);
      return;
   }

   buf[0] = buf[1] = buf[2] = buf[3] = sample_depth;
   png_crc_read(png_ptr, buf, truelen);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   for (i=0; i<truelen; ++i)
   {
      if (buf[i] == 0 || buf[i] > sample_depth)
      {
         png_chunk_benign_error(png_ptr, "invalid");
         return;
      }
   }

   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
   {
      png_ptr->sig_bit.red = buf[0];
      png_ptr->sig_bit.green = buf[1];
      png_ptr->sig_bit.blue = buf[2];
      png_ptr->sig_bit.alpha = buf[3];
   }

   else
   {
      png_ptr->sig_bit.gray = buf[0];
      png_ptr->sig_bit.red = buf[0];
      png_ptr->sig_bit.green = buf[0];
      png_ptr->sig_bit.blue = buf[0];
      png_ptr->sig_bit.alpha = buf[1];
   }

   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));
}
#endif

#ifdef PNG_READ_cHRM_SUPPORTED
void /* PRIVATE */
png_handle_cHRM(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_byte buf[32];
   png_xy xy;

   png_debug(1, "in png_handle_cHRM");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   if (length != 32)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "invalid");
      return;
   }

   png_crc_read(png_ptr, buf, 32);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   xy.whitex = png_get_fixed_point(NULL, buf);
   xy.whitey = png_get_fixed_point(NULL, buf + 4);
   xy.redx   = png_get_fixed_point(NULL, buf + 8);
   xy.redy   = png_get_fixed_point(NULL, buf + 12);
   xy.greenx = png_get_fixed_point(NULL, buf + 16);
   xy.greeny = png_get_fixed_point(NULL, buf + 20);
   xy.bluex  = png_get_fixed_point(NULL, buf + 24);
   xy.bluey  = png_get_fixed_point(NULL, buf + 28);

   if (xy.whitex == PNG_FIXED_ERROR ||
       xy.whitey == PNG_FIXED_ERROR ||
       xy.redx   == PNG_FIXED_ERROR ||
       xy.redy   == PNG_FIXED_ERROR ||
       xy.greenx == PNG_FIXED_ERROR ||
       xy.greeny == PNG_FIXED_ERROR ||
       xy.bluex  == PNG_FIXED_ERROR ||
       xy.bluey  == PNG_FIXED_ERROR)
   {
      png_chunk_benign_error(png_ptr, "invalid values");
      return;
   }

   /* If a colorspace error has already been output skip this chunk */
   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)
      return;

   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_FROM_cHRM) != 0)
   {
      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;
      png_colorspace_sync(png_ptr, info_ptr);
      png_chunk_benign_error(png_ptr, "duplicate");
      return;
   }

   png_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;
   (void)png_colorspace_set_chromaticities(png_ptr, &png_ptr->colorspace, &xy,
       1/*prefer cHRM values*/);
   png_colorspace_sync(png_ptr, info_ptr);
}
#endif

#ifdef PNG_READ_sRGB_SUPPORTED
void /* PRIVATE */
png_handle_sRGB(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_byte intent;

   png_debug(1, "in png_handle_sRGB");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   if (length != 1)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "invalid");
      return;
   }

   png_crc_read(png_ptr, &intent, 1);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   /* If a colorspace error has already been output skip this chunk */
   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)
      return;

   /* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect
    * this.
    */
   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) != 0)
   {
      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;
      png_colorspace_sync(png_ptr, info_ptr);
      png_chunk_benign_error(png_ptr, "too many profiles");
      return;
   }

   (void)png_colorspace_set_sRGB(png_ptr, &png_ptr->colorspace, intent);
   png_colorspace_sync(png_ptr, info_ptr);
}
#endif /* READ_sRGB */

#ifdef PNG_READ_iCCP_SUPPORTED
void /* PRIVATE */
png_handle_iCCP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
/* Note: this does not properly handle profiles that are > 64K under DOS */
{
   png_const_charp errmsg = NULL; /* error message output, or no error */
   int finished = 0; /* crc checked */

   png_debug(1, "in png_handle_iCCP");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   /* Consistent with all the above colorspace handling an obviously *invalid*
    * chunk is just ignored, so does not invalidate the color space.  An
    * alternative is to set the 'invalid' flags at the start of this routine
    * and only clear them in they were not set before and all the tests pass.
    * The minimum 'deflate' stream is assumed to be just the 2 byte header and
    * 4 byte checksum.  The keyword must be at least one character and there is
    * a terminator (0) byte and the compression method.
    */
   if (length < 9)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "too short");
      return;
   }

   /* If a colorspace error has already been output skip this chunk */
   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)
   {
      png_crc_finish(png_ptr, length);
      return;
   }

   /* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect
    * this.
    */
   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) == 0)
   {
      uInt read_length, keyword_length;
      char keyword[81];

      /* Find the keyword; the keyword plus separator and compression method
       * bytes can be at most 81 characters long.
       */
      read_length = 81; /* maximum */
      if (read_length > length)
         read_length = (uInt)length;

      png_crc_read(png_ptr, (png_bytep)keyword, read_length);
      length -= read_length;

      keyword_length = 0;
      while (keyword_length < 80 && keyword_length < read_length &&
         keyword[keyword_length] != 0)
         ++keyword_length;

      /* TODO: make the keyword checking common */
      if (keyword_length >= 1 && keyword_length <= 79)
      {
         /* We only understand '0' compression - deflate - so if we get a
          * different value we can't safely decode the chunk.
          */
         if (keyword_length+1 < read_length &&
            keyword[keyword_length+1] == PNG_COMPRESSION_TYPE_BASE)
         {
            read_length -= keyword_length+2;

            if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)
            {
               Byte profile_header[132];
               Byte local_buffer[PNG_INFLATE_BUF_SIZE];
               png_alloc_size_t size = (sizeof profile_header);

               png_ptr->zstream.next_in = (Bytef*)keyword + (keyword_length+2);
               png_ptr->zstream.avail_in = read_length;
               (void)png_inflate_read(png_ptr, local_buffer,
                   (sizeof local_buffer), &length, profile_header, &size,
                   0/*finish: don't, because the output is too small*/);

               if (size == 0)
               {
                  /* We have the ICC profile header; do the basic header checks.
                   */
                  const png_uint_32 profile_length =
                     png_get_uint_32(profile_header);

                  if (png_icc_check_length(png_ptr, &png_ptr->colorspace,
                      keyword, profile_length) != 0)
                  {
                     /* The length is apparently ok, so we can check the 132
                      * byte header.
                      */
                     if (png_icc_check_header(png_ptr, &png_ptr->colorspace,
                         keyword, profile_length, profile_header,
                         png_ptr->color_type) != 0)
                     {
                        /* Now read the tag table; a variable size buffer is
                         * needed at this point, allocate one for the whole
                         * profile.  The header check has already validated
                         * that none of these stuff will overflow.
                         */
                        const png_uint_32 tag_count = png_get_uint_32(
                            profile_header+128);
                        png_bytep profile = png_read_buffer(png_ptr,
                            profile_length, 2/*silent*/);

                        if (profile != NULL)
                        {
                           memcpy(profile, profile_header,
                               (sizeof profile_header));

                           size = 12 * tag_count;

                           (void)png_inflate_read(png_ptr, local_buffer,
                               (sizeof local_buffer), &length,
                               profile + (sizeof profile_header), &size, 0);

                           /* Still expect a buffer error because we expect
                            * there to be some tag data!
                            */
                           if (size == 0)
                           {
                              if (png_icc_check_tag_table(png_ptr,
                                  &png_ptr->colorspace, keyword, profile_length,
                                  profile) != 0)
                              {
                                 /* The profile has been validated for basic
                                  * security issues, so read the whole thing in.
                                  */
                                 size = profile_length - (sizeof profile_header)
                                     - 12 * tag_count;

                                 (void)png_inflate_read(png_ptr, local_buffer,
                                     (sizeof local_buffer), &length,
                                     profile + (sizeof profile_header) +
                                     12 * tag_count, &size, 1/*finish*/);

                                 if (length > 0 && !(png_ptr->flags &
                                     PNG_FLAG_BENIGN_ERRORS_WARN))
                                    errmsg = "extra compressed data";

                                 /* But otherwise allow extra data: */
                                 else if (size == 0)
                                 {
                                    if (length > 0)
                                    {
                                       /* This can be handled completely, so
                                        * keep going.
                                        */
                                       png_chunk_warning(png_ptr,
                                           "extra compressed data");
                                    }

                                    png_crc_finish(png_ptr, length);
                                    finished = 1;

# if defined(PNG_sRGB_SUPPORTED) && PNG_sRGB_PROFILE_CHECKS >= 0
                                    /* Check for a match against sRGB */
                                    png_icc_set_sRGB(png_ptr,
                                        &png_ptr->colorspace, profile,
                                        png_ptr->zstream.adler);
# endif

                                    /* Steal the profile for info_ptr. */
                                    if (info_ptr != NULL)
                                    {
                                       png_free_data(png_ptr, info_ptr,
                                           PNG_FREE_ICCP, 0);

                                       info_ptr->iccp_name = png_voidcast(char*,
                                           png_malloc_base(png_ptr,
                                           keyword_length+1));
                                       if (info_ptr->iccp_name != NULL)
                                       {
                                          memcpy(info_ptr->iccp_name, keyword,
                                              keyword_length+1);
                                          info_ptr->iccp_proflen =
                                              profile_length;
                                          info_ptr->iccp_profile = profile;
                                          png_ptr->read_buffer = NULL; /*steal*/
                                          info_ptr->free_me |= PNG_FREE_ICCP;
                                          info_ptr->valid |= PNG_INFO_iCCP;
                                       }

                                       else
                                       {
                                          png_ptr->colorspace.flags |=
                                             PNG_COLORSPACE_INVALID;
                                          errmsg = "out of memory";
                                       }
                                    }

                                    /* else the profile remains in the read
                                     * buffer which gets reused for subsequent
                                     * chunks.
                                     */

                                    if (info_ptr != NULL)
                                       png_colorspace_sync(png_ptr, info_ptr);

                                    if (errmsg == NULL)
                                    {
                                       png_ptr->zowner = 0;
                                       return;
                                    }
                                 }

                                 else if (size > 0)
                                    errmsg = "truncated";

#ifndef __COVERITY__
                                 else
                                    errmsg = png_ptr->zstream.msg;
#endif
                              }

                              /* else png_icc_check_tag_table output an error */
                           }

                           else /* profile truncated */
                              errmsg = png_ptr->zstream.msg;
                        }

                        else
                           errmsg = "out of memory";
                     }

                     /* else png_icc_check_header output an error */
                  }

                  /* else png_icc_check_length output an error */
               }

               else /* profile truncated */
                  errmsg = png_ptr->zstream.msg;

               /* Release the stream */
               png_ptr->zowner = 0;
            }

            else /* png_inflate_claim failed */
               errmsg = png_ptr->zstream.msg;
         }

         else
            errmsg = "bad compression method"; /* or missing */
      }

      else
         errmsg = "bad keyword";
   }

   else
      errmsg = "too many profiles";

   /* Failure: the reason is in 'errmsg' */
   if (finished == 0)
      png_crc_finish(png_ptr, length);

   png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;
   png_colorspace_sync(png_ptr, info_ptr);
   if (errmsg != NULL) /* else already output */
      png_chunk_benign_error(png_ptr, errmsg);
}
#endif /* READ_iCCP */

#ifdef PNG_READ_sPLT_SUPPORTED
void /* PRIVATE */
png_handle_sPLT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
/* Note: this does not properly handle chunks that are > 64K under DOS */
{
   png_bytep entry_start, buffer;
   png_sPLT_t new_palette;
   png_sPLT_entryp pp;
   png_uint_32 data_length;
   int entry_size, i;
   png_uint_32 skip = 0;
   png_uint_32 dl;
   png_size_t max_dl;

   png_debug(1, "in png_handle_sPLT");

#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }

      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_warning(png_ptr, "No space in chunk cache for sPLT");
         png_crc_finish(png_ptr, length);
         return;
      }
   }
#endif

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

#ifdef PNG_MAX_MALLOC_64K
   if (length > 65535U)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "too large to fit in memory");
      return;
   }
#endif

   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);
   if (buffer == NULL)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of memory");
      return;
   }


   /* WARNING: this may break if size_t is less than 32 bits; it is assumed
    * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a
    * potential breakage point if the types in pngconf.h aren't exactly right.
    */
   png_crc_read(png_ptr, buffer, length);

   if (png_crc_finish(png_ptr, skip) != 0)
      return;

   buffer[length] = 0;

   for (entry_start = buffer; *entry_start; entry_start++)
      /* Empty loop to find end of name */ ;

   ++entry_start;

   /* A sample depth should follow the separator, and we should be on it  */
   if (length < 2U || entry_start > buffer + (length - 2U))
   {
      png_warning(png_ptr, "malformed sPLT chunk");
      return;
   }

   new_palette.depth = *entry_start++;
   entry_size = (new_palette.depth == 8 ? 6 : 10);
   /* This must fit in a png_uint_32 because it is derived from the original
    * chunk data length.
    */
   data_length = length - (png_uint_32)(entry_start - buffer);

   /* Integrity-check the data length */
   if ((data_length % (unsigned int)entry_size) != 0)
   {
      png_warning(png_ptr, "sPLT chunk has bad length");
      return;
   }

   dl = (png_uint_32)(data_length / (unsigned int)entry_size);
   max_dl = PNG_SIZE_MAX / (sizeof (png_sPLT_entry));

   if (dl > max_dl)
   {
      png_warning(png_ptr, "sPLT chunk too long");
      return;
   }

   new_palette.nentries = (png_int_32)(data_length / (unsigned int)entry_size);

   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
       (png_alloc_size_t) new_palette.nentries * (sizeof (png_sPLT_entry)));

   if (new_palette.entries == NULL)
   {
      png_warning(png_ptr, "sPLT chunk requires too much memory");
      return;
   }

#ifdef PNG_POINTER_INDEXING_SUPPORTED
   for (i = 0; i < new_palette.nentries; i++)
   {
      pp = new_palette.entries + i;

      if (new_palette.depth == 8)
      {
         pp->red = *entry_start++;
         pp->green = *entry_start++;
         pp->blue = *entry_start++;
         pp->alpha = *entry_start++;
      }

      else
      {
         pp->red   = png_get_uint_16(entry_start); entry_start += 2;
         pp->green = png_get_uint_16(entry_start); entry_start += 2;
         pp->blue  = png_get_uint_16(entry_start); entry_start += 2;
         pp->alpha = png_get_uint_16(entry_start); entry_start += 2;
      }

      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
   }
#else
   pp = new_palette.entries;

   for (i = 0; i < new_palette.nentries; i++)
   {

      if (new_palette.depth == 8)
      {
         pp[i].red   = *entry_start++;
         pp[i].green = *entry_start++;
         pp[i].blue  = *entry_start++;
         pp[i].alpha = *entry_start++;
      }

      else
      {
         pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;
         pp[i].green = png_get_uint_16(entry_start); entry_start += 2;
         pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;
         pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;
      }

      pp[i].frequency = png_get_uint_16(entry_start); entry_start += 2;
   }
#endif

   /* Discard all chunk data except the name and stash that */
   new_palette.name = (png_charp)buffer;

   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);

   png_free(png_ptr, new_palette.entries);
}
#endif /* READ_sPLT */

#ifdef PNG_READ_tRNS_SUPPORTED
void /* PRIVATE */
png_handle_tRNS(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];

   png_debug(1, "in png_handle_tRNS");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "duplicate");
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
   {
      png_byte buf[2];

      if (length != 2)
      {
         png_crc_finish(png_ptr, length);
         png_chunk_benign_error(png_ptr, "invalid");
         return;
      }

      png_crc_read(png_ptr, buf, 2);
      png_ptr->num_trans = 1;
      png_ptr->trans_color.gray = png_get_uint_16(buf);
   }

   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
   {
      png_byte buf[6];

      if (length != 6)
      {
         png_crc_finish(png_ptr, length);
         png_chunk_benign_error(png_ptr, "invalid");
         return;
      }

      png_crc_read(png_ptr, buf, length);
      png_ptr->num_trans = 1;
      png_ptr->trans_color.red = png_get_uint_16(buf);
      png_ptr->trans_color.green = png_get_uint_16(buf + 2);
      png_ptr->trans_color.blue = png_get_uint_16(buf + 4);
   }

   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if ((png_ptr->mode & PNG_HAVE_PLTE) == 0)
      {
         /* TODO: is this actually an error in the ISO spec? */
         png_crc_finish(png_ptr, length);
         png_chunk_benign_error(png_ptr, "out of place");
         return;
      }

      if (length > (unsigned int) png_ptr->num_palette ||
         length > (unsigned int) PNG_MAX_PALETTE_LENGTH ||
         length == 0)
      {
         png_crc_finish(png_ptr, length);
         png_chunk_benign_error(png_ptr, "invalid");
         return;
      }

      png_crc_read(png_ptr, readbuf, length);
      png_ptr->num_trans = (png_uint_16)length;
   }

   else
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "invalid with alpha channel");
      return;
   }

   if (png_crc_finish(png_ptr, 0) != 0)
   {
      png_ptr->num_trans = 0;
      return;
   }

   /* TODO: this is a horrible side effect in the palette case because the
    * png_struct ends up with a pointer to the tRNS buffer owned by the
    * png_info.  Fix this.
    */
   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
       &(png_ptr->trans_color));
}
#endif

#ifdef PNG_READ_bKGD_SUPPORTED
void /* PRIVATE */
png_handle_bKGD(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   unsigned int truelen;
   png_byte buf[6];
   png_color_16 background;

   png_debug(1, "in png_handle_bKGD");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||
       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
       (png_ptr->mode & PNG_HAVE_PLTE) == 0))
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "duplicate");
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      truelen = 1;

   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
      truelen = 6;

   else
      truelen = 2;

   if (length != truelen)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "invalid");
      return;
   }

   png_crc_read(png_ptr, buf, truelen);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   /* We convert the index value into RGB components so that we can allow
    * arbitrary RGB values for background when we have transparency, and
    * so it is easy to determine the RGB values of the background color
    * from the info_ptr struct.
    */
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      background.index = buf[0];

      if (info_ptr != NULL && info_ptr->num_palette != 0)
      {
         if (buf[0] >= info_ptr->num_palette)
         {
            png_chunk_benign_error(png_ptr, "invalid index");
            return;
         }

         background.red = (png_uint_16)png_ptr->palette[buf[0]].red;
         background.green = (png_uint_16)png_ptr->palette[buf[0]].green;
         background.blue = (png_uint_16)png_ptr->palette[buf[0]].blue;
      }

      else
         background.red = background.green = background.blue = 0;

      background.gray = 0;
   }

   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0) /* GRAY */
   {
      background.index = 0;
      background.red =
      background.green =
      background.blue =
      background.gray = png_get_uint_16(buf);
   }

   else
   {
      background.index = 0;
      background.red = png_get_uint_16(buf);
      background.green = png_get_uint_16(buf + 2);
      background.blue = png_get_uint_16(buf + 4);
      background.gray = 0;
   }

   png_set_bKGD(png_ptr, info_ptr, &background);
}
#endif

#ifdef PNG_READ_hIST_SUPPORTED
void /* PRIVATE */
png_handle_hIST(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   unsigned int num, i;
   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];

   png_debug(1, "in png_handle_hIST");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||
       (png_ptr->mode & PNG_HAVE_PLTE) == 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "duplicate");
      return;
   }

   num = length / 2 ;

   if (num != (unsigned int) png_ptr->num_palette ||
       num > (unsigned int) PNG_MAX_PALETTE_LENGTH)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "invalid");
      return;
   }

   for (i = 0; i < num; i++)
   {
      png_byte buf[2];

      png_crc_read(png_ptr, buf, 2);
      readbuf[i] = png_get_uint_16(buf);
   }

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   png_set_hIST(png_ptr, info_ptr, readbuf);
}
#endif

#ifdef PNG_READ_pHYs_SUPPORTED
void /* PRIVATE */
png_handle_pHYs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_byte buf[9];
   png_uint_32 res_x, res_y;
   int unit_type;

   png_debug(1, "in png_handle_pHYs");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "duplicate");
      return;
   }

   if (length != 9)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "invalid");
      return;
   }

   png_crc_read(png_ptr, buf, 9);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   res_x = png_get_uint_32(buf);
   res_y = png_get_uint_32(buf + 4);
   unit_type = buf[8];
   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
}
#endif

#ifdef PNG_READ_oFFs_SUPPORTED
void /* PRIVATE */
png_handle_oFFs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_byte buf[9];
   png_int_32 offset_x, offset_y;
   int unit_type;

   png_debug(1, "in png_handle_oFFs");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "duplicate");
      return;
   }

   if (length != 9)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "invalid");
      return;
   }

   png_crc_read(png_ptr, buf, 9);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   offset_x = png_get_int_32(buf);
   offset_y = png_get_int_32(buf + 4);
   unit_type = buf[8];
   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
}
#endif

#ifdef PNG_READ_pCAL_SUPPORTED
/* Read the pCAL chunk (described in the PNG Extensions document) */
void /* PRIVATE */
png_handle_pCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_int_32 X0, X1;
   png_byte type, nparams;
   png_bytep buffer, buf, units, endptr;
   png_charpp params;
   int i;

   png_debug(1, "in png_handle_pCAL");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "duplicate");
      return;
   }

   png_debug1(2, "Allocating and reading pCAL chunk data (%u bytes)",
       length + 1);

   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);

   if (buffer == NULL)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of memory");
      return;
   }

   png_crc_read(png_ptr, buffer, length);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   buffer[length] = 0; /* Null terminate the last string */

   png_debug(3, "Finding end of pCAL purpose string");
   for (buf = buffer; *buf; buf++)
      /* Empty loop */ ;

   endptr = buffer + length;

   /* We need to have at least 12 bytes after the purpose string
    * in order to get the parameter information.
    */
   if (endptr - buf <= 12)
   {
      png_chunk_benign_error(png_ptr, "invalid");
      return;
   }

   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units");
   X0 = png_get_int_32((png_bytep)buf+1);
   X1 = png_get_int_32((png_bytep)buf+5);
   type = buf[9];
   nparams = buf[10];
   units = buf + 11;

   png_debug(3, "Checking pCAL equation type and number of parameters");
   /* Check that we have the right number of parameters for known
    * equation types.
    */
   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||
       (type == PNG_EQUATION_BASE_E && nparams != 3) ||
       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||
       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))
   {
      png_chunk_benign_error(png_ptr, "invalid parameter count");
      return;
   }

   else if (type >= PNG_EQUATION_LAST)
   {
      png_chunk_benign_error(png_ptr, "unrecognized equation type");
   }

   for (buf = units; *buf; buf++)
      /* Empty loop to move past the units string. */ ;

   png_debug(3, "Allocating pCAL parameters array");

   params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,
       nparams * (sizeof (png_charp))));

   if (params == NULL)
   {
      png_chunk_benign_error(png_ptr, "out of memory");
      return;
   }

   /* Get pointers to the start of each parameter string. */
   for (i = 0; i < nparams; i++)
   {
      buf++; /* Skip the null string terminator from previous parameter. */

      png_debug1(3, "Reading pCAL parameter %d", i);

      for (params[i] = (png_charp)buf; buf <= endptr && *buf != 0; buf++)
         /* Empty loop to move past each parameter string */ ;

      /* Make sure we haven't run out of data yet */
      if (buf > endptr)
      {
         png_free(png_ptr, params);
         png_chunk_benign_error(png_ptr, "invalid data");
         return;
      }
   }

   png_set_pCAL(png_ptr, info_ptr, (png_charp)buffer, X0, X1, type, nparams,
       (png_charp)units, params);

   png_free(png_ptr, params);
}
#endif

#ifdef PNG_READ_sCAL_SUPPORTED
/* Read the sCAL chunk */
void /* PRIVATE */
png_handle_sCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_bytep buffer;
   png_size_t i;
   int state;

   png_debug(1, "in png_handle_sCAL");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of place");
      return;
   }

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "duplicate");
      return;
   }

   /* Need unit type, width, \0, height: minimum 4 bytes */
   else if (length < 4)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "invalid");
      return;
   }

   png_debug1(2, "Allocating and reading sCAL chunk data (%u bytes)",
       length + 1);

   buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);

   if (buffer == NULL)
   {
      png_chunk_benign_error(png_ptr, "out of memory");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buffer, length);
   buffer[length] = 0; /* Null terminate the last string */

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   /* Validate the unit. */
   if (buffer[0] != 1 && buffer[0] != 2)
   {
      png_chunk_benign_error(png_ptr, "invalid unit");
      return;
   }

   /* Validate the ASCII numbers, need two ASCII numbers separated by
    * a '\0' and they need to fit exactly in the chunk data.
    */
   i = 1;
   state = 0;

   if (png_check_fp_number((png_const_charp)buffer, length, &state, &i) == 0 ||
       i >= length || buffer[i++] != 0)
      png_chunk_benign_error(png_ptr, "bad width format");

   else if (PNG_FP_IS_POSITIVE(state) == 0)
      png_chunk_benign_error(png_ptr, "non-positive width");

   else
   {
      png_size_t heighti = i;

      state = 0;
      if (png_check_fp_number((png_const_charp)buffer, length,
          &state, &i) == 0 || i != length)
         png_chunk_benign_error(png_ptr, "bad height format");

      else if (PNG_FP_IS_POSITIVE(state) == 0)
         png_chunk_benign_error(png_ptr, "non-positive height");

      else
         /* This is the (only) success case. */
         png_set_sCAL_s(png_ptr, info_ptr, buffer[0],
             (png_charp)buffer+1, (png_charp)buffer+heighti);
   }
}
#endif

#ifdef PNG_READ_tIME_SUPPORTED
void /* PRIVATE */
png_handle_tIME(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_byte buf[7];
   png_time mod_time;

   png_debug(1, "in png_handle_tIME");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "duplicate");
      return;
   }

   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
      png_ptr->mode |= PNG_AFTER_IDAT;

   if (length != 7)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "invalid");
      return;
   }

   png_crc_read(png_ptr, buf, 7);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   mod_time.second = buf[6];
   mod_time.minute = buf[5];
   mod_time.hour = buf[4];
   mod_time.day = buf[3];
   mod_time.month = buf[2];
   mod_time.year = png_get_uint_16(buf);

   png_set_tIME(png_ptr, info_ptr, &mod_time);
}
#endif

#ifdef PNG_READ_tEXt_SUPPORTED
/* Note: this does not properly handle chunks that are > 64K under DOS */
void /* PRIVATE */
png_handle_tEXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_text  text_info;
   png_bytep buffer;
   png_charp key;
   png_charp text;
   png_uint_32 skip = 0;

   png_debug(1, "in png_handle_tEXt");

#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }

      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         png_chunk_benign_error(png_ptr, "no space in chunk cache");
         return;
      }
   }
#endif

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
      png_ptr->mode |= PNG_AFTER_IDAT;

#ifdef PNG_MAX_MALLOC_64K
   if (length > 65535U)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "too large to fit in memory");
      return;
   }
#endif

   buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);

   if (buffer == NULL)
   {
      png_chunk_benign_error(png_ptr, "out of memory");
      return;
   }

   png_crc_read(png_ptr, buffer, length);

   if (png_crc_finish(png_ptr, skip) != 0)
      return;

   key = (png_charp)buffer;
   key[length] = 0;

   for (text = key; *text; text++)
      /* Empty loop to find end of key */ ;

   if (text != key + length)
      text++;

   text_info.compression = PNG_TEXT_COMPRESSION_NONE;
   text_info.key = key;
   text_info.lang = NULL;
   text_info.lang_key = NULL;
   text_info.itxt_length = 0;
   text_info.text = text;
   text_info.text_length = strlen(text);

   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) != 0)
      png_warning(png_ptr, "Insufficient memory to process text chunk");
}
#endif

#ifdef PNG_READ_zTXt_SUPPORTED
/* Note: this does not correctly handle chunks that are > 64K under DOS */
void /* PRIVATE */
png_handle_zTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_const_charp errmsg = NULL;
   png_bytep       buffer;
   png_uint_32     keyword_length;

   png_debug(1, "in png_handle_zTXt");

#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }

      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         png_chunk_benign_error(png_ptr, "no space in chunk cache");
         return;
      }
   }
#endif

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
      png_ptr->mode |= PNG_AFTER_IDAT;

   buffer = png_read_buffer(png_ptr, length, 2/*silent*/);

   if (buffer == NULL)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of memory");
      return;
   }

   png_crc_read(png_ptr, buffer, length);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   /* TODO: also check that the keyword contents match the spec! */
   for (keyword_length = 0;
      keyword_length < length && buffer[keyword_length] != 0;
      ++keyword_length)
      /* Empty loop to find end of name */ ;

   if (keyword_length > 79 || keyword_length < 1)
      errmsg = "bad keyword";

   /* zTXt must have some LZ data after the keyword, although it may expand to
    * zero bytes; we need a '\0' at the end of the keyword, the compression type
    * then the LZ data:
    */
   else if (keyword_length + 3 > length)
      errmsg = "truncated";

   else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)
      errmsg = "unknown compression type";

   else
   {
      png_alloc_size_t uncompressed_length = PNG_SIZE_MAX;

      /* TODO: at present png_decompress_chunk imposes a single application
       * level memory limit, this should be split to different values for iCCP
       * and text chunks.
       */
      if (png_decompress_chunk(png_ptr, length, keyword_length+2,
          &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)
      {
         png_text text;

         /* It worked; png_ptr->read_buffer now looks like a tEXt chunk except
          * for the extra compression type byte and the fact that it isn't
          * necessarily '\0' terminated.
          */
         buffer = png_ptr->read_buffer;
         buffer[uncompressed_length+(keyword_length+2)] = 0;

         text.compression = PNG_TEXT_COMPRESSION_zTXt;
         text.key = (png_charp)buffer;
         text.text = (png_charp)(buffer + keyword_length+2);
         text.text_length = uncompressed_length;
         text.itxt_length = 0;
         text.lang = NULL;
         text.lang_key = NULL;

         if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)
            errmsg = "insufficient memory";
      }

      else
         errmsg = png_ptr->zstream.msg;
   }

   if (errmsg != NULL)
      png_chunk_benign_error(png_ptr, errmsg);
}
#endif

#ifdef PNG_READ_iTXt_SUPPORTED
/* Note: this does not correctly handle chunks that are > 64K under DOS */
void /* PRIVATE */
png_handle_iTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   png_const_charp errmsg = NULL;
   png_bytep buffer;
   png_uint_32 prefix_length;

   png_debug(1, "in png_handle_iTXt");

#ifdef PNG_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_cache_max != 0)
   {
      if (png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         return;
      }

      if (--png_ptr->user_chunk_cache_max == 1)
      {
         png_crc_finish(png_ptr, length);
         png_chunk_benign_error(png_ptr, "no space in chunk cache");
         return;
      }
   }
#endif

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, "missing IHDR");

   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
      png_ptr->mode |= PNG_AFTER_IDAT;

   buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);

   if (buffer == NULL)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "out of memory");
      return;
   }

   png_crc_read(png_ptr, buffer, length);

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   /* First the keyword. */
   for (prefix_length=0;
      prefix_length < length && buffer[prefix_length] != 0;
      ++prefix_length)
      /* Empty loop */ ;

   /* Perform a basic check on the keyword length here. */
   if (prefix_length > 79 || prefix_length < 1)
      errmsg = "bad keyword";

   /* Expect keyword, compression flag, compression type, language, translated
    * keyword (both may be empty but are 0 terminated) then the text, which may
    * be empty.
    */
   else if (prefix_length + 5 > length)
      errmsg = "truncated";

   else if (buffer[prefix_length+1] == 0 ||
      (buffer[prefix_length+1] == 1 &&
      buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))
   {
      int compressed = buffer[prefix_length+1] != 0;
      png_uint_32 language_offset, translated_keyword_offset;
      png_alloc_size_t uncompressed_length = 0;

      /* Now the language tag */
      prefix_length += 3;
      language_offset = prefix_length;

      for (; prefix_length < length && buffer[prefix_length] != 0;
         ++prefix_length)
         /* Empty loop */ ;

      /* WARNING: the length may be invalid here, this is checked below. */
      translated_keyword_offset = ++prefix_length;

      for (; prefix_length < length && buffer[prefix_length] != 0;
         ++prefix_length)
         /* Empty loop */ ;

      /* prefix_length should now be at the trailing '\0' of the translated
       * keyword, but it may already be over the end.  None of this arithmetic
       * can overflow because chunks are at most 2^31 bytes long, but on 16-bit
       * systems the available allocation may overflow.
       */
      ++prefix_length;

      if (compressed == 0 && prefix_length <= length)
         uncompressed_length = length - prefix_length;

      else if (compressed != 0 && prefix_length < length)
      {
         uncompressed_length = PNG_SIZE_MAX;

         /* TODO: at present png_decompress_chunk imposes a single application
          * level memory limit, this should be split to different values for
          * iCCP and text chunks.
          */
         if (png_decompress_chunk(png_ptr, length, prefix_length,
             &uncompressed_length, 1/*terminate*/) == Z_STREAM_END)
            buffer = png_ptr->read_buffer;

         else
            errmsg = png_ptr->zstream.msg;
      }

      else
         errmsg = "truncated";

      if (errmsg == NULL)
      {
         png_text text;

         buffer[uncompressed_length+prefix_length] = 0;

         if (compressed == 0)
            text.compression = PNG_ITXT_COMPRESSION_NONE;

         else
            text.compression = PNG_ITXT_COMPRESSION_zTXt;

         text.key = (png_charp)buffer;
         text.lang = (png_charp)buffer + language_offset;
         text.lang_key = (png_charp)buffer + translated_keyword_offset;
         text.text = (png_charp)buffer + prefix_length;
         text.text_length = 0;
         text.itxt_length = uncompressed_length;

         if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)
            errmsg = "insufficient memory";
      }
   }

   else
      errmsg = "bad compression info";

   if (errmsg != NULL)
      png_chunk_benign_error(png_ptr, errmsg);
}
#endif

#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
/* Utility function for png_handle_unknown; set up png_ptr::unknown_chunk */
static int
png_cache_unknown_chunk(png_structrp png_ptr, png_uint_32 length)
{
   png_alloc_size_t limit = PNG_SIZE_MAX;

   if (png_ptr->unknown_chunk.data != NULL)
   {
      png_free(png_ptr, png_ptr->unknown_chunk.data);
      png_ptr->unknown_chunk.data = NULL;
   }

#  ifdef PNG_SET_USER_LIMITS_SUPPORTED
   if (png_ptr->user_chunk_malloc_max > 0 &&
       png_ptr->user_chunk_malloc_max < limit)
      limit = png_ptr->user_chunk_malloc_max;

#  elif PNG_USER_CHUNK_MALLOC_MAX > 0
   if (PNG_USER_CHUNK_MALLOC_MAX < limit)
      limit = PNG_USER_CHUNK_MALLOC_MAX;
#  endif

   if (length <= limit)
   {
      PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);
      /* The following is safe because of the PNG_SIZE_MAX init above */
      png_ptr->unknown_chunk.size = (png_size_t)length/*SAFE*/;
      /* 'mode' is a flag array, only the bottom four bits matter here */
      png_ptr->unknown_chunk.location = (png_byte)png_ptr->mode/*SAFE*/;

      if (length == 0)
         png_ptr->unknown_chunk.data = NULL;

      else
      {
         /* Do a 'warn' here - it is handled below. */
         png_ptr->unknown_chunk.data = png_voidcast(png_bytep,
             png_malloc_warn(png_ptr, length));
      }
   }

   if (png_ptr->unknown_chunk.data == NULL && length > 0)
   {
      /* This is benign because we clean up correctly */
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, "unknown chunk exceeds memory limits");
      return 0;
   }

   else
   {
      if (length > 0)
         png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);
      png_crc_finish(png_ptr, 0);
      return 1;
   }
}
#endif /* READ_UNKNOWN_CHUNKS */

/* Handle an unknown, or known but disabled, chunk */
void /* PRIVATE */
png_handle_unknown(png_structrp png_ptr, png_inforp info_ptr,
    png_uint_32 length, int keep)
{
   int handled = 0; /* the chunk was handled */

   png_debug(1, "in png_handle_unknown");

#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
   /* NOTE: this code is based on the code in libpng-1.4.12 except for fixing
    * the bug which meant that setting a non-default behavior for a specific
    * chunk would be ignored (the default was always used unless a user
    * callback was installed).
    *
    * 'keep' is the value from the png_chunk_unknown_handling, the setting for
    * this specific chunk_name, if PNG_HANDLE_AS_UNKNOWN_SUPPORTED, if not it
    * will always be PNG_HANDLE_CHUNK_AS_DEFAULT and it needs to be set here.
    * This is just an optimization to avoid multiple calls to the lookup
    * function.
    */
#  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
#     ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
   keep = png_chunk_unknown_handling(png_ptr, png_ptr->chunk_name);
#     endif
#  endif

   /* One of the following methods will read the chunk or skip it (at least one
    * of these is always defined because this is the only way to switch on
    * PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
    */
#  ifdef PNG_READ_USER_CHUNKS_SUPPORTED
   /* The user callback takes precedence over the chunk keep value, but the
    * keep value is still required to validate a save of a critical chunk.
    */
   if (png_ptr->read_user_chunk_fn != NULL)
   {
      if (png_cache_unknown_chunk(png_ptr, length) != 0)
      {
         /* Callback to user unknown chunk handler */
         int ret = (*(png_ptr->read_user_chunk_fn))(png_ptr,
             &png_ptr->unknown_chunk);

         /* ret is:
          * negative: An error occurred; png_chunk_error will be called.
          *     zero: The chunk was not handled, the chunk will be discarded
          *           unless png_set_keep_unknown_chunks has been used to set
          *           a 'keep' behavior for this particular chunk, in which
          *           case that will be used.  A critical chunk will cause an
          *           error at this point unless it is to be saved.
          * positive: The chunk was handled, libpng will ignore/discard it.
          */
         if (ret < 0)
            png_chunk_error(png_ptr, "error in user chunk");

         else if (ret == 0)
         {
            /* If the keep value is 'default' or 'never' override it, but
             * still error out on critical chunks unless the keep value is
             * 'always'  While this is weird it is the behavior in 1.4.12.
             * A possible improvement would be to obey the value set for the
             * chunk, but this would be an API change that would probably
             * damage some applications.
             *
             * The png_app_warning below catches the case that matters, where
             * the application has not set specific save or ignore for this
             * chunk or global save or ignore.
             */
            if (keep < PNG_HANDLE_CHUNK_IF_SAFE)
            {
#              ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
               if (png_ptr->unknown_default < PNG_HANDLE_CHUNK_IF_SAFE)
               {
                  png_chunk_warning(png_ptr, "Saving unknown chunk:");
                  png_app_warning(png_ptr,
                      "forcing save of an unhandled chunk;"
                      " please call png_set_keep_unknown_chunks");
                      /* with keep = PNG_HANDLE_CHUNK_IF_SAFE */
               }
#              endif
               keep = PNG_HANDLE_CHUNK_IF_SAFE;
            }
         }

         else /* chunk was handled */
         {
            handled = 1;
            /* Critical chunks can be safely discarded at this point. */
            keep = PNG_HANDLE_CHUNK_NEVER;
         }
      }

      else
         keep = PNG_HANDLE_CHUNK_NEVER; /* insufficient memory */
   }

   else
   /* Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk */
#  endif /* READ_USER_CHUNKS */

#  ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
   {
      /* keep is currently just the per-chunk setting, if there was no
       * setting change it to the global default now (not that this may
       * still be AS_DEFAULT) then obtain the cache of the chunk if required,
       * if not simply skip the chunk.
       */
      if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)
         keep = png_ptr->unknown_default;

      if (keep == PNG_HANDLE_CHUNK_ALWAYS ||
         (keep == PNG_HANDLE_CHUNK_IF_SAFE &&
          PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))
      {
         if (png_cache_unknown_chunk(png_ptr, length) == 0)
            keep = PNG_HANDLE_CHUNK_NEVER;
      }

      else
         png_crc_finish(png_ptr, length);
   }
#  else
#     ifndef PNG_READ_USER_CHUNKS_SUPPORTED
#        error no method to support READ_UNKNOWN_CHUNKS
#     endif

   {
      /* If here there is no read callback pointer set and no support is
       * compiled in to just save the unknown chunks, so simply skip this
       * chunk.  If 'keep' is something other than AS_DEFAULT or NEVER then
       * the app has erroneously asked for unknown chunk saving when there
       * is no support.
       */
      if (keep > PNG_HANDLE_CHUNK_NEVER)
         png_app_error(png_ptr, "no unknown chunk support available");

      png_crc_finish(png_ptr, length);
   }
#  endif

#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
   /* Now store the chunk in the chunk list if appropriate, and if the limits
    * permit it.
    */
   if (keep == PNG_HANDLE_CHUNK_ALWAYS ||
      (keep == PNG_HANDLE_CHUNK_IF_SAFE &&
       PNG_CHUNK_ANCILLARY(png_ptr->chunk_name)))
   {
#     ifdef PNG_USER_LIMITS_SUPPORTED
      switch (png_ptr->user_chunk_cache_max)
      {
         case 2:
            png_ptr->user_chunk_cache_max = 1;
            png_chunk_benign_error(png_ptr, "no space in chunk cache");
            /* FALL THROUGH */
         case 1:
            /* NOTE: prior to 1.6.0 this case resulted in an unknown critical
             * chunk being skipped, now there will be a hard error below.
             */
            break;

         default: /* not at limit */
            --(png_ptr->user_chunk_cache_max);
            /* FALL THROUGH */
         case 0: /* no limit */
#  endif /* USER_LIMITS */
            /* Here when the limit isn't reached or when limits are compiled
             * out; store the chunk.
             */
            png_set_unknown_chunks(png_ptr, info_ptr,
                &png_ptr->unknown_chunk, 1);
            handled = 1;
#  ifdef PNG_USER_LIMITS_SUPPORTED
            break;
      }
#  endif
   }
#  else /* no store support: the chunk must be handled by the user callback */
   PNG_UNUSED(info_ptr)
#  endif

   /* Regardless of the error handling below the cached data (if any) can be
    * freed now.  Notice that the data is not freed if there is a png_error, but
    * it will be freed by destroy_read_struct.
    */
   if (png_ptr->unknown_chunk.data != NULL)
      png_free(png_ptr, png_ptr->unknown_chunk.data);
   png_ptr->unknown_chunk.data = NULL;

#else /* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */
   /* There is no support to read an unknown chunk, so just skip it. */
   png_crc_finish(png_ptr, length);
   PNG_UNUSED(info_ptr)
   PNG_UNUSED(keep)
#endif /* !READ_UNKNOWN_CHUNKS */

   /* Check for unhandled critical chunks */
   if (handled == 0 && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))
      png_chunk_error(png_ptr, "unhandled critical chunk");
}

/* This function is called to verify that a chunk name is valid.
 * This function can't have the "critical chunk check" incorporated
 * into it, since in the future we will need to be able to call user
 * functions to handle unknown critical chunks after we check that
 * the chunk name itself is valid.
 */

/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:
 *
 * ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
 */

void /* PRIVATE */
png_check_chunk_name(png_structrp png_ptr, png_uint_32 chunk_name)
{
   int i;

   png_debug(1, "in png_check_chunk_name");

   for (i=1; i<=4; ++i)
   {
      int c = chunk_name & 0xff;

      if (c < 65 || c > 122 || (c > 90 && c < 97))
         png_chunk_error(png_ptr, "invalid chunk type");

      chunk_name >>= 8;
   }
}

/* Combines the row recently read in with the existing pixels in the row.  This
 * routine takes care of alpha and transparency if requested.  This routine also
 * handles the two methods of progressive display of interlaced images,
 * depending on the 'display' value; if 'display' is true then the whole row
 * (dp) is filled from the start by replicating the available pixels.  If
 * 'display' is false only those pixels present in the pass are filled in.
 */
void /* PRIVATE */
png_combine_row(png_const_structrp png_ptr, png_bytep dp, int display)
{
   unsigned int pixel_depth = png_ptr->transformed_pixel_depth;
   png_const_bytep sp = png_ptr->row_buf + 1;
   png_alloc_size_t row_width = png_ptr->width;
   unsigned int pass = png_ptr->pass;
   png_bytep end_ptr = 0;
   png_byte end_byte = 0;
   unsigned int end_mask;

   png_debug(1, "in png_combine_row");

   /* Added in 1.5.6: it should not be possible to enter this routine until at
    * least one row has been read from the PNG data and transformed.
    */
   if (pixel_depth == 0)
      png_error(png_ptr, "internal row logic error");

   /* Added in 1.5.4: the pixel depth should match the information returned by
    * any call to png_read_update_info at this point.  Do not continue if we got
    * this wrong.
    */
   if (png_ptr->info_rowbytes != 0 && png_ptr->info_rowbytes !=
          PNG_ROWBYTES(pixel_depth, row_width))
      png_error(png_ptr, "internal row size calculation error");

   /* Don't expect this to ever happen: */
   if (row_width == 0)
      png_error(png_ptr, "internal row width error");

   /* Preserve the last byte in cases where only part of it will be overwritten,
    * the multiply below may overflow, we don't care because ANSI-C guarantees
    * we get the low bits.
    */
   end_mask = (pixel_depth * row_width) & 7;
   if (end_mask != 0)
   {
      /* end_ptr == NULL is a flag to say do nothing */
      end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;
      end_byte = *end_ptr;
#     ifdef PNG_READ_PACKSWAP_SUPPORTED
      if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
         /* little-endian byte */
         end_mask = (unsigned int)(0xff << end_mask);

      else /* big-endian byte */
#     endif
      end_mask = 0xff >> end_mask;
      /* end_mask is now the bits to *keep* from the destination row */
   }

   /* For non-interlaced images this reduces to a memcpy(). A memcpy()
    * will also happen if interlacing isn't supported or if the application
    * does not call png_set_interlace_handling().  In the latter cases the
    * caller just gets a sequence of the unexpanded rows from each interlace
    * pass.
    */
#ifdef PNG_READ_INTERLACING_SUPPORTED
   if (png_ptr->interlaced != 0 &&
       (png_ptr->transformations & PNG_INTERLACE) != 0 &&
       pass < 6 && (display == 0 ||
       /* The following copies everything for 'display' on passes 0, 2 and 4. */
       (display == 1 && (pass & 1) != 0)))
   {
      /* Narrow images may have no bits in a pass; the caller should handle
       * this, but this test is cheap:
       */
      if (row_width <= PNG_PASS_START_COL(pass))
         return;

      if (pixel_depth < 8)
      {
         /* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit
          * into 32 bits, then a single loop over the bytes using the four byte
          * values in the 32-bit mask can be used.  For the 'display' option the
          * expanded mask may also not require any masking within a byte.  To
          * make this work the PACKSWAP option must be taken into account - it
          * simply requires the pixels to be reversed in each byte.
          *
          * The 'regular' case requires a mask for each of the first 6 passes,
          * the 'display' case does a copy for the even passes in the range
          * 0..6.  This has already been handled in the test above.
          *
          * The masks are arranged as four bytes with the first byte to use in
          * the lowest bits (little-endian) regardless of the order (PACKSWAP or
          * not) of the pixels in each byte.
          *
          * NOTE: the whole of this logic depends on the caller of this function
          * only calling it on rows appropriate to the pass.  This function only
          * understands the 'x' logic; the 'y' logic is handled by the caller.
          *
          * The following defines allow generation of compile time constant bit
          * masks for each pixel depth and each possibility of swapped or not
          * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,
          * is in the range 0..7; and the result is 1 if the pixel is to be
          * copied in the pass, 0 if not.  'S' is for the sparkle method, 'B'
          * for the block method.
          *
          * With some compilers a compile time expression of the general form:
          *
          *    (shift >= 32) ? (a >> (shift-32)) : (b >> shift)
          *
          * Produces warnings with values of 'shift' in the range 33 to 63
          * because the right hand side of the ?: expression is evaluated by
          * the compiler even though it isn't used.  Microsoft Visual C (various
          * versions) and the Intel C compiler are known to do this.  To avoid
          * this the following macros are used in 1.5.6.  This is a temporary
          * solution to avoid destabilizing the code during the release process.
          */
#        if PNG_USE_COMPILE_TIME_MASKS
#           define PNG_LSR(x,s) ((x)>>((s) & 0x1f))
#           define PNG_LSL(x,s) ((x)<<((s) & 0x1f))
#        else
#           define PNG_LSR(x,s) ((x)>>(s))
#           define PNG_LSL(x,s) ((x)<<(s))
#        endif
#        define S_COPY(p,x) (((p)<4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\
           PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x)))) & 1)
#        define B_COPY(p,x) (((p)<4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\
           PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x)))) & 1)

         /* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is
          * little endian - the first pixel is at bit 0 - however the extra
          * parameter 's' can be set to cause the mask position to be swapped
          * within each byte, to match the PNG format.  This is done by XOR of
          * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.
          */
#        define PIXEL_MASK(p,x,d,s) \
            (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))

         /* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.
          */
#        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
#        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)

         /* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp
          * cases the result needs replicating, for the 4-bpp case the above
          * generates a full 32 bits.
          */
#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))

#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)

#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)

#if PNG_USE_COMPILE_TIME_MASKS
         /* Utility macros to construct all the masks for a depth/swap
          * combination.  The 's' parameter says whether the format is PNG
          * (big endian bytes) or not.  Only the three odd-numbered passes are
          * required for the display/block algorithm.
          */
#        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
            S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }

#        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }

#        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))

         /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
          * then pass:
          */
         static PNG_CONST png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =
         {
            /* Little-endian byte masks for PACKSWAP */
            { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },
            /* Normal (big-endian byte) masks - PNG format */
            { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
         };

         /* display_mask has only three entries for the odd passes, so index by
          * pass>>1.
          */
         static PNG_CONST png_uint_32 display_mask[2][3][3] =
         {
            /* Little-endian byte masks for PACKSWAP */
            { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },
            /* Normal (big-endian byte) masks - PNG format */
            { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
         };

#        define MASK(pass,depth,display,png)\
            ((display)?display_mask[png][DEPTH_INDEX(depth)][pass>>1]:\
               row_mask[png][DEPTH_INDEX(depth)][pass])

#else /* !PNG_USE_COMPILE_TIME_MASKS */
         /* This is the runtime alternative: it seems unlikely that this will
          * ever be either smaller or faster than the compile time approach.
          */
#        define MASK(pass,depth,display,png)\
            ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))
#endif /* !USE_COMPILE_TIME_MASKS */

         /* Use the appropriate mask to copy the required bits.  In some cases
          * the byte mask will be 0 or 0xff; optimize these cases.  row_width is
          * the number of pixels, but the code copies bytes, so it is necessary
          * to special case the end.
          */
         png_uint_32 pixels_per_byte = 8 / pixel_depth;
         png_uint_32 mask;

#        ifdef PNG_READ_PACKSWAP_SUPPORTED
         if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
            mask = MASK(pass, pixel_depth, display, 0);

         else
#        endif
         mask = MASK(pass, pixel_depth, display, 1);

         for (;;)
         {
            png_uint_32 m;

            /* It doesn't matter in the following if png_uint_32 has more than
             * 32 bits because the high bits always match those in m<<24; it is,
             * however, essential to use OR here, not +, because of this.
             */
            m = mask;
            mask = (m >> 8) | (m << 24); /* rotate right to good compilers */
            m &= 0xff;

            if (m != 0) /* something to copy */
            {
               if (m != 0xff)
                  *dp = (png_byte)((*dp & ~m) | (*sp & m));
               else
                  *dp = *sp;
            }

            /* NOTE: this may overwrite the last byte with garbage if the image
             * is not an exact number of bytes wide; libpng has always done
             * this.
             */
            if (row_width <= pixels_per_byte)
               break; /* May need to restore part of the last byte */

            row_width -= pixels_per_byte;
            ++dp;
            ++sp;
         }
      }

      else /* pixel_depth >= 8 */
      {
         unsigned int bytes_to_copy, bytes_to_jump;

         /* Validate the depth - it must be a multiple of 8 */
         if (pixel_depth & 7)
            png_error(png_ptr, "invalid user transform pixel depth");

         pixel_depth >>= 3; /* now in bytes */
         row_width *= pixel_depth;

         /* Regardless of pass number the Adam 7 interlace always results in a
          * fixed number of pixels to copy then to skip.  There may be a
          * different number of pixels to skip at the start though.
          */
         {
            unsigned int offset = PNG_PASS_START_COL(pass) * pixel_depth;

            row_width -= offset;
            dp += offset;
            sp += offset;
         }

         /* Work out the bytes to copy. */
         if (display != 0)
         {
            /* When doing the 'block' algorithm the pixel in the pass gets
             * replicated to adjacent pixels.  This is why the even (0,2,4,6)
             * passes are skipped above - the entire expanded row is copied.
             */
            bytes_to_copy = (1<<((6-pass)>>1)) * pixel_depth;

            /* But don't allow this number to exceed the actual row width. */
            if (bytes_to_copy > row_width)
               bytes_to_copy = (unsigned int)/*SAFE*/row_width;
         }

         else /* normal row; Adam7 only ever gives us one pixel to copy. */
            bytes_to_copy = pixel_depth;

         /* In Adam7 there is a constant offset between where the pixels go. */
         bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;

         /* And simply copy these bytes.  Some optimization is possible here,
          * depending on the value of 'bytes_to_copy'.  Special case the low
          * byte counts, which we know to be frequent.
          *
          * Notice that these cases all 'return' rather than 'break' - this
          * avoids an unnecessary test on whether to restore the last byte
          * below.
          */
         switch (bytes_to_copy)
         {
            case 1:
               for (;;)
               {
                  *dp = *sp;

                  if (row_width <= bytes_to_jump)
                     return;

                  dp += bytes_to_jump;
                  sp += bytes_to_jump;
                  row_width -= bytes_to_jump;
               }

            case 2:
               /* There is a possibility of a partial copy at the end here; this
                * slows the code down somewhat.
                */
               do
               {
                  dp[0] = sp[0], dp[1] = sp[1];

                  if (row_width <= bytes_to_jump)
                     return;

                  sp += bytes_to_jump;
                  dp += bytes_to_jump;
                  row_width -= bytes_to_jump;
               }
               while (row_width > 1);

               /* And there can only be one byte left at this point: */
               *dp = *sp;
               return;

            case 3:
               /* This can only be the RGB case, so each copy is exactly one
                * pixel and it is not necessary to check for a partial copy.
                */
               for (;;)
               {
                  dp[0] = sp[0], dp[1] = sp[1], dp[2] = sp[2];

                  if (row_width <= bytes_to_jump)
                     return;

                  sp += bytes_to_jump;
                  dp += bytes_to_jump;
                  row_width -= bytes_to_jump;
               }

            default:
#if PNG_ALIGN_TYPE != PNG_ALIGN_NONE
               /* Check for double byte alignment and, if possible, use a
                * 16-bit copy.  Don't attempt this for narrow images - ones that
                * are less than an interlace panel wide.  Don't attempt it for
                * wide bytes_to_copy either - use the memcpy there.
                */
               if (bytes_to_copy < 16 /*else use memcpy*/ &&
                   png_isaligned(dp, png_uint_16) &&
                   png_isaligned(sp, png_uint_16) &&
                   bytes_to_copy % (sizeof (png_uint_16)) == 0 &&
                   bytes_to_jump % (sizeof (png_uint_16)) == 0)
               {
                  /* Everything is aligned for png_uint_16 copies, but try for
                   * png_uint_32 first.
                   */
                  if (png_isaligned(dp, png_uint_32) &&
                      png_isaligned(sp, png_uint_32) &&
                      bytes_to_copy % (sizeof (png_uint_32)) == 0 &&
                      bytes_to_jump % (sizeof (png_uint_32)) == 0)
                  {
                     png_uint_32p dp32 = png_aligncast(png_uint_32p,dp);
                     png_const_uint_32p sp32 = png_aligncastconst(
                         png_const_uint_32p, sp);
                     size_t skip = (bytes_to_jump-bytes_to_copy) /
                         (sizeof (png_uint_32));

                     do
                     {
                        size_t c = bytes_to_copy;
                        do
                        {
                           *dp32++ = *sp32++;
                           c -= (sizeof (png_uint_32));
                        }
                        while (c > 0);

                        if (row_width <= bytes_to_jump)
                           return;

                        dp32 += skip;
                        sp32 += skip;
                        row_width -= bytes_to_jump;
                     }
                     while (bytes_to_copy <= row_width);

                     /* Get to here when the row_width truncates the final copy.
                      * There will be 1-3 bytes left to copy, so don't try the
                      * 16-bit loop below.
                      */
                     dp = (png_bytep)dp32;
                     sp = (png_const_bytep)sp32;
                     do
                        *dp++ = *sp++;
                     while (--row_width > 0);
                     return;
                  }

                  /* Else do it in 16-bit quantities, but only if the size is
                   * not too large.
                   */
                  else
                  {
                     png_uint_16p dp16 = png_aligncast(png_uint_16p, dp);
                     png_const_uint_16p sp16 = png_aligncastconst(
                        png_const_uint_16p, sp);
                     size_t skip = (bytes_to_jump-bytes_to_copy) /
                        (sizeof (png_uint_16));

                     do
                     {
                        size_t c = bytes_to_copy;
                        do
                        {
                           *dp16++ = *sp16++;
                           c -= (sizeof (png_uint_16));
                        }
                        while (c > 0);

                        if (row_width <= bytes_to_jump)
                           return;

                        dp16 += skip;
                        sp16 += skip;
                        row_width -= bytes_to_jump;
                     }
                     while (bytes_to_copy <= row_width);

                     /* End of row - 1 byte left, bytes_to_copy > row_width: */
                     dp = (png_bytep)dp16;
                     sp = (png_const_bytep)sp16;
                     do
                        *dp++ = *sp++;
                     while (--row_width > 0);
                     return;
                  }
               }
#endif /* ALIGN_TYPE code */

               /* The true default - use a memcpy: */
               for (;;)
               {
                  memcpy(dp, sp, bytes_to_copy);

                  if (row_width <= bytes_to_jump)
                     return;

                  sp += bytes_to_jump;
                  dp += bytes_to_jump;
                  row_width -= bytes_to_jump;
                  if (bytes_to_copy > row_width)
                     bytes_to_copy = (unsigned int)/*SAFE*/row_width;
               }
         }

         /* NOT REACHED*/
      } /* pixel_depth >= 8 */

      /* Here if pixel_depth < 8 to check 'end_ptr' below. */
   }
   else
#endif /* READ_INTERLACING */

   /* If here then the switch above wasn't used so just memcpy the whole row
    * from the temporary row buffer (notice that this overwrites the end of the
    * destination row if it is a partial byte.)
    */
   memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));

   /* Restore the overwritten bits from the last byte if necessary. */
   if (end_ptr != NULL)
      *end_ptr = (png_byte)((end_byte & end_mask) | (*end_ptr & ~end_mask));
}

#ifdef PNG_READ_INTERLACING_SUPPORTED
void /* PRIVATE */
png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
    png_uint_32 transformations /* Because these may affect the byte layout */)
{
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   /* Offset to next interlace block */
   static PNG_CONST unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   png_debug(1, "in png_do_read_interlace");
   if (row != NULL && row_info != NULL)
   {
      png_uint_32 final_width;

      final_width = row_info->width * png_pass_inc[pass];

      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);
            png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);
            unsigned int sshift, dshift;
            unsigned int s_start, s_end;
            int s_inc;
            int jstop = (int)png_pass_inc[pass];
            png_byte v;
            png_uint_32 i;
            int j;

#ifdef PNG_READ_PACKSWAP_SUPPORTED
            if ((transformations & PNG_PACKSWAP) != 0)
            {
                sshift = ((row_info->width + 7) & 0x07);
                dshift = ((final_width + 7) & 0x07);
                s_start = 7;
                s_end = 0;
                s_inc = -1;
            }

            else
#endif
            {
                sshift = 7 - ((row_info->width + 7) & 0x07);
                dshift = 7 - ((final_width + 7) & 0x07);
                s_start = 0;
                s_end = 7;
                s_inc = 1;
            }

            for (i = 0; i < row_info->width; i++)
            {
               v = (png_byte)((*sp >> sshift) & 0x01);
               for (j = 0; j < jstop; j++)
               {
                  unsigned int tmp = *dp & (0x7f7f >> (7 - dshift));
                  tmp |= (unsigned int)(v << dshift);
                  *dp = (png_byte)(tmp & 0xff);

                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }

                  else
                     dshift = (unsigned int)((int)dshift + s_inc);
               }

               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }

               else
                  sshift = (unsigned int)((int)sshift + s_inc);
            }
            break;
         }

         case 2:
         {
            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);
            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);
            unsigned int sshift, dshift;
            unsigned int s_start, s_end;
            int s_inc;
            int jstop = (int)png_pass_inc[pass];
            png_uint_32 i;

#ifdef PNG_READ_PACKSWAP_SUPPORTED
            if ((transformations & PNG_PACKSWAP) != 0)
            {
               sshift = (((row_info->width + 3) & 0x03) << 1);
               dshift = (((final_width + 3) & 0x03) << 1);
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }

            else
#endif
            {
               sshift = ((3 - ((row_info->width + 3) & 0x03)) << 1);
               dshift = ((3 - ((final_width + 3) & 0x03)) << 1);
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v;
               int j;

               v = (png_byte)((*sp >> sshift) & 0x03);
               for (j = 0; j < jstop; j++)
               {
                  unsigned int tmp = *dp & (0x3f3f >> (6 - dshift));
                  tmp |= (unsigned int)(v << dshift);
                  *dp = (png_byte)(tmp & 0xff);

                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }

                  else
                     dshift = (unsigned int)((int)dshift + s_inc);
               }

               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }

               else
                  sshift = (unsigned int)((int)sshift + s_inc);
            }
            break;
         }

         case 4:
         {
            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);
            png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);
            unsigned int sshift, dshift;
            unsigned int s_start, s_end;
            int s_inc;
            png_uint_32 i;
            int jstop = (int)png_pass_inc[pass];

#ifdef PNG_READ_PACKSWAP_SUPPORTED
            if ((transformations & PNG_PACKSWAP) != 0)
            {
               sshift = (((row_info->width + 1) & 0x01) << 2);
               dshift = (((final_width + 1) & 0x01) << 2);
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }

            else
#endif
            {
               sshift = ((1 - ((row_info->width + 1) & 0x01)) << 2);
               dshift = ((1 - ((final_width + 1) & 0x01)) << 2);
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v = (png_byte)((*sp >> sshift) & 0x0f);
               int j;

               for (j = 0; j < jstop; j++)
               {
                  unsigned int tmp = *dp & (0xf0f >> (4 - dshift));
                  tmp |= (unsigned int)(v << dshift);
                  *dp = (png_byte)(tmp & 0xff);

                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }

                  else
                     dshift = (unsigned int)((int)dshift + s_inc);
               }

               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }

               else
                  sshift = (unsigned int)((int)sshift + s_inc);
            }
            break;
         }

         default:
         {
            png_size_t pixel_bytes = (row_info->pixel_depth >> 3);

            png_bytep sp = row + (png_size_t)(row_info->width - 1)
                * pixel_bytes;

            png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;

            int jstop = (int)png_pass_inc[pass];
            png_uint_32 i;

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v[8]; /* SAFE; pixel_depth does not exceed 64 */
               int j;

               memcpy(v, sp, pixel_bytes);

               for (j = 0; j < jstop; j++)
               {
                  memcpy(dp, v, pixel_bytes);
                  dp -= pixel_bytes;
               }

               sp -= pixel_bytes;
            }
            break;
         }
      }

      row_info->width = final_width;
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);
   }
#ifndef PNG_READ_PACKSWAP_SUPPORTED
   PNG_UNUSED(transformations)  /* Silence compiler warning */
#endif
}
#endif /* READ_INTERLACING */

static void
png_read_filter_row_sub(png_row_infop row_info, png_bytep row,
    png_const_bytep prev_row)
{
   png_size_t i;
   png_size_t istop = row_info->rowbytes;
   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
   png_bytep rp = row + bpp;

   PNG_UNUSED(prev_row)

   for (i = bpp; i < istop; i++)
   {
      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
      rp++;
   }
}

static void
png_read_filter_row_up(png_row_infop row_info, png_bytep row,
    png_const_bytep prev_row)
{
   png_size_t i;
   png_size_t istop = row_info->rowbytes;
   png_bytep rp = row;
   png_const_bytep pp = prev_row;

   for (i = 0; i < istop; i++)
   {
      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
      rp++;
   }
}

static void
png_read_filter_row_avg(png_row_infop row_info, png_bytep row,
    png_const_bytep prev_row)
{
   png_size_t i;
   png_bytep rp = row;
   png_const_bytep pp = prev_row;
   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
   png_size_t istop = row_info->rowbytes - bpp;

   for (i = 0; i < bpp; i++)
   {
      *rp = (png_byte)(((int)(*rp) +
         ((int)(*pp++) / 2 )) & 0xff);

      rp++;
   }

   for (i = 0; i < istop; i++)
   {
      *rp = (png_byte)(((int)(*rp) +
         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);

      rp++;
   }
}

static void
png_read_filter_row_paeth_1byte_pixel(png_row_infop row_info, png_bytep row,
    png_const_bytep prev_row)
{
   png_bytep rp_end = row + row_info->rowbytes;
   int a, c;

   /* First pixel/byte */
   c = *prev_row++;
   a = *row + c;
   *row++ = (png_byte)a;

   /* Remainder */
   while (row < rp_end)
   {
      int b, pa, pb, pc, p;

      a &= 0xff; /* From previous iteration or start */
      b = *prev_row++;

      p = b - c;
      pc = a - c;

#ifdef PNG_USE_ABS
      pa = abs(p);
      pb = abs(pc);
      pc = abs(p + pc);
#else
      pa = p < 0 ? -p : p;
      pb = pc < 0 ? -pc : pc;
      pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

      /* Find the best predictor, the least of pa, pb, pc favoring the earlier
       * ones in the case of a tie.
       */
      if (pb < pa) pa = pb, a = b;
      if (pc < pa) a = c;

      /* Calculate the current pixel in a, and move the previous row pixel to c
       * for the next time round the loop
       */
      c = b;
      a += *row;
      *row++ = (png_byte)a;
   }
}

static void
png_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info, png_bytep row,
    png_const_bytep prev_row)
{
   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
   png_bytep rp_end = row + bpp;

   /* Process the first pixel in the row completely (this is the same as 'up'
    * because there is only one candidate predictor for the first row).
    */
   while (row < rp_end)
   {
      int a = *row + *prev_row++;
      *row++ = (png_byte)a;
   }

   /* Remainder */
   rp_end = rp_end + (row_info->rowbytes - bpp);

   while (row < rp_end)
   {
      int a, b, c, pa, pb, pc, p;

      c = *(prev_row - bpp);
      a = *(row - bpp);
      b = *prev_row++;

      p = b - c;
      pc = a - c;

#ifdef PNG_USE_ABS
      pa = abs(p);
      pb = abs(pc);
      pc = abs(p + pc);
#else
      pa = p < 0 ? -p : p;
      pb = pc < 0 ? -pc : pc;
      pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

      if (pb < pa) pa = pb, a = b;
      if (pc < pa) a = c;

      a += *row;
      *row++ = (png_byte)a;
   }
}

static void
png_init_filter_functions(png_structrp pp)
   /* This function is called once for every PNG image (except for PNG images
    * that only use PNG_FILTER_VALUE_NONE for all rows) to set the
    * implementations required to reverse the filtering of PNG rows.  Reversing
    * the filter is the first transformation performed on the row data.  It is
    * performed in place, therefore an implementation can be selected based on
    * the image pixel format.  If the implementation depends on image width then
    * take care to ensure that it works correctly if the image is interlaced -
    * interlacing causes the actual row width to vary.
    */
{
   unsigned int bpp = (pp->pixel_depth + 7) >> 3;

   pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub;
   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up;
   pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg;
   if (bpp == 1)
      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
         png_read_filter_row_paeth_1byte_pixel;
   else
      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
         png_read_filter_row_paeth_multibyte_pixel;

#ifdef PNG_FILTER_OPTIMIZATIONS
   /* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to
    * call to install hardware optimizations for the above functions; simply
    * replace whatever elements of the pp->read_filter[] array with a hardware
    * specific (or, for that matter, generic) optimization.
    *
    * To see an example of this examine what configure.ac does when
    * --enable-arm-neon is specified on the command line.
    */
   PNG_FILTER_OPTIMIZATIONS(pp, bpp);
#endif
}

void /* PRIVATE */
png_read_filter_row(png_structrp pp, png_row_infop row_info, png_bytep row,
    png_const_bytep prev_row, int filter)
{
   /* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define
    * PNG_FILTER_OPTIMIZATIONS to a function that overrides the generic
    * implementations.  See png_init_filter_functions above.
    */
   if (filter > PNG_FILTER_VALUE_NONE && filter < PNG_FILTER_VALUE_LAST)
   {
      if (pp->read_filter[0] == NULL)
         png_init_filter_functions(pp);

      pp->read_filter[filter-1](row_info, row, prev_row);
   }
}

#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
void /* PRIVATE */
png_read_IDAT_data(png_structrp png_ptr, png_bytep output,
    png_alloc_size_t avail_out)
{
   /* Loop reading IDATs and decompressing the result into output[avail_out] */
   png_ptr->zstream.next_out = output;
   png_ptr->zstream.avail_out = 0; /* safety: set below */

   if (output == NULL)
      avail_out = 0;

   do
   {
      int ret;
      png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];

      if (png_ptr->zstream.avail_in == 0)
      {
         uInt avail_in;
         png_bytep buffer;

         while (png_ptr->idat_size == 0)
         {
            png_crc_finish(png_ptr, 0);

            png_ptr->idat_size = png_read_chunk_header(png_ptr);
            /* This is an error even in the 'check' case because the code just
             * consumed a non-IDAT header.
             */
            if (png_ptr->chunk_name != png_IDAT)
               png_error(png_ptr, "Not enough image data");
         }

         avail_in = png_ptr->IDAT_read_size;

         if (avail_in > png_ptr->idat_size)
            avail_in = (uInt)png_ptr->idat_size;

         /* A PNG with a gradually increasing IDAT size will defeat this attempt
          * to minimize memory usage by causing lots of re-allocs, but
          * realistically doing IDAT_read_size re-allocs is not likely to be a
          * big problem.
          */
         buffer = png_read_buffer(png_ptr, avail_in, 0/*error*/);

         png_crc_read(png_ptr, buffer, avail_in);
         png_ptr->idat_size -= avail_in;

         png_ptr->zstream.next_in = buffer;
         png_ptr->zstream.avail_in = avail_in;
      }

      /* And set up the output side. */
      if (output != NULL) /* standard read */
      {
         uInt out = ZLIB_IO_MAX;

         if (out > avail_out)
            out = (uInt)avail_out;

         avail_out -= out;
         png_ptr->zstream.avail_out = out;
      }

      else /* after last row, checking for end */
      {
         png_ptr->zstream.next_out = tmpbuf;
         png_ptr->zstream.avail_out = (sizeof tmpbuf);
      }

      /* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the
       * process.  If the LZ stream is truncated the sequential reader will
       * terminally damage the stream, above, by reading the chunk header of the
       * following chunk (it then exits with png_error).
       *
       * TODO: deal more elegantly with truncated IDAT lists.
       */
      ret = PNG_INFLATE(png_ptr, Z_NO_FLUSH);

      /* Take the unconsumed output back. */
      if (output != NULL)
         avail_out += png_ptr->zstream.avail_out;

      else /* avail_out counts the extra bytes */
         avail_out += (sizeof tmpbuf) - png_ptr->zstream.avail_out;

      png_ptr->zstream.avail_out = 0;

      if (ret == Z_STREAM_END)
      {
         /* Do this for safety; we won't read any more into this row. */
         png_ptr->zstream.next_out = NULL;

         png_ptr->mode |= PNG_AFTER_IDAT;
         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;

         if (png_ptr->zstream.avail_in > 0 || png_ptr->idat_size > 0)
            png_chunk_benign_error(png_ptr, "Extra compressed data");
         break;
      }

      if (ret != Z_OK)
      {
         png_zstream_error(png_ptr, ret);

         if (output != NULL)
            png_chunk_error(png_ptr, png_ptr->zstream.msg);

         else /* checking */
         {
            png_chunk_benign_error(png_ptr, png_ptr->zstream.msg);
            return;
         }
      }
   } while (avail_out > 0);

   if (avail_out > 0)
   {
      /* The stream ended before the image; this is the same as too few IDATs so
       * should be handled the same way.
       */
      if (output != NULL)
         png_error(png_ptr, "Not enough image data");

      else /* the deflate stream contained extra data */
         png_chunk_benign_error(png_ptr, "Too much image data");
   }
}

void /* PRIVATE */
png_read_finish_IDAT(png_structrp png_ptr)
{
   /* We don't need any more data and the stream should have ended, however the
    * LZ end code may actually not have been processed.  In this case we must
    * read it otherwise stray unread IDAT data or, more likely, an IDAT chunk
    * may still remain to be consumed.
    */
   if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)
   {
      /* The NULL causes png_read_IDAT_data to swallow any remaining bytes in
       * the compressed stream, but the stream may be damaged too, so even after
       * this call we may need to terminate the zstream ownership.
       */
      png_read_IDAT_data(png_ptr, NULL, 0);
      png_ptr->zstream.next_out = NULL; /* safety */

      /* Now clear everything out for safety; the following may not have been
       * done.
       */
      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_ENDED) == 0)
      {
         png_ptr->mode |= PNG_AFTER_IDAT;
         png_ptr->flags |= PNG_FLAG_ZSTREAM_ENDED;
      }
   }

   /* If the zstream has not been released do it now *and* terminate the reading
    * of the final IDAT chunk.
    */
   if (png_ptr->zowner == png_IDAT)
   {
      /* Always do this; the pointers otherwise point into the read buffer. */
      png_ptr->zstream.next_in = NULL;
      png_ptr->zstream.avail_in = 0;

      /* Now we no longer own the zstream. */
      png_ptr->zowner = 0;

      /* The slightly weird semantics of the sequential IDAT reading is that we
       * are always in or at the end of an IDAT chunk, so we always need to do a
       * crc_finish here.  If idat_size is non-zero we also need to read the
       * spurious bytes at the end of the chunk now.
       */
      (void)png_crc_finish(png_ptr, png_ptr->idat_size);
   }
}

void /* PRIVATE */
png_read_finish_row(png_structrp png_ptr)
{
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* Start of interlace block in the y direction */
   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* Offset to next interlace block in the y direction */
   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};

   png_debug(1, "in png_read_finish_row");
   png_ptr->row_number++;
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

   if (png_ptr->interlaced != 0)
   {
      png_ptr->row_number = 0;

      /* TO DO: don't do this if prev_row isn't needed (requires
       * read-ahead of the next row's filter byte.
       */
      memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);

      do
      {
         png_ptr->pass++;

         if (png_ptr->pass >= 7)
            break;

         png_ptr->iwidth = (png_ptr->width +
            png_pass_inc[png_ptr->pass] - 1 -
            png_pass_start[png_ptr->pass]) /
            png_pass_inc[png_ptr->pass];

         if ((png_ptr->transformations & PNG_INTERLACE) == 0)
         {
            png_ptr->num_rows = (png_ptr->height +
                png_pass_yinc[png_ptr->pass] - 1 -
                png_pass_ystart[png_ptr->pass]) /
                png_pass_yinc[png_ptr->pass];
         }

         else  /* if (png_ptr->transformations & PNG_INTERLACE) */
            break; /* libpng deinterlacing sees every row */

      } while (png_ptr->num_rows == 0 || png_ptr->iwidth == 0);

      if (png_ptr->pass < 7)
         return;
   }

   /* Here after at the end of the last row of the last pass. */
   png_read_finish_IDAT(png_ptr);
}
#endif /* SEQUENTIAL_READ */

void /* PRIVATE */
png_read_start_row(png_structrp png_ptr)
{
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* Start of interlace block in the y direction */
   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* Offset to next interlace block in the y direction */
   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};

   unsigned int max_pixel_depth;
   png_size_t row_bytes;

   png_debug(1, "in png_read_start_row");

#ifdef PNG_READ_TRANSFORMS_SUPPORTED
   png_init_read_transformations(png_ptr);
#endif
   if (png_ptr->interlaced != 0)
   {
      if ((png_ptr->transformations & PNG_INTERLACE) == 0)
         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
             png_pass_ystart[0]) / png_pass_yinc[0];

      else
         png_ptr->num_rows = png_ptr->height;

      png_ptr->iwidth = (png_ptr->width +
          png_pass_inc[png_ptr->pass] - 1 -
          png_pass_start[png_ptr->pass]) /
          png_pass_inc[png_ptr->pass];
   }

   else
   {
      png_ptr->num_rows = png_ptr->height;
      png_ptr->iwidth = png_ptr->width;
   }

   max_pixel_depth = (unsigned int)png_ptr->pixel_depth;

   /* WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of
    * calculations to calculate the final pixel depth, then
    * png_do_read_transforms actually does the transforms.  This means that the
    * code which effectively calculates this value is actually repeated in three
    * separate places.  They must all match.  Innocent changes to the order of
    * transformations can and will break libpng in a way that causes memory
    * overwrites.
    *
    * TODO: fix this.
    */
#ifdef PNG_READ_PACK_SUPPORTED
   if ((png_ptr->transformations & PNG_PACK) != 0 && png_ptr->bit_depth < 8)
      max_pixel_depth = 8;
#endif

#ifdef PNG_READ_EXPAND_SUPPORTED
   if ((png_ptr->transformations & PNG_EXPAND) != 0)
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         if (png_ptr->num_trans != 0)
            max_pixel_depth = 32;

         else
            max_pixel_depth = 24;
      }

      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (max_pixel_depth < 8)
            max_pixel_depth = 8;

         if (png_ptr->num_trans != 0)
            max_pixel_depth *= 2;
      }

      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
      {
         if (png_ptr->num_trans != 0)
         {
            max_pixel_depth *= 4;
            max_pixel_depth /= 3;
         }
      }
   }
#endif

#ifdef PNG_READ_EXPAND_16_SUPPORTED
   if ((png_ptr->transformations & PNG_EXPAND_16) != 0)
   {
#  ifdef PNG_READ_EXPAND_SUPPORTED
      /* In fact it is an error if it isn't supported, but checking is
       * the safe way.
       */
      if ((png_ptr->transformations & PNG_EXPAND) != 0)
      {
         if (png_ptr->bit_depth < 16)
            max_pixel_depth *= 2;
      }
      else
#  endif
      png_ptr->transformations &= ~PNG_EXPAND_16;
   }
#endif

#ifdef PNG_READ_FILLER_SUPPORTED
   if ((png_ptr->transformations & (PNG_FILLER)) != 0)
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (max_pixel_depth <= 8)
            max_pixel_depth = 16;

         else
            max_pixel_depth = 32;
      }

      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB ||
         png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         if (max_pixel_depth <= 32)
            max_pixel_depth = 32;

         else
            max_pixel_depth = 64;
      }
   }
#endif

#ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
   if ((png_ptr->transformations & PNG_GRAY_TO_RGB) != 0)
   {
      if (
#ifdef PNG_READ_EXPAND_SUPPORTED
          (png_ptr->num_trans != 0 &&
          (png_ptr->transformations & PNG_EXPAND) != 0) ||
#endif
#ifdef PNG_READ_FILLER_SUPPORTED
          (png_ptr->transformations & (PNG_FILLER)) != 0 ||
#endif
          png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (max_pixel_depth <= 16)
            max_pixel_depth = 32;

         else
            max_pixel_depth = 64;
      }

      else
      {
         if (max_pixel_depth <= 8)
         {
            if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
               max_pixel_depth = 32;

            else
               max_pixel_depth = 24;
         }

         else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            max_pixel_depth = 64;

         else
            max_pixel_depth = 48;
      }
   }
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \
defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
   {
      unsigned int user_pixel_depth = png_ptr->user_transform_depth *
         png_ptr->user_transform_channels;

      if (user_pixel_depth > max_pixel_depth)
         max_pixel_depth = user_pixel_depth;
   }
#endif

   /* This value is stored in png_struct and double checked in the row read
    * code.
    */
   png_ptr->maximum_pixel_depth = (png_byte)max_pixel_depth;
   png_ptr->transformed_pixel_depth = 0; /* calculated on demand */

   /* Align the width on the next larger 8 pixels.  Mainly used
    * for interlacing
    */
   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));
   /* Calculate the maximum bytes needed, adding a byte and a pixel
    * for safety's sake
    */
   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +
       1 + ((max_pixel_depth + 7) >> 3U);

#ifdef PNG_MAX_MALLOC_64K
   if (row_bytes > (png_uint_32)65536L)
      png_error(png_ptr, "This image requires a row greater than 64KB");
#endif

   if (row_bytes + 48 > png_ptr->old_big_row_buf_size)
   {
      png_free(png_ptr, png_ptr->big_row_buf);
      png_free(png_ptr, png_ptr->big_prev_row);

      if (png_ptr->interlaced != 0)
         png_ptr->big_row_buf = (png_bytep)png_calloc(png_ptr,
             row_bytes + 48);

      else
         png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes + 48);

      png_ptr->big_prev_row = (png_bytep)png_malloc(png_ptr, row_bytes + 48);

#ifdef PNG_ALIGNED_MEMORY_SUPPORTED
      /* Use 16-byte aligned memory for row_buf with at least 16 bytes
       * of padding before and after row_buf; treat prev_row similarly.
       * NOTE: the alignment is to the start of the pixels, one beyond the start
       * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this
       * was incorrect; the filter byte was aligned, which had the exact
       * opposite effect of that intended.
       */
      {
         png_bytep temp = png_ptr->big_row_buf + 32;
         int extra = (int)((temp - (png_bytep)0) & 0x0f);
         png_ptr->row_buf = temp - extra - 1/*filter byte*/;

         temp = png_ptr->big_prev_row + 32;
         extra = (int)((temp - (png_bytep)0) & 0x0f);
         png_ptr->prev_row = temp - extra - 1/*filter byte*/;
      }

#else
      /* Use 31 bytes of padding before and 17 bytes after row_buf. */
      png_ptr->row_buf = png_ptr->big_row_buf + 31;
      png_ptr->prev_row = png_ptr->big_prev_row + 31;
#endif
      png_ptr->old_big_row_buf_size = row_bytes + 48;
   }

#ifdef PNG_MAX_MALLOC_64K
   if (png_ptr->rowbytes > 65535)
      png_error(png_ptr, "This image requires a row greater than 64KB");

#endif
   if (png_ptr->rowbytes > (PNG_SIZE_MAX - 1))
      png_error(png_ptr, "Row has too many bytes to allocate in memory");

   memset(png_ptr->prev_row, 0, png_ptr->rowbytes + 1);

   png_debug1(3, "width = %u,", png_ptr->width);
   png_debug1(3, "height = %u,", png_ptr->height);
   png_debug1(3, "iwidth = %u,", png_ptr->iwidth);
   png_debug1(3, "num_rows = %u,", png_ptr->num_rows);
   png_debug1(3, "rowbytes = %lu,", (unsigned long)png_ptr->rowbytes);
   png_debug1(3, "irowbytes = %lu",
       (unsigned long)PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);

   /* The sequential reader needs a buffer for IDAT, but the progressive reader
    * does not, so free the read buffer now regardless; the sequential reader
    * reallocates it on demand.
    */
   if (png_ptr->read_buffer != NULL)
   {
      png_bytep buffer = png_ptr->read_buffer;

      png_ptr->read_buffer_size = 0;
      png_ptr->read_buffer = NULL;
      png_free(png_ptr, buffer);
   }

   /* Finally claim the zstream for the inflate of the IDAT data, use the bits
    * value from the stream (note that this will result in a fatal error if the
    * IDAT stream has a bogus deflate header window_bits value, but this should
    * not be happening any longer!)
    */
   if (png_inflate_claim(png_ptr, png_IDAT) != Z_OK)
      png_error(png_ptr, png_ptr->zstream.msg);

   png_ptr->flags |= PNG_FLAG_ROW_INIT;
}
#endif /* READ */

```

`ThirdPartyBuild/PNG/Code/pngset.c`:

```c

/* pngset.c - storage of image information into info struct
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * The functions here are used during reads to store data from the file
 * into the info struct, and during writes to store application data
 * into the info struct for writing into the file.  This abstracts the
 * info struct and allows us to change the structure in the future.
 */

#include "pngpriv.h"

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)

#ifdef PNG_bKGD_SUPPORTED
void PNGAPI
png_set_bKGD(png_const_structrp png_ptr, png_inforp info_ptr,
    png_const_color_16p background)
{
   png_debug1(1, "in %s storage function", "bKGD");

   if (png_ptr == NULL || info_ptr == NULL || background == NULL)
      return;

   info_ptr->background = *background;
   info_ptr->valid |= PNG_INFO_bKGD;
}
#endif

#ifdef PNG_cHRM_SUPPORTED
void PNGFAPI
png_set_cHRM_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
    png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
    png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
    png_fixed_point blue_x, png_fixed_point blue_y)
{
   png_xy xy;

   png_debug1(1, "in %s storage function", "cHRM fixed");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   xy.redx = red_x;
   xy.redy = red_y;
   xy.greenx = green_x;
   xy.greeny = green_y;
   xy.bluex = blue_x;
   xy.bluey = blue_y;
   xy.whitex = white_x;
   xy.whitey = white_y;

   if (png_colorspace_set_chromaticities(png_ptr, &info_ptr->colorspace, &xy,
       2/* override with app values*/) != 0)
      info_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;

   png_colorspace_sync_info(png_ptr, info_ptr);
}

void PNGFAPI
png_set_cHRM_XYZ_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
    png_fixed_point int_red_X, png_fixed_point int_red_Y,
    png_fixed_point int_red_Z, png_fixed_point int_green_X,
    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
    png_fixed_point int_blue_Z)
{
   png_XYZ XYZ;

   png_debug1(1, "in %s storage function", "cHRM XYZ fixed");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   XYZ.red_X = int_red_X;
   XYZ.red_Y = int_red_Y;
   XYZ.red_Z = int_red_Z;
   XYZ.green_X = int_green_X;
   XYZ.green_Y = int_green_Y;
   XYZ.green_Z = int_green_Z;
   XYZ.blue_X = int_blue_X;
   XYZ.blue_Y = int_blue_Y;
   XYZ.blue_Z = int_blue_Z;

   if (png_colorspace_set_endpoints(png_ptr, &info_ptr->colorspace,
       &XYZ, 2) != 0)
      info_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;

   png_colorspace_sync_info(png_ptr, info_ptr);
}

#  ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_cHRM(png_const_structrp png_ptr, png_inforp info_ptr,
    double white_x, double white_y, double red_x, double red_y,
    double green_x, double green_y, double blue_x, double blue_y)
{
   png_set_cHRM_fixed(png_ptr, info_ptr,
       png_fixed(png_ptr, white_x, "cHRM White X"),
       png_fixed(png_ptr, white_y, "cHRM White Y"),
       png_fixed(png_ptr, red_x, "cHRM Red X"),
       png_fixed(png_ptr, red_y, "cHRM Red Y"),
       png_fixed(png_ptr, green_x, "cHRM Green X"),
       png_fixed(png_ptr, green_y, "cHRM Green Y"),
       png_fixed(png_ptr, blue_x, "cHRM Blue X"),
       png_fixed(png_ptr, blue_y, "cHRM Blue Y"));
}

void PNGAPI
png_set_cHRM_XYZ(png_const_structrp png_ptr, png_inforp info_ptr, double red_X,
    double red_Y, double red_Z, double green_X, double green_Y, double green_Z,
    double blue_X, double blue_Y, double blue_Z)
{
   png_set_cHRM_XYZ_fixed(png_ptr, info_ptr,
       png_fixed(png_ptr, red_X, "cHRM Red X"),
       png_fixed(png_ptr, red_Y, "cHRM Red Y"),
       png_fixed(png_ptr, red_Z, "cHRM Red Z"),
       png_fixed(png_ptr, green_X, "cHRM Green X"),
       png_fixed(png_ptr, green_Y, "cHRM Green Y"),
       png_fixed(png_ptr, green_Z, "cHRM Green Z"),
       png_fixed(png_ptr, blue_X, "cHRM Blue X"),
       png_fixed(png_ptr, blue_Y, "cHRM Blue Y"),
       png_fixed(png_ptr, blue_Z, "cHRM Blue Z"));
}
#  endif /* FLOATING_POINT */

#endif /* cHRM */

#ifdef PNG_gAMA_SUPPORTED
void PNGFAPI
png_set_gAMA_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
    png_fixed_point file_gamma)
{
   png_debug1(1, "in %s storage function", "gAMA");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   png_colorspace_set_gamma(png_ptr, &info_ptr->colorspace, file_gamma);
   png_colorspace_sync_info(png_ptr, info_ptr);
}

#  ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_gAMA(png_const_structrp png_ptr, png_inforp info_ptr, double file_gamma)
{
   png_set_gAMA_fixed(png_ptr, info_ptr, png_fixed(png_ptr, file_gamma,
       "png_set_gAMA"));
}
#  endif
#endif

#ifdef PNG_hIST_SUPPORTED
void PNGAPI
png_set_hIST(png_const_structrp png_ptr, png_inforp info_ptr,
    png_const_uint_16p hist)
{
   int i;

   png_debug1(1, "in %s storage function", "hIST");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (info_ptr->num_palette == 0 || info_ptr->num_palette
       > PNG_MAX_PALETTE_LENGTH)
   {
      png_warning(png_ptr,
          "Invalid palette size, hIST allocation skipped");

      return;
   }

   png_free_data(png_ptr, info_ptr, PNG_FREE_HIST, 0);

   /* Changed from info->num_palette to PNG_MAX_PALETTE_LENGTH in
    * version 1.2.1
    */
   info_ptr->hist = png_voidcast(png_uint_16p, png_malloc_warn(png_ptr,
       PNG_MAX_PALETTE_LENGTH * (sizeof (png_uint_16))));

   if (info_ptr->hist == NULL)
   {
      png_warning(png_ptr, "Insufficient memory for hIST chunk data");

      return;
   }

   info_ptr->free_me |= PNG_FREE_HIST;

   for (i = 0; i < info_ptr->num_palette; i++)
      info_ptr->hist[i] = hist[i];

   info_ptr->valid |= PNG_INFO_hIST;
}
#endif

void PNGAPI
png_set_IHDR(png_const_structrp png_ptr, png_inforp info_ptr,
    png_uint_32 width, png_uint_32 height, int bit_depth,
    int color_type, int interlace_type, int compression_type,
    int filter_type)
{
   png_debug1(1, "in %s storage function", "IHDR");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->width = width;
   info_ptr->height = height;
   info_ptr->bit_depth = (png_byte)bit_depth;
   info_ptr->color_type = (png_byte)color_type;
   info_ptr->compression_type = (png_byte)compression_type;
   info_ptr->filter_type = (png_byte)filter_type;
   info_ptr->interlace_type = (png_byte)interlace_type;

   png_check_IHDR (png_ptr, info_ptr->width, info_ptr->height,
       info_ptr->bit_depth, info_ptr->color_type, info_ptr->interlace_type,
       info_ptr->compression_type, info_ptr->filter_type);

   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      info_ptr->channels = 1;

   else if ((info_ptr->color_type & PNG_COLOR_MASK_COLOR) != 0)
      info_ptr->channels = 3;

   else
      info_ptr->channels = 1;

   if ((info_ptr->color_type & PNG_COLOR_MASK_ALPHA) != 0)
      info_ptr->channels++;

   info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);

   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);
}

#ifdef PNG_oFFs_SUPPORTED
void PNGAPI
png_set_oFFs(png_const_structrp png_ptr, png_inforp info_ptr,
    png_int_32 offset_x, png_int_32 offset_y, int unit_type)
{
   png_debug1(1, "in %s storage function", "oFFs");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->x_offset = offset_x;
   info_ptr->y_offset = offset_y;
   info_ptr->offset_unit_type = (png_byte)unit_type;
   info_ptr->valid |= PNG_INFO_oFFs;
}
#endif

#ifdef PNG_pCAL_SUPPORTED
void PNGAPI
png_set_pCAL(png_const_structrp png_ptr, png_inforp info_ptr,
    png_const_charp purpose, png_int_32 X0, png_int_32 X1, int type,
    int nparams, png_const_charp units, png_charpp params)
{
   png_size_t length;
   int i;

   png_debug1(1, "in %s storage function", "pCAL");

   if (png_ptr == NULL || info_ptr == NULL || purpose == NULL || units == NULL
       || (nparams > 0 && params == NULL))
      return;

   length = strlen(purpose) + 1;
   png_debug1(3, "allocating purpose for info (%lu bytes)",
       (unsigned long)length);

   /* TODO: validate format of calibration name and unit name */

   /* Check that the type matches the specification. */
   if (type < 0 || type > 3)
   {
      png_chunk_report(png_ptr, "Invalid pCAL equation type",
            PNG_CHUNK_WRITE_ERROR);
      return;
   }

   if (nparams < 0 || nparams > 255)
   {
      png_chunk_report(png_ptr, "Invalid pCAL parameter count",
            PNG_CHUNK_WRITE_ERROR);
      return;
   }

   /* Validate params[nparams] */
   for (i=0; i<nparams; ++i)
   {
      if (params[i] == NULL ||
          !png_check_fp_string(params[i], strlen(params[i])))
      {
         png_chunk_report(png_ptr, "Invalid format for pCAL parameter",
               PNG_CHUNK_WRITE_ERROR);
         return;
      }
   }

   info_ptr->pcal_purpose = png_voidcast(png_charp,
       png_malloc_warn(png_ptr, length));

   if (info_ptr->pcal_purpose == NULL)
   {
      png_chunk_report(png_ptr, "Insufficient memory for pCAL purpose",
            PNG_CHUNK_WRITE_ERROR);
      return;
   }

   memcpy(info_ptr->pcal_purpose, purpose, length);

   png_debug(3, "storing X0, X1, type, and nparams in info");
   info_ptr->pcal_X0 = X0;
   info_ptr->pcal_X1 = X1;
   info_ptr->pcal_type = (png_byte)type;
   info_ptr->pcal_nparams = (png_byte)nparams;

   length = strlen(units) + 1;
   png_debug1(3, "allocating units for info (%lu bytes)",
       (unsigned long)length);

   info_ptr->pcal_units = png_voidcast(png_charp,
       png_malloc_warn(png_ptr, length));

   if (info_ptr->pcal_units == NULL)
   {
      png_warning(png_ptr, "Insufficient memory for pCAL units");

      return;
   }

   memcpy(info_ptr->pcal_units, units, length);

   info_ptr->pcal_params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,
       (png_size_t)(((unsigned int)nparams + 1) * (sizeof (png_charp)))));

   if (info_ptr->pcal_params == NULL)
   {
      png_warning(png_ptr, "Insufficient memory for pCAL params");

      return;
   }

   memset(info_ptr->pcal_params, 0, ((unsigned int)nparams + 1) *
       (sizeof (png_charp)));

   for (i = 0; i < nparams; i++)
   {
      length = strlen(params[i]) + 1;
      png_debug2(3, "allocating parameter %d for info (%lu bytes)", i,
          (unsigned long)length);

      info_ptr->pcal_params[i] = (png_charp)png_malloc_warn(png_ptr, length);

      if (info_ptr->pcal_params[i] == NULL)
      {
         png_warning(png_ptr, "Insufficient memory for pCAL parameter");

         return;
      }

      memcpy(info_ptr->pcal_params[i], params[i], length);
   }

   info_ptr->valid |= PNG_INFO_pCAL;
   info_ptr->free_me |= PNG_FREE_PCAL;
}
#endif

#ifdef PNG_sCAL_SUPPORTED
void PNGAPI
png_set_sCAL_s(png_const_structrp png_ptr, png_inforp info_ptr,
    int unit, png_const_charp swidth, png_const_charp sheight)
{
   png_size_t lengthw = 0, lengthh = 0;

   png_debug1(1, "in %s storage function", "sCAL");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   /* Double check the unit (should never get here with an invalid
    * unit unless this is an API call.)
    */
   if (unit != 1 && unit != 2)
      png_error(png_ptr, "Invalid sCAL unit");

   if (swidth == NULL || (lengthw = strlen(swidth)) == 0 ||
       swidth[0] == 45 /* '-' */ || !png_check_fp_string(swidth, lengthw))
      png_error(png_ptr, "Invalid sCAL width");

   if (sheight == NULL || (lengthh = strlen(sheight)) == 0 ||
       sheight[0] == 45 /* '-' */ || !png_check_fp_string(sheight, lengthh))
      png_error(png_ptr, "Invalid sCAL height");

   info_ptr->scal_unit = (png_byte)unit;

   ++lengthw;

   png_debug1(3, "allocating unit for info (%u bytes)", (unsigned int)lengthw);

   info_ptr->scal_s_width = png_voidcast(png_charp,
       png_malloc_warn(png_ptr, lengthw));

   if (info_ptr->scal_s_width == NULL)
   {
      png_warning(png_ptr, "Memory allocation failed while processing sCAL");

      return;
   }

   memcpy(info_ptr->scal_s_width, swidth, lengthw);

   ++lengthh;

   png_debug1(3, "allocating unit for info (%u bytes)", (unsigned int)lengthh);

   info_ptr->scal_s_height = png_voidcast(png_charp,
       png_malloc_warn(png_ptr, lengthh));

   if (info_ptr->scal_s_height == NULL)
   {
      png_free (png_ptr, info_ptr->scal_s_width);
      info_ptr->scal_s_width = NULL;

      png_warning(png_ptr, "Memory allocation failed while processing sCAL");

      return;
   }

   memcpy(info_ptr->scal_s_height, sheight, lengthh);

   info_ptr->valid |= PNG_INFO_sCAL;
   info_ptr->free_me |= PNG_FREE_SCAL;
}

#  ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_sCAL(png_const_structrp png_ptr, png_inforp info_ptr, int unit,
    double width, double height)
{
   png_debug1(1, "in %s storage function", "sCAL");

   /* Check the arguments. */
   if (width <= 0)
      png_warning(png_ptr, "Invalid sCAL width ignored");

   else if (height <= 0)
      png_warning(png_ptr, "Invalid sCAL height ignored");

   else
   {
      /* Convert 'width' and 'height' to ASCII. */
      char swidth[PNG_sCAL_MAX_DIGITS+1];
      char sheight[PNG_sCAL_MAX_DIGITS+1];

      png_ascii_from_fp(png_ptr, swidth, (sizeof swidth), width,
          PNG_sCAL_PRECISION);
      png_ascii_from_fp(png_ptr, sheight, (sizeof sheight), height,
          PNG_sCAL_PRECISION);

      png_set_sCAL_s(png_ptr, info_ptr, unit, swidth, sheight);
   }
}
#  endif

#  ifdef PNG_FIXED_POINT_SUPPORTED
void PNGAPI
png_set_sCAL_fixed(png_const_structrp png_ptr, png_inforp info_ptr, int unit,
    png_fixed_point width, png_fixed_point height)
{
   png_debug1(1, "in %s storage function", "sCAL");

   /* Check the arguments. */
   if (width <= 0)
      png_warning(png_ptr, "Invalid sCAL width ignored");

   else if (height <= 0)
      png_warning(png_ptr, "Invalid sCAL height ignored");

   else
   {
      /* Convert 'width' and 'height' to ASCII. */
      char swidth[PNG_sCAL_MAX_DIGITS+1];
      char sheight[PNG_sCAL_MAX_DIGITS+1];

      png_ascii_from_fixed(png_ptr, swidth, (sizeof swidth), width);
      png_ascii_from_fixed(png_ptr, sheight, (sizeof sheight), height);

      png_set_sCAL_s(png_ptr, info_ptr, unit, swidth, sheight);
   }
}
#  endif
#endif

#ifdef PNG_pHYs_SUPPORTED
void PNGAPI
png_set_pHYs(png_const_structrp png_ptr, png_inforp info_ptr,
    png_uint_32 res_x, png_uint_32 res_y, int unit_type)
{
   png_debug1(1, "in %s storage function", "pHYs");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->x_pixels_per_unit = res_x;
   info_ptr->y_pixels_per_unit = res_y;
   info_ptr->phys_unit_type = (png_byte)unit_type;
   info_ptr->valid |= PNG_INFO_pHYs;
}
#endif

void PNGAPI
png_set_PLTE(png_structrp png_ptr, png_inforp info_ptr,
    png_const_colorp palette, int num_palette)
{

   png_uint_32 max_palette_length;

   png_debug1(1, "in %s storage function", "PLTE");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   max_palette_length = (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
      (1 << info_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;

   if (num_palette < 0 || num_palette > (int) max_palette_length)
   {
      if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         png_error(png_ptr, "Invalid palette length");

      else
      {
         png_warning(png_ptr, "Invalid palette length");

         return;
      }
   }

   if ((num_palette > 0 && palette == NULL) ||
      (num_palette == 0
#        ifdef PNG_MNG_FEATURES_SUPPORTED
            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0
#        endif
      ))
   {
      png_error(png_ptr, "Invalid palette");
   }

   /* It may not actually be necessary to set png_ptr->palette here;
    * we do it for backward compatibility with the way the png_handle_tRNS
    * function used to do the allocation.
    *
    * 1.6.0: the above statement appears to be incorrect; something has to set
    * the palette inside png_struct on read.
    */
   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);

   /* Changed in libpng-1.2.1 to allocate PNG_MAX_PALETTE_LENGTH instead
    * of num_palette entries, in case of an invalid PNG file or incorrect
    * call to png_set_PLTE() with too-large sample values.
    */
   png_ptr->palette = png_voidcast(png_colorp, png_calloc(png_ptr,
       PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));

   if (num_palette > 0)
      memcpy(png_ptr->palette, palette, (unsigned int)num_palette *
          (sizeof (png_color)));
   info_ptr->palette = png_ptr->palette;
   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;

   info_ptr->free_me |= PNG_FREE_PLTE;

   info_ptr->valid |= PNG_INFO_PLTE;
}

#ifdef PNG_sBIT_SUPPORTED
void PNGAPI
png_set_sBIT(png_const_structrp png_ptr, png_inforp info_ptr,
    png_const_color_8p sig_bit)
{
   png_debug1(1, "in %s storage function", "sBIT");

   if (png_ptr == NULL || info_ptr == NULL || sig_bit == NULL)
      return;

   info_ptr->sig_bit = *sig_bit;
   info_ptr->valid |= PNG_INFO_sBIT;
}
#endif

#ifdef PNG_sRGB_SUPPORTED
void PNGAPI
png_set_sRGB(png_const_structrp png_ptr, png_inforp info_ptr, int srgb_intent)
{
   png_debug1(1, "in %s storage function", "sRGB");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   (void)png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace, srgb_intent);
   png_colorspace_sync_info(png_ptr, info_ptr);
}

void PNGAPI
png_set_sRGB_gAMA_and_cHRM(png_const_structrp png_ptr, png_inforp info_ptr,
    int srgb_intent)
{
   png_debug1(1, "in %s storage function", "sRGB_gAMA_and_cHRM");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace,
       srgb_intent) != 0)
   {
      /* This causes the gAMA and cHRM to be written too */
      info_ptr->colorspace.flags |=
         PNG_COLORSPACE_FROM_gAMA|PNG_COLORSPACE_FROM_cHRM;
   }

   png_colorspace_sync_info(png_ptr, info_ptr);
}
#endif /* sRGB */


#ifdef PNG_iCCP_SUPPORTED
void PNGAPI
png_set_iCCP(png_const_structrp png_ptr, png_inforp info_ptr,
    png_const_charp name, int compression_type,
    png_const_bytep profile, png_uint_32 proflen)
{
   png_charp new_iccp_name;
   png_bytep new_iccp_profile;
   png_size_t length;

   png_debug1(1, "in %s storage function", "iCCP");

   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)
      return;

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
      png_app_error(png_ptr, "Invalid iCCP compression method");

   /* Set the colorspace first because this validates the profile; do not
    * override previously set app cHRM or gAMA here (because likely as not the
    * application knows better than libpng what the correct values are.)  Pass
    * the info_ptr color_type field to png_colorspace_set_ICC because in the
    * write case it has not yet been stored in png_ptr.
    */
   {
      int result = png_colorspace_set_ICC(png_ptr, &info_ptr->colorspace, name,
          proflen, profile, info_ptr->color_type);

      png_colorspace_sync_info(png_ptr, info_ptr);

      /* Don't do any of the copying if the profile was bad, or inconsistent. */
      if (result == 0)
         return;

      /* But do write the gAMA and cHRM chunks from the profile. */
      info_ptr->colorspace.flags |=
         PNG_COLORSPACE_FROM_gAMA|PNG_COLORSPACE_FROM_cHRM;
   }

   length = strlen(name)+1;
   new_iccp_name = png_voidcast(png_charp, png_malloc_warn(png_ptr, length));

   if (new_iccp_name == NULL)
   {
      png_benign_error(png_ptr, "Insufficient memory to process iCCP chunk");

      return;
   }

   memcpy(new_iccp_name, name, length);
   new_iccp_profile = png_voidcast(png_bytep,
       png_malloc_warn(png_ptr, proflen));

   if (new_iccp_profile == NULL)
   {
      png_free(png_ptr, new_iccp_name);
      png_benign_error(png_ptr,
          "Insufficient memory to process iCCP profile");

      return;
   }

   memcpy(new_iccp_profile, profile, proflen);

   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);

   info_ptr->iccp_proflen = proflen;
   info_ptr->iccp_name = new_iccp_name;
   info_ptr->iccp_profile = new_iccp_profile;
   info_ptr->free_me |= PNG_FREE_ICCP;
   info_ptr->valid |= PNG_INFO_iCCP;
}
#endif

#ifdef PNG_TEXT_SUPPORTED
void PNGAPI
png_set_text(png_const_structrp png_ptr, png_inforp info_ptr,
    png_const_textp text_ptr, int num_text)
{
   int ret;
   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);

   if (ret != 0)
      png_error(png_ptr, "Insufficient memory to store text");
}

int /* PRIVATE */
png_set_text_2(png_const_structrp png_ptr, png_inforp info_ptr,
    png_const_textp text_ptr, int num_text)
{
   int i;

   png_debug1(1, "in %lx storage function", png_ptr == NULL ? 0xabadca11U :
      (unsigned long)png_ptr->chunk_name);

   if (png_ptr == NULL || info_ptr == NULL || num_text <= 0 || text_ptr == NULL)
      return(0);

   /* Make sure we have enough space in the "text" array in info_struct
    * to hold all of the incoming text_ptr objects.  This compare can't overflow
    * because max_text >= num_text (anyway, subtract of two positive integers
    * can't overflow in any case.)
    */
   if (num_text > info_ptr->max_text - info_ptr->num_text)
   {
      int old_num_text = info_ptr->num_text;
      int max_text;
      png_textp new_text = NULL;

      /* Calculate an appropriate max_text, checking for overflow. */
      max_text = old_num_text;
      if (num_text <= INT_MAX - max_text)
      {
         max_text += num_text;

         /* Round up to a multiple of 8 */
         if (max_text < INT_MAX-8)
            max_text = (max_text + 8) & ~0x7;

         else
            max_text = INT_MAX;

         /* Now allocate a new array and copy the old members in; this does all
          * the overflow checks.
          */
         new_text = png_voidcast(png_textp,png_realloc_array(png_ptr,
             info_ptr->text, old_num_text, max_text-old_num_text,
             sizeof *new_text));
      }

      if (new_text == NULL)
      {
         png_chunk_report(png_ptr, "too many text chunks",
             PNG_CHUNK_WRITE_ERROR);

         return 1;
      }

      png_free(png_ptr, info_ptr->text);

      info_ptr->text = new_text;
      info_ptr->free_me |= PNG_FREE_TEXT;
      info_ptr->max_text = max_text;
      /* num_text is adjusted below as the entries are copied in */

      png_debug1(3, "allocated %d entries for info_ptr->text", max_text);
   }

   for (i = 0; i < num_text; i++)
   {
      size_t text_length, key_len;
      size_t lang_len, lang_key_len;
      png_textp textp = &(info_ptr->text[info_ptr->num_text]);

      if (text_ptr[i].key == NULL)
          continue;

      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||
          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)
      {
         png_chunk_report(png_ptr, "text compression mode is out of range",
             PNG_CHUNK_WRITE_ERROR);
         continue;
      }

      key_len = strlen(text_ptr[i].key);

      if (text_ptr[i].compression <= 0)
      {
         lang_len = 0;
         lang_key_len = 0;
      }

      else
#  ifdef PNG_iTXt_SUPPORTED
      {
         /* Set iTXt data */

         if (text_ptr[i].lang != NULL)
            lang_len = strlen(text_ptr[i].lang);

         else
            lang_len = 0;

         if (text_ptr[i].lang_key != NULL)
            lang_key_len = strlen(text_ptr[i].lang_key);

         else
            lang_key_len = 0;
      }
#  else /* iTXt */
      {
         png_chunk_report(png_ptr, "iTXt chunk not supported",
             PNG_CHUNK_WRITE_ERROR);
         continue;
      }
#  endif

      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0')
      {
         text_length = 0;
#  ifdef PNG_iTXt_SUPPORTED
         if (text_ptr[i].compression > 0)
            textp->compression = PNG_ITXT_COMPRESSION_NONE;

         else
#  endif
            textp->compression = PNG_TEXT_COMPRESSION_NONE;
      }

      else
      {
         text_length = strlen(text_ptr[i].text);
         textp->compression = text_ptr[i].compression;
      }

      textp->key = png_voidcast(png_charp,png_malloc_base(png_ptr,
          key_len + text_length + lang_len + lang_key_len + 4));

      if (textp->key == NULL)
      {
         png_chunk_report(png_ptr, "text chunk: out of memory",
             PNG_CHUNK_WRITE_ERROR);

         return 1;
      }

      png_debug2(2, "Allocated %lu bytes at %p in png_set_text",
          (unsigned long)(png_uint_32)
          (key_len + lang_len + lang_key_len + text_length + 4),
          textp->key);

      memcpy(textp->key, text_ptr[i].key, key_len);
      *(textp->key + key_len) = '\0';

      if (text_ptr[i].compression > 0)
      {
         textp->lang = textp->key + key_len + 1;
         memcpy(textp->lang, text_ptr[i].lang, lang_len);
         *(textp->lang + lang_len) = '\0';
         textp->lang_key = textp->lang + lang_len + 1;
         memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);
         *(textp->lang_key + lang_key_len) = '\0';
         textp->text = textp->lang_key + lang_key_len + 1;
      }

      else
      {
         textp->lang=NULL;
         textp->lang_key=NULL;
         textp->text = textp->key + key_len + 1;
      }

      if (text_length != 0)
         memcpy(textp->text, text_ptr[i].text, text_length);

      *(textp->text + text_length) = '\0';

#  ifdef PNG_iTXt_SUPPORTED
      if (textp->compression > 0)
      {
         textp->text_length = 0;
         textp->itxt_length = text_length;
      }

      else
#  endif
      {
         textp->text_length = text_length;
         textp->itxt_length = 0;
      }

      info_ptr->num_text++;
      png_debug1(3, "transferred text chunk %d", info_ptr->num_text);
   }

   return(0);
}
#endif

#ifdef PNG_tIME_SUPPORTED
void PNGAPI
png_set_tIME(png_const_structrp png_ptr, png_inforp info_ptr,
    png_const_timep mod_time)
{
   png_debug1(1, "in %s storage function", "tIME");

   if (png_ptr == NULL || info_ptr == NULL || mod_time == NULL ||
       (png_ptr->mode & PNG_WROTE_tIME) != 0)
      return;

   if (mod_time->month == 0   || mod_time->month > 12  ||
       mod_time->day   == 0   || mod_time->day   > 31  ||
       mod_time->hour  > 23   || mod_time->minute > 59 ||
       mod_time->second > 60)
   {
      png_warning(png_ptr, "Ignoring invalid time value");

      return;
   }

   info_ptr->mod_time = *mod_time;
   info_ptr->valid |= PNG_INFO_tIME;
}
#endif

#ifdef PNG_tRNS_SUPPORTED
void PNGAPI
png_set_tRNS(png_structrp png_ptr, png_inforp info_ptr,
    png_const_bytep trans_alpha, int num_trans, png_const_color_16p trans_color)
{
   png_debug1(1, "in %s storage function", "tRNS");

   if (png_ptr == NULL || info_ptr == NULL)

      return;

   if (trans_alpha != NULL)
   {
       /* It may not actually be necessary to set png_ptr->trans_alpha here;
        * we do it for backward compatibility with the way the png_handle_tRNS
        * function used to do the allocation.
        *
        * 1.6.0: The above statement is incorrect; png_handle_tRNS effectively
        * relies on png_set_tRNS storing the information in png_struct
        * (otherwise it won't be there for the code in pngrtran.c).
        */

       png_free_data(png_ptr, info_ptr, PNG_FREE_TRNS, 0);

       if (num_trans > 0 && num_trans <= PNG_MAX_PALETTE_LENGTH)
       {
         /* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
          info_ptr->trans_alpha = png_voidcast(png_bytep,
              png_malloc(png_ptr, PNG_MAX_PALETTE_LENGTH));
          memcpy(info_ptr->trans_alpha, trans_alpha, (png_size_t)num_trans);
       }
       png_ptr->trans_alpha = info_ptr->trans_alpha;
   }

   if (trans_color != NULL)
   {
#ifdef PNG_WARNINGS_SUPPORTED
      if (info_ptr->bit_depth < 16)
      {
         int sample_max = (1 << info_ptr->bit_depth) - 1;

         if ((info_ptr->color_type == PNG_COLOR_TYPE_GRAY &&
             trans_color->gray > sample_max) ||
             (info_ptr->color_type == PNG_COLOR_TYPE_RGB &&
             (trans_color->red > sample_max ||
             trans_color->green > sample_max ||
             trans_color->blue > sample_max)))
            png_warning(png_ptr,
                "tRNS chunk has out-of-range samples for bit_depth");
      }
#endif

      info_ptr->trans_color = *trans_color;

      if (num_trans == 0)
         num_trans = 1;
   }

   info_ptr->num_trans = (png_uint_16)num_trans;

   if (num_trans != 0)
   {
      info_ptr->valid |= PNG_INFO_tRNS;
      info_ptr->free_me |= PNG_FREE_TRNS;
   }
}
#endif

#ifdef PNG_sPLT_SUPPORTED
void PNGAPI
png_set_sPLT(png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_sPLT_tp entries, int nentries)
/*
 *  entries        - array of png_sPLT_t structures
 *                   to be added to the list of palettes
 *                   in the info structure.
 *
 *  nentries       - number of palette structures to be
 *                   added.
 */
{
   png_sPLT_tp np;

   if (png_ptr == NULL || info_ptr == NULL || nentries <= 0 || entries == NULL)
      return;

   /* Use the internal realloc function, which checks for all the possible
    * overflows.  Notice that the parameters are (int) and (size_t)
    */
   np = png_voidcast(png_sPLT_tp,png_realloc_array(png_ptr,
       info_ptr->splt_palettes, info_ptr->splt_palettes_num, nentries,
       sizeof *np));

   if (np == NULL)
   {
      /* Out of memory or too many chunks */
      png_chunk_report(png_ptr, "too many sPLT chunks", PNG_CHUNK_WRITE_ERROR);

      return;
   }

   png_free(png_ptr, info_ptr->splt_palettes);
   info_ptr->splt_palettes = np;
   info_ptr->free_me |= PNG_FREE_SPLT;

   np += info_ptr->splt_palettes_num;

   do
   {
      png_size_t length;

      /* Skip invalid input entries */
      if (entries->name == NULL || entries->entries == NULL)
      {
         /* png_handle_sPLT doesn't do this, so this is an app error */
         png_app_error(png_ptr, "png_set_sPLT: invalid sPLT");
         /* Just skip the invalid entry */
         continue;
      }

      np->depth = entries->depth;

      /* In the event of out-of-memory just return - there's no point keeping
       * on trying to add sPLT chunks.
       */
      length = strlen(entries->name) + 1;
      np->name = png_voidcast(png_charp, png_malloc_base(png_ptr, length));

      if (np->name == NULL)
         break;

      memcpy(np->name, entries->name, length);

      /* IMPORTANT: we have memory now that won't get freed if something else
       * goes wrong; this code must free it.  png_malloc_array produces no
       * warnings; use a png_chunk_report (below) if there is an error.
       */
      np->entries = png_voidcast(png_sPLT_entryp, png_malloc_array(png_ptr,
          entries->nentries, sizeof (png_sPLT_entry)));

      if (np->entries == NULL)
      {
         png_free(png_ptr, np->name);
         np->name = NULL;
         break;
      }

      np->nentries = entries->nentries;
      /* This multiply can't overflow because png_malloc_array has already
       * checked it when doing the allocation.
       */
      memcpy(np->entries, entries->entries,
          (unsigned int)entries->nentries * sizeof (png_sPLT_entry));

      /* Note that 'continue' skips the advance of the out pointer and out
       * count, so an invalid entry is not added.
       */
      info_ptr->valid |= PNG_INFO_sPLT;
      ++(info_ptr->splt_palettes_num);
      ++np;
   }
   while (++entries, --nentries);

   if (nentries > 0)
      png_chunk_report(png_ptr, "sPLT out of memory", PNG_CHUNK_WRITE_ERROR);
}
#endif /* sPLT */

#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
static png_byte
check_location(png_const_structrp png_ptr, int location)
{
   location &= (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT);

   /* New in 1.6.0; copy the location and check it.  This is an API
    * change; previously the app had to use the
    * png_set_unknown_chunk_location API below for each chunk.
    */
   if (location == 0 && (png_ptr->mode & PNG_IS_READ_STRUCT) == 0)
   {
      /* Write struct, so unknown chunks come from the app */
      png_app_warning(png_ptr,
          "png_set_unknown_chunks now expects a valid location");
      /* Use the old behavior */
      location = (png_byte)(png_ptr->mode &
          (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT));
   }

   /* This need not be an internal error - if the app calls
    * png_set_unknown_chunks on a read pointer it must get the location right.
    */
   if (location == 0)
      png_error(png_ptr, "invalid location in png_set_unknown_chunks");

   /* Now reduce the location to the top-most set bit by removing each least
    * significant bit in turn.
    */
   while (location != (location & -location))
      location &= ~(location & -location);

   /* The cast is safe because 'location' is a bit mask and only the low four
    * bits are significant.
    */
   return (png_byte)location;
}

void PNGAPI
png_set_unknown_chunks(png_const_structrp png_ptr,
    png_inforp info_ptr, png_const_unknown_chunkp unknowns, int num_unknowns)
{
   png_unknown_chunkp np;

   if (png_ptr == NULL || info_ptr == NULL || num_unknowns <= 0 ||
       unknowns == NULL)
      return;

   /* Check for the failure cases where support has been disabled at compile
    * time.  This code is hardly ever compiled - it's here because
    * STORE_UNKNOWN_CHUNKS is set by both read and write code (compiling in this
    * code) but may be meaningless if the read or write handling of unknown
    * chunks is not compiled in.
    */
#  if !defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED) && \
      defined(PNG_READ_SUPPORTED)
      if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)
      {
         png_app_error(png_ptr, "no unknown chunk support on read");

         return;
      }
#  endif
#  if !defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED) && \
      defined(PNG_WRITE_SUPPORTED)
      if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)
      {
         png_app_error(png_ptr, "no unknown chunk support on write");

         return;
      }
#  endif

   /* Prior to 1.6.0 this code used png_malloc_warn; however, this meant that
    * unknown critical chunks could be lost with just a warning resulting in
    * undefined behavior.  Now png_chunk_report is used to provide behavior
    * appropriate to read or write.
    */
   np = png_voidcast(png_unknown_chunkp, png_realloc_array(png_ptr,
       info_ptr->unknown_chunks, info_ptr->unknown_chunks_num, num_unknowns,
       sizeof *np));

   if (np == NULL)
   {
      png_chunk_report(png_ptr, "too many unknown chunks",
          PNG_CHUNK_WRITE_ERROR);

      return;
   }

   png_free(png_ptr, info_ptr->unknown_chunks);
   info_ptr->unknown_chunks = np; /* safe because it is initialized */
   info_ptr->free_me |= PNG_FREE_UNKN;

   np += info_ptr->unknown_chunks_num;

   /* Increment unknown_chunks_num each time round the loop to protect the
    * just-allocated chunk data.
    */
   for (; num_unknowns > 0; --num_unknowns, ++unknowns)
   {
      memcpy(np->name, unknowns->name, (sizeof np->name));
      np->name[(sizeof np->name)-1] = '\0';
      np->location = check_location(png_ptr, unknowns->location);

      if (unknowns->size == 0)
      {
         np->data = NULL;
         np->size = 0;
      }

      else
      {
         np->data = png_voidcast(png_bytep,
             png_malloc_base(png_ptr, unknowns->size));

         if (np->data == NULL)
         {
            png_chunk_report(png_ptr, "unknown chunk: out of memory",
                PNG_CHUNK_WRITE_ERROR);
            /* But just skip storing the unknown chunk */
            continue;
         }

         memcpy(np->data, unknowns->data, unknowns->size);
         np->size = unknowns->size;
      }

      /* These increments are skipped on out-of-memory for the data - the
       * unknown chunk entry gets overwritten if the png_chunk_report returns.
       * This is correct in the read case (the chunk is just dropped.)
       */
      ++np;
      ++(info_ptr->unknown_chunks_num);
   }
}

void PNGAPI
png_set_unknown_chunk_location(png_const_structrp png_ptr, png_inforp info_ptr,
    int chunk, int location)
{
   /* This API is pretty pointless in 1.6.0 because the location can be set
    * before the call to png_set_unknown_chunks.
    *
    * TODO: add a png_app_warning in 1.7
    */
   if (png_ptr != NULL && info_ptr != NULL && chunk >= 0 &&
      chunk < info_ptr->unknown_chunks_num)
   {
      if ((location & (PNG_HAVE_IHDR|PNG_HAVE_PLTE|PNG_AFTER_IDAT)) == 0)
      {
         png_app_error(png_ptr, "invalid unknown chunk location");
         /* Fake out the pre 1.6.0 behavior: */
         if (((unsigned int)location & PNG_HAVE_IDAT) != 0) /* undocumented! */
            location = PNG_AFTER_IDAT;

         else
            location = PNG_HAVE_IHDR; /* also undocumented */
      }

      info_ptr->unknown_chunks[chunk].location =
         check_location(png_ptr, location);
   }
}
#endif /* STORE_UNKNOWN_CHUNKS */

#ifdef PNG_MNG_FEATURES_SUPPORTED
png_uint_32 PNGAPI
png_permit_mng_features (png_structrp png_ptr, png_uint_32 mng_features)
{
   png_debug(1, "in png_permit_mng_features");

   if (png_ptr == NULL)
      return 0;

   png_ptr->mng_features_permitted = mng_features & PNG_ALL_MNG_FEATURES;

   return png_ptr->mng_features_permitted;
}
#endif

#ifdef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
static unsigned int
add_one_chunk(png_bytep list, unsigned int count, png_const_bytep add, int keep)
{
   unsigned int i;

   /* Utility function: update the 'keep' state of a chunk if it is already in
    * the list, otherwise add it to the list.
    */
   for (i=0; i<count; ++i, list += 5)
   {
      if (memcmp(list, add, 4) == 0)
      {
         list[4] = (png_byte)keep;

         return count;
      }
   }

   if (keep != PNG_HANDLE_CHUNK_AS_DEFAULT)
   {
      ++count;
      memcpy(list, add, 4);
      list[4] = (png_byte)keep;
   }

   return count;
}

void PNGAPI
png_set_keep_unknown_chunks(png_structrp png_ptr, int keep,
    png_const_bytep chunk_list, int num_chunks_in)
{
   png_bytep new_list;
   unsigned int num_chunks, old_num_chunks;

   if (png_ptr == NULL)
      return;

   if (keep < 0 || keep >= PNG_HANDLE_CHUNK_LAST)
   {
      png_app_error(png_ptr, "png_set_keep_unknown_chunks: invalid keep");

      return;
   }

   if (num_chunks_in <= 0)
   {
      png_ptr->unknown_default = keep;

      /* '0' means just set the flags, so stop here */
      if (num_chunks_in == 0)
        return;
   }

   if (num_chunks_in < 0)
   {
      /* Ignore all unknown chunks and all chunks recognized by
       * libpng except for IHDR, PLTE, tRNS, IDAT, and IEND
       */
      static PNG_CONST png_byte chunks_to_ignore[] = {
         98,  75,  71,  68, '\0',  /* bKGD */
         99,  72,  82,  77, '\0',  /* cHRM */
        103,  65,  77,  65, '\0',  /* gAMA */
        104,  73,  83,  84, '\0',  /* hIST */
        105,  67,  67,  80, '\0',  /* iCCP */
        105,  84,  88, 116, '\0',  /* iTXt */
        111,  70,  70, 115, '\0',  /* oFFs */
        112,  67,  65,  76, '\0',  /* pCAL */
        112,  72,  89, 115, '\0',  /* pHYs */
        115,  66,  73,  84, '\0',  /* sBIT */
        115,  67,  65,  76, '\0',  /* sCAL */
        115,  80,  76,  84, '\0',  /* sPLT */
        115,  84,  69,  82, '\0',  /* sTER */
        115,  82,  71,  66, '\0',  /* sRGB */
        116,  69,  88, 116, '\0',  /* tEXt */
        116,  73,  77,  69, '\0',  /* tIME */
        122,  84,  88, 116, '\0'   /* zTXt */
      };

      chunk_list = chunks_to_ignore;
      num_chunks = (unsigned int)/*SAFE*/(sizeof chunks_to_ignore)/5U;
   }

   else /* num_chunks_in > 0 */
   {
      if (chunk_list == NULL)
      {
         /* Prior to 1.6.0 this was silently ignored, now it is an app_error
          * which can be switched off.
          */
         png_app_error(png_ptr, "png_set_keep_unknown_chunks: no chunk list");

         return;
      }

      num_chunks = (unsigned int)num_chunks_in;
   }

   old_num_chunks = png_ptr->num_chunk_list;
   if (png_ptr->chunk_list == NULL)
      old_num_chunks = 0;

   /* Since num_chunks is always restricted to UINT_MAX/5 this can't overflow.
    */
   if (num_chunks + old_num_chunks > UINT_MAX/5)
   {
      png_app_error(png_ptr, "png_set_keep_unknown_chunks: too many chunks");

      return;
   }

   /* If these chunks are being reset to the default then no more memory is
    * required because add_one_chunk above doesn't extend the list if the 'keep'
    * parameter is the default.
    */
   if (keep != 0)
   {
      new_list = png_voidcast(png_bytep, png_malloc(png_ptr,
          5 * (num_chunks + old_num_chunks)));

      if (old_num_chunks > 0)
         memcpy(new_list, png_ptr->chunk_list, 5*old_num_chunks);
   }

   else if (old_num_chunks > 0)
      new_list = png_ptr->chunk_list;

   else
      new_list = NULL;

   /* Add the new chunks together with each one's handling code.  If the chunk
    * already exists the code is updated, otherwise the chunk is added to the
    * end.  (In libpng 1.6.0 order no longer matters because this code enforces
    * the earlier convention that the last setting is the one that is used.)
    */
   if (new_list != NULL)
   {
      png_const_bytep inlist;
      png_bytep outlist;
      unsigned int i;

      for (i=0; i<num_chunks; ++i)
      {
         old_num_chunks = add_one_chunk(new_list, old_num_chunks,
             chunk_list+5*i, keep);
      }

      /* Now remove any spurious 'default' entries. */
      num_chunks = 0;
      for (i=0, inlist=outlist=new_list; i<old_num_chunks; ++i, inlist += 5)
      {
         if (inlist[4])
         {
            if (outlist != inlist)
               memcpy(outlist, inlist, 5);
            outlist += 5;
            ++num_chunks;
         }
      }

      /* This means the application has removed all the specialized handling. */
      if (num_chunks == 0)
      {
         if (png_ptr->chunk_list != new_list)
            png_free(png_ptr, new_list);

         new_list = NULL;
      }
   }

   else
      num_chunks = 0;

   png_ptr->num_chunk_list = num_chunks;

   if (png_ptr->chunk_list != new_list)
   {
      if (png_ptr->chunk_list != NULL)
         png_free(png_ptr, png_ptr->chunk_list);

      png_ptr->chunk_list = new_list;
   }
}
#endif

#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
void PNGAPI
png_set_read_user_chunk_fn(png_structrp png_ptr, png_voidp user_chunk_ptr,
    png_user_chunk_ptr read_user_chunk_fn)
{
   png_debug(1, "in png_set_read_user_chunk_fn");

   if (png_ptr == NULL)
      return;

   png_ptr->read_user_chunk_fn = read_user_chunk_fn;
   png_ptr->user_chunk_ptr = user_chunk_ptr;
}
#endif

#ifdef PNG_INFO_IMAGE_SUPPORTED
void PNGAPI
png_set_rows(png_const_structrp png_ptr, png_inforp info_ptr,
    png_bytepp row_pointers)
{
   png_debug1(1, "in %s storage function", "rows");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (info_ptr->row_pointers != NULL &&
       (info_ptr->row_pointers != row_pointers))
      png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);

   info_ptr->row_pointers = row_pointers;

   if (row_pointers != NULL)
      info_ptr->valid |= PNG_INFO_IDAT;
}
#endif

void PNGAPI
png_set_compression_buffer_size(png_structrp png_ptr, png_size_t size)
{
   if (png_ptr == NULL)
      return;

   if (size == 0 || size > PNG_UINT_31_MAX)
      png_error(png_ptr, "invalid compression buffer size");

#  ifdef PNG_SEQUENTIAL_READ_SUPPORTED
   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)
   {
      png_ptr->IDAT_read_size = (png_uint_32)size; /* checked above */
      return;
   }
#  endif

#  ifdef PNG_WRITE_SUPPORTED
   if ((png_ptr->mode & PNG_IS_READ_STRUCT) == 0)
   {
      if (png_ptr->zowner != 0)
      {
         png_warning(png_ptr,
             "Compression buffer size cannot be changed because it is in use");

         return;
      }

#ifndef __COVERITY__
      /* Some compilers complain that this is always false.  However, it
       * can be true when integer overflow happens.
       */
      if (size > ZLIB_IO_MAX)
      {
         png_warning(png_ptr,
             "Compression buffer size limited to system maximum");
         size = ZLIB_IO_MAX; /* must fit */
      }
#endif

      if (size < 6)
      {
         /* Deflate will potentially go into an infinite loop on a SYNC_FLUSH
          * if this is permitted.
          */
         png_warning(png_ptr,
             "Compression buffer size cannot be reduced below 6");

         return;
      }

      if (png_ptr->zbuffer_size != size)
      {
         png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);
         png_ptr->zbuffer_size = (uInt)size;
      }
   }
#  endif
}

void PNGAPI
png_set_invalid(png_const_structrp png_ptr, png_inforp info_ptr, int mask)
{
   if (png_ptr != NULL && info_ptr != NULL)
      info_ptr->valid &= (unsigned int)(~mask);
}


#ifdef PNG_SET_USER_LIMITS_SUPPORTED
/* This function was added to libpng 1.2.6 */
void PNGAPI
png_set_user_limits (png_structrp png_ptr, png_uint_32 user_width_max,
    png_uint_32 user_height_max)
{
   /* Images with dimensions larger than these limits will be
    * rejected by png_set_IHDR().  To accept any PNG datastream
    * regardless of dimensions, set both limits to 0x7fffffff.
    */
   if (png_ptr == NULL)
      return;

   png_ptr->user_width_max = user_width_max;
   png_ptr->user_height_max = user_height_max;
}

/* This function was added to libpng 1.4.0 */
void PNGAPI
png_set_chunk_cache_max (png_structrp png_ptr, png_uint_32 user_chunk_cache_max)
{
   if (png_ptr != NULL)
      png_ptr->user_chunk_cache_max = user_chunk_cache_max;
}

/* This function was added to libpng 1.4.1 */
void PNGAPI
png_set_chunk_malloc_max (png_structrp png_ptr,
    png_alloc_size_t user_chunk_malloc_max)
{
   if (png_ptr != NULL)
      png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;
}
#endif /* ?SET_USER_LIMITS */


#ifdef PNG_BENIGN_ERRORS_SUPPORTED
void PNGAPI
png_set_benign_errors(png_structrp png_ptr, int allowed)
{
   png_debug(1, "in png_set_benign_errors");

   /* If allowed is 1, png_benign_error() is treated as a warning.
    *
    * If allowed is 0, png_benign_error() is treated as an error (which
    * is the default behavior if png_set_benign_errors() is not called).
    */

   if (allowed != 0)
      png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN |
         PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN;

   else
      png_ptr->flags &= ~(PNG_FLAG_BENIGN_ERRORS_WARN |
         PNG_FLAG_APP_WARNINGS_WARN | PNG_FLAG_APP_ERRORS_WARN);
}
#endif /* BENIGN_ERRORS */

#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
   /* Whether to report invalid palette index; added at libng-1.5.10.
    * It is possible for an indexed (color-type==3) PNG file to contain
    * pixels with invalid (out-of-range) indexes if the PLTE chunk has
    * fewer entries than the image's bit-depth would allow. We recover
    * from this gracefully by filling any incomplete palette with zeros
    * (opaque black).  By default, when this occurs libpng will issue
    * a benign error.  This API can be used to override that behavior.
    */
void PNGAPI
png_set_check_for_invalid_index(png_structrp png_ptr, int allowed)
{
   png_debug(1, "in png_set_check_for_invalid_index");

   if (allowed > 0)
      png_ptr->num_palette_max = 0;

   else
      png_ptr->num_palette_max = -1;
}
#endif

#if defined(PNG_TEXT_SUPPORTED) || defined(PNG_pCAL_SUPPORTED) || \
    defined(PNG_iCCP_SUPPORTED) || defined(PNG_sPLT_SUPPORTED)
/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
 * and if invalid, correct the keyword rather than discarding the entire
 * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in
 * length, forbids leading or trailing whitespace, multiple internal spaces,
 * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.
 *
 * The 'new_key' buffer must be 80 characters in size (for the keyword plus a
 * trailing '\0').  If this routine returns 0 then there was no keyword, or a
 * valid one could not be generated, and the caller must png_error.
 */
png_uint_32 /* PRIVATE */
png_check_keyword(png_structrp png_ptr, png_const_charp key, png_bytep new_key)
{
#ifdef PNG_WARNINGS_SUPPORTED
   png_const_charp orig_key = key;
#endif
   png_uint_32 key_len = 0;
   int bad_character = 0;
   int space = 1;

   png_debug(1, "in png_check_keyword");

   if (key == NULL)
   {
      *new_key = 0;
      return 0;
   }

   while (*key && key_len < 79)
   {
      png_byte ch = (png_byte)*key++;

      if ((ch > 32 && ch <= 126) || (ch >= 161 /*&& ch <= 255*/))
         *new_key++ = ch, ++key_len, space = 0;

      else if (space == 0)
      {
         /* A space or an invalid character when one wasn't seen immediately
          * before; output just a space.
          */
         *new_key++ = 32, ++key_len, space = 1;

         /* If the character was not a space then it is invalid. */
         if (ch != 32)
            bad_character = ch;
      }

      else if (bad_character == 0)
         bad_character = ch; /* just skip it, record the first error */
   }

   if (key_len > 0 && space != 0) /* trailing space */
   {
      --key_len, --new_key;
      if (bad_character == 0)
         bad_character = 32;
   }

   /* Terminate the keyword */
   *new_key = 0;

   if (key_len == 0)
      return 0;

#ifdef PNG_WARNINGS_SUPPORTED
   /* Try to only output one warning per keyword: */
   if (*key != 0) /* keyword too long */
      png_warning(png_ptr, "keyword truncated");

   else if (bad_character != 0)
   {
      PNG_WARNING_PARAMETERS(p)

      png_warning_parameter(p, 1, orig_key);
      png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_character);

      png_formatted_warning(png_ptr, p, "keyword \"@1\": bad character '0x@2'");
   }
#else /* !WARNINGS */
   PNG_UNUSED(png_ptr)
#endif /* !WARNINGS */

   return key_len;
}
#endif /* TEXT || pCAL || iCCP || sPLT */
#endif /* READ || WRITE */

```

`ThirdPartyBuild/PNG/Code/pngstruct.h`:

```h

/* pngstruct.h - header file for PNG reference library
 *
 * Last changed in libpng 1.6.28 [January 5, 2017]
 * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

/* The structure that holds the information to read and write PNG files.
 * The only people who need to care about what is inside of this are the
 * people who will be modifying the library for their own special needs.
 * It should NOT be accessed directly by an application.
 */

#ifndef PNGSTRUCT_H
#define PNGSTRUCT_H
/* zlib.h defines the structure z_stream, an instance of which is included
 * in this structure and is required for decompressing the LZ compressed
 * data in PNG files.
 */
#ifndef ZLIB_CONST
   /* We must ensure that zlib uses 'const' in declarations. */
#  define ZLIB_CONST
#endif
#include "zlib.h"
#ifdef const
   /* zlib.h sometimes #defines const to nothing, undo this. */
#  undef const
#endif

/* zlib.h has mediocre z_const use before 1.2.6, this stuff is for compatibility
 * with older builds.
 */
#if ZLIB_VERNUM < 0x1260
#  define PNGZ_MSG_CAST(s) png_constcast(char*,s)
#  define PNGZ_INPUT_CAST(b) png_constcast(png_bytep,b)
#else
#  define PNGZ_MSG_CAST(s) (s)
#  define PNGZ_INPUT_CAST(b) (b)
#endif

/* zlib.h declares a magic type 'uInt' that limits the amount of data that zlib
 * can handle at once.  This type need be no larger than 16 bits (so maximum of
 * 65535), this define allows us to discover how big it is, but limited by the
 * maximuum for png_size_t.  The value can be overriden in a library build
 * (pngusr.h, or set it in CPPFLAGS) and it works to set it to a considerably
 * lower value (e.g. 255 works).  A lower value may help memory usage (slightly)
 * and may even improve performance on some systems (and degrade it on others.)
 */
#ifndef ZLIB_IO_MAX
#  define ZLIB_IO_MAX ((uInt)-1)
#endif

#ifdef PNG_WRITE_SUPPORTED
/* The type of a compression buffer list used by the write code. */
typedef struct png_compression_buffer
{
   struct png_compression_buffer *next;
   png_byte                       output[1]; /* actually zbuf_size */
} png_compression_buffer, *png_compression_bufferp;

#define PNG_COMPRESSION_BUFFER_SIZE(pp)\
   (offsetof(png_compression_buffer, output) + (pp)->zbuffer_size)
#endif

/* Colorspace support; structures used in png_struct, png_info and in internal
 * functions to hold and communicate information about the color space.
 *
 * PNG_COLORSPACE_SUPPORTED is only required if the application will perform
 * colorspace corrections, otherwise all the colorspace information can be
 * skipped and the size of libpng can be reduced (significantly) by compiling
 * out the colorspace support.
 */
#ifdef PNG_COLORSPACE_SUPPORTED
/* The chromaticities of the red, green and blue colorants and the chromaticity
 * of the corresponding white point (i.e. of rgb(1.0,1.0,1.0)).
 */
typedef struct png_xy
{
   png_fixed_point redx, redy;
   png_fixed_point greenx, greeny;
   png_fixed_point bluex, bluey;
   png_fixed_point whitex, whitey;
} png_xy;

/* The same data as above but encoded as CIE XYZ values.  When this data comes
 * from chromaticities the sum of the Y values is assumed to be 1.0
 */
typedef struct png_XYZ
{
   png_fixed_point red_X, red_Y, red_Z;
   png_fixed_point green_X, green_Y, green_Z;
   png_fixed_point blue_X, blue_Y, blue_Z;
} png_XYZ;
#endif /* COLORSPACE */

#if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)
/* A colorspace is all the above plus, potentially, profile information;
 * however at present libpng does not use the profile internally so it is only
 * stored in the png_info struct (if iCCP is supported.)  The rendering intent
 * is retained here and is checked.
 *
 * The file gamma encoding information is also stored here and gamma correction
 * is done by libpng, whereas color correction must currently be done by the
 * application.
 */
typedef struct png_colorspace
{
#ifdef PNG_GAMMA_SUPPORTED
   png_fixed_point gamma;        /* File gamma */
#endif

#ifdef PNG_COLORSPACE_SUPPORTED
   png_xy      end_points_xy;    /* End points as chromaticities */
   png_XYZ     end_points_XYZ;   /* End points as CIE XYZ colorant values */
   png_uint_16 rendering_intent; /* Rendering intent of a profile */
#endif

   /* Flags are always defined to simplify the code. */
   png_uint_16 flags;            /* As defined below */
} png_colorspace, * PNG_RESTRICT png_colorspacerp;

typedef const png_colorspace * PNG_RESTRICT png_const_colorspacerp;

/* General flags for the 'flags' field */
#define PNG_COLORSPACE_HAVE_GAMMA           0x0001
#define PNG_COLORSPACE_HAVE_ENDPOINTS       0x0002
#define PNG_COLORSPACE_HAVE_INTENT          0x0004
#define PNG_COLORSPACE_FROM_gAMA            0x0008
#define PNG_COLORSPACE_FROM_cHRM            0x0010
#define PNG_COLORSPACE_FROM_sRGB            0x0020
#define PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB 0x0040
#define PNG_COLORSPACE_MATCHES_sRGB         0x0080 /* exact match on profile */
#define PNG_COLORSPACE_INVALID              0x8000
#define PNG_COLORSPACE_CANCEL(flags)        (0xffff ^ (flags))
#endif /* COLORSPACE || GAMMA */

struct png_struct_def
{
#ifdef PNG_SETJMP_SUPPORTED
   jmp_buf jmp_buf_local;     /* New name in 1.6.0 for jmp_buf in png_struct */
   png_longjmp_ptr longjmp_fn;/* setjmp non-local goto function. */
   jmp_buf *jmp_buf_ptr;      /* passed to longjmp_fn */
   size_t jmp_buf_size;       /* size of the above, if allocated */
#endif
   png_error_ptr error_fn;    /* function for printing errors and aborting */
#ifdef PNG_WARNINGS_SUPPORTED
   png_error_ptr warning_fn;  /* function for printing warnings */
#endif
   png_voidp error_ptr;       /* user supplied struct for error functions */
   png_rw_ptr write_data_fn;  /* function for writing output data */
   png_rw_ptr read_data_fn;   /* function for reading input data */
   png_voidp io_ptr;          /* ptr to application struct for I/O functions */

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
   png_user_transform_ptr read_user_transform_fn; /* user read transform */
#endif

#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
   png_user_transform_ptr write_user_transform_fn; /* user write transform */
#endif

/* These were added in libpng-1.0.2 */
#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
   png_voidp user_transform_ptr; /* user supplied struct for user transform */
   png_byte user_transform_depth;    /* bit depth of user transformed pixels */
   png_byte user_transform_channels; /* channels in user transformed pixels */
#endif
#endif

   png_uint_32 mode;          /* tells us where we are in the PNG file */
   png_uint_32 flags;         /* flags indicating various things to libpng */
   png_uint_32 transformations; /* which transformations to perform */

   png_uint_32 zowner;        /* ID (chunk type) of zstream owner, 0 if none */
   z_stream    zstream;       /* decompression structure */

#ifdef PNG_WRITE_SUPPORTED
   png_compression_bufferp zbuffer_list; /* Created on demand during write */
   uInt                    zbuffer_size; /* size of the actual buffer */

   int zlib_level;            /* holds zlib compression level */
   int zlib_method;           /* holds zlib compression method */
   int zlib_window_bits;      /* holds zlib compression window bits */
   int zlib_mem_level;        /* holds zlib compression memory level */
   int zlib_strategy;         /* holds zlib compression strategy */
#endif
/* Added at libpng 1.5.4 */
#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
   int zlib_text_level;            /* holds zlib compression level */
   int zlib_text_method;           /* holds zlib compression method */
   int zlib_text_window_bits;      /* holds zlib compression window bits */
   int zlib_text_mem_level;        /* holds zlib compression memory level */
   int zlib_text_strategy;         /* holds zlib compression strategy */
#endif
/* End of material added at libpng 1.5.4 */
/* Added at libpng 1.6.0 */
#ifdef PNG_WRITE_SUPPORTED
   int zlib_set_level;        /* Actual values set into the zstream on write */
   int zlib_set_method;
   int zlib_set_window_bits;
   int zlib_set_mem_level;
   int zlib_set_strategy;
#endif

   png_uint_32 width;         /* width of image in pixels */
   png_uint_32 height;        /* height of image in pixels */
   png_uint_32 num_rows;      /* number of rows in current pass */
   png_uint_32 usr_width;     /* width of row at start of write */
   png_size_t rowbytes;       /* size of row in bytes */
   png_uint_32 iwidth;        /* width of current interlaced row in pixels */
   png_uint_32 row_number;    /* current row in interlace pass */
   png_uint_32 chunk_name;    /* PNG_CHUNK() id of current chunk */
   png_bytep prev_row;        /* buffer to save previous (unfiltered) row.
                               * While reading this is a pointer into
                               * big_prev_row; while writing it is separately
                               * allocated if needed.
                               */
   png_bytep row_buf;         /* buffer to save current (unfiltered) row.
                               * While reading, this is a pointer into
                               * big_row_buf; while writing it is separately
                               * allocated.
                               */
#ifdef PNG_WRITE_FILTER_SUPPORTED
   png_bytep try_row;    /* buffer to save trial row when filtering */
   png_bytep tst_row;    /* buffer to save best trial row when filtering */
#endif
   png_size_t info_rowbytes;  /* Added in 1.5.4: cache of updated row bytes */

   png_uint_32 idat_size;     /* current IDAT size for read */
   png_uint_32 crc;           /* current chunk CRC value */
   png_colorp palette;        /* palette from the input file */
   png_uint_16 num_palette;   /* number of color entries in palette */

/* Added at libpng-1.5.10 */
#ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
   int num_palette_max;       /* maximum palette index found in IDAT */
#endif

   png_uint_16 num_trans;     /* number of transparency values */
   png_byte compression;      /* file compression type (always 0) */
   png_byte filter;           /* file filter type (always 0) */
   png_byte interlaced;       /* PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */
   png_byte pass;             /* current interlace pass (0 - 6) */
   png_byte do_filter;        /* row filter flags (see PNG_FILTER_ in png.h ) */
   png_byte color_type;       /* color type of file */
   png_byte bit_depth;        /* bit depth of file */
   png_byte usr_bit_depth;    /* bit depth of users row: write only */
   png_byte pixel_depth;      /* number of bits per pixel */
   png_byte channels;         /* number of channels in file */
#ifdef PNG_WRITE_SUPPORTED
   png_byte usr_channels;     /* channels at start of write: write only */
#endif
   png_byte sig_bytes;        /* magic bytes read/written from start of file */
   png_byte maximum_pixel_depth;
                              /* pixel depth used for the row buffers */
   png_byte transformed_pixel_depth;
                              /* pixel depth after read/write transforms */
#if ZLIB_VERNUM >= 0x1240
   png_byte zstream_start;    /* at start of an input zlib stream */
#endif /* Zlib >= 1.2.4 */
#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
   png_uint_16 filler;           /* filler bytes for pixel expansion */
#endif

#if defined(PNG_bKGD_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
   defined(PNG_READ_ALPHA_MODE_SUPPORTED)
   png_byte background_gamma_type;
   png_fixed_point background_gamma;
   png_color_16 background;   /* background color in screen gamma space */
#ifdef PNG_READ_GAMMA_SUPPORTED
   png_color_16 background_1; /* background normalized to gamma 1.0 */
#endif
#endif /* bKGD */

#ifdef PNG_WRITE_FLUSH_SUPPORTED
   png_flush_ptr output_flush_fn; /* Function for flushing output */
   png_uint_32 flush_dist;    /* how many rows apart to flush, 0 - no flush */
   png_uint_32 flush_rows;    /* number of rows written since last flush */
#endif

#ifdef PNG_READ_GAMMA_SUPPORTED
   int gamma_shift;      /* number of "insignificant" bits in 16-bit gamma */
   png_fixed_point screen_gamma; /* screen gamma value (display_exponent) */

   png_bytep gamma_table;     /* gamma table for 8-bit depth files */
   png_uint_16pp gamma_16_table; /* gamma table for 16-bit depth files */
#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
   png_bytep gamma_from_1;    /* converts from 1.0 to screen */
   png_bytep gamma_to_1;      /* converts from file to 1.0 */
   png_uint_16pp gamma_16_from_1; /* converts from 1.0 to screen */
   png_uint_16pp gamma_16_to_1; /* converts from file to 1.0 */
#endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
#endif

#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_sBIT_SUPPORTED)
   png_color_8 sig_bit;       /* significant bits in each available channel */
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
   png_color_8 shift;         /* shift for significant bit tranformation */
#endif

#if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) \
 || defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
   png_bytep trans_alpha;           /* alpha values for paletted files */
   png_color_16 trans_color;  /* transparent color for non-paletted files */
#endif

   png_read_status_ptr read_row_fn;   /* called after each row is decoded */
   png_write_status_ptr write_row_fn; /* called after each row is encoded */
#ifdef PNG_PROGRESSIVE_READ_SUPPORTED
   png_progressive_info_ptr info_fn; /* called after header data fully read */
   png_progressive_row_ptr row_fn;   /* called after a prog. row is decoded */
   png_progressive_end_ptr end_fn;   /* called after image is complete */
   png_bytep save_buffer_ptr;        /* current location in save_buffer */
   png_bytep save_buffer;            /* buffer for previously read data */
   png_bytep current_buffer_ptr;     /* current location in current_buffer */
   png_bytep current_buffer;         /* buffer for recently used data */
   png_uint_32 push_length;          /* size of current input chunk */
   png_uint_32 skip_length;          /* bytes to skip in input data */
   png_size_t save_buffer_size;      /* amount of data now in save_buffer */
   png_size_t save_buffer_max;       /* total size of save_buffer */
   png_size_t buffer_size;           /* total amount of available input data */
   png_size_t current_buffer_size;   /* amount of data now in current_buffer */
   int process_mode;                 /* what push library is currently doing */
   int cur_palette;                  /* current push library palette index */

#endif /* PROGRESSIVE_READ */

#if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
/* For the Borland special 64K segment handler */
   png_bytepp offset_table_ptr;
   png_bytep offset_table;
   png_uint_16 offset_table_number;
   png_uint_16 offset_table_count;
   png_uint_16 offset_table_count_free;
#endif

#ifdef PNG_READ_QUANTIZE_SUPPORTED
   png_bytep palette_lookup; /* lookup table for quantizing */
   png_bytep quantize_index; /* index translation for palette files */
#endif

/* Options */
#ifdef PNG_SET_OPTION_SUPPORTED
   png_uint_32 options;           /* On/off state (up to 16 options) */
#endif

#if PNG_LIBPNG_VER < 10700
/* To do: remove this from libpng-1.7 */
#ifdef PNG_TIME_RFC1123_SUPPORTED
   char time_buffer[29]; /* String to hold RFC 1123 time text */
#endif
#endif

/* New members added in libpng-1.0.6 */

   png_uint_32 free_me;    /* flags items libpng is responsible for freeing */

#ifdef PNG_USER_CHUNKS_SUPPORTED
   png_voidp user_chunk_ptr;
#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
   png_user_chunk_ptr read_user_chunk_fn; /* user read chunk handler */
#endif
#endif

#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
   int          unknown_default; /* As PNG_HANDLE_* */
   unsigned int num_chunk_list;  /* Number of entries in the list */
   png_bytep    chunk_list;      /* List of png_byte[5]; the textual chunk name
                                  * followed by a PNG_HANDLE_* byte */
#endif

/* New members added in libpng-1.0.3 */
#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
   png_byte rgb_to_gray_status;
   /* Added in libpng 1.5.5 to record setting of coefficients: */
   png_byte rgb_to_gray_coefficients_set;
   /* These were changed from png_byte in libpng-1.0.6 */
   png_uint_16 rgb_to_gray_red_coeff;
   png_uint_16 rgb_to_gray_green_coeff;
   /* deleted in 1.5.5: rgb_to_gray_blue_coeff; */
#endif

/* New member added in libpng-1.0.4 (renamed in 1.0.9) */
#if defined(PNG_MNG_FEATURES_SUPPORTED)
/* Changed from png_byte to png_uint_32 at version 1.2.0 */
   png_uint_32 mng_features_permitted;
#endif

/* New member added in libpng-1.0.9, ifdef'ed out in 1.0.12, enabled in 1.2.0 */
#ifdef PNG_MNG_FEATURES_SUPPORTED
   png_byte filter_type;
#endif

/* New members added in libpng-1.2.0 */

/* New members added in libpng-1.0.2 but first enabled by default in 1.2.0 */
#ifdef PNG_USER_MEM_SUPPORTED
   png_voidp mem_ptr;             /* user supplied struct for mem functions */
   png_malloc_ptr malloc_fn;      /* function for allocating memory */
   png_free_ptr free_fn;          /* function for freeing memory */
#endif

/* New member added in libpng-1.0.13 and 1.2.0 */
   png_bytep big_row_buf;         /* buffer to save current (unfiltered) row */

#ifdef PNG_READ_QUANTIZE_SUPPORTED
/* The following three members were added at version 1.0.14 and 1.2.4 */
   png_bytep quantize_sort;          /* working sort array */
   png_bytep index_to_palette;       /* where the original index currently is
                                        in the palette */
   png_bytep palette_to_index;       /* which original index points to this
                                         palette color */
#endif

/* New members added in libpng-1.0.16 and 1.2.6 */
   png_byte compression_type;

#ifdef PNG_USER_LIMITS_SUPPORTED
   png_uint_32 user_width_max;
   png_uint_32 user_height_max;

   /* Added in libpng-1.4.0: Total number of sPLT, text, and unknown
    * chunks that can be stored (0 means unlimited).
    */
   png_uint_32 user_chunk_cache_max;

   /* Total memory that a zTXt, sPLT, iTXt, iCCP, or unknown chunk
    * can occupy when decompressed.  0 means unlimited.
    */
   png_alloc_size_t user_chunk_malloc_max;
#endif

/* New member added in libpng-1.0.25 and 1.2.17 */
#ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
   /* Temporary storage for unknown chunk that the library doesn't recognize,
    * used while reading the chunk.
    */
   png_unknown_chunk unknown_chunk;
#endif

/* New member added in libpng-1.2.26 */
  png_size_t old_big_row_buf_size;

#ifdef PNG_READ_SUPPORTED
/* New member added in libpng-1.2.30 */
  png_bytep        read_buffer;      /* buffer for reading chunk data */
  png_alloc_size_t read_buffer_size; /* current size of the buffer */
#endif
#ifdef PNG_SEQUENTIAL_READ_SUPPORTED
  uInt             IDAT_read_size;   /* limit on read buffer size for IDAT */
#endif

#ifdef PNG_IO_STATE_SUPPORTED
/* New member added in libpng-1.4.0 */
   png_uint_32 io_state;
#endif

/* New member added in libpng-1.5.6 */
   png_bytep big_prev_row;

/* New member added in libpng-1.5.7 */
   void (*read_filter[PNG_FILTER_VALUE_LAST-1])(png_row_infop row_info,
      png_bytep row, png_const_bytep prev_row);

#ifdef PNG_READ_SUPPORTED
#if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)
   png_colorspace   colorspace;
#endif
#endif
};
#endif /* PNGSTRUCT_H */

```

`ThirdPartyBuild/PNG/Code/pngtest.c`:

```c

/* pngtest.c - a simple test program to test libpng
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This program reads in a PNG image, writes it out again, and then
 * compares the two files.  If the files are identical, this shows that
 * the basic chunk handling, filtering, and (de)compression code is working
 * properly.  It does not currently test all of the transforms, although
 * it probably should.
 *
 * The program will report "FAIL" in certain legitimate cases:
 * 1) when the compression level or filter selection method is changed.
 * 2) when the maximum IDAT size (PNG_ZBUF_SIZE in pngconf.h) is not 8192.
 * 3) unknown unsafe-to-copy ancillary chunks or unknown critical chunks
 *    exist in the input file.
 * 4) others not listed here...
 * In these cases, it is best to check with another tool such as "pngcheck"
 * to see what the differences between the two files are.
 *
 * If a filename is given on the command-line, then this file is used
 * for the input, rather than the default "pngtest.png".  This allows
 * testing a wide variety of files easily.  You can also test a number
 * of files at once by typing "pngtest -m file1.png file2.png ..."
 */

#define _POSIX_SOURCE 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Defined so I can write to a file on gui/windowing platforms */
/*  #define STDERR stderr  */
#define STDERR stdout   /* For DOS */

#include "png.h"

/* Known chunks that exist in pngtest.png must be supported or pngtest will fail
 * simply as a result of re-ordering them.  This may be fixed in 1.7
 *
 * pngtest allocates a single row buffer for each row and overwrites it,
 * therefore if the write side doesn't support the writing of interlaced images
 * nothing can be done for an interlaced image (and the code below will fail
 * horribly trying to write extra data after writing garbage).
 */
#if defined PNG_READ_SUPPORTED && /* else nothing can be done */\
   defined PNG_READ_bKGD_SUPPORTED &&\
   defined PNG_READ_cHRM_SUPPORTED &&\
   defined PNG_READ_gAMA_SUPPORTED &&\
   defined PNG_READ_oFFs_SUPPORTED &&\
   defined PNG_READ_pCAL_SUPPORTED &&\
   defined PNG_READ_pHYs_SUPPORTED &&\
   defined PNG_READ_sBIT_SUPPORTED &&\
   defined PNG_READ_sCAL_SUPPORTED &&\
   defined PNG_READ_sRGB_SUPPORTED &&\
   defined PNG_READ_sPLT_SUPPORTED &&\
   defined PNG_READ_tEXt_SUPPORTED &&\
   defined PNG_READ_tIME_SUPPORTED &&\
   defined PNG_READ_zTXt_SUPPORTED &&\
   (defined PNG_WRITE_INTERLACING_SUPPORTED || PNG_LIBPNG_VER >= 10700)

#ifdef PNG_ZLIB_HEADER
#  include PNG_ZLIB_HEADER /* defined by pnglibconf.h from 1.7 */
#else
#  include "zlib.h"
#endif

/* Copied from pngpriv.h but only used in error messages below. */
#ifndef PNG_ZBUF_SIZE
#  define PNG_ZBUF_SIZE 8192
#endif
#define FCLOSE(file) fclose(file)

#ifndef PNG_STDIO_SUPPORTED
typedef FILE                * png_FILE_p;
#endif

/* Makes pngtest verbose so we can find problems. */
#ifndef PNG_DEBUG
#  define PNG_DEBUG 0
#endif

#if PNG_DEBUG > 1
#  define pngtest_debug(m)        ((void)fprintf(stderr, m "\n"))
#  define pngtest_debug1(m,p1)    ((void)fprintf(stderr, m "\n", p1))
#  define pngtest_debug2(m,p1,p2) ((void)fprintf(stderr, m "\n", p1, p2))
#else
#  define pngtest_debug(m)        ((void)0)
#  define pngtest_debug1(m,p1)    ((void)0)
#  define pngtest_debug2(m,p1,p2) ((void)0)
#endif

#if !PNG_DEBUG
#  define SINGLE_ROWBUF_ALLOC  /* Makes buffer overruns easier to nail */
#endif

#ifndef PNG_UNUSED
#  define PNG_UNUSED(param) (void)param;
#endif

/* Turn on CPU timing
#define PNGTEST_TIMING
*/

#ifndef PNG_FLOATING_POINT_SUPPORTED
#undef PNGTEST_TIMING
#endif

#ifdef PNGTEST_TIMING
static float t_start, t_stop, t_decode, t_encode, t_misc;
#include <time.h>
#endif

#ifdef PNG_TIME_RFC1123_SUPPORTED
#define PNG_tIME_STRING_LENGTH 29
static int tIME_chunk_present = 0;
static char tIME_string[PNG_tIME_STRING_LENGTH] = "tIME chunk is not present";

#if PNG_LIBPNG_VER < 10619
#define png_convert_to_rfc1123_buffer(ts, t) tIME_to_str(read_ptr, ts, t)

static int
tIME_to_str(png_structp png_ptr, png_charp ts, png_const_timep t)
{
   png_const_charp str = png_convert_to_rfc1123(png_ptr, t);

   if (str == NULL)
       return 0;

   strcpy(ts, str);
   return 1;
}
#endif /* older libpng */
#endif

static int verbose = 0;
static int strict = 0;
static int relaxed = 0;
static int unsupported_chunks = 0; /* chunk unsupported by libpng in input */
static int error_count = 0; /* count calls to png_error */
static int warning_count = 0; /* count calls to png_warning */

/* Define png_jmpbuf() in case we are using a pre-1.0.6 version of libpng */
#ifndef png_jmpbuf
#  define png_jmpbuf(png_ptr) png_ptr->jmpbuf
#endif

/* Defines for unknown chunk handling if required. */
#ifndef PNG_HANDLE_CHUNK_ALWAYS
#  define PNG_HANDLE_CHUNK_ALWAYS       3
#endif
#ifndef PNG_HANDLE_CHUNK_IF_SAFE
#  define PNG_HANDLE_CHUNK_IF_SAFE      2
#endif

/* Utility to save typing/errors, the argument must be a name */
#define MEMZERO(var) ((void)memset(&var, 0, sizeof var))

/* Example of using row callbacks to make a simple progress meter */
static int status_pass = 1;
static int status_dots_requested = 0;
static int status_dots = 1;

static void PNGCBAPI
read_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
{
   if (png_ptr == NULL || row_number > PNG_UINT_31_MAX)
      return;

   if (status_pass != pass)
   {
      fprintf(stdout, "\n Pass %d: ", pass);
      status_pass = pass;
      status_dots = 31;
   }

   status_dots--;

   if (status_dots == 0)
   {
      fprintf(stdout, "\n         ");
      status_dots=30;
   }

   fprintf(stdout, "r");
}

#ifdef PNG_WRITE_SUPPORTED
static void PNGCBAPI
write_row_callback(png_structp png_ptr, png_uint_32 row_number, int pass)
{
   if (png_ptr == NULL || row_number > PNG_UINT_31_MAX || pass > 7)
      return;

   fprintf(stdout, "w");
}
#endif


#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
/* Example of using a user transform callback (doesn't do anything at present).
 */
static void PNGCBAPI
read_user_callback(png_structp png_ptr, png_row_infop row_info, png_bytep data)
{
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(row_info)
   PNG_UNUSED(data)
}
#endif

#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
/* Example of using user transform callback (we don't transform anything,
 * but merely count the zero samples)
 */

static png_uint_32 zero_samples;

static void PNGCBAPI
count_zero_samples(png_structp png_ptr, png_row_infop row_info, png_bytep data)
{
   png_bytep dp = data;
   if (png_ptr == NULL)
      return;

   /* Contents of row_info:
    *  png_uint_32 width      width of row
    *  png_uint_32 rowbytes   number of bytes in row
    *  png_byte color_type    color type of pixels
    *  png_byte bit_depth     bit depth of samples
    *  png_byte channels      number of channels (1-4)
    *  png_byte pixel_depth   bits per pixel (depth*channels)
    */

   /* Counts the number of zero samples (or zero pixels if color_type is 3 */

   if (row_info->color_type == 0 || row_info->color_type == 3)
   {
      int pos = 0;
      png_uint_32 n, nstop;

      for (n = 0, nstop=row_info->width; n<nstop; n++)
      {
         if (row_info->bit_depth == 1)
         {
            if (((*dp << pos++ ) & 0x80) == 0)
               zero_samples++;

            if (pos == 8)
            {
               pos = 0;
               dp++;
            }
         }

         if (row_info->bit_depth == 2)
         {
            if (((*dp << (pos+=2)) & 0xc0) == 0)
               zero_samples++;

            if (pos == 8)
            {
               pos = 0;
               dp++;
            }
         }

         if (row_info->bit_depth == 4)
         {
            if (((*dp << (pos+=4)) & 0xf0) == 0)
               zero_samples++;

            if (pos == 8)
            {
               pos = 0;
               dp++;
            }
         }

         if (row_info->bit_depth == 8)
            if (*dp++ == 0)
               zero_samples++;

         if (row_info->bit_depth == 16)
         {
            if ((*dp | *(dp+1)) == 0)
               zero_samples++;
            dp+=2;
         }
      }
   }
   else /* Other color types */
   {
      png_uint_32 n, nstop;
      int channel;
      int color_channels = row_info->channels;
      if (row_info->color_type > 3)
         color_channels--;

      for (n = 0, nstop=row_info->width; n<nstop; n++)
      {
         for (channel = 0; channel < color_channels; channel++)
         {
            if (row_info->bit_depth == 8)
               if (*dp++ == 0)
                  zero_samples++;

            if (row_info->bit_depth == 16)
            {
               if ((*dp | *(dp+1)) == 0)
                  zero_samples++;

               dp+=2;
            }
         }
         if (row_info->color_type > 3)
         {
            dp++;
            if (row_info->bit_depth == 16)
               dp++;
         }
      }
   }
}
#endif /* WRITE_USER_TRANSFORM */

#ifndef PNG_STDIO_SUPPORTED
/* START of code to validate stdio-free compilation */
/* These copies of the default read/write functions come from pngrio.c and
 * pngwio.c.  They allow "don't include stdio" testing of the library.
 * This is the function that does the actual reading of data.  If you are
 * not reading from a standard C stream, you should create a replacement
 * read_data function and use it at run time with png_set_read_fn(), rather
 * than changing the library.
 */

#ifdef PNG_IO_STATE_SUPPORTED
void
pngtest_check_io_state(png_structp png_ptr, png_size_t data_length,
    png_uint_32 io_op);
void
pngtest_check_io_state(png_structp png_ptr, png_size_t data_length,
    png_uint_32 io_op)
{
   png_uint_32 io_state = png_get_io_state(png_ptr);
   int err = 0;

   /* Check if the current operation (reading / writing) is as expected. */
   if ((io_state & PNG_IO_MASK_OP) != io_op)
      png_error(png_ptr, "Incorrect operation in I/O state");

   /* Check if the buffer size specific to the current location
    * (file signature / header / data / crc) is as expected.
    */
   switch (io_state & PNG_IO_MASK_LOC)
   {
   case PNG_IO_SIGNATURE:
      if (data_length > 8)
         err = 1;
      break;
   case PNG_IO_CHUNK_HDR:
      if (data_length != 8)
         err = 1;
      break;
   case PNG_IO_CHUNK_DATA:
      break;  /* no restrictions here */
   case PNG_IO_CHUNK_CRC:
      if (data_length != 4)
         err = 1;
      break;
   default:
      err = 1;  /* uninitialized */
   }
   if (err != 0)
      png_error(png_ptr, "Bad I/O state or buffer size");
}
#endif

static void PNGCBAPI
pngtest_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_size_t check = 0;
   png_voidp io_ptr;

   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
    * instead of an int, which is what fread() actually returns.
    */
   io_ptr = png_get_io_ptr(png_ptr);
   if (io_ptr != NULL)
   {
      check = fread(data, 1, length, (png_FILE_p)io_ptr);
   }

   if (check != length)
   {
      png_error(png_ptr, "Read Error");
   }

#ifdef PNG_IO_STATE_SUPPORTED
   pngtest_check_io_state(png_ptr, length, PNG_IO_READING);
#endif
}

#ifdef PNG_WRITE_FLUSH_SUPPORTED
static void PNGCBAPI
pngtest_flush(png_structp png_ptr)
{
   /* Do nothing; fflush() is said to be just a waste of energy. */
   PNG_UNUSED(png_ptr)   /* Stifle compiler warning */
}
#endif

/* This is the function that does the actual writing of data.  If you are
 * not writing to a standard C stream, you should create a replacement
 * write_data function and use it at run time with png_set_write_fn(), rather
 * than changing the library.
 */
static void PNGCBAPI
pngtest_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_size_t check;

   check = fwrite(data, 1, length, (png_FILE_p)png_get_io_ptr(png_ptr));

   if (check != length)
   {
      png_error(png_ptr, "Write Error");
   }

#ifdef PNG_IO_STATE_SUPPORTED
   pngtest_check_io_state(png_ptr, length, PNG_IO_WRITING);
#endif
}
#endif /* !STDIO */

/* This function is called when there is a warning, but the library thinks
 * it can continue anyway.  Replacement functions don't have to do anything
 * here if you don't want to.  In the default configuration, png_ptr is
 * not used, but it is passed in case it may be useful.
 */
typedef struct
{
   PNG_CONST char *file_name;
}  pngtest_error_parameters;

static void PNGCBAPI
pngtest_warning(png_structp png_ptr, png_const_charp message)
{
   PNG_CONST char *name = "UNKNOWN (ERROR!)";
   pngtest_error_parameters *test =
      (pngtest_error_parameters*)png_get_error_ptr(png_ptr);

   ++warning_count;

   if (test != NULL && test->file_name != NULL)
      name = test->file_name;

   fprintf(STDERR, "%s: libpng warning: %s\n", name, message);
}

/* This is the default error handling function.  Note that replacements for
 * this function MUST NOT RETURN, or the program will likely crash.  This
 * function is used by default, or if the program supplies NULL for the
 * error function pointer in png_set_error_fn().
 */
static void PNGCBAPI
pngtest_error(png_structp png_ptr, png_const_charp message)
{
   ++error_count;

   pngtest_warning(png_ptr, message);
   /* We can return because png_error calls the default handler, which is
    * actually OK in this case.
    */
}

/* END of code to validate stdio-free compilation */

/* START of code to validate memory allocation and deallocation */
#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG

/* Allocate memory.  For reasonable files, size should never exceed
 * 64K.  However, zlib may allocate more than 64K if you don't tell
 * it not to.  See zconf.h and png.h for more information.  zlib does
 * need to allocate exactly 64K, so whatever you call here must
 * have the ability to do that.
 *
 * This piece of code can be compiled to validate max 64K allocations
 * by setting MAXSEG_64K in zlib zconf.h *or* PNG_MAX_MALLOC_64K.
 */
typedef struct memory_information
{
   png_alloc_size_t          size;
   png_voidp                 pointer;
   struct memory_information *next;
} memory_information;
typedef memory_information *memory_infop;

static memory_infop pinformation = NULL;
static int current_allocation = 0;
static int maximum_allocation = 0;
static int total_allocation = 0;
static int num_allocations = 0;

png_voidp PNGCBAPI png_debug_malloc PNGARG((png_structp png_ptr,
    png_alloc_size_t size));
void PNGCBAPI png_debug_free PNGARG((png_structp png_ptr, png_voidp ptr));

png_voidp
PNGCBAPI png_debug_malloc(png_structp png_ptr, png_alloc_size_t size)
{

   /* png_malloc has already tested for NULL; png_create_struct calls
    * png_debug_malloc directly, with png_ptr == NULL which is OK
    */

   if (size == 0)
      return (NULL);

   /* This calls the library allocator twice, once to get the requested
      buffer and once to get a new free list entry. */
   {
      /* Disable malloc_fn and free_fn */
      memory_infop pinfo;
      png_set_mem_fn(png_ptr, NULL, NULL, NULL);
      pinfo = (memory_infop)png_malloc(png_ptr,
          (sizeof *pinfo));
      pinfo->size = size;
      current_allocation += size;
      total_allocation += size;
      num_allocations ++;

      if (current_allocation > maximum_allocation)
         maximum_allocation = current_allocation;

      pinfo->pointer = png_malloc(png_ptr, size);
      /* Restore malloc_fn and free_fn */

      png_set_mem_fn(png_ptr,
          NULL, png_debug_malloc, png_debug_free);

      if (size != 0 && pinfo->pointer == NULL)
      {
         current_allocation -= size;
         total_allocation -= size;
         png_error(png_ptr,
           "out of memory in pngtest->png_debug_malloc");
      }

      pinfo->next = pinformation;
      pinformation = pinfo;
      /* Make sure the caller isn't assuming zeroed memory. */
      memset(pinfo->pointer, 0xdd, pinfo->size);

      if (verbose != 0)
         printf("png_malloc %lu bytes at %p\n", (unsigned long)size,
             pinfo->pointer);

      return (png_voidp)(pinfo->pointer);
   }
}

/* Free a pointer.  It is removed from the list at the same time. */
void PNGCBAPI
png_debug_free(png_structp png_ptr, png_voidp ptr)
{
   if (png_ptr == NULL)
      fprintf(STDERR, "NULL pointer to png_debug_free.\n");

   if (ptr == 0)
   {
#if 0 /* This happens all the time. */
      fprintf(STDERR, "WARNING: freeing NULL pointer\n");
#endif
      return;
   }

   /* Unlink the element from the list. */
   if (pinformation != NULL)
   {
      memory_infop *ppinfo = &pinformation;

      for (;;)
      {
         memory_infop pinfo = *ppinfo;

         if (pinfo->pointer == ptr)
         {
            *ppinfo = pinfo->next;
            current_allocation -= pinfo->size;
            if (current_allocation < 0)
               fprintf(STDERR, "Duplicate free of memory\n");
            /* We must free the list element too, but first kill
               the memory that is to be freed. */
            memset(ptr, 0x55, pinfo->size);
            free(pinfo);
            pinfo = NULL;
            break;
         }

         if (pinfo->next == NULL)
         {
            fprintf(STDERR, "Pointer %p not found\n", ptr);
            break;
         }

         ppinfo = &pinfo->next;
      }
   }

   /* Finally free the data. */
   if (verbose != 0)
      printf("Freeing %p\n", ptr);

   if (ptr != NULL)
      free(ptr);
   ptr = NULL;
}
#endif /* USER_MEM && DEBUG */
/* END of code to test memory allocation/deallocation */


#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
/* Demonstration of user chunk support of the sTER and vpAg chunks */

/* (sTER is a public chunk not yet known by libpng.  vpAg is a private
chunk used in ImageMagick to store "virtual page" size).  */

static struct user_chunk_data
{
   png_const_infop info_ptr;
   png_uint_32     vpAg_width, vpAg_height;
   png_byte        vpAg_units;
   png_byte        sTER_mode;
   int             location[2];
}
user_chunk_data;

/* Used for location and order; zero means nothing. */
#define have_sTER   0x01
#define have_vpAg   0x02
#define before_PLTE 0x10
#define before_IDAT 0x20
#define after_IDAT  0x40

static void
init_callback_info(png_const_infop info_ptr)
{
   MEMZERO(user_chunk_data);
   user_chunk_data.info_ptr = info_ptr;
}

static int
set_location(png_structp png_ptr, struct user_chunk_data *data, int what)
{
   int location;

   if ((data->location[0] & what) != 0 || (data->location[1] & what) != 0)
      return 0; /* already have one of these */

   /* Find where we are (the code below zeroes info_ptr to indicate that the
    * chunks before the first IDAT have been read.)
    */
   if (data->info_ptr == NULL) /* after IDAT */
      location = what | after_IDAT;

   else if (png_get_valid(png_ptr, data->info_ptr, PNG_INFO_PLTE) != 0)
      location = what | before_IDAT;

   else
      location = what | before_PLTE;

   if (data->location[0] == 0)
      data->location[0] = location;

   else
      data->location[1] = location;

   return 1; /* handled */
}

static int PNGCBAPI
read_user_chunk_callback(png_struct *png_ptr, png_unknown_chunkp chunk)
{
   struct user_chunk_data *my_user_chunk_data =
      (struct user_chunk_data*)png_get_user_chunk_ptr(png_ptr);

   if (my_user_chunk_data == NULL)
      png_error(png_ptr, "lost user chunk pointer");

   /* Return one of the following:
    *    return (-n);  chunk had an error
    *    return (0);  did not recognize
    *    return (n);  success
    *
    * The unknown chunk structure contains the chunk data:
    * png_byte name[5];
    * png_byte *data;
    * png_size_t size;
    *
    * Note that libpng has already taken care of the CRC handling.
    */

   if (chunk->name[0] == 115 && chunk->name[1] ==  84 &&     /* s  T */
       chunk->name[2] ==  69 && chunk->name[3] ==  82)       /* E  R */
      {
         /* Found sTER chunk */
         if (chunk->size != 1)
            return (-1); /* Error return */

         if (chunk->data[0] != 0 && chunk->data[0] != 1)
            return (-1);  /* Invalid mode */

         if (set_location(png_ptr, my_user_chunk_data, have_sTER) != 0)
         {
            my_user_chunk_data->sTER_mode=chunk->data[0];
            return (1);
         }

         else
            return (0); /* duplicate sTER - give it to libpng */
      }

   if (chunk->name[0] != 118 || chunk->name[1] != 112 ||    /* v  p */
       chunk->name[2] !=  65 || chunk->name[3] != 103)      /* A  g */
      return (0); /* Did not recognize */

   /* Found ImageMagick vpAg chunk */

   if (chunk->size != 9)
      return (-1); /* Error return */

   if (set_location(png_ptr, my_user_chunk_data, have_vpAg) == 0)
      return (0);  /* duplicate vpAg */

   my_user_chunk_data->vpAg_width = png_get_uint_31(png_ptr, chunk->data);
   my_user_chunk_data->vpAg_height = png_get_uint_31(png_ptr, chunk->data + 4);
   my_user_chunk_data->vpAg_units = chunk->data[8];

   return (1);
}

#ifdef PNG_WRITE_SUPPORTED
static void
write_sTER_chunk(png_structp write_ptr)
{
   png_byte sTER[5] = {115,  84,  69,  82, '\0'};

   if (verbose != 0)
      fprintf(STDERR, "\n stereo mode = %d\n", user_chunk_data.sTER_mode);

   png_write_chunk(write_ptr, sTER, &user_chunk_data.sTER_mode, 1);
}

static void
write_vpAg_chunk(png_structp write_ptr)
{
   png_byte vpAg[5] = {118, 112,  65, 103, '\0'};

   png_byte vpag_chunk_data[9];

   if (verbose != 0)
      fprintf(STDERR, " vpAg = %lu x %lu, units = %d\n",
          (unsigned long)user_chunk_data.vpAg_width,
          (unsigned long)user_chunk_data.vpAg_height,
          user_chunk_data.vpAg_units);

   png_save_uint_32(vpag_chunk_data, user_chunk_data.vpAg_width);
   png_save_uint_32(vpag_chunk_data + 4, user_chunk_data.vpAg_height);
   vpag_chunk_data[8] = user_chunk_data.vpAg_units;
   png_write_chunk(write_ptr, vpAg, vpag_chunk_data, 9);
}

static void
write_chunks(png_structp write_ptr, int location)
{
   int i;

   /* Notice that this preserves the original chunk order, however chunks
    * intercepted by the callback will be written *after* chunks passed to
    * libpng.  This will actually reverse a pair of sTER chunks or a pair of
    * vpAg chunks, resulting in an error later.  This is not worth worrying
    * about - the chunks should not be duplicated!
    */
   for (i=0; i<2; ++i)
   {
      if (user_chunk_data.location[i] == (location | have_sTER))
         write_sTER_chunk(write_ptr);

      else if (user_chunk_data.location[i] == (location | have_vpAg))
         write_vpAg_chunk(write_ptr);
   }
}
#endif /* WRITE */
#else /* !READ_USER_CHUNKS */
#  define write_chunks(pp,loc) ((void)0)
#endif
/* END of code to demonstrate user chunk support */

/* START of code to check that libpng has the required text support; this only
 * checks for the write support because if read support is missing the chunk
 * will simply not be reported back to pngtest.
 */
#ifdef PNG_TEXT_SUPPORTED
static void
pngtest_check_text_support(png_structp png_ptr, png_textp text_ptr,
    int num_text)
{
   while (num_text > 0)
   {
      switch (text_ptr[--num_text].compression)
      {
         case PNG_TEXT_COMPRESSION_NONE:
            break;

         case PNG_TEXT_COMPRESSION_zTXt:
#           ifndef PNG_WRITE_zTXt_SUPPORTED
               ++unsupported_chunks;
               /* In libpng 1.7 this now does an app-error, so stop it: */
               text_ptr[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
#           endif
            break;

         case PNG_ITXT_COMPRESSION_NONE:
         case PNG_ITXT_COMPRESSION_zTXt:
#           ifndef PNG_WRITE_iTXt_SUPPORTED
               ++unsupported_chunks;
               text_ptr[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
#           endif
            break;

         default:
            /* This is an error */
            png_error(png_ptr, "invalid text chunk compression field");
            break;
      }
   }
}
#endif
/* END of code to check that libpng has the required text support */

/* Test one file */
static int
test_one_file(PNG_CONST char *inname, PNG_CONST char *outname)
{
   static png_FILE_p fpin;
   static png_FILE_p fpout;  /* "static" prevents setjmp corruption */
   pngtest_error_parameters error_parameters;
   png_structp read_ptr;
   png_infop read_info_ptr, end_info_ptr;
#ifdef PNG_WRITE_SUPPORTED
   png_structp write_ptr;
   png_infop write_info_ptr;
   png_infop write_end_info_ptr;
#ifdef PNG_WRITE_FILTER_SUPPORTED
   int interlace_preserved = 1;
#endif /* WRITE_FILTER */
#else /* !WRITE */
   png_structp write_ptr = NULL;
   png_infop write_info_ptr = NULL;
   png_infop write_end_info_ptr = NULL;
#endif /* !WRITE */
   png_bytep row_buf;
   png_uint_32 y;
   png_uint_32 width, height;
   volatile int num_passes;
   int pass;
   int bit_depth, color_type;

   row_buf = NULL;
   error_parameters.file_name = inname;

   if ((fpin = fopen(inname, "rb")) == NULL)
   {
      fprintf(STDERR, "Could not find input file %s\n", inname);
      return (1);
   }

   if ((fpout = fopen(outname, "wb")) == NULL)
   {
      fprintf(STDERR, "Could not open output file %s\n", outname);
      FCLOSE(fpin);
      return (1);
   }

   pngtest_debug("Allocating read and write structures");
#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
   read_ptr =
       png_create_read_struct_2(PNG_LIBPNG_VER_STRING, NULL,
       NULL, NULL, NULL, png_debug_malloc, png_debug_free);
#else
   read_ptr =
       png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
#endif
   png_set_error_fn(read_ptr, &error_parameters, pngtest_error,
       pngtest_warning);

#ifdef PNG_WRITE_SUPPORTED
#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
   write_ptr =
       png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL,
       NULL, NULL, NULL, png_debug_malloc, png_debug_free);
#else
   write_ptr =
       png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
#endif
   png_set_error_fn(write_ptr, &error_parameters, pngtest_error,
       pngtest_warning);
#endif
   pngtest_debug("Allocating read_info, write_info and end_info structures");
   read_info_ptr = png_create_info_struct(read_ptr);
   end_info_ptr = png_create_info_struct(read_ptr);
#ifdef PNG_WRITE_SUPPORTED
   write_info_ptr = png_create_info_struct(write_ptr);
   write_end_info_ptr = png_create_info_struct(write_ptr);
#endif

#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
   init_callback_info(read_info_ptr);
   png_set_read_user_chunk_fn(read_ptr, &user_chunk_data,
       read_user_chunk_callback);
#endif

#ifdef PNG_SETJMP_SUPPORTED
   pngtest_debug("Setting jmpbuf for read struct");
   if (setjmp(png_jmpbuf(read_ptr)))
   {
      fprintf(STDERR, "%s -> %s: libpng read error\n", inname, outname);
      png_free(read_ptr, row_buf);
      row_buf = NULL;
      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
#ifdef PNG_WRITE_SUPPORTED
      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
      png_destroy_write_struct(&write_ptr, &write_info_ptr);
#endif
      FCLOSE(fpin);
      FCLOSE(fpout);
      return (1);
   }

#ifdef PNG_WRITE_SUPPORTED
   pngtest_debug("Setting jmpbuf for write struct");

   if (setjmp(png_jmpbuf(write_ptr)))
   {
      fprintf(STDERR, "%s -> %s: libpng write error\n", inname, outname);
      png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
      png_destroy_info_struct(write_ptr, &write_end_info_ptr);
#ifdef PNG_WRITE_SUPPORTED
      png_destroy_write_struct(&write_ptr, &write_info_ptr);
#endif
      FCLOSE(fpin);
      FCLOSE(fpout);
      return (1);
   }
#endif
#endif

#ifdef PNG_BENIGN_ERRORS_SUPPORTED
   if (strict != 0)
   {
      /* Treat png_benign_error() as errors on read */
      png_set_benign_errors(read_ptr, 0);

# ifdef PNG_WRITE_SUPPORTED
      /* Treat them as errors on write */
      png_set_benign_errors(write_ptr, 0);
# endif

      /* if strict is not set, then app warnings and errors are treated as
       * warnings in release builds, but not in unstable builds; this can be
       * changed with '--relaxed'.
       */
   }

   else if (relaxed != 0)
   {
      /* Allow application (pngtest) errors and warnings to pass */
      png_set_benign_errors(read_ptr, 1);

      /* Turn off CRC checking while reading */
      png_set_crc_action(read_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);

#ifdef PNG_IGNORE_ADLER32
      /* Turn off ADLER32 checking while reading */
      png_set_option(read_ptr, PNG_IGNORE_ADLER32, PNG_OPTION_ON);
#endif

# ifdef PNG_WRITE_SUPPORTED
      png_set_benign_errors(write_ptr, 1);
# endif

   }
#endif /* BENIGN_ERRORS */

   pngtest_debug("Initializing input and output streams");
#ifdef PNG_STDIO_SUPPORTED
   png_init_io(read_ptr, fpin);
#  ifdef PNG_WRITE_SUPPORTED
   png_init_io(write_ptr, fpout);
#  endif
#else
   png_set_read_fn(read_ptr, (png_voidp)fpin, pngtest_read_data);
#  ifdef PNG_WRITE_SUPPORTED
   png_set_write_fn(write_ptr, (png_voidp)fpout,  pngtest_write_data,
#    ifdef PNG_WRITE_FLUSH_SUPPORTED
       pngtest_flush);
#    else
       NULL);
#    endif
#  endif
#endif

   if (status_dots_requested == 1)
   {
#ifdef PNG_WRITE_SUPPORTED
      png_set_write_status_fn(write_ptr, write_row_callback);
#endif
      png_set_read_status_fn(read_ptr, read_row_callback);
   }

   else
   {
#ifdef PNG_WRITE_SUPPORTED
      png_set_write_status_fn(write_ptr, NULL);
#endif
      png_set_read_status_fn(read_ptr, NULL);
   }

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
   png_set_read_user_transform_fn(read_ptr, read_user_callback);
#endif
#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
   zero_samples = 0;
   png_set_write_user_transform_fn(write_ptr, count_zero_samples);
#endif

#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
   /* Preserve all the unknown chunks, if possible.  If this is disabled then,
    * even if the png_{get,set}_unknown_chunks stuff is enabled, we can't use
    * libpng to *save* the unknown chunks on read (because we can't switch the
    * save option on!)
    *
    * Notice that if SET_UNKNOWN_CHUNKS is *not* supported read will discard all
    * unknown chunks and write will write them all.
    */
#ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
   png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_ALWAYS,
       NULL, 0);
#endif
#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
   png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS,
       NULL, 0);
#endif
#endif

   pngtest_debug("Reading info struct");
   png_read_info(read_ptr, read_info_ptr);

#ifdef PNG_READ_USER_CHUNKS_SUPPORTED
   /* This is a bit of a hack; there is no obvious way in the callback function
    * to determine that the chunks before the first IDAT have been read, so
    * remove the info_ptr (which is only used to determine position relative to
    * PLTE) here to indicate that we are after the IDAT.
    */
   user_chunk_data.info_ptr = NULL;
#endif

   pngtest_debug("Transferring info struct");
   {
      int interlace_type, compression_type, filter_type;

      if (png_get_IHDR(read_ptr, read_info_ptr, &width, &height, &bit_depth,
          &color_type, &interlace_type, &compression_type, &filter_type) != 0)
      {
         png_set_IHDR(write_ptr, write_info_ptr, width, height, bit_depth,
             color_type, interlace_type, compression_type, filter_type);
         /* num_passes may not be available below if interlace support is not
          * provided by libpng for both read and write.
          */
         switch (interlace_type)
         {
            case PNG_INTERLACE_NONE:
               num_passes = 1;
               break;

            case PNG_INTERLACE_ADAM7:
               num_passes = 7;
               break;

            default:
               png_error(read_ptr, "invalid interlace type");
               /*NOT REACHED*/
         }
      }

      else
         png_error(read_ptr, "png_get_IHDR failed");
   }
#ifdef PNG_FIXED_POINT_SUPPORTED
#ifdef PNG_cHRM_SUPPORTED
   {
      png_fixed_point white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
          blue_y;

      if (png_get_cHRM_fixed(read_ptr, read_info_ptr, &white_x, &white_y,
          &red_x, &red_y, &green_x, &green_y, &blue_x, &blue_y) != 0)
      {
         png_set_cHRM_fixed(write_ptr, write_info_ptr, white_x, white_y, red_x,
             red_y, green_x, green_y, blue_x, blue_y);
      }
   }
#endif
#ifdef PNG_gAMA_SUPPORTED
   {
      png_fixed_point gamma;

      if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma) != 0)
         png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);
   }
#endif
#else /* Use floating point versions */
#ifdef PNG_FLOATING_POINT_SUPPORTED
#ifdef PNG_cHRM_SUPPORTED
   {
      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
          blue_y;

      if (png_get_cHRM(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,
          &red_y, &green_x, &green_y, &blue_x, &blue_y) != 0)
      {
         png_set_cHRM(write_ptr, write_info_ptr, white_x, white_y, red_x,
             red_y, green_x, green_y, blue_x, blue_y);
      }
   }
#endif
#ifdef PNG_gAMA_SUPPORTED
   {
      double gamma;

      if (png_get_gAMA(read_ptr, read_info_ptr, &gamma) != 0)
         png_set_gAMA(write_ptr, write_info_ptr, gamma);
   }
#endif
#endif /* Floating point */
#endif /* Fixed point */
#ifdef PNG_iCCP_SUPPORTED
   {
      png_charp name;
      png_bytep profile;
      png_uint_32 proflen;
      int compression_type;

      if (png_get_iCCP(read_ptr, read_info_ptr, &name, &compression_type,
          &profile, &proflen) != 0)
      {
         png_set_iCCP(write_ptr, write_info_ptr, name, compression_type,
             profile, proflen);
      }
   }
#endif
#ifdef PNG_sRGB_SUPPORTED
   {
      int intent;

      if (png_get_sRGB(read_ptr, read_info_ptr, &intent) != 0)
         png_set_sRGB(write_ptr, write_info_ptr, intent);
   }
#endif
   {
      png_colorp palette;
      int num_palette;

      if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette) != 0)
         png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
   }
#ifdef PNG_bKGD_SUPPORTED
   {
      png_color_16p background;

      if (png_get_bKGD(read_ptr, read_info_ptr, &background) != 0)
      {
         png_set_bKGD(write_ptr, write_info_ptr, background);
      }
   }
#endif
#ifdef PNG_hIST_SUPPORTED
   {
      png_uint_16p hist;

      if (png_get_hIST(read_ptr, read_info_ptr, &hist) != 0)
         png_set_hIST(write_ptr, write_info_ptr, hist);
   }
#endif
#ifdef PNG_oFFs_SUPPORTED
   {
      png_int_32 offset_x, offset_y;
      int unit_type;

      if (png_get_oFFs(read_ptr, read_info_ptr, &offset_x, &offset_y,
          &unit_type) != 0)
      {
         png_set_oFFs(write_ptr, write_info_ptr, offset_x, offset_y, unit_type);
      }
   }
#endif
#ifdef PNG_pCAL_SUPPORTED
   {
      png_charp purpose, units;
      png_charpp params;
      png_int_32 X0, X1;
      int type, nparams;

      if (png_get_pCAL(read_ptr, read_info_ptr, &purpose, &X0, &X1, &type,
          &nparams, &units, &params) != 0)
      {
         png_set_pCAL(write_ptr, write_info_ptr, purpose, X0, X1, type,
             nparams, units, params);
      }
   }
#endif
#ifdef PNG_pHYs_SUPPORTED
   {
      png_uint_32 res_x, res_y;
      int unit_type;

      if (png_get_pHYs(read_ptr, read_info_ptr, &res_x, &res_y,
          &unit_type) != 0)
         png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);
   }
#endif
#ifdef PNG_sBIT_SUPPORTED
   {
      png_color_8p sig_bit;

      if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit) != 0)
         png_set_sBIT(write_ptr, write_info_ptr, sig_bit);
   }
#endif
#ifdef PNG_sCAL_SUPPORTED
#if defined(PNG_FLOATING_POINT_SUPPORTED) && \
   defined(PNG_FLOATING_ARITHMETIC_SUPPORTED)
   {
      int unit;
      double scal_width, scal_height;

      if (png_get_sCAL(read_ptr, read_info_ptr, &unit, &scal_width,
          &scal_height) != 0)
      {
         png_set_sCAL(write_ptr, write_info_ptr, unit, scal_width, scal_height);
      }
   }
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   {
      int unit;
      png_charp scal_width, scal_height;

      if (png_get_sCAL_s(read_ptr, read_info_ptr, &unit, &scal_width,
           &scal_height) != 0)
      {
         png_set_sCAL_s(write_ptr, write_info_ptr, unit, scal_width,
             scal_height);
      }
   }
#endif
#endif
#endif

#ifdef PNG_sPLT_SUPPORTED
   {
       png_sPLT_tp entries;

       int num_entries = (int) png_get_sPLT(read_ptr, read_info_ptr, &entries);
       if (num_entries)
       {
           png_set_sPLT(write_ptr, write_info_ptr, entries, num_entries);
       }
   }
#endif

#ifdef PNG_TEXT_SUPPORTED
   {
      png_textp text_ptr;
      int num_text;

      if (png_get_text(read_ptr, read_info_ptr, &text_ptr, &num_text) > 0)
      {
         pngtest_debug1("Handling %d iTXt/tEXt/zTXt chunks", num_text);

         pngtest_check_text_support(read_ptr, text_ptr, num_text);

         if (verbose != 0)
         {
            int i;

            printf("\n");
            for (i=0; i<num_text; i++)
            {
               printf("   Text compression[%d]=%d\n",
                   i, text_ptr[i].compression);
            }
         }

         png_set_text(write_ptr, write_info_ptr, text_ptr, num_text);
      }
   }
#endif
#ifdef PNG_tIME_SUPPORTED
   {
      png_timep mod_time;

      if (png_get_tIME(read_ptr, read_info_ptr, &mod_time) != 0)
      {
         png_set_tIME(write_ptr, write_info_ptr, mod_time);
#ifdef PNG_TIME_RFC1123_SUPPORTED
         if (png_convert_to_rfc1123_buffer(tIME_string, mod_time) != 0)
            tIME_string[(sizeof tIME_string) - 1] = '\0';

         else
         {
            strncpy(tIME_string, "*** invalid time ***", (sizeof tIME_string));
            tIME_string[(sizeof tIME_string) - 1] = '\0';
         }

         tIME_chunk_present++;
#endif /* TIME_RFC1123 */
      }
   }
#endif
#ifdef PNG_tRNS_SUPPORTED
   {
      png_bytep trans_alpha;
      int num_trans;
      png_color_16p trans_color;

      if (png_get_tRNS(read_ptr, read_info_ptr, &trans_alpha, &num_trans,
          &trans_color) != 0)
      {
         int sample_max = (1 << bit_depth);
         /* libpng doesn't reject a tRNS chunk with out-of-range samples */
         if (!((color_type == PNG_COLOR_TYPE_GRAY &&
             (int)trans_color->gray > sample_max) ||
             (color_type == PNG_COLOR_TYPE_RGB &&
             ((int)trans_color->red > sample_max ||
             (int)trans_color->green > sample_max ||
             (int)trans_color->blue > sample_max))))
            png_set_tRNS(write_ptr, write_info_ptr, trans_alpha, num_trans,
               trans_color);
      }
   }
#endif
#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
   {
      png_unknown_chunkp unknowns;
      int num_unknowns = png_get_unknown_chunks(read_ptr, read_info_ptr,
          &unknowns);

      if (num_unknowns != 0)
      {
         png_set_unknown_chunks(write_ptr, write_info_ptr, unknowns,
             num_unknowns);
#if PNG_LIBPNG_VER < 10600
         /* Copy the locations from the read_info_ptr.  The automatically
          * generated locations in write_end_info_ptr are wrong prior to 1.6.0
          * because they are reset from the write pointer (removed in 1.6.0).
          */
         {
            int i;
            for (i = 0; i < num_unknowns; i++)
              png_set_unknown_chunk_location(write_ptr, write_info_ptr, i,
                  unknowns[i].location);
         }
#endif
      }
   }
#endif

#ifdef PNG_WRITE_SUPPORTED
   pngtest_debug("Writing info struct");

   /* Write the info in two steps so that if we write the 'unknown' chunks here
    * they go to the correct place.
    */
   png_write_info_before_PLTE(write_ptr, write_info_ptr);

   write_chunks(write_ptr, before_PLTE); /* before PLTE */

   png_write_info(write_ptr, write_info_ptr);

   write_chunks(write_ptr, before_IDAT); /* after PLTE */

#ifdef PNG_COMPRESSION_COMPAT
   /* Test the 'compatibility' setting here, if it is available. */
   png_set_compression(write_ptr, PNG_COMPRESSION_COMPAT);
#endif
#endif

#ifdef SINGLE_ROWBUF_ALLOC
   pngtest_debug("Allocating row buffer...");
   row_buf = (png_bytep)png_malloc(read_ptr,
       png_get_rowbytes(read_ptr, read_info_ptr));

   pngtest_debug1("\t0x%08lx", (unsigned long)row_buf);
#endif /* SINGLE_ROWBUF_ALLOC */
   pngtest_debug("Writing row data");

#if defined(PNG_READ_INTERLACING_SUPPORTED) &&\
   defined(PNG_WRITE_INTERLACING_SUPPORTED)
   /* Both must be defined for libpng to be able to handle the interlace,
    * otherwise it gets handled below by simply reading and writing the passes
    * directly.
    */
   if (png_set_interlace_handling(read_ptr) != num_passes)
      png_error(write_ptr,
          "png_set_interlace_handling(read): wrong pass count ");
   if (png_set_interlace_handling(write_ptr) != num_passes)
      png_error(write_ptr,
          "png_set_interlace_handling(write): wrong pass count ");
#else /* png_set_interlace_handling not called on either read or write */
#  define calc_pass_height
#endif /* not using libpng interlace handling */

#ifdef PNGTEST_TIMING
   t_stop = (float)clock();
   t_misc += (t_stop - t_start);
   t_start = t_stop;
#endif
   for (pass = 0; pass < num_passes; pass++)
   {
#     ifdef calc_pass_height
         png_uint_32 pass_height;

         if (num_passes == 7) /* interlaced */
         {
            if (PNG_PASS_COLS(width, pass) > 0)
               pass_height = PNG_PASS_ROWS(height, pass);

            else
               pass_height = 0;
         }

         else /* not interlaced */
            pass_height = height;
#     else
#        define pass_height height
#     endif

      pngtest_debug1("Writing row data for pass %d", pass);
      for (y = 0; y < pass_height; y++)
      {
#ifndef SINGLE_ROWBUF_ALLOC
         pngtest_debug2("Allocating row buffer (pass %d, y = %u)...", pass, y);

         row_buf = (png_bytep)png_malloc(read_ptr,
             png_get_rowbytes(read_ptr, read_info_ptr));

         pngtest_debug2("\t0x%08lx (%lu bytes)", (unsigned long)row_buf,
             (unsigned long)png_get_rowbytes(read_ptr, read_info_ptr));

#endif /* !SINGLE_ROWBUF_ALLOC */
         png_read_rows(read_ptr, (png_bytepp)&row_buf, NULL, 1);

#ifdef PNG_WRITE_SUPPORTED
#ifdef PNGTEST_TIMING
         t_stop = (float)clock();
         t_decode += (t_stop - t_start);
         t_start = t_stop;
#endif
         png_write_rows(write_ptr, (png_bytepp)&row_buf, 1);
#ifdef PNGTEST_TIMING
         t_stop = (float)clock();
         t_encode += (t_stop - t_start);
         t_start = t_stop;
#endif
#endif /* WRITE */

#ifndef SINGLE_ROWBUF_ALLOC
         pngtest_debug2("Freeing row buffer (pass %d, y = %u)", pass, y);
         png_free(read_ptr, row_buf);
         row_buf = NULL;
#endif /* !SINGLE_ROWBUF_ALLOC */
      }
   }

#ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
#  ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
      png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);
#  endif
#  ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
      png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);
#  endif
#endif

   pngtest_debug("Reading and writing end_info data");

   png_read_end(read_ptr, end_info_ptr);
#ifdef PNG_TEXT_SUPPORTED
   {
      png_textp text_ptr;
      int num_text;

      if (png_get_text(read_ptr, end_info_ptr, &text_ptr, &num_text) > 0)
      {
         pngtest_debug1("Handling %d iTXt/tEXt/zTXt chunks", num_text);

         pngtest_check_text_support(read_ptr, text_ptr, num_text);

         if (verbose != 0)
         {
            int i;

            printf("\n");
            for (i=0; i<num_text; i++)
            {
               printf("   Text compression[%d]=%d\n",
                   i, text_ptr[i].compression);
            }
         }

         png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);
      }
   }
#endif
#ifdef PNG_tIME_SUPPORTED
   {
      png_timep mod_time;

      if (png_get_tIME(read_ptr, end_info_ptr, &mod_time) != 0)
      {
         png_set_tIME(write_ptr, write_end_info_ptr, mod_time);
#ifdef PNG_TIME_RFC1123_SUPPORTED
         if (png_convert_to_rfc1123_buffer(tIME_string, mod_time) != 0)
            tIME_string[(sizeof tIME_string) - 1] = '\0';

         else
         {
            strncpy(tIME_string, "*** invalid time ***", sizeof tIME_string);
            tIME_string[(sizeof tIME_string)-1] = '\0';
         }

         tIME_chunk_present++;
#endif /* TIME_RFC1123 */
      }
   }
#endif
#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
   {
      png_unknown_chunkp unknowns;
      int num_unknowns = png_get_unknown_chunks(read_ptr, end_info_ptr,
          &unknowns);

      if (num_unknowns != 0)
      {
         png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns,
             num_unknowns);
#if PNG_LIBPNG_VER < 10600
         /* Copy the locations from the read_info_ptr.  The automatically
          * generated locations in write_end_info_ptr are wrong prior to 1.6.0
          * because they are reset from the write pointer (removed in 1.6.0).
          */
         {
            int i;
            for (i = 0; i < num_unknowns; i++)
              png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i,
                  unknowns[i].location);
         }
#endif
      }
   }
#endif

#ifdef PNG_WRITE_SUPPORTED
#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
   /* Normally one would use Z_DEFAULT_STRATEGY for text compression.
    * This is here just to make pngtest replicate the results from libpng
    * versions prior to 1.5.4, and to test this new API.
    */
   png_set_text_compression_strategy(write_ptr, Z_FILTERED);
#endif

   /* When the unknown vpAg/sTER chunks are written by pngtest the only way to
    * do it is to write them *before* calling png_write_end.  When unknown
    * chunks are written by libpng, however, they are written just before IEND.
    * There seems to be no way round this, however vpAg/sTER are not expected
    * after IDAT.
    */
   write_chunks(write_ptr, after_IDAT);

   png_write_end(write_ptr, write_end_info_ptr);
#endif

#ifdef PNG_EASY_ACCESS_SUPPORTED
   if (verbose != 0)
   {
      png_uint_32 iwidth, iheight;
      iwidth = png_get_image_width(write_ptr, write_info_ptr);
      iheight = png_get_image_height(write_ptr, write_info_ptr);
      fprintf(STDERR, "\n Image width = %lu, height = %lu\n",
          (unsigned long)iwidth, (unsigned long)iheight);
   }
#endif

   pngtest_debug("Destroying data structs");
#ifdef SINGLE_ROWBUF_ALLOC
   pngtest_debug("destroying row_buf for read_ptr");
   png_free(read_ptr, row_buf);
   row_buf = NULL;
#endif /* SINGLE_ROWBUF_ALLOC */
   pngtest_debug("destroying read_ptr, read_info_ptr, end_info_ptr");
   png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
#ifdef PNG_WRITE_SUPPORTED
   pngtest_debug("destroying write_end_info_ptr");
   png_destroy_info_struct(write_ptr, &write_end_info_ptr);
   pngtest_debug("destroying write_ptr, write_info_ptr");
   png_destroy_write_struct(&write_ptr, &write_info_ptr);
#endif
   pngtest_debug("Destruction complete.");

   FCLOSE(fpin);
   FCLOSE(fpout);

   /* Summarize any warnings or errors and in 'strict' mode fail the test.
    * Unsupported chunks can result in warnings, in that case ignore the strict
    * setting, otherwise fail the test on warnings as well as errors.
    */
   if (error_count > 0)
   {
      /* We don't really expect to get here because of the setjmp handling
       * above, but this is safe.
       */
      fprintf(STDERR, "\n  %s: %d libpng errors found (%d warnings)",
          inname, error_count, warning_count);

      if (strict != 0)
         return (1);
   }

#  ifdef PNG_WRITE_SUPPORTED
      /* If there is no write support nothing was written! */
      else if (unsupported_chunks > 0)
      {
         fprintf(STDERR, "\n  %s: unsupported chunks (%d)%s",
             inname, unsupported_chunks, strict ? ": IGNORED --strict!" : "");
      }
#  endif

   else if (warning_count > 0)
   {
      fprintf(STDERR, "\n  %s: %d libpng warnings found",
          inname, warning_count);

      if (strict != 0)
         return (1);
   }

   pngtest_debug("Opening files for comparison");
   if ((fpin = fopen(inname, "rb")) == NULL)
   {
      fprintf(STDERR, "Could not find file %s\n", inname);
      return (1);
   }

   if ((fpout = fopen(outname, "rb")) == NULL)
   {
      fprintf(STDERR, "Could not find file %s\n", outname);
      FCLOSE(fpin);
      return (1);
   }

#if defined (PNG_WRITE_SUPPORTED) /* else nothing was written */ &&\
    defined (PNG_WRITE_FILTER_SUPPORTED)
   if (interlace_preserved != 0) /* else the files will be changed */
   {
      for (;;)
      {
         static int wrote_question = 0;
         png_size_t num_in, num_out;
         char inbuf[256], outbuf[256];

         num_in = fread(inbuf, 1, sizeof inbuf, fpin);
         num_out = fread(outbuf, 1, sizeof outbuf, fpout);

         if (num_in != num_out)
         {
            fprintf(STDERR, "\nFiles %s and %s are of a different size\n",
                inname, outname);

            if (wrote_question == 0 && unsupported_chunks == 0)
            {
               fprintf(STDERR,
                   "   Was %s written with the same maximum IDAT"
                   " chunk size (%d bytes),",
                   inname, PNG_ZBUF_SIZE);
               fprintf(STDERR,
                   "\n   filtering heuristic (libpng default), compression");
               fprintf(STDERR,
                   " level (zlib default),\n   and zlib version (%s)?\n\n",
                   ZLIB_VERSION);
               wrote_question = 1;
            }

            FCLOSE(fpin);
            FCLOSE(fpout);

            if (strict != 0 && unsupported_chunks == 0)
              return (1);

            else
              return (0);
         }

         if (num_in == 0)
            break;

         if (memcmp(inbuf, outbuf, num_in))
         {
            fprintf(STDERR, "\nFiles %s and %s are different\n", inname,
                outname);

            if (wrote_question == 0 && unsupported_chunks == 0)
            {
               fprintf(STDERR,
                   "   Was %s written with the same maximum"
                   " IDAT chunk size (%d bytes),",
                    inname, PNG_ZBUF_SIZE);
               fprintf(STDERR,
                   "\n   filtering heuristic (libpng default), compression");
               fprintf(STDERR,
                   " level (zlib default),\n   and zlib version (%s)?\n\n",
                 ZLIB_VERSION);
               wrote_question = 1;
            }

            FCLOSE(fpin);
            FCLOSE(fpout);

            /* NOTE: the unsupported_chunks escape is permitted here because
             * unsupported text chunk compression will result in the compression
             * mode being changed (to NONE) yet, in the test case, the result
             * can be exactly the same size!
             */
            if (strict != 0 && unsupported_chunks == 0)
              return (1);

            else
              return (0);
         }
      }
   }
#endif /* WRITE && WRITE_FILTER */

   FCLOSE(fpin);
   FCLOSE(fpout);

   return (0);
}

/* Input and output filenames */
#ifdef RISCOS
static PNG_CONST char *inname = "pngtest/png";
static PNG_CONST char *outname = "pngout/png";
#else
static PNG_CONST char *inname = "pngtest.png";
static PNG_CONST char *outname = "pngout.png";
#endif

int
main(int argc, char *argv[])
{
   int multiple = 0;
   int ierror = 0;

   png_structp dummy_ptr;

   fprintf(STDERR, "\n Testing libpng version %s\n", PNG_LIBPNG_VER_STRING);
   fprintf(STDERR, "   with zlib   version %s\n", ZLIB_VERSION);
   fprintf(STDERR, "%s", png_get_copyright(NULL));
   /* Show the version of libpng used in building the library */
   fprintf(STDERR, " library (%lu):%s",
       (unsigned long)png_access_version_number(),
       png_get_header_version(NULL));

   /* Show the version of libpng used in building the application */
   fprintf(STDERR, " pngtest (%lu):%s", (unsigned long)PNG_LIBPNG_VER,
       PNG_HEADER_VERSION_STRING);

   /* Do some consistency checking on the memory allocation settings, I'm
    * not sure this matters, but it is nice to know, the first of these
    * tests should be impossible because of the way the macros are set
    * in pngconf.h
    */
#if defined(MAXSEG_64K) && !defined(PNG_MAX_MALLOC_64K)
      fprintf(STDERR, " NOTE: Zlib compiled for max 64k, libpng not\n");
#endif
   /* I think the following can happen. */
#if !defined(MAXSEG_64K) && defined(PNG_MAX_MALLOC_64K)
      fprintf(STDERR, " NOTE: libpng compiled for max 64k, zlib not\n");
#endif

   if (strcmp(png_libpng_ver, PNG_LIBPNG_VER_STRING))
   {
      fprintf(STDERR,
          "Warning: versions are different between png.h and png.c\n");
      fprintf(STDERR, "  png.h version: %s\n", PNG_LIBPNG_VER_STRING);
      fprintf(STDERR, "  png.c version: %s\n\n", png_libpng_ver);
      ++ierror;
   }

   if (argc > 1)
   {
      if (strcmp(argv[1], "-m") == 0)
      {
         multiple = 1;
         status_dots_requested = 0;
      }

      else if (strcmp(argv[1], "-mv") == 0 ||
               strcmp(argv[1], "-vm") == 0 )
      {
         multiple = 1;
         verbose = 1;
         status_dots_requested = 1;
      }

      else if (strcmp(argv[1], "-v") == 0)
      {
         verbose = 1;
         status_dots_requested = 1;
         inname = argv[2];
      }

      else if (strcmp(argv[1], "--strict") == 0)
      {
         status_dots_requested = 0;
         verbose = 1;
         inname = argv[2];
         strict++;
         relaxed = 0;
      }

      else if (strcmp(argv[1], "--relaxed") == 0)
      {
         status_dots_requested = 0;
         verbose = 1;
         inname = argv[2];
         strict = 0;
         relaxed++;
      }

      else
      {
         inname = argv[1];
         status_dots_requested = 0;
      }
   }

   if (multiple == 0 && argc == 3 + verbose)
      outname = argv[2 + verbose];

   if ((multiple == 0 && argc > 3 + verbose) ||
       (multiple != 0 && argc < 2))
   {
      fprintf(STDERR,
          "usage: %s [infile.png] [outfile.png]\n\t%s -m {infile.png}\n",
          argv[0], argv[0]);
      fprintf(STDERR,
          "  reads/writes one PNG file (without -m) or multiple files (-m)\n");
      fprintf(STDERR,
          "  with -m %s is used as a temporary file\n", outname);
      exit(1);
   }

   if (multiple != 0)
   {
      int i;
#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
      int allocation_now = current_allocation;
#endif
      for (i=2; i<argc; ++i)
      {
         int kerror;
         fprintf(STDERR, "\n Testing %s:", argv[i]);
#if PNG_DEBUG > 0
         fprintf(STDERR, "\n");
#endif
         kerror = test_one_file(argv[i], outname);
         if (kerror == 0)
         {
#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
            fprintf(STDERR, "\n PASS (%lu zero samples)\n",
                (unsigned long)zero_samples);
#else
            fprintf(STDERR, " PASS\n");
#endif
#ifdef PNG_TIME_RFC1123_SUPPORTED
            if (tIME_chunk_present != 0)
               fprintf(STDERR, " tIME = %s\n", tIME_string);

            tIME_chunk_present = 0;
#endif /* TIME_RFC1123 */
         }

         else
         {
            fprintf(STDERR, " FAIL\n");
            ierror += kerror;
         }
#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
         if (allocation_now != current_allocation)
            fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
                current_allocation - allocation_now);

         if (current_allocation != 0)
         {
            memory_infop pinfo = pinformation;

            fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
                current_allocation);

            while (pinfo != NULL)
            {
               fprintf(STDERR, " %lu bytes at %p\n",
                   (unsigned long)pinfo->size,
                   pinfo->pointer);
               pinfo = pinfo->next;
            }
         }
#endif
      }
#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
         fprintf(STDERR, " Current memory allocation: %10d bytes\n",
             current_allocation);
         fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
             maximum_allocation);
         fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
             total_allocation);
         fprintf(STDERR, "     Number of allocations: %10d\n",
             num_allocations);
#endif
   }

   else
   {
      int i;
      for (i = 0; i<3; ++i)
      {
         int kerror;
#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
         int allocation_now = current_allocation;
#endif
         if (i == 1)
            status_dots_requested = 1;

         else if (verbose == 0)
            status_dots_requested = 0;

         if (i == 0 || verbose == 1 || ierror != 0)
         {
            fprintf(STDERR, "\n Testing %s:", inname);
#if PNG_DEBUG > 0
            fprintf(STDERR, "\n");
#endif
         }

         kerror = test_one_file(inname, outname);

         if (kerror == 0)
         {
            if (verbose == 1 || i == 2)
            {
#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
                fprintf(STDERR, "\n PASS (%lu zero samples)\n",
                    (unsigned long)zero_samples);
#else
                fprintf(STDERR, " PASS\n");
#endif
#ifdef PNG_TIME_RFC1123_SUPPORTED
             if (tIME_chunk_present != 0)
                fprintf(STDERR, " tIME = %s\n", tIME_string);
#endif /* TIME_RFC1123 */
            }
         }

         else
         {
            if (verbose == 0 && i != 2)
            {
               fprintf(STDERR, "\n Testing %s:", inname);
#if PNG_DEBUG > 0
               fprintf(STDERR, "\n");
#endif
            }

            fprintf(STDERR, " FAIL\n");
            ierror += kerror;
         }
#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
         if (allocation_now != current_allocation)
             fprintf(STDERR, "MEMORY ERROR: %d bytes lost\n",
                 current_allocation - allocation_now);

         if (current_allocation != 0)
         {
             memory_infop pinfo = pinformation;

             fprintf(STDERR, "MEMORY ERROR: %d bytes still allocated\n",
                 current_allocation);

             while (pinfo != NULL)
             {
                fprintf(STDERR, " %lu bytes at %p\n",
                    (unsigned long)pinfo->size, pinfo->pointer);
                pinfo = pinfo->next;
             }
          }
#endif
       }
#if defined(PNG_USER_MEM_SUPPORTED) && PNG_DEBUG
       fprintf(STDERR, " Current memory allocation: %10d bytes\n",
           current_allocation);
       fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
           maximum_allocation);
       fprintf(STDERR, " Total   memory allocation: %10d bytes\n",
           total_allocation);
       fprintf(STDERR, "     Number of allocations: %10d\n",
           num_allocations);
#endif
   }

#ifdef PNGTEST_TIMING
   t_stop = (float)clock();
   t_misc += (t_stop - t_start);
   t_start = t_stop;
   fprintf(STDERR, " CPU time used = %.3f seconds",
       (t_misc+t_decode+t_encode)/(float)CLOCKS_PER_SEC);
   fprintf(STDERR, " (decoding %.3f,\n",
       t_decode/(float)CLOCKS_PER_SEC);
   fprintf(STDERR, "        encoding %.3f ,",
       t_encode/(float)CLOCKS_PER_SEC);
   fprintf(STDERR, " other %.3f seconds)\n\n",
       t_misc/(float)CLOCKS_PER_SEC);
#endif

   if (ierror == 0)
      fprintf(STDERR, " libpng passes test\n");

   else
      fprintf(STDERR, " libpng FAILS test\n");

   dummy_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
   fprintf(STDERR, " Default limits:\n");
   fprintf(STDERR, "  width_max  = %lu\n",
       (unsigned long) png_get_user_width_max(dummy_ptr));
   fprintf(STDERR, "  height_max = %lu\n",
       (unsigned long) png_get_user_height_max(dummy_ptr));
   if (png_get_chunk_cache_max(dummy_ptr) == 0)
      fprintf(STDERR, "  cache_max  = unlimited\n");
   else
      fprintf(STDERR, "  cache_max  = %lu\n",
          (unsigned long) png_get_chunk_cache_max(dummy_ptr));
   if (png_get_chunk_malloc_max(dummy_ptr) == 0)
      fprintf(STDERR, "  malloc_max = unlimited\n");
   else
      fprintf(STDERR, "  malloc_max = %lu\n",
          (unsigned long) png_get_chunk_malloc_max(dummy_ptr));
   png_destroy_read_struct(&dummy_ptr, NULL, NULL);

   return (int)(ierror != 0);
}
#else
int
main(void)
{
   fprintf(STDERR,
       " test ignored because libpng was not built with read support\n");
   /* And skip this test */
   return PNG_LIBPNG_VER < 10600 ? 0 : 77;
}
#endif

/* Generate a compiler error if there is an old png.h in the search path. */
typedef png_libpng_version_1_6_28 Your_png_h_is_not_version_1_6_28;

```

`ThirdPartyBuild/PNG/Code/pngtrans.c`:

```c

/* pngtrans.c - transforms the data in a row (used by both readers and writers)
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

#include "pngpriv.h"

#if defined(PNG_READ_SUPPORTED) || defined(PNG_WRITE_SUPPORTED)

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
/* Turn on BGR-to-RGB mapping */
void PNGAPI
png_set_bgr(png_structrp png_ptr)
{
   png_debug(1, "in png_set_bgr");

   if (png_ptr == NULL)
      return;

   png_ptr->transformations |= PNG_BGR;
}
#endif

#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
/* Turn on 16-bit byte swapping */
void PNGAPI
png_set_swap(png_structrp png_ptr)
{
   png_debug(1, "in png_set_swap");

   if (png_ptr == NULL)
      return;

   if (png_ptr->bit_depth == 16)
      png_ptr->transformations |= PNG_SWAP_BYTES;
}
#endif

#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
/* Turn on pixel packing */
void PNGAPI
png_set_packing(png_structrp png_ptr)
{
   png_debug(1, "in png_set_packing");

   if (png_ptr == NULL)
      return;

   if (png_ptr->bit_depth < 8)
   {
      png_ptr->transformations |= PNG_PACK;
#     ifdef PNG_WRITE_SUPPORTED
         png_ptr->usr_bit_depth = 8;
#     endif
   }
}
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
/* Turn on packed pixel swapping */
void PNGAPI
png_set_packswap(png_structrp png_ptr)
{
   png_debug(1, "in png_set_packswap");

   if (png_ptr == NULL)
      return;

   if (png_ptr->bit_depth < 8)
      png_ptr->transformations |= PNG_PACKSWAP;
}
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
void PNGAPI
png_set_shift(png_structrp png_ptr, png_const_color_8p true_bits)
{
   png_debug(1, "in png_set_shift");

   if (png_ptr == NULL)
      return;

   png_ptr->transformations |= PNG_SHIFT;
   png_ptr->shift = *true_bits;
}
#endif

#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
    defined(PNG_WRITE_INTERLACING_SUPPORTED)
int PNGAPI
png_set_interlace_handling(png_structrp png_ptr)
{
   png_debug(1, "in png_set_interlace handling");

   if (png_ptr != 0 && png_ptr->interlaced != 0)
   {
      png_ptr->transformations |= PNG_INTERLACE;
      return (7);
   }

   return (1);
}
#endif

#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
/* Add a filler byte on read, or remove a filler or alpha byte on write.
 * The filler type has changed in v0.95 to allow future 2-byte fillers
 * for 48-bit input data, as well as to avoid problems with some compilers
 * that don't like bytes as parameters.
 */
void PNGAPI
png_set_filler(png_structrp png_ptr, png_uint_32 filler, int filler_loc)
{
   png_debug(1, "in png_set_filler");

   if (png_ptr == NULL)
      return;

   /* In libpng 1.6 it is possible to determine whether this is a read or write
    * operation and therefore to do more checking here for a valid call.
    */
   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0)
   {
#     ifdef PNG_READ_FILLER_SUPPORTED
         /* On read png_set_filler is always valid, regardless of the base PNG
          * format, because other transformations can give a format where the
          * filler code can execute (basically an 8 or 16-bit component RGB or G
          * format.)
          *
          * NOTE: usr_channels is not used by the read code!  (This has led to
          * confusion in the past.)  The filler is only used in the read code.
          */
         png_ptr->filler = (png_uint_16)filler;
#     else
         png_app_error(png_ptr, "png_set_filler not supported on read");
         PNG_UNUSED(filler) /* not used in the write case */
         return;
#     endif
   }

   else /* write */
   {
#     ifdef PNG_WRITE_FILLER_SUPPORTED
         /* On write the usr_channels parameter must be set correctly at the
          * start to record the number of channels in the app-supplied data.
          */
         switch (png_ptr->color_type)
         {
            case PNG_COLOR_TYPE_RGB:
               png_ptr->usr_channels = 4;
               break;

            case PNG_COLOR_TYPE_GRAY:
               if (png_ptr->bit_depth >= 8)
               {
                  png_ptr->usr_channels = 2;
                  break;
               }

               else
               {
                  /* There simply isn't any code in libpng to strip out bits
                   * from bytes when the components are less than a byte in
                   * size!
                   */
                  png_app_error(png_ptr,
                      "png_set_filler is invalid for"
                      " low bit depth gray output");
                  return;
               }

            default:
               png_app_error(png_ptr,
                   "png_set_filler: inappropriate color type");
               return;
         }
#     else
         png_app_error(png_ptr, "png_set_filler not supported on write");
         return;
#     endif
   }

   /* Here on success - libpng supports the operation, set the transformation
    * and the flag to say where the filler channel is.
    */
   png_ptr->transformations |= PNG_FILLER;

   if (filler_loc == PNG_FILLER_AFTER)
      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;

   else
      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;
}

/* Added to libpng-1.2.7 */
void PNGAPI
png_set_add_alpha(png_structrp png_ptr, png_uint_32 filler, int filler_loc)
{
   png_debug(1, "in png_set_add_alpha");

   if (png_ptr == NULL)
      return;

   png_set_filler(png_ptr, filler, filler_loc);
   /* The above may fail to do anything. */
   if ((png_ptr->transformations & PNG_FILLER) != 0)
      png_ptr->transformations |= PNG_ADD_ALPHA;
}

#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
void PNGAPI
png_set_swap_alpha(png_structrp png_ptr)
{
   png_debug(1, "in png_set_swap_alpha");

   if (png_ptr == NULL)
      return;

   png_ptr->transformations |= PNG_SWAP_ALPHA;
}
#endif

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
void PNGAPI
png_set_invert_alpha(png_structrp png_ptr)
{
   png_debug(1, "in png_set_invert_alpha");

   if (png_ptr == NULL)
      return;

   png_ptr->transformations |= PNG_INVERT_ALPHA;
}
#endif

#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
void PNGAPI
png_set_invert_mono(png_structrp png_ptr)
{
   png_debug(1, "in png_set_invert_mono");

   if (png_ptr == NULL)
      return;

   png_ptr->transformations |= PNG_INVERT_MONO;
}

/* Invert monochrome grayscale data */
void /* PRIVATE */
png_do_invert(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_invert");

  /* This test removed from libpng version 1.0.13 and 1.2.0:
   *   if (row_info->bit_depth == 1 &&
   */
   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
   {
      png_bytep rp = row;
      png_size_t i;
      png_size_t istop = row_info->rowbytes;

      for (i = 0; i < istop; i++)
      {
         *rp = (png_byte)(~(*rp));
         rp++;
      }
   }

   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
      row_info->bit_depth == 8)
   {
      png_bytep rp = row;
      png_size_t i;
      png_size_t istop = row_info->rowbytes;

      for (i = 0; i < istop; i += 2)
      {
         *rp = (png_byte)(~(*rp));
         rp += 2;
      }
   }

#ifdef PNG_16BIT_SUPPORTED
   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA &&
      row_info->bit_depth == 16)
   {
      png_bytep rp = row;
      png_size_t i;
      png_size_t istop = row_info->rowbytes;

      for (i = 0; i < istop; i += 4)
      {
         *rp = (png_byte)(~(*rp));
         *(rp + 1) = (png_byte)(~(*(rp + 1)));
         rp += 4;
      }
   }
#endif
}
#endif

#ifdef PNG_16BIT_SUPPORTED
#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
/* Swaps byte order on 16-bit depth images */
void /* PRIVATE */
png_do_swap(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_swap");

   if (row_info->bit_depth == 16)
   {
      png_bytep rp = row;
      png_uint_32 i;
      png_uint_32 istop= row_info->width * row_info->channels;

      for (i = 0; i < istop; i++, rp += 2)
      {
#ifdef PNG_BUILTIN_BSWAP16_SUPPORTED
         /* Feature added to libpng-1.6.11 for testing purposes, not
          * enabled by default.
          */
         *(png_uint_16*)rp = __builtin_bswap16(*(png_uint_16*)rp);
#else
         png_byte t = *rp;
         *rp = *(rp + 1);
         *(rp + 1) = t;
#endif
      }
   }
}
#endif
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
static PNG_CONST png_byte onebppswaptable[256] = {
   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};

static PNG_CONST png_byte twobppswaptable[256] = {
   0x00, 0x40, 0x80, 0xC0, 0x10, 0x50, 0x90, 0xD0,
   0x20, 0x60, 0xA0, 0xE0, 0x30, 0x70, 0xB0, 0xF0,
   0x04, 0x44, 0x84, 0xC4, 0x14, 0x54, 0x94, 0xD4,
   0x24, 0x64, 0xA4, 0xE4, 0x34, 0x74, 0xB4, 0xF4,
   0x08, 0x48, 0x88, 0xC8, 0x18, 0x58, 0x98, 0xD8,
   0x28, 0x68, 0xA8, 0xE8, 0x38, 0x78, 0xB8, 0xF8,
   0x0C, 0x4C, 0x8C, 0xCC, 0x1C, 0x5C, 0x9C, 0xDC,
   0x2C, 0x6C, 0xAC, 0xEC, 0x3C, 0x7C, 0xBC, 0xFC,
   0x01, 0x41, 0x81, 0xC1, 0x11, 0x51, 0x91, 0xD1,
   0x21, 0x61, 0xA1, 0xE1, 0x31, 0x71, 0xB1, 0xF1,
   0x05, 0x45, 0x85, 0xC5, 0x15, 0x55, 0x95, 0xD5,
   0x25, 0x65, 0xA5, 0xE5, 0x35, 0x75, 0xB5, 0xF5,
   0x09, 0x49, 0x89, 0xC9, 0x19, 0x59, 0x99, 0xD9,
   0x29, 0x69, 0xA9, 0xE9, 0x39, 0x79, 0xB9, 0xF9,
   0x0D, 0x4D, 0x8D, 0xCD, 0x1D, 0x5D, 0x9D, 0xDD,
   0x2D, 0x6D, 0xAD, 0xED, 0x3D, 0x7D, 0xBD, 0xFD,
   0x02, 0x42, 0x82, 0xC2, 0x12, 0x52, 0x92, 0xD2,
   0x22, 0x62, 0xA2, 0xE2, 0x32, 0x72, 0xB2, 0xF2,
   0x06, 0x46, 0x86, 0xC6, 0x16, 0x56, 0x96, 0xD6,
   0x26, 0x66, 0xA6, 0xE6, 0x36, 0x76, 0xB6, 0xF6,
   0x0A, 0x4A, 0x8A, 0xCA, 0x1A, 0x5A, 0x9A, 0xDA,
   0x2A, 0x6A, 0xAA, 0xEA, 0x3A, 0x7A, 0xBA, 0xFA,
   0x0E, 0x4E, 0x8E, 0xCE, 0x1E, 0x5E, 0x9E, 0xDE,
   0x2E, 0x6E, 0xAE, 0xEE, 0x3E, 0x7E, 0xBE, 0xFE,
   0x03, 0x43, 0x83, 0xC3, 0x13, 0x53, 0x93, 0xD3,
   0x23, 0x63, 0xA3, 0xE3, 0x33, 0x73, 0xB3, 0xF3,
   0x07, 0x47, 0x87, 0xC7, 0x17, 0x57, 0x97, 0xD7,
   0x27, 0x67, 0xA7, 0xE7, 0x37, 0x77, 0xB7, 0xF7,
   0x0B, 0x4B, 0x8B, 0xCB, 0x1B, 0x5B, 0x9B, 0xDB,
   0x2B, 0x6B, 0xAB, 0xEB, 0x3B, 0x7B, 0xBB, 0xFB,
   0x0F, 0x4F, 0x8F, 0xCF, 0x1F, 0x5F, 0x9F, 0xDF,
   0x2F, 0x6F, 0xAF, 0xEF, 0x3F, 0x7F, 0xBF, 0xFF
};

static PNG_CONST png_byte fourbppswaptable[256] = {
   0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
   0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
   0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,
   0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1,
   0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,
   0x82, 0x92, 0xA2, 0xB2, 0xC2, 0xD2, 0xE2, 0xF2,
   0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,
   0x83, 0x93, 0xA3, 0xB3, 0xC3, 0xD3, 0xE3, 0xF3,
   0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74,
   0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4, 0xF4,
   0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,
   0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5,
   0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,
   0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6, 0xF6,
   0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,
   0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7, 0xE7, 0xF7,
   0x08, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78,
   0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8, 0xF8,
   0x09, 0x19, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79,
   0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9, 0xF9,
   0x0A, 0x1A, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A,
   0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA,
   0x0B, 0x1B, 0x2B, 0x3B, 0x4B, 0x5B, 0x6B, 0x7B,
   0x8B, 0x9B, 0xAB, 0xBB, 0xCB, 0xDB, 0xEB, 0xFB,
   0x0C, 0x1C, 0x2C, 0x3C, 0x4C, 0x5C, 0x6C, 0x7C,
   0x8C, 0x9C, 0xAC, 0xBC, 0xCC, 0xDC, 0xEC, 0xFC,
   0x0D, 0x1D, 0x2D, 0x3D, 0x4D, 0x5D, 0x6D, 0x7D,
   0x8D, 0x9D, 0xAD, 0xBD, 0xCD, 0xDD, 0xED, 0xFD,
   0x0E, 0x1E, 0x2E, 0x3E, 0x4E, 0x5E, 0x6E, 0x7E,
   0x8E, 0x9E, 0xAE, 0xBE, 0xCE, 0xDE, 0xEE, 0xFE,
   0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F, 0x7F,
   0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF
};

/* Swaps pixel packing order within bytes */
void /* PRIVATE */
png_do_packswap(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_packswap");

   if (row_info->bit_depth < 8)
   {
      png_bytep rp;
      png_const_bytep end, table;

      end = row + row_info->rowbytes;

      if (row_info->bit_depth == 1)
         table = onebppswaptable;

      else if (row_info->bit_depth == 2)
         table = twobppswaptable;

      else if (row_info->bit_depth == 4)
         table = fourbppswaptable;

      else
         return;

      for (rp = row; rp < end; rp++)
         *rp = table[*rp];
   }
}
#endif /* PACKSWAP || WRITE_PACKSWAP */

#if defined(PNG_WRITE_FILLER_SUPPORTED) || \
    defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
/* Remove a channel - this used to be 'png_do_strip_filler' but it used a
 * somewhat weird combination of flags to determine what to do.  All the calls
 * to png_do_strip_filler are changed in 1.5.2 to call this instead with the
 * correct arguments.
 *
 * The routine isn't general - the channel must be the channel at the start or
 * end (not in the middle) of each pixel.
 */
void /* PRIVATE */
png_do_strip_channel(png_row_infop row_info, png_bytep row, int at_start)
{
   png_bytep sp = row; /* source pointer */
   png_bytep dp = row; /* destination pointer */
   png_bytep ep = row + row_info->rowbytes; /* One beyond end of row */

   /* At the start sp will point to the first byte to copy and dp to where
    * it is copied to.  ep always points just beyond the end of the row, so
    * the loop simply copies (channels-1) channels until sp reaches ep.
    *
    * at_start:        0 -- convert AG, XG, ARGB, XRGB, AAGG, XXGG, etc.
    *            nonzero -- convert GA, GX, RGBA, RGBX, GGAA, RRGGBBXX, etc.
    */

   /* GA, GX, XG cases */
   if (row_info->channels == 2)
   {
      if (row_info->bit_depth == 8)
      {
         if (at_start != 0) /* Skip initial filler */
            ++sp;
         else          /* Skip initial channel and, for sp, the filler */
            sp += 2, ++dp;

         /* For a 1 pixel wide image there is nothing to do */
         while (sp < ep)
            *dp++ = *sp, sp += 2;

         row_info->pixel_depth = 8;
      }

      else if (row_info->bit_depth == 16)
      {
         if (at_start != 0) /* Skip initial filler */
            sp += 2;
         else          /* Skip initial channel and, for sp, the filler */
            sp += 4, dp += 2;

         while (sp < ep)
            *dp++ = *sp++, *dp++ = *sp, sp += 3;

         row_info->pixel_depth = 16;
      }

      else
         return; /* bad bit depth */

      row_info->channels = 1;

      /* Finally fix the color type if it records an alpha channel */
      if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
         row_info->color_type = PNG_COLOR_TYPE_GRAY;
   }

   /* RGBA, RGBX, XRGB cases */
   else if (row_info->channels == 4)
   {
      if (row_info->bit_depth == 8)
      {
         if (at_start != 0) /* Skip initial filler */
            ++sp;
         else          /* Skip initial channels and, for sp, the filler */
            sp += 4, dp += 3;

         /* Note that the loop adds 3 to dp and 4 to sp each time. */
         while (sp < ep)
            *dp++ = *sp++, *dp++ = *sp++, *dp++ = *sp, sp += 2;

         row_info->pixel_depth = 24;
      }

      else if (row_info->bit_depth == 16)
      {
         if (at_start != 0) /* Skip initial filler */
            sp += 2;
         else          /* Skip initial channels and, for sp, the filler */
            sp += 8, dp += 6;

         while (sp < ep)
         {
            /* Copy 6 bytes, skip 2 */
            *dp++ = *sp++, *dp++ = *sp++;
            *dp++ = *sp++, *dp++ = *sp++;
            *dp++ = *sp++, *dp++ = *sp, sp += 3;
         }

         row_info->pixel_depth = 48;
      }

      else
         return; /* bad bit depth */

      row_info->channels = 3;

      /* Finally fix the color type if it records an alpha channel */
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
         row_info->color_type = PNG_COLOR_TYPE_RGB;
   }

   else
      return; /* The filler channel has gone already */

   /* Fix the rowbytes value. */
   row_info->rowbytes = (unsigned int)(dp-row);
}
#endif

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
/* Swaps red and blue bytes within a pixel */
void /* PRIVATE */
png_do_bgr(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_bgr");

   if ((row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)
   {
      png_uint_32 row_width = row_info->width;
      if (row_info->bit_depth == 8)
      {
         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 3)
            {
               png_byte save = *rp;
               *rp = *(rp + 2);
               *(rp + 2) = save;
            }
         }

         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 4)
            {
               png_byte save = *rp;
               *rp = *(rp + 2);
               *(rp + 2) = save;
            }
         }
      }

#ifdef PNG_16BIT_SUPPORTED
      else if (row_info->bit_depth == 16)
      {
         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 6)
            {
               png_byte save = *rp;
               *rp = *(rp + 4);
               *(rp + 4) = save;
               save = *(rp + 1);
               *(rp + 1) = *(rp + 5);
               *(rp + 5) = save;
            }
         }

         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 8)
            {
               png_byte save = *rp;
               *rp = *(rp + 4);
               *(rp + 4) = save;
               save = *(rp + 1);
               *(rp + 1) = *(rp + 5);
               *(rp + 5) = save;
            }
         }
      }
#endif
   }
}
#endif /* READ_BGR || WRITE_BGR */

#if defined(PNG_READ_CHECK_FOR_INVALID_INDEX_SUPPORTED) || \
    defined(PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED)
/* Added at libpng-1.5.10 */
void /* PRIVATE */
png_do_check_palette_indexes(png_structrp png_ptr, png_row_infop row_info)
{
   if (png_ptr->num_palette < (1 << row_info->bit_depth) &&
      png_ptr->num_palette > 0) /* num_palette can be 0 in MNG files */
   {
      /* Calculations moved outside switch in an attempt to stop different
       * compiler warnings.  'padding' is in *bits* within the last byte, it is
       * an 'int' because pixel_depth becomes an 'int' in the expression below,
       * and this calculation is used because it avoids warnings that other
       * forms produced on either GCC or MSVC.
       */
      int padding = PNG_PADBITS(row_info->pixel_depth, row_info->width);
      png_bytep rp = png_ptr->row_buf + row_info->rowbytes;

      switch (row_info->bit_depth)
      {
         case 1:
         {
            /* in this case, all bytes must be 0 so we don't need
             * to unpack the pixels except for the rightmost one.
             */
            for (; rp > png_ptr->row_buf; rp--)
            {
              if ((*rp >> padding) != 0)
                 png_ptr->num_palette_max = 1;
              padding = 0;
            }

            break;
         }

         case 2:
         {
            for (; rp > png_ptr->row_buf; rp--)
            {
              int i = ((*rp >> padding) & 0x03);

              if (i > png_ptr->num_palette_max)
                 png_ptr->num_palette_max = i;

              i = (((*rp >> padding) >> 2) & 0x03);

              if (i > png_ptr->num_palette_max)
                 png_ptr->num_palette_max = i;

              i = (((*rp >> padding) >> 4) & 0x03);

              if (i > png_ptr->num_palette_max)
                 png_ptr->num_palette_max = i;

              i = (((*rp >> padding) >> 6) & 0x03);

              if (i > png_ptr->num_palette_max)
                 png_ptr->num_palette_max = i;

              padding = 0;
            }

            break;
         }

         case 4:
         {
            for (; rp > png_ptr->row_buf; rp--)
            {
              int i = ((*rp >> padding) & 0x0f);

              if (i > png_ptr->num_palette_max)
                 png_ptr->num_palette_max = i;

              i = (((*rp >> padding) >> 4) & 0x0f);

              if (i > png_ptr->num_palette_max)
                 png_ptr->num_palette_max = i;

              padding = 0;
            }

            break;
         }

         case 8:
         {
            for (; rp > png_ptr->row_buf; rp--)
            {
               if (*rp > png_ptr->num_palette_max)
                  png_ptr->num_palette_max = (int) *rp;
            }

            break;
         }

         default:
            break;
      }
   }
}
#endif /* CHECK_FOR_INVALID_INDEX */

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
void PNGAPI
png_set_user_transform_info(png_structrp png_ptr, png_voidp
   user_transform_ptr, int user_transform_depth, int user_transform_channels)
{
   png_debug(1, "in png_set_user_transform_info");

   if (png_ptr == NULL)
      return;

#ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
   if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&
      (png_ptr->flags & PNG_FLAG_ROW_INIT) != 0)
   {
      png_app_error(png_ptr,
          "info change after png_start_read_image or png_read_update_info");
      return;
   }
#endif

   png_ptr->user_transform_ptr = user_transform_ptr;
   png_ptr->user_transform_depth = (png_byte)user_transform_depth;
   png_ptr->user_transform_channels = (png_byte)user_transform_channels;
}
#endif

/* This function returns a pointer to the user_transform_ptr associated with
 * the user transform functions.  The application should free any memory
 * associated with this pointer before png_write_destroy and png_read_destroy
 * are called.
 */
#ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
png_voidp PNGAPI
png_get_user_transform_ptr(png_const_structrp png_ptr)
{
   if (png_ptr == NULL)
      return (NULL);

   return png_ptr->user_transform_ptr;
}
#endif

#ifdef PNG_USER_TRANSFORM_INFO_SUPPORTED
png_uint_32 PNGAPI
png_get_current_row_number(png_const_structrp png_ptr)
{
   /* See the comments in png.h - this is the sub-image row when reading an
    * interlaced image.
    */
   if (png_ptr != NULL)
      return png_ptr->row_number;

   return PNG_UINT_32_MAX; /* help the app not to fail silently */
}

png_byte PNGAPI
png_get_current_pass_number(png_const_structrp png_ptr)
{
   if (png_ptr != NULL)
      return png_ptr->pass;
   return 8; /* invalid */
}
#endif /* USER_TRANSFORM_INFO */
#endif /* READ_USER_TRANSFORM || WRITE_USER_TRANSFORM */
#endif /* READ || WRITE */

```

`ThirdPartyBuild/PNG/Code/pngwio.c`:

```c

/* pngwio.c - functions for data output
 *
 * Last changed in libpng 1.6.24 [August 4, 2016]
 * Copyright (c) 1998-2002,2004,2006-2014,2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 *
 * This file provides a location for all output.  Users who need
 * special handling are expected to write functions that have the same
 * arguments as these and perform similar functions, but that possibly
 * use different output methods.  Note that you shouldn't change these
 * functions, but rather write replacement functions and then change
 * them at run time with png_set_write_fn(...).
 */

#include "pngpriv.h"

#ifdef PNG_WRITE_SUPPORTED

/* Write the data to whatever output you are using.  The default routine
 * writes to a file pointer.  Note that this routine sometimes gets called
 * with very small lengths, so you should implement some kind of simple
 * buffering if you are using unbuffered writes.  This should never be asked
 * to write more than 64K on a 16-bit machine.
 */

void /* PRIVATE */
png_write_data(png_structrp png_ptr, png_const_bytep data, png_size_t length)
{
   /* NOTE: write_data_fn must not change the buffer! */
   if (png_ptr->write_data_fn != NULL )
      (*(png_ptr->write_data_fn))(png_ptr, png_constcast(png_bytep,data),
          length);

   else
      png_error(png_ptr, "Call to NULL write function");
}

#ifdef PNG_STDIO_SUPPORTED
/* This is the function that does the actual writing of data.  If you are
 * not writing to a standard C stream, you should create a replacement
 * write_data function and use it at run time with png_set_write_fn(), rather
 * than changing the library.
 */
void PNGCBAPI
png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_size_t check;

   if (png_ptr == NULL)
      return;

   check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));

   if (check != length)
      png_error(png_ptr, "Write Error");
}
#endif

/* This function is called to output any data pending writing (normally
 * to disk).  After png_flush is called, there should be no data pending
 * writing in any buffers.
 */
#ifdef PNG_WRITE_FLUSH_SUPPORTED
void /* PRIVATE */
png_flush(png_structrp png_ptr)
{
   if (png_ptr->output_flush_fn != NULL)
      (*(png_ptr->output_flush_fn))(png_ptr);
}

#  ifdef PNG_STDIO_SUPPORTED
void PNGCBAPI
png_default_flush(png_structp png_ptr)
{
   png_FILE_p io_ptr;

   if (png_ptr == NULL)
      return;

   io_ptr = png_voidcast(png_FILE_p, (png_ptr->io_ptr));
   fflush(io_ptr);
}
#  endif
#endif

/* This function allows the application to supply new output functions for
 * libpng if standard C streams aren't being used.
 *
 * This function takes as its arguments:
 * png_ptr       - pointer to a png output data structure
 * io_ptr        - pointer to user supplied structure containing info about
 *                 the output functions.  May be NULL.
 * write_data_fn - pointer to a new output function that takes as its
 *                 arguments a pointer to a png_struct, a pointer to
 *                 data to be written, and a 32-bit unsigned int that is
 *                 the number of bytes to be written.  The new write
 *                 function should call png_error(png_ptr, "Error msg")
 *                 to exit and output any fatal error messages.  May be
 *                 NULL, in which case libpng's default function will
 *                 be used.
 * flush_data_fn - pointer to a new flush function that takes as its
 *                 arguments a pointer to a png_struct.  After a call to
 *                 the flush function, there should be no data in any buffers
 *                 or pending transmission.  If the output method doesn't do
 *                 any buffering of output, a function prototype must still be
 *                 supplied although it doesn't have to do anything.  If
 *                 PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
 *                 time, output_flush_fn will be ignored, although it must be
 *                 supplied for compatibility.  May be NULL, in which case
 *                 libpng's default function will be used, if
 *                 PNG_WRITE_FLUSH_SUPPORTED is defined.  This is not
 *                 a good idea if io_ptr does not point to a standard
 *                 *FILE structure.
 */
void PNGAPI
png_set_write_fn(png_structrp png_ptr, png_voidp io_ptr,
    png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
{
   if (png_ptr == NULL)
      return;

   png_ptr->io_ptr = io_ptr;

#ifdef PNG_STDIO_SUPPORTED
   if (write_data_fn != NULL)
      png_ptr->write_data_fn = write_data_fn;

   else
      png_ptr->write_data_fn = png_default_write_data;
#else
   png_ptr->write_data_fn = write_data_fn;
#endif

#ifdef PNG_WRITE_FLUSH_SUPPORTED
#  ifdef PNG_STDIO_SUPPORTED

   if (output_flush_fn != NULL)
      png_ptr->output_flush_fn = output_flush_fn;

   else
      png_ptr->output_flush_fn = png_default_flush;

#  else
   png_ptr->output_flush_fn = output_flush_fn;
#  endif
#else
   PNG_UNUSED(output_flush_fn)
#endif /* WRITE_FLUSH */

#ifdef PNG_READ_SUPPORTED
   /* It is an error to read while writing a png file */
   if (png_ptr->read_data_fn != NULL)
   {
      png_ptr->read_data_fn = NULL;

      png_warning(png_ptr,
          "Can't set both read_data_fn and write_data_fn in the"
          " same structure");
   }
#endif
}
#endif /* WRITE */

```

`ThirdPartyBuild/PNG/Code/pngwrite.c`:

```c

/* pngwrite.c - general routines to write a PNG file
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

#include "pngpriv.h"
#ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
#  include <errno.h>
#endif /* SIMPLIFIED_WRITE_STDIO */

#ifdef PNG_WRITE_SUPPORTED

#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
/* Write out all the unknown chunks for the current given location */
static void
write_unknown_chunks(png_structrp png_ptr, png_const_inforp info_ptr,
    unsigned int where)
{
   if (info_ptr->unknown_chunks_num != 0)
   {
      png_const_unknown_chunkp up;

      png_debug(5, "writing extra chunks");

      for (up = info_ptr->unknown_chunks;
           up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
           ++up)
         if ((up->location & where) != 0)
      {
         /* If per-chunk unknown chunk handling is enabled use it, otherwise
          * just write the chunks the application has set.
          */
#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
         int keep = png_handle_as_unknown(png_ptr, up->name);

         /* NOTE: this code is radically different from the read side in the
          * matter of handling an ancillary unknown chunk.  In the read side
          * the default behavior is to discard it, in the code below the default
          * behavior is to write it.  Critical chunks are, however, only
          * written if explicitly listed or if the default is set to write all
          * unknown chunks.
          *
          * The default handling is also slightly weird - it is not possible to
          * stop the writing of all unsafe-to-copy chunks!
          *
          * TODO: REVIEW: this would seem to be a bug.
          */
         if (keep != PNG_HANDLE_CHUNK_NEVER &&
             ((up->name[3] & 0x20) /* safe-to-copy overrides everything */ ||
              keep == PNG_HANDLE_CHUNK_ALWAYS ||
              (keep == PNG_HANDLE_CHUNK_AS_DEFAULT &&
               png_ptr->unknown_default == PNG_HANDLE_CHUNK_ALWAYS)))
#endif
         {
            /* TODO: review, what is wrong with a zero length unknown chunk? */
            if (up->size == 0)
               png_warning(png_ptr, "Writing zero-length unknown chunk");

            png_write_chunk(png_ptr, up->name, up->data, up->size);
         }
      }
   }
}
#endif /* WRITE_UNKNOWN_CHUNKS */

/* Writes all the PNG information.  This is the suggested way to use the
 * library.  If you have a new chunk to add, make a function to write it,
 * and put it in the correct location here.  If you want the chunk written
 * after the image data, put it in png_write_end().  I strongly encourage
 * you to supply a PNG_INFO_ flag, and check info_ptr->valid before writing
 * the chunk, as that will keep the code from breaking if you want to just
 * write a plain PNG file.  If you have long comments, I suggest writing
 * them in png_write_end(), and compressing them.
 */
void PNGAPI
png_write_info_before_PLTE(png_structrp png_ptr, png_const_inforp info_ptr)
{
   png_debug(1, "in png_write_info_before_PLTE");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if ((png_ptr->mode & PNG_WROTE_INFO_BEFORE_PLTE) == 0)
   {
      /* Write PNG signature */
      png_write_sig(png_ptr);

#ifdef PNG_MNG_FEATURES_SUPPORTED
      if ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) != 0 && \
          png_ptr->mng_features_permitted != 0)
      {
         png_warning(png_ptr,
             "MNG features are not allowed in a PNG datastream");
         png_ptr->mng_features_permitted = 0;
      }
#endif

      /* Write IHDR information. */
      png_write_IHDR(png_ptr, info_ptr->width, info_ptr->height,
          info_ptr->bit_depth, info_ptr->color_type, info_ptr->compression_type,
          info_ptr->filter_type,
#ifdef PNG_WRITE_INTERLACING_SUPPORTED
          info_ptr->interlace_type
#else
          0
#endif
         );

      /* The rest of these check to see if the valid field has the appropriate
       * flag set, and if it does, writes the chunk.
       *
       * 1.6.0: COLORSPACE support controls the writing of these chunks too, and
       * the chunks will be written if the WRITE routine is there and
       * information * is available in the COLORSPACE. (See
       * png_colorspace_sync_info in png.c for where the valid flags get set.)
       *
       * Under certain circumstances the colorspace can be invalidated without
       * syncing the info_struct 'valid' flags; this happens if libpng detects
       * an error and calls png_error while the color space is being set, yet
       * the application continues writing the PNG.  So check the 'invalid'
       * flag here too.
       */
#ifdef PNG_GAMMA_SUPPORTED
#  ifdef PNG_WRITE_gAMA_SUPPORTED
      if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) == 0 &&
          (info_ptr->colorspace.flags & PNG_COLORSPACE_FROM_gAMA) != 0 &&
          (info_ptr->valid & PNG_INFO_gAMA) != 0)
         png_write_gAMA_fixed(png_ptr, info_ptr->colorspace.gamma);
#  endif
#endif

#ifdef PNG_COLORSPACE_SUPPORTED
      /* Write only one of sRGB or an ICC profile.  If a profile was supplied
       * and it matches one of the known sRGB ones issue a warning.
       */
#  ifdef PNG_WRITE_iCCP_SUPPORTED
         if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) == 0 &&
             (info_ptr->valid & PNG_INFO_iCCP) != 0)
         {
#    ifdef PNG_WRITE_sRGB_SUPPORTED
               if ((info_ptr->valid & PNG_INFO_sRGB) != 0)
                  png_app_warning(png_ptr,
                      "profile matches sRGB but writing iCCP instead");
#     endif

            png_write_iCCP(png_ptr, info_ptr->iccp_name,
                info_ptr->iccp_profile);
         }
#     ifdef PNG_WRITE_sRGB_SUPPORTED
         else
#     endif
#  endif

#  ifdef PNG_WRITE_sRGB_SUPPORTED
         if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) == 0 &&
             (info_ptr->valid & PNG_INFO_sRGB) != 0)
            png_write_sRGB(png_ptr, info_ptr->colorspace.rendering_intent);
#  endif /* WRITE_sRGB */
#endif /* COLORSPACE */

#ifdef PNG_WRITE_sBIT_SUPPORTED
         if ((info_ptr->valid & PNG_INFO_sBIT) != 0)
            png_write_sBIT(png_ptr, &(info_ptr->sig_bit), info_ptr->color_type);
#endif

#ifdef PNG_COLORSPACE_SUPPORTED
#  ifdef PNG_WRITE_cHRM_SUPPORTED
         if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) == 0 &&
             (info_ptr->colorspace.flags & PNG_COLORSPACE_FROM_cHRM) != 0 &&
             (info_ptr->valid & PNG_INFO_cHRM) != 0)
            png_write_cHRM_fixed(png_ptr, &info_ptr->colorspace.end_points_xy);
#  endif
#endif

#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
         write_unknown_chunks(png_ptr, info_ptr, PNG_HAVE_IHDR);
#endif

      png_ptr->mode |= PNG_WROTE_INFO_BEFORE_PLTE;
   }
}

void PNGAPI
png_write_info(png_structrp png_ptr, png_const_inforp info_ptr)
{
#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
   int i;
#endif

   png_debug(1, "in png_write_info");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   png_write_info_before_PLTE(png_ptr, info_ptr);

   if ((info_ptr->valid & PNG_INFO_PLTE) != 0)
      png_write_PLTE(png_ptr, info_ptr->palette,
          (png_uint_32)info_ptr->num_palette);

   else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      png_error(png_ptr, "Valid palette required for paletted images");

#ifdef PNG_WRITE_tRNS_SUPPORTED
   if ((info_ptr->valid & PNG_INFO_tRNS) !=0)
   {
#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
      /* Invert the alpha channel (in tRNS) */
      if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0 &&
          info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         int j, jend;

         jend = info_ptr->num_trans;
         if (jend > PNG_MAX_PALETTE_LENGTH)
            jend = PNG_MAX_PALETTE_LENGTH;

         for (j = 0; j<jend; ++j)
            info_ptr->trans_alpha[j] =
               (png_byte)(255 - info_ptr->trans_alpha[j]);
      }
#endif
      png_write_tRNS(png_ptr, info_ptr->trans_alpha, &(info_ptr->trans_color),
          info_ptr->num_trans, info_ptr->color_type);
   }
#endif
#ifdef PNG_WRITE_bKGD_SUPPORTED
   if ((info_ptr->valid & PNG_INFO_bKGD) != 0)
      png_write_bKGD(png_ptr, &(info_ptr->background), info_ptr->color_type);
#endif

#ifdef PNG_WRITE_hIST_SUPPORTED
   if ((info_ptr->valid & PNG_INFO_hIST) != 0)
      png_write_hIST(png_ptr, info_ptr->hist, info_ptr->num_palette);
#endif

#ifdef PNG_WRITE_oFFs_SUPPORTED
   if ((info_ptr->valid & PNG_INFO_oFFs) != 0)
      png_write_oFFs(png_ptr, info_ptr->x_offset, info_ptr->y_offset,
          info_ptr->offset_unit_type);
#endif

#ifdef PNG_WRITE_pCAL_SUPPORTED
   if ((info_ptr->valid & PNG_INFO_pCAL) != 0)
      png_write_pCAL(png_ptr, info_ptr->pcal_purpose, info_ptr->pcal_X0,
          info_ptr->pcal_X1, info_ptr->pcal_type, info_ptr->pcal_nparams,
          info_ptr->pcal_units, info_ptr->pcal_params);
#endif

#ifdef PNG_WRITE_sCAL_SUPPORTED
   if ((info_ptr->valid & PNG_INFO_sCAL) != 0)
      png_write_sCAL_s(png_ptr, (int)info_ptr->scal_unit,
          info_ptr->scal_s_width, info_ptr->scal_s_height);
#endif /* sCAL */

#ifdef PNG_WRITE_pHYs_SUPPORTED
   if ((info_ptr->valid & PNG_INFO_pHYs) != 0)
      png_write_pHYs(png_ptr, info_ptr->x_pixels_per_unit,
          info_ptr->y_pixels_per_unit, info_ptr->phys_unit_type);
#endif /* pHYs */

#ifdef PNG_WRITE_tIME_SUPPORTED
   if ((info_ptr->valid & PNG_INFO_tIME) != 0)
   {
      png_write_tIME(png_ptr, &(info_ptr->mod_time));
      png_ptr->mode |= PNG_WROTE_tIME;
   }
#endif /* tIME */

#ifdef PNG_WRITE_sPLT_SUPPORTED
   if ((info_ptr->valid & PNG_INFO_sPLT) != 0)
      for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
         png_write_sPLT(png_ptr, info_ptr->splt_palettes + i);
#endif /* sPLT */

#ifdef PNG_WRITE_TEXT_SUPPORTED
   /* Check to see if we need to write text chunks */
   for (i = 0; i < info_ptr->num_text; i++)
   {
      png_debug2(2, "Writing header text chunk %d, type %d", i,
          info_ptr->text[i].compression);
      /* An internationalized chunk? */
      if (info_ptr->text[i].compression > 0)
      {
#ifdef PNG_WRITE_iTXt_SUPPORTED
         /* Write international chunk */
         png_write_iTXt(png_ptr,
             info_ptr->text[i].compression,
             info_ptr->text[i].key,
             info_ptr->text[i].lang,
             info_ptr->text[i].lang_key,
             info_ptr->text[i].text);
         /* Mark this chunk as written */
         if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
         else
            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
#else
         png_warning(png_ptr, "Unable to write international text");
#endif
      }

      /* If we want a compressed text chunk */
      else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_zTXt)
      {
#ifdef PNG_WRITE_zTXt_SUPPORTED
         /* Write compressed chunk */
         png_write_zTXt(png_ptr, info_ptr->text[i].key,
             info_ptr->text[i].text, info_ptr->text[i].compression);
         /* Mark this chunk as written */
         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
#else
         png_warning(png_ptr, "Unable to write compressed text");
#endif
      }

      else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
      {
#ifdef PNG_WRITE_tEXt_SUPPORTED
         /* Write uncompressed chunk */
         png_write_tEXt(png_ptr, info_ptr->text[i].key,
             info_ptr->text[i].text,
             0);
         /* Mark this chunk as written */
         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
#else
         /* Can't get here */
         png_warning(png_ptr, "Unable to write uncompressed text");
#endif
      }
   }
#endif /* tEXt */

#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
   write_unknown_chunks(png_ptr, info_ptr, PNG_HAVE_PLTE);
#endif
}

/* Writes the end of the PNG file.  If you don't want to write comments or
 * time information, you can pass NULL for info.  If you already wrote these
 * in png_write_info(), do not write them again here.  If you have long
 * comments, I suggest writing them here, and compressing them.
 */
void PNGAPI
png_write_end(png_structrp png_ptr, png_inforp info_ptr)
{
   png_debug(1, "in png_write_end");

   if (png_ptr == NULL)
      return;

   if ((png_ptr->mode & PNG_HAVE_IDAT) == 0)
      png_error(png_ptr, "No IDATs written into file");

#ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
   if (png_ptr->num_palette_max > png_ptr->num_palette)
      png_benign_error(png_ptr, "Wrote palette index exceeding num_palette");
#endif

   /* See if user wants us to write information chunks */
   if (info_ptr != NULL)
   {
#ifdef PNG_WRITE_TEXT_SUPPORTED
      int i; /* local index variable */
#endif
#ifdef PNG_WRITE_tIME_SUPPORTED
      /* Check to see if user has supplied a time chunk */
      if ((info_ptr->valid & PNG_INFO_tIME) != 0 &&
          (png_ptr->mode & PNG_WROTE_tIME) == 0)
         png_write_tIME(png_ptr, &(info_ptr->mod_time));

#endif
#ifdef PNG_WRITE_TEXT_SUPPORTED
      /* Loop through comment chunks */
      for (i = 0; i < info_ptr->num_text; i++)
      {
         png_debug2(2, "Writing trailer text chunk %d, type %d", i,
             info_ptr->text[i].compression);
         /* An internationalized chunk? */
         if (info_ptr->text[i].compression > 0)
         {
#ifdef PNG_WRITE_iTXt_SUPPORTED
            /* Write international chunk */
            png_write_iTXt(png_ptr,
                info_ptr->text[i].compression,
                info_ptr->text[i].key,
                info_ptr->text[i].lang,
                info_ptr->text[i].lang_key,
                info_ptr->text[i].text);
            /* Mark this chunk as written */
            if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
               info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
            else
               info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
#else
            png_warning(png_ptr, "Unable to write international text");
#endif
         }

         else if (info_ptr->text[i].compression >= PNG_TEXT_COMPRESSION_zTXt)
         {
#ifdef PNG_WRITE_zTXt_SUPPORTED
            /* Write compressed chunk */
            png_write_zTXt(png_ptr, info_ptr->text[i].key,
                info_ptr->text[i].text, info_ptr->text[i].compression);
            /* Mark this chunk as written */
            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
#else
            png_warning(png_ptr, "Unable to write compressed text");
#endif
         }

         else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
         {
#ifdef PNG_WRITE_tEXt_SUPPORTED
            /* Write uncompressed chunk */
            png_write_tEXt(png_ptr, info_ptr->text[i].key,
                info_ptr->text[i].text, 0);
            /* Mark this chunk as written */
            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
#else
            png_warning(png_ptr, "Unable to write uncompressed text");
#endif
         }
      }
#endif
#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
      write_unknown_chunks(png_ptr, info_ptr, PNG_AFTER_IDAT);
#endif
   }

   png_ptr->mode |= PNG_AFTER_IDAT;

   /* Write end of PNG file */
   png_write_IEND(png_ptr);

   /* This flush, added in libpng-1.0.8, removed from libpng-1.0.9beta03,
    * and restored again in libpng-1.2.30, may cause some applications that
    * do not set png_ptr->output_flush_fn to crash.  If your application
    * experiences a problem, please try building libpng with
    * PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED defined, and report the event to
    * png-mng-implement at lists.sf.net .
    */
#ifdef PNG_WRITE_FLUSH_SUPPORTED
#  ifdef PNG_WRITE_FLUSH_AFTER_IEND_SUPPORTED
   png_flush(png_ptr);
#  endif
#endif
}

#ifdef PNG_CONVERT_tIME_SUPPORTED
void PNGAPI
png_convert_from_struct_tm(png_timep ptime, PNG_CONST struct tm * ttime)
{
   png_debug(1, "in png_convert_from_struct_tm");

   ptime->year = (png_uint_16)(1900 + ttime->tm_year);
   ptime->month = (png_byte)(ttime->tm_mon + 1);
   ptime->day = (png_byte)ttime->tm_mday;
   ptime->hour = (png_byte)ttime->tm_hour;
   ptime->minute = (png_byte)ttime->tm_min;
   ptime->second = (png_byte)ttime->tm_sec;
}

void PNGAPI
png_convert_from_time_t(png_timep ptime, time_t ttime)
{
   struct tm *tbuf;

   png_debug(1, "in png_convert_from_time_t");

   tbuf = gmtime(&ttime);
   png_convert_from_struct_tm(ptime, tbuf);
}
#endif

/* Initialize png_ptr structure, and allocate any memory needed */
PNG_FUNCTION(png_structp,PNGAPI
png_create_write_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
{
#ifndef PNG_USER_MEM_SUPPORTED
   png_structrp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
       error_fn, warn_fn, NULL, NULL, NULL);
#else
   return png_create_write_struct_2(user_png_ver, error_ptr, error_fn,
       warn_fn, NULL, NULL, NULL);
}

/* Alternate initialize png_ptr structure, and allocate any memory needed */
PNG_FUNCTION(png_structp,PNGAPI
png_create_write_struct_2,(png_const_charp user_png_ver, png_voidp error_ptr,
    png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
    png_malloc_ptr malloc_fn, png_free_ptr free_fn),PNG_ALLOCATED)
{
   png_structrp png_ptr = png_create_png_struct(user_png_ver, error_ptr,
       error_fn, warn_fn, mem_ptr, malloc_fn, free_fn);
#endif /* USER_MEM */
   if (png_ptr != NULL)
   {
      /* Set the zlib control values to defaults; they can be overridden by the
       * application after the struct has been created.
       */
      png_ptr->zbuffer_size = PNG_ZBUF_SIZE;

      /* The 'zlib_strategy' setting is irrelevant because png_default_claim in
       * pngwutil.c defaults it according to whether or not filters will be
       * used, and ignores this setting.
       */
      png_ptr->zlib_strategy = PNG_Z_DEFAULT_STRATEGY;
      png_ptr->zlib_level = PNG_Z_DEFAULT_COMPRESSION;
      png_ptr->zlib_mem_level = 8;
      png_ptr->zlib_window_bits = 15;
      png_ptr->zlib_method = 8;

#ifdef PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
      png_ptr->zlib_text_strategy = PNG_TEXT_Z_DEFAULT_STRATEGY;
      png_ptr->zlib_text_level = PNG_TEXT_Z_DEFAULT_COMPRESSION;
      png_ptr->zlib_text_mem_level = 8;
      png_ptr->zlib_text_window_bits = 15;
      png_ptr->zlib_text_method = 8;
#endif /* WRITE_COMPRESSED_TEXT */

      /* This is a highly dubious configuration option; by default it is off,
       * but it may be appropriate for private builds that are testing
       * extensions not conformant to the current specification, or of
       * applications that must not fail to write at all costs!
       */
#ifdef PNG_BENIGN_WRITE_ERRORS_SUPPORTED
      /* In stable builds only warn if an application error can be completely
       * handled.
       */
      png_ptr->flags |= PNG_FLAG_BENIGN_ERRORS_WARN;
#endif

      /* App warnings are warnings in release (or release candidate) builds but
       * are errors during development.
       */
#if PNG_RELEASE_BUILD
      png_ptr->flags |= PNG_FLAG_APP_WARNINGS_WARN;
#endif

      /* TODO: delay this, it can be done in png_init_io() (if the app doesn't
       * do it itself) avoiding setting the default function if it is not
       * required.
       */
      png_set_write_fn(png_ptr, NULL, NULL, NULL);
   }

   return png_ptr;
}


/* Write a few rows of image data.  If the image is interlaced,
 * either you will have to write the 7 sub images, or, if you
 * have called png_set_interlace_handling(), you will have to
 * "write" the image seven times.
 */
void PNGAPI
png_write_rows(png_structrp png_ptr, png_bytepp row,
    png_uint_32 num_rows)
{
   png_uint_32 i; /* row counter */
   png_bytepp rp; /* row pointer */

   png_debug(1, "in png_write_rows");

   if (png_ptr == NULL)
      return;

   /* Loop through the rows */
   for (i = 0, rp = row; i < num_rows; i++, rp++)
   {
      png_write_row(png_ptr, *rp);
   }
}

/* Write the image.  You only need to call this function once, even
 * if you are writing an interlaced image.
 */
void PNGAPI
png_write_image(png_structrp png_ptr, png_bytepp image)
{
   png_uint_32 i; /* row index */
   int pass, num_pass; /* pass variables */
   png_bytepp rp; /* points to current row */

   if (png_ptr == NULL)
      return;

   png_debug(1, "in png_write_image");

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* Initialize interlace handling.  If image is not interlaced,
    * this will set pass to 1
    */
   num_pass = png_set_interlace_handling(png_ptr);
#else
   num_pass = 1;
#endif
   /* Loop through passes */
   for (pass = 0; pass < num_pass; pass++)
   {
      /* Loop through image */
      for (i = 0, rp = image; i < png_ptr->height; i++, rp++)
      {
         png_write_row(png_ptr, *rp);
      }
   }
}

#ifdef PNG_MNG_FEATURES_SUPPORTED
/* Performs intrapixel differencing  */
static void
png_do_write_intrapixel(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_write_intrapixel");

   if ((row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)
   {
      int bytes_per_pixel;
      png_uint_32 row_width = row_info->width;
      if (row_info->bit_depth == 8)
      {
         png_bytep rp;
         png_uint_32 i;

         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
            bytes_per_pixel = 3;

         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            bytes_per_pixel = 4;

         else
            return;

         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
         {
            *(rp)     = (png_byte)(*rp       - *(rp + 1));
            *(rp + 2) = (png_byte)(*(rp + 2) - *(rp + 1));
         }
      }

#ifdef PNG_WRITE_16BIT_SUPPORTED
      else if (row_info->bit_depth == 16)
      {
         png_bytep rp;
         png_uint_32 i;

         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
            bytes_per_pixel = 6;

         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            bytes_per_pixel = 8;

         else
            return;

         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
         {
            png_uint_32 s0   = (png_uint_32)(*(rp    ) << 8) | *(rp + 1);
            png_uint_32 s1   = (png_uint_32)(*(rp + 2) << 8) | *(rp + 3);
            png_uint_32 s2   = (png_uint_32)(*(rp + 4) << 8) | *(rp + 5);
            png_uint_32 red  = (png_uint_32)((s0 - s1) & 0xffffL);
            png_uint_32 blue = (png_uint_32)((s2 - s1) & 0xffffL);
            *(rp    ) = (png_byte)(red >> 8);
            *(rp + 1) = (png_byte)red;
            *(rp + 4) = (png_byte)(blue >> 8);
            *(rp + 5) = (png_byte)blue;
         }
      }
#endif /* WRITE_16BIT */
   }
}
#endif /* MNG_FEATURES */

/* Called by user to write a row of image data */
void PNGAPI
png_write_row(png_structrp png_ptr, png_const_bytep row)
{
   /* 1.5.6: moved from png_struct to be a local structure: */
   png_row_info row_info;

   if (png_ptr == NULL)
      return;

   png_debug2(1, "in png_write_row (row %u, pass %d)",
       png_ptr->row_number, png_ptr->pass);

   /* Initialize transformations and other stuff if first time */
   if (png_ptr->row_number == 0 && png_ptr->pass == 0)
   {
      /* Make sure we wrote the header info */
      if ((png_ptr->mode & PNG_WROTE_INFO_BEFORE_PLTE) == 0)
         png_error(png_ptr,
             "png_write_info was never called before png_write_row");

      /* Check for transforms that have been set but were defined out */
#if !defined(PNG_WRITE_INVERT_SUPPORTED) && defined(PNG_READ_INVERT_SUPPORTED)
      if ((png_ptr->transformations & PNG_INVERT_MONO) != 0)
         png_warning(png_ptr, "PNG_WRITE_INVERT_SUPPORTED is not defined");
#endif

#if !defined(PNG_WRITE_FILLER_SUPPORTED) && defined(PNG_READ_FILLER_SUPPORTED)
      if ((png_ptr->transformations & PNG_FILLER) != 0)
         png_warning(png_ptr, "PNG_WRITE_FILLER_SUPPORTED is not defined");
#endif
#if !defined(PNG_WRITE_PACKSWAP_SUPPORTED) && \
    defined(PNG_READ_PACKSWAP_SUPPORTED)
      if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
         png_warning(png_ptr,
             "PNG_WRITE_PACKSWAP_SUPPORTED is not defined");
#endif

#if !defined(PNG_WRITE_PACK_SUPPORTED) && defined(PNG_READ_PACK_SUPPORTED)
      if ((png_ptr->transformations & PNG_PACK) != 0)
         png_warning(png_ptr, "PNG_WRITE_PACK_SUPPORTED is not defined");
#endif

#if !defined(PNG_WRITE_SHIFT_SUPPORTED) && defined(PNG_READ_SHIFT_SUPPORTED)
      if ((png_ptr->transformations & PNG_SHIFT) != 0)
         png_warning(png_ptr, "PNG_WRITE_SHIFT_SUPPORTED is not defined");
#endif

#if !defined(PNG_WRITE_BGR_SUPPORTED) && defined(PNG_READ_BGR_SUPPORTED)
      if ((png_ptr->transformations & PNG_BGR) != 0)
         png_warning(png_ptr, "PNG_WRITE_BGR_SUPPORTED is not defined");
#endif

#if !defined(PNG_WRITE_SWAP_SUPPORTED) && defined(PNG_READ_SWAP_SUPPORTED)
      if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)
         png_warning(png_ptr, "PNG_WRITE_SWAP_SUPPORTED is not defined");
#endif

      png_write_start_row(png_ptr);
   }

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* If interlaced and not interested in row, return */
   if (png_ptr->interlaced != 0 &&
       (png_ptr->transformations & PNG_INTERLACE) != 0)
   {
      switch (png_ptr->pass)
      {
         case 0:
            if ((png_ptr->row_number & 0x07) != 0)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;

         case 1:
            if ((png_ptr->row_number & 0x07) != 0 || png_ptr->width < 5)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;

         case 2:
            if ((png_ptr->row_number & 0x07) != 4)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;

         case 3:
            if ((png_ptr->row_number & 0x03) != 0 || png_ptr->width < 3)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;

         case 4:
            if ((png_ptr->row_number & 0x03) != 2)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;

         case 5:
            if ((png_ptr->row_number & 0x01) != 0 || png_ptr->width < 2)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;

         case 6:
            if ((png_ptr->row_number & 0x01) == 0)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;

         default: /* error: ignore it */
            break;
      }
   }
#endif

   /* Set up row info for transformations */
   row_info.color_type = png_ptr->color_type;
   row_info.width = png_ptr->usr_width;
   row_info.channels = png_ptr->usr_channels;
   row_info.bit_depth = png_ptr->usr_bit_depth;
   row_info.pixel_depth = (png_byte)(row_info.bit_depth * row_info.channels);
   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);

   png_debug1(3, "row_info->color_type = %d", row_info.color_type);
   png_debug1(3, "row_info->width = %u", row_info.width);
   png_debug1(3, "row_info->channels = %d", row_info.channels);
   png_debug1(3, "row_info->bit_depth = %d", row_info.bit_depth);
   png_debug1(3, "row_info->pixel_depth = %d", row_info.pixel_depth);
   png_debug1(3, "row_info->rowbytes = %lu", (unsigned long)row_info.rowbytes);

   /* Copy user's row into buffer, leaving room for filter byte. */
   memcpy(png_ptr->row_buf + 1, row, row_info.rowbytes);

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* Handle interlacing */
   if (png_ptr->interlaced && png_ptr->pass < 6 &&
       (png_ptr->transformations & PNG_INTERLACE) != 0)
   {
      png_do_write_interlace(&row_info, png_ptr->row_buf + 1, png_ptr->pass);
      /* This should always get caught above, but still ... */
      if (row_info.width == 0)
      {
         png_write_finish_row(png_ptr);
         return;
      }
   }
#endif

#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED
   /* Handle other transformations */
   if (png_ptr->transformations != 0)
      png_do_write_transformations(png_ptr, &row_info);
#endif

   /* At this point the row_info pixel depth must match the 'transformed' depth,
    * which is also the output depth.
    */
   if (row_info.pixel_depth != png_ptr->pixel_depth ||
       row_info.pixel_depth != png_ptr->transformed_pixel_depth)
      png_error(png_ptr, "internal write transform logic error");

#ifdef PNG_MNG_FEATURES_SUPPORTED
   /* Write filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not write a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA
    */
   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) != 0 &&
       (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
   {
      /* Intrapixel differencing */
      png_do_write_intrapixel(&row_info, png_ptr->row_buf + 1);
   }
#endif

/* Added at libpng-1.5.10 */
#ifdef PNG_WRITE_CHECK_FOR_INVALID_INDEX_SUPPORTED
   /* Check for out-of-range palette index */
   if (row_info.color_type == PNG_COLOR_TYPE_PALETTE &&
       png_ptr->num_palette_max >= 0)
      png_do_check_palette_indexes(png_ptr, &row_info);
#endif

   /* Find a filter if necessary, filter the row and write it out. */
   png_write_find_filter(png_ptr, &row_info);

   if (png_ptr->write_row_fn != NULL)
      (*(png_ptr->write_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
}

#ifdef PNG_WRITE_FLUSH_SUPPORTED
/* Set the automatic flush interval or 0 to turn flushing off */
void PNGAPI
png_set_flush(png_structrp png_ptr, int nrows)
{
   png_debug(1, "in png_set_flush");

   if (png_ptr == NULL)
      return;

   png_ptr->flush_dist = (nrows < 0 ? 0 : (png_uint_32)nrows);
}

/* Flush the current output buffers now */
void PNGAPI
png_write_flush(png_structrp png_ptr)
{
   png_debug(1, "in png_write_flush");

   if (png_ptr == NULL)
      return;

   /* We have already written out all of the data */
   if (png_ptr->row_number >= png_ptr->num_rows)
      return;

   png_compress_IDAT(png_ptr, NULL, 0, Z_SYNC_FLUSH);
   png_ptr->flush_rows = 0;
   png_flush(png_ptr);
}
#endif /* WRITE_FLUSH */

/* Free any memory used in png_ptr struct without freeing the struct itself. */
static void
png_write_destroy(png_structrp png_ptr)
{
   png_debug(1, "in png_write_destroy");

   /* Free any memory zlib uses */
   if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
      deflateEnd(&png_ptr->zstream);

   /* Free our memory.  png_free checks NULL for us. */
   png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list);
   png_free(png_ptr, png_ptr->row_buf);
   png_ptr->row_buf = NULL;
#ifdef PNG_WRITE_FILTER_SUPPORTED
   png_free(png_ptr, png_ptr->prev_row);
   png_free(png_ptr, png_ptr->try_row);
   png_free(png_ptr, png_ptr->tst_row);
   png_ptr->prev_row = NULL;
   png_ptr->try_row = NULL;
   png_ptr->tst_row = NULL;
#endif

#ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
   png_free(png_ptr, png_ptr->chunk_list);
   png_ptr->chunk_list = NULL;
#endif

   /* The error handling and memory handling information is left intact at this
    * point: the jmp_buf may still have to be freed.  See png_destroy_png_struct
    * for how this happens.
    */
}

/* Free all memory used by the write.
 * In libpng 1.6.0 this API changed quietly to no longer accept a NULL value for
 * *png_ptr_ptr.  Prior to 1.6.0 it would accept such a value and it would free
 * the passed in info_structs but it would quietly fail to free any of the data
 * inside them.  In 1.6.0 it quietly does nothing (it has to be quiet because it
 * has no png_ptr.)
 */
void PNGAPI
png_destroy_write_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr)
{
   png_debug(1, "in png_destroy_write_struct");

   if (png_ptr_ptr != NULL)
   {
      png_structrp png_ptr = *png_ptr_ptr;

      if (png_ptr != NULL) /* added in libpng 1.6.0 */
      {
         png_destroy_info_struct(png_ptr, info_ptr_ptr);

         *png_ptr_ptr = NULL;
         png_write_destroy(png_ptr);
         png_destroy_png_struct(png_ptr);
      }
   }
}

/* Allow the application to select one or more row filters to use. */
void PNGAPI
png_set_filter(png_structrp png_ptr, int method, int filters)
{
   png_debug(1, "in png_set_filter");

   if (png_ptr == NULL)
      return;

#ifdef PNG_MNG_FEATURES_SUPPORTED
   if ((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) != 0 &&
       (method == PNG_INTRAPIXEL_DIFFERENCING))
      method = PNG_FILTER_TYPE_BASE;

#endif
   if (method == PNG_FILTER_TYPE_BASE)
   {
      switch (filters & (PNG_ALL_FILTERS | 0x07))
      {
#ifdef PNG_WRITE_FILTER_SUPPORTED
         case 5:
         case 6:
         case 7: png_app_error(png_ptr, "Unknown row filter for method 0");
            /* FALL THROUGH */
#endif /* WRITE_FILTER */
         case PNG_FILTER_VALUE_NONE:
            png_ptr->do_filter = PNG_FILTER_NONE; break;

#ifdef PNG_WRITE_FILTER_SUPPORTED
         case PNG_FILTER_VALUE_SUB:
            png_ptr->do_filter = PNG_FILTER_SUB; break;

         case PNG_FILTER_VALUE_UP:
            png_ptr->do_filter = PNG_FILTER_UP; break;

         case PNG_FILTER_VALUE_AVG:
            png_ptr->do_filter = PNG_FILTER_AVG; break;

         case PNG_FILTER_VALUE_PAETH:
            png_ptr->do_filter = PNG_FILTER_PAETH; break;

         default:
            png_ptr->do_filter = (png_byte)filters; break;
#else
         default:
            png_app_error(png_ptr, "Unknown row filter for method 0");
#endif /* WRITE_FILTER */
      }

#ifdef PNG_WRITE_FILTER_SUPPORTED
      /* If we have allocated the row_buf, this means we have already started
       * with the image and we should have allocated all of the filter buffers
       * that have been selected.  If prev_row isn't already allocated, then
       * it is too late to start using the filters that need it, since we
       * will be missing the data in the previous row.  If an application
       * wants to start and stop using particular filters during compression,
       * it should start out with all of the filters, and then remove them
       * or add them back after the start of compression.
       *
       * NOTE: this is a nasty constraint on the code, because it means that the
       * prev_row buffer must be maintained even if there are currently no
       * 'prev_row' requiring filters active.
       */
      if (png_ptr->row_buf != NULL)
      {
         int num_filters;
         png_alloc_size_t buf_size;

         /* Repeat the checks in png_write_start_row; 1 pixel high or wide
          * images cannot benefit from certain filters.  If this isn't done here
          * the check below will fire on 1 pixel high images.
          */
         if (png_ptr->height == 1)
            filters &= ~(PNG_FILTER_UP|PNG_FILTER_AVG|PNG_FILTER_PAETH);

         if (png_ptr->width == 1)
            filters &= ~(PNG_FILTER_SUB|PNG_FILTER_AVG|PNG_FILTER_PAETH);

         if ((filters & (PNG_FILTER_UP|PNG_FILTER_AVG|PNG_FILTER_PAETH)) != 0
            && png_ptr->prev_row == NULL)
         {
            /* This is the error case, however it is benign - the previous row
             * is not available so the filter can't be used.  Just warn here.
             */
            png_app_warning(png_ptr,
                "png_set_filter: UP/AVG/PAETH cannot be added after start");
            filters &= ~(PNG_FILTER_UP|PNG_FILTER_AVG|PNG_FILTER_PAETH);
         }

         num_filters = 0;

         if (filters & PNG_FILTER_SUB)
            num_filters++;

         if (filters & PNG_FILTER_UP)
            num_filters++;

         if (filters & PNG_FILTER_AVG)
            num_filters++;

         if (filters & PNG_FILTER_PAETH)
            num_filters++;

         /* Allocate needed row buffers if they have not already been
          * allocated.
          */
         buf_size = PNG_ROWBYTES(png_ptr->usr_channels * png_ptr->usr_bit_depth,
             png_ptr->width) + 1;

         if (png_ptr->try_row == NULL)
            png_ptr->try_row = png_voidcast(png_bytep,
                png_malloc(png_ptr, buf_size));

         if (num_filters > 1)
         {
            if (png_ptr->tst_row == NULL)
               png_ptr->tst_row = png_voidcast(png_bytep,
                   png_malloc(png_ptr, buf_size));
         }
      }
      png_ptr->do_filter = (png_byte)filters;
#endif
   }
   else
      png_error(png_ptr, "Unknown custom filter method");
}

#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED /* DEPRECATED */
/* Provide floating and fixed point APIs */
#ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_filter_heuristics(png_structrp png_ptr, int heuristic_method,
    int num_weights, png_const_doublep filter_weights,
    png_const_doublep filter_costs)
{
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(heuristic_method)
   PNG_UNUSED(num_weights)
   PNG_UNUSED(filter_weights)
   PNG_UNUSED(filter_costs)
}
#endif /* FLOATING_POINT */

#ifdef PNG_FIXED_POINT_SUPPORTED
void PNGAPI
png_set_filter_heuristics_fixed(png_structrp png_ptr, int heuristic_method,
    int num_weights, png_const_fixed_point_p filter_weights,
    png_const_fixed_point_p filter_costs)
{
   PNG_UNUSED(png_ptr)
   PNG_UNUSED(heuristic_method)
   PNG_UNUSED(num_weights)
   PNG_UNUSED(filter_weights)
   PNG_UNUSED(filter_costs)
}
#endif /* FIXED_POINT */
#endif /* WRITE_WEIGHTED_FILTER */

#ifdef PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
void PNGAPI
png_set_compression_level(png_structrp png_ptr, int level)
{
   png_debug(1, "in png_set_compression_level");

   if (png_ptr == NULL)
      return;

   png_ptr->zlib_level = level;
}

void PNGAPI
png_set_compression_mem_level(png_structrp png_ptr, int mem_level)
{
   png_debug(1, "in png_set_compression_mem_level");

   if (png_ptr == NULL)
      return;

   png_ptr->zlib_mem_level = mem_level;
}

void PNGAPI
png_set_compression_strategy(png_structrp png_ptr, int strategy)
{
   png_debug(1, "in png_set_compression_strategy");

   if (png_ptr == NULL)
      return;

   /* The flag setting here prevents the libpng dynamic selection of strategy.
    */
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_STRATEGY;
   png_ptr->zlib_strategy = strategy;
}

/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 */
void PNGAPI
png_set_compression_window_bits(png_structrp png_ptr, int window_bits)
{
   if (png_ptr == NULL)
      return;

   /* Prior to 1.6.0 this would warn but then set the window_bits value. This
    * meant that negative window bits values could be selected that would cause
    * libpng to write a non-standard PNG file with raw deflate or gzip
    * compressed IDAT or ancillary chunks.  Such files can be read and there is
    * no warning on read, so this seems like a very bad idea.
    */
   if (window_bits > 15)
   {
      png_warning(png_ptr, "Only compression windows <= 32k supported by PNG");
      window_bits = 15;
   }

   else if (window_bits < 8)
   {
      png_warning(png_ptr, "Only compression windows >= 256 supported by PNG");
      window_bits = 8;
   }

   png_ptr->zlib_window_bits = window_bits;
}

void PNGAPI
png_set_compression_method(png_structrp png_ptr, int method)
{
   png_debug(1, "in png_set_compression_method");

   if (png_ptr == NULL)
      return;

   /* This would produce an invalid PNG file if it worked, but it doesn't and
    * deflate will fault it, so it is harmless to just warn here.
    */
   if (method != 8)
      png_warning(png_ptr, "Only compression method 8 is supported by PNG");

   png_ptr->zlib_method = method;
}
#endif /* WRITE_CUSTOMIZE_COMPRESSION */

/* The following were added to libpng-1.5.4 */
#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
void PNGAPI
png_set_text_compression_level(png_structrp png_ptr, int level)
{
   png_debug(1, "in png_set_text_compression_level");

   if (png_ptr == NULL)
      return;

   png_ptr->zlib_text_level = level;
}

void PNGAPI
png_set_text_compression_mem_level(png_structrp png_ptr, int mem_level)
{
   png_debug(1, "in png_set_text_compression_mem_level");

   if (png_ptr == NULL)
      return;

   png_ptr->zlib_text_mem_level = mem_level;
}

void PNGAPI
png_set_text_compression_strategy(png_structrp png_ptr, int strategy)
{
   png_debug(1, "in png_set_text_compression_strategy");

   if (png_ptr == NULL)
      return;

   png_ptr->zlib_text_strategy = strategy;
}

/* If PNG_WRITE_OPTIMIZE_CMF_SUPPORTED is defined, libpng will use a
 * smaller value of window_bits if it can do so safely.
 */
void PNGAPI
png_set_text_compression_window_bits(png_structrp png_ptr, int window_bits)
{
   if (png_ptr == NULL)
      return;

   if (window_bits > 15)
   {
      png_warning(png_ptr, "Only compression windows <= 32k supported by PNG");
      window_bits = 15;
   }

   else if (window_bits < 8)
   {
      png_warning(png_ptr, "Only compression windows >= 256 supported by PNG");
      window_bits = 8;
   }

   png_ptr->zlib_text_window_bits = window_bits;
}

void PNGAPI
png_set_text_compression_method(png_structrp png_ptr, int method)
{
   png_debug(1, "in png_set_text_compression_method");

   if (png_ptr == NULL)
      return;

   if (method != 8)
      png_warning(png_ptr, "Only compression method 8 is supported by PNG");

   png_ptr->zlib_text_method = method;
}
#endif /* WRITE_CUSTOMIZE_ZTXT_COMPRESSION */
/* end of API added to libpng-1.5.4 */

void PNGAPI
png_set_write_status_fn(png_structrp png_ptr, png_write_status_ptr write_row_fn)
{
   if (png_ptr == NULL)
      return;

   png_ptr->write_row_fn = write_row_fn;
}

#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
void PNGAPI
png_set_write_user_transform_fn(png_structrp png_ptr, png_user_transform_ptr
    write_user_transform_fn)
{
   png_debug(1, "in png_set_write_user_transform_fn");

   if (png_ptr == NULL)
      return;

   png_ptr->transformations |= PNG_USER_TRANSFORM;
   png_ptr->write_user_transform_fn = write_user_transform_fn;
}
#endif


#ifdef PNG_INFO_IMAGE_SUPPORTED
void PNGAPI
png_write_png(png_structrp png_ptr, png_inforp info_ptr,
    int transforms, voidp params)
{
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if ((info_ptr->valid & PNG_INFO_IDAT) == 0)
   {
      png_app_error(png_ptr, "no rows for png_write_image to write");
      return;
   }

   /* Write the file header information. */
   png_write_info(png_ptr, info_ptr);

   /* ------ these transformations don't touch the info structure ------- */

   /* Invert monochrome pixels */
   if ((transforms & PNG_TRANSFORM_INVERT_MONO) != 0)
#ifdef PNG_WRITE_INVERT_SUPPORTED
      png_set_invert_mono(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_INVERT_MONO not supported");
#endif

   /* Shift the pixels up to a legal bit depth and fill in
    * as appropriate to correctly scale the image.
    */
   if ((transforms & PNG_TRANSFORM_SHIFT) != 0)
#ifdef PNG_WRITE_SHIFT_SUPPORTED
      if ((info_ptr->valid & PNG_INFO_sBIT) != 0)
         png_set_shift(png_ptr, &info_ptr->sig_bit);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_SHIFT not supported");
#endif

   /* Pack pixels into bytes */
   if ((transforms & PNG_TRANSFORM_PACKING) != 0)
#ifdef PNG_WRITE_PACK_SUPPORTED
      png_set_packing(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_PACKING not supported");
#endif

   /* Swap location of alpha bytes from ARGB to RGBA */
   if ((transforms & PNG_TRANSFORM_SWAP_ALPHA) != 0)
#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
      png_set_swap_alpha(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_SWAP_ALPHA not supported");
#endif

   /* Remove a filler (X) from XRGB/RGBX/AG/GA into to convert it into
    * RGB, note that the code expects the input color type to be G or RGB; no
    * alpha channel.
    */
   if ((transforms & (PNG_TRANSFORM_STRIP_FILLER_AFTER|
       PNG_TRANSFORM_STRIP_FILLER_BEFORE)) != 0)
   {
#ifdef PNG_WRITE_FILLER_SUPPORTED
      if ((transforms & PNG_TRANSFORM_STRIP_FILLER_AFTER) != 0)
      {
         if ((transforms & PNG_TRANSFORM_STRIP_FILLER_BEFORE) != 0)
            png_app_error(png_ptr,
                "PNG_TRANSFORM_STRIP_FILLER: BEFORE+AFTER not supported");

         /* Continue if ignored - this is the pre-1.6.10 behavior */
         png_set_filler(png_ptr, 0, PNG_FILLER_AFTER);
      }

      else if ((transforms & PNG_TRANSFORM_STRIP_FILLER_BEFORE) != 0)
         png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_STRIP_FILLER not supported");
#endif
   }

   /* Flip BGR pixels to RGB */
   if ((transforms & PNG_TRANSFORM_BGR) != 0)
#ifdef PNG_WRITE_BGR_SUPPORTED
      png_set_bgr(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_BGR not supported");
#endif

   /* Swap bytes of 16-bit files to most significant byte first */
   if ((transforms & PNG_TRANSFORM_SWAP_ENDIAN) != 0)
#ifdef PNG_WRITE_SWAP_SUPPORTED
      png_set_swap(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_SWAP_ENDIAN not supported");
#endif

   /* Swap bits of 1-bit, 2-bit, 4-bit packed pixel formats */
   if ((transforms & PNG_TRANSFORM_PACKSWAP) != 0)
#ifdef PNG_WRITE_PACKSWAP_SUPPORTED
      png_set_packswap(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_PACKSWAP not supported");
#endif

   /* Invert the alpha channel from opacity to transparency */
   if ((transforms & PNG_TRANSFORM_INVERT_ALPHA) != 0)
#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
      png_set_invert_alpha(png_ptr);
#else
      png_app_error(png_ptr, "PNG_TRANSFORM_INVERT_ALPHA not supported");
#endif

   /* ----------------------- end of transformations ------------------- */

   /* Write the bits */
   png_write_image(png_ptr, info_ptr->row_pointers);

   /* It is REQUIRED to call this to finish writing the rest of the file */
   png_write_end(png_ptr, info_ptr);

   PNG_UNUSED(params)
}
#endif


#ifdef PNG_SIMPLIFIED_WRITE_SUPPORTED
/* Initialize the write structure - general purpose utility. */
static int
png_image_write_init(png_imagep image)
{
   png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, image,
       png_safe_error, png_safe_warning);

   if (png_ptr != NULL)
   {
      png_infop info_ptr = png_create_info_struct(png_ptr);

      if (info_ptr != NULL)
      {
         png_controlp control = png_voidcast(png_controlp,
             png_malloc_warn(png_ptr, (sizeof *control)));

         if (control != NULL)
         {
            memset(control, 0, (sizeof *control));

            control->png_ptr = png_ptr;
            control->info_ptr = info_ptr;
            control->for_write = 1;

            image->opaque = control;
            return 1;
         }

         /* Error clean up */
         png_destroy_info_struct(png_ptr, &info_ptr);
      }

      png_destroy_write_struct(&png_ptr, NULL);
   }

   return png_image_error(image, "png_image_write_: out of memory");
}

/* Arguments to png_image_write_main: */
typedef struct
{
   /* Arguments: */
   png_imagep      image;
   png_const_voidp buffer;
   png_int_32      row_stride;
   png_const_voidp colormap;
   int             convert_to_8bit;
   /* Local variables: */
   png_const_voidp first_row;
   ptrdiff_t       row_bytes;
   png_voidp       local_row;
   /* Byte count for memory writing */
   png_bytep        memory;
   png_alloc_size_t memory_bytes; /* not used for STDIO */
   png_alloc_size_t output_bytes; /* running total */
} png_image_write_control;

/* Write png_uint_16 input to a 16-bit PNG; the png_ptr has already been set to
 * do any necessary byte swapping.  The component order is defined by the
 * png_image format value.
 */
static int
png_write_image_16bit(png_voidp argument)
{
   png_image_write_control *display = png_voidcast(png_image_write_control*,
       argument);
   png_imagep image = display->image;
   png_structrp png_ptr = image->opaque->png_ptr;

   png_const_uint_16p input_row = png_voidcast(png_const_uint_16p,
       display->first_row);
   png_uint_16p output_row = png_voidcast(png_uint_16p, display->local_row);
   png_uint_16p row_end;
   const unsigned int channels = (image->format & PNG_FORMAT_FLAG_COLOR) != 0 ?
       3 : 1;
   int aindex = 0;
   png_uint_32 y = image->height;

   if ((image->format & PNG_FORMAT_FLAG_ALPHA) != 0)
   {
#   ifdef PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
      if ((image->format & PNG_FORMAT_FLAG_AFIRST) != 0)
      {
         aindex = -1;
         ++input_row; /* To point to the first component */
         ++output_row;
      }
         else
            aindex = (int)channels;
#     else
         aindex = (int)channels;
#     endif
   }

   else
      png_error(png_ptr, "png_write_image: internal call error");

   /* Work out the output row end and count over this, note that the increment
    * above to 'row' means that row_end can actually be beyond the end of the
    * row; this is correct.
    */
   row_end = output_row + image->width * (channels+1);

   for (; y > 0; --y)
   {
      png_const_uint_16p in_ptr = input_row;
      png_uint_16p out_ptr = output_row;

      while (out_ptr < row_end)
      {
         const png_uint_16 alpha = in_ptr[aindex];
         png_uint_32 reciprocal = 0;
         int c;

         out_ptr[aindex] = alpha;

         /* Calculate a reciprocal.  The correct calculation is simply
          * component/alpha*65535 << 15. (I.e. 15 bits of precision); this
          * allows correct rounding by adding .5 before the shift.  'reciprocal'
          * is only initialized when required.
          */
         if (alpha > 0 && alpha < 65535)
            reciprocal = ((0xffff<<15)+(alpha>>1))/alpha;

         c = (int)channels;
         do /* always at least one channel */
         {
            png_uint_16 component = *in_ptr++;

            /* The following gives 65535 for an alpha of 0, which is fine,
             * otherwise if 0/0 is represented as some other value there is more
             * likely to be a discontinuity which will probably damage
             * compression when moving from a fully transparent area to a
             * nearly transparent one.  (The assumption here is that opaque
             * areas tend not to be 0 intensity.)
             */
            if (component >= alpha)
               component = 65535;

            /* component<alpha, so component/alpha is less than one and
             * component*reciprocal is less than 2^31.
             */
            else if (component > 0 && alpha < 65535)
            {
               png_uint_32 calc = component * reciprocal;
               calc += 16384; /* round to nearest */
               component = (png_uint_16)(calc >> 15);
            }

            *out_ptr++ = component;
         }
         while (--c > 0);

         /* Skip to next component (skip the intervening alpha channel) */
         ++in_ptr;
         ++out_ptr;
      }

      png_write_row(png_ptr, png_voidcast(png_const_bytep, display->local_row));
      input_row += (png_uint_16)display->row_bytes/(sizeof (png_uint_16));
   }

   return 1;
}

/* Given 16-bit input (1 to 4 channels) write 8-bit output.  If an alpha channel
 * is present it must be removed from the components, the components are then
 * written in sRGB encoding.  No components are added or removed.
 *
 * Calculate an alpha reciprocal to reverse pre-multiplication.  As above the
 * calculation can be done to 15 bits of accuracy; however, the output needs to
 * be scaled in the range 0..255*65535, so include that scaling here.
 */
#   define UNP_RECIPROCAL(alpha) ((((0xffff*0xff)<<7)+(alpha>>1))/alpha)

static png_byte
png_unpremultiply(png_uint_32 component, png_uint_32 alpha,
    png_uint_32 reciprocal/*from the above macro*/)
{
   /* The following gives 1.0 for an alpha of 0, which is fine, otherwise if 0/0
    * is represented as some other value there is more likely to be a
    * discontinuity which will probably damage compression when moving from a
    * fully transparent area to a nearly transparent one.  (The assumption here
    * is that opaque areas tend not to be 0 intensity.)
    *
    * There is a rounding problem here; if alpha is less than 128 it will end up
    * as 0 when scaled to 8 bits.  To avoid introducing spurious colors into the
    * output change for this too.
    */
   if (component >= alpha || alpha < 128)
      return 255;

   /* component<alpha, so component/alpha is less than one and
    * component*reciprocal is less than 2^31.
    */
   else if (component > 0)
   {
      /* The test is that alpha/257 (rounded) is less than 255, the first value
       * that becomes 255 is 65407.
       * NOTE: this must agree with the PNG_DIV257 macro (which must, therefore,
       * be exact!)  [Could also test reciprocal != 0]
       */
      if (alpha < 65407)
      {
         component *= reciprocal;
         component += 64; /* round to nearest */
         component >>= 7;
      }

      else
         component *= 255;

      /* Convert the component to sRGB. */
      return (png_byte)PNG_sRGB_FROM_LINEAR(component);
   }

   else
      return 0;
}

static int
png_write_image_8bit(png_voidp argument)
{
   png_image_write_control *display = png_voidcast(png_image_write_control*,
       argument);
   png_imagep image = display->image;
   png_structrp png_ptr = image->opaque->png_ptr;

   png_const_uint_16p input_row = png_voidcast(png_const_uint_16p,
       display->first_row);
   png_bytep output_row = png_voidcast(png_bytep, display->local_row);
   png_uint_32 y = image->height;
   const unsigned int channels = (image->format & PNG_FORMAT_FLAG_COLOR) != 0 ?
       3 : 1;

   if ((image->format & PNG_FORMAT_FLAG_ALPHA) != 0)
   {
      png_bytep row_end;
      int aindex;

#   ifdef PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
      if ((image->format & PNG_FORMAT_FLAG_AFIRST) != 0)
      {
         aindex = -1;
         ++input_row; /* To point to the first component */
         ++output_row;
      }

      else
#   endif
      aindex = (int)channels;

      /* Use row_end in place of a loop counter: */
      row_end = output_row + image->width * (channels+1);

      for (; y > 0; --y)
      {
         png_const_uint_16p in_ptr = input_row;
         png_bytep out_ptr = output_row;

         while (out_ptr < row_end)
         {
            png_uint_16 alpha = in_ptr[aindex];
            png_byte alphabyte = (png_byte)PNG_DIV257(alpha);
            png_uint_32 reciprocal = 0;
            int c;

            /* Scale and write the alpha channel. */
            out_ptr[aindex] = alphabyte;

            if (alphabyte > 0 && alphabyte < 255)
               reciprocal = UNP_RECIPROCAL(alpha);

            c = (int)channels;
            do /* always at least one channel */
               *out_ptr++ = png_unpremultiply(*in_ptr++, alpha, reciprocal);
            while (--c > 0);

            /* Skip to next component (skip the intervening alpha channel) */
            ++in_ptr;
            ++out_ptr;
         } /* while out_ptr < row_end */

         png_write_row(png_ptr, png_voidcast(png_const_bytep,
             display->local_row));
         input_row += (png_uint_16)display->row_bytes/(sizeof (png_uint_16));
      } /* while y */
   }

   else
   {
      /* No alpha channel, so the row_end really is the end of the row and it
       * is sufficient to loop over the components one by one.
       */
      png_bytep row_end = output_row + image->width * channels;

      for (; y > 0; --y)
      {
         png_const_uint_16p in_ptr = input_row;
         png_bytep out_ptr = output_row;

         while (out_ptr < row_end)
         {
            png_uint_32 component = *in_ptr++;

            component *= 255;
            *out_ptr++ = (png_byte)PNG_sRGB_FROM_LINEAR(component);
         }

         png_write_row(png_ptr, output_row);
         input_row += (png_uint_16)display->row_bytes/(sizeof (png_uint_16));
      }
   }

   return 1;
}

static void
png_image_set_PLTE(png_image_write_control *display)
{
   const png_imagep image = display->image;
   const void *cmap = display->colormap;
   const int entries = image->colormap_entries > 256 ? 256 :
       (int)image->colormap_entries;

   /* NOTE: the caller must check for cmap != NULL and entries != 0 */
   const png_uint_32 format = image->format;
   const unsigned int channels = PNG_IMAGE_SAMPLE_CHANNELS(format);

#   if defined(PNG_FORMAT_BGR_SUPPORTED) &&\
      defined(PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED)
      const int afirst = (format & PNG_FORMAT_FLAG_AFIRST) != 0 &&
          (format & PNG_FORMAT_FLAG_ALPHA) != 0;
#   else
#     define afirst 0
#   endif

#   ifdef PNG_FORMAT_BGR_SUPPORTED
      const int bgr = (format & PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;
#   else
#     define bgr 0
#   endif

   int i, num_trans;
   png_color palette[256];
   png_byte tRNS[256];

   memset(tRNS, 255, (sizeof tRNS));
   memset(palette, 0, (sizeof palette));

   for (i=num_trans=0; i<entries; ++i)
   {
      /* This gets automatically converted to sRGB with reversal of the
       * pre-multiplication if the color-map has an alpha channel.
       */
      if ((format & PNG_FORMAT_FLAG_LINEAR) != 0)
      {
         png_const_uint_16p entry = png_voidcast(png_const_uint_16p, cmap);

         entry += (unsigned int)i * channels;

         if ((channels & 1) != 0) /* no alpha */
         {
            if (channels >= 3) /* RGB */
            {
               palette[i].blue = (png_byte)PNG_sRGB_FROM_LINEAR(255 *
                   entry[(2 ^ bgr)]);
               palette[i].green = (png_byte)PNG_sRGB_FROM_LINEAR(255 *
                   entry[1]);
               palette[i].red = (png_byte)PNG_sRGB_FROM_LINEAR(255 *
                   entry[bgr]);
            }

            else /* Gray */
               palette[i].blue = palette[i].red = palette[i].green =
                  (png_byte)PNG_sRGB_FROM_LINEAR(255 * *entry);
         }

         else /* alpha */
         {
            png_uint_16 alpha = entry[afirst ? 0 : channels-1];
            png_byte alphabyte = (png_byte)PNG_DIV257(alpha);
            png_uint_32 reciprocal = 0;

            /* Calculate a reciprocal, as in the png_write_image_8bit code above
             * this is designed to produce a value scaled to 255*65535 when
             * divided by 128 (i.e. asr 7).
             */
            if (alphabyte > 0 && alphabyte < 255)
               reciprocal = (((0xffff*0xff)<<7)+(alpha>>1))/alpha;

            tRNS[i] = alphabyte;
            if (alphabyte < 255)
               num_trans = i+1;

            if (channels >= 3) /* RGB */
            {
               palette[i].blue = png_unpremultiply(entry[afirst + (2 ^ bgr)],
                   alpha, reciprocal);
               palette[i].green = png_unpremultiply(entry[afirst + 1], alpha,
                   reciprocal);
               palette[i].red = png_unpremultiply(entry[afirst + bgr], alpha,
                   reciprocal);
            }

            else /* gray */
               palette[i].blue = palette[i].red = palette[i].green =
                   png_unpremultiply(entry[afirst], alpha, reciprocal);
         }
      }

      else /* Color-map has sRGB values */
      {
         png_const_bytep entry = png_voidcast(png_const_bytep, cmap);

         entry += (unsigned int)i * channels;

         switch (channels)
         {
            case 4:
               tRNS[i] = entry[afirst ? 0 : 3];
               if (tRNS[i] < 255)
                  num_trans = i+1;
               /* FALL THROUGH */
            case 3:
               palette[i].blue = entry[afirst + (2 ^ bgr)];
               palette[i].green = entry[afirst + 1];
               palette[i].red = entry[afirst + bgr];
               break;

            case 2:
               tRNS[i] = entry[1 ^ afirst];
               if (tRNS[i] < 255)
                  num_trans = i+1;
               /* FALL THROUGH */
            case 1:
               palette[i].blue = palette[i].red = palette[i].green =
                  entry[afirst];
               break;

            default:
               break;
         }
      }
   }

#   ifdef afirst
#     undef afirst
#   endif
#   ifdef bgr
#     undef bgr
#   endif

   png_set_PLTE(image->opaque->png_ptr, image->opaque->info_ptr, palette,
       entries);

   if (num_trans > 0)
      png_set_tRNS(image->opaque->png_ptr, image->opaque->info_ptr, tRNS,
          num_trans, NULL);

   image->colormap_entries = (png_uint_32)entries;
}

static int
png_image_write_main(png_voidp argument)
{
   png_image_write_control *display = png_voidcast(png_image_write_control*,
       argument);
   png_imagep image = display->image;
   png_structrp png_ptr = image->opaque->png_ptr;
   png_inforp info_ptr = image->opaque->info_ptr;
   png_uint_32 format = image->format;

   /* The following four ints are actually booleans */
   int colormap = (format & PNG_FORMAT_FLAG_COLORMAP);
   int linear = !colormap && (format & PNG_FORMAT_FLAG_LINEAR); /* input */
   int alpha = !colormap && (format & PNG_FORMAT_FLAG_ALPHA);
   int write_16bit = linear && !colormap && (display->convert_to_8bit == 0);

#   ifdef PNG_BENIGN_ERRORS_SUPPORTED
      /* Make sure we error out on any bad situation */
      png_set_benign_errors(png_ptr, 0/*error*/);
#   endif

   /* Default the 'row_stride' parameter if required, also check the row stride
    * and total image size to ensure that they are within the system limits.
    */
   {
      const unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image->format);

      if (image->width <= 0x7fffffffU/channels) /* no overflow */
      {
         png_uint_32 check;
         const png_uint_32 png_row_stride = image->width * channels;

         if (display->row_stride == 0)
            display->row_stride = (png_int_32)/*SAFE*/png_row_stride;

         if (display->row_stride < 0)
            check = (png_uint_32)(-display->row_stride);

         else
            check = (png_uint_32)display->row_stride;

         if (check >= png_row_stride)
         {
            /* Now check for overflow of the image buffer calculation; this
             * limits the whole image size to 32 bits for API compatibility with
             * the current, 32-bit, PNG_IMAGE_BUFFER_SIZE macro.
             */
            if (image->height > 0xffffffffU/png_row_stride)
               png_error(image->opaque->png_ptr, "memory image too large");
         }

         else
            png_error(image->opaque->png_ptr, "supplied row stride too small");
      }

      else
         png_error(image->opaque->png_ptr, "image row stride too large");
   }

   /* Set the required transforms then write the rows in the correct order. */
   if ((format & PNG_FORMAT_FLAG_COLORMAP) != 0)
   {
      if (display->colormap != NULL && image->colormap_entries > 0)
      {
         png_uint_32 entries = image->colormap_entries;

         png_set_IHDR(png_ptr, info_ptr, image->width, image->height,
             entries > 16 ? 8 : (entries > 4 ? 4 : (entries > 2 ? 2 : 1)),
             PNG_COLOR_TYPE_PALETTE, PNG_INTERLACE_NONE,
             PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);

         png_image_set_PLTE(display);
      }

      else
         png_error(image->opaque->png_ptr,
             "no color-map for color-mapped image");
   }

   else
      png_set_IHDR(png_ptr, info_ptr, image->width, image->height,
          write_16bit ? 16 : 8,
          ((format & PNG_FORMAT_FLAG_COLOR) ? PNG_COLOR_MASK_COLOR : 0) +
          ((format & PNG_FORMAT_FLAG_ALPHA) ? PNG_COLOR_MASK_ALPHA : 0),
          PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);

   /* Counter-intuitively the data transformations must be called *after*
    * png_write_info, not before as in the read code, but the 'set' functions
    * must still be called before.  Just set the color space information, never
    * write an interlaced image.
    */

   if (write_16bit != 0)
   {
      /* The gamma here is 1.0 (linear) and the cHRM chunk matches sRGB. */
      png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_LINEAR);

      if ((image->flags & PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB) == 0)
         png_set_cHRM_fixed(png_ptr, info_ptr,
             /* color      x       y */
             /* white */ 31270, 32900,
             /* red   */ 64000, 33000,
             /* green */ 30000, 60000,
             /* blue  */ 15000,  6000
         );
   }

   else if ((image->flags & PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB) == 0)
      png_set_sRGB(png_ptr, info_ptr, PNG_sRGB_INTENT_PERCEPTUAL);

   /* Else writing an 8-bit file and the *colors* aren't sRGB, but the 8-bit
    * space must still be gamma encoded.
    */
   else
      png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_sRGB_INVERSE);

   /* Write the file header. */
   png_write_info(png_ptr, info_ptr);

   /* Now set up the data transformations (*after* the header is written),
    * remove the handled transformations from the 'format' flags for checking.
    *
    * First check for a little endian system if writing 16-bit files.
    */
   if (write_16bit != 0)
   {
      PNG_CONST png_uint_16 le = 0x0001;

      if ((*(png_const_bytep) & le) != 0)
         png_set_swap(png_ptr);
   }

#   ifdef PNG_SIMPLIFIED_WRITE_BGR_SUPPORTED
      if ((format & PNG_FORMAT_FLAG_BGR) != 0)
      {
         if (colormap == 0 && (format & PNG_FORMAT_FLAG_COLOR) != 0)
            png_set_bgr(png_ptr);
         format &= ~PNG_FORMAT_FLAG_BGR;
      }
#   endif

#   ifdef PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED
      if ((format & PNG_FORMAT_FLAG_AFIRST) != 0)
      {
         if (colormap == 0 && (format & PNG_FORMAT_FLAG_ALPHA) != 0)
            png_set_swap_alpha(png_ptr);
         format &= ~PNG_FORMAT_FLAG_AFIRST;
      }
#   endif

   /* If there are 16 or fewer color-map entries we wrote a lower bit depth
    * above, but the application data is still byte packed.
    */
   if (colormap != 0 && image->colormap_entries <= 16)
      png_set_packing(png_ptr);

   /* That should have handled all (both) the transforms. */
   if ((format & ~(png_uint_32)(PNG_FORMAT_FLAG_COLOR | PNG_FORMAT_FLAG_LINEAR |
         PNG_FORMAT_FLAG_ALPHA | PNG_FORMAT_FLAG_COLORMAP)) != 0)
      png_error(png_ptr, "png_write_image: unsupported transformation");

   {
      png_const_bytep row = png_voidcast(png_const_bytep, display->buffer);
      ptrdiff_t row_bytes = display->row_stride;

      if (linear != 0)
         row_bytes *= (sizeof (png_uint_16));

      if (row_bytes < 0)
         row += (image->height-1) * (-row_bytes);

      display->first_row = row;
      display->row_bytes = row_bytes;
   }

   /* Apply 'fast' options if the flag is set. */
   if ((image->flags & PNG_IMAGE_FLAG_FAST) != 0)
   {
      png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, PNG_NO_FILTERS);
      /* NOTE: determined by experiment using pngstest, this reflects some
       * balance between the time to write the image once and the time to read
       * it about 50 times.  The speed-up in pngstest was about 10-20% of the
       * total (user) time on a heavily loaded system.
       */
#   ifdef PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
      png_set_compression_level(png_ptr, 3);
#   endif
   }

   /* Check for the cases that currently require a pre-transform on the row
    * before it is written.  This only applies when the input is 16-bit and
    * either there is an alpha channel or it is converted to 8-bit.
    */
   if ((linear != 0 && alpha != 0 ) ||
       (colormap == 0 && display->convert_to_8bit != 0))
   {
      png_bytep row = png_voidcast(png_bytep, png_malloc(png_ptr,
          png_get_rowbytes(png_ptr, info_ptr)));
      int result;

      display->local_row = row;
      if (write_16bit != 0)
         result = png_safe_execute(image, png_write_image_16bit, display);
      else
         result = png_safe_execute(image, png_write_image_8bit, display);
      display->local_row = NULL;

      png_free(png_ptr, row);

      /* Skip the 'write_end' on error: */
      if (result == 0)
         return 0;
   }

   /* Otherwise this is the case where the input is in a format currently
    * supported by the rest of the libpng write code; call it directly.
    */
   else
   {
      png_const_bytep row = png_voidcast(png_const_bytep, display->first_row);
      ptrdiff_t row_bytes = display->row_bytes;
      png_uint_32 y = image->height;

      for (; y > 0; --y)
      {
         png_write_row(png_ptr, row);
         row += row_bytes;
      }
   }

   png_write_end(png_ptr, info_ptr);
   return 1;
}


static void (PNGCBAPI
image_memory_write)(png_structp png_ptr, png_bytep/*const*/ data,
    png_size_t size)
{
   png_image_write_control *display = png_voidcast(png_image_write_control*,
       png_ptr->io_ptr/*backdoor: png_get_io_ptr(png_ptr)*/);
   const png_alloc_size_t ob = display->output_bytes;

   /* Check for overflow; this should never happen: */
   if (size <= ((png_alloc_size_t)-1) - ob)
   {
      /* I don't think libpng ever does this, but just in case: */
      if (size > 0)
      {
         if (display->memory_bytes >= ob+size) /* writing */
            memcpy(display->memory+ob, data, size);

         /* Always update the size: */
         display->output_bytes = ob+size;
      }
   }

   else
      png_error(png_ptr, "png_image_write_to_memory: PNG too big");
}

static void (PNGCBAPI
image_memory_flush)(png_structp png_ptr)
{
   PNG_UNUSED(png_ptr)
}

static int
png_image_write_memory(png_voidp argument)
{
   png_image_write_control *display = png_voidcast(png_image_write_control*,
       argument);

   /* The rest of the memory-specific init and write_main in an error protected
    * environment.  This case needs to use callbacks for the write operations
    * since libpng has no built in support for writing to memory.
    */
   png_set_write_fn(display->image->opaque->png_ptr, display/*io_ptr*/,
       image_memory_write, image_memory_flush);

   return png_image_write_main(display);
}

int PNGAPI
png_image_write_to_memory(png_imagep image, void *memory,
    png_alloc_size_t * PNG_RESTRICT memory_bytes, int convert_to_8bit,
    const void *buffer, png_int_32 row_stride, const void *colormap)
{
   /* Write the image to the given buffer, or count the bytes if it is NULL */
   if (image != NULL && image->version == PNG_IMAGE_VERSION)
   {
      if (memory_bytes != NULL && buffer != NULL)
      {
         /* This is to give the caller an easier error detection in the NULL
          * case and guard against uninitialized variable problems:
          */
         if (memory == NULL)
            *memory_bytes = 0;

         if (png_image_write_init(image) != 0)
         {
            png_image_write_control display;
            int result;

            memset(&display, 0, (sizeof display));
            display.image = image;
            display.buffer = buffer;
            display.row_stride = row_stride;
            display.colormap = colormap;
            display.convert_to_8bit = convert_to_8bit;
            display.memory = png_voidcast(png_bytep, memory);
            display.memory_bytes = *memory_bytes;
            display.output_bytes = 0;

            result = png_safe_execute(image, png_image_write_memory, &display);
            png_image_free(image);

            /* write_memory returns true even if we ran out of buffer. */
            if (result)
            {
               /* On out-of-buffer this function returns '0' but still updates
                * memory_bytes:
                */
               if (memory != NULL && display.output_bytes > *memory_bytes)
                  result = 0;

               *memory_bytes = display.output_bytes;
            }

            return result;
         }

         else
            return 0;
      }

      else
         return png_image_error(image,
             "png_image_write_to_memory: invalid argument");
   }

   else if (image != NULL)
      return png_image_error(image,
          "png_image_write_to_memory: incorrect PNG_IMAGE_VERSION");

   else
      return 0;
}

#ifdef PNG_SIMPLIFIED_WRITE_STDIO_SUPPORTED
int PNGAPI
png_image_write_to_stdio(png_imagep image, FILE *file, int convert_to_8bit,
    const void *buffer, png_int_32 row_stride, const void *colormap)
{
   /* Write the image to the given (FILE*). */
   if (image != NULL && image->version == PNG_IMAGE_VERSION)
   {
      if (file != NULL && buffer != NULL)
      {
         if (png_image_write_init(image) != 0)
         {
            png_image_write_control display;
            int result;

            /* This is slightly evil, but png_init_io doesn't do anything other
             * than this and we haven't changed the standard IO functions so
             * this saves a 'safe' function.
             */
            image->opaque->png_ptr->io_ptr = file;

            memset(&display, 0, (sizeof display));
            display.image = image;
            display.buffer = buffer;
            display.row_stride = row_stride;
            display.colormap = colormap;
            display.convert_to_8bit = convert_to_8bit;

            result = png_safe_execute(image, png_image_write_main, &display);
            png_image_free(image);
            return result;
         }

         else
            return 0;
      }

      else
         return png_image_error(image,
             "png_image_write_to_stdio: invalid argument");
   }

   else if (image != NULL)
      return png_image_error(image,
          "png_image_write_to_stdio: incorrect PNG_IMAGE_VERSION");

   else
      return 0;
}

int PNGAPI
png_image_write_to_file(png_imagep image, const char *file_name,
    int convert_to_8bit, const void *buffer, png_int_32 row_stride,
    const void *colormap)
{
   /* Write the image to the named file. */
   if (image != NULL && image->version == PNG_IMAGE_VERSION)
   {
      if (file_name != NULL && buffer != NULL)
      {
         FILE *fp = fopen(file_name, "wb");

         if (fp != NULL)
         {
            if (png_image_write_to_stdio(image, fp, convert_to_8bit, buffer,
                row_stride, colormap) != 0)
            {
               int error; /* from fflush/fclose */

               /* Make sure the file is flushed correctly. */
               if (fflush(fp) == 0 && ferror(fp) == 0)
               {
                  if (fclose(fp) == 0)
                     return 1;

                  error = errno; /* from fclose */
               }

               else
               {
                  error = errno; /* from fflush or ferror */
                  (void)fclose(fp);
               }

               (void)remove(file_name);
               /* The image has already been cleaned up; this is just used to
                * set the error (because the original write succeeded).
                */
               return png_image_error(image, strerror(error));
            }

            else
            {
               /* Clean up: just the opened file. */
               (void)fclose(fp);
               (void)remove(file_name);
               return 0;
            }
         }

         else
            return png_image_error(image, strerror(errno));
      }

      else
         return png_image_error(image,
             "png_image_write_to_file: invalid argument");
   }

   else if (image != NULL)
      return png_image_error(image,
          "png_image_write_to_file: incorrect PNG_IMAGE_VERSION");

   else
      return 0;
}
#endif /* SIMPLIFIED_WRITE_STDIO */
#endif /* SIMPLIFIED_WRITE */
#endif /* WRITE */

```

`ThirdPartyBuild/PNG/Code/pngwtran.c`:

```c

/* pngwtran.c - transforms the data in a row for PNG writers
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

#include "pngpriv.h"

#ifdef PNG_WRITE_SUPPORTED
#ifdef PNG_WRITE_TRANSFORMS_SUPPORTED

#ifdef PNG_WRITE_PACK_SUPPORTED
/* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
 * row_info bit depth should be 8 (one pixel per byte).  The channels
 * should be 1 (this only happens on grayscale and paletted images).
 */
static void
png_do_pack(png_row_infop row_info, png_bytep row, png_uint_32 bit_depth)
{
   png_debug(1, "in png_do_pack");

   if (row_info->bit_depth == 8 &&
      row_info->channels == 1)
   {
      switch ((int)bit_depth)
      {
         case 1:
         {
            png_bytep sp, dp;
            int mask, v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            mask = 0x80;
            v = 0;

            for (i = 0; i < row_width; i++)
            {
               if (*sp != 0)
                  v |= mask;

               sp++;

               if (mask > 1)
                  mask >>= 1;

               else
               {
                  mask = 0x80;
                  *dp = (png_byte)v;
                  dp++;
                  v = 0;
               }
            }

            if (mask != 0x80)
               *dp = (png_byte)v;

            break;
         }

         case 2:
         {
            png_bytep sp, dp;
            unsigned int shift;
            int v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            shift = 6;
            v = 0;

            for (i = 0; i < row_width; i++)
            {
               png_byte value;

               value = (png_byte)(*sp & 0x03);
               v |= (value << shift);

               if (shift == 0)
               {
                  shift = 6;
                  *dp = (png_byte)v;
                  dp++;
                  v = 0;
               }

               else
                  shift -= 2;

               sp++;
            }

            if (shift != 6)
               *dp = (png_byte)v;

            break;
         }

         case 4:
         {
            png_bytep sp, dp;
            unsigned int shift;
            int v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            shift = 4;
            v = 0;

            for (i = 0; i < row_width; i++)
            {
               png_byte value;

               value = (png_byte)(*sp & 0x0f);
               v |= (value << shift);

               if (shift == 0)
               {
                  shift = 4;
                  *dp = (png_byte)v;
                  dp++;
                  v = 0;
               }

               else
                  shift -= 4;

               sp++;
            }

            if (shift != 4)
               *dp = (png_byte)v;

            break;
         }

         default:
            break;
      }

      row_info->bit_depth = (png_byte)bit_depth;
      row_info->pixel_depth = (png_byte)(bit_depth * row_info->channels);
      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
          row_info->width);
   }
}
#endif

#ifdef PNG_WRITE_SHIFT_SUPPORTED
/* Shift pixel values to take advantage of whole range.  Pass the
 * true number of bits in bit_depth.  The row should be packed
 * according to row_info->bit_depth.  Thus, if you had a row of
 * bit depth 4, but the pixels only had values from 0 to 7, you
 * would pass 3 as bit_depth, and this routine would translate the
 * data to 0 to 15.
 */
static void
png_do_shift(png_row_infop row_info, png_bytep row,
    png_const_color_8p bit_depth)
{
   png_debug(1, "in png_do_shift");

   if (row_info->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      int shift_start[4], shift_dec[4];
      unsigned int channels = 0;

      if ((row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)
      {
         shift_start[channels] = row_info->bit_depth - bit_depth->red;
         shift_dec[channels] = bit_depth->red;
         channels++;

         shift_start[channels] = row_info->bit_depth - bit_depth->green;
         shift_dec[channels] = bit_depth->green;
         channels++;

         shift_start[channels] = row_info->bit_depth - bit_depth->blue;
         shift_dec[channels] = bit_depth->blue;
         channels++;
      }

      else
      {
         shift_start[channels] = row_info->bit_depth - bit_depth->gray;
         shift_dec[channels] = bit_depth->gray;
         channels++;
      }

      if ((row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0)
      {
         shift_start[channels] = row_info->bit_depth - bit_depth->alpha;
         shift_dec[channels] = bit_depth->alpha;
         channels++;
      }

      /* With low row depths, could only be grayscale, so one channel */
      if (row_info->bit_depth < 8)
      {
         png_bytep bp = row;
         png_size_t i;
         unsigned int mask;
         png_size_t row_bytes = row_info->rowbytes;

         if (bit_depth->gray == 1 && row_info->bit_depth == 2)
            mask = 0x55;

         else if (row_info->bit_depth == 4 && bit_depth->gray == 3)
            mask = 0x11;

         else
            mask = 0xff;

         for (i = 0; i < row_bytes; i++, bp++)
         {
            int j;
            unsigned int v, out;

            v = *bp;
            out = 0;

            for (j = shift_start[0]; j > -shift_dec[0]; j -= shift_dec[0])
            {
               if (j > 0)
                  out |= v << j;

               else
                  out |= (v >> (-j)) & mask;
            }

            *bp = (png_byte)(out & 0xff);
         }
      }

      else if (row_info->bit_depth == 8)
      {
         png_bytep bp = row;
         png_uint_32 i;
         png_uint_32 istop = channels * row_info->width;

         for (i = 0; i < istop; i++, bp++)
         {

            const unsigned int c = i%channels;
            int j;
            unsigned int v, out;

            v = *bp;
            out = 0;

            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
            {
               if (j > 0)
                  out |= v << j;

               else
                  out |= v >> (-j);
            }

            *bp = (png_byte)(out & 0xff);
         }
      }

      else
      {
         png_bytep bp;
         png_uint_32 i;
         png_uint_32 istop = channels * row_info->width;

         for (bp = row, i = 0; i < istop; i++)
         {
            const unsigned int c = i%channels;
            int j;
            unsigned int value, v;

            v = png_get_uint_16(bp);
            value = 0;

            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
            {
               if (j > 0)
                  value |= v << j;

               else
                  value |= v >> (-j);
            }
            *bp++ = (png_byte)((value >> 8) & 0xff);
            *bp++ = (png_byte)(value & 0xff);
         }
      }
   }
}
#endif

#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
static void
png_do_write_swap_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_write_swap_alpha");

   {
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         if (row_info->bit_depth == 8)
         {
            /* This converts from ARGB to RGBA */
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save;
            }
         }

#ifdef PNG_WRITE_16BIT_SUPPORTED
         else
         {
            /* This converts from AARRGGBB to RRGGBBAA */
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save[2];
               save[0] = *(sp++);
               save[1] = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save[0];
               *(dp++) = save[1];
            }
         }
#endif /* WRITE_16BIT */
      }

      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (row_info->bit_depth == 8)
         {
            /* This converts from AG to GA */
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save;
            }
         }

#ifdef PNG_WRITE_16BIT_SUPPORTED
         else
         {
            /* This converts from AAGG to GGAA */
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save[2];
               save[0] = *(sp++);
               save[1] = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save[0];
               *(dp++) = save[1];
            }
         }
#endif /* WRITE_16BIT */
      }
   }
}
#endif

#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
static void
png_do_write_invert_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_write_invert_alpha");

   {
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         if (row_info->bit_depth == 8)
         {
            /* This inverts the alpha channel in RGBA */
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               /* Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               */
               sp+=3; dp = sp;
               *dp = (png_byte)(255 - *(sp++));
            }
         }

#ifdef PNG_WRITE_16BIT_SUPPORTED
         else
         {
            /* This inverts the alpha channel in RRGGBBAA */
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               /* Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               */
               sp+=6; dp = sp;
               *(dp++) = (png_byte)(255 - *(sp++));
               *dp     = (png_byte)(255 - *(sp++));
            }
         }
#endif /* WRITE_16BIT */
      }

      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (row_info->bit_depth == 8)
         {
            /* This inverts the alpha channel in GA */
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               *(dp++) = *(sp++);
               *(dp++) = (png_byte)(255 - *(sp++));
            }
         }

#ifdef PNG_WRITE_16BIT_SUPPORTED
         else
         {
            /* This inverts the alpha channel in GGAA */
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               /* Does nothing
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               */
               sp+=2; dp = sp;
               *(dp++) = (png_byte)(255 - *(sp++));
               *dp     = (png_byte)(255 - *(sp++));
            }
         }
#endif /* WRITE_16BIT */
      }
   }
}
#endif

/* Transform the data according to the user's wishes.  The order of
 * transformations is significant.
 */
void /* PRIVATE */
png_do_write_transformations(png_structrp png_ptr, png_row_infop row_info)
{
   png_debug(1, "in png_do_write_transformations");

   if (png_ptr == NULL)
      return;

#ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
   if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
      if (png_ptr->write_user_transform_fn != NULL)
         (*(png_ptr->write_user_transform_fn)) /* User write transform
                                                 function */
             (png_ptr,  /* png_ptr */
             row_info,  /* row_info: */
                /*  png_uint_32 width;       width of row */
                /*  png_size_t rowbytes;     number of bytes in row */
                /*  png_byte color_type;     color type of pixels */
                /*  png_byte bit_depth;      bit depth of samples */
                /*  png_byte channels;       number of channels (1-4) */
                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
             png_ptr->row_buf + 1);      /* start of pixel data for row */
#endif

#ifdef PNG_WRITE_FILLER_SUPPORTED
   if ((png_ptr->transformations & PNG_FILLER) != 0)
      png_do_strip_channel(row_info, png_ptr->row_buf + 1,
          !(png_ptr->flags & PNG_FLAG_FILLER_AFTER));
#endif

#ifdef PNG_WRITE_PACKSWAP_SUPPORTED
   if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
      png_do_packswap(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_WRITE_PACK_SUPPORTED
   if ((png_ptr->transformations & PNG_PACK) != 0)
      png_do_pack(row_info, png_ptr->row_buf + 1,
          (png_uint_32)png_ptr->bit_depth);
#endif

#ifdef PNG_WRITE_SWAP_SUPPORTED
#  ifdef PNG_16BIT_SUPPORTED
   if ((png_ptr->transformations & PNG_SWAP_BYTES) != 0)
      png_do_swap(row_info, png_ptr->row_buf + 1);
#  endif
#endif

#ifdef PNG_WRITE_SHIFT_SUPPORTED
   if ((png_ptr->transformations & PNG_SHIFT) != 0)
      png_do_shift(row_info, png_ptr->row_buf + 1,
           &(png_ptr->shift));
#endif

#ifdef PNG_WRITE_SWAP_ALPHA_SUPPORTED
   if ((png_ptr->transformations & PNG_SWAP_ALPHA) != 0)
      png_do_write_swap_alpha(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_WRITE_INVERT_ALPHA_SUPPORTED
   if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0)
      png_do_write_invert_alpha(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_WRITE_BGR_SUPPORTED
   if ((png_ptr->transformations & PNG_BGR) != 0)
      png_do_bgr(row_info, png_ptr->row_buf + 1);
#endif

#ifdef PNG_WRITE_INVERT_SUPPORTED
   if ((png_ptr->transformations & PNG_INVERT_MONO) != 0)
      png_do_invert(row_info, png_ptr->row_buf + 1);
#endif
}
#endif /* WRITE_TRANSFORMS */
#endif /* WRITE */

```

`ThirdPartyBuild/PNG/Code/pngwutil.c`:

```c

/* pngwutil.c - utilities to write a PNG file
 *
 * Last changed in libpng 1.6.26 [October 20, 2016]
 * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This code is released under the libpng license.
 * For conditions of distribution and use, see the disclaimer
 * and license in png.h
 */

#include "pngpriv.h"

#ifdef PNG_WRITE_SUPPORTED

#ifdef PNG_WRITE_INT_FUNCTIONS_SUPPORTED
/* Place a 32-bit number into a buffer in PNG byte order.  We work
 * with unsigned numbers for convenience, although one supported
 * ancillary chunk uses signed (two's complement) numbers.
 */
void PNGAPI
png_save_uint_32(png_bytep buf, png_uint_32 i)
{
   buf[0] = (png_byte)((i >> 24) & 0xffU);
   buf[1] = (png_byte)((i >> 16) & 0xffU);
   buf[2] = (png_byte)((i >>  8) & 0xffU);
   buf[3] = (png_byte)( i        & 0xffU);
}

/* Place a 16-bit number into a buffer in PNG byte order.
 * The parameter is declared unsigned int, not png_uint_16,
 * just to avoid potential problems on pre-ANSI C compilers.
 */
void PNGAPI
png_save_uint_16(png_bytep buf, unsigned int i)
{
   buf[0] = (png_byte)((i >> 8) & 0xffU);
   buf[1] = (png_byte)( i       & 0xffU);
}
#endif

/* Simple function to write the signature.  If we have already written
 * the magic bytes of the signature, or more likely, the PNG stream is
 * being embedded into another stream and doesn't need its own signature,
 * we should call png_set_sig_bytes() to tell libpng how many of the
 * bytes have already been written.
 */
void PNGAPI
png_write_sig(png_structrp png_ptr)
{
   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};

#ifdef PNG_IO_STATE_SUPPORTED
   /* Inform the I/O callback that the signature is being written */
   png_ptr->io_state = PNG_IO_WRITING | PNG_IO_SIGNATURE;
#endif

   /* Write the rest of the 8 byte signature */
   png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],
       (png_size_t)(8 - png_ptr->sig_bytes));

   if (png_ptr->sig_bytes < 3)
      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
}

/* Write the start of a PNG chunk.  The type is the chunk type.
 * The total_length is the sum of the lengths of all the data you will be
 * passing in png_write_chunk_data().
 */
static void
png_write_chunk_header(png_structrp png_ptr, png_uint_32 chunk_name,
    png_uint_32 length)
{
   png_byte buf[8];

#if defined(PNG_DEBUG) && (PNG_DEBUG > 0)
   PNG_CSTRING_FROM_CHUNK(buf, chunk_name);
   png_debug2(0, "Writing %s chunk, length = %lu", buf, (unsigned long)length);
#endif

   if (png_ptr == NULL)
      return;

#ifdef PNG_IO_STATE_SUPPORTED
   /* Inform the I/O callback that the chunk header is being written.
    * PNG_IO_CHUNK_HDR requires a single I/O call.
    */
   png_ptr->io_state = PNG_IO_WRITING | PNG_IO_CHUNK_HDR;
#endif

   /* Write the length and the chunk name */
   png_save_uint_32(buf, length);
   png_save_uint_32(buf + 4, chunk_name);
   png_write_data(png_ptr, buf, 8);

   /* Put the chunk name into png_ptr->chunk_name */
   png_ptr->chunk_name = chunk_name;

   /* Reset the crc and run it over the chunk name */
   png_reset_crc(png_ptr);

   png_calculate_crc(png_ptr, buf + 4, 4);

#ifdef PNG_IO_STATE_SUPPORTED
   /* Inform the I/O callback that chunk data will (possibly) be written.
    * PNG_IO_CHUNK_DATA does NOT require a specific number of I/O calls.
    */
   png_ptr->io_state = PNG_IO_WRITING | PNG_IO_CHUNK_DATA;
#endif
}

void PNGAPI
png_write_chunk_start(png_structrp png_ptr, png_const_bytep chunk_string,
    png_uint_32 length)
{
   png_write_chunk_header(png_ptr, PNG_CHUNK_FROM_STRING(chunk_string), length);
}

/* Write the data of a PNG chunk started with png_write_chunk_header().
 * Note that multiple calls to this function are allowed, and that the
 * sum of the lengths from these calls *must* add up to the total_length
 * given to png_write_chunk_header().
 */
void PNGAPI
png_write_chunk_data(png_structrp png_ptr, png_const_bytep data,
    png_size_t length)
{
   /* Write the data, and run the CRC over it */
   if (png_ptr == NULL)
      return;

   if (data != NULL && length > 0)
   {
      png_write_data(png_ptr, data, length);

      /* Update the CRC after writing the data,
       * in case the user I/O routine alters it.
       */
      png_calculate_crc(png_ptr, data, length);
   }
}

/* Finish a chunk started with png_write_chunk_header(). */
void PNGAPI
png_write_chunk_end(png_structrp png_ptr)
{
   png_byte buf[4];

   if (png_ptr == NULL) return;

#ifdef PNG_IO_STATE_SUPPORTED
   /* Inform the I/O callback that the chunk CRC is being written.
    * PNG_IO_CHUNK_CRC requires a single I/O function call.
    */
   png_ptr->io_state = PNG_IO_WRITING | PNG_IO_CHUNK_CRC;
#endif

   /* Write the crc in a single operation */
   png_save_uint_32(buf, png_ptr->crc);

   png_write_data(png_ptr, buf, (png_size_t)4);
}

/* Write a PNG chunk all at once.  The type is an array of ASCII characters
 * representing the chunk name.  The array must be at least 4 bytes in
 * length, and does not need to be null terminated.  To be safe, pass the
 * pre-defined chunk names here, and if you need a new one, define it
 * where the others are defined.  The length is the length of the data.
 * All the data must be present.  If that is not possible, use the
 * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
 * functions instead.
 */
static void
png_write_complete_chunk(png_structrp png_ptr, png_uint_32 chunk_name,
    png_const_bytep data, png_size_t length)
{
   if (png_ptr == NULL)
      return;

   /* On 64-bit architectures 'length' may not fit in a png_uint_32. */
   if (length > PNG_UINT_31_MAX)
      png_error(png_ptr, "length exceeds PNG maximum");

   png_write_chunk_header(png_ptr, chunk_name, (png_uint_32)length);
   png_write_chunk_data(png_ptr, data, length);
   png_write_chunk_end(png_ptr);
}

/* This is the API that calls the internal function above. */
void PNGAPI
png_write_chunk(png_structrp png_ptr, png_const_bytep chunk_string,
    png_const_bytep data, png_size_t length)
{
   png_write_complete_chunk(png_ptr, PNG_CHUNK_FROM_STRING(chunk_string), data,
       length);
}

/* This is used below to find the size of an image to pass to png_deflate_claim,
 * so it only needs to be accurate if the size is less than 16384 bytes (the
 * point at which a lower LZ window size can be used.)
 */
static png_alloc_size_t
png_image_size(png_structrp png_ptr)
{
   /* Only return sizes up to the maximum of a png_uint_32; do this by limiting
    * the width and height used to 15 bits.
    */
   png_uint_32 h = png_ptr->height;

   if (png_ptr->rowbytes < 32768 && h < 32768)
   {
      if (png_ptr->interlaced != 0)
      {
         /* Interlacing makes the image larger because of the replication of
          * both the filter byte and the padding to a byte boundary.
          */
         png_uint_32 w = png_ptr->width;
         unsigned int pd = png_ptr->pixel_depth;
         png_alloc_size_t cb_base;
         int pass;

         for (cb_base=0, pass=0; pass<=6; ++pass)
         {
            png_uint_32 pw = PNG_PASS_COLS(w, pass);

            if (pw > 0)
               cb_base += (PNG_ROWBYTES(pd, pw)+1) * PNG_PASS_ROWS(h, pass);
         }

         return cb_base;
      }

      else
         return (png_ptr->rowbytes+1) * h;
   }

   else
      return 0xffffffffU;
}

#ifdef PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
   /* This is the code to hack the first two bytes of the deflate stream (the
    * deflate header) to correct the windowBits value to match the actual data
    * size.  Note that the second argument is the *uncompressed* size but the
    * first argument is the *compressed* data (and it must be deflate
    * compressed.)
    */
static void
optimize_cmf(png_bytep data, png_alloc_size_t data_size)
{
   /* Optimize the CMF field in the zlib stream.  The resultant zlib stream is
    * still compliant to the stream specification.
    */
   if (data_size <= 16384) /* else windowBits must be 15 */
   {
      unsigned int z_cmf = data[0];  /* zlib compression method and flags */

      if ((z_cmf & 0x0f) == 8 && (z_cmf & 0xf0) <= 0x70)
      {
         unsigned int z_cinfo;
         unsigned int half_z_window_size;

         z_cinfo = z_cmf >> 4;
         half_z_window_size = 1U << (z_cinfo + 7);

         if (data_size <= half_z_window_size) /* else no change */
         {
            unsigned int tmp;

            do
            {
               half_z_window_size >>= 1;
               --z_cinfo;
            }
            while (z_cinfo > 0 && data_size <= half_z_window_size);

            z_cmf = (z_cmf & 0x0f) | (z_cinfo << 4);

            data[0] = (png_byte)z_cmf;
            tmp = data[1] & 0xe0;
            tmp += 0x1f - ((z_cmf << 8) + tmp) % 0x1f;
            data[1] = (png_byte)tmp;
         }
      }
   }
}
#endif /* WRITE_OPTIMIZE_CMF */

/* Initialize the compressor for the appropriate type of compression. */
static int
png_deflate_claim(png_structrp png_ptr, png_uint_32 owner,
    png_alloc_size_t data_size)
{
   if (png_ptr->zowner != 0)
   {
#if defined(PNG_WARNINGS_SUPPORTED) || defined(PNG_ERROR_TEXT_SUPPORTED)
      char msg[64];

      PNG_STRING_FROM_CHUNK(msg, owner);
      msg[4] = ':';
      msg[5] = ' ';
      PNG_STRING_FROM_CHUNK(msg+6, png_ptr->zowner);
      /* So the message that results is "<chunk> using zstream"; this is an
       * internal error, but is very useful for debugging.  i18n requirements
       * are minimal.
       */
      (void)png_safecat(msg, (sizeof msg), 10, " using zstream");
#endif
#if PNG_RELEASE_BUILD
         png_warning(png_ptr, msg);

         /* Attempt sane error recovery */
         if (png_ptr->zowner == png_IDAT) /* don't steal from IDAT */
         {
            png_ptr->zstream.msg = PNGZ_MSG_CAST("in use by IDAT");
            return Z_STREAM_ERROR;
         }

         png_ptr->zowner = 0;
#else
         png_error(png_ptr, msg);
#endif
   }

   {
      int level = png_ptr->zlib_level;
      int method = png_ptr->zlib_method;
      int windowBits = png_ptr->zlib_window_bits;
      int memLevel = png_ptr->zlib_mem_level;
      int strategy; /* set below */
      int ret; /* zlib return code */

      if (owner == png_IDAT)
      {
         if ((png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_STRATEGY) != 0)
            strategy = png_ptr->zlib_strategy;

         else if (png_ptr->do_filter != PNG_FILTER_NONE)
            strategy = PNG_Z_DEFAULT_STRATEGY;

         else
            strategy = PNG_Z_DEFAULT_NOFILTER_STRATEGY;
      }

      else
      {
#ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
            level = png_ptr->zlib_text_level;
            method = png_ptr->zlib_text_method;
            windowBits = png_ptr->zlib_text_window_bits;
            memLevel = png_ptr->zlib_text_mem_level;
            strategy = png_ptr->zlib_text_strategy;
#else
            /* If customization is not supported the values all come from the
             * IDAT values except for the strategy, which is fixed to the
             * default.  (This is the pre-1.6.0 behavior too, although it was
             * implemented in a very different way.)
             */
            strategy = Z_DEFAULT_STRATEGY;
#endif
      }

      /* Adjust 'windowBits' down if larger than 'data_size'; to stop this
       * happening just pass 32768 as the data_size parameter.  Notice that zlib
       * requires an extra 262 bytes in the window in addition to the data to be
       * able to see the whole of the data, so if data_size+262 takes us to the
       * next windowBits size we need to fix up the value later.  (Because even
       * though deflate needs the extra window, inflate does not!)
       */
      if (data_size <= 16384)
      {
         /* IMPLEMENTATION NOTE: this 'half_window_size' stuff is only here to
          * work round a Microsoft Visual C misbehavior which, contrary to C-90,
          * widens the result of the following shift to 64-bits if (and,
          * apparently, only if) it is used in a test.
          */
         unsigned int half_window_size = 1U << (windowBits-1);

         while (data_size + 262 <= half_window_size)
         {
            half_window_size >>= 1;
            --windowBits;
         }
      }

      /* Check against the previous initialized values, if any. */
      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0 &&
         (png_ptr->zlib_set_level != level ||
         png_ptr->zlib_set_method != method ||
         png_ptr->zlib_set_window_bits != windowBits ||
         png_ptr->zlib_set_mem_level != memLevel ||
         png_ptr->zlib_set_strategy != strategy))
      {
         if (deflateEnd(&png_ptr->zstream) != Z_OK)
            png_warning(png_ptr, "deflateEnd failed (ignored)");

         png_ptr->flags &= ~PNG_FLAG_ZSTREAM_INITIALIZED;
      }

      /* For safety clear out the input and output pointers (currently zlib
       * doesn't use them on Init, but it might in the future).
       */
      png_ptr->zstream.next_in = NULL;
      png_ptr->zstream.avail_in = 0;
      png_ptr->zstream.next_out = NULL;
      png_ptr->zstream.avail_out = 0;

      /* Now initialize if required, setting the new parameters, otherwise just
       * do a simple reset to the previous parameters.
       */
      if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
         ret = deflateReset(&png_ptr->zstream);

      else
      {
         ret = deflateInit2(&png_ptr->zstream, level, method, windowBits,
             memLevel, strategy);

         if (ret == Z_OK)
            png_ptr->flags |= PNG_FLAG_ZSTREAM_INITIALIZED;
      }

      /* The return code is from either deflateReset or deflateInit2; they have
       * pretty much the same set of error codes.
       */
      if (ret == Z_OK)
         png_ptr->zowner = owner;

      else
         png_zstream_error(png_ptr, ret);

      return ret;
   }
}

/* Clean up (or trim) a linked list of compression buffers. */
void /* PRIVATE */
png_free_buffer_list(png_structrp png_ptr, png_compression_bufferp *listp)
{
   png_compression_bufferp list = *listp;

   if (list != NULL)
   {
      *listp = NULL;

      do
      {
         png_compression_bufferp next = list->next;

         png_free(png_ptr, list);
         list = next;
      }
      while (list != NULL);
   }
}

#ifdef PNG_WRITE_COMPRESSED_TEXT_SUPPORTED
/* This pair of functions encapsulates the operation of (a) compressing a
 * text string, and (b) issuing it later as a series of chunk data writes.
 * The compression_state structure is shared context for these functions
 * set up by the caller to allow access to the relevant local variables.
 *
 * compression_buffer (new in 1.6.0) is just a linked list of zbuffer_size
 * temporary buffers.  From 1.6.0 it is retained in png_struct so that it will
 * be correctly freed in the event of a write error (previous implementations
 * just leaked memory.)
 */
typedef struct
{
   png_const_bytep      input;        /* The uncompressed input data */
   png_alloc_size_t     input_len;    /* Its length */
   png_uint_32          output_len;   /* Final compressed length */
   png_byte             output[1024]; /* First block of output */
} compression_state;

static void
png_text_compress_init(compression_state *comp, png_const_bytep input,
    png_alloc_size_t input_len)
{
   comp->input = input;
   comp->input_len = input_len;
   comp->output_len = 0;
}

/* Compress the data in the compression state input */
static int
png_text_compress(png_structrp png_ptr, png_uint_32 chunk_name,
    compression_state *comp, png_uint_32 prefix_len)
{
   int ret;

   /* To find the length of the output it is necessary to first compress the
    * input. The result is buffered rather than using the two-pass algorithm
    * that is used on the inflate side; deflate is assumed to be slower and a
    * PNG writer is assumed to have more memory available than a PNG reader.
    *
    * IMPLEMENTATION NOTE: the zlib API deflateBound() can be used to find an
    * upper limit on the output size, but it is always bigger than the input
    * size so it is likely to be more efficient to use this linked-list
    * approach.
    */
   ret = png_deflate_claim(png_ptr, chunk_name, comp->input_len);

   if (ret != Z_OK)
      return ret;

   /* Set up the compression buffers, we need a loop here to avoid overflowing a
    * uInt.  Use ZLIB_IO_MAX to limit the input.  The output is always limited
    * by the output buffer size, so there is no need to check that.  Since this
    * is ANSI-C we know that an 'int', hence a uInt, is always at least 16 bits
    * in size.
    */
   {
      png_compression_bufferp *end = &png_ptr->zbuffer_list;
      png_alloc_size_t input_len = comp->input_len; /* may be zero! */
      png_uint_32 output_len;

      /* zlib updates these for us: */
      png_ptr->zstream.next_in = PNGZ_INPUT_CAST(comp->input);
      png_ptr->zstream.avail_in = 0; /* Set below */
      png_ptr->zstream.next_out = comp->output;
      png_ptr->zstream.avail_out = (sizeof comp->output);

      output_len = png_ptr->zstream.avail_out;

      do
      {
         uInt avail_in = ZLIB_IO_MAX;

         if (avail_in > input_len)
            avail_in = (uInt)input_len;

         input_len -= avail_in;

         png_ptr->zstream.avail_in = avail_in;

         if (png_ptr->zstream.avail_out == 0)
         {
            png_compression_buffer *next;

            /* Chunk data is limited to 2^31 bytes in length, so the prefix
             * length must be counted here.
             */
            if (output_len + prefix_len > PNG_UINT_31_MAX)
            {
               ret = Z_MEM_ERROR;
               break;
            }

            /* Need a new (malloc'ed) buffer, but there may be one present
             * already.
             */
            next = *end;
            if (next == NULL)
            {
               next = png_voidcast(png_compression_bufferp, png_malloc_base
                  (png_ptr, PNG_COMPRESSION_BUFFER_SIZE(png_ptr)));

               if (next == NULL)
               {
                  ret = Z_MEM_ERROR;
                  break;
               }

               /* Link in this buffer (so that it will be freed later) */
               next->next = NULL;
               *end = next;
            }

            png_ptr->zstream.next_out = next->output;
            png_ptr->zstream.avail_out = png_ptr->zbuffer_size;
            output_len += png_ptr->zstream.avail_out;

            /* Move 'end' to the next buffer pointer. */
            end = &next->next;
         }

         /* Compress the data */
         ret = deflate(&png_ptr->zstream,
             input_len > 0 ? Z_NO_FLUSH : Z_FINISH);

         /* Claw back input data that was not consumed (because avail_in is
          * reset above every time round the loop).
          */
         input_len += png_ptr->zstream.avail_in;
         png_ptr->zstream.avail_in = 0; /* safety */
      }
      while (ret == Z_OK);

      /* There may be some space left in the last output buffer. This needs to
       * be subtracted from output_len.
       */
      output_len -= png_ptr->zstream.avail_out;
      png_ptr->zstream.avail_out = 0; /* safety */
      comp->output_len = output_len;

      /* Now double check the output length, put in a custom message if it is
       * too long.  Otherwise ensure the z_stream::msg pointer is set to
       * something.
       */
      if (output_len + prefix_len >= PNG_UINT_31_MAX)
      {
         png_ptr->zstream.msg = PNGZ_MSG_CAST("compressed data too long");
         ret = Z_MEM_ERROR;
      }

      else
         png_zstream_error(png_ptr, ret);

      /* Reset zlib for another zTXt/iTXt or image data */
      png_ptr->zowner = 0;

      /* The only success case is Z_STREAM_END, input_len must be 0; if not this
       * is an internal error.
       */
      if (ret == Z_STREAM_END && input_len == 0)
      {
#ifdef PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
         /* Fix up the deflate header, if required */
         optimize_cmf(comp->output, comp->input_len);
#endif
         /* But Z_OK is returned, not Z_STREAM_END; this allows the claim
          * function above to return Z_STREAM_END on an error (though it never
          * does in the current versions of zlib.)
          */
         return Z_OK;
      }

      else
         return ret;
   }
}

/* Ship the compressed text out via chunk writes */
static void
png_write_compressed_data_out(png_structrp png_ptr, compression_state *comp)
{
   png_uint_32 output_len = comp->output_len;
   png_const_bytep output = comp->output;
   png_uint_32 avail = (sizeof comp->output);
   png_compression_buffer *next = png_ptr->zbuffer_list;

   for (;;)
   {
      if (avail > output_len)
         avail = output_len;

      png_write_chunk_data(png_ptr, output, avail);

      output_len -= avail;

      if (output_len == 0 || next == NULL)
         break;

      avail = png_ptr->zbuffer_size;
      output = next->output;
      next = next->next;
   }

   /* This is an internal error; 'next' must have been NULL! */
   if (output_len > 0)
      png_error(png_ptr, "error writing ancillary chunked compressed data");
}
#endif /* WRITE_COMPRESSED_TEXT */

/* Write the IHDR chunk, and update the png_struct with the necessary
 * information.  Note that the rest of this code depends upon this
 * information being correct.
 */
void /* PRIVATE */
png_write_IHDR(png_structrp png_ptr, png_uint_32 width, png_uint_32 height,
    int bit_depth, int color_type, int compression_type, int filter_type,
    int interlace_type)
{
   png_byte buf[13]; /* Buffer to store the IHDR info */

   png_debug(1, "in png_write_IHDR");

   /* Check that we have valid input data from the application info */
   switch (color_type)
   {
      case PNG_COLOR_TYPE_GRAY:
         switch (bit_depth)
         {
            case 1:
            case 2:
            case 4:
            case 8:
#ifdef PNG_WRITE_16BIT_SUPPORTED
            case 16:
#endif
               png_ptr->channels = 1; break;

            default:
               png_error(png_ptr,
                   "Invalid bit depth for grayscale image");
         }
         break;

      case PNG_COLOR_TYPE_RGB:
#ifdef PNG_WRITE_16BIT_SUPPORTED
         if (bit_depth != 8 && bit_depth != 16)
#else
         if (bit_depth != 8)
#endif
            png_error(png_ptr, "Invalid bit depth for RGB image");

         png_ptr->channels = 3;
         break;

      case PNG_COLOR_TYPE_PALETTE:
         switch (bit_depth)
         {
            case 1:
            case 2:
            case 4:
            case 8:
               png_ptr->channels = 1;
               break;

            default:
               png_error(png_ptr, "Invalid bit depth for paletted image");
         }
         break;

      case PNG_COLOR_TYPE_GRAY_ALPHA:
         if (bit_depth != 8 && bit_depth != 16)
            png_error(png_ptr, "Invalid bit depth for grayscale+alpha image");

         png_ptr->channels = 2;
         break;

      case PNG_COLOR_TYPE_RGB_ALPHA:
#ifdef PNG_WRITE_16BIT_SUPPORTED
         if (bit_depth != 8 && bit_depth != 16)
#else
         if (bit_depth != 8)
#endif
            png_error(png_ptr, "Invalid bit depth for RGBA image");

         png_ptr->channels = 4;
         break;

      default:
         png_error(png_ptr, "Invalid image color type specified");
   }

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
   {
      png_warning(png_ptr, "Invalid compression type specified");
      compression_type = PNG_COMPRESSION_TYPE_BASE;
   }

   /* Write filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not write a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA
    */
   if (
#ifdef PNG_MNG_FEATURES_SUPPORTED
       !((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) != 0 &&
       ((png_ptr->mode & PNG_HAVE_PNG_SIGNATURE) == 0) &&
       (color_type == PNG_COLOR_TYPE_RGB ||
        color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
       (filter_type == PNG_INTRAPIXEL_DIFFERENCING)) &&
#endif
       filter_type != PNG_FILTER_TYPE_BASE)
   {
      png_warning(png_ptr, "Invalid filter type specified");
      filter_type = PNG_FILTER_TYPE_BASE;
   }

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   if (interlace_type != PNG_INTERLACE_NONE &&
       interlace_type != PNG_INTERLACE_ADAM7)
   {
      png_warning(png_ptr, "Invalid interlace type specified");
      interlace_type = PNG_INTERLACE_ADAM7;
   }
#else
   interlace_type=PNG_INTERLACE_NONE;
#endif

   /* Save the relevant information */
   png_ptr->bit_depth = (png_byte)bit_depth;
   png_ptr->color_type = (png_byte)color_type;
   png_ptr->interlaced = (png_byte)interlace_type;
#ifdef PNG_MNG_FEATURES_SUPPORTED
   png_ptr->filter_type = (png_byte)filter_type;
#endif
   png_ptr->compression_type = (png_byte)compression_type;
   png_ptr->width = width;
   png_ptr->height = height;

   png_ptr->pixel_depth = (png_byte)(bit_depth * png_ptr->channels);
   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, width);
   /* Set the usr info, so any transformations can modify it */
   png_ptr->usr_width = png_ptr->width;
   png_ptr->usr_bit_depth = png_ptr->bit_depth;
   png_ptr->usr_channels = png_ptr->channels;

   /* Pack the header information into the buffer */
   png_save_uint_32(buf, width);
   png_save_uint_32(buf + 4, height);
   buf[8] = (png_byte)bit_depth;
   buf[9] = (png_byte)color_type;
   buf[10] = (png_byte)compression_type;
   buf[11] = (png_byte)filter_type;
   buf[12] = (png_byte)interlace_type;

   /* Write the chunk */
   png_write_complete_chunk(png_ptr, png_IHDR, buf, (png_size_t)13);

   if ((png_ptr->do_filter) == PNG_NO_FILTERS)
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
          png_ptr->bit_depth < 8)
         png_ptr->do_filter = PNG_FILTER_NONE;

      else
         png_ptr->do_filter = PNG_ALL_FILTERS;
   }

   png_ptr->mode = PNG_HAVE_IHDR; /* not READY_FOR_ZTXT */
}

/* Write the palette.  We are careful not to trust png_color to be in the
 * correct order for PNG, so people can redefine it to any convenient
 * structure.
 */
void /* PRIVATE */
png_write_PLTE(png_structrp png_ptr, png_const_colorp palette,
    png_uint_32 num_pal)
{
   png_uint_32 max_palette_length, i;
   png_const_colorp pal_ptr;
   png_byte buf[3];

   png_debug(1, "in png_write_PLTE");

   max_palette_length = (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?
      (1 << png_ptr->bit_depth) : PNG_MAX_PALETTE_LENGTH;

   if ((
#ifdef PNG_MNG_FEATURES_SUPPORTED
       (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0 &&
#endif
       num_pal == 0) || num_pal > max_palette_length)
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         png_error(png_ptr, "Invalid number of colors in palette");
      }

      else
      {
         png_warning(png_ptr, "Invalid number of colors in palette");
         return;
      }
   }

   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)
   {
      png_warning(png_ptr,
          "Ignoring request to write a PLTE chunk in grayscale PNG");

      return;
   }

   png_ptr->num_palette = (png_uint_16)num_pal;
   png_debug1(3, "num_palette = %d", png_ptr->num_palette);

   png_write_chunk_header(png_ptr, png_PLTE, (png_uint_32)(num_pal * 3));
#ifdef PNG_POINTER_INDEXING_SUPPORTED

   for (i = 0, pal_ptr = palette; i < num_pal; i++, pal_ptr++)
   {
      buf[0] = pal_ptr->red;
      buf[1] = pal_ptr->green;
      buf[2] = pal_ptr->blue;
      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
   }

#else
   /* This is a little slower but some buggy compilers need to do this
    * instead
    */
   pal_ptr=palette;

   for (i = 0; i < num_pal; i++)
   {
      buf[0] = pal_ptr[i].red;
      buf[1] = pal_ptr[i].green;
      buf[2] = pal_ptr[i].blue;
      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
   }

#endif
   png_write_chunk_end(png_ptr);
   png_ptr->mode |= PNG_HAVE_PLTE;
}

/* This is similar to png_text_compress, above, except that it does not require
 * all of the data at once and, instead of buffering the compressed result,
 * writes it as IDAT chunks.  Unlike png_text_compress it *can* png_error out
 * because it calls the write interface.  As a result it does its own error
 * reporting and does not return an error code.  In the event of error it will
 * just call png_error.  The input data length may exceed 32-bits.  The 'flush'
 * parameter is exactly the same as that to deflate, with the following
 * meanings:
 *
 * Z_NO_FLUSH: normal incremental output of compressed data
 * Z_SYNC_FLUSH: do a SYNC_FLUSH, used by png_write_flush
 * Z_FINISH: this is the end of the input, do a Z_FINISH and clean up
 *
 * The routine manages the acquire and release of the png_ptr->zstream by
 * checking and (at the end) clearing png_ptr->zowner; it does some sanity
 * checks on the 'mode' flags while doing this.
 */
void /* PRIVATE */
png_compress_IDAT(png_structrp png_ptr, png_const_bytep input,
    png_alloc_size_t input_len, int flush)
{
   if (png_ptr->zowner != png_IDAT)
   {
      /* First time.   Ensure we have a temporary buffer for compression and
       * trim the buffer list if it has more than one entry to free memory.
       * If 'WRITE_COMPRESSED_TEXT' is not set the list will never have been
       * created at this point, but the check here is quick and safe.
       */
      if (png_ptr->zbuffer_list == NULL)
      {
         png_ptr->zbuffer_list = png_voidcast(png_compression_bufferp,
             png_malloc(png_ptr, PNG_COMPRESSION_BUFFER_SIZE(png_ptr)));
         png_ptr->zbuffer_list->next = NULL;
      }

      else
         png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list->next);

      /* It is a terminal error if we can't claim the zstream. */
      if (png_deflate_claim(png_ptr, png_IDAT, png_image_size(png_ptr)) != Z_OK)
         png_error(png_ptr, png_ptr->zstream.msg);

      /* The output state is maintained in png_ptr->zstream, so it must be
       * initialized here after the claim.
       */
      png_ptr->zstream.next_out = png_ptr->zbuffer_list->output;
      png_ptr->zstream.avail_out = png_ptr->zbuffer_size;
   }

   /* Now loop reading and writing until all the input is consumed or an error
    * terminates the operation.  The _out values are maintained across calls to
    * this function, but the input must be reset each time.
    */
   png_ptr->zstream.next_in = PNGZ_INPUT_CAST(input);
   png_ptr->zstream.avail_in = 0; /* set below */
   for (;;)
   {
      int ret;

      /* INPUT: from the row data */
      uInt avail = ZLIB_IO_MAX;

      if (avail > input_len)
         avail = (uInt)input_len; /* safe because of the check */

      png_ptr->zstream.avail_in = avail;
      input_len -= avail;

      ret = deflate(&png_ptr->zstream, input_len > 0 ? Z_NO_FLUSH : flush);

      /* Include as-yet unconsumed input */
      input_len += png_ptr->zstream.avail_in;
      png_ptr->zstream.avail_in = 0;

      /* OUTPUT: write complete IDAT chunks when avail_out drops to zero. Note
       * that these two zstream fields are preserved across the calls, therefore
       * there is no need to set these up on entry to the loop.
       */
      if (png_ptr->zstream.avail_out == 0)
      {
         png_bytep data = png_ptr->zbuffer_list->output;
         uInt size = png_ptr->zbuffer_size;

         /* Write an IDAT containing the data then reset the buffer.  The
          * first IDAT may need deflate header optimization.
          */
#ifdef PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
            if ((png_ptr->mode & PNG_HAVE_IDAT) == 0 &&
                png_ptr->compression_type == PNG_COMPRESSION_TYPE_BASE)
               optimize_cmf(data, png_image_size(png_ptr));
#endif

         png_write_complete_chunk(png_ptr, png_IDAT, data, size);
         png_ptr->mode |= PNG_HAVE_IDAT;

         png_ptr->zstream.next_out = data;
         png_ptr->zstream.avail_out = size;

         /* For SYNC_FLUSH or FINISH it is essential to keep calling zlib with
          * the same flush parameter until it has finished output, for NO_FLUSH
          * it doesn't matter.
          */
         if (ret == Z_OK && flush != Z_NO_FLUSH)
            continue;
      }

      /* The order of these checks doesn't matter much; it just affects which
       * possible error might be detected if multiple things go wrong at once.
       */
      if (ret == Z_OK) /* most likely return code! */
      {
         /* If all the input has been consumed then just return.  If Z_FINISH
          * was used as the flush parameter something has gone wrong if we get
          * here.
          */
         if (input_len == 0)
         {
            if (flush == Z_FINISH)
               png_error(png_ptr, "Z_OK on Z_FINISH with output space");

            return;
         }
      }

      else if (ret == Z_STREAM_END && flush == Z_FINISH)
      {
         /* This is the end of the IDAT data; any pending output must be
          * flushed.  For small PNG files we may still be at the beginning.
          */
         png_bytep data = png_ptr->zbuffer_list->output;
         uInt size = png_ptr->zbuffer_size - png_ptr->zstream.avail_out;

#ifdef PNG_WRITE_OPTIMIZE_CMF_SUPPORTED
         if ((png_ptr->mode & PNG_HAVE_IDAT) == 0 &&
             png_ptr->compression_type == PNG_COMPRESSION_TYPE_BASE)
            optimize_cmf(data, png_image_size(png_ptr));
#endif

         png_write_complete_chunk(png_ptr, png_IDAT, data, size);
         png_ptr->zstream.avail_out = 0;
         png_ptr->zstream.next_out = NULL;
         png_ptr->mode |= PNG_HAVE_IDAT | PNG_AFTER_IDAT;

         png_ptr->zowner = 0; /* Release the stream */
         return;
      }

      else
      {
         /* This is an error condition. */
         png_zstream_error(png_ptr, ret);
         png_error(png_ptr, png_ptr->zstream.msg);
      }
   }
}

/* Write an IEND chunk */
void /* PRIVATE */
png_write_IEND(png_structrp png_ptr)
{
   png_debug(1, "in png_write_IEND");

   png_write_complete_chunk(png_ptr, png_IEND, NULL, (png_size_t)0);
   png_ptr->mode |= PNG_HAVE_IEND;
}

#ifdef PNG_WRITE_gAMA_SUPPORTED
/* Write a gAMA chunk */
void /* PRIVATE */
png_write_gAMA_fixed(png_structrp png_ptr, png_fixed_point file_gamma)
{
   png_byte buf[4];

   png_debug(1, "in png_write_gAMA");

   /* file_gamma is saved in 1/100,000ths */
   png_save_uint_32(buf, (png_uint_32)file_gamma);
   png_write_complete_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
}
#endif

#ifdef PNG_WRITE_sRGB_SUPPORTED
/* Write a sRGB chunk */
void /* PRIVATE */
png_write_sRGB(png_structrp png_ptr, int srgb_intent)
{
   png_byte buf[1];

   png_debug(1, "in png_write_sRGB");

   if (srgb_intent >= PNG_sRGB_INTENT_LAST)
      png_warning(png_ptr,
          "Invalid sRGB rendering intent specified");

   buf[0]=(png_byte)srgb_intent;
   png_write_complete_chunk(png_ptr, png_sRGB, buf, (png_size_t)1);
}
#endif

#ifdef PNG_WRITE_iCCP_SUPPORTED
/* Write an iCCP chunk */
void /* PRIVATE */
png_write_iCCP(png_structrp png_ptr, png_const_charp name,
    png_const_bytep profile)
{
   png_uint_32 name_len;
   png_uint_32 profile_len;
   png_byte new_name[81]; /* 1 byte for the compression byte */
   compression_state comp;
   png_uint_32 temp;

   png_debug(1, "in png_write_iCCP");

   /* These are all internal problems: the profile should have been checked
    * before when it was stored.
    */
   if (profile == NULL)
      png_error(png_ptr, "No profile for iCCP chunk"); /* internal error */

   profile_len = png_get_uint_32(profile);

   if (profile_len < 132)
      png_error(png_ptr, "ICC profile too short");

   temp = (png_uint_32) (*(profile+8));
   if (temp > 3 && (profile_len & 0x03))
      png_error(png_ptr, "ICC profile length invalid (not a multiple of 4)");

   {
      png_uint_32 embedded_profile_len = png_get_uint_32(profile);

      if (profile_len != embedded_profile_len)
         png_error(png_ptr, "Profile length does not match profile");
   }

   name_len = png_check_keyword(png_ptr, name, new_name);

   if (name_len == 0)
      png_error(png_ptr, "iCCP: invalid keyword");

   new_name[++name_len] = PNG_COMPRESSION_TYPE_BASE;

   /* Make sure we include the NULL after the name and the compression type */
   ++name_len;

   png_text_compress_init(&comp, profile, profile_len);

   /* Allow for keyword terminator and compression byte */
   if (png_text_compress(png_ptr, png_iCCP, &comp, name_len) != Z_OK)
      png_error(png_ptr, png_ptr->zstream.msg);

   png_write_chunk_header(png_ptr, png_iCCP, name_len + comp.output_len);

   png_write_chunk_data(png_ptr, new_name, name_len);

   png_write_compressed_data_out(png_ptr, &comp);

   png_write_chunk_end(png_ptr);
}
#endif

#ifdef PNG_WRITE_sPLT_SUPPORTED
/* Write a sPLT chunk */
void /* PRIVATE */
png_write_sPLT(png_structrp png_ptr, png_const_sPLT_tp spalette)
{
   png_uint_32 name_len;
   png_byte new_name[80];
   png_byte entrybuf[10];
   png_size_t entry_size = (spalette->depth == 8 ? 6 : 10);
   png_size_t palette_size = entry_size * (png_size_t)spalette->nentries;
   png_sPLT_entryp ep;
#ifndef PNG_POINTER_INDEXING_SUPPORTED
   int i;
#endif

   png_debug(1, "in png_write_sPLT");

   name_len = png_check_keyword(png_ptr, spalette->name, new_name);

   if (name_len == 0)
      png_error(png_ptr, "sPLT: invalid keyword");

   /* Make sure we include the NULL after the name */
   png_write_chunk_header(png_ptr, png_sPLT,
       (png_uint_32)(name_len + 2 + palette_size));

   png_write_chunk_data(png_ptr, (png_bytep)new_name,
       (png_size_t)(name_len + 1));

   png_write_chunk_data(png_ptr, &spalette->depth, (png_size_t)1);

   /* Loop through each palette entry, writing appropriately */
#ifdef PNG_POINTER_INDEXING_SUPPORTED
   for (ep = spalette->entries; ep<spalette->entries + spalette->nentries; ep++)
   {
      if (spalette->depth == 8)
      {
         entrybuf[0] = (png_byte)ep->red;
         entrybuf[1] = (png_byte)ep->green;
         entrybuf[2] = (png_byte)ep->blue;
         entrybuf[3] = (png_byte)ep->alpha;
         png_save_uint_16(entrybuf + 4, ep->frequency);
      }

      else
      {
         png_save_uint_16(entrybuf + 0, ep->red);
         png_save_uint_16(entrybuf + 2, ep->green);
         png_save_uint_16(entrybuf + 4, ep->blue);
         png_save_uint_16(entrybuf + 6, ep->alpha);
         png_save_uint_16(entrybuf + 8, ep->frequency);
      }

      png_write_chunk_data(png_ptr, entrybuf, entry_size);
   }
#else
   ep=spalette->entries;
   for (i = 0; i>spalette->nentries; i++)
   {
      if (spalette->depth == 8)
      {
         entrybuf[0] = (png_byte)ep[i].red;
         entrybuf[1] = (png_byte)ep[i].green;
         entrybuf[2] = (png_byte)ep[i].blue;
         entrybuf[3] = (png_byte)ep[i].alpha;
         png_save_uint_16(entrybuf + 4, ep[i].frequency);
      }

      else
      {
         png_save_uint_16(entrybuf + 0, ep[i].red);
         png_save_uint_16(entrybuf + 2, ep[i].green);
         png_save_uint_16(entrybuf + 4, ep[i].blue);
         png_save_uint_16(entrybuf + 6, ep[i].alpha);
         png_save_uint_16(entrybuf + 8, ep[i].frequency);
      }

      png_write_chunk_data(png_ptr, entrybuf, entry_size);
   }
#endif

   png_write_chunk_end(png_ptr);
}
#endif

#ifdef PNG_WRITE_sBIT_SUPPORTED
/* Write the sBIT chunk */
void /* PRIVATE */
png_write_sBIT(png_structrp png_ptr, png_const_color_8p sbit, int color_type)
{
   png_byte buf[4];
   png_size_t size;

   png_debug(1, "in png_write_sBIT");

   /* Make sure we don't depend upon the order of PNG_COLOR_8 */
   if ((color_type & PNG_COLOR_MASK_COLOR) != 0)
   {
      png_byte maxbits;

      maxbits = (png_byte)(color_type==PNG_COLOR_TYPE_PALETTE ? 8 :
          png_ptr->usr_bit_depth);

      if (sbit->red == 0 || sbit->red > maxbits ||
          sbit->green == 0 || sbit->green > maxbits ||
          sbit->blue == 0 || sbit->blue > maxbits)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }

      buf[0] = sbit->red;
      buf[1] = sbit->green;
      buf[2] = sbit->blue;
      size = 3;
   }

   else
   {
      if (sbit->gray == 0 || sbit->gray > png_ptr->usr_bit_depth)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }

      buf[0] = sbit->gray;
      size = 1;
   }

   if ((color_type & PNG_COLOR_MASK_ALPHA) != 0)
   {
      if (sbit->alpha == 0 || sbit->alpha > png_ptr->usr_bit_depth)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }

      buf[size++] = sbit->alpha;
   }

   png_write_complete_chunk(png_ptr, png_sBIT, buf, size);
}
#endif

#ifdef PNG_WRITE_cHRM_SUPPORTED
/* Write the cHRM chunk */
void /* PRIVATE */
png_write_cHRM_fixed(png_structrp png_ptr, const png_xy *xy)
{
   png_byte buf[32];

   png_debug(1, "in png_write_cHRM");

   /* Each value is saved in 1/100,000ths */
   png_save_int_32(buf,      xy->whitex);
   png_save_int_32(buf +  4, xy->whitey);

   png_save_int_32(buf +  8, xy->redx);
   png_save_int_32(buf + 12, xy->redy);

   png_save_int_32(buf + 16, xy->greenx);
   png_save_int_32(buf + 20, xy->greeny);

   png_save_int_32(buf + 24, xy->bluex);
   png_save_int_32(buf + 28, xy->bluey);

   png_write_complete_chunk(png_ptr, png_cHRM, buf, 32);
}
#endif

#ifdef PNG_WRITE_tRNS_SUPPORTED
/* Write the tRNS chunk */
void /* PRIVATE */
png_write_tRNS(png_structrp png_ptr, png_const_bytep trans_alpha,
    png_const_color_16p tran, int num_trans, int color_type)
{
   png_byte buf[6];

   png_debug(1, "in png_write_tRNS");

   if (color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (num_trans <= 0 || num_trans > (int)png_ptr->num_palette)
      {
         png_app_warning(png_ptr,
             "Invalid number of transparent colors specified");
         return;
      }

      /* Write the chunk out as it is */
      png_write_complete_chunk(png_ptr, png_tRNS, trans_alpha,
          (png_size_t)num_trans);
   }

   else if (color_type == PNG_COLOR_TYPE_GRAY)
   {
      /* One 16-bit value */
      if (tran->gray >= (1 << png_ptr->bit_depth))
      {
         png_app_warning(png_ptr,
             "Ignoring attempt to write tRNS chunk out-of-range for bit_depth");

         return;
      }

      png_save_uint_16(buf, tran->gray);
      png_write_complete_chunk(png_ptr, png_tRNS, buf, (png_size_t)2);
   }

   else if (color_type == PNG_COLOR_TYPE_RGB)
   {
      /* Three 16-bit values */
      png_save_uint_16(buf, tran->red);
      png_save_uint_16(buf + 2, tran->green);
      png_save_uint_16(buf + 4, tran->blue);
#ifdef PNG_WRITE_16BIT_SUPPORTED
      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]) != 0)
#else
      if ((buf[0] | buf[2] | buf[4]) != 0)
#endif
      {
         png_app_warning(png_ptr,
             "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
         return;
      }

      png_write_complete_chunk(png_ptr, png_tRNS, buf, (png_size_t)6);
   }

   else
   {
      png_app_warning(png_ptr, "Can't write tRNS with an alpha channel");
   }
}
#endif

#ifdef PNG_WRITE_bKGD_SUPPORTED
/* Write the background chunk */
void /* PRIVATE */
png_write_bKGD(png_structrp png_ptr, png_const_color_16p back, int color_type)
{
   png_byte buf[6];

   png_debug(1, "in png_write_bKGD");

   if (color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (
#ifdef PNG_MNG_FEATURES_SUPPORTED
          (png_ptr->num_palette != 0 ||
          (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0) &&
#endif
         back->index >= png_ptr->num_palette)
      {
         png_warning(png_ptr, "Invalid background palette index");
         return;
      }

      buf[0] = back->index;
      png_write_complete_chunk(png_ptr, png_bKGD, buf, (png_size_t)1);
   }

   else if ((color_type & PNG_COLOR_MASK_COLOR) != 0)
   {
      png_save_uint_16(buf, back->red);
      png_save_uint_16(buf + 2, back->green);
      png_save_uint_16(buf + 4, back->blue);
#ifdef PNG_WRITE_16BIT_SUPPORTED
      if (png_ptr->bit_depth == 8 && (buf[0] | buf[2] | buf[4]) != 0)
#else
      if ((buf[0] | buf[2] | buf[4]) != 0)
#endif
      {
         png_warning(png_ptr,
             "Ignoring attempt to write 16-bit bKGD chunk "
             "when bit_depth is 8");

         return;
      }

      png_write_complete_chunk(png_ptr, png_bKGD, buf, (png_size_t)6);
   }

   else
   {
      if (back->gray >= (1 << png_ptr->bit_depth))
      {
         png_warning(png_ptr,
             "Ignoring attempt to write bKGD chunk out-of-range for bit_depth");

         return;
      }

      png_save_uint_16(buf, back->gray);
      png_write_complete_chunk(png_ptr, png_bKGD, buf, (png_size_t)2);
   }
}
#endif

#ifdef PNG_WRITE_hIST_SUPPORTED
/* Write the histogram */
void /* PRIVATE */
png_write_hIST(png_structrp png_ptr, png_const_uint_16p hist, int num_hist)
{
   int i;
   png_byte buf[3];

   png_debug(1, "in png_write_hIST");

   if (num_hist > (int)png_ptr->num_palette)
   {
      png_debug2(3, "num_hist = %d, num_palette = %d", num_hist,
          png_ptr->num_palette);

      png_warning(png_ptr, "Invalid number of histogram entries specified");
      return;
   }

   png_write_chunk_header(png_ptr, png_hIST, (png_uint_32)(num_hist * 2));

   for (i = 0; i < num_hist; i++)
   {
      png_save_uint_16(buf, hist[i]);
      png_write_chunk_data(png_ptr, buf, (png_size_t)2);
   }

   png_write_chunk_end(png_ptr);
}
#endif

#ifdef PNG_WRITE_tEXt_SUPPORTED
/* Write a tEXt chunk */
void /* PRIVATE */
png_write_tEXt(png_structrp png_ptr, png_const_charp key, png_const_charp text,
    png_size_t text_len)
{
   png_uint_32 key_len;
   png_byte new_key[80];

   png_debug(1, "in png_write_tEXt");

   key_len = png_check_keyword(png_ptr, key, new_key);

   if (key_len == 0)
      png_error(png_ptr, "tEXt: invalid keyword");

   if (text == NULL || *text == '\0')
      text_len = 0;

   else
      text_len = strlen(text);

   if (text_len > PNG_UINT_31_MAX - (key_len+1))
      png_error(png_ptr, "tEXt: text too long");

   /* Make sure we include the 0 after the key */
   png_write_chunk_header(png_ptr, png_tEXt,
       (png_uint_32)/*checked above*/(key_len + text_len + 1));
   /*
    * We leave it to the application to meet PNG-1.0 requirements on the
    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
    * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
    * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
    */
   png_write_chunk_data(png_ptr, new_key, key_len + 1);

   if (text_len != 0)
      png_write_chunk_data(png_ptr, (png_const_bytep)text, text_len);

   png_write_chunk_end(png_ptr);
}
#endif

#ifdef PNG_WRITE_zTXt_SUPPORTED
/* Write a compressed text chunk */
void /* PRIVATE */
png_write_zTXt(png_structrp png_ptr, png_const_charp key, png_const_charp text,
    int compression)
{
   png_uint_32 key_len;
   png_byte new_key[81];
   compression_state comp;

   png_debug(1, "in png_write_zTXt");

   if (compression == PNG_TEXT_COMPRESSION_NONE)
   {
      png_write_tEXt(png_ptr, key, text, 0);
      return;
   }

   if (compression != PNG_TEXT_COMPRESSION_zTXt)
      png_error(png_ptr, "zTXt: invalid compression type");

   key_len = png_check_keyword(png_ptr, key, new_key);

   if (key_len == 0)
      png_error(png_ptr, "zTXt: invalid keyword");

   /* Add the compression method and 1 for the keyword separator. */
   new_key[++key_len] = PNG_COMPRESSION_TYPE_BASE;
   ++key_len;

   /* Compute the compressed data; do it now for the length */
   png_text_compress_init(&comp, (png_const_bytep)text,
       text == NULL ? 0 : strlen(text));

   if (png_text_compress(png_ptr, png_zTXt, &comp, key_len) != Z_OK)
      png_error(png_ptr, png_ptr->zstream.msg);

   /* Write start of chunk */
   png_write_chunk_header(png_ptr, png_zTXt, key_len + comp.output_len);

   /* Write key */
   png_write_chunk_data(png_ptr, new_key, key_len);

   /* Write the compressed data */
   png_write_compressed_data_out(png_ptr, &comp);

   /* Close the chunk */
   png_write_chunk_end(png_ptr);
}
#endif

#ifdef PNG_WRITE_iTXt_SUPPORTED
/* Write an iTXt chunk */
void /* PRIVATE */
png_write_iTXt(png_structrp png_ptr, int compression, png_const_charp key,
    png_const_charp lang, png_const_charp lang_key, png_const_charp text)
{
   png_uint_32 key_len, prefix_len;
   png_size_t lang_len, lang_key_len;
   png_byte new_key[82];
   compression_state comp;

   png_debug(1, "in png_write_iTXt");

   key_len = png_check_keyword(png_ptr, key, new_key);

   if (key_len == 0)
      png_error(png_ptr, "iTXt: invalid keyword");

   /* Set the compression flag */
   switch (compression)
   {
      case PNG_ITXT_COMPRESSION_NONE:
      case PNG_TEXT_COMPRESSION_NONE:
         compression = new_key[++key_len] = 0; /* no compression */
         break;

      case PNG_TEXT_COMPRESSION_zTXt:
      case PNG_ITXT_COMPRESSION_zTXt:
         compression = new_key[++key_len] = 1; /* compressed */
         break;

      default:
         png_error(png_ptr, "iTXt: invalid compression");
   }

   new_key[++key_len] = PNG_COMPRESSION_TYPE_BASE;
   ++key_len; /* for the keywod separator */

   /* We leave it to the application to meet PNG-1.0 requirements on the
    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
    * any non-Latin-1 characters except for NEWLINE.  ISO PNG, however,
    * specifies that the text is UTF-8 and this really doesn't require any
    * checking.
    *
    * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
    *
    * TODO: validate the language tag correctly (see the spec.)
    */
   if (lang == NULL) lang = ""; /* empty language is valid */
   lang_len = strlen(lang)+1;
   if (lang_key == NULL) lang_key = ""; /* may be empty */
   lang_key_len = strlen(lang_key)+1;
   if (text == NULL) text = ""; /* may be empty */

   prefix_len = key_len;
   if (lang_len > PNG_UINT_31_MAX-prefix_len)
      prefix_len = PNG_UINT_31_MAX;
   else
      prefix_len = (png_uint_32)(prefix_len + lang_len);

   if (lang_key_len > PNG_UINT_31_MAX-prefix_len)
      prefix_len = PNG_UINT_31_MAX;
   else
      prefix_len = (png_uint_32)(prefix_len + lang_key_len);

   png_text_compress_init(&comp, (png_const_bytep)text, strlen(text));

   if (compression != 0)
   {
      if (png_text_compress(png_ptr, png_iTXt, &comp, prefix_len) != Z_OK)
         png_error(png_ptr, png_ptr->zstream.msg);
   }

   else
   {
      if (comp.input_len > PNG_UINT_31_MAX-prefix_len)
         png_error(png_ptr, "iTXt: uncompressed text too long");

      /* So the string will fit in a chunk: */
      comp.output_len = (png_uint_32)/*SAFE*/comp.input_len;
   }

   png_write_chunk_header(png_ptr, png_iTXt, comp.output_len + prefix_len);

   png_write_chunk_data(png_ptr, new_key, key_len);

   png_write_chunk_data(png_ptr, (png_const_bytep)lang, lang_len);

   png_write_chunk_data(png_ptr, (png_const_bytep)lang_key, lang_key_len);

   if (compression != 0)
      png_write_compressed_data_out(png_ptr, &comp);

   else
      png_write_chunk_data(png_ptr, (png_const_bytep)text, comp.output_len);

   png_write_chunk_end(png_ptr);
}
#endif

#ifdef PNG_WRITE_oFFs_SUPPORTED
/* Write the oFFs chunk */
void /* PRIVATE */
png_write_oFFs(png_structrp png_ptr, png_int_32 x_offset, png_int_32 y_offset,
    int unit_type)
{
   png_byte buf[9];

   png_debug(1, "in png_write_oFFs");

   if (unit_type >= PNG_OFFSET_LAST)
      png_warning(png_ptr, "Unrecognized unit type for oFFs chunk");

   png_save_int_32(buf, x_offset);
   png_save_int_32(buf + 4, y_offset);
   buf[8] = (png_byte)unit_type;

   png_write_complete_chunk(png_ptr, png_oFFs, buf, (png_size_t)9);
}
#endif
#ifdef PNG_WRITE_pCAL_SUPPORTED
/* Write the pCAL chunk (described in the PNG extensions document) */
void /* PRIVATE */
png_write_pCAL(png_structrp png_ptr, png_charp purpose, png_int_32 X0,
    png_int_32 X1, int type, int nparams, png_const_charp units,
    png_charpp params)
{
   png_uint_32 purpose_len;
   png_size_t units_len, total_len;
   png_size_tp params_len;
   png_byte buf[10];
   png_byte new_purpose[80];
   int i;

   png_debug1(1, "in png_write_pCAL (%d parameters)", nparams);

   if (type >= PNG_EQUATION_LAST)
      png_error(png_ptr, "Unrecognized equation type for pCAL chunk");

   purpose_len = png_check_keyword(png_ptr, purpose, new_purpose);

   if (purpose_len == 0)
      png_error(png_ptr, "pCAL: invalid keyword");

   ++purpose_len; /* terminator */

   png_debug1(3, "pCAL purpose length = %d", (int)purpose_len);
   units_len = strlen(units) + (nparams == 0 ? 0 : 1);
   png_debug1(3, "pCAL units length = %d", (int)units_len);
   total_len = purpose_len + units_len + 10;

   params_len = (png_size_tp)png_malloc(png_ptr,
       (png_alloc_size_t)((png_alloc_size_t)nparams * (sizeof (png_size_t))));

   /* Find the length of each parameter, making sure we don't count the
    * null terminator for the last parameter.
    */
   for (i = 0; i < nparams; i++)
   {
      params_len[i] = strlen(params[i]) + (i == nparams - 1 ? 0 : 1);
      png_debug2(3, "pCAL parameter %d length = %lu", i,
          (unsigned long)params_len[i]);
      total_len += params_len[i];
   }

   png_debug1(3, "pCAL total length = %d", (int)total_len);
   png_write_chunk_header(png_ptr, png_pCAL, (png_uint_32)total_len);
   png_write_chunk_data(png_ptr, new_purpose, purpose_len);
   png_save_int_32(buf, X0);
   png_save_int_32(buf + 4, X1);
   buf[8] = (png_byte)type;
   buf[9] = (png_byte)nparams;
   png_write_chunk_data(png_ptr, buf, (png_size_t)10);
   png_write_chunk_data(png_ptr, (png_const_bytep)units, (png_size_t)units_len);

   for (i = 0; i < nparams; i++)
   {
      png_write_chunk_data(png_ptr, (png_const_bytep)params[i], params_len[i]);
   }

   png_free(png_ptr, params_len);
   png_write_chunk_end(png_ptr);
}
#endif

#ifdef PNG_WRITE_sCAL_SUPPORTED
/* Write the sCAL chunk */
void /* PRIVATE */
png_write_sCAL_s(png_structrp png_ptr, int unit, png_const_charp width,
    png_const_charp height)
{
   png_byte buf[64];
   png_size_t wlen, hlen, total_len;

   png_debug(1, "in png_write_sCAL_s");

   wlen = strlen(width);
   hlen = strlen(height);
   total_len = wlen + hlen + 2;

   if (total_len > 64)
   {
      png_warning(png_ptr, "Can't write sCAL (buffer too small)");
      return;
   }

   buf[0] = (png_byte)unit;
   memcpy(buf + 1, width, wlen + 1);      /* Append the '\0' here */
   memcpy(buf + wlen + 2, height, hlen);  /* Do NOT append the '\0' here */

   png_debug1(3, "sCAL total length = %u", (unsigned int)total_len);
   png_write_complete_chunk(png_ptr, png_sCAL, buf, total_len);
}
#endif

#ifdef PNG_WRITE_pHYs_SUPPORTED
/* Write the pHYs chunk */
void /* PRIVATE */
png_write_pHYs(png_structrp png_ptr, png_uint_32 x_pixels_per_unit,
    png_uint_32 y_pixels_per_unit,
    int unit_type)
{
   png_byte buf[9];

   png_debug(1, "in png_write_pHYs");

   if (unit_type >= PNG_RESOLUTION_LAST)
      png_warning(png_ptr, "Unrecognized unit type for pHYs chunk");

   png_save_uint_32(buf, x_pixels_per_unit);
   png_save_uint_32(buf + 4, y_pixels_per_unit);
   buf[8] = (png_byte)unit_type;

   png_write_complete_chunk(png_ptr, png_pHYs, buf, (png_size_t)9);
}
#endif

#ifdef PNG_WRITE_tIME_SUPPORTED
/* Write the tIME chunk.  Use either png_convert_from_struct_tm()
 * or png_convert_from_time_t(), or fill in the structure yourself.
 */
void /* PRIVATE */
png_write_tIME(png_structrp png_ptr, png_const_timep mod_time)
{
   png_byte buf[7];

   png_debug(1, "in png_write_tIME");

   if (mod_time->month  > 12 || mod_time->month  < 1 ||
       mod_time->day    > 31 || mod_time->day    < 1 ||
       mod_time->hour   > 23 || mod_time->second > 60)
   {
      png_warning(png_ptr, "Invalid time specified for tIME chunk");
      return;
   }

   png_save_uint_16(buf, mod_time->year);
   buf[2] = mod_time->month;
   buf[3] = mod_time->day;
   buf[4] = mod_time->hour;
   buf[5] = mod_time->minute;
   buf[6] = mod_time->second;

   png_write_complete_chunk(png_ptr, png_tIME, buf, (png_size_t)7);
}
#endif

/* Initializes the row writing capability of libpng */
void /* PRIVATE */
png_write_start_row(png_structrp png_ptr)
{
#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* Start of interlace block in the y direction */
   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* Offset to next interlace block in the y direction */
   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
#endif

   png_alloc_size_t buf_size;
   int usr_pixel_depth;

#ifdef PNG_WRITE_FILTER_SUPPORTED
   png_byte filters;
#endif

   png_debug(1, "in png_write_start_row");

   usr_pixel_depth = png_ptr->usr_channels * png_ptr->usr_bit_depth;
   buf_size = PNG_ROWBYTES(usr_pixel_depth, png_ptr->width) + 1;

   /* 1.5.6: added to allow checking in the row write code. */
   png_ptr->transformed_pixel_depth = png_ptr->pixel_depth;
   png_ptr->maximum_pixel_depth = (png_byte)usr_pixel_depth;

   /* Set up row buffer */
   png_ptr->row_buf = png_voidcast(png_bytep, png_malloc(png_ptr, buf_size));

   png_ptr->row_buf[0] = PNG_FILTER_VALUE_NONE;

#ifdef PNG_WRITE_FILTER_SUPPORTED
   filters = png_ptr->do_filter;

   if (png_ptr->height == 1)
      filters &= 0xff & ~(PNG_FILTER_UP|PNG_FILTER_AVG|PNG_FILTER_PAETH);

   if (png_ptr->width == 1)
      filters &= 0xff & ~(PNG_FILTER_SUB|PNG_FILTER_AVG|PNG_FILTER_PAETH);

   if (filters == 0)
      filters = PNG_FILTER_NONE;

   png_ptr->do_filter = filters;

   if (((filters & (PNG_FILTER_SUB | PNG_FILTER_UP | PNG_FILTER_AVG |
       PNG_FILTER_PAETH)) != 0) && png_ptr->try_row == NULL)
   {
      int num_filters = 0;

      png_ptr->try_row = png_voidcast(png_bytep, png_malloc(png_ptr, buf_size));

      if (filters & PNG_FILTER_SUB)
         num_filters++;

      if (filters & PNG_FILTER_UP)
         num_filters++;

      if (filters & PNG_FILTER_AVG)
         num_filters++;

      if (filters & PNG_FILTER_PAETH)
         num_filters++;

      if (num_filters > 1)
         png_ptr->tst_row = png_voidcast(png_bytep, png_malloc(png_ptr,
             buf_size));
   }

   /* We only need to keep the previous row if we are using one of the following
    * filters.
    */
   if ((filters & (PNG_FILTER_AVG | PNG_FILTER_UP | PNG_FILTER_PAETH)) != 0)
      png_ptr->prev_row = png_voidcast(png_bytep,
          png_calloc(png_ptr, buf_size));
#endif /* WRITE_FILTER */

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* If interlaced, we need to set up width and height of pass */
   if (png_ptr->interlaced != 0)
   {
      if ((png_ptr->transformations & PNG_INTERLACE) == 0)
      {
         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
             png_pass_ystart[0]) / png_pass_yinc[0];

         png_ptr->usr_width = (png_ptr->width + png_pass_inc[0] - 1 -
             png_pass_start[0]) / png_pass_inc[0];
      }

      else
      {
         png_ptr->num_rows = png_ptr->height;
         png_ptr->usr_width = png_ptr->width;
      }
   }

   else
#endif
   {
      png_ptr->num_rows = png_ptr->height;
      png_ptr->usr_width = png_ptr->width;
   }
}

/* Internal use only.  Called when finished processing a row of data. */
void /* PRIVATE */
png_write_finish_row(png_structrp png_ptr)
{
#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* Start of interlace block in the y direction */
   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* Offset to next interlace block in the y direction */
   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
#endif

   png_debug(1, "in png_write_finish_row");

   /* Next row */
   png_ptr->row_number++;

   /* See if we are done */
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* If interlaced, go to next pass */
   if (png_ptr->interlaced != 0)
   {
      png_ptr->row_number = 0;
      if ((png_ptr->transformations & PNG_INTERLACE) != 0)
      {
         png_ptr->pass++;
      }

      else
      {
         /* Loop until we find a non-zero width or height pass */
         do
         {
            png_ptr->pass++;

            if (png_ptr->pass >= 7)
               break;

            png_ptr->usr_width = (png_ptr->width +
                png_pass_inc[png_ptr->pass] - 1 -
                png_pass_start[png_ptr->pass]) /
                png_pass_inc[png_ptr->pass];

            png_ptr->num_rows = (png_ptr->height +
                png_pass_yinc[png_ptr->pass] - 1 -
                png_pass_ystart[png_ptr->pass]) /
                png_pass_yinc[png_ptr->pass];

            if ((png_ptr->transformations & PNG_INTERLACE) != 0)
               break;

         } while (png_ptr->usr_width == 0 || png_ptr->num_rows == 0);

      }

      /* Reset the row above the image for the next pass */
      if (png_ptr->pass < 7)
      {
         if (png_ptr->prev_row != NULL)
            memset(png_ptr->prev_row, 0,
                (png_size_t)(PNG_ROWBYTES(png_ptr->usr_channels*
                png_ptr->usr_bit_depth, png_ptr->width)) + 1);

         return;
      }
   }
#endif

   /* If we get here, we've just written the last row, so we need
      to flush the compressor */
   png_compress_IDAT(png_ptr, NULL, 0, Z_FINISH);
}

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
/* Pick out the correct pixels for the interlace pass.
 * The basic idea here is to go through the row with a source
 * pointer and a destination pointer (sp and dp), and copy the
 * correct pixels for the pass.  As the row gets compacted,
 * sp will always be >= dp, so we should never overwrite anything.
 * See the default: case for the easiest code to understand.
 */
void /* PRIVATE */
png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)
{
   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* Start of interlace block */
   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* Offset to next interlace block */
   static PNG_CONST png_byte  png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   png_debug(1, "in png_do_write_interlace");

   /* We don't have to do anything on the last pass (6) */
   if (pass < 6)
   {
      /* Each pixel depth is handled separately */
      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp;
            png_bytep dp;
            unsigned int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            d = 0;
            shift = 7;

            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 3);
               value = (int)(*sp >> (7 - (int)(i & 0x07))) & 0x01;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 7;
                  *dp++ = (png_byte)d;
                  d = 0;
               }

               else
                  shift--;

            }
            if (shift != 7)
               *dp = (png_byte)d;

            break;
         }

         case 2:
         {
            png_bytep sp;
            png_bytep dp;
            unsigned int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            shift = 6;
            d = 0;

            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 2);
               value = (*sp >> ((3 - (int)(i & 0x03)) << 1)) & 0x03;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 6;
                  *dp++ = (png_byte)d;
                  d = 0;
               }

               else
                  shift -= 2;
            }
            if (shift != 6)
               *dp = (png_byte)d;

            break;
         }

         case 4:
         {
            png_bytep sp;
            png_bytep dp;
            unsigned int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            shift = 4;
            d = 0;
            for (i = png_pass_start[pass]; i < row_width;
                i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 1);
               value = (*sp >> ((1 - (int)(i & 0x01)) << 2)) & 0x0f;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 4;
                  *dp++ = (png_byte)d;
                  d = 0;
               }

               else
                  shift -= 4;
            }
            if (shift != 4)
               *dp = (png_byte)d;

            break;
         }

         default:
         {
            png_bytep sp;
            png_bytep dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;
            png_size_t pixel_bytes;

            /* Start at the beginning */
            dp = row;

            /* Find out how many bytes each pixel takes up */
            pixel_bytes = (row_info->pixel_depth >> 3);

            /* Loop through the row, only looking at the pixels that matter */
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               /* Find out where the original pixel is */
               sp = row + (png_size_t)i * pixel_bytes;

               /* Move the pixel */
               if (dp != sp)
                  memcpy(dp, sp, pixel_bytes);

               /* Next pixel */
               dp += pixel_bytes;
            }
            break;
         }
      }
      /* Set new row width */
      row_info->width = (row_info->width +
          png_pass_inc[pass] - 1 -
          png_pass_start[pass]) /
          png_pass_inc[pass];

      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
          row_info->width);
   }
}
#endif


/* This filters the row, chooses which filter to use, if it has not already
 * been specified by the application, and then writes the row out with the
 * chosen filter.
 */
static void /* PRIVATE */
png_write_filtered_row(png_structrp png_ptr, png_bytep filtered_row,
    png_size_t row_bytes);

#ifdef PNG_WRITE_FILTER_SUPPORTED
static png_size_t /* PRIVATE */
png_setup_sub_row(png_structrp png_ptr, const png_uint_32 bpp,
    const png_size_t row_bytes, const png_size_t lmins)
{
   png_bytep rp, dp, lp;
   png_size_t i;
   png_size_t sum = 0;
   unsigned int v;

   png_ptr->try_row[0] = PNG_FILTER_VALUE_SUB;

   for (i = 0, rp = png_ptr->row_buf + 1, dp = png_ptr->try_row + 1; i < bpp;
        i++, rp++, dp++)
   {
      v = *dp = *rp;
#ifdef PNG_USE_ABS
      sum += 128 - abs((int)v - 128);
#else
      sum += (v < 128) ? v : 256 - v;
#endif
   }

   for (lp = png_ptr->row_buf + 1; i < row_bytes;
      i++, rp++, lp++, dp++)
   {
      v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
#ifdef PNG_USE_ABS
      sum += 128 - abs((int)v - 128);
#else
      sum += (v < 128) ? v : 256 - v;
#endif

      if (sum > lmins)  /* We are already worse, don't continue. */
        break;
   }

   return (sum);
}

static void /* PRIVATE */
png_setup_sub_row_only(png_structrp png_ptr, const png_uint_32 bpp,
    const png_size_t row_bytes)
{
   png_bytep rp, dp, lp;
   png_size_t i;

   png_ptr->try_row[0] = PNG_FILTER_VALUE_SUB;

   for (i = 0, rp = png_ptr->row_buf + 1, dp = png_ptr->try_row + 1; i < bpp;
        i++, rp++, dp++)
   {
      *dp = *rp;
   }

   for (lp = png_ptr->row_buf + 1; i < row_bytes;
      i++, rp++, lp++, dp++)
   {
      *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
   }
}

static png_size_t /* PRIVATE */
png_setup_up_row(png_structrp png_ptr, const png_size_t row_bytes,
    const png_size_t lmins)
{
   png_bytep rp, dp, pp;
   png_size_t i;
   png_size_t sum = 0;
   unsigned int v;

   png_ptr->try_row[0] = PNG_FILTER_VALUE_UP;

   for (i = 0, rp = png_ptr->row_buf + 1, dp = png_ptr->try_row + 1,
       pp = png_ptr->prev_row + 1; i < row_bytes;
       i++, rp++, pp++, dp++)
   {
      v = *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
#ifdef PNG_USE_ABS
      sum += 128 - abs((int)v - 128);
#else
      sum += (v < 128) ? v : 256 - v;
#endif

      if (sum > lmins)  /* We are already worse, don't continue. */
        break;
   }

   return (sum);
}
static void /* PRIVATE */
png_setup_up_row_only(png_structrp png_ptr, const png_size_t row_bytes)
{
   png_bytep rp, dp, pp;
   png_size_t i;

   png_ptr->try_row[0] = PNG_FILTER_VALUE_UP;

   for (i = 0, rp = png_ptr->row_buf + 1, dp = png_ptr->try_row + 1,
       pp = png_ptr->prev_row + 1; i < row_bytes;
       i++, rp++, pp++, dp++)
   {
      *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
   }
}

static png_size_t /* PRIVATE */
png_setup_avg_row(png_structrp png_ptr, const png_uint_32 bpp,
    const png_size_t row_bytes, const png_size_t lmins)
{
   png_bytep rp, dp, pp, lp;
   png_uint_32 i;
   png_size_t sum = 0;
   unsigned int v;

   png_ptr->try_row[0] = PNG_FILTER_VALUE_AVG;

   for (i = 0, rp = png_ptr->row_buf + 1, dp = png_ptr->try_row + 1,
       pp = png_ptr->prev_row + 1; i < bpp; i++)
   {
      v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);

#ifdef PNG_USE_ABS
      sum += 128 - abs((int)v - 128);
#else
      sum += (v < 128) ? v : 256 - v;
#endif
   }

   for (lp = png_ptr->row_buf + 1; i < row_bytes; i++)
   {
      v = *dp++ = (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2))
          & 0xff);

#ifdef PNG_USE_ABS
      sum += 128 - abs((int)v - 128);
#else
      sum += (v < 128) ? v : 256 - v;
#endif

      if (sum > lmins)  /* We are already worse, don't continue. */
        break;
   }

   return (sum);
}
static void /* PRIVATE */
png_setup_avg_row_only(png_structrp png_ptr, const png_uint_32 bpp,
    const png_size_t row_bytes)
{
   png_bytep rp, dp, pp, lp;
   png_uint_32 i;

   png_ptr->try_row[0] = PNG_FILTER_VALUE_AVG;

   for (i = 0, rp = png_ptr->row_buf + 1, dp = png_ptr->try_row + 1,
       pp = png_ptr->prev_row + 1; i < bpp; i++)
   {
      *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
   }

   for (lp = png_ptr->row_buf + 1; i < row_bytes; i++)
   {
      *dp++ = (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2))
          & 0xff);
   }
}

static png_size_t /* PRIVATE */
png_setup_paeth_row(png_structrp png_ptr, const png_uint_32 bpp,
    const png_size_t row_bytes, const png_size_t lmins)
{
   png_bytep rp, dp, pp, cp, lp;
   png_size_t i;
   png_size_t sum = 0;
   unsigned int v;

   png_ptr->try_row[0] = PNG_FILTER_VALUE_PAETH;

   for (i = 0, rp = png_ptr->row_buf + 1, dp = png_ptr->try_row + 1,
       pp = png_ptr->prev_row + 1; i < bpp; i++)
   {
      v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);

#ifdef PNG_USE_ABS
      sum += 128 - abs((int)v - 128);
#else
      sum += (v < 128) ? v : 256 - v;
#endif
   }

   for (lp = png_ptr->row_buf + 1, cp = png_ptr->prev_row + 1; i < row_bytes;
        i++)
   {
      int a, b, c, pa, pb, pc, p;

      b = *pp++;
      c = *cp++;
      a = *lp++;

      p = b - c;
      pc = a - c;

#ifdef PNG_USE_ABS
      pa = abs(p);
      pb = abs(pc);
      pc = abs(p + pc);
#else
      pa = p < 0 ? -p : p;
      pb = pc < 0 ? -pc : pc;
      pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

      p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;

      v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);

#ifdef PNG_USE_ABS
      sum += 128 - abs((int)v - 128);
#else
      sum += (v < 128) ? v : 256 - v;
#endif

      if (sum > lmins)  /* We are already worse, don't continue. */
        break;
   }

   return (sum);
}
static void /* PRIVATE */
png_setup_paeth_row_only(png_structrp png_ptr, const png_uint_32 bpp,
    const png_size_t row_bytes)
{
   png_bytep rp, dp, pp, cp, lp;
   png_size_t i;

   png_ptr->try_row[0] = PNG_FILTER_VALUE_PAETH;

   for (i = 0, rp = png_ptr->row_buf + 1, dp = png_ptr->try_row + 1,
       pp = png_ptr->prev_row + 1; i < bpp; i++)
   {
      *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
   }

   for (lp = png_ptr->row_buf + 1, cp = png_ptr->prev_row + 1; i < row_bytes;
        i++)
   {
      int a, b, c, pa, pb, pc, p;

      b = *pp++;
      c = *cp++;
      a = *lp++;

      p = b - c;
      pc = a - c;

#ifdef PNG_USE_ABS
      pa = abs(p);
      pb = abs(pc);
      pc = abs(p + pc);
#else
      pa = p < 0 ? -p : p;
      pb = pc < 0 ? -pc : pc;
      pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

      p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;

      *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
   }
}
#endif /* WRITE_FILTER */

void /* PRIVATE */
png_write_find_filter(png_structrp png_ptr, png_row_infop row_info)
{
#ifndef PNG_WRITE_FILTER_SUPPORTED
   png_write_filtered_row(png_ptr, png_ptr->row_buf, row_info->rowbytes+1);
#else
   unsigned int filter_to_do = png_ptr->do_filter;
   png_bytep row_buf;
   png_bytep best_row;
   png_uint_32 bpp;
   png_size_t mins;
   png_size_t row_bytes = row_info->rowbytes;

   png_debug(1, "in png_write_find_filter");

   /* Find out how many bytes offset each pixel is */
   bpp = (row_info->pixel_depth + 7) >> 3;

   row_buf = png_ptr->row_buf;
   mins = PNG_SIZE_MAX - 256/* so we can detect potential overflow of the
                               running sum */;

   /* The prediction method we use is to find which method provides the
    * smallest value when summing the absolute values of the distances
    * from zero, using anything >= 128 as negative numbers.  This is known
    * as the "minimum sum of absolute differences" heuristic.  Other
    * heuristics are the "weighted minimum sum of absolute differences"
    * (experimental and can in theory improve compression), and the "zlib
    * predictive" method (not implemented yet), which does test compressions
    * of lines using different filter methods, and then chooses the
    * (series of) filter(s) that give minimum compressed data size (VERY
    * computationally expensive).
    *
    * GRR 980525:  consider also
    *
    *   (1) minimum sum of absolute differences from running average (i.e.,
    *       keep running sum of non-absolute differences & count of bytes)
    *       [track dispersion, too?  restart average if dispersion too large?]
    *
    *  (1b) minimum sum of absolute differences from sliding average, probably
    *       with window size <= deflate window (usually 32K)
    *
    *   (2) minimum sum of squared differences from zero or running average
    *       (i.e., ~ root-mean-square approach)
    */


   /* We don't need to test the 'no filter' case if this is the only filter
    * that has been chosen, as it doesn't actually do anything to the data.
    */
   best_row = png_ptr->row_buf;

   if (PNG_SIZE_MAX/128 <= row_bytes)
   {
      /* Overflow can occur in the calculation, just select the lowest set
       * filter.
       */
      filter_to_do &= 0U-filter_to_do;
   }
   else if ((filter_to_do & PNG_FILTER_NONE) != 0 &&
         filter_to_do != PNG_FILTER_NONE)
   {
      /* Overflow not possible and multiple filters in the list, including the
       * 'none' filter.
       */
      png_bytep rp;
      png_size_t sum = 0;
      png_size_t i;
      unsigned int v;

      {
         for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)
         {
            v = *rp;
#ifdef PNG_USE_ABS
            sum += 128 - abs((int)v - 128);
#else
            sum += (v < 128) ? v : 256 - v;
#endif
         }
      }

      mins = sum;
   }

   /* Sub filter */
   if (filter_to_do == PNG_FILTER_SUB)
   /* It's the only filter so no testing is needed */
   {
      png_setup_sub_row_only(png_ptr, bpp, row_bytes);
      best_row = png_ptr->try_row;
   }

   else if ((filter_to_do & PNG_FILTER_SUB) != 0)
   {
      png_size_t sum;
      png_size_t lmins = mins;

      sum = png_setup_sub_row(png_ptr, bpp, row_bytes, lmins);

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->try_row;
         if (png_ptr->tst_row != NULL)
         {
            png_ptr->try_row = png_ptr->tst_row;
            png_ptr->tst_row = best_row;
         }
      }
   }

   /* Up filter */
   if (filter_to_do == PNG_FILTER_UP)
   {
      png_setup_up_row_only(png_ptr, row_bytes);
      best_row = png_ptr->try_row;
   }

   else if ((filter_to_do & PNG_FILTER_UP) != 0)
   {
      png_size_t sum;
      png_size_t lmins = mins;

      sum = png_setup_up_row(png_ptr, row_bytes, lmins);

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->try_row;
         if (png_ptr->tst_row != NULL)
         {
            png_ptr->try_row = png_ptr->tst_row;
            png_ptr->tst_row = best_row;
         }
      }
   }

   /* Avg filter */
   if (filter_to_do == PNG_FILTER_AVG)
   {
      png_setup_avg_row_only(png_ptr, bpp, row_bytes);
      best_row = png_ptr->try_row;
   }

   else if ((filter_to_do & PNG_FILTER_AVG) != 0)
   {
      png_size_t sum;
      png_size_t lmins = mins;

      sum= png_setup_avg_row(png_ptr, bpp, row_bytes, lmins);

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->try_row;
         if (png_ptr->tst_row != NULL)
         {
            png_ptr->try_row = png_ptr->tst_row;
            png_ptr->tst_row = best_row;
         }
      }
   }

   /* Paeth filter */
   if (filter_to_do == PNG_FILTER_PAETH)
   {
      png_setup_paeth_row_only(png_ptr, bpp, row_bytes);
      best_row = png_ptr->try_row;
   }

   else if ((filter_to_do & PNG_FILTER_PAETH) != 0)
   {
      png_size_t sum;
      png_size_t lmins = mins;

      sum = png_setup_paeth_row(png_ptr, bpp, row_bytes, lmins);

      if (sum < mins)
      {
         best_row = png_ptr->try_row;
         if (png_ptr->tst_row != NULL)
         {
            png_ptr->try_row = png_ptr->tst_row;
            png_ptr->tst_row = best_row;
         }
      }
   }

   /* Do the actual writing of the filtered row data from the chosen filter. */
   png_write_filtered_row(png_ptr, best_row, row_info->rowbytes+1);

#endif /* WRITE_FILTER */
}


/* Do the actual writing of a previously filtered row. */
static void
png_write_filtered_row(png_structrp png_ptr, png_bytep filtered_row,
    png_size_t full_row_length/*includes filter byte*/)
{
   png_debug(1, "in png_write_filtered_row");

   png_debug1(2, "filter = %d", filtered_row[0]);

   png_compress_IDAT(png_ptr, filtered_row, full_row_length, Z_NO_FLUSH);

#ifdef PNG_WRITE_FILTER_SUPPORTED
   /* Swap the current and previous rows */
   if (png_ptr->prev_row != NULL)
   {
      png_bytep tptr;

      tptr = png_ptr->prev_row;
      png_ptr->prev_row = png_ptr->row_buf;
      png_ptr->row_buf = tptr;
   }
#endif /* WRITE_FILTER */

   /* Finish row - updates counters and flushes zlib if last row */
   png_write_finish_row(png_ptr);

#ifdef PNG_WRITE_FLUSH_SUPPORTED
   png_ptr->flush_rows++;

   if (png_ptr->flush_dist > 0 &&
       png_ptr->flush_rows >= png_ptr->flush_dist)
   {
      png_write_flush(png_ptr);
   }
#endif /* WRITE_FLUSH */
}
#endif /* WRITE */

```

`ThirdPartyBuild/PNG/IOS/LibPng.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 46;
	objects = {

/* Begin PBXBuildFile section */
		17114D281F3D600C00FC9929 /* png.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D111F3D600C00FC9929 /* png.c */; };
		17114D291F3D600C00FC9929 /* pngerror.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D151F3D600C00FC9929 /* pngerror.c */; };
		17114D2A1F3D600C00FC9929 /* pngget.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D161F3D600C00FC9929 /* pngget.c */; };
		17114D2B1F3D600C00FC9929 /* pngmem.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D191F3D600C00FC9929 /* pngmem.c */; };
		17114D2C1F3D600C00FC9929 /* pngpread.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D1A1F3D600C00FC9929 /* pngpread.c */; };
		17114D2D1F3D600C00FC9929 /* pngread.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D1C1F3D600C00FC9929 /* pngread.c */; };
		17114D2E1F3D600C00FC9929 /* pngrio.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D1D1F3D600C00FC9929 /* pngrio.c */; };
		17114D2F1F3D600C00FC9929 /* pngrtran.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D1E1F3D600C00FC9929 /* pngrtran.c */; };
		17114D301F3D600C00FC9929 /* pngrutil.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D1F1F3D600C00FC9929 /* pngrutil.c */; };
		17114D311F3D600C00FC9929 /* pngset.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D201F3D600C00FC9929 /* pngset.c */; };
		17114D321F3D600C00FC9929 /* pngtest.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D221F3D600C00FC9929 /* pngtest.c */; };
		17114D331F3D600C00FC9929 /* pngtrans.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D231F3D600C00FC9929 /* pngtrans.c */; };
		17114D341F3D600C00FC9929 /* pngwio.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D241F3D600C00FC9929 /* pngwio.c */; };
		17114D351F3D600C00FC9929 /* pngwrite.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D251F3D600C00FC9929 /* pngwrite.c */; };
		17114D361F3D600C00FC9929 /* pngwtran.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D261F3D600C00FC9929 /* pngwtran.c */; };
		17114D371F3D600C00FC9929 /* pngwutil.c in Sources */ = {isa = PBXBuildFile; fileRef = 17114D271F3D600C00FC9929 /* pngwutil.c */; };
/* End PBXBuildFile section */

/* Begin PBXCopyFilesBuildPhase section */
		17114D031F3D5FC500FC9929 /* CopyFiles */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "include/$(PRODUCT_NAME)";
			dstSubfolderSpec = 16;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		17114D051F3D5FC500FC9929 /* libLibPNG.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; name = libLibPNG.a; path = libpng.a; sourceTree = BUILT_PRODUCTS_DIR; };
		17114D111F3D600C00FC9929 /* png.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = png.c; path = ../Code/png.c; sourceTree = "<group>"; };
		17114D121F3D600C00FC9929 /* png.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = png.h; path = ../Code/png.h; sourceTree = "<group>"; };
		17114D131F3D600C00FC9929 /* pngconf.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = pngconf.h; path = ../Code/pngconf.h; sourceTree = "<group>"; };
		17114D141F3D600C00FC9929 /* pngdebug.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = pngdebug.h; path = ../Code/pngdebug.h; sourceTree = "<group>"; };
		17114D151F3D600C00FC9929 /* pngerror.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngerror.c; path = ../Code/pngerror.c; sourceTree = "<group>"; };
		17114D161F3D600C00FC9929 /* pngget.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngget.c; path = ../Code/pngget.c; sourceTree = "<group>"; };
		17114D171F3D600C00FC9929 /* pnginfo.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = pnginfo.h; path = ../Code/pnginfo.h; sourceTree = "<group>"; };
		17114D181F3D600C00FC9929 /* pnglibconf.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = pnglibconf.h; path = ../Code/pnglibconf.h; sourceTree = "<group>"; };
		17114D191F3D600C00FC9929 /* pngmem.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngmem.c; path = ../Code/pngmem.c; sourceTree = "<group>"; };
		17114D1A1F3D600C00FC9929 /* pngpread.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngpread.c; path = ../Code/pngpread.c; sourceTree = "<group>"; };
		17114D1B1F3D600C00FC9929 /* pngpriv.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = pngpriv.h; path = ../Code/pngpriv.h; sourceTree = "<group>"; };
		17114D1C1F3D600C00FC9929 /* pngread.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngread.c; path = ../Code/pngread.c; sourceTree = "<group>"; };
		17114D1D1F3D600C00FC9929 /* pngrio.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngrio.c; path = ../Code/pngrio.c; sourceTree = "<group>"; };
		17114D1E1F3D600C00FC9929 /* pngrtran.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngrtran.c; path = ../Code/pngrtran.c; sourceTree = "<group>"; };
		17114D1F1F3D600C00FC9929 /* pngrutil.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngrutil.c; path = ../Code/pngrutil.c; sourceTree = "<group>"; };
		17114D201F3D600C00FC9929 /* pngset.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngset.c; path = ../Code/pngset.c; sourceTree = "<group>"; };
		17114D211F3D600C00FC9929 /* pngstruct.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = pngstruct.h; path = ../Code/pngstruct.h; sourceTree = "<group>"; };
		17114D221F3D600C00FC9929 /* pngtest.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngtest.c; path = ../Code/pngtest.c; sourceTree = "<group>"; };
		17114D231F3D600C00FC9929 /* pngtrans.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngtrans.c; path = ../Code/pngtrans.c; sourceTree = "<group>"; };
		17114D241F3D600C00FC9929 /* pngwio.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngwio.c; path = ../Code/pngwio.c; sourceTree = "<group>"; };
		17114D251F3D600C00FC9929 /* pngwrite.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngwrite.c; path = ../Code/pngwrite.c; sourceTree = "<group>"; };
		17114D261F3D600C00FC9929 /* pngwtran.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngwtran.c; path = ../Code/pngwtran.c; sourceTree = "<group>"; };
		17114D271F3D600C00FC9929 /* pngwutil.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = pngwutil.c; path = ../Code/pngwutil.c; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		17114D021F3D5FC500FC9929 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		17114CFC1F3D5FC500FC9929 = {
			isa = PBXGroup;
			children = (
				17114D111F3D600C00FC9929 /* png.c */,
				17114D121F3D600C00FC9929 /* png.h */,
				17114D131F3D600C00FC9929 /* pngconf.h */,
				17114D141F3D600C00FC9929 /* pngdebug.h */,
				17114D151F3D600C00FC9929 /* pngerror.c */,
				17114D161F3D600C00FC9929 /* pngget.c */,
				17114D171F3D600C00FC9929 /* pnginfo.h */,
				17114D181F3D600C00FC9929 /* pnglibconf.h */,
				17114D191F3D600C00FC9929 /* pngmem.c */,
				17114D1A1F3D600C00FC9929 /* pngpread.c */,
				17114D1B1F3D600C00FC9929 /* pngpriv.h */,
				17114D1C1F3D600C00FC9929 /* pngread.c */,
				17114D1D1F3D600C00FC9929 /* pngrio.c */,
				17114D1E1F3D600C00FC9929 /* pngrtran.c */,
				17114D1F1F3D600C00FC9929 /* pngrutil.c */,
				17114D201F3D600C00FC9929 /* pngset.c */,
				17114D211F3D600C00FC9929 /* pngstruct.h */,
				17114D221F3D600C00FC9929 /* pngtest.c */,
				17114D231F3D600C00FC9929 /* pngtrans.c */,
				17114D241F3D600C00FC9929 /* pngwio.c */,
				17114D251F3D600C00FC9929 /* pngwrite.c */,
				17114D261F3D600C00FC9929 /* pngwtran.c */,
				17114D271F3D600C00FC9929 /* pngwutil.c */,
				17114D061F3D5FC500FC9929 /* Products */,
			);
			sourceTree = "<group>";
		};
		17114D061F3D5FC500FC9929 /* Products */ = {
			isa = PBXGroup;
			children = (
				17114D051F3D5FC500FC9929 /* libLibPNG.a */,
			);
			name = Products;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		17114D041F3D5FC500FC9929 /* LibPNG */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 17114D0E1F3D5FC500FC9929 /* Build configuration list for PBXNativeTarget "LibPNG" */;
			buildPhases = (
				17114D011F3D5FC500FC9929 /* Sources */,
				17114D021F3D5FC500FC9929 /* Frameworks */,
				17114D031F3D5FC500FC9929 /* CopyFiles */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = LibPNG;
			productName = LibPNG;
			productReference = 17114D051F3D5FC500FC9929 /* libLibPNG.a */;
			productType = "com.apple.product-type.library.static";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		17114CFD1F3D5FC500FC9929 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastUpgradeCheck = 0830;
				ORGANIZATIONNAME = com.Mojoc;
				TargetAttributes = {
					17114D041F3D5FC500FC9929 = {
						CreatedOnToolsVersion = 8.3.3;
						ProvisioningStyle = Automatic;
					};
				};
			};
			buildConfigurationList = 17114D001F3D5FC500FC9929 /* Build configuration list for PBXProject "LibPng" */;
			compatibilityVersion = "Xcode 3.2";
			developmentRegion = English;
			hasScannedForEncodings = 0;
			knownRegions = (
				English,
				en,
			);
			mainGroup = 17114CFC1F3D5FC500FC9929;
			productRefGroup = 17114D061F3D5FC500FC9929 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				17114D041F3D5FC500FC9929 /* LibPNG */,
			);
		};
/* End PBXProject section */

/* Begin PBXSourcesBuildPhase section */
		17114D011F3D5FC500FC9929 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				17114D331F3D600C00FC9929 /* pngtrans.c in Sources */,
				17114D291F3D600C00FC9929 /* pngerror.c in Sources */,
				17114D2B1F3D600C00FC9929 /* pngmem.c in Sources */,
				17114D351F3D600C00FC9929 /* pngwrite.c in Sources */,
				17114D2E1F3D600C00FC9929 /* pngrio.c in Sources */,
				17114D371F3D600C00FC9929 /* pngwutil.c in Sources */,
				17114D281F3D600C00FC9929 /* png.c in Sources */,
				17114D341F3D600C00FC9929 /* pngwio.c in Sources */,
				17114D321F3D600C00FC9929 /* pngtest.c in Sources */,
				17114D311F3D600C00FC9929 /* pngset.c in Sources */,
				17114D2C1F3D600C00FC9929 /* pngpread.c in Sources */,
				17114D2A1F3D600C00FC9929 /* pngget.c in Sources */,
				17114D2D1F3D600C00FC9929 /* pngread.c in Sources */,
				17114D301F3D600C00FC9929 /* pngrutil.c in Sources */,
				17114D361F3D600C00FC9929 /* pngwtran.c in Sources */,
				17114D2F1F3D600C00FC9929 /* pngrtran.c in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		17114D0C1F3D5FC500FC9929 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "compiler-default";
				CLANG_CXX_LIBRARY = "compiler-default";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				CONFIGURATION_BUILD_DIR = "$(SRCROOT)";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = c99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = fast;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 11.4;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				OTHER_CFLAGS = "-DPNG_ARM_NEON_OPT=0";
				SDKROOT = iphoneos;
			};
			name = Debug;
		};
		17114D0D1F3D5FC500FC9929 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "compiler-default";
				CLANG_CXX_LIBRARY = "compiler-default";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				CONFIGURATION_BUILD_DIR = "$(SRCROOT)";
				COPY_PHASE_STRIP = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = c99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = fast;
				"GCC_PREPROCESSOR_DEFINITIONS[arch=*]" = "";
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 11.4;
				MTL_ENABLE_DEBUG_INFO = NO;
				ONLY_ACTIVE_ARCH = YES;
				OTHER_CFLAGS = "-DPNG_ARM_NEON_OPT=0";
				SDKROOT = iphoneos;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		17114D0F1F3D5FC500FC9929 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				OTHER_LDFLAGS = "-ObjC";
				PRODUCT_NAME = png;
				SKIP_INSTALL = YES;
			};
			name = Debug;
		};
		17114D101F3D5FC500FC9929 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				OTHER_LDFLAGS = "-ObjC";
				PRODUCT_NAME = png;
				SKIP_INSTALL = YES;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		17114D001F3D5FC500FC9929 /* Build configuration list for PBXProject "LibPng" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				17114D0C1F3D5FC500FC9929 /* Debug */,
				17114D0D1F3D5FC500FC9929 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		17114D0E1F3D5FC500FC9929 /* Build configuration list for PBXNativeTarget "LibPNG" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				17114D0F1F3D5FC500FC9929 /* Debug */,
				17114D101F3D5FC500FC9929 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 17114CFD1F3D5FC500FC9929 /* Project object */;
}

```

`ThirdPartyBuild/PNG/IOS/LibPng.xcodeproj/project.xcworkspace/contents.xcworkspacedata`:

```xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:LibPNG.xcodeproj">
   </FileRef>
</Workspace>

```

`ThirdPartyBuild/PNG/IOS/LibPng.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>

```

`ThirdPartyBuild/PNG/IOS/LibPng.xcodeproj/xcshareddata/xcschemes/LibPNG.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1020"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "17114D041F3D5FC500FC9929"
               BuildableName = "libpng.a"
               BlueprintName = "LibPNG"
               ReferencedContainer = "container:LibPng.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <Testables>
      </Testables>
      <AdditionalOptions>
      </AdditionalOptions>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "17114D041F3D5FC500FC9929"
            BuildableName = "libpng.a"
            BlueprintName = "LibPNG"
            ReferencedContainer = "container:LibPng.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <AdditionalOptions>
      </AdditionalOptions>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "17114D041F3D5FC500FC9929"
            BuildableName = "libpng.a"
            BlueprintName = "LibPNG"
            ReferencedContainer = "container:LibPng.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```