Project Path: arc_tmr232_Sark_xujw9r9h

Source Tree:

```txt
arc_tmr232_Sark_xujw9r9h
├── AUTHORS.rst
├── CONTRIBUTING.rst
├── LICENSE
├── MANIFEST.in
├── README.rst
├── docs
│   ├── Installation.rst
│   ├── Introduction.rst
│   ├── Makefile
│   ├── Support.rst
│   ├── api
│   │   ├── Code-Blocks.rst
│   │   ├── Enums.rst
│   │   ├── Functions.rst
│   │   ├── IDB-Graphs.rst
│   │   ├── Instructions.rst
│   │   ├── Lines.rst
│   │   ├── Miscellaneous.rst
│   │   ├── Switch.rst
│   │   ├── UI.rst
│   │   ├── Xrefs.rst
│   │   ├── index.rst
│   │   ├── segments.rst
│   │   └── tutorial-conventions.rst
│   ├── conf.py
│   ├── debugging.rst
│   ├── examples
│   │   ├── Capture-Huge-Screenshots.rst
│   │   ├── Plotting-a-Call-Graph.rst
│   │   └── index.rst
│   ├── index.rst
│   ├── make.bat
│   ├── media
│   │   ├── debugging
│   │   │   ├── attach_dialog.PNG
│   │   │   ├── break.PNG
│   │   │   └── debugging_menu.PNG
│   │   ├── examples
│   │   │   ├── httpsys8_1_callgraph.png
│   │   │   └── huge_callgraph.png
│   │   ├── intro_demo
│   │   │   ├── highlight_xrefs.png
│   │   │   └── print_lines.png
│   │   ├── meme_bring_in_the_logic_probe_small.jpg
│   │   ├── plugins
│   │   │   ├── autostruct-1.png
│   │   │   ├── autostruct-2.png
│   │   │   ├── autostruct-3.png
│   │   │   ├── autostruct-4.png
│   │   │   ├── autostruct-5.png
│   │   │   ├── autostruct-6.png
│   │   │   ├── copy-current-bytes.png
│   │   │   ├── copy-selected-bytes.png
│   │   │   ├── cursor-at-line.png
│   │   │   ├── first-meaningful-output.png
│   │   │   ├── meaningful-output.png
│   │   │   ├── xrefsgraph-1.png
│   │   │   ├── xrefsgraph-2.png
│   │   │   └── xrefsgraph-3.png
│   │   ├── sark-pacman_small.jpg
│   │   └── ui
│   │       └── top-level-menu.png
│   └── plugins
│       ├── autostruct.rst
│       ├── index.rst
│       ├── installation.rst
│       ├── meaningful.rst
│       ├── quick_copy.rst
│       └── xrefsgraph.rst
├── media
│   ├── autostruct-demo.gif
│   └── sark-pacman.jpg
├── plugins
│   ├── README.rst
│   ├── autoenum.py
│   ├── autostruct.py
│   ├── function_flow.py
│   ├── function_strings.py
│   ├── highlight_calls.py
│   ├── lca.py
│   ├── meaningful.py
│   ├── plugin_loader.py
│   ├── ptvsd_enable.py
│   ├── quick_copy.py
│   ├── requirements.txt
│   └── xrefsgraph.py
├── pyproject.toml
├── sark
│   ├── __init__.py
│   ├── code
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── function.py
│   │   ├── instruction.py
│   │   ├── intel.py
│   │   ├── line.py
│   │   ├── segment.py
│   │   ├── switch.py
│   │   └── xref.py
│   ├── codeblock.py
│   ├── core.py
│   ├── data.py
│   ├── debug.py
│   ├── enum.py
│   ├── exceptions.py
│   ├── graph.py
│   ├── ipython.py
│   ├── plumbing.py
│   ├── qt.py
│   ├── structure.py
│   └── ui.py
└── tests
    ├── README.rst
    ├── approvaltests_config.json
    ├── approved_files
    │   ├── SimpleTest.test_api_sampler.approved.txt
    │   ├── SimpleTest.test_codeblocks.approved.txt
    │   ├── SimpleTest.test_comments.approved.txt
    │   ├── SimpleTest.test_data.approved.txt
    │   ├── SimpleTest.test_enum.approved.txt
    │   ├── SimpleTest.test_functions.approved.txt
    │   ├── SimpleTest.test_idat.approved.txt
    │   ├── SimpleTest.test_idat_data_dumper.approved.txt
    │   ├── SimpleTest.test_instructions.approved.txt
    │   ├── SimpleTest.test_modify_block_color.approved.txt
    │   ├── SimpleTest.test_phrase_dumper.approved.txt
    │   └── SimpleTest.test_segments.approved.txt
    ├── binary_samples
    │   ├── simple.out
    │   ├── simple.out.i64
    │   └── sources
    │       └── simple.c
    ├── config.json
    ├── dumpers
    │   ├── api_sampler.py
    │   ├── block_color_modifier.py
    │   ├── codeblock_dumper.py
    │   ├── data_dumper.py
    │   ├── dumper_helper.py
    │   ├── dumper_wrapper.py
    │   ├── enum_dumper.py
    │   ├── function_dumper.py
    │   ├── instruction_dumper.py
    │   ├── phrase_dumper.py
    │   ├── segment_dumper.py
    │   └── simple_comment_dumper.py
    ├── testhelper.py
    └── tests.py

```

`AUTHORS.rst`:

```rst
Credits
=======

Sark is written and maintained by Tamir Bahar.

Contributors
------------

The following people have contributed directly or indirectly to this project:

- `darx0r <https://github.com/darx0r>`_
- `iamtimmy <https://github.com/iamtimmy>`_
- `ynvb <https://github.com/ynvb>`_
- `OfficialMan <https://github.com/OfficialMan>`_

Please add yourself here alphabetically when you submit your first pull request.
```

`CONTRIBUTING.rst`:

```rst
How To Contribute
=================

The Sark project was created to provide an intuitive, easy to use scripting
layer for IDA Pro. If something seems like the right-way to do something,
it should probably be added to Sark.

If you have something you think is worth adding, either submit a new issue
or (preferably) create a pull-request.

When contributing, try and follow these guidelines:

- Add yourself to the `AUTHORS.rst`_ file in alphabetical order. Every
  contribution shall be credited.
- Each new feature must have a reproducible test-case or usage. If it can't
  be used, it will not get in.
- Obey `PEP 8`_ and `PEP 257`_.
- All code should be documented. Usage samples and references to the IDASDK
  headers are a bonus.
- Write meaningful commit messages.
- No change is too small. You are welcome to fix typos, convention violations,
  or plain ugly code. All contributions are welcome.
- When submitting a fix to a bug, describe the bug being fixed. Include both
  the bug and the desired results. Creating an issue for the bug is good practice.
- When reporting bugs, make sure you mention your OS and IDA version.
- Sark has tests (though the coverage is bad...). When adding features, it
  is advisable to add matching tests.

If you can't adhere to the guidelines, **submit your pull requests anyway**.
Maybe someone else can improve on it.

Thanks for contributing!

.. _`PEP 8`: http://www.python.org/dev/peps/pep-0008/
.. _`PEP 257`: http://www.python.org/dev/peps/pep-0257/
.. _AUTHORS.rst: https://github.com/tmr232/sark/blob/master/AUTHORS.rst
```

`LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2015 Tamir Bahar

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`MANIFEST.in`:

```in
include *.rst LICENSE
recursive-include sark *.rst
```

`README.rst`:

```rst
====
Sark
====


General
-------

IDA Plugins & IDAPython Scripting Library.

For documentation, see `sark.rtfd.io <http://sark.rtfd.io/>`_.


Installation (Python 3 & IDA 7.4)
---------------------------------

For latest version (IDA7.4 & Python3):

.. code:: bash

    pip3 install -U git+https://github.com/tmr232/Sark.git#egg=Sark

Or from PyPI:

.. code:: bash

    pip3 install sark



For more info see `here <http://sark.readthedocs.org/en/latest/Installation.html>`_.


Python 2 & IDA < 7.4
~~~~~~~~~~~~~~~~~~~~

As of the release of IDA 7.4, Sark is only actively developed for IDA7.4 or
newer, and Python 3.

Python2 and older IDA is still supported for bugfixes & community contributions and
is maintained on the `IDA-6.x branch <https://github.com/tmr232/Sark/tree/IDA-6.x>`_.

To install Sark for older IDA use:

.. code:: bash

    pip2 install -U git+https://github.com/tmr232/Sark.git@IDA-6.x#egg=Sark

Or from PyPI:

.. code:: bash

    pip2 install "sark<7.4"


Dependencies
------------

1. `NetworkX <https://networkx.github.io/>`_
2. `wrapt <https://pypi.python.org/pypi/wrapt>`_

Plugins
-------

Plugin `documentation <http://sark.readthedocs.org/en/latest/plugins/index.html>`_
and `installation instructions <http://sark.readthedocs.org/en/latest/plugins/installation.html>`_.

```

`docs/Installation.rst`:

```rst
Installation
============

For Sark Users
~~~~~~~~~~~~~~

To get the bleeding edge version, use:

.. code:: bash

    pip3 install -U git+https://github.com/tmr232/Sark.git#egg=Sark

For older versions of IDA (7.3 or lower), use:

.. code:: bash

    pip2 install -U git+https://github.com/tmr232/Sark.git@IDA-6.x#egg=Sark

And see :doc:`Support`

Alternatively, you can install Sark directly from PyPI. The Sark version will
match the IDA versions, more or less. So for 7.4 or higher, you'll just want
the latest:

.. code:: bash

    pip3 install sark

But for 7.3 or earlier, you'll want a version smaller than 7.4:

.. code:: bash

    pip2 install "sark<7.4"


That said, installing from the repo is the only way to be sure you get the
latest version of Sark.


To install the IDA Plugins (optional) download the entire repository
from `GitHub <https://github.com/tmr232/Sark>`__ and read :doc:`plugins/installation`.

Updates
^^^^^^^

To update Sark to the latest version, just run the installation command
again.


For Sark Developers
~~~~~~~~~~~~~~~~~~~

If you want to help in the development of Sark, follow this.

Clone the Sark repository to get the latest version

.. code:: bash

    git clone https://github.com/tmr232/Sark.git && cd Sark
    pip3 install -e .


Updates
^^^^^^^

To update Sark to the latest version (including all *installed* codecs
and plugins) simply pull the latest version from the repo

.. code:: bash

    git pull

```

`docs/Introduction.rst`:

```rst
Introduction
============

Even with books like Alexander Hanel's `The Beginner's Guide to
IDAPython <https://leanpub.com/IDAPython-Book>`__, writing IDA scripts
still remains a daunting task. The need to dive into the IDA SDK's
header files (all 54 of them), read ``idaapi.py``, ``idc.py`` and
``idautils.py``, and preferably some existing plugins as well, wards off
many researchers and keeps the script & plugin writing community small.

Being a researcher myself, I wanted to make scripting IDA a bit easier
and more intuitive. I wanted to spend the majority of my (scripting)
time writing code (be it in a code editor or an `interactive
shell <https://github.com/james91b/ida_ipython>`__) and not reading
someone else's (I prefer spending my reading efforts on assembly.) So I
created Sark.

Sark, (named after the notorious Tron villain,) is an object-oriented
scripting layer written on top of IDAPython to provide ease of use, as
well as additional tools for writing advanced scripts and plugins.

This tutorial will show you the basics of Sark, to get you started right
away.

.. image:: ./media/meme_bring_in_the_logic_probe_small.jpg

```

`docs/Makefile`:

```
# Makefile for Sphinx documentation
#

# You can set these variables from the command line.
SPHINXOPTS    =
SPHINXBUILD   = sphinx-build
PAPER         =
BUILDDIR      = _build

# User-friendly check for sphinx-build
ifeq ($(shell which $(SPHINXBUILD) >/dev/null 2>&1; echo $$?), 1)
$(error The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from http://sphinx-doc.org/)
endif

# Internal variables.
PAPEROPT_a4     = -D latex_paper_size=a4
PAPEROPT_letter = -D latex_paper_size=letter
ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
# the i18n builder cannot share the environment and doctrees with the others
I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .

.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest gettext

help:
	@echo "Please use \`make <target>' where <target> is one of"
	@echo "  html       to make standalone HTML files"
	@echo "  dirhtml    to make HTML files named index.html in directories"
	@echo "  singlehtml to make a single large HTML file"
	@echo "  pickle     to make pickle files"
	@echo "  json       to make JSON files"
	@echo "  htmlhelp   to make HTML files and a HTML help project"
	@echo "  qthelp     to make HTML files and a qthelp project"
	@echo "  devhelp    to make HTML files and a Devhelp project"
	@echo "  epub       to make an epub"
	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
	@echo "  latexpdfja to make LaTeX files and run them through platex/dvipdfmx"
	@echo "  text       to make text files"
	@echo "  man        to make manual pages"
	@echo "  texinfo    to make Texinfo files"
	@echo "  info       to make Texinfo files and run them through makeinfo"
	@echo "  gettext    to make PO message catalogs"
	@echo "  changes    to make an overview of all changed/added/deprecated items"
	@echo "  xml        to make Docutils-native XML files"
	@echo "  pseudoxml  to make pseudoxml-XML files for display purposes"
	@echo "  linkcheck  to check all external links for integrity"
	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"

clean:
	rm -rf $(BUILDDIR)/*

html:
	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
	@echo
	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."

dirhtml:
	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
	@echo
	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."

singlehtml:
	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
	@echo
	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."

pickle:
	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
	@echo
	@echo "Build finished; now you can process the pickle files."

json:
	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
	@echo
	@echo "Build finished; now you can process the JSON files."

htmlhelp:
	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
	@echo
	@echo "Build finished; now you can run HTML Help Workshop with the" \
	      ".hhp project file in $(BUILDDIR)/htmlhelp."

qthelp:
	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
	@echo
	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/Sark.qhcp"
	@echo "To view the help file:"
	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/Sark.qhc"

devhelp:
	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
	@echo
	@echo "Build finished."
	@echo "To view the help file:"
	@echo "# mkdir -p $$HOME/.local/share/devhelp/Sark"
	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/Sark"
	@echo "# devhelp"

epub:
	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
	@echo
	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."

latex:
	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
	@echo
	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
	@echo "Run \`make' in that directory to run these through (pdf)latex" \
	      "(use \`make latexpdf' here to do that automatically)."

latexpdf:
	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
	@echo "Running LaTeX files through pdflatex..."
	$(MAKE) -C $(BUILDDIR)/latex all-pdf
	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."

latexpdfja:
	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
	@echo "Running LaTeX files through platex and dvipdfmx..."
	$(MAKE) -C $(BUILDDIR)/latex all-pdf-ja
	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."

text:
	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
	@echo
	@echo "Build finished. The text files are in $(BUILDDIR)/text."

man:
	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
	@echo
	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."

texinfo:
	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
	@echo
	@echo "Build finished. The Texinfo files are in $(BUILDDIR)/texinfo."
	@echo "Run \`make' in that directory to run these through makeinfo" \
	      "(use \`make info' here to do that automatically)."

info:
	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
	@echo "Running Texinfo files through makeinfo..."
	make -C $(BUILDDIR)/texinfo info
	@echo "makeinfo finished; the Info files are in $(BUILDDIR)/texinfo."

gettext:
	$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
	@echo
	@echo "Build finished. The message catalogs are in $(BUILDDIR)/locale."

changes:
	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
	@echo
	@echo "The overview file is in $(BUILDDIR)/changes."

linkcheck:
	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
	@echo
	@echo "Link check complete; look for any errors in the above output " \
	      "or in $(BUILDDIR)/linkcheck/output.txt."

doctest:
	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
	@echo "Testing of doctests in the sources finished, look at the " \
	      "results in $(BUILDDIR)/doctest/output.txt."

xml:
	$(SPHINXBUILD) -b xml $(ALLSPHINXOPTS) $(BUILDDIR)/xml
	@echo
	@echo "Build finished. The XML files are in $(BUILDDIR)/xml."

pseudoxml:
	$(SPHINXBUILD) -b pseudoxml $(ALLSPHINXOPTS) $(BUILDDIR)/pseudoxml
	@echo
	@echo "Build finished. The pseudo-XML files are in $(BUILDDIR)/pseudoxml."

```

`docs/Support.rst`:

```rst
=======
Support
=======

IDA 7.4 & Python 3
------------------

Those versions are under active support and expected to receive updates.

IDA 7.4 made 2 significant changes that affect support

1. Python 3 support

2. Python 2: 6.95 compatibility APIs OFF by default

`IDA 7.4 release notes <https://www.hex-rays.com/products/ida/7.4/index.shtml>`_

This means that all code breaks by default - be it Python 2 or 3.
While adapting Sark to the new APIs & Python 3 I concluded that
actively maintaining & developing multiple (IDA 7.4 and lower, Python 2 & 3)
versions incurs an overhead that is too high for me. As a result -
Sark will only support Python 3 on IDA 7.4. Older versions of IDA will
get bugfixes. IDA 7.4 with Python 2 will receive no support.

If you need Python 2 support on IDA 7.4, please contact me or create
an issue on this repo. I am not opposed to adding bugfix-based support.

Older Versions
--------------

Older versions of IDA (7.3 and lower) using Python 2 are still
supported for bugfixes.

The older version is maintained on the `IDA-6.x branch <https://github.com/tmr232/Sark/tree/IDA-6.x>`_.

Installation of the older version follows the same flow as before:

.. code:: bash

    pip2 install -U git+https://github.com/tmr232/Sark.git@IDA-6.x#egg=Sark

To develop locally, clone the repo & check-out the ``IDA-6.x`` branch.

```

`docs/api/Code-Blocks.rst`:

```rst
Code Blocks
===========

If you ever looked at a function in the Graph-View, you know what code
blocks are. They are the nodes in the function graph, sometimes referred
to as a flowchart.

.. code:: python

    >>> block = sark.CodeBlock()
    >>> print(list(block.next))
    [<CodeBlock(start_ea=0x00417567, end_ea=0x00417570)>,
     <CodeBlock(start_ea=0x0041759E, end_ea=0x004175D4)>]

Sark's ``CodeBlock`` object inherits from the ``idaapi.BasicBlock``
objects, and adds a few handy members.

+----------+------------------------------------------+
| Member   | Usage                                    |
+==========+==========================================+
| lines    | the lines in the block, as a generator   |
+----------+------------------------------------------+
| next     | successor nodes, as a generator          |
+----------+------------------------------------------+
| prev     | predecessor nodes, as a generator        |
+----------+------------------------------------------+
| color    | the background color of the node         |
+----------+------------------------------------------+

These members allow for easy traversal and analysis of nodes in a graph.

FlowChart
~~~~~~~~~

Sark's flowchart, inheriting from ``idaapi.FlowChart``, is in every way
the same except for returning Sark ``CodeBlock`` objects instead of
``idaapi.BasicBlock`` ones. It can be used to quickly fetch all the
blocks in a function graph.

Getting Codeblocks
~~~~~~~~~~~~~~~~~~

Codeblocks are created using the ``sark.CodeBlock(ea)`` class.
Flowcharts can be retrieved using the ``sark.FlowChart(ea)``
class accordingly.

In some cases, you may want to go over more than one function. In those
cases, you can use the ``sark.codeblocks(start=None, end=None, full=True)`` function.
The ``full`` parameter controls the way the blocks are generated. With ``full=True``,
``FlowChart`` objects are generated per function, yielding fully capable ``CodeBlock``
objects. With ``full=False``, a single ``FlowChart`` is generated for the entire
address range. This results in faster iteration, but since the blocks are not associated
to their containing functions, it is not possible to get or set block colors (line color
will change, though.)

Advanced Usage
~~~~~~~~~~~~~~

Since the function flowchart is actually a graph, it makes sense to use
it as one. To ease you into it, the ``sark.get_nx_graph(ea)`` function
was added.

.. code:: python

    >>> sark.get_nx_graph(idc.here())
    <networkx.classes.digraph.DiGraph at 0x85d6570>

The function returns a `NetworkX <https://networkx.github.io/>`__
``DiGraph`` object representing the flowchart, with each node being the
``start_ea`` of a matching block. Using NetworkX's functionality, it is
easy to trace routes in the graph.

.. code:: python

    >>> import networkx as nx
    >>> func = sark.Function()
    >>> graph = sark.get_nx_graph(func.ea)
    >>> start_address = sark.get_block_start(func.start_ea)  # The `get_block_start(ea)` is short for `get_codeblock(ea).start_ea`
    >>> end_address = sark.get_block_start(func.end_ea - 1)  # Remember, `end_ea` is outside the function!
    >>> path = nx.shortest_path(graph, start_address, end_address)
    >>> print("From {} to {}".format(hex(start_address), hex(end_address)))
    From 0x417400L to 0x4176a6L

    >>>print " -> ".join(map(hex, nx.shortest_path(graph, start, end)))
    0x417400L -> 0x41745dL -> 0x417483L -> 0x417499L -> 0x4176a6L

```

`docs/api/Enums.rst`:

```rst
Enums
=====

Enums in IDA are a great way to name numbers and bit-values for easier
reading.

.. code:: python

    >>> for enum in sark.enums():
    ...     print("{}:".format(enum.name))
    ...     for member in enum.members:
    ...         print("    {:<30} = {}".format(member.name, member.value))
    ...     print()
    POOL_TYPE:
        NonPagedPool                   = 0
        PagedPool                      = 1
        NonPagedPoolMustSucceed        = 2
        DontUseThisType                = 3
        NonPagedPoolCacheAligned       = 4
        PagedPoolCacheAligned          = 5
        NonPagedPoolCacheAlignedMustS  = 6
        MaxPoolType                    = 7

    CREATE_FILE_TYPE:
        CreateFileTypeNone             = 0
        CreateFileTypeNamedPipe        = 1
        CreateFileTypeMailslot         = 2

The Sark ``Enum`` object provides the following members:

+------------+-------------------------------------------+
| Member     | Usage                                     |
+============+===========================================+
| name       | the enum name                             |
+------------+-------------------------------------------+
| comments   | enum comments, similar to line comments   |
+------------+-------------------------------------------+
| eid        | the enum-id of the enum                   |
+------------+-------------------------------------------+
| bitfield   | is the enum a bitfield                    |
+------------+-------------------------------------------+
| members    | the enum member constants                 |
+------------+-------------------------------------------+

Using the ``Enum`` object you can easily enumerate and manipulate enums
in IDA.

Enum Members
~~~~~~~~~~~~

The ``.members`` member of ``sark.Enum`` returns a members object. The
members object allows easy enumeration and manipulation of the members:

.. code:: python

    >>> my_enum = sark.add_enum("MyEnum")
    >>> my_enum.members.add("first", 0)
    >>> my_enum.members.add("second", 1)
    >>> my_enum.members.add("third", 2)
    >>> my_enum.members.remove("second")
    >>> for member in my_enum.members:
    ...     print("{} = {}".format(member.name, member.value))
    first = 0
    third = 2

Each member provides the following:

+------------+-----------------------+
| Member     | Usage                 |
+============+=======================+
| name       | the member name       |
+------------+-----------------------+
| value      | the member value      |
+------------+-----------------------+
| comments   | the member comments   |
+------------+-----------------------+
| enum       | the containing enum   |
+------------+-----------------------+

Getting Enums
-------------

There are several ways to get an enum. All are summed in the following
table:

+------------------------------------+------------------------------------+
| Code                               | Explanation                        |
+====================================+====================================+
| ``sark.enums()``                   | iterate all the enums in the IDB   |
+------------------------------------+------------------------------------+
| ``sark.Enum("EnumName")``          | get an existing enum by name       |
+------------------------------------+------------------------------------+
| ``sark.Enum(eid=enum_id)``         | get an enum using a known id       |
+------------------------------------+------------------------------------+
| ``sark.add_enum("NewEnumName")``   | create a new enum                  |
+------------------------------------+------------------------------------+

```

`docs/api/Functions.rst`:

```rst
Functions
=========

Functions are another basic object in Sark. Each one provides access to
a single function in IDA.

.. code:: python

    >>> my_func = sark.Function()  # The same arguments as `sark.Line`
    >>> print(my_func)
    Function(name="sub_417400", addr=0x00417400)

    >>> my_func.name = "my_func"
    >>> print(my_func)
    Function(name="my_func", addr=0x00417400)

    >>> for line in my_func.lines:
    ...     print(line.disasm)
    push    ebp
    mov     ebp, esp
    sub     esp, 0DCh
    push    ebx
    push    esi
    .
    .
    .

Like the ``sark.Line`` objects, they encapsulate relevant API into a
single object. Some useful members are:

+-------------+----------------------------------------------------------------+
| Member      | Usage                                                          |
+=============+================================================================+
| start_ea    | starting address                                               |
+-------------+----------------------------------------------------------------+
| end_ea      | end address                                                    |
+-------------+----------------------------------------------------------------+
| ea          | alias for ``start_ea`` (for comparability with ``sark.Line``)   |
+-------------+----------------------------------------------------------------+
| comments    | function comments                                              |
+-------------+----------------------------------------------------------------+
| name        | function name                                                  |
+-------------+----------------------------------------------------------------+
| flags       | function flags                                                 |
+-------------+----------------------------------------------------------------+
| lines       | all the lines in the function (a generator)                    |
+-------------+----------------------------------------------------------------+
| xrefs\_\*   | xrefs to and from the function [#xrefs_to]_                    |
+-------------+----------------------------------------------------------------+

All similarly named members between ``sark.Line`` and ``sark.Function``
work similarly as well to avoid confusion.

Getting Functions
~~~~~~~~~~~~~~~~~

There are 2 ways to get functions:

1. Using the ``sark.Function`` class, which accepts the same arguments
   as ``sark.Line``;
2. Using ``sark.functions`` to iterate over functions. It is the same as
   ``sark.lines``, but does not accept a ``reverse`` argument.

.. rubric:: Footnotes

.. [#xrefs_to] Xrefs from a function include **only** references with a target outside the
    function. So recursion will be ignored.
```

`docs/api/IDB-Graphs.rst`:

```rst
IDB Graphs
==========

Earlier we discussed codeblock graphs inside functions. Another
interesting graph is the call graph connecting all the functions.

As we have already played with graphs earlier, we will not delve into
the details.

Getting IDB Graphs
~~~~~~~~~~~~~~~~~~

To get an IDB graph, use ``sark.graph.get_idb_graph()``. The function traverses
all xrefs from and to all functions to create a graph of the IDB, with
each node being the address of a function's ``start_ea``.

```

`docs/api/Instructions.rst`:

```rst
Instructions
============

As promised - we arrive to discuss the instruction objects. Instruction
objects represent the actual assembly code of each line.

.. code:: python

    >>> line = sark.Line()
    >>> insn = line.insn
    >>> print(line)
    [00417555]    mov     ecx, [eax+8]

    >>> print(insn.mnem)
    mov

    >>> print(insn.operands)
    [<Operand(n=0, text='ecx')>, <Operand(n=1, text='[eax+8]')>]

Out of their members,

+------------+-----------------------------------------+
| Member     | Usage                                   |
+============+=========================================+
| operands   | list of operands                        |
+------------+-----------------------------------------+
| mnem       | opcode mnemonic                         |
+------------+-----------------------------------------+
| has\_reg   | is a reg used in the instruction        |
+------------+-----------------------------------------+
| regs       | the registers used in the instruction   |
+------------+-----------------------------------------+

``Instruction.operands`` is the most interesting one.

Operands
~~~~~~~~

Each operand provides the means to analyze individual operands in the
code.

.. code:: python

    >>> print(insn.operands[1])
    <Operand(n=1, text='[eax+8]')>

    >>> print("{0.reg} + {0.offset}".format(insn.operands[1]))
    eax + 8

+-------------+-----------------------------------------+
| Member      | Usage                                   |
+=============+=========================================+
| n           | operand index in instruction            |
+-------------+-----------------------------------------+
| type        | numeric type a-la IDA SDK               |
+-------------+-----------------------------------------+
| size        | data size of the operand                |
+-------------+-----------------------------------------+
| is\_read    | is the operand read from                |
+-------------+-----------------------------------------+
| is\_write   | is the operand written to               |
+-------------+-----------------------------------------+
| reg         | the register used in the operand        |
+-------------+-----------------------------------------+
| text        | the operand text, as displayed in IDA   |
+-------------+-----------------------------------------+
| base        | the ``base`` register in an             |
|             | address-phrase of the form              |
|             | ``[base + index * scale + offset]``     |
+-------------+-----------------------------------------+
| index       | the ``index`` register in a phrase      |
+-------------+-----------------------------------------+
| scale       | the ``scale`` in a phrase               |
+-------------+-----------------------------------------+
| offset      | the ``offset`` in a phrase              |
+-------------+-----------------------------------------+


Getting Instructions
~~~~~~~~~~~~~~~~~~~~

The best way to retrieve instruction objects is using the ``.insn``
member of ``sark.Line``.

```

`docs/api/Lines.rst`:

```rst
Lines
=====

Lines are the most basic and intuitive object in Sark. A line in the
IDA-View is a line in Sark. Let's have a look.

.. code:: python

    >>> my_line = sark.Line()  # Same as `sark.Line(ea=idc.here())`
    >>> print(my_line)
    [00417401]    mov     ebp, esp

    >>> my_line.comments.regular = "The line at 0x{:08X}".format(my_line.ea)
    >>> print(my_line)
    [00417401]    mov     ebp, esp        ; The line at 0x00417401

The ``sark.Line`` object encapsulates most of the line-relevant
functions of IDAPython. Some examples include:

+---------------+----------------------------------+
| Member        | Usage                            |
+===============+==================================+
| ea            | line's address                   |
+---------------+----------------------------------+
| comments      | line comments                    |
+---------------+----------------------------------+
| name          | the name of the line (if any)    |
+---------------+----------------------------------+
| insn          | assembly instruction             |
+---------------+----------------------------------+
| xrefs\_to     | cross references to the line     |
+---------------+----------------------------------+
| xrefs\_from   | cross references from the line   |
+---------------+----------------------------------+
| bytes         | the actual bytes in the line     |
+---------------+----------------------------------+

For the rest, I suggest reading the highly documented code, or using the
interactive shell to experiment with the ``sark.Line`` object.

The line object contains 4 notable members: ``comments``, ``insn`` and
the ``xrefs_*`` pair.

Line Comments
~~~~~~~~~~~~~

The ``comments`` member provides access to all comment types: - Regular
comments - Repeating comments - Anterior lines - Posterior lines

It allows you to get, as well as set comments. Each change to the
comments will cause the UI to refresh.

.. code:: python

    >>> anterior = my_line.comments.anterior
    >>> my_line.comments.regular = "My Regular Comment"

Line Xrefs
~~~~~~~~~~

Provide access to ``Xref`` objects describing the line's cross
references. ``Xref`` objects will be discussed later under :doc:`Xrefs`.

Instructions
~~~~~~~~~~~~

Provide access to the line's instructions, down to the single operand.
``Instruction`` objects will be discussed later under :doc:`Instructions`.

Getting Lines
~~~~~~~~~~~~~

There are several ways to get lines. Either directly or from other
objects.

+----------------------------------------------+---------------------------------------------------------+
| Method                                       | Effect                                                  |
+==============================================+=========================================================+
| **A Single Line**                                                                                      |
+----------------------------------------------+---------------------------------------------------------+
| ``sark.Line()``                              | Get the current line                                    |
+----------------------------------------------+---------------------------------------------------------+
| ``sark.Line(ea=my_address)``                 | Get the line at the given address                       |
+----------------------------------------------+---------------------------------------------------------+
| ``sark.Line(name=some_name)``                | Get the line with the given name                        |
+----------------------------------------------+---------------------------------------------------------+
| **Multiple Lines**                                                                                     |
+----------------------------------------------+---------------------------------------------------------+
| ``sark.lines()``                             | Iterate all lines in the IDB                            |
+----------------------------------------------+---------------------------------------------------------+
| ``sark.lines(start=start_ea, end=end_ea)``   | Iterate all lines between ``start_ea`` and ``end_ea``   |
+----------------------------------------------+---------------------------------------------------------+
| ``sark.lines(selection=True)``               | Iterate all lines in current selection                  |
+----------------------------------------------+---------------------------------------------------------+
| ``sark.lines(reverse=True)``                 | Iterate lines in reverse order                          |
+----------------------------------------------+---------------------------------------------------------+


Objects that contain lines, such as functions and code blocks, can
return their own set of lines. See ``sark.Function().lines`` for an
example.

```

`docs/api/Miscellaneous.rst`:

```rst
Miscellaneous
=============

Sark also has a lot of functionality outside of the core objects.

+------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+
| Function                                       | Description                                                                                                               |
+================================================+===========================================================================================================================+
| ``sark.fix_addresses(start=None, end=None)``   | returns a ``start, end`` pair, where ``None`` is replaced with the start-address and end-address of the IDB accordingly   |
+------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+
| ``sark.is_same_function(ea1, ea2)``            | checks if the addresses are in the same function                                                                          |
+------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+
| ``sark.get_name_or_address(ea)``               | returns the name of the address if it exists. Otherwise a hex representation is returned                                  |
+------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------+

```

`docs/api/Switch.rst`:

```rst
Switch
======

The switch-case is a common construct in compiled code, and IDA is doing
a great job at analyzing it.

.. code:: python

    >>> switch = sark.Switch(idc.here())
    >>> for case, target in switch:
    ...     print("{} -> 0x{:08X}".format(case, target))
    0 -> 0x004224C9
    1 -> 0x0042249F
    2 -> 0x0042251B
    3 -> 0x0042251B
    4 -> 0x00422475
    5 -> 0x0042251B
    6 -> 0x0042251B
    7 -> 0x0042251B
    8 -> 0x004224F3
    9 -> 0x0042251B
    10 -> 0x0042251B
    11 -> 0x00422448

It provides the following members

+--------------+----------------------------------------+
| Member       | Usage                                  |
+==============+========================================+
| targets      | switch target addresses                |
+--------------+----------------------------------------+
| cases        | switch case values                     |
+--------------+----------------------------------------+
| pairs        | iterator of ``(case, target)`` pairs   |
+--------------+----------------------------------------+
| get\_cases   | get the cases matching a target        |
+--------------+----------------------------------------+

The ``sark.Switch`` object is similar to a Python ``dict``, mapping
cases to targets. ``switch[case]`` returns the relevant target, and
iteration returning the cases.

Getting Switches
~~~~~~~~~~~~~~~~

To check if an address is a switch address, use ``sark.is_switch(ea)``.
To get the switch, use ``sark.Switch(ea)``.

```

`docs/api/UI.rst`:

```rst
UI
==

Sark provides some basic utilities and wrappers for IDA's UI.

NXGraph
~~~~~~~

A natural extension to creating and analyzing graphs, is plotting them.
IDA provides a generic API via the ``idaapi.GraphViewer`` interface. As
Sark mainly uses NetworkX digraphs, the ``sark.ui.NXGraph`` class has
been created to provide an easy plotting solution.

.. code:: python

    >>> viewer = sark.ui.NXGraph(graph, title="My Graph", handler=sark.ui.AddressNodeHandler())
    >>> viewer.Show()

The ``NXGraph`` constructor takes several arguments:

+------------+--------------------------------------+
| Argument   | Desctription                         |
+============+======================================+
| graph      | the graph to plot                    |
+------------+--------------------------------------+
| title      | (opt.) title for the graph           |
+------------+--------------------------------------+
| handler    | (opt.) a default handler for nodes   |
+------------+--------------------------------------+
| padding    | (opt.) visual padding of nodes       |
+------------+--------------------------------------+

After an ``NXGraph`` is created, use ``.Show()`` to display it.

Node Handlers
^^^^^^^^^^^^^

To allow different types of node data, ``NXGraph`` uses node handlers.
Node handlers inherit from ``sark.ui.BasicNodeHandler`` and implement
the callbacks required for them (all are optional).

+---------------------+-------------------------------------------------------------------------+
| Callback            | Usage                                                                   |
+=====================+=========================================================================+
| on\_get\_text       | returns the text to display for the node                                |
+---------------------+-------------------------------------------------------------------------+
| on\_click           | handles a click on the node. Return ``True`` to set the cursor on it.   |
+---------------------+-------------------------------------------------------------------------+
| on\_double\_click   | same as ``on_click``                                                    |
+---------------------+-------------------------------------------------------------------------+
| on\_hint            | the hint to show                                                        |
+---------------------+-------------------------------------------------------------------------+
| on\_bg\_color       | returns the background color for the node                               |
+---------------------+-------------------------------------------------------------------------+
| on\_frame\_color    | returns the frame (border) color for the node                           |
+---------------------+-------------------------------------------------------------------------+

There are 2 existing handlers you can use.

+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Handler                  | Info                                                                                                                                                                         |
+==========================+==============================================================================================================================================================================+
| ``BasicNodeHandler``     | The most basic handler. Calls ``str`` to get node text, and nothing else. This is the default handler for ``NXGraph``.                                                       |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``AddressNodeHandler``   | Assumes all nodes are IDB addresses. For node text, it shows the address' name if it exists, or a hex address otherwise. On double click, it jumps to the clicked address.   |
+--------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+


Menu Manager
~~~~~~~~~~~~

Sark provides a menu-manager class to allow the addition of top-level menus to IDA's GUI.
This is done by abusing QT to find the top level menu, but you don't need to worry about that.



|menu_image|


.. code:: python

    >>> # Use the manager to add top-level menus
    >>> menu_manager = sark.ui.MenuManager()
    >>> menu_manager.add_menu("My Menu")
    >>> # Use the standard API to add menu items
    >>> # Assume the action's text is "My Action"
    >>> idaapi.attach_action_to_menu("My Menu/", "SomeActionName", idaapi.SETMENU_APP)
    >>> # When a menu is not needed, remove it
    >>> menu_manager.remove_menu("My Menu")
    >>> # When you are done with the manager (and want to remove all menus you added.)
    >>> # clear it before deleting.
    >>> menu_manager.clear()

As you can see in the above code, the `MenuManager` class only handles the addition of
a top-level menu. After that, IDA's own APIs can be used freely with the created
menu to add or remove menu items


.. |menu_image| image:: ../media/ui/top-level-menu.png
```

`docs/api/Xrefs.rst`:

```rst
Xrefs
=====

Cross references are a core concept in IDA. They provide us with links
between different objects and addresses throughout an IDB.

.. code:: python

    >>> for xref in sark.Line().xrefs_from:
    ...     print(xref)
    <Xref(frm=0x0041745B, to=0x0041745D, iscode=1, user=0, type='Ordinary_Flow')>
    <Xref(frm=0x0041745B, to='loc_4174A4', iscode=1, user=0, type='Code_Near_Jump')>

    >>> for xref in sark.Line().xrefs_from:
    ...     if xref.type.is_jump:
    ...         print(xref)
    <Xref(frm=0x0041745B, to='loc_4174A4', iscode=1, user=0, type='Code_Near_Jump')>

Sark xrefs are pretty compact objects:

+----------+----------------------------+
| Member   | Usage                      |
+==========+============================+
| frm      | xref source address        |
+----------+----------------------------+
| to       | xref destination address   |
+----------+----------------------------+
| iscode   | is code xref               |
+----------+----------------------------+
| user     | is user defined xref       |
+----------+----------------------------+
| type     | ``XrefType`` object        |
+----------+----------------------------+

XrefType
~~~~~~~~

To make querying the type of the xref as easy as possible, the
``XrefType`` object was created:

+------------+----------------------------------------------------------------------------+
| Member     | Usage                                                                      |
+============+============================================================================+
| name       | a string representing the type, mainly for display                         |
+------------+----------------------------------------------------------------------------+
| type       | the numeric type constant, as per IDA SDK                                  |
+------------+----------------------------------------------------------------------------+
| is\_call   | is the xref a call                                                         |
+------------+----------------------------------------------------------------------------+
| is\_jump   | is the xref a jump                                                         |
+------------+----------------------------------------------------------------------------+
| is\_\*     | predicates to check if a specific type applies. Includes all xref types.   |
+------------+----------------------------------------------------------------------------+

Usage is quite simple and looks like plain English (of sorts):

.. code:: python

    >>> if xref.type.is_jump:
    ...     print("xref is jump.")

Getting Xrefs
~~~~~~~~~~~~~

Xrefs can be retrieved from lines or functions. Both objects have
``xrefs_from`` and ``xrefs_to`` properties that allow retrieval of the
relevant xrefs.

```

`docs/api/index.rst`:

```rst
API
===

.. toctree::

    tutorial-conventions.rst
    Lines
    Functions
    Xrefs
    Instructions
    Code-Blocks
    segments
    Switch
    Enums
    IDB-Graphs
    UI
    Miscellaneous
```

`docs/api/segments.rst`:

```rst
Segments
========

Though not as popular as functions and lines, IDA segments include both. In Sark, ``Segment``
objects allow access to underlying ``Function`` and ``Line`` objects.

.. code:: python

    >>> #
    >>> # Reference Lister
    >>> #
    >>> # List all functions and all references to them in the current section.
    >>> #
    >>> # Implemented with Sark
    >>> #
    >>> # See reference implementation here: https://code.google.com/p/idapython/wiki/ExampleScripts
    >>> #
    >>> for function in sark.Segment().functions:
    >>>    print("Function %s at 0x%x" % (function.name, function.ea))
    >>>    for ref in function.crefs_to:
    >>>        print("  called from %s(0x%x)" % (sark.Function(ref).name, ref))


Like the ``sark.Line`` objects, they encapsulate relevant API into a
single object. Some useful members are:

+-------------+----------------------------------------------------------------+
| Member      | Usage                                                          |
+=============+================================================================+
| start_ea    | starting address                                               |
+-------------+----------------------------------------------------------------+
| end_ea      | end address                                                    |
+-------------+----------------------------------------------------------------+
| ea          | alias for ``start_ea`` (for comparability with ``sark.Segment``)|
+-------------+----------------------------------------------------------------+
| comments    | segment comments                                               |
+-------------+----------------------------------------------------------------+
| name        | segment name                                                   |
+-------------+----------------------------------------------------------------+
| lines       | all the lines in the segment (a generator)                     |
+-------------+----------------------------------------------------------------+
| functions   | all the functions in the segment (a generator)                 |
+-------------+----------------------------------------------------------------+
| size        | the size of the segment                                        |
+-------------+----------------------------------------------------------------+
| permissions | the segments permissions (r/w/x). Can be modified.             |
+-------------+----------------------------------------------------------------+
| next        | the next segment.                                              |
+-------------+----------------------------------------------------------------+
| bitness     | the bitness of the segment (16, 32 or 64.)                     |
+-------------+----------------------------------------------------------------+

All similarly named members between ``sark.Line`` and ``sark.Segment``
work similarly as well to avoid confusion.

Getting Segments
~~~~~~~~~~~~~~~~

There are 2 ways to get segments:

1. Using the ``sark.Segment`` object, using an address in a segment, a segment name,
   or the index of a segment.
2. Using ``sark.segments`` to iterate over segments.

```

`docs/api/tutorial-conventions.rst`:

```rst
Tutorial Conventions
====================

`IDA IPython <https://github.com/james91b/ida_ipython>`__ is used in the
examples unless stated otherwise. For brevity, assume the following code
precedes any example code.

.. code:: python

    import idaapi, idc, idautils
    import sark

As Sark is a large, evolving library, the API documentation provided
here will be partial and only include what is needed to get you started.
However, the Sark code in itself is heavily documented.

```

`docs/conf.py`:

```py
# -*- coding: utf-8 -*-
#
# Sark documentation build configuration file, created by
# sphinx-quickstart on Mon May 25 16:03:27 2015.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Sark'
copyright = u'2015, Tamir Bahar'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1.0'
# The full version, including alpha/beta/rc tags.
release = '0.1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'sphinx_rtd_theme'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
# html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Sarkdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'Sark.tex', u'Sark Documentation',
   u'Tamir Bahar', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'sark', u'Sark Documentation',
     [u'Tamir Bahar'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Sark', u'Sark Documentation',
   u'Tamir Bahar', 'Sark', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

# Use documents from the top-level (needed for github)
import shutil
shutil.copy("../CONTRIBUTING.rst", "CONTRIBUTING.rst")
shutil.copy("../AUTHORS.rst", "AUTHORS.rst")
```

`docs/debugging.rst`:

```rst
Debugging IDAPython Scripts
===========================

While IDAPython is extremely useful, it can be a bit of a hassle to debug IDA Pro plugins.
This tutorial will give get you started on debugging IDAPython scripts and plugins
using Python Tools for Visual Studio.

And yes, it is completely free.


The Setup
---------

For this tutorial, we will be using the following software:

#. `IDA Pro 6.8`_
#. `Visual Studio Community`_
#. `Python Tools for Visual Studio`_, documentation can be found `here <https://github.com/Microsoft/PTVS/wiki>`_.
#. Python's ``ptvsd`` module. Install using ``pip install ptvsd``.
#. The following plugin:

    .. code:: python

        # filename: ptvsd_enable.py

        import idaapi
        import ptvsd

        try:
            # Enable the debugger. Raises exception if called more than once.
            ptvsd.enable_attach(secret="IDA")
        except:
            pass


        class DebugPlugin(idaapi.plugin_t):
            flags = idaapi.PLUGIN_FIX
            comment = "PTVSD Debug Enable"
            help = "Enable debugging using PTVSD"
            wanted_name = "PTVSD"
            wanted_hotkey = ""

            def init(self):
                return idaapi.PLUGIN_KEEP

            def term(self):
                pass

            def run(self, arg):
                pass


        def PLUGIN_ENTRY():
            return DebugPlugin()

For the purposes of this tutorial, you can try and debug this plugin:

.. code:: python

    # filename: sample_debuggee.py

    import idaapi


    def my_debugged_function():
        # Set breakpoint here!
        pass


    class SamplePlugin(idaapi.plugin_t):
        flags = idaapi.PLUGIN_PROC
        comment = "Sample Debuggee"
        help = "Sample Debuggee"
        wanted_name = "Sample Debuggee"
        wanted_hotkey = "Shift+D"

        def init(self):
            return idaapi.PLUGIN_KEEP

        def term(self):
            pass

        def run(self, arg):
            my_debugged_function()


    def PLUGIN_ENTRY():
        return SamplePlugin()


Debugging
---------

#. Put ``ptvsd_enable.py`` (provided above) in IDA's plugins directory.
   If you want to use the sample debuggee, put it in the plugins directory as well.
#. Start IDA and load an IDB (otherwise weird issues arise)
#. Load the code you want to debug into Visual Studio and set breakpoints.
#. In Visual Studio (with the plugin file open), use ``DEBUG->Attach to process``

    .. image:: media/debugging/debugging_menu.PNG


#. In the dialog, select ``idaq.exe`` and click ``Attach``

    .. image:: media/debugging/attach_dialog.PNG


#. We are now attached. Once a breakpoint is hit, Visual Studio will break and let you debug.

#. Have fun debugging!

Important Notes
---------------

#. When debugging (breaking and stepping), IDA will be frozen.
#. Load your IDB prior to attaching the debugger.
#. For easy debug-on-demand, keep ``ptvsd_enable.py`` in IDA's plugins directory at all times.
#. To set breakpoints, make sure you load into VS the files that are actually loaded by IDA.

If you find any issues with the tutorial, please submit them `here <https://github.com/tmr232/Sark/issues>`_.


.. _`IDA Pro 6.8`: https://www.hex-rays.com/products/ida/index.shtml
.. _`Visual Studio Community`: https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx
.. _`Python Tools for Visual Studio`: https://pytools.codeplex.com/releases
```

`docs/examples/Capture-Huge-Screenshots.rst`:

```rst
Capture Huge Screenshots
========================

Usage
-----

Click on the image for full scale screenshot.

**Warning:** really big image file.

|image0|

Code
----

.. code:: python

   import sark.qt

   widget = sark.qt.get_widget("IDA View-A")
   sark.qt.resize(widget, 7000, 18000)

   # Move the view about a bit to capture the entire function

   sark.qt.capture_widget(widget, "huge-screenshot.png")

   # Crop the image to remove extra background.

.. |image0| image:: ../media/examples/huge_callgraph.png
   :target: http://i.imgur.com/jwBDM8D.png

```

`docs/examples/Plotting-a-Call-Graph.rst`:

```rst
Plotting a Call Graph
=====================

Usage
-----

Using Windows 8.1 ``http.sys``. Before ``MS15-034``.

.. code:: python

    draw_call_graph(sark.Function(name="_UlpParseRange@32").ea, to=True, distance=4)

.. figure:: ../media/examples/httpsys8_1_callgraph.png
   :alt: 

Code
----

.. code:: python

    import sark
    import networkx as nx

    def draw_call_graph(ea, distance=2, to=False):
        # First, get the IDB graph (caching it might be a good idea
        # as this operation can be time consuming on large IDBs)
        idb_graph = sark.graph.get_idb_graph()
        
        # Get the address of the function to use in the graph
        func_ea = sark.Function(ea).ea

        # Create the call graph
        if to:
            # If we want the calls to our function, we need to reverse
            # the graph
            idb_graph = idb_graph.reverse()
        
        # Use NetworkX to limit the IDB graph
        call_graph = nx.ego_graph(idb_graph, func_ea, distance)

        # Paint the root node red
        call_graph.node[func_ea][sark.ui.NXGraph.BG_COLOR] = 0x80

        if to:
            # If we reversed it before, we need to reverse it again
            # to make the links point the right way
            call_graph = call_graph.reverse()

        # Create an NXGraph viewer
        viewer = sark.ui.NXGraph(call_graph, handler=sark.ui.AddressNodeHandler())
        
        # Show the graph
        viewer.Show()

```

`docs/examples/index.rst`:

```rst
Examples
========

.. toctree::

    Capture-Huge-Screenshots
    Plotting-a-Call-Graph
```

`docs/index.rst`:

```rst
Welcome to the Sark Documentation!
==================================

.. image:: ./media/sark-pacman_small.jpg

Sark (named after the notorious Tron villain) is an object-oriented
scripting layer written on top of IDAPython. Sark is easy to use and
provides tools for writing advanced scripts and plugins.

Sark actively supports IDA7.4 and Python3. For older versions, see :doc:`Support`.


Getting Started
===============

Install Sark from the command line:

.. code:: bash

   pip3 install -U git+https://github.com/tmr232/Sark.git#egg=Sark

Import inside IDA, and start having fun!

.. code:: python

   import sark
   import idaapi

   # Get the current function
   func = sark.Function()

   # Print all lines in the function
   for line in func.lines:
      idaapi.msg("{}\n".format(line))


.. image:: ./media/intro_demo/print_lines.png


.. code:: python

   # Mark all the lines containing xrefs outside the function
   for xref in func.xrefs_from:
      sark.Line(xref.frm).color = 0x8833FF

.. image:: ./media/intro_demo/highlight_xrefs.png


Table of Contents
=================

Contents:

.. toctree::
   :maxdepth: 2

   Introduction
   Installation
   api/index
   examples/index
   plugins/index
   debugging
   Support
   CONTRIBUTING
   AUTHORS

```

`docs/make.bat`:

```bat
@ECHO OFF

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set BUILDDIR=_build
set ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% .
set I18NSPHINXOPTS=%SPHINXOPTS% .
if NOT "%PAPER%" == "" (
	set ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%
	set I18NSPHINXOPTS=-D latex_paper_size=%PAPER% %I18NSPHINXOPTS%
)

if "%1" == "" goto help

if "%1" == "help" (
	:help
	echo.Please use `make ^<target^>` where ^<target^> is one of
	echo.  html       to make standalone HTML files
	echo.  dirhtml    to make HTML files named index.html in directories
	echo.  singlehtml to make a single large HTML file
	echo.  pickle     to make pickle files
	echo.  json       to make JSON files
	echo.  htmlhelp   to make HTML files and a HTML help project
	echo.  qthelp     to make HTML files and a qthelp project
	echo.  devhelp    to make HTML files and a Devhelp project
	echo.  epub       to make an epub
	echo.  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter
	echo.  text       to make text files
	echo.  man        to make manual pages
	echo.  texinfo    to make Texinfo files
	echo.  gettext    to make PO message catalogs
	echo.  changes    to make an overview over all changed/added/deprecated items
	echo.  xml        to make Docutils-native XML files
	echo.  pseudoxml  to make pseudoxml-XML files for display purposes
	echo.  linkcheck  to check all external links for integrity
	echo.  doctest    to run all doctests embedded in the documentation if enabled
	goto end
)

if "%1" == "clean" (
	for /d %%i in (%BUILDDIR%\*) do rmdir /q /s %%i
	del /q /s %BUILDDIR%\*
	goto end
)


%SPHINXBUILD% 2> nul
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
	echo.installed, then set the SPHINXBUILD environment variable to point
	echo.to the full path of the 'sphinx-build' executable. Alternatively you
	echo.may add the Sphinx directory to PATH.
	echo.
	echo.If you don't have Sphinx installed, grab it from
	echo.http://sphinx-doc.org/
	exit /b 1
)

if "%1" == "html" (
	%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/html.
	goto end
)

if "%1" == "dirhtml" (
	%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/dirhtml.
	goto end
)

if "%1" == "singlehtml" (
	%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The HTML pages are in %BUILDDIR%/singlehtml.
	goto end
)

if "%1" == "pickle" (
	%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can process the pickle files.
	goto end
)

if "%1" == "json" (
	%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can process the JSON files.
	goto end
)

if "%1" == "htmlhelp" (
	%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can run HTML Help Workshop with the ^
.hhp project file in %BUILDDIR%/htmlhelp.
	goto end
)

if "%1" == "qthelp" (
	%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; now you can run "qcollectiongenerator" with the ^
.qhcp project file in %BUILDDIR%/qthelp, like this:
	echo.^> qcollectiongenerator %BUILDDIR%\qthelp\Sark.qhcp
	echo.To view the help file:
	echo.^> assistant -collectionFile %BUILDDIR%\qthelp\Sark.ghc
	goto end
)

if "%1" == "devhelp" (
	%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished.
	goto end
)

if "%1" == "epub" (
	%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The epub file is in %BUILDDIR%/epub.
	goto end
)

if "%1" == "latex" (
	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished; the LaTeX files are in %BUILDDIR%/latex.
	goto end
)

if "%1" == "latexpdf" (
	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
	cd %BUILDDIR%/latex
	make all-pdf
	cd %BUILDDIR%/..
	echo.
	echo.Build finished; the PDF files are in %BUILDDIR%/latex.
	goto end
)

if "%1" == "latexpdfja" (
	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
	cd %BUILDDIR%/latex
	make all-pdf-ja
	cd %BUILDDIR%/..
	echo.
	echo.Build finished; the PDF files are in %BUILDDIR%/latex.
	goto end
)

if "%1" == "text" (
	%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The text files are in %BUILDDIR%/text.
	goto end
)

if "%1" == "man" (
	%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The manual pages are in %BUILDDIR%/man.
	goto end
)

if "%1" == "texinfo" (
	%SPHINXBUILD% -b texinfo %ALLSPHINXOPTS% %BUILDDIR%/texinfo
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The Texinfo files are in %BUILDDIR%/texinfo.
	goto end
)

if "%1" == "gettext" (
	%SPHINXBUILD% -b gettext %I18NSPHINXOPTS% %BUILDDIR%/locale
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The message catalogs are in %BUILDDIR%/locale.
	goto end
)

if "%1" == "changes" (
	%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes
	if errorlevel 1 exit /b 1
	echo.
	echo.The overview file is in %BUILDDIR%/changes.
	goto end
)

if "%1" == "linkcheck" (
	%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck
	if errorlevel 1 exit /b 1
	echo.
	echo.Link check complete; look for any errors in the above output ^
or in %BUILDDIR%/linkcheck/output.txt.
	goto end
)

if "%1" == "doctest" (
	%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest
	if errorlevel 1 exit /b 1
	echo.
	echo.Testing of doctests in the sources finished, look at the ^
results in %BUILDDIR%/doctest/output.txt.
	goto end
)

if "%1" == "xml" (
	%SPHINXBUILD% -b xml %ALLSPHINXOPTS% %BUILDDIR%/xml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The XML files are in %BUILDDIR%/xml.
	goto end
)

if "%1" == "pseudoxml" (
	%SPHINXBUILD% -b pseudoxml %ALLSPHINXOPTS% %BUILDDIR%/pseudoxml
	if errorlevel 1 exit /b 1
	echo.
	echo.Build finished. The pseudo-XML files are in %BUILDDIR%/pseudoxml.
	goto end
)

:end

```

`docs/plugins/autostruct.rst`:

```rst
Autostruct
==========

Creating and applying structs in IDA can be quite a hassle.

Go to the structure window, create a structure, define members at specific offsets, go to the disassembly to apply
them, go back to the structure view to correct errors, apply other members... And on and on it goes.

The Autostruct plugin does all this work for you, without ever having to leave the IDA view.
It automatically creates structs, defines member offsets, and applies them in the disassembly view.

Usage
-----

1. Select a line (or lines) containing struct references
 |image1|
2. Press ``Shift + T``
3. Set the struct name
 |image2|
4. Choose the register holding the struct base for the selected code. Autostruct will automatically suggest the most likely candidate in the selection.
 |image3|

 At this point, Autostruct will try and create a new struct, populate it with relevant offsets, and apply it to the
 selection.

 |image4|
5. If a structure of the given name already exists, you will need to select whether to modify the existing structure, apply without modification, or cancel.
 |image5|
6. Struct creation and modification happen seamlessly
 |image6|

Known Issues
------------

Misaligned Member Creation
    When attempting to create a member at an offset belonging to another member, Autostruct will fail.
    This usually happens when a previous definition was incorrect (wrong member size) or when members are
    unions.
    At this point, manual handling (redefining the large member as a smaller one) is required.


.. |image1| image:: ../media/plugins/autostruct-1.png
.. |image2| image:: ../media/plugins/autostruct-2.png
.. |image3| image:: ../media/plugins/autostruct-3.png
.. |image4| image:: ../media/plugins/autostruct-4.png
.. |image5| image:: ../media/plugins/autostruct-5.png
.. |image6| image:: ../media/plugins/autostruct-6.png
```

`docs/plugins/index.rst`:

```rst
Plugins
=======

.. toctree::

    installation
    meaningful
    quick_copy
    autostruct
    xrefsgraph
```

`docs/plugins/installation.rst`:

```rst
Installing Plugins
==================

The IDA Way
-----------

IDA provides a single way to install plugins - stick them in the ``plugins`` subdirectory and you're good to go.

While this is great for compiled plugins, as your build scripts can place the newly compiled plugin there for you, it
is not as comfortable when using scripted plugins. Forgetting to copy the latest version, or updating the code in the
``plugins`` directory instead of your repository can both lead to annoying problems and waste precious time.

Moreover, access to the ``plugins`` directory requires root access.

The Sark Way
------------

To combat the limitations of IDAs plugin loading mechanism, Sark provides the ``plugin_loader.py`` plugin.
Once installed (in the classic IDA way) it allows you to define plugin-lists - a system-wide list and a user-specific
list - to be loaded automatically.

The lists are simple, consisting of full-paths and line-comments::

    C:\Plugins\my_plugin.py

    # This is a comment. Comments are whole lines.
    C:\OtherPlugins\another_plugin.py

Both lists are named ``plugins.list`` and are automatically created by IDA as empty lists at the following locations:

System-Wide
    Under IDA's ``cfg`` subdirectory. The path can be found using ``idaapi.idadir(idaapi.CFG_SUBDIR)``.
    This list requires root access to modify as it is in IDA's installation directory.

User-Specific
    Under IDA's user-directory. ``$HOME/.idapro`` on Linux, ``%appdata/%HexRays/IDA Pro`` on Windows.
    The path can be found using ``idaapi.get_user_idadir()``.
    Each user can set his own plugins to load, thus eliminating the need for root access.


To install your plugins, just add them to one of the lists. This allows you to easily update plugins as you go
without ever needing to copy them.
```

`docs/plugins/meaningful.rst`:

```rst
Show Meaningful
===============

When reversing an executable, we often need to deal with a large amount of unknown code.
To combat this, we usually look for strings and library functions, and use them as guides
as we interpret the code.
When those are ample, we hardly need to look at the assembly code to infer meaning.
On the other hand, the need to constantly jump into functions, pan them around to see all
the strings, then jump back out is quite time consuming and confusing.

Well, no more!

The "Meaningful" plugin allows you to get all the information you need with a simple hotkey.

Usage
-----

Whenever inside a function, just press ``Alt + 0`` to get a table of all the meaningful objects in it:

.. image:: ../media/plugins/first-meaningful-output.png

Since the output is at the `Output window`, a double click on an address will take you to it.

To make things even more agile, you can press ``Ctrl + Alt + 0`` whenever on a line referencing a function
to get the values displayed for that function:

.. image:: ../media/plugins/cursor-at-line.png
.. image:: ../media/plugins/meaningful-output.png


```

`docs/plugins/quick_copy.rst`:

```rst
Quick Copy
==========

The quick copy allows you to easily copy data from the IDB.

Usage
-----

Copying Addresses
~~~~~~~~~~~~~~~~~

To copy the address of the current line, just press ``Ctrl + Alt + C``. It will get copied as a hex number, prefixed
with ``0x``.

To copy the file offset of the current line, simply press ``Ctrl + Alt + O``. It will get copied as a hex
number (like line address copying), prefixed with ``0x``.

Copying Bytes
~~~~~~~~~~~~~

Pressing ``Ctrl + Shift + C`` copies the bytes of the current line or selection.

Copying the current line:

.. image:: ../media/plugins/copy-current-bytes.png

Will result in ``8b 4d 08``, while copying a selection:

.. image:: ../media/plugins/copy-selected-bytes.png

Will result in ``8b 4d 08 8b 51 14``.

```

`docs/plugins/xrefsgraph.rst`:

```rst
Xrefs Graph
===========

The Xrefs-Graph is used to easily generate interactive xref graphs.

Usage
-----

Anywhere within the IDA-View, just right-click [#pre67]_, and select the desired option:

.. image:: ../media/plugins/xrefsgraph-1.png

In the popup dialog, enter the distance (recursion level) desired from the source:

.. image:: ../media/plugins/xrefsgraph-2.png

Once you press ``OK``, the plugin will generate an interactive xrefs graph:

.. image:: ../media/plugins/xrefsgraph-3.png

A double-click on any block will take you to the relevant address. Also, names in the blocks will be
updated as you rename functions.

Known Issues
------------

Node Groups
    While creation of node groups *is* possible via IDA's GUI, it is not presently supported in the plugin.
    Creation of node groups may cause unpredictable errors.

.. rubric:: Footnotes

.. [#pre67] In IDA 6.6 or earlier, use ``View/Graph/Xrefs from source`` or ``View/Graph/Xrefs to source``, as context
    menus cannot be augmented.
```

`plugins/README.rst`:

```rst
=======
Plugins
=======

To install the plugins, first run ``pip install -r requirements.txt``, then follow the instructions found
`here <http://sark.readthedocs.org/en/latest/plugins/installation.html>`_.
```

`plugins/autoenum.py`:

```py
from collections import defaultdict
import idaapi
import sark
import sark.exceptions


def apply_enum_by_name(enum, member_name):
    member_value = enum.members[member_name].value
    for line in sark.lines(*sark.get_selection()):
        for operand in line.insn.operands:
            if operand.type.is_imm:
                if operand.imm == member_value:
                    idaapi.op_enum(line.ea, operand.n, enum.eid, enum.members[member_name].serial)

            elif operand.type.is_displ or operand.type.is_phrase:
                if operand.addr == member_value:
                    idaapi.op_enum(line.ea, operand.n, enum.eid, enum.members[member_name].serial)


def get_common_value(desired=None):
    values = defaultdict(int)
    for line in sark.lines(*sark.get_selection()):
        for operand in line.insn.operands:
            if operand.type.is_imm:
                if desired is not None:
                    if desired == operand.imm:
                        return desired
                values[operand.imm] += 1

            elif operand.type.is_displ or operand.type.is_phrase:
                if desired is not None:
                    if desired == operand.addr:
                        return desired
                values[operand.addr] += 1

    # Ignore 0 as it is usually not interesting
    values[0] = 0
    # Get the most common value
    common_value = max(values.items(), key=lambda x: x[1])[0]
    return common_value


def const_name(enum, value):
    return "{}_{:X}h".format(enum.name.upper(), value)


def rename_immediate():
    highlighted = sark.get_highlighted_identifier()
    try:
        desired = int(highlighted, 0)
    except (ValueError, TypeError):
        desired = None
    value = idaapi.ask_long(get_common_value(desired), "Const Value")
    if value is None:
        return

    name = idaapi.ask_str("", 0, "Constant Name")
    if name is None:
        return

    try:
        enum = sark.Enum('GlobalConstants')
    except sark.exceptions.EnumNotFound:
        enum = sark.add_enum('GlobalConstants')

    enum.members.add(name, value)
    apply_enum_by_name(enum, name)


class RenameImmediateHandler(idaapi.action_handler_t):
    def activate(self, ctx):
        try:
            rename_immediate()
        except:
            import traceback
            traceback.print_exc()

        return 1

    def update(self, ctx):
        if ctx.widget_type == idaapi.BWN_DISASM:
            return idaapi.AST_ENABLE_FOR_WIDGET
        return idaapi.AST_DISABLE_FOR_WIDGET


class AutoEnumHandler(idaapi.action_handler_t):
    def activate(self, ctx):
        try:
            rename_immediate()
        except:
            import traceback
            traceback.print_exc()

        return 1

    def update(self, ctx):
        if ctx.widget_type == idaapi.BWN_DISASM:
            return idaapi.AST_ENABLE_FOR_WIDGET
        return idaapi.AST_DISABLE_FOR_WIDGET


class AutoEnum(idaapi.plugin_t):
    flags = idaapi.PLUGIN_PROC
    comment = "Automatic Enum Generation"
    help = "Automatic Enum Generation"
    wanted_name = "AutoEnum"
    wanted_hotkey = ""

    def init(self):
        self._last_enum = ""

        self.rename_action_desc = idaapi.action_desc_t('AutoEnum:RenameImmediate',
                                                       'Rename immediate value',
                                                       RenameImmediateHandler(),
                                                       'Ctrl+Shift+M',
                                                       'Rename immediate value',
                                                       -1)
        idaapi.register_action(self.rename_action_desc)

        self.autoenum_action_desc = idaapi.action_desc_t('AutoEnum:AutoEnum',
                                                         'Automatically create enum',
                                                         AutoEnumHandler(),
                                                         'Shift+M',
                                                         'Automatically create enum',
                                                         -1)
        idaapi.register_action(self.autoenum_action_desc)

        return idaapi.PLUGIN_KEEP

    def term(self):
        idaapi.unregister_action(self.autoenum_action_desc.name)
        idaapi.unregister_action(self.rename_action_desc.name)

    def run(self, arg):
        pass

    def autoenum(self):
        common_value = get_common_value()

        enum_name = idaapi.ask_str(self._last_enum, 0, "Enum Name")
        if enum_name is None:
            return

        if not enum_name:
            enum_name = None

        self._last_enum = enum_name

        # Can't ask with negative numbers.
        if common_value >> ((8 * sark.core.get_native_size()) - 1):
            common_value = 0

        const_value = idaapi.ask_long(common_value, "Const Value")
        if const_value is None:
            return

        modify = True

        try:
            enum = sark.add_enum(enum_name)

        except sark.exceptions.EnumAlreadyExists:
            enum = sark.Enum(enum_name)
            yes_no_cancel = idaapi.ask_yn(idaapi.ASKBTN_NO,
                                      "Enum already exists. Modify?\n")
            if yes_no_cancel == idaapi.ASKBTN_CANCEL:
                return

            elif yes_no_cancel == idaapi.ASKBTN_YES:
                modify = True

            else:  # yes_no_cancel == idaapi.ASKBTN_NO:
                modify = False

        member_name = const_name(enum, const_value)

        if modify:

            try:
                enum.members.add(member_name, const_value)
            except sark.exceptions.SarkErrorAddEnumMemeberFailed as ex:
                idaapi.msg("[AutoEnum] Adding enum member failed: {}.".format(ex.message))


        else:
            for member in enum.members:
                if member.value == const_value:
                    member_name = member.name
                    break
                else:
                    return

        # Apply the enum
        apply_enum_by_name(enum, member_name)


def PLUGIN_ENTRY():
    return AutoEnum()

```

`plugins/autostruct.py`:

```py
import idaapi
import idc

import sark


def message(*messages):
    for msg in messages:
        for line in msg.splitlines():
            idaapi.msg("[Autostruct] {}\n".format(line))


class AutoStruct(idaapi.plugin_t):
    flags = idaapi.PLUGIN_PROC
    comment = "AutoStruct struct creator"
    help = "Automagically Create and Apply Structs"
    wanted_name = "AutoStruct"
    wanted_hotkey = "Shift+T"

    def init(self):
        self._prev_struct_name = ""
        return idaapi.PLUGIN_KEEP

    def term(self):
        pass

    def run(self, arg):
        start, end = sark.get_selection()

        if not sark.structure.selection_has_offsets(start, end):
            message('No structure offsets in selection. Operation cancelled.')
            idaapi.warning('No structure offsets in selection. Operation cancelled.')
            return

        struct_name = idaapi.ask_str(self._prev_struct_name, 0, "Struct Name")
        if not struct_name:
            message("No structure name provided. Operation cancelled.")
            return
        self._prev_struct_name = struct_name

        common_reg = sark.structure.get_common_register(start, end)
        reg_name = idaapi.ask_str(common_reg, 0, "Register")
        if not reg_name:
            message("No offsets found. Operation cancelled.")
            return

        try:
            offsets, operands = sark.structure.infer_struct_offsets(start, end, reg_name)
        except sark.exceptions.InvalidStructOffset:
            message("Invalid offset found. Cannot create structure.",
                    "Make sure there are no negative offsets in the selection.")
            return

        except sark.exceptions.SarkInvalidRegisterName:
            message("Invalid register name {!r}. Cannot create structs.".format(reg_name))
            return

        try:
            sark.structure.create_struct_from_offsets(struct_name, offsets)
        except sark.exceptions.SarkStructAlreadyExists:
            yes_no_cancel = idaapi.ask_yn(idaapi.ASKBTN_NO,
                                      "Struct already exists. Modify?\n"
                                      "Cancel to avoid applying the struct.")
            if yes_no_cancel == idaapi.ASKBTN_CANCEL:
                return

            elif yes_no_cancel == idaapi.ASKBTN_YES:
                sid = sark.structure.get_struct(struct_name)
                sark.structure.set_struct_offsets(offsets, sid)

            else:  # yes_no_cancel == idaapi.ASKBTN_NO:
                pass

        sark.structure.apply_struct(start, end, reg_name, struct_name)


def PLUGIN_ENTRY():
    return AutoStruct()

```

`plugins/function_flow.py`:

```py
import networkx as nx

import idaapi

from sark import CodeBlock, FlowChart, get_block_start, get_nx_graph

try:
    from sark.ui import ActionHandler

    use_new_ui = True
except:
    use_new_ui = False

COLOR_REACHABLE = 0x66EE11
COLOR_UNREACHABLE = 0x6611EE
COLOR_REACHING = 0x11EE66
COLOR_NOT_REACHING = 0x1166EE
COLOR_SOURCE = 0xEE6611
COLOR_NONE = 0xFFFFFFFF
COLOR_EXIT = 0x000048


def iter_exit_nodes(ea):
    for block in FlowChart(ea):
        # Check if there are successors
        for successor in block.next:
            break
        else:
            yield block


def clear_func(ea):
    for block in FlowChart(ea):
        block.color = COLOR_NONE


def mark_not_reaching_nodes(ea, source_color=COLOR_SOURCE, other_color=COLOR_NOT_REACHING):
    graph = get_nx_graph(ea)
    graph = graph.reverse()
    block_ea = get_block_start(ea)
    reaching = nx.descendants(graph, block_ea)

    try:
        graph_nodes_iter = graph.nodes()
    except:
        graph_nodes_iter = graph.nodes_iter()

    for node_ea in graph_nodes_iter:
        if node_ea not in reaching:
            CodeBlock(node_ea).color = other_color

    CodeBlock(ea).color = source_color


def mark_reaching_nodes(ea, source_color=COLOR_SOURCE, other_color=COLOR_REACHING):
    graph = get_nx_graph(ea)
    graph = graph.reverse()
    block_ea = get_block_start(ea)
    for descendant in nx.descendants(graph, block_ea):
        CodeBlock(descendant).color = other_color

    CodeBlock(ea).color = source_color


def mark_unreachable_nodes(ea, source_color=COLOR_SOURCE, other_color=COLOR_UNREACHABLE):
    graph = get_nx_graph(ea)
    block_ea = get_block_start(ea)
    descendants = nx.descendants(graph, block_ea)
    for block in FlowChart(ea):
        if block.start_ea not in descendants:
            block.color = other_color

    CodeBlock(ea).color = source_color


def mark_reachable_nodes(ea, source_color=COLOR_SOURCE, other_color=COLOR_REACHABLE):
    graph = get_nx_graph(ea)
    block_ea = get_block_start(ea)
    for descendant in nx.descendants(graph, block_ea):
        CodeBlock(descendant).color = other_color

    CodeBlock(ea).color = source_color


def mark_exit_nodes(ea, node_color=COLOR_EXIT):
    for block in iter_exit_nodes(ea):
        block.color = node_color


class MarkReachableNodesHandler(ActionHandler):
    TEXT = "Reachable"

    def _activate(self, ctx):
        clear_func(ctx.cur_ea)
        mark_reachable_nodes(ctx.cur_ea)


class MarkUnReachableNodesHandler(ActionHandler):
    TEXT = "Unreachable"

    def _activate(self, ctx):
        clear_func(ctx.cur_ea)
        mark_unreachable_nodes(ctx.cur_ea)


class MarkReachingNodesHandler(ActionHandler):
    TEXT = "Reaching"

    def _activate(self, ctx):
        clear_func(ctx.cur_ea)
        mark_reaching_nodes(ctx.cur_ea)


class MarkNotReachingNodesHandler(ActionHandler):
    TEXT = "Not Reaching"

    def _activate(self, ctx):
        clear_func(ctx.cur_ea)
        mark_not_reaching_nodes(ctx.cur_ea)


class MarkClearHandler(ActionHandler):
    TEXT = "Clear"

    def _activate(self, ctx):
        clear_func(ctx.cur_ea)


class MarkExits(ActionHandler):
    TEXT = "Exits"

    def _activate(self, ctx):
        clear_func(ctx.cur_ea)
        mark_exit_nodes(ctx.cur_ea)

        idaapi.msg("\n" * 2)

        for block in iter_exit_nodes(ctx.cur_ea):
            idaapi.msg("Exit at 0x{:08X}\n".format(block.start_ea))


class Hooks(idaapi.UI_Hooks):
    def populating_widget_popup(self, form, popup):
        # You can attach here.
        pass

    def finish_populating_widget_popup(self, form, popup):
        # Or here, after the popup is done being populated by its owner.

        if idaapi.get_widget_type(form) == idaapi.BWN_DISASM:
            idaapi.attach_action_to_popup(form, popup, MarkReachableNodesHandler.get_name(), "Mark/")
            idaapi.attach_action_to_popup(form, popup, MarkUnReachableNodesHandler.get_name(), "Mark/")
            idaapi.attach_action_to_popup(form, popup, MarkReachingNodesHandler.get_name(), "Mark/")
            idaapi.attach_action_to_popup(form, popup, MarkNotReachingNodesHandler.get_name(), "Mark/")
            idaapi.attach_action_to_popup(form, popup, MarkExits.get_name(), "Mark/")
            idaapi.attach_action_to_popup(form, popup, MarkClearHandler.get_name(), "Mark/")


class FunctionFlow(idaapi.plugin_t):
    flags = idaapi.PLUGIN_PROC
    comment = "Show Flow in Functions"
    help = "Show code flow inside functions"
    wanted_name = "Function Flow"
    wanted_hotkey = ""

    def init(self):
        MarkReachableNodesHandler.register()
        MarkUnReachableNodesHandler.register()
        MarkReachingNodesHandler.register()
        MarkNotReachingNodesHandler.register()
        MarkExits.register()
        MarkClearHandler.register()

        self.hooks = Hooks()
        self.hooks.hook()
        return idaapi.PLUGIN_KEEP

    def term(self):
        MarkReachableNodesHandler.unregister()
        MarkUnReachableNodesHandler.unregister()
        MarkReachingNodesHandler.unregister()
        MarkNotReachingNodesHandler.unregister()
        MarkExits.unregister()
        MarkClearHandler.unregister()

    def run(self, arg):
        pass


def PLUGIN_ENTRY():
    return FunctionFlow()















```

`plugins/function_strings.py`:

```py
from contextlib import suppress
import idaapi
import idc
import sark


def show_function_strings(function):
    idaapi.msg("\n\nString References in {}:0x{:08X}\n".format(function.name, function.start_ea))
    idaapi.msg("From          To            String\n")

    for xref in function.xrefs_from:
        with suppress(sark.exceptions.SarkNoString):
            string = sark.get_string(xref.to)
            # Trim the string for easier display
            string = string[:100]

            idaapi.msg("0x{:08X}    0x{:08X}    {}\n".format(xref.frm, xref.to, repr(string)))


def show_current_function_strings():
    try:
        function = sark.Function(idc.here())
        show_function_strings(function)

    except sark.exceptions.SarkNoFunction:
        idaapi.msg("[FunctionStrings] No function at 0x{:08X}.\n".format(idc.here()))


def show_highlighted_function_strings():
    identifier = sark.get_highlighted_identifier()
    if not identifier:
        return

    try:
        function = sark.Function(name=identifier)
        show_function_strings(function)

    except sark.exceptions.SarkNoFunction:
        idaapi.msg("[FunctionStrings] {!r} is not a function.\n".format(identifier))


class FunctionStrings(idaapi.plugin_t):
    flags = 0
    comment = "Show Function Strings"
    help = "Show all strings references by the function."
    wanted_name = "FunctionStrings"
    wanted_hotkey = ""

    def init(self):
        self.hotkeys = []
        self.hotkeys.append(idaapi.add_hotkey("Alt+9", show_current_function_strings))
        self.hotkeys.append(idaapi.add_hotkey("Ctrl+Alt+9", show_highlighted_function_strings))
        return idaapi.PLUGIN_KEEP

    def term(self):
        for hotkey in self.hotkeys:
            idaapi.del_hotkey(hotkey)

    def run(self, arg):
        pass


def PLUGIN_ENTRY():
    return FunctionStrings()

```

`plugins/highlight_calls.py`:

```py
from contextlib import suppress
import idaapi
import sark
from ida_settings import IDASettings

HIGHLIGHT_COLOR = 0x303060


def highlight_calls_in_function(ea):
    highlighted_lines = set()
    for line in sark.Function(ea).lines:
        if not line.insn.is_call:
            continue

        # Refrain from painting over someone else...
        if line.color is None:
            line.color = HIGHLIGHT_COLOR
            highlighted_lines.add(line.ea)
    return highlighted_lines


class UiHooks(idaapi.UI_Hooks):
    def __init__(self, lines):
        super(UiHooks, self).__init__()
        self.lines = lines

    def updating_actions(self, ctx):
        if ctx.form_type == idaapi.BWN_DISASM:
            with suppress(sark.exceptions.SarkNoFunction):
                self.lines.update(highlight_calls_in_function(ctx.cur_ea))

        return super(UiHooks, self).updating_actions(ctx)


class ToggleHandler(idaapi.action_handler_t):
    def __init__(self, state=False):
        idaapi.action_handler_t.__init__(self)

        self._state = state

    def on_enable(self, ctx):
        raise NotImplementedError()

    def on_disable(self, ctx):
        raise NotImplementedError()

    def activate(self, ctx):
        if self._state:
            self.on_disable(ctx)
        else:
            self.on_enable(ctx)

        self._state = not self._state


class ToggleHighlightHandler(ToggleHandler):
    def __init__(self, enable, disable):
        ToggleHandler.__init__(self)

        self.enable = enable
        self.disable = disable

    def on_enable(self, ctx):
        self.enable()

    def on_disable(self, ctx):
        self.disable()

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class SelectColorHandler(idaapi.action_handler_t):
    def __init__(self, set_color):
        idaapi.action_handler_t.__init__(self)
        self._set_color = set_color

    def activate(self, ctx):
        color = sark.ui.ask_color(initial=HIGHLIGHT_COLOR)
        if color is not None:
            self._set_color(color)

        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS


class HighlightCalls(idaapi.plugin_t):
    flags = idaapi.PLUGIN_PROC
    comment = 'Highlight Call Instructions'
    help = 'Highlight all call instructions'
    wanted_name = 'Highlight Calls'
    wanted_hotkey = ''

    def init(self):
        self.lines = set()
        self.settings = IDASettings('HighlightCalls')
        try:
            self.set_color(self.settings['color'])
        except KeyError:
            self.settings.user['color'] = HIGHLIGHT_COLOR
            self.set_color(HIGHLIGHT_COLOR)
        self.ui_hooks = UiHooks(self.lines)

        self.toggle_action_desc = idaapi.action_desc_t('HighlightCalls:Toggle',
                                                       'Toggle call highlighting',
                                                       ToggleHighlightHandler(self.enable_highlights,
                                                                              self.disable_highlights),
                                                       '',
                                                       'Toggle call highlighting',
                                                       -1)
        idaapi.register_action(self.toggle_action_desc)

        self.color_selector = idaapi.action_desc_t('HighlightCalls:SelectColor',
                                                   'Select highlight color',
                                                   SelectColorHandler(set_color=self.set_color),
                                                   '',
                                                   'Select highlight color',
                                                   -1)
        idaapi.register_action(self.color_selector)

        idaapi.attach_action_to_menu('View/', self.toggle_action_desc.name, idaapi.SETMENU_APP)
        idaapi.attach_action_to_menu('View/', self.color_selector.name, idaapi.SETMENU_APP)

        return idaapi.PLUGIN_KEEP

    def set_color(self, color):
        self.color = color
        self.settings.user['color'] = color
        global HIGHLIGHT_COLOR
        HIGHLIGHT_COLOR = color
        self.clear_all_highlights()

    def enable_highlights(self):
        self.ui_hooks.hook()

    def term(self):
        self.disable_highlights()
        idaapi.unregister_action(self.toggle_action_desc.name)
        idaapi.unregister_action(self.color_selector.name)

    def disable_highlights(self):
        self.ui_hooks.unhook()
        self.clear_all_highlights()

    def clear_all_highlights(self):
        for ea in self.lines:
            sark.Line(ea=ea).color = None
        self.lines.clear()

    def run(self, arg):
        pass


def PLUGIN_ENTRY():
    return HighlightCalls()

```

`plugins/lca.py`:

```py
from contextlib import suppress
import sark
import sark.graph
import networkx as nx
import sark.ui
import idc
import idaapi

COLOR_SOURCE = 0x364b00
COLOR_TARGET = 0x601116
COLOR_DISABLED = 0x000673
COLOR_PATH = 0x004773
COLOR_SOURCE_TARGET = 0x634107

PADDING = 1
PAD_WIDTH = 3


def pad(text, padding=PADDING):
    top_bottom = ("\n" * padding) + " "
    right_left = " " * padding * PAD_WIDTH
    return top_bottom + right_left + text + right_left + top_bottom


def remove_target_handler(lca_viewer):
    class RemoveTargetHandler(sark.ui.ActionHandler):
        TEXT = "Remove Target"

        def _activate(self, ctx):
            node_id = lca_viewer.current_node_id
            lca_viewer.remove_target(lca_viewer[node_id])
            lca_viewer.rebuild_graph()
            lca_viewer.Refresh()
            idaapi.msg("[LCA] Target Removed: {}\n".format(idaapi.get_ea_name(lca_viewer[node_id], idaapi.GN_VISIBLE)))

    return RemoveTargetHandler


def disable_source_handler(lca_viewer):
    class DisableSourceHandler(sark.ui.ActionHandler):
        TEXT = "Disable Source"

        def _activate(self, ctx):
            node_id = lca_viewer.current_node_id
            lca_viewer.disable_source(lca_viewer[node_id])
            lca_viewer.rebuild_graph()
            lca_viewer.Refresh()

    return DisableSourceHandler


def enable_source_handler(lca_viewer):
    class EnableSourceHandler(sark.ui.ActionHandler):
        TEXT = "Enable Source"

        def _activate(self, ctx):
            node_id = lca_viewer.current_node_id
            lca_viewer.enable_source(lca_viewer[node_id])
            lca_viewer.rebuild_graph()
            lca_viewer.Refresh()

    return EnableSourceHandler


def add_address_handler(lca_viewer):
    class AddAddressHandler(sark.ui.ActionHandler):
        TEXT = "Add Target Function"
        HOTKEY = "Shift+Space"

        def _activate(self, ctx):
            ea = idaapi.ask_long(0, "Add LCA Target")
            if ea is None:
                return

            lca_viewer.add_target(ea)
            lca_viewer.rebuild_graph()
            lca_viewer.Refresh()

    return AddAddressHandler


def add_function_handler(lca_viewer):
    class AddFunctionHandler(sark.ui.ActionHandler):
        TEXT = "Add Target Function"
        HOTKEY = "Space"

        def _activate(self, ctx):
            func = idaapi.choose_func("Add LCA Target", 0)
            if not func:
                return

            lca_viewer.add_target(func.start_ea)
            lca_viewer.rebuild_graph()
            lca_viewer.Refresh()
            lca_viewer.Show()

    return AddFunctionHandler


class LCAGraph(idaapi.GraphViewer):
    def __init__(self, title):
        self._title = title
        idaapi.GraphViewer.__init__(self, self._title)

        self._targets = set()
        self._sources = set()

        # This might take a while...
        self._idb_graph = sark.graph.get_idb_graph()

        self._lca_graph = nx.DiGraph()

        self._handlers = [add_function_handler(self),
                          add_address_handler(self)]

        self._current_node_id = 0

        self._disabled_sources = set()

        self._remove_target_handler = remove_target_handler(self)
        self._enable_source_handler = enable_source_handler(self)
        self._disable_source_handler = disable_source_handler(self)

        self._node_ids = {}

    @property
    def current_node_id(self):
        return self._current_node_id

    def OnGetText(self, node_id):
        return pad(idaapi.get_ea_name(self[node_id], idaapi.GN_VISIBLE))

    def _register_handlers(self):
        for handler in self._handlers:
            handler.register()

    def Show(self):
        if not idaapi.GraphViewer.Show(self):
            return False

        self._register_handlers()
        self.color_nodes()
        return True

    def disable_source(self, source):
        self._disabled_sources.add(source)

    def enable_source(self, source):
        self._disabled_sources.remove(source)

    def add_target(self, target):
        if target not in self._idb_graph.node:
            idaapi.msg(
                "[LCA] Target {} not in IDB graph. Cannot add.\n".format(idaapi.get_ea_name(target, idaapi.GN_VISIBLE)))
            raise KeyError("Target {} not in IDB graph.".format(idaapi.get_ea_name(target, idaapi.GN_VISIBLE)))

        self._targets.add(target)

    def remove_target(self, target):
        self._targets.remove(target)

    def add_targets(self, targets):
        for target in targets:
            self.add_target(target)

    def rebuild_graph(self):
        self._sources = sark.graph.lowest_common_ancestors(self._idb_graph, self._targets)

        # Remove disabled sources from the connected graph.
        active_sources = self._sources - self._disabled_sources
        if active_sources:
            self._lca_graph = sark.graph.get_lca_graph(self._idb_graph, self._targets, active_sources)
        else:
            self._lca_graph = nx.DiGraph()
            self._lca_graph.add_nodes_from(self._targets)

        # Make sure the disabled sources are still shown.
        self._lca_graph.add_nodes_from(self._disabled_sources)

    def _set_node_bg_color(self, node_id, bg_color):
        node_info = idaapi.node_info_t()
        node_info.bg_color = bg_color
        self.SetNodeInfo(node_id, node_info, idaapi.NIF_BG_COLOR)

    def color_nodes(self):
        self.clear_nodes()
        for node_id, node_ea in enumerate(self):
            if node_ea in self._targets and node_ea in self._sources:
                self._set_node_bg_color(node_id, COLOR_SOURCE_TARGET)

            elif node_ea in self._disabled_sources:
                self._set_node_bg_color(node_id, COLOR_DISABLED)

            elif node_ea in self._targets:
                self._set_node_bg_color(node_id, COLOR_TARGET)

            elif node_ea in self._sources:
                self._set_node_bg_color(node_id, COLOR_SOURCE)

    def clear_nodes(self):
        for node_id in range(self.Count()):
            self._set_node_bg_color(node_id, 0xFFFFFFFF)

    def OnRefresh(self):
        self.Clear()

        if self._targets and self._lca_graph is None:
            # This might take a while...
            self.rebuild_graph()

        try:
            lca_graph_nodes_iter = self._lca_graph.nodes()
            lca_graph_edges_iter = self._lca_graph.edges()
        except AttributeError:
            lca_graph_nodes_iter = self._lca_graph.nodes_iter()
            lca_graph_edges_iter = self._lca_graph.edges_iter()

        node_ids = {node: self.AddNode(node) for node in lca_graph_nodes_iter}

        self._node_ids = node_ids

        for frm, to in lca_graph_edges_iter:
            self.AddEdge(node_ids[frm], node_ids[to])

        self.color_nodes()

        return True

    def OnActivate(self):
        # Refresh on every activation to make sure the names are up to date.
        self.Refresh()
        self._register_handlers()
        self.color_nodes()
        return True

    def _unregister_handlers(self):
        for handler in self._handlers:
            handler.unregister()

    def OnDeactivate(self):
        self._unregister_handlers()

    def OnDblClick(self, node_id):
        # On double-click, jump to the clicked address.
        idaapi.jumpto(self[node_id])

        return True

    def _attach_to_popup(self, action_name):
        idaapi.attach_action_to_popup(self.GetTCustomControl(), None, action_name)

    def OnClick(self, node_id):
        self.color_nodes()
        self._current_node_id = node_id
        node_ea = self[node_id]

        self._remove_target_handler.unregister()
        self._disable_source_handler.unregister()
        self._enable_source_handler.unregister()

        if node_ea in self._targets:
            self._remove_target_handler.register()
            self._attach_to_popup(self._remove_target_handler.get_name())

            for ea in nx.ancestors(self._lca_graph, node_ea):
                if ea not in self._targets and ea not in self._sources:
                    self._set_node_bg_color(self._node_ids[ea], COLOR_PATH)

        if node_ea in self._sources:
            if node_ea in self._disabled_sources:
                self._enable_source_handler.register()
                self._attach_to_popup(self._enable_source_handler.get_name())
            else:
                self._disable_source_handler.register()
                self._attach_to_popup(self._disable_source_handler.get_name())

                for ea in nx.descendants(self._lca_graph, node_ea):
                    if ea not in self._targets and ea not in self._sources:
                        self._set_node_bg_color(self._node_ids[ea], COLOR_PATH)

        return False


def lca_viewer_starter(lca_plugin):
    class LCAViewerStarter(sark.ui.ActionHandler):
        TEXT = "LCA Graph"
        TOOLTIP = "Show an interactive lowest-common-ancestors graph."

        def _activate(self, ctx):
            lca_plugin.show_graph()

    return LCAViewerStarter


def idaview_add_target_handler(lca_plugin):
    class IDAViewAddTargetHandler(sark.ui.ActionHandler):
        TEXT = "Add LCA Target"

        def _activate(self, ctx):
            if lca_plugin._lca_viewer:
                with suppress(KeyError):
                    lca_plugin._lca_viewer.add_target(ctx.cur_ea)
                    lca_plugin._lca_viewer.rebuild_graph()
                    idaapi.msg("[LCA] Target Added: {}\n".format(idaapi.get_ea_name(ctx.cur_ea, idaapi.GN_VISIBLE)))

    return IDAViewAddTargetHandler


def idaview_hooks(idaview_handler):
    class Hooks(idaapi.UI_Hooks):
        def finish_populating_widget_popup(self, form, popup):
            if idaapi.get_widget_type(form) == idaapi.BWN_DISASM:
                idaapi.attach_action_to_popup(form, popup, idaview_handler.get_name(), "")

    return Hooks


class LCA(idaapi.plugin_t):
    flags = idaapi.PLUGIN_PROC
    comment = "Lowest Common Ancestors"
    help = "Lowest Common Ancestors"
    wanted_name = "Lowest Common Ancestors"
    wanted_hotkey = ""

    def init(self):
        self._lca_viewer = None

        self._lca_starter = lca_viewer_starter(self)
        self._lca_starter.register()
        idaapi.attach_action_to_menu("View/Graph Overview", self._lca_starter.get_name(), idaapi.SETMENU_APP)

        self._idaview_handler = idaview_add_target_handler(self)
        self._idaview_handler.register()
        self._hooks = idaview_hooks(self._idaview_handler)()
        self._hooks.hook()

        return idaapi.PLUGIN_KEEP

    def term(self):
        self._lca_starter.unregister()
        self._idaview_handler.unregister()
        self._hooks.unhook()

    def show_graph(self):
        if self._lca_viewer is None:
            self._lca_viewer = LCAGraph("LCA Graph")
        self._lca_viewer.Show()

    def run(self, arg):
        self.show_graph()


def PLUGIN_ENTRY():
    return LCA()

```

`plugins/meaningful.py`:

```py
import idaapi
import idc

import sark
from sark.data import get_string
from sark import exceptions
import sark.ui


class NoName(Exception):
    pass


def get_name(ea):
    name = None

    if not sark.Line(ea).has_name:
        raise NoName("No non-trivial name for 0x{:08X}".format(ea))

    try:
        function = sark.Function(ea)
        if function.ea == ea:
            name = function.demangled
    except:
        pass

    if not name:
        name = idc.Name(ea)

    if not name:
        raise NoName("No named for address 0x{:08X}".format(ea))

    return name


def show_meaningful_in_function(function):
    idaapi.msg("\n\nMeaningful References in {!r} : 0x{:08X}\n".format(function.demangled, function.start_ea))
    idaapi.msg("Type    Usage         Address       Object\n")
    idaapi.msg("------------------------------------------\n")

    for xref in function.xrefs_from:
        if xref.type.is_code:
            try:
                name = get_name(xref.to)
            except NoName:
                continue

            idaapi.msg("code    0x{:08X}    0x{:08X}    {}\n".format(xref.frm, xref.to, name))

        else:
            try:
                string = get_string(xref.to)
            except exceptions.SarkNoString:
                continue

            # Trim the string for easier display
            string = string[:100]

            idaapi.msg("data    0x{:08X}    {}    {}\n".format(xref.frm, sark.core.get_name_or_address(xref.to), repr(string)))

    idaapi.msg("\n\n")


def show_current_function_meaningful():
    try:
        function = sark.Function(idc.here())
        show_meaningful_in_function(function)

    except sark.exceptions.SarkNoFunction:
        idaapi.msg("[FunctionStrings] No function at 0x{:08X}.\n".format(idc.here()))


def show_highlighted_function_meaningful():
    line = sark.Line()
    meaningful_displayed = False
    for xref in line.xrefs_from:
        try:
            if xref.type.is_flow:
                continue

            function = sark.Function(xref.to)
            show_meaningful_in_function(function)
            meaningful_displayed = True

        except sark.exceptions.SarkNoFunction:
            pass

    if not meaningful_displayed:
        idaapi.msg("[FunctionStrings] No function referenced by current line: 0x{:08X}.\n".format(idc.here()))


class Meaningful(idaapi.plugin_t):
    flags = 0
    comment = "Show meaningful information"
    help = "Show strings and named xrefs"
    wanted_name = "Meaningful"
    wanted_hotkey = ""

    def init(self):
        self.hotkeys = []
        self.hotkeys.append(idaapi.add_hotkey("Alt+0", show_current_function_meaningful))
        self.hotkeys.append(idaapi.add_hotkey("Ctrl+Alt+0", show_highlighted_function_meaningful))
        return idaapi.PLUGIN_KEEP

    def term(self):
        pass

    def run(self, arg):
        pass


def PLUGIN_ENTRY():
    return Meaningful()

```

`plugins/plugin_loader.py`:

```py
import os
import itertools
import idaapi
import idc

PLUGINS_LIST = "plugins.list"

USER_PLUGIN_LIST_PATH = os.path.join(idaapi.get_user_idadir(), PLUGINS_LIST)
SYS_PLUGIN_LIST_PATH = os.path.join(idaapi.idadir(idaapi.CFG_SUBDIR), PLUGINS_LIST)
if idc.get_idb_path():
    PROJECT_PLUGIN_LIST_PATH = os.path.join(os.path.dirname(idc.get_idb_path()), PLUGINS_LIST)
else:
    PROJECT_PLUGIN_LIST_PATH = None


def message(*messages):
    for msg in messages:
        for line in msg.splitlines():
            idaapi.msg("[PluginLoader] {}\n".format(line))


def iter_without_duplicates(*iterables):
    visited = set()
    chained_iterables = itertools.chain(*iterables)
    for item in chained_iterables:
        if item in visited:
            continue
        yield item
        visited.add(item)


def iter_paths(filepath):
    if not filepath:
        return
    try:
        with open(filepath) as f:
            for line in f:
                # Use `#` for comments
                if line.startswith("#"):
                    continue
                # Remove trailing spaces and newlines, then normalize to avoid duplicates.
                path = os.path.normpath(line.strip())
                if path:
                    yield path
    except IOError:
        pass


def iter_plugin_paths():
    return iter_without_duplicates(iter_paths(SYS_PLUGIN_LIST_PATH),
                                   iter_paths(USER_PLUGIN_LIST_PATH),
                                   iter_paths(PROJECT_PLUGIN_LIST_PATH))


class PluginLoader(idaapi.plugin_t):
    flags = idaapi.PLUGIN_FIX
    comment = "Plugin Loader"
    help = "Plugin Loader"
    wanted_name = "PluginLoader"
    wanted_hotkey = ""

    def init(self):
        # Show usage message.
        usage_message = ["Loading plugins from system-wide and user-specific lists:",
                         "  System-wide List:      {}".format(SYS_PLUGIN_LIST_PATH),
                         "  User-specific List:    {}".format(USER_PLUGIN_LIST_PATH)]
        if PROJECT_PLUGIN_LIST_PATH:
            usage_message.append("  Project-specific List: {}".format(PROJECT_PLUGIN_LIST_PATH))

        message(*usage_message)

        # Make sure the files exist. If not - create them.
        if not os.path.isfile(SYS_PLUGIN_LIST_PATH):
            try:
                with open(SYS_PLUGIN_LIST_PATH, "wb"):
                    message("Created system plugin list at {}".format(SYS_PLUGIN_LIST_PATH))
            except IOError:
                message("Failed creating system plugin list at {}".format(SYS_PLUGIN_LIST_PATH))

        if not os.path.isfile(USER_PLUGIN_LIST_PATH):
            try:
                with open(USER_PLUGIN_LIST_PATH, "wb"):
                    message("Created user plugin list at {}".format(USER_PLUGIN_LIST_PATH))
            except IOError:
                message("Failed creating user plugin list at {}".format(USER_PLUGIN_LIST_PATH))

        for path in iter_plugin_paths():
            # This check is not needed, but saves us from the dreaded error message-box
            # that pops when a python plugin is not found.
            if not os.path.isfile(path):
                message("Plugin file not found: {}".format(path))
                continue
            idaapi.load_plugin(path)
        return idaapi.PLUGIN_SKIP

    def term(self):
        pass

    def run(self, arg):
        pass


def PLUGIN_ENTRY():
    return PluginLoader()

```

`plugins/ptvsd_enable.py`:

```py
import idaapi
import ptvsd

try:
    # Enable the debugger. Raises exception if called more than once.
    ptvsd.enable_attach(secret="IDA")
except:
    pass


class DebugPlugin(idaapi.plugin_t):
    flags = idaapi.PLUGIN_FIX
    comment = "PTVSD Debug Enable"
    help = "Enable debugging using PTVSD"
    wanted_name = "PTVSD"
    wanted_hotkey = ""

    def init(self):
        return idaapi.PLUGIN_KEEP

    def term(self):
        pass

    def run(self, arg):
        pass


def PLUGIN_ENTRY():
    return DebugPlugin()
```

`plugins/quick_copy.py`:

```py
import idaapi
import clipboard
import sark
import binascii


def to_hex_bytes(raw_bytes: bytes) -> str:
    hex_string = binascii.b2a_hex(raw_bytes).decode('utf-8')
    hex_bytes = ' '.join(hex_string[i:i + 2] for i in range(0, len(hex_string), 2))
    return hex_bytes


def message(*messages):
    for msg in messages:
        for line in msg.splitlines():
            idaapi.msg("[QuickCopy] {}\n".format(line))


def copy_current_address():
    start, end = sark.get_selection()
    clipboard.copy("0x{:08X}".format(start))


def copy_current_file_offset():
    """Get the file-offset mapped to the current address."""
    start, end = sark.get_selection()

    try:
        file_offset = sark.core.get_fileregion_offset(start)
        clipboard.copy("0x{:08X}".format(file_offset))

    except sark.exceptions.NoFileOffset:
        message("The current address cannot be mapped to a valid offset of the input file.")


def copy_current_selection():
    start, end = sark.get_selection()
    buffer = sark.data.read_memory(start, end)
    clipboard.copy(to_hex_bytes(buffer))


class QuickCopy(idaapi.plugin_t):
    flags = 0
    comment = "Quickly copy addresses and instructions"
    help = "Quickly copy addresses and instructions"
    wanted_name = "Quick Copy"
    wanted_hotkey = ""

    def init(self):
        self.hotkeys = []
        self.hotkeys.append(idaapi.add_hotkey("Ctrl+Alt+C", copy_current_address))
        self.hotkeys.append(idaapi.add_hotkey("Ctrl+Alt+O", copy_current_file_offset))
        self.hotkeys.append(idaapi.add_hotkey("Ctrl+Shift+C", copy_current_selection))
        return idaapi.PLUGIN_KEEP

    def term(self):
        for hotkey in self.hotkeys:
            idaapi.del_hotkey(hotkey)

    def run(self, arg):
        pass


def PLUGIN_ENTRY():
    return QuickCopy()

```

`plugins/requirements.txt`:

```txt
git+https://github.com/tmr232/Sark.git#egg=Sark
clipboard
ida-settings
```

`plugins/xrefsgraph.py`:

```py
from itertools import repeat
from contextlib import suppress
import sark
import idaapi
import networkx as nx
from collections import deque
from sark import exceptions

MENU_PATH_GRAPHS = 'View/Graphs/'


def _try_get_function_start(ea):
    with suppress(exceptions.SarkNoFunction):
        return sark.Function(ea).start_ea

    return ea


def _get_best_name(ea):
    try:
        return sark.Function(ea).demangled
    except exceptions.SarkNoFunction:
        name = idaapi.get_ea_name(ea)
        if name:
            return name
        return '0x{:X}'.format(ea)


def _xrefs_to(function_ea):
    try:
        return sark.Function(function_ea).xrefs_to

    except exceptions.SarkNoFunction:
        return sark.Line(function_ea).xrefs_to


def _xrefs_from(function_ea):
    try:
        return sark.Function(function_ea).xrefs_from

    except exceptions.SarkNoFunction:
        return sark.Line(function_ea).xrefs_from


def gen_xref_graph(ea, to=False, distance=4):
    xref_graph = nx.DiGraph()

    ea_queue = deque()
    distance_queue = deque()

    ea_queue.append(ea)
    distance_queue.append(distance)

    if to:
        get_xrefs = _xrefs_to
    else:
        get_xrefs = _xrefs_from

    while ea_queue:
        ea = ea_queue.pop()
        distance_to_go = distance_queue.pop()

        if distance_to_go == 0:
            # Distance is exhausted for this path.
            continue

        new = set()
        for xref in get_xrefs(ea):
            frm = _try_get_function_start(xref.frm)
            to_ = _try_get_function_start(xref.to)

            xref_graph.add_edge(frm, to_)

            if to:
                new.add(frm)
            else:
                new.add(to_)

        ea_queue.extend(new)
        distance_queue.extend(repeat(distance_to_go - 1, len(new)))

    return xref_graph


def show_xref_graph(ea, to=False, distance=4):
    ea = _try_get_function_start(ea)

    call_graph = gen_xref_graph(ea, to=to, distance=distance)

    call_graph.nodes[ea][sark.ui.NXGraph.BG_COLOR] = 0x80

    title = 'Xrefs {tofrom} {target} '.format(tofrom='to' if to else 'from',
                                              target=_get_best_name(ea))

    # Create an NXGraph viewer
    viewer = sark.ui.NXGraph(call_graph, handler=sark.ui.AddressNodeHandler(), title=title)

    # Show the graph
    viewer.Show()


class ShowXrefsGraphTo(sark.ui.ActionHandler):
    TEXT = "Show xref graph to..."

    def _activate(self, ctx):
        distance = idaapi.ask_long(4, 'Distance To Source')
        show_xref_graph(ctx.cur_ea, to=True, distance=distance)


class ShowXrefsGraphFrom(sark.ui.ActionHandler):
    TEXT = "Show xref graph from..."

    def _activate(self, ctx):
        distance = idaapi.ask_long(4, 'Distance From Source')
        show_xref_graph(ctx.cur_ea, to=False, distance=distance)


class Hooks(idaapi.UI_Hooks):
    def finish_populating_widget_popup(self, form, popup):
        # Or here, after the popup is done being populated by its owner.

        if idaapi.get_widget_type(form) == idaapi.BWN_DISASM:
            idaapi.attach_action_to_popup(form, popup, ShowXrefsGraphFrom.get_name(), '')
            idaapi.attach_action_to_popup(form, popup, ShowXrefsGraphTo.get_name(), '')


class XrefsGraphPlugins(idaapi.plugin_t):
    flags = 0
    comment = 'Show xref graphs'
    help = 'Shows xref graphs.'
    wanted_name = 'Xref Graphs'
    wanted_hotkey = ""

    def init(self):
        ShowXrefsGraphTo.register()
        ShowXrefsGraphFrom.register()
        idaapi.attach_action_to_menu(MENU_PATH_GRAPHS, ShowXrefsGraphTo.get_name(), 0)
        idaapi.attach_action_to_menu(MENU_PATH_GRAPHS, ShowXrefsGraphFrom.get_name(), 0)

        self.hooks = Hooks()
        self.hooks.hook()

        return idaapi.PLUGIN_KEEP

    def term(self):
        self.hooks.unhook()
        idaapi.detach_action_from_menu(MENU_PATH_GRAPHS, ShowXrefsGraphTo.get_name())
        idaapi.detach_action_from_menu(MENU_PATH_GRAPHS, ShowXrefsGraphFrom.get_name())
        ShowXrefsGraphTo.unregister()
        ShowXrefsGraphFrom.unregister()

    def run(self, arg):
        pass


def PLUGIN_ENTRY():
    return XrefsGraphPlugins()

```

`pyproject.toml`:

```toml
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "sark"
description = "IDA Scripting Library"
readme = "README.rst"
license = "MIT"
version = "9.0.0"
authors = [{ name = "Tamir Bahar", email = "" }]
dependencies = ["networkx >= 2.0.0", "wrapt"]

[project.optional-dependencies]
dev = ["keystone-engine == 0.9.2", "approvaltests >= 10.1.0"]

[project.urls]
Homepage = "https://github.com/tmr232/Sark"

[tool.hatch.build.targets.sdist]
include = ["/sark"]

```

`sark/__init__.py`:

```py
def is_in_ida():
    try:
        import idaapi

        return True
    except ImportError:
        return False


# Since some of our code can be used outside of IDA, namely the `plumbing` module
# when used in the codecs proxy, we want to allow importing specific modules outside
# IDA.
if is_in_ida():
    from . import (core,
                   code,
                   exceptions,
                   structure,
                   codeblock,
                   data,
                   debug,
                   enum,
                   ui,
                   graph)

    import idaapi
    idaapi.require('sark.code')
    idaapi.require('sark.core')
    idaapi.require('sark.exceptions')
    idaapi.require('sark.graph')
    idaapi.require('sark.structure')
    idaapi.require('sark.codeblock')
    idaapi.require('sark.data')
    idaapi.require('sark.debug')
    idaapi.require('sark.enum')
    idaapi.require('sark.ui')

    from .code import *
    from .codeblock import CodeBlock, get_nx_graph, get_block_start, FlowChart, codeblocks
    from .data import read_ascii_string, get_string
    from .core import set_name, is_function
    from .enum import Enum, enums, add_enum, remove_enum

```

`sark/code/__init__.py`:

```py
import importlib
from . import base

importlib.reload(base)

from . import xref

importlib.reload(xref)

from . import line

importlib.reload(line)

from . import function

importlib.reload(function)

from . import switch

importlib.reload(switch)

from . import instruction

importlib.reload(instruction)

from . import segment

importlib.reload(segment)

from .base import *
from .line import Line, lines
from .function import Function, functions
from .switch import Switch, is_switch
from .segment import Segment, segments
```

`sark/code/base.py`:

```py
import collections
import string

import idaapi
import idc
import idautils

from ..core import get_func, get_native_size
from .. import exceptions

NAME_VALID_CHARS = string.ascii_letters + string.digits + "?_:"

DTYPE_TO_SIZE = {
    idaapi.dt_byte: 1,
    idaapi.dt_word: 2,
    idaapi.dt_dword: 4,
    idaapi.dt_float: 4,
    idaapi.dt_double: 8,
    idaapi.dt_qword: 8,
    idaapi.dt_byte16: 16,
    idaapi.dt_fword: 6,
    idaapi.dt_byte32: 32,
    idaapi.dt_byte64: 64,
}


def dtype_to_size(dtyp):
    if dtyp == idaapi.dt_tbyte:
        # This can't be put in the dict as it depends on the current processor
        # and may change during runtime.
        return idaapi.ph_get_tbyte_size()

    return DTYPE_TO_SIZE[dtyp]


def is_ea_call(ea):
    inst = idautils.DecodeInstruction(ea)
    feature = inst.get_canon_feature()
    return feature & idaapi.CF_CALL


def get_register_info(reg_name):
    ri = idaapi.reg_info_t()
    if idaapi.IDA_SDK_VERSION >= 750:
        success = idaapi.parse_reg_name(ri, reg_name)
    else:
        success = idaapi.parse_reg_name(reg_name, ri)
    if not success:
        raise exceptions.SarkInvalidRegisterName("No register named {!r}".format(reg_name))
    return ri


def get_register_id(reg_name):
    return get_register_info(reg_name).reg


def get_register_size(reg_name):
    return get_register_info(reg_name).size


def get_register_name(reg_id, size=None):
    if size is None:
        size = get_native_size()
    return idaapi.get_reg_name(reg_id, size)


def operand_has_displacement(operand):
    if operand.type in (idaapi.o_phrase, idaapi.o_displ):
        return True

    return False


def operand_get_displacement(operand):
    return operand.addr


def is_same_function(ea1, ea2):
    try:
        if get_func(ea1).start_ea == get_func(ea2).start_ea:
            return True
    except:
        pass

    return False


Selection = collections.namedtuple("Selection", "start end")


def get_selection(always=True):
    start = idc.read_selection_start()
    end = idc.read_selection_end()

    if idaapi.BADADDR in (start, end):
        if not always:
            raise exceptions.SarkNoSelection()

        ea = idc.here()
        start = idaapi.get_item_head(ea)
        end = idaapi.get_item_end(ea)

    return Selection(start, end)


def get_highlighted_identifier():
    thing = idaapi.get_highlight(idaapi.get_current_viewer())
    if thing and thing[1]:
        return thing[0]

def format_name(name):
    try:
        return "".join(char if char in NAME_VALID_CHARS else "_" for char in name)
    except:
        return ""

def demangle(name, disable_mask=0):
    demangled_name = idaapi.demangle_name(name, disable_mask, idaapi.DQT_FULL)
    if demangled_name:
        return demangled_name
    return name


def get_offset_name(ea):
    # Try and get the function name
    try:
        func = get_func(ea)
        name = idaapi.get_ea_name(func.start_ea)
        name = demangle(name, 0x60) # MNG_NOTYPE | MNG_NORETTYPE
        if name:
            offset = ea - func.start_ea
            if offset:
                return '{}+{:X}'.format(name, offset)
            return name
    except exceptions.SarkNoFunction:
        pass

    # If that failed, use the segment name instead.
    segment = idaapi.getseg(ea)
    name = idaapi.get_segm_name(segment)
    offset_format = '{{:0{}X}}'.format(get_native_size() * 2)
    ea_text = offset_format.format(ea)
    if name:
        return '{}:{}'.format(name, ea_text)

    # Nothing found, simply return the address
    return ea_text

```

`sark/code/function.py`:

```py
from typing import Iterable

import idaapi
import idautils
import idc
from .base import get_func, demangle
from ..core import set_name, get_ea, fix_addresses, is_same_function, add_func
from .line import Line
from .xref import Xref
from ..ui import updates_ui
from .. import exceptions


class Comments(object):
    """IDA Function Comments

    Provides easy access to all types of comments for an IDA Function.
    """

    def __init__(self, function):
        self._function = function

    def __bool__(self):
        return any((self.regular, self.repeat,))

    @property
    def regular(self):
        """Function Comment"""
        return idaapi.get_func_cmt(self._function._func, False)

    @regular.setter
    def regular(self, comment):
        idaapi.set_func_cmt(self._function._func, comment, False)

    @property
    def repeat(self):
        """Repeatable Function Comment"""
        return idaapi.get_func_cmt(self._function._func, True)

    @repeat.setter
    def repeat(self, comment):
        idaapi.set_func_cmt(self._function._func, comment, True)

    def __repr__(self):
        return ("Comments("
                "func={name},"
                " reqular={regular},"
                " repeat={repeat})").format(
            name=self._function.name,
            regular=repr(self.regular),
            repeat=repr(self.repeat))


class FunctionFlagsMixin(object):
    """ Mixin to add convenience checks for the function flags provided by IDA.

    IDA SDK documentation for the flags is found at:
    https://www.hex-rays.com/products/ida/support/sdkdoc/group___f_u_n_c__.html
    """

    flags = None

    @property
    def is_noret(self):
        """ Function doesn't return """
        return bool(self.flags & idaapi.FUNC_NORET)  # 0x00000001

    @property
    def is_far(self):
        """ Is a far function. """
        return bool(self.flags & idaapi.FUNC_FAR)  # 0x00000002

    @property
    def is_library(self):
        """ Is a library function. """
        return bool(self.flags & idaapi.FUNC_LIB)  # 0x00000004

    @property
    def is_static(self):
        """ Is a static function. """
        return bool(self.flags & idaapi.FUNC_STATICDEF)  # 0x00000008

    @property
    def is_frame(self):
        """ Function uses frame pointer (BP) """
        return bool(self.flags & idaapi.FUNC_FRAME)  # 0x00000010

    @property
    def is_user_far(self):
        """ User has specified far-ness of the function. """
        return bool(self.flags & idaapi.FUNC_USERFAR)  # 0x00000020

    @property
    def is_hidden(self):
        """ A hidden function chunk. """
        return bool(self.flags & idaapi.FUNC_HIDDEN)  # 0x00000040

    @property
    def is_thunk(self):
        """ Thunk (jump) function. """
        return bool(self.flags & idaapi.FUNC_THUNK)  # 0x00000080

    @property
    def is_bottom_bp(self):
        """ BP points to the bottom of the stack frame. """
        return bool(self.flags & idaapi.FUNC_BOTTOMBP)  # 0x00000100

    @property
    def is_noret_pending(self):
        """ Function 'non-return' analysis must be performed. """
        return bool(self.flags & idaapi.FUNC_NORET_PENDING)  # 0x00200

    @property
    def is_sp_ready(self):
        """ SP-analysis has been performed. """
        return bool(self.flags & idaapi.FUNC_SP_READY)  # 0x00000400

    @property
    def is_purged_ok(self):
        """ 'argsize' field has been validated. """
        return bool(self.flags & idaapi.FUNC_PURGED_OK)  # 0x00004000

    @property
    def is_tail(self):
        """ This is a function tail. """
        return bool(self.flags & idaapi.FUNC_TAIL)  # 0x00008000


class Function(FunctionFlagsMixin):
    """IDA Function

    Provides easy access to function related APIs in IDA.
    """

    class UseCurrentAddress(object):
        """
        This is a filler object to replace `None` for the EA.
        In many cases, a programmer can accidentally initialize the
        `Function` object with `ea=None`, resulting in the current address.
        Usually, this is not the desired outcome. This object resolves this issue.
        """
        pass

    def __init__(self, ea=UseCurrentAddress, name=None):
        if name is not None and ea != self.UseCurrentAddress:
            raise ValueError(("Either supply a name or an address (ea). "
                              "Not both. (ea={!r}, name={!r})").format(ea, name))

        elif name is not None:
            ea = idc.get_name_ea_simple(name)
            if ea == idc.BADADDR:
                raise exceptions.SarkNoFunction(
                    "The supplied name does not belong to an existing function. "
                    "(name = {!r})".format(name))

        elif ea == self.UseCurrentAddress:
            ea = idc.here()

        elif ea is None:
            raise ValueError("`None` is not a valid address. To use the current screen ea, "
                             "use `Function(ea=Function.UseCurrentAddress)` or supply no `ea`.")

        elif isinstance(ea, Line):
            ea = ea.ea
        self._func = get_func(ea)
        self._comments = Comments(self)

    @staticmethod
    def is_function(ea=UseCurrentAddress):
        try:
            Function(ea)
            return True
        except exceptions.SarkNoFunction:
            return False

    @staticmethod
    def create(ea=UseCurrentAddress):
        if ea == Function.UseCurrentAddress:
            ea = idc.here()

        if Function.is_function(ea):
            raise exceptions.SarkFunctionExists("Function already exists")

        if not add_func(ea):
            raise exceptions.SarkAddFunctionFailed("Failed to add function")

        return Function(ea)

    @property
    def comments(self):
        """Comments"""
        return self._comments

    def __eq__(self, other):
        try:
            return self.start_ea == other.start_ea
        except AttributeError:
            return False

    def __hash__(self):
        return self.start_ea

    @property
    def lines(self) -> Iterable[Line]:
        """Get all function lines."""
        return iter_function_lines(self._func)

    @property
    def start_ea(self) -> int:
        """Start Address"""
        return self._func.start_ea

    # Alias for `start_ea` for increased guessability and less typing.
    ea = start_ea

    @property
    def end_ea(self):
        """End Address

        Note that taking all the lines between `start_ea` and `end_ea` does not guarantee
        that you get all the lines in the function. To get all the lines, use `.lines`.
        """
        return self._func.end_ea

    @property
    def flags(self):
        """The function flags.

        See `idaapi.FUNC_*` constants.
        """
        return self._func.flags

    @property
    def xrefs_from(self):
        """Xrefs from the function.

        This includes the xrefs from every line in the function, as `Xref` objects.
        Xrefs are filtered to exclude code references that are internal to the function. This
        means that every xrefs to the function's code will NOT be returned (yet, references
        to the function's data will be returnd). To get those extra xrefs, you need to iterate
        the function's lines yourself.
        """
        for line in self.lines:
            for xref in line.xrefs_from:
                if xref.type.is_flow:
                    continue

                if xref.to in self and xref.iscode:
                    continue

                yield xref

    @property
    def calls_from(self):
        return (xref for xref in self.xrefs_from if xref.type.is_call)

    @property
    def drefs_from(self):
        """Destination addresses of data xrefs from this function."""
        for line in self.lines:
            for ea in line.drefs_from:
                yield ea

    @property
    def crefs_from(self):
        """Destination addresses of code xrefs from this function."""
        for line in self.lines:
            for ea in line.crefs_from:
                yield ea

    @property
    def xrefs_to(self):
        """Xrefs to the function.

        This only includes references to that function's start address.
        """
        return map(Xref, idautils.XrefsTo(self.start_ea))

    @property
    def drefs_to(self):
        """Source addresses of data xrefs to this function."""
        return idautils.DataRefsTo(self.start_ea)

    @property
    def crefs_to(self):
        """Source addresses of code xrefs to this function."""
        return idautils.CodeRefsTo(self.start_ea, 1)

    @property
    def name(self):
        """Function's Name"""
        return idaapi.get_ea_name(self.start_ea)

    @property
    def demangled(self):
        """Return the demangled name of the function. If none exists, return `.name`"""
        return demangle(self.name)

    @name.setter
    def name(self, name):
        """Set the function name.

        If the name exists, an exception will be raised. To use IDA's name counting use
        `.set_name(desired_name, anyway=True)`.
        """
        self.set_name(name)

    def set_name(self, name, anyway=False):
        """Set Function Name.

        Default behavior throws an exception when setting to a name that already exists in
        the IDB. to make IDA automatically add a counter to the name (like in the GUI,)
        use `anyway=True`.

        Args:
            name: Desired name.
            anyway: `True` to set anyway.
        """
        set_name(self.start_ea, name, anyway=anyway)

    def __repr__(self):
        return 'Function(name="{}", addr=0x{:08X})'.format(self.name, self.start_ea)

    def __contains__(self, item):
        """Is an item contained (its EA is in) the function."""
        # If the item has an EA, use it. If not, use the item itself assuming it is an EA.
        ea = getattr(item, "ea", item)

        return is_same_function(ea, self.ea)

    @property
    def frame_size(self):
        return idaapi.get_frame_size(self._func)

    @property
    def color(self):
        """Function color in IDA View"""
        color = idc.get_color(self.ea, idc.CIC_FUNC)
        if color == 0xFFFFFFFF:
            return None

        return color

    @color.setter
    @updates_ui
    def color(self, color):
        """Function Color in IDA View.

        Set color to `None` to clear the color.
        """
        if color is None:
            color = 0xFFFFFFFF

        idc.set_color(self.ea, idc.CIC_FUNC, color)

    @property
    def has_name(self):
        return Line(self.start_ea).has_name

    @property
    def func_t(self):
        return self._func

    @property
    def signature(self):
        '''The C signature of the function.'''
        return idc.get_type(self.start_ea)

    @signature.setter
    def signature(self, c_signature):
        success = idc.SetType(self.start_ea, c_signature)
        if not success:
            raise exceptions.SetTypeFailed(self.start_ea, c_signature)

    @property
    def tinfo(self):
        '''The tinfo of the function type'''
        return idc.get_tinfo(self.start_ea)

    @tinfo.setter
    def tinfo(self, tinfo):
        success = idc.apply_type(self.start_ea, tinfo)
        if not success:
            raise exceptions.SetTypeFailed(self.start_ea, tinfo)


def iter_function_lines(func_ea) -> Iterable[Line]:
    """Iterate the lines of a function.

    Args:
        func_ea (idaapi.func_t, int): The function to iterate.

    Returns:
        Iterator over all the lines of the function.
    """
    for line in idautils.FuncItems(get_ea(func_ea)):
        yield Line(line)


def functions(start=None, end=None):
    """Get all functions in range.

    Args:
        start: Start address of the range. Defaults to IDB start.
        end: End address of the range. Defaults to IDB end.

    Returns:
        This is a generator that iterates over all the functions in the IDB.
    """
    start, end = fix_addresses(start, end)

    for func_t in idautils.Functions(start, end):
        yield Function(func_t)

```

`sark/code/instruction.py`:

```py
import ida_ua
import idaapi
import idautils
import idc
import ida_ida
from typing import Optional

from . import intel
from . import base
from .. import core
from .. import exceptions

OPND_WRITE_FLAGS = {
    0: idaapi.CF_CHG1,
    1: idaapi.CF_CHG2,
    2: idaapi.CF_CHG3,
    3: idaapi.CF_CHG4,
    4: idaapi.CF_CHG5,
    5: idaapi.CF_CHG6,
}

OPND_READ_FLAGS = {
    0: idaapi.CF_USE1,
    1: idaapi.CF_USE2,
    2: idaapi.CF_USE3,
    3: idaapi.CF_USE4,
    4: idaapi.CF_USE5,
    5: idaapi.CF_USE6,
}


def _is_intel()->bool:
    proc_name = ida_ida.inf_get_procname()
    return proc_name == 'metapc'


class Phrase(object):
    def __init__(self, insn_t, op_t):
        self.insn_t:ida_ua.insn_t = insn_t
        self.op_t:ida_ua.op_t = op_t

        self._initialize()

    def _initialize(self):
        if self.op_t.type not in (idaapi.o_displ, idaapi.o_phrase):
            raise exceptions.OperandNotPhrase(f'Operand is not of type o_phrase or o_displ: {self.op_t.type}')

        proc_name = ida_ida.inf_get_procname()
        if proc_name != 'metapc':
            raise exceptions.PhraseProcessorNotSupported(
                'Phrase analysis not supported for processor {}'.format(proc_name))

        def fix_reg_none(reg_id) -> Optional[int]:
            if reg_id == intel.RegNo.R_none:
                return None
            return reg_id

        self.scale = 1 << intel.x86_scale(self.op_t)
        self.index_id = fix_reg_none(intel.x86_index_reg(self.insn_t, self.op_t))
        self.base_id = fix_reg_none(intel.x86_base_reg(self.insn_t, self.op_t))
        self.offset = self.op_t.addr

    @property
    def base(self):
        if self.base_id is None:
            return None
        return base.get_register_name(self.base_id)

    @property
    def index(self):
        if self.index_id is None:
            return None
        return base.get_register_name(self.index_id)

    def __repr__(self):
        phrase = []
        if self.base_id is not None:
            phrase.append(self.base)
        if self.index_id is not None:
            if phrase:
                phrase.append('+')
            phrase.append('{index}*{scale}'.format(index=self.index, scale=self.scale))
        if self.offset:
            offset = self.offset
            sign = '+'
            if core.is_signed(offset):
                offset = offset - (1 << (8 * core.get_native_size()))
                sign = '-'
            value = '{:X}'.format(abs(offset))
            phrase.append('{sign}{prefix}{value}{suffix}'.format(sign=sign if phrase or offset < 0 else '',
                                                                 prefix='0' if value[0].isalpha() else '',
                                                                 value=value,
                                                                 suffix='h' if abs(offset) > 9 else ''))

        return '[{}]'.format(''.join(phrase))


class OperandType(object):
    TYPES = {
        idaapi.o_void: "No_Operand",
        idaapi.o_reg: "General_Register",
        idaapi.o_mem: "Direct_Memory_Reference",
        idaapi.o_phrase: "Memory_Phrase",
        idaapi.o_displ: "Memory_Displacement",
        idaapi.o_imm: "Immediate_Value",
        idaapi.o_far: "Immediate_Far_Address",
        idaapi.o_near: "Immediate_Near_Address",
        idaapi.o_idpspec0: "Processor_specific_type",
        # There can be more processor specific types!
    }

    def __init__(self, type_):
        super(OperandType, self).__init__()

        self._type = type_

    @property
    def type(self):
        """Raw `type` value

        Use this if you need to pass the operand type around as a number.
        """
        return self._type

    @property
    def name(self):
        """Name of the xref type."""
        return self.TYPES.get(self._type, self.TYPES[idaapi.o_idpspec0])

    def __repr__(self):
        return self.name

    @property
    def is_void(self):
        return self._type == idaapi.o_void

    @property
    def is_reg(self):
        return self._type == idaapi.o_reg

    @property
    def is_mem(self):
        return self._type == idaapi.o_mem

    @property
    def is_phrase(self):
        return self._type == idaapi.o_phrase

    @property
    def is_displ(self):
        return self._type == idaapi.o_displ

    @property
    def is_imm(self):
        return self._type == idaapi.o_imm

    @property
    def is_far(self):
        return self._type == idaapi.o_far

    @property
    def is_near(self):
        return self._type == idaapi.o_near

    @property
    def is_special(self):
        return self._type >= idaapi.o_idpspec0

    @property
    def has_reg(self):
        return self._type in (idaapi.o_reg, idaapi.o_displ, idaapi.o_phrase)

    @property
    def has_phrase(self):
        return self._type in (idaapi.o_phrase, idaapi.o_displ)


class Operand(object):
    def __init__(self, operand, ea, insn, write=False, read=False):
        self._operand = operand
        self._write = write
        self._read = read
        self._type = OperandType(operand.type)
        self._ea = ea
        # We have to save the `insn_t` object referenced to make sure the `op_t` object is not released on the C side.
        self._insn = insn
        try:
            self._phrase = Phrase(insn, operand)
        except exceptions.PhraseError:
            self._phrase = None

    @property
    def n(self):
        """Index of the operand in the instruction."""
        return self._operand.n

    @property
    def type(self):
        """Operand type."""
        return self._type

    @property
    def has_displacement(self):
        return base.operand_has_displacement(self._operand)

    @property
    def displacement(self):
        return base.operand_get_displacement(self._operand)

    @property
    def op_t(self):
        return self._operand

    @property
    def flags(self):
        return self._operand.flags

    @property
    def dtype(self):
        return self._operand.dtype

    @property
    def imm(self):
        return self._operand.value

    value = imm

    @property
    def addr(self):
        return self._operand.addr

    def has_reg(self, reg_name):
        return any(reg == reg_name for reg in self.regs)

    @property
    def size(self):
        """Size of the operand."""
        return base.dtype_to_size(self._operand.dtype)

    @property
    def is_read(self):
        """Is the operand value used in the instruction."""
        return self._read

    @property
    def is_write(self):
        """Is the operand value changed in the instruction."""
        return self._write

    @property
    def reg_id(self):
        """ID of the register used in the operand."""
        return self._operand.reg

    @property
    def reg(self):
        """Name of the register used in the operand."""
        if self.type.is_displ or self.type.is_phrase:
            size = core.get_native_size()
            return base.get_register_name(self.reg_id, size)

        if self.type.is_reg:
            return base.get_register_name(self.reg_id, self.size)

        else:
            raise exceptions.SarkOperandWithoutReg("Operand does not have a register.")

    @property
    def regs(self):
        if self.type.has_phrase:
            return set(reg for reg in (self.base, self.index) if reg)
        elif self.type.is_reg:
            return {base.get_register_name(self.reg_id, self.size)}
        else:
            return set()

    @property
    def text(self):
        return idc.print_operand(self._ea, self.n)

    def __str__(self):
        return self.text

    def __repr__(self):
        return "<Operand(n={}, text={!r})>".format(self.n, str(self))

    @property
    def base(self):
        if self._phrase:
            return self._phrase.base
        return self.reg

    @property
    def scale(self):
        if self._phrase:
            return self._phrase.scale

        if self.type.is_mem and _is_intel():
            return 1<< intel.x86_scale(self.op_t)
        return None

    @property
    def index(self):
        if self._phrase:
            return self._phrase.index

        if self.type.is_mem and _is_intel():
            return base.get_register_name(intel.x86_index_reg(self._insn, self.op_t), self.size)
        return None

    @property
    def offset(self):
        return self.addr


class IndexingMode(object):
    def __init__(self, pre=False, post=False):
        self.pre = pre
        self.post = post

    @property
    def is_pre(self):
        return self.pre

    @property
    def is_post(self):
        return self.post

    @property
    def is_none(self):
        return not (self.pre or self.post)

    def __bool__(self):
        return self.pre or self.post


class Instruction(object):
    def __init__(self, ea):
        self._ea = ea
        self._insn = idautils.DecodeInstruction(ea)

        if self._insn is None:
            raise exceptions.SarkNoInstruction("No Instruction at 0x{:08X}.".format(ea))

        self._operands = self._make_operands()

    def __repr__(self):
        return f'<Instruction at 0x{self._ea:08x}>'

    def _make_operands(self):
        operands = []
        for index, operand in enumerate(self._insn.ops):
            if operand.type == idaapi.o_void:
                break  # No more operands.
            operands.append(Operand(operand,
                                    self._ea,
                                    insn=self._insn,
                                    write=self.is_operand_written_to(index),
                                    read=self.is_operand_read_from(index)))
        return operands

    @property
    def operands(self):
        """Instruction's Operands."""
        return self._operands

    @property
    def feature(self):
        """Canonical Features"""
        return self._insn.get_canon_feature()

    @property
    def mnem(self):
        """Instruction Mnemonic"""
        return self._insn.get_canon_mnem()

    def has_reg(self, reg_name):
        """Check if a register is used in the instruction."""
        return any(operand.has_reg(reg_name) for operand in self.operands)

    def is_operand_written_to(self, operand_index):
        """Check if an operand is written to (destination operand)."""
        return bool(self.feature & OPND_WRITE_FLAGS[operand_index])

    def is_operand_read_from(self, operand_index):
        """Check if an operand is read from (source operand)."""
        return bool(self.feature & OPND_READ_FLAGS[operand_index])

    @property
    def regs(self):
        """Names of all registers used by the instruction."""
        regs = set()
        for operand in self.operands:
            if not operand.type.has_reg:
                continue
            regs.update(operand.regs)
        return regs

    @property
    def is_call(self):
        """Is the instruction a call instruction."""
        return idaapi.is_call_insn(self._insn)

    @property
    def is_ret(self):
        """Is the instruction a return instruction."""
        return idaapi.is_ret_insn(self._insn)

    @property
    def is_indirect_jump(self):
        """Is the instruction an indirect jump instruction."""
        return idaapi.is_indirect_jump_insn(self._insn)

    @property
    def insn_t(self):
        return self._insn

    @property
    def indexing_mode(self):
        if ida_ida.inf_get_procname() != 'ARM':
            return IndexingMode()

        return IndexingMode(pre=bool(self.insn_t.auxpref & 0x20),
                            post=bool(self.insn_t.auxpref & 0x80))

```

`sark/code/intel.py`:

```py
"""
Parsing x86_64 operand phrases.

This is a partial Python port of the functionality in `intel.hpp`.
For more information and documentation, see `intel.hpp` in the IDA SDK.

The names and structure here are ment to closely resemble the C++ code,
to make future changes easier.
"""

import enum

import ida_ua

from sark.exceptions import InvalidPhraseRegisters


class RegNo(enum.IntEnum):
    R_none = -1
    R_ax = 0
    R_cx = 1
    R_dx = 2
    R_bx = 3
    R_sp = 4
    R_bp = 5
    R_si = 6
    R_di = 7
    R_r8 = 8
    R_r9 = 9
    R_r10 = 10
    R_r11 = 11
    R_r12 = 12
    R_r13 = 13
    R_r14 = 14
    R_r15 = 15


class Aux(enum.IntFlag):
    Use32 = 0x8
    Use64 = 0x10
    NatAd = 0x1000


REX_X = 2  # sib index field extension
REX_B = 1  # modrm r/m, sib base, or opcode reg fields extension


INDEX_NONE = 4  # no index register is present


def ad16(insn: ida_ua.insn_t) -> bool:
    p = insn.auxpref & (Aux.Use32 | Aux.Use64 | Aux.NatAd)
    return p == Aux.NatAd or p == Aux.Use32


def hasSIB(op: ida_ua.op_t) -> int:
    return op.specflag1


def sib(op: ida_ua.op_t) -> int:
    return op.specflag2


def rex(insn: ida_ua.insn_t) -> int:
    return insn.insnpref


def sib_base(insn: ida_ua.insn_t, x: ida_ua.op_t):
    base = sib(x) & 7
    if rex(insn) & REX_B:
        base |= 8
    return base


def is_vsib(insn):
    # This seems to be for AVX instructions, and is annoying to implement.
    # So I'm ignoring this for now.
    return False


def sib_index(insn, x):
    index = (sib(x) >> 3) & 7
    if rex(insn) & REX_X:
        index |= 8
    if is_vsib(insn):
        # This is a lot of code to write, and I don't know if there's
        # an actual need for this.
        # If anyone wants this - PRs are welcome!
        raise NotImplementedError("AVX support is currently not implemented.")
    return index


def sib_scale(x):
    scale = (sib(x) >> 6) & 3
    return scale


def x86_scale(x):
    if hasSIB(x):
        return sib_scale(x)
    return 0


def x86_index_reg(insn, x):
    if hasSIB(x):
        idx = sib_index(insn, x)
        if idx != INDEX_NONE:
            return idx
        return RegNo.R_none
    if not ad16(insn):
        return RegNo.R_none
    if x.phrase == 0 or x.phrase == 2:
        return RegNo.R_si
    if x.phrase == 1 or x.phrase == 3:
        return RegNo.R_di
    if x.phrase in (4, 5, 6, 7):
        return RegNo.R_none
    raise InvalidPhraseRegisters("Could not parse phrase index register.")


def x86_base_reg(insn, x):
    if hasSIB(x):
        if x.type == ida_ua.o_mem:
            return RegNo.R_none
        return sib_base(insn, x)  # base register is encoded in the SIB
    elif not ad16(insn):
        return x.phrase  # 'phrase' contains the base register number
    elif x.phrase == RegNo.R_none:
        return RegNo.R_sp
    if x.phrase == 0 or x.phrase == 1 or x.phrase == 7:  # [BX+SI], [BX+DI], [BX]
        return RegNo.R_bx
    elif x.phrase == 2 or x.phrase == 3 or x.phrase == 6:  # [BP+SI], [BP+DI], [BP]
        return RegNo.R_bp
    elif x.phrase == 4:  # [SI]
        return RegNo.R_si
    elif x.phrase == 5:  # [DI]
        return RegNo.R_di
    else:
        raise InvalidPhraseRegisters("Could not parse phrase base register.")

```

`sark/code/line.py`:

```py
import idaapi
import idautils
import idc
from ..core import fix_addresses
from .xref import Xref
from .instruction import Instruction
from ..ui import updates_ui
from .base import get_selection, get_offset_name, demangle
from .. import data


class Comments(object):
    """IDA Line Comments

    Provides easy access to all types of comments for an IDA line.
    """

    def __init__(self, ea):
        self._ea = ea

    def __bool__(self):
        return any((self.regular, self.repeat, self.anterior, self.posterior,))

    @property
    def regular(self):
        """Regular Comment"""
        return idaapi.get_cmt(self._ea, 0)

    @regular.setter
    def regular(self, comment):
        idaapi.set_cmt(self._ea, comment, 0)

    @property
    def repeat(self):
        """Repeatable Comment"""
        return idaapi.get_cmt(self._ea, 1)

    @repeat.setter
    def repeat(self, comment):
        idaapi.set_cmt(self._ea, comment, 1)

    def _iter_extra_comments(self, start):
        end = idaapi.get_first_free_extra_cmtidx(self._ea, start)
        for idx in range(start, end):
            line = idaapi.get_extra_cmt(self._ea, idx)
            yield line or ''

    def _iter_anterior(self):
        return self._iter_extra_comments(idaapi.E_PREV)

    @property
    def anterior(self):
        """Anterior Comment"""
        return "\n".join(self._iter_anterior())

    @anterior.setter
    @updates_ui
    def anterior(self, comment):
        if not comment:
            idaapi.del_extra_cmt(self._ea, idaapi.E_PREV)
            return

        index = 0

        for index, line in enumerate(comment.splitlines()):
            idaapi.update_extra_cmt(self._ea, idaapi.E_PREV + index, line)

        idaapi.del_extra_cmt(self._ea, idaapi.E_PREV + (index + 1))

    def _iter_posterior(self):
        return self._iter_extra_comments(idaapi.E_NEXT)

    @property
    def posterior(self):
        """Posterior Comment"""
        return "\n".join(self._iter_posterior())

    @posterior.setter
    @updates_ui
    def posterior(self, comment):
        if not comment:
            idaapi.del_extra_cmt(self._ea, idaapi.E_NEXT)
            return

        index = 0

        for index, line in enumerate(comment.splitlines()):
            idaapi.update_extra_cmt(self._ea, idaapi.E_NEXT + index, line)

        idaapi.del_extra_cmt(self._ea, idaapi.E_NEXT + (index + 1))

    def __repr__(self):
        return ("Comments("
                "ea=0x{ea:08X},"
                " reqular={regular},"
                " repeat={repeat},"
                " anterior={anterior},"
                " posterior={posterior})").format(
            ea=self._ea,
            regular=repr(self.regular),
            repeat=repr(self.repeat),
            anterior=repr(self.anterior),
            posterior=repr(self.posterior))


class Line(object):
    """
    An IDA Line.

    This objects encapsulates many of IDA's line-handling APIs in an easy to use
    and object oriented way.
    """

    class UseCurrentAddress(object):
        """
        This is a filler object to replace `None` for the EA.
        In many cases, a programmer can accidentally initialize the
        `Line` object with `ea=None`, resulting in the current address.
        Usually, this is not the desired outcome. This object resolves this issue.
        """
        pass

    def __init__(self, ea=UseCurrentAddress, name=None):
        if name is not None and ea != self.UseCurrentAddress:
            raise ValueError(("Either supply a name or an address (ea). "
                              "Not both. (ea={!r}, name={!r})").format(ea, name))

        elif name is not None:
            ea = idc.get_name_ea_simple(name)

        elif ea == self.UseCurrentAddress:
            ea = idc.here()

        elif ea is None:
            raise ValueError("`None` is not a valid address. To use the current screen ea, "
                             "use `Line(ea=Line.UseCurrentAddress)` or supply no `ea`.")

        self._ea = idaapi.get_item_head(ea)
        self._comments = Comments(self._ea)

    @property
    def flags(self):
        """`FF_*` Flags. See `bytes.hpp`."""
        return idaapi.get_full_flags(self.ea)

    @property
    def is_code(self):
        """Is the line code."""
        return idaapi.is_code(self.flags)

    @property
    def is_data(self):
        """Is the line data."""
        return idaapi.is_data(self.flags)

    @property
    def is_unknown(self):
        """Is the line unknown."""
        return idaapi.is_unknown(self.flags)

    @property
    def is_tail(self):
        """Is the line a tail."""
        return idaapi.is_tail(self.flags)

    @property
    def is_string(self):
        """Is the line a string."""
        return data.is_string(self.ea)

    @property
    def comments(self):
        """Comments"""
        return self._comments

    @property
    def ea(self):
        """Line EA"""
        return self._ea

    start_ea = ea

    @property
    def end_ea(self):
        """End address of line (first byte after the line)"""
        return self.ea + self.size

    @property
    def disasm(self):
        """Line Disassembly"""
        return idc.GetDisasm(self.ea)

    @property
    def type(self):
        """return the type of the Line """
        properties = {self.is_code: "code",
                      self.is_data: "data",
                      self.is_string: "string",
                      self.is_tail: "tail",
                      self.is_unknown: "unknown"}
        for k, v in properties.items():
            if k: return v

    def __repr__(self):
        return "[{:08X}]    {}".format(self.ea, self.disasm)

    @property
    def xrefs_from(self):
        """Xrefs from this line.

        :return: Xrefs as `sark.code.xref.Xref` objects.
        """
        return list(map(Xref, idautils.XrefsFrom(self.ea)))

    @property
    def calls_from(self):
        return (xref for xref in self.xrefs_from if xref.type.is_call)

    @property
    def drefs_from(self):
        """Destination addresses of data references from this line."""
        return idautils.DataRefsFrom(self.ea)

    @property
    def crefs_from(self):
        """Destination addresses of code references from this line."""
        return idautils.CodeRefsFrom(self.ea, 1)

    @property
    def xrefs_to(self):
        """Xrefs to this line.

        Returns:
            Xrefs as `sark.code.xref.Xref` objects.
        """
        return list(map(Xref, idautils.XrefsTo(self.ea)))

    @property
    def drefs_to(self):
        """Source addresses of data references from this line."""
        return idautils.DataRefsTo(self.ea)

    @property
    def crefs_to(self):
        """Source addresses of data references to this line."""
        return idautils.CodeRefsTo(self.ea, 1)

    @property
    def size(self):
        """Size (in bytes) of the line."""
        return idaapi.get_item_size(self.ea)

    @property
    def name(self):
        """Name of the line (the label shown in IDA)."""
        return idaapi.get_ea_name(self.ea)

    @name.setter
    def name(self, value):
        idc.set_name(self.ea, value)

    @property
    def demangled(self):
        """Return the demangled name of the line. If none exists, return `.name`"""
        return demangle(self.name)

    @property
    def insn(self):
        """Instruction"""
        return Instruction(self.ea)

    @property
    def color(self):
        """Line color in IDA View"""
        color = idc.get_color(self.ea, idc.CIC_ITEM)
        if color == 0xFFFFFFFF:
            return None

        return color

    @color.setter
    @updates_ui
    def color(self, color):
        """Line Color in IDA View.

        Set color to `None` to clear the color.
        """
        if color is None:
            color = 0xFFFFFFFF

        idc.set_color(self.ea, idc.CIC_ITEM, color)

    @property
    def next(self):
        """The next line."""
        return Line(self.end_ea)

    @property
    def prev(self):
        """The previous line."""
        return Line(self.ea - 1)

    @property
    def has_name(self):
        """Does the current line have a non-trivial (non-dummy) name?"""
        return idaapi.has_name(self.flags)

    @property
    def offset_name(self):
        return get_offset_name(self.ea)

    @property
    def bytes(self):
        return idaapi.get_bytes(self.ea, self.size)

    def __eq__(self, other):
        if not isinstance(other, Line):
            return False

        return self.ea == other.ea

    def __ne__(self, other):
        return not self.__eq__(other)


def lines(start=None, end=None, reverse=False, selection=False):
    """Iterate lines in range.

    Args:
        start: Starting address, start of IDB if `None`.
        end: End address, end of IDB if `None`.
        reverse: Set to true to iterate in reverse order.
        selection: If set to True, replaces start and end with current selection.

    Returns:
        iterator of `Line` objects.
    """
    if selection:
        start, end = get_selection()

    else:
        start, end = fix_addresses(start, end)

    if not reverse:
        item = idaapi.get_item_head(start)
        while item < end:
            yield Line(item)
            item += idaapi.get_item_size(item)

    else:  # if reverse:
        item = idaapi.get_item_head(end - 1)
        while item >= start:
            yield Line(item)
            item = idaapi.get_item_head(item - 1)

```

`sark/code/segment.py`:

```py
import idc
import idaapi
import idautils
from .function import functions
from .line import lines
from .. import exceptions

class Comments(object):
    def __init__(self, segment):
        super(Comments, self).__init__()
        self._segment = segment

    @property
    def regular(self):
        return idaapi.get_segment_cmt(self._segment, False)

    @regular.setter
    def regular(self, comment):
        idaapi.set_segment_cmt(self._segment, comment, False)

    @property
    def repeat(self):
        return idaapi.get_segment_cmt(self._segment, True)

    @repeat.setter
    def repeat(self, comment):
        idaapi.set_segment_cmt(self._segment, comment, True)


class SegmentPermissions(object):
    def __init__(self, segment_t):
        super(SegmentPermissions, self).__init__()
        self._segment = segment_t

    @property
    def x(self):
        return bool(self._segment.perm & idaapi.SEGPERM_EXEC)

    @x.setter
    def x(self, value):
        if value:
            self._segment.perm |= idaapi.SEGPERM_EXEC

        else:
            self._segment.perm &= ~idaapi.SEGPERM_EXEC

    @property
    def w(self):
        return bool(self._segment.perm & idaapi.SEGPERM_WRITE)

    @w.setter
    def w(self, value):
        if value:
            self._segment.perm |= idaapi.SEGPERM_WRITE

        else:
            self._segment.perm &= ~idaapi.SEGPERM_WRITE

    @property
    def r(self):
        return bool(self._segment.perm & idaapi.SEGPERM_READ)

    @r.setter
    def r(self, value):
        if value:
            self._segment.perm |= idaapi.SEGPERM_READ

        else:
            self._segment.perm &= ~idaapi.SEGPERM_READ

    execute = x
    write = w
    read = r

    def __str__(self):
        return "".join(("R" if self.r else "", "W" if self.w else "", "X" if self.x else ""))

    def __repr__(self):
        return "<SegmentPermissions(read={}, write={}, execute={})>".format(self.r, self.w, self.x)


class Segment(object):
    BITNESS_TO_BITS = {
        0: 16,
        1: 32,
        2: 64,
    }

    BITS_TO_BITNESS = {
        16: 0,
        32: 1,
        64: 2,
    }

    class UseCurrentAddress(object):
        pass

    def __init__(self, ea=UseCurrentAddress, name=None, index=None, segment_t=None):
        """Wrapper around IDA segments.

        There are 3 ways to get a segment - by name, ea or index. Only use one.

        Args:
            ea - address in the segment
            name - name of the segment
            index - index of the segment
        """
        if sum((ea not in (self.UseCurrentAddress, None), name is not None, index is not None,
                segment_t is not None,)) > 1:
            raise ValueError((
                                 "Expected only one (ea, name, index or segment_t)."
                                 " Got (ea={!r}, name={!r}, index={!r}, segment_t={!r})"
                             ).format(ea,
                                      name,
                                      index,
                                      segment_t))


        elif segment_t is not None:
            seg = segment_t

        elif name is not None:
            seg = idaapi.get_segm_by_name(name)

        elif index is not None:
            seg = idaapi.getnseg(index)

        elif ea == self.UseCurrentAddress:
            seg = idaapi.getseg(idc.here())

        elif ea is None:
            raise ValueError("`None` is not a valid address. To use the current screen ea, "
                             "use `Function(ea=Function.UseCurrentAddress)` or supply no `ea`.")

        else:
            seg = idaapi.getseg(ea)

        self._segment = seg

    @property
    def segment_t(self):
        return self._segment

    @property
    def permissions(self):
        """Segment permissions.

        Can be used to get or set the segment permissions (r/w/x).

        Returns:
            A `SegmentPermissions` object.
        """
        return SegmentPermissions(self.segment_t)

    @property
    def start_ea(self):
        return self._segment.start_ea

    ea = start_ea

    @property
    def end_ea(self):
        return self._segment.end_ea

    @property
    def type(self):
        return idaapi.segtype(self.ea)

    @property
    def name(self):
        return idaapi.get_segm_name(self.segment_t)

    @name.setter
    def name(self, name):
        idaapi.set_segm_name(self.segment_t, name)

    @property
    def class_(self):
        return idaapi.get_segm_class(self.segment_t)

    @class_.setter
    def class_(self, value):
        idaapi.set_segm_class(self.segment_t, value)

    @property
    def functions(self):
        """Iterate all functions in the segment."""
        return functions(self.start_ea, self.end_ea)

    @property
    def lines(self):
        """Iterate all lines in the segment."""
        return lines(self.start_ea, self.end_ea)

    @property
    def bitness(self):
        """Segment's Bitness.

        Can be 16, 32 or 64.
        """
        return self.BITNESS_TO_BITS[self.segment_t.bitness]

    @bitness.setter
    def bitness(self, bits):
        try:
            self.segment_t.bitness = self.BITS_TO_BITNESS[bits]
        except KeyError:
            raise exceptions.InvalidBitness("Got {}. Expecting 16, 32 or 64.".format(bits))

    @property
    def next(self):
        """Get the next segment."""
        seg = Segment(segment_t=idaapi.get_next_seg(self.ea))

        if seg.ea <= self.ea:
            raise exceptions.NoMoreSegments("This is the last segment. No segments exist after it.")

        return seg

    @property
    def prev(self):
        """Get the previous segment."""
        seg = Segment(segment_t=idaapi.get_prev_seg(self.ea))

        if seg.ea >= self.ea:
            raise exceptions.NoMoreSegments("This is the first segment. no segments exist before it.")

        return seg

    @property
    def comments(self):
        return Comments(self.segment_t)

    @property
    def size(self):
        return self.end_ea - self.start_ea

    def __repr__(self):
        return ("<Segment(ea=0x{:08X},"
                " name={!r},"
                " size=0x{:08X},"
                " permissions={!r},"
                " bitness={})>").format(self.ea,
                                        self.name,
                                        self.size,
                                        str(self.permissions),
                                        self.bitness)


def segments(seg_type=None):
    """Iterate segments based on type

        Args:
            seg_type: type of segment e.g. SEG_CODE

        Returns:
            iterator of `Segment` objects. if seg_type is None , returns all segments
            otherwise returns only the relevant ones
    """

    for index in range(idaapi.get_segm_qty()):
        seg = Segment(index=index)
        if (seg_type is None) or (seg.type == seg_type):
            yield Segment(index=index)

```

`sark/code/switch.py`:

```py
from collections import defaultdict


import idaapi

from .. import exceptions

class Switch(object):
    """IDA Switch

    Access IDA switch data with ease.

    Usage:

        >>> my_switch = Switch(switch_jump_address)
        >>> for case, target in my_switch:
        ...     print("{} -> 0x{:08X}".format(case, target))

    """
    def __init__(self, ea):
        """Initialize a switch parser.

        Args:
            ea: An address of a switch jump instruction.
        """
        self._ea = ea

        results = self._calc_cases()

        self._map = self._build_map(results)

        self._reverse_map = self._build_reverse(self._map)

    def _build_reverse(self, switch_map):
        reverse_map = defaultdict(list)
        for case, target in switch_map.items():
            reverse_map[target].append(case)
        return reverse_map

    def _calc_cases(self):
        si = idaapi.get_switch_info(self._ea)
        results = idaapi.calc_switch_cases(self._ea, si)
        if not results:
            raise exceptions.SarkNotASwitch("Seems like 0x{:08X} is not a switch jump instruction.".format(self._ea))

        return results

    def _build_map(self, results):
        switch_map = {}
        for cases, target in zip(results.cases, results.targets):
            for case in cases:
                switch_map[case] = target

        return switch_map

    @property
    def targets(self):
        """Switch Targets"""
        return list(self._map.values())

    @property
    def cases(self):
        """Switch Cases"""
        return list(self._map.keys())

    @property
    def pairs(self):
        """(case, target) pairs"""
        return iter(self._map.items())

    def __iter__(self):
        """Iterate switch cases."""
        return iter(self._map.keys())

    def __getitem__(self, case):
        """switch[case] -> target"""
        return self._map[case]

    def get_cases(self, target):
        """switch.get_cases(target) -> [case]"""
        if target in self.targets:
            return self._reverse_map[target]

        raise KeyError("Target 0x{:08X} does not exist.".format(target))


def is_switch(ea):
    try:
        switch = Switch(ea)
        return True
    except exceptions.SarkNotASwitch:
        return False
```

`sark/code/xref.py`:

```py
import idaapi
import idc
from ..core import get_name_or_address


class XrefType(object):
    """Xref Type Wrapper.

    Provides easy to use parsing of xref types.
    All the properties are flag checks on the type value.
    """
    TYPES = {
        0x00: 'Data_Unknown',
        0x01: 'Data_Offset',
        0x02: 'Data_Write',
        0x03: 'Data_Read',
        0x04: 'Data_Text',
        0x05: 'Data_Informational',
        0x10: 'Code_Far_Call',
        0x11: 'Code_Near_Call',
        0x12: 'Code_Far_Jump',
        0x13: 'Code_Near_Jump',
        0x14: 'Code_User',
        0x15: 'Ordinary_Flow'
    }

    def __init__(self, type_):
        self._type = type_

    @property
    def type(self):
        """Xref type, flags excluded."""
        return self._type & idaapi.XREF_MASK

    @property
    def flags(self):
        """Xref flags, type excluded."""
        return self._type ^ self.type

    @property
    def name(self):
        """Name of the xref type."""
        return self.TYPES[self._type]

    def __repr__(self):
        return self.name

    @property
    def is_code(self):
        return self._type & 0x10

    @property
    def is_data(self):
        return not self.is_code

    @property
    def is_unknown(self):
        return self.type == idaapi.fl_U

    @property
    def is_offset(self):
        return self.type == idaapi.dr_O

    @property
    def is_write(self):
        return self.type == idaapi.dr_W

    @property
    def is_read(self):
        return self.type == idaapi.dr_R

    @property
    def is_text(self):
        return self.type == idaapi.dr_T

    @property
    def is_info(self):
        return self.type == idaapi.dr_I

    @property
    def is_far_call(self):
        return self.type == idaapi.fl_CF

    @property
    def is_near_call(self):
        return self.type == idaapi.fl_CN

    @property
    def is_far_jump(self):
        return self.type == idaapi.fl_JF

    @property
    def is_near_jump(self):
        return self.type == idaapi.fl_JN

    @property
    def is_unknown(self):
        return self.type == idaapi.fl_U

    @property
    def is_flow(self):
        return self.type == idaapi.fl_F

    @property
    def is_user(self):
        return self.flags & idaapi.XREF_USER

    @property
    def is_tail(self):
        return self.flags & idaapi.XREF_TAIL

    @property
    def is_base(self):
        return self.flags & idaapi.XREF_BASE

    @property
    def is_call(self):
        return self.is_far_call or self.is_near_call

    @property
    def is_jump(self):
        return self.is_far_jump or self.is_near_jump


class Xref(object):
    """Xref Object

    Provides easy access to xref attributes.
    Most interesting data (xref type) is accessible via the `.type`
    attribute.
    """

    def __init__(self, xref):
        for attr in ['frm', 'to', 'iscode', 'user']:
            setattr(self, attr, getattr(xref, attr))

        self._type = XrefType(xref.type)

    @property
    def type(self):
        return self._type

    def __repr__(self):
        return "<Xref(frm={frm}, to={to}, iscode={iscode}, user={user}, type={type})>".format(
            frm=get_name_or_address(self.frm),
            to=get_name_or_address(self.to),
            iscode=self.iscode,
            user=self.user,
            type=repr(self.type),
        )
```

`sark/codeblock.py`:

```py
import networkx

import idaapi
from .code import lines, functions
from .core import get_func, fix_addresses


class CodeBlock(idaapi.BasicBlock):
    def __init__(self, id_ea=None, bb=None, fc=None):
        if bb is None and fc is None:
            if id_ea is None:
                id_ea = idaapi.get_screen_ea()
            temp_codeblock = get_codeblock(id_ea)
            self.__dict__.update(temp_codeblock.__dict__)
        else:
            super(CodeBlock, self).__init__(id=id_ea, bb=bb, fc=fc)

    @property
    def lines(self):
        return lines(self.start_ea, self.end_ea)

    @property
    def next(self):
        return self.succs()

    @property
    def prev(self):
        return self.preds()

    def set_color(self, color=None):
        for line in self.lines:
            line.color = color

        if color is None:
            idaapi.clr_node_info(self._fc._q.bounds.start_ea, self.id, idaapi.NIF_BG_COLOR)

        else:
            node_info = idaapi.node_info_t()
            node_info.bg_color = color
            idaapi.set_node_info(self._fc._q.bounds.start_ea, self.id, node_info, idaapi.NIF_BG_COLOR)

    @property
    def color(self):
        node_info = idaapi.node_info_t()
        success = idaapi.get_node_info(node_info, self._fc._q.bounds.start_ea, self.id)

        if not success:
            return None

        if not node_info.valid_bg_color():
            return None

        return node_info.bg_color

    @color.setter
    def color(self, color):
        self.set_color(color)

    def __repr__(self):
        return "<CodeBlock(start_ea=0x{:08X}, end_ea=0x{:08X})>".format(self.start_ea, self.end_ea)

    def __eq__(self, other):
        return self.start_ea == other.start_ea


class FlowChart(idaapi.FlowChart):
    def __init__(self, f=None, bounds=None, flags=idaapi.FC_PREDS, ignore_external=False):
        if f is None and bounds is None:
            f = idaapi.get_screen_ea()
        if f is not None:
            f = get_func(f)
        if ignore_external:
            flags |= idaapi.FC_NOEXT

        super(FlowChart, self).__init__(f=f, bounds=bounds, flags=flags)

    def _getitem(self, index):
        return CodeBlock(index, self._q[index], self)


def get_flowchart(ea=None):
    if ea is None:
        ea = idaapi.get_screen_ea()
    func = idaapi.get_func(ea)
    flowchart_ = FlowChart(func)
    return flowchart_


def get_codeblock(ea=None):
    if ea is None:
        ea = idaapi.get_screen_ea()
    flowchart_ = get_flowchart(ea)
    for code_block in flowchart_:
        if code_block.start_ea == ea: # External blocks can be zero-sized.
            return code_block
        if code_block.start_ea <= ea < code_block.end_ea:
            return code_block


def get_block_start(ea):
    """Get the start address of an IDA Graph block."""
    return get_codeblock(ea).start_ea


def get_nx_graph(ea, ignore_external=False):
    """Convert an IDA flowchart to a NetworkX graph."""
    nx_graph = networkx.DiGraph()
    func = idaapi.get_func(ea)
    flowchart = FlowChart(func, ignore_external=ignore_external)
    for block in flowchart:
        # Make sure all nodes are added (including edge-less nodes)
        nx_graph.add_node(block.start_ea)

        for pred in block.preds():
            nx_graph.add_edge(pred.start_ea, block.start_ea)
        for succ in block.succs():
            nx_graph.add_edge(block.start_ea, succ.start_ea)

    return nx_graph


def codeblocks(start=None, end=None, full=True):
    """Get all `CodeBlock`s in a given range.

    Args:
        start - start address of the range. If `None` uses IDB start.
        end - end address of the range. If `None` uses IDB end.
        full - `True` is required to change node info (e.g. color). `False` causes faster iteration.
    """
    if full:
        for function in functions(start, end):
            fc = FlowChart(f=function.func_t)
            for block in fc:
                yield block

    else:
        start, end = fix_addresses(start, end)

        for code_block in FlowChart(bounds=(start, end)):
            yield code_block

```

`sark/core.py`:

```py
import idaapi
import idc
import ida_ida
import ida_search
import string
from . import exceptions


def get_func(func_ea):
    """get_func(func_t or ea) -> func_t

    Take an IDA function (``idaapi.func_t``) or an address (EA) and return
    an IDA function object.

    Use this when APIs can take either a function or an address.

    Args:
        func_ea: ``idaapi.func_t`` or ea of the function.

    Returns:
        An ``idaapi.func_t`` object for the given address. If a ``func_t`` is
        provided, it is returned.
    """
    if isinstance(func_ea, idaapi.func_t):
        return func_ea
    func = idaapi.get_func(func_ea)
    if func is None:
        raise exceptions.SarkNoFunction("No function at 0x{:08X}".format(func_ea))

    return func


def get_ea(func_ea):
    """get_ea(func_t or ea) -> ea

    Same as `get_func`, but returns the EA.

    Args:
        func_ea: `idaapi.func_t` or EA.

    Returns:
        The ea.
    """
    if isinstance(func_ea, idaapi.func_t):
        return func_ea.start_ea
    return func_ea


def add_func(func_ea,func_end=idaapi.BADADDR):
    return idaapi.add_func(func_ea,func_end)

def is_string_printable(string_):
    """Check if a string is printable"""
    return set(string_) - set(string.printable)


def string_to_query(string_):
    if is_string_printable(string_):
        return '"{}"'.format(string_)

    return " ".join(char.encode("hex") for char in string_)


def iter_find_string(query, start=None, end=None, down=True):
    query = string_to_query(query)
    return iter_find_query(query, start, end, down)


def iter_find_query(query, start=None, end=None, down=True):
    start, end = fix_addresses(start, end)

    if down:
        direction = ida_search.SEARCH_DOWN
    else:
        direction = ida_search.SEARCH_UP

    current = ida_search.find_binary(start, end, query, 16, direction)
    while current < end:
        yield current
        current = ida_search.find_binary(current + 1, end, query, 16, direction)


def fix_addresses(start=None, end=None):
    """Set missing addresses to start and end of IDB.

    Take a start and end addresses. If an address is None or `BADADDR`,
    return start or end addresses of the IDB instead.

    Args
        start: Start EA. Use `None` to get IDB start.
        end:  End EA. Use `None` to get IDB end.

    Returns:
        (start, end)
    """
    if start in (None, idaapi.BADADDR):
        start = ida_ida.inf_get_min_ea()

    if end in (None, idaapi.BADADDR):
        end = ida_ida.inf_get_max_ea()

    return start, end


def set_name(address, name, anyway=False):
    """Set the name of an address.

    Sets the name of an address in IDA.
    If the name already exists, check the `anyway` parameter:

        True - Add `_COUNTER` to the name (default IDA behaviour)
        False - Raise an `exceptions.SarkErrorNameAlreadyExists` exception.


    Args
        address: The address to rename.
        name: The desired name.
        anyway: Set anyway or not. Defualt ``False``.
    """
    success = idaapi.set_name(address, name, idaapi.SN_NOWARN | idaapi.SN_NOCHECK)
    if success:
        return

    if anyway:
        success = idaapi.force_name(address, name)
        if success:
            return

        raise exceptions.SarkSetNameFailed("Failed renaming 0x{:08X} to {!r}.".format(address, name))

    raise exceptions.SarkErrorNameAlreadyExists(
        "Can't rename 0x{:08X}. Name {!r} already exists.".format(address, name))


def is_same_function(ea1, ea2):
    """Are both addresses in the same function?"""
    func1 = idaapi.get_func(ea1)
    func2 = idaapi.get_func(ea2)
    # This is bloated code. `None in (func1, func2)` will not work because of a
    # bug in IDAPython in the way functions are compared.
    if any(func is None for func in (func1, func2)):
        return False

    return func1.start_ea == func2.start_ea


def get_name_or_address(ea):
    name = idaapi.get_ea_name(ea, idaapi.GN_VISIBLE)
    if name:
        name = repr(name)
    else:
        name = "0x{:08X}".format(ea)

    return name


def get_native_size():
    """Get the native word size in normal 8-bit bytes."""
    bits = ida_ida.inf_get_app_bitness()
    if bits == 64:
        return 8
    elif bits == 32:
        return 4
    else:
        return 2


def get_fileregion_offset(ea):
    file_offset = idaapi.get_fileregion_offset(ea)
    if file_offset == -1:
        raise exceptions.NoFileOffset("Address 0x{:08X} is not mapped to any file offset.".format(ea))

    return file_offset

def is_function(ea):
    try:
        get_func(ea)
        return True
    except exceptions.SarkNoFunction:
        return False


def is_signed(number, size=None):
    if not size:
        size = get_native_size()
    return number & (1 << ((8 * size) - 1))



```

`sark/data.py`:

```py
from collections import namedtuple
import idc
import idaapi

import shutil
import itertools
import struct
from .core import fix_addresses, get_native_size
from . import exceptions


def Bytes(start=None, end=None):
    start, end = fix_addresses(start, end)

    return map(idaapi.get_wide_byte, list(range(start, end)))


def Words(start=None, end=None):
    start, end = fix_addresses(start, end)

    return map(idaapi.get_wide_word, list(range(start, end, 2)))


def Dwords(start=None, end=None):
    start, end = fix_addresses(start, end)

    return map(idaapi.get_wide_dword, list(range(start, end, 4)))


def Qwords(start=None, end=None):
    start, end = fix_addresses(start, end)

    return map(idaapi.get_qword, list(range(start, end, 8)))


def NativeWords(start=None, end=None):
    native_size = get_native_size()

    if native_size == 2:
        return Words(start, end)
    elif native_size == 4:
        return Dwords(start, end)
    elif native_size == 8:
        return Qwords(start, end)


def bytes_until(byte=0, start=None, end=None):
    return iter(Bytes(start, end).__next__, byte)


def words_until(word=0, start=None, end=None):
    return iter(Words(start, end).__next__, word)


def dwords_until(dword=0, start=None, end=None):
    return iter(Dwords(start, end).__next__, dword)


def qwords_until(qword=0, start=None, end=None):
    return iter(Qwords(start, end).__next__, qword)


def native_words_until(native_word=0, start=None, end=None):
    return iter(NativeWords(start, end).__next__, native_word)


def Chars(start=None, end=None):
    return map(chr, Bytes(start, end))


def chars_until(char='\0', start=None, end=None):
    return iter(Chars(start, end).__next__, char)


def read_ascii_string(ea, max_length=None):
    if max_length is None:
        end = None
    else:
        end = ea + max_length
    return "".join(chars_until(start=ea, end=end))


def dword_to_bytes(dword):
    return struct.pack(">L", dword)


def read_memory(start, end):
    size = end - start
    return idaapi.get_bytes(start, size)


def write_memory(start, data, destructive=False):
    if destructive:
        idaapi.put_bytes(start, data)

    else:
        idaapi.patch_bytes(start, data)


PatchedByte = namedtuple("PatchedByte", "ea fpos original patched")


def get_patched_bytes(start=None, end=None):
    start, end = fix_addresses(start, end)

    patched_bytes = dict()

    def collector(ea, fpos, original, patched):
        patched_bytes[ea] = PatchedByte(ea, fpos, original, patched)
        return 0

    idaapi.visit_patched_bytes(start, end, collector)

    return patched_bytes


def apply_patches(output_path=None):
    to_patch = idaapi.get_input_file_path()

    if output_path:
        shutil.copyfile(to_patch, output_path)
        to_patch = output_path

    patches = get_patched_bytes()

    with open(to_patch, "r+b") as output:
        for patch in patches.values():
            output.seek(patch.fpos)
            patched_byte = bytes([patch.patched])
            output.write(patched_byte)


def undefine(start, end):
    idaapi.del_items(start, idaapi.DELIT_SIMPLE, end - start)


def is_string(ea):
    string_type = idc.get_str_type(idaapi.get_item_head(ea))

    if string_type in (None, -1):
        return False

    return True


def get_string(ea):
    """Read the string at the given ea.

    This function uses IDA's string APIs and does not implement any special logic.
    """
    # We get the item-head because the `GetStringType` function only works on the head of an item.
    string_type = idc.get_str_type(idaapi.get_item_head(ea))

    if string_type is None:
        raise exceptions.SarkNoString("No string at 0x{:08X}".format(ea))

    string = idc.get_strlit_contents(ea, strtype=string_type)

    if not string:
        raise exceptions.SarkNoString("No string at 0x{:08X}".format(ea))

    return string

```

`sark/debug.py`:

```py
from collections import namedtuple
import idaapi


class Registers(object):
    """
    Wrapper around IDA's debug registers.

    Enables easy querying of the debug registers API (`idaapi.dbg_get_registers`) to get
    register info, such as the names of the instruction pointer and the stack pointer.

    Usage (on x86):
        >>> print(Registers().ip.name)
        eip

        >>> print(Registers().sp.name)
        esp
    """
    REGISTER_READONLY = 0x001  # the user can't modify the current value of this register
    REGISTER_IP = 0x002  # instruction pointer
    REGISTER_SP = 0x004  # stack pointer
    REGISTER_FP = 0x008  # frame pointer
    REGISTER_ADDRESS = 0x010  # may contain an address
    REGISTER_CS = 0x020  # code segment
    REGSITER_SS = 0x040  # stack segment
    REGISTER_NOLF = 0x080  # displays this register without returning to the next line
    REGISTER_CUSTFMT = 0x100  # allowing the next register to be displayed to its right (on the same line)
    # register should be displayed using a custom data format.

    RegisterInfo = namedtuple("RegisterInfo", "name, flags, cls, dtyp, bit_strings, bit_strings_default_mask")

    def __init__(self):
        reg_infos = idaapi.dbg_get_registers()
        if not reg_infos:
            raise RuntimeError("Debugger not present.")

        self._reg_infos = [self.RegisterInfo(*reg_info) for reg_info in reg_infos]

    def get_by_flags(self, flags):
        """Iterate all register infos matching the given flags."""
        for reg in self._reg_infos:
            if reg.flags & flags == flags:
                yield reg

    def get_single_by_flags(self, flags):
        """Get the register info matching the flag. Raises ValueError if more than one are found."""
        regs = list(self.get_by_flags(flags))
        if len(regs) != 1:
            raise ValueError("Flags do not return unique resigter. {!r}", regs)

        return regs[0]

    @property
    def ip(self):
        """Instruction Pointer"""
        return self.get_single_by_flags(self.REGISTER_IP)

    pc = ip

    @property
    def sp(self):
        """Stack Pointer"""
        return self.get_single_by_flags(self.REGISTER_SP)

    @property
    def fp(self):
        """Frame Pointer"""
        return self.get_single_by_flags(self.REGISTER_FP)
```

`sark/enum.py`:

```py
import idaapi
import ida_typeinf
import idc
from . import exceptions
from contextlib import suppress

DEFMASK = -1

ENUM_ERROR_MAP = {
    ida_typeinf.TERR_BAD_NAME:
        (exceptions.SarkErrorEnumMemberName, "already have member with this name (bad name)"),
    ida_typeinf.TERR_BAD_VALUE:
        (exceptions.SarkErrorEnumMemberValue, "already have 256 members with this value"),
    ida_typeinf.TERR_BAD_TYPE:
        (exceptions.SarkErrorEnumMemberEnum, "bad typeid parameter"),
    ida_typeinf.TERR_BAD_BMASK:
        (exceptions.SarkErrorEnumMemberMask, "bad bmask"),
    ida_typeinf.TERR_BAD_MSKVAL:
        (exceptions.SarkErrorEnumMemberIllv, "bad bmask and value combination (~bmask & value != 0)"),
}


def _enum_member_error(err, tid, name, value, bitmask):
    """Format enum member error."""
    exception, msg = ENUM_ERROR_MAP[err]
    enum_name = idc.get_enum_name(tid)
    return exception(('add_enum_member(enum="{}", member="{}", value={}, bitmask=0x{:08X}) '
                      'failed: {}').format(
        enum_name,
        name,
        value,
        bitmask,
        msg
    ))


def _get_enum(name):
    """Get an existing enum type ID"""
    tid = idc.get_enum(name)
    if tid == idaapi.BADADDR:
        raise exceptions.EnumNotFound('Enum "{}" does not exist.'.format(name))
    return tid


def add_enum(name=None, index=None, flags=idaapi.hex_flag(), bitfield=False):
    """Create a new enum.

    Args:
        name: Name of the enum to create.
        index: The index of the enum. Leave at default to append the enum as the last enum.
        flags: Enum type flags.
        bitfield: Is the enum a bitfield.

    Returns:
        An `Enum` object.
    """
    if name is not None:
        with suppress(exceptions.EnumNotFound):
            _get_enum(name)
            raise exceptions.EnumAlreadyExists()

    # idx is not used anymore according to docs
    tid = idc.add_enum(0, name, flags)

    if tid == idaapi.BADADDR:
        raise exceptions.EnumCreationFailed('Failed creating enum "{}"'.format(name))

    if bitfield:
        idc.set_enum_bf(tid, bitfield)

    return Enum(tid=tid)


def remove_enum(name):
    """Delete an enum by name."""
    tid = _get_enum(name)
    idc.del_enum(tid)


def _add_enum_member(enum, name, value, bitmask=DEFMASK):
    """Add an enum member."""
    error = idc.add_enum_member(enum, name, value, bitmask)

    if error:
        raise _enum_member_error(error, enum, name, value, bitmask)


class EnumComments(object):
    """Enum comments retrieval and manipulation."""

    def __init__(self, tid):
        super(EnumComments, self).__init__()

        self._tid = tid

    @property
    def regular(self):
        return idc.get_enum_cmt(self._tid)

    @regular.setter
    def regular(self, comment):
        success = idc.set_enum_cmt(self._tid, comment, False)
        if not success:
            raise exceptions.CantSetEnumComment("Cant set enum comment.")

    @property
    def repeat(self):
        return idc.get_enum_cmt(self._tid)

    @repeat.setter
    def repeat(self, comment):
        success = idc.set_enum_cmt(self._tid, comment, True)
        if not success:
            raise exceptions.CantSetEnumComment("Cant set enum comment.")

    def __repr__(self):
        return ("EnumComments("
                "name={name!r},"
                " reqular={regular!r},"
                " repeat={repeat!r})").format(
            name=Enum(tid=self._tid).name,
            regular=self.regular,
            repeat=self.repeat, )


class EnumMembers(object):
    """Enum members retrieval and manipulation."""

    def __init__(self, tid):
        super(EnumMembers, self).__init__()
        self._tid = tid

    def __len__(self):
        """Number of members in the enum"""
        return idc.get_enum_size(self._tid)

    def __iter__(self):
        """Iterate all members of the enum"""
        return (EnumMember(cid) for cid in _iter_enum_constant_ids(self._tid))

    def add(self, name, value, bitmask=DEFMASK):
        """Add an enum member

        Args:
            name: Name of the member
            value: value of the member
            bitmask: bitmask. Only use if enum is a bitfield.
        """
        _add_enum_member(self._tid, name, value, bitmask)

    def __getitem__(self, name):
        """Get an enum member by name."""
        for enum_member in self:
            if enum_member.name == name:
                return enum_member
        raise KeyError("No member named {!r}".format(name))

    def remove(self, name):
        """Remove an enum member by name"""
        member = self[name]
        cid = member.cid
        value = member.value
        bmask = member.bmask

        success = idc.del_enum_member(self._tid, value, cid, bmask)
        if not success:
            raise exceptions.CantDeleteEnumMember("Can't delete enum member {!r}.".format(name))

    def __repr__(self):
        return "<EnumMembers(enum={!r}, members={{{}}})>".format(
            Enum(tid=self._tid).name,
            ", ".join("{member.name!r}: {member.value!r}".format(member=member) for member in self)
        )


class Enum(object):
    """An enum in the IDB"""

    def __init__(self, name=None, tid=None):
        """
        Get an existing enum.

        Only provide one of `name` and `tid`.

        Args:
            name: Name of the enum
            tid: Enum type ID
        """
        if None not in (name, tid):
            raise TypeError("Provide only a `name` or a `tid`.")

        self._tid = tid or _get_enum(name)
        self._comments = EnumComments(self._tid)

    @property
    def name(self):
        """Name of the enum"""
        return idc.get_enum_name(self.tid)

    @name.setter
    def name(self, name):
        """Set the enum name."""
        success = idc.set_enum_name(self.tid, name)
        if not success:
            raise exceptions.CantRenameEnum("Cant rename enum {!r} to {!r}.".format(self.name, name))

    @property
    def width(self):
        """Width of the enum"""
        return idc.get_enum_width(self.tid)

    @property
    def comments(self):
        """Enum comments"""
        return self._comments

    @property
    def tid(self):
        """Enum ID"""
        return self._tid

    @property
    def flag(self):
        """Enum flags (bitness, and display type)"""
        return idc.get_enum_flag(self.tid)

    @property
    def bitfield(self):
        """Is the enum a bitfield"""
        return idc.is_bf(self.tid)

    @bitfield.setter
    def bitfield(self, value):
        success = idc.set_enum_bf(self.tid, value)
        if not success:
            raise exceptions.CantSetEnumBitfield()

    @property
    def members(self):
        """Get the enum members."""
        return EnumMembers(self.tid)

    @property
    def is_from_til(self):
        """Is from type library?"""
        return ida_typeinf.get_tid_name(self.tid) is not None

    def __repr__(self):
        return "<Enum(name={!r})>".format(self.name)


class EnumMemberComments(object):
    """Enum member comments retrieval and manipulation."""

    def __init__(self, cid):
        super(EnumMemberComments, self).__init__()

        self._cid = cid

    @property
    def regular(self):
        return idc.get_enum_member_cmt(self._cid, False)

    @regular.setter
    def regular(self, comment):
        success = idc.set_enum_member_cmt(self._cid, comment, False)
        if not success:
            raise exceptions.CantSetEnumMemberComment("Cant set enum member comment.")

    @property
    def repeat(self):
        return idc.get_enum_member_cmt(self._cid, True)

    @repeat.setter
    def repeat(self, comment):
        success = idc.set_enum_member_cmt(self._cid, comment, True)
        if not success:
            raise exceptions.CantSetEnumMemberComment("Cant set enum member comment.")

    def __repr__(self):
        enum_member = EnumMember(self._cid)
        return ("EnumMemberComments("
                "name={name!r},"
                " reqular={regular!r},"
                " repeat={repeat!r})").format(
            name="{}.{}".format(enum_member.parent.name, enum_member.name),
            regular=self.regular,
            repeat=self.repeat, )


class EnumMember(object):
    """A member of an enum."""

    def __init__(self, cid):
        super(EnumMember, self).__init__()
        self._cid = cid
        self._comments = EnumMemberComments(self._cid)

    @property
    def cid(self):
        """Get the constant ID"""
        return self._cid

    @property
    def name(self):
        """Get the member name."""
        return idc.get_enum_member_name(self.cid)

    @name.setter
    def name(self, name):
        """Set the member name.

        Note that a member name cannot appear in other enums, or generally
        anywhere else in the IDB.
        """
        success = idc.set_enum_member_name(self.cid, name)
        if not success:
            raise exceptions.CantRenameEnumMember(
                "Failed renaming {!r} to {!r}. Does the name exist somewhere else?".format(self.name, name))

    @property
    def bmask(self):
        """Get the bitmask"""
        return idc.get_enum_member_bmask(self.cid)

    bitmask = bmask

    @property
    def value(self):
        """Get the member value"""
        return idc.get_enum_member_value(self.cid)

    @property
    def comments(self):
        """Get the member comments"""
        return self._comments

    @property
    def parent(self):
        """Get the enum holding the member."""
        return Enum(tid=idc.get_enum_member_enum(self.cid))

    def __repr__(self):
        return "<EnumMember(name='{}.{}')>".format(self.parent.name, self.name)


def _iter_bitmasks(tid):
    """Iterate all bitmasks in a given enum.

    Note that while `DEFMASK` indicates no-more-bitmasks, it is also a
    valid bitmask value. The only way to tell if it exists is when iterating
    the serials.
    """
    bitmask = idc.get_first_bmask(tid)

    yield bitmask

    while bitmask != DEFMASK:
        bitmask = idc.get_next_bmask(tid, bitmask)
        yield bitmask


def _iter_enum_member_values(tid, bitmask):
    """Iterate member values with given bitmask inside the enum

    Note that `DEFMASK` can either indicate end-of-values or a valid value.
    Iterate serials to tell apart.
    """
    value = idc.get_first_enum_member(tid, bitmask)

    yield value
    while value != DEFMASK:
        value = idc.get_next_enum_member(tid, value, bitmask)
        yield value


def _iter_enum_member_cid_with_bitmask(tid, bitmask):
    """Iterate serial and CID of enum members with given value and bitmask.

    Here only valid values are returned, as `idaapi.BADNODE` always indicates
    an invalid member.
    """
    cid = idc.get_first_enum_member(tid, bmask=bitmask)
    while cid != DEFMASK:
        yield cid
        cid = idc.get_next_enum_member(tid, cid, bmask=bitmask)


def _iter_enum_constant_ids(tid):
    """Iterate the constant IDs of all members in the given enum"""
    for bitmask in _iter_bitmasks(tid):
        for cid in _iter_enum_member_cid_with_bitmask(tid, bitmask):
            yield cid


def _iter_types():
    """Iterate all types in the database"""
    til = ida_typeinf.get_idati()
    # get_ordinal_count returns 0 when numbered types
    # aren't enabled in the database (according to docs).
    if ida_typeinf.get_ordinal_count() == 0:
        for named in til.named_types():
            yield named
    else:
        for numbered in til.numbered_types():
            yield numbered


def _iter_enum_ids():
    """Iterate the IDs of all enums in the IDB"""
    for t in _iter_types():
        if t.is_enum():
            yield t.get_tid()


def enums():
    """Iterate all enums in the IDB"""
    return (Enum(tid=tid) for tid in _iter_enum_ids())

```

`sark/exceptions.py`:

```py
class SarkException(Exception):
    pass


class SarkError(SarkException):
    pass


class SarkNoSelection(SarkError):
    pass


class SarkNoFunction(SarkError):
    pass


class SarkAddFunctionFailed(SarkError):
    pass


class SarkFunctionExists(SarkError):
    pass


class SarkStructError(SarkError):
    pass


class SarkInvalidRegisterName(SarkError):
    pass


class SarkStructAlreadyExists(SarkStructError):
    pass


class SarkStructCreationFailed(SarkStructError):
    pass


class SarkStructNotFound(SarkStructError):
    pass


class SarkErrorAddStructMemeberFailed(SarkStructError):
    pass


class SarkErrorStructMemberName(SarkErrorAddStructMemeberFailed):
    pass


class SarkErrorStructMemberOffset(SarkErrorAddStructMemeberFailed):
    pass


class SarkErrorStructMemberSize(SarkErrorAddStructMemeberFailed):
    pass


class SarkErrorStructMemberTinfo(SarkErrorAddStructMemeberFailed):
    pass


class SarkErrorStructMemberStruct(SarkErrorAddStructMemeberFailed):
    pass


class SarkErrorStructMemberUnivar(SarkErrorAddStructMemeberFailed):
    pass


class SarkErrorStructMemberVarlast(SarkErrorAddStructMemeberFailed):
    pass


class SarkEnumError(SarkError):
    pass


class SarkErrorAddEnumMemeberFailed(SarkEnumError):
    pass


class SarkErrorEnumMemberName(SarkErrorAddEnumMemeberFailed):
    pass


class SarkErrorEnumMemberValue(SarkErrorAddEnumMemeberFailed):
    pass


class SarkErrorEnumMemberEnum(SarkErrorAddEnumMemeberFailed):
    pass


class SarkErrorEnumMemberMask(SarkErrorAddEnumMemeberFailed):
    pass


class SarkErrorEnumMemberIllv(SarkErrorAddEnumMemeberFailed):
    pass


class EnumNotFound(SarkEnumError):
    pass


class EnumCreationFailed(SarkEnumError):
    pass


class EnumAlreadyExists(SarkEnumError):
    pass


class CantRenameEnumMember(SarkEnumError):
    pass


class CantSetEnumMemberComment(SarkEnumError):
    pass


class SarkErrorNameAlreadyExists(SarkError):
    pass


class SarkSetNameFailed(SarkError):
    pass


class SarkSwitchError(SarkError):
    pass


class SarkNotASwitch(SarkSwitchError):
    pass


class SarkNoInstruction(SarkError):
    pass


class SarkOperandError(SarkError):
    pass


class SarkOperandWithoutReg(SarkOperandError):
    pass


class CantSetEnumComment(SarkEnumError):
    pass


class CantDeleteEnumMember(SarkEnumError):
    pass


class CantSetEnumBitfield(SarkEnumError):
    pass


class CantRenameEnum(SarkEnumError):
    pass


class SarkGuiError(SarkError):
    pass


class SarkMenuError(SarkGuiError):
    pass


class MenuAlreadyExists(SarkMenuError):
    pass


class MenuNotFound(SarkMenuError):
    pass


class FormNotFound(SarkGuiError):
    pass


class InvalidStructOffset(SarkStructError):
    pass


class SegmentError(SarkError):
    pass


class NoMoreSegments(SegmentError):
    pass


class InvalidBitness(SegmentError):
    pass


class NoFileOffset(SarkError):
    pass


class SarkNoString(SarkError):
    pass


class SarkExpectedPatchedByte(SarkError):
    pass


class PhraseError(SarkOperandError):
    pass


class OperandNotPhrase(PhraseError):
    pass


class InvalidPhraseRegisters(PhraseError):
    pass


class PhraseNotSupported(PhraseError):
    pass


class PhraseProcessorNotSupported(PhraseNotSupported):
    pass


class SetTypeFailed(SarkError):
    def __init__(self, ea, c_signature):
        message = 'idc.SetType(ea={ea:08X}, "{c_signature}") failed'.format(ea=ea, c_signature=c_signature)
        super(SetTypeFailed, self).__init__(message)

```

`sark/graph.py`:

```py
import collections
import itertools
import networkx as nx
from .code.function import functions, Function
from contextlib import suppress
from . import exceptions


def lowest_common_ancestors(G, targets):
    common_ancestors = None
    all_ancestors = set()
    for target in targets:
        parents = set()
        q = collections.deque()
        q.append(target)

        while q:
            n = q.popleft()
            if n in parents:
                continue
            for p in G.predecessors(n):
                q.append(p)
            parents.add(n)

        all_ancestors.update(parents)

        if common_ancestors is None:
            common_ancestors = parents
        else:
            common_ancestors &= parents

    lowest_common = set()
    if common_ancestors is not None:
        for p in common_ancestors:
            if any(child not in common_ancestors and child in all_ancestors for child in G.successors(p)):
                lowest_common.add(p)

    return lowest_common


def _try_get_function_start(ea):
    with suppress(exceptions.SarkNoFunction):
        return Function(ea).start_ea

    return ea


def get_idb_graph():
    """Export IDB to a NetworkX graph.

    Use xrefs to and from functions to build a DiGraph containing all
    the functions in the IDB and all the links between them.
    The graph can later be used to perform analysis on the IDB.

    :return: nx.DiGraph()
    """
    digraph = nx.DiGraph()

    for function in functions():
        for xref in itertools.chain(function.xrefs_from, function.xrefs_to):
            frm = _try_get_function_start(xref.frm)
            to = _try_get_function_start(xref.to)

            digraph.add_edge(frm, to)

    return digraph


def get_lca_graph(G, targets, lca_sources=None):
    if lca_sources is None:
        lca_sources = lowest_common_ancestors(G, targets)

    lca_graph = nx.DiGraph()

    for source in lca_sources:
        for target in targets:
            path = nx.shortest_path(G, source, target)

            for frm, to in zip(path[:-1], path[1:]):
                lca_graph.add_edge(frm, to)

    return lca_graph
```

`sark/ipython.py`:

```py
from IPython import display

from .qt import capture_widget, get_window, get_widget

def snap(title=None):
    if title:
        w = get_widget(title)
    else:
        w = get_window()

    display.display_png(capture_widget(w), raw=True)
```

`sark/plumbing.py`:

```py
import os

SARK_PLUGINS_ENV_NAME = "sarkPlugins"

SARK_DEFAULT_PATH = os.path.normpath(os.path.join(os.path.dirname(__file__), "../"))

def get_sark_dir(dirname, envname=None):
    if envname in os.environ:
        return os.environ[envname]

    return os.path.join(SARK_DEFAULT_PATH, dirname)


def get_plugins_dir():
    return get_sark_dir("plugins", SARK_PLUGINS_ENV_NAME)


def get_codecs_dir():
    from sark import encodings
    return os.path.dirname(encodings.__file__)

CODECS_DIR = get_codecs_dir()
PLUGINS_DIR = get_plugins_dir()
```

`sark/qt.py`:

```py
import os
import sys

from PyQt5 import QtCore, QtWidgets, QtGui

import idaapi

from . import exceptions


def capture_widget(widget, path=None):
    """Grab an image of a Qt widget

    Args:
        widget: The Qt Widget to capture
        path (optional): The path to save to. If not provided - will return image data.

    Returns:
        If a path is provided, the image will be saved to it.
        If not, the PNG buffer will be returned.
    """
    pixmap = widget.grab()

    if path:
        pixmap.save(path)

    else:
        image_buffer = QtCore.QBuffer()
        image_buffer.open(QtCore.QIODevice.ReadWrite)

        pixmap.save(image_buffer, "PNG")

        return image_buffer.data().data()


def get_widget(title):
    """Get the Qt widget of the IDA window with the given title."""
    tform = idaapi.find_widget(title)
    if not tform:
        raise exceptions.FormNotFound("No form titled {!r} found.".format(title))

    return idaapi.PluginForm.FormToPyQtWidget(tform)


def resize_widget(widget, width, height):
    """Resize a Qt widget."""
    widget.setGeometry(0, 0, width, height)


def get_window():
    """Get IDA's top level window."""
    tform = idaapi.get_current_widget()

    # Required sometimes when closing IDBs and not IDA.
    if not tform:
        tform = idaapi.find_widget("Output window")

    widget = idaapi.PluginForm.FormToPyQtWidget(tform)
    window = widget.window()
    return window


class MenuManager(object):
    """IDA Menu Manipulation

    Use this class to add your own top-level menus.
    While this is discouraged by the SDK:

    > You should not change top level menu, or the Edit,Plugins submenus

    (documentation for `attach_action_to_menu`, kernwin.hpp)

    Adding top-level menus is useful sometimes.
    Nonetheless, you should be careful and make sure to remove all your menus
    when you are done. Leaving them handing would force users to restart IDA
    to remove them.

    Usage of this class should be as follows:

    >>> # Use the manager to add top-level menus
    >>> menu_manager = MenuManager()
    >>> menu_manager.add_menu("My Menu")
    >>> # Use the standard API to add menu items
    >>> idaapi.attach_action_to_menu("My Menu/", ":My-Action:", idaapi.SETMENU_APP)
    >>> # When a menu is not needed, remove it
    >>> menu_manager.remove_menu("My Menu")
    >>> # When you are done with the manager (and want to remove all menus you added,)
    >>> # clear it before deleting.
    >>> menu_manager.clear()
    """

    def __init__(self):
        super(MenuManager, self).__init__()

        self._window = get_window()
        self._menu = self._window.findChild(QtWidgets.QMenuBar)

        self._menus = {}

    def add_menu(self, name):
        """Add a top-level menu.

        The menu manager only allows one menu of the same name. However, it does
        not make sure that there are no pre-existing menus of that name.
        """
        if name in self._menus:
            raise exceptions.MenuAlreadyExists("Menu name {!r} already exists.".format(name))
        menu = self._menu.addMenu(name)
        self._menus[name] = menu

    def remove_menu(self, name):
        """Remove a top-level menu.

        Only removes menus created by the same menu manager.
        """
        if name not in self._menus:
            raise exceptions.MenuNotFound(
                "Menu {!r} was not found. It might be deleted, or belong to another menu manager.".format(name))

        self._menu.removeAction(self._menus[name].menuAction())
        del self._menus[name]

    def clear(self):
        """Clear all menus created by this manager."""
        for menu in self._menus.values():
            self._menu.removeAction(menu.menuAction())
        self._menus = {}

```

`sark/structure.py`:

```py
from collections import namedtuple, defaultdict
import operator

import idaapi
import idautils
import idc
import ida_typeinf

from . import exceptions
from .code import lines

FF_TYPES = [idc.FF_BYTE, idc.FF_WORD, idc.FF_DWORD, idc.FF_QWORD, idc.FF_OWORD, ]
FF_SIZES = [1, 2, 4, 8, 16, ]

SIZE_TO_TYPE = dict(zip(FF_SIZES, FF_TYPES))

STRUCT_ERROR_MAP = {
    ida_typeinf.TERR_BAD_NAME:
        (exceptions.SarkErrorStructMemberName, "already has member with this name (bad name)"),
    ida_typeinf.TERR_BAD_OFFSET:
        (exceptions.SarkErrorStructMemberOffset, "already has member at this offset"),
    ida_typeinf.TERR_BAD_SIZE:
        (exceptions.SarkErrorStructMemberSize, "bad number of bytes or bad sizeof(type)"),
    ida_typeinf.TERR_BAD_TYPE:
        (exceptions.SarkErrorStructMemberTinfo, "bad typeid parameter"),
    ida_typeinf.TERR_BAD_UNIVAR:
        (exceptions.SarkErrorStructMemberUnivar, "unions can't have variable sized members"),
    ida_typeinf.TERR_BAD_VARLAST:
        (exceptions.SarkErrorStructMemberVarlast, "variable sized member should be the last member in the structure"),
}


def struct_member_error(err, tid, name, offset, size):
    """Create and format a struct member exception.

    Args:
        err: The error value returned from struct member creation
        tid: The type id
        name: The member name
        offset: Memeber offset
        size: Member size

    Returns:
        A ``SarkErrorAddStructMemeberFailed`` derivative exception, with an
        informative message.
    """
    exception, msg = STRUCT_ERROR_MAP[err]
    struct_name = idaapi.get_tid_name(tid)
    return exception(('AddStructMember(struct="{}", member="{}", offset={}, size={}) '
                      'failed: {}').format(
        struct_name,
        name,
        offset,
        size,
        msg
    ))


def create_struct(name):
    """Create a structure.

    Args:
        name: The structure's name

    Returns:
        The sturct ID

    Raises:
        exceptions.SarkStructAlreadyExists: A struct with the same name already exists
        exceptions.SarkCreationFailed:  Struct creation failed
    """
    tid = idaapi.get_named_type_tid(name)
    if tid != idaapi.BADADDR:
        # The struct already exists.
        raise exceptions.SarkStructAlreadyExists("A struct names {!r} already exists.".format(name))

    tid = idaapi.tinfo_t.create_udt(idaapi.BADADDR, name, 0)
    if tid == idaapi.BADADDR:
        raise exceptions.SarkStructCreationFailed("Struct creation failed.")

    return tid


def get_struct(name):
    """Get a struct by it's name.

    Args:
        name: The name of the struct

    Returns:
        The struct's id

    Raises:
        exceptions.SarkStructNotFound: is the struct does not exist.
    """
    tid = idaapi.get_named_type_tid(name)
    if tid == idaapi.BADADDR:
        raise exceptions.SarkStructNotFound()

    return tid


def size_to_flags(size):
    return SIZE_TO_TYPE[size] | idc.FF_DATA


def add_struct_member(tid, name, offset, size):
    failure = idc.add_struc_member(tid, name, offset, size_to_flags(size), -1, size)

    if failure:
        raise struct_member_error(failure, tid, name, offset, size)


StructOffset = namedtuple("StructOffset", "offset size")
OperandRef = namedtuple("OperandRef", "ea n")


def infer_struct_offsets(start, end, reg_name):
    offsets = set()
    operands = []
    for line in lines(start, end):
        for operand in line.insn.operands:
            if not operand.has_reg(reg_name):
                continue

            if not operand.type.has_phrase:
                continue

            if not operand.base:
                continue

            offset = operand.offset
            if offset < 0:
                raise exceptions.InvalidStructOffset(
                    "Invalid structure offset 0x{:08X}, probably negative number.".format(offset))
            size = operand.size
            offsets.add(StructOffset(offset, size))
            operands.append(OperandRef(line.ea, operand.n))

    return offsets, operands


def get_common_register(start, end):
    """Get the register most commonly used in accessing structs.

    Access to is considered for every opcode that accesses memory
    in an offset from a register::

        mov eax, [ebx + 5]

    For every access, the struct-referencing registers, in this case
    `ebx`, are counted. The most used one is returned.

    Args:
        start: The adderss to start at
        end: The address to finish at
    """
    registers = defaultdict(int)
    for line in lines(start, end):
        insn = line.insn

        for operand in insn.operands:

            if not operand.type.has_phrase:
                continue

            if not operand.base:
                continue

            register_name = operand.base
            registers[register_name] += 1

    return max(registers.items(), key=operator.itemgetter(1))[0]


def offset_name(offset):
    """Format an offset into a name."""
    return "offset_{:X}".format(offset.offset)


def set_struct_offsets(offsets, tid):
    for offset in offsets:
        try:
            add_struct_member(tid,
                              offset_name(offset),
                              offset.offset,
                              offset.size)
        except exceptions.SarkErrorStructMemberName:
            # Get the offset of the member with the same name
            existing_offset = idc.get_member_offset(tid, offset_name(offset))
            if offset.offset == existing_offset:
                pass
            else:
                raise
        except exceptions.SarkErrorStructMemberOffset:
            # Get the size of the member at the same offset
            if offset.size == idc.get_member_size(tid, offset.offset):
                # If they are the same, all is well.
                pass


def create_struct_from_offsets(name, offsets):
    tid = create_struct(name)

    set_struct_offsets(offsets, tid)


def apply_struct(start, end, reg_name, struct_name):
    offsets, operands = infer_struct_offsets(start, end, reg_name)

    sid = get_struct(struct_name)

    for ea, n in operands:
        insn = idautils.DecodeInstruction(ea)
        idc.op_stroff(insn, n, sid, 0)


def selection_has_offsets(start, end):
    for line in lines(start, end):
        for operand in line.insn.operands:
            if not operand.type.has_phrase:
                continue
            if not operand.base:
                continue
            return True
    return False

```

`sark/ui.py`:

```py
import idaapi
import idc
from threading import RLock
import itertools
import wrapt
import traceback

if idaapi.is_idaq():
    # Only load Qt if we're in IDAQ.
    # This should allow running in IDAT.
    from .qt import MenuManager
    from PyQt5 import QtGui, QtWidgets

def ask_color(initial=None):
    if initial is not None:
        color = QtGui.QColor(initial & 0xFF, (initial >> 8) & 0xFF, (initial >> 16) & 0xFF)
        qcolor_dialog = QtWidgets.QColorDialog(color)

    else:
        qcolor_dialog = QtWidgets.QColorDialog()

    qcolor = qcolor_dialog.getColor()

    if not qcolor.isValid:
        return None

    return (qcolor.blue() << 16) | (qcolor.green() << 8) | (qcolor.red() << 0)


class Update(object):
    """
    A context manager that refreshes the UI on `__exit__`.

    When nested, only the topmost context manager can update the UI.
    This is used to make sure that UI-heavy code does not update the
    UI until it is finished.

    Note that this does not prevent updates via other APIs, so be sure
    to use this and the `updates_ui` decorator.
    """
    LOCK = RLock()

    def __enter__(self):
        self.LOCK.acquire(blocking=False)

    def __exit__(self, exc_type, exc_val, exc_tb):
        can_update = self.LOCK._is_owned()

        if can_update:
            idaapi.refresh_idaview_anyway()

        self.LOCK.release()


@wrapt.decorator
def updates_ui(wrapped, instance, args, kwargs):
    """Refresh UI on return."""
    with Update():
        return wrapped(*args, **kwargs)


class BasicNodeHandler(object):
    """Basic Node Handler

    This is the base class for all node handlers (for NXGraph).
    It implements usable defaults for all required events.

    When subclassing, simply replace the events you want to modify.
    """

    def on_get_text(self, value, attrs):
        """Get the text to display on the node.

        Args:
            value: The value of the current node.
            attrs (dict): The node's attributes.

        Returns:
            str: The text to display.
        """
        return str(value)

    def on_click(self, value, attrs):
        """Action to perform on click.

        Args:
            value: The value of the current node.
            attrs (dict): The node's attributes.

        Returns:
            ``True`` to accept the click, ``False`` to ignore it.
        """
        return False

    def on_double_click(self, value, attrs):
        """Action to perform on double click.

        Args:
            value: The value of the current node.
            attrs (dict): The node's attributes.

        Returns:
            ``True`` to accept the click, ``False`` to ignore it.
        """
        return False

    def on_hint(self, value, attrs):
        """Hint to show.

        Args:
            value: The value of the current node.
            attrs (dict): The node's attributes.

        Returns:
            The hint to show.
        """
        return None

    def on_bg_color(self, value, attrs):
        """Background color.

        Args:
            value: The value of the current node.
            attrs (dict): The node's attributes.

        Returns:
            ``None`` for default color, otherwise the color as a number.
        """
        return attrs.get(NXGraph.BG_COLOR, None)

    def on_frame_color(self, value, attrs):
        """Frame color.

        Args:
            value: The value of the current node.
            attrs (dict): The node's attributes.

        Returns:
            ``None`` for default color, otherwise the color as a number.
        """
        return attrs.get(NXGraph.FRAME_COLOR, None)


class AddressNodeHandler(BasicNodeHandler):
    """Address Node Handler

    Used to display addresses.
    In addition to the default functionality:
        1. Shows the name of an address (hex value if no name exists) instead of
            just the number;
        2. On double-click, jumps to the address clicked.
    """

    def on_get_text(self, value, attrs):
        name = idaapi.get_ea_name(value)
        demangle = getattr(idaapi, 'demangle_name2', idaapi.demangle_name)
        name = demangle(name, 0) or name
        return name or "0x{:08X}".format(value)

    def on_double_click(self, value, attrs):
        idaapi.jumpto(value)
        return False


class NXGraph(idaapi.GraphViewer):
    """NetworkX Graph Viewer

    A utility class for displaying NetworkX graphs inside IDA with ease.

    When showing a graph, the nodes and edges are iterated to create the graph structure.
    For every node, a "handler" is used to get display parameters:
        - Text to display
        - Background and Frame colors
        - Hint
        - Actions on click and double-click

    Handlers can be specified in one of 2 ways:
        1. By specifying the `handler` parameter to the constructor;
        2. By setting the `NXGraph.HANDLER` attribute of a specific node:

            >>> my_graph.nodes[my_node][NXGraph.HANDLER] = MyCustomHandler()

    Two other useful attribute are `NXGraph.BG_COLOR` and `NXGraph.FRAME_COLOR` that allow
    specifying colors for your nodes. If not provided, the default color will be used.
    Note that the handler is responsible for using those attributes, and can therefore
    modify their behaviour or ignore them completely.

    for more information about handlers see the `BasicNodeHandler` class.

    To display a graph, use:

        >>> viewer = sark.ui.NXGraph(my_graph, title="My Graph")
        >>> viewer.Show()


    To make the graph easier on the eye, node text is padded, adding empty space around it.
    `PADDING` is the default amount of padding to use in all directions.
    `PADDING_WIDTH` scales the padding width.
    To change the padding, simply provide the constructor with a padding to use.
    """
    PAD_WIDTH = 3
    PADDING = 1
    HANDLER = "HANDLER"
    BG_COLOR = "BG_COLOR"
    FRAME_COLOR = "FRAME_COLOR"
    DEFAULT_HANDLER = BasicNodeHandler()

    def __init__(self, graph, title="GraphViewer", handler=None, padding=PADDING):
        """Initialize the graph viewer.

        To avoid bizarre IDA errors (crashing when creating 2 graphs with the same title,)
        a counter is appended to the title (similar to "Hex View-1".)

        Args:
            graph: A NetworkX graph to display.
            title: The graph title.
            handler: The default node handler to use when accessing node data.
        """
        title = self._make_unique_title(title)

        idaapi.GraphViewer.__init__(self, title)

        self._graph = graph

        if handler is None:
            handler = self.DEFAULT_HANDLER

        # Here we make sure the handler is an instance of `BasicNodeHandler` or inherited
        # types. While generally being bad Python practice, we still need it here as an
        # invalid handler can cause IDA to crash.
        if not isinstance(handler, BasicNodeHandler):
            raise TypeError("Node handler must inherit from `BasicNodeHandler`.")

        self._default_handler = handler
        self._padding = padding

    def _pad(self, text):
        """Pad the text."""
        top_bottom = ("\n" * self._padding) + " "
        right_left = " " * self._padding * self.PAD_WIDTH
        return top_bottom + right_left + text + right_left + top_bottom

    def _make_unique_title(self, title):
        """Make the title unique.

        Adds a counter to the title to prevent duplicates.

        Prior to IDA 6.8, two graphs with the same title could crash IDA.
        This has been fixed (https://www.hex-rays.com/products/ida/6.8/index.shtml).
        The code will not change for support of older versions and as it is
        more usable this way.
        """
        unique_title = title

        for counter in itertools.count():
            unique_title = "{}-{}".format(title, counter)
            if not idaapi.find_widget(unique_title):
                break

        return unique_title

    def _get_handler(self, node_id):
        """Get the handler of a given node."""
        handler = self._get_attrs(node_id).get(self.HANDLER, self._default_handler)

        # Here we make sure the handler is an instance of `BasicNodeHandler` or inherited
        # types. While generally being bad Python practice, we still need it here as an
        # invalid handler can cause IDA to crash.
        if not isinstance(handler, BasicNodeHandler):
            idaapi.msg(("Invalid handler for node {}: {}. All handlers must inherit from"
                        "`BasicNodeHandler`.").format(node_id, handler))
            handler = self._default_handler
        return handler

    def _get_attrs(self, node_id):
        """Get the node's attributes"""
        return self._graph.nodes[self[node_id]]

    def _get_handling_triplet(self, node_id):
        """_get_handling_triplet(node_id) -> (handler, value, attrs)"""
        handler = self._get_handler(node_id)
        value = self[node_id]
        attrs = self._get_attrs(node_id)

        return handler, value, attrs

    def _OnNodeInfo(self, node_id):
        """Sets the node info based on its attributes."""
        handler, value, attrs = self._get_handling_triplet(node_id)
        frame_color = handler.on_frame_color(value, attrs)

        node_info = idaapi.node_info_t()

        if frame_color is not None:
            node_info.frame_color = frame_color

        flags = node_info.get_flags_for_valid()

        self.SetNodeInfo(node_id, node_info, flags)

    def update_node_info(self):
        """Sets the node info for all nodes."""
        for node_id, node in enumerate(self):
            self._OnNodeInfo(node_id)

    def OnGetText(self, node_id):
        handler, value, attrs = self._get_handling_triplet(node_id)
        self._OnNodeInfo(node_id)
        return (self._pad(handler.on_get_text(value, attrs)), handler.on_bg_color(value, attrs))

    def Show(self):
        if not idaapi.GraphViewer.Show(self):
            return False

        return True

    def OnRefresh(self):
        self.Clear()

        # Compatibility between NetworkX 1.x and 2.x
        try:
            graph_nodes_iter = self._graph.nodes()
            graph_edges_iter = self._graph.edges()
        except AttributeError:
            graph_nodes_iter = self._graph.nodes_iter()
            graph_edges_iter = self._graph.edges_iter()

        node_ids = {node: self.AddNode(node) for node in graph_nodes_iter}

        for frm, to in graph_edges_iter:
            self.AddEdge(node_ids[frm], node_ids[to])

        self.update_node_info()

        return True

    def OnActivate(self):
        # Refresh on every activation to keep the graph up to date.
        self.Refresh()
        return True

    def OnDeactivate(self):
        pass

    def OnDblClick(self, node_id):
        handler, value, attrs = self._get_handling_triplet(node_id)
        return handler.on_double_click(value, attrs)

    def OnClick(self, node_id):
        handler, value, attrs = self._get_handling_triplet(node_id)
        return handler.on_click(value, attrs)

    def OnHint(self, node_id):
        handler, value, attrs = self._get_handling_triplet(node_id)
        return handler.on_hint(value, attrs)


class ActionHandler(idaapi.action_handler_t):
    """A wrapper around `idaapi.action_handler_t`.

    The class simplifies the creation of UI actions in IDA >= 6.7.

    To create an action, simply create subclass and override the relevant fields
    and register it::

        class MyAction(ActionHandler):
            TEXT = "My Action"
            HOTKEY = "Alt+Z"

            def _activate(self, ctx):
                idaapi.msg("Activated!")

        MyAction.register()

    Additional Documentation:
        Introduction to `idaapi.action_handler_t`:
            http://www.hexblog.com/?p=886

        Return values for update (from the SDK):
            AST_ENABLE_ALWAYS     // enable action and do not call action_handler_t::update() anymore
            AST_ENABLE_FOR_IDB    // enable action for the current idb. Call action_handler_t::update() when a database is opened/closed
            AST_ENABLE_FOR_WIDGET // enable action for the current widget. Call action_handler_t::update() when a form gets/loses focus
            AST_ENABLE            // enable action - call action_handler_t::update() when anything changes

            AST_DISABLE_ALWAYS    // disable action and do not call action_handler_t::action() anymore
            AST_DISABLE_FOR_IDB   // analog of ::AST_ENABLE_FOR_IDB
            AST_DISABLE_FOR_WIDGET// analog of ::AST_ENABLE_FOR_WIDGET
            AST_DISABLE           // analog of ::AST_ENABLE
    """
    NAME = None
    TEXT = "Default. Replace me!"
    HOTKEY = ""
    TOOLTIP = ""
    ICON = -1

    @classmethod
    def get_name(cls):
        """Return the name of the action.

        If a name has not been set (using the `Name` class variable), the
        function generates a name based on the class name and id.
        :return: action name
        :rtype: str
        """
        if cls.NAME is not None:
            return cls.NAME

        return "{}:{}".format(cls.__name__, id(cls))

    @classmethod
    def get_desc(cls):
        """Get a descriptor for this handler."""
        name = cls.get_name()
        text = cls.TEXT
        handler = cls()
        hotkey = cls.HOTKEY
        tooltip = cls.TOOLTIP
        icon = cls.ICON
        action_desc = idaapi.action_desc_t(
            name,
            text,
            handler,
            hotkey,
            tooltip,
            icon,
        )
        return action_desc

    @classmethod
    def register(cls):
        """Register the action.

        Each action MUST be registered before it can be used. To remove the action
        use the `unregister` method.
        """
        action_desc = cls.get_desc()

        return idaapi.register_action(action_desc)

    @classmethod
    def unregister(cls):
        """Unregister the action.

        After unregistering the class cannot be used.
        """
        idaapi.unregister_action(cls.get_name())

    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        try:
            self._activate(ctx)
            return 1
        except:
            trace = traceback.format_exc()
            idaapi.msg("Action {!r} failed to activate. Traceback:\n{}".format(self.get_name(), trace))
            return 0

    def update(self, ctx):
        """Update the action.

        Optionally override this function.
        See IDA-SDK for more information.
        """
        return idaapi.AST_ENABLE_ALWAYS

    def _activate(self, ctx):
        """Activate the action.

        This function contains the action code itself. You MUST implement
        it in your class for the action to work.

        Args:
            ctx: The action context passed from IDA.
        """
        raise NotImplementedError()

```

`tests/README.rst`:

```rst
==========
Sark Tests
==========


Running The Tests
-----------------

First, inside ``tests/config.json`` set ``IDAPATH`` to point to your IDA executable.

Then, make sure ``approvaltests`` and ``keystone-engine`` are installed

.. code:: bash

    pip3 install approvaltests keystone-engine

Then, run the following:

.. code:: bash

    py -3 tests/tests.py
```

`tests/approvaltests_config.json`:

```json
{
  "subdirectory": "approved_files"
}
```

`tests/approved_files/SimpleTest.test_codeblocks.approved.txt`:

```txt
**********************************************************************
Function(name=".init_proc", addr=0x004003C8)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004003C8, end_ea=0x004003D8)>
    color = None
    end_ea = 4195288
    id = 0
    start_ea = 4195272
    type = 0
    prev = []
    next = [<CodeBlock(start_ea=0x004003D8, end_ea=0x004003DA)>, <CodeBlock(start_ea=0x004003DA, end_ea=0x004003DF)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004003D8, end_ea=0x004003DA)>
    color = None
    end_ea = 4195290
    id = 1
    start_ea = 4195288
    type = 0
    prev = [<CodeBlock(start_ea=0x004003C8, end_ea=0x004003D8)>]
    next = [<CodeBlock(start_ea=0x004003DA, end_ea=0x004003DF)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004003DA, end_ea=0x004003DF)>
    color = None
    end_ea = 4195295
    id = 2
    start_ea = 4195290
    type = 2
    prev = [<CodeBlock(start_ea=0x004003C8, end_ea=0x004003D8)>, <CodeBlock(start_ea=0x004003D8, end_ea=0x004003DA)>]
    next = []
**********************************************************************
Function(name="sub_4003E0", addr=0x004003E0)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004003E0, end_ea=0x004003EC)>
    color = None
    end_ea = 4195308
    id = 0
    start_ea = 4195296
    type = 1
    prev = []
    next = []
**********************************************************************
Function(name=".puts", addr=0x004003F0)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004003F0, end_ea=0x004003F6)>
    color = None
    end_ea = 4195318
    id = 0
    start_ea = 4195312
    type = 1
    prev = []
    next = []
**********************************************************************
Function(name="_start", addr=0x00400400)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400400, end_ea=0x0040042B)>
    color = None
    end_ea = 4195371
    id = 0
    start_ea = 4195328
    type = 0
    prev = []
    next = []
**********************************************************************
Function(name="_dl_relocate_static_pie", addr=0x00400430)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400430, end_ea=0x00400432)>
    color = None
    end_ea = 4195378
    id = 0
    start_ea = 4195376
    type = 2
    prev = []
    next = []
**********************************************************************
Function(name="deregister_tm_clones", addr=0x00400440)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400440, end_ea=0x00400451)>
    color = None
    end_ea = 4195409
    id = 0
    start_ea = 4195392
    type = 0
    prev = []
    next = [<CodeBlock(start_ea=0x00400451, end_ea=0x0040045B)>, <CodeBlock(start_ea=0x00400468, end_ea=0x0040046A)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400451, end_ea=0x0040045B)>
    color = None
    end_ea = 4195419
    id = 1
    start_ea = 4195409
    type = 0
    prev = [<CodeBlock(start_ea=0x00400440, end_ea=0x00400451)>]
    next = [<CodeBlock(start_ea=0x0040045B, end_ea=0x00400463)>, <CodeBlock(start_ea=0x00400468, end_ea=0x0040046A)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x0040045B, end_ea=0x00400463)>
    color = None
    end_ea = 4195427
    id = 2
    start_ea = 4195419
    type = 1
    prev = [<CodeBlock(start_ea=0x00400451, end_ea=0x0040045B)>]
    next = []
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400468, end_ea=0x0040046A)>
    color = None
    end_ea = 4195434
    id = 3
    start_ea = 4195432
    type = 2
    prev = [<CodeBlock(start_ea=0x00400440, end_ea=0x00400451)>, <CodeBlock(start_ea=0x00400451, end_ea=0x0040045B)>]
    next = []
**********************************************************************
Function(name="register_tm_clones", addr=0x00400470)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400470, end_ea=0x00400493)>
    color = None
    end_ea = 4195475
    id = 0
    start_ea = 4195440
    type = 0
    prev = []
    next = [<CodeBlock(start_ea=0x00400493, end_ea=0x0040049D)>, <CodeBlock(start_ea=0x004004A8, end_ea=0x004004AA)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400493, end_ea=0x0040049D)>
    color = None
    end_ea = 4195485
    id = 1
    start_ea = 4195475
    type = 0
    prev = [<CodeBlock(start_ea=0x00400470, end_ea=0x00400493)>]
    next = [<CodeBlock(start_ea=0x0040049D, end_ea=0x004004A5)>, <CodeBlock(start_ea=0x004004A8, end_ea=0x004004AA)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x0040049D, end_ea=0x004004A5)>
    color = None
    end_ea = 4195493
    id = 2
    start_ea = 4195485
    type = 1
    prev = [<CodeBlock(start_ea=0x00400493, end_ea=0x0040049D)>]
    next = []
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004004A8, end_ea=0x004004AA)>
    color = None
    end_ea = 4195498
    id = 3
    start_ea = 4195496
    type = 2
    prev = [<CodeBlock(start_ea=0x00400470, end_ea=0x00400493)>, <CodeBlock(start_ea=0x00400493, end_ea=0x0040049D)>]
    next = []
**********************************************************************
Function(name="__do_global_dtors_aux", addr=0x004004B0)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004004B0, end_ea=0x004004B9)>
    color = None
    end_ea = 4195513
    id = 0
    start_ea = 4195504
    type = 0
    prev = []
    next = [<CodeBlock(start_ea=0x004004B9, end_ea=0x004004CB)>, <CodeBlock(start_ea=0x004004D0, end_ea=0x004004D2)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004004B9, end_ea=0x004004CB)>
    color = None
    end_ea = 4195531
    id = 1
    start_ea = 4195513
    type = 2
    prev = [<CodeBlock(start_ea=0x004004B0, end_ea=0x004004B9)>]
    next = []
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004004D0, end_ea=0x004004D2)>
    color = None
    end_ea = 4195538
    id = 2
    start_ea = 4195536
    type = 2
    prev = [<CodeBlock(start_ea=0x004004B0, end_ea=0x004004B9)>]
    next = []
**********************************************************************
Function(name="frame_dummy", addr=0x004004E0)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004004E0, end_ea=0x004004E7)>
    color = None
    end_ea = 4195559
    id = 0
    start_ea = 4195552
    type = 0
    prev = []
    next = [<CodeBlock(start_ea=0x00400470, end_ea=0x00400470)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400470, end_ea=0x00400470)>
    color = None
    end_ea = 4195440
    id = 1
    start_ea = 4195440
    type = 6
    prev = [<CodeBlock(start_ea=0x004004E0, end_ea=0x004004E7)>]
    next = []
**********************************************************************
Function(name="main", addr=0x004004F0)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x004004F0, end_ea=0x0040051B)>
    color = None
    end_ea = 4195611
    id = 0
    start_ea = 4195568
    type = 2
    prev = []
    next = []
**********************************************************************
Function(name="__libc_csu_init", addr=0x00400520)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400520, end_ea=0x00400556)>
    color = None
    end_ea = 4195670
    id = 0
    start_ea = 4195616
    type = 0
    prev = []
    next = [<CodeBlock(start_ea=0x00400556, end_ea=0x00400560)>, <CodeBlock(start_ea=0x00400576, end_ea=0x00400585)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400556, end_ea=0x00400560)>
    color = None
    end_ea = 4195680
    id = 1
    start_ea = 4195670
    type = 0
    prev = [<CodeBlock(start_ea=0x00400520, end_ea=0x00400556)>]
    next = [<CodeBlock(start_ea=0x00400560, end_ea=0x00400576)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400560, end_ea=0x00400576)>
    color = None
    end_ea = 4195702
    id = 2
    start_ea = 4195680
    type = 0
    prev = [<CodeBlock(start_ea=0x00400556, end_ea=0x00400560)>, <CodeBlock(start_ea=0x00400560, end_ea=0x00400576)>]
    next = [<CodeBlock(start_ea=0x00400576, end_ea=0x00400585)>, <CodeBlock(start_ea=0x00400560, end_ea=0x00400576)>]
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400576, end_ea=0x00400585)>
    color = None
    end_ea = 4195717
    id = 3
    start_ea = 4195702
    type = 2
    prev = [<CodeBlock(start_ea=0x00400520, end_ea=0x00400556)>, <CodeBlock(start_ea=0x00400560, end_ea=0x00400576)>]
    next = []
**********************************************************************
Function(name="__libc_csu_fini", addr=0x00400590)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400590, end_ea=0x00400592)>
    color = None
    end_ea = 4195730
    id = 0
    start_ea = 4195728
    type = 2
    prev = []
    next = []
**********************************************************************
Function(name=".term_proc", addr=0x00400594)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00400594, end_ea=0x0040059D)>
    color = None
    end_ea = 4195741
    id = 0
    start_ea = 4195732
    type = 2
    prev = []
    next = []
**********************************************************************
Function(name="puts", addr=0x00601040)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00601040, end_ea=0x00601048)>
    color = None
    end_ea = 6295624
    id = 0
    start_ea = 6295616
    type = 2
    prev = []
    next = []
**********************************************************************
Function(name="__libc_start_main", addr=0x00601048)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00601048, end_ea=0x00601050)>
    color = None
    end_ea = 6295632
    id = 0
    start_ea = 6295624
    type = 2
    prev = []
    next = []
**********************************************************************
Function(name="__gmon_start__", addr=0x00601050)
----------------------------------------------------------------------
<CodeBlock(start_ea=0x00601050, end_ea=0x00601058)>
    color = None
    end_ea = 6295640
    id = 0
    start_ea = 6295632
    type = 2
    prev = []
    next = []

```

`tests/approved_files/SimpleTest.test_comments.approved.txt`:

```txt
Comments(func=main, reqular='This is a function comment', repeat='This is a repeatable function comment')
    regular = This is a function comment
    repeat = This is a repeatable function comment
Comments(ea=0x004004F0, reqular='This is a regular comment', repeat=None, anterior='This is an anterior comment', posterior='This is a posterior comment')
    anterior = This is an anterior comment
    posterior = This is a posterior comment
    regular = This is a regular comment
    repeat = None
Comments(ea=0x004004F1, reqular=None, repeat='This is a repeatable comment', anterior='', posterior='')
    anterior = 
    posterior = 
    regular = None
    repeat = This is a repeatable comment
Comments(ea=0x004004F4, reqular=None, repeat=None, anterior='', posterior='')
    anterior = 
    posterior = 
    regular = None
    repeat = None
Comments(ea=0x004004F8, reqular=None, repeat=None, anterior='This is a long anterior comment.\nIt has multiple lines.\n\nThere are also gaps between them.\n\n\n\n\n\nIt is very long.', posterior='')
    anterior = This is a long anterior comment.
It has multiple lines.

There are also gaps between them.





It is very long.
    posterior = 
    regular = None
    repeat = None
Comments(ea=0x004004FF, reqular=None, repeat=None, anterior='', posterior='')
    anterior = 
    posterior = 
    regular = None
    repeat = None
Comments(ea=0x00400509, reqular=None, repeat=None, anterior='', posterior='')
    anterior = 
    posterior = 
    regular = None
    repeat = None
Comments(ea=0x0040050E, reqular=None, repeat=None, anterior='', posterior='')
    anterior = 
    posterior = 
    regular = None
    repeat = None
Comments(ea=0x00400510, reqular=None, repeat=None, anterior='', posterior='')
    anterior = 
    posterior = 
    regular = None
    repeat = None
Comments(ea=0x00400513, reqular=None, repeat=None, anterior='', posterior='')
    anterior = 
    posterior = 
    regular = None
    repeat = None
Comments(ea=0x00400515, reqular=None, repeat=None, anterior='', posterior='')
    anterior = 
    posterior = 
    regular = None
    repeat = None
Comments(ea=0x00400519, reqular=None, repeat=None, anterior='', posterior='')
    anterior = 
    posterior = 
    regular = None
    repeat = None
Comments(ea=0x0040051A, reqular=None, repeat=None, anterior='', posterior='')
    anterior = 
    posterior = 
    regular = None
    repeat = None

```

`tests/approved_files/SimpleTest.test_data.approved.txt`:

```txt
Bytes
[127, 69, 76, 70, 2, 1, 1, 0, 0, 0]

Bytes Until 0
[127, 69, 76, 70, 2, 1, 1]

Words
[17791, 17996, 258, 1, 0, 0, 0, 0, 2, 62]

Words Until 0
[17791, 17996, 258, 1]

DWords
[1179403647, 65794, 0, 0, 4063234, 1, 4195328, 0, 64, 0]

DWords Until 0
[1179403647, 65794]

QWords
[282584257676671, 0, 4299030530, 4195328, 64, 6432, 15762873573703680, 7881423906144265, 17179869190, 64]

QWords Until 0
[282584257676671]

Native Words
[282584257676671, 0, 4299030530, 4195328, 64, 6432, 15762873573703680, 7881423906144265, 17179869190, 64]

Native Words Until 0
[282584257676671]

Chars
['\x7f', 'E', 'L', 'F', '\x02', '\x01', '\x01', '\x00', '\x00', '\x00']

Chars Until \0
['\x7f', 'E', 'L', 'F', '\x02', '\x01', '\x01']

Read ascii string
'Hello, World!'

Get String
b'Hello, World!'

```

`tests/approved_files/SimpleTest.test_enum.approved.txt`:

```txt
<Enum(name='FunLittleEnum')>
    bitfield = False
    comments = EnumComments(name='FunLittleEnum', reqular=None, repeat=None)
    flag = 1179648
    is_from_til = True
    name = FunLittleEnum
    tid = 18374686479671623820
    width = 4

```

`tests/approved_files/SimpleTest.test_functions.approved.txt`:

```txt
Function(name=".init_proc", addr=0x004003C8)
    color = None
    comments = Comments(func=.init_proc, reqular=None, repeat=None)
    demangled = .init_proc
    ea = 4195272
    end_ea = 4195295
    flags = 21504
    frame_size = 16
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = True
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = .init_proc
    signature = None
    start_ea = 4195272
    tinfo = None
Function(name="sub_4003E0", addr=0x004003E0)
    color = None
    comments = Comments(func=sub_4003E0, reqular=None, repeat=None)
    demangled = sub_4003E0
    ea = 4195296
    end_ea = 4195308
    flags = 5120
    frame_size = 8
    has_name = False
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = False
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = sub_4003E0
    signature = None
    start_ea = 4195296
    tinfo = None
Function(name=".puts", addr=0x004003F0)
    color = None
    comments = Comments(func=.puts, reqular=None, repeat=None)
    demangled = .puts
    ea = 4195312
    end_ea = 4195318
    flags = 5312
    frame_size = 8
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = True
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = False
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = True
    is_user_far = False
    name = .puts
    signature = int(const char *s)
    start_ea = 4195312
    tinfo = (b'\x0c\x11\x07\x02\nr', b'\x02s')
Function(name="_start", addr=0x00400400)
    color = None
    comments = Comments(func=_start, reqular=None, repeat=None)
    demangled = _start
    ea = 4195328
    end_ea = 4195371
    flags = 7169
    frame_size = 8
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = True
    is_noret_pending = False
    is_purged_ok = False
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = _start
    signature = None
    start_ea = 4195328
    tinfo = None
Function(name="_dl_relocate_static_pie", addr=0x00400430)
    color = None
    comments = Comments(func=_dl_relocate_static_pie, reqular=None, repeat=None)
    demangled = _dl_relocate_static_pie
    ea = 4195376
    end_ea = 4195378
    flags = 21504
    frame_size = 8
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = True
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = _dl_relocate_static_pie
    signature = None
    start_ea = 4195376
    tinfo = None
Function(name="deregister_tm_clones", addr=0x00400440)
    color = None
    comments = Comments(func=deregister_tm_clones, reqular=None, repeat=None)
    demangled = deregister_tm_clones
    ea = 4195392
    end_ea = 4195434
    flags = 21520
    frame_size = 16
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = True
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = True
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = deregister_tm_clones
    signature = None
    start_ea = 4195392
    tinfo = None
Function(name="register_tm_clones", addr=0x00400470)
    color = None
    comments = Comments(func=register_tm_clones, reqular=None, repeat=None)
    demangled = register_tm_clones
    ea = 4195440
    end_ea = 4195498
    flags = 21520
    frame_size = 16
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = True
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = True
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = register_tm_clones
    signature = None
    start_ea = 4195440
    tinfo = None
Function(name="__do_global_dtors_aux", addr=0x004004B0)
    color = None
    comments = Comments(func=__do_global_dtors_aux, reqular=None, repeat=None)
    demangled = __do_global_dtors_aux
    ea = 4195504
    end_ea = 4195538
    flags = 21504
    frame_size = 8
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = True
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = __do_global_dtors_aux
    signature = None
    start_ea = 4195504
    tinfo = None
Function(name="frame_dummy", addr=0x004004E0)
    color = None
    comments = Comments(func=frame_dummy, reqular=None, repeat=None)
    demangled = frame_dummy
    ea = 4195552
    end_ea = 4195559
    flags = 21520
    frame_size = 16
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = True
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = True
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = frame_dummy
    signature = None
    start_ea = 4195552
    tinfo = None
Function(name="main", addr=0x004004F0)
    color = None
    comments = Comments(func=main, reqular='This is a function comment', repeat='This is a repeatable function comment')
    demangled = main
    ea = 4195568
    end_ea = 4195611
    flags = 21520
    frame_size = 32
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = True
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = True
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = main
    signature = int __cdecl(int argc, const char **argv, const char **envp)
    start_ea = 4195568
    tinfo = (b'\x0c1\x07\x04\x07\n\nr\n\nr', b'\x05argc\x05argv\x05envp')
Function(name="__libc_csu_init", addr=0x00400520)
    color = None
    comments = Comments(func=__libc_csu_init, reqular=None, repeat=None)
    demangled = __libc_csu_init
    ea = 4195616
    end_ea = 4195717
    flags = 21504
    frame_size = 64
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = True
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = __libc_csu_init
    signature = void(void)
    start_ea = 4195616
    tinfo = (b'\x0c!\x01', b'')
Function(name="__libc_csu_fini", addr=0x00400590)
    color = None
    comments = Comments(func=__libc_csu_fini, reqular=None, repeat=None)
    demangled = __libc_csu_fini
    ea = 4195728
    end_ea = 4195730
    flags = 21504
    frame_size = 8
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = True
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = __libc_csu_fini
    signature = void(void)
    start_ea = 4195728
    tinfo = (b'\x0c!\x01', b'')
Function(name=".term_proc", addr=0x00400594)
    color = None
    comments = Comments(func=.term_proc, reqular=None, repeat=None)
    demangled = .term_proc
    ea = 4195732
    end_ea = 4195741
    flags = 21504
    frame_size = 16
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = True
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = .term_proc
    signature = None
    start_ea = 4195732
    tinfo = None
Function(name="puts", addr=0x00601040)
    color = None
    comments = Comments(func=puts, reqular=None, repeat=None)
    demangled = puts
    ea = 6295616
    end_ea = 6295624
    flags = 5120
    frame_size = 8
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = False
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = puts
    signature = int(const char *s)
    start_ea = 6295616
    tinfo = (b'\x0c\x11\x07\x02\nr', b'\x02s')
Function(name="__libc_start_main", addr=0x00601048)
    color = None
    comments = Comments(func=__libc_start_main, reqular=None, repeat=None)
    demangled = __libc_start_main
    ea = 6295624
    end_ea = 6295632
    flags = 5120
    frame_size = 8
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = False
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = __libc_start_main
    signature = int __cdecl(int (__cdecl *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end)
    start_ea = 6295624
    tinfo = (b'\x0c1\x07\x08\n\x0c1\x07\x04\x07\n\n2\n\n2\x07\n\n2\n\x0c!\x01\n\x0c!\x01\n\x0c!\x01\n\x01', b'\x05main\x01\x01\x01\x05argc\x07ubp_av\x05init\x05fini\nrtld_fini\nstack_end')
Function(name="__gmon_start__", addr=0x00601050)
    color = None
    comments = Comments(func=__gmon_start__, reqular=None, repeat=None)
    demangled = __gmon_start__
    ea = 6295632
    end_ea = 6295640
    flags = 5120
    frame_size = 8
    has_name = True
    is_bottom_bp = False
    is_far = False
    is_frame = False
    is_hidden = False
    is_library = False
    is_noret = False
    is_noret_pending = False
    is_purged_ok = False
    is_sp_ready = True
    is_static = False
    is_tail = False
    is_thunk = False
    is_user_far = False
    name = __gmon_start__
    signature = None
    start_ea = 6295632
    tinfo = None

```

`tests/approved_files/SimpleTest.test_idat_data_dumper.approved.txt`:

```txt
Bytes
[127, 69, 76, 70, 2, 1, 1, 0, 0, 0]

Bytes Until 0
[127, 69, 76, 70, 2, 1, 1]

Words
[17791, 17996, 258, 1, 0, 0, 0, 0, 2, 62]

Words Until 0
[17791, 17996, 258, 1]

DWords
[1179403647, 65794, 0, 0, 4063234, 1, 4195328, 0, 64, 0]

DWords Until 0
[1179403647, 65794]

QWords
[282584257676671, 0, 4299030530, 4195328, 64, 6432, 15762873573703680, 7881423906144265, 17179869190, 64]

QWords Until 0
[282584257676671]

Native Words
[282584257676671, 0, 4299030530, 4195328, 64, 6432, 15762873573703680, 7881423906144265, 17179869190, 64]

Native Words Until 0
[282584257676671]

Chars
['\x7f', 'E', 'L', 'F', '\x02', '\x01', '\x01', '\x00', '\x00', '\x00']

Chars Until \0
['\x7f', 'E', 'L', 'F', '\x02', '\x01', '\x01']

Read ascii string
'Hello, World!'

Get String
b'Hello, World!'

```

`tests/approved_files/SimpleTest.test_instructions.approved.txt`:

```txt
**********************************************************************
[004004F0]    push    rbp; This is a regular comment
<Instruction at 0x004004f0>
    feature = 65792
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = push
    operands = [<Operand(n=0, text='rbp')>]
    regs = {'rbp'}

----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
**********************************************************************
[004004F1]    mov     rbp, rsp; This is a repeatable comment
<Instruction at 0x004004f1>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='rbp')>, <Operand(n=1, text='rsp')>]
    regs = {'rbp', 'rsp'}

----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
----------------------------------------------------------------------
rsp
    addr = 0
    base = rsp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = rsp
    reg_id = 4
    regs = {'rsp'}
    scale = None
    size = 8
    text = rsp
    type = General_Register
    value = 0
**********************************************************************
[004004F4]    sub     rsp, 10h
<Instruction at 0x004004f4>
    feature = 66308
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = sub
    operands = [<Operand(n=0, text='rsp')>, <Operand(n=1, text='10h')>]
    regs = {'rsp'}

----------------------------------------------------------------------
rsp
    addr = 0
    base = rsp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = True
    n = 0
    offset = 0
    reg = rsp
    reg_id = 4
    regs = {'rsp'}
    scale = None
    size = 8
    text = rsp
    type = General_Register
    value = 0
----------------------------------------------------------------------
10h
    addr = 0
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 16
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 8
    text = 10h
    type = Immediate_Value
    value = 16
**********************************************************************
[004004F8]    mov     [rbp+var_4], 0
<Instruction at 0x004004f8>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='[rbp+var_4]')>, <Operand(n=1, text='0')>]
    regs = {'rbp'}

----------------------------------------------------------------------
[rbp+var_4]
    addr = 18446744073709551612
    base = rbp
    displacement = 18446744073709551612
    dtype = 2
    flags = 8
    has_displacement = True
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 18446744073709551612
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = 1
    size = 4
    text = [rbp+var_4]
    type = Memory_Displacement
    value = 0
----------------------------------------------------------------------
0
    addr = 0
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 4
    text = 0
    type = Immediate_Value
    value = 0
**********************************************************************
[004004FF]    mov     rdi, offset s; "Hello, World!"
<Instruction at 0x004004ff>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='rdi')>, <Operand(n=1, text='offset s')>]
    regs = {'rdi'}

----------------------------------------------------------------------
rdi
    addr = 0
    base = rdi
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = rdi
    reg_id = 7
    regs = {'rdi'}
    scale = None
    size = 8
    text = rdi
    type = General_Register
    value = 0
----------------------------------------------------------------------
offset s
    addr = 0
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 4195748
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 8
    text = offset s
    type = Immediate_Value
    value = 4195748
**********************************************************************
[00400509]    call    _puts
<Instruction at 0x00400509>
    feature = 65794
    is_call = True
    is_indirect_jump = False
    is_ret = False
    mnem = call
    operands = [<Operand(n=0, text='_puts')>]
    regs = set()

----------------------------------------------------------------------
_puts
    addr = 4195312
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 4195312
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 4195312
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 4
    text = _puts
    type = Immediate_Near_Address
    value = 0
**********************************************************************
[0040050E]    xor     ecx, ecx
<Instruction at 0x0040050e>
    feature = 66308
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = xor
    operands = [<Operand(n=0, text='ecx')>, <Operand(n=1, text='ecx')>]
    regs = {'ecx'}

----------------------------------------------------------------------
ecx
    addr = 0
    base = ecx
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = True
    n = 0
    offset = 0
    reg = ecx
    reg_id = 1
    regs = {'ecx'}
    scale = None
    size = 4
    text = ecx
    type = General_Register
    value = 0
----------------------------------------------------------------------
ecx
    addr = 0
    base = ecx
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = ecx
    reg_id = 1
    regs = {'ecx'}
    scale = None
    size = 4
    text = ecx
    type = General_Register
    value = 0
**********************************************************************
[00400510]    mov     [rbp+var_8], eax
<Instruction at 0x00400510>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='[rbp+var_8]')>, <Operand(n=1, text='eax')>]
    regs = {'eax', 'rbp'}

----------------------------------------------------------------------
[rbp+var_8]
    addr = 18446744073709551608
    base = rbp
    displacement = 18446744073709551608
    dtype = 2
    flags = 8
    has_displacement = True
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 18446744073709551608
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = 1
    size = 4
    text = [rbp+var_8]
    type = Memory_Displacement
    value = 0
----------------------------------------------------------------------
eax
    addr = 0
    base = eax
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = eax
    reg_id = 0
    regs = {'eax'}
    scale = None
    size = 4
    text = eax
    type = General_Register
    value = 0
**********************************************************************
[00400513]    mov     eax, ecx
<Instruction at 0x00400513>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='eax')>, <Operand(n=1, text='ecx')>]
    regs = {'eax', 'ecx'}

----------------------------------------------------------------------
eax
    addr = 0
    base = eax
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = eax
    reg_id = 0
    regs = {'eax'}
    scale = None
    size = 4
    text = eax
    type = General_Register
    value = 0
----------------------------------------------------------------------
ecx
    addr = 0
    base = ecx
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = ecx
    reg_id = 1
    regs = {'ecx'}
    scale = None
    size = 4
    text = ecx
    type = General_Register
    value = 0
**********************************************************************
[00400515]    add     rsp, 10h
<Instruction at 0x00400515>
    feature = 66308
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = add
    operands = [<Operand(n=0, text='rsp')>, <Operand(n=1, text='10h')>]
    regs = {'rsp'}

----------------------------------------------------------------------
rsp
    addr = 0
    base = rsp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = True
    n = 0
    offset = 0
    reg = rsp
    reg_id = 4
    regs = {'rsp'}
    scale = None
    size = 8
    text = rsp
    type = General_Register
    value = 0
----------------------------------------------------------------------
10h
    addr = 0
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 16
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 8
    text = 10h
    type = Immediate_Value
    value = 16
**********************************************************************
[00400519]    pop     rbp
<Instruction at 0x00400519>
    feature = 65540
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = pop
    operands = [<Operand(n=0, text='rbp')>]
    regs = {'rbp'}

----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
**********************************************************************
[0040051A]    retn
<Instruction at 0x0040051a>
    feature = 65537
    is_call = False
    is_indirect_jump = False
    is_ret = True
    mnem = retn
    operands = []
    regs = set()

**********************************************************************
[00400520]    push    r15
<Instruction at 0x00400520>
    feature = 65792
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = push
    operands = [<Operand(n=0, text='r15')>]
    regs = {'r15'}

----------------------------------------------------------------------
r15
    addr = 0
    base = r15
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 0
    reg = r15
    reg_id = 15
    regs = {'r15'}
    scale = None
    size = 8
    text = r15
    type = General_Register
    value = 0
**********************************************************************
[00400522]    push    r14
<Instruction at 0x00400522>
    feature = 65792
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = push
    operands = [<Operand(n=0, text='r14')>]
    regs = {'r14'}

----------------------------------------------------------------------
r14
    addr = 0
    base = r14
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 0
    reg = r14
    reg_id = 14
    regs = {'r14'}
    scale = None
    size = 8
    text = r14
    type = General_Register
    value = 0
**********************************************************************
[00400524]    mov     r15, rdx
<Instruction at 0x00400524>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='r15')>, <Operand(n=1, text='rdx')>]
    regs = {'r15', 'rdx'}

----------------------------------------------------------------------
r15
    addr = 0
    base = r15
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = r15
    reg_id = 15
    regs = {'r15'}
    scale = None
    size = 8
    text = r15
    type = General_Register
    value = 0
----------------------------------------------------------------------
rdx
    addr = 0
    base = rdx
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = rdx
    reg_id = 2
    regs = {'rdx'}
    scale = None
    size = 8
    text = rdx
    type = General_Register
    value = 0
**********************************************************************
[00400527]    push    r13
<Instruction at 0x00400527>
    feature = 65792
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = push
    operands = [<Operand(n=0, text='r13')>]
    regs = {'r13'}

----------------------------------------------------------------------
r13
    addr = 0
    base = r13
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 0
    reg = r13
    reg_id = 13
    regs = {'r13'}
    scale = None
    size = 8
    text = r13
    type = General_Register
    value = 0
**********************************************************************
[00400529]    push    r12
<Instruction at 0x00400529>
    feature = 65792
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = push
    operands = [<Operand(n=0, text='r12')>]
    regs = {'r12'}

----------------------------------------------------------------------
r12
    addr = 0
    base = r12
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 0
    reg = r12
    reg_id = 12
    regs = {'r12'}
    scale = None
    size = 8
    text = r12
    type = General_Register
    value = 0
**********************************************************************
[0040052B]    lea     r12, __frame_dummy_init_array_entry
<Instruction at 0x0040052b>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = lea
    operands = [<Operand(n=0, text='r12')>, <Operand(n=1, text='__frame_dummy_init_array_entry')>]
    regs = {'r12'}

----------------------------------------------------------------------
r12
    addr = 0
    base = r12
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = r12
    reg_id = 12
    regs = {'r12'}
    scale = None
    size = 8
    text = r12
    type = General_Register
    value = 0
----------------------------------------------------------------------
__frame_dummy_init_array_entry
    addr = 6295056
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 6295056
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 6295056
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 5
    regs = set()
    scale = 1
    size = 8
    text = __frame_dummy_init_array_entry
    type = Direct_Memory_Reference
    value = 0
**********************************************************************
[00400532]    push    rbp
<Instruction at 0x00400532>
    feature = 65792
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = push
    operands = [<Operand(n=0, text='rbp')>]
    regs = {'rbp'}

----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
**********************************************************************
[00400533]    lea     rbp, __do_global_dtors_aux_fini_array_entry
<Instruction at 0x00400533>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = lea
    operands = [<Operand(n=0, text='rbp')>, <Operand(n=1, text='__do_global_dtors_aux_fini_array_entry')>]
    regs = {'rbp'}

----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
----------------------------------------------------------------------
__do_global_dtors_aux_fini_array_entry
    addr = 6295064
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 6295064
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 6295064
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 5
    regs = set()
    scale = 1
    size = 8
    text = __do_global_dtors_aux_fini_array_entry
    type = Direct_Memory_Reference
    value = 0
**********************************************************************
[0040053A]    push    rbx
<Instruction at 0x0040053a>
    feature = 65792
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = push
    operands = [<Operand(n=0, text='rbx')>]
    regs = {'rbx'}

----------------------------------------------------------------------
rbx
    addr = 0
    base = rbx
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 0
    reg = rbx
    reg_id = 3
    regs = {'rbx'}
    scale = None
    size = 8
    text = rbx
    type = General_Register
    value = 0
**********************************************************************
[0040053B]    mov     r13d, edi
<Instruction at 0x0040053b>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='r13d')>, <Operand(n=1, text='edi')>]
    regs = {'edi', 'r13d'}

----------------------------------------------------------------------
r13d
    addr = 0
    base = r13d
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = r13d
    reg_id = 13
    regs = {'r13d'}
    scale = None
    size = 4
    text = r13d
    type = General_Register
    value = 0
----------------------------------------------------------------------
edi
    addr = 0
    base = edi
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = edi
    reg_id = 7
    regs = {'edi'}
    scale = None
    size = 4
    text = edi
    type = General_Register
    value = 0
**********************************************************************
[0040053E]    mov     r14, rsi
<Instruction at 0x0040053e>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='r14')>, <Operand(n=1, text='rsi')>]
    regs = {'r14', 'rsi'}

----------------------------------------------------------------------
r14
    addr = 0
    base = r14
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = r14
    reg_id = 14
    regs = {'r14'}
    scale = None
    size = 8
    text = r14
    type = General_Register
    value = 0
----------------------------------------------------------------------
rsi
    addr = 0
    base = rsi
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = rsi
    reg_id = 6
    regs = {'rsi'}
    scale = None
    size = 8
    text = rsi
    type = General_Register
    value = 0
**********************************************************************
[00400541]    sub     rbp, r12
<Instruction at 0x00400541>
    feature = 66308
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = sub
    operands = [<Operand(n=0, text='rbp')>, <Operand(n=1, text='r12')>]
    regs = {'r12', 'rbp'}

----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = True
    n = 0
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
----------------------------------------------------------------------
r12
    addr = 0
    base = r12
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = r12
    reg_id = 12
    regs = {'r12'}
    scale = None
    size = 8
    text = r12
    type = General_Register
    value = 0
**********************************************************************
[00400544]    sub     rsp, 8
<Instruction at 0x00400544>
    feature = 66308
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = sub
    operands = [<Operand(n=0, text='rsp')>, <Operand(n=1, text='8')>]
    regs = {'rsp'}

----------------------------------------------------------------------
rsp
    addr = 0
    base = rsp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = True
    n = 0
    offset = 0
    reg = rsp
    reg_id = 4
    regs = {'rsp'}
    scale = None
    size = 8
    text = rsp
    type = General_Register
    value = 0
----------------------------------------------------------------------
8
    addr = 0
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 8
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 8
    text = 8
    type = Immediate_Value
    value = 8
**********************************************************************
[00400548]    sar     rbp, 3
<Instruction at 0x00400548>
    feature = 99076
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = sar
    operands = [<Operand(n=0, text='rbp')>, <Operand(n=1, text='3')>]
    regs = {'rbp'}

----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = True
    n = 0
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
----------------------------------------------------------------------
3
    addr = 0
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 0
    dtype = 0
    flags = 8
    has_displacement = False
    imm = 3
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 1
    text = 3
    type = Immediate_Value
    value = 3
**********************************************************************
[0040054C]    call    _init_proc
<Instruction at 0x0040054c>
    feature = 65794
    is_call = True
    is_indirect_jump = False
    is_ret = False
    mnem = call
    operands = [<Operand(n=0, text='_init_proc')>]
    regs = set()

----------------------------------------------------------------------
_init_proc
    addr = 4195272
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 4195272
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 4195272
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 4
    text = _init_proc
    type = Immediate_Near_Address
    value = 0
**********************************************************************
[00400551]    test    rbp, rbp
<Instruction at 0x00400551>
    feature = 66304
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = test
    operands = [<Operand(n=0, text='rbp')>, <Operand(n=1, text='rbp')>]
    regs = {'rbp'}

----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
**********************************************************************
[00400554]    jz      short loc_400576
<Instruction at 0x00400554>
    feature = 65792
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = jz
    operands = [<Operand(n=0, text='loc_400576')>]
    regs = set()

----------------------------------------------------------------------
loc_400576
    addr = 4195702
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 4195702
    dtype = 0
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 4195702
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 1
    text = loc_400576
    type = Immediate_Near_Address
    value = 0
**********************************************************************
[00400556]    xor     ebx, ebx
<Instruction at 0x00400556>
    feature = 66308
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = xor
    operands = [<Operand(n=0, text='ebx')>, <Operand(n=1, text='ebx')>]
    regs = {'ebx'}

----------------------------------------------------------------------
ebx
    addr = 0
    base = ebx
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = True
    n = 0
    offset = 0
    reg = ebx
    reg_id = 3
    regs = {'ebx'}
    scale = None
    size = 4
    text = ebx
    type = General_Register
    value = 0
----------------------------------------------------------------------
ebx
    addr = 0
    base = ebx
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = ebx
    reg_id = 3
    regs = {'ebx'}
    scale = None
    size = 4
    text = ebx
    type = General_Register
    value = 0
**********************************************************************
[00400558]    nop     dword ptr [rax+rax+00000000h]
<Instruction at 0x00400558>
    feature = 65536
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = nop
    operands = [<Operand(n=0, text='dword ptr [rax+rax+00000000h]')>]
    regs = {'rax'}

----------------------------------------------------------------------
dword ptr [rax+rax+00000000h]
    addr = 0
    base = rax
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = True
    imm = 0
    index = rax
    is_read = False
    is_write = False
    n = 0
    offset = 0
    reg = rsp
    reg_id = 4
    regs = {'rax'}
    scale = 1
    size = 4
    text = dword ptr [rax+rax+00000000h]
    type = Memory_Displacement
    value = 0
**********************************************************************
[00400560]    mov     rdx, r15
<Instruction at 0x00400560>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='rdx')>, <Operand(n=1, text='r15')>]
    regs = {'r15', 'rdx'}

----------------------------------------------------------------------
rdx
    addr = 0
    base = rdx
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = rdx
    reg_id = 2
    regs = {'rdx'}
    scale = None
    size = 8
    text = rdx
    type = General_Register
    value = 0
----------------------------------------------------------------------
r15
    addr = 0
    base = r15
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = r15
    reg_id = 15
    regs = {'r15'}
    scale = None
    size = 8
    text = r15
    type = General_Register
    value = 0
**********************************************************************
[00400563]    mov     rsi, r14
<Instruction at 0x00400563>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='rsi')>, <Operand(n=1, text='r14')>]
    regs = {'r14', 'rsi'}

----------------------------------------------------------------------
rsi
    addr = 0
    base = rsi
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = rsi
    reg_id = 6
    regs = {'rsi'}
    scale = None
    size = 8
    text = rsi
    type = General_Register
    value = 0
----------------------------------------------------------------------
r14
    addr = 0
    base = r14
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = r14
    reg_id = 14
    regs = {'r14'}
    scale = None
    size = 8
    text = r14
    type = General_Register
    value = 0
**********************************************************************
[00400566]    mov     edi, r13d
<Instruction at 0x00400566>
    feature = 66052
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = mov
    operands = [<Operand(n=0, text='edi')>, <Operand(n=1, text='r13d')>]
    regs = {'edi', 'r13d'}

----------------------------------------------------------------------
edi
    addr = 0
    base = edi
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = edi
    reg_id = 7
    regs = {'edi'}
    scale = None
    size = 4
    text = edi
    type = General_Register
    value = 0
----------------------------------------------------------------------
r13d
    addr = 0
    base = r13d
    displacement = 0
    dtype = 2
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = r13d
    reg_id = 13
    regs = {'r13d'}
    scale = None
    size = 4
    text = r13d
    type = General_Register
    value = 0
**********************************************************************
[00400569]    call    ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]
<Instruction at 0x00400569>
    feature = 82178
    is_call = True
    is_indirect_jump = False
    is_ret = False
    mnem = call
    operands = [<Operand(n=0, text='ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]')>]
    regs = {'r12', 'rbx'}

----------------------------------------------------------------------
ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]
    addr = 0
    base = r12
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = True
    imm = 0
    index = rbx
    is_read = True
    is_write = False
    n = 0
    offset = 0
    reg = r12
    reg_id = 12
    regs = {'r12', 'rbx'}
    scale = 8
    size = 8
    text = ds:(__frame_dummy_init_array_entry - 600E10h)[r12+rbx*8]
    type = Memory_Phrase
    value = 0
**********************************************************************
[0040056D]    add     rbx, 1
<Instruction at 0x0040056d>
    feature = 66308
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = add
    operands = [<Operand(n=0, text='rbx')>, <Operand(n=1, text='1')>]
    regs = {'rbx'}

----------------------------------------------------------------------
rbx
    addr = 0
    base = rbx
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = True
    n = 0
    offset = 0
    reg = rbx
    reg_id = 3
    regs = {'rbx'}
    scale = None
    size = 8
    text = rbx
    type = General_Register
    value = 0
----------------------------------------------------------------------
1
    addr = 0
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 1
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 8
    text = 1
    type = Immediate_Value
    value = 1
**********************************************************************
[00400571]    cmp     rbp, rbx
<Instruction at 0x00400571>
    feature = 66304
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = cmp
    operands = [<Operand(n=0, text='rbp')>, <Operand(n=1, text='rbx')>]
    regs = {'rbp', 'rbx'}

----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
----------------------------------------------------------------------
rbx
    addr = 0
    base = rbx
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = rbx
    reg_id = 3
    regs = {'rbx'}
    scale = None
    size = 8
    text = rbx
    type = General_Register
    value = 0
**********************************************************************
[00400574]    jnz     short loc_400560
<Instruction at 0x00400574>
    feature = 65792
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = jnz
    operands = [<Operand(n=0, text='loc_400560')>]
    regs = set()

----------------------------------------------------------------------
loc_400560
    addr = 4195680
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 4195680
    dtype = 0
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = False
    n = 0
    offset = 4195680
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 1
    text = loc_400560
    type = Immediate_Near_Address
    value = 0
**********************************************************************
[00400576]    add     rsp, 8
<Instruction at 0x00400576>
    feature = 66308
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = add
    operands = [<Operand(n=0, text='rsp')>, <Operand(n=1, text='8')>]
    regs = {'rsp'}

----------------------------------------------------------------------
rsp
    addr = 0
    base = rsp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = True
    is_write = True
    n = 0
    offset = 0
    reg = rsp
    reg_id = 4
    regs = {'rsp'}
    scale = None
    size = 8
    text = rsp
    type = General_Register
    value = 0
----------------------------------------------------------------------
8
    addr = 0
    base = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 8
    index = None
    is_read = True
    is_write = False
    n = 1
    offset = 0
    reg = # Exception: SarkOperandWithoutReg('Operand does not have a register.')
    reg_id = 0
    regs = set()
    scale = None
    size = 8
    text = 8
    type = Immediate_Value
    value = 8
**********************************************************************
[0040057A]    pop     rbx
<Instruction at 0x0040057a>
    feature = 65540
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = pop
    operands = [<Operand(n=0, text='rbx')>]
    regs = {'rbx'}

----------------------------------------------------------------------
rbx
    addr = 0
    base = rbx
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = rbx
    reg_id = 3
    regs = {'rbx'}
    scale = None
    size = 8
    text = rbx
    type = General_Register
    value = 0
**********************************************************************
[0040057B]    pop     rbp
<Instruction at 0x0040057b>
    feature = 65540
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = pop
    operands = [<Operand(n=0, text='rbp')>]
    regs = {'rbp'}

----------------------------------------------------------------------
rbp
    addr = 0
    base = rbp
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = rbp
    reg_id = 5
    regs = {'rbp'}
    scale = None
    size = 8
    text = rbp
    type = General_Register
    value = 0
**********************************************************************
[0040057C]    pop     r12
<Instruction at 0x0040057c>
    feature = 65540
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = pop
    operands = [<Operand(n=0, text='r12')>]
    regs = {'r12'}

----------------------------------------------------------------------
r12
    addr = 0
    base = r12
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = r12
    reg_id = 12
    regs = {'r12'}
    scale = None
    size = 8
    text = r12
    type = General_Register
    value = 0
**********************************************************************
[0040057E]    pop     r13
<Instruction at 0x0040057e>
    feature = 65540
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = pop
    operands = [<Operand(n=0, text='r13')>]
    regs = {'r13'}

----------------------------------------------------------------------
r13
    addr = 0
    base = r13
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = r13
    reg_id = 13
    regs = {'r13'}
    scale = None
    size = 8
    text = r13
    type = General_Register
    value = 0
**********************************************************************
[00400580]    pop     r14
<Instruction at 0x00400580>
    feature = 65540
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = pop
    operands = [<Operand(n=0, text='r14')>]
    regs = {'r14'}

----------------------------------------------------------------------
r14
    addr = 0
    base = r14
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = r14
    reg_id = 14
    regs = {'r14'}
    scale = None
    size = 8
    text = r14
    type = General_Register
    value = 0
**********************************************************************
[00400582]    pop     r15
<Instruction at 0x00400582>
    feature = 65540
    is_call = False
    is_indirect_jump = False
    is_ret = False
    mnem = pop
    operands = [<Operand(n=0, text='r15')>]
    regs = {'r15'}

----------------------------------------------------------------------
r15
    addr = 0
    base = r15
    displacement = 0
    dtype = 7
    flags = 8
    has_displacement = False
    imm = 0
    index = None
    is_read = False
    is_write = True
    n = 0
    offset = 0
    reg = r15
    reg_id = 15
    regs = {'r15'}
    scale = None
    size = 8
    text = r15
    type = General_Register
    value = 0
**********************************************************************
[00400584]    retn
<Instruction at 0x00400584>
    feature = 65537
    is_call = False
    is_indirect_jump = False
    is_ret = True
    mnem = retn
    operands = []
    regs = set()


```

`tests/approved_files/SimpleTest.test_modify_block_color.approved.txt`:

```txt
Color before change: None
Color after change: 4919
Color after clear: None

```

`tests/approved_files/SimpleTest.test_phrase_dumper.approved.txt`:

```txt
Diffing generated and parsed phrases.
Any line printed indicates an error.


Done.

```

`tests/approved_files/SimpleTest.test_segments.approved.txt`:

```txt
<Segment(ea=0x00400000, name='LOAD', size=0x000003C8, permissions='RX', bitness=64)>
    bitness = 64
    class_ = CODE
    ea = 4194304
    end_ea = 4195272
    name = LOAD
    permissions = RX
    size = 968
    start_ea = 4194304
    type = 2
<Segment(ea=0x004003C8, name='.init', size=0x00000017, permissions='RX', bitness=64)>
    bitness = 64
    class_ = CODE
    ea = 4195272
    end_ea = 4195295
    name = .init
    permissions = RX
    size = 23
    start_ea = 4195272
    type = 2
<Segment(ea=0x004003DF, name='LOAD', size=0x00000001, permissions='RX', bitness=64)>
    bitness = 64
    class_ = CODE
    ea = 4195295
    end_ea = 4195296
    name = LOAD
    permissions = RX
    size = 1
    start_ea = 4195295
    type = 2
<Segment(ea=0x004003E0, name='.plt', size=0x00000020, permissions='RX', bitness=64)>
    bitness = 64
    class_ = CODE
    ea = 4195296
    end_ea = 4195328
    name = .plt
    permissions = RX
    size = 32
    start_ea = 4195296
    type = 2
<Segment(ea=0x00400400, name='.text', size=0x00000192, permissions='RX', bitness=64)>
    bitness = 64
    class_ = CODE
    ea = 4195328
    end_ea = 4195730
    name = .text
    permissions = RX
    size = 402
    start_ea = 4195328
    type = 2
<Segment(ea=0x00400592, name='LOAD', size=0x00000002, permissions='RX', bitness=64)>
    bitness = 64
    class_ = CODE
    ea = 4195730
    end_ea = 4195732
    name = LOAD
    permissions = RX
    size = 2
    start_ea = 4195730
    type = 2
<Segment(ea=0x00400594, name='.fini', size=0x00000009, permissions='RX', bitness=64)>
    bitness = 64
    class_ = CODE
    ea = 4195732
    end_ea = 4195741
    name = .fini
    permissions = RX
    size = 9
    start_ea = 4195732
    type = 2
<Segment(ea=0x0040059D, name='LOAD', size=0x00000003, permissions='RX', bitness=64)>
    bitness = 64
    class_ = CODE
    ea = 4195741
    end_ea = 4195744
    name = LOAD
    permissions = RX
    size = 3
    start_ea = 4195741
    type = 2
<Segment(ea=0x004005A0, name='.rodata', size=0x00000012, permissions='R', bitness=64)>
    bitness = 64
    class_ = CONST
    ea = 4195744
    end_ea = 4195762
    name = .rodata
    permissions = R
    size = 18
    start_ea = 4195744
    type = 3
<Segment(ea=0x004005B2, name='LOAD', size=0x00000002, permissions='RX', bitness=64)>
    bitness = 64
    class_ = CODE
    ea = 4195762
    end_ea = 4195764
    name = LOAD
    permissions = RX
    size = 2
    start_ea = 4195762
    type = 2
<Segment(ea=0x004005B4, name='.eh_frame_hdr', size=0x0000003C, permissions='R', bitness=64)>
    bitness = 64
    class_ = CONST
    ea = 4195764
    end_ea = 4195824
    name = .eh_frame_hdr
    permissions = R
    size = 60
    start_ea = 4195764
    type = 3
<Segment(ea=0x004005F0, name='.eh_frame', size=0x00000100, permissions='R', bitness=64)>
    bitness = 64
    class_ = CONST
    ea = 4195824
    end_ea = 4196080
    name = .eh_frame
    permissions = R
    size = 256
    start_ea = 4195824
    type = 3
<Segment(ea=0x00600E10, name='.init_array', size=0x00000008, permissions='RW', bitness=64)>
    bitness = 64
    class_ = DATA
    ea = 6295056
    end_ea = 6295064
    name = .init_array
    permissions = RW
    size = 8
    start_ea = 6295056
    type = 3
<Segment(ea=0x00600E18, name='.fini_array', size=0x00000008, permissions='RW', bitness=64)>
    bitness = 64
    class_ = DATA
    ea = 6295064
    end_ea = 6295072
    name = .fini_array
    permissions = RW
    size = 8
    start_ea = 6295064
    type = 3
<Segment(ea=0x00600E20, name='LOAD', size=0x000001D0, permissions='RW', bitness=64)>
    bitness = 64
    class_ = DATA
    ea = 6295072
    end_ea = 6295536
    name = LOAD
    permissions = RW
    size = 464
    start_ea = 6295072
    type = 3
<Segment(ea=0x00600FF0, name='.got', size=0x00000010, permissions='RW', bitness=64)>
    bitness = 64
    class_ = DATA
    ea = 6295536
    end_ea = 6295552
    name = .got
    permissions = RW
    size = 16
    start_ea = 6295536
    type = 3
<Segment(ea=0x00601000, name='.got.plt', size=0x00000020, permissions='RW', bitness=64)>
    bitness = 64
    class_ = DATA
    ea = 6295552
    end_ea = 6295584
    name = .got.plt
    permissions = RW
    size = 32
    start_ea = 6295552
    type = 3
<Segment(ea=0x00601020, name='.data', size=0x00000010, permissions='RW', bitness=64)>
    bitness = 64
    class_ = DATA
    ea = 6295584
    end_ea = 6295600
    name = .data
    permissions = RW
    size = 16
    start_ea = 6295584
    type = 3
<Segment(ea=0x00601030, name='.bss', size=0x00000008, permissions='RW', bitness=64)>
    bitness = 64
    class_ = BSS
    ea = 6295600
    end_ea = 6295608
    name = .bss
    permissions = RW
    size = 8
    start_ea = 6295600
    type = 9
<Segment(ea=0x00601038, name='.prgend', size=0x00000001, permissions='', bitness=64)>
    bitness = 64
    class_ = None
    ea = 6295608
    end_ea = 6295609
    name = .prgend
    permissions = 
    size = 1
    start_ea = 6295608
    type = 7
<Segment(ea=0x00601040, name='extern', size=0x00000018, permissions='', bitness=64)>
    bitness = 64
    class_ = None
    ea = 6295616
    end_ea = 6295640
    name = extern
    permissions = 
    size = 24
    start_ea = 6295616
    type = 1

```

`tests/binary_samples/sources/simple.c`:

```c
#include <stdio.h>

int main() {
    puts("Hello, World!");
    return 0;
}
```

`tests/config.json`:

```json
{
  "IDAPATH": "C:\\Program Files\\IDA Pro 8.2\\ida64.exe",
  "IDATPATH": "C:\\Program Files\\IDA Pro 8.2\\idat64.exe"
}
```

`tests/dumpers/api_sampler.py`:

```py
import sark
from dumper_helper import dump_attrs


def main():
    sark.core.fix_addresses()

if __name__ == '__main__':
    main()

```

`tests/dumpers/block_color_modifier.py`:

```py
import sark


def main():
    block = next(sark.codeblocks())
    print('Color before change: {}'.format(block.color))

    block.color = 0x1337
    print('Color after change: {}'.format(block.color))

    block.color = None
    print('Color after clear: {}'.format(block.color))


if __name__ == '__main__':
    main()

```

`tests/dumpers/codeblock_dumper.py`:

```py
import sark
from dumper_helper import dump_attrs


def main():
    for function in sark.functions():
        print('*' * 70)
        print(function)
        flowchart = sark.FlowChart(f=function.ea)
        for block in flowchart:
            print('-' * 70)
            print(block)
            dump_attrs(block, exclude=('startEA','endEA'))
            print('    {} = {}'.format('prev',list(block.prev)))
            print('    {} = {}'.format('next',list(block.next)))


if __name__ == '__main__':
    main()

```

`tests/dumpers/data_dumper.py`:

```py
import sark
from dumper_helper import dump_attrs
import itertools


def main():
    print('Bytes')
    print(list(itertools.islice(sark.data.Bytes(), 10)))

    print()

    print('Bytes Until 0')
    print(list(sark.data.bytes_until()))

    print()

    print('Words')
    print(list(itertools.islice(sark.data.Words(), 10)))

    print()

    print('Words Until 0')
    print(list(sark.data.words_until()))

    print()

    print('DWords')
    print(list(itertools.islice(sark.data.Dwords(), 10)))

    print()

    print('DWords Until 0')
    print(list(sark.data.dwords_until()))

    print()

    print('QWords')
    print(list(itertools.islice(sark.data.Qwords(), 10)))

    print()

    print('QWords Until 0')
    print(list(sark.data.qwords_until()))

    print()

    print('Native Words')
    print(list(itertools.islice(sark.data.NativeWords(), 10)))

    print()

    print('Native Words Until 0')
    print(list(sark.data.native_words_until()))

    print()

    print('Chars')
    print(list(itertools.islice(sark.data.Chars(), 10)))

    print()

    print('Chars Until \\0')
    print(list(sark.data.chars_until()))

    print()

    print('Read ascii string')
    print(repr(sark.data.read_ascii_string(0x004005A4)))

    print()

    print('Get String')
    print(repr(sark.data.get_string(0x004005A4)))


if __name__ == '__main__':
    main()

```

`tests/dumpers/dumper_helper.py`:

```py
import types


def is_magic_attr(name):
    return name.startswith('__') and name.endswith('__')


def is_automated_repr(obj):
    string = str(obj)
    return string.startswith('<') and string.endswith('>')


def is_private_attr(name):
    return name.startswith('_')

def is_constant_attr(name):
    return name.isupper()

def repr_set(set_:set):
    if not set_:
        return 'set()'
    else:
        sorted_members = sorted(set_)
        content = ', '.join(map(repr, sorted_members))
        return f'{{{content}}}'


def dump_attrs(obj, exclude=None, handle_execption=None):
    if exclude is None:
        exclude = set()

    for name in sorted(dir(obj)):
        if name in exclude:
            continue

        if is_magic_attr(name):
            continue

        if is_private_attr(name):
            continue

        if is_constant_attr(name):
            continue

        try:
            attr = getattr(obj, name)
        except Exception as e:
            if handle_execption and handle_execption(e):
                attr = '# Exception: {!r}'.format(e)
            else:
                raise

        if isinstance(attr, types.FunctionType):
            continue

        if is_automated_repr(attr):
            continue

        if isinstance(attr, set):
            attr = repr_set(attr)

        print('    {} = {}'.format(name, attr))
```

`tests/dumpers/dumper_wrapper.py`:

```py
import idaapi
import idc
import contextlib

idaapi.auto_wait()


with open(idc.ARGV[1], 'w') as f, contextlib.redirect_stdout(f), contextlib.redirect_stderr(f):
    try:
        exec(compile(open(idc.ARGV[2], "rb").read(), idc.ARGV[2], 'exec'))
    except:
        import traceback
        traceback.print_exc()

# Ensure the database is not saved on exit
idaapi.set_database_flag(idaapi.DBFL_KILL)
idc.qexit(0)

```

`tests/dumpers/enum_dumper.py`:

```py
import sark
from dumper_helper import dump_attrs


def main():
    for enum in sark.enums():
        print(enum)
        dump_attrs(enum)


if __name__ == '__main__':
    main()

```

`tests/dumpers/function_dumper.py`:

```py
import sark
from dumper_helper import dump_attrs


def main():
    for function in sark.functions():
        print(function)
        dump_attrs(function)


if __name__ == '__main__':
    main()

```

`tests/dumpers/instruction_dumper.py`:

```py
import sark
from dumper_helper import dump_attrs

def ignore_sark_exception(e):
    return isinstance(e, sark.exceptions.SarkException)

def main():
    function_names = ['main', '__libc_csu_init']
    for name in function_names:
        function = sark.Function(name=name)
        for line in function.lines:
            print('*' * 70)
            print(line)
            insn = line.insn
            print(insn)
            dump_attrs(insn)
            print()
            for operand in insn.operands:
                print('-'*70)
                print(operand)
                dump_attrs(operand, handle_execption=ignore_sark_exception)



if __name__ == '__main__':
    main()

```

`tests/dumpers/phrase_dumper.py`:

```py
import itertools
from typing import Optional

import ida_bytes
import ida_ua

import sark
from keystone import Ks, KS_MODE_64, KS_ARCH_X86

from sark.exceptions import SarkOperandWithoutReg

REGISTERS_64 = ["rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "rsp"] + [
    f"r{i}" for i in range(8, 16)
]


def assemble(line: str) -> bytes:
    ks = Ks(KS_ARCH_X86, KS_MODE_64)
    encoding, _count = ks.asm(line)
    return bytes(encoding)


def lea(base: Optional[str], index: Optional[str], scale: int, offset: int) -> str:
    assert scale >= 1

    parts = []

    if base:
        parts.append(base)

    if index:
        if base:
            parts.append("+")
        parts.append(f"{index} * {scale}")

    if offset:
        if base or index:
            parts.append("+")
        parts.append(str(offset))

    phrase = " ".join(parts)

    return f"lea rax, [{phrase}]"


def main():
    print("Diffing generated and parsed phrases.")
    print("Any line printed indicates an error.")
    print()
    text_segment = sark.Segment(name=".text")

    # First, make room for our code!
    sark.data.undefine(text_segment.start_ea, text_segment.end_ea)

    ea = text_segment.start_ea

    for base, index, scale, offset in itertools.product(
        REGISTERS_64 + [None], REGISTERS_64 + [None], [1, 2, 4, 8], [0, 1, 255]
    ):
        if index is None and scale != 1:
            continue
        if index == "rsp":
            # RSP is ignored
            continue
        if base is None and index is None:
            continue

        line = lea(base, index, scale, offset)
        try:
            asm = assemble(line)
        except Exception:
            print("Invalid: ", line)
            raise

        ida_bytes.patch_bytes(ea, asm)
        ida_ua.create_insn(ea)

        op = sark.Line(ea).insn.operands[1]
        try:
            try:
                parsed_base = op.base
            except SarkOperandWithoutReg:
                parsed_base = None
            parsed_index = op.index
            parsed_scale = op.scale
            parsed_offset = op.offset
        except Exception:
            print(line)
            raise

        flags = (
            ("B" if parsed_base != base else "-")
            + ("I" if parsed_index != index else "-")
            + ("S" if parsed_scale != scale else "-")
            + ("O" if parsed_offset != offset else "-")
        )

        if flags != "----":
            print(f"{flags} | {line} | {parsed_index=} | {parsed_scale=}")

        sark.data.undefine(ea, ea + ida_bytes.get_item_size(ea))

    print()
    print("Done.")


if __name__ == "__main__":
    main()

```

`tests/dumpers/segment_dumper.py`:

```py
import sark
from dumper_helper import dump_attrs


def main():
    for segment in sark.segments():
        print(segment)
        dump_attrs(segment, exclude=('prev', 'next'))


if __name__ == '__main__':
    main()

```

`tests/dumpers/simple_comment_dumper.py`:

```py
import sark
from dumper_helper import dump_attrs


def main():
    main_function = sark.Function(name='main')

    print(main_function.comments)
    dump_attrs(main_function.comments)

    for line in main_function.lines:
        print(line.comments)
        dump_attrs(line.comments)


if __name__ == '__main__':
    main()

```

`tests/testhelper.py`:

```py
import contextlib
import os
import subprocess
import tempfile
import json


def get_wrapper_script():
    return os.path.join(get_dumper_dir(), 'dumper_wrapper.py')


def query_config(key):
    config_path = os.path.join(os.path.dirname(__file__), 'config.json')
    with open(config_path) as f:
        config = json.load(f)
    return config[key]


def read_config(key):
    value = query_config(key)

    def _decorator(_):
        return lambda: value

    return _decorator


@read_config('IDAPATH')
def get_ida_path(): pass


@read_config('IDATPATH')
def get_idat_path(): pass


def get_tempfile_path():
    handle, name = tempfile.mkstemp()
    os.close(handle)
    return name


@contextlib.contextmanager
def unsafe_tempfile():
    name = get_tempfile_path()

    f = open(name)
    try:
        yield f
    finally:
        f.close()
        os.unlink(name)


def run_ida(script, idb, *, use_idat=False):
    if use_idat:
        ida_path = get_idat_path()
    else:
        ida_path = get_ida_path()

    with unsafe_tempfile() as f:
        subprocess.call([ida_path, '-A', '-S"{}" "{}" "{}"'.format(get_wrapper_script(), f.name, script), idb])

        output = f.read()

    return output


def get_dumper_path(name):
    return os.path.join(get_dumper_dir(), name)


def get_dumper_dir():
    return os.path.join(os.path.dirname(__file__), 'dumpers')


def get_binary_dir():
    return os.path.join(os.path.dirname(__file__), 'binary_samples')


def get_binary_path(name):
    return os.path.join(get_binary_dir(), name)


def run_dumper(dumper_name, binary_name, *, use_idat=False):
    return run_ida(get_dumper_path(dumper_name), get_binary_path(binary_name), use_idat=use_idat)

```

`tests/tests.py`:

```py
import unittest

from approvaltests.approvals import verify
from approvaltests.reporters.generic_diff_reporter_factory import GenericDiffReporterFactory

from testhelper import run_dumper


class SimpleTest(unittest.TestCase):
    def setUp(self):
        self.reporter = GenericDiffReporterFactory().get_first_working()

    def test_data(self):
        data = run_dumper('data_dumper.py', 'simple.out.i64')
        verify(data, self.reporter)

    def test_functions(self):
        data = run_dumper('function_dumper.py', 'simple.out.i64')
        verify(data, self.reporter)

    def test_segments(self):
        data = run_dumper('segment_dumper.py', 'simple.out.i64')
        verify(data, self.reporter)

    def test_enum(self):
        data = run_dumper('enum_dumper.py', 'simple.out.i64')
        verify(data, self.reporter)

    def test_comments(self):
        data = run_dumper('simple_comment_dumper.py', 'simple.out.i64')
        verify(data, self.reporter)

    def test_codeblocks(self):
        data = run_dumper('codeblock_dumper.py', 'simple.out.i64')
        verify(data, self.reporter)

    def test_instructions(self):
        data = run_dumper('instruction_dumper.py', 'simple.out.i64')
        verify(data, self.reporter)

    def test_modify_block_color(self):
        data = run_dumper('block_color_modifier.py', 'simple.out.i64')
        verify(data, self.reporter)

    def test_api_sampler(self):
        data = run_dumper('api_sampler.py', 'simple.out.i64')
        verify(data, self.reporter)

    def test_phrase_dumper(self):
        data = run_dumper("phrase_dumper.py", "simple.out.i64")
        verify(data, self.reporter)

    def test_idat(self):
        data = run_dumper('api_sampler.py', 'simple.out.i64', use_idat=True)
        verify(data, self.reporter)

    def test_idat_data_dumper(self):
        data = run_dumper('data_dumper.py', 'simple.out.i64', use_idat=True)
        verify(data, self.reporter)


if __name__ == "__main__":
    unittest.main()

```