Project Path: arc_nlepleux_MappedCallback_d3so9luz

Source Tree:

```txt
arc_nlepleux_MappedCallback_d3so9luz
├── MappedCallback
│   ├── MappedCallback.inf
│   ├── MappedCallback.vcxproj
│   ├── MappedCallback.vcxproj.filters
│   ├── MappedCallback.vcxproj.user
│   ├── internals.h
│   ├── kernel_utils.h
│   ├── main.cpp
│   ├── mapped_callback.h
│   └── scan.h
├── MappedCallback.sln
├── README.md
└── img
    ├── MmVerifyCallbackFunction.png
    └── MmVerifyCallbackFunctionCheckFlags.png

```

`MappedCallback.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.30907.101
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MappedCallback", "MappedCallback\MappedCallback.vcxproj", "{074F2882-8AEC-4437-8774-7707D7399ABC}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|ARM.ActiveCfg = Debug|ARM
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|ARM.Build.0 = Debug|ARM
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|ARM.Deploy.0 = Debug|ARM
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|ARM64.Build.0 = Debug|ARM64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|x64.ActiveCfg = Debug|x64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|x64.Build.0 = Debug|x64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|x64.Deploy.0 = Debug|x64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|x86.ActiveCfg = Debug|Win32
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|x86.Build.0 = Debug|Win32
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Debug|x86.Deploy.0 = Debug|Win32
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|ARM.ActiveCfg = Release|ARM
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|ARM.Build.0 = Release|ARM
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|ARM.Deploy.0 = Release|ARM
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|ARM64.ActiveCfg = Release|ARM64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|ARM64.Build.0 = Release|ARM64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|ARM64.Deploy.0 = Release|ARM64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|x64.ActiveCfg = Release|x64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|x64.Build.0 = Release|x64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|x64.Deploy.0 = Release|x64
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|x86.ActiveCfg = Release|Win32
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|x86.Build.0 = Release|Win32
		{074F2882-8AEC-4437-8774-7707D7399ABC}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {AF35FD58-70A8-4346-939B-AD9EF70C677E}
	EndGlobalSection
EndGlobal

```

`MappedCallback/MappedCallback.inf`:

```inf
;
; MappedCallback.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=MappedCallback.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages
PnpLockDown=1

[DestinationDirs]
DefaultDestDir = 12
MappedCallback_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
MappedCallback.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%MappedCallback.DeviceDesc%=MappedCallback_Device, Root\MappedCallback ; TODO: edit hw-id

[MappedCallback_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
MappedCallback.sys

;-------------- Service installation
[MappedCallback_Device.NT.Services]
AddService = MappedCallback,%SPSVCINST_ASSOCSERVICE%, MappedCallback_Service_Inst

; -------------- MappedCallback driver install sections
[MappedCallback_Service_Inst]
DisplayName    = %MappedCallback.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\MappedCallback.sys

;
;--- MappedCallback_Device Coinstaller installation ------
;

[MappedCallback_Device.NT.CoInstallers]
AddReg=MappedCallback_Device_CoInstaller_AddReg
CopyFiles=MappedCallback_Device_CoInstaller_CopyFiles

[MappedCallback_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[MappedCallback_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[MappedCallback_Device.NT.Wdf]
KmdfService =  MappedCallback, MappedCallback_wdfsect
[MappedCallback_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "MappedCallback Installation Disk"
MappedCallback.DeviceDesc = "MappedCallback Device"
MappedCallback.SVCDESC = "MappedCallback Service"

```

`MappedCallback/MappedCallback.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{074F2882-8AEC-4437-8774-7707D7399ABC}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>MappedCallback</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.19041.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Inf>
      <SpecifyArchitecture>true</SpecifyArchitecture>
      <SpecifyDriverVerDirectiveVersion>true</SpecifyDriverVerDirectiveVersion>
      <SpecifyDriverVerDirectiveDate>true</SpecifyDriverVerDirectiveDate>
    </Inf>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="MappedCallback.inf" />
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="internals.h" />
    <ClInclude Include="kernel_utils.h" />
    <ClInclude Include="mapped_callback.h" />
    <ClInclude Include="scan.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`MappedCallback/MappedCallback.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="MappedCallback.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="internals.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="kernel_utils.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="mapped_callback.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="scan.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`MappedCallback/MappedCallback.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`MappedCallback/internals.h`:

```h
#pragma once
#include <ntdef.h>
#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>

typedef struct _LDR_DATA_TABLE_ENTRY
{
	struct _LIST_ENTRY InLoadOrderLinks;                                    //0x0
	struct _LIST_ENTRY InMemoryOrderLinks;                                  //0x10
	struct _LIST_ENTRY InInitializationOrderLinks;                          //0x20
	VOID* DllBase;                                                          //0x30
	VOID* EntryPoint;                                                       //0x38
	ULONG SizeOfImage;                                                      //0x40
	struct _UNICODE_STRING FullDllName;                                     //0x48
	struct _UNICODE_STRING BaseDllName;                                     //0x58
	union
	{
		UCHAR FlagGroup[4];                                                 //0x68
		ULONG Flags;                                                        //0x68
		struct TT
		{
			ULONG PackagedBinary : 1;                                         //0x68
			ULONG MarkedForRemoval : 1;                                       //0x68
			ULONG ImageDll : 1;                                               //0x68
			ULONG LoadNotificationsSent : 1;                                  //0x68
			ULONG TelemetryEntryProcessed : 1;                                //0x68
			ULONG ProcessStaticImport : 1;                                    //0x68
			ULONG InLegacyLists : 1;                                          //0x68
			ULONG InIndexes : 1;                                              //0x68
			ULONG ShimDll : 1;                                                //0x68
			ULONG InExceptionTable : 1;                                       //0x68
			ULONG ReservedFlags1 : 2;                                         //0x68
			ULONG LoadInProgress : 1;                                         //0x68
			ULONG LoadConfigProcessed : 1;                                    //0x68
			ULONG EntryProcessed : 1;                                         //0x68
			ULONG ProtectDelayLoad : 1;                                       //0x68
			ULONG ReservedFlags3 : 2;                                         //0x68
			ULONG DontCallForThreads : 1;                                     //0x68
			ULONG ProcessAttachCalled : 1;                                    //0x68
			ULONG ProcessAttachFailed : 1;                                    //0x68
			ULONG CorDeferredValidate : 1;                                    //0x68
			ULONG CorImage : 1;                                               //0x68
			ULONG DontRelocate : 1;                                           //0x68
			ULONG CorILOnly : 1;                                              //0x68
			ULONG ChpeImage : 1;                                              //0x68
			ULONG ReservedFlags5 : 2;                                         //0x68
			ULONG Redirected : 1;                                             //0x68
			ULONG ReservedFlags6 : 2;                                         //0x68
			ULONG CompatDatabaseProcessed : 1;                                //0x68
		};
	};
	USHORT ObsoleteLoadCount;                                               //0x6c
	USHORT TlsIndex;                                                        //0x6e
	struct _LIST_ENTRY HashLinks;                                           //0x70
	ULONG TimeDateStamp;                                                    //0x80
	struct _ACTIVATION_CONTEXT* EntryPointActivationContext;                //0x88
	VOID* Lock;                                                             //0x90
	struct _LDR_DDAG_NODE* DdagNode;                                        //0x98
	struct _LIST_ENTRY NodeModuleLink;                                      //0xa0
	struct _LDRP_LOAD_CONTEXT* LoadContext;                                 //0xb0
	VOID* ParentDllBase;                                                    //0xb8
	VOID* SwitchBackContext;                                                //0xc0
	struct _RTL_BALANCED_NODE BaseAddressIndexNode;                         //0xc8
	struct _RTL_BALANCED_NODE MappingInfoIndexNode;                         //0xe0
	ULONGLONG OriginalBase;                                                 //0xf8
	union _LARGE_INTEGER LoadTime;                                          //0x100
	ULONG BaseNameHashValue;                                                //0x108
	enum _LDR_DLL_LOAD_REASON LoadReason;                                   //0x10c
	ULONG ImplicitPathOptions;                                              //0x110
	ULONG ReferenceCount;                                                   //0x114
	ULONG DependentLoadFlags;                                               //0x118
	UCHAR SigningLevel;                                                     //0x11c
} LDR_DATA_TABLE_ENTRY;

typedef struct _EPROCESS
{
    char pad[0x5a8];
    unsigned char ImageFileName[15];
} EPROCESS, * _PEPROCESS;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemBasicInformation = 0x0,
	SystemProcessorInformation = 0x1,
	SystemPerformanceInformation = 0x2,
	SystemTimeOfDayInformation = 0x3,
	SystemPathInformation = 0x4,
	SystemProcessInformation = 0x5,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemProcessorPerformanceInformation = 0x8,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemInterruptInformation = 0x17,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemExceptionInformation = 0x21,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemRegistryQuotaInformation = 0x25,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemLookasideInformation = 0x2d,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;         // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[MAXIMUM_FILENAME_LENGTH];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;


EXTERN_C NTSYSAPI
PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(
	PVOID   ModuleAddress
);

EXTERN_C NTSYSAPI
NTSTATUS NTAPI ZwQuerySystemInformation(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
);
```

`MappedCallback/kernel_utils.h`:

```h
#pragma once

#include "internals.h"

namespace utils
{
	PVOID kernelBase = NULL;

	NTSTATUS writeToReadOnly(PVOID address, PVOID buffer, SIZE_T size, BOOLEAN reset = false)
	{
		auto mdl = IoAllocateMdl(address, (ULONG)size, FALSE, FALSE, NULL);
		if (!mdl)
			return STATUS_UNSUCCESSFUL;

		MmProbeAndLockPages(mdl, KernelMode, IoReadAccess);
		MmProtectMdlSystemAddress(mdl, PAGE_EXECUTE_READWRITE);

		auto mmMap = MmMapLockedPagesSpecifyCache(mdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
		RtlCopyMemory(mmMap, buffer, size);

		if (reset)
			MmProtectMdlSystemAddress(mdl, PAGE_READONLY);

		MmUnmapLockedPages(mmMap, mdl);
		MmUnlockPages(mdl);
		IoFreeMdl(mdl);

		return STATUS_SUCCESS;
	}

	BOOLEAN writeTrampoline(PVOID address, PVOID target)
	{
		UCHAR trampoline[12] = {
			0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // mov rax, xxxxxxxx
			0xFF, 0xE0                                                   // jmp rax
		};
		*(PVOID*)(trampoline + 2) = target;

		return NT_SUCCESS(writeToReadOnly(address, trampoline, 12, FALSE));
	}

	BOOLEAN removeTrampoline(PVOID address)
	{
		UCHAR trampoline[12] = {
			0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
			0xCC, 0xCC
		};

		return NT_SUCCESS(writeToReadOnly(address, trampoline, 12, TRUE));
	}

	PVOID getSystemModuleBase(PCCHAR module_name)
	{
		ULONG bytes = 0;
		PVOID moduleBase = NULL;

		// First fetch to retrieve the size
		ZwQuerySystemInformation(SystemModuleInformation, 0, bytes, &bytes);
		if (!bytes)
			return moduleBase;

		// Allocate the size
		PRTL_PROCESS_MODULES modules = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, bytes, 'pool');
		if (!modules)
			return moduleBase;

		RtlZeroMemory(modules, bytes);

		// Fetch real data
		if (NT_SUCCESS(ZwQuerySystemInformation(SystemModuleInformation, modules, bytes, &bytes)))
		{
			// Walk loaded modules
			PRTL_PROCESS_MODULE_INFORMATION module = modules->Modules;
			for (ULONG i(0); i < modules->NumberOfModules; i++)
			{
				if (strstr((PCHAR)module[i].FullPathName, module_name) != NULL)
				{
					moduleBase = module[i].ImageBase;
					break;
				}
			}
		}

		ExFreePoolWithTag(modules, 'pool');
		return moduleBase;
	}

	PVOID getKernelBase()
	{
		if (kernelBase == NULL)
			return (kernelBase = getSystemModuleBase("ntoskrnl"));
		return kernelBase;
	}
}
```

`MappedCallback/main.cpp`:

```cpp
#include "internals.h"
#include "mapped_callback.h"

EXTERN_C NTSTATUS DriverEntry()
{
	if (!callback::findCodeCaves())
	{
		DbgPrint("Unable to find code caves in ntoskrnl");
		return STATUS_UNSUCCESSFUL;
	}
	
	if (!callback::alterFlags())
	{
		DbgPrint("Unable to alter flags");
		return STATUS_UNSUCCESSFUL;
	}

	if (!callback::applyTrampolines())
	{
		DbgPrint("Unable to apply trampoline to code caves");
		return STATUS_UNSUCCESSFUL;
	}
	
	if (!callback::startThread())
	{
		DbgPrint("Unable to start thread");
		return STATUS_UNSUCCESSFUL;
	}
	
	return STATUS_SUCCESS;

}
```

`MappedCallback/mapped_callback.h`:

```h
#pragma once

#include "internals.h"
#include "kernel_utils.h"
#include "scan.h"

typedef LDR_DATA_TABLE_ENTRY* (*fnMiLookupDataTableEntry)(PVOID Address, BOOLEAN);
fnMiLookupDataTableEntry MiLookupDataTableEntry;
UCHAR fnPattern[18] = {	0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x70, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x33, 0xF6 };

PVOID codeCaveThread = NULL;
PVOID codeCaveCallback = NULL;

namespace callback
{
	VOID callbackRoutine(PKPROCESS process, HANDLE handle, PPS_CREATE_NOTIFY_INFO createNotifyInfo)
	{
		UNREFERENCED_PARAMETER(createNotifyInfo);
		UNREFERENCED_PARAMETER(handle);
		DbgPrint("New process created: %s\n", ((EPROCESS*)process)->ImageFileName);
	}

	VOID callbackThread()
	{
		// Remove previous trampoline
		if (!utils::removeTrampoline(codeCaveThread))
			return;

		DbgPrint("Setup the callback\n");
		// Setup the callback
		PsSetCreateProcessNotifyRoutineEx((PCREATE_PROCESS_NOTIFY_ROUTINE_EX)codeCaveCallback, FALSE);
	}

	BOOLEAN findCodeCaves()
	{
		// Start from ACPI base
		PVOID base = utils::getSystemModuleBase("ACPI");

		// Find a codecave for the thread
		UCHAR codeCave[12];
		RtlFillMemory(codeCave, 12, 0xCC);
		codeCaveThread = scan::findCodeCave(base, codeCave, 12, 0);
		if (!codeCaveThread)
		{
			DbgPrint("Unable to find codecave for thread");
			return FALSE;
		}

		// Find a codecave for the callback
		codeCaveCallback = scan::findCodeCave(base, codeCave, 12, (PUINT8)codeCaveThread + 12);
		if (!codeCaveCallback)
		{
			DbgPrint("Unable to find codecave for callback");
			return FALSE;
		}

		return TRUE;
	}

	BOOLEAN alterFlags()
	{
		// Avoid BSOD by tinkering with the Flags attribute for the corresponding data table entry
		UCHAR mask[18];
		RtlFillMemory(mask, 18, 'x');
		MiLookupDataTableEntry = (fnMiLookupDataTableEntry)scan::signatureScanBySection(utils::getKernelBase(), ".text", fnPattern, mask, 18, 0);
		if (!MiLookupDataTableEntry)
			return FALSE;

		LDR_DATA_TABLE_ENTRY* ldr = MiLookupDataTableEntry(codeCaveCallback, FALSE);
		if (!ldr)
			return FALSE;

		ldr->Flags |= 0x20;
		return TRUE;
	}

	BOOLEAN applyTrampolines()
	{
		if (!utils::writeTrampoline(codeCaveThread, &callbackThread))
			return FALSE;

		if (!utils::writeTrampoline(codeCaveCallback, &callbackRoutine))
			return FALSE;

		return TRUE;
	}

	BOOLEAN startThread()
	{
		HANDLE handle;
		NTSTATUS status = PsCreateSystemThread(&handle, THREAD_ALL_ACCESS, 0, 0, 0, (KSTART_ROUTINE*)codeCaveThread, 0);

		return NT_SUCCESS(status);
	}
}
```

`MappedCallback/scan.h`:

```h
#pragma once

#include "internals.h"

namespace scan
{
	UINT64 scanPattern(PUINT8 base, SIZE_T size, PCUCHAR pattern, PCUCHAR mask, SIZE_T patternSize) {
		for (SIZE_T i(0); i < size - patternSize; i++)
		{
			for (SIZE_T j(0); j < patternSize; j++)
			{
				if ((mask == NULL || mask[j] != '?') && *(PUINT8)(base + i + j) != (UINT8)(pattern[j]))
					break;

				if (j == patternSize - 1)
					return (UINT64)(base)+i;
			}
		}

		return NULL;
	}

	PVOID signatureScanBySection(PVOID baseAddress, PCCHAR sectionName, PCUCHAR pattern, PCUCHAR mask, SIZE_T len, PVOID start)
	{
		if (baseAddress == NULL)
			return NULL;

		PIMAGE_NT_HEADERS64 header = RtlImageNtHeader(baseAddress);
		if (!header)
			return NULL;

		ANSI_STRING ansiSectionName, ansiCurrentSectionName;
		RtlInitAnsiString(&ansiSectionName, sectionName);

		PIMAGE_SECTION_HEADER firstSection = (PIMAGE_SECTION_HEADER)((uintptr_t)&header->FileHeader + header->FileHeader.SizeOfOptionalHeader + sizeof(IMAGE_FILE_HEADER));

		// There can be multiple sections with the same name
		for (PIMAGE_SECTION_HEADER section(firstSection); section < firstSection + header->FileHeader.NumberOfSections; section++)
		{
			RtlInitAnsiString(&ansiCurrentSectionName, (PCCHAR)section->Name);
			if (!RtlCompareString(&ansiSectionName, &ansiCurrentSectionName, FALSE))
			{
				UINT64 result = scanPattern(start ? (PUINT8)start : ((PUINT8)baseAddress + section->VirtualAddress), section->Misc.VirtualSize, pattern, mask, len);
				if (result != NULL)
					return (PVOID)result;
			}
		}

		return NULL;
	}

	PVOID findCodeCave(PVOID baseAddress, PCUCHAR pattern, SIZE_T len, PVOID start)
	{
		PCUCHAR mask = (PCUCHAR)ExAllocatePool(PagedPool, len);
		RtlFillMemory((PVOID)mask, len, 'x');
		PVOID codeCave = signatureScanBySection(baseAddress, ".text", pattern, mask, len, start);
		ExFreePool((PVOID)mask);
		return codeCave;
	}
}

```

`README.md`:

```md
# MappedCallback
Register a callback in Kernel from a manually mapped driver.

## Limitations
Registering a callback in the kernel without taking further precautions will either not work or lead to a nice BSOD. 
This small driver, designed to be manually mapped, is able to register a callback in the kernel without triggering any crash.

## How?
By finding a codecave in a legit module in the kernel (here we take APCI driver, which is not protected by PatchGuard), we can write a JMP to our routines so that the start address of the registered function for the callback is in a valid module.<br/>
On top of that, we need to find a way to circumvent MmVerifyCallbackFunction, which is a routine designed to check for the presence of unwanted callbacks.<br/>
If we take a look at this function, we see that it's just a call to MmVerifyCallbackFunctionCheckFlags, with arg = 0x20<br/>
![Alt Text](/img/MmVerifyCallbackFunction.png)<br/>
Then we have a look at MmVerifyCallbackFunctionCheckFlags<br/>
![Alt Text](/img/MmVerifyCallbackFunctionCheckFlags.png)<br/>
The 0x68 here corresponds to the offset of attribute Flags for struct _LDR_DATA_TABLE_ENTRY, as defined in internals.h.
So all we need to do, is find the corresponding data table entry and change the flag so the function will not crash the OS.<br/>
Unfortunately, the MiLookupDataTableEntry function is not exported by ntoskrnl, so we need to make a signature of this function and find it ourselves in memory.

Note that using this is easily detectable as we patch the .text section of a module, and discrepancies can be checked versus the file on disk

```