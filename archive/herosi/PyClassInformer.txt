Project Path: arc_herosi_PyClassInformer_9gzmqdhu

Source Tree:

```txt
arc_herosi_PyClassInformer_9gzmqdhu
├── LICENSE.txt
├── README.md
├── ida-plugin.json
├── images
│   ├── after_libflag_applied.png
│   ├── auto_renmaing.png
│   ├── auto_renmaing2.png
│   ├── before_libflag_applied.png
│   ├── class_hierarchy.png
│   ├── classification.png
│   ├── coloring.png
│   ├── config.png
│   ├── method_classifier.png
│   ├── orig_class_informer.png
│   ├── overridden_methods.png
│   └── result.png
├── pyclassinformer
│   ├── dirtree_utils.py
│   ├── get_func_colors.py
│   ├── lib_classes.json
│   ├── lib_classes_checker.py
│   ├── mc_tree.py
│   ├── method_classifier.py
│   ├── msvc_rtti.py
│   ├── pci_chooser.py
│   ├── pci_config.py
│   ├── pci_config_form.py
│   ├── pci_icon.png
│   ├── pci_utils.py
│   ├── pyclassinformer.py
│   └── qtutils.py
└── pyclassinformer_plugin.py

```

`LICENSE.txt`:

```txt
This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
   distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
```

`README.md`:

```md
# PyClassInformer
## Yet Another RTTI Parsing IDA plugin
![PyClassInformer Icon](/pyclassinformer/pci_icon.png)

PyClassInformer is an RTTI parser. Although there are several RTTI parsers such as Class Informer and SusanRTTI, and even IDA can also parse RTTI, I created this tool. It is because they cannot be used as libraries for parsing RTTI. IDA cannot easily manage class hierarchies such as checking them as a list and filtering the information, either.

**PyClassInformer can parse RTTI on PE formatted binaries compiled by MSVC++ for x86, x64, ARM and ARM64**. Since it is written in IDAPython, you can run it on IDA for Mac OS and Linux as well as Windows. You can also use results of parsing RTTI in your python code by importing this tool as a library.

## Usage
Launch it by pressing Alt+Shift+L. Or navigate to Edit -> Plugins -> PyClassInformer.  
Then, select the options. In most cases, the default options should remain unchanged.

## Installation
Put "pyclassinformer_plugin.py" and "pyclassinformer" folder including the files under it into the "plugins" folder of IDA's user directory ($IDAUSR).  
If you use IDA 8.5 or later and want to manage this plugin with a directory, make a directory like "pci_plugin" in "plugins", copy "ida-plugin.json" into it as well as the files and the folders above.

See the URL if you don't know about "$IDAUSR".  
[https://hex-rays.com/blog/igors-tip-of-the-week-33-idas-user-directory-idausr/](https://hex-rays.com/blog/igors-tip-of-the-week-33-idas-user-directory-idausr/)  
[https://www.hex-rays.com/products/ida/support/idadoc/1375.shtml](https://www.hex-rays.com/products/ida/support/idadoc/1375.shtml)

## Requirements
- IDA Pro 7.4 or later (I tested on 7.4 SP1 to 9.1)
- Python 3.x (I tested on Python 3.8 and 3.10)

You will need at least IDA Pro 7.4 or later because of the APIs that I use. If you want to use full features, use IDA 8.3 or later. Otherwise, some features will be limited to use or skipped.

## Features (short)
- Display class names, vftables and class hierarchies as a list
- Display RTTI parsed results on the Output window
- Display vftables, class names, virtual methods, possible constructors and destructors, and class hierarchies as a dir tree (IDA 7.7 or later)
- Create directories for classes and move virtual methods to them in Functions and Names subviews (IDA 7.7 or later)
- Move functions refer vftables to "possible ctors or dtors" folder under each class directory in Functions and Names subviews (IDA 7.7 or later)
- Rename virtual methods by appending class names to them
- Add the FUNC_LIB flag to methods that known classes own
- Rename possible constructors and destructors
- Coloring known class names and their methods on the list and the tree widgets (IDA 8.3 or later)

## Features in detail
### Default output
![PyClassInformer Result](/images/result.png)
The image above is an example of PyClassInformer result. And the image below is an example of the original Class Informer result.  
  
![Original ClassInformer Result](/images/orig_class_informer.png)  
  
As you see, almost all columns match the original ones.   
  
In addition, PyClassInformer has two more columns. One is "offset", which shows the offset of a vftable in a class layout.  
  
Another one named "Hierarchy Order" shows class hierarchy information related to a vftable of a line. The column shows the order of inheritance from the class to the top-most super class.  
  
These are useful for grasping class layouts and class hierarchies. Double-clicking a line navigates to its vftable address as well.

### RTTI parsed results
If you check the Output window, you will also see parsed RTTI information such as Complete Object Locator as COL, Class Hierarchy Descriptor as CHD and Base Class Descriptor as BCD with their addresses. They are useful for checking more details and debugging.  
  
![Class Hierarchy](/images/class_hierarchy.png)  

You will also see class hierarchies by checking indents of BCDs. For example, CMFCComObject, which is the class for the vftable at 0x530fcc, inherits ATL::CAccessibleProxy. And ATL::CAccessibleProxy inherits three super classes, ATL::CComObjectRootEx, ATL::IAccessibleProxyImpl and IOleWindow. Like this, you can get class hierarchy information as a form of a tree.

### Automatic renaming
PyClassInformer can automatically append class names to their virtual method names. Therefore, you can easily find them by filtering the class name. The image below is a result appending a class name "CDC" to its methods.  

![automatically renaming virtual methods](/images/auto_renmaing.png)  
  
PyClassInformer can also rename functions that refer to vftables to "class name" + "_possible_ctor_or_dtor". The image below is a result. Although some false positives will occur due to inlined ctors and dtors, and dynamic initializers, this feature is still useful to find them.  
  
![automatically renaming possible ctors and dtors](/images/auto_renmaing2.png)  

### Virtual method classification (<= IDA 7.7)
The detected methods are moved to each class folder in Functions and Names subviews.  
> [!NOTE]
> This is only available IDA 7.7 or later. 
  
![method classifications](/images/classification.png)  
  
PyClassInformer also displays a new widget named "Method Classifier". It lists all detected classes, vftables, virtual methods and possible constructors and destructors, and class hierarchies at once as a form of a tree.  

![method classifier](/images/method_classifier.png)  

> [!TIP]
> Class hierarchies are represented as directories in Method Classifier.
> Unfortunately, IDA's quick filter feature cannot filter directory contents.
> To search them, use text search feature (Ctrl+T (find first text) and Alt+T (Find next text)).
> For example, input a class name, a single space, and a parenthesis like "CWinApp (".

> [!NOTE]
> This is only available IDA 7.7 or later. 

### Known classes detection (<= IDA 8.3)
PyClassInformer can color known class names for easily finding user-defined classes.
The image below is an example of a coloring result.  
You can easily find CSimpleTestApp, CSimpleTestDoc, CSimpleTestView and CSimpleTestCtrlItem are user-defined classes. So you can focus on checking them.  
  
![Class coloring](/images/coloring.png)  

The coloring is also applied to Method Classifier widget. Therefore, you can easily find overridden virtual methods like the image below.  

![Methods coloring](/images/overridden_methods.png)  
  
> [!NOTE]
> The coloring feature is only available IDA 8.3 or later. 
  
Known class names are defined in "lib_classes.json". I added many patterns related to STL, which starts with "std::", and several versions of MFC Application with MFC Application Wizard.  
If you find some additional legitimate classes, you can add them to it.  

PyClassInformer also adds the FUNC_LIB flag to the methods that match the list. Therefore, you can recognize they are a part of static linked libraries.  
The following images are before and after PyClassInformer execution. Many known class methods are found and IDA can recognize them as a part of static linked libraries.  
  
![Methods coloring](/images/before_libflag_applied.png)  
![Methods coloring](/images/after_libflag_applied.png)  

## Note
- I **WILL NOT** support parsing GCC's RTTI. **DO NOT** open an issue about it.
- I **WILL NOT** support beta versions of IDA. **DO NOT** open an issue about it.
- I **WILL NOT** support IDA free and IDA demo except for IDA Classroom Free because they do not have IDAPython.
- Some code is from SusanRTTI and the output table is similar to Class Informer.  
[https://github.com/nccgroup/SusanRTTI](https://github.com/nccgroup/SusanRTTI)  
[https://sourceforge.net/projects/classinformer/](https://sourceforge.net/projects/classinformer/)

```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "PyClassInformer",
    "entryPoint": "pyclassinformer_plugin.py"
  }
}

```

`pyclassinformer/dirtree_utils.py`:

```py
#import ida_idaapi
import ida_dirtree

def get_full_paths(dirtree, recurse=False, search_path=""):
    iterator = ida_dirtree.dirtree_iterator_t()
    r = dirtree.findfirst(iterator, "{}/*".format(search_path))
    while r:
        de = dirtree.resolve_cursor(iterator.cursor)
        path = dirtree.get_abspath(iterator.cursor)
        if not de.isdir:
            yield path, de, iterator.cursor
        elif de.isdir and recurse:
            # if dir_entry is a directory, execute it recursively 
            for rpath, rde, rcur in get_full_paths(dirtree, recurse, path):
                yield rpath, rde, rcur
        r = dirtree.findnext(iterator)

"""
# get the top level func paths
abs_paths = []
for path, de, cursor in get_full_paths(dirtree):
    abs_paths.append(path)
"""

# An inode can be ea in standard dirtrees such as Functions and Names.
# It can also be structure ids and enum ids and so on.
def get_cursor_by_inode(dirtree, inode):
    de = ida_dirtree.direntry_t(inode)
    cursor = dirtree.find_entry(de)
    return cursor

def get_abs_path_by_inode(dirtree, inode):
    cursor = get_cursor_by_inode(dirtree, inode)
    abs_path = dirtree.get_abspath(cursor)
    return abs_path

def get_parent_dir_by_inode(dirtree, inode):
    cursor = get_cursor_by_inode(dirtree, inode)
    cursor = dirtree.get_parent_cursor(cursor)
    abs_path = dirtree.get_abspath(cursor)
    return abs_path

```

`pyclassinformer/get_func_colors.py`:

```py
import ida_kernwin
import ida_funcs
import ida_idaapi

ida_idaapi.require("pyclassinformer")
ida_idaapi.require("pyclassinformer.qtutils")


def get_chooser_data(chooser="Functions"):
    cri = ida_kernwin.chooser_row_info_vec_t()
    ida_kernwin.get_chooser_rows(cri, chooser, ida_kernwin.GCRF_ALL)
    return cri

def get_func_color(cri, f):
    if f:
        for r in cri:
            fea = int(r.texts[2],16)
            color = r.attrs.color
            if fea == f.start_ea:
                return color
    return -1

def get_libfunc():
    for n in range(ida_funcs.get_func_qty()):
        f = ida_funcs.getn_func(n)
        if f.flags & ida_funcs.FUNC_LIB:
            return f
    return None

def get_genfunc():
    for n in range(ida_funcs.get_func_qty()):
        f = ida_funcs.getn_func(n)
        if not f.flags & ida_funcs.FUNC_LIB and not f.flags & ida_funcs.FUNC_LUMINA and not f.flags & ida_funcs.FUNC_THUNK:
            return f
    return None

def get_gen_lib_func_colors():
    try:
        # IDA 8.4 or later only has chooser_row_info_vec_t and get_chooser_rows
        cri = get_chooser_data()
    except AttributeError:
        cri = None
        
    gen_func_color = -1
    lib_func_color = -1
    
    if cri is not None:
        f = get_genfunc()
        gen_func_color = get_func_color(cri, f)

        f = get_libfunc()
        lib_func_color = get_func_color(cri, f)
        
    #print(hex(gen_func_color), hex(lib_func_color))
    
    # if something is wrong, set default colors
    if gen_func_color < 0:
        gen_func_color = 0xffffffff
    if lib_func_color < 0:
        lib_func_color = 0xffffffe9
        dark = False
        # check if dark mode is enabled or not
        try:
            dark = pyclassinformer.qtutils.dark_mode_checker_t.is_dark_mode()
        except:
            pass
        # set the default dark mode color on IDA
        if dark:
            lib_func_color = 0xff685328
    
    return gen_func_color, lib_func_color

#print([hex(x) for x in get_gen_lib_func_colors()])

```

`pyclassinformer/lib_classes.json`:

```json
{
    "=":[
        "AFX_MODULE_STATE",
        "AFX_MODULE_THREAD_STATE",
        "ATL::CComObjectNoLock<class ATL::CAccessibleProxy>",
        "ATL::CFixedStringMgr",
        "ATL::CFixedStringT<class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t>>>,256>",
        "ATL::CImage",
        "CAboutDlg",
        "CAfxStringMgr",
        "CArchiveException",
        "CArchiveStream",
        "CArray<__int64,__int64>",
        "CArray<class CButton *,class CButton * const &>",
        "CArray<class CMFCRibbonBaseElement *,class CMFCRibbonBaseElement *>",
        "CArray<class CMFCRibbonContextCaption *,class CMFCRibbonContextCaption *>",
        "CArray<class CMFCRibbonKeyTip *,class CMFCRibbonKeyTip *>",
        "CArray<class CMFCRibbonPanel *,class CMFCRibbonPanel *>",
        "CArray<class CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem *,class CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem *>",
        "CArray<class CSize,class CSize>",
        "CArray<class CVariantBoolPair,class CVariantBoolPair const &>",
        "CArray<enum CArchive::LoadArrayObjType,enum CArchive::LoadArrayObjType const &>",
        "CArray<int,int const &>",
        "CArray<int,int>",
        "CArray<long,long>",
        "CArray<struct CTaskDialog::_CTaskDialogButton,struct CTaskDialog::_CTaskDialogButton const &>",
        "CArray<struct HWND__ *,struct HWND__ *>",
        "CArray<unsigned int,unsigned int>",
        "CArray<unsigned long,unsigned long>",
        "CAutoHideDockSite",
        "CBasePane",
        "CBaseTabbedPane",
        "CBitmap",
        "CBrowserControlSite",
        "CBrush",
        "CButton",
        "CByteArray",
        "CCellObj",
        "CCheckListBox",
        "CChevronOwnerDrawMenu",
        "CClientDC",
        "CCmdUI",
        "CColorDialog",
        "CComCtlWrapper",
        "CComboBox",
        "CCommDlgWrapper",
        "CCommandLineInfo",
        "CCommandManager",
        "CCommonDialog",
        "CControlSiteFactoryMgr",
        "CCriticalSection",
        "CDC",
        "CDHtmlControlSink",
        "CDHtmlDialog",
        "CDHtmlElementEventSink",
        "CDHtmlEventSink",
        "CDWordArray",
        "CDataRecoveryHandler",
        "CDataSourceControl",
        "CDialog",
        "CDialogBar",
        "CDialogEx",
        "CDialogImpl",
        "CDlgDrawer",
        "CDllIsolationWrapperBase",
        "CDocItem",
        "CDocManager",
        "CDockBar",
        "CDockSite",
        "CDockState",
        "CDockablePane",
        "CDockablePaneAdapter",
        "CDockingManager",
        "CDockingPanesRow",
        "CDrawingManager",
        "CDummyDockablePane",
        "CEdit",
        "CEnumArray",
        "CEnumArray::XEnumVOID",
        "CEnumFormatEtc",
        "CEnumUnknown",
        "CFile",
        "CFileDialog",
        "CFileDialog::XFileDialogControlEvents",
        "CFileDialog::XFileDialogEvents",
        "CFileException",
        "CFindReplaceDialog",
        "CFont",
        "CFontDialog",
        "CFormView",
        "CFrameImpl",
        "CFrameWnd",
        "CFrameWndEx",
        "CFullScreenImpl",
        "CGdiObject",
        "CGlobalUtils",
        "CHandleMap",
        "CHeaderCtrl",
        "CHelpComboBoxButton",
        "CImageList",
        "CInvalidArgException",
        "CList<class CFrameWnd *,class CFrameWnd *>",
        "CList<class CMDIChildWndEx *,class CMDIChildWndEx *>",
        "CList<class CMFCButton *,class CMFCButton *>",
        "CList<class CMFCPropertyGridProperty *,class CMFCPropertyGridProperty *>",
        "CList<class CPropertyPage *,class CPropertyPage *>",
        "CList<class IControlSiteFactory *,class IControlSiteFactory *>",
        "CList<struct AFX_AUTOHIDE_DOCKSITE_SAVE_INFO,struct AFX_AUTOHIDE_DOCKSITE_SAVE_INFO &>",
        "CList<struct AFX_DYNAMIC_LAYOUT_ITEM *,struct AFX_DYNAMIC_LAYOUT_ITEM *>",
        "CList<struct CMFCDynamicLayoutData::Item,struct CMFCDynamicLayoutData::Item &>",
        "CList<struct CMFCRestoredTabInfo,struct CMFCRestoredTabInfo>",
        "CList<struct HINSTANCE__ *,struct HINSTANCE__ *>",
        "CList<struct HWND__ *,struct HWND__ * &>",
        "CList<struct HWND__ *,struct HWND__ *>",
        "CList<struct _ITEMIDLIST *,struct _ITEMIDLIST *>",
        "CList<struct _ITEMIDLIST __unaligned *,struct _ITEMIDLIST __unaligned *>",
        "CList<struct tagPOINT,struct tagPOINT>",
        "CList<unsigned __int64,unsigned __int64>",
        "CList<unsigned int,unsigned int &>",
        "CList<unsigned int,unsigned int>",
        "CList<unsigned long,unsigned long>",
        "CListBox",
        "CListCtrl",
        "CMDIChildWnd",
        "CMDIChildWndEx",
        "CMDIClientAreaWnd",
        "CMDIFrameWnd",
        "CMDIFrameWndEx",
        "CMDITabProxyWnd",
        "CMFCAcceleratorKey",
        "CMFCAcceleratorKeyAssignCtrl",
        "CMFCAutoHideBar",
        "CMFCAutoHideButton",
        "CMFCBaseAccessibleObject",
        "CMFCBaseAccessibleObject::XAccessible",
        "CMFCBaseTabCtrl",
        "CMFCBaseToolBar",
        "CMFCBaseVisualManager",
        "CMFCButton",
        "CMFCCaptionBar",
        "CMFCCaptionButton",
        "CMFCCaptionButtonEx",
        "CMFCCaptionMenuButton",
        "CMFCCmdUsageCount",
        "CMFCColorBar",
        "CMFCColorBarCmdUI",
        "CMFCColorButton",
        "CMFCColorDialog",
        "CMFCColorMenuButton",
        "CMFCColorPickerCtrl",
        "CMFCColorPopupMenu",
        "CMFCColorPropertySheet",
        "CMFCComObject<class ATL::CAccessibleProxy>",
        "CMFCControlBarImpl",
        "CMFCControlContainer",
        "CMFCControlRenderer",
        "CMFCCustomColorsPropertyPage",
        "CMFCCustomizeButton",
        "CMFCCustomizeMenuButton",
        "CMFCDisableMenuAnimation",
        "CMFCDragFrameImpl",
        "CMFCDropDownFrame",
        "CMFCDropDownToolBar",
        "CMFCDropDownToolbarButton",
        "CMFCDynamicLayout",
        "CMFCEditBrowseCtrl",
        "CMFCFontComboBox",
        "CMFCFontInfo",
        "CMFCHeaderCtrl",
        "CMFCImageEditorDialog",
        "CMFCImageEditorPaletteBar",
        "CMFCImagePaintArea",
        "CMFCLinkCtrl",
        "CMFCListCtrl",
        "CMFCMaskedEdit",
        "CMFCMenuBar",
        "CMFCMenuButton",
        "CMFCMousePropertyPage",
        "CMFCOutlookBar",
        "CMFCOutlookBarPane",
        "CMFCOutlookBarPaneAdapter",
        "CMFCOutlookBarPaneButton",
        "CMFCOutlookBarScrollButton",
        "CMFCOutlookBarTabCtrl",
        "CMFCOutlookBarToolBar",
        "CMFCPopupMenu",
        "CMFCPopupMenuBar",
        "CMFCPrintPreviewToolBar",
        "CMFCPropertyGridCtrl",
        "CMFCPropertyGridToolTipCtrl",
        "CMFCPropertyPage",
        "CMFCRibbonBaseElement",
        "CMFCRibbonButton",
        "CMFCRibbonButtonsGroup",
        "CMFCRibbonCaptionButton",
        "CMFCRibbonCategory",
        "CMFCRibbonCmdUI",
        "CMFCRibbonColorButton",
        "CMFCRibbonColorMenuButton",
        "CMFCRibbonDefaultPanelButton",
        "CMFCRibbonEdit",
        "CMFCRibbonGallery",
        "CMFCRibbonGalleryIcon",
        "CMFCRibbonKeyTip",
        "CMFCRibbonLabel",
        "CMFCRibbonLaunchButton",
        "CMFCRibbonMainPanel",
        "CMFCRibbonMiniToolBar",
        "CMFCRibbonPanel",
        "CMFCRibbonPanelMenu",
        "CMFCRibbonPanelMenuBar",
        "CMFCRibbonQuickAccessCustomizeButton",
        "CMFCRibbonQuickAccessToolBar",
        "CMFCRibbonRecentFilesList",
        "CMFCRibbonRichEditCtrl",
        "CMFCRibbonSeparator",
        "CMFCRibbonSpinButtonCtrl",
        "CMFCRibbonTab",
        "CMFCRibbonUndoButton",
        "CMFCShadowRenderer",
        "CMFCShadowWnd",
        "CMFCShellListCtrl",
        "CMFCShellTreeCtrl",
        "CMFCShowAllButton",
        "CMFCSpinButtonCtrl",
        "CMFCStandardColorsPropertyPage",
        "CMFCTabButton",
        "CMFCTabCtrl",
        "CMFCTabDropTarget",
        "CMFCTabInfo",
        "CMFCTasksPane",
        "CMFCTasksPaneFrameWnd",
        "CMFCTasksPanePropertyPage",
        "CMFCTasksPaneToolBar",
        "CMFCTasksPaneToolBarCmdUI",
        "CMFCToolBar",
        "CMFCToolBarButton",
        "CMFCToolBarButtonCustomizeDialog",
        "CMFCToolBarButtonsListButton",
        "CMFCToolBarCmdUI",
        "CMFCToolBarColorButton",
        "CMFCToolBarComboBoxButton",
        "CMFCToolBarComboBoxEdit",
        "CMFCToolBarDropSource",
        "CMFCToolBarDropTarget",
        "CMFCToolBarEditBoxButton",
        "CMFCToolBarEditCtrl",
        "CMFCToolBarFontComboBox",
        "CMFCToolBarFontSizeComboBox",
        "CMFCToolBarImages",
        "CMFCToolBarMenuButton",
        "CMFCToolBarMenuButtonsButton",
        "CMFCToolBarNameDialog",
        "CMFCToolBarSystemMenuButton",
        "CMFCToolBarsCommandsListBox",
        "CMFCToolBarsCommandsPropertyPage",
        "CMFCToolBarsCustomizeDialog",
        "CMFCToolBarsKeyboardPropertyPage",
        "CMFCToolBarsListCheckBox",
        "CMFCToolBarsListPropertyPage",
        "CMFCToolBarsMenuPropertyPage",
        "CMFCToolBarsOptionsPropertyPage",
        "CMFCToolBarsToolsPropertyPage",
        "CMFCToolTipCtrl",
        "CMFCVisualManager",
        "CMFCVisualManagerBitmapCache",
        "CMFCVisualManagerBitmapCache::CMFCVisualManagerBitmapCacheItem",
        "CMFCVisualManagerOffice2003",
        "CMFCVisualManagerOffice2007",
        "CMFCVisualManagerOfficeXP",
        "CMFCVisualManagerWindows",
        "CMFCZoomKernel",
        "CMainFrame",
        "CMap<class ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char>>>,char const *,bool,bool>",
        "CMap<class ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char>>>,char const *,class ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char>>>,char const *>",
        "CMap<class ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char>>>,char const *,class CDocument *,class CDocument *>",
        "CMap<class ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char>>>,char const *,class CObList *,class CObList *>",
        "CMap<class ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char>>>,char const *,int,int>",
        "CMap<class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t>>>,wchar_t const *,bool,bool>",
        "CMap<class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t>>>,wchar_t const *,class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t>>>,wchar_t const *>",
        "CMap<class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t>>>,wchar_t const *,class CDocument *,class CDocument *>",
        "CMap<class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t>>>,wchar_t const *,class CObList *,class CObList *>",
        "CMap<class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t>>>,wchar_t const *,int,int>",
        "CMap<class CDocument *,class CDocument *,class ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char>>>,char const *>",
        "CMap<class CDocument *,class CDocument *,class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t>>>,wchar_t const *>",
        "CMap<class CWnd *,class CWnd *,class CImageList *,class CImageList *>",
        "CMap<int,int,int,int>",
        "CMap<int,int,unsigned int,unsigned int>",
        "CMap<struct HICON__ *,struct HICON__ *,int,int>",
        "CMap<struct HMENU__ *,struct HMENU__ * &,void *,void * &>",
        "CMap<struct HWND__ *,struct HWND__ *,int,int>",
        "CMap<unsigned int,unsigned int &,class CMFCToolBarButton *,class CMFCToolBarButton * &>",
        "CMap<unsigned int,unsigned int,class CMFCRibbonStatusBarPane *,class CMFCRibbonStatusBarPane *>",
        "CMap<unsigned int,unsigned int,class CPane *,class CPane *>",
        "CMap<unsigned int,unsigned int,int,int>",
        "CMap<unsigned int,unsigned int,struct HICON__ *,struct HICON__ *>",
        "CMap<unsigned int,unsigned int,struct HWND__ *,struct HWND__ *>",
        "CMap<unsigned int,unsigned int,unsigned int,unsigned int>",
        "CMap<unsigned int,unsigned int,unsigned long,unsigned long>",
        "CMap<unsigned long,unsigned long,class ATL::CStringT<char,class StrTraitMFC<char,class ATL::ChTraitsCRT<char>>>,char const *>",
        "CMap<unsigned long,unsigned long,class ATL::CStringT<wchar_t,class StrTraitMFC<wchar_t,class ATL::ChTraitsCRT<wchar_t>>>,wchar_t const *>",
        "CMapPtrToPtr",
        "CMapStringToPtr",
        "CMapWordToOb",
        "CMemDC",
        "CMemFile",
        "CMemoryException",
        "CMenu",
        "CMenuHash",
        "CMiniDockFrameWnd",
        "CMiniFrameWnd",
        "CMirrorFile",
        "CMouseManager",
        "CMultiDocTemplate",
        "CMultiPaneFrameWnd",
        "CNewTypeDlg",
        "CNotSupportedException",
        "CObArray",
        "CObList",
        "COccManager",
        "COleBusyDialog",
        "COleClientItem",
        "COleClientItem::XAdviseSink",
        "COleClientItem::XOleClientSite",
        "COleClientItem::XOleIPSite",
        "COleCmdUI",
        "COleCntrFrameWnd",
        "COleCntrFrameWndEx",
        "COleControlContainer",
        "COleControlContainer::XOleContainer",
        "COleControlContainer::XOleIPFrame",
        "COleControlSite",
        "COleControlSite::XAmbientProps",
        "COleControlSite::XBoundObjectSite",
        "COleControlSite::XEventSink",
        "COleControlSite::XNotifyDBEvents",
        "COleControlSite::XOleClientSite",
        "COleControlSite::XOleControlSite",
        "COleControlSite::XOleIPSite",
        "COleControlSite::XPropertyNotifySink",
        "COleControlSite::XRowsetNotify",
        "COleControlSiteFactory",
        "COleDataSource",
        "COleDataSource::XDataObject",
        "COleDispatchException",
        "COleDispatchImpl",
        "COleDocIPFrameWnd",
        "COleDocIPFrameWndEx",
        "COleDocument",
        "COleDropSource",
        "COleDropSource::XDropSource",
        "COleDropTarget",
        "COleDropTarget::XDropTarget",
        "COleException",
        "COleFrameHook",
        "COleFrameHook::XOleCommandTarget",
        "COleFrameHook::XOleInPlaceFrame",
        "COleIPFrameWnd",
        "COleIPFrameWndEx",
        "COleInsertDialog",
        "COleLinkingDoc",
        "COleLinkingDoc::XOleItemContainer",
        "COleLinkingDoc::XPersistFile",
        "COleLinksDialog",
        "COleMessageFilter",
        "COleMessageFilter::XMessageFilter",
        "COleObjectFactory",
        "COleObjectFactory::XClassFactory",
        "COlePasteSpecialDialog",
        "COlePropertiesDialog",
        "COlePropertiesDialog::XOleUIObjInfo",
        "COleServerDoc::XDataObject",
        "COleServerDoc::XOleInPlaceActiveObject",
        "COleServerDoc::XOleInPlaceObject",
        "COleServerDoc::XOleObject",
        "COleServerDoc::XPersistStorage",
        "COleStreamFile",
        "COleTemplateServer",
        "COleUILinkInfo",
        "COutlookCustomizeButton",
        "COutlookOptionsDlg",
        "CPaintDC",
        "CPalette",
        "CPane",
        "CPaneContainer",
        "CPaneContainerManager",
        "CPaneDivider",
        "CPaneFrameWnd",
        "CPaneTrackingWnd",
        "CPen",
        "CPngImage",
        "CPreviewDC",
        "CPreviewView",
        "CPreviewViewEx",
        "CPrintDialog",
        "CPrintingDialog",
        "CPropertyPage",
        "CPropertySheet",
        "CPtrArray",
        "CPtrList",
        "CReBar",
        "CRecentDockSiteInfo",
        "CRecentFileList",
        "CRecentPaneContainerInfo",
        "CResourceException",
        "CRgn",
        "CRibbonCategoryScroll",
        "CRibbonUndoLabel",
        "CRichEditCntrItem",
        "CRichEditCtrl",
        "CRichEditView",
        "CRichEditView::XRichEditOleCallback",
        "CScreenWnd",
        "CScrollBar",
        "CScrollView",
        "CSettingsStore",
        "CSharedFile",
        "CShellManager",
        "CShellWrapper",
        "CSimpleException",
        "CSmartDockingGroupGuide",
        "CSmartDockingGroupGuidesManager",
        "CSmartDockingGroupGuidesWnd",
        "CSmartDockingHighlighterWnd",
        "CSmartDockingInfo",
        "CSmartDockingManager",
        "CSmartDockingStandaloneGuide",
        "CSmartDockingStandaloneGuideWnd",
        "CSpinButtonCtrl",
        "CStatic",
        "CStatusBar",
        "CStatusCmdUI",
        "CStringArray",
        "CStringList",
        "CSyncObject",
        "CTabbedPane",
        "CTagManager",
        "CTaskDialog",
        "CTasksPaneHistoryButton",
        "CTasksPaneMenuButton",
        "CTasksPaneNavigateButton",
        "CTestCmdUI",
        "CThreadData",
        "CToolBar",
        "CToolCmdUI",
        "CToolTipCtrl",
        "CTreeCtrl",
        "CTypedPtrArray<class CObArray,class CBitmap *>",
        "CTypedPtrArray<class CObArray,class CMFCCaptionButton *>",
        "CTypedPtrList<class CPtrList, struct COleControlSiteOrWnd *>",
        "CTypedPtrList<class CPtrList,struct COleControlSiteOrWnd *>",
        "CUIntArray",
        "CUserException",
        "CUserTool",
        "CVSListBox",
        "CVSListBoxBase",
        "CVSListBoxEditCtrl",
        "CVSToolsListBox",
        "CWinApp",
        "CWinThread",
        "CWindowDC",
        "CWnd",
        "CWnd::XAccessible",
        "CWnd::XAccessibleServer",
        "Gdiplus::Bitmap",
        "Gdiplus::Image",
        "IAccessibleProxy",
        "IControlSiteFactory",
        "IOleWindow",
        "_AFX_BASE_MODULE_STATE",
        "_AFX_CHECKLIST_STATE",
        "_AFX_COLOR_STATE ",
        "_AFX_COLOR_STATE",
        "_AFX_CTL3D_STATE",
        "_AFX_CTL3D_THREAD",
        "_AFX_D2D_STATE",
        "_AFX_EDIT_STATE",
        "_AFX_HTMLHELP_STATE",
        "_AFX_MOUSEANCHORWND",
        "_AFX_OLE_STATE",
        "_AFX_PROPPAGEFONTINFO",
        "_AFX_RICHEDIT_STATE",
        "_AFX_SOCK_STATE",
        "_AFX_THREAD_STATE",
        "_AFX_WIN_STATE",
        "_CTypedPtrList<class CPtrList, struct COleControlSiteOrWnd *>",
        "_CTypedPtrList<class CPtrList,struct COleControlSiteOrWnd *>",
        "type_info"
    ],
    "startswith":[
        "std::"
    ],
    "regex":[
    ]
}

```

`pyclassinformer/lib_classes_checker.py`:

```py
import os
import json
import re

class lib_classes_checker_t(object):
    
    def __init__(self, rules=os.path.join(os.path.dirname(__file__),"lib_classes.json")):
        self.lib_class_ptns = {}
        with open(rules) as f:
            self.lib_class_ptns = json.load(f)
            
    def does_class_startwith(self, name, ptns):
        for ptn in ptns:
            if name.startswith(ptn):
                return True
        return False
    
    def does_class_match_regex_ptns(self, name, ptns):
        for ptn in ptns:
            if re.match(ptn, name):
                return True
        return False
    
    def is_class_lib(self, name):
        r = False
        if name in self.lib_class_ptns["="]:
            r = True
        elif self.does_class_startwith(name, self.lib_class_ptns["startswith"]):
            r = True
        elif self.does_class_match_regex_ptns(name, self.lib_class_ptns["regex"]):
            r = True
        return r

def set_libflag(data):
    for vftable_ea in data:
        col = data[vftable_ea]
        
        # get the class name that owns the vftable
        class_name = col.name
        
        # check the class is a part of standard library classes such as STL and MFC
        lib_class_ptns = lib_classes_checker_t()
        col.libflag = col.LIBNOTLIB
        if lib_class_ptns.is_class_lib(class_name):
            col.libflag = col.LIBLIB

"""
lib_class_ptns = lib_classes_checker_t()
print(lib_class_ptns.is_class_lib("std::aaaa")) # True
print(lib_class_ptns.is_class_lib("CWinApp")) # True
print(lib_class_ptns.is_class_lib("CSimpleTextApp")) # False
"""

```

`pyclassinformer/mc_tree.py`:

```py
import idc
import ida_kernwin
import ida_idaapi
import ida_dirtree
import ida_name
import idautils
import ida_funcs

ida_idaapi.require("pyclassinformer")
ida_idaapi.require("pyclassinformer.pci_utils")
ida_idaapi.require("pyclassinformer.dirtree_utils")

# dirspec for the dirtree
class my_dirspec_t(ida_dirtree.dirspec_t):
    def __init__(self, chooser):
        ida_dirtree.dirspec_t.__init__(self)
        self.chooser = chooser
        
        self.inodes = []
        self.name_index = {}

    def add_entry(self, dirpath, name):
        if (dirpath, name) not in self.inodes:
            new_inode = len(self.inodes)
            self.inodes.append((dirpath, name))
            self.name_index[dirpath, name] = new_inode
        # inode has already been inserted
        else:
            new_inode = -1
        return new_inode
    
    def update_parent_dir(self, inode, new_dirpath):
        # get old dir and node name by inode
        old_dirpath, name = self.get_name_idx(inode)
        
        # change dir entry to new one
        if old_dirpath != new_dirpath:
            del self.name_index[old_dirpath, name]
            self.name_index[new_dirpath, name] = inode
            self.inodes[inode] = (new_dirpath, name)

    def get_name_idx(self, inode):
        if inode >= 0 and inode < len(self.inodes):
            #print("get_name", self.inodes[inode])
            return self.inodes[inode]

    def get_name(self, inode, flags=0):
        return self.get_name_idx(inode)[1]

    def get_inode(self, dirpath, name):
        #print("get_inode", dirpath, name, self.name_index.get((dirpath, name), ida_dirtree.direntry_t.BADIDX))
        return self.name_index.get((dirpath, name), ida_dirtree.direntry_t.BADIDX)

    def n_inodes(self):
        return len(self.inodes)
    
    def rename_inode(self, inode, newname):
        #print("rename_inode", inode, newname)
        return ida_dirtree.dirspec_t.rename_inode(self, inode, newname)
    
    def get_attrs(self, inode):
        pass

    def unlink_inode(self, inode):
        pass


class mc_tree_t(ida_kernwin.Choose):

    def __init__(self, title, data, base_class_paths, icon=-1):
        self.dirspec = my_dirspec_t(self)
        self.dirtree = ida_dirtree.dirtree_t(self.dirspec)

        self.data = data
        self.base_class_paths = base_class_paths
        
        ida_kernwin.Choose.__init__(
            self,
            title,
            [
                ["EA",   15 | ida_kernwin.Choose.CHCOL_EA|ida_kernwin.CHCOL_FNAME],
                ["Name",   50  | ida_kernwin.Choose.CHCOL_PLAIN|ida_kernwin.Choose.CHCOL_INODENAME],
                ["Offset",     4  | ida_kernwin.Choose.CHCOL_HEX],
                ["CdOffset",   4 | ida_kernwin.Choose.CHCOL_HEX],
            ],
            flags=ida_kernwin.CH_TM_FULL_TREE|ida_kernwin.CH_NON_PERSISTED_TREE|ida_kernwin.CH_RENAME_IS_EDIT,
            icon=icon
        )
        self.items = []
            
    def process_data(self):
        for vftable_ea in self.data:
            col = self.data[vftable_ea]
            class_name = col.name
            
            # for creating a directory of a class name
            dirtree_path = "/" + class_name + "/" # needs the last slash for a directory
            self.dirtree.mkdir(dirtree_path)
            
            bc_path = self.base_class_paths[vftable_ea]
            if not bc_path:
                continue
            actual_class_name = bc_path[-1].name

            # for vftable folder
            dp = dirtree_path + "vftable/" # needs the last slash for a directory
            self.dirtree.mkdir(dp)
                
            # for vftable with COL info
            # get demangled name
            name = ida_name.get_short_name(vftable_ea)
            # add the actual class name information
            if class_name != actual_class_name:
                name += " for {} ({})".format(actual_class_name, col.offset)
            inode, r = self.add_item(dp, vftable_ea, name, col.offset, col.cdOffset)
            
            # for virtual methods folder
            dp = dirtree_path + "virtual methods/" # needs the last slash for a directory
            self.dirtree.mkdir(dp)
            
            # if the class has multiple vftables, create a nested folder
            col_offs = pyclassinformer.pci_utils.utils.get_col_offs(col, self.data)
            if len(col_offs) > 1:
                # if the class has multiple vftables, create a nested folder with the actual class name
                if class_name != actual_class_name:
                    dp += "virtual methods for {} ({})/".format(actual_class_name, col.offset) # needs the last slash for a directory
                else:
                    dp += "virtual methods/" # needs the last slash for a directory
                self.dirtree.mkdir(dp)
            
            # add virtual methods to the folder
            for vfea in col.vfeas:
                name = ida_name.get_short_name(vfea)
                inode, r = self.add_item(dp, vfea, name, ida_idaapi.BADADDR, ida_idaapi.BADADDR)
                
            # add functions that refer to vftable
            dp = dirtree_path + "possible ctors or dtors/" # needs the last slash for a directory
            self.dirtree.mkdir(dp)
            for refea in idautils.DataRefsTo(vftable_ea):
                f = ida_funcs.get_func(refea)
                if f:
                    name = ida_name.get_short_name(f.start_ea)
                    inode, r = self.add_item(dp, f.start_ea, name, ida_idaapi.BADADDR, ida_idaapi.BADADDR)
            
            # for hierarchy path
            for off in col.chd.bca.paths:
                for path in col.chd.bca.paths[off]:
                    dpath = [dirtree_path+"hierarchy"]
                    dp = "/".join(dpath)
                    self.dirtree.mkdir(dp + "/") # needs the last slash for a directory
                    for bcd in path:
                        # make directory for a BCD
                        dpath.append(bcd.name + " ({},{},{})".format(bcd.mdisp, bcd.pdisp, bcd.vdisp))
                        dp = "/".join(dpath)
                        self.dirtree.mkdir(dp + "/") # needs the last slash for a directory
                        
                        # IDA seems not to apply quick filter to directories.
                        # to avoid that, insert a text node as well if you want.
                        #name = bcd.name + " ({},{},{})".format(bcd.mdisp, bcd.pdisp, bcd.vdisp)
                        #inode, r = self.add_item(dp, bcd.ea, name, ida_idaapi.BADADDR, ida_idaapi.BADADDR)
                        #print(dp, name, inode, r, self.dirtree.getcwd(), len(self.items), self.dirspec.n_inodes())
                        
    def add_item(self, dirtree_path, ea, name, offset, cdoffset):
        r = -1
        inode = self.dirspec.add_entry(dirtree_path, name)
        if inode >= 0:
            self.items.append([hex(ea) if ea != ida_idaapi.BADADDR else "", name, hex(offset) if offset != ida_idaapi.BADADDR else "", hex(cdoffset) if cdoffset != ida_idaapi.BADADDR else "", ea])
            self.dirtree.chdir(dirtree_path)
            r = self.dirtree.link(inode)
        return inode, r
    
    def OnInit(self):
        self.process_data()
        return True

    def OnGetSize(self):
        return self.dirspec.n_inodes()

    def OnGetLine(self, n):
        #inode = self.OnIndexToInode(n)
        return self.items[n]
        
    # for old versions of IDA
    def OnSelectLine(self, n):
        idc.jumpto(self.items[n][-1])
        return (ida_kernwin.Choose.NOTHING_CHANGED, )

    def OnGetEA(self, n):
        return self.items[n][-1]
    
    def OnInsertLine(self, sel):
        #print("OnInsertLine", sel)
        pass

    def OnDeleteLine(self, sel):
        #print("OnDeleteLine", sel)
        pass

    def OnEditLine(self, sel):
        #print("OnEditLine", sel)
        pass
        
    def OnSelectionChange(self, sel):
        # get inode and get the current dir and the cached entry
        inode = self.OnIndexToInode(sel)
        curr_dir, name = self.dirspec.get_name_idx(inode)
        abs_path = pyclassinformer.dirtree_utils.get_abs_path_by_inode(self.dirtree, inode)
        parent_dir = pyclassinformer.dirtree_utils.get_parent_dir_by_inode(self.dirtree, inode) + "/" # add slash at the end
        
        # need to update the directory in the cached inodes if the current dir and the parent dir of the selection are not matched.
        #print("OnSelectionChange", sel, inode, curr_dir, name, abs_path, parent_dir)
        if parent_dir != curr_dir:
            #print("update the parent dir {} to {} for {} ({})".format(curr_dir, parent_dir, name, inode))
            self.dirspec.update_parent_dir(inode, parent_dir)

    def OnRefresh(self, sel):
        #print("OnRefresh", sel)
        pass

    def OnGetDirTree(self):
        return self.dirspec, self.dirtree

    def OnIndexToInode(self, n):
        return n


def show_mc_tree_t(data, paths, icon=-1, modal=False):
    tree = mc_tree_t("[MethodClassifier]", data, paths, icon)
    tree.Show(modal=modal)
    return tree


```

`pyclassinformer/method_classifier.py`:

```py
import ida_idaapi
import ida_funcs
import ida_name
import idautils

try:
    ModuleNotFoundError
except NameError:
    ModuleNotFoundError = ImportError

tree_categorize = True
try:
    import ida_dirtree
    ida_dirtree.dirtree_t.find_entry
# For IDA 7.4 and 7.5
except ModuleNotFoundError:
    tree_categorize = False
# For IDA 7.6
except AttributeError:
    tree_categorize = False

ida_idaapi.require("pyclassinformer")
ida_idaapi.require("pyclassinformer.pci_utils")
ida_idaapi.require("pyclassinformer.pci_config")
if tree_categorize:
    ida_idaapi.require("pyclassinformer.mc_tree")
    ida_idaapi.require("pyclassinformer.dirtree_utils")

def change_dir_of_ctors_dtors(paths, data, dirtree):
    path_prefix = "/classes/"
    
    # move virtual functions to its class folder
    for vftable_ea in paths:
        path = paths[vftable_ea]
        if not path:
            continue
        
        # get the class name that owns the vftable, which is the last entry of the path.
        class_name = path[-1].name
        
        for refea in idautils.DataRefsTo(vftable_ea):
            f = ida_funcs.get_func(refea)
            if f:
                func_name = ida_funcs.get_func_name(f.start_ea)
                # make a directory with a class name
                dst_path = path_prefix + class_name + "/possible ctors or dtors/"
                dirtree.mkdir(dst_path)
                
                # if the vfunc is at the top level, move it into the vftables folder.
                func_path = "/" + func_name
            
                # get the func path in the dir tree.
                dirtree_path = pyclassinformer.dirtree_utils.get_abs_path_by_inode(dirtree, f.start_ea)
            
                # check if the function is at the top level or not.
                # and rename it.
                if func_path == dirtree_path:
                    #print(func_path)
                    dirtree.rename(func_path, dst_path)
        
def change_dir_of_vfuncs(paths, data, dirtree):
    path_prefix = "/classes/"
    
    # move virtual functions to its class folder
    for vftable_ea in paths:
        path = paths[vftable_ea]
        if not path:
            continue
        
        # get the class name that owns the vftable, which is the last entry of the path.
        class_name = path[-1].name
        vfunc_eas = data[vftable_ea].vfeas
        #print(hex(vftable_ea), class_name, len(vfunc_eas), list(reversed([x.name for x in path])))
        
        # make a directory with a class name
        dst_path = path_prefix + class_name + "/virtual methods/"
        dirtree.mkdir(dst_path)
        
        # move virtual functions into the class name folder
        for vfea in vfunc_eas:
            func_name = ida_funcs.get_func_name(vfea)
            
            # sometimes, a function is not form of a function.
            # try to fix it or skip it
            if func_name is None:
                ida_funcs.add_func(vfea)
                f = ida_funcs.get_func(vfea)
                if f is None:
                    print("Warning: a virtual method at {:#x} in {} is not a function and failed to add it as a function. Skipping...".format(vfea, class_name))
                    continue
                
                # get func name again after creating a function
                func_name = ida_funcs.get_func_name(vfea)
                if func_name is None:
                    print("Warning: the func name of the virtual method at {:#x} in {} could not be obtaind. Skipping...".format(vfea, class_name))
                    continue
            #print(hex(vfea), func_name)
                
            # if the vfunc is at the top level, move it into the vftables folder.
            func_path = "/" + func_name
            
            # get the func path in the dir tree.
            dirtree_path = pyclassinformer.dirtree_utils.get_abs_path_by_inode(dirtree, vfea)
            
            # check if the function is at the top level or not.
            # and rename it.
            if func_path == dirtree_path:
                #print(func_path)
                dirtree.rename(func_path, dst_path)
                
        # just create directories for rest of classes
        for bcd in path[1:]:
            dst_path = path_prefix + bcd.name
            dirtree.mkdir(dst_path)


def rename_func(ea, prefix="", fn="", is_lib=False):
    func_name = ida_funcs.get_func_name(ea)
    
    # if a virtuame method is not a valid function, skip it
    if func_name is None:
        return False
    
    # rename the function name if it is a dummy name
    if func_name.startswith("sub_") or func_name.startswith("unknown_"):
        # change the function name to the specific name
        if fn:
            func_name = fn
        ida_name.set_name(ea, prefix + func_name, ida_name.SN_NOCHECK|ida_name.SN_FORCE)
        
    # add FUNC_LIB to make ida recognize the function as a part of static linked libraries
    if is_lib:
        f = ida_funcs.get_func(ea)
        if not f.flags & ida_funcs.FUNC_LIB:
            f.flags |= ida_funcs.FUNC_LIB
            ida_funcs.update_func(f)
    return True


def rename_vftable_ref_funcs(paths, data):
    for vftable_ea in paths:
        path = paths[vftable_ea]
        if not path:
            continue
        col = data[vftable_ea]
        
        # get the class name that owns the vftable, which is the last entry of the path.
        class_name = path[-1].name
        
        # check the class is a part of standard library classes such as STL and MFC
        is_lib = False
        if col.libflag == col.LIBLIB:
            is_lib = True
        
        # get the func eas that refer to vftables and rename them
        #print(hex(vftable_ea))
        for refea in idautils.DataRefsTo(vftable_ea):
            #print(hex(refea))
            f = ida_funcs.get_func(refea)
            if f:
                rename_func(f.start_ea, class_name.split("<")[0] + "::", "possible_ctor_or_dtor", is_lib=is_lib)


def rename_funcs(func_eas, prefix="", is_lib=False):
    for ea in func_eas:
        rename_func(ea, prefix, is_lib=is_lib)


def rename_vfuncs(paths, data):
    for vftable_ea in paths:
        path = paths[vftable_ea]
        if not path:
            continue
        col = data[vftable_ea]
        
        # get the class name that owns the vftable, which is the last entry of the path.
        #print(hex(vftable_ea), path)
        class_name = path[-1].name
        vfunc_eas = data[vftable_ea].vfeas
        
        # check the class is a part of standard library classes such as STL and MFC
        is_lib = False
        if col.libflag == col.LIBLIB:
            is_lib = True
        
        rename_funcs(vfunc_eas, class_name.split("<")[0] + "::", is_lib=is_lib)


def get_base_classes(data):
    paths = {}
    for vftable_ea in data:
        # get COL
        col = data[vftable_ea]
        
        # get relevant BCDs mainly for multiple inheritance
        base_classes = pyclassinformer.pci_utils.utils.get_col_bases(col, data)
        
        # reverse the path because the path is reverse ordered.
        base_classes.reverse()
        paths[vftable_ea] = base_classes
    
    # sort the results by the class name and base class length
    return {x:paths[x] for x in sorted(sorted(paths, key=lambda key: [x.name for x in paths[key]]), key=lambda key: len(paths[key]))}


def method_classifier(data, config=None, icon=-1):
    if config is None:
        config = pyclassinformer.pci_config.pci_confg()
        
    # check config values to execute or not
    if not config.exana and not config.mvvm and not config.mvcd and not config.rnvm and not config.rncd:
        return None
    
    # get base classes
    paths = get_base_classes(data)
    
    # rename virtual methods in vftables
    if config.rnvm:
        rename_vfuncs(paths, data)

    # rename functions that refer to vftables because they are constructors or destructors
    if config.rncd:
       rename_vftable_ref_funcs(paths, data)
        
    tree = None
    if tree_categorize:
        # get dirtree and move vfuncs to their class directories
        for dirtype in [ida_dirtree.DIRTREE_FUNCS, ida_dirtree.DIRTREE_NAMES]:
            dirtree = ida_dirtree.get_std_dirtree(dirtype)
            if config.mvvm:
                change_dir_of_vfuncs(paths, data, dirtree)
            if config.mvcd:
                change_dir_of_ctors_dtors(paths, data, dirtree)
        
        # display dir tree
        if config.exana:
            tree = pyclassinformer.mc_tree.show_mc_tree_t(data, paths, icon=icon)
    else:
        print("Warning; Your IDA does not have ida_dirtree or find_entry in dirtree_t. Skip creating dirs for classes and moving functions into them.")
    
    return tree

```

`pyclassinformer/msvc_rtti.py`:

```py
import idc
import ida_idaapi
import ida_typeinf
import ida_offset
import ida_bytes
import ida_nalt
import ida_xref
import ida_kernwin
import ida_auto
import ida_name
import ida_ida
import ida_idp

try:
    ModuleNotFoundError
except NameError:
    ModuleNotFoundError = ImportError

ida_9_or_later = False
try:
    from ida_struct import get_struc
except ModuleNotFoundError:
    ida_9_or_later = True
    # for IDA 9.0
    def get_struc(struct_tid):
        tif = ida_typeinf.tinfo_t()
        if tif.get_type_by_tid(struct_tid):
            if tif.is_struct():
                return tif
        return None

ida_idaapi.require("pyclassinformer")
ida_idaapi.require("pyclassinformer.pci_utils")
u = pyclassinformer.pci_utils.utils()


class RTTIStruc(object):
    tid = 0
    struc = 0
    size = 0
    

def strip(name):
    if name.startswith("class ") and name.endswith("`RTTI Type Descriptor'"):
        return name[6:-23]
    elif name.startswith("struct ") and name.endswith("`RTTI Type Descriptor'"):
        return name[7:-23]
    else:
        return name


class RTTITypeDescriptor(RTTIStruc):
    
    # create structure
    msid = idc.get_struc_id("RTTITypeDescriptor")
    if msid != ida_idaapi.BADADDR:
        idc.del_struc(msid)
    msid = idc.add_struc(0xFFFFFFFF, "RTTITypeDescriptor", False)
    
    # add members
    if u.x64:
        idc.add_struc_member(msid, "pVFTable", ida_idaapi.BADADDR, ida_bytes.FF_DATA|u.PTR_TYPE|ida_bytes.FF_0OFF, -1, u.PTR_SIZE, reftype=u.REF_OFF)
    else:
        idc.add_struc_member(msid, "pVFTable", ida_idaapi.BADADDR, ida_bytes.FF_DATA|u.PTR_TYPE|ida_bytes.FF_0OFF, -1, u.PTR_SIZE)
    idc.add_struc_member(msid, "spare", ida_idaapi.BADADDR, ida_bytes.FF_DATA|u.PTR_TYPE, -1, u.PTR_SIZE)
    idc.add_struc_member(msid, "name", ida_idaapi.BADADDR, ida_bytes.FF_DATA|ida_bytes.FF_STRLIT, ida_nalt.STRTYPE_C, 0)
    
    # get structure related info
    tid = msid
    struc = get_struc(tid)
    size = idc.get_struc_size(tid)
    print("Completed Registering RTTITypeDescriptor")

    def __init__(self, ea):
        self.class_name = None
        self.ea = ea
        
        # get name and len
        name = ea + u.get_moff_by_name(self.struc, "name")
        strlen = u.get_strlen(name)
        if strlen is None:
            # not a real vtable
            return
        self.size = self.size + strlen + 1 # for NULL byte
        
        # get mangled name
        bmangled = ida_bytes.get_strlit_contents(name, strlen, 0)
        if bmangled is None:
            # not a real function name
            return
        mangled = bmangled.decode('UTF-8')
        
        # get demangled name
        #print("Mangled: " + mangled)
        demangled = ida_name.demangle_name('??_R0' + mangled[1:] , 0)
        if demangled:
            # apply structure type to bytes
            #print("Demangled: " + demangled)
            ida_bytes.del_items(ea, ida_bytes.DELIT_DELNAMES, self.size)
            if ida_bytes.create_struct(ea, self.size, self.tid):
                #print("  Made td at 0x%x: %s" % (ea, demangled))
                self.class_name = demangled
                return
        print("  FAIL :(")
        return


class RTTIClassHierarchyDescriptor(RTTIStruc):
    
    CHD_MULTINH   = 0x01 # Multiple inheritance
    CHD_VIRTINH   = 0x02 # Virtual inheritance
    CHD_AMBIGUOUS = 0x04 # Ambiguous inheritance
    
    # create structure
    msid = idc.get_struc_id("RTTIClassHierarchyDescriptor")
    if msid != ida_idaapi.BADADDR:
        idc.del_struc(msid)
    msid = idc.add_struc(0xFFFFFFFF, "RTTIClassHierarchyDescriptor", False)

    # add members
    idc.add_struc_member(msid, "signature", ida_idaapi.BADADDR, ida_bytes.FF_DWORD|ida_bytes.FF_DATA, -1, 4)
    idc.add_struc_member(msid, "attribute", ida_idaapi.BADADDR, ida_bytes.FF_DWORD|ida_bytes.FF_DATA, -1, 4)
    idc.add_struc_member(msid, "numBaseClasses", ida_idaapi.BADADDR, ida_bytes.FF_DWORD|ida_bytes.FF_DATA, -1, 4)
    idc.add_struc_member(msid, "pBaseClassArray", ida_idaapi.BADADDR, ida_bytes.FF_DWORD|ida_bytes.FF_DATA, -1, 4) # for dummy. the correct type will be applied when the BCA class is created.
    
    # get structure related info
    tid = msid
    struc = get_struc(tid)
    size = idc.get_struc_size(tid)
    print("Completed Registering RTTIClassHierarchyDescriptor")

    def __init__(self, ea):
        self.ea = ea
        self.sig = 0
        self.bcaea = ida_idaapi.BADADDR
        self.nb_classes = 0
        self.flags = ""
        self.bca = None
        
        # apply structure type to bytes
        ida_bytes.del_items(ea, ida_bytes.DELIT_DELNAMES, self.size)
        if ida_bytes.create_struct(ea, self.size, self.tid):
            # Get members of CHD
            self.sig = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "signature"))
            self.attribute = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "attribute"))
            self.nb_classes = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "numBaseClasses"))
            self.bcaea = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "pBaseClassArray")) + u.x64_imagebase()
            
            self.bca = RTTIBaseClassArray(self.bcaea, self.nb_classes)
            
            # parse flags
            if self.attribute & self.CHD_MULTINH:
                self.flags += "M"
            if self.attribute & self.CHD_VIRTINH:
                self.flags += "V"
            if self.attribute & self.CHD_AMBIGUOUS:
                self.flags += "A"
            #self.flags += " {:#x}".format(self.attribute)
        

class RTTIBaseClassDescriptor(RTTIStruc):
    
    BCD_NOTVISIBLE = 0x00000001
    BCD_AMBIGUOUS = 0x00000002
    BCD_PRIVORPROTBASE = 0x00000004
    BCD_PRIVORPROTINCOMPOBJ = 0x00000008
    BCD_VBOFCONTOBJ = 0x00000010
    BCD_NONPOLYMORPHIC = 0x00000020
    BCD_HASPCHD = 0x00000040 # pClassDescriptor field is present
    
    # create structure
    msid = idc.get_struc_id("RTTIBaseClassDescriptor")
    if msid != ida_idaapi.BADADDR:
        idc.del_struc(msid)
    msid = idc.add_struc(0xFFFFFFFF, "RTTIBaseClassDescriptor", False)
    
    # add members
    u.add_ptr_or_rva_member(msid, "pTypeDescriptor", "RTTITypeDescriptor")
    idc.add_struc_member(msid, "numContainerBases", ida_idaapi.BADADDR, ida_bytes.FF_DWORD|ida_bytes.FF_DATA, -1, 4)
    idc.add_struc_member(msid, "mdisp", ida_idaapi.BADADDR, ida_bytes.FF_DATA|ida_bytes.FF_DWORD, -1, 4) # 00 PMD Vftable displacement inside class layout
    idc.add_struc_member(msid, "pdisp", ida_idaapi.BADADDR, ida_bytes.FF_DATA|ida_bytes.FF_DWORD, -1, 4) # 04 PMD Vbtable displacement
    idc.add_struc_member(msid, "vdisp", ida_idaapi.BADADDR, ida_bytes.FF_DATA|ida_bytes.FF_DWORD, -1, 4) # 08 PMD Vftable displacement inside vbtable
    idc.add_struc_member(msid, "attributes", ida_idaapi.BADADDR, ida_bytes.FF_DWORD|ida_bytes.FF_DATA, -1, 4)
    u.add_ptr_or_rva_member(msid, "pClassDescriptor", "RTTIClassHierarchyDescriptor")
    
    # get structure related info
    tid = msid
    struc = get_struc(tid)
    size = idc.get_struc_size(tid)
    print("Completed Registering RTTIBaseClassDescriptor")
    
    def __init__(self, ea):
        self.ea = ea
        # apply structure type to bytes
        ida_bytes.del_items(ea, ida_bytes.DELIT_DELNAMES, self.size)
        if ida_bytes.create_struct(ea, self.size, self.tid):
            # Get members of BCD
            self.tdea = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "pTypeDescriptor")) + u.x64_imagebase()
            self.nb_cbs = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "numContainerBases"))
            self.mdisp = u.to_signed32(ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "mdisp")))
            self.pdisp = u.to_signed32(ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "pdisp")))
            self.vdisp = u.to_signed32(ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "vdisp")))
            self.attributes = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "attributes"))
            self.chdea = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "pClassDescriptor")) + u.x64_imagebase()
                

class RTTIBaseClassArray(RTTIStruc):
    
    # create structure
    msid = idc.get_struc_id("RTTIBaseClassArray")
    if msid != ida_idaapi.BADADDR:
        idc.del_struc(msid)
    msid = idc.add_struc(0xFFFFFFFF, "RTTIBaseClassArray", False)

    # add members
    u.add_ptr_or_rva_member(msid, "arrayOfBaseClassDescriptors", "RTTIBaseClassDescriptor", array=True)
    
    # get structure related info
    tid = msid
    struc = get_struc(tid)
    size = idc.get_struc_size(tid)
    
    # correct BCA's pBaseClassArray member type here.
    u.set_ptr_or_rva_member(RTTIClassHierarchyDescriptor.tid, "pBaseClassArray", "RTTIBaseClassArray")
    
    print("Completed Registering RTTIBaseClassArray")

    def __init__(self, ea, nb_classes):
        self.ea = ea
        # fix the size with the actual size by using nb_classes from CHD since the size depends on each BCA
        self.size = 4 * nb_classes

        self.bases = []
        self.paths = {}
        self.depth = 0
        
        # apply structure type to bytes
        ida_bytes.del_items(ea, ida_bytes.DELIT_DELNAMES, self.size)
        if ida_bytes.create_struct(ea, self.size, self.tid):
            pass
        
    # Sometimes, mdisp value is not included in COLs' offsets.
    # In that case, use either one of the following:
    #   - in the middle of the BCD's mdisp of a path (for MI with multiple vftables)
    #   - least COL's offset (for other cases such as SI and MI with a single vftable)
    def fix_offset(self, col_offs, curr_path, curr_off):
        # for MI with multiple vftables
        if len(col_offs) > 1:
            #print([(bcd.name, hex(bcd.mdisp)) for bcd in curr_path], [hex(x) for x in col_offs], curr_off)
            if curr_path and curr_path[-1].mdisp in col_offs:
                return curr_path[-1].mdisp
            return curr_off
        # for other cases such as SI and MI with a single vftable
        return sorted(col_offs)[0]
    
    def is_path_added(self, curr_path, offset, vi_offs, col):
        # if the offset has negative value, the path will not be added
        if offset < 0:
            return False
        
        # if the path does not have any VI classes, it will be added.
        if len(vi_offs) == 0:
            return True
        
        # if the path has a VI class and the path is for the current COL, the path will be added.
        if col.offset in vi_offs:
            #print("before comparing paths: current offset {}, col offset {}, vi_offs table {}, curr_path {}, vi_off == curr_path {}, name of vi_off == curr_path {}.".format(offset, col.offset, {x: [y.name for y in vi_offs[x]] for x in vi_offs}, [x.name for x in curr_path], curr_path == vi_offs[col.offset], [x.name for x in vi_offs[col.offset]] == [x.name for x in curr_path]))
            # here, it needs to compare the names instead of instances
            # because they are different on each vftable
            if [x.name for x in vi_offs[col.offset]] == [x.name for x in curr_path]:
                #print("this will be added: current offset {}, col offset {}, vi_offs table {}, curr_path {}.".format(offset, col.offset, {x: [y.name for y in vi_offs[x]] for x in vi_offs}, [x.name for x in curr_path]))
                return True
        return False
    
    # calc final offset mainly for VI
    def fix_offset_final(self, col_offs, curr_path, curr_off, vi_offs, col):
        # get first VI class
        found = False
        bcd = None
        for bcd in curr_path:
            if bcd.pdisp >= 0:
                found = True
                break
            
        # for SI and MI
        if len(col_offs) <= 1 or not found:
            return curr_off
        
        # for VI
        if found:
            found_col = False
            #print("vi_offs:", {x: [y.name for y in vi_offs[x]] for x in vi_offs})
            # get current offset if the current col is already in vi_offs.
            if col.offset in vi_offs:
                curr_off = col.offset
            # if the current col offset is not in vi_offs, the path is not processed yet.
            else:
                for p in vi_offs:
                    # check vi_offs table to get the correct offset by comparing the current
                    # path and paths in the vi_offs.
                    # here, it needs to compare the names instead of instances because they
                    # are different on each vftable
                    if [x.name for x in vi_offs[p]] == [x.name for x in curr_path]:
                        # sometimes, a class has two or more vftables, and a vfptr is at
                        # its COL's offset but anther is not at COL's offsets because of VI.
                        # E.g.
                        # XXXXX::xxx (0,-1,0) -> XXXXX::yyy (0,4,4)
                        # in this case, the current path is necessary on both vftables.
                        # here, a path that is already added in the past will also be added
                        # to another vftable that is not stored in vi_offs yet.
                        if curr_off in col_offs and col.offset != curr_off:
                            pass
                        # otherwise, this path will be skipped adding the current vftable
                        # because it is already processed.
                        else:
                            return -1
                    else:
                        # processing the path is the first time.
                        # this path will be added on the current vftable.
                        pass
                
                # update vi_offs if the offset is empty, processing the path is the first 
                # time, or a special case (see above)
                curr_off = col.offset
                vi_offs[col.offset] = curr_path
                found_col = True

            if not found_col:
                if curr_off not in vi_offs:
                    print("Warning: current offset {} was not found in vi_offs table {}. This should be a virtual inheritance {}.".format(curr_off, {x: [y.name for y in vi_offs[x]] for x in vi_offs}, [x.name for x in curr_path]))
        else:
            print("Warning: current offset {} is not in COL's offset {}. This should be a virtual inheritance. But all pdisp values in the path has negative values. {} {}".format(curr_off, col_offs, [x.pdisp for x in curr_path], [x.name for x in curr_path]))
        return curr_off
    
    def parse_bca(self, col, col_offs, vi_offs):
        ea = col.chd.bca.ea
        nb_classes = col.chd.nb_classes
        
        # parse bca
        for i in range(0, nb_classes):
            bcdoff = ea+i*4
            
            # get relevant structures
            bcdea = ida_bytes.get_32bit(bcdoff) + u.x64_imagebase()
            bcd = RTTIBaseClassDescriptor(bcdea)
            tdea = ida_bytes.get_32bit(bcdea) + u.x64_imagebase()
            td = RTTITypeDescriptor(tdea)
            
            ida_bytes.create_struct(bcd.chdea, RTTIClassHierarchyDescriptor.size, RTTIClassHierarchyDescriptor.tid, True)
            
            # add to result and filter out None entries
            if td.class_name:
                bcd.name = strip(td.class_name)
                self.bases.append(bcd)
                
        # parse hierarchy
        result_paths = {}
        curr_path = []
        n_processed = {}
        curr_off = 0
        for i, bcd in enumerate(self.bases):
            n_processed[bcd.nb_cbs] = 0
            
            # add BCD to the current path
            curr_path.append(bcd)
            curr_depth = len(curr_path) - 1
            
            # update the offset for paths of base classes
            curr_off = self.fix_offset(col_offs, curr_path, curr_off)
        
            # find a path to an offset for multiple inheritance
            if bcd.nb_cbs == 0:
                path = curr_path.copy()
                
                # get the final offset mainluy for VI
                offset = self.fix_offset_final(col_offs, path, curr_off, vi_offs, col)
                
                # append result according to the obtained offset
                if self.is_path_added(path, offset, vi_offs, col):
                    if offset in result_paths:
                        result_paths[offset].append(path)
                    else:
                        result_paths[offset] = [path]
                    
                # rewind current result for next inheritance
                while True:
                    # compare the number of bases to be processed in the current path with the number processed so far.
                    # if they are maatched, the base class must have been processed. So remove it.
                    if n_processed[curr_path[-1].nb_cbs] == curr_path[-1].nb_cbs:
                        # pop the record of the last bcd from the n_processed. and pop the last bcd itself from the current path.
                        #print("before:", [x.name for x in curr_path], n_processed[curr_path[-1].nb_cbs], n_processed)
                        del n_processed[curr_path[-1].nb_cbs]
                        prev_bcd = curr_path.pop()
                        
                        # set the number processed so far to the new tail.
                        if len(curr_path) > 0:
                            n_processed[curr_path[-1].nb_cbs] += prev_bcd.nb_cbs + 1
                        #print("after: ", [x.name for x in curr_path], n_processed[curr_path[-1].nb_cbs] if len(curr_path) > 0 else -1, n_processed)
                            
                    # quit the loop if finished, or no need to unwind for next bcd.
                    if len(curr_path) == 0 or (len(curr_path) > 0 and n_processed[curr_path[-1].nb_cbs] != curr_path[-1].nb_cbs):
                        break
                #print("out of loop:", [x.name for x in curr_path], n_processed[curr_path[-1].nb_cbs] if len(curr_path) > 0 else -1, n_processed)
            
            yield bcd, curr_depth
            
            # update the base class depth
            self.bases[i].depth = curr_depth
                        
        #print({x:[[z.name for z in y] for y in result_paths[x]] for x in result_paths}, col_offs)
        self.paths = result_paths

        if col.offset not in self.paths or not self.paths[col.offset]:
            print("Warning: Dispatching class hierarchy paths of the BCA at {:#x} for {} may be wrong because the paths list for the offset {} is empty. The paths will be misclassified as the wrong offset.".format(ea, self.bases[0].name, col.offset))


class RTTICompleteObjectLocator(RTTIStruc):

    # create structure
    msid = idc.get_struc_id("RTTICompleteObjectLocator")
    if msid != ida_idaapi.BADADDR:
        idc.del_struc(msid)
    msid = idc.add_struc(0xFFFFFFFF, "RTTICompleteObjectLocator", False)
    
    # add members
    idc.add_struc_member(msid, "signature", ida_idaapi.BADADDR, ida_bytes.FF_DATA|ida_bytes.FF_DWORD, -1, 4)
    idc.add_struc_member(msid, "offset", ida_idaapi.BADADDR, ida_bytes.FF_DATA|ida_bytes.FF_DWORD, -1, 4)
    idc.add_struc_member(msid, "cdOffset", ida_idaapi.BADADDR, ida_bytes.FF_DATA|ida_bytes.FF_DWORD, -1, 4)
    u.add_ptr_or_rva_member(msid, "pTypeDescriptor", "RTTITypeDescriptor")
    u.add_ptr_or_rva_member(msid, "pClassDescriptor", "RTTIClassHierarchyDescriptor")
    if u.x64:
        u.add_ptr_or_rva_member(msid, "pSelf", "RTTICompleteObjectLocator")
        
    # get structure related info
    tid = msid
    struc = get_struc(tid)
    size = idc.get_struc_size(tid)
    print("Completed Registering RTTICompleteObjectLocator")

    LIBUNK = 0
    LIBLIB = 1
    LIBNOTLIB = 2
    
    def __init__(self, ea, vtable):
        self.ea = ea
        self.name = None
        self.chd = None
        self.td = None
        self.offset = 0
        self.cdOffset = 0
        self.vfeas = []
        self.libflag = self.LIBUNK
        
        # apply structure type to bytes at ea
        ida_bytes.del_items(ea, ida_bytes.DELIT_DELNAMES, self.size)
        if ida_bytes.create_struct(ea, self.size, self.tid):
            # Get members of COL
            self.sig = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "signature"))
            self.offset = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "offset"))
            self.cdOffset = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "cdOffset"))
            self.tdea = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "pTypeDescriptor")) + u.x64_imagebase()
            self.chdea = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "pClassDescriptor")) + u.x64_imagebase()
            self.selfea = ida_idaapi.BADADDR
            if u.x64:
                self.selfea = ida_bytes.get_32bit(ea+u.get_moff_by_name(self.struc, "pSelf")) + u.x64_imagebase()
                
            # get TD to get the class name
            td = RTTITypeDescriptor(self.tdea)
            # validate the COL if the TD has a valid class name or not
            if td.class_name:
                # parse relevant structures
                self.td = td
                self.chd = RTTIClassHierarchyDescriptor(self.chdea)
                self.vfeas = [x for x in pyclassinformer.pci_utils.get_vtbl_methods(vtable)]
                
                # set class name
                self.name = strip(self.td.class_name)
                
                # set vftable name
                if ida_name.get_name(vtable).startswith("off_"):
                    ida_name.set_name(vtable, "vtable__" + self.name, ida_name.SN_NOWARN)
            else:
                # if the RTTITypeDescriptor doesn't have a valid name for us to
                # read, then this wasn't a valid RTTICompleteObjectLocator
                ida_bytes.del_items(ea, ida_bytes.DELIT_SIMPLE, self.size)


class rtti_parser(object):
    
    platforms = [ida_idp.PLFM_386, ida_idp.PLFM_ARM]
    formats = [ida_ida.f_PE]
    
    @staticmethod
    def parse(start, end):
        data_size = end-start
       
        # for RTTI relevant structures creation
        ida_auto.auto_wait()
    
        # get COLs with CHDs and TDs
        result = {}
        for offset in range(0, data_size-u.PTR_SIZE, u.PTR_SIZE):
            vtable = start+offset
            if u.is_vtable(vtable):
                colea = u.get_ptr(vtable-u.PTR_SIZE)
                if u.within(colea, u.valid_ranges):
                    col = RTTICompleteObjectLocator(colea, vtable)
                    # add rcol to the results
                    if col.name is not None:
                        result[vtable] = col
                        
        # may be this is a bug on IDA.
        # ida fails to apply a structure type to bytes under some conditions, although create_struct returns True.
        # to avoid that, apply them again.
        ida_auto.auto_wait()
        #print(len([xrea for xrea in u.get_refs_to(RTTICompleteObjectLocator.tid)]), len([result[x].ea for x in result]))
        if len([xrea for xrea in u.get_refs_to(RTTICompleteObjectLocator.tid)]) != len([result[x].ea for x in result]):
            [ida_bytes.create_struct(result[x].ea, RTTICompleteObjectLocator.size, RTTICompleteObjectLocator.tid, True) for x in result]
        #print(len([xrea for xrea in u.get_refs_to(RTTIClassHierarchyDescriptor.tid)]), len(set([result[x].chd.ea for x in result])))
        if len([xrea for xrea in u.get_refs_to(RTTIClassHierarchyDescriptor.tid)]) != len(set([result[x].chd.ea for x in result])):
            [ida_bytes.create_struct(result[x].chd.ea, RTTIClassHierarchyDescriptor.size, RTTIClassHierarchyDescriptor.tid, True) for x in result]
        #print(len([xrea for xrea in u.get_refs_to(RTTITypeDescriptor.tid)]), len(set([result[x].td.ea for x in result])))
        if len([xrea for xrea in u.get_refs_to(RTTITypeDescriptor.tid)]) != len(set([result[x].td.ea for x in result])):
            [ida_bytes.create_struct(result[x].td.ea, result[x].td.size, RTTITypeDescriptor.tid, True) for x in result]
            
        # for refreshing xrefs to get xrefs from COLs to TDs
        ida_auto.auto_wait()
        
        # parse BCA
        prev_col = None
        vi_offs = {}
        for vtable in result:
            col = result[vtable]
            col_offs = u.get_col_offs(col, result)
            if prev_col and prev_col.name != col.name:
                vi_offs = {}
            
            # get BCDs
            for bcd, depth in col.chd.bca.parse_bca(col, col_offs, vi_offs):
                pass
            prev_col = col
        
        # may be this is a bug on IDA.
        # ida fails to apply a structure type to bytes under some conditions, although create_struct returns True.
        # to avoid that, apply them again.
        ida_auto.auto_wait()
        #print(len([xrea for xrea in u.get_refs_to(RTTIBaseClassArray.tid)]), len(set([result[x].chd.bca.ea for x in result])))
        if len([xrea for xrea in u.get_refs_to(RTTIBaseClassArray.tid)]) != len(set([result[x].chd.bca.ea for x in result])):
            [ida_bytes.create_struct(result[x].chd.bca.ea, result[x].chd.bca.size, RTTIBaseClassArray.tid, True) for x in result]
        #print(len([xrea for xrea in u.get_refs_to(RTTIClassHierarchyDescriptor.tid)]), len(set([result[x].chd.ea for x in result])))
        if len([xrea for xrea in u.get_refs_to(RTTIClassHierarchyDescriptor.tid)]) != len(set([result[x].chd.ea for x in result])):
            [ida_bytes.create_struct(result[x].chd.ea, RTTIClassHierarchyDescriptor.size, RTTIClassHierarchyDescriptor.tid, True) for x in result]
        #print(len([xrea for xrea in u.get_refs_to(RTTIBaseClassDescriptor.tid)]), len(set([y.ea for x in result for y in result[x].chd.bca.bases])))
        if len([xrea for xrea in u.get_refs_to(RTTIBaseClassDescriptor.tid)]) != len(set([y.ea for x in result for y in result[x].chd.bca.bases])):
            [[ida_bytes.create_struct(y.ea, RTTIBaseClassDescriptor.size, RTTIBaseClassDescriptor.tid, True) for y in result[x].chd.bca.bases] for x in result]
        #print(len([xrea for xrea in u.get_refs_to(RTTITypeDescriptor.tid)]), len(set([y.tdea for x in result for y in result[x].chd.bca.bases])))
        if len([xrea for xrea in u.get_refs_to(RTTITypeDescriptor.tid)]) != len(set([y.tdea for x in result for y in result[x].chd.bca.bases])):
            [[ida_bytes.create_struct(y.tdea, RTTITypeDescriptor.size, RTTITypeDescriptor.tid, True) for y in result[x].chd.bca.bases] for x in result]
        if len([xrea for xrea in u.get_refs_to(RTTIClassHierarchyDescriptor.tid)]) != len(set([result[x].chd.ea for x in result] + [y.chdea for x in result for y in result[x].chd.bca.bases])):
            [[ida_bytes.create_struct(y.chdea, RTTIClassHierarchyDescriptor.size, RTTIClassHierarchyDescriptor.tid, True) for y in result[x].chd.bca.bases] for x in result]
        ida_auto.auto_wait()
    
        # for debugging
        if len([xrea for xrea in u.get_refs_to(RTTICompleteObjectLocator.tid)]) != len([result[x].ea for x in result]):
            print("Warning: RTTICompleteObjectLocator found and its xrefs are not matched (xrefs:{}, found: {})".format(len([xrea for xrea in u.get_refs_to(RTTICompleteObjectLocator.tid)]), len([result[x].ea for x in result])))
        if len([xrea for xrea in u.get_refs_to(RTTIClassHierarchyDescriptor.tid)]) != len(set([result[x].chd.ea for x in result] + [y.chdea for x in result for y in result[x].chd.bca.bases])):
            print("Warning: RTTIClassHierarchyDescriptor found and its xrefs are not matched (xrefs:{}, found: {})".format(len([xrea for xrea in u.get_refs_to(RTTIClassHierarchyDescriptor.tid)]), len(set([result[x].chd.ea for x in result] + [y.chdea for x in result for y in result[x].chd.bca.bases]))))
        if len([xrea for xrea in u.get_refs_to(RTTITypeDescriptor.tid)]) != len(set([y.tdea for x in result for y in result[x].chd.bca.bases])):
            print("Warning: RTTITypeDescriptor found and its xrefs are not matched (xrefs:{}, found: {})".format(len([xrea for xrea in u.get_refs_to(RTTITypeDescriptor.tid)]), len(set([y.tdea for x in result for y in result[x].chd.bca.bases]))))
        if len([xrea for xrea in u.get_refs_to(RTTIBaseClassArray.tid)]) != len(set([result[x].chd.bca.ea for x in result])):
            print("Warning: RTTIBaseClassArray found and its xrefs are not matched (xrefs:{}, found: {})".format(len([xrea for xrea in u.get_refs_to(RTTIBaseClassArray.tid)]), len(set([result[x].chd.bca.ea for x in result]))))
        if len([xrea for xrea in u.get_refs_to(RTTIBaseClassDescriptor.tid)]) != len(set([y.ea for x in result for y in result[x].chd.bca.bases])):
            print("Warning: RTTIBaseClassDescriptor found and its xrefs are not matched (xrefs:{}, found: {})".format(len([xrea for xrea in u.get_refs_to(RTTIBaseClassDescriptor.tid)]), len(set([y.ea for x in result for y in result[x].chd.bca.bases]))))
        return result

    @staticmethod
    def is_binary_allowed():
        if ida_idp.ph.id not in rtti_parser.platforms:
            print("[PyClassInformer] Warning: The platform is not supported ({:#x}). This only supports x86, x64, ARM and ARM64.".format(ida_idp.ph.id))
            return False
        if ida_ida.inf_get_filetype() not in rtti_parser.formats:
            import ida_loader
            print("[PyClassInformer] Warning: The binary format is not supported ({}). This only supports PE.".format(ida_loader.get_file_type_name()))
            return False
        return True
        
    @staticmethod
    def show(result):
        for vtable in result:
            col = result[vtable]
            print("vtable at : " + hex(vtable))
            print("  COL at {:#x}:".format(col.ea), col.name, col.sig, col.offset, col.cdOffset, hex(col.tdea), hex(col.chdea), hex(col.selfea) if col.selfea != ida_idaapi.BADADDR else "")
            print("  CHD at {:#x}:".format(col.chd.ea), hex(col.chd.sig), col.chd.flags, col.chd.nb_classes, hex(col.chd.bcaea))
            
            # get BCDs
            for bcd in col.chd.bca.bases:
                print("    {}BCD at {:#x}:".format(" " *bcd.depth*2, bcd.ea), bcd.name, hex(bcd.tdea), bcd.nb_cbs, bcd.mdisp, bcd.pdisp, bcd.vdisp, bcd.attributes, hex(bcd.chdea))

    @staticmethod
    def run(alldata=False, icon=-1):
        result = {}
        
        # check if the binary you loaded is valid or not.
        if not rtti_parser.is_binary_allowed():
            return result
        
        # find vftables with relevant structures
        if u.rdata and not alldata:
            result = rtti_parser.parse(u.rdata.start_ea, u.rdata.end_ea)
        # if .rdata was not found, try multiple data segments
        else:
            # expand ranges to check to all data
            u.update_valid_ranges()
            
            # get all data segments' results
            for seg in u.get_data_segments():
                result.update(rtti_parser.parse(seg.start_ea, seg.end_ea))
        return result
    

```

`pyclassinformer/pci_chooser.py`:

```py
import idc
import ida_kernwin
import ida_idaapi

ida_idaapi.require("pyclassinformer")
ida_idaapi.require("pyclassinformer.pci_utils")
u = pyclassinformer.pci_utils.utils()

class pci_chooser_t(ida_kernwin.Choose):

    def __init__(self, title, data, icon=-1, libcolor=0xffffffe9, defcolor=0xffffffff):
        ida_kernwin.Choose.__init__(
            self,
            title,
            [
                ["Vftable",   10 | ida_kernwin.Choose.CHCOL_EA],
                ["Methods",   4  | ida_kernwin.Choose.CHCOL_DEC],
                ["Flags",     4  | ida_kernwin.Choose.CHCOL_PLAIN],
                ["Type",      30 | ida_kernwin.Choose.CHCOL_PLAIN],
                ["Hierarchy", 50 | ida_kernwin.Choose.CHCOL_PLAIN],
                ["Offset",    4  | ida_kernwin.Choose.CHCOL_HEX],
                ["Hierarchy Order", 50  | ida_kernwin.Choose.CHCOL_PLAIN],
            ],
            flags=ida_kernwin.CH_MULTI|ida_kernwin.CH_ATTRS,
            icon=icon
        )
        self.items = [
            [
                hex(vftable_ea),
                "{}".format(len(data[vftable_ea].vfeas)),
                data[vftable_ea].chd.flags,
                data[vftable_ea].name,
                self.get_hierarychy(data, vftable_ea),
                hex(data[vftable_ea].offset),
                self.get_hierarychy_order(data, vftable_ea),
                data[vftable_ea].libflag,
                vftable_ea
            ] for vftable_ea in data
        ]
        self.libcolor = libcolor
        self.defcolor = defcolor
        self.libflag = data[next(iter(data))].LIBLIB
            
    def get_hierarychy(self, data, vftable_ea):
        col = data[vftable_ea]
        # get the actual base classes mainly for multiple inheritance
        bases = u.get_col_bases(col, data)
        
        result = "{}: ".format(col.name)
        if len(bases) > 0:
            # replace the class name with the first BCD's class name if they are different from each other.
            # it occurs when the class is multiple inheritance with multiple vftables
            i = 1
            if bases[0].name != col.name:
                result = "{}: ".format(bases[0].name)
                #i = 0

            # get the result related to the offset of the COL
            result += ", ".join([x.name for x in bases][i:]) + ";" if len(bases) > 1 else ""
        return result
        
    def get_hierarychy_order(self, data, vftable_ea):
        col = data[vftable_ea]
        result = []
        if len(col.chd.bca.bases) > 0:
            for off in col.chd.bca.paths:
                # output each path
                for p in col.chd.bca.paths[off]:
                    # get only the target COL related result
                    if col.offset == off:
                        result.append(" -> ".join([x.name + " ({},{},{})".format(x.mdisp, x.pdisp, x.vdisp) for x in p]))

        return ", ".join(result)
        
    def OnInit(self):
        return True

    def OnGetSize(self):
        return len(self.items)

    def OnGetLine(self, n):
        if isinstance(n, list):
            n = n[0]
        return self.items[n]
    
    # for old versions of IDA
    def OnSelectLine(self, n):
        # CH_MULTI passes a list.
        # Change it to integer before passing to jumpto.
        if isinstance(n, list):
            n = n[0]
        idc.jumpto(self.items[n][-1])
        return (ida_kernwin.Choose.NOTHING_CHANGED, )

    def OnGetEA(self, n):
        if isinstance(n, list):
            n = n[0]
        return self.items[n][-1]
    
    def OnGetLineAttr(self, n):
        # change the line color if a class is a part of static linked libraries
        vftable_ea = self.items[n][-1]
        color = self.defcolor
        if self.items[n][-2] == self.libflag:
            color = self.libcolor
        return (color, 0)


def show_pci_chooser_t(data, icon=-1, modal=False, libcolor=0xffffffe9, defcolor=0xffffffff):
    c = pci_chooser_t("[PyClassInformer]", data, icon, libcolor, defcolor)
    c.Show(modal=modal)


```

`pyclassinformer/pci_config.py`:

```py
try:
    ModuleNotFoundError
except NameError:
    ModuleNotFoundError = ImportError

class pci_config(object):
    
    alldata = True
    rtti = True
    exana = True
    mvvm = True
    mvcd = True
    rnvm = True
    rncd = True
    dirtree = True
    
    def __init__(self, alldata=False, rtti=True, exana=True, mvvm=True, mvcd=True, rnvm=True, rncd=True):
        self.alldata = alldata
        self.rtti = rtti
        self.exana = exana
        self.mvvm = mvvm
        self.mvcd = mvcd
        self.rnvm = rnvm
        self.rncd = rncd
        self.check_dirtree()
        
    def check_dirtree(self):
        try:
            import ida_dirtree
            ida_dirtree.dirtree_t.find_entry
        # for IDA 7.x
        except (ModuleNotFoundError, AttributeError) as e:
            self.exana = False
            self.mvvm = False
            self.mvcd = False
            self.dirtree = False
            

```

`pyclassinformer/pci_config_form.py`:

```py
import ida_idaapi
import ida_kernwin


# --------------------------------------------------------------------------
class pci_form_t(ida_kernwin.Form):

    def __init__(self, dirtree=True):
        self.invert = False
        F = ida_kernwin.Form
        F.__init__(
            self,
            r"""PyClassInformer Options

{FormChangeCb}

<##Search area##Only .rdata section:{rdata}> <##All data sections:{alldata}>{search_area}>

<##Actions##Display RTTI parsed results on the Output window:{rtti}>
<##Display extra analysis result (IDA 7.7 or later):{exana}>
<##Create folders for classes and move virtual methods to them in Functions and Names subviews (IDA 7.7 or later):{mvvm}>
<##Move functions refer vftables to "possible ctors or dtors" folder under each class folder in Functions and Names subviews (IDA 7.7 or later):{mvcd}>
<##Rename virtual methods:{rnvm}>
<##Rename possible constructors and destructors:{rncd}>{acts}>
""", {
            'FormChangeCb': F.FormChangeCb(self.OnFormChange),
            'search_area': F.RadGroupControl(("rdata", "alldata")),
            'acts': F.ChkGroupControl(("rtti", "exana", "mvvm", "mvcd", "rnvm", "rncd")),
        })
        
        self.dirtree = dirtree
        self.executed = False
        
        # Compile (in order to populate the controls)
        self.Compile()
        self.set_default_settings()
        
    def OnFormChange(self, fid):
        # set only once when it is called
        if not self.executed:
            self.change_dirtree_settings()
            self.executed = True
        return 1
        
    def change_dirtree_settings(self):
        self.SetControlValue(self.exana, True)
        self.SetControlValue(self.mvvm, True)
        self.SetControlValue(self.mvcd, True)
        if not self.dirtree:
            self.EnableField(self.exana, False)
            self.EnableField(self.mvvm, False)
            self.EnableField(self.mvcd, False)
            self.SetControlValue(self.exana, False)
            self.SetControlValue(self.mvvm, False)
            self.SetControlValue(self.mvcd, False)

    def set_default_settings(self):
        self.rdata.selected = True
        self.rtti.checked = True
        self.exana.checked = True
        self.mvvm.checked = True
        self.mvcd.checked = True
        self.rnvm.checked = True
        self.rncd.checked = True
        
    @staticmethod
    def show():
        ida_idaapi.require("pyclassinformer")
        ida_idaapi.require("pyclassinformer.pci_config")
        pcic = pyclassinformer.pci_config.pci_config()
        f = pci_form_t(dirtree=pcic.dirtree)

        # Execute the form
        ok = f.Execute()
        if ok == 1:
            pcic = pyclassinformer.pci_config.pci_config(alldata=f.alldata.selected, rtti=f.rtti.checked, exana=f.exana.checked, mvvm=f.mvvm.checked, mvcd=f.mvcd.checked, rnvm=f.rnvm.checked, rncd=f.rncd.checked)
        else:
            return None

        # Dispose the form
        f.Free()
        return pcic

"""
ida_idaapi.require("pci_config")
pcic = pci_form_t.show()
if pcic is not None:
    print(pcic.alldata, pcic.exana, pcic.mvvm, pcic.mvcd, pcic.rnvm, pcic.rncd)
"""

```

`pyclassinformer/pci_utils.py`:

```py
import struct

import idc
import idautils
import ida_bytes
import ida_search
import ida_idaapi
import ida_segment
import ida_xref
import ida_typeinf
import ida_nalt
import ida_offset
import ida_name
import ida_ida

try:
    ModuleNotFoundError
except NameError:
    ModuleNotFoundError = ImportError

ida_9_or_later = False
try:
    import ida_struct
    from ida_struct import get_member_by_name
except ModuleNotFoundError:
    # for IDA 9.0
    ida_9_or_later = True
    def get_member_by_name(tif, name):
        if not tif.is_struct():
            return None
    
        udm = ida_typeinf.udm_t()
        udm.name = name
        idx = tif.find_udm(udm, ida_typeinf.STRMEM_NAME)
        if idx != -1:
            return udm
        return None


class utils(object):
    text = 0
    data = 0
    rdata = 0
    valid_ranges = []
    within = lambda self, x, rl: any([True for r in rl if r[0]<=x<=r[1]])

    REF_OFF = 0
    x64 = 0
    PTR_TYPE = 0
    PTR_SIZE = 0

    def __init__(self):
        self.text = ida_segment.get_segm_by_name(".text")
        self.data = ida_segment.get_segm_by_name(".data")
        self.rdata = ida_segment.get_segm_by_name(".rdata")
        # try to use rdata if there actually is an rdata segment, otherwise just use data
        if self.rdata is not None and self.data is not None:
            self.valid_ranges = [(self.rdata.start_ea, self.rdata.end_ea), (self.data.start_ea, self.data.end_ea)]
        # fail safe for renaming segment names
        else:
            self.valid_ranges = []
            for n in range(ida_segment.get_segm_qty()):
                seg = ida_segment.getnseg(n)
                if seg and ida_segment.get_segm_class(seg) == "DATA" and seg and not seg.is_header_segm():
                    self.valid_ranges.append((seg.start_ea, seg.end_ea))

        self.x64 = (ida_segment.getnseg(0).bitness == 2)
        if self.x64:
            self.PTR_TYPE = ida_bytes.FF_QWORD
            self.REF_OFF = ida_nalt.REF_OFF64
            self.PTR_SIZE = 8
            self.get_ptr = ida_bytes.get_64bit
        else:
            self.PTR_TYPE = ida_bytes.FF_DWORD
            self.REF_OFF = ida_nalt.REF_OFF32
            self.PTR_SIZE = 4
            self.get_ptr = ida_bytes.get_32bit
            
    @staticmethod
    def get_data_segments():
        for n in range(ida_segment.get_segm_qty()):
            seg = ida_segment.getnseg(n)
            if seg and ida_segment.get_segm_class(seg) == "DATA" and seg and not seg.is_header_segm():
                yield seg
            
    def update_valid_ranges(self):
        self.valid_ranges = []
        for seg in utils.get_data_segments():
            self.valid_ranges.append((seg.start_ea, seg.end_ea))

    # for 32-bit binaries, the RTTI structs contain absolute addresses, but for
    # 64-bit binaries, they're offsets from the image base.
    def x64_imagebase(self):
        if self.x64:
            return ida_nalt.get_imagebase()
        else:
            return 0
        
    def get_strlen(self, addr, max_len=500):
        # 50 is sometimes too short. I increased a number here.
        strlen = 0
        #while get_byte(addr+strlen) != 0x0 and strlen < 50:
        while ida_bytes.get_byte(addr+strlen) != 0x0 and strlen < max_len:
            strlen+=1
        #assume no names will ever be longer than 50 bytes
        #if strlen == 50:
        if strlen == max_len:
            return None
        return strlen

    def is_vtable(self, addr):
        function = self.get_ptr(addr)
        # Check if vtable has ref and its first pointer lies within code segment
        if ida_bytes.has_xref(ida_bytes.get_full_flags(addr)) and function >= self.text.start_ea and function <= self.text.end_ea:
            return True
        return False

    @staticmethod
    def to_signed32(n):
        n = n & 0xffffffff
        return n | (-(n & 0x80000000))

    @staticmethod
    def get_refs_to(ea):
        for xref in idautils.XrefsTo(ea, 0):
            yield xref.frm

    @classmethod
    def get_refs_to_by_type_name(cls, name):
        tif = ida_typeinf.tinfo_t()
        if tif.get_named_type(None, name, ida_typeinf.BTF_STRUCT):
            for xref in cls.get_refs_to(tif.get_tid()):
                yield xref
                
    def add_ptr_or_rva_member(self, sid, mname, mtype_name, array=False, idx=-1):
        sname = idc.get_struc_name(sid)
        
        # if idx is not specified, insert the member at the end of the structure
        if idx < 0:
            idx = idc.get_member_qty(sid)
            
        idc.add_struc_member(sid, mname, ida_idaapi.BADADDR, ida_bytes.FF_DATA|ida_bytes.FF_DWORD|ida_bytes.FF_0OFF, -1, 4)
        self.set_ptr_or_rva_member(sid, mname, mtype_name, array, idx)
        
    def set_ptr_or_rva_member(self, sid, mname, mtype_name, array=False, idx=-1):
        sname = idc.get_struc_name(sid)
        
        # if idx is not specified, modifie the last member
        if idx < 0:
            idx = idc.get_member_qty(sid) - 1
            
        r = None
        if self.x64:
            reftype = ida_nalt.REFINFO_RVAOFF|self.REF_OFF
            mtif = get_ptr_type(mtype_name, ptr_size=ida_typeinf.TAPTR_PTR32, array=array)
            if ida_9_or_later:
                r = get_val_repr(ida_typeinf.FRB_OFFSET, reftype)
        else:
            reftype = self.REF_OFF
            mtif = get_ptr_type(mtype_name, ptr_size=0, array=array)
            
        if ida_9_or_later:
            tif = ida_typeinf.tinfo_t()
            tif.get_named_type(None, sname)
            udt = ida_typeinf.udt_type_data_t()
            tif.set_udm_type(idx, mtif, 0, r)
            tif.get_udt_details(udt)
        else:
            s = ida_struct.get_struc(sid)
            ida_struct.set_member_tinfo(s, s.get_member(idx), 0, mtif, 0)
            idc.set_member_type(sid, idc.get_member_offset(sid, mname), ida_bytes.FF_DATA|ida_bytes.FF_DWORD|ida_bytes.FF_0OFF, -1, 1, reftype=reftype)
        
    @staticmethod
    def get_moff_by_name(struc, name):
        try:
            offset = get_member_by_name(struc, name).soff
        except AttributeError:
            # for ida 9.0
            offset = get_member_by_name(struc, name).offset // 8
        return offset
    
    @classmethod
    def get_cols_by_col(cls, col, vftables):
        # get offsets in COLs by finding xrefs for multiple inheritance
        x = set([xrea for xrea in cls.get_refs_to(col.tdea)])
        y = set([xrea for xrea in cls.get_refs_to(col.tid)])
        # If the target is a multi inheritance class, TD or CHD has multiple xrefs from multiple COLs.
        # Here, get the COLs
        coleas = (x&y)
        cols = sorted(list(filter(lambda x: x.ea in coleas, vftables.values())), key=lambda x: x.ea in coleas)
        return cols

    @classmethod
    def get_col_offs_by_cols(cls, cols):
        col_offs = [ida_bytes.get_32bit(x.ea+cls.get_moff_by_name(x.struc, "offset")) for x in cols]
        return col_offs

    @classmethod
    def get_col_offs(cls, col, vftables):
        cols = cls.get_cols_by_col(col, vftables)
        # get the offsets in COLs
        col_offs = cls.get_col_offs_by_cols(cols)
        return col_offs

    @classmethod
    def get_col_bases(cls, col, vftables):
        # for checking if a class has multiple vftables or not
        col_offs = cls.get_col_offs(col, vftables)
        
        bases = []
        paths = col.chd.bca.paths.get(col.offset, [])
        for path in paths:
            append = False
            for bcd in path:
                # for SI and MI but there is only a vftable
                if len(col_offs) < 2:
                    append = True
                # for MI and there are multiple vftables
                elif bcd.mdisp == col.offset:
                    append = True
                elif bcd.pdisp >= 0:
                    append = True
                # if append flag is enabled, append it and subsequent BCDs after it
                if append and bcd not in bases:
                    bases.append(bcd)
        return bases


def add_struc_by_name_and_def(name, struc_def):
    tif = ida_typeinf.tinfo_t(struc_def)
    tif.set_named_type(None, name, ida_typeinf.NTF_REPLACE)
    return tif


def build_udm(tif, name, msize=0, mtype=ida_typeinf.BTF_INT, moffset=-1, vrepr=None):
    # create a struct member
    udm = ida_typeinf.udm_t()
    udm.name = name
    if msize > 0:
        udm.size = msize * 8
        
    udm.offset = tif.get_unpadded_size() * 8
    if moffset >= 0:
        udm.offset = moffset * 8
        
    udm.type = ida_typeinf.tinfo_t(mtype)
    
    if vrepr:
        udm.set_value_repr(vrepr)
        
    return udm


def add_struc(name):
    tif = ida_typeinf.tinfo_t()
    udt = ida_typeinf.udt_type_data_t()
    # add the structure to local types
    if tif.create_udt(udt):
        tif.set_named_type(None, name)
    return tif


def add_struc_member(tif, name, msize=0, mtype=None, moffset=-1, vrepr=None):
    udm = build_udm(tif, name, msize, mtype, moffset, vrepr)
    tif.add_udm(udm, ida_typeinf.ETF_MAY_DESTROY|ida_typeinf.ETF_FORCENAME)
    return udm


def create_ptr_attr(data_type=ida_typeinf.BTF_INT, attr=ida_typeinf.TAPTR_PTR32):
    # pointer description
    pi = ida_typeinf.ptr_type_data_t()
    pi.obj_type = ida_typeinf.tinfo_t(data_type)
    pi.taptr_bits = attr
    # pointer type
    mtif = ida_typeinf.tinfo_t()
    mtif.create_ptr(pi)
    return mtif


def get_ptr_type(type_name, ptr_size=ida_typeinf.TAPTR_PTR32, array=False):
    mtif = ida_typeinf.tinfo_t()
    if mtif.get_named_type(None, type_name):
        # for 64-bit, the member stores an RVA.
        # create "*__ptr32" here.
        if ptr_size:
            mtif = create_ptr_attr(mtif, ptr_size)
        # for 32-bit, the member stores a pointer.
        # just create a pointer
        else:
            mtif.create_ptr(mtif)
            
        # for BCA
        if array:
            mtif.create_array(mtif)
        return mtif
    return None


"""
def get_refinfo(reftype=ida_nalt.REF_OFF64, flags=ida_nalt.REFINFO_RVAOFF):
    ri = ida_nalt.refinfo_t()
    ri.flags = flags
    ri.target = 0
    ri.set_type(reftype)
    return ri


def get_offset_refinfo(reftype=ida_nalt.REF_OFF64, flags=ida_nalt.REFINFO_RVAOFF):
    ri = get_refinfo(reftype, flags)
    vr = ida_typeinf.value_repr_t()
    vr.set_vtype(ida_typeinf.FRB_OFFSET)
    vr.ri = ri
    return vr


def set_opinfo(tif, udt, udt_idx):
    oi = ida_nalt.opinfo_t()
    oi.ri = get_refinfo(reftype=ida_nalt.REF_OFF64, flags=ida_nalt.REFINFO_RVAOFF)
    mtif = create_ptr_attr(ida_typeinf.BTF_INT, ida_typeinf.TAPTR_PTR32)
    flags = ida_bytes.off_flag()
    # Apply the offset and RVA attributes to udm target.
    udt[udt_idx].repr.from_opinfo(flags, 0, oi, None)
    tif.set_udm_repr(udt_idx, udt[udt_idx].repr)
    tif.set_udm_type(udt_idx, mtif)
"""


def get_val_repr(vtype=-1, flags=ida_nalt.REF_OFF64|ida_nalt.REFINFO_RVAOFF):
    if vtype < 0:
        vtype = ida_typeinf.FRB_OFFSET
    r = ida_typeinf.value_repr_t()
    r.set_vtype(vtype)
    r.ri.init(flags)
    return r


"""
struc_def = '''
struct RTTICompleteObjectLocator
{
  int signature;
  int offset;
  int cdOffset;
  int pTypeDescriptor;
  int pClassDescriptor;
  int pSelf;
};
'''
name = "RTTICompleteObjectLocator"
tif = add_struc_by_name_and_def(name, struc_def)

r = get_val_repr(ida_typeinf.FRB_OFFSET, ida_nalt.REF_OFF64|ida_nalt.REFINFO_RVAOFF)
mtif = create_ptr_attr(ida_typeinf.BTF_INT, ida_typeinf.TAPTR_PTR32)
for i in range(3, 6):
    tif.set_udm_type(i, mtif, 0, r)
ida_typeinf.apply_tinfo(here(), tif, ida_typeinf.TINFO_DEFINITE)
"""


def get_value_with_size(val, vsize):
    off_v = ida_idaapi.BADADDR
    if vsize == 8:
        off_v = ida_bytes.get_qword(val)
    elif vsize == 4:
        off_v = ida_bytes.get_dword(val)
    elif vsize == 2:
        off_v = ida_bytes.get_word(val)
    elif vsize == 1:
        off_v = ida_bytes.get_byte(val)
    return off_v


def get_offset_ptr(v, force_bitness=False):
    target_ea = ida_idaapi.BADADDR
    if v == ida_idaapi.BADADDR:
        return target_ea
    flags = ida_bytes.get_full_flags(v)
    if not force_bitness and ida_bytes.is_qword(flags):
        target_ea = get_value_with_size(v, 8)
    elif not force_bitness and ida_bytes.is_dword(flags):
        target_ea = get_value_with_size(v, 4)
    else:
        seg = ida_segment.getseg(v)
        if seg is None:
            return target_ea
        off_size = 1<<(seg.bitness+1)
        target_ea = get_value_with_size(v, off_size)
    return target_ea


def get_offset_fptr(v, force_bitness=False):
    target_ea = ida_idaapi.BADADDR
    tmp_ea = get_offset_ptr(v, force_bitness)
    flags = ida_bytes.get_full_flags(tmp_ea)
    if ida_bytes.is_code(flags):
        target_ea = tmp_ea
    return target_ea


def get_vtbl_methods(target_ea):
    orig_target_ea = target_ea
    prev_target_ea = target_ea
    item_diff = 8
    seg = ida_segment.getseg(target_ea)
    next_name_ea = ida_ida.inf_get_max_ea()
    if seg:
        item_diff = 1<<(seg.bitness+1)
        # get next label that has a xref
        next_name_ea = ida_bytes.next_that(target_ea, seg.end_ea, ida_bytes.has_xref)
        if next_name_ea == ida_idaapi.BADADDR:
            next_name_ea = seg.end_ea
    
    ea = get_offset_fptr(target_ea, force_bitness=True)
    while target_ea != ida_idaapi.BADADDR and target_ea < next_name_ea and ea != ida_idaapi.BADADDR:
        flags = ida_bytes.get_full_flags(ea)
        if ida_bytes.is_code(flags):
            yield ea
        else:
            break
        
        prev_target_ea = target_ea
        target_ea = ida_search.find_data(target_ea, ida_search.SEARCH_DOWN|ida_search.SEARCH_NEXT)
        if target_ea - prev_target_ea != item_diff:
            break
        ea = get_offset_fptr(target_ea, force_bitness=True)


```

`pyclassinformer/pyclassinformer.py`:

```py
import ida_idaapi
import ida_kernwin

ida_idaapi.require("pyclassinformer")
ida_idaapi.require("pyclassinformer.msvc_rtti")
ida_idaapi.require("pyclassinformer.pci_config")
ida_idaapi.require("pyclassinformer.pci_chooser")
ida_idaapi.require("pyclassinformer.method_classifier")
ida_idaapi.require("pyclassinformer.lib_classes_checker")
ida_idaapi.require("pyclassinformer.get_func_colors")

def run_pci(config=None, icon=-1):
    print("Starting PyClassInformer")
    if config is None:
        config = pyclassinformer.pci_config.pci_config()
    
    # find vftables with relevant structures
    result = pyclassinformer.msvc_rtti.rtti_parser.run(alldata=config.alldata, icon=-1)
    
    # show results
    tree = None
    if result:
        if config.rtti:
            pyclassinformer.msvc_rtti.rtti_parser.show(result)
        pyclassinformer.lib_classes_checker.set_libflag(result)
        gen_func_color, lib_func_color = pyclassinformer.get_func_colors.get_gen_lib_func_colors()
        pyclassinformer.pci_chooser.show_pci_chooser_t(result, icon=icon, libcolor=lib_func_color, defcolor=gen_func_color)
        tree = pyclassinformer.method_classifier.method_classifier(result, config=config, icon=icon)
        
        # dock the tree to next to functions
        if tree:
            # On ida 9.0, if the tree wdiget is directly docked in the same tab,
            # the Functions subview will freeze. I think it is a bug.
            # To avoid it, once create it as a floating widget, then dock it to
            # the Functions subview.
            ida_kernwin.set_dock_pos(tree.title, None, ida_kernwin.DP_FLOATING)
            ida_kernwin.set_dock_pos(tree.title, 'Functions', ida_kernwin.DP_TAB)
    else:
        print("Nothing found. RTTI might be disabled or it is not a Windows C++ program.")
    print("Done")
    
    return tree


def main():
    run_pci()

if __name__ == '__main__':
    main()

```

`pyclassinformer/qtutils.py`:

```py
import ida_kernwin

try:
    ModuleNotFoundError
except NameError:
    ModuleNotFoundError = ImportError

def can_use_qt():
    try:
        import sip
        from PyQt5 import QtCore
        from PyQt5 import QtWidgets
        from PyQt5 import QtGui
    # for ida 9.2 or later
    except ImportError:
        from shiboken6 import wrapInstance as wrapinstance
        from PySide6 import QtCore
        from PySide6 import QtWidgets
        from PySide6 import QtGui
    except ModuleNotFoundError:
        return False
    return True
    

def get_qver():
    try:
        from PyQt5 import QtCore
    # for ida 9.2 or later
    except ImportError:
        from PySide6 import QtCore
    v = QtCore.qVersion()
    maj, mnr, _ =[int(x) for x in v.split(".")]
    return maj, mnr


def get_widget(w, widget_types=None, title=None, max_try=100):
    try:
        from sip import wrapinstance
        from PyQt5 import QtWidgets
    # for ida 9.2 or later
    except ImportError:
        from shiboken6 import wrapInstance as wrapinstance
        from PySide6 import QtWidgets
    
    if widget_types is None:
        widget_types = set([QtWidgets.QWidget,QtWidgets.QSplitter])
        
    widget = wrapinstance(int(w), QtWidgets.QWidget)
    i = 0
    while i < max_try and widget and type(widget) != QtWidgets.QMainWindow:
        if type(widget) in widget_types:
            #print(widget.windowTitle(), type(widget))
            if title is not None:
                if title == widget.windowTitle():
                    find_flag = True
                    break
            else:
                find_flag = True
                break
        widget = widget.parent()
        i += 1
    return widget


def get_qmain_window(w, max_try = 100):
    if not can_use_qt():
        return None
    try:
        from sip import wrapinstance
        from PyQt5 import QtWidgets
    # for ida 9.2 or later
    except ImportError:
        from shiboken6 import wrapInstance as wrapinstance
        from PySide6 import QtWidgets
    if w is None:
        return None
    widget = wrapinstance(int(w), QtWidgets.QWidget)
    find_flag = False
    i = 0
    while i < max_try and widget:
        if  type(widget) == QtWidgets.QMainWindow:
            return widget
        widget = widget.parent()
        i += 1
    return None


def find_toolbar(widget, toolbar_name):
    if not can_use_qt():
        return None
    try:
        from PyQt5 import QtWidgets
    # for ida 9.2 or later
    except ImportError:
        from PySide6 import QtWidgets
    for cwidget in widget.children():
        if type(cwidget) == QtWidgets.QToolBar:
            #print(cwidget.objectName())
            #print(cwidget.accessibleName())
            if cwidget.objectName() == toolbar_name:
                return cwidget
    return None


def set_toobar_visible(w, toolbar_name):
    if not can_use_qt():
        return False
    try:
        from PyQt5 import QtCore
    # for ida 9.2 or later
    except ImportError:
        from PySide6 import QtCore
    widget = get_qmain_window(w)
    if widget:
        tb_widget = find_toolbar(widget, toolbar_name)
        if tb_widget and not tb_widget.isVisible():
            tb_widget.setEnabled(True)
            tb_widget.setVisible(True)
            return True
        widget.addToolBar(QtCore.Qt.TopToolBarArea, tb_widget)
    return False


class enable_toolbar_t(ida_kernwin.UI_Hooks):
    def __init__(self, toolbar_name):
        self.toolbar_name = toolbar_name
        ida_kernwin.UI_Hooks.__init__(self)
        self.hook()
        
    def ready_to_run(self):
        self.enable_toolbar()
        
    def enable_toolbar(self):
        widget = ida_kernwin.open_navband_window(ida_kernwin.get_screen_ea(),1)
        set_toobar_visible(widget, self.toolbar_name)
        
    def __del__(self):
        self.unhook()


class dark_mode_checker_t(object):
    
    @staticmethod
    def is_dark_mode():
        return dark_mode_checker_t.is_dark_mode_with_main()
    
    @staticmethod
    def get_main_window():
        try:
            from PyQt5 import QtWidgets
        # for ida 9.2 or later
        except ImportError:
            from PySide6 import QtWidgets
        except ModuleNotFoundError:
            return None
        
        widget = QtWidgets.QApplication.activeWindow()
        QtWidgets.QApplication.focusWidget()
        for widget in [QtWidgets.QApplication.activeWindow(), QtWidgets.QApplication.focusWidget()] + QtWidgets.QApplication.topLevelWidgets():
            while widget:
                if isinstance(widget, QtWidgets.QMainWindow):
                    break
                widget = widget.parent()
            if isinstance(widget, QtWidgets.QMainWindow):
                return widget
        return None
    
    @staticmethod
    def _is_dark_mode(bgcolor, threshold=128):
        if bgcolor >= 0:
            alpha = bgcolor >> 24
            bgcolor &= 0xffffff
            green = bgcolor >> 16
            blue = (bgcolor >> 8) & 0xff
            red = bgcolor & 0xff
            #print("%x, %x, %x, %x, %x" % (bgcolor, green, blue, red, alpha))
            if green < threshold and blue < threshold and red < threshold:
                return True
        return False
    
    @staticmethod
    def is_dark_mode_with_main():
        try:
            from PyQt5 import QtWidgets
        # for ida 9.2 or later
        except ImportError:
            from PySide6 import QtWidgets
        except ModuleNotFoundError:
            return False

        widget = dark_mode_checker_t.get_main_window()
        if not isinstance(widget, QtWidgets.QMainWindow):
            return False
        bgcolor = dark_mode_checker_t.get_bgcolor(x=0, y=0, w=widget)
        if bgcolor < 0:
            return False
        return dark_mode_checker_t._is_dark_mode(bgcolor)
        
    @staticmethod
    def get_bgcolor(x=0, y=0, w=None):
        bgcolor = -1
        if w is None:
            return bgcolor
        
        try:
            from sip import wrapinstance
            from PyQt5 import QtCore
            from PyQt5 import QtWidgets
            from PyQt5 import QtGui
        # for ida 9.2 or later
        except ImportError:
            from shiboken6 import wrapInstance as wrapinstance
            from PySide6 import QtCore
            from PySide6 import QtWidgets
            from PySide6 import QtGui
        except ModuleNotFoundError:
            return bgcolor
        
        if str(w).startswith("<Swig Object of type 'TWidget *' at") and str(type(w)) in ["<class 'SwigPyObject'>", "<type 'SwigPyObject'>"]: # type: for py2, class: for py3
            widget = wrapinstance(int(w), QtWidgets.QWidget)
        else:
            widget = w
            
        pixmap = widget.grab(QtCore.QRect(x, y, x+1, y+1))
        image = QtGui.QImage(pixmap.toImage())
        bgcolor = image.pixel(0, 0)
        
        return bgcolor
        

```

`pyclassinformer_plugin.py`:

```py
import ida_idaapi
import ida_kernwin

import os
import sys

dirpath = os.path.dirname(os.path.abspath(__file__))
script_dir = os.path.join(dirpath, "pyclassinformer")
if not os.path.isdir(script_dir):
    script_dir = os.path.join(dirpath, "..", "pyclassinformer")

ida_idaapi.require("pyclassinformer")
ida_idaapi.require("pyclassinformer.qtutils")

# for IDA 7.4 or earlier
try:
    g_flags = ida_idaapi.PLUGIN_MULTI
except AttributeError:
    g_flags = ida_idaapi.PLUGIN_DRAW

# for IDA 7.4 or earlier
try:
    g_obj = ida_idaapi.plugmod_t
except AttributeError:
    g_obj = object

g_plugmod_flag = False
if g_flags != ida_idaapi.PLUGIN_DRAW and g_obj != object:
    g_plugmod_flag = True

class pci_plugin_t(ida_idaapi.plugin_t):
    flags = g_flags
    comment = "Yet Another RTTI Parser"
    wanted_name = "PyClassInformer"
    wanted_hotkey = "Alt-Shift-L"
    help = "Press '" + wanted_hotkey + "' to display the " + wanted_name + " result."
    
    toolbar_displayed_name = wanted_name
    toolbar_name = toolbar_displayed_name + 'Toolbar'
    
    action_name = "pyclassinformer:execute"
    menu_path = "Edit/Plugins/"
    
    icon_data = open(os.path.join(script_dir, "pci_icon.png"), "rb").read()
    act_icon = ida_kernwin.load_custom_icon(data=icon_data, format="png")
    
    class exec_pci_action(ida_kernwin.action_handler_t):
        def __init__(self, plugin):
            ida_kernwin.action_handler_t.__init__(self)
            import weakref
            self.v = weakref.ref(plugin)
        
        def activate(self, ctx):
            self.v().plugin_mod.run(None)
            
        def update(self, ctx):
            return ida_kernwin.AST_ENABLE_ALWAYS
        
    def attach_to_menu_and_toolbar(self):
        # insert the action
        ida_kernwin.register_action(
            ida_kernwin.action_desc_t(
            self.action_name,
            self.comment,
            self.exec_pci_action(self),
            None,
            self.wanted_name,
            self.act_icon))
        
        # attach the action to menu
        ida_kernwin.attach_action_to_menu(
            self.menu_path,
            self.action_name,
            ida_kernwin.SETMENU_APP)

        # create the toolbar and attach the action to the toolbar
        ida_kernwin.create_toolbar(self.toolbar_name, self.toolbar_displayed_name)
        ida_kernwin.attach_action_to_toolbar(self.toolbar_name, self.action_name)
        
        # install ui hook to enable toolbar later
        self.ph = pyclassinformer.qtutils.enable_toolbar_t(self.toolbar_name)
        
    @staticmethod
    class register_icon(ida_kernwin.UI_Hooks):
        def updated_actions(self):
            if ida_kernwin.update_action_icon(pci_plugin_t.menu_path + pci_plugin_t.wanted_name, pci_plugin_t.act_icon):
                # unhook this if it's successful
                self.unhook()

    def init(self):
        ida_kernwin.msg("############### %s (%s) ###############%s" % (self.wanted_name, self.comment, os.linesep))
        ida_kernwin.msg("%s%s" % (self.help, os.linesep))

        # attach action to menu and toolbar
        self.attach_to_menu_and_toolbar()
        
        r = self.flags
        self.plugin_mod = pci_plugmod_t()
        if g_plugmod_flag:
            r = self.plugin_mod
        return r
    
    # for old IDA til 7.6
    def run(self, arg):
        self.plugin_mod.run(arg)
        
    # for old IDA til 7.6
    def term(self):
        self.plugin_mod.term()
        

class pci_plugmod_t(g_obj):
    toolbar_name = pci_plugin_t.toolbar_name
    menu_path = pci_plugin_t.menu_path
    action_name = pci_plugin_t.action_name
    act_icon = pci_plugin_t.act_icon
    
    def __del__(self):
        self.term()
        
    def run(self, arg):
        pci_plugmod_t.run_pci(icon=self.act_icon)
        
    def term(self):
        self.detatch_from_menu_and_toolbar()
        
    def detatch_from_menu_and_toolbar(self):
        ida_kernwin.detach_action_from_toolbar(self.toolbar_name, self.action_name)
        ida_kernwin.delete_toolbar(self.toolbar_name)
        ida_kernwin.detach_action_from_menu(self.menu_path, self.action_name)
        ida_kernwin.free_custom_icon(self.act_icon)
        ida_kernwin.unregister_action(self.action_name)
        
    @staticmethod
    def run_pci(icon=-1):
        ida_idaapi.require("pyclassinformer.pci_config_form")
        config = pyclassinformer.pci_config_form.pci_form_t.show()
        if config is not None:
            ida_idaapi.require("pyclassinformer.pyclassinformer")
            pyclassinformer.pyclassinformer.run_pci(config=config, icon=icon)
        else:
            print("PyClassInformer: Canceled")


def PLUGIN_ENTRY():
    return pci_plugin_t()


# install a UI hook to add icon in the plugin menu
ri = pci_plugin_t.register_icon()
ri.hook()

```