Project Path: arc_cellebrite-labs_ida_kcpp_p8xfgtbq

Source Tree:

```txt
arc_cellebrite-labs_ida_kcpp_p8xfgtbq
├── README.md
├── ida_kcpp
│   ├── __init__.py
│   ├── logic.py
│   ├── ui.py
│   ├── ui_utils.py
│   └── utils.py
├── ida_kcpp_plugin.py
└── images
    ├── choose_vfunc.png
    └── general_overview.gif

```

`README.md`:

```md
# ida_kcpp

An IDAPython module for way more convienent way to Reverse Engineering iOS kernelcaches.

Big part of the iOS kernelcache is written by C++, which compiled into complicated binary code use many virtual table derefences rather than explicit direct calls.`ida_kcpp` takes the advanteage of `ida_kernelcache` classes hierarchy reconstruction. It maps the IDB and synchronizes the binary functions and the original virtual methods. It enables navigation through the iOS kernelcache by double-clicking on c++ virtual methods call, finding their xrefs, and keeping all of it synchronized during live research.

`ida_kcpp` is inspired by [ida_medigate](https://github.com/medigateio/ida_medigate) but benefits from the unique structure of the iOS kernelcache and provides more powerful and convenient research environment.

![general_view](images/general_overview.gif)

# Installation

1. Install  [ida_kernelcache(Cellebrite's fork)](https://github.com/cellebrite-srl/ida_kernelcache)
1. Make sure `ida_kernelcache` and `ida_kcpp` are in IDA python path.

Could also be added by adding into `~/.idapro/idapythonrc.py`:

```python
import sys
sys.path.append(IDA_KCPP_PATH)
sys.path.append(IDA_KERNELCACHE_PATH)
```

2. clone the repository and symlink  `~/.idapro/plugins/ida_kcpp_plugin.py` to `ida_kcpp_plugin.py`
2. Install [ida-netnode](https://github.com/williballenthin/ida-netnode)
2. [Optional]: Install [ida-referee](https://github.com/joeleong/ida-referee) if decompiler structs fields xrefs tracking is required

# Usage

## Preliminary Analysis

1. Open analyzed kernelcache. If `ida_kernelcache` has not run yet, please run it `edit >> Plugins >> Kernel Cache CPP  >> ida_kernelcache process kernel`
2. Run `Edit >> Plugins >> Kernel Cache CPP >> Perform Initial sync...` (Some warning messageboxes might appear, you can ignore them for now).  This step renames Virtual functions names by setting their prefix to the class they belong. This step also decompiles all the virtual functions, sets their `this` argument, and changes the relevant `::vmethods` member to be a function pointer to the decompiled type. **This step can take a while...**
3. Now there is a "Synced IDB", but **pay attention - the plugin isn't activated yet.**

## Plugin activating for a synced IDB

`ida_kcpp` automatically propagates names and prototypes, and also changes some aspects of navigation in IDA, hence is not activated automatically but at any point may be activated or deactivated.

Activate `ida_kcpp` by clicking on `edit >> Plugins >> Kernel Cache CPP >> Activate Plugin` (This will install the Hexrays hooks and also run `ida_kernelcache.collect_class_info()`)

## Deactivate the plugin

clicking on `Edit >> Plugins >> Kernel Cache CPP >> Deactivate Plugin`

# Features overview

## Virtual functions synchronizer

### Virtual function renaming

**When renaming a virtual function** one may edit the mangled name (for example `__ZNK10AppleA7IOP9method_86Ev_99`), or change it to human-being names (`AppleA7IOP::method_86`) which will be mangled automatic. The relevant `ANCESTOR::vmethods`  member will be renamed as well, and also all of the virtual functions that implement the same virtual method will be renamed too.

### Virutal function prototype updating

The same goes for **virutal function prototype changing**. In this case, the relevant `ANCESTOR::vmethods` member's prototype will be changed to a function pointer to the type that just was set, with setting `this` as `ANCESTOR *`. Also, the prototypes of all of the relevant virtual method implementations of the ANCESTOR's DESCENDANTS will be changed, with setting their `this` to `DESCENTANT *`.

## Improved XREFS

* We add an xref from every virtual function to it's abstract `::vmethods` member.
* Using `ida_referee` we can track uses of every field, and especially `::vmethods` member (virtual calls) in the decompiler.
  * We also added `CTRL+SHIFT+Y` hotkey from virtual function, to directly opening the xrefs window to its relevant `::vmethod` member. *IDA has a bug and this only works from the disassembly window and not from the decompiler.*

## Improved Navigation

* Decompiler: Double click on a virtual function call pops up a window that allowing the user to choose the implementation of the virtual method.

  ![image-20220707161129479](images/choose_vfunc.png)

* Structures window:

  * Double click on virtual method pops up the same window as in the decompiler
  * Fixed an IDA bug that double-click on struct name that contains `::` won't jump.

# Future improvements

1. Adding support in IDA7.2 c++ classes compatibility. Require changing ida_kernelcache structs layout which we didn't do yet for legacy reason
2. Adding a name/prototype resolving interface for conflicts.

# Meta

Authored by Uriel Malin, Ievgen Solodovnykov and Omer Porzecanski of Cellebrite Labs.
Developed and tested for IDA8.4/iOS 18.4 on macOS with python 3.10.2

```

`ida_kcpp/logic.py`:

```py
import collections
import json
import logging
import pathlib
import re
import subprocess

import netnode

import ida_auto
import ida_bytes
import ida_hexrays
import ida_idaapi
import ida_name
import ida_struct
import ida_typeinf
import ida_xref
import idautils
import idc
from . import utils

initialized = False
logger = None
vfunc_to_vmethod = None
config = None
VFuncMetadata = collections.namedtuple('VFuncMetadata', ['impl_class', 'base_class', 'vmethod_offset', 'vtable_offset'])


def init_if_needed(only_collect=True):
    global initialized
    if initialized:
        return
    initialized = True

    # ida_kernelcache shall be imported on demand, otherwise it throws errors
    global ida_kernelcache
    import ida_kernelcache
    import ida_kernelcache.classes
    import ida_kernelcache.ida_utilities

    global logger

    # Create a custom logger
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)
    # Create handlers
    c_handler = logging.StreamHandler()
    f_handler = logging.FileHandler('/tmp/ida_kcpp.log')
    c_handler.setLevel(logging.ERROR)
    f_handler.setLevel(logging.DEBUG)

    # Create formatters and add it to handlers
    c_format = logging.Formatter('%(name)s - %(levelname)s - %(message)s')
    f_format = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    c_handler.setFormatter(c_format)
    f_handler.setFormatter(f_format)

    # Add handlers to the logger
    logger.addHandler(c_handler)
    logger.addHandler(f_handler)

    if only_collect:
        ida_kernelcache.collect_class_info()
    else:
        ida_kernelcache.kernelcache_process()

    global vfunc_to_vmethod
    vfunc_to_vmethod = netnode.Netnode("$ ida_kcpp.vfunc_to_vmethod")

    global config
    config = netnode.Netnode("$ ida_kcpp.config")


def vfunc_metadata(func):
    def wrapper(ea, *args, **kwargs):
        if ea not in vfunc_to_vmethod:
            return
        vfunc_metadata = VFuncMetadata(*vfunc_to_vmethod[ea])
        return func(ea, vfunc_metadata, *args, **kwargs)
    return wrapper


def find_vtable_funcptr_from_expr(e):
    """Check if expr is from the form x->x::vtable->y::vmethods.methodz
    :returns x and absolute method offset inside x::vtable"""
    method_cand_expr = e
    if method_cand_expr.op != ida_hexrays.cot_memref:
        return
    offset = method_cand_expr.m  # method offset in y::vmethods
    vmethods_cand_expr = method_cand_expr.x
    if vmethods_cand_expr.op != ida_hexrays.cot_memptr:
        return
    if not str(vmethods_cand_expr.type).endswith("::vmethods"):  # check y::methods
        return
    offset += vmethods_cand_expr.m  # add y::methods offset in x::vtable
    vtable_cand_expr = vmethods_cand_expr.x
    if vtable_cand_expr.op != ida_hexrays.cot_memptr:
        return
    vtable_cand = utils.extract_struct_from_tinfo(vtable_cand_expr.type)
    vtable_cand_struc_name = ida_struct.get_struc_name(vtable_cand.id)
    if vtable_cand_struc_name.endswith("::vtable"):
        return vtable_cand_struc_name[:-len("::vtable")], offset


def get_func_in_vtable(class_info_or_name, offset_in_vtable):
    if isinstance(class_info_or_name, str):
        class_name = class_info_or_name
        if class_name not in ida_kernelcache.class_info:
            return ida_idaapi.BADADDR
        class_info = ida_kernelcache.class_info[class_name]
    elif isinstance(class_info_or_name, ida_kernelcache.classes.ClassInfo):
        class_info = class_info_or_name
    else:
        raise TypeError("class_info_or_name expected to be str or ClassInfo")
    if class_info.vtable:
        return ida_kernelcache.ida_utilities.read_word(class_info.vtable_methods + offset_in_vtable)
    return ida_idaapi.BADADDR


def gather_funcs_from_descendants(ancestor_classname, offset_in_vtable):
    funcs = []
    ancestor_virtual_func = get_func_in_vtable(ancestor_classname, offset_in_vtable)
    if ancestor_virtual_func != ida_idaapi.BADADDR and utils.is_func_start(ancestor_virtual_func):
        # TODO: can remove the check about 0 and try to hunt the problematic virtual table.
        funcs.append((ancestor_classname, ancestor_virtual_func))
    if ancestor_classname in ida_kernelcache.class_info:
        for descendant in ida_kernelcache.class_info[ancestor_classname].descendants():
            descendant_virtual_func = get_func_in_vtable(descendant, offset_in_vtable)
            if descendant_virtual_func != ida_idaapi.BADADDR and utils.is_func_start(descendant_virtual_func) != 0:
                # TODO: can remove the check about 0 and try to hunt the problematic virtual table.
                funcs.append((descendant.classname, descendant_virtual_func))
    return funcs


def perform_initial_sync(ui_update_func):
    fix_classes_vtables_top_down(ui_update_func)
    path = pathlib.Path(__file__)
    git_dir = path.parent.parent.absolute()
    hash_file = subprocess.check_output(['git', '-C', git_dir, 'rev-parse', 'HEAD']).decode('ascii').strip('\n')
    config["commit_hash"] = hash_file


@utils.batch_mode
def fix_classes_vtables_top_down(ui_update_func):
    parsed_classes = set()
    descendants = list(ida_kernelcache.class_info["OSObject"].descendants())
    descendants_len = len(descendants)
    for class_info in descendants:
        if class_info in parsed_classes:
            continue
        for class_info_to_fix in class_info.ancestors(inclusive=True):
            if class_info_to_fix in parsed_classes:
                continue
            try:
                ui_update_func(f"ida_kcpp: fixing classes vtables ({len(parsed_classes)}/{descendants_len})")
                fix_vtable(class_info_to_fix)
            except Exception as e:
                logger.warning(
                    f"Error in fixing {class_info_to_fix.classname} while iterating {class_info.classname} ancestors"
                )
            parsed_classes.add(class_info_to_fix)


def find_own_vmethods_offset_in_vtable(class_name):
    vtable_sptr = utils.get_sptr_by_name(class_name + "::vtable")
    if vtable_sptr is None:
        logger.warning(f"Couldn't find struc {class_name}::vtable")
        return
    offset = 0
    while offset != ida_idaapi.BADADDR and offset < ida_struct.get_struc_size(vtable_sptr):
        curr_vtable_member = ida_struct.get_member(vtable_sptr, offset)
        if not curr_vtable_member:
            logger.warning(f"Couldn't find struc member at {class_name}::vtable offset {offset}")
            return
        vmethods_sptr = utils.get_member_substruct(curr_vtable_member)
        if not vmethods_sptr:
            logger.warning(
                f"{class_name}::vtable can't find vmethods struct in offset {hex(offset)}"
            )
            return
        vmethods_name = ida_struct.get_struc_name(vmethods_sptr.id)
        if not vmethods_name.endswith("::vmethods"):
            logger.warning(
                f"{class_name}::vtable can't find vmethods struct in offset {hex(offset)}"
            )
            return
        if "".join(vmethods_name.split(":")[:-1]) == class_name:
            return offset
        offset = ida_struct.get_struc_next_offset(vtable_sptr, offset)
    return None


def extract_method_name_from_func_ea(func_ea):
    if ida_bytes.has_dummy_name(ida_bytes.get_flags(func_ea)):
        return
    return extract_method_name(ida_kernelcache.ida_utilities.get_ea_name(func_ea))

def extract_method_name(impl_name):
    if impl_name == "___cxa_pure_virtual" or impl_name.startswith("nullsub"):
        return
    mangled_class, method_name = utils.parse_mangled_method_name(impl_name)
    if not (mangled_class or method_name):
        return
    if method_name.startswith("method_") and method_name[len("method_"):].isnumeric():
        return
    return method_name


def find_vmethod_name_candidates(class_name, offset_in_vtable, member_name):
    all_impls = gather_funcs_from_descendants(class_name, offset_in_vtable)
    unique_impls = {}
    cands = []
    for imple_class_name, impl in all_impls:
        if impl not in unique_impls:
            unique_impls[impl] = imple_class_name
            method_name = extract_method_name(impl)
            if method_name and method_name != member_name:
                cands.append((method_name, impl))
    if not cands:
        return member_name, unique_impls, all_impls
    elif len(cands) > 1:
        logger.warning(f"More than one option to {class_name} offset {offset_in_vtable}")
        # TODO: handle this collision

    else:
        cand_name, cand = cands[0]
        if member_name.startswith("method_") and member_name[len("method_"):].isnumeric():
            return cand_name, unique_impls, all_impls
        else:
            logger.warning(f"Cand and not generic member name for {class_name} offset {offset_in_vtable}")
    return None, None, all_impls


def link_vfuncs_to_vmethod(class_name, offset_in_vmethods, offset_in_vtable, all_impls, vmethod_member_id):
    for impl_class_name, impl_ea in all_impls:
        if impl_ea not in vfunc_to_vmethod:
            vfunc_to_vmethod[impl_ea] = (impl_class_name, class_name, offset_in_vmethods, offset_in_vtable)
            ida_xref.add_dref(vmethod_member_id, impl_ea, ida_xref.dr_I | ida_xref.XREF_USER)


def fix_virtual_method(class_name, vmethods_sptr, vmethods_member, vmethods_offset, vmethods_offset_in_vtable):
    member_name = ida_struct.get_member_name(vmethods_member.id)
    offset_in_vtable = vmethods_offset + vmethods_offset_in_vtable
    chosen_method_name, unique_impls, all_impls = find_vmethod_name_candidates(class_name,
                                                                               offset_in_vtable, member_name)
    link_vfuncs_to_vmethod(class_name, vmethods_offset, offset_in_vtable, all_impls, vmethods_member.id)
    if not (chosen_method_name and unique_impls):
        return
    if chosen_method_name != member_name:
        ida_struct.set_member_name(vmethods_sptr, vmethods_member.soff, chosen_method_name)
    for impl, impl_class_name in unique_impls.items():
        full_name = utils.generate_method_name(impl_class_name, chosen_method_name)
        utils.set_func_name(impl, full_name)
        func_type = utils.decompile_and_update_this(impl, utils.get_typeinf_ptr(impl_class_name))
        if func_type and impl_class_name == class_name:
            func_ptr = utils.get_typeinf_ptr(func_type)
            ida_struct.set_member_tinfo(vmethods_sptr, vmethods_member, 0, func_ptr, ida_typeinf.TINFO_DEFINITE)


def fix_vtable(class_info):
    """This functions locates the ::vtable struct of given class_info and iterates by its vmethod structs over
    the actual vtable for'class_info'. Then it sets the name of every `dummy_function` to be a mangling of
    class name and function name according to the relevant vmethod. It also decompiles the function and sets its first
    argument to be `this` from the relevant type. Then, only in the vmethods struct of the class, it changes the
    type of the relevant vmethod member to be a funcptr to the decompiled function
    """
    class_name = class_info.classname
    vmethods_offset_in_vtable = find_own_vmethods_offset_in_vtable(class_name)
    if vmethods_offset_in_vtable is None:
        logger.warning(f"Couldn't find vmethod in vtable of {class_name}")
        return
    vmethods_sptr = utils.get_sptr_by_name(class_name + "::vmethods")
    if not vmethods_sptr:
        logger.warning("%s struct doesn't exist" % (class_name + "::vmethods"))
        return
    for vmethods_member, vmethods_offset in utils.iterate_struct_members(vmethods_sptr):
        fix_virtual_method(class_name, vmethods_sptr, vmethods_member, vmethods_offset, vmethods_offset_in_vtable)


@vfunc_metadata
def virtual_method_renamed(ea, vfunc_metadata, class_name, method_name):
    if vfunc_metadata.impl_class != class_name:
        logger.warning(f"Bad name case of {hex(ea)} from saved impl_class {vfunc_metadata.impl_class} to "
                       f"{class_name}::{method_name}")
    rename_virtual_method(vfunc_metadata.base_class, vfunc_metadata.vtable_offset, vfunc_metadata.vmethod_offset,
                          method_name)


def virtual_method_member_renamed(class_name, vmethod_offset, method_name):
    vtable_offset = find_own_vmethods_offset_in_vtable(class_name) + vmethod_offset
    rename_virtual_method(class_name, vtable_offset, vmethod_offset, method_name, set_member_name=False)


def rename_virtual_method(class_name, vtable_offset, vmethod_offset, method_name, set_member_name=True):
    member_name = method_name
    if set_member_name:
        vmethod_sptr = utils.get_sptr_by_name(class_name + "::vmethods")
        i = 0
        for i in range(20):
            if i > 0:
                member_name = method_name + "_" + str(i)
            if ida_struct.set_member_name(vmethod_sptr, vmethod_offset, member_name):
                break
        else:
            logger.warning(f"Couldn't rename f{class_name}::vemthod at offset {hex(vmethod_offset)} to {method_name}")
            return
        member = ida_struct.get_member(vmethod_sptr, vmethod_offset)
        comment = ida_struct.get_member_cmt(member.id, 1)
        if comment and comment.startswith("Conflicting virtual function name"):
            ida_struct.set_member_cmt(member, '', 1)
    impls = gather_funcs_from_descendants(class_name, vtable_offset)
    changed_funcs = set()
    for _, impl_ea in impls:
        if impl_ea not in changed_funcs:
            impl_name = ida_kernelcache.ida_utilities.get_ea_name(impl_ea)
            impl_orig_class_name, impl_orig_method_name = utils.parse_mangled_method_name(impl_name)
            if not (impl_orig_method_name and impl_orig_class_name):
                logger.warning(f"Skipping impl with unexpected name: {impl_name}")
                continue
            new_impl_name = utils.generate_method_name(impl_orig_class_name, member_name)
            ida_name.set_name(impl_ea, new_impl_name, ida_name.SN_AUTO | ida_name.SN_FORCE | ida_name.SN_NOWARN)
            changed_funcs.add(impl_ea)


@vfunc_metadata
def virtual_method_prototype_changed(ea, vfunc_metadata, method_details):
    class_name = vfunc_metadata.base_class
    vtable_offset = vfunc_metadata.vtable_offset
    vmethods_offset = vfunc_metadata.vmethod_offset
    vmethods_sptr = utils.get_sptr_by_name(class_name + "::vmethods")
    vmethods_member = ida_struct.get_member(vmethods_sptr, vmethods_offset)
    function_tinfo = ida_typeinf.tinfo_t()
    new_details = utils.duplicate_details_with_this(method_details, utils.get_typeinf_ptr(class_name))
    function_tinfo.create_func(new_details)
    func_ptr = utils.get_typeinf_ptr(function_tinfo)
    ida_struct.set_member_tinfo(vmethods_sptr, vmethods_member, 0, func_ptr, ida_typeinf.TINFO_DEFINITE)
    propagate_vmethod_member_prototype_change(class_name, vtable_offset, method_details, ea)


def virtual_method_member_prototype_changed(class_name, mptr):
    method_details = ida_typeinf.func_type_data_t()
    funcptr = ida_typeinf.tinfo_t()
    if not ida_struct.get_member_tinfo(funcptr, mptr):
        return
    if not funcptr.is_funcptr():
        return
    func = funcptr.get_pointed_object()
    if not func.get_func_details(method_details):
        return
    vmethod_in_vtable = find_own_vmethods_offset_in_vtable(class_name)
    propagate_vmethod_member_prototype_change(class_name, mptr.soff + vmethod_in_vtable, method_details)


def propagate_vmethod_member_prototype_change(class_name, vtable_offset, method_details, ea=None):
    impls = gather_funcs_from_descendants(class_name, vtable_offset)
    changed_funcs = {ea}
    for impl_class_name, impl_ea in impls:
        if impl_ea not in changed_funcs:
            this_type = utils.get_typeinf_ptr(impl_class_name)
            if len(method_details) > 0:
                utils.update_func_details(impl_ea, utils.duplicate_details_with_this(method_details, this_type))
            changed_funcs.add(impl_ea)


@vfunc_metadata
def get_member_id_for_vfunc(ea, func_metadata):
    if utils.is_func_start(ea):
        sid = ida_struct.get_struc_id(func_metadata.base_class + "::vmethods")
        if sid is ida_idaapi.BADADDR:
            return
        sptr = ida_struct.get_struc(sid)
        if not sptr:
            return
        mid = ida_struct.get_member_id(sptr, func_metadata.vmethod_offset)
        if mid == ida_idaapi.BADADDR:
            return
        return mid


def shrink_struct(name, how_much):
    if how_much == 0:
        return

    sptr = utils.get_sptr_by_name(name)
    if not sptr:
        raise RuntimeError("struct {name} does not exist")
    curr_size = ida_struct.get_struc_size(sptr)
    assert how_much < curr_size

    new_size = curr_size - how_much

    # remove last members
    ida_struct.del_struc_members(sptr, new_size, curr_size + 1)
    curr_size = ida_struct.get_struc_size(sptr)
    assert curr_size <= new_size

    # add padding member if required
    if curr_size < new_size:
        ida_struct.add_struc_member(sptr, None, new_size - 1, 0, None, 1)

    # verify that we're alright
    assert ida_struct.get_struc_size(sptr) == new_size
    return sptr


def get_fields_member_in_iokit_class(class_name):
    class_sptr = utils.get_sptr_by_name(class_name)
    fields_member = ida_struct.get_member_by_name(class_sptr, class_name)
    if not fields_member:
        raise RuntimeError(f"Class {class_name} does not have {class_name} member")
    member_tinfo = utils.get_member_tinfo(fields_member)
    expected_fields_name = class_name + "::fields"
    if not (member_tinfo.is_struct() and member_tinfo.get_type_name() == expected_fields_name):
        raise RuntimeError(f"member {class_name}.{class_name} isn't of type {class_name}::fields")
    return fields_member


def fix_containing_struct(class_name, fields_member_offset, next_member_offset, fields_sptr):
    sptr = utils.get_sptr_by_name(class_name)
    if not sptr:
        return
    fields_class_name = ida_struct.get_struc_name(fields_sptr.id)[:-len("::fields")]
    utils.add_struct_substruct_member(sptr, fields_class_name, fields_member_offset, fields_sptr.id)
    next_member = ida_struct.get_member(sptr, next_member_offset)
    if next_member:
        next_member_fields = utils.get_struc_from_tinfo(utils.get_member_tinfo(next_member))
        if not next_member_fields:
            return
        next_member_name = ida_struct.get_member_name(next_member.id)
        return sptr, next_member_name, next_member_fields


def shrink_iokit_class(class_name, how_much):
    if how_much == 0:
        return

    if class_name not in ida_kernelcache.class_info:
        raise NameError(f"no such class_info: {class_name}")

    fields_member = get_fields_member_in_iokit_class(class_name)
    fields_member_offset = fields_member.soff
    next_member_offset = fields_member.soff + fields_member.get_size()
    old_auto_analysis_status = ida_auto.enable_auto(False)
    fields_sptr = shrink_struct(class_name + "::fields", how_much)
    fix_containing_struct(class_name, fields_member_offset, next_member_offset, fields_sptr)

    expanded_fields = set()
    structs_to_fix = []

    class_info = ida_kernelcache.class_info[class_name]
    for descendant in class_info.descendants():
        to_fix = fix_containing_struct(descendant.classname, fields_member_offset, next_member_offset, fields_sptr)
        if to_fix:
            structs_to_fix.append(to_fix)

    next_member_new_offset = fields_member_offset + ida_struct.get_struc_size(fields_sptr)
    for sptr, member_name, next_member_fields in structs_to_fix:
        if next_member_fields.id not in expanded_fields:
            expanded_fields.add(next_member_fields.id)
            old_struct_size = ida_struct.get_struc_size(next_member_fields)
            ida_struct.del_struc_member(next_member_fields, old_struct_size)
            if ida_struct.get_struc_size(next_member_fields) < old_struct_size:
                ida_struct.add_struc_member(next_member_fields, None, old_struct_size - 1, 0, None, 1)
            ida_struct.expand_struc(next_member_fields, 0, how_much)
        utils.add_struct_substruct_member(sptr, member_name, next_member_new_offset, next_member_fields.id)

    ida_auto.enable_auto(old_auto_analysis_status)


def export_function_symbols(filepath):
    functions = {}
    for ea in idautils.Functions():
        name = idc.get_name(ea)
        # Check name is user defined
        if (not idc.hasUserName(ida_bytes.get_full_flags(ea))):
            continue
        # ...And that it isn't a "Classname::method_X" default name
        _, method_name = parse_mangled_method_name(name)
        if method_name and bool(re.fullmatch(r"method_\d+", method_name)):
            continue            
        # ...Nor a InitFunc/TermFunc
        if '_InitFunc_' in name or '_TermFunc_' in name:
            continue
        functions[hex(ea)] = name
    with open(filepath, "w") as f:
        json.dump(functions, f)


def _load_function_symbol(ea, name):
    # If ea is not vmethod, rename and return.
    # In case function already has a user defined name,
    # chain them together as "option1_OR_option2"
    if ea not in vfunc_to_vmethod:
        if idc.hasUserName(ida_bytes.get_full_flags(ea)):
            existing_name = ida_name.get_ea_name(ea)
            if existing_name == name: return
            name += f'_OR_{existing_name}'
        ida_name.set_name(ea, name, ida_name.SN_AUTO | ida_name.SN_FORCE)
        return
    
    # Using gathered metadata, find the ::vmethods struct this vfunction is defined in.
    # If the name defined in the struct is method_XX we know this function wasn't RE yet,
    # and we can change both the ::vmethods member's name and every implementing function's name
    vfunc_metadata = VFuncMetadata(*vfunc_to_vmethod[ea])
    vmethods_struct_name = vfunc_metadata.base_class + '::vmethods'
    sptr = utils.get_sptr_by_name(vmethods_struct_name)
    if not sptr:
        logger.warning(f"{vmethods_struct_name} structure not found.")
        return
    member = ida_struct.get_member(sptr, vfunc_metadata.vmethod_offset)
    if not member:
        logger.warning(f"Could not find struct {vmethods_struct_name} member at offset {vfunc_metadata.vmethod_offset}")
        return
    member_name = ida_struct.get_member_name(member.id)
    sym_method_name = extract_method_name(name)
    if sym_method_name is None:
        logger.warning(f"Func {name} in ea {hex(ea)} can't be demangled")
        return
    logger.warning(f"{name} demangled into -> {sym_method_name}")
    # TODO: apply mangled method name on method prototype
    if (member_name.startswith("method_") and member_name[len("method_"):].isnumeric()):
        rename_virtual_method(vfunc_metadata.base_class, vfunc_metadata.vtable_offset,
                              vfunc_metadata.vmethod_offset, sym_method_name, set_member_name=True)
        return

    # Otherwise, we know ea is a vmethod and it has already been RE in one of the classes in the hierarchy.
    # So, we change struct member's name to CONFLICT_XX and add a comment that specifies all the collisions.
    # We also rename all the matching functions in the inheritance tree to classname::CONFLICT_XX
    # But first, check that we don't apply all this logic in case we "rename" to the current name...
    if member_name == sym_method_name or sym_method_name == "_".join(member_name.split("_")[:-1]):
        # if sym_method_name is the same as member_name or member_name_POSTFIX-NUM
        return
    vtable_off = vfunc_metadata.vtable_offset
    word_size = ida_kernelcache.ida_utilities.WORD_SIZE
    conflict_name = f'CONFLICT_{vtable_off // word_size}'
    set_member_name = 'CONFLICT_' not in member_name
    rename_virtual_method(vfunc_metadata.base_class, vfunc_metadata.vtable_offset, 
                          vfunc_metadata.vmethod_offset, conflict_name, set_member_name)
    comment = ida_struct.get_member_cmt(member.id, 1)
    if not comment:
        comment = 'Conflicting virtual function name with:\n%s @ 0x%x' % (member_name, ea)
    demangled_name = idc.demangle_name(name, idc.get_inf_attr(idc.INF_LONG_DN))
    if demangled_name:
        comment += '\n%s @ 0x%x' % (demangled_name, ea)
    else:
        comment += '\n%s @ 0x%x' % (name, ea)
    ida_struct.set_member_cmt(member, comment, 1)
    
def import_function_symbols(filepath):
    if filepath.endswith(".json"):
        with open(filepath, "r") as f:
            functions = json.load(f)
    elif filepath.endswith(".syms"):
        with open(filepath, 'r') as f:
            functions = {}
            for l in f:
                comps = l.split(' ')
                if len(comps) > 1:
                    addr, name = comps[0].strip(), comps[1].strip()
                    if not "fn_0x" in name and not name.startswith("sub_"):
                        functions[addr] = name
    for addr, name in functions.items():
        _load_function_symbol(int(addr, 16), name)
        

```

`ida_kcpp/ui.py`:

```py
import ida_hexrays
import ida_idaapi
import ida_idp
import ida_kernwin
import ida_moves
import ida_name
import ida_struct
import ida_typeinf
import idaapi

from . import logic, ui_utils, utils


class HexraysDoubleClickHook(ida_hexrays.Hexrays_Hooks):
    def __init__(self):
        super().__init__()
        self.vu = None

    def double_click(self, vu, shift):
        self.vu = vu
        if not (vu.item and vu.item.is_citem()):
            return 0
        result = logic.find_vtable_funcptr_from_expr(vu.item.e)
        if not result:
            return 0
        class_name, offset_in_vtable = result
        return jump_to_virtual_func(class_name, offset_in_vtable)


class VirtualFunctionChooser(ui_utils.Choose):
    def __init__(self, items):
        super().__init__("Choose a Virtual function...", items, [
            ["Class", 30 | self.CHCOL_PLAIN],
            ["Function name", 40 | self.CHCOL_FNAME],
            ["Address", 20 | self.CHCOL_HEX],
        ])


def jump_to_virtual_func(ancestor_name, offset_in_vtable):
    functions_table = logic.gather_funcs_from_descendants(ancestor_name, offset_in_vtable)
    vtable_func = ida_idaapi.BADADDR
    if not functions_table:
        return 0
    elif len(functions_table) == 1:
        _, vtable_func = functions_table[0]
    else:
        prepared_data = []
        functions_set = set()
        for class_name, virtual_func in functions_table:
            functions_set.add(virtual_func)
            virtual_func_formatted = "0x%016X" % virtual_func
            func_name = ida_name.get_ea_name(virtual_func)
            func_class_name, method_name = utils.parse_mangled_method_name(func_name)
            if func_class_name:
                func_name = func_class_name + "::" + method_name
            prepared_data.append((class_name, func_name, virtual_func_formatted))
        if len(functions_set) > 1:
            vf_chooser = VirtualFunctionChooser(prepared_data)
            chosen_vf = vf_chooser.show()
            if chosen_vf:
                _, _, vtable_func_formatted = chosen_vf
                vtable_func = int(vtable_func_formatted, 16)
        else:
            (vtable_func,) = functions_set
    if vtable_func != ida_idaapi.BADADDR:
        ida_kernwin.jumpto(vtable_func)
        return 1
    return 0


class VirtualFuncsSynchronizer(ida_idp.IDB_Hooks):
    def renamed(self, ea, new_name, local_name, old_name):
        if utils.is_func_start(ea):
            if "::" in new_name:
                self.unhook()
                class_name, method_name = new_name.split("::")
                full_name = utils.generate_method_name(class_name, method_name)
                utils.set_func_name(ea, full_name)
            else:
                class_name, method_name = utils.parse_mangled_method_name(new_name)
                if class_name is None:
                    # Case only actual method name was assigned without class prefix
                    if ea not in logic.vfunc_to_vmethod:
                        return
                    vfunc_metadata = logic.VFuncMetadata(*logic.vfunc_to_vmethod[ea])
                    class_name = vfunc_metadata.impl_class
                    method_name = new_name
                    full_name = utils.generate_method_name(class_name, method_name)
                    utils.set_func_name(ea, full_name)
                self.unhook()
            logic.virtual_method_renamed(ea, class_name, method_name)
            self.hook()
    
    # TODO: use lt_udm_renamed when porting to ida9
    def local_types_changed(self, ltc, ordinal, name):
        # There are two very annoying things about local_types_changed:
        #   1. the parameters tell you very little about WHAT changed.
        #      specifically, we can't really tell in which way a struct 
        #      was edited.
        #   2. this function hooks in exactly after the change starts
        #      but before it takes place. So for example if a member is
        #      modified by the user, the old name/type will still presist
        #      if this function tries to read them.
        # So in order to overcome these restrictions, we use
        # execute_ui_requests to perform the logic of this 
        # hook only AFTER the renaming/retyping takes place.
        # ...And instead of updating the functions that match
        # only the member that was modified, we update the matching
        # functions for EVERY member.
        if ltc != ida_idp.LTC_EDITED or not name.endswith("::vmethods"):
            return
        idaapi.execute_ui_requests([lambda: self._update_vmethods(name)])
    
    def _update_vmethods(self, name):
        sid = ida_struct.get_struc_id(name)
        sptr = ida_struct.get_struc(sid)
        self.unhook()
        class_name = name.split("::")[0]
        for mptr in sptr.members:
            vtable_offset = logic.find_own_vmethods_offset_in_vtable(class_name) + mptr.soff
            generic_method_name = f"method_{vtable_offset // 8}"
            logic.virtual_method_member_renamed(class_name, mptr.soff, generic_method_name)
        for mptr in sptr.members:
            member_name = ida_struct.get_member_name(mptr.id)
            logic.virtual_method_member_renamed(class_name, mptr.soff, member_name)    
            logic.virtual_method_member_prototype_changed(class_name, mptr)
        self.hook()
        
    def ti_changed(self, ea, ti_type, ti_fname):
        if not utils.is_func_start(ea):
            return
        tinfo = ida_typeinf.tinfo_t()
        tinfo.deserialize(None, ti_type, ti_fname, None)
        func_details = ida_typeinf.func_type_data_t()
        tinfo.get_func_details(func_details)
        self.unhook()
        logic.virtual_method_prototype_changed(ea, func_details)
        self.hook()


class StructsDoubleColonHooks(ida_kernwin.View_Hooks):
    def __init__(self):
        super(StructsDoubleColonHooks, self).__init__()
        self.selected_expr = None
        self.double_click_triggered = False

    def view_click(self, viewer, point):
        widget_type = ida_kernwin.get_widget_type(viewer)
        # Make sure the widget_type is of the Structures viewer
        if widget_type != 28:
            return
        if self.double_click_triggered:
            self.double_click_triggered = False
            return
        self.selected_expr = ui_utils.get_wrapped_word_from_viewer(viewer)

    def view_dblclick(self, viewer, point):
        widget_type = ida_kernwin.get_widget_type(viewer)
        # Make sure the widget_type is of the Structures viewer
        if widget_type != 28:
            return
        self.double_click_triggered = True
        if not self.selected_expr:
            return
        expr = self.selected_expr
        e = ida_moves.lochist_entry_t()
        if not ida_kernwin.get_custom_viewer_location(e, viewer):
            return
        place = e.place()
        if not place:
            return
        struct_place = place.as_structplace_t(place)

        if "::" in expr and " " not in expr:
            # Case click on struct type such as "OSObject::field"
            sid = ida_struct.get_struc_id(expr)
            if sid == ida_idaapi.BADADDR:
                return
            sidx = ida_struct.get_struc_idx(sid)
            if sid == ida_idaapi.BADADDR:
                return
            struct_place.idx = sidx
            struct_place.offset = 0
            e.set_place(struct_place)
            ida_kernwin.custom_viewer_jump(viewer, e)
            self.selected_expr = None
        else:
            sid = ida_struct.get_struc_by_idx(struct_place.idx)
            # Checking for a case click on vmethod
            if sid == ida_idaapi.BADADDR:
                return
            struct_name = ida_struct.get_struc_name(sid)
            if not struct_name.endswith("::vmethods"):
                return
            sptr = ida_struct.get_struc(sid)
            if not sptr:
                return
            member = ida_struct.get_member(sptr, struct_place.offset)
            name = ida_struct.get_member_name(member.id)
            if not name:
                return
            if name == expr:
                # clicked on method_x inside Y::vmethods
                class_name = "::".join(struct_name.split("::")[:-1])
                vmethod_offset_in_obj = logic.find_own_vmethods_offset_in_vtable(class_name) + struct_place.offset
                jump_to_virtual_func(class_name, vmethod_offset_in_obj)


def open_smart_xrefs():
    ea = ida_kernwin.get_screen_ea()
    vmethod_member_id = logic.get_member_id_for_vfunc(ea)
    if vmethod_member_id:
        ida_kernwin.open_xrefs_window(vmethod_member_id)

```

`ida_kcpp/ui_utils.py`:

```py
import ida_kernwin
import ida_lines
import idc


class Choose(ida_kernwin.Choose):
    # Fix Choose.UI_Hooks_Trampoline to work with modal dialogs
    class UI_Hooks_Trampoline(ida_kernwin.Choose.UI_Hooks_Trampoline):
        def populating_widget_popup(self, form, popup_handle):
            chooser = self.v()
            if hasattr(chooser, "OnPopup") and callable(getattr(chooser, "OnPopup")):
                chooser.OnPopup(form, popup_handle)

    class chooser_handler_t(ida_kernwin.action_handler_t):
        def __init__(self, handler):
            super().__init__()
            self.handler = handler

        def activate(self, ctx):
            self.handler()
            return 1

        def update(self, ctx):
            return (
                ida_kernwin.AST_ENABLE_FOR_WIDGET
                if ida_kernwin.is_chooser_widget(ctx.widget_type)
                else ida_kernwin.AST_DISABLE_FOR_WIDGET
            )

    def __init__(self, title, items, columns):
        super().__init__(title, columns, flags=self.CH_RESTORE)

        self.items = items

    def OnGetSize(self):
        return len(self.items)

    def OnGetLine(self, n):
        return self.items[n]

    def show(self):
        selected = self.Show(modal=True)
        if selected < 0:
            return None
        return self.items[selected]


class MenuBase(ida_kernwin.action_handler_t):
    label = None
    shortcut = None
    tooltip = None
    icon = -1
    COUNTER = 0

    def __init__(self, plugin, callback, label):
        super().__init__()
        self.plugin = plugin
        self.label = label
        self.activate_callback = callback
        self.name = self.plugin.wanted_name + ":" + self.__class__.__name__ + str(self.COUNTER)
        MenuBase.COUNTER += 1
        self.register()

    def register(self):
        return ida_kernwin.register_action(
            ida_kernwin.action_desc_t(
                self.name,  # Name. Acts as an ID. Must be unique.
                self.label,  # Label. That's what users see.
                self,  # Handler. Called when activated, and for updating
                self.shortcut,  # shortcut,
                self.tooltip,  # tooltip
                self.icon,  # icon
            )
        )

    def unregister(self):
        """Unregister the action.
        After unregistering the class cannot be used.
        """
        ida_kernwin.unregister_action(self.__name__)

    def activate(self, ctx):
        self.activate_callback()
        return 1

    def update(self, ctx):
        return ida_kernwin.AST_ENABLE_ALWAYS

    def path(self):
        return "Edit/Plugins/" + self.plugin.wanted_name + "/" + self.label

    def get_name(self):
        return self.name

    def attach_to_menu(self):
        ida_kernwin.attach_action_to_menu(self.path(), self.get_name(), ida_kernwin.SETMENU_APP)

    def detach_from_menu(self):
        ida_kernwin.detach_action_from_menu(self.path(), self.get_name())


def get_wrapped_word_from_viewer(viewer):
    line = ida_kernwin.get_custom_viewer_curline(viewer, False)
    line = ida_lines.tag_remove(line)
    place, x, y = ida_kernwin.get_custom_viewer_place(viewer, False)
    start = x
    while 0 < start < len(line) and line[start] not in (' ', '\t'):
        start -= 1
    end = x
    while 0 < end < len(line) and line[end] not in (' ', '\t'):
        end += 1
    return line[start + 1: end]


def update_wait_box(s):
    old_batch_mode = idc.batch(0)
    ida_kernwin.hide_wait_box()
    ida_kernwin.show_wait_box("HIDECANCEL\n" + s)
    idc.batch(old_batch_mode)

```

`ida_kcpp/utils.py`:

```py
import logging

import ida_bytes
import ida_funcs
import ida_hexrays
import ida_idaapi
import ida_nalt
import ida_name
import ida_struct
import ida_typeinf
import idaapi
import idc
from ida_kernelcache import symbol


def batch_mode(func):
    def wrapper(*args, **kwargs):
        old_batch = idc.batch(1)
        try:
            return func(*args, **kwargs)
        finally:
            idc.batch(old_batch)

    return wrapper


def generate_method_name(classname, methodname):
    # TODO: this is a temp solution to have templated classes names resolved well. Need a permanent one.
    new_class_part = symbol.global_name(classname).replace("__ZN", "").replace("__Z", "") 
    
    # the "_99" is a marker which IDA ignores and will let us identify self-generated mangled names
    return "__ZNK{}{}{}Ev_99".format(
        new_class_part, len(methodname), methodname
    )


def parse_mangled_method_name(mangled_name):
    demangled_name = idc.demangle_name(mangled_name, idc.get_inf_attr(idc.INF_LONG_DN))
    if not demangled_name:
        return None, None
    # Now strip arguments list such as in 'OSDictionary::setObject(OSSymbol const*, OSMetaClassBase const*)'
    strip_args = demangled_name.split("(")[0].split("::")
    method_name = strip_args[-1]
    if len(strip_args) < 2:
        return None, strip_args[0]
    class_name = "::".join(strip_args[:-1])
    if method_name[0] == '~' and method_name[1:] == class_name.split("<")[0]:
        method_name = "dtor"
    return class_name, method_name


# Functions below were copied from ida_medigate


def get_func_details(func_ea):
    tinfo = ida_typeinf.tinfo_t()
    ida_nalt.get_tinfo(tinfo, func_ea)
    if not tinfo.is_func():
        return None
    func_details = ida_typeinf.func_type_data_t()
    tinfo.get_func_details(func_details)
    return func_details


def update_func_details(func_ea, func_details):
    function_tinfo = ida_typeinf.tinfo_t()
    function_tinfo.create_func(func_details)
    if not ida_typeinf.apply_tinfo(func_ea, function_tinfo, ida_typeinf.TINFO_DEFINITE):
        return None
    return function_tinfo


def duplicate_details_with_this(method_details, this_type):
    new_method_details = ida_typeinf.func_type_data_t()
    new_method_details.retloc = method_details.retloc
    new_method_details.rettype = method_details.rettype
    new_method_details.stkargs = method_details.stkargs
    new_method_details.cc = method_details.cc
    if len(method_details) > 0:
        old_this_arg = method_details[0]
        new_arg = ida_typeinf.funcarg_t()
        new_arg.cmt = old_this_arg.cmt
        new_arg.name = old_this_arg.name
        new_arg.flags = old_this_arg.flags
        new_arg.argloc = old_this_arg.argloc
        new_arg.type = this_type
        new_method_details.push_back(new_arg)
        for i in range(1, method_details.size()):
            new_method_details.push_back(method_details[i])
    return new_method_details


def get_struc_from_tinfo(struct_tinfo):

    if not (struct_tinfo.is_struct() or struct_tinfo.is_union()):
        return None
    struct_id = ida_struct.get_struc_id(struct_tinfo.get_type_name())
    if struct_id == ida_idaapi.BADADDR:
        return None
    struct = ida_struct.get_struc(struct_id)
    return struct


def deref_tinfo(tinfo):
    pointed_obj = None
    if tinfo.is_ptr():
        pointed_obj = tinfo.get_pointed_object()
    return pointed_obj


def deref_struct_from_tinfo(tinfo):
    struct_tinfo = deref_tinfo(tinfo)
    if struct_tinfo is None:
        return None
    return get_struc_from_tinfo(struct_tinfo)


def extract_struct_from_tinfo(tinfo):
    struct = get_struc_from_tinfo(tinfo)
    if struct is None:
        struct = deref_struct_from_tinfo(tinfo)
    return struct


def decompile_and_update_this(func_ea, this_type=None):

    functype = None
    try:
        cfunc = ida_hexrays.decompile(func_ea)
        functype = cfunc.type
        func_details = ida_typeinf.func_type_data_t()
        functype.get_func_details(func_details)
        if func_details is None:
            return None
        if this_type:
            if len(func_details) > 0:
                func_details[0].name = "this"
                func_details[0].type = this_type
        functype = update_func_details(func_ea, func_details)
    except ida_hexrays.DecompilationFailure as e:
        logging.exception("Couldn't decompile 0x%x", func_ea)
    return functype


def get_sptr_by_name(struct_name):
    s_id = ida_struct.get_struc_id(struct_name)
    return ida_struct.get_struc(s_id)


def set_func_name(func_ea, func_name):
    counter = 0
    new_name = func_name
    while not ida_name.set_name(func_ea, new_name) and counter < 20:
        new_name = func_name + "_%d" % counter
        counter += 1
    return new_name


def get_member_substruct(member):
    member_type = get_member_tinfo(member)
    if member_type is not None and member_type.is_struct():
        current_struct_id = ida_struct.get_struc_id(member_type.get_type_name())
        return ida_struct.get_struc(current_struct_id)
    elif member.flag & ida_bytes.FF_STRUCT == ida_bytes.FF_STRUCT:
        return ida_struct.get_sptr(member)
    return None


def get_member_tinfo(member, member_typeinf=None):
    if member_typeinf is None:
        member_typeinf = ida_typeinf.tinfo_t()
    ida_struct.get_or_guess_member_tinfo(member_typeinf, member)
    return member_typeinf


def get_typeinf(typestr):
    tif = ida_typeinf.tinfo_t()
    tif.get_named_type(ida_typeinf.get_idati(), typestr)
    return tif


def get_typeinf_ptr(typeinf):
    old_typeinf = typeinf
    if isinstance(typeinf, str):
        typeinf = get_typeinf(typeinf)
    if typeinf is None:
        logging.warning("Couldn't find typeinf %s", old_typeinf or typeinf)
        return None
    tif = ida_typeinf.tinfo_t()
    tif.create_ptr(typeinf)
    return tif


def iterate_struct_members(sptr):
    offset = ida_struct.get_struc_first_offset(sptr)
    while offset != ida_idaapi.BADADDR and offset < ida_struct.get_struc_size(sptr):
        member = ida_struct.get_member(sptr, offset)
        yield member, offset
        offset = ida_struct.get_struc_next_offset(sptr, offset)


def is_func_start(ea):
    func = ida_funcs.get_func(ea)
    if func:
        return func.start_ea == ea
    return False


def add_struct_substruct_member(sptr, new_member_name, offset, substruct_id):
    flag = idaapi.FF_STRUCT
    mt = ida_nalt.opinfo_t()
    mt.tid = substruct_id
    member_size = ida_struct.get_struc_size(substruct_id)
    ida_struct.del_struc_members(sptr, offset, offset + member_size)
    return ida_struct.add_struc_member(sptr, new_member_name, offset, flag, mt, member_size)

```

`ida_kcpp_plugin.py`:

```py
import logging

import netnode

import ida_kernwin
import idaapi
from ida_kcpp import ui_utils


class KCPPPlugin(idaapi.plugin_t, idaapi.UI_Hooks):
    plugin_initialized = False
    flags = idaapi.PLUGIN_MOD | idaapi.PLUGIN_HIDE
    comment = "Add support for CPP navigating on top of ida_kernelcache"
    help = ""
    wanted_name = "Kernel Cache CPP"
    wanted_hotkey = ""

    def __init__(self):
        super().__init__()
        self.ui_hook = False
        self.activate_menu = None
        self.deactivate_menu = None
        self.kc_process_idb = None
        self.initial_sync_menu = None
        # Hook properties
        self.hexrays_hook = None
        self.virtual_synchronizer_hook = None
        self.structs_double_colon_hook = None
        # Hotkeys context
        self.vfunc_xref_hotkey = None
        self.is_activated = False

    def init(self):
        """plugin_t init() function"""
        # full name is something like "Apple XNU kernelcache for ARM64 (kernel + all kexts)"
        typename_markers = ("kernelcache", "arm64")
        typename = idaapi.get_file_type_name().lower()
        if any(word not in typename for word in typename_markers):
            logging.error(f"{self.wanted_name}: IDB deemed unsuitable (not an ARM64 kernelcache binary). Skipping...")
            return idaapi.PLUGIN_SKIP
        self.activated = False
        if not self.plugin_initialized:
            logging.info(f"{self.wanted_name}: IDB deemed suitable. Initializing...")
            global logic
            global ui

            # noinspection PyUnresolvedReferences
            from ida_kcpp import logic, ui
            self.init_menu_items()

            self.ui_hook = True
            self.hook()
            kcpp_netnode = netnode.Netnode("$ ida_kcpp.vfunc_to_vmethod")
            if len(kcpp_netnode.keys()) > 0 :
                self.activate_plugin()
                self.activated = True
            else:
                kcpp_netnode.kill()


        return idaapi.PLUGIN_KEEP

    def init_menu_items(self):
        self.kc_process_idb = ui_utils.MenuBase(self, self.process_kernelcache, "ida_kernelcache process kernel")
        self.activate_menu = ui_utils.MenuBase(self, self.activate_plugin, "Activate plugin")
        self.deactivate_menu = ui_utils.MenuBase(self, self.deactivate_plugin, "Deactivate plugin")
        self.initial_sync_menu = ui_utils.MenuBase(self, self.perform_initial_sync, "Perform initial sync")
        self.export_function_symbols_menu = ui_utils.MenuBase(self, self.export_function_symbols, "Export function symbols")
        self.import_function_symbols_menu = ui_utils.MenuBase(self, self.import_function_symbols, "Import function symbols")

    def run(self, arg=0):
        """plugin_t run() implementation"""
        return

    def term(self):
        """plugin_t term() implementation"""
        if self.ui_hook:
            self.unhook()
            self.ui_hook = False
        return

    def activate_hooks(self):
        if not self.hexrays_hook:
            self.hexrays_hook = ui.HexraysDoubleClickHook()
        self.hexrays_hook.hook()
        if not self.virtual_synchronizer_hook:
            self.virtual_synchronizer_hook = ui.VirtualFuncsSynchronizer()
        self.virtual_synchronizer_hook.hook()
        if not self.structs_double_colon_hook:
            self.structs_double_colon_hook = ui.StructsDoubleColonHooks()
        self.structs_double_colon_hook.hook()

    def deactivate_hooks(self):
        if self.hexrays_hook:
            self.hexrays_hook.unhook()
        if self.virtual_synchronizer_hook:
            self.virtual_synchronizer_hook.unhook()
        if self.structs_double_colon_hook:
            self.structs_double_colon_hook.unhook()

    def activate_plugin(self):
        logging.info("KernelCache CPP plugin was activated")
        self.activated = True
        logic.init_if_needed()
        self.activate_hooks()
        self.activate_menu.detach_from_menu()
        self.deactivate_menu.attach_to_menu()
        self.install_hotkeys()

    def deactivate_plugin(self):
        logging.info("KernelCache CPP plugin was deactivated")
        self.activated = False
        self.deactivate_hooks()
        self.deactivate_menu.detach_from_menu()
        self.activate_menu.attach_to_menu()
        self.uninstall_hotkeys()

    def install_hotkeys(self):
        self.vfunc_xref_hotkey = ida_kernwin.add_hotkey("CTRL+SHIFT+Y", ui.open_smart_xrefs)

    def uninstall_hotkeys(self):
        ida_kernwin.del_hotkey(self.vfunc_xref_hotkey)

    def perform_initial_sync(self):
        try:
            ida_kernwin.show_wait_box("Running initial sync...")
            logic.init_if_needed()
            logic.perform_initial_sync(ui_utils.update_wait_box)
        except Exception as e:
            logic.logger.exception("Exception in performinitial_sync")
        finally:
            ida_kernwin.hide_wait_box()

    def process_kernelcache(self):
        ida_kernwin.show_wait_box("ida_kernelcache is running...")
        try:
            logic.init_if_needed(only_collect=False)
        except Exception as e:
            logic.logger.exception("Exception in process_kernelcache")
        finally:
            ida_kernwin.hide_wait_box()

    def export_function_symbols(self):
        filepath = idaapi.ask_str("function_syms.json", 1, "Enter filename to save symbol list")
        ida_kernwin.show_wait_box("Exporting symbols...")
        try:
            logic.export_function_symbols(filepath)
        except Exception as e:
            logic.logger.exception("Exception in export_symbols")
        finally:
            ida_kernwin.hide_wait_box()

    def import_function_symbols(self):
        if not logic.initialized:
            ida_kernwin.warning('You must perform initial sync first')
            return
        
        filepath = idaapi.ask_file(False, '*', 'Choose symbol map')
        ida_kernwin.show_wait_box("Importing symbols...")
        try:
            self.deactivate_hooks()
            logic.import_function_symbols(filepath)
        except Exception as e:
            logic.logger.exception("Exception in import_symbols")
        finally:
            ida_kernwin.hide_wait_box()
            self.activate_hooks()

    def ready_to_run(self):
        """UI_Hooks function.
        Attaches actions to plugin in main menu.
        """
        self.kc_process_idb.attach_to_menu()
        self.initial_sync_menu.attach_to_menu()
        if self.activated:
            self.deactivate_menu.attach_to_menu()
        else:
            self.activate_menu.attach_to_menu()
        self.export_function_symbols_menu.attach_to_menu()
        self.import_function_symbols_menu.attach_to_menu()

        KCPPPlugin.plugin_initialized = True


def PLUGIN_ENTRY():
    return KCPPPlugin()

```