Project Path: arc_Xyrem_HyperDeceit_j7fopfqk

Source Tree:

```txt
arc_Xyrem_HyperDeceit_j7fopfqk
├── Common.hpp
├── HyperDeceit.cpp
├── HyperDeceit.vcxproj
├── HyperDeceit.vcxproj.filters
├── HyperDeceit.vcxproj.user
├── HyperV
│   ├── Emulator
│   │   ├── Emulator.cpp
│   │   └── Emulator.hpp
│   ├── HyperV.cpp
│   └── HyperV.hpp
├── Includes
│   └── HyperDeceit.hpp
├── LICENSE
├── Misc
│   ├── DynamicArray.hpp
│   └── HDE
│       ├── HDE64.cpp
│       ├── HDE64.hpp
│       └── Table64.hpp
├── README.md
└── Utils
    ├── Utils.cpp
    └── Utils.hpp

```

`Common.hpp`:

```hpp
/*
*		File name:
*			Common.hpp
*
*		Use:
*			Header files, macros, etc...
*
*		Author:
*			Xyrem ( https://reversing.info | Xyrem@reversing.info )
*/

#pragma once
#define _VERBOSE_ // Comment this line out to disable debug logging completely.
//#define _FILEVERBOSE_ // Uncomment this line to show file path, line number, and function name for debug logging.

#include <ntifs.h>
#include <ntddk.h>
#include <ntstrsafe.h>
#include <ntimage.h>
#include <intrin.h>

typedef unsigned long long uint64_t;
typedef unsigned int uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char uint8_t;
typedef long long int64_t;
typedef int int32_t;
typedef short int16_t;
typedef char int8_t;

// Basic macros and definitions.
#pragma region Definitions
// KEEP IN MIND THAT THIS HAS NO CHECK SO USE WITH CAUTION BEFORE BLINDLY PROVIDING SOME ADDRESS AS BASE!!
#define NTHEADER( Base ) PIMAGE_NT_HEADERS64( uint64_t( Base ) + PIMAGE_DOS_HEADER( Base )->e_lfanew )
#define _IMPORT_ extern "C" __declspec( dllimport )
#define GetBuildNumber( ) SharedUserData->NtBuildNumber
#define NFLAG(Var, Flag) ((Var & Flag) == 0)
#define PCODE(Code) (0xBAD00000 | Code)

#define WIN10_BN_1709 16299
#define WIN10_BN_1803 17134
#define WIN10_BN_1809 17763
#define WIN10_BN_1903 18362
#define WIN10_BN_1909 18363
#define WIN10_BN_20H1 19041
#define WIN10_BN_20H2 19042
#define WIN10_BN_21H1 19043
#define WIN10_BN_21H2 19044
#define WIN10_BN_22H2 19045
#define WIN11_BN_21H2 22000
#define WIN11_BN_22H2 22621
#pragma endregion

#pragma region PanicCodes
#define PANIC_BREAK 0 // Only use this if you don't want to bugcheck the system.
#define PANIC_UNSUPPORTED_WINDOWS_VERSION PCODE(1)
#define PANIC_KERNELBASE_NULL PCODE(2)
#define PANIC_UNSUPPORTED_STATEMENT PCODE(3)
#define PANIC_FAILED_TO_DISASSEMBLE PCODE(4)
#pragma endregion

#pragma region DebugLogging
#ifdef _VERBOSE_
#	ifdef _FILEVERBOSE_
#		define DBG( Fmt, ... )																							    \
			{																											    \
				DbgPrintEx( 0, 0, "[HyperDeceit:CORE <%s:%d %s>] "##Fmt, __FILE__, __LINE__, __FUNCTION__, __VA_ARGS__ );	\
			}
#	else
#		define DBG( Fmt, ... )												    \
			{																    \
				DbgPrintEx( 0, 0, "[HyperDeceit:CORE] "##Fmt, __VA_ARGS__ );	\
			}
#	endif

#define PANIC( BugcheckCode, Fmt, ... )												            \
	{                                                                                           \
		DbgPrintEx( 0, 0, "\n[HyperDeceit:PANIC] !!! "##Fmt##" !!!\n", __VA_ARGS__ );           \
		BugcheckCode ? KeBugCheck( BugcheckCode ) : __debugbreak( );	            \
	}
#else
#	define DBG( ... )
#	define PANIC( BugcheckCode, ... ) BugcheckCode ? KeBugCheck( BugcheckCode ) : __debugbreak( );
#endif
#pragma endregion

#pragma region Imports
_IMPORT_ uint64_t RtlFindExportedRoutineByName( uint64_t, const char* );
_IMPORT_ uint64_t RtlPcToFileHeader( uint64_t, uint64_t* );
#pragma endregion

#pragma region Structures
struct UNWIND_INFO_HDR
{
    uint8_t Flags;
    uint8_t PrologueSize;
    uint8_t NumOfUnwindCodes;
    uint8_t FrRegOff;
};

struct RUNTIME_FUNCTION
{
    uint32_t FunctionStart;
    uint32_t FunctionEnd;
    uint32_t UnwindInfo;
};

// https://www.vergiliusproject.com/kernels/x64/Windows%2011/22H2%20(2022%20Update)/_HAL_INTEL_ENLIGHTENMENT_INFORMATION
struct HAL_INTEL_ENLIGHTENMENT_INFORMATION
{
    uint32_t Enlightenments;
    uint32_t HypervisorConnected;
    uint64_t EndOfInterrupt;
    uint64_t ApicWriteIcr;
    uint32_t Reserved0;
    uint32_t SpinCountMask;
    uint64_t LongSpinWait;
    uint64_t GetReferenceTime;
    uint64_t SetSystemSleepProperty;
    uint64_t EnterSleepState;
    uint64_t NotifyDebugDeviceAvailable;
    uint64_t MapDeviceInterrupt;
    uint64_t UnmapDeviceInterrupt;
    uint64_t RetargetDeviceInterrupt;
    uint64_t SetHpetConfig;
    uint64_t NotifyHpetEnabled;
    uint64_t QueryAssociatedProcessors;
    uint64_t ReadMultipleMsr;
    uint64_t WriteMultipleMsr;
    uint64_t ReadCpuid;
    uint64_t LpWritebackInvalidate;
    uint64_t GetMachineCheckContext;
    uint64_t SuspendPartition;
    uint64_t ResumePartition;
    uint64_t SetSystemMachineCheckProperty;
    uint64_t WheaErrorNotification;
    uint64_t GetProcessorIndexFromVpIndex;
    uint64_t SyntheticClusterIpi;
    uint64_t VpStartEnabled;
    uint64_t StartVirtualProcessor;
    uint64_t GetVpIndexFromApicId;
    uint64_t IumAccessPciDevice;
    uint64_t IumEfiRuntimeService;
    uint64_t SvmGetSystemCapabilities;
    uint64_t GetDeviceCapabilities;
    uint64_t SvmCreatePasidSpace;
    uint64_t SvmSetPasidAddressSpace;
    uint64_t SvmFlushPasid;
    uint64_t SvmAttachPasidSpace;
    uint64_t SvmDetachPasidSpace;
    uint64_t SvmEnablePasid;
    uint64_t SvmDisablePasid;
    uint64_t SvmAcknowledgePageRequest;
    uint64_t SvmCreatePrQueue;
    uint64_t SvmDeletePrQueue;
    uint64_t SvmClearPrqStalled;
    uint64_t SetDeviceAtsEnabled;
    uint64_t SetDeviceCapabilities;
    uint64_t HvDebuggerPowerHandler;
    uint64_t SetQpcBias;
    uint64_t GetQpcBias;
    uint64_t RegisterDeviceId;
    uint64_t UnregisterDeviceId;
    uint64_t AllocateDeviceDomain;
    uint64_t AttachDeviceDomain;
    uint64_t DetachDeviceDomain;
    uint64_t DeleteDeviceDomain;
    uint64_t MapDeviceLogicalRange;
    uint64_t UnmapDeviceLogicalRange;
    uint64_t MapDeviceSparsePages;
    uint64_t UnmapDeviceSparsePages;
    uint64_t GetDmaGuardEnabled;
    uint64_t UpdateMicrocode;
    uint64_t GetSintMessage;
    uint64_t SetRootFaultReportingReady;

    // Below are added from Win11 22H1!
    uint64_t ConfigureDeviceDomain;
    uint64_t UnblockDefaultDma;
    uint64_t FlushDeviceDomain;
    uint64_t FlushDeviceDomainVaList;

    // Below are added from Win11 22H2!
    uint64_t GetHybridPassthroughReservedRegions;
};
#pragma endregion
```

`HyperDeceit.cpp`:

```cpp
/*
*		File name:
*			HyperDeceit.cpp
*
*		Use:
*			Contains the actual logic for HyperDeceit.
*
*		Author:
*			Xyrem ( https://reversing.info | Xyrem@reversing.info )
*/

#include "Common.hpp"
#include "Misc/DynamicArray.hpp"
#include "HyperV/HyperV.hpp"
#include "HyperV/Emulator/Emulator.hpp"

namespace HyperDeceit
{
	struct UserCallback_t
	{
		HyperV::ECommand Cmd;
		void(*Callback)(uint64_t, uint64_t, uint64_t);
	};

	enum class EHvDStatus
	{
		Unknown,
		InvalidArguments,
		NotInitialized,
		FailedToFindEnlightenmentInformation,
		FailedToFindHalpHvSleepEnlightenedCpuManager,
		FailedToFindHvlEnlightenments,
		FailedToFindHvlInvokeHypercall,
		FailedToFindCallbacks,
		IncompatibleWindowsVersion,
		UnsupportedEnlightenment,
		Success
	};

	uint64_t gKernelBase;
	bool Unloading;
	DynamicArray<UserCallback_t> UserCallbacks;

	/*
	*	Actual hook responsible for emulating and calling any available user callbacks
	*	available for the specific command.
	*/
	uint64_t HvDHypercallHook( _In_ HyperV::ECommand Command, _In_opt_ uint64_t Input, _In_opt_ uint64_t Output )
	{
		uint64_t Status = 0;
		uint64_t OldCR3 = __readcr3();

		// Check if this hypercall is required to be emulated or not...
		if ((HyperV::OriginalHvlEnlightenments & HyperV::GetEnlightenmentFromCommand( Command )) == 0)
			HyperV::Emulator::EmulateOriginalHyperCall( Command, Input );
		else if (HyperV::HyperVRunning)
			Status = HyperV::OriginalHypercall( Command, Input, Output );

		// Walk all user callbacks responsible for the command and invoke the callback.
		for (uint32_t i = 0; i < UserCallbacks.Size(); i++)
		{
			// To avoid a race condition between unloading.
			if (Unloading) return Status;

			UserCallback_t Callback = UserCallbacks[ i ];
			if (!Callback.Callback)
				continue;

			if (Callback.Cmd != Command)
				continue;

			Callback.Callback( Input, Output, OldCR3 );
		}

		return Status;
	}

	/*
	*	Inserts callback to intercept a specific hypercall, and also sets up additional stuff,
	*	like englightenments, callbacks etc...
	*/
	EHvDStatus HvDInsertCallback( _In_ HyperV::ECommand Cmd, _In_ void(*Callback)(uint64_t Input, uint64_t Output, uint64_t OldCR3) )
	{
		if (!Callback)
			return EHvDStatus::InvalidArguments;

		if (!HyperV::EnlightenmentInformation)
			return EHvDStatus::NotInitialized;

		// Get enlightenment from command.
		HyperV::EEnlightenments Enlightenment = HyperV::GetEnlightenmentFromCommand( Cmd );
		if (Enlightenment == HyperV::EEnlightenments::Unknown)
			return EHvDStatus::UnsupportedEnlightenment;

		// Close your eyes and pretend this part of the code doesn't exist...
		if (!HyperV::HyperVRunning)
		{
			if (Enlightenment == HyperV::EEnlightenments::VirtualizedSleepState && (!HyperV::EnlightenmentInformation->EnterSleepState || !HyperV::EnlightenmentInformation->NotifyDebugDeviceAvailable))
			{
				// Search for the Hyper-V callbacks from HvlGetEnlightenmentInfo.
				uint64_t Addr = Utils::FindPattern( gKernelBase, "\x48\x8D\x05\xCC\xCC\xCC\xCC\x48\x89\x43\x38\x48\x8D\x05" );
				if (!Addr)
					return EHvDStatus::FailedToFindCallbacks;

				// By default these callbacks are null, and the initializer has been discarded.
				// So we should initialize them ourselves.
				HyperV::EnlightenmentInformation->EnterSleepState = Addr + *(int*)(Addr + 3) + 7; // HalpHvEnterSleepState
				Addr += 11;
				HyperV::EnlightenmentInformation->NotifyDebugDeviceAvailable = Addr + *(int*)(Addr + 3) + 7; // HvlNotifyDebugDeviceAvailable

				// Set HalpHvSleepEnlightenedCpuManager to true, so the callbacks above are invoked.
				*HyperV::HalpHvSleepEnlightenedCpuManager = true;
			}
		}

		if (Enlightenment == HyperV::EEnlightenments::NotifyLongSpinWait)
		{
			uint64_t Addr = Utils::FindPattern( gKernelBase, "\x85\x3D\xCC\xCC\xCC\xCC\x75\x1C\x8B\x05\xCC\xCC\xCC\xCC\xA8\x40" );
			if (!Addr)
				return EHvDStatus::FailedToFindCallbacks;

			Addr += *(int*)(Addr + 2) + 6;
			HyperV::OriginalHvlLongSpinCountMask = *(int*)Addr;
			HyperV::HvlLongSpinCountMask = (int*)Addr;
			*HyperV::HvlLongSpinCountMask = 1;
		}

		// Insert callback and add enlightenment.
		UserCallbacks.Insert( UserCallback_t{ Cmd, Callback } );
		*HyperV::HvlEnlightenments |= uint32_t( Enlightenment );

		return EHvDStatus::Success;
	}

	/*
	*	Initialize core components of HyperDeceit.
	*/
	EHvDStatus HvDInitialize( _In_ uint64_t KernelBase )
	{
		// You NEED to supply ntoskrnl.exe's base address as a parameter...
		if (!KernelBase)
			return EHvDStatus::InvalidArguments;

		// Unsupported windows version check..
		ULONG BuildNumber = GetBuildNumber();
		if (BuildNumber < WIN10_BN_1709 || BuildNumber > WIN11_BN_22H2)
			return EHvDStatus::IncompatibleWindowsVersion;

		gKernelBase = KernelBase;

		if (!HyperV::GetHvcallCodeVa( KernelBase ))
			return EHvDStatus::FailedToFindHvlInvokeHypercall;

		if (!HyperV::GetHvlEnlightenments( KernelBase ))
			return EHvDStatus::FailedToFindHvlEnlightenments;

		if (!HyperV::FindHvEnlightenmentInformation( KernelBase ))
			return EHvDStatus::FailedToFindEnlightenmentInformation;

		if (!HyperV::FindHalpHvSleepEnlightenedCpuManager( KernelBase ))
			return EHvDStatus::FailedToFindHalpHvSleepEnlightenedCpuManager;

		HyperV::Initialize();

		// Store the original stuff...
		HyperV::OriginalHypercall = decltype(HyperV::OriginalHypercall)(*HyperV::HvcallCodeVa);
		HyperV::OriginalHvlEnlightenments = *HyperV::HvlEnlightenments;
		HyperV::OriginalHalpHvSleepEnlightenedCpuManager = *HyperV::HalpHvSleepEnlightenedCpuManager;
		HyperV::OriginalEnlightenmentInformation = *HyperV::EnlightenmentInformation;

		// Swap the HvcallCodeVa pointer with our own hook. 
		*HyperV::HvcallCodeVa = HvDHypercallHook;
		Unloading = false;

		return EHvDStatus::Success;
	}

	/*
	*	Stop and restore everything...
	*/
	EHvDStatus HvDStop()
	{
		// Hyperdeceit isn't initialized...
		if (!HyperV::HalpHvSleepEnlightenedCpuManager)
			return EHvDStatus::NotInitialized;

		// Botch fix for now....
		Unloading = true;

		// Restore hv callbacks and disable indicator for virtualized cpu manager if
		// Hyper-V is not running.
		if (!HyperV::HyperVRunning)
		{
			*HyperV::HalpHvSleepEnlightenedCpuManager = HyperV::OriginalHalpHvSleepEnlightenedCpuManager;
			*HyperV::EnlightenmentInformation = HyperV::OriginalEnlightenmentInformation;
		}

		// Restore SpinCountMask.
		if (HyperV::HvlLongSpinCountMask)
			*HyperV::HvlLongSpinCountMask = HyperV::OriginalHvlLongSpinCountMask;

		// Restore enlightenments and hypercall.
		*HyperV::HvlEnlightenments = HyperV::OriginalHvlEnlightenments;
		*HyperV::HvcallCodeVa = HyperV::OriginalHypercall;

		// Free all user callbacks.
		// Also I think this will hit the fan at one point due to a race condition in the hook and unloading process.. Added a botch fix for now tho..
		UserCallbacks.Destroy();

		// Restore HyperV stuff.
		HyperV::Stop();

		return EHvDStatus::Success;
	}

	/*
	*	Returns a string of the status code.
	*/
	const char* HvDGetStatusString( EHvDStatus Status )
	{
		// Could be written so much better but meh....

#define CASETOSTR(x) case x: return #x
		switch (Status)
		{
			CASETOSTR( EHvDStatus::Unknown );
			CASETOSTR( EHvDStatus::InvalidArguments );
			CASETOSTR( EHvDStatus::NotInitialized );
			CASETOSTR( EHvDStatus::FailedToFindEnlightenmentInformation );
			CASETOSTR( EHvDStatus::FailedToFindHalpHvSleepEnlightenedCpuManager );
			CASETOSTR( EHvDStatus::FailedToFindHvlEnlightenments );
			CASETOSTR( EHvDStatus::FailedToFindHvlInvokeHypercall );
			CASETOSTR( EHvDStatus::FailedToFindCallbacks );
			CASETOSTR( EHvDStatus::IncompatibleWindowsVersion );
			CASETOSTR( EHvDStatus::UnsupportedEnlightenment );
			CASETOSTR( EHvDStatus::Success );
		}
#undef CASETOSTR

		// Well clearly you had either of the 2 things occur,
		// One: You inputted some gibberish status to this function.
		// Two: Some new status codes were added but this function didn't handle them lol.
		PANIC( PANIC_UNSUPPORTED_STATEMENT, "Non-implemented status <%d>", Status );
	}
}

```

`HyperDeceit.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Common.hpp" />
    <ClInclude Include="HyperV\Emulator\Emulator.hpp" />
    <ClInclude Include="HyperV\HyperV.hpp" />
    <None Include="Includes\HyperDeceit.hpp">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <ClInclude Include="Misc\DynamicArray.hpp" />
    <ClInclude Include="Misc\HDE\HDE64.hpp" />
    <ClInclude Include="Misc\HDE\Table64.hpp" />
    <ClInclude Include="Utils\Utils.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HyperDeceit.cpp" />
    <ClCompile Include="HyperV\Emulator\Emulator.cpp" />
    <ClCompile Include="HyperV\HyperV.cpp" />
    <ClCompile Include="Misc\HDE\HDE64.cpp" />
    <ClCompile Include="Utils\Utils.cpp" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{CB418176-5A7A-432B-B2CC-879041D0C4A4}</ProjectGuid>
    <TemplateGuid>{0a049372-4c4d-4ea0-a64e-dc6ad88ceca1}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>HyperDeceit</RootNamespace>
    <DriverType>KMDF</DriverType>
    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
    <ALLOW_DATE_TIME>1</ALLOW_DATE_TIME>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)Builds\</OutDir>
    <IntDir>$(SolutionDir)Build Objects\$(ProjectName)\</IntDir>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <PreprocessorDefinitions>WINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP;WINAPI_PARTITION_DESKTOP=1;WINAPI_PARTITION_SYSTEM=1;WINAPI_PARTITION_APP=1;WINAPI_PARTITION_PC_APP=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`HyperDeceit.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClInclude Include="Misc\DynamicArray.hpp" />
    <ClInclude Include="Utils\Utils.hpp" />
    <ClInclude Include="Common.hpp" />
    <ClInclude Include="HyperV\HyperV.hpp" />
    <ClInclude Include="HyperV\Emulator\Emulator.hpp" />
    <ClInclude Include="Misc\HDE\HDE64.hpp" />
    <ClInclude Include="Misc\HDE\Table64.hpp" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="HyperV\Emulator\Emulator.cpp" />
    <ClCompile Include="Utils\Utils.cpp" />
    <ClCompile Include="Misc\HDE\HDE64.cpp" />
    <ClCompile Include="HyperV\HyperV.cpp" />
    <ClCompile Include="HyperDeceit.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Includes\HyperDeceit.hpp" />
  </ItemGroup>
</Project>
```

`HyperDeceit.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <SignMode>Off</SignMode>
  </PropertyGroup>
</Project>
```

`HyperV/Emulator/Emulator.cpp`:

```cpp
/*
*		File name:
*			Emulator.cpp
*
*		Use:
*			For emulating original hypercalls.
*
*		Author:
*			Xyrem ( https://reversing.info | Xyrem@reversing.info )
*/

#include "Emulator.hpp"

// Maybe fix + refactor this later.. Though submit a PR if you want to do this lol :)

namespace HyperDeceit::HyperV::Emulator
{
	/*
	*	Flushes the cache responsible for the current core.
	*/
	void FlushTB( )
	{
		uint64_t CR4 = __readcr4( );

		// CR4.PGE + CR4.PCIDE
		if ( CR4 & ((1 << 7) | (1 << 17)) )
		{
			// Toggle CR4.PGE
			__writecr4( CR4 ^ (1 << 7) );
			__writecr4( CR4 );
			return;
		}

		__writecr3( __readcr3( ) );
	}

	/*
	*	Flushes the cache for all cores by doing an IPI.
	*/
	void FlushTBAllCores( )
	{
		KeIpiGenericCall( PKIPI_BROADCAST_WORKER( &FlushTB ), 0 );
	}

	/*
	*	Switch to new address space and flush cache for the current core.
	*/
	void SwitchAddressSpace( _In_ uint64_t NewCR3 )
	{
		if ( HyperVRunning && (OriginalHvlEnlightenments & EEnlightenments::VirtualizedAddressSwitch))
		{
			HyperV::OriginalHypercall( ECommand::SwitchAddressSpace, NewCR3, 0 );
			return;
		}

		__writecr3( NewCR3 );
		FlushTB( );
	}

	/*
	*	Pretty much useless in this use case, but still added because why not...
	*/
	void NotifySpinWait( )
	{
		_mm_pause( );
	}

	/*
	*	Emulates the command if it can emulate the command.
	*/
	void EmulateOriginalHyperCall( _In_ ECommand Cmd, _In_ uint64_t Input )
	{
		switch ( Cmd )
		{
			case ECommand::SlowFlushAddressSpace: return FlushTBAllCores( );
			case ECommand::FastFlushAddressSpace: return FlushTB( );
			case ECommand::SwitchAddressSpace: return SwitchAddressSpace( Input );
			case ECommand::LongSpinWait: return NotifySpinWait( );
		}
	}
}
```

`HyperV/Emulator/Emulator.hpp`:

```hpp
/*
*		File name:
*			Emulator.hpp
*
*		Use:
*			For emulating original hypercalls.
*
*		Author:
*			Xyrem ( https://reversing.info | Xyrem@reversing.info )
*/

#pragma once
#include "..\..\Common.hpp"
#include "..\HyperV.hpp"

namespace HyperDeceit::HyperV::Emulator
{
	void FlushTB( );
	void FlushTBAllCores( );
	void SwitchAddressSpace( _In_ uint64_t NewCR3 );
	void NotifySpinWait( );

	void EmulateOriginalHyperCall( _In_ ECommand Cmd, _In_ uint64_t Input );
}
```

`HyperV/HyperV.cpp`:

```cpp
/*
*		File name:
*			HyperV.cpp
*
*		Use:
*			To setup HyperV related stuff.
*
*		Author:
*			Xyrem ( https://reversing.info | Xyrem@reversing.info )
*/

#include "HyperV.hpp"

namespace HyperDeceit::HyperV
{
	HvDCallTemplate OriginalHypercall;
	bool HyperVRunning;
	void* CachedHypercallPages;

	// Why are we still here? Just to suffer?
	void** HvcallCodeVa;
	uint32_t* HvlEnlightenments; uint32_t OriginalHvlEnlightenments;
	bool* HalpHvSleepEnlightenedCpuManager; bool OriginalHalpHvSleepEnlightenedCpuManager;
	int* HvlLongSpinCountMask; int OriginalHvlLongSpinCountMask;
	HAL_INTEL_ENLIGHTENMENT_INFORMATION* EnlightenmentInformation; HAL_INTEL_ENLIGHTENMENT_INFORMATION OriginalEnlightenmentInformation;

	/*
	*	Returns the enlightenment responsible for the command.
	*/
	EEnlightenments GetEnlightenmentFromCommand( ECommand Cmd )
	{
		switch (Cmd)
		{
			case ECommand::SlowFlushAddressSpace: return EEnlightenments::VirtualizedRemoteFlush;
			case ECommand::FastFlushAddressSpace: return EEnlightenments::VirtualizedLocalFlush;

			case ECommand::EnterSleepState:
			case ECommand::DebugDeviceAvailable:
				return EEnlightenments::VirtualizedSleepState;

			case ECommand::SwitchAddressSpace: return EEnlightenments::VirtualizedAddressSwitch;
			case ECommand::LongSpinWait: return EEnlightenments::NotifyLongSpinWait;
		}

		return EEnlightenments::Unknown;
	}

	/*
	*	Gets the KPRCB offset for "HypercallCachedPages".
	*	Currently only supports Windows 10 1709 - Windows 11 22H2
	*/
	uint32_t GetHypercallCachedPagesOffset()
	{
		ULONG BuildNumber = GetBuildNumber();
		if (BuildNumber >= WIN10_BN_1709 && BuildNumber <= WIN10_BN_1903)
			return 0x6080;
		else if (BuildNumber >= WIN10_BN_1909 && BuildNumber <= WIN10_BN_22H2)
			return 0x8380;
		else if (BuildNumber >= WIN11_BN_21H2 && BuildNumber <= WIN11_BN_22H2)
			return 0x8700;

		// Should never occur, as there is a check for this in the entry point...
		PANIC( PANIC_UNSUPPORTED_WINDOWS_VERSION, "Unsupported Version" );
	}

	/*
	*	IPI callback for setting the HypercallCachedPages pointer in the KPRCB.
	*/
	ULONG_PTR SetHypercallCachedPagesIPICallback( _In_ ULONG_PTR CachedPagePtr )
	{
		uint64_t* HypercallCachedPages = (uint64_t*)(uint64_t( KeGetPcr()->CurrentPrcb ) + GetHypercallCachedPagesOffset());
		*HypercallCachedPages = CachedPagePtr;
		return 0;
	}

	/*
	*	Resets and frees CachedHypercallPages if HyperV is not running.
	*/
	void Stop()
	{
		// If HyperV is running, DO NOT OVERWRITE.
		if (HyperVRunning)
			return;

		// Reset it back to 0.
		KeIpiGenericCall( SetHypercallCachedPagesIPICallback, 0 );
		MmFreeContiguousMemory( CachedHypercallPages );
	}

	/*
	*	Setup CachedHypercallPages if HyperV is not running.
	*/
	bool Initialize()
	{
		// Simply check if HyperV is running by checking the HV vendor.
		int Regs[ 4 ]{};
		__cpuid( Regs, 0x40000001 );
		HyperVRunning = Regs[ 0 ] == '1#vH';

		// Check if HyperV is NOT running.
		if (!HyperVRunning)
		{
			// When Hyper-V is off, HypercallCachedPages is null, and this is
			// accessed in multiple places and will cause a page fault if not initialized.
			CachedHypercallPages = MmAllocateContiguousMemory( 0x6000, PHYSICAL_ADDRESS{ .QuadPart = -1 } );
			if (!CachedHypercallPages)
				return false;

			// Zero out the newly allocated memory.
			memset( CachedHypercallPages, 0, 0x6000 );

			int64_t HypercallCachedPagesPhys = MmGetPhysicalAddress( CachedHypercallPages ).QuadPart;

			for (int i = 0; i < 2; i++)
				*(int64_t*)(uint64_t( CachedHypercallPages ) + 16 + i * 0x1000LL) = HypercallCachedPagesPhys + i * 0x1000LL;

			// Do an IPI on all cores to set HypercallCachedPages for every core’s processor block.
			KeIpiGenericCall( SetHypercallCachedPagesIPICallback, ULONG_PTR( CachedHypercallPages ) );
		}

		return true;
	}

	/*
	*	Gets the pointer to HalpHvSleepEnlightenedCpuManager bool from ntoskrnl.
	*	Required for certain callbacks.
	*/
	bool* FindHalpHvSleepEnlightenedCpuManager( _In_ uint64_t KernelBase )
	{
		if (!KernelBase)
			PANIC( PANIC_KERNELBASE_NULL, "Kernel base was null" );

		uint64_t Addr = Utils::FindPattern( KernelBase, "\x40\x38\x3D\xCC\xCC\xCC\xCC\x74\xCC\xB9\x05" );
		if (!Addr)
			return 0;

		// Resolves the relative reference to HalpHvSleepEnlightenedCpuManager.
		HalpHvSleepEnlightenedCpuManager = (bool*)(*(int*)(Addr + 3) + Addr + 7);
		return HalpHvSleepEnlightenedCpuManager;
	}

	/*
	*	Gets the pointer to the HAL_INTEL_ENLIGHTENMENT_INFORMATION stored in ntoskrnl.
	*	Required for certain callbacks.
	*/
	HAL_INTEL_ENLIGHTENMENT_INFORMATION* FindHvEnlightenmentInformation( _In_ uint64_t KernelBase )
	{
		if (!KernelBase)
			PANIC( PANIC_KERNELBASE_NULL, "Kernel base was null" );

		uint64_t Addr = Utils::FindPattern( KernelBase, "\x89\x05\xCC\xCC\xCC\xCC\xE8\xCC\xCC\xCC\xCC\xF6\xC3\x01\x74" );
		if (!Addr)
			return 0;

		// Resolves the relative reference to HvEnlightenmentInformation.
		EnlightenmentInformation = (HAL_INTEL_ENLIGHTENMENT_INFORMATION*)(*(int*)(Addr + 2) + Addr + 6);
		return EnlightenmentInformation;
	}

	/*
	*	Gets the HvcallCodeVa pointer in ntoskrnl.
	*	Required for the hypercall hook.
	*	NOTE: Alternatively I could have pattern scanned, but this is future proofed lol..
	*/
	void** GetHvcallCodeVa( _In_ uint64_t KernelBase )
	{
		if (!KernelBase)
			PANIC( PANIC_KERNELBASE_NULL, "Kernel base was null" );

		// Let the windows kernel find the exported routine HvlInvokeHypercall/HvcallInitiateHypercall.
		uint64_t HvlInvokeHypercall = RtlFindExportedRoutineByName( KernelBase, "HvlInvokeHypercall" );

		// Not found???
		if (!HvlInvokeHypercall)
		{
			DBG( "HvlInvokeHypercall not found" );
			return 0;
		}

		// Get function information from SEH data.
		RUNTIME_FUNCTION RuntimeData{};
		UNWIND_INFO_HDR UnwindInfo{};
		if (!Utils::GetFunctionInformation( HvlInvokeHypercall, &RuntimeData, &UnwindInfo ))
		{
			// Should literally never occur, but still handle it just in case....
			DBG( "Failed to find HvlInvokeHypercall SEH information" );
			return 0;
		}

		// Skip prologue.
		uint64_t PC = HvlInvokeHypercall + UnwindInfo.PrologueSize;

		// Walk till the end of the function is reached.
		while (PC < (HvlInvokeHypercall + RuntimeData.FunctionEnd))
		{
			hde64s HDE;
			hde64_disasm( (void*)PC, &HDE );

			// Failed to disassemble???
			if (HDE.flags & F_ERROR)
				PANIC( PANIC_FAILED_TO_DISASSEMBLE, "Failed to disassemble 0x%p", PC );

			// 48 8B 05 ?? ?? ?? ??		mov rax, cs:HvcallCodeVa
			uint32_t Opcode = *(uint32_t*)PC & 0xFFFFFF;
			if (Opcode == 0x058B48)
			{
				// Resolve HvcallCodeVa.
				void** Reference = (void**)(*(int*)(PC + 3) + PC + 7);

				// If Hyper-V is not running, HvcallCodeVa always points to HvcallpNoHypervisorPresent.
				// But if it is running, it will point to a page which is just a vmcall + ret with the rest of the page nop'd out.
				if (!MmIsAddressValid( *Reference ))
					continue;

				HvcallCodeVa = Reference;
				return Reference;
			}

			// Increment instruction pointer.
			PC += HDE.len;
		}

		return 0;
	}

	/*
	*	Gets the HvlEnlightenments pointer from ntoskrnl,
	*	Required to setup the enlightenments by HyperV / to trick windows.
	*/
	uint32_t* GetHvlEnlightenments( _In_ uint64_t KernelBase )
	{
		if (!KernelBase)
			PANIC( PANIC_KERNELBASE_NULL, "Kernel base was null" );

		uint64_t Addr = Utils::FindPattern( KernelBase, "\xF7\x05\xCC\xCC\xCC\xCC\x01\x00\x00\x00\x74\xCC\xE8" );
		if (!Addr)
			return 0;

		// Resolves the relative reference to HvlEnlightenments.
		HvlEnlightenments = (uint32_t*)(*(int*)(Addr + 2) + Addr + 10);
		return HvlEnlightenments;
	}
}
```

`HyperV/HyperV.hpp`:

```hpp
/*
*		File name:
*			HyperV.hpp
*
*		Use:
*			To setup HyperV related stuff.
*
*		Author:
*			Xyrem ( https://reversing.info | Xyrem@reversing.info )
*/

#pragma once
#include "..\Common.hpp"
#include "..\Utils\Utils.hpp"
#include "..\Misc\HDE\HDE64.hpp"

namespace HyperDeceit::HyperV
{
	enum EEnlightenments : uint32_t
	{
		Unknown = 0x1BADD00D,
		VirtualizedAddressSwitch = 1,
		VirtualizedLocalFlush = 2,
		VirtualizedRemoteFlush = 4,
		NotifyLongSpinWait = 0x40,
		VirtualizedSleepState = 0x10000,
		Max = 0xFFFFFFFF
	};

	enum ECommand : uint64_t
	{
		SlowFlushAddressSpace = 2,
		FastFlushAddressSpace = 0x10002,

		EnterSleepState = 0x84,
		DebugDeviceAvailable = 0x87,
		
		SwitchAddressSpace = 0x10001,

		LongSpinWait = 0x10008
	};


	typedef uint64_t( *HvDCallTemplate )(_In_ HyperV::ECommand Command, _In_ uint64_t Arg1, _In_ uint64_t Arg2);
	
	extern HvDCallTemplate OriginalHypercall;
	extern bool HyperVRunning;


	extern void** HvcallCodeVa; extern void* OriginalHvcallCodeVa;
	extern uint32_t* HvlEnlightenments; extern uint32_t OriginalHvlEnlightenments;
	extern bool* HalpHvSleepEnlightenedCpuManager; extern bool OriginalHalpHvSleepEnlightenedCpuManager;
	extern HAL_INTEL_ENLIGHTENMENT_INFORMATION* EnlightenmentInformation; extern HAL_INTEL_ENLIGHTENMENT_INFORMATION OriginalEnlightenmentInformation;
	extern int* HvlLongSpinCountMask; extern int OriginalHvlLongSpinCountMask;


	bool Initialize( );
	void Stop( );

	EEnlightenments GetEnlightenmentFromCommand( ECommand Cmd );

	void** GetHvcallCodeVa( _In_ uint64_t KernelBase );
	uint32_t* GetHvlEnlightenments( _In_ uint64_t KernelBase );
	HAL_INTEL_ENLIGHTENMENT_INFORMATION* FindHvEnlightenmentInformation( _In_ uint64_t KernelBase );
	bool* FindHalpHvSleepEnlightenedCpuManager( _In_ uint64_t KernelBase );
}
```

`Includes/HyperDeceit.hpp`:

```hpp
/*
*		File name:
*			HyperDeceit.hpp
*
*		Use:
*			Header file to provide an interface with HyperDeceit on a subproject.
*
*		Author:
*			Xyrem ( https://reversing.info | Xyrem@reversing.info )
*/

#pragma once
typedef unsigned long long uint64_t;
typedef unsigned int uint32_t;
typedef unsigned short uint16_t;
typedef unsigned char uint8_t;

#ifndef _In_
#define _In_
#endif

namespace HyperDeceit
{
	namespace HyperV
	{
		enum class ECommand : uint64_t
		{
			SlowFlushAddressSpace = 2,
			FastFlushAddressSpace = 0x10002,

			EnterSleepState = 0x84,
			DebugDeviceAvailable = 0x87,

			SwitchAddressSpace = 0x10001,

			LongSpinWait = 0x10008
		};

		namespace Emulator
		{
			void FlushTB();
			void FlushTBAllCores();
			void SwitchAddressSpace( _In_ uint64_t NewCR3 );
			void NotifySpinWait();

			void EmulateOriginalHyperCall( _In_ ECommand Cmd, _In_ uint64_t Input );
		}
	}

	enum class EHvDStatus
	{
		Unknown,
		InvalidArguments,
		NotInitialized,
		FailedToFindEnlightenmentInformation,
		FailedToFindHalpHvSleepEnlightenedCpuManager,
		FailedToFindHvlEnlightenments,
		FailedToFindHvlInvokeHypercall,
		FailedToFindCallbacks,
		IncompatibleWindowsVersion,
		UnsupportedEnlightenment,
		Success
	};

	EHvDStatus HvDInitialize( _In_ uint64_t KernelBase );
	EHvDStatus HvDInsertCallback( _In_ HyperV::ECommand Cmd, _In_ void(*Callback)(uint64_t Input, uint64_t Output, uint64_t OldCR3) );
	EHvDStatus HvDStop();

	const char* HvDGetStatusString( EHvDStatus Status );
}

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Aryan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Misc/DynamicArray.hpp`:

```hpp
/*
*		File name:
*			DynamicArray.hpp
*
*		Use:
*			Minimalistic dynamic array.
*
*		Author:
*			Xyrem ( https://reversing.info | Xyrem@reversing.info )
*/


#pragma once
#include "..\Common.hpp"

template<typename T>
class DynamicArray
{
private:
	T* Objects;
	uint32_t Count;
	uint32_t MaxCapacity;
	KSPIN_LOCK Spinlock;

	/*
	*	Initialize the array by allocating memory for the objects. 
	*/
	void Initialize( )
	{
		KIRQL Irql = EnterLock( );
		if ( !Objects )
		{
			// Simply accept 64 entries as a starting point.
			MaxCapacity = sizeof( T ) * 64;
			Objects = (T*)ExAllocatePool( POOL_TYPE::NonPagedPoolNx, MaxCapacity );

			// Should never happen, unless the system is out of resources, so just crash the system at that point.
			if ( !Objects )
				__fastfail( 'POOL' );

			// Erase all artifacts of previously allocated stuff.
			memset( Objects, 0, MaxCapacity );
		}
		ExitLock( Irql );
	}

public:

	/*
	*	Enter a spinlock for thread safety.
	*/
	KIRQL EnterLock( )
	{
		return KeAcquireSpinLockRaiseToDpc( &Spinlock );
	}

	/*
	*	Leave the spinlock.
	*/
	void ExitLock( _In_ KIRQL Irql )
	{
		KeReleaseSpinLock( &Spinlock, Irql );
	}

	/*
	*	Removes all entries.
	*/
	void Clear( )
	{
		KIRQL Irql = EnterLock( );
		if ( Objects && Count )
		{
			memset( Objects, 0, sizeof( T ) * Count );
			Count = 0;
		}
		ExitLock( Irql );
	}

	/*
	*	Remove all entries and free the allocation.
	*/
	void Destroy( )
	{
		if( !Objects )
			return;
		
		KIRQL Irql = EnterLock( );

		// Erase everything.
		memset( Objects, 0, Count * sizeof( T ) );
		
		// Free the allocation.
		ExFreePool( Objects );

		Count = 0;
		MaxCapacity = 0;
		Objects = 0;
		ExitLock( Irql );
	}

	/*
	*	Add an item to the array.
	*/
	void Insert( _In_ T Item )
	{
		// Has the array not been initialized yet?
		if ( !Objects )
			Initialize( );

		KIRQL Irql = EnterLock( );
		
		// Have we ran out of space for a new item? If so, allocate a pool x2 the size and copy over data.
		if ( sizeof(T) + Count * sizeof(T) > MaxCapacity )
		{
			MaxCapacity *= 2;
			T* NewArray = (T*)ExAllocatePool( POOL_TYPE::NonPagedPoolNx, MaxCapacity );

			// If this is null, the system is out of resources, there's nothing we can do now, so crash the system.
			if ( !NewArray )
				__fastfail( 'POOL' );

			// We can ignore the *existing* items as they will be overwritten anyway.
			memset( &NewArray[Count], 0, MaxCapacity - (sizeof(T) * Count));

			// Copy over the existing items to the new array.
			// Suppressing / disabling the warning for C6387 isnt working for some reason, so well we ignore this lol..
			memcpy( NewArray, Objects, Count * sizeof( T ) );

			// Free the original pool.
			ExFreePool( Objects );
			
			// Set the new array.
			Objects = NewArray;
		}

		// Insert the new item.
		Objects[ Count++ ] = Item;
		ExitLock( Irql );
	}

	/*
	*	Checks if the item is in the array.
	*/
	bool Contains( _In_ T Item )
	{
		// Has the array not been initialized yet? If so, initialize and return false as there
		// will not be any entries anyway.
		if ( !Objects )
		{
			Initialize( );
			return false;
		}

		KIRQL Irql = EnterLock( );
		// Loop through the array in search of the item.
		for (uint32_t i = 0; i < Count; i++ )
		{
			if ( Objects[ i ] == Item )
			{
				ExitLock( Irql );
				return true;
			}
		}

		// Not found
		ExitLock( Irql );
		return false;
	}

	/*
	*	Get the item in the array with the index provided,
	*	also do certain sanity checks.
	*/
	T operator[]( uint32_t i )
	{
		// Has the array not been initialized yet? If so, initialize and return nothing as there
		// will not be any entries anyway.
		if ( !Objects )
		{
			Initialize( );
			return {};
		}

		// Is the index specified more than the number of items? If so trigger a crash to analyze this bug..
		if ( i > Count )
			__fastfail( 0xBAD128 );

		// Return the item.
		return Objects[ i ];
	}

	/*
	*	Gets the number of items.
	*/
	uint32_t Size( )
	{
		return Count;
	}
};

```

`Misc/HDE/HDE64.cpp`:

```cpp
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#if defined( _M_X64 ) || defined( __x86_64__ )

#include "HDE64.hpp"
#include "Table64.hpp"

unsigned int hde64_disasm( const void* code, hde64s* hs )
{
	uint8_t x, c = 0, *p = (uint8_t*)code, cflags, opcode, pref = 0;
	uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
	uint8_t op64 = 0;

	__stosb( (PUCHAR)hs, 0, sizeof( hde64s ) );

	for ( x = 16; x; x-- )
		switch ( c = *p++ )
		{
			case 0xf3:
				hs->p_rep = c;
				pref |= PRE_F3;
				break;
			case 0xf2:
				hs->p_rep = c;
				pref |= PRE_F2;
				break;
			case 0xf0:
				hs->p_lock = c;
				pref |= PRE_LOCK;
				break;
			case 0x26:
			case 0x2e:
			case 0x36:
			case 0x3e:
			case 0x64:
			case 0x65:
				hs->p_seg = c;
				pref |= PRE_SEG;
				break;
			case 0x66:
				hs->p_66 = c;
				pref |= PRE_66;
				break;
			case 0x67:
				hs->p_67 = c;
				pref |= PRE_67;
				break;
			default:
				goto pref_done;
		}
pref_done:

	hs->flags = (uint32_t)pref << 23;

	if ( !pref )
		pref |= PRE_NONE;

	if ( ( c & 0xf0 ) == 0x40 )
	{
		hs->flags |= F_PREFIX_REX;
		hs->rex_w = ( c & 0xf ) >> 3;
		if ( hs->rex_w && ( *p & 0xf8 ) == 0xb8 )
			op64++;

		hs->rex_r = ( c & 7 ) >> 2;
		hs->rex_x = ( c & 3 ) >> 1;
		hs->rex_b = c & 1;
		if ( ( ( c = *p++ ) & 0xf0 ) == 0x40 )
		{
			opcode = c;
			goto error_opcode;
		}
	}

	if ( ( hs->opcode = c ) == 0x0f )
	{
		hs->opcode2 = c = *p++;
		ht += DELTA_OPCODES;
	}
	else if ( c >= 0xa0 && c <= 0xa3 )
	{
		op64++;
		if ( pref & PRE_67 )
			pref |= PRE_66;
		else
			pref &= ~PRE_66;
	}

	opcode = c;
	cflags = ht[ ht[ opcode / 4 ] + ( opcode % 4 ) ];

	if ( cflags == C_ERROR )
	{
	error_opcode:
		hs->flags |= F_ERROR | F_ERROR_OPCODE;
		cflags = 0;
		if ( ( opcode & -3 ) == 0x24 )
			cflags++;
	}

	x = 0;
	if ( cflags & C_GROUP )
	{
		uint16_t t;
		t = *(uint16_t*)( ht + ( cflags & 0x7f ) );
		cflags = (uint8_t)t;
		x = (uint8_t)( t >> 8 );
	}

	if ( hs->opcode2 )
	{
		ht = hde64_table + DELTA_PREFIXES;
		if ( ht[ ht[ opcode / 4 ] + ( opcode % 4 ) ] & pref )
			hs->flags |= F_ERROR | F_ERROR_OPCODE;
	}

	if ( cflags & C_MODRM )
	{
		hs->flags |= F_MODRM;
		hs->modrm = c = *p++;
		hs->modrm_mod = m_mod = c >> 6;
		hs->modrm_rm = m_rm = c & 7;
		hs->modrm_reg = m_reg = ( c & 0x3f ) >> 3;

		if ( x && ( ( x << m_reg ) & 0x80 ) )
			hs->flags |= F_ERROR | F_ERROR_OPCODE;

		if ( !hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf )
		{
			uint8_t t = opcode - 0xd9;
			if ( m_mod == 3 )
			{
				ht = hde64_table + DELTA_FPU_MODRM + t * 8;
				t = ht[ m_reg ] << m_rm;
			}
			else
			{
				ht = hde64_table + DELTA_FPU_REG;
				t = ht[ t ] << m_reg;
			}
			if ( t & 0x80 )
				hs->flags |= F_ERROR | F_ERROR_OPCODE;
		}

		if ( pref & PRE_LOCK )
		{
			if ( m_mod == 3 )
			{
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			}
			else
			{
				uint8_t *table_end, op = opcode;
				if ( hs->opcode2 )
				{
					ht = hde64_table + DELTA_OP2_LOCK_OK;
					table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
				}
				else
				{
					ht = hde64_table + DELTA_OP_LOCK_OK;
					table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
					op &= -2;
				}
				for ( ; ht != table_end; ht++ )
					if ( *ht++ == op )
					{
						if ( !( ( *ht << m_reg ) & 0x80 ) )
							goto no_lock_error;
						else
							break;
					}
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			no_lock_error:;
			}
		}

		if ( hs->opcode2 )
		{
			switch ( opcode )
			{
				case 0x20:
				case 0x22:
					m_mod = 3;
					if ( m_reg > 4 || m_reg == 1 )
						goto error_operand;
					else
						goto no_error_operand;
				case 0x21:
				case 0x23:
					m_mod = 3;
					if ( m_reg == 4 || m_reg == 5 )
						goto error_operand;
					else
						goto no_error_operand;
			}
		}
		else
		{
			switch ( opcode )
			{
				case 0x8c:
					if ( m_reg > 5 )
						goto error_operand;
					else
						goto no_error_operand;
				case 0x8e:
					if ( m_reg == 1 || m_reg > 5 )
						goto error_operand;
					else
						goto no_error_operand;
			}
		}

		if ( m_mod == 3 )
		{
			uint8_t* table_end;
			if ( hs->opcode2 )
			{
				ht = hde64_table + DELTA_OP2_ONLY_MEM;
				table_end = ht + sizeof( hde64_table ) - DELTA_OP2_ONLY_MEM;
			}
			else
			{
				ht = hde64_table + DELTA_OP_ONLY_MEM;
				table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
			}
			for ( ; ht != table_end; ht += 2 )
				if ( *ht++ == opcode )
				{
					if ( ( *ht++ & pref ) && !( ( *ht << m_reg ) & 0x80 ) )
						goto error_operand;
					else
						break;
				}
			goto no_error_operand;
		}
		else if ( hs->opcode2 )
		{
			switch ( opcode )
			{
				case 0x50:
				case 0xd7:
				case 0xf7:
					if ( pref & ( PRE_NONE | PRE_66 ) )
						goto error_operand;
					break;
				case 0xd6:
					if ( pref & ( PRE_F2 | PRE_F3 ) )
						goto error_operand;
					break;
				case 0xc5:
					goto error_operand;
			}
			goto no_error_operand;
		}
		else
			goto no_error_operand;

	error_operand:
		hs->flags |= F_ERROR | F_ERROR_OPERAND;
	no_error_operand:

		c = *p++;
		if ( m_reg <= 1 )
		{
			if ( opcode == 0xf6 )
				cflags |= C_IMM8;
			else if ( opcode == 0xf7 )
				cflags |= C_IMM_P66;
		}

		switch ( m_mod )
		{
			case 0:
				if ( pref & PRE_67 )
				{
					if ( m_rm == 6 )
						disp_size = 2;
				}
				else if ( m_rm == 5 )
					disp_size = 4;
				break;
			case 1:
				disp_size = 1;
				break;
			case 2:
				disp_size = 2;
				if ( !( pref & PRE_67 ) )
					disp_size <<= 1;
				break;
		}

		if ( m_mod != 3 && m_rm == 4 )
		{
			hs->flags |= F_SIB;
			p++;
			hs->sib = c;
			hs->sib_scale = c >> 6;
			hs->sib_index = ( c & 0x3f ) >> 3;
			if ( ( hs->sib_base = c & 7 ) == 5 && !( m_mod & 1 ) )
				disp_size = 4;
		}

		p--;
		switch ( disp_size )
		{
			case 1:
				hs->flags |= F_DISP8;
				hs->disp.disp8 = *p;
				break;
			case 2:
				hs->flags |= F_DISP16;
				hs->disp.disp16 = *(uint16_t*)p;
				break;
			case 4:
				hs->flags |= F_DISP32;
				hs->disp.disp32 = *(uint32_t*)p;
				break;
		}
		p += disp_size;
	}
	else if ( pref & PRE_LOCK )
		hs->flags |= F_ERROR | F_ERROR_LOCK;

	if ( cflags & C_IMM_P66 )
	{
		if ( cflags & C_REL32 )
		{
			if ( pref & PRE_66 )
			{
				hs->flags |= F_IMM16 | F_RELATIVE;
				hs->imm.imm16 = *(uint16_t*)p;
				p += 2;
				goto disasm_done;
			}
			goto rel32_ok;
		}
		if ( op64 )
		{
			hs->flags |= F_IMM64;
			hs->imm.imm64 = *(uint64_t*)p;
			p += 8;
		}
		else if ( !( pref & PRE_66 ) )
		{
			hs->flags |= F_IMM32;
			hs->imm.imm32 = *(uint32_t*)p;
			p += 4;
		}
		else
			goto imm16_ok;
	}


	if ( cflags & C_IMM16 )
	{
	imm16_ok:
		hs->flags |= F_IMM16;
		hs->imm.imm16 = *(uint16_t*)p;
		p += 2;
	}
	if ( cflags & C_IMM8 )
	{
		hs->flags |= F_IMM8;
		hs->imm.imm8 = *p++;
	}

	if ( cflags & C_REL32 )
	{
	rel32_ok:
		hs->flags |= F_IMM32 | F_RELATIVE;
		hs->imm.imm32 = *(uint32_t*)p;
		p += 4;
	}
	else if ( cflags & C_REL8 )
	{
		hs->flags |= F_IMM8 | F_RELATIVE;
		hs->imm.imm8 = *p++;
	}

disasm_done:

	if ( ( hs->len = (uint8_t)( p - (uint8_t*)code ) ) > 15 )
	{
		hs->flags |= F_ERROR | F_ERROR_LENGTH;
		hs->len = 15;
	}

	return (unsigned int)hs->len;
}

#endif // defined(_M_X64) || defined(__x86_64__)
```

`Misc/HDE/HDE64.hpp`:

```hpp
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "..\..\Common.hpp"

#define F_MODRM 0x00000001
#define F_SIB 0x00000002
#define F_IMM8 0x00000004
#define F_IMM16 0x00000008
#define F_IMM32 0x00000010
#define F_IMM64 0x00000020
#define F_DISP8 0x00000040
#define F_DISP16 0x00000080
#define F_DISP32 0x00000100
#define F_RELATIVE 0x00000200
#define F_ERROR 0x00001000
#define F_ERROR_OPCODE 0x00002000
#define F_ERROR_LENGTH 0x00004000
#define F_ERROR_LOCK 0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ 0x01000000
#define F_PREFIX_REPX 0x02000000
#define F_PREFIX_REP 0x03000000
#define F_PREFIX_66 0x04000000
#define F_PREFIX_67 0x08000000
#define F_PREFIX_LOCK 0x10000000
#define F_PREFIX_SEG 0x20000000
#define F_PREFIX_REX 0x40000000
#define F_PREFIX_ANY 0x7f000000

#define PREFIX_SEGMENT_CS 0x2e
#define PREFIX_SEGMENT_SS 0x36
#define PREFIX_SEGMENT_DS 0x3e
#define PREFIX_SEGMENT_ES 0x26
#define PREFIX_SEGMENT_FS 0x64
#define PREFIX_SEGMENT_GS 0x65
#define PREFIX_LOCK 0xf0
#define PREFIX_REPNZ 0xf2
#define PREFIX_REPX 0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack( push, 1 )

typedef struct
{
	uint8_t len;
	uint8_t p_rep;
	uint8_t p_lock;
	uint8_t p_seg;
	uint8_t p_66;
	uint8_t p_67;
	uint8_t rex;
	uint8_t rex_w;
	uint8_t rex_r;
	uint8_t rex_x;
	uint8_t rex_b;
	uint8_t opcode;
	uint8_t opcode2;
	uint8_t modrm;
	uint8_t modrm_mod;
	uint8_t modrm_reg;
	uint8_t modrm_rm;
	uint8_t sib;
	uint8_t sib_scale;
	uint8_t sib_index;
	uint8_t sib_base;
	union
	{
		uint8_t imm8;
		uint16_t imm16;
		uint32_t imm32;
		uint64_t imm64;
	} imm;
	union
	{
		uint8_t disp8;
		uint16_t disp16;
		uint32_t disp32;
	} disp;
	uint32_t flags;
} hde64s;

#pragma pack( pop )

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm( const void* code, hde64s* hs );

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */
```

`Misc/HDE/Table64.hpp`:

```hpp
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE 0x00
#define C_MODRM 0x01
#define C_IMM8 0x02
#define C_IMM16 0x04
#define C_IMM_P66 0x10
#define C_REL8 0x20
#define C_REL32 0x40
#define C_GROUP 0x80
#define C_ERROR 0xff

#define PRE_ANY 0x00
#define PRE_NONE 0x01
#define PRE_F2 0x02
#define PRE_F3 0x04
#define PRE_66 0x08
#define PRE_67 0x10
#define PRE_LOCK 0x20
#define PRE_SEG 0x40
#define PRE_ALL 0xff

#define DELTA_OPCODES 0x4a
#define DELTA_FPU_REG 0xfd
#define DELTA_FPU_MODRM 0x104
#define DELTA_PREFIXES 0x13c
#define DELTA_OP_LOCK_OK 0x1ae
#define DELTA_OP2_LOCK_OK 0x1c6
#define DELTA_OP_ONLY_MEM 0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
	0xa5, 0xaa, 0xa5, 0xb8, 0xa5, 0xaa, 0xa5, 0xaa, 0xa5, 0xb8, 0xa5, 0xb8, 0xa5, 0xb8, 0xa5,
	0xb8, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xac, 0xc0, 0xcc, 0xc0, 0xa1, 0xa1,
	0xa1, 0xa1, 0xb1, 0xa5, 0xa5, 0xa6, 0xc0, 0xc0, 0xd7, 0xda, 0xe0, 0xc0, 0xe4, 0xc0, 0xea,
	0xea, 0xe0, 0xe0, 0x98, 0xc8, 0xee, 0xf1, 0xa5, 0xd3, 0xa5, 0xa5, 0xa1, 0xea, 0x9e, 0xc0,
	0xc0, 0xc2, 0xc0, 0xe6, 0x03, 0x7f, 0x11, 0x7f, 0x01, 0x7f, 0x01, 0x3f, 0x01, 0x01, 0xab,
	0x8b, 0x90, 0x64, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x92, 0x5b, 0x5b, 0x76, 0x90, 0x92, 0x92,
	0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x6a, 0x73, 0x90,
	0x5b, 0x52, 0x52, 0x52, 0x52, 0x5b, 0x5b, 0x5b, 0x5b, 0x77, 0x7c, 0x77, 0x85, 0x5b, 0x5b,
	0x70, 0x5b, 0x7a, 0xaf, 0x76, 0x76, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b,
	0x5b, 0x5b, 0x86, 0x01, 0x03, 0x01, 0x04, 0x03, 0xd5, 0x03, 0xd5, 0x03, 0xcc, 0x01, 0xbc,
	0x03, 0xf0, 0x03, 0x03, 0x04, 0x00, 0x50, 0x50, 0x50, 0x50, 0xff, 0x20, 0x20, 0x20, 0x20,
	0x01, 0x01, 0x01, 0x01, 0xc4, 0x02, 0x10, 0xff, 0xff, 0xff, 0x01, 0x00, 0x03, 0x11, 0xff,
	0x03, 0xc4, 0xc6, 0xc8, 0x02, 0x10, 0x00, 0xff, 0xcc, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x01, 0x03, 0x01, 0xff, 0xff, 0xc0, 0xc2, 0x10, 0x11, 0x02, 0x03, 0x01, 0x01,
	0x01, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x10,
	0x10, 0x10, 0x10, 0x02, 0x10, 0x00, 0x00, 0xc6, 0xc8, 0x02, 0x02, 0x02, 0x02, 0x06, 0x00,
	0x04, 0x00, 0x02, 0xff, 0x00, 0xc0, 0xc2, 0x01, 0x01, 0x03, 0x03, 0x03, 0xca, 0x40, 0x00,
	0x0a, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x33, 0x01, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xff, 0xbf, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xff, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00,
	0xff, 0x40, 0x40, 0x40, 0x40, 0x41, 0x49, 0x40, 0x40, 0x40, 0x40, 0x4c, 0x42, 0x40, 0x40,
	0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x4f, 0x44, 0x53, 0x40, 0x40, 0x40, 0x44, 0x57, 0x43,
	0x5c, 0x40, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
	0x40, 0x40, 0x64, 0x66, 0x6e, 0x6b, 0x40, 0x40, 0x6a, 0x46, 0x40, 0x40, 0x44, 0x46, 0x40,
	0x40, 0x5b, 0x44, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 0x06, 0x01, 0x06,
	0x06, 0x02, 0x06, 0x06, 0x00, 0x06, 0x00, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x02, 0x07, 0x07,
	0x06, 0x02, 0x0d, 0x06, 0x06, 0x06, 0x0e, 0x05, 0x05, 0x02, 0x02, 0x00, 0x00, 0x04, 0x04,
	0x04, 0x04, 0x05, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x08, 0x00, 0x10,
	0x00, 0x18, 0x00, 0x20, 0x00, 0x28, 0x00, 0x30, 0x00, 0x80, 0x01, 0x82, 0x01, 0x86, 0x00,
	0xf6, 0xcf, 0xfe, 0x3f, 0xab, 0x00, 0xb0, 0x00, 0xb1, 0x00, 0xb3, 0x00, 0xba, 0xf8, 0xbb,
	0x00, 0xc0, 0x00, 0xc1, 0x00, 0xc7, 0xbf, 0x62, 0xff, 0x00, 0x8d, 0xff, 0x00, 0xc4, 0xff,
	0x00, 0xc5, 0xff, 0x00, 0xff, 0xff, 0xeb, 0x01, 0xff, 0x0e, 0x12, 0x08, 0x00, 0x13, 0x09,
	0x00, 0x16, 0x08, 0x00, 0x17, 0x09, 0x00, 0x2b, 0x09, 0x00, 0xae, 0xff, 0x07, 0xb2, 0xff,
	0x00, 0xb4, 0xff, 0x00, 0xb5, 0xff, 0x00, 0xc3, 0x01, 0x00, 0xc7, 0xff, 0xbf, 0xe7, 0x08,
	0x00, 0xf0, 0x02, 0x00
};
```

`README.md`:

```md
# HyperDeceit
This repository contains the full source-code of the HyperDeceit project which is a library that allows you to impersonate as Hyper-V and intercept hypercalls done by the Windows kernel.

Blog post: https://reversing.info/posts/hyperdeceit/

# Disclaimer
The code has not been through proper code review and hence might contain inconsistencies, please do create a new issue / pull request for any additions/fixes.

# Implementations
#### The following features are ready to be hooked out of the box:
- TLB flushing
- Sleep / shutdown
- Address space switching
- Spinlock
#### Features which are not added yet and have plans to be added on later (Feel free to implement and create a new PR):
- IPI
- ???

# Compatibility
- Only supports Windows versions from **Windows 10 1709** to **Windows 11 22H2**.

# Notes
- [Includes/HyperDeceit.hpp](https://github.com/Xyrem/HyperDeceit/blob/main/Includes/HyperDeceit.hpp) is the header file which should be included in your project with the output library linked to use HyperDeceit.
- Bugcheck information
  |Code|Reason|
  |-|-|
  |0xBAD00001|Unsupported Windows version.|
  |0xBAD00002|Provided kernel base address was null.|
  |0xBAD00003|Unhandled code.|
  |0xBAD00004|Failed to disassemble address.|

# Examples
- [Yumekage](https://github.com/Xyrem/Yumekage) is a demo proof of concept for creating hidden memory regions inside a process.

# Credits
- Vyacheslav Patkov for Hacker Disassembler Engine (HDE).

```

`Utils/Utils.cpp`:

```cpp
/*
*		File name:
*			Utils.cpp
*
*		Use:
*			Utilities for kernel and memory manipulation.
*
*		Author:
*			Xyrem ( https://reversing.info | Xyrem@reversing.info )
*/

#include "Utils.hpp"

namespace Utils
{
	/*
	*	Get function information from SEH data.
	*	DISCLAIMER: THIS IMPLEMENTATION ONLY SUPPORTS KERNEL ADDRESSES!!!!!
	*/
	bool GetFunctionInformation( _In_ uint64_t Addr, _In_opt_ RUNTIME_FUNCTION* RuntimeDataOut, _In_opt_ UNWIND_INFO_HDR* UnwindInfoOut )
	{
		// Address is null?
		if (!Addr)
			return false;

		// Get base address of driver from address.
		uint64_t BaseAddress;
		if (!RtlPcToFileHeader( Addr, &BaseAddress ))
			return false;	// Was not found.

		PIMAGE_NT_HEADERS64 NT = NTHEADER( BaseAddress );
		PIMAGE_DATA_DIRECTORY ExceptionDirectory = &NT->OptionalHeader.DataDirectory[ IMAGE_DIRECTORY_ENTRY_EXCEPTION ];

		// Exception data not present?
		if (!ExceptionDirectory->VirtualAddress || !ExceptionDirectory->Size)
			return false;

		int NumOfFunctions = ExceptionDirectory->Size / sizeof( RUNTIME_FUNCTION );
		for (int i = 0; i < NumOfFunctions; i++)
		{
			RUNTIME_FUNCTION* RuntimeData = (RUNTIME_FUNCTION*)(BaseAddress + ExceptionDirectory->VirtualAddress + i * sizeof( RUNTIME_FUNCTION ));

			// Is the address inside the function bounds?
			if ((BaseAddress + RuntimeData->FunctionStart) <= Addr && (BaseAddress + RuntimeData->FunctionEnd) >= Addr)
			{
				// Found
				if (RuntimeDataOut)
					*RuntimeDataOut = *RuntimeData;

				if (UnwindInfoOut)
					*UnwindInfoOut = *(UNWIND_INFO_HDR*)(BaseAddress + RuntimeData->UnwindInfo);
			
				return true;
			}
		}

		// Not found
		return false;
	}
}
```

`Utils/Utils.hpp`:

```hpp
/*
*		File name:
*			Utils.hpp
*
*		Use:
*			Utilities for kernel and memory manipulation.
*
*		Author:
*			Xyrem ( https://reversing.info | Xyrem@reversing.info )
*/

#pragma once
#include "..\Common.hpp"

namespace Utils
{
	bool GetFunctionInformation( _In_ uint64_t Addr, _In_opt_ RUNTIME_FUNCTION* RuntimeDataOut = 0, _In_opt_ UNWIND_INFO_HDR* UnwindInfoOut = 0);

	/*
	*	Search for a pattern in a memory block.
	*	The 0xCC byte is ignored while searching, use it as a wildcard.
	*/
	template <int T>
	static uint64_t FindPattern_C( _In_ uint64_t SearchStart, _In_ uint32_t SearchSize, _In_ const char( &CPattern )[ T ] )
	{
		uint8_t* Pattern = (uint8_t*)CPattern;
		for ( uint8_t* i = (uint8_t*)SearchStart; i < (uint8_t*)(SearchStart + SearchSize - T - 1); i++ )
		{
			bool Found = true;

			for ( int a = 0; a < T - 1; a++ )
			{
				if ( i[ a ] != Pattern[ a ] && Pattern[ a ] != 0xCC )
				{
					Found = false;
					break;
				}
			}

			if ( Found )
				return uint64_t(i);
		}

		return 0;
	}

	/*
	*	Searches for a pattern in a PE module.
	*	0xCC byte is ignored while searching, use it as a wildcard.
	*/
	template <int T>
	static uint64_t FindPattern( _In_ uint64_t Base, _In_ const char( &Pattern )[ T ] )
	{
		// Basic sanity checks.
		if ( !Base || PIMAGE_DOS_HEADER( Base )->e_magic != IMAGE_DOS_SIGNATURE )
			return 0;

		PIMAGE_NT_HEADERS64 NT = NTHEADER( Base );
		if ( NT->Signature != IMAGE_NT_SIGNATURE )
			return 0;

		PIMAGE_SECTION_HEADER SectionHeader = IMAGE_FIRST_SECTION( NT );

		for ( int i = 0; i < NT->FileHeader.NumberOfSections; i++, SectionHeader++ )
		{
			// Discardable sections are invalidated, so we should ignore them.
			if ( SectionHeader->Characteristics & IMAGE_SCN_MEM_DISCARDABLE )
				continue;

			uint64_t Address = FindPattern_C( Base + SectionHeader->VirtualAddress, SectionHeader->Misc.VirtualSize, Pattern );
			if ( Address )
				return Address;
		}

		return 0;
	}
}

```