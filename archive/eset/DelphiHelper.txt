Project Path: arc_eset_DelphiHelper_d1if87se

Source Tree:

```txt
arc_eset_DelphiHelper_d1if87se
├── DelphiHelper
│   ├── __init__.py
│   ├── core
│   │   ├── ClassResolver.py
│   │   ├── ClassStruct.py
│   │   ├── DFMFinder.py
│   │   ├── DFMParser.py
│   │   ├── DelphiClass.py
│   │   ├── DelphiClass_ClassTable.py
│   │   ├── DelphiClass_DynamicTable.py
│   │   ├── DelphiClass_FieldTable.py
│   │   ├── DelphiClass_InitTable.py
│   │   ├── DelphiClass_IntfTable.py
│   │   ├── DelphiClass_MethodTable.py
│   │   ├── DelphiClass_TypeInfo.py
│   │   ├── DelphiClass_TypeInfo_tkClass.py
│   │   ├── DelphiClass_TypeInfo_tkRecord.py
│   │   ├── DelphiClass_VMTTable.py
│   │   ├── DelphiForm.py
│   │   ├── EPFinder.py
│   │   ├── FieldEnum.py
│   │   ├── FormViewer.py
│   │   ├── FuncStruct.py
│   │   ├── IDRKBLoader.py
│   │   └── IDRKBParser.py
│   ├── ui
│   │   └── FormViewerUI.py
│   └── util
│       ├── delphi.py
│       ├── exception.py
│       └── ida.py
├── DelphiHelper.py
├── LICENSE
├── README.md
├── ida-plugin.json
├── img
│   ├── CallVMTFunc_After.PNG
│   ├── CallVMTFunc_Before.PNG
│   ├── ClassStruct.PNG
│   ├── CreateForm.PNG
│   ├── DelphiFormViewer.PNG
│   ├── EPFinder.PNG
│   ├── FieldInFunc_After.PNG
│   ├── FieldInFunc_Before.PNG
│   ├── FieldTable.PNG
│   ├── IDAEnum_FieldTable.PNG
│   ├── IDAStruct_VMT.PNG
│   ├── LoadFile.PNG
│   ├── MethodTable.PNG
│   ├── VMT.PNG
│   ├── VMTStructure.PNG
│   └── VMTStructureParsed.PNG
└── setup_IDRKB.py

```

`DelphiHelper.py`:

```py
#
# IDA plugin definition
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_auto
import ida_idaapi
import ida_kernwin
import ida_segment
import idautils

from DelphiHelper.core.ClassResolver import ResolveClass, ResolveApplicationClass
from DelphiHelper.core.ClassStruct import UpdateClassStructures
from DelphiHelper.core.DFMParser import ParseDFMs
from DelphiHelper.core.DelphiClass_TypeInfo import ParseTypeInfo
from DelphiHelper.core.EPFinder import EPFinder
from DelphiHelper.core.FormViewer import FormViewer
from DelphiHelper.core.IDRKBLoader import KBLoader
from DelphiHelper.core.IDRKBParser import GetDelphiVersion
from DelphiHelper.util.delphi import LoadDelphiFLIRTSignatures
from DelphiHelper.util.exception import DelphiHelperError


PLUGIN_NAME = "DelphiHelper"
PLUGIN_VERSION = "1.22"
PLUGIN_AUTHOR = "Juraj Hornak (juraj.hornak@eset.com)"


class DelphiHelperPlugin(ida_idaapi.plugin_t):
    flags = ida_idaapi.PLUGIN_MOD | ida_idaapi.PLUGIN_MULTI
    comment = PLUGIN_NAME + " - IDA plugin simplifying the analysis of Delphi x86/x64 binaries"
    help = "IDA plugin simplifying the analysis of Delphi binaries"
    wanted_name = PLUGIN_NAME
    wanted_hotkey = "Alt+Shift+H"

    def init(self):
        addon = ida_kernwin.addon_info_t()
        addon.id = "delphi_helper"
        addon.name = PLUGIN_NAME
        addon.producer = PLUGIN_AUTHOR
        addon.url = "juraj.hornak@eset.com"
        addon.version = PLUGIN_VERSION
        ida_kernwin.register_addon(addon)

        LoadDelphiFLIRTSignatures()

        return DelphiHelperPluginMain()


class DelphiHelperPluginMain(ida_idaapi.plugmod_t):

    def __init__(self) -> None:
        ida_idaapi.plugmod_t.__init__(self)

        self.__delphiFormList = list()
        self.__packageinfo = None
        self.__parseFlag = True
        self.__delphiVersion = 0

        self.hotkeys = []
        self.hotkeys.append(ida_kernwin.add_hotkey("Alt+Shift+R", self.resolveClass))
        self.hotkeys.append(ida_kernwin.add_hotkey("Alt+Shift+E", self.findEntryPointFunc))
        self.hotkeys.append(ida_kernwin.add_hotkey("Alt+Shift+F", self.formViewer))
        self.hotkeys.append(ida_kernwin.add_hotkey("Alt+Shift+S", self.loadIDRKBSignatures_main))
        self.hotkeys.append(ida_kernwin.add_hotkey("Alt+Shift+A", self.loadIDRKBSignatures_custom))

    def run(self, arg):
        self.printHelp()

    def printHelp(self) -> None:
        print("-"*100)
        print(f"{PLUGIN_NAME} ({PLUGIN_VERSION}) by {PLUGIN_AUTHOR}")
        print("Copyright (c) 2020-2026 ESET\n")
        print("IDA plugin simplifying the analysis of Delphi x86/x64 binaries")
        print("\nHotkeys:")

        print("  \"Alt + Shift + R\" - run VMT Parser in order to parse selected VMT structure")
        print("        Usage: Press it in disassembly window when the cursor is on the starting address of a VMT structure")
        print("               e.g.  mov edx, VMT_offset  --> starting address of the VMT structure")
        print("                     call CreateForm\n")

        print("  \"Alt + Shift + F\" - run DFM Finder (show Delphi Form Viewer)")
        print("        Usage: Press it anywhere in the disassembly window")
        print("        Note: The resource section of Delphi file must be loaded by IDA\n")

        print("  \"Alt + Shift + E\" - run Entry Point Function Finder (searching for \"CreateForm\", \"InitExe\" and \"InitLib\" references)")
        print("        Usage: Press it anywhere in the disassembly window\n")

        print("  \"Alt + Shift + S\" - run IDR Knowledge Base Loader for \"SysInit\" and \"System\" unit")
        print("        Usage: Press it anywhere in the disassembly window")
        print("        Note: read the README.md for KB file location.\n")

        print("  \"Alt + Shift + A\" - run IDR Knowledge Base Loader for selected units")
        print("        Usage: Press it anywhere in the disassembly window")
        print("        Note: read the README.md for KB file location.")
        print("-"*100)

    def term(self) -> None:
        for hotkey in self.hotkeys:
            ida_kernwin.del_hotkey(hotkey)

    def findEntryPointFunc(self) -> None:
        msg = "NODELAY\nHIDECANCEL\nSearching for EP function..."
        ida_kernwin.show_wait_box(msg)
        try:
            self.getDelphiVersion()
            EPFinder(self.__delphiVersion).FindEPFunction()
        except DelphiHelperError as e:
            e.print()
        finally:
            ida_kernwin.hide_wait_box()

    def resolveClass(self) -> None:
        msg = "NODELAY\nHIDECANCEL\nProcessing selected VMT structure..."
        ida_kernwin.show_wait_box(msg)
        try:
            self.getDelphiVersion()
            LoadDelphiFLIRTSignatures()
            ida_auto.auto_wait()
            ResolveClass(ida_kernwin.get_screen_ea(), self.__delphiVersion)
        except DelphiHelperError as e:
            e.print()
        finally:
            ida_kernwin.hide_wait_box()

    def formViewer(self) -> None:
        msg = "NODELAY\nHIDECANCEL\nProcessing Delphi file's DFMs..."
        ida_kernwin.show_wait_box(msg)
        try:
            self.getDelphiVersion()
            LoadDelphiFLIRTSignatures()
            ida_auto.auto_wait()
            ResolveApplicationClass(self.__delphiVersion)

            if self.__parseFlag:
                self.__delphiFormList = ParseDFMs(self.__delphiVersion)
                self.__parseFlag = False

            self.processTypeInfoStructures()

            UpdateClassStructures()

            if self.__delphiFormList:
                FormViewer(self.__delphiFormList)
            else:
                print("[INFO] The Delphi binary seems to not contain any Delphi Form")

        except DelphiHelperError as e:
            e.print()
        finally:
            ida_kernwin.hide_wait_box()

    def loadIDRKBSignatures_custom(self) -> None:
        try:
            KBLoader(True)
        except DelphiHelperError as e:
            e.print()

    def loadIDRKBSignatures_main(self) -> None:
        try:
            KBLoader(False)
        except DelphiHelperError as e:
            e.print()

    def getDelphiVersion(self) -> None:
        if self.__delphiVersion == 0:
            self.__delphiVersion = GetDelphiVersion()

    def processTypeInfoStructures(self) -> None:
        msg = "NODELAY\nHIDECANCEL\nProcessing TypeInfo structures..."
        ida_kernwin.show_wait_box(msg)
        try:
            self.getDelphiVersion()

            for ea_seg_start in idautils.Segments():
                addr = ea_seg_start + 5
                seg = ida_segment.getseg(ea_seg_start)

                while addr != ida_idaapi.BADADDR and addr < seg.end_ea:
                    addr = ParseTypeInfo(addr, self.__delphiVersion)
        except DelphiHelperError as e:
            e.print()
        finally:
            ida_kernwin.hide_wait_box()


def PLUGIN_ENTRY():
    """Required plugin entry point for IDAPython Plugins.
    """

    return DelphiHelperPlugin()

```

`DelphiHelper/core/ClassResolver.py`:

```py
#
# This module allows to parse and extract data from Delphi's VMT structures
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_idaapi
import ida_kernwin
import ida_name
from DelphiHelper.core.ClassStruct import UpdateClassStructures
from DelphiHelper.core.DelphiClass import DelphiClass
from DelphiHelper.util.delphi import GetApplicationClassAddr
from DelphiHelper.util.exception import DelphiHelperError


def ResolveApplicationClass(
        delphiVersion: int,
        classAddr: int = ida_idaapi.BADADDR) -> None:
    if classAddr == ida_idaapi.BADADDR:
        classAddr = GetApplicationClassAddr()
        if classAddr == ida_idaapi.BADADDR:
            return

    classApplicationName = ida_name.get_name(classAddr)
    if not classApplicationName.startswith('VMT_'):
        msg = "NODELAY\nHIDECANCEL\nProcessing \"TApplication\" VMT structure..."
        ida_kernwin.show_wait_box(msg)
        try:
            DelphiClass(classAddr, delphiVersion).MakeClass()
        except DelphiHelperError:
            pass
        finally:
            ida_kernwin.hide_wait_box()


def ResolveClass(classAddr: int, delphiVersion: int) -> None:
    ResolveApplicationClass(delphiVersion)
    DelphiClass(classAddr, delphiVersion).MakeClass()
    UpdateClassStructures()

```

`DelphiHelper/core/ClassStruct.py`:

```py
#
# This module allows to create IDA structure storing data extracted from VMT
# and Field table
#
# Copyright (c) 2025-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import ida_idaapi
import ida_name
import idautils
import idc

from DelphiHelper.util.ida import (
    FixName,
    GetCustomWord,
    GetProcessorWordSize,
    GetStructComment,
    GetStructMemberComment,
)


class ClassStruct(object):

    def __init__(self, classStructName: str, classStructComment: str) -> None:
        self.__classStructName = classStructName + "_Self"
        self.__classStructComment = classStructComment
        self.__classStructId = ida_idaapi.BADADDR
        self.__processorWordSize = GetProcessorWordSize()

    def Create(self) -> None:
        self.__CreateClassStruct()

    def AddMember(
            self,
            memberType: str,
            memberName: str,
            memberOffset: int) -> None:
        self.__CreateClassStruct()
        self.__AddClassStructMember(memberType, memberName, memberOffset)

    def __CreateClassStruct(self) -> None:
        if self.__classStructId == ida_idaapi.BADADDR:
            self.__DeleteStruct()

            self.__classStructId = idc.add_struc(
                -1,
                self.__classStructName,
                0
            )

            idc.set_struc_cmt(
                self.__classStructId,
                self.__classStructComment,
                0
            )

            idc.add_struc_member(
                self.__classStructId,
                self.__classStructName[:-5] + "_VMT",
                0,
                ida_bytes.FF_DWORD,
                -1,
                4
            )

    def __AddClassStructMember(
            self,
            memberType: str,
            memberName: str,
            memberOffset: int) -> None:
        structMemberName = (memberType
                            + "_"
                            + memberName)
        structMemberName = FixName(structMemberName)

        name = idc.get_member_name(self.__classStructId, memberOffset)
        if name is not None and not name.startswith("gap"):
            if name == structMemberName:
                return
            else:
                idc.set_member_name(
                    self.__classStructId,
                    memberOffset,
                    structMemberName
                )
                return

        idc.add_struc_member(
            self.__classStructId,
            structMemberName,
            memberOffset,
            ida_bytes.FF_BYTE,
            -1,
            1
        )

        idc.set_member_cmt(
            self.__classStructId,
            memberOffset,
            FixName(memberType),
            0
        )

    def __DeleteStruct(self) -> None:
        structId = idc.get_struc_id(self.__classStructName)

        if structId != ida_idaapi.BADADDR:
            idc.del_struc(structId)

        self.__classStructId = ida_idaapi.BADADDR


def UpdateClassStructures() -> None:
    for struct in idautils.Structs():
        structID = struct[1]
        structName = struct[2]
        structCmt = GetStructComment(structID)

        if structName.endswith("_Self") and \
           idc.get_type(idc.get_member_id(structID, 0)) == "int" and \
           structCmt is not None and \
           structCmt.startswith("VMT_"):
            propagateBaseClassFields(structID, structName)

    for struct in idautils.Structs():
        if struct[2].endswith("_Self"):
            fixMemberTypes(struct[1])


def fixMemberTypes(structID: int) -> None:
    for member in idautils.StructMembers(structID):
        if member[0] != 0 and not member[1].startswith("gap"):
            memberCmt = GetStructMemberComment(structID, member[0])
            if memberCmt is not None and \
               memberCmt[0] == 'T' and \
               idc.get_struc_id(memberCmt + "_Self") != ida_idaapi.BADADDR:
                memberID = idc.get_member_id(structID, member[0])
                idc.SetType(memberID, memberCmt + "_Self*")


def propagateBaseClassFields(structID: int, structName: str) -> None:
    processorWordSize = GetProcessorWordSize()
    memberID = idc.get_member_id(structID, 0)

    structCmt = GetStructComment(structID)
    if structCmt is None:
        return

    classAddr = idc.get_name_ea_simple(structCmt)
    parentClassAddr = GetCustomWord(
        classAddr + 10 * processorWordSize,
        processorWordSize
    )

    if parentClassAddr == 0 or not ida_bytes.is_loaded(parentClassAddr):
        idc.SetType(memberID, "void*")
        return

    if ida_name.get_name(parentClassAddr).startswith("VMT_"):
        parentClassName = ida_name.get_name(parentClassAddr).split('_', 2)[2]
        parentStructName = parentClassName + "_Self"
        parentStructID = idc.get_struc_id(parentStructName)

        if parentStructID != ida_idaapi.BADADDR:
            if idc.get_type(idc.get_member_id(parentStructID, 0)) == "int":
                propagateBaseClassFields(parentStructID, parentStructName)

            for member in idautils.StructMembers(parentStructID):
                if member[0] != 0 and not member[1].startswith("gap"):
                    idc.add_struc_member(
                        structID,
                        member[1],
                        member[0],
                        ida_bytes.FF_BYTE,
                        -1,
                        1
                    )

                    idc.set_member_cmt(
                        structID,
                        member[0],
                        GetStructMemberComment(parentStructID, member[0]),
                        0
                    )

        memberName = idc.get_member_name(structID, 0)

        if idc.get_struc_id(memberName) == ida_idaapi.BADADDR:
            idc.SetType(memberID, "void*")
        else:
            idc.SetType(memberID, structName[:-5] + "_VMT*")

```

`DelphiHelper/core/DFMFinder.py`:

```py
#
# This module allows to search for Delphi's DFM in Delphi binary
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_idaapi
import ida_kernwin
import ida_nalt
import ida_offset
import idautils
import struct
from DelphiHelper.util.ida import Byte, Word, Dword, find_bytes


class DFMFinder():

    def __init__(self) -> None:
        self.__rsrcSecAddr = self.__GetResourceSectionAddress()
        self.__DFMlist = list()
        self.__ExtractDFM()

    def GetDFMList(self) -> list[tuple[int, int]]:
        return self.__DFMlist

    def __CheckDFMSignature(self, addr: int) -> bool:
        if chr(Byte(addr)) == "T" and \
           chr(Byte(addr + 1)) == "P" and \
           chr(Byte(addr + 2)) == "F" and \
           chr(Byte(addr + 3)) == "0":
            return True
        else:
            return False

    def __GetResourceSectionAddress(self) -> int:
        pe = idautils.peutils_t()

        resourceDirectoryOffset = 0x88
        if not pe or len(pe.header()) < resourceDirectoryOffset + 4:
            return 0

        resourceDirectory = pe.header()[resourceDirectoryOffset:resourceDirectoryOffset+4]
        resourceDirectoryRVA = struct.unpack("i", resourceDirectory)[0]

        if resourceDirectoryRVA:
            return ida_nalt.get_imagebase() + resourceDirectoryRVA
        else:
            return 0

    def __GetRCDATAAddr(self) -> int:
        numOfDirEntries = self.__GetNumberOfDirEntries(self.__rsrcSecAddr)
        addr = self.__rsrcSecAddr + 16

        for i in range(numOfDirEntries):
            # RCDATA
            if Dword(addr) == 10 and Dword(addr + 4) & 0x80000000 != 0:
                return self.__rsrcSecAddr + (Dword(addr + 4) & 0x7FFFFFFF)
            addr += 8
        return 0

    def __GetNumberOfDirEntries(self, tableAddr: int) -> int:
        return Word(tableAddr + 12) + Word(tableAddr + 14)

    def __ExtractDFMFromResource(self) -> None:
        print("[INFO] Searching for DFM in loaded resource section...")

        if self.__rsrcSecAddr == 0:
            print("[INFO] The resource directory is empty.")
            return

        if ida_offset.can_be_off32(self.__rsrcSecAddr) != ida_idaapi.BADADDR:
            RCDATAaddr = self.__GetRCDATAAddr()

            if RCDATAaddr != 0:
                RCDATAaddrEntryCount = self.__GetNumberOfDirEntries(RCDATAaddr)
                addr = RCDATAaddr + 16

                for i in range(RCDATAaddrEntryCount):
                    if Dword(addr) & 0x80000000 != 0 and \
                       Dword(addr + 4) & 0x80000000 != 0:
                        dirTableAddr = (self.__rsrcSecAddr
                                        + (Dword(addr + 4) & 0x7FFFFFFF))

                        if self.__GetNumberOfDirEntries(dirTableAddr) == 1:
                            DFMDataAddr = (ida_nalt.get_imagebase()
                                           + Dword(self.__rsrcSecAddr
                                           + Dword(dirTableAddr + 20)))

                            DFMDataSizeAddr = (self.__rsrcSecAddr
                                               + Dword(dirTableAddr + 20)
                                               + 4)
                            DFMDataSize = Dword(DFMDataSizeAddr)

                            if self.__CheckDFMSignature(DFMDataAddr):
                                self.__DFMlist.append((DFMDataAddr, DFMDataSize))
                    addr += 8
            else:
                print("[WARNING] The resource section seems to be corrupted!")
        else:
            print("[WARNING] The resource section not found! Make sure the resource section is loaded by IDA.")
            ida_kernwin.warning("The resource section not found!\nMake sure the resource section is loaded by IDA.")

    def __ExtractDFMFromBinary(self) -> None:
        print("[INFO] Searching for DFM in loaded binary...")

        self.__DFMlist = list()
        startAddr = 0
        counter = 0

        while True:
            # 0x0TPF0
            dfmAddr = find_bytes("00 54 50 46 30", startAddr)

            if dfmAddr == ida_idaapi.BADADDR:
                break

            if counter != 0 and Byte(dfmAddr + 5) != 0:  # FP
                print(f"[INFO] Found DFM: 0x{dfmAddr:x}")
                self.__DFMlist.append((dfmAddr + 1, 10000000))

            counter += 1
            startAddr = dfmAddr + 1

    def __ExtractDFM(self) -> None:
        self.__ExtractDFMFromResource()

        if len(self.__DFMlist) == 0:
            self.__ExtractDFMFromBinary()

        if len(self.__DFMlist) == 0:
            print("[INFO] DFM not found.")

```

`DelphiHelper/core/DFMParser.py`:

```py
#
# This module allows to search for, parse and extract data from Delphi's DFM
# resource
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import ida_kernwin
import ida_name
from DelphiHelper.core.DFMFinder import *
from DelphiHelper.core.DelphiClass import *
from DelphiHelper.core.DelphiForm import *
from DelphiHelper.util.exception import DelphiHelperError


def ParseDFMs(
        delphiVersion: int
    ) -> list[tuple[DelphiObject, list[tuple[str, int]], int]]:
    dfmList = DFMFinder().GetDFMList()
    numOfDfms = len(dfmList)
    delphiFormList = list()

    ida_kernwin.show_wait_box("NODELAY\nHIDECANCEL\nProcessing Delphi file's DFMs...")

    try:
        for i, dfmEntry in enumerate(dfmList):
            msg = "HIDECANCEL\nProcessing Delphi file's DFMs (%d/%d)" \
                % (i + 1, numOfDfms)
            ida_kernwin.replace_wait_box(msg)

            data = ida_bytes.get_bytes(dfmEntry[0], dfmEntry[1])

            if data and (ida_bytes.is_loaded(dfmEntry[0] + dfmEntry[1] - 1) or dfmEntry[1] == 10000000):
                dfmEntryParser = DFMParser(data, dfmEntry[1])

                if dfmEntryParser.CheckSignature():
                    methodList = list()
                    VMTAddr = 0
                    delphiDFM = dfmEntryParser.ParseForm()

                    try:
                        delphiRTTI = DelphiClass(
                            0,
                            delphiVersion,
                            delphiDFM.GetClassName()
                        )

                        VMTAddr = delphiRTTI.GetVMTAddress()
                        if not ida_name.get_name(VMTAddr).startswith("VMT_"):
                            delphiRTTI.MakeClass()

                        methodList = delphiRTTI.GetMethods()
                    except DelphiHelperError:
                        print(f"[WARNING] RTTI Class {delphiDFM.GetClassName()} not found!")

                    delphiFormList.append((delphiDFM, methodList, VMTAddr))

                del dfmEntryParser

        return delphiFormList
    finally:
        ida_kernwin.hide_wait_box()


class DFMParser(object):

    def __init__(self, data: bytes, dataSize: int) -> None:
        self.__resData = data
        self.__resDataSize = dataSize
        self.__resDataPos = 0

    def ParseForm(self) -> DelphiObject | None:
        if self.__ReadSignature():
            delphiForm = self.__ParseObject()
            return delphiForm
        return None

    def CheckSignature(self) -> bool:
        if self.__resDataSize < 4:
            return False
        return self.__resData.startswith(b"TPF0")

    def __ParseProperty(
            self,
            parentDelphiObj: DelphiObject) -> DelphiProperty | None:
        try:
            if self.__ReadRawData(1, 0)[0] == 0:
                self.__ReadByte()
                return None
        except DelphiHelperError:
            return None

        propName = self.__ReadString().decode()
        propType = self.__ReadByte()

        if propName is None or propType is None:
            return None

        propValue = self.__ReadPropertyValue(propType)

        delphiProp = DelphiProperty(
            propName,
            propType,
            propValue,
            parentDelphiObj
        )
        parentDelphiObj.AddProperty(delphiProp)

        return delphiProp

    def __ParseObject(
            self,
            parentDelphiObj: DelphiObject | None = None
            ) -> DelphiObject | None:
        try:
            if self.__ReadRawData(1, 0)[0] == 0:
                self.__ReadByte()
                return None
        except DelphiHelperError:
            return None

        if not self.__ReadPrefix():
            className = self.__ReadString().decode()
            objectName = self.__ReadString().decode()

            if className is not None and objectName is not None:
                childDelphiObj = DelphiObject(
                    className,
                    objectName,
                    parentDelphiObj
                )

                while self.__ParseProperty(childDelphiObj) is not None:
                    pass
                while self.__ParseObject(childDelphiObj) is not None:
                    pass

                if parentDelphiObj is not None:
                    parentDelphiObj.AddChildObject(childDelphiObj)

                return childDelphiObj
            else:
                raise DelphiHelperError("ClassName or ObjName is None")

    def __ReadSignature(self) -> bool:
        return self.__ReadRawData(4) == b"TPF0"

    def __OutOfDataCheck(self, size: int) -> bool:
        if self.__resDataPos + size - 1 >= self.__resDataSize:
            raise DelphiHelperError("DMF corrupted: No more data to read!")
        return False

    def __ReadRawData(self, size: int, shift: int = 1) -> bytes:
        if size < 0:
            size = 0

        self.__OutOfDataCheck(size)
        rawData = self.__resData[self.__resDataPos:self.__resDataPos+size]

        if shift == 1:
            self.__resDataPos += size

        return rawData

    def __ReadByte(self) -> int:
        return self.__ReadRawData(1)[0]

    def __ReadWord(self) -> int:
        rawData = self.__ReadRawData(2)
        value = 0

        for i in range(2):
            value += (rawData[i] << i*8)
        return value

    def __ReadDword(self) -> int:
        rawData = self.__ReadRawData(4)
        value = 0

        for i in range(4):
            value += (rawData[i] << i*8)
        return value

    def __ReadString(self) -> bytes:
        return self.__ReadRawData(self.__ReadByte())

    def __ReadLString(self) -> bytes:
        return self.__ReadRawData(self.__ReadDword())

    def __ReadWString(self) -> bytes:
        return self.__ReadRawData(self.__ReadDword() * 2)

    def __ReadData(self) -> bytes:
        return self.__ReadRawData(self.__ReadDword())

    def __ReadSingle(self) -> bytes:
        return self.__ReadRawData(4)

    def __ReadExtended(self) -> bytes:
        return self.__ReadRawData(10)

    def __ReadDouble(self) -> bytes:
        return self.__ReadRawData(8)

    def __ReadCurrency(self) -> bytes:
        return self.__ReadRawData(8)

    def __ReadDate(self) -> bytes:
        return self.__ReadRawData(8)

    def __ReadInt64(self) -> bytes:
        return self.__ReadRawData(8)

    def __ReadList(self) -> list:
        listElementType = self.__ReadByte()
        listElements = list()

        while listElementType != 0:
            listElements.append(
                (self.__ReadPropertyValue(listElementType), listElementType)
            )
            listElementType = self.__ReadByte()
        return listElements

    def __ReadSet(self) -> list:
        setElements = list()

        while True:
            elem = self.__ReadString()

            if len(elem) != 0:
                setElements.append(elem)
            else:
                break

        return setElements

    def __ReadCollection(self) -> list:
        collectionElements = list()

        while True:
            elementValue = None
            elementType = self.__ReadByte()

            if elementType == 0:
                break
            elif elementType == 2 or elementType == 3 or elementType == 4:
                elementValue = self.__ReadPropertyValue(elementType)
            elif elementType == 1:
                attrList = list()
                flag = True

                while flag:
                    attrName = self.__ReadString().decode()

                    if len(attrName) == 0:
                        flag = False
                    else:
                        attrType = self.__ReadByte()
                        attrList.append((
                            attrName,
                            self.__ReadPropertyValue(attrType),
                            attrType
                        ))
            else:
                raise DelphiHelperError("Invalid collection format!")

            collectionElements.append((elementValue, attrList))

        return collectionElements

    def __ReadPrefix(self) -> bool:
        if self.__ReadRawData(1, 0)[0] & 0xf0 == 0xf0:
            prefix = self.__ReadByte()

            flags = prefix & 0x0f

            if flags > 7:
                raise DelphiHelperError("Unsupported DFM Prefix.")

            if (flags & 2) != 0:
                propType = self.__ReadByte()

                if propType == 2 or propType == 3 or propType == 4:
                    self.__ReadPropertyValue(propType)
                else:
                    raise DelphiHelperError("Unsupported DFM Prefix.")

        return False

    def __ReadPropertyValue(
            self,
            propType: int) -> bytes | int | list | str:
        match propType:
            # Null
            case 0: return "Null"
            # List
            case 1: return self.__ReadList()
            # Int8
            case 2: return self.__ReadByte()
            # Int16
            case 3: return self.__ReadWord()
            # Int32
            case 4: return self.__ReadDword()
            # Extended
            case 5: return self.__ReadExtended()
            # String
            case 6: return self.__ReadString()
            # Ident
            case 7: return self.__ReadString()
            # False
            case 8: return 0
            # True
            case 9: return 1
            # Binary
            case 10: return self.__ReadData()
            # Set
            case 11: return self.__ReadSet()
            # LString
            case 12: return self.__ReadLString()
            # Nil
            case 13: return "Nil"
            # Collection
            case 14: return self.__ReadCollection()
            # Single
            case 15: return self.__ReadSingle()
            # Currency
            case 16: return self.__ReadCurrency()
            # Date
            case 17: return self.__ReadDate()
            # WString
            case 18: return self.__ReadWString()
            # Int64
            case 19: return self.__ReadInt64()
            # UTF8String
            case 20: return self.__ReadLString()
            # Double
            case 21: return self.__ReadDouble()
            case _:
                raise DelphiHelperError("Unsupported property type: " + str(propType))

```

`DelphiHelper/core/DelphiClass.py`:

```py
#
# This module implements class for storing data extracted from Delphi's VMT
# structure
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import ida_idaapi
import ida_name
from DelphiHelper.core.ClassStruct import *
from DelphiHelper.core.DelphiClass_DynamicTable import *
from DelphiHelper.core.DelphiClass_FieldTable import *
from DelphiHelper.core.DelphiClass_InitTable import *
from DelphiHelper.core.DelphiClass_IntfTable import *
from DelphiHelper.core.DelphiClass_MethodTable import *
from DelphiHelper.core.DelphiClass_TypeInfo import *
from DelphiHelper.core.DelphiClass_VMTTable import *
from DelphiHelper.core.FieldEnum import *
from DelphiHelper.core.FuncStruct import *
from DelphiHelper.util.delphi import DemangleFuncName
from DelphiHelper.util.exception import DelphiHelperError
from DelphiHelper.util.ida import *


class DelphiClass(object):
    __CLASS_DESCRIPTION = [
        "SelfPtr",
        "IntfTable",
        "AutoTable",
        "InitTable",
        "TypeInfo",
        "FieldTable",
        "MethodTable",
        "DynamicTable",
        "ClassName",
        "InstanceSize",
        "Parent"
    ]

    def __init__(
            self,
            VMT_addr: int,
            delphiVersion: int,
            className: str = str()) -> None:
        self.__processorWordSize = GetProcessorWordSize()
        self.__delphiVersion = delphiVersion

        if VMT_addr == 0:
            self.__VMTaddr = self.__GetVMTAddrByName(className)
        else:
            self.__VMTaddr = VMT_addr

        if self.IsDelphiClass():
            self.__classInfo = self.GetClassInfo()

            self.__fieldEnum = FieldEnum(
                self.__classInfo["Name"],
                self.__classInfo["FullName"]
            )

            self.__funcStruct = FuncStruct(
                self.__classInfo["Name"],
                self.__classInfo["FullName"]
            )

            self.__classStruct = ClassStruct(
                self.__classInfo["Name"],
                self.__classInfo["FullName"]
            )

            self.__intfTable = IntfTable(
                self.__delphiVersion,
                self.__classInfo
            )
            
            self.__initTable = InitTable(
                self.__delphiVersion,
                self.__classInfo,
                self.__fieldEnum,
            )

            self.__typeInfo = TypeInfo(
                self.__delphiVersion,
                self.__classInfo["Address"]["TypeInfo"],
                self.__fieldEnum,
                self.__classStruct
            )

            self.__fieldTable = FieldTable(
                self.__delphiVersion,
                self.__classInfo,
                self.__fieldEnum,
                self.__classStruct
            )
            
            self.__methodTable = MethodTable(
                self.__delphiVersion,
                self.__classInfo
            )
            self.__dynamicTable = DynamicTable(self.__classInfo)
            self.__VMTTable = VMTTable(self.__classInfo, self.__funcStruct)
        else:
            raise DelphiHelperError("Invalid VMT structure address: " + hex(self.__VMTaddr))

    def GetClassInfo(self) -> dict[str, str | dict[str, int]]:
        classInfo = {}
        classInfo["Address"] = self.__GetAddressTable()
        classInfo["Name"] = self.__GetClassName()
        classInfo["FullName"] = self.__GetVMTClassName()
        return classInfo

    def GetVMTAddress(self) -> int:
        return self.__VMTaddr

    def GetClassName(self) -> str:
        return self.__classInfo["Name"]

    def GetClassFullName(self) -> str:
        return self.__classInfo["FullName"]

    def GetClassAddress(self) -> int:
        return self.__classInfo["Address"]["Class"]

    def GetClassStruct(self) -> ClassStruct:
        return self.__classStruct

    def GetMethods(self) -> list[tuple[str, int]]:
        return self.__methodTable.GetMethods()

    def MakeClass(self) -> None:
        print(f"[INFO] Processing {self.__classInfo['FullName']}")

        self.__DeleteClassHeader()
        self.__MakeClassName()

        self.__classStruct.Create()
        parentClassAddr = self.__classInfo["Address"]["ParentClass"]
        self.__ResolveParent(parentClassAddr)

        self.__intfTable.MakeTable()
        self.__initTable.MakeTable()
        self.__typeInfo.MakeTable()
        self.__fieldTable.MakeTable()
        self.__methodTable.MakeTable()
        self.__dynamicTable.MakeTable()
        self.__VMTTable.MakeTable()

        self.__MakeClassHeader()

    def IsDelphiClass(self) -> bool:
        if not ida_bytes.is_loaded(self.__VMTaddr) or \
           self.__VMTaddr == ida_idaapi.BADADDR or \
           self.__VMTaddr == 0:
            return False

        vmtTableAddr = GetCustomWord(self.__VMTaddr, self.__processorWordSize)

        if vmtTableAddr == 0 or vmtTableAddr < self.__VMTaddr:
            return False

        offset = vmtTableAddr - self.__VMTaddr

        if offset % self.__processorWordSize != 0 or \
           offset / self.__processorWordSize > 30 or \
           offset / self.__processorWordSize < 5:
            return False

        return True

    def __GetVMTClassName(self) -> str:
        return ("VMT_"
                + ("%x" % self.__VMTaddr).upper()
                + "_"
                + self.__GetClassName())

    def __GetClassName(self) -> str:
        return FixName(GetStr_PASCAL(self.__GetClassNameAddr()))

    def __GetClassNameAddr(self) -> int:
        return GetCustomWord(
            self.__VMTaddr + 8 * self.__processorWordSize,
            self.__processorWordSize
        )

    def __GetIntfTableAddr(self) -> int:
        return GetCustomWord(
            self.__VMTaddr + 1 * self.__processorWordSize,
            self.__processorWordSize
        )

    def __GetAutoTableAddr(self) -> int:
        return GetCustomWord(
            self.__VMTaddr + 2 * self.__processorWordSize,
            self.__processorWordSize
        )

    def __GetInitTableAddr(self) -> int:
        return GetCustomWord(
            self.__VMTaddr + 3 * self.__processorWordSize,
            self.__processorWordSize
        )

    def __GetTypeInfoAddr(self) -> int:
        return GetCustomWord(
            self.__VMTaddr + 4 * self.__processorWordSize,
            self.__processorWordSize
        )

    def __GetFieldTableAddr(self) -> int:
        return GetCustomWord(
            self.__VMTaddr + 5 * self.__processorWordSize,
            self.__processorWordSize
        )

    def __GetMethodTableAddr(self) -> int:
        return GetCustomWord(
            self.__VMTaddr + 6 * self.__processorWordSize,
            self.__processorWordSize
        )

    def __GetDynamicTableAddr(self) -> int:
        return GetCustomWord(
            self.__VMTaddr + 7 * self.__processorWordSize,
            self.__processorWordSize
        )

    def __GetParentClassAddr(self) -> int:
        return GetCustomWord(
            self.__VMTaddr + 10 * self.__processorWordSize,
            self.__processorWordSize
        )

    def __GetAddressTable(self) -> dict[str, int]:
        addressTable = {}
        addressTable["Class"] = self.__VMTaddr
        addressTable["VMTTable"] = GetCustomWord(
            self.__VMTaddr,
            self.__processorWordSize
        )
        addressTable["ParentClass"] = self.__GetParentClassAddr()
        addressTable["IntfTable"] = self.__GetIntfTableAddr()
        addressTable["AutoTable"] = self.__GetAutoTableAddr()
        addressTable["InitTable"] = self.__GetInitTableAddr()
        addressTable["TypeInfo"] = self.__GetTypeInfoAddr()
        addressTable["FieldTable"] = self.__GetFieldTableAddr()
        addressTable["MethodTable"] = self.__GetMethodTableAddr()
        addressTable["DynamicTable"] = self.__GetDynamicTableAddr()
        addressTable["ClassName"] = self.__GetClassNameAddr()
        return addressTable

    def __GetVMTAddrByName(self, className: str) -> int:
        stringToFind = " "

        if className == str():
            return 0

        for a in className:
            stringToFind += hex(ord(a))[2:] + " "

        stringToFind = "07 " + hex(len(className))[2:] + stringToFind

        addr = find_bytes(stringToFind)
        if addr != ida_idaapi.BADADDR:
            addr += 2 + len(className)
            addr = FindRef_Dword(
                GetCustomWord(addr, 4),
                GetCustomWord(addr, 4),
                ida_bytes.BIN_SEARCH_BACKWARD
            )

        return addr

    def __DeleteClassHeader(self) -> None:
        ida_bytes.del_items(
            self.__VMTaddr,
            ida_bytes.DELIT_DELNAMES,
            GetCustomWord(
                self.__VMTaddr,
                self.__processorWordSize
            ) - self.__VMTaddr
        )

    def __MakeClassHeader(self) -> None:
        addr = self.__VMTaddr
        endAddr = GetCustomWord(self.__VMTaddr, self.__processorWordSize)
        i = 0

        while addr < endAddr and i < 30:
            MakeCustomWord(addr, self.__processorWordSize)

            if addr < self.__VMTaddr + 11 * self.__processorWordSize:
                ida_bytes.set_cmt(addr, self.__CLASS_DESCRIPTION[i], 0)
            else:
                DemangleFuncName(GetCustomWord(addr, self.__processorWordSize))

            addr += self.__processorWordSize
            i += 1

    def __MakeClassName(self) -> None:
        classNameAddr = self.__GetClassNameAddr()
        classNameLen = Byte(classNameAddr)

        ida_bytes.del_items(
            classNameAddr,
            ida_bytes.DELIT_DELNAMES,
            classNameLen + 1
        )

        MakeStr_PASCAL(classNameAddr)
        MakeName(classNameAddr, self.__classInfo["Name"] + "_ClassName")
        MakeCustomWord(self.__VMTaddr, self.__processorWordSize)

        ida_name.set_name(
            self.__VMTaddr,
            self.__classInfo["FullName"],
            ida_name.SN_NOCHECK
        )

    def __ResolveParent(self, parentClassAddr: int) -> None:
        if ida_bytes.is_loaded(parentClassAddr) and \
           parentClassAddr != 0 and \
           not ida_name.get_name(parentClassAddr).startswith("VMT_"):
            try:
                delphiClass = DelphiClass(
                    parentClassAddr,
                    self.__delphiVersion
                )
                delphiClass.MakeClass()
            except DelphiHelperError as e:
                print(f"[ERROR] {e.msg}")

```

`DelphiHelper/core/DelphiClass_ClassTable.py`:

```py
#
# This module allows to parse Delphi's ClassTable
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import ida_name
from DelphiHelper.util.exception import DelphiHelperError
from DelphiHelper.util.ida import *


class ClassTable(object):

    def __init__(
            self,
            addr: int,
            tableName: str,
            delphiVersion: int) -> None:
        self.__tableAddr = addr
        self.__tableName = tableName
        self.__tableEntries = list()
        self.__processorWordSize = GetProcessorWordSize()
        self.__delphiVersion = delphiVersion

        if self.__tableAddr != 0:
            self.__numOfEntries = Word(self.__tableAddr)

    def GetTableAddress(self) -> int:
        return self.__tableAddr

    def MakeTable(self) -> None:
        if self.__tableAddr != 0:
            self.__DeleteTable()
            self.__CreateTable()

        return self.__tableEntries

    def __CreateTable(self) -> None:
        MakeWord(self.__tableAddr)
        MakeName(self.__tableAddr, self.__tableName + "_ClassTable")
        ida_bytes.set_cmt(self.__tableAddr, "Number of entries", 0)

        addr = self.__tableAddr + 2

        for i in range(self.__numOfEntries):
            vmtStructAddr = GetCustomWord(addr, self.__processorWordSize)
            self.__tableEntries.append(vmtStructAddr)

            if ida_bytes.is_loaded(vmtStructAddr) and \
               vmtStructAddr != 0 and \
               ida_name.get_name(vmtStructAddr)[:4] != "VMT_":
                from DelphiHelper.core.DelphiClass import DelphiClass
                try:
                    delphiClass = DelphiClass(
                        vmtStructAddr,
                        self.__delphiVersion
                    )
                    delphiClass.MakeClass()
                except DelphiHelperError as e:
                    e.print()

            MakeCustomWord(addr, self.__processorWordSize)
            addr += self.__processorWordSize

    def __DeleteTable(self) -> None:
        ida_bytes.del_items(
            self.__tableAddr,
            ida_bytes.DELIT_DELNAMES,
            self.__numOfEntries * self.__processorWordSize + 2
        )

```

`DelphiHelper/core/DelphiClass_DynamicTable.py`:

```py
#
# This module allows to parse Delphi's DynamicTable
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
from DelphiHelper.util.ida import *


class DynamicTable(object):

    def __init__(
            self,
            classInfo: dict[str, str | dict[str, int]]) -> None:
        self.__tableAddr = classInfo["Address"]["DynamicTable"]
        self.__tableName = classInfo["Name"]
        self.__processorWordSize = GetProcessorWordSize()

        if self.__tableAddr != 0:
            self.__numOfEntries = Word(self.__tableAddr)

    def GetTableAddress(self) -> int:
        return self.__tableAddr

    def MakeTable(self) -> None:
        if self.__tableAddr != 0:
            self.__DeleteTable()
            self.__CreateTable()

    def __CreateTable(self) -> None:
        MakeWord(self.__tableAddr)
        MakeName(self.__tableAddr, self.__tableName + "_DynamicTable")

        for i in range(self.__numOfEntries):
            MakeWord(self.__tableAddr + 2 + 2 * i)

        for i in range(self.__numOfEntries):
            addr = (self.__tableAddr
                    + 2
                    + 2 * self.__numOfEntries
                    + self.__processorWordSize * i)
            MakeCustomWord(addr, self.__processorWordSize)

        ida_bytes.set_cmt(
            self.__tableAddr,
            "Count",
            0
        )
        ida_bytes.set_cmt(
            self.__tableAddr + 2,
            "Method/Message handler number",
            0
        )
        ida_bytes.set_cmt(
            self.__tableAddr + 2 + 2 * self.__numOfEntries,
            "Method/Message handler pointer",
            0
        )

    def __DeleteTable(self) -> None:
        ida_bytes.del_items(
            self.__tableAddr,
            ida_bytes.DELIT_DELNAMES,
            self.__numOfEntries * (2 + self.__processorWordSize) + 2
        )

```

`DelphiHelper/core/DelphiClass_FieldTable.py`:

```py
#
# This module allows to parse and extract data from Delphi's FieldTable
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import ida_name
import idc
from DelphiHelper.core.ClassStruct import *
from DelphiHelper.core.DelphiClass_ClassTable import *
from DelphiHelper.core.DelphiClass_TypeInfo import *
from DelphiHelper.util.ida import *
from typing import Optional


class FieldTable(object):

    def __init__(
            self,
            delphiVersion: int,
            classInfo: dict[str, str | dict[str, int]],
            fieldEnum: FieldEnum,
            classStruct: ClassStruct) -> None:
        self.__tableAddr = classInfo["Address"]["FieldTable"]
        self.__classInfo = classInfo
        self.__fieldEnum = fieldEnum
        self.__classStruct = classStruct
        self.__tableName = classInfo["Name"]
        self.__NoNameCounter = 1
        self.__processorWordSize = GetProcessorWordSize()
        self.__classTableEntries = list()
        self.__delphiVersion = delphiVersion

        if self.__tableAddr != 0:
            self.__classTableAddr = GetCustomWord(
                self.__tableAddr + 2,
                self.__processorWordSize
            )

    def GetTableAddress(self) -> int:
        return self.__tableAddr

    def MakeTable(self) -> None:
        if self.__tableAddr != 0:
            self.__DeleteTable()
            self.__CreateTableAndExtractData()

    def __CreateExtendedTableAndExtractData(self, addr: int) -> None:
        MakeWord(addr)
        numOfEntries = Word(addr)
        MakeName(addr, self.__tableName + "_ExtendedFieldTable")
        ida_bytes.set_cmt(addr, "Number of records", 0)

        addr += 2

        for i in range(numOfEntries):
            nameAddr = addr + 5 + self.__processorWordSize
            recordSize = (8 + self.__processorWordSize
                          + Byte(nameAddr)
                          + Word(addr + 6
                                 + self.__processorWordSize
                                 + Byte(nameAddr))
                          - 2)

            MakeByte(addr)

            MakeCustomWord(addr + 1, self.__processorWordSize)
            typeInfoAddr = GetCustomWord(addr + 1, self.__processorWordSize)
            typeName = self.__ExtractTypeName(typeInfoAddr)

            if typeName is not None:
                MakeDword(addr + 1 + self.__processorWordSize)
                offset = Dword(addr + 1 + self.__processorWordSize)

                if Byte(nameAddr) != 0:
                    MakeStr_PASCAL(nameAddr)
                    name = GetStr_PASCAL(nameAddr)
                else:
                    MakeByte(nameAddr)
                    name = "NoName" + str(self.__NoNameCounter)
                    self.__NoNameCounter += 1

                MakeWord(addr + 6
                         + self.__processorWordSize
                         + Byte(nameAddr))

                if name[0] == "F":
                    tempName = name[1:]
                else:
                    tempName = name

                self.__fieldEnum.AddMember(typeName, tempName, offset)
                self.__classStruct.AddMember(typeName, tempName, offset)
                addr = addr + recordSize
            else:
                return

    def __CreateTableAndExtractData(self) -> None:
        MakeWord(self.__tableAddr)
        MakeName(self.__tableAddr, self.__tableName + "_FieldTable")

        ida_bytes.set_cmt(
            self.__tableAddr,
            "Number of records",
            0
        )

        MakeCustomWord(self.__tableAddr + 2, self.__processorWordSize)

        ida_bytes.set_cmt(
            self.__tableAddr + 2,
            "Class table",
            0
        )

        classTable = ClassTable(
            self.__classTableAddr,
            self.__tableName,
            self.__delphiVersion
        )
        self.__classTableEntries = classTable.MakeTable()

        addr = self.__tableAddr + 2 + self.__processorWordSize
        numOfEntries = Word(self.__tableAddr)

        for i in range(numOfEntries):
            fieldClassInfo = None
            recordSize = 7 + Byte(addr + 6)

            MakeDword(addr)
            offset = Dword(addr)
            MakeWord(addr + 4)
            index = Word(addr + 4)

            if Byte(addr + 6) != 0:
                MakeStr_PASCAL(addr + 6)
                name = GetStr_PASCAL(addr + 6)
            else:
                MakeByte(addr + 6)
                name = "NoName" + str(self.__NoNameCounter)
                self.__NoNameCounter += 1

            if ida_bytes.is_loaded(self.__classTableEntries[index]) and \
               self.__classTableEntries[index] != 0:
                from DelphiHelper.core.DelphiClass import DelphiClass
                delphiClass = DelphiClass(
                    self.__classTableEntries[index],
                    self.__delphiVersion
                )
                fieldClassInfo = delphiClass.GetClassInfo()

                ida_bytes.set_cmt(
                    addr,
                    fieldClassInfo["FullName"],
                    0
                )

            MakeName(addr, self.__tableName + "_" + name)

            if name[0] == "F":
                tempName = name[1:]
            else:
                tempName = name

            if fieldClassInfo is None:
                self.__fieldEnum.AddMember(
                    "Unknown",
                    tempName,
                    offset
                )
                self.__classStruct.AddMember(
                    "Unknown",
                    tempName,
                    offset
                )
            else:
                self.__fieldEnum.AddMember(
                    fieldClassInfo["Name"],
                    tempName,
                    offset
                )
                self.__classStruct.AddMember(
                    fieldClassInfo["Name"],
                    tempName,
                    offset
                )

            addr = addr + recordSize

        methodTableAddr = self.__classInfo["Address"]["MethodTable"]
        dynamicTableAddr = self.__classInfo["Address"]["DynamicTable"]
        classNameAddr = self.__classInfo["Address"]["ClassName"]

        if (methodTableAddr != 0 and addr < methodTableAddr) or \
           (methodTableAddr == 0 and dynamicTableAddr != 0 and addr < dynamicTableAddr) or \
           (methodTableAddr == 0 and dynamicTableAddr == 0 and addr < classNameAddr):
            self.__CreateExtendedTableAndExtractData(addr)

    def __DeleteTable(self) -> None:
        ida_bytes.del_items(
            self.__tableAddr,
            ida_bytes.DELIT_DELNAMES,
            2 + self.__processorWordSize
        )

        addr = self.__tableAddr + 2 + self.__processorWordSize
        numOfEntries = Word(self.__tableAddr)

        for i in range(numOfEntries):
            recordSize = 7 + Byte(addr + 6)
            ida_bytes.del_items(addr, ida_bytes.DELIT_DELNAMES, recordSize)
            addr = addr + recordSize

        methodTableAddr = self.__classInfo["Address"]["MethodTable"]
        dynamicTableAddr = self.__classInfo["Address"]["DynamicTable"]
        classNameAddr = self.__classInfo["Address"]["ClassName"]

        if (methodTableAddr != 0 and addr < methodTableAddr) or \
           (methodTableAddr == 0 and dynamicTableAddr != 0 and addr < dynamicTableAddr) or \
           (methodTableAddr == 0 and dynamicTableAddr == 0 and addr < classNameAddr):
            ida_bytes.del_items(addr, ida_bytes.DELIT_DELNAMES, 2)
            numOfEntries = Word(addr)
            addr += 2

            for i in range(numOfEntries):
                recordSize = (8 + self.__processorWordSize
                              + Byte(addr + 5 + self.__processorWordSize)
                              + Word(addr + 6 + self.__processorWordSize + Byte(addr + 5 + self.__processorWordSize))
                              - 2)

                ida_bytes.del_items(
                    addr,
                    ida_bytes.DELIT_DELNAMES,
                    recordSize
                )

                addr = addr + recordSize

    def __ExtractTypeName(self, addr: int) -> Optional[str]:
        typeName = None

        if addr == 0:
            typeName = "NoType"
        elif ida_bytes.is_loaded(addr):
            typeInfo = TypeInfo(
                self.__delphiVersion,
                addr + self.__processorWordSize
            )
            typeInfo.MakeTable(1)
            typeName = typeInfo.GetTypeName()
        elif idc.get_segm_name(addr) == ".idata" and ida_name.get_name(addr).startswith("@"):
            typeName = ida_name.get_name(addr)
            typeName = typeName.split('@')[-1]
            typeName = typeName.split('$')[-1]
            typeName = "".join([i for i in typeName if not i.isdigit()])

            if not len(typeName):
                typeName = None

        return typeName

```

`DelphiHelper/core/DelphiClass_InitTable.py`:

```py
#
# This module allows to parse and extract data from Delphi's InitTable
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
from DelphiHelper.core.DelphiClass_TypeInfo import *
from DelphiHelper.util.ida import *


class InitTable(object):

    def __init__(
            self,
            delphiVersion: int,
            classInfo: dict[str, str | dict[str, int]],
            fieldEnum: FieldEnum) -> None:
        self.__tableAddr = classInfo["Address"]["InitTable"]
        self.__fieldEnum = fieldEnum
        self.__tableName = classInfo["Name"]
        self.__processorWordSize = GetProcessorWordSize()
        self.__delphiVersion = delphiVersion

        if self.__tableAddr != 0:
            self.__fieldCount = Word(self.__tableAddr + 6)
            self.__fieldAddr = self.__tableAddr + 8

    def GetTableAddress(self) -> int:
        return self.__tableAddr

    def MakeTable(self) -> None:
        if self.__tableAddr != 0:
            self.__DeleteTable()
            self.__CreateTable()
            self.__ExtractData()

    def __CreateTable(self) -> None:
        MakeWord(self.__tableAddr)
        MakeWord(self.__tableAddr + 2)
        MakeWord(self.__tableAddr + 4)
        MakeWord(self.__tableAddr + 6)
        MakeName(self.__tableAddr, self.__tableName + "_InitTable")

        addr = self.__fieldAddr
        for i in range(self.__fieldCount):
            MakeWord(addr)
            MakeCustomWord(addr + 2, self.__processorWordSize)

            if self.__processorWordSize == 4:
                MakeWord(addr + 6)
                addr += 8
            else:
                MakeWord(addr + 10)
                MakeDword(addr + 12)
                addr += 16

    def __DeleteTable(self) -> None:
        ida_bytes.del_items(self.__tableAddr, ida_bytes.DELIT_DELNAMES, 8)

        addr = self.__fieldAddr
        for i in range(self.__fieldCount):
            if self.__processorWordSize == 4:
                ida_bytes.del_items(addr, ida_bytes.DELIT_DELNAMES, 8)
                addr += 8
            else:
                ida_bytes.del_items(addr, ida_bytes.DELIT_DELNAMES, 16)
                addr += 16

    def __ExtractData(self) -> None:
        if self.__fieldCount != 0:
            addr = self.__fieldAddr

            for i in range(self.__fieldCount):
                typeInfoAddr = GetCustomWord(
                    addr + 2,
                    self.__processorWordSize
                )

                if ida_bytes.is_loaded(typeInfoAddr) and \
                   typeInfoAddr != 0:
                    typeInfo = TypeInfo(
                        self.__delphiVersion,
                        typeInfoAddr + self.__processorWordSize
                    )
                    typeInfo.MakeTable(1)
                    fieldType = typeInfo.GetTypeName()
                    fieldValue = Word(addr + 2 + self.__processorWordSize)

                    self.__fieldEnum.AddMember(
                        fieldType,
                        hex(fieldValue),
                        fieldValue
                    )

                if self.__processorWordSize == 4:
                    addr += 8
                else:
                    addr += 16

```

`DelphiHelper/core/DelphiClass_IntfTable.py`:

```py
#
# This module allows to parse Delphi's IntfTable
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.

import idc
import ida_bytes
from DelphiHelper.core.DelphiClass_TypeInfo import *
from DelphiHelper.util.ida import *


class IntfTable(object):

    def __init__(
            self,
            delphiVersion: int,
            classInfo: dict[str, str | dict[str, int]]) -> None:
        self.__tableAddr = classInfo["Address"]["IntfTable"]
        self.__classAddr = classInfo["Address"]["Class"]
        self.__tableName = classInfo["Name"]
        self.__processorWordSize = GetProcessorWordSize()
        self.__minIntfAddr = 0
        self.__delphiVersion = delphiVersion

        if self.__tableAddr != 0:
            self.__intfCount = Dword(self.__tableAddr)
            self.__typeInfoAddr = (self.__tableAddr
                                   + self.__processorWordSize
                                   + self.__intfCount * (16 + 3 * self.__processorWordSize))

            addr = self.__tableAddr + self.__processorWordSize
            intfList = list()

            for i in range(self.__intfCount):
                if GetCustomWord(addr + 16, self.__processorWordSize) != 0:
                    intf = GetCustomWord(addr + 16, self.__processorWordSize)
                    intfList.append(intf)
                addr += 3 * self.__processorWordSize + 16

            self.__minIntfAddr = 0

            if len(intfList) != 0:
                self.__minIntfAddr = intfList[0]

                for intfAddr in intfList:
                    if intfAddr < self.__minIntfAddr:
                        self.__minIntfAddr = intfAddr

    def GetTableAddress(self) -> int:
        return self.__tableAddr

    def MakeTable(self) -> None:
        if self.__tableAddr != 0:
            self.__DeleteTable()
            self.__CreateTable()

    def __CreateTable(self) -> None:
        MakeCustomWord(self.__tableAddr, self.__processorWordSize)
        MakeName(self.__tableAddr, self.__tableName + "_IntfTable")
        ida_bytes.set_cmt(self.__tableAddr, "Count", 0)

        addr = self.__tableAddr + self.__processorWordSize
        for i in range(self.__intfCount):
            MakeDword(addr)
            idc.make_array(addr, 4)
            MakeName(addr, self.__tableName + "_Interface" + str(i))

            MakeCustomWord(
                addr + 16,
                self.__processorWordSize
            )

            MakeName(
                GetCustomWord(addr + 16, self.__processorWordSize),
                self.__tableName + "_Interface" + str(i) + "_VMT"
            )

            MakeCustomWord(
                addr + self.__processorWordSize + 16,
                self.__processorWordSize
            )

            MakeCustomWord(
                addr + 2 * self.__processorWordSize + 16,
                self.__processorWordSize
            )

            addr += 3 * self.__processorWordSize + 16

        addr = (self.__typeInfoAddr
                + self.__intfCount * self.__processorWordSize)

        if addr <= self.__classAddr:
            addr = self.__typeInfoAddr

            for i in range(self.__intfCount):
                MakeCustomWord(addr, self.__processorWordSize)

                typeInfoAddr = GetCustomWord(addr, self.__processorWordSize)
                if ida_bytes.is_loaded(typeInfoAddr) and \
                   typeInfoAddr != 0 and \
                   "_TypeInfo" not in idc.get_name(typeInfoAddr):
                    typeInfo = TypeInfo(
                        self.__delphiVersion,
                        typeInfoAddr + self.__processorWordSize
                    )
                    typeInfo.MakeTable(1)

                addr += self.__processorWordSize

        if self.__minIntfAddr != 0:
            addr = self.__minIntfAddr

            while addr < self.__tableAddr:
                MakeFunction(GetCustomWord(addr, self.__processorWordSize))
                MakeCustomWord(addr, self.__processorWordSize)
                addr += self.__processorWordSize

        if self.__intfCount != 0:
            ida_bytes.set_cmt(
                self.__tableAddr + self.__processorWordSize,
                "GUID",
                0
            )
            ida_bytes.set_cmt(
                self.__tableAddr + self.__processorWordSize + 16,
                "Interface VMT",
                0
            )
            ida_bytes.set_cmt(
                self.__tableAddr + 2 * self.__processorWordSize + 16,
                "Interface's hidden field offset",
                0
            )
            ida_bytes.set_cmt(
                self.__tableAddr + 3 * self.__processorWordSize + 16,
                "Property implementing interface",
                0
            )

    def __DeleteTable(self) -> None:
        nbytes = ((3 * self.__processorWordSize + 16) * self.__intfCount
                  + self.__processorWordSize)

        ida_bytes.del_items(
            self.__tableAddr,
            ida_bytes.DELIT_DELNAMES,
            nbytes
        )

        addr = (self.__typeInfoAddr
                + self.__intfCount * self.__processorWordSize)

        if addr <= self.__classAddr:
            ida_bytes.del_items(
                self.__typeInfoAddr,
                ida_bytes.DELIT_DELNAMES,
                self.__processorWordSize * self.__intfCount
            )

        offset = self.__minIntfAddr - self.__tableAddr

        if self.__minIntfAddr != 0 and \
           offset % self.__processorWordSize == 0:
            ida_bytes.del_items(
                self.__minIntfAddr,
                ida_bytes.DELIT_DELNAMES,
                self.__tableAddr - self.__minIntfAddr
            )

```

`DelphiHelper/core/DelphiClass_MethodTable.py`:

```py
#
# This module allows to parse Delphi's MethodTable
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.

import ida_bytes
import ida_name
import idc
from DelphiHelper.core.DelphiClass_TypeInfo import *
from DelphiHelper.util.delphi import GetParamRegister
from DelphiHelper.util.ida import *


class MethodTable(object):

    def __init__(
            self,
            delphiVersion: int,
            classInfo: dict[str, str | dict[str, int]]) -> None:
        self.__tableAddr = classInfo["Address"]["MethodTable"]
        self.__tableName = classInfo["Name"]
        self.__classInfo = classInfo
        self.__processorWordSize = GetProcessorWordSize()
        self.__delphiVersion = delphiVersion

    def GetTableAddress(self) -> int:
        return self.__tableAddr

    def MakeTable(self) -> None:
        if self.__tableAddr != 0:
            self.__DeleteTable()
            self.__CreateTable()

    def GetMethods(self) -> list[tuple[str, int]]:
        methodList = list()

        if self.__tableAddr != 0:
            numOfEntries = Word(self.__tableAddr)
            addr = self.__tableAddr + 2

            for i in range(numOfEntries):
                methodAddr = GetCustomWord(addr + 2, self.__processorWordSize)
                methodName = GetStr_PASCAL(addr + 2 + self.__processorWordSize)
                addr += Word(addr)
                methodList.append((methodName, methodAddr))

        return methodList

    def __CreateTable(self) -> None:
        MakeWord(self.__tableAddr)
        MakeName(self.__tableAddr, self.__tableName + "_MethodTable")

        ida_bytes.set_cmt(
            self.__tableAddr,
            "Number of records",
            0
        )

        numOfEntries = Word(self.__tableAddr)
        if numOfEntries != 0:
            ida_bytes.set_cmt(
                self.__tableAddr + 2,
                "Record size",
                0
            )
            ida_bytes.set_cmt(
                self.__tableAddr + 4,
                "Method pointer",
                0
            )
            ida_bytes.set_cmt(
                self.__tableAddr + 4 + self.__processorWordSize,
                "Method Name",
                0
            )

        addr = self.__tableAddr + 2
        for i in range(numOfEntries):
            recordSize = Word(addr)

            MakeWord(addr)
            MakeFunction(GetCustomWord(addr + 2, self.__processorWordSize))
            MakeCustomWord(addr + 2, self.__processorWordSize)
            MakeStr_PASCAL(addr + 2 + self.__processorWordSize)

            name = (self.__tableName
                    + "_"
                    + GetStr_PASCAL(addr + 2 + self.__processorWordSize))

            MakeName(GetCustomWord(addr + 2, self.__processorWordSize), name)

            addr = addr + recordSize

        dynamicTableAddr = self.__classInfo["Address"]["DynamicTable"]
        classNameAddr = self.__classInfo["Address"]["ClassName"]

        if (dynamicTableAddr == 0 and addr < classNameAddr) or \
           (dynamicTableAddr != 0 and addr < dynamicTableAddr):
            numOfEntries = Word(addr)
            MakeWord(addr)
            addr += 2

            for i in range(numOfEntries):
                MakeCustomWord(addr, self.__processorWordSize)
                MakeByte(addr + self.__processorWordSize)
                idc.make_array(addr + self.__processorWordSize, 4)

                recordAddr = GetCustomWord(addr, self.__processorWordSize)
                self.__CreateFunctionRecord(recordAddr)
                addr += 4 + self.__processorWordSize

    def __CreateFunctionRecord(self, addr: int) -> None:
        recordSize = Word(addr)
        funcNameAddr = addr + 2

        MakeWord(addr)

        nameAddr = GetCustomWord(funcNameAddr, self.__processorWordSize)
        name = ida_name.get_name(nameAddr)
        if self.__tableName not in name:
            MakeFunction(GetCustomWord(funcNameAddr, self.__processorWordSize))

        MakeCustomWord(funcNameAddr, self.__processorWordSize)
        MakeStr_PASCAL(funcNameAddr + self.__processorWordSize)
        funcBaseName = GetStr_PASCAL(funcNameAddr + self.__processorWordSize)
        MakeName(addr, "_" + self.__tableName + "_" + funcBaseName)

        funcPrototype = ("void __usercall "
                         + self.__tableName
                         + "_"
                         + funcBaseName
                         + "(")

        size = (3 + self.__processorWordSize
                + Byte(funcNameAddr + self.__processorWordSize))

        if recordSize > size:
            addr += size
            MakeCustomWord(addr, self.__processorWordSize)
            addr += self.__processorWordSize
            MakeDword(addr)
            addr += 4
            MakeByte(addr)

            numOfParams = Byte(addr)
            addr += 1

            if funcBaseName == "Create":
                numOfParams += 1

            for i in range(numOfParams):
                regStr = GetParamRegister(i)

                if i == 1 and funcBaseName == "Create":
                    funcPrototype += "void* ShortInt_Alloc" + regStr
                else:
                    MakeByte(addr)
                    MakeCustomWord(addr + 1, self.__processorWordSize)
                    MakeWord(addr + 1 + self.__processorWordSize)
                    MakeStr_PASCAL(addr + 3 + self.__processorWordSize)

                    wordAddr = (addr + 4
                                + self.__processorWordSize
                                + Byte(addr + 3 + self.__processorWordSize))
                    MakeWord(wordAddr)

                    argTypeInfo = GetCustomWord(
                        addr + 1,
                        self.__processorWordSize
                    )

                    if argTypeInfo == 0:
                        typeName = "NoType"
                    elif ida_bytes.is_mapped(argTypeInfo) and ida_bytes.is_loaded(argTypeInfo):
                        typeInfoAddr = argTypeInfo + self.__processorWordSize
                        typeInfo = TypeInfo(
                            self.__delphiVersion,
                            typeInfoAddr
                        )
                        typeInfo.MakeTable(1)
                        typeName = typeInfo.GetTypeName()
                    else:
                        return

                    paramNameAddr = addr + 3 + self.__processorWordSize
                    paramName = GetStr_PASCAL(paramNameAddr)
                    if paramName is None:
                        paramName = "RetVal"

                    if paramName == "Self" or \
                       idc.get_struc_id(typeName + "_Self") != ida_idaapi.BADADDR:
                        funcPrototype += (typeName
                                          + "_Self* "
                                          + typeName
                                          + "_"
                                          + paramName
                                          + regStr)
                    else:
                        funcPrototype += ("void* "
                                          + typeName
                                          + "_"
                                          + paramName
                                          + regStr)

                    addr = (addr + 6
                            + self.__processorWordSize
                            + Byte(addr + 3 + self.__processorWordSize))

                if i != numOfParams - 1:
                    funcPrototype += ", "

            MakeWord(addr)

        funcPrototype += ");"

        nameAddr = GetCustomWord(funcNameAddr, self.__processorWordSize)
        name = ida_name.get_name(nameAddr)

        if Byte(nameAddr) == 0:
            MakeName(nameAddr, "sub_nullsub")
        else:
            if self.__tableName not in name:
                MakeName(nameAddr, self.__tableName + "_" + funcBaseName)

            idc.SetType(nameAddr, funcPrototype)

    def __DeleteTable(self) -> None:
        ida_bytes.del_items(self.__tableAddr, ida_bytes.DELIT_DELNAMES, 2)

        addr = self.__tableAddr + 2
        numOfEntries = Word(self.__tableAddr)

        for i in range(numOfEntries):
            recordSize = Word(addr)
            ida_bytes.del_items(addr, ida_bytes.DELIT_DELNAMES, recordSize)
            addr = addr + recordSize

        dynamicTableAddr = self.__classInfo["Address"]["DynamicTable"]
        classNameAddr = self.__classInfo["Address"]["ClassName"]

        if (dynamicTableAddr == 0 and addr < classNameAddr) or \
           (dynamicTableAddr != 0 and addr < dynamicTableAddr):
            numOfEntries = Word(addr)
            ida_bytes.del_items(addr, ida_bytes.DELIT_DELNAMES, 2)
            addr += 2

            for i in range(numOfEntries):
                ida_bytes.del_items(
                    addr,
                    ida_bytes.DELIT_DELNAMES,
                    4 + self.__processorWordSize
                )
                ida_bytes.del_items(
                    GetCustomWord(addr, self.__processorWordSize),
                    ida_bytes.DELIT_DELNAMES,
                    Word(GetCustomWord(addr, self.__processorWordSize))
                )
                addr += 4 + self.__processorWordSize

```

`DelphiHelper/core/DelphiClass_TypeInfo.py`:

```py
#
# This module allows to parse and extract data from Delphi's TypeInfo
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import ida_idaapi
import ida_name
from DelphiHelper.core.ClassStruct import *
from DelphiHelper.core.DelphiClass_TypeInfo_tkClass import TypeInfo_tkClass
from DelphiHelper.core.DelphiClass_TypeInfo_tkRecord import TypeInfo_tkRecord
from DelphiHelper.core.FieldEnum import FieldEnum
from DelphiHelper.util.exception import DelphiHelperError
from DelphiHelper.util.ida import *


typeKindList = ["tkUnknown", "tkInteger", "tkChar", "tkEnumeration",
                "tkFloat", "tkString", "tkSet", "tkClass", "tkMethod",
                "tkWChar", "tkLString", "tkLWString", "tkVariant",
                "tkArray", "tkRecord", "tkInterface", "tkInt64",
                "tkDynArray", "tkUString", "tkClassRef", "tkPointer",
                "tkProcedure", "tkMRecord"]

def ParseTypeInfo(addr: int, delphiVersion: int) -> int:
    global typeKindList

    if Byte(addr) and \
       Byte(addr) < len(typeKindList) and \
       Dword(addr - GetProcessorWordSize()) == addr and \
       Byte(addr - GetProcessorWordSize() - 1) == 0:
        typeInfo = TypeInfo(delphiVersion, addr)
        typeInfo.MakeTable()

        if typeKindList[Byte(addr)] == "tkClass":
            typeInfo.ResolveTypeInfo(addr)

        addr += Byte(addr + 1)

    return addr + 1

class TypeInfo(object):

    def __init__(
            self,
            delphiVersion: int,
            addr: int = ida_idaapi.BADADDR,
            fieldEnum: FieldEnum = None,
            classStruct: ClassStruct = None) -> None:
        self.__delphiVersion = delphiVersion
        self.__fieldEnum = fieldEnum
        self.__classStruct = classStruct
        self.__tableAddr = addr
        self.__processorWordSize = GetProcessorWordSize()
        self.__typeName = ""

        if self.__tableAddr and self.__tableAddr != ida_idaapi.BADADDR:
            self.__typeName = GetStr_PASCAL(self.__tableAddr + 1)
            if self.__typeName is None:
                msg = ("TypeInfo: TypeName is None ("
                       + hex(self.__tableAddr)
                       + ").")
                raise DelphiHelperError(msg)

            global typeKindList
            self.__typeKind = Byte(self.__tableAddr)
            if self.__typeKind >= len(typeKindList):
                msg = ("TypeInfo: TypeKind out of range - "
                       + str(self.__typeKind)
                       + " ("
                       + hex(self.__tableAddr)
                       + ").")
                raise DelphiHelperError(msg)

            typeDataAddr = self.__tableAddr + 2 + Byte(self.__tableAddr + 1)

            if typeKindList[self.__typeKind] == "tkClass":
                self.__tkClass = TypeInfo_tkClass(
                    typeDataAddr,
                    self.__typeName,
                    self.__delphiVersion
                )
            elif typeKindList[self.__typeKind] == "tkRecord":
                self.__tkRecord = TypeInfo_tkRecord(
                    typeDataAddr,
                    self.__typeName,
                    self.__delphiVersion
                )

    def GetTableAddress(self) -> int:
        return self.__tableAddr

    def GetTypeName(self) -> str:
        return self.__typeName

    def MakeTable(self, resolveTypeInfoClass: int = 0) -> None:
        if self.__tableAddr and \
           self.__tableAddr != ida_idaapi.BADADDR and \
           ida_bytes.is_loaded(self.__tableAddr) and \
           "_TypeInfo" not in ida_name.get_name(self.__tableAddr):
            print(
                f"[INFO] Processing {self.__typeName}_TypeInfo (0x{self.__tableAddr:X})"
            )
            if resolveTypeInfoClass != 0:
                self.ResolveTypeInfo(self.__tableAddr)
            else:
                self.__DeleteTable()
                self.__CreateTable()
                self.__ExtractData()

    def ResolveTypeInfo(
            self,
            tableAddr: int,
            once: bool = False) -> None:
        if tableAddr == ida_idaapi.BADADDR or \
           tableAddr == 0 or \
           not ida_bytes.is_loaded(tableAddr):
            return

        if once:
            if "_TypeInfo" in ida_name.get_name(tableAddr) or \
               not ida_bytes.is_loaded(tableAddr + self.__processorWordSize):
                return
            tableAddr += self.__processorWordSize

        typeKind = Byte(tableAddr)

        global typeKindList
        if typeKind != 0xff:
            if typeKindList[typeKind] == "tkClass":
                self.__ResolveTypeInfo_tkClass(tableAddr)
            else:
                typeInfo = TypeInfo(
                    self.__delphiVersion,
                    tableAddr
                )
                typeInfo.MakeTable()

    def __ResolveTypeInfo_tkClass(self, tableAddr: int) -> None:
        if self.__processorWordSize == 4:
            ref = FindRef_Dword(
                tableAddr - 4,
                tableAddr,
                ida_bytes.BIN_SEARCH_BACKWARD
            )
        else:
            ref = FindRef_Qword(
                tableAddr - 4,
                tableAddr,
                ida_bytes.BIN_SEARCH_BACKWARD
            )

        if ref != ida_idaapi.BADADDR:
            classAddr = ref - 4 * self.__processorWordSize
            className = ida_name.get_name(classAddr)

            if not className.startswith("VMT_"):
                from DelphiHelper.core.DelphiClass import DelphiClass
                delphiClass = DelphiClass(
                    classAddr,
                    self.__delphiVersion
                )
                delphiClass.MakeClass()        

    def __CreateTableHeader(self) -> None:
        MakeByte(self.__tableAddr)

        global typeKindList
        if self.__typeKind < len(typeKindList):
            ida_bytes.set_cmt(
                self.__tableAddr,
                "Type kind - " + typeKindList[self.__typeKind],
                0
            )
        else:
            ida_bytes.set_cmt(
                self.__tableAddr,
                "Type kind - UNKNOWN",
                0
            )

        if Byte(self.__tableAddr + 1):
            MakeStr_PASCAL(self.__tableAddr + 1)
            ida_bytes.set_cmt(self.__tableAddr + 1, "Type name", 0)

            MakeName(self.__tableAddr, self.__typeName + "_TypeInfo")

            addr = GetCustomWord(
                self.__tableAddr - self.__processorWordSize,
                self.__processorWordSize
            )

            if addr == self.__tableAddr:
                MakeCustomWord(
                    self.__tableAddr - self.__processorWordSize,
                    self.__processorWordSize
                )
                MakeName(
                    self.__tableAddr - self.__processorWordSize,
                    "_" + self.__typeName + "_TypeInfo"
                )

    def __CreateTable(self) -> None:
        self.__CreateTableHeader()

        global typeKindList
        if typeKindList[self.__typeKind] == "tkClass":
            self.__tkClass.CreateTypeData()
        elif typeKindList[self.__typeKind] == "tkRecord":
            self.__tkRecord.CreateTypeData()

    def __DeleteTableHeader(self) -> None:
        ida_bytes.del_items(
            self.__tableAddr,
            ida_bytes.DELIT_DELNAMES,
            1
        )
        ida_bytes.del_items(
            self.__tableAddr + 1,
            ida_bytes.DELIT_DELNAMES,
            1 + Byte(self.__tableAddr + 1)
        )

        addr = GetCustomWord(
            self.__tableAddr - self.__processorWordSize,
            self.__processorWordSize
        )

        if addr == self.__tableAddr:
            ida_bytes.del_items(
                self.__tableAddr - self.__processorWordSize,
                ida_bytes.DELIT_DELNAMES,
                self.__processorWordSize
            )

    def __DeleteTable(self) -> None:
        self.__DeleteTableHeader()

        global typeKindList
        if typeKindList[self.__typeKind] == "tkClass":
            self.__tkClass.DeleteTypeData()
        elif typeKindList[self.__typeKind] == "tkRecord":
            self.__tkRecord.DeleteTypeData()

    def __ExtractData(self) -> None:
        global typeKindList
        if typeKindList[self.__typeKind] == "tkClass":
            self.__tkClass.ExtractData_TypeData(
                self.__fieldEnum,
                self.__classStruct
            )

```

`DelphiHelper/core/DelphiClass_TypeInfo_tkClass.py`:

```py
#
# This module allows to parse and extract data from Delphi's TypeInfo tkClass
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import ida_name
from DelphiHelper.core.ClassStruct import *
from DelphiHelper.core.FieldEnum import FieldEnum
from DelphiHelper.util.ida import *


class TypeInfo_tkClass(object):

    def __init__(
            self,
            typeDataAddr: int,
            typeName: str,
            delphiVersion: int) -> None:
        self.__delphiVersion = delphiVersion
        self.__fieldEnum = None
        self.__processorWordSize = GetProcessorWordSize()
        self.__typeName = typeName
        self.__typeDataAddr = typeDataAddr
        self.__propDataAddr = (typeDataAddr
                               + 2 * self.__processorWordSize
                               + 3
                               + Byte(typeDataAddr + 2 * self.__processorWordSize + 2))

    def CreateTypeData(self) -> None:
        addr = self.__typeDataAddr

        MakeCustomWord(addr, self.__processorWordSize)
        ida_bytes.set_cmt(addr, "TypeData.ClassType", 0)

        addr += self.__processorWordSize
        MakeCustomWord(addr, self.__processorWordSize)
        ida_bytes.set_cmt(addr, "TypeData.ParentInfo", 0)

        typeInfoAddr = GetCustomWord(addr, self.__processorWordSize)
        from DelphiHelper.core.DelphiClass_TypeInfo import TypeInfo
        typeInfo = TypeInfo(self.__delphiVersion)
        typeInfo.ResolveTypeInfo(typeInfoAddr, True)

        addr += self.__processorWordSize
        MakeWord(addr)
        ida_bytes.set_cmt(addr, "TypeData.PropCount", 0)

        addr += 2
        MakeStr_PASCAL(addr)
        ida_bytes.set_cmt(addr, "TypeData.UnitName", 0)

        MakeWord(self.__propDataAddr)
        ida_bytes.set_cmt(self.__propDataAddr, "TypeData.PropData.PropCount", 0)

        propCount = Word(self.__propDataAddr)
        addr = self.__propDataAddr + 2

        for i in range(propCount):
            addr = self.__CreatePropDataRecord(addr)

        propCount = Word(addr)

        if propCount != 0 and propCount <= 0xff:
            if (Byte(addr + 2) == 2) or (Byte(addr + 2) == 3):
                MakeWord(addr)
                addr += 2

                for i in range(propCount):
                    MakeByte(addr)
                    MakeCustomWord(addr + 1, self.__processorWordSize)

                    nameAddr = GetCustomWord(addr + 1, self.__processorWordSize)
                    name = ida_name.get_name(nameAddr)
                    if self.__typeName not in name:
                        propDataRecordAddr = GetCustomWord(
                            addr + 1,
                            self.__processorWordSize
                        )
                        self.__CreatePropDataRecord(propDataRecordAddr)

                    MakeWord(addr + 1 + self.__processorWordSize)
                    addr += (1 + self.__processorWordSize
                             + Word(addr + 1 + self.__processorWordSize))

    def __CreatePropDataRecord(self, addr: int) -> None:
        nameAddr = addr + 4 * self.__processorWordSize + 10
        recordSize = 4 * self.__processorWordSize + 11 + Byte(nameAddr)
        nextRecordAddr = addr + recordSize

        typeInfoAddr = GetCustomWord(addr, self.__processorWordSize)
        from DelphiHelper.core.DelphiClass_TypeInfo import TypeInfo
        typeInfo = TypeInfo(self.__delphiVersion)
        typeInfo.ResolveTypeInfo(typeInfoAddr, True)

        MakeCustomWord(addr, self.__processorWordSize)
        ida_bytes.set_cmt(addr, "TypeData.PropData.PropType", 0)

        addr += self.__processorWordSize
        MakeCustomWord(addr, self.__processorWordSize)
        ida_bytes.set_cmt(addr, "TypeData.PropData.GetProc", 0)

        shiftCount = (self.__processorWordSize - 1) * 8
        bitmask = GetCustomWord(addr, self.__processorWordSize) >> shiftCount
        if bitmask & 0xC0 == 0:
            MakeName(
                GetCustomWord(addr, self.__processorWordSize),
                self.__typeName + "_Get" + GetStr_PASCAL(nameAddr)
            )

        addr += self.__processorWordSize
        MakeCustomWord(addr, self.__processorWordSize)
        ida_bytes.set_cmt(addr, "TypeData.PropData.SetProc", 0)

        bitmask = GetCustomWord(addr, self.__processorWordSize) >> shiftCount
        if bitmask & 0xC0 == 0:
            MakeName(
                GetCustomWord(addr, self.__processorWordSize),
                self.__typeName + "_Set" + GetStr_PASCAL(nameAddr)
            )

        addr += self.__processorWordSize
        MakeCustomWord(addr, self.__processorWordSize)
        ida_bytes.set_cmt(addr, "TypeData.PropData.StoredProc", 0)

        addr += self.__processorWordSize
        MakeDword(addr)
        ida_bytes.set_cmt(addr, "TypeData.PropData.Index", 0)

        addr += 4
        MakeDword(addr)
        ida_bytes.set_cmt(addr, "TypeData.PropData.Default", 0)

        addr += 4
        MakeWord(addr)
        ida_bytes.set_cmt(addr, "TypeData.PropData.NameIndex", 0)

        MakeStr_PASCAL(nameAddr)
        ida_bytes.set_cmt(nameAddr, "TypeData.PropData.Name", 0)

        MakeName(
            nextRecordAddr - recordSize,
            self.__typeName + "_" + GetStr_PASCAL(nameAddr)
        )

        return nextRecordAddr

    def DeleteTypeData(self) -> None:
        size = (2 * self.__processorWordSize
                + 5
                + Byte(self.__typeDataAddr + 2 * self.__processorWordSize + 2))

        ida_bytes.del_items(
            self.__typeDataAddr,
            ida_bytes.DELIT_DELNAMES,
            size
        )

        propCount = Word(self.__propDataAddr)
        addr = self.__propDataAddr + 2

        for i in range(propCount):
            addr = self.__DeletePropDataRecord(addr)

        propCount = Word(addr)

        if propCount != 0:
            if Byte(addr + 2) == 2 or Byte(addr + 2) == 3:
                ida_bytes.del_items(addr, ida_bytes.DELIT_DELNAMES, 2)
                addr += 2

                for i in range(propCount):
                    ida_bytes.del_items(
                        addr,
                        ida_bytes.DELIT_DELNAMES,
                        3 + self.__processorWordSize
                    )

                    propDataRecordAddr = GetCustomWord(
                        addr + 1,
                        self.__processorWordSize
                    )
                    self.__DeletePropDataRecord(propDataRecordAddr)

                    addr += (self.__processorWordSize
                             + 1
                             + Word(addr + self.__processorWordSize + 1))

    def __DeletePropDataRecord(self, addr: int) -> int:
        recordSize = (4 * self.__processorWordSize
                      + 11
                      + Byte(addr + 4 * self.__processorWordSize + 10))
        ida_bytes.del_items(addr, ida_bytes.DELIT_DELNAMES, recordSize)
        return addr + recordSize

    def ExtractData_TypeData(
            self,
            fieldEnum: FieldEnum,
            classStruct: ClassStruct) -> None:
        self.__fieldEnum = fieldEnum
        self.__classStruct = classStruct

        if self.__fieldEnum is None or self.__classStruct is None:
            return

        propCount = Word(self.__propDataAddr)
        addr = self.__propDataAddr + 2

        for i in range(propCount):
            addr = self.__ExtractData_PropDataRecord(addr)

        propCount = Word(addr)

        if propCount != 0 and \
           propCount <= 0xff and \
           (Byte(addr + 2) == 2 or Byte(addr + 2) == 3):
            addr += 2

            for i in range(propCount):
                propDataRecordAddr = GetCustomWord(
                    addr + 1,
                    self.__processorWordSize
                )
                self.__ExtractData_PropDataRecord(propDataRecordAddr)

                addr += (self.__processorWordSize
                         + 1
                         + Word(addr + self.__processorWordSize + 1))

    def __ExtractData_PropDataRecord(self, addr: int) -> int:
        nameAddr = addr + 4 * self.__processorWordSize + 10
        getProcEntry = GetCustomWord(
            addr + self.__processorWordSize,
            self.__processorWordSize
        )
        setProcEntry = GetCustomWord(
            addr + 2 * self.__processorWordSize,
            self.__processorWordSize
        )
        recordSize = 4 * self.__processorWordSize + 11 + Byte(nameAddr)
        shiftVal = (self.__processorWordSize - 1) * 8

        if self.__processorWordSize == 4:
            mask1 = 0x00FFFFFF
        else:
            mask1 = 0x00FFFFFFFFFFFFFF

        typeInfoAddr = GetCustomWord(addr, self.__processorWordSize)

        if ida_bytes.is_loaded(typeInfoAddr) and typeInfoAddr != 0:
            from DelphiHelper.core.DelphiClass_TypeInfo import TypeInfo
            typeInfo = TypeInfo(
                self.__delphiVersion,
                typeInfoAddr + self.__processorWordSize
            )
            typeName = typeInfo.GetTypeName()

            if ((getProcEntry >> shiftVal) & 0xF0 != 0) and \
               ((setProcEntry >> shiftVal) & 0xF0 != 0):
                if getProcEntry == setProcEntry:
                    self.__fieldEnum.AddMember(
                        typeName,
                        GetStr_PASCAL(nameAddr),
                        setProcEntry & mask1
                    )
                else:
                    self.__fieldEnum.AddMember(
                        typeName,
                        GetStr_PASCAL(nameAddr) + "_Get",
                        getProcEntry & mask1
                    )
                    self.__fieldEnum.AddMember(
                        typeName,
                        GetStr_PASCAL(nameAddr) + "_Set",
                        setProcEntry & mask1
                    )
            else:
                if (getProcEntry >> shiftVal) & 0xF0 != 0:
                    self.__fieldEnum.AddMember(
                        typeName,
                        GetStr_PASCAL(nameAddr),
                        getProcEntry & mask1
                    )
                if (setProcEntry >> shiftVal) & 0xF0 != 0:
                    self.__fieldEnum.AddMember(
                        typeName,
                        GetStr_PASCAL(nameAddr),
                        setProcEntry & mask1
                    )

            if ((getProcEntry >> shiftVal) == 0xFF):
                self.__classStruct.AddMember(
                    typeName,
                    GetStr_PASCAL(nameAddr),
                    getProcEntry & mask1
                )
            if ((setProcEntry >> shiftVal) == 0xFF):
                self.__classStruct.AddMember(
                    typeName,
                    GetStr_PASCAL(nameAddr),
                    setProcEntry & mask1
                )

        return addr + recordSize

```

`DelphiHelper/core/DelphiClass_TypeInfo_tkRecord.py`:

```py
#
# This module allows to parse and extract data from Delphi's TypeInfo tkRecord
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import ida_funcs
import idc
from DelphiHelper.util.delphi import GetParamRegister
from DelphiHelper.util.ida import *


class TypeInfo_tkRecord(object):

    def __init__(
            self,
            typeDataAddr: int,
            typeName: str,
            delphiVersion: int) -> None:
        self.__processorWordSize = GetProcessorWordSize()
        self.__typeDataAddr = typeDataAddr

        if len(typeName) == 0:
             self.__typeName = "Record_" + hex(self.__typeDataAddr)
        else:
            self.__typeName = typeName
        self.__delphiVersion = delphiVersion

    def CreateTypeData(self) -> None:
        addr = self.__typeDataAddr

        MakeDword(addr)
        ida_bytes.set_cmt(addr, "TypeData.Size", 0)
        addr += 4

        addr = self.__CreateManagedFields(addr)

        if self.__delphiVersion != -1 and self.__delphiVersion >= 2010:
            MakeByte(addr)
            ida_bytes.set_cmt(addr, "TypeData.NumOps", 0)
            numOps = Byte(addr)
            addr += 1

            if numOps:
                ida_bytes.set_cmt(addr, "TypeData.RecOps", 0)
                print("WARNING WARNING TypeData.RecOps")

                for i in range(numOps):
                    MakeCustomWord(addr, self.__processorWordSize)
                    addr += self.__processorWordSize

            addr = self.__CreateRecordTypeField(addr)

            MakeWord(addr)
            ida_bytes.set_cmt(addr, "TypeData.RecAttrData", 0)
            addr += Word(addr)

            if self.__delphiVersion >= 2012:
                addr = self.__CreateRecordTypeMethod(addr)

    def __CreateRecordTypeMethod(self, addr: int) -> int:
        MakeWord(addr)
        ida_bytes.set_cmt(addr, "TypeData.RecMethCnt", 0)
        recMethCnt = Word(addr)
        addr += 2

        if recMethCnt and recMethCnt <= 4096:
            ida_bytes.set_cmt(addr, "TypeData.RecMeths", 0)

            for i in range(recMethCnt):
                # Flags
                ida_bytes.set_cmt(addr, "TypeData.RecMeths.Flags", 0)
                MakeByte(addr)

                # Code
                MakeCustomWord(addr + 1, self.__processorWordSize)
                ida_bytes.set_cmt(addr + 1, "TypeData.RecMeths.Code", 0)
                funcAddr = GetCustomWord(addr + 1, self.__processorWordSize)

                # Name
                MakeStr_PASCAL(addr + 1 + self.__processorWordSize)
                nameSize = Byte(addr + 1 + self.__processorWordSize)
                funcName = GetStr_PASCAL(addr + 1 + self.__processorWordSize)
                ida_bytes.set_cmt(
                    addr + 1 + self.__processorWordSize,
                    "TypeData.RecMeths.Name",
                    0
                )

                if len(funcName) == 0:
                    funcName = hex(funcAddr)

                MakeName(addr, self.__typeName + "_RecMeth_" + funcName)

                addr += 2 + self.__processorWordSize + nameSize
                # ProcedureSignature
                # Flags
                MakeByte(addr)
                ida_bytes.set_cmt(
                    addr,
                    "TypeData.RecMeths.ProcedureSignature.Flags",
                    0
                )

                funcRetType = "NoType"
                funcParamList = list()

                if Byte(addr) != 0xFF:
                    # CC
                    MakeByte(addr + 1)
                    ida_bytes.set_cmt(
                        addr + 1,
                        "TypeData.RecMeths.ProcedureSignature.CC",
                        0
                    )

                    # ResultType
                    typeInfoAddr = GetCustomWord(
                        addr + 2,
                        self.__processorWordSize
                    )
                    MakeCustomWord(addr + 2, self.__processorWordSize)
                    ida_bytes.set_cmt(
                        addr + 2,
                        "TypeData.RecMeths.ProcedureSignature.ResultType",
                        0
                    )

                    if typeInfoAddr and \
                       ida_bytes.is_mapped(typeInfoAddr) and \
                       ida_bytes.is_loaded(typeInfoAddr):
                        from DelphiHelper.core.DelphiClass_TypeInfo import TypeInfo
                        typeInfoAddr += self.__processorWordSize
                        typeInfo = TypeInfo(self.__delphiVersion, typeInfoAddr)
                        typeInfo.MakeTable(1)
                        funcRetType = typeInfo.GetTypeName()

                    # ParamCnt
                    MakeByte(addr + 2 + self.__processorWordSize)
                    paramCnt = Byte(addr + 2 + self.__processorWordSize)
                    ida_bytes.set_cmt(
                        addr + 2 + self.__processorWordSize,
                        "TypeData.RecMeths.ProcedureSignature.ParamCnt",
                        0
                    )

                    addr += 3 + self.__processorWordSize

                    # Params
                    for i in range(paramCnt):
                        addr, funcParam = self.__CreateProcedureParam(addr)
                        funcParamList.append(funcParam)
                else:
                    addr += 1

                # AttrData
                MakeWord(addr)
                ida_bytes.set_cmt(
                    addr,
                    "TypeData.RecMeths.ProcedureSignature.AttrData",
                    0
                )
                addr += Word(addr)

                self.__ProcessRecordMethod(
                    funcAddr,
                    funcName,
                    funcRetType,
                    funcParamList
                )

        return addr

    def __ProcessRecordMethod(
            self,
            funcAddr: int,
            funcName: str,
            funcRetType: str,
            funcParamList: list[(str, str)]) -> None:
        if funcAddr == 0 or \
           ida_name.get_name(funcAddr).startswith("sub_nullsub") or \
           ida_name.get_name(funcAddr).startswith(self.__typeName):
            return

        if Byte(funcAddr) == 0:
            MakeName(funcAddr, "sub_nullsub")
        else:
            MakeFunction(funcAddr)

            funcFullName = self.__typeName + "_" + funcName
            MakeName(funcAddr, funcFullName)

            if len(funcParamList):
                functionCmt = self.__typeName + "::" + funcName + "("
                for funcType, funcName in funcParamList:
                    functionCmt += funcType + " " + funcName + ","
                functionCmt = functionCmt[:-1] + ")"
            else:
                functionCmt = self.__typeName + "::" + funcName + "()"

            if funcRetType != "NoType":
                functionCmt += ":" + funcRetType

            ida_funcs.set_func_cmt(
                funcAddr,
                functionCmt,
                1
            )

            funcPrototype = "void __usercall " + FixName(funcFullName) + "("
            for i in range(len(funcParamList)):
                funcPrototype += ("void* "
                                  + funcParamList[i][0]
                                  + "_"
                                  + funcParamList[i][1]
                                  + GetParamRegister(i))

                if i != len(funcParamList) - 1:
                    funcPrototype += ", "

            funcPrototype += ");"

            idc.SetType(funcAddr, funcPrototype)

    def __CreateProcedureParam(self, addr: int) -> (int, (str, str)):
        # Flags
        MakeByte(addr)
        ida_bytes.set_cmt(
            addr,
            "TypeData.RecMeths.ProcedureSignature.ProcedureParam.Flags",
            0
        )

        # ParamType
        typeInfoAddr = GetCustomWord(addr + 1, self.__processorWordSize)
        MakeCustomWord(addr + 1, self.__processorWordSize)
        ida_bytes.set_cmt(
            addr + 1,
            "TypeData.RecMeths.ProcedureSignature.ProcedureParam.ParamType",
            0
        )

        paramType = "NoType"
        if typeInfoAddr and \
           ida_bytes.is_mapped(typeInfoAddr) and \
           ida_bytes.is_loaded(typeInfoAddr):
            from DelphiHelper.core.DelphiClass_TypeInfo import TypeInfo
            typeInfoAddr += self.__processorWordSize
            typeInfo = TypeInfo(self.__delphiVersion, typeInfoAddr)
            typeInfo.MakeTable(1)
            paramType = typeInfo.GetTypeName()

        # Name
        MakeStr_PASCAL(addr + 1 + self.__processorWordSize)
        nameSize = Byte(addr + 1 + self.__processorWordSize)
        paramName = GetStr_PASCAL(addr + 1 + self.__processorWordSize)
        ida_bytes.set_cmt(
            addr + 1 + self.__processorWordSize,
            "TypeData.RecMeths.ProcedureSignature.ProcedureParam.Name",
            0
        )

        # AttrData
        MakeWord(addr + 2 + self.__processorWordSize + nameSize)
        ida_bytes.set_cmt(
            addr + 2 + self.__processorWordSize + nameSize,
            "TypeData.RecMeths.ProcedureSignature.ProcedureParam.AttrData",
            0
        )

        if len(paramName) == 0:
            paramName = "UnknownParam"

        return addr + 4 + self.__processorWordSize + nameSize, (paramType, paramName)

    def __CreateManagedFields(self, addr: int) -> int:
        MakeDword(addr)
        ida_bytes.set_cmt(addr, "TypeData.ManagedFieldCount", 0)
        managedFieldCount = Dword(addr)
        addr += 4

        if managedFieldCount:
            ida_bytes.set_cmt(addr, "TypeData.ManagedFields", 0)

            for i in range(managedFieldCount):
                typeInfoAddr = GetCustomWord(addr, self.__processorWordSize)
                from DelphiHelper.core.DelphiClass_TypeInfo import TypeInfo
                typeInfo = TypeInfo(self.__delphiVersion)
                typeInfo.ResolveTypeInfo(typeInfoAddr, True) 

                MakeCustomWord(addr, self.__processorWordSize)
                MakeCustomWord(
                    addr + self.__processorWordSize,
                    self.__processorWordSize
                )
                addr += 2 * self.__processorWordSize

        return addr

    def __CreateRecordTypeField(self, addr: int) -> int:
        MakeDword(addr)
        ida_bytes.set_cmt(addr, "TypeData.RecFldCnt", 0)
        recFldCnt = Dword(addr)
        addr += 4

        for i in range(recFldCnt):
            typeInfoAddr = GetCustomWord(addr, self.__processorWordSize)
            from DelphiHelper.core.DelphiClass_TypeInfo import TypeInfo
            typeInfo = TypeInfo(self.__delphiVersion)
            typeInfo.ResolveTypeInfo(typeInfoAddr, True)                

            # TypeRef
            MakeCustomWord(addr, self.__processorWordSize)
            ida_bytes.set_cmt(addr, "TypeData.RecField.TypeRef", 0)

            # FldOffset
            MakeCustomWord(
                addr + self.__processorWordSize,
                self.__processorWordSize
            )
            ida_bytes.set_cmt(
                addr + self.__processorWordSize,
                "TypeData.RecField.FldOffset",
                0
            )

            # Flags
            MakeByte(addr + 2 * self.__processorWordSize)
            ida_bytes.set_cmt(
                addr + 2 * self.__processorWordSize,
                "TypeData.RecField.Flags",
                0
            )

            # Name
            MakeStr_PASCAL(addr + 2 * self.__processorWordSize + 1)
            fieldName = GetStr_PASCAL(addr + 2 * self.__processorWordSize + 1)
            fieldNameSize = Byte(addr + 2 * self.__processorWordSize + 1)
            ida_bytes.set_cmt(
                addr + 2 * self.__processorWordSize + 1,
                "TypeData.RecField.Name",
                0
            )

            # AttrData
            MakeWord(addr + 2 * self.__processorWordSize + 2 + fieldNameSize)
            attrDataSize = Word(addr + 2 * self.__processorWordSize + 2 + fieldNameSize)
            ida_bytes.set_cmt(
                addr + 2 * self.__processorWordSize + 2 + fieldNameSize,
                "TypeData.RecField.AttrData",
                0
            )

            if len(fieldName) == 0:
                fieldName = hex(addr)

            MakeName(addr, self.__typeName + "_RecField_" + fieldName)
            addr += 2 * self.__processorWordSize + 2 + fieldNameSize + attrDataSize

        return addr

    def DeleteTypeData(self) -> None:
        managedFieldsSize = 0
        if Dword(self.__typeDataAddr + 4):
            managedFieldsSize = Dword(self.__typeDataAddr + 4) * 2 * self.__processorWordSize

        addr = self.__typeDataAddr + 8 + managedFieldsSize

        if self.__delphiVersion != -1 and self.__delphiVersion >= 2010:
            numOps = Byte(addr)
            addr += 1 + numOps * self.__processorWordSize + 4

            for i in range(Dword(addr - 4)):
                fieldNameSize = Byte(addr + 2 * self.__processorWordSize + 1)
                attrDataSize = Word(addr + 2 * self.__processorWordSize + 2 + fieldNameSize)
                addr += 2 * self.__processorWordSize + 2 + fieldNameSize + attrDataSize

            addr += Word(addr)

            if self.__delphiVersion >= 2012:
                recMethCnt = Word(addr)
                addr += 2

                if recMethCnt and recMethCnt <= 4096:
                    for i in range(recMethCnt):
                        addr += 1 + self.__processorWordSize
                        addr += 2 + Byte(addr)

                        if Byte(addr - 1) != 0xFF:
                            addr += 2 + self.__processorWordSize
                            for y in range(Byte(addr - 1)):
                                addr += 1 + self.__processorWordSize
                                addr += 3 + Byte(addr)
                        addr += Word(addr)

        ida_bytes.del_items(
            self.__typeDataAddr,
            ida_bytes.DELIT_DELNAMES,
            addr - self.__typeDataAddr
        )

```

`DelphiHelper/core/DelphiClass_VMTTable.py`:

```py
#
# This module allows to parse and extract data from Delphi's VMTTable
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes

from DelphiHelper.core.FuncStruct import FuncStruct
from DelphiHelper.util.delphi import DemangleFuncName
from DelphiHelper.util.ida import (
    GetCustomWord,
    GetProcessorWordSize,
    MakeCustomWord,
    MakeFunction,
    MakeName,
)


class VMTTable(object):

    def __init__(
            self,
            classInfo: dict[str, str | dict[str, int]],
            funcStruct: FuncStruct) -> None:
        self.__tableAddr: int = classInfo["Address"]["VMTTable"]
        self.__tableName = classInfo["Name"]
        self.__funcStruct = funcStruct
        self.__processorWordSize = GetProcessorWordSize()

        if classInfo["Address"]["InitTable"] != 0:
            self.__tableEndAddr = classInfo["Address"]["InitTable"]
        elif classInfo["Address"]["FieldTable"] != 0:
            self.__tableEndAddr = classInfo["Address"]["FieldTable"]
        elif classInfo["Address"]["MethodTable"] != 0:
            self.__tableEndAddr = classInfo["Address"]["MethodTable"]
        elif classInfo["Address"]["DynamicTable"] != 0:
            self.__tableEndAddr = classInfo["Address"]["DynamicTable"]
        elif classInfo["Address"]["ClassName"] != 0:
            self.__tableEndAddr = classInfo["Address"]["ClassName"]
        else:
            self.__tableEndAddr = self.__tableAddr

    def GetTableAddress(self) -> int:
        return self.__tableAddr

    def MakeTable(self) -> None:
        if self.__tableAddr != 0:
            self.__DeleteTable()
            self.__CreateTableAndExtractData()

    def __CreateTableAndExtractData(self) -> None:
        MakeName(self.__tableAddr, f"{self.__tableName}_VMT")

        offset = 0
        while self.__tableAddr + offset < self.__tableEndAddr:
            funcAddr = GetCustomWord(
                self.__tableAddr + offset,
                self.__processorWordSize
            )

            MakeFunction(funcAddr)
            DemangleFuncName(funcAddr)
            MakeCustomWord(self.__tableAddr + offset, self.__processorWordSize)

            ida_bytes.set_cmt(
                self.__tableAddr + offset,
                "'+" + ("%x" % offset).upper() + "'",
                0
            )

            self.__funcStruct.AddMember(funcAddr, offset)

            offset += self.__processorWordSize

    def __DeleteTable(self) -> None:
        ida_bytes.del_items(
            self.__tableAddr,
            ida_bytes.DELIT_DELNAMES,
            self.__tableEndAddr - self.__tableAddr
        )

```

`DelphiHelper/core/DelphiForm.py`:

```py
#
# This module implements DelphiObject and DelphiProperty classes storing data
# extracted from Delphi's DFM
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


from __future__ import annotations
import hashlib
import ida_loader
import idautils
import os
import struct


PropertyTypes = ["Null", "List", "Int8", "Int16", "Int32", "Extended",
                 "String", "Ident", "False", "True", "Binary", "Set",
                 "LString", "Nil", "Collection", "Single", "Currency", "Date",
                 "WString", "Int64", "UTF8String", "Double"]


class DelphiProperty(object):

    def __init__(
            self,
            name: str,
            propType: int,
            value: bytes | int | list | str,
            parentObj: DelphiObject) -> None:
        self.__type = propType
        self.__name = name
        self.__value = value
        self.__parentObj = parentObj

    def GetType(self) -> int:
        return self.__type

    def GetTypeAsString(self) -> str:
        return PropertyTypes[self.__type]

    def GetName(self) -> str:
        return self.__name

    def GetParentObjName(self) -> str:
        return self.__parentObj.GetObjectName()

    def GetParentClassName(self) -> str:
        return self.__parentObj.GetClassName()

    def GetValue(self) -> bytes | int | list | str:
        return self.__value

    def GetValueAsString(self, flag: int = 0) -> None:
        return self.__PrintValue(self.__value, self.__type, flag)

    def PrintPropertyInfo(self, indentation: str) -> None:
        """Print Property Info"""

        # Binary
        if self.__type == 10:
            print(f"{indentation}{self.__name} = Binary data ... ({PropertyTypes[self.__type]})")
        else:
            print(f"{indentation}{self.__name} = {self.__PrintValue(self.__value, self.__type)} ({PropertyTypes[self.__type]})")

    def __PrintValue(
            self,
            data: bytes | int | list | str,
            dataType: int,
            flag: int = 0) -> str:
        match dataType:
            case 0:
                # "Null"
                return "Null"
            case 1:
                # "List"
                return self.__PrintList(data)
            case 2:
                # "Int8"
                return str(data)
            case 3:
                # "Int16"
                return str(data)
            case 4:
                # "Int32"
                return str(data)
            case 5:
                # "Extended"
                return self.__PrintExtended(data)
            case 6:
                # "String"
                return self.__PrintString(data)
            case 7:
                # "Ident"
                return data.decode()
            case 8:
                # "False"
                return "False"
            case 9:
                # "True"
                return "True"
            case 10:
                # "Binary"
                return self.__PrintBinary(data, flag)
            case 11:
                # "Set"
                return self.__PrintSet(data)
            case 12:
                # "LString"
                return self.__PrintString(data)
            case 13:
                # "Nil"
                return "Nil"
            case 14:
                # "Collection"
                return self.__PrintCollection(data)
            case 15:
                # "Single"
                return str(struct.unpack("f", data)[0])
            case 16:
                # "Currency"
                return str(struct.unpack("d", data)[0])
            case 17:
                # "Date"
                return str(struct.unpack("d", data)[0])
            case 18:
                # "WString"
                return self.__PrintWString(data)
            case 19:
                # "Int64"
                return str(struct.unpack("q", data)[0])
            case 20:
                # "UTF8String"
                return self.__PrintString(data)
            case 21:
                # "Double"
                return str(struct.unpack("d", data)[0])
            case _:
                return ""

    def __PrintExtended(self, data: bytes) -> str:
        strValue = str()

        for a in data:
            strValue += "%02X" % (a)

        return strValue

    def __PrintBinary(self, data: bytes, flag: int = 0) -> str:
        if flag == 1:
            hashSha1 = hashlib.sha1()
            hashSha1.update(data)
            return hashSha1.hexdigest().upper()
        else:
            return self.__SaveDataToFile(data)

    def __PrintList(self, listData: list) -> str:
        if len(listData) == 0:
            strValue = "[]"
        else:
            strValue = "["

            for item in listData:
                strValue += self.__PrintValue(item[0], item[1]) + ", "

            strValue = strValue[:-2] + "]"

        return strValue

    def __PrintCollection(self, data: list) -> str:
        if len(data) == 0:
            return "<>"
        else:
            strValue = "<"

            for collectionElem in data:
                if collectionElem[0] is not None:
                    strValue += " [" + str(collectionElem[0]) + "]: "

                if len(collectionElem[1]) != 0:
                    for attrElem in collectionElem[1]:
                        strValue += (attrElem[0]
                                     + "="
                                     + self.__PrintValue(attrElem[1], attrElem[2])
                                     + " | ")

                    strValue = strValue[:-3]

                strValue += ", "

            return strValue[:-2] + ">"

    def __PrintSet(self, data: list) -> str:
        if len(data) == 0:
            return "()"
        else:
            strValue = str()

            for elem in data:
                strValue += elem.decode() + ", "

            strValue = "(" + strValue[: -2] + ")"
            return strValue

    def __PrintString(self, rawdata: bytes) -> str:
        if len(rawdata) == 0:
            strValue = "\'\'"
        else:
            strValue = str(rawdata)[1:]

        return strValue

    def __PrintWString(self, rawData: bytes) -> str:
        data = list()

        for i in range(len(rawData) // 2):
            value = rawData[i*2] + (rawData[i*2 + 1] << 8)
            data.append(value)

        if len(data) == 0:
            strValue = "\'\'"
        else:
            strValue = "\'"

            for a in data:
                if a > 31 and a < 127:
                    strValue += str(chr(a))
                else:
                    strValue += "\\u%04x" % (a)

            strValue += "\'"

        return strValue

    def __SaveDataToFile(self, data: bytes) -> str:
        """ Save extracted data to folder, the folder name is derived from the
        file name of the binary. i.e: file.exe -> _extracted_file_exe

        Args:
            data (bytes): data to save to the folder.

        Returns:
            path (str): return path of the folder.

        """
        binaryFileName = ida_loader.get_path(ida_loader.PATH_TYPE_IDB)
        if binaryFileName.endswith(".idb") or binaryFileName.endswith(".i64"):
            binaryFileName = binaryFileName[:-4]
        binaryFileName = binaryFileName[binaryFileName.rfind(os.path.sep) + 1:]

        dataDir = os.path.abspath(idautils.GetIdbDir())
        if not os.path.isdir(dataDir):
            print(f"[ERROR] No such directory: \"{dataDir}\". Trying to create it...")

            try:
                os.mkdir(dataDir)
            except FileNotFoundError:
                print(f"Failed to create directory: \"{dataDir}\". Extracted file not saved!")
                return ""

        dataDir = os.path.join(
            dataDir,
            "_extracted_" + binaryFileName.replace(".", "_")
        )

        if not os.path.isdir(dataDir):
            os.mkdir(dataDir)

        data, ext = self.__PreprocessData(data)
        fileName = self.__GetFileName() + ext

        filePath = os.path.join(dataDir, fileName)
        with open(filePath, "wb") as f:
            print(f"[INFO] Saving file \"{filePath}\"")
            f.write(data)

        retPath = ("\".\\_extracted_"
                   + binaryFileName.replace(".", "_")
                   + "\\"
                   + fileName
                   + "\"")

        return retPath

    def __PreprocessData(self, data: bytes) -> tuple[bytes, str]:
        ext = ".bin"
        signature = data[:32]

        if b"TBitmap" in signature:
            data = data[12:]
            ext = ".bmp"
        elif b"TJPEGImage" in signature:
            data = data[15:]
            ext = ".jpeg"
        elif b"TWICImage" in signature:
            data = data[10:]
            ext = ".tif"
        elif b"TPngImage" in signature:
            data = data[10:]
            ext = ".png"
        elif b"TPNGGraphic" in signature:
            data = data[16:]
            ext = ".png"
        elif b"TPNGObject" in signature:
            data = data[11:]
            ext = ".png"
        elif signature[1:4] == b"PNG":
            ext = ".png"
        elif b"TGIFImage" in signature:
            data = data[10:]
            ext = ".gif"
        elif signature[28:31] == b"BM6":
            data = data[28:]
            ext = ".bmp"
        elif signature[4:6] == b"BM":
            flag = True

            for i in range(4):
                if data[i] != data[i + 6]:
                    flag = False

            if flag:
                data = data[4:]
                ext = ".bmp"

        return data, ext

    def __GetFileName(self) -> str:
        parentObj = self.__parentObj
        fileName = str()

        while parentObj is not None:
            fileName = parentObj.GetObjectName()[:15] + "_" + fileName
            parentObj = parentObj.GetParentObject()

        return fileName[:len(fileName)-1]


class DelphiObject(object):

    def __init__(
            self,
            className: str,
            objName: str,
            parentObj: DelphiObject | None) -> None:
        self.__className = className
        self.__objectName = objName
        self.__listOfChildrenObjects = list()
        self.__listOfProperties = list()
        self.__parentObj = parentObj

    def GetParentObject(self) -> DelphiObject | None:
        return self.__parentObj

    def GetObjectName(self) -> str:
        return self.__objectName

    def SetObjectName(self, objName: str) -> None:
        self.__objectName = objName

    def GetClassName(self) -> str:
        return self.__className

    def SetClassName(self, className: str) -> None:
        self.__className = className

    def GetPropertyList(self) -> list[DelphiProperty]:
        return self.__listOfProperties

    def AddProperty(self, prop: DelphiProperty) -> None:
        self.__listOfProperties.append(prop)

    def GetChildObjectList(self) -> list[DelphiObject]:
        return self.__listOfChildrenObjects

    def AddChildObject(self, childObj: DelphiObject) -> None:
        self.__listOfChildrenObjects.append(childObj)

    def PrintObjectInfo(self, indentation: str = "") -> None:
        print(f"{indentation}object {self.__objectName}: {self.__className}")

        for prop in self.__listOfProperties:
            prop.PrintPropertyInfo(indentation + "   ")

        for obj in self.__listOfChildrenObjects:
            obj.PrintObjectInfo(indentation + "   ")

        print(f"{indentation} end")

```

`DelphiHelper/core/EPFinder.py`:

```py
#
# This module implements simple heuristic for searching for EP functions
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_idaapi
import ida_kernwin
import ida_name
import ida_ua
import idautils
import idc
from DelphiHelper.core.ClassResolver import *
from DelphiHelper.core.ClassStruct import UpdateClassStructures
from DelphiHelper.core.DelphiClass import *
from DelphiHelper.util.delphi import FindInitTable, GetApplicationClassAddr
from DelphiHelper.util.exception import DelphiHelperError
from DelphiHelper.util.ida import *


class EPFinder(object):

    def __init__(self, delphiVersion: int) -> None:
        self.__delphiVersion = delphiVersion

    def FindEPFunction(self) -> None:
        createFormRef = dict()
        initExeRef = list()
        EPAddrToJmp = 0
        createFormFuncAddr = 0
        processorWordSize = GetProcessorWordSize()

        classAddr = GetApplicationClassAddr()

        if classAddr != ida_idaapi.BADADDR:
            ResolveApplicationClass(self.__delphiVersion, classAddr)
            # CreateForm
            createFormStrAddr = find_bytes("0A 43 72 65 61 74 65 46 6F 72 6D")

            if createFormStrAddr != ida_idaapi.BADADDR:
                createFormFuncAddr = GetCustomWord(
                    createFormStrAddr - processorWordSize,
                    processorWordSize
                )

        if createFormFuncAddr == 0:
            for funcAddr in idautils.Functions():
                funcName = ida_name.get_name(funcAddr)

                if "TApplication" in funcName and "CreateForm" in funcName:
                    createFormFuncAddr = funcAddr
                    break

        if createFormFuncAddr != 0:
            for ref in idautils.CodeRefsTo(createFormFuncAddr, 1):
                createFormRef[ref] = self.__getFormName(ref)

        initTable = FindInitTable()
        if initTable:
            for ref in idautils.DataRefsTo(initTable):
                initExeRef.append(ref)

        if initExeRef or createFormRef:
            i = 0
            print("[INFO] Found EP functions:")

            if initExeRef:
                EPAddrToJmp = initExeRef[0]

                for addr in initExeRef:
                    print(f"[INFO] EP{i}: 0x{addr:x} InitExe/InitLib")
                    i += 1

            if len(createFormRef):
                for addr, name in createFormRef.items():
                    if EPAddrToJmp == 0:
                        EPAddrToJmp = addr

                    if name == "":
                        print(f"[INFO] EP{i}: 0x{addr:x}")
                    else:
                        print(f"[INFO] EP{i}: 0x{addr:x} CreateForm(\"{name}\")")
                    i += 1

            if EPAddrToJmp != 0:
                ida_kernwin.jumpto(EPAddrToJmp)
        else:
            print("[INFO] EP function not found!")

        UpdateClassStructures()

    def __getFormName(self, createFormRef: int) -> str:
        addr = createFormRef
        regEdx = "edx"
        if Is64bit():
            regEdx = "rdx"

        counter = 3
        while counter != 0:
            addr = idc.prev_head(addr)
            if ida_ua.print_insn_mnem(addr) == "mov" and \
               idc.print_operand(addr, 0) == regEdx and \
               idc.get_operand_type(addr, 1) == 0x2:
                addr = idc.get_operand_value(addr, 1)
                try:
                    delphiClass = DelphiClass(
                        addr,
                        self.__delphiVersion
                    )
                    if not ida_name.get_name(addr).startswith("VMT_"):
                        delphiClass.MakeClass()
                    return delphiClass.GetClassFullName()
                except DelphiHelperError:
                    return ""
            counter -= 1
        return ""

```

`DelphiHelper/core/FieldEnum.py`:

```py
#
# This module allows to store data from Delphi's FieldTable in IDA's enums
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import idc
import ida_idaapi
from DelphiHelper.util.ida import FixName


class FieldEnum(object):

    def __init__(self, enumName: str, enumComment: str) -> None:
        self.__fieldEnumName = enumName
        self.__fieldEnumComment = enumComment
        self.__fieldEnumId = ida_idaapi.BADADDR

    def AddMember(
            self,
            memberType: str,
            memberName: str,
            enumMemberValue: int) -> None:
        self.__CreateFieldEnum()
        self.__AddFieldEnumMember(
            memberType,
            memberName,
            enumMemberValue
        )

    def __CreateFieldEnum(self) -> None:
        if self.__fieldEnumId == ida_idaapi.BADADDR:
            self.__DeleteEnum()

            self.__fieldEnumId = idc.add_enum(
                ida_idaapi.BADADDR,
                self.__fieldEnumName + "_Fields",
                ida_bytes.hex_flag()
            )
            idc.set_enum_cmt(self.__fieldEnumId, self.__fieldEnumComment, 0)

    def __AddFieldEnumMember(
            self,
            memberType: str,
            memberName: str,
            enumMemberValue: int) -> None:
        enumMemberName = (self.__fieldEnumName
                          + "_"
                          + memberType
                          + "_"
                          + memberName)
        enumMemberName = FixName(enumMemberName)

        memberId = idc.get_enum_member_by_name(enumMemberName)

        if memberId == ida_idaapi.BADADDR:
            idc.add_enum_member(
                self.__fieldEnumId,
                enumMemberName,
                enumMemberValue,
                -1
            )
        elif idc.get_enum_member_value(memberId) != enumMemberValue:
            self.__AddFieldEnumMember(
                memberType,
                memberName + "_",
                enumMemberValue
            )

    def __DeleteEnum(self) -> None:
        fieldEnumId = idc.get_enum(self.__fieldEnumName + "_Fields")

        if fieldEnumId != ida_idaapi.BADADDR:
            idc.del_enum(fieldEnumId)

        self.__fieldEnumId = ida_idaapi.BADADDR

```

`DelphiHelper/core/FormViewer.py`:

```py
#
# This module allows to show Delphi's forms extracted from DFMs
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_kernwin
from DelphiHelper.core.DelphiForm import DelphiObject
from DelphiHelper.ui.FormViewerUI import FormViewerUI


class DelphiFormViewer(ida_kernwin.PluginForm):

    def __init__(
            self,
            formList: list[tuple[DelphiObject, list[tuple[str, int]], int]]
            ) -> None:
        ida_kernwin.PluginForm.__init__(self)
        self.parent = None
        self.__formList = formList

    def OnCreate(self, form) -> None:
        if len(self.__formList):
            FormViewerUI(self.FormToPyQtWidget(form), self.__formList)

    def OnClose(self, form) -> None:
        global _DelphiFormViewer
        del _DelphiFormViewer

    def Show(self):
        return ida_kernwin.PluginForm.Show(
            self,
            "Delphi Form Viewer",
            options=ida_kernwin.PluginForm.WOPN_PERSIST
        )


def FormViewer(
        formList: list[tuple[DelphiObject, list[tuple[str, int]], int]]
        ) -> None:
    global _DelphiFormViewer

    try:
        _DelphiFormViewer
    except Exception:
        _DelphiFormViewer = DelphiFormViewer(formList)

    _DelphiFormViewer.Show()

```

`DelphiHelper/core/FuncStruct.py`:

```py
#
# This module allows to store data extracted from Delphi's RTTI tables into
# IDA's structures
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import ida_idaapi
import ida_name
import idc
from DelphiHelper.util.ida import GetProcessorWordSize


class FuncStruct(object):

    def __init__(self, funcStructName: str, funcStructComment: str) -> None:
        self.__funcStructName = funcStructName + "_VMT"
        self.__funcStructComment = funcStructComment
        self.__funcStructId = ida_idaapi.BADADDR
        self.__processorWordSize = GetProcessorWordSize()

    def AddMember(self, funcAddr: int, funcOffset: int) -> None:
        self.__CreateFuncStruct()
        self.__AddFuncStructMember(funcAddr, funcOffset)

    def __CreateFuncStruct(self) -> None:
        if self.__funcStructId == ida_idaapi.BADADDR:
            self.__DeleteStruct()
            self.__funcStructId = idc.add_struc(-1, self.__funcStructName, 0)

            idc.set_struc_cmt(
                self.__funcStructId,
                self.__funcStructComment,
                0
            )

    def __AddFuncStructMember(self, funcAddr: int, funcOffset: int) -> None:
        funcName = ida_name.get_name(funcAddr)

        if self.__processorWordSize == 4:
            idc.add_struc_member(
                self.__funcStructId,
                funcName + "_" + hex(funcOffset),
                funcOffset,
                ida_bytes.FF_DWORD,
                -1,
                4
            )
        else:
            idc.add_struc_member(
                self.__funcStructId,
                funcName + "_" + hex(funcOffset),
                funcOffset,
                ida_bytes.FF_QWORD,
                -1,
                8
            )

        memberId = idc.get_member_id(self.__funcStructId, funcOffset)

        idc.set_member_cmt(
            self.__funcStructId,
            funcOffset,
            "0x" + ("%x" % funcAddr),
            1
        )

        structMemberPrototype = self.__GetStructMemberPrototype(funcName)
        if structMemberPrototype is not None:
            idc.SetType(memberId, structMemberPrototype)

    def __GetStructMemberPrototype(self, funcName: str) -> str | None:
        structMemberPrototype = idc.get_type(idc.get_name_ea_simple(funcName))

        if structMemberPrototype is not None:
            funcNameStart = structMemberPrototype.find("(")

            if funcNameStart != -1 and \
               structMemberPrototype[funcNameStart - 1] != " ":
                structMemberPrototype = (structMemberPrototype[0: funcNameStart]
                                         + "(*"
                                         + funcName
                                         + ")"
                                         + structMemberPrototype[funcNameStart:])

        return structMemberPrototype

    def __DeleteStruct(self) -> None:
        structId = idc.get_struc_id(self.__funcStructName)

        if structId != ida_idaapi.BADADDR:
            idc.del_struc(structId)

        self.__funcStructId = ida_idaapi.BADADDR

```

`DelphiHelper/core/IDRKBLoader.py`:

```py
#
# This module allows to load IDR KB signatures and implements GUI for
# IDRKBLoader
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.

from __future__ import annotations

import os

import ida_funcs
import ida_idaapi
import ida_kernwin
import ida_name
import ida_pro

from DelphiHelper.core.IDRKBParser import GetDelphiVersion, KBParser
from DelphiHelper.util.delphi import GetUnits, ParseMangledFunctionName
from DelphiHelper.util.exception import DelphiHelperError
from DelphiHelper.util.ida import (
    FixName,
    Is64bit,
    MakeFunction,
    MakeName,
    find_bytes,
)

if ida_pro.IDA_SDK_VERSION >= 920:
    from PySide6 import QtGui, QtCore, QtWidgets
else:
    from PyQt5 import QtGui, QtCore, QtWidgets  # type: ignore[no-redef]


_KBLoader: IDRKBLoaderDialog | None = None


def KBLoader(custom: bool = False) -> None:
    global _KBLoader

    KBFile = chooseKBFile()

    if KBFile is None:
        return

    if custom:
        try:
            _KBLoader
        except Exception:
            _KBLoader = IDRKBLoaderDialog(KBFile)
        _KBLoader.Show()
    else:
        kbLoader = IDRKBLoader(["SysInit", "System"], KBFile)
        kbLoader.LoadIDRKBSignatures(GetDelphiVersion())


def chooseKBFile() -> str | None:
    question = "Do you want to choose the IDR KB file manually? (If not, KB autodetection will be performed.)"
    result = ida_kernwin.ask_yn(ida_kernwin.ASKBTN_NO, question)

    if result == ida_kernwin.ASKBTN_YES:
        return ida_kernwin.ask_file(False, "*.*", "Select IDR KB file")

    if result == ida_kernwin.ASKBTN_NO:
        return ""

    return None


class IDRKBLoaderDialog(ida_kernwin.PluginForm):

    def __init__(self, KBFile: str) -> None:
        super(IDRKBLoaderDialog, self).__init__()
        self.__KBFile = KBFile

    def OnCreate(self, form) -> None:
        msg = "NODELAY\nHIDECANCEL\nExtracting list of imported units..."
        ida_kernwin.show_wait_box(msg)
        unitList = sorted(GetUnits())
        ida_kernwin.hide_wait_box()

        if len(unitList):
            _ = ChecklistDialog(
                self.__clink__,
                self.FormToPyQtWidget(form),
                unitList,
                self.__KBFile
            )

    def OnClose(self, form) -> None:
        global _KBLoader
        del _KBLoader

    def Show(self):
        return ida_kernwin.plgform_show(
            self.__clink__,
            self,
            "IDR Knowledge Base Loader",
            ida_kernwin.WOPN_PERSIST | 0x20
        )


class ChecklistDialog(QtWidgets.QDialog):

    def __init__(
            self,
            clink,
            parent,
            unitList: list[str],
            KBFile: str,
            checked: bool = True) -> None:
        super(ChecklistDialog, self).__init__(parent)

        self.__KBFile = KBFile
        self.clink = clink
        self.parent = parent

        self.model = QtGui.QStandardItemModel()
        self.listView = QtWidgets.QListView()

        for unit in unitList:
            item = QtGui.QStandardItem(unit)
            item.setCheckable(True)
            item.setEditable(False)

            if checked:
                item.setCheckState(QtCore.Qt.Checked)
            else:
                item.setCheckState(QtCore.Qt.Unchecked)

            self.model.appendRow(item)

        self.listView.setModel(self.model)

        self.loadButton = QtWidgets.QPushButton("Load")
        self.cancelButton = QtWidgets.QPushButton("Cancel")
        self.selectButton = QtWidgets.QPushButton("Select All")
        self.unselectButton = QtWidgets.QPushButton("Unselect All")

        hbox = QtWidgets.QHBoxLayout()
        hbox.addStretch(1)
        hbox.addWidget(self.loadButton)
        hbox.addWidget(self.cancelButton)
        hbox.addWidget(self.selectButton)
        hbox.addWidget(self.unselectButton)

        vbox = QtWidgets.QVBoxLayout(self)
        label = QtWidgets.QLabel("Select units whose IDR KB signatures will be loaded")
        label.setFont(QtGui.QFont("Arial", 8))
        vbox.addWidget(label)
        label = QtWidgets.QLabel("Warning: Loading signatures for all units can last very long time")
        label.setFont(QtGui.QFont("Arial", 8))
        vbox.addWidget(label)
        vbox.addWidget(self.listView)
        vbox.addLayout(hbox)

        self.parent.setLayout(vbox)

        self.loadButton.clicked.connect(self.onLoad)
        self.cancelButton.clicked.connect(self.onCanceled)
        self.selectButton.clicked.connect(self.select)
        self.unselectButton.clicked.connect(self.unselect)

    def onLoad(self) -> None:
        choices = list()

        for i in range(self.model.rowCount()):
            if self.model.item(i).checkState() == QtCore.Qt.Checked:
                choices.append(self.model.item(i).text())

        ida_kernwin.plgform_close(self.clink, 0x2)

        try:
            if choices:
                IDRKBLoader(choices, self.__KBFile).LoadIDRKBSignatures()
        except DelphiHelperError as e:
            e.print()

    def onCanceled(self) -> None:
        ida_kernwin.plgform_close(self.clink, 0x2)

    def select(self) -> None:
        for i in range(self.model.rowCount()):
            item = self.model.item(i)
            item.setCheckState(QtCore.Qt.Checked)

    def unselect(self) -> None:
        for i in range(self.model.rowCount()):
            item = self.model.item(i)
            item.setCheckState(QtCore.Qt.Unchecked)


class IDRKBLoader(object):

    def __init__(
            self,
            units: list[str],
            KBFile: str) -> None:
        self.__unitList = units
        self.__KBFile = KBFile

    def LoadIDRKBSignatures(self, delphiVersion: int = 0) -> None:
        if self.__KBFile == str():
            if delphiVersion == 0:
                ida_kernwin.show_wait_box("NODELAY\nHIDECANCEL\nTrying to determine Delphi version...")
                delphiVersion = GetDelphiVersion()
                ida_kernwin.hide_wait_box()

            if delphiVersion == -1:
                delphiVersion = 2014

            self.__KBFile = self.__getKBFilePath(delphiVersion)

        self.__loadSignatures(self.__KBFile, self.__unitList)

    def __isDifferentFunctionName(
            self,
            origName: str,
            signatureName: str) -> bool:
        if origName.startswith("KB_"):
            if origName == signatureName or \
               origName == signatureName + "_0":
                return False
            else:
                return True

        if "@" in origName:
            origName = ParseMangledFunctionName(origName)

        if origName == signatureName[3:]:
            return False

        return True

    def __renameFunction(self, unit: str, function: tuple[str, str]) -> bool:
        funcAddr = find_bytes(function[1])
        if funcAddr != ida_idaapi.BADADDR:
            if function[0][0] == "@":
                functionName = FixName("KB_" + unit + "_" + function[0][1:])
            else:
                functionName = FixName("KB_" + unit + "_" + function[0])

            funcAddr2 = find_bytes(function[1], funcAddr + 1)
            if funcAddr2 == ida_idaapi.BADADDR:
                funcStruct = ida_funcs.get_func(funcAddr)
                if funcStruct:
                    funcAddr = funcStruct.start_ea
                else:
                    MakeFunction(funcAddr)
                    print(f"[INFO] Making a new function on 0x{funcAddr:X}")
                origFunctionName = ida_name.get_name(funcAddr)

                if not self.__isDifferentFunctionName(origFunctionName, functionName):
                    return False

                functionCmt = ida_funcs.get_func_cmt(funcAddr, 1)
                if not self.__isDifferentFunctionName(origFunctionName, functionName) or \
                   (functionCmt and functionName in functionCmt):
                    return False

                if origFunctionName.startswith("sub_") or \
                   origFunctionName.startswith("unknown_"):
                    print(
                        f"[INFO] Renaming: {origFunctionName} -> {functionName} (0x{funcAddr:X})"
                    )
                    MakeName(funcAddr, functionName)
                else:
                    cmt = ida_funcs.get_func_cmt(funcAddr, 1)
                    if cmt:
                        cmt = functionName + "\n" + cmt
                    else:
                        cmt = functionName

                    print(
                        f"[INFO] Adding alternative name: {origFunctionName} -> {functionName} (0x{funcAddr:X})"
                    )
                    ida_funcs.set_func_cmt(funcAddr, cmt, 1)
                return True
        return False

    def __getKBFilePath(self, delphiVersion: int) -> str:
        if Is64bit():
            KBPath = os.path.join(
                os.path.dirname(__file__),
                "..",
                "IDR_KB",
                "IDR64",
                f"syskb{delphiVersion}.bin"
            )
        else:
            KBPath = os.path.join(
                os.path.dirname(__file__),
                "..",
                "IDR_KB",
                "IDR",
                f"kb{delphiVersion}.bin"
            )
        KBPath = os.path.normpath(KBPath)

        if not os.path.exists(KBPath):
            print(f"[WARNING] KB file \"{KBPath}\" not found!")

            msg = f"KB file \"{KBPath}\" not found!\nNote: read the README.md for KB file location."
            ida_kernwin.warning(msg)

            raise DelphiHelperError()

        return KBPath

    def __loadSignatures(
            self,
            KBFile: str,
            units: list[str]) -> None:
        ida_kernwin.show_wait_box("NODELAY\nLoading IDR Knowledge base signatures...")

        try:
            kb = KBParser(KBFile)
            counter = 0
            unitCounter = 0

            for unit in units:
                unitCounter += 1
                moduleID = kb.GetModuleID(unit)

                if moduleID != -1:
                    print(f"[INFO] Loading function signatures for \"{unit}\" unit")

                    firstIndex, lastIndex = kb.GetProcIdxs(moduleID)
                    functions = kb.GetFunctions(firstIndex, lastIndex)
                    i = 0

                    for func in functions:
                        i += 1

                        msg = (f"Loading IDR Knowledge base signatures... Unit {unit} ({unitCounter}/{len(units)}) - Function ({i}/{len(functions)})")
                        ida_kernwin.replace_wait_box(msg)

                        if self.__renameFunction(unit, func):
                            counter += 1

                        if ida_kernwin.user_cancelled():
                            print(f"[INFO] Applied signatures: {str(counter)}")
                            return
                else:
                    print(f"[INFO] KB file does not include signatures for \"{unit}\" module")

            print(f"[INFO] Applied signatures: {str(counter)}")
        except DelphiHelperError as e:
            e.print()
        finally:
            ida_kernwin.hide_wait_box()

```

`DelphiHelper/core/IDRKBParser.py`:

```py
#
# This module allows to parse IDR Knowledge base files and to determine
# Delphi's version.
#
# The module is based on code from IDR project
# (https://github.com/crypto2011/IDR),
# which is licensed under the MIT License.
#

"""
MIT License

Copyright (c) 2006-2018 crypto

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""


import ida_idaapi
import ida_kernwin
import struct
from DelphiHelper.util.delphi import *
from DelphiHelper.util.exception import DelphiHelperError
from DelphiHelper.util.ida import *


class KBParser(object):

    def __init__(self, KB_filename: str) -> None:
        self.__moduleOffsets = list()
        self.__constOffsets = list()
        self.__typeOffsets = list()
        self.__varOffsets = list()
        self.__resStrOffsets = list()
        self.__procOffsets = list()

        self.__kbFile = open(KB_filename, "rb")

        if not self.__CheckKBFile():
            self.__kbFile.close()
            raise DelphiHelperError("Unexpected Knowledge base file format.")

        self.__kbFile.seek(-4, 2)
        sectionsOffset = struct.unpack("i", self.__kbFile.read(4))[0]
        self.__kbFile.seek(sectionsOffset, 0)

        self.__moduleCount = struct.unpack("i", self.__kbFile.read(4))[0]
        self.__maxModuleDataSize = struct.unpack("i", self.__kbFile.read(4))[0]

        for i in range(self.__moduleCount):
            self.__moduleOffsets.append(self.__ReadOffetsInfo())

        self.__constCount = struct.unpack("i", self.__kbFile.read(4))[0]
        self.__maxConstDataSize = struct.unpack("i", self.__kbFile.read(4))[0]

        for i in range(self.__constCount):
            self.__constOffsets.append(self.__ReadOffetsInfo())

        self.__typeCount = struct.unpack("i", self.__kbFile.read(4))[0]
        self.__maxTypeDataSize = struct.unpack("i", self.__kbFile.read(4))[0]

        for i in range(self.__typeCount):
            self.__typeOffsets.append(self.__ReadOffetsInfo())

        self.__varCount = struct.unpack("i", self.__kbFile.read(4))[0]
        self.__maxVarDataSize = struct.unpack("i", self.__kbFile.read(4))[0]

        for i in range(self.__varCount):
            self.__varOffsets.append(self.__ReadOffetsInfo())

        self.__resStrCount = struct.unpack("i", self.__kbFile.read(4))[0]
        self.__maxResStrDataSize = struct.unpack("i", self.__kbFile.read(4))[0]

        for i in range(self.__resStrCount):
            self.__resStrOffsets.append(self.__ReadOffetsInfo())

        self.__procCount = struct.unpack("i", self.__kbFile.read(4))[0]
        self.__maxProcDataSize = struct.unpack("i", self.__kbFile.read(4))[0]

        for i in range(self.__procCount):
            self.__procOffsets.append(self.__ReadOffetsInfo())

        self.__kbFile.seek(0, 0)
        self.__kbMem = bytes()
        self.__kbMem = self.__kbFile.read()
        self.__kbFile.close()

    def __ReadOffetsInfo(self) -> list:
        offsetsInfo = list()
        offsetsInfo.append(struct.unpack("I", self.__kbFile.read(4))[0])
        offsetsInfo.append(struct.unpack("I", self.__kbFile.read(4))[0])
        offsetsInfo.append(struct.unpack("i", self.__kbFile.read(4))[0])
        offsetsInfo.append(struct.unpack("i", self.__kbFile.read(4))[0])

        return offsetsInfo

    def __CheckKBFile(self) -> bool:
        signature = self.__kbFile.read(24)
        self.__kbFile.seek(265, 1)
        kbVersion = struct.unpack("i", self.__kbFile.read(4))[0]

        if (signature == b"IDD Knowledge Base File\x00") and (kbVersion == 1):
            self.__version = kbVersion
            return True

        if (signature == b"IDR Knowledge Base File\x00") and (kbVersion == 2):
            self.__version = kbVersion
            return True

        return False

    def GetFunctions(
            self,
            firstIndex: int = -1,
            lastIndex: int = -1) -> list[tuple[str, str]]:
        functions = list()

        if firstIndex == -1:
            firstIndex = 0

        if lastIndex == -1:
            lastIndex = self.__procCount - 1

        for i in range(firstIndex, lastIndex + 1, 1):
            procInfo = self.GetProcInfo(i)

            if procInfo["DumpSz"] > 9:
                code = str()

                for y in range(procInfo["DumpSz"]):
                    b = procInfo["Dump"][y]

                    if procInfo["Reloc"][y] == 0xff:
                        code += "?? "
                    elif b < 0x10:
                        code += "0" + hex(b)[2:] + " "
                    else:
                        code += hex(b)[2:] + " "

                functions.append((procInfo["ProcName"].decode("utf-8"), code[:-1]))

        return functions

    def GetModuleID(self, moduleName: str) -> int:
        if moduleName == "" or self.__moduleCount == 0:
            return -1

        L = 0
        R = self.__moduleCount - 1

        while L < R:
            M = (L + R) // 2
            ID = self.__moduleOffsets[M][3]  # NameID
            nameLen = struct.unpack("H", self.__kbMem[self.__moduleOffsets[ID][0] + 2: self.__moduleOffsets[ID][0] + 4])[0]
            name = self.__kbMem[self.__moduleOffsets[ID][0] + 4: self.__moduleOffsets[ID][0] + 4 + nameLen].decode("utf-8")

            if moduleName.lower() <= name.lower():
                R = M
            else:
                L = M + 1

        ID = self.__moduleOffsets[R][3]
        nameLen = struct.unpack("H", self.__kbMem[self.__moduleOffsets[ID][0] + 2: self.__moduleOffsets[ID][0] + 4])[0]
        name = self.__kbMem[self.__moduleOffsets[ID][0] + 4: self.__moduleOffsets[ID][0] + 4 + nameLen].decode("utf-8")

        if moduleName == name:
            return struct.unpack("H", self.__kbMem[self.__moduleOffsets[ID][0]: self.__moduleOffsets[ID][0] + 2])[0]

        return -1

    def GetProcIdx(self, moduleID: int, procName: str) -> int:
        """Return proc index by name in given ModuleID"""

        if moduleID == -1 or procName == "" or self.__procCount == 0:
            return -1

        L = 0
        R = self.__procCount - 1

        while True:
            M = (L + R) // 2
            # NameID
            ID = self.__procOffsets[M][3]
            nameLen = struct.unpack("H", self.__kbMem[self.__moduleOffsets[ID][0] + 2: self.__moduleOffsets[ID][0] + 4])[0]
            name = self.__kbMem[self.__procOffsets[ID][0] + 4: self.__procOffsets[ID][0] + 4 + nameLen].decode("utf-8")

            if procName < name:
                R = M - 1
            elif procName > name:
                L = M + 1
            else:
                # Find left boundary
                LN = M - 1
                while LN >= 0:
                    ID = self.__procOffsets[LN][3]  # NameID
                    nameLen = struct.unpack("H", self.__kbMem[self.__moduleOffsets[ID][0] + 2: self.__moduleOffsets[ID][0] + 4])[0]
                    name = self.__kbMem[self.__procOffsets[ID][0] + 4: self.__procOffsets[ID][0] + 4 + nameLen].decode("utf-8")

                    if procName != name:
                        break

                    LN -= 1

                # Find right boundary
                RN = M + 1

                while RN < self.__procCount:
                    ID = self.__procOffsets[RN][3]  # NameID
                    nameLen = struct.unpack("H", self.__kbMem[self.__moduleOffsets[ID][0] + 2: self.__moduleOffsets[ID][0] + 4])[0]
                    name = self.__kbMem[self.__procOffsets[ID][0] + 4: self.__procOffsets[ID][0] + 4 + nameLen].decode("utf-8")

                    if procName != name:
                        break

                    RN += 1

                N = LN + 1

                while N < RN:
                    ID = self.__procOffsets[N][3]  # NameID
                    ModID = struct.unpack("H", self.__kbMem[self.__moduleOffsets[ID][0]: self.__moduleOffsets[ID][0] + 2])[0]

                    if moduleID == ModID:
                        return N

                    N += 1

                return -1

            if L > R:
                return -1

    def GetProcIdxs(self, moduleID: int) -> tuple[int, int]:
        firstIndex = -1
        lastIndex = -1

        if moduleID != -1 or self.__procCount != 0:
            L = 0
            R = self.__procCount - 1

            while True:
                M = (L + R) // 2
                ID = self.__procOffsets[M][2]
                ModID = struct.unpack("H", self.__kbMem[self.__procOffsets[ID][0]: self.__procOffsets[ID][0] + 2])[0]

                if moduleID < ModID:
                    R = M - 1
                elif moduleID > ModID:
                    L = M + 1
                else:
                    firstIndex = M
                    lastIndex = M

                    LN = M - 1
                    while LN >= 0:
                        ID = self.__procOffsets[LN][2]
                        ModID = struct.unpack("H", self.__kbMem[self.__procOffsets[ID][0]: self.__procOffsets[ID][0] + 2])[0]

                        if moduleID != ModID:
                            break

                        firstIndex = LN
                        LN -= 1

                    RN = M + 1
                    while RN < self.__procCount:
                        ID = self.__procOffsets[RN][2]
                        ModID = struct.unpack("H", self.__kbMem[self.__procOffsets[ID][0]: self.__procOffsets[ID][0] + 2])[0]

                        if moduleID != ModID:
                            break

                        lastIndex = RN
                        RN += 1

                    return firstIndex, lastIndex

                if L > R:
                    return -1, -1

        return firstIndex, lastIndex

    def GetProcInfo(self, procIdx: int) -> int:

        if procIdx == -1:
            return 0

        procInfo = dict()
        rawProcInfo = self.__kbMem[self.__procOffsets[procIdx][0]: self.__procOffsets[procIdx][0] + self.__procOffsets[procIdx][1]]
        pos = 0

        procInfo["ModuleID"] = struct.unpack("H", rawProcInfo[pos: pos + 2])[0]
        pos += 2
        Len = struct.unpack("H", rawProcInfo[pos: pos + 2])[0]
        pos += 2
        procInfo["ProcName"] = rawProcInfo[pos: pos + Len]#.decode("utf-8")
        pos += Len + 1
        # procInfo["Embedded"] = rawProcInfo[pos]
        pos += 1
        # procInfo["DumpType"] = rawProcInfo[pos]
        pos += 1
        # procInfo["MethodKind"] = rawProcInfo[pos]
        pos += 1
        # procInfo["CallKind"] = rawProcInfo[pos]
        pos += 1
        # procInfo["VProc"] = struct.unpack("I", rawProcInfo[pos : pos + 4])[0]
        pos += 4
        Len = struct.unpack("H", rawProcInfo[pos: pos + 2])[0]
        pos += 2 + Len + 1

        # pInfo->TypeDef = TrimTypeName(String((char*)p)); p += Len + 1;

        # dumpTotal = struct.unpack("I", rawProcInfo[pos : pos + 4])[0]
        pos += 4
        procInfo["DumpSz"] = struct.unpack("I", rawProcInfo[pos: pos + 4])[0]
        pos += 4
        # procInfo["FixupNum"] = struct.unpack("I", rawProcInfo[pos : pos + 4])[0]
        pos += 4
        procInfo["Dump"] = b""
        if procInfo["DumpSz"]:
            procInfo["Dump"] = rawProcInfo[pos: pos + procInfo["DumpSz"]]
            procInfo["Reloc"] = rawProcInfo[pos + procInfo["DumpSz"]: pos + 2*procInfo["DumpSz"]]
        return procInfo


# 32bit
STRINGCOPY_2014_PATTERN = "53 85 d2 75 07 66 c7 00 00 00 eb 26 85 d2 7e 16 0f b7 19 66 89 18 66 85 db 74 17 83 c0 02 83 c1 02 4a 85 d2 7f ea 85 d2 75 08 83 e8 02 66 c7 00 00 00 5b c3"
ERRORAT_2014_PATTERN = "53 56 8b f2 8b d8 80 e3 7f 83 3d ?? ?? ?? ?? 00 74 0a 8b d6 8b c3 ff 15 ?? ?? ?? ?? 84 db 75 0d e8 ?? ?? ?? ?? 8b 98 ?? ?? ?? ?? eb 0f 80 fb 1c 77 0a 0f b6 c3 0f b6 98 ?? ?? ?? ?? 0f b6 c3 8b d6 e8 ?? ?? ?? ?? 5e 5b c3"
FINALIZERESSTRINGS_2013_PATTERN = "53 31 db 57 56 8b 3c 18 8d 74 18 04 8b 06 01 da 8b 4e 08 85 c9 74 07 49 74 0b 49 74 0f cc e8 ?? ?? ?? ?? eb 0c e8 ?? ?? ?? ?? eb 05 e8 ?? ?? ?? ?? 83 c6 0c 4f 75 d5 5e 5f 5b c3"
OBJECT_FIELDADDRESS_2013_PATTERN = "53 56 57 31 c9 31 ff 8a 1a 50 8b 00 8b 70 bc 85 f6 74 18 66 8b 3e 85 ff 74 11 83 c6 06 8a 4e 06 38 d9 74 2c 8d 74 31 07 4f 75 f2 8b 40 d0 85 c0 75 d8 5a eb 39 8a 1a 8a 4e 06 eb e8 50 52 8d 46 06 e8 ?? ?? ?? ?? 31 c9 84 c0 5a 58 74 e7 eb 19 8a 5c 31 06 f6 c3 80 75 e3 32 1c 11 f6 c3 80 75 db 80 e3 df 75 cf 49 75 e7 8b 06 5a 01 d0 5f 5e 5b c3"
INITIALIZECONTROLWORD_2012_PATTERN = "e8 ?? ?? ?? ?? a3 ?? ?? ?? ?? e8 ?? ?? ?? ?? 25 c0 ff 00 00 a3 ?? ?? ?? ?? c3"
ERRORAT_2011_PATTERN = "53 56 8b f2 8b d8 80 e3 7f 83 3d ?? ?? ?? ?? 00 74 0a 8b d6 8b c3 ff 15 ?? ?? ?? ?? 84 db 75 0d e8 ?? ?? ?? ?? 8b 98 ?? ?? ?? ?? eb 0f 80 fb 1b 77 0a 0f b6 c3 0f b6 98 ?? ?? ?? ?? 0f b6 c3 8b d6 e8 ?? ?? ?? ?? 5e 5b c3"
ERRORAT_2010_PATTERN = "53 56 8b f2 8b d8 80 e3 7f 83 3d ?? ?? ?? ?? 00 74 0a 8b d6 8b c3 ff 15 ?? ?? ?? ?? 84 db 75 0d e8 ?? ?? ?? ?? 8b 98 ?? ?? ?? ?? eb 0f 80 fb 1a 77 0a 0f b6 c3 0f b6 98 ?? ?? ?? ?? 0f b6 c3 8b d6 e8 ?? ?? ?? ?? 5e 5b c3"


def getDelphiVersion32() -> int:
    initTableAddr = IsExtendedInitTab()

    if initTableAddr:
        STRINGCOPY_addr = find_bytes(STRINGCOPY_2014_PATTERN)
        ERRORAT_2014_addr = find_bytes(ERRORAT_2014_PATTERN)

        if STRINGCOPY_addr != ida_idaapi.BADADDR or \
           ERRORAT_2014_addr != ida_idaapi.BADADDR:
            print("[INFO] Delphi version: >= 2014")
            return 2014

        FINALIZERESSTRINGS_addr = find_bytes(FINALIZERESSTRINGS_2013_PATTERN)
        OBJECT_FIELDADDRESS_addr = find_bytes(OBJECT_FIELDADDRESS_2013_PATTERN)

        if OBJECT_FIELDADDRESS_addr != ida_idaapi.BADADDR or \
           FINALIZERESSTRINGS_addr != ida_idaapi.BADADDR:
            print("[INFO] Delphi version: 2013")
            return 2013

        INITIALIZECONTROLWORD_addr = find_bytes(INITIALIZECONTROLWORD_2012_PATTERN)

        if INITIALIZECONTROLWORD_addr != ida_idaapi.BADADDR:
            print("[INFO] Delphi version: 2012")
            return 2012

        ERRORAT_2011_addr = find_bytes(ERRORAT_2011_PATTERN)

        if ERRORAT_2011_addr != ida_idaapi.BADADDR:
            print("[INFO] Delphi version: 2011")
            return 2011

        ERRORAT_2010_addr = find_bytes(ERRORAT_2010_PATTERN)

        if ERRORAT_2010_addr != ida_idaapi.BADADDR:
            print("[INFO] Delphi version: 2010")
            return 2010

        print("[INFO] Delphi version: UNKNOWN")
        return -1

    print("[INFO] Delphi version: <= 2009")
    return 2009


# 64bit
STRINGCOPY_2014_PATTERN64 = "85 d2 75 07 66 c7 01 00 00 eb 2a 85 d2 7e 1b 49 0f b7 00 66 89 01 66 85 c0 74 1a 48 83 c1 02 49 83 c0 02 83 ea 01 85 d2 7f e5 90 85 d2 75 06 66 c7 41 fe 00 00 c3"
ERRORAT_2014_PATTERN64 = "56 53 48 83 ec 28 89 cb 48 89 d6 80 e3 7f 48 83 3d ?? ?? ?? ?? 00 74 0b 89 d9 48 89 f2 ff 15 ?? ?? ?? ?? 84 db 75 0f e8 ?? ?? ?? ?? 48 0f b6 98 ?? ?? ?? ?? eb 15 80 fb 1c 77 10 48 8d 05 ?? ?? ?? ?? 48 0f b6 db 48 0f b6 1c 18 48 0f b6 cb 48 89 f2 e8 ?? ?? ?? ?? 48 83 c4 28 5b 5e c3"
OBJECT_CLASSNAME_2013_PATTERN64 = "53 48 83 ec 20 48 89 d3 48 89 d8 48 8b 91 78 ff ff ff 48 89 c1 e8 ?? ?? ?? ?? 48 89 d8 48 83 c4 20 5b c3"
CLASSCREATE_2013_PATTERN64 = "48 83 ec 28 48 89 c8 84 d2 7c 06 48 89 c1 ff 50 d0 48 83 c4 28 c3"
INITIALIZECONTROLWORD_2012_PATTERN64 = "48 83 ec 28 c7 05 ?? ?? ?? ?? 03 00 00 00 e8 ?? ?? ?? ?? 66 81 e0 3f 1f 66 89 05 ?? ?? ?? ?? 48 83 c4 28 c3"


def getDelphiVersion64() -> int:
    STRINGCOPY_addr = find_bytes(STRINGCOPY_2014_PATTERN64)
    ERRORAT_addr = find_bytes(ERRORAT_2014_PATTERN64)
    if ERRORAT_addr != ida_idaapi.BADADDR or \
       STRINGCOPY_addr != ida_idaapi.BADADDR:
        print("[INFO] Delphi version: >= 2014")
        return 2014

    OBJECT_CLASSNAME_addr = find_bytes(OBJECT_CLASSNAME_2013_PATTERN64)
    CLASSCREATE_addr = find_bytes(CLASSCREATE_2013_PATTERN64)

    if OBJECT_CLASSNAME_addr != ida_idaapi.BADADDR or \
       CLASSCREATE_addr != ida_idaapi.BADADDR:
        print("[INFO] Delphi version: 2013")
        return 2013

    INITIALIZECONTROLWORD_addr = find_bytes(INITIALIZECONTROLWORD_2012_PATTERN64)

    if INITIALIZECONTROLWORD_addr != ida_idaapi.BADADDR:
        print("[INFO] Delphi version: 2012")
        return 2012

    print("[INFO] Delphi version: UNKNOWN")
    return 2014


def GetDelphiVersion() -> int:
    ida_kernwin.show_wait_box("Trying to determine Delphi version...")
    try:
        if Is64bit():
            return getDelphiVersion64()
        else:
            return getDelphiVersion32()
    finally:
        ida_kernwin.hide_wait_box()

```

`DelphiHelper/ui/FormViewerUI.py`:

```py
#
# This module implements GUI for FormViewer
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_kernwin
import ida_pro

from DelphiHelper.core.DelphiForm import DelphiObject, DelphiProperty

if ida_pro.IDA_SDK_VERSION >= 920:
    from PySide6 import QtGui, QtWidgets
else:
    from PyQt5 import QtGui, QtWidgets  # type: ignore[no-redef]


class FormViewerUI():

    def __init__(
            self,
            parent,
            delphiFormList: list[tuple[DelphiObject, list[tuple[str, int]], int]]
            ) -> None:
        super().__init__()
        self.parent = parent
        self.initUI(delphiFormList)

    def initUI(
            self,
            delphiFormList: list[tuple[DelphiObject, list[tuple[str, int]], int]]
            ) -> None:
        self.tree = QtWidgets.QTreeWidget()
        self.tree.setHeaderLabels(("Delphi Forms (Hint: Bold nodes -> Delphi Events inside, Green nodes -> binary files inside)",))
        self.tree.setColumnWidth(0, 30)
        self.tree.itemDoubleClicked.connect(OnDoubleClickItem)
        self.tree.itemClicked.connect(OnClickItem)

        layout = QtWidgets.QVBoxLayout()
        layout.addWidget(self.tree)
        self.parent.setLayout(layout)

        self.PopulateFormTree(delphiFormList)

    def BuildObject(
            self,
            parentNode,
            delphiObject: DelphiObject,
            methodList: list[tuple[str, int]],
            VMTAddr: int = 0,
            _type: int = 1002) -> None:
        propList = delphiObject.GetPropertyList()
        childObjList = delphiObject.GetChildObjectList()

        objNode = ObjectNodeTreeItem(parentNode, delphiObject, VMTAddr, _type)

        if propList != list():
            propertyNode = PropertyNodeTreeItem(objNode)

            for prop in propList:
                PropertyTreeItem(propertyNode, prop, methodList)

        if childObjList != list():
            for childObj in childObjList:
                self.BuildObject(objNode, childObj, methodList)

    def BuildForm(
            self,
            parentNode,
            delphiForm: tuple[DelphiObject, list[tuple[str, int]], int]
            ) -> None:
        self.BuildObject(
            parentNode,
            delphiForm[0],
            delphiForm[1],
            delphiForm[2],
            1001
        )

    def PopulateFormTree(
            self,
            delphiFormList: list[tuple[DelphiObject, list[tuple[str, int]], int]]
            ) -> None:
        self.tree.clear()

        for delphiForm in delphiFormList:
            self.BuildForm(self.tree, delphiForm)


class ObjectNodeTreeItem(QtWidgets.QTreeWidgetItem):

    def __init__(
            self,
            parent,
            delphiObject: DelphiObject,
            VMTAddr: int,
            _type: int) -> None:
        super(ObjectNodeTreeItem, self).__init__(parent, _type)

        self.setData(0, 0x100, delphiObject)
        self.setText(
            0,
            "%s (%s)" % (
                delphiObject.GetObjectName(),
                delphiObject.GetClassName()
            )
        )
        self.setData(0, 0x101, VMTAddr)

        if VMTAddr != 0:
            self.setData(0, 3, "Click to go to the Form's VMT structure")


class PropertyNodeTreeItem(QtWidgets.QTreeWidgetItem):

    def __init__(self, parent) -> None:
        super(PropertyNodeTreeItem, self).__init__(parent)
        self.setText(0, "Properties")


class PropertyTreeItem(QtWidgets.QTreeWidgetItem):

    def __init__(
            self,
            parent,
            prop: DelphiProperty,
            methodList: list[tuple[str, int]]) -> None:
        super(PropertyTreeItem, self).__init__(parent, 1000)

        self.setText(
            0,
            "%s (%s) = %s" % (
                prop.GetName(),
                prop.GetTypeAsString(),
                prop.GetValueAsString()
            )
        )

        self.setData(0, 0x100, prop)

        if prop.GetTypeAsString() == "Binary":
            self.__setBinaryPropertyItem()

        if prop.GetTypeAsString() == "Ident" and \
           prop.GetName().startswith("On"):
            self.__setEventPropertyItem(prop, methodList)

    def __setBinaryPropertyItem(self) -> None:
        self.setData(
            0,
            3,
            "The file has been saved into current working directory"
        )
        self.setForeground(0, QtGui.QBrush(QtGui.QColor("green")))

        node = self.parent()
        while node is not None:
            node.setForeground(0, QtGui.QBrush(QtGui.QColor("green")))

            if node != self.parent():
                cmtToAdd = "The component or its child component includes some binary file (follow green nodes to see binary file in \"Properties\")"
                cmt = node.data(0, 3)

                if cmt is None:
                    node.setData(0, 3, cmtToAdd)
                elif cmtToAdd not in cmt:
                    node.setData(0, 3, cmt + "\n" + cmtToAdd)

            node = node.parent()

    def __setEventPropertyItem(
            self,
            prop: DelphiProperty,
            methodList: list[tuple[str, int]]) -> None:
        myFont = QtGui.QFont()
        myFont.setBold(True)

        self.setData(0, 0x101, 0)

        for method in methodList:
            if method[0] == prop.GetValue().decode():
                self.setData(0, 3, "Double-click to go to the Event handler")
                self.setData(0, 0x101, method[1])
                self.setForeground(0, QtGui.QBrush(QtGui.QColor("blue")))
                self.setFont(0, myFont)

                node = self.parent()
                while node is not None:
                    node.setFont(0, myFont)

                    if node != self.parent():
                        cmtToAdd = "The component or its child component has some Event defined (follow bold nodes to see blue colored Event in \"Properties\")"
                        cmt = node.data(0, 3)

                        if cmt is None:
                            node.setData(0, 3, cmtToAdd)
                        elif cmtToAdd not in cmt:
                            node.setData(0, 3, cmt + "\n" + cmtToAdd)

                    node = node.parent()


def OnDoubleClickItem(item) -> None:
    if item.type() == 1000:
        propType = item.data(0, 0x100).GetTypeAsString()

        if propType == "Ident" and \
           item.data(0, 0x100).GetName().startswith("On"):
            ida_kernwin.jumpto(item.data(0, 0x101))


def OnClickItem(item) -> None:
    if item.type() == 1001 and item.data(0, 0x101) != 0:
        ida_kernwin.jumpto(item.data(0, 0x101))

```

`DelphiHelper/util/delphi.py`:

```py
#
# This module implements utilities for working with Delphi binaries
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_bytes
import ida_funcs
import ida_ida
import ida_idaapi
import ida_kernwin
import ida_name
from DelphiHelper.util.ida import (
    Is32bit, Is64bit, GetStr_PASCAL, GetProcessorWordSize, GetProcessorWord,
    Byte, MakeStr_PASCAL, find_bytes, FindRef_Dword, FindRef_Qword, MakeName,
    FixName
)


def GetApplicationClassAddr() -> int:
    # TApplication#
    strTApplicationAddr = find_bytes("0C 54 41 70 70 6C 69 63 61 74 69 6F 6E")

    if strTApplicationAddr != ida_idaapi.BADADDR:
        if Is32bit():
            addr = FindRef_Dword(
                strTApplicationAddr,
                strTApplicationAddr,
                ida_bytes.BIN_SEARCH_BACKWARD
            )

            if addr != ida_idaapi.BADADDR:
                return addr - 0x20

        if Is64bit():
            addr = FindRef_Qword(
                strTApplicationAddr,
                strTApplicationAddr,
                ida_bytes.BIN_SEARCH_BACKWARD
            )

            if addr != ida_idaapi.BADADDR:
                return addr - 0x40

    return ida_idaapi.BADADDR


def LoadDelphiFLIRTSignatures() -> None:
    """Load Delphi 32bit FLIRT signatures"""
    sigList = ["bds8vcl", "bds8rw32", "bds8ext", "mssdk32"]
    loadedSigList = list()

    result = find_bytes(
        "20 62 65 20 72 75 6E 20 75 6E 64 65 72 20 57 69 6E 33 32 0D 0A"
    )
    result_2 = find_bytes("07 42 6F 6F 6C 65 61 6E")
    result_3 = find_bytes("05 46 61 6C 73 65")

    if ida_idaapi.BADADDR != result or \
       (ida_idaapi.BADADDR != result_2 and ida_idaapi.BADADDR != result_3):
        for i in range(ida_funcs.get_idasgn_qty()):
            loadedSigList.append(ida_funcs.get_idasgn_desc(i)[0])

        for sig in sigList:
            if sig not in loadedSigList:
                ida_funcs.plan_to_apply_idasgn(sig)


def GetUnits() -> list[str]:
    ida_kernwin.show_wait_box("Searching for imported Units...")
    units = list()
    initTableAddr = 0

    if Is64bit():
        initTableAddr = _findInitTable(40)
    elif IsExtendedInitTab():
        initTableAddr = _findInitTable(20)
    else:
        units = ["SysInit", "System"]

    if units == list():
        numOfUnits = GetProcessorWord(
            initTableAddr + 4 * GetProcessorWordSize()
        )
        addr = GetProcessorWord(initTableAddr + 5 * GetProcessorWordSize())

        for i in range(numOfUnits):
            unitName = GetStr_PASCAL(addr)
            units.append(unitName)
            ida_bytes.del_items(addr, ida_bytes.DELIT_DELNAMES, Byte(addr) + 1)
            MakeStr_PASCAL(addr)
            addr += Byte(addr) + 1

    ida_kernwin.hide_wait_box()

    return units


def FindInitTable() -> int:
    initTable = 0

    if Is64bit():
        initTable = _findInitTable(40)
    else:
        initTable = _findInitTable(4)

        if initTable == 0:
            initTable = _findInitTable(20)

    return initTable


def _findInitTable(offset: int) -> int:
    addr = ida_ida.inf_get_min_ea()
    maxAddr = ida_ida.inf_get_max_ea()
    initTable = 0

    procWordSize = GetProcessorWordSize()

    while addr < maxAddr - offset:
        initTable = GetProcessorWord(addr)

        if initTable == addr + offset:
            initTable -= offset + procWordSize
            num = GetProcessorWord(initTable)

            if num > 0 and num < 10000:
                pos = addr + offset

                for i in range(num):
                    funcAddr = GetProcessorWord(pos)

                    if funcAddr and not ida_bytes.is_loaded(funcAddr):
                        initTable = 0
                        break

                    funcAddr = GetProcessorWord(pos + procWordSize)

                    if funcAddr and not ida_bytes.is_loaded(funcAddr):
                        initTable = 0
                        break

                    pos += 2 * procWordSize

                if initTable:
                    break

        initTable = 0
        addr += procWordSize

    return initTable


def IsExtendedInitTab() -> bool:
    if _findInitTable(4):
        return False
    if _findInitTable(20):
        return True
    else:
        return False


def DemangleFuncName(funcAddr: int) -> str:
    funcName = ida_name.get_name(funcAddr)

    if "@" in funcName:
        funcNameSplitted = funcName.split("$")
        names = funcNameSplitted[0]

        parameters = ""
        if "$" in funcName:
            parameters = funcNameSplitted[1]

        namesSplitted = names.split("@")

        if namesSplitted[-1] == "":
            if namesSplitted[-2] == "":
                print(f"[WARNING] FixFuncName: Unmangling error - {funcName}")
            elif parameters == "bctr":
                funcName = namesSplitted[-2] + "_Constructor"
            elif parameters == "bdtr":
                funcName = namesSplitted[-2] + "_Destructor"
            else:
                print(f"[WARNING] FixFuncName: Unmangling error - {funcName}")
        elif namesSplitted[-1] == "":
            funcName = namesSplitted[-3] + "_" + namesSplitted[-1]
        else:
            funcName = namesSplitted[-2] + "_" + namesSplitted[-1]

        MakeName(funcAddr, FixName(funcName))

    return ida_name.get_name(funcAddr)


def ParseMangledFunctionName(mang_func_name: str) -> str:
    func_name_splitted = mang_func_name.split("$")
    tmp = func_name_splitted[0]
    tmp_splitted = tmp.split("@")
    used_keywords = []
    new_function_name = ""
    last_iteration_inserted = False

    for name in tmp_splitted:
        if name == "":
            continue

        if last_iteration_inserted:
            new_function_name += "_"
            last_iteration_inserted = False

        if name not in used_keywords:
            new_function_name += name
            last_iteration_inserted = True
            used_keywords.append(name)

    return new_function_name


def GetParamRegister(index: int) -> str:
    procWordSize = GetProcessorWordSize()
    regStr = str()

    if procWordSize == 4:
        if index == 0:
            regStr = "@<eax>"
        elif index == 1:
            regStr = "@<edx>"
        elif index == 2:
            regStr = "@<ecx>"
    else:
        if index == 0:
            regStr = "@<rcx>"
        elif index == 1:
            regStr = "@<rdx>"
        elif index == 2:
            regStr = "@<r8>"
        elif index == 3:
            regStr = "@<r9>"

    return regStr

```

`DelphiHelper/util/exception.py`:

```py
#
# This module implements DelphiHelper exception
#
# Copyright (c) 2020-2025 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


class DelphiHelperError(Exception):

    def __init__(self, msg: str = str(), msgType: int = 0) -> None:
        Exception.__init__(self, msg)
        self.msg = msg

        if msgType == 0:
            self.msgType = "[ERROR]"
        else:
            self.msgType = "[WARNING]"

    def print(self) -> None:
        if self.msg:
            print(f"{self.msgType} {self.msg}")

```

`DelphiHelper/util/ida.py`:

```py
#
# This module implements simple IDA utilities
#
# Copyright (c) 2020-2026 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import ida_auto
import ida_bytes
import ida_funcs
import ida_ida
import ida_idaapi
import ida_nalt
import ida_name
import ida_search
import ida_ua
import ida_pro
import idc


def find_bytes(
        search: str,
        address: int = 0,
        forward_search: bool = True) -> int:
    # IDA 9.0
    if ida_pro.IDA_SDK_VERSION >= 900:
        if forward_search:
            address = ida_bytes.find_bytes(search, address)
        else:
            address = ida_bytes.find_bytes(
                search,
                range_start=0,
                range_end=address,
                flags=ida_bytes.BIN_SEARCH_BACKWARD
            )
    # IDA 8.4
    elif ida_pro.IDA_SDK_VERSION == 840:
        if forward_search:
            address = ida_search.find_binary(address, -1, search, 0x10, ida_search.SEARCH_DOWN)
        else:
            address = ida_search.find_binary(0, address, search, 0x10, ida_search.SEARCH_UP)
    else:
        print("[WARNING] Unsupported IDA version. Supported versions: IDA 8.4+")
        return ida_idaapi.BADADDR

    return address

def GetStructComment(structID: int) -> str or None:
    if ida_pro.IDA_SDK_VERSION >= 900:
        return idc.get_struc_cmt(structID)
    else:
        return idc.get_struc_cmt(structID, 0)

def GetStructMemberComment(structID: int, offset: int) -> str or None:
    if ida_pro.IDA_SDK_VERSION >= 900:
        return idc.get_member_cmt(structID, offset)
    else:
        return idc.get_member_cmt(structID, offset, False)

def Is64bit() -> bool:
    return ida_ida.inf_is_64bit()


def Is32bit() -> bool:
    return ida_ida.inf_is_32bit_exactly()


def GetProcessorWordSize() -> int:
    if Is64bit() is True:
        return 8
    elif Is32bit() is True:
        return 4
    else:
        raise Exception("Unsupported word size!")


def GetCustomWord(addr: int, wordSize: int = 4) -> int:
    if wordSize == 8:
        return Qword(addr)
    elif wordSize == 4:
        return Dword(addr)
    else:
        raise Exception("Unsupported word size!")


def MakeCustomWord(addr: int, wordSize: int = 4) -> None:
    if wordSize == 8:
        MakeQword(addr)
    elif wordSize == 4:
        MakeDword(addr)
    else:
        raise Exception("Unsupported word size!")


def GetProcessorWord(addr: int) -> int:
    wordSize = GetProcessorWordSize()
    if wordSize == 8:
        return Qword(addr)
    elif wordSize == 4:
        return Dword(addr)
    else:
        raise Exception("Unsupported word size!")


def MakeProccesorWord(addr: int) -> None:
    wordSize = GetProcessorWordSize()
    if wordSize == 8:
        MakeQword(addr)
    elif wordSize == 4:
        MakeDword(addr)
    else:
        raise Exception("Unsupported word size!")


def Byte(addr: int) -> int:
    return ida_bytes.get_wide_byte(addr)


def Word(addr: int) -> int:
    return ida_bytes.get_wide_word(addr)


def Dword(addr: int) -> int:
    return ida_bytes.get_wide_dword(addr)


def Qword(addr: int) -> int:
    return ida_bytes.get_qword(addr)


def MakeByte(addr: int) -> None:
    ida_bytes.create_data(addr, ida_bytes.FF_BYTE, 1, ida_idaapi.BADADDR)


def MakeWord(addr: int) -> None:
    ida_bytes.create_data(addr, ida_bytes.FF_WORD, 2, ida_idaapi.BADADDR)


def MakeDword(addr: int) -> None:
    ida_bytes.create_data(addr, ida_bytes.FF_DWORD, 4, ida_idaapi.BADADDR)


def MakeQword(addr: int) -> None:
    ida_bytes.create_data(addr, ida_bytes.FF_QWORD, 8, ida_idaapi.BADADDR)


def GetStr(addr: int, strType: int, strLen: int = -1) -> bytes | None:
    return ida_bytes.get_strlit_contents(addr, strLen, strType)


def GetStr_PASCAL(addr: int) -> bytes | None:
    return GetStr(addr, ida_nalt.STRTYPE_PASCAL, Byte(addr) + 1).decode()


def MakeStr(startAddr: int, endAddr: int = ida_idaapi.BADADDR) -> None:
    idc.create_strlit(startAddr, endAddr)


def MakeStr_PASCAL(startAddr: int) -> None:
    oldStringType = idc.get_inf_attr(ida_ida.INF_STRTYPE)
    idc.set_inf_attr(ida_ida.INF_STRTYPE, ida_nalt.STRTYPE_PASCAL)
    MakeStr(startAddr, startAddr + Byte(startAddr) + 1)
    idc.set_inf_attr(ida_ida.INF_STRTYPE, oldStringType)


def FindRef_Dword(
        fromAddr: int,
        dwordToFind: int,
        flag: int = ida_bytes.BIN_SEARCH_FORWARD) -> int:
    stringToFind = str()

    for i in range(4):
        stringToFind += "%02X " % ((dwordToFind >> 8*i) & 0xff)

    if flag == ida_bytes.BIN_SEARCH_FORWARD:
        return find_bytes(stringToFind, fromAddr)
    else:
        return find_bytes(stringToFind, fromAddr, False)


def FindRef_Qword(
        fromAddr: int,
        qwordToFind: int,
        flag: int = ida_bytes.BIN_SEARCH_FORWARD) -> int:
    stringToFind = str()

    for i in range(8):
        stringToFind += "%02X " % ((qwordToFind >> 8*i) & 0xff)

    if flag == ida_bytes.BIN_SEARCH_FORWARD:
        return find_bytes(stringToFind, fromAddr)
    else:
        return find_bytes(stringToFind, fromAddr, False)


def FixName(name: str) -> str:
    name = "".join(i for i in name if ord(i) < 128)
    for elem in [".", "<", ">", ":", ",", "%", "&", "{", "}"]:
        if elem in name:
            name = name.replace(elem, "_")
    return name


def MakeName(addr: int, name: str) -> None:
    name = FixName(name)
    # ida_idaapi.SN_FORCE == 0x800
    ida_name.set_name(
        addr,
        name,
        ida_name.SN_NOCHECK | ida_name.SN_NOWARN | 0x800
    )


def MakeFunction(addr: int) -> None:
    ida_funcs.del_func(addr)
    ida_bytes.del_items(addr, ida_bytes.DELIT_SIMPLE, 1)
    ida_ua.create_insn(addr)
    ida_auto.auto_wait()
    ida_funcs.add_func(addr)

```

`LICENSE`:

```
Copyright (c) 2020-2024, ESET
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FreeBSD Project.
```

`README.md`:

```md
# DelphiHelper

DelphiHelper is a python IDA Pro plugin aiming to help the analysis of
x86/x86_64 binaries written in
[Delphi](https://www.embarcadero.com/products/delphi) programming language.

## Table of Contents


## Features

* Displays an interactive tree view of Delphi's DFM (Delphi Form Modules)
resource (Delphi Form description)
* Parses Delphi's RTTI data structures
* Extracts useful information from Delphi's RTTI data structures
* Extracts binary files embedded in Delphi's DFM resources
* Searches for the Entry Point (EP) function
* Loads Delphi's FLIRT signatures automatically
* Loads Interactive Delphi Reconstructor (IDR) Knowledge Base (KB) function
signatures 

## Installation

1. Copy `DelphiHelper` directory and `DelphiHelper.py` inside the IDA plugin
   directory:
   * on Windows: `%APPDATA%\Hex-Rays\IDA Pro\plugins\`
   * on macOS/Linux: `$HOME/.idapro/plugins/`
2. Download IDR Knowledge Base files manually by following 
   [instructions](#download-instructions) given below or run the script
   `setup_IDRKB.py`.

   > **_NOTE_**: `py7zr` installation is required to run the setup script: 
   `pip install py7zr`

**DelphiHelper** should be compatible with IDA 8.4 and later on Windows, macOS
and GNU/Linux.

## Usage

In order to use the DelphiHelper plugin, the resource section has to be loaded
in IDA. This can be achieved by checking the box **Load resources** or with the
option `-R` in the command line switch.

![Loading a file in IDA Pro GUI.](img/LoadFile.PNG)

> **_NOTE_**: IDA autoanalysis must be completed before using the plugin.

### Hotkeys

* `<Alt-Shift-H>`: Print Help
* `<Alt-Shift-R>`: Run [VMT Parser](#vmt-parser)
* `<Alt-Shift-F>`: Run [DFM Finder](#dfm-finder) (show Delphi Form Viewer window)
* `<Alt-Shift-E>`: Run [Entry Point Function Finder](#entry-point-function-finder)
* `<Alt-Shift-S>`: Run [IDR Knowledge Base Loader](#idr-knowledge-base-loader) for `SysInit` and `System` unit
* `<Alt-Shift-A>`: Run [IDR Knowledge Base Loader](#idr-knowledge-base-loader)
for selected units

### VMT Parser

**Hotkey**: `<Alt-Shift-R>`

The **Virtual Method Table (VMT) Parser** must be executed with the cursor on
the starting address of a VMT structure. This structure can be located by
searching the functions named `CreateForm`, `CreateObject`, etc.; once the
function is found, the last argument should be the VMT structure.

In most cases there is a sequence of two instructions:
```
mov <register>, <VMTStructureOffset>
call CreateForm
```

For example:

![Identifying of VMT structure offset.](img/CreateForm.PNG)

Once on the structure (VMTStructureOffset e.g. `off_664A8C`), press `<Enter>`:

![VMT structure.](img/VMTStructure.PNG)

Press the hotkey `<Alt-Shift-R>`. The result looks like below:

![Parsed VMT structure.](img/VMTStructureParsed.PNG)

The VMT structure contains a lot of useful information stored in various RTTI
tables. The most interesting ones are:
* [Field Table](#field-table)
* [Virtual Method Table (VMT)](#virtual-method-table-(vmt))
* [Method Table](#method-table)

The **VMT Parser** automatically extracts data from those tables and stores it
into IDA enums and structures. 

#### Field Table

The Field Table stores a name, a type and an offset of each published field.
The **VMT Parser** extracts and saves all these entries for each VMT structure
into IDA Enums:

![Field Table](img/FieldTable.PNG)

The enums created by the **VMT Parser** have following format:
`%ObjectName%_Fields`. The names of enum entries have this format:
`%ObjectName%_%FieldType%_%FieldName%`:

![Field Table in IDA Enum](img/IDAEnum_FieldTable.PNG)

The entries from enums created by the **VMT Parser** can be then named by
pressing built-in IDA shortcut `<M>`, used for naming symbolic constants.

**Before**

![Resolving a field from Field Table](img/FieldInFunc_Before.PNG)

**After**

![Resolving a field from Field Table](img/FieldInFunc_After.PNG)

In addition, entries from the Field Table are stored in an IDA structure named
`%ObjectName%_Self`. This structure contains not only the published fields
of the specific class, but also all fields inherited from its base classes:

![Class Structure](img/ClassStruct.PNG)

To map entries from the `%ObjectName%_Self` structure, use the built‑in IDA
shortcut `<T>`.

#### Virtual Method Table (VMT)

The Virtual Method Table stores pointers to all virtual methods declared for a
class and its base classes:

![VMT table](img/VMT.PNG)

The **VMT Parser** extracts pointers from the VMT and saves them into an IDA
structure named by the parsed VMT structure (`%ObjectName%_VMT`). The names
of structure entries have the following format: `%MethodName%_%MethodOffset%`:

![VMT table in IDA Structure](img/IDAStruct_VMT.PNG)

The entries from structures created by the **VMT Parser** can be then named by
pressing the built-in IDA shortcut `<T>`, used for naming structure offsets.

**Before**

![Call VMT method by offset](img/CallVMTFunc_Before.PNG)

**After**

![Call VMT method by offset](img/CallVMTFunc_After.PNG)


#### Method Table

The Method Table stores names and pointers of published methods. The Method
Table also contains pointers of Delphi Event handlers that can be found and
accessed from the **Delphi Form Viewer** (for more info see [DFM
Finder](#dfm-finder))

![Method Table](img/MethodTable.PNG)

### DFM Finder

**Hotkey**: `<Alt-Shift-F`

The **DFM Finder** tries to find all DFMs stored in a resource section of the
analyzed Delphi binary and after that it runs the **VMT Parser** on all VMT
structures associated with found DMFs. After all VMT structures are processed,
a new interactive IDA subview (**Delphi Form Viewer**) is displayed. The
subview shows a tree view of Delphi Form descriptions extracted from DFM:

![Delphi Form Viewer](img/DelphiFormViewer.PNG)

**Bold** nodes represent components that have some Delphi Event defined.
Follow such bold nodes deeper in a subtree until you spot bold `Properties`
node, where you can find a blue colored Delphi Event. By clicking on the Event
item, you are moved to a corresponding Event handler in the IDA Disassembly
window.

**Green** nodes represent components which have some binary file embedded.
Follow such green nodes deeper in a subtree until you spot green `Properties`
node, where you can find a green colored item. The item shows a file path of
the embedded binary file dropped by **DFM Finder**. The destination
subdirectory for extracted files is located in current IDA working directory
and has the following format:
`%IDAWorkingDirectory%\_extracted_%BinaryFileName%\` 

Click on a root (Form's) node in Delphi Form Viewer window moves you to the
Form's VMT structure in the IDA Disassembly window.

### Entry Point Function Finder

**Hotkey**: `<Alt-Shift-E>`

**Entry Point Function Finder** tries to find possible entry point functions by
searching for references to `CreateFrom`, `InitExe` and `InitLib` calls.
Results are presented in IDA's output window, e.g.:  

![Ouput of EP Function Finder](img/EPFinder.PNG)

### IDR Knowledge Base Loader

**Hotkeys**: `<Alt-Shift-S>` and  `<Alt-Shift-A>`

**IDR Knowledge Base Loader** loads IDR KB signatures from KB files. The plugin 
expects to have the KB files stored in the following location:

* on Windows: `%APPDATA%\Hex-Rays\IDA Pro\plugins\DelphiHelper\IDR_KB\`

* on macOS/Linux: `$HOME/.idapro/plugins/DelphiHelper/IDR_KB/`

`<Alt-Shift-S>` loads function signatures for only `SysInit` and `System`.

`<Alt-Shift-A>` tries to load function signatures for all units selected from a
list of imported units.

> **_NOTE_**: The KB files are downloaded from the IDR project:<br>
> https://github.com/crypto2011/IDR<br>
> https://github.com/crypto2011/IDR64

The IDR project is licensed under the MIT license:
``` 
MIT License

Copyright (c) 2006-2018 crypto

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

#### Download instructions

Download and copy following KB files into `DelphiHelper\IDR_KB\IDR64\`
directory:<br>
https://github.com/crypto2011/IDR64/blob/master/syskb2012.bin<br>
https://github.com/crypto2011/IDR64/blob/master/syskb2013.bin<br>
https://github.com/crypto2011/IDR64/blob/master/syskb2014.bin<br>

Download and **extract** following KB files into `DelphiHelper\IDR_KB\IDR\`
directory:<br>
https://github.com/crypto2011/IDR/blob/master/kb2005.7z<br>
https://github.com/crypto2011/IDR/blob/master/kb2006.7z<br>
https://github.com/crypto2011/IDR/blob/master/kb2007.7z<br>
https://github.com/crypto2011/IDR/blob/master/kb2009.7z<br>
https://github.com/crypto2011/IDR/blob/master/kb2010.7z<br>
https://github.com/crypto2011/IDR/blob/master/kb2011.7z<br>
https://github.com/crypto2011/IDR/blob/master/kb2012.7z<br>
https://github.com/crypto2011/IDR/blob/master/kb2013.7z<br>
https://github.com/crypto2011/IDR/blob/master/kb2014.7z

```

`ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "DelphiHelper",
    "entryPoint": "DelphiHelper.py",
    "version": "1.22",
    "idaVersions": ">=8.4",
    "description": "Analyzes Delphi binaries with VMT parsing, form viewing, and IDR Knowledge Base integration.",
    "license": "BSD 2-Clause",
    "pythonDependencies": ["py7zr"],
    "categories": [
      "file-parsers-and-loaders",
      "decompilation",
      "ui-ux-and-visualization"
    ],
    "urls": {
      "repository": "https://github.com/eset/DelphiHelper"
    },
    "authors": [
      {
        "name": "Juraj Horňák",
        "email": "juraj.hornak@eset.com"
      },
      {
        "name": "Tom Dupuy",
        "email": "thomas.dupuy@eset.com"
      }
    ],
    "keywords": [
      "delphi",
      "borland",
      "embarcadero",
      "rtti",
      "vmt",
      "virtual-method-table",
      "dfm",
      "form-viewer",
      "idr",
      "knowledge-base",
      "pascal",
      "object-pascal",
      "windows-forms",
      "vcl",
      "rad-studio"
    ]
  }
}

```

`setup_IDRKB.py`:

```py
#
# This script downloads IDR Knowledge Base files used by DelphiHelper plugin
#
# The script downloads KB files from IDR projects:
# https://github.com/crypto2011/IDR,
# https://github.com/crypto2011/IDR64,
# which are licensed under the MIT License:
# https://github.com/crypto2011/IDR/blob/master/LICENSE
#
# Copyright (c) 2020-2024 ESET
# Author: Juraj Horňák <juraj.hornak@eset.com>
# See LICENSE file for redistribution.


import os
import py7zr
import shutil
import sys
import urllib.error
import urllib.request


IDRKBDIR = "IDR_KB"
PLUGIN_PATH = os.path.expandvars("$HOME/.idapro/plugins/DelphiHelper/")
if sys.platform == "win32":
    PLUGIN_PATH = os.path.expandvars("%APPDATA%\\Hex-Rays\\IDA Pro\\plugins\\DelphiHelper\\")
IDR_PATH = os.path.join(PLUGIN_PATH, IDRKBDIR)

DOWNLOADLIST_IDR = [
    ("kb2005.7z", "https://raw.githubusercontent.com/crypto2011/IDR/master/kb2005.7z"),
    ("kb2006.7z", "https://raw.githubusercontent.com/crypto2011/IDR/master/kb2006.7z"),
    ("kb2007.7z", "https://raw.githubusercontent.com/crypto2011/IDR/master/kb2007.7z"),
    ("kb2009.7z", "https://raw.githubusercontent.com/crypto2011/IDR/master/kb2009.7z"),
    ("kb2010.7z", "https://raw.githubusercontent.com/crypto2011/IDR/master/kb2010.7z"),
    ("kb2011.7z", "https://raw.githubusercontent.com/crypto2011/IDR/master/kb2011.7z"),
    ("kb2012.7z", "https://raw.githubusercontent.com/crypto2011/IDR/master/kb2012.7z"),
    ("kb2013.7z", "https://raw.githubusercontent.com/crypto2011/IDR/master/kb2013.7z"),
    ("kb2014.7z", "https://raw.githubusercontent.com/crypto2011/IDR/master/kb2014.7z")
]

DOWNLOADLIST_IDR64 = [
    ("syskb2012.bin", "https://raw.githubusercontent.com/crypto2011/IDR64/master/syskb2012.bin"),
    ("syskb2013.bin", "https://raw.githubusercontent.com/crypto2011/IDR64/master/syskb2013.bin"),
    ("syskb2014.bin", "https://raw.githubusercontent.com/crypto2011/IDR64/master/syskb2014.bin")
]


def downloadFile(url: str, filename: str) -> bool:
    print(f"[INFO] Downloading file from: {url}")

    try:
        urllib.request.urlretrieve(url, filename)
    except urllib.error.HTTPError as e:
        print(f"[ERROR] HTTPError: {e.msg} ({e.url})")
        return False

    print(f"[INFO] The file saved as \"{filename}\"")
    return True

def unpack7z(archivePath: str, destinationFolder: str) -> bool:
    print(f"[INFO] Unpacking archive \"{archivePath}\"...")

    if not py7zr.is_7zfile(archivePath):
        print(f"[ERROR] {archivePath} is not valid 7z file.")
        return False

    with py7zr.SevenZipFile(archivePath, "r") as archive:
        archive.extractall(path=destinationFolder)

    return True

def init() -> bool:
    try:
        if not os.path.exists(PLUGIN_PATH):
            print(f"[ERROR] DelphiHelper directory \"{PLUGIN_PATH}\" not found!")
            print("[INFO] Read the README.md for DelphiHelper installation location.")
            return False

        if os.path.exists(IDR_PATH):
            shutil.rmtree(IDR_PATH)

        os.mkdir(IDR_PATH)
        os.mkdir(os.path.join(IDR_PATH, "IDR"))
        os.mkdir(os.path.join(IDR_PATH, "IDR64"))
    except FileNotFoundError as e:
        raise e

    return True

def downloadIDRKB() -> None:
    if init():
        print("[INFO] Downloading IDR Knowledge Base files...")
        for filename, url in DOWNLOADLIST_IDR64:
            downloadFile(url, os.path.join(IDR_PATH, "IDR64", filename))

        for filename, url in DOWNLOADLIST_IDR:
            downloadFile(url, filename)
            unpack7z(filename, os.path.join(IDR_PATH, "IDR"))
            os.remove(filename)

downloadIDRKB()

```