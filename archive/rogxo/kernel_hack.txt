Project Path: arc_rogxo_kernel_hack_e4qr1h82

Source Tree:

```txt
arc_rogxo_kernel_hack_e4qr1h82
├── LICENSE
├── README.md
└── kernel_hack
    ├── km
    │   ├── Kconfig
    │   ├── Makefile
    │   ├── comm.h
    │   ├── entry.c
    │   ├── memory.c
    │   ├── memory.h
    │   ├── process.c
    │   ├── process.h
    │   ├── verify.c
    │   └── verify.h
    └── um
        ├── Makefile
        ├── driver.hpp
        ├── main.cpp
        └── test.sh

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 Rog

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# kernel_hack
linux kernel read/write process memory

安卓内核通过进程页目录基址计算虚拟地址的物理页读取物理内存
可过缺页检测
## ioctl+phys & bypass pte->present detection

注意：未实现多物理页页读，读取内存过长时会出现错误

## Contact

```

`kernel_hack/km/Kconfig`:

```
config KERNEL_HACK
    tristate "Kernel Hack Driver"
    default y
    help
    This is the kernel hack driver for android system.


```

`kernel_hack/km/Makefile`:

```
obj-y += memory.o
obj-y += process.o
obj-y += verify.o
obj-y += entry.o


```

`kernel_hack/km/comm.h`:

```h
typedef struct _COPY_MEMORY {
    pid_t pid;
    uintptr_t addr;
    void* buffer;
    size_t size;
} COPY_MEMORY, *PCOPY_MEMORY;

typedef struct _MODULE_BASE {
    pid_t pid;
    char* name;
    uintptr_t base;
} MODULE_BASE, *PMODULE_BASE;

enum OPERATIONS {
    OP_INIT_KEY = 0x800,
    OP_READ_MEM = 0x801,
    OP_WRITE_MEM = 0x802,
    OP_MODULE_BASE = 0x803,
};
```

`kernel_hack/km/entry.c`:

```c
#include <linux/module.h>
#include <linux/tty.h>
#include <linux/miscdevice.h>
#include "comm.h"
#include "memory.h"
#include "process.h"
#include "verify.h"

#define DEVICE_NAME "kernel_hack"

int dispatch_open(struct inode *node, struct file *file)
{
    return 0;
}

int dispatch_close(struct inode *node, struct file *file)
{
    return 0;
}

long dispatch_ioctl(struct file* const file, unsigned int const cmd, unsigned long const arg)
{
    COPY_MEMORY cm;
    MODULE_BASE mb;
    char key[0x100] = {0};
    char name[0x100] = {0};
    static bool is_verified = false;

    if (cmd == OP_INIT_KEY && !is_verified) {
        if (copy_from_user(key, (void __user*)arg, sizeof(key)-1) != 0) {
            return -1;
        }
        is_verified = init_key(key, sizeof(key));
    }
    if (is_verified == false) {
        return -1;
    }
    switch (cmd) {
        case OP_READ_MEM:
            {
                if (copy_from_user(&cm, (void __user*)arg, sizeof(cm)) != 0) {
                    return -1;
                }
                if (read_process_memory(cm.pid, cm.addr, cm.buffer, cm.size) == false) {
                    return -1;
                }
            }
            break;
        case OP_WRITE_MEM:
            {
                if (copy_from_user(&cm, (void __user*)arg, sizeof(cm)) != 0) {
                    return -1;
                }
                if (write_process_memory(cm.pid, cm.addr, cm.buffer, cm.size) == false) {
                    return -1;
                }
            }
            break;
        case OP_MODULE_BASE:
            {
                if (copy_from_user(&mb, (void __user*)arg, sizeof(mb)) != 0 
                ||  copy_from_user(name, (void __user*)mb.name, sizeof(name)-1) !=0) {
                    return -1;
                }
                mb.base = get_module_base(mb.pid, name);
                if (copy_to_user((void __user*)arg, &mb, sizeof(mb)) !=0) {
                    return -1;
                }
            }
            break;
        default:
            break;
    }
    return 0;
}

struct file_operations dispatch_functions = {
    .owner   = THIS_MODULE,
    .open    = dispatch_open,
    .release = dispatch_close,
    .unlocked_ioctl = dispatch_ioctl,
};

struct miscdevice misc = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = DEVICE_NAME,
	.fops = &dispatch_functions,
};

int __init driver_entry(void)
{
    int ret;
    printk("[+] driver_entry");
	ret = misc_register(&misc);
	return ret;
}

void __exit driver_unload(void)
{
    printk("[+] driver_unload");
	misc_deregister(&misc);
}

module_init(driver_entry);
module_exit(driver_unload);

MODULE_DESCRIPTION("Linux Kernel H4cking.");
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Rog");

```

`kernel_hack/km/memory.c`:

```c
#include "memory.h"
#include <linux/tty.h>
#include <linux/io.h>
#include <linux/mm.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <linux/version.h>

#include <asm/cpu.h>
#include <asm/io.h>
#include <asm/page.h>
#include <asm/pgtable.h>

extern struct mm_struct *get_task_mm(struct task_struct *task);

#if(LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 61))
extern void mmput(struct mm_struct *);

phys_addr_t translate_linear_address(struct mm_struct* mm, uintptr_t va) {

    pgd_t *pgd;
    p4d_t *p4d;
    pmd_t *pmd;
    pte_t *pte;
    pud_t *pud;
	
    phys_addr_t page_addr;
    uintptr_t page_offset;
    
    pgd = pgd_offset(mm, va);
    if(pgd_none(*pgd) || pgd_bad(*pgd)) {
        return 0;
    }
    p4d = p4d_offset(pgd, va);
    if (p4d_none(*p4d) || p4d_bad(*p4d)) {
    	return 0;
    }
	pud = pud_offset(p4d,va);
	if(pud_none(*pud) || pud_bad(*pud)) {
        return 0;
    }
	pmd = pmd_offset(pud,va);
	if(pmd_none(*pmd)) {
        return 0;
    }
	pte = pte_offset_kernel(pmd,va);
	if(pte_none(*pte)) {
        return 0;
    }
	if(!pte_present(*pte)) {
        return 0;
    }
	//页物理地址
	page_addr = (phys_addr_t)(pte_pfn(*pte) << PAGE_SHIFT);
	//页内偏移
	page_offset = va & (PAGE_SIZE-1);
	
	return page_addr + page_offset;
}
#else
phys_addr_t translate_linear_address(struct mm_struct* mm, uintptr_t va) {

    pgd_t *pgd;
    pmd_t *pmd;
    pte_t *pte;
    pud_t *pud;
	
    phys_addr_t page_addr;
    uintptr_t page_offset;
    
    pgd = pgd_offset(mm, va);
    if(pgd_none(*pgd) || pgd_bad(*pgd)) {
        return 0;
    }
	pud = pud_offset(pgd,va);
	if(pud_none(*pud) || pud_bad(*pud)) {
        return 0;
    }
	pmd = pmd_offset(pud,va);
	if(pmd_none(*pmd)) {
        return 0;
    }
	pte = pte_offset_kernel(pmd,va);
	if(pte_none(*pte)) {
        return 0;
    }
	if(!pte_present(*pte)) {
        return 0;
    }
	//页物理地址
	page_addr = (phys_addr_t)(pte_pfn(*pte) << PAGE_SHIFT);
	//页内偏移
	page_offset = va & (PAGE_SIZE-1);
	
	return page_addr + page_offset;
}
#endif

#ifndef ARCH_HAS_VALID_PHYS_ADDR_RANGE
static inline int valid_phys_addr_range(phys_addr_t addr, size_t count) {
    return addr + count <= __pa(high_memory);
}
#endif

bool read_physical_address(phys_addr_t pa, void* buffer, size_t size) {
    void* mapped;

    if (!pfn_valid(__phys_to_pfn(pa))) {
        return false;
    }
    if (!valid_phys_addr_range(pa, size)) {
        return false;
    }
    mapped = ioremap_cache(pa, size);
    if (!mapped) {
        return false;
    }
    if(copy_to_user(buffer, mapped, size)) {
        iounmap(mapped);
        return false;
    }
    iounmap(mapped);
    return true;
}

bool write_physical_address(phys_addr_t pa, void* buffer, size_t size) {
    void* mapped;

    if (!pfn_valid(__phys_to_pfn(pa))) {
        return false;
    }
    if (!valid_phys_addr_range(pa, size)) {
        return false;
    }
    mapped = ioremap_cache(pa, size);
    if (!mapped) {
        return false;
    }
    if(copy_from_user(mapped, buffer, size)) {
        iounmap(mapped);
        return false;
    }
    iounmap(mapped);
    return true;
}

/*
static inline unsigned long size_inside_page(unsigned long start,
					     unsigned long size) {
	unsigned long sz;
	sz = PAGE_SIZE - (start & (PAGE_SIZE - 1));
	return min(sz, size);
}

static inline bool should_stop_iteration(void) {
	if (need_resched())
		cond_resched();
	return signal_pending(current);
}

static long x_probe_kernel_read(void *dst, const char *src, size_t size) {
#if(LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 61))
    return copy_from_kernel_nofault(dst, src, size);
#else
    return probe_kernel_read(dst, src, size);
#endif
}

static long x_probe_kernel_write(void *dst, const char *src, size_t size) {
#if(LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 61))
    return copy_to_kernel_nofault(dst, src, size);
#else
    return probe_kernel_write(dst, src, size);
#endif
}


bool read_physical_address(phys_addr_t pa, void* buffer, size_t size) {

    void* mapped;
    ssize_t sz;
	char* bounce;
    char* buf = buffer;
    
    if (!pfn_valid(__phys_to_pfn(pa)))
        return false;

    if (!valid_phys_addr_range(pa, size))
        return false;
    
    bounce = kmalloc(PAGE_SIZE, GFP_KERNEL);
	if (!bounce)
		return false;

	while (size > 0) {
		unsigned long remaining;
		int probe;

		sz = size_inside_page(pa, size);

		mapped = xlate_dev_mem_ptr(pa);
		if (!mapped)
			goto failed;

		probe = x_probe_kernel_read(bounce, mapped, sz);
		unxlate_dev_mem_ptr(pa, mapped);
		if (probe)
			goto failed;

		remaining = copy_to_user(buf, bounce, sz);

		if (remaining)
			goto failed;

		buf += sz;
		pa += sz;
		size -= sz;
		if (should_stop_iteration())
			break;
	}
	kfree(bounce);
    return true;

failed:
	kfree(bounce);
	return false;
}

bool write_physical_address(phys_addr_t pa, void* buffer, size_t size) {
    
    void* mapped;
    ssize_t sz;
	char* bounce;
    char* buf = buffer;

    if (!pfn_valid(__phys_to_pfn(pa)))
        return false;

    if (!valid_phys_addr_range(pa, size))
        return false;
    
    bounce = kmalloc(PAGE_SIZE, GFP_KERNEL);
	if (!bounce)
		return false;

	while (size > 0) {
		unsigned long remaining;
		int probe;

		sz = size_inside_page(pa, size);

        remaining = copy_from_user(bounce, buf, sz);
		if (remaining)
			goto failed;

		mapped = xlate_dev_mem_ptr(pa);
		if (!mapped)
			goto failed;

		probe = x_probe_kernel_write(mapped, bounce, sz);
		unxlate_dev_mem_ptr(pa, mapped);
		if (probe)
			goto failed;

		buf += sz;
		pa += sz;
		size -= sz;
		if (should_stop_iteration())
			break;
	}
	kfree(bounce);
    return true;

failed:
	kfree(bounce);
	return false;
}
*/

bool read_process_memory(
    pid_t pid, 
    uintptr_t addr, 
    void* buffer, 
    size_t size) {
    
    struct task_struct* task;
    struct mm_struct* mm;
    struct pid* pid_struct;
    phys_addr_t pa;

    pid_struct = find_get_pid(pid);
    if (!pid_struct) {
        return false;
    }
	task = get_pid_task(pid_struct, PIDTYPE_PID);
	if (!task) {
        return false;
    }
    put_task_struct(task);
	mm = get_task_mm(task);
    if (!mm) {
        return false;
    }
    mmput(mm);
    pa = translate_linear_address(mm, addr);
    if (!pa) {
        return false;
    }
    //printk("[*] physical_address = %lx",pa);
    return read_physical_address(pa, buffer, size);
}

bool write_process_memory(
    pid_t pid, 
    uintptr_t addr, 
    void* buffer, 
    size_t size) {
    
    struct task_struct* task;
    struct mm_struct* mm;
    struct pid* pid_struct;
    phys_addr_t pa;

    pid_struct = find_get_pid(pid);
    if (!pid_struct) {
        return false;
    }
    task = get_pid_task(pid_struct, PIDTYPE_PID);
    if (!task) {
        return false;
    }
    put_task_struct(task);
    mm = get_task_mm(task);
    if (!mm) {
        return false;
    }
    mmput(mm);
    pa = translate_linear_address(mm, addr);
    if (!pa) {
        return false;
    }
    return write_physical_address(pa,buffer,size);
}

```

`kernel_hack/km/memory.h`:

```h
#include <linux/kernel.h>
#include <linux/sched.h>

phys_addr_t translate_linear_address(struct mm_struct* mm, uintptr_t va);

bool read_physical_address(phys_addr_t pa, void* buffer, size_t size);

bool write_physical_address(phys_addr_t pa, void* buffer, size_t size);

bool read_process_memory(pid_t pid, uintptr_t addr, void* buffer, size_t size);

bool write_process_memory(pid_t pid, uintptr_t addr, void* buffer, size_t size);

```

`kernel_hack/km/process.c`:

```c
#include "process.h"
#include <linux/sched.h>
#include <linux/module.h>
#include <linux/tty.h>
#include <linux/mm.h>
#include <linux/version.h>

#define ARC_PATH_MAX 256

extern struct mm_struct *get_task_mm(struct task_struct *task);

#if(LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 61))
extern void mmput(struct mm_struct *);
#endif

uintptr_t get_module_base(pid_t pid, char* name) 
{
    struct pid* pid_struct;
    struct task_struct* task;
    struct mm_struct* mm;
    struct vm_area_struct *vma;

    pid_struct = find_get_pid(pid);
    if (!pid_struct) {
        return false;
    }
    task = get_pid_task(pid_struct, PIDTYPE_PID);
    if (!task) {
        return false;
    }
    mm = get_task_mm(task);
    if (!mm) {
        return false;
    }
    mmput(mm);

    for (vma = mm->mmap; vma; vma = vma->vm_next) {
        char buf[ARC_PATH_MAX];
        char *path_nm = "";

        if (vma->vm_file) {
            path_nm = file_path(vma->vm_file, buf, ARC_PATH_MAX-1);
            if (!strcmp(kbasename(path_nm), name)) {
                return vma->vm_start;
            }
        }
    }
    return 0;
}
 
```

`kernel_hack/km/process.h`:

```h
#include <linux/kernel.h>

uintptr_t get_module_base(pid_t pid, char* name);

```

`kernel_hack/km/verify.c`:

```c
#include "verify.h"
#include <linux/net.h>
#include <linux/inet.h>
#include <net/sock.h>

char rc4_key[] = "!@##$asdcgfxxxop";

void rc4_init(unsigned char* s, unsigned char* key, unsigned long len_key)
{
	int i = 0, j = 0;
	unsigned char k[256] = { 0 };
	unsigned char tmp = 0;
	for (i = 0; i < 256; i++) {
		s[i] = i;
		k[i] = key[i % len_key];
	}
	for (i = 0; i < 256; i++) {
		j = (j + s[i] + k[i]) % 256;
		tmp = s[i];
		s[i] = s[j];
		s[j] = tmp;
	}
}

void rc4_crypt(unsigned char* data, 
    unsigned long len_data, unsigned char* key, 
    unsigned long len_key)
{
	unsigned char s[256];
	int i = 0, j = 0, t = 0;
	unsigned long k = 0;
	unsigned char tmp;
	rc4_init(s, key, len_key);
	for (k = 0; k < len_data; k++) {
		i = (i + 1) % 256;
		j = (j + s[i]) % 256;
		tmp = s[i];
		s[i] = s[j];
		s[j] = tmp;
		t = (s[i] + s[j]) % 256;
		data[k] = data[k] ^ s[t];
	}
}

bool encrypt_key(char* keydata, size_t len, int* magic) {
    if (!keydata || len < 0x100) {
        return false;
    }

    *magic = *(int*)keydata ^ 0x0C8D778A;

	*(int*)&keydata[len - 5] = *magic;

    rc4_crypt(keydata, len, rc4_key, strlen(rc4_key));
    return true;
}

bool decrypt_key(char* keydata, size_t len, int magic) {
    if (!keydata || len < 0x100) {
        return false;
    }

    rc4_crypt(keydata, len, rc4_key, strlen(rc4_key));

	if(magic + 0x55 == *(int*)&keydata[len - 5]) {
        return true;
    }
    return false;
}

bool init_key(char* key, size_t len_key) {
    
    struct socket *sock;
    struct sockaddr_in addr;
    struct msghdr sendmsg, recvmsg;
    struct kvec send_vec, recv_vec;
    char* buf = NULL;
    int err, magic;

    memset(&addr, 0, sizeof(addr));
    memset(&sendmsg, 0, sizeof(sendmsg));
    memset(&send_vec, 0, sizeof(send_vec));
    memset(&recvmsg, 0, sizeof(recvmsg));
    memset(&recv_vec, 0, sizeof(recv_vec));

    if (!key || len_key < 0x100) {
        return false;
    }

    buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
    if (!buf) {
        return false;
    }

    err = sock_create_kern(&init_net, AF_INET, SOCK_STREAM, 0, &sock);
    if (err < 0) {
        goto fail;
    }

    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = in_aton("64.112.43.2");
    addr.sin_port = htons(31828);

    err = sock->ops->connect(sock, (struct sockaddr *)&addr, sizeof(addr), 0);
    if (err < 0) {
        goto fail;
    }

    memset(buf, 0, PAGE_SIZE);
    memcpy(buf, key ,len_key);
    encrypt_key(buf, 0x100, &magic);
    send_vec.iov_base = buf;
    send_vec.iov_len = 0x100;
    //send
    err = kernel_sendmsg(sock, &sendmsg, &send_vec, 1, 0x100);
    if (err < 0) {
        goto fail;
    }

    memset(buf, 0, PAGE_SIZE);
    recv_vec.iov_base = buf;
    recv_vec.iov_len = 0x100;
    //recv
    err = kernel_recvmsg(sock, &recvmsg, &recv_vec, 1, 0x100, 0);
    if (err < 0) {
        goto fail;
    }

    if(decrypt_key(buf, 0x100, magic)) {
        if (*(uint64_t*)&buf[0] == 0xDFFDABCD03007677) {
            sock_release(sock);
            return true;
        }
    }

fail:
 	if (sock) {
		sock_release(sock);
		sock = NULL;
	}
    if (buf) {
        kfree(buf);
    }
    return false;
}

```

`kernel_hack/km/verify.h`:

```h
#include <linux/kernel.h>

bool init_key(char* key, size_t len_key);

```

`kernel_hack/um/Makefile`:

```
CC := /home/rog/project/android_kernel/toolchain/gcc-arm-9.2-2019.12-x86_64-aarch64-none-linux-gnu/bin/aarch64-none-linux-gnu-g++
CFLAGS := -g
TARGET := main
SRCS := $(wildcard *.cpp)
OBJS := $(patsubst %cpp,%o,$(SRCS))
all:$(TARGET)
%.o:%.cpp
	$(CC) $(CFLAGS) -static -c $<
$(TARGET):$(OBJS)
	$(CC) $(CFLAGS) -static -o $@ $^
clean:
	rm -rf $(TARGET) *.o
```

`kernel_hack/um/driver.hpp`:

```hpp
#include <sys/fcntl.h>
#include <sys/ioctl.h>

#define DEVICE_NAME "/dev/kernel_hack"

class c_driver {
private:
    int fd;
    pid_t pid;

    typedef struct _COPY_MEMORY {
        pid_t pid;
        uintptr_t addr;
        void* buffer;
        size_t size;
    } COPY_MEMORY, *PCOPY_MEMORY;

    typedef struct _MODULE_BASE {
        pid_t pid;
        char* name;
        uintptr_t base;
    } MODULE_BASE, *PMODULE_BASE;

    enum OPERATIONS {
        OP_INIT_KEY = 0x800,
        OP_READ_MEM = 0x801,
        OP_WRITE_MEM = 0x802,
        OP_MODULE_BASE = 0x803,
    };

public:
    c_driver() {
        fd = open(DEVICE_NAME, O_RDWR);
        if (fd == -1) {
            printf("[-] open driver failed\n");
        }
    }

    ~c_driver() {
        //wont be called
        if (fd > 0)
            close(fd);
    }

    void initialize(pid_t pid) {
        this->pid = pid;
    }

    bool init_key(char* key) {
        char buf[0x100];
        strcpy(buf,key);
        if (ioctl(fd, OP_INIT_KEY, buf) != 0) {
            return false;
        }
        return true;
    }

    bool read(uintptr_t addr, void *buffer, size_t size) {
        COPY_MEMORY cm;

        cm.pid = this->pid;
        cm.addr = addr;
        cm.buffer = buffer;
        cm.size = size;

        if (ioctl(fd, OP_READ_MEM, &cm) != 0) {
            return false;
        }
        return true;
    }

    bool write(uintptr_t addr, void *buffer, size_t size) {
        COPY_MEMORY cm;

        cm.pid = this->pid;
        cm.addr = addr;
        cm.buffer = buffer;
        cm.size = size;

        if (ioctl(fd, OP_WRITE_MEM, &cm) != 0) {
            return false;
        }
        return true;
    }

    template <typename T>
    T read(uintptr_t addr) {
        T res;
        if (this->read(addr, &res, sizeof(T)))
            return res;
        return {};
    }

    template <typename T>
    bool write(uintptr_t addr,T value) {
        return this->write(addr, &value, sizeof(T));
    }

    uintptr_t get_module_base(char* name) {
        MODULE_BASE mb;
        char buf[0x100];
        strcpy(buf,name);
        mb.pid = this->pid;
        mb.name = buf;

        if (ioctl(fd, OP_MODULE_BASE, &mb) != 0) {
            return 0;
        }
        return mb.base;
    }
};

static c_driver *driver = new c_driver();

```

`kernel_hack/um/main.cpp`:

```cpp
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include "driver.hpp"

uint64_t get_tick_count64() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC,&ts);
    return (ts.tv_sec*1000 + ts.tv_nsec/(1000*1000));
}

pid_t get_name_pid(char* name) {
    FILE* fp;
    pid_t pid;
    char cmd[0x100] = "pidof ";

    strcat(cmd, name);
    fp = popen(cmd,"r");
    fscanf(fp,"%d", &pid);
    pclose(fp);
    return pid;
}

int main(int argc, char const *argv[]) {

    uintptr_t base = 0;
    uint64_t result = 0;
    char module_name[0x100] = "libunity.so";    //strlen(name) < 0xff or overflow
    pid_t pid = get_name_pid((char*)"com.tencent.tmgp.sgame");
    printf("pid = %d\n", pid);

    driver->init_key("paste your driver verify key here");
    driver->initialize(pid);

    base = driver->get_module_base(module_name);
    printf("base = %lx\n", base);

    //driver->write<uint64_t>(addr, 0xfedcba987654321);
    {
		size_t number = 1;
		uint64_t now = get_tick_count64();
		for (size_t i = 0; i < number; i++) {
            result = driver->read<uint64_t>(base);
		}
		printf("Read %ld times cost = %lfs\n", number,
			(double)(get_tick_count64() - now) / 1000);
	}
    printf("result = %lx\n", result);

    return 0;
}

```

`kernel_hack/um/test.sh`:

```sh
make clean && make
#sudo ./main
#sudo dmesg
adb push main /data/local/tmp
#adb shell ./data/local/tmp/main

```