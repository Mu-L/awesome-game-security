Project Path: arc_korcankaraokcu_PINCE_ymrwq2s_

Source Tree:

```txt
arc_korcankaraokcu_PINCE_ymrwq2s_
├── AUTHORS
├── CONTRIBUTING.md
├── COPYING
├── COPYING.CC-BY
├── GUI
│   ├── AboutWidget.py
│   ├── AboutWidget.ui
│   ├── AbstractTableModels
│   │   ├── AsciiModel.py
│   │   └── HexModel.py
│   ├── AddAddressManuallyDialog.py
│   ├── AddAddressManuallyDialog.ui
│   ├── BreakpointInfoWidget.py
│   ├── BreakpointInfoWidget.ui
│   ├── ConsoleWidget.py
│   ├── ConsoleWidget.ui
│   ├── DissectCodeDialog.py
│   ├── DissectCodeDialog.ui
│   ├── EditInstructionDialog.py
│   ├── EditInstructionDialog.ui
│   ├── EditTypeDialog.py
│   ├── EditTypeDialog.ui
│   ├── ExamineReferrersWidget.py
│   ├── ExamineReferrersWidget.ui
│   ├── FloatRegisterWidget.py
│   ├── FloatRegisterWidget.ui
│   ├── FunctionsInfoWidget.py
│   ├── FunctionsInfoWidget.ui
│   ├── HexEditDialog.py
│   ├── HexEditDialog.ui
│   ├── ItemDelegates
│   │   └── HexDelegate.py
│   ├── Labels
│   │   ├── FlagRegisterLabel.py
│   │   └── RegisterLabel.py
│   ├── LoadingDialog.py
│   ├── LoadingDialog.ui
│   ├── LogFileWidget.py
│   ├── LogFileWidget.ui
│   ├── MainWindow.py
│   ├── MainWindow.ui
│   ├── ManualAddressDialogUtils
│   │   └── PointerChainOffset.py
│   ├── MemoryRegionsWidget.py
│   ├── MemoryRegionsWidget.ui
│   ├── MemoryViewerWindow.py
│   ├── MemoryViewerWindow.ui
│   ├── ReferencedCallsWidget.py
│   ├── ReferencedCallsWidget.ui
│   ├── ReferencedStringsWidget.py
│   ├── ReferencedStringsWidget.ui
│   ├── SearchOpcodeWidget.py
│   ├── SearchOpcodeWidget.ui
│   ├── SelectProcess.py
│   ├── SelectProcess.ui
│   ├── Session
│   │   └── session.py
│   ├── Settings
│   │   ├── settings.py
│   │   └── themes.py
│   ├── StackTraceInfoWidget.py
│   ├── StackTraceInfoWidget.ui
│   ├── States
│   │   └── states.py
│   ├── TableViews
│   │   ├── AsciiView.py
│   │   └── HexView.py
│   ├── TextEditDialog.py
│   ├── TextEditDialog.ui
│   ├── TraceInstructionsPromptDialog.py
│   ├── TraceInstructionsPromptDialog.ui
│   ├── TraceInstructionsWaitWidget.py
│   ├── TraceInstructionsWaitWidget.ui
│   ├── TraceInstructionsWindow.py
│   ├── TraceInstructionsWindow.ui
│   ├── TrackBreakpointWidget.py
│   ├── TrackBreakpointWidget.ui
│   ├── TrackSelectorDialog.py
│   ├── TrackSelectorDialog.ui
│   ├── TrackWatchpointWidget.py
│   ├── TrackWatchpointWidget.ui
│   ├── TreeWidgets
│   │   └── AddressTree.py
│   ├── Utils
│   │   ├── __init__.py
│   │   ├── guitypedefs.py
│   │   ├── guiutils.py
│   │   ├── keyboard_hack.py
│   │   └── utilwidgets.py
│   ├── Validators
│   │   └── HexValidator.py
│   ├── Widgets
│   │   ├── Bookmark
│   │   │   ├── Bookmark.py
│   │   │   └── Form
│   │   │       ├── BookmarkWidget.py
│   │   │       └── BookmarkWidget.ui
│   │   ├── HandleSignals
│   │   │   ├── Form
│   │   │   │   ├── HandleSignalsDialog.py
│   │   │   │   └── HandleSignalsDialog.ui
│   │   │   └── HandleSignals.py
│   │   ├── LibpinceEngine
│   │   │   ├── Form
│   │   │   │   ├── LibpinceEngineWindow.py
│   │   │   │   └── LibpinceEngineWindow.ui
│   │   │   └── LibpinceEngine.py
│   │   ├── ManageScanRegions
│   │   │   ├── Form
│   │   │   │   ├── ManageScanRegionsDialog.py
│   │   │   │   └── ManageScanRegionsDialog.ui
│   │   │   ├── ManageScanRegions.py
│   │   │   └── ScanRegionTable.py
│   │   ├── PointerScan
│   │   │   ├── Form
│   │   │   │   ├── PointerScanWindow.py
│   │   │   │   └── PointerScanWindow.ui
│   │   │   └── PointerScan.py
│   │   ├── PointerScanFilter
│   │   │   ├── Form
│   │   │   │   ├── PointerScanFilterDialog.py
│   │   │   │   └── PointerScanFilterDialog.ui
│   │   │   └── PointerScanFilter.py
│   │   ├── PointerScanSearch
│   │   │   ├── Form
│   │   │   │   ├── PointerScanSearchDialog.py
│   │   │   │   └── PointerScanSearchDialog.ui
│   │   │   └── PointerScanSearch.py
│   │   ├── RestoreInstructions
│   │   │   ├── Form
│   │   │   │   ├── RestoreInstructionsWidget.py
│   │   │   │   └── RestoreInstructionsWidget.ui
│   │   │   └── RestoreInstructions.py
│   │   ├── SessionNotes
│   │   │   ├── Form
│   │   │   │   ├── SessionNotes.py
│   │   │   │   └── SessionNotes.ui
│   │   │   └── SessionNotes.py
│   │   └── Settings
│   │       ├── Form
│   │       │   ├── SettingsDialog.py
│   │       │   └── SettingsDialog.ui
│   │       └── Settings.py
│   ├── __init__.py
│   └── ui_to_py.sh
├── PINCE.py
├── PINCE.sh
├── README.md
├── THANKS
├── __init__.py
├── ci
│   └── package.sh
├── compile_gdb.sh
├── compile_ts.sh
├── docs
│   ├── Makefile
│   ├── build_html.sh
│   ├── install_sphinx.sh
│   └── source
│       ├── conf.py
│       ├── gui_utils.rst
│       ├── index.rst
│       ├── libpince.rst
│       └── modules.rst
├── fix_ts.py
├── i18n
│   └── ts
│       ├── it_IT.ts
│       └── zh_CN.ts
├── install.sh
├── libpince
│   ├── __init__.py
│   ├── debugcore.py
│   ├── gdb_python_scripts
│   │   ├── __init__.py
│   │   ├── gdbextensions.py
│   │   ├── gdbutils.py
│   │   └── tests
│   │       ├── Notes.txt
│   │       └── example.c
│   ├── gdbinit_venv
│   ├── injection
│   │   ├── Notes.txt
│   │   └── example.c
│   ├── regexes.py
│   ├── typedefs.py
│   └── utils.py
├── libscanmem-PINCE
├── media
│   ├── LoadingDialog
│   │   └── ajax-loader.gif
│   ├── TraceInstructionsWaitWidget
│   │   └── ajax-loader.gif
│   ├── icons
│   │   ├── accept.png
│   │   ├── add.png
│   │   ├── anchor.png
│   │   ├── application.png
│   │   ├── application_add.png
│   │   ├── application_cascade.png
│   │   ├── application_delete.png
│   │   ├── application_double.png
│   │   ├── application_edit.png
│   │   ├── application_error.png
│   │   ├── application_form.png
│   │   ├── application_form_add.png
│   │   ├── application_form_delete.png
│   │   ├── application_form_edit.png
│   │   ├── application_form_magnify.png
│   │   ├── application_get.png
│   │   ├── application_go.png
│   │   ├── application_home.png
│   │   ├── application_key.png
│   │   ├── application_lightning.png
│   │   ├── application_link.png
│   │   ├── application_osx.png
│   │   ├── application_osx_terminal.png
│   │   ├── application_put.png
│   │   ├── application_side_boxes.png
│   │   ├── application_side_contract.png
│   │   ├── application_side_expand.png
│   │   ├── application_side_list.png
│   │   ├── application_side_tree.png
│   │   ├── application_split.png
│   │   ├── application_tile_horizontal.png
│   │   ├── application_tile_vertical.png
│   │   ├── application_view_columns.png
│   │   ├── application_view_detail.png
│   │   ├── application_view_gallery.png
│   │   ├── application_view_icons.png
│   │   ├── application_view_list.png
│   │   ├── application_view_tile.png
│   │   ├── application_xp.png
│   │   ├── application_xp_terminal.png
│   │   ├── arrow_branch.png
│   │   ├── arrow_divide.png
│   │   ├── arrow_down.png
│   │   ├── arrow_in.png
│   │   ├── arrow_inout.png
│   │   ├── arrow_join.png
│   │   ├── arrow_left.png
│   │   ├── arrow_merge.png
│   │   ├── arrow_out.png
│   │   ├── arrow_redo.png
│   │   ├── arrow_refresh.png
│   │   ├── arrow_refresh_small.png
│   │   ├── arrow_right.png
│   │   ├── arrow_rotate_anticlockwise.png
│   │   ├── arrow_rotate_clockwise.png
│   │   ├── arrow_switch.png
│   │   ├── arrow_turn_left.png
│   │   ├── arrow_turn_right.png
│   │   ├── arrow_undo.png
│   │   ├── arrow_up.png
│   │   ├── asterisk_orange.png
│   │   ├── asterisk_yellow.png
│   │   ├── attach.png
│   │   ├── award_star_add.png
│   │   ├── award_star_bronze_1.png
│   │   ├── award_star_bronze_2.png
│   │   ├── award_star_bronze_3.png
│   │   ├── award_star_delete.png
│   │   ├── award_star_gold_1.png
│   │   ├── award_star_gold_2.png
│   │   ├── award_star_gold_3.png
│   │   ├── award_star_silver_1.png
│   │   ├── award_star_silver_2.png
│   │   ├── award_star_silver_3.png
│   │   ├── basket.png
│   │   ├── basket_add.png
│   │   ├── basket_delete.png
│   │   ├── basket_edit.png
│   │   ├── basket_error.png
│   │   ├── basket_go.png
│   │   ├── basket_put.png
│   │   ├── basket_remove.png
│   │   ├── bell.png
│   │   ├── bell_add.png
│   │   ├── bell_delete.png
│   │   ├── bell_error.png
│   │   ├── bell_go.png
│   │   ├── bell_link.png
│   │   ├── bin.png
│   │   ├── bin_closed.png
│   │   ├── bin_empty.png
│   │   ├── bomb.png
│   │   ├── book.png
│   │   ├── book_add.png
│   │   ├── book_addresses.png
│   │   ├── book_delete.png
│   │   ├── book_edit.png
│   │   ├── book_error.png
│   │   ├── book_go.png
│   │   ├── book_key.png
│   │   ├── book_link.png
│   │   ├── book_next.png
│   │   ├── book_open.png
│   │   ├── book_previous.png
│   │   ├── box.png
│   │   ├── brick.png
│   │   ├── brick_add.png
│   │   ├── brick_delete.png
│   │   ├── brick_edit.png
│   │   ├── brick_error.png
│   │   ├── brick_go.png
│   │   ├── brick_link.png
│   │   ├── bricks.png
│   │   ├── briefcase.png
│   │   ├── bug.png
│   │   ├── bug_add.png
│   │   ├── bug_delete.png
│   │   ├── bug_edit.png
│   │   ├── bug_error.png
│   │   ├── bug_go.png
│   │   ├── bug_link.png
│   │   ├── building.png
│   │   ├── building_add.png
│   │   ├── building_delete.png
│   │   ├── building_edit.png
│   │   ├── building_error.png
│   │   ├── building_go.png
│   │   ├── building_key.png
│   │   ├── building_link.png
│   │   ├── bullet_add.png
│   │   ├── bullet_arrow_bottom.png
│   │   ├── bullet_arrow_down.png
│   │   ├── bullet_arrow_top.png
│   │   ├── bullet_arrow_up.png
│   │   ├── bullet_black.png
│   │   ├── bullet_blue.png
│   │   ├── bullet_delete.png
│   │   ├── bullet_disk.png
│   │   ├── bullet_error.png
│   │   ├── bullet_feed.png
│   │   ├── bullet_go.png
│   │   ├── bullet_green.png
│   │   ├── bullet_key.png
│   │   ├── bullet_orange.png
│   │   ├── bullet_picture.png
│   │   ├── bullet_pink.png
│   │   ├── bullet_purple.png
│   │   ├── bullet_red.png
│   │   ├── bullet_star.png
│   │   ├── bullet_toggle_minus.png
│   │   ├── bullet_toggle_plus.png
│   │   ├── bullet_white.png
│   │   ├── bullet_wrench.png
│   │   ├── bullet_yellow.png
│   │   ├── cake.png
│   │   ├── calculator.png
│   │   ├── calculator_add.png
│   │   ├── calculator_delete.png
│   │   ├── calculator_edit.png
│   │   ├── calculator_error.png
│   │   ├── calculator_link.png
│   │   ├── calendar.png
│   │   ├── calendar_add.png
│   │   ├── calendar_delete.png
│   │   ├── calendar_edit.png
│   │   ├── calendar_link.png
│   │   ├── calendar_view_day.png
│   │   ├── calendar_view_month.png
│   │   ├── calendar_view_week.png
│   │   ├── camera.png
│   │   ├── camera_add.png
│   │   ├── camera_delete.png
│   │   ├── camera_edit.png
│   │   ├── camera_error.png
│   │   ├── camera_go.png
│   │   ├── camera_link.png
│   │   ├── camera_small.png
│   │   ├── cancel.png
│   │   ├── car.png
│   │   ├── car_add.png
│   │   ├── car_delete.png
│   │   ├── cart.png
│   │   ├── cart_add.png
│   │   ├── cart_delete.png
│   │   ├── cart_edit.png
│   │   ├── cart_error.png
│   │   ├── cart_go.png
│   │   ├── cart_put.png
│   │   ├── cart_remove.png
│   │   ├── cd.png
│   │   ├── cd_add.png
│   │   ├── cd_burn.png
│   │   ├── cd_delete.png
│   │   ├── cd_edit.png
│   │   ├── cd_eject.png
│   │   ├── cd_go.png
│   │   ├── chart_bar.png
│   │   ├── chart_bar_add.png
│   │   ├── chart_bar_delete.png
│   │   ├── chart_bar_edit.png
│   │   ├── chart_bar_error.png
│   │   ├── chart_bar_link.png
│   │   ├── chart_curve.png
│   │   ├── chart_curve_add.png
│   │   ├── chart_curve_delete.png
│   │   ├── chart_curve_edit.png
│   │   ├── chart_curve_error.png
│   │   ├── chart_curve_go.png
│   │   ├── chart_curve_link.png
│   │   ├── chart_line.png
│   │   ├── chart_line_add.png
│   │   ├── chart_line_delete.png
│   │   ├── chart_line_edit.png
│   │   ├── chart_line_error.png
│   │   ├── chart_line_link.png
│   │   ├── chart_organisation.png
│   │   ├── chart_organisation_add.png
│   │   ├── chart_organisation_delete.png
│   │   ├── chart_pie.png
│   │   ├── chart_pie_add.png
│   │   ├── chart_pie_delete.png
│   │   ├── chart_pie_edit.png
│   │   ├── chart_pie_error.png
│   │   ├── chart_pie_link.png
│   │   ├── clock.png
│   │   ├── clock_add.png
│   │   ├── clock_delete.png
│   │   ├── clock_edit.png
│   │   ├── clock_error.png
│   │   ├── clock_go.png
│   │   ├── clock_link.png
│   │   ├── clock_pause.png
│   │   ├── clock_play.png
│   │   ├── clock_red.png
│   │   ├── clock_stop.png
│   │   ├── cog.png
│   │   ├── cog_add.png
│   │   ├── cog_delete.png
│   │   ├── cog_edit.png
│   │   ├── cog_error.png
│   │   ├── cog_go.png
│   │   ├── coins.png
│   │   ├── coins_add.png
│   │   ├── coins_delete.png
│   │   ├── color_swatch.png
│   │   ├── color_wheel.png
│   │   ├── comment.png
│   │   ├── comment_add.png
│   │   ├── comment_delete.png
│   │   ├── comment_edit.png
│   │   ├── comments.png
│   │   ├── comments_add.png
│   │   ├── comments_delete.png
│   │   ├── compress.png
│   │   ├── computer.png
│   │   ├── computer_add.png
│   │   ├── computer_delete.png
│   │   ├── computer_edit.png
│   │   ├── computer_error.png
│   │   ├── computer_go.png
│   │   ├── computer_key.png
│   │   ├── computer_link.png
│   │   ├── connect.png
│   │   ├── contrast.png
│   │   ├── contrast_decrease.png
│   │   ├── contrast_high.png
│   │   ├── contrast_increase.png
│   │   ├── contrast_low.png
│   │   ├── control_eject.png
│   │   ├── control_eject_blue.png
│   │   ├── control_end.png
│   │   ├── control_end_blue.png
│   │   ├── control_equalizer.png
│   │   ├── control_equalizer_blue.png
│   │   ├── control_fastforward.png
│   │   ├── control_fastforward_blue.png
│   │   ├── control_pause.png
│   │   ├── control_pause_blue.png
│   │   ├── control_play.png
│   │   ├── control_play_blue.png
│   │   ├── control_repeat.png
│   │   ├── control_repeat_blue.png
│   │   ├── control_rewind.png
│   │   ├── control_rewind_blue.png
│   │   ├── control_start.png
│   │   ├── control_start_blue.png
│   │   ├── control_stop.png
│   │   ├── control_stop_blue.png
│   │   ├── controller.png
│   │   ├── controller_add.png
│   │   ├── controller_delete.png
│   │   ├── controller_error.png
│   │   ├── creditcards.png
│   │   ├── cross.png
│   │   ├── css.png
│   │   ├── css_add.png
│   │   ├── css_delete.png
│   │   ├── css_go.png
│   │   ├── css_valid.png
│   │   ├── cup.png
│   │   ├── cup_add.png
│   │   ├── cup_delete.png
│   │   ├── cup_edit.png
│   │   ├── cup_error.png
│   │   ├── cup_go.png
│   │   ├── cup_key.png
│   │   ├── cup_link.png
│   │   ├── cursor.png
│   │   ├── cut.png
│   │   ├── cut_red.png
│   │   ├── database.png
│   │   ├── database_add.png
│   │   ├── database_connect.png
│   │   ├── database_delete.png
│   │   ├── database_edit.png
│   │   ├── database_error.png
│   │   ├── database_gear.png
│   │   ├── database_go.png
│   │   ├── database_key.png
│   │   ├── database_lightning.png
│   │   ├── database_link.png
│   │   ├── database_refresh.png
│   │   ├── database_save.png
│   │   ├── database_table.png
│   │   ├── date.png
│   │   ├── date_add.png
│   │   ├── date_delete.png
│   │   ├── date_edit.png
│   │   ├── date_error.png
│   │   ├── date_go.png
│   │   ├── date_link.png
│   │   ├── date_magnify.png
│   │   ├── date_next.png
│   │   ├── date_previous.png
│   │   ├── delete.png
│   │   ├── disconnect.png
│   │   ├── disk.png
│   │   ├── disk_multiple.png
│   │   ├── door.png
│   │   ├── door_in.png
│   │   ├── door_open.png
│   │   ├── door_out.png
│   │   ├── drink.png
│   │   ├── drink_empty.png
│   │   ├── drive.png
│   │   ├── drive_add.png
│   │   ├── drive_burn.png
│   │   ├── drive_cd.png
│   │   ├── drive_cd_empty.png
│   │   ├── drive_delete.png
│   │   ├── drive_disk.png
│   │   ├── drive_edit.png
│   │   ├── drive_error.png
│   │   ├── drive_go.png
│   │   ├── drive_key.png
│   │   ├── drive_link.png
│   │   ├── drive_magnify.png
│   │   ├── drive_network.png
│   │   ├── drive_rename.png
│   │   ├── drive_user.png
│   │   ├── drive_web.png
│   │   ├── dvd.png
│   │   ├── dvd_add.png
│   │   ├── dvd_delete.png
│   │   ├── dvd_edit.png
│   │   ├── dvd_error.png
│   │   ├── dvd_go.png
│   │   ├── dvd_key.png
│   │   ├── dvd_link.png
│   │   ├── email.png
│   │   ├── email_add.png
│   │   ├── email_attach.png
│   │   ├── email_delete.png
│   │   ├── email_edit.png
│   │   ├── email_error.png
│   │   ├── email_go.png
│   │   ├── email_link.png
│   │   ├── email_open.png
│   │   ├── email_open_image.png
│   │   ├── emoticon_evilgrin.png
│   │   ├── emoticon_grin.png
│   │   ├── emoticon_happy.png
│   │   ├── emoticon_smile.png
│   │   ├── emoticon_surprised.png
│   │   ├── emoticon_tongue.png
│   │   ├── emoticon_unhappy.png
│   │   ├── emoticon_waii.png
│   │   ├── emoticon_wink.png
│   │   ├── error.png
│   │   ├── error_add.png
│   │   ├── error_delete.png
│   │   ├── error_go.png
│   │   ├── exclamation.png
│   │   ├── eye.png
│   │   ├── feed.png
│   │   ├── feed_add.png
│   │   ├── feed_delete.png
│   │   ├── feed_disk.png
│   │   ├── feed_edit.png
│   │   ├── feed_error.png
│   │   ├── feed_go.png
│   │   ├── feed_key.png
│   │   ├── feed_link.png
│   │   ├── feed_magnify.png
│   │   ├── female.png
│   │   ├── film.png
│   │   ├── film_add.png
│   │   ├── film_delete.png
│   │   ├── film_edit.png
│   │   ├── film_error.png
│   │   ├── film_go.png
│   │   ├── film_key.png
│   │   ├── film_link.png
│   │   ├── film_save.png
│   │   ├── find.png
│   │   ├── flag_blue.png
│   │   ├── flag_green.png
│   │   ├── flag_orange.png
│   │   ├── flag_pink.png
│   │   ├── flag_purple.png
│   │   ├── flag_red.png
│   │   ├── flag_yellow.png
│   │   ├── folder.png
│   │   ├── folder_add.png
│   │   ├── folder_bell.png
│   │   ├── folder_brick.png
│   │   ├── folder_bug.png
│   │   ├── folder_camera.png
│   │   ├── folder_database.png
│   │   ├── folder_delete.png
│   │   ├── folder_edit.png
│   │   ├── folder_error.png
│   │   ├── folder_explore.png
│   │   ├── folder_feed.png
│   │   ├── folder_find.png
│   │   ├── folder_go.png
│   │   ├── folder_heart.png
│   │   ├── folder_image.png
│   │   ├── folder_key.png
│   │   ├── folder_lightbulb.png
│   │   ├── folder_link.png
│   │   ├── folder_magnify.png
│   │   ├── folder_page.png
│   │   ├── folder_page_white.png
│   │   ├── folder_palette.png
│   │   ├── folder_picture.png
│   │   ├── folder_star.png
│   │   ├── folder_table.png
│   │   ├── folder_user.png
│   │   ├── folder_wrench.png
│   │   ├── font.png
│   │   ├── font_add.png
│   │   ├── font_delete.png
│   │   ├── font_go.png
│   │   ├── group.png
│   │   ├── group_add.png
│   │   ├── group_delete.png
│   │   ├── group_edit.png
│   │   ├── group_error.png
│   │   ├── group_gear.png
│   │   ├── group_go.png
│   │   ├── group_key.png
│   │   ├── group_link.png
│   │   ├── heart.png
│   │   ├── heart_add.png
│   │   ├── heart_delete.png
│   │   ├── help.png
│   │   ├── hourglass.png
│   │   ├── hourglass_add.png
│   │   ├── hourglass_delete.png
│   │   ├── hourglass_go.png
│   │   ├── hourglass_link.png
│   │   ├── house.png
│   │   ├── house_go.png
│   │   ├── house_link.png
│   │   ├── html.png
│   │   ├── html_add.png
│   │   ├── html_delete.png
│   │   ├── html_go.png
│   │   ├── html_valid.png
│   │   ├── image.png
│   │   ├── image_add.png
│   │   ├── image_delete.png
│   │   ├── image_edit.png
│   │   ├── image_link.png
│   │   ├── images.png
│   │   ├── information.png
│   │   ├── ipod.png
│   │   ├── ipod_cast.png
│   │   ├── ipod_cast_add.png
│   │   ├── ipod_cast_delete.png
│   │   ├── ipod_sound.png
│   │   ├── joystick.png
│   │   ├── joystick_add.png
│   │   ├── joystick_delete.png
│   │   ├── joystick_error.png
│   │   ├── key.png
│   │   ├── key_add.png
│   │   ├── key_delete.png
│   │   ├── key_go.png
│   │   ├── keyboard.png
│   │   ├── keyboard_add.png
│   │   ├── keyboard_delete.png
│   │   ├── keyboard_magnify.png
│   │   ├── layers.png
│   │   ├── layout.png
│   │   ├── layout_add.png
│   │   ├── layout_content.png
│   │   ├── layout_delete.png
│   │   ├── layout_edit.png
│   │   ├── layout_error.png
│   │   ├── layout_header.png
│   │   ├── layout_link.png
│   │   ├── layout_sidebar.png
│   │   ├── lightbulb.png
│   │   ├── lightbulb_add.png
│   │   ├── lightbulb_delete.png
│   │   ├── lightbulb_off.png
│   │   ├── lightning.png
│   │   ├── lightning_add.png
│   │   ├── lightning_delete.png
│   │   ├── lightning_go.png
│   │   ├── link.png
│   │   ├── link_add.png
│   │   ├── link_break.png
│   │   ├── link_delete.png
│   │   ├── link_edit.png
│   │   ├── link_error.png
│   │   ├── link_go.png
│   │   ├── lock.png
│   │   ├── lock_add.png
│   │   ├── lock_break.png
│   │   ├── lock_delete.png
│   │   ├── lock_edit.png
│   │   ├── lock_go.png
│   │   ├── lock_open.png
│   │   ├── lorry.png
│   │   ├── lorry_add.png
│   │   ├── lorry_delete.png
│   │   ├── lorry_error.png
│   │   ├── lorry_flatbed.png
│   │   ├── lorry_go.png
│   │   ├── lorry_link.png
│   │   ├── magifier_zoom_out.png
│   │   ├── magnifier.png
│   │   ├── magnifier_zoom_in.png
│   │   ├── male.png
│   │   ├── map.png
│   │   ├── map_add.png
│   │   ├── map_delete.png
│   │   ├── map_edit.png
│   │   ├── map_go.png
│   │   ├── map_magnify.png
│   │   ├── medal_bronze_1.png
│   │   ├── medal_bronze_2.png
│   │   ├── medal_bronze_3.png
│   │   ├── medal_bronze_add.png
│   │   ├── medal_bronze_delete.png
│   │   ├── medal_gold_1.png
│   │   ├── medal_gold_2.png
│   │   ├── medal_gold_3.png
│   │   ├── medal_gold_add.png
│   │   ├── medal_gold_delete.png
│   │   ├── medal_silver_1.png
│   │   ├── medal_silver_2.png
│   │   ├── medal_silver_3.png
│   │   ├── medal_silver_add.png
│   │   ├── medal_silver_delete.png
│   │   ├── money.png
│   │   ├── money_add.png
│   │   ├── money_delete.png
│   │   ├── money_dollar.png
│   │   ├── money_euro.png
│   │   ├── money_pound.png
│   │   ├── money_yen.png
│   │   ├── monitor.png
│   │   ├── monitor_add.png
│   │   ├── monitor_delete.png
│   │   ├── monitor_edit.png
│   │   ├── monitor_error.png
│   │   ├── monitor_go.png
│   │   ├── monitor_lightning.png
│   │   ├── monitor_link.png
│   │   ├── mouse.png
│   │   ├── mouse_add.png
│   │   ├── mouse_delete.png
│   │   ├── mouse_error.png
│   │   ├── music.png
│   │   ├── new.png
│   │   ├── newspaper.png
│   │   ├── newspaper_add.png
│   │   ├── newspaper_delete.png
│   │   ├── newspaper_go.png
│   │   ├── newspaper_link.png
│   │   ├── note.png
│   │   ├── note_add.png
│   │   ├── note_delete.png
│   │   ├── note_edit.png
│   │   ├── note_error.png
│   │   ├── note_go.png
│   │   ├── overlays.png
│   │   ├── package.png
│   │   ├── package_add.png
│   │   ├── package_delete.png
│   │   ├── package_go.png
│   │   ├── package_green.png
│   │   ├── package_link.png
│   │   ├── page.png
│   │   ├── page_add.png
│   │   ├── page_attach.png
│   │   ├── page_code.png
│   │   ├── page_copy.png
│   │   ├── page_delete.png
│   │   ├── page_edit.png
│   │   ├── page_error.png
│   │   ├── page_excel.png
│   │   ├── page_find.png
│   │   ├── page_gear.png
│   │   ├── page_go.png
│   │   ├── page_green.png
│   │   ├── page_key.png
│   │   ├── page_lightning.png
│   │   ├── page_link.png
│   │   ├── page_paintbrush.png
│   │   ├── page_paste.png
│   │   ├── page_red.png
│   │   ├── page_refresh.png
│   │   ├── page_save.png
│   │   ├── page_white.png
│   │   ├── page_white_acrobat.png
│   │   ├── page_white_actionscript.png
│   │   ├── page_white_add.png
│   │   ├── page_white_c.png
│   │   ├── page_white_camera.png
│   │   ├── page_white_cd.png
│   │   ├── page_white_code.png
│   │   ├── page_white_code_red.png
│   │   ├── page_white_coldfusion.png
│   │   ├── page_white_compressed.png
│   │   ├── page_white_copy.png
│   │   ├── page_white_cplusplus.png
│   │   ├── page_white_csharp.png
│   │   ├── page_white_cup.png
│   │   ├── page_white_database.png
│   │   ├── page_white_delete.png
│   │   ├── page_white_dvd.png
│   │   ├── page_white_edit.png
│   │   ├── page_white_error.png
│   │   ├── page_white_excel.png
│   │   ├── page_white_find.png
│   │   ├── page_white_flash.png
│   │   ├── page_white_freehand.png
│   │   ├── page_white_gear.png
│   │   ├── page_white_get.png
│   │   ├── page_white_go.png
│   │   ├── page_white_h.png
│   │   ├── page_white_horizontal.png
│   │   ├── page_white_key.png
│   │   ├── page_white_lightning.png
│   │   ├── page_white_link.png
│   │   ├── page_white_magnify.png
│   │   ├── page_white_medal.png
│   │   ├── page_white_office.png
│   │   ├── page_white_paint.png
│   │   ├── page_white_paintbrush.png
│   │   ├── page_white_paste.png
│   │   ├── page_white_php.png
│   │   ├── page_white_picture.png
│   │   ├── page_white_powerpoint.png
│   │   ├── page_white_put.png
│   │   ├── page_white_ruby.png
│   │   ├── page_white_stack.png
│   │   ├── page_white_star.png
│   │   ├── page_white_swoosh.png
│   │   ├── page_white_text.png
│   │   ├── page_white_text_width.png
│   │   ├── page_white_tux.png
│   │   ├── page_white_vector.png
│   │   ├── page_white_visualstudio.png
│   │   ├── page_white_width.png
│   │   ├── page_white_word.png
│   │   ├── page_white_world.png
│   │   ├── page_white_wrench.png
│   │   ├── page_white_zip.png
│   │   ├── page_word.png
│   │   ├── page_world.png
│   │   ├── paintbrush.png
│   │   ├── paintcan.png
│   │   ├── palette.png
│   │   ├── paste_plain.png
│   │   ├── paste_word.png
│   │   ├── pencil.png
│   │   ├── pencil_add.png
│   │   ├── pencil_delete.png
│   │   ├── pencil_go.png
│   │   ├── phone.png
│   │   ├── phone_add.png
│   │   ├── phone_delete.png
│   │   ├── phone_sound.png
│   │   ├── photo.png
│   │   ├── photo_add.png
│   │   ├── photo_delete.png
│   │   ├── photo_link.png
│   │   ├── photos.png
│   │   ├── picture.png
│   │   ├── picture_add.png
│   │   ├── picture_delete.png
│   │   ├── picture_edit.png
│   │   ├── picture_empty.png
│   │   ├── picture_error.png
│   │   ├── picture_go.png
│   │   ├── picture_key.png
│   │   ├── picture_link.png
│   │   ├── picture_save.png
│   │   ├── pictures.png
│   │   ├── pilcrow.png
│   │   ├── pill.png
│   │   ├── pill_add.png
│   │   ├── pill_delete.png
│   │   ├── pill_go.png
│   │   ├── plugin.png
│   │   ├── plugin_add.png
│   │   ├── plugin_delete.png
│   │   ├── plugin_disabled.png
│   │   ├── plugin_edit.png
│   │   ├── plugin_error.png
│   │   ├── plugin_go.png
│   │   ├── plugin_link.png
│   │   ├── printer.png
│   │   ├── printer_add.png
│   │   ├── printer_delete.png
│   │   ├── printer_empty.png
│   │   ├── printer_error.png
│   │   ├── rainbow.png
│   │   ├── report.png
│   │   ├── report_add.png
│   │   ├── report_delete.png
│   │   ├── report_disk.png
│   │   ├── report_edit.png
│   │   ├── report_go.png
│   │   ├── report_key.png
│   │   ├── report_link.png
│   │   ├── report_magnify.png
│   │   ├── report_picture.png
│   │   ├── report_user.png
│   │   ├── report_word.png
│   │   ├── resultset_first.png
│   │   ├── resultset_last.png
│   │   ├── resultset_next.png
│   │   ├── resultset_previous.png
│   │   ├── rosette.png
│   │   ├── rss.png
│   │   ├── rss_add.png
│   │   ├── rss_delete.png
│   │   ├── rss_go.png
│   │   ├── rss_valid.png
│   │   ├── ruby.png
│   │   ├── ruby_add.png
│   │   ├── ruby_delete.png
│   │   ├── ruby_gear.png
│   │   ├── ruby_get.png
│   │   ├── ruby_go.png
│   │   ├── ruby_key.png
│   │   ├── ruby_link.png
│   │   ├── ruby_put.png
│   │   ├── script.png
│   │   ├── script_add.png
│   │   ├── script_code.png
│   │   ├── script_code_red.png
│   │   ├── script_delete.png
│   │   ├── script_edit.png
│   │   ├── script_error.png
│   │   ├── script_gear.png
│   │   ├── script_go.png
│   │   ├── script_key.png
│   │   ├── script_lightning.png
│   │   ├── script_link.png
│   │   ├── script_palette.png
│   │   ├── script_save.png
│   │   ├── server.png
│   │   ├── server_add.png
│   │   ├── server_chart.png
│   │   ├── server_compressed.png
│   │   ├── server_connect.png
│   │   ├── server_database.png
│   │   ├── server_delete.png
│   │   ├── server_edit.png
│   │   ├── server_error.png
│   │   ├── server_go.png
│   │   ├── server_key.png
│   │   ├── server_lightning.png
│   │   ├── server_link.png
│   │   ├── server_uncompressed.png
│   │   ├── shading.png
│   │   ├── shape_align_bottom.png
│   │   ├── shape_align_center.png
│   │   ├── shape_align_left.png
│   │   ├── shape_align_middle.png
│   │   ├── shape_align_right.png
│   │   ├── shape_align_top.png
│   │   ├── shape_flip_horizontal.png
│   │   ├── shape_flip_vertical.png
│   │   ├── shape_group.png
│   │   ├── shape_handles.png
│   │   ├── shape_move_back.png
│   │   ├── shape_move_backwards.png
│   │   ├── shape_move_forwards.png
│   │   ├── shape_move_front.png
│   │   ├── shape_rotate_anticlockwise.png
│   │   ├── shape_rotate_clockwise.png
│   │   ├── shape_square.png
│   │   ├── shape_square_add.png
│   │   ├── shape_square_delete.png
│   │   ├── shape_square_edit.png
│   │   ├── shape_square_error.png
│   │   ├── shape_square_go.png
│   │   ├── shape_square_key.png
│   │   ├── shape_square_link.png
│   │   ├── shape_ungroup.png
│   │   ├── shield.png
│   │   ├── shield_add.png
│   │   ├── shield_delete.png
│   │   ├── shield_go.png
│   │   ├── sitemap.png
│   │   ├── sitemap_color.png
│   │   ├── sound.png
│   │   ├── sound_add.png
│   │   ├── sound_delete.png
│   │   ├── sound_low.png
│   │   ├── sound_mute.png
│   │   ├── sound_none.png
│   │   ├── spellcheck.png
│   │   ├── sport_8ball.png
│   │   ├── sport_basketball.png
│   │   ├── sport_football.png
│   │   ├── sport_golf.png
│   │   ├── sport_raquet.png
│   │   ├── sport_shuttlecock.png
│   │   ├── sport_soccer.png
│   │   ├── sport_tennis.png
│   │   ├── star.png
│   │   ├── status_away.png
│   │   ├── status_busy.png
│   │   ├── status_offline.png
│   │   ├── status_online.png
│   │   ├── stop.png
│   │   ├── style.png
│   │   ├── style_add.png
│   │   ├── style_delete.png
│   │   ├── style_edit.png
│   │   ├── style_go.png
│   │   ├── sum.png
│   │   ├── tab.png
│   │   ├── tab_add.png
│   │   ├── tab_delete.png
│   │   ├── tab_edit.png
│   │   ├── tab_go.png
│   │   ├── table.png
│   │   ├── table_add.png
│   │   ├── table_delete.png
│   │   ├── table_edit.png
│   │   ├── table_error.png
│   │   ├── table_gear.png
│   │   ├── table_go.png
│   │   ├── table_key.png
│   │   ├── table_lightning.png
│   │   ├── table_link.png
│   │   ├── table_multiple.png
│   │   ├── table_refresh.png
│   │   ├── table_relationship.png
│   │   ├── table_row_delete.png
│   │   ├── table_row_insert.png
│   │   ├── table_save.png
│   │   ├── table_sort.png
│   │   ├── tag.png
│   │   ├── tag_blue.png
│   │   ├── tag_blue_add.png
│   │   ├── tag_blue_delete.png
│   │   ├── tag_blue_edit.png
│   │   ├── tag_green.png
│   │   ├── tag_orange.png
│   │   ├── tag_pink.png
│   │   ├── tag_purple.png
│   │   ├── tag_red.png
│   │   ├── tag_yellow.png
│   │   ├── telephone.png
│   │   ├── telephone_add.png
│   │   ├── telephone_delete.png
│   │   ├── telephone_edit.png
│   │   ├── telephone_error.png
│   │   ├── telephone_go.png
│   │   ├── telephone_key.png
│   │   ├── telephone_link.png
│   │   ├── television.png
│   │   ├── television_add.png
│   │   ├── television_delete.png
│   │   ├── text_align_center.png
│   │   ├── text_align_justify.png
│   │   ├── text_align_left.png
│   │   ├── text_align_right.png
│   │   ├── text_allcaps.png
│   │   ├── text_bold.png
│   │   ├── text_columns.png
│   │   ├── text_dropcaps.png
│   │   ├── text_heading_1.png
│   │   ├── text_heading_2.png
│   │   ├── text_heading_3.png
│   │   ├── text_heading_4.png
│   │   ├── text_heading_5.png
│   │   ├── text_heading_6.png
│   │   ├── text_horizontalrule.png
│   │   ├── text_indent.png
│   │   ├── text_indent_remove.png
│   │   ├── text_italic.png
│   │   ├── text_kerning.png
│   │   ├── text_letter_omega.png
│   │   ├── text_letterspacing.png
│   │   ├── text_linespacing.png
│   │   ├── text_list_bullets.png
│   │   ├── text_list_numbers.png
│   │   ├── text_lowercase.png
│   │   ├── text_padding_bottom.png
│   │   ├── text_padding_left.png
│   │   ├── text_padding_right.png
│   │   ├── text_padding_top.png
│   │   ├── text_replace.png
│   │   ├── text_signature.png
│   │   ├── text_smallcaps.png
│   │   ├── text_strikethrough.png
│   │   ├── text_subscript.png
│   │   ├── text_superscript.png
│   │   ├── text_underline.png
│   │   ├── text_uppercase.png
│   │   ├── textfield.png
│   │   ├── textfield_add.png
│   │   ├── textfield_delete.png
│   │   ├── textfield_key.png
│   │   ├── textfield_rename.png
│   │   ├── thumb_down.png
│   │   ├── thumb_up.png
│   │   ├── tick.png
│   │   ├── time.png
│   │   ├── time_add.png
│   │   ├── time_delete.png
│   │   ├── time_go.png
│   │   ├── timeline_marker.png
│   │   ├── transmit.png
│   │   ├── transmit_add.png
│   │   ├── transmit_blue.png
│   │   ├── transmit_delete.png
│   │   ├── transmit_edit.png
│   │   ├── transmit_error.png
│   │   ├── transmit_go.png
│   │   ├── tux.png
│   │   ├── user.png
│   │   ├── user_add.png
│   │   ├── user_comment.png
│   │   ├── user_delete.png
│   │   ├── user_edit.png
│   │   ├── user_female.png
│   │   ├── user_go.png
│   │   ├── user_gray.png
│   │   ├── user_green.png
│   │   ├── user_orange.png
│   │   ├── user_red.png
│   │   ├── user_suit.png
│   │   ├── vcard.png
│   │   ├── vcard_add.png
│   │   ├── vcard_delete.png
│   │   ├── vcard_edit.png
│   │   ├── vector.png
│   │   ├── vector_add.png
│   │   ├── vector_delete.png
│   │   ├── wand.png
│   │   ├── weather_clouds.png
│   │   ├── weather_cloudy.png
│   │   ├── weather_lightning.png
│   │   ├── weather_rain.png
│   │   ├── weather_snow.png
│   │   ├── weather_sun.png
│   │   ├── webcam.png
│   │   ├── webcam_add.png
│   │   ├── webcam_delete.png
│   │   ├── webcam_error.png
│   │   ├── world.png
│   │   ├── world_add.png
│   │   ├── world_delete.png
│   │   ├── world_edit.png
│   │   ├── world_go.png
│   │   ├── world_link.png
│   │   ├── wrench.png
│   │   ├── wrench_orange.png
│   │   ├── xhtml.png
│   │   ├── xhtml_add.png
│   │   ├── xhtml_delete.png
│   │   ├── xhtml_go.png
│   │   ├── xhtml_valid.png
│   │   ├── zoom.png
│   │   ├── zoom_in.png
│   │   └── zoom_out.png
│   └── logo
│       └── ozgurozbek
│           ├── pince_appimage.png
│           ├── pince_big_cyan.png
│           ├── pince_big_gray.png
│           ├── pince_big_green.png
│           ├── pince_big_neon_blue.png
│           ├── pince_big_neon_orange.png
│           ├── pince_big_orange.png
│           ├── pince_big_red.png
│           ├── pince_big_tan.png
│           ├── pince_big_transparent.png
│           ├── pince_big_white.png
│           ├── pince_big_yellow.png
│           ├── pince_small_carved_cyan.png
│           ├── pince_small_carved_orange.png
│           ├── pince_small_cyan.png
│           ├── pince_small_gray.png
│           ├── pince_small_green.png
│           ├── pince_small_orange.png
│           ├── pince_small_red.png
│           ├── pince_small_tan.png
│           ├── pince_small_transparent.png
│           ├── pince_small_white.png
│           └── pince_small_yellow.png
├── pyproject.toml
├── requirements.txt
├── run_tests.py
├── tests
│   ├── __init__.py
│   ├── debugcore_tests.py
│   ├── guiutils_tests.py
│   └── utils_tests.py
└── tr
    └── tr.py

```

`AUTHORS`:

```
Copyright (C) 2016-2020 Korcan Karaokçu <korcankaraokcu@gmail.com>
Copyright (C) 2016-2020 Çağrı Ulaş <cagriulas@gmail.com>
Copyright (C) 2016-2020 Jakob Kreuze <jakob@memeware.net>
Copyright (C) 2020 Viktor Horsmanheimo <https://github.com/vikke1234>
Copyright (C) 2018 user202729
Copyright (C) 2018 Özgür Özbek <ozgurozbek1@yandex.com> [media/logo/ozgurozbek]

Copyright (C) Mark James 2005, 2006  Silk Icons <http://www.famfamfam.com> [media/icons/]

Silk Icons are licensed under Creative Commons Attribution 3.0
Unported License. See COPYING.CC-BY for conditions.

```

`CONTRIBUTING.md`:

```md
# Code Structure
- [PINCE.py](./PINCE.py) - The main file, it contains everything from GUI logic to libpince communication. A chonky boi on a diet, see below for information about ongoing refactoring
- [PINCE.sh](./PINCE.sh) - Launch script
- [install.sh](./install.sh) - Installation script
- [compile_ts.sh](./compile_ts.sh) - Gathers translation information from various sources and compiles them into ts files
- [fix_ts.py](./fix_ts.py) - Fixes line information issue, used within [compile_ts.sh](./compile_ts.sh)
- [compile_gdb.sh](./compile_gdb.sh) - PINCE normally uses system GDB but in cases where system GDB is unavailable, this script is used to compile GDB locally
- [GUI](./GUI) - Contains Qt Designer forms and their respective codes along with utility functions and custom Qt classes
- [media](./media) - Contains media files such as logos and icons
- [tr](./tr) - Contains translation constants
- [docs](./docs) - Contains Sphinx documentation. The build files are automatically generated in the `gh-pages` branch.
- [i18n](./i18n) - Contains translation files. `ts` files are created with Qt Linguist and [compile_ts.sh](./compile_ts.sh), `qm` files are created within the last section of [install.sh](./install.sh)
- ### **[libpince](./libpince)**
  - [debugcore.py](./libpince/debugcore.py) - Everything related to communicating with GDB and debugging
  - [utils.py](./libpince/utils.py) - Contains generic utility functions such as parsing, file creation, process querying etc
  - [typedefs.py](./libpince/typedefs.py) - Contains all constants and variable definitions
  - [regexes.py](./libpince/regexes.py) - Contains regexes for parsing GDB output and other things
  - [injection](./libpince/injection) - An example for injecting .so files
  - ### **[gdb_python_scripts](./libpince/gdb_python_scripts)**
    - [gdbextensions.py](./libpince/gdb_python_scripts/gdbextensions.py) - Contains custom GDB commands
    - [gdbutils.py](./libpince/gdb_python_scripts/gdbutils.py) - Contains utility functions for GDB commands
    - [tests](./libpince/gdb_python_scripts/tests) - An example for .so extension, read more [here](https://github.com/korcankaraokcu/PINCE/wiki/Extending-PINCE-with-.so-files)

**About GUI file structure refactoring**: PINCE.py currently holds all of the GUI logic classes and this makes PINCE.py grow larger as the project progresses. To prevent this, all GUI logic will be carried to their respective folders and the GUI folder will follow this structure:
```
GUI/
|-- Settings/
|-- States/
|-- Utils/
|-- Widgets/
|   |-- Example/
│   |   |-- Form/
│   |   │   |-- ExampleWidget.ui (Designer UI file)
│   |   │   |-- ExampleWidget.py (Auto-generated from the UI file)
│   |   |-- Example.py (Form logic)
│   |   |-- CustomClass.py (Helper class)
```
A good example of the structure above can be seen in [ManageScanRegions](./GUI/Widgets/ManageScanRegions)

# Code Style
Formatting style is [Black](https://github.com/psf/black) defaults, except line length is 120. You can use Black without parameters since we already use `pyproject.toml` for this setting.

***You must format the files you changed using Black before you open a PR!*** Please do not format automatically generated files under GUI folder. Your changes will be overwritten by Qt Designer. More info at [UI Files](#ui-files)
- Max characters per line: 120
- Variable naming for libpince:
  - Classes: PascalCase
  - Class members: snake_case
  - Variables: snake_case
  - Functions: snake_case
  - Constants: SCREAMING_SNAKE_CASE
  - Modules: flatcase
  - Standalone scripts: snake_case
- Variable naming for Qt:
  - Classes: PascalCase
  - Class members:
    - non-Qt: snake_case
    - Qt: objectType + PascalCase
    For example: `keySequenceEdit_Hotkey` in [PINCE.py](./PINCE.py)
  - Variables: snake_case
  - Functions:
    - non-Qt: snake_case
    - Qt: objectName + snake_case
    Here's an example: `keySequenceEdit_Hotkey_key_sequence_changed` in [PINCE.py](./PINCE.py)
  - Constants: SCREAMING_SNAKE_CASE
  - Modules: PascalCase
  - Standalone scripts: snake_case

For convenience, I'm using auto-format tool of vscode. Any modern IDE will most likely have an auto-formatting tool.
Readability and being clear is the most important aspect, so if you decide to not follow the rules, make sure that your code still reads nice and plays well with others.
If you feel unsure to which naming convention you should use, try to check out similar patterns in the code or just ask away in the PINCE discord server!

The reason behind Qt class member naming convention is that when this project first started, supported python version didn't have type hints.
So, to have an idea about the type of the variable we are working with, I've come up with that naming idea. It's an old habit if anything.
It could maybe replaced with something else after a refactorization

About the max characters per line, I used to use PyCharm when I first started this project years ago. 120 characters is a limit brought by PyCharm, I've quit using PyCharm eventually but I think the limit makes the code look quite nice. Black suggests a limit of 88 characters, which is a bit short to be frank. So I think it's good to keep this old habit, especially considering that docstrings have also followed this rule for a long time now. This limit for docstrings however, is not strict at all. A few characters passing the limit is ok, sometimes going for a newline messes up the readability, trust your guts and decide for yourself

# Documentation
We use Google style documentation and type hints. A good example would be `get_breakpoints_in_range` function in [debugcore.py](./libpince/debugcore.py). Root folder of libpince has 100% documentation coverage so a pull request regarding libpince has to be documented. For other places, it's enough to document the parts you think that'd be confusing to read later on. You are not obliged to document everything in other places as we are also quite lax with it

We use Sphinx to automatically generate html files from the docs and napoleon extension to convert Google style docs to reStructuredText. To test locally, `cd` into the [docs](./docs) directory and execute `sh install_sphinx.sh`. This will install Sphinx and its extensions within the venv. After this, You can modify [source files](./docs/source) and then build html files with `sh build_html.sh` to test your changes. To create source files for multiple modules automatically, `sphinx-apidoc` can be used. For single modules, you can edit the source files manually (like I did with `guiutils`)

[build_docs.yml](.github/workflows/build_docs.yml) workflow is responsible for automatic html generation, it gets triggered automatically whenever there's a new release or manually whenever necessary. The workflow generates files within the `gh-pages` branch. It's an orphaned branch so it can be deleted without affecting the history

# UI Files
You need to have [Qt6 Designer](https://pkgs.org/search/?q=designer&on=files) installed. If there are no available packages for your distro, install [pyqt6-tools](https://pypi.org/project/pyqt6-tools/) instead  

Follow the steps below:
- Edit or create ui files with the designer and save them
- After saving ui files, run `sh ui_to_py.sh` within GUI folder to convert them into py files

The py files that contains the same name with the ui files are auto-generated, please edit the ui files with designer instead of messing with the py files

# Translation
You need to have [Qt6 Linguist](https://pkgs.org/search/?q=linguist&on=files) installed. If there are no available packages for your distro, install [pyqt6-tools](https://pypi.org/project/pyqt6-tools/) instead  

Follow the steps below:
- To create a new translation file, use [compile_ts.sh](./compile_ts.sh) with the locale as the parameter, such as `sh compile.sh ja_JP`. This will create a ts file with the locale you entered.
You can skip this step if you only want to edit already existing files
- Edit ts files in [/i18n/ts](./i18n/ts) with the linguist and then save them. After saving the files, run the [compile_ts.sh](./compile_ts.sh) script.
This script fixes inconsistencies between Qt6 Linguist and pylupdate6, also removes line information so the git history stays cleaner
- To test your translations, use [install.sh](./install.sh). The last part of the installation script also compiles ts files to qm files so PINCE can process them.
When asked to recompile libscanmem, enter no

Make sure that you read the comments in [tr.py](./tr/tr.py). Some of the translations have caveats that might interest you

About the untranslated parts of the code, such as context menus of libpince reference widget. You'll see that some of the code serves as a placeholder that'll be
removed or replaced in the future. These are not marked as translatable as translating them would be a waste of time

**ATTENTION:** Make sure you read this part even if you aren't a translator:  
If you create or delete any Qt related string (for example, ui forms or translation constants in [tr.py](./tr/tr.py)), you must run [compile_ts.sh](./compile_ts.sh) so it updates the translations.
Not every string has to be translatable, if it's only printed on console, it can stay as is, in English. If it's shown to the user within a form, it should be translatable

# Logo
All logo requests should be posted in `/media/logo/your_username`. Instead of opening a new issue, pull request your logo files to that folder.
Your PR must include at least one png file named pince_small, pince_medium or pince_big, according to its size. So, a minimal PR will look like this:

`/media/logo/your_username/pince_big.png`

pince_big is interchangeable with pince_medium and pince_small
A full PR will look like this:
```
/media/logo/your_username/pince_big.png
/media/logo/your_username/pince_medium.png
/media/logo/your_username/pince_small.png
```

# Notes
Here are some notes that explains some of the caveats and hacks, they also include a timestamp. As we upgrade the libraries and the methods we are working with,
some of these notes might become obsolete. You are free to test and provide solutions to these tricks

- 28/08/2018 - All QMessageBoxes that's called from outside of their classes(via parent() etc.) must use 'QApplication.focusWidget()' instead of 'self' in their first parameter.
Refer to issue #57 for more information

- 23/11/2018 - Don't use get_current_item or get_current_row within currentItemChanged or currentChanged signals.
Qt doesn't update selected rows on first currentChanged or currentItemChanged calls

- 22/05/2023 - For QTableWidget and QTableView, disabling wordWrap and using ScrollPerPixel as the horizontal scroll mode can help the user experience.
Consider doing these when creating a new QTableWidget or QTableView

- 15/02/2024 - Don't always trust the "Adjust Size" button of the Qt Designer, it might expand widgets much more than needed, especially for smaller widgets. Consider the use cases
and adjust manually. This also helps functions like `guiutils.center_to_parent` work properly

- 13/05/2024 - Monospace font and `utils.upper_hex` function greatly improve readability if the text area includes hex data, consider using those when creating new text areas. Memory Viewer is a good example for this

- 13/10/2024 - Using big integers as a `pyqtSignal` param will cause them to overflow and turn into different numbers because of the type mismatch between python and cpp. Use `object` instead of `int` as param in this case. An example for this case can be seen in [BookmarkWidget](./GUI/Widgets/Bookmark/Bookmark.py)

- 02/09/2018 - Seek methods of all file handles that read directly from the memory(/proc/pid/mem etc.) should be wrapped in a try/except block that catches both
OSError and ValueError exceptions. For instance:
```python
    try:
        self.memory.seek(start_addr)
    except (OSError, ValueError):
        break
```
OSError handles I/O related errors and ValueError handles the off_t limit error that prints "cannot fit 'int' into an offset-sized integer"

- 12/09/2018 - All namedtuples must have the same field name with their variable names. This makes the namedtuple transferable via pickle. For instance:
```python
    tuple_examine_expression = collections.namedtuple("tuple_examine_expression", "all address symbol")
```
- 06/10/2016 - HexView section of MemoryViewerWindow.ui: Changed listWidget_HexView_Address to tableWidget_HexView_Address in order to prevent possible future visual bugs.
Logically, it should stay as a listwidget considering its functionality. But it doesn't play nice with the other neighboring tablewidgets in different pyqt versions,
forcing me to use magic numbers for adjusting, which is a bit hackish

# Roadmap
So, after learning how to contribute, you are wondering where to start now. You can either search for `TODO` within the code or pick up any task from the roadmap below.
These tasks are ordered by importance but feel free to pick any of them. Further details can be discussed in the PINCE discord server
- Implement libpince engine
- Implement multi-line code injection, this will also help with previously dropped inject_with_advanced_injection
- Libpince support for Mono and Java (symbol recognition, calling functions, dissect obj tree etc.)
- Move GUI classes of PINCE.py to their own files
- Extend documentation to GUI parts. Libpince has 100% documentation coverage but GUI doesn't
- Use type hints(py 3.5) and variable annotations(py 3.6) when support drops for older systems
- Arrows for jump instructions based on disassembled output
- Flowcharts based on disassembled output
- Consider implementing a GUI for catchpoints. This is currently done via GDB Console
- Implement speedhack
- Implement unrandomizer
- Automatic function bypassing(make it return the desired value, hook specific parts etc.)
- Implement auto-ESP&aimbot
- Implement thread info widget
- Write at least one test for each function in libpince
- Refactorize memory write/read functions
- - ReferencedStringsWidgetForm refreshes the cache everytime the comboBox_ValueType changes, this creates serious performance issues if total results are more than 800k.
  Only update the visible rows to prevent this(check ```disassemble_check_viewport``` for an example)
- - Implement same system for the TrackBreakpointWidgetForm if necessary. Do performance tests
- - Consider using a class instead of primitive return types to store the raw bytes. This class should also include a method to display None type as red '??' text for Qt
- - Provide an option to cut BOM bytes when writing to memory with the types UTF-16 and UTF-32
- - Put a warning for users about replacement bytes for non UTF-8 types
- - Extend string types with LE and BE variants of UTF-16 and UTF-32
- - Change comboBox_ValueType string order to be ... String_UTF-8 String_Others if necessary
- - Implement a custom combobox class for comboBox_ValueType and create a context menu for String_Others, if it gets implemented
- Implement "Investigate Registers" button to gather information about the addresses registers point to
- Add the ability to track down registers and addresses in tracer(unsure)
- Implement CE's Ultimap-like feature for tracing data, dissect code data and raw instruction list.
Search for calls and store their hit counts to filter out the functions that haven't or have executed specific number of times.
Implement a flexible input field for the execution count. For instance, 2^x only searches for hit counts 2, 4, 8 and so on, 3x only searches for 3, 6, 9 etc.
([CE#358](https://github.com/cheat-engine/cheat-engine/issues/358))
- Extend search_referenced_strings with relative search
- Consider adding type guessing for the StackView
- Implement a psuedo-terminal for the inferior like edb does(idk if necessary, we don't usually target CLI games, up to debate)
- Try to optimize TrackBreakpoint and TrackWatchpoint return data structures further, adding an id field might simplify traversing of the tree, performance tests are required
- Implement extra MemoryViewerWindow tabs(not really critical right now, up to debate)
- ~~Consider removing the command file layer of IPC system for debugcore.send_command to speed up things~~
[Update-29/04/2018 : Delaying this until GDB/MI implements a native multiline command feature or improves ```interpreter-exec``` command to cover every single multiline command type(including ```define``` commands)]
- Implement developer mode in settings. Developer mode will include features like dissection of GUI elements on events such as mouse-over
- Add ability to include non-absolute calls for dissect code feature(i.e call rax). Should be considered after the first version release. Might be useful for multi-breakpoint related features
- Provide information about absolute addresses in disassemble screen
- All tables that hold large amount of data should only update the visible rows(check ```disassemble_check_viewport``` for an example)

```

`COPYING`:

```
PINCE is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {one line to give the program's name and a brief idea of what it does.}
    Copyright (C) {year}  {name of author}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    {project}  Copyright (C) {year}  {fullname}
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

```

`COPYING.CC-BY`:

```CC-BY
Creative Commons Legal Code

Attribution 3.0 Unported

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS LICENSE DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE INFORMATION PROVIDED, AND DISCLAIMS LIABILITY FOR
    DAMAGES RESULTING FROM ITS USE.

License

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE
COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS PROTECTED BY
COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS
AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE
TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY
BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS
CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND
CONDITIONS.

1. Definitions

 a. "Adaptation" means a work based upon the Work, or upon the Work and
    other pre-existing works, such as a translation, adaptation,
    derivative work, arrangement of music or other alterations of a
    literary or artistic work, or phonogram or performance and includes
    cinematographic adaptations or any other form in which the Work may be
    recast, transformed, or adapted including in any form recognizably
    derived from the original, except that a work that constitutes a
    Collection will not be considered an Adaptation for the purpose of
    this License. For the avoidance of doubt, where the Work is a musical
    work, performance or phonogram, the synchronization of the Work in
    timed-relation with a moving image ("synching") will be considered an
    Adaptation for the purpose of this License.
 b. "Collection" means a collection of literary or artistic works, such as
    encyclopedias and anthologies, or performances, phonograms or
    broadcasts, or other works or subject matter other than works listed
    in Section 1(f) below, which, by reason of the selection and
    arrangement of their contents, constitute intellectual creations, in
    which the Work is included in its entirety in unmodified form along
    with one or more other contributions, each constituting separate and
    independent works in themselves, which together are assembled into a
    collective whole. A work that constitutes a Collection will not be
    considered an Adaptation (as defined above) for the purposes of this
    License.
 c. "Distribute" means to make available to the public the original and
    copies of the Work or Adaptation, as appropriate, through sale or
    other transfer of ownership.
 d. "Licensor" means the individual, individuals, entity or entities that
    offer(s) the Work under the terms of this License.
 e. "Original Author" means, in the case of a literary or artistic work,
    the individual, individuals, entity or entities who created the Work
    or if no individual or entity can be identified, the publisher; and in
    addition (i) in the case of a performance the actors, singers,
    musicians, dancers, and other persons who act, sing, deliver, declaim,
    play in, interpret or otherwise perform literary or artistic works or
    expressions of folklore; (ii) in the case of a phonogram the producer
    being the person or legal entity who first fixes the sounds of a
    performance or other sounds; and, (iii) in the case of broadcasts, the
    organization that transmits the broadcast.
 f. "Work" means the literary and/or artistic work offered under the terms
    of this License including without limitation any production in the
    literary, scientific and artistic domain, whatever may be the mode or
    form of its expression including digital form, such as a book,
    pamphlet and other writing; a lecture, address, sermon or other work
    of the same nature; a dramatic or dramatico-musical work; a
    choreographic work or entertainment in dumb show; a musical
    composition with or without words; a cinematographic work to which are
    assimilated works expressed by a process analogous to cinematography;
    a work of drawing, painting, architecture, sculpture, engraving or
    lithography; a photographic work to which are assimilated works
    expressed by a process analogous to photography; a work of applied
    art; an illustration, map, plan, sketch or three-dimensional work
    relative to geography, topography, architecture or science; a
    performance; a broadcast; a phonogram; a compilation of data to the
    extent it is protected as a copyrightable work; or a work performed by
    a variety or circus performer to the extent it is not otherwise
    considered a literary or artistic work.
 g. "You" means an individual or entity exercising rights under this
    License who has not previously violated the terms of this License with
    respect to the Work, or who has received express permission from the
    Licensor to exercise rights under this License despite a previous
    violation.
 h. "Publicly Perform" means to perform public recitations of the Work and
    to communicate to the public those public recitations, by any means or
    process, including by wire or wireless means or public digital
    performances; to make available to the public Works in such a way that
    members of the public may access these Works from a place and at a
    place individually chosen by them; to perform the Work to the public
    by any means or process and the communication to the public of the
    performances of the Work, including by public digital performance; to
    broadcast and rebroadcast the Work by any means including signs,
    sounds or images.
 i. "Reproduce" means to make copies of the Work by any means including
    without limitation by sound or visual recordings and the right of
    fixation and reproducing fixations of the Work, including storage of a
    protected performance or phonogram in digital form or other electronic
    medium.

2. Fair Dealing Rights. Nothing in this License is intended to reduce,
limit, or restrict any uses free from copyright or rights arising from
limitations or exceptions that are provided for in connection with the
copyright protection under copyright law or other applicable laws.

3. License Grant. Subject to the terms and conditions of this License,
Licensor hereby grants You a worldwide, royalty-free, non-exclusive,
perpetual (for the duration of the applicable copyright) license to
exercise the rights in the Work as stated below:

 a. to Reproduce the Work, to incorporate the Work into one or more
    Collections, and to Reproduce the Work as incorporated in the
    Collections;
 b. to create and Reproduce Adaptations provided that any such Adaptation,
    including any translation in any medium, takes reasonable steps to
    clearly label, demarcate or otherwise identify that changes were made
    to the original Work. For example, a translation could be marked "The
    original work was translated from English to Spanish," or a
    modification could indicate "The original work has been modified.";
 c. to Distribute and Publicly Perform the Work including as incorporated
    in Collections; and,
 d. to Distribute and Publicly Perform Adaptations.
 e. For the avoidance of doubt:

     i. Non-waivable Compulsory License Schemes. In those jurisdictions in
        which the right to collect royalties through any statutory or
        compulsory licensing scheme cannot be waived, the Licensor
        reserves the exclusive right to collect such royalties for any
        exercise by You of the rights granted under this License;
    ii. Waivable Compulsory License Schemes. In those jurisdictions in
        which the right to collect royalties through any statutory or
        compulsory licensing scheme can be waived, the Licensor waives the
        exclusive right to collect such royalties for any exercise by You
        of the rights granted under this License; and,
   iii. Voluntary License Schemes. The Licensor waives the right to
        collect royalties, whether individually or, in the event that the
        Licensor is a member of a collecting society that administers
        voluntary licensing schemes, via that society, from any exercise
        by You of the rights granted under this License.

The above rights may be exercised in all media and formats whether now
known or hereafter devised. The above rights include the right to make
such modifications as are technically necessary to exercise the rights in
other media and formats. Subject to Section 8(f), all rights not expressly
granted by Licensor are hereby reserved.

4. Restrictions. The license granted in Section 3 above is expressly made
subject to and limited by the following restrictions:

 a. You may Distribute or Publicly Perform the Work only under the terms
    of this License. You must include a copy of, or the Uniform Resource
    Identifier (URI) for, this License with every copy of the Work You
    Distribute or Publicly Perform. You may not offer or impose any terms
    on the Work that restrict the terms of this License or the ability of
    the recipient of the Work to exercise the rights granted to that
    recipient under the terms of the License. You may not sublicense the
    Work. You must keep intact all notices that refer to this License and
    to the disclaimer of warranties with every copy of the Work You
    Distribute or Publicly Perform. When You Distribute or Publicly
    Perform the Work, You may not impose any effective technological
    measures on the Work that restrict the ability of a recipient of the
    Work from You to exercise the rights granted to that recipient under
    the terms of the License. This Section 4(a) applies to the Work as
    incorporated in a Collection, but this does not require the Collection
    apart from the Work itself to be made subject to the terms of this
    License. If You create a Collection, upon notice from any Licensor You
    must, to the extent practicable, remove from the Collection any credit
    as required by Section 4(b), as requested. If You create an
    Adaptation, upon notice from any Licensor You must, to the extent
    practicable, remove from the Adaptation any credit as required by
    Section 4(b), as requested.
 b. If You Distribute, or Publicly Perform the Work or any Adaptations or
    Collections, You must, unless a request has been made pursuant to
    Section 4(a), keep intact all copyright notices for the Work and
    provide, reasonable to the medium or means You are utilizing: (i) the
    name of the Original Author (or pseudonym, if applicable) if supplied,
    and/or if the Original Author and/or Licensor designate another party
    or parties (e.g., a sponsor institute, publishing entity, journal) for
    attribution ("Attribution Parties") in Licensor's copyright notice,
    terms of service or by other reasonable means, the name of such party
    or parties; (ii) the title of the Work if supplied; (iii) to the
    extent reasonably practicable, the URI, if any, that Licensor
    specifies to be associated with the Work, unless such URI does not
    refer to the copyright notice or licensing information for the Work;
    and (iv) , consistent with Section 3(b), in the case of an Adaptation,
    a credit identifying the use of the Work in the Adaptation (e.g.,
    "French translation of the Work by Original Author," or "Screenplay
    based on original Work by Original Author"). The credit required by
    this Section 4 (b) may be implemented in any reasonable manner;
    provided, however, that in the case of a Adaptation or Collection, at
    a minimum such credit will appear, if a credit for all contributing
    authors of the Adaptation or Collection appears, then as part of these
    credits and in a manner at least as prominent as the credits for the
    other contributing authors. For the avoidance of doubt, You may only
    use the credit required by this Section for the purpose of attribution
    in the manner set out above and, by exercising Your rights under this
    License, You may not implicitly or explicitly assert or imply any
    connection with, sponsorship or endorsement by the Original Author,
    Licensor and/or Attribution Parties, as appropriate, of You or Your
    use of the Work, without the separate, express prior written
    permission of the Original Author, Licensor and/or Attribution
    Parties.
 c. Except as otherwise agreed in writing by the Licensor or as may be
    otherwise permitted by applicable law, if You Reproduce, Distribute or
    Publicly Perform the Work either by itself or as part of any
    Adaptations or Collections, You must not distort, mutilate, modify or
    take other derogatory action in relation to the Work which would be
    prejudicial to the Original Author's honor or reputation. Licensor
    agrees that in those jurisdictions (e.g. Japan), in which any exercise
    of the right granted in Section 3(b) of this License (the right to
    make Adaptations) would be deemed to be a distortion, mutilation,
    modification or other derogatory action prejudicial to the Original
    Author's honor and reputation, the Licensor will waive or not assert,
    as appropriate, this Section, to the fullest extent permitted by the
    applicable national law, to enable You to reasonably exercise Your
    right under Section 3(b) of this License (right to make Adaptations)
    but not otherwise.

5. Representations, Warranties and Disclaimer

UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR
OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY
KIND CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE,
INCLUDING, WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY,
FITNESS FOR A PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF
LATENT OR OTHER DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS,
WHETHER OR NOT DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION
OF IMPLIED WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.

6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE
LAW, IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR
ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES
ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

7. Termination

 a. This License and the rights granted hereunder will terminate
    automatically upon any breach by You of the terms of this License.
    Individuals or entities who have received Adaptations or Collections
    from You under this License, however, will not have their licenses
    terminated provided such individuals or entities remain in full
    compliance with those licenses. Sections 1, 2, 5, 6, 7, and 8 will
    survive any termination of this License.
 b. Subject to the above terms and conditions, the license granted here is
    perpetual (for the duration of the applicable copyright in the Work).
    Notwithstanding the above, Licensor reserves the right to release the
    Work under different license terms or to stop distributing the Work at
    any time; provided, however that any such election will not serve to
    withdraw this License (or any other license that has been, or is
    required to be, granted under the terms of this License), and this
    License will continue in full force and effect unless terminated as
    stated above.

8. Miscellaneous

 a. Each time You Distribute or Publicly Perform the Work or a Collection,
    the Licensor offers to the recipient a license to the Work on the same
    terms and conditions as the license granted to You under this License.
 b. Each time You Distribute or Publicly Perform an Adaptation, Licensor
    offers to the recipient a license to the original Work on the same
    terms and conditions as the license granted to You under this License.
 c. If any provision of this License is invalid or unenforceable under
    applicable law, it shall not affect the validity or enforceability of
    the remainder of the terms of this License, and without further action
    by the parties to this agreement, such provision shall be reformed to
    the minimum extent necessary to make such provision valid and
    enforceable.
 d. No term or provision of this License shall be deemed waived and no
    breach consented to unless such waiver or consent shall be in writing
    and signed by the party to be charged with such waiver or consent.
 e. This License constitutes the entire agreement between the parties with
    respect to the Work licensed here. There are no understandings,
    agreements or representations with respect to the Work not specified
    here. Licensor shall not be bound by any additional provisions that
    may appear in any communication from You. This License may not be
    modified without the mutual written agreement of the Licensor and You.
 f. The rights granted under, and the subject matter referenced, in this
    License were drafted utilizing the terminology of the Berne Convention
    for the Protection of Literary and Artistic Works (as amended on
    September 28, 1979), the Rome Convention of 1961, the WIPO Copyright
    Treaty of 1996, the WIPO Performances and Phonograms Treaty of 1996
    and the Universal Copyright Convention (as revised on July 24, 1971).
    These rights and subject matter take effect in the relevant
    jurisdiction in which the License terms are sought to be enforced
    according to the corresponding provisions of the implementation of
    those treaty provisions in the applicable national law. If the
    standard suite of rights granted under applicable copyright law
    includes additional rights not granted under this License, such
    additional rights are deemed to be included in the License; this
    License is not intended to restrict the license of any rights under
    applicable law.


Creative Commons Notice

    Creative Commons is not a party to this License, and makes no warranty
    whatsoever in connection with the Work. Creative Commons will not be
    liable to You or any party on any legal theory for any damages
    whatsoever, including without limitation any general, special,
    incidental or consequential damages arising in connection to this
    license. Notwithstanding the foregoing two (2) sentences, if Creative
    Commons has expressly identified itself as the Licensor hereunder, it
    shall have all rights and obligations of Licensor.

    Except for the limited purpose of indicating to the public that the
    Work is licensed under the CCPL, Creative Commons does not authorize
    the use by either party of the trademark "Creative Commons" or any
    related trademark or logo of Creative Commons without the prior
    written consent of Creative Commons. Any permitted use will be in
    compliance with Creative Commons' then-current trademark usage
    guidelines, as may be published on its website or otherwise made
    available upon request from time to time. For the avoidance of doubt,
    this trademark restriction does not form part of this License.

    Creative Commons may be contacted at https://creativecommons.org/.

```

`GUI/AboutWidget.py`:

```py
# Form implementation generated from reading ui file 'AboutWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_TabWidget(object):
    def setupUi(self, TabWidget):
        TabWidget.setObjectName("TabWidget")
        TabWidget.resize(721, 659)
        self.tab_Contributors = QtWidgets.QWidget()
        self.tab_Contributors.setObjectName("tab_Contributors")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.tab_Contributors)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.textBrowser_Contributors = QtWidgets.QTextBrowser(parent=self.tab_Contributors)
        self.textBrowser_Contributors.setObjectName("textBrowser_Contributors")
        self.gridLayout_2.addWidget(self.textBrowser_Contributors, 0, 0, 1, 1)
        TabWidget.addTab(self.tab_Contributors, "")
        self.tab_License = QtWidgets.QWidget()
        self.tab_License.setObjectName("tab_License")
        self.gridLayout = QtWidgets.QGridLayout(self.tab_License)
        self.gridLayout.setObjectName("gridLayout")
        self.textBrowser_License = QtWidgets.QTextBrowser(parent=self.tab_License)
        self.textBrowser_License.setObjectName("textBrowser_License")
        self.gridLayout.addWidget(self.textBrowser_License, 0, 0, 1, 1)
        TabWidget.addTab(self.tab_License, "")

        self.retranslateUi(TabWidget)
        TabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(TabWidget)

    def retranslateUi(self, TabWidget):
        _translate = QtCore.QCoreApplication.translate
        TabWidget.setWindowTitle(_translate("TabWidget", "About PINCE"))
        TabWidget.setTabText(TabWidget.indexOf(self.tab_Contributors), _translate("TabWidget", "Contributors"))
        TabWidget.setTabText(TabWidget.indexOf(self.tab_License), _translate("TabWidget", "License"))

```

`GUI/AboutWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TabWidget</class>
 <widget class="QTabWidget" name="TabWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>721</width>
    <height>659</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>About PINCE</string>
  </property>
  <property name="currentIndex">
   <number>0</number>
  </property>
  <widget class="QWidget" name="tab_Contributors">
   <attribute name="title">
    <string>Contributors</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout_2">
    <item row="0" column="0">
     <widget class="QTextBrowser" name="textBrowser_Contributors"/>
    </item>
   </layout>
  </widget>
  <widget class="QWidget" name="tab_License">
   <attribute name="title">
    <string>License</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout">
    <item row="0" column="0">
     <widget class="QTextBrowser" name="textBrowser_License"/>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/AbstractTableModels/AsciiModel.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from GUI.AbstractTableModels.HexModel import QHexModel
from libpince import utils


class QAsciiModel(QHexModel):
    def __init__(self, row_count, column_count, parent=None):
        super().__init__(row_count, column_count, parent)

    def display_data(self, index):
        return utils.aob_to_str(self.data_array[index])

    def translate_data(self, data):
        return utils.str_to_aob(data)

```

`GUI/AbstractTableModels/HexModel.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt6.QtCore import QAbstractTableModel, QModelIndex, Qt
from PyQt6.QtGui import QColor, QColorConstants
from libpince import utils, debugcore


class QHexModel(QAbstractTableModel):
    def __init__(self, row_count, column_count, parent=None):
        super().__init__(parent)
        self.breakpoint_list = set()
        self.row_count = row_count
        self.column_count = column_count
        self.current_address = 0
        offset = row_count * column_count
        self.data_array = ["??"] * offset
        self.cell_animation = [0] * offset
        self.cell_change_color = QColor(QColorConstants.Red)
        self.breakpoint_color = QColor(QColorConstants.Green)
        self.breakpoint_color.setAlpha(96)

    def rowCount(self, QModelIndex_parent=None, *args, **kwargs):
        return self.row_count

    def columnCount(self, QModelIndex_parent=None, *args, **kwargs):
        return self.column_count

    def flags(self, index: QModelIndex):
        return super().flags(index) | Qt.ItemFlag.ItemIsEditable

    def data(self, model_index: QModelIndex, int_role=None):
        if self.data_array and model_index.isValid():
            index = model_index.row() * self.column_count + model_index.column()
            if int_role == Qt.ItemDataRole.BackgroundRole:
                address = self.current_address + index
                if utils.modulo_address(address, debugcore.inferior_arch) in self.breakpoint_list:
                    return self.breakpoint_color
                self.cell_change_color.setAlpha(20 * self.cell_animation[index])
                return self.cell_change_color
            elif int_role == Qt.ItemDataRole.DisplayRole:
                return self.display_data(index)

    def display_data(self, index):
        return self.data_array[index]

    def translate_data(self, data):
        return data

    def refresh(self, int_address, offset, data_array=None, breakpoint_info=None):
        int_address = utils.modulo_address(int_address, debugcore.inferior_arch)
        self.breakpoint_list.clear()
        if data_array is None:
            self.data_array = debugcore.hex_dump(int_address, offset)
        else:
            self.data_array = data_array
        if breakpoint_info is None:
            breakpoint_info = debugcore.get_breakpoint_info()
        for bp in breakpoint_info:
            if type(bp.address) != str:
                continue
            breakpoint_address = utils.safe_str_to_int(bp.address, 16)
            for i in range(bp.size):
                self.breakpoint_list.add(utils.modulo_address(breakpoint_address + i, debugcore.inferior_arch))
        self.current_address = int_address
        self.cell_animation = [0] * offset
        self.dataChanged.emit(self.index(0, 0), self.index(self.row_count - 1, self.column_count - 1))

    def update_loop(self, updated_array):
        for index, item in enumerate(self.cell_animation):
            if item > 0:
                self.cell_animation[index] = item - 1
        for index, item in enumerate(updated_array):
            if item != self.data_array[index]:
                self.cell_animation[index] = 6
        self.data_array = updated_array
        self.dataChanged.emit(self.index(0, 0), self.index(self.row_count - 1, self.column_count - 1))

    def update_index(self, index: int, data: str):
        data = self.translate_data(data)
        if self.data_array[index] != data:
            self.cell_animation[index] = 6
            self.data_array[index] = data
            model_index = self.index(index // self.column_count, index % self.column_count)
            self.dataChanged.emit(model_index, model_index)

```

`GUI/AddAddressManuallyDialog.py`:

```py
# Form implementation generated from reading ui file 'AddAddressManuallyDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(262, 486)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_5 = QtWidgets.QLabel(parent=Dialog)
        self.label_5.setObjectName("label_5")
        self.horizontalLayout_3.addWidget(self.label_5)
        self.comboBox_ValueType = QtWidgets.QComboBox(parent=Dialog)
        self.comboBox_ValueType.setObjectName("comboBox_ValueType")
        self.horizontalLayout_3.addWidget(self.comboBox_ValueType)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem)
        self.verticalLayout_3.addLayout(self.horizontalLayout_3)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.label_3 = QtWidgets.QLabel(parent=Dialog)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout_6.addWidget(self.label_3)
        self.comboBox_Endianness = QtWidgets.QComboBox(parent=Dialog)
        self.comboBox_Endianness.setObjectName("comboBox_Endianness")
        self.horizontalLayout_6.addWidget(self.comboBox_Endianness)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_6.addItem(spacerItem1)
        self.verticalLayout_3.addLayout(self.horizontalLayout_6)
        self.widget_Repr = QtWidgets.QWidget(parent=Dialog)
        self.widget_Repr.setObjectName("widget_Repr")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.widget_Repr)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.checkBox_Hex = QtWidgets.QCheckBox(parent=self.widget_Repr)
        self.checkBox_Hex.setObjectName("checkBox_Hex")
        self.horizontalLayout_2.addWidget(self.checkBox_Hex)
        self.checkBox_Signed = QtWidgets.QCheckBox(parent=self.widget_Repr)
        self.checkBox_Signed.setObjectName("checkBox_Signed")
        self.horizontalLayout_2.addWidget(self.checkBox_Signed)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem2)
        self.verticalLayout_3.addWidget(self.widget_Repr)
        self.widget_Length = QtWidgets.QWidget(parent=Dialog)
        self.widget_Length.setObjectName("widget_Length")
        self.horizontalLayout_Length = QtWidgets.QHBoxLayout(self.widget_Length)
        self.horizontalLayout_Length.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_Length.setObjectName("horizontalLayout_Length")
        self.label_Length = QtWidgets.QLabel(parent=self.widget_Length)
        self.label_Length.setObjectName("label_Length")
        self.horizontalLayout_Length.addWidget(self.label_Length)
        self.lineEdit_Length = QtWidgets.QLineEdit(parent=self.widget_Length)
        self.lineEdit_Length.setMaximumSize(QtCore.QSize(60, 16777215))
        self.lineEdit_Length.setInputMask("")
        self.lineEdit_Length.setText("10")
        self.lineEdit_Length.setObjectName("lineEdit_Length")
        self.horizontalLayout_Length.addWidget(self.lineEdit_Length)
        self.checkBox_ZeroTerminate = QtWidgets.QCheckBox(parent=self.widget_Length)
        self.checkBox_ZeroTerminate.setChecked(True)
        self.checkBox_ZeroTerminate.setObjectName("checkBox_ZeroTerminate")
        self.horizontalLayout_Length.addWidget(self.checkBox_ZeroTerminate)
        spacerItem3 = QtWidgets.QSpacerItem(13, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_Length.addItem(spacerItem3)
        self.verticalLayout_3.addWidget(self.widget_Length)
        self.gridLayout.addLayout(self.verticalLayout_3, 2, 0, 1, 1)
        self.widget_Pointer = QtWidgets.QWidget(parent=Dialog)
        self.widget_Pointer.setEnabled(True)
        self.widget_Pointer.setMinimumSize(QtCore.QSize(0, 0))
        self.widget_Pointer.setObjectName("widget_Pointer")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.widget_Pointer)
        self.verticalLayout_4.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_4.setSpacing(0)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.verticalLayout_Pointers = QtWidgets.QVBoxLayout()
        self.verticalLayout_Pointers.setObjectName("verticalLayout_Pointers")
        self.label_BaseAddress = QtWidgets.QLabel(parent=self.widget_Pointer)
        self.label_BaseAddress.setObjectName("label_BaseAddress")
        self.verticalLayout_Pointers.addWidget(self.label_BaseAddress)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.lineEdit_PtrStartAddress = QtWidgets.QLineEdit(parent=self.widget_Pointer)
        self.lineEdit_PtrStartAddress.setObjectName("lineEdit_PtrStartAddress")
        self.horizontalLayout_4.addWidget(self.lineEdit_PtrStartAddress)
        self.label_BaseAddressDeref = QtWidgets.QLabel(parent=self.widget_Pointer)
        self.label_BaseAddressDeref.setText("-> <font color=red>??</font>")
        self.label_BaseAddressDeref.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_BaseAddressDeref.setObjectName("label_BaseAddressDeref")
        self.horizontalLayout_4.addWidget(self.label_BaseAddressDeref)
        self.verticalLayout_Pointers.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.pushButton_AddOffset = QtWidgets.QPushButton(parent=self.widget_Pointer)
        self.pushButton_AddOffset.setObjectName("pushButton_AddOffset")
        self.horizontalLayout_5.addWidget(self.pushButton_AddOffset)
        self.pushButton_RemoveOffset = QtWidgets.QPushButton(parent=self.widget_Pointer)
        self.pushButton_RemoveOffset.setObjectName("pushButton_RemoveOffset")
        self.horizontalLayout_5.addWidget(self.pushButton_RemoveOffset)
        spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_5.addItem(spacerItem4)
        self.verticalLayout_Pointers.addLayout(self.horizontalLayout_5)
        self.verticalLayout_4.addLayout(self.verticalLayout_Pointers)
        self.gridLayout.addWidget(self.widget_Pointer, 7, 0, 1, 1)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label_4 = QtWidgets.QLabel(parent=Dialog)
        self.label_4.setObjectName("label_4")
        self.verticalLayout.addWidget(self.label_4)
        self.lineEdit_Description = QtWidgets.QLineEdit(parent=Dialog)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.MinimumExpanding, QtWidgets.QSizePolicy.Policy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lineEdit_Description.sizePolicy().hasHeightForWidth())
        self.lineEdit_Description.setSizePolicy(sizePolicy)
        self.lineEdit_Description.setText("")
        self.lineEdit_Description.setObjectName("lineEdit_Description")
        self.verticalLayout.addWidget(self.lineEdit_Description)
        self.gridLayout.addLayout(self.verticalLayout, 1, 0, 1, 1)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.buttonBox.sizePolicy().hasHeightForWidth())
        self.buttonBox.setSizePolicy(sizePolicy)
        self.buttonBox.setMaximumSize(QtCore.QSize(16777215, 35))
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 9, 0, 1, 1, QtCore.Qt.AlignmentFlag.AlignLeft)
        spacerItem5 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Minimum)
        self.gridLayout.addItem(spacerItem5, 8, 0, 1, 1)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setObjectName("label")
        self.verticalLayout_2.addWidget(self.label)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.lineEdit_Address = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_Address.setText("")
        self.lineEdit_Address.setObjectName("lineEdit_Address")
        self.horizontalLayout.addWidget(self.lineEdit_Address)
        self.label_2 = QtWidgets.QLabel(parent=Dialog)
        self.label_2.setText("=")
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.label_Value = QtWidgets.QLabel(parent=Dialog)
        self.label_Value.setText("")
        self.label_Value.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_Value.setObjectName("label_Value")
        self.horizontalLayout.addWidget(self.label_Value)
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem6)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        self.gridLayout.addLayout(self.verticalLayout_2, 0, 0, 1, 1)
        self.checkBox_IsPointer = QtWidgets.QCheckBox(parent=Dialog)
        self.checkBox_IsPointer.setObjectName("checkBox_IsPointer")
        self.gridLayout.addWidget(self.checkBox_IsPointer, 3, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Add Address Manually"))
        self.label_5.setText(_translate("Dialog", "Type:"))
        self.label_3.setText(_translate("Dialog", "Endianness:"))
        self.checkBox_Hex.setText(_translate("Dialog", "Hex"))
        self.checkBox_Signed.setText(_translate("Dialog", "Signed"))
        self.label_Length.setText(_translate("Dialog", "Length:"))
        self.checkBox_ZeroTerminate.setText(_translate("Dialog", "Zero-Terminated"))
        self.label_BaseAddress.setText(_translate("Dialog", "Base Address:"))
        self.pushButton_AddOffset.setText(_translate("Dialog", "Add Offset"))
        self.pushButton_RemoveOffset.setText(_translate("Dialog", "Remove Offset"))
        self.label_4.setText(_translate("Dialog", "Description:"))
        self.label.setText(_translate("Dialog", "Address:"))
        self.checkBox_IsPointer.setText(_translate("Dialog", "Pointer"))

```

`GUI/AddAddressManuallyDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>262</width>
    <height>486</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Add Address Manually</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="2" column="0">
    <layout class="QVBoxLayout" name="verticalLayout_3">
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_3">
       <item>
        <widget class="QLabel" name="label_5">
         <property name="text">
          <string>Type:</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QComboBox" name="comboBox_ValueType"/>
       </item>
       <item>
        <spacer name="horizontalSpacer_3">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_6">
       <item>
        <widget class="QLabel" name="label_3">
         <property name="text">
          <string>Endianness:</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QComboBox" name="comboBox_Endianness"/>
       </item>
       <item>
        <spacer name="horizontalSpacer_5">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
     <item>
      <widget class="QWidget" name="widget_Repr" native="true">
       <layout class="QHBoxLayout" name="horizontalLayout_2">
        <property name="leftMargin">
         <number>0</number>
        </property>
        <property name="topMargin">
         <number>0</number>
        </property>
        <property name="rightMargin">
         <number>0</number>
        </property>
        <property name="bottomMargin">
         <number>0</number>
        </property>
        <item>
         <widget class="QCheckBox" name="checkBox_Hex">
          <property name="text">
           <string>Hex</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QCheckBox" name="checkBox_Signed">
          <property name="text">
           <string>Signed</string>
          </property>
         </widget>
        </item>
        <item>
         <spacer name="horizontalSpacer_6">
          <property name="orientation">
           <enum>Qt::Horizontal</enum>
          </property>
          <property name="sizeHint" stdset="0">
           <size>
            <width>40</width>
            <height>20</height>
           </size>
          </property>
         </spacer>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QWidget" name="widget_Length" native="true">
       <layout class="QHBoxLayout" name="horizontalLayout_Length">
        <property name="leftMargin">
         <number>0</number>
        </property>
        <property name="topMargin">
         <number>0</number>
        </property>
        <property name="rightMargin">
         <number>0</number>
        </property>
        <property name="bottomMargin">
         <number>0</number>
        </property>
        <item>
         <widget class="QLabel" name="label_Length">
          <property name="text">
           <string>Length:</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QLineEdit" name="lineEdit_Length">
          <property name="maximumSize">
           <size>
            <width>60</width>
            <height>16777215</height>
           </size>
          </property>
          <property name="inputMask">
           <string/>
          </property>
          <property name="text">
           <string notr="true">10</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QCheckBox" name="checkBox_ZeroTerminate">
          <property name="text">
           <string>Zero-Terminated</string>
          </property>
          <property name="checked">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item>
         <spacer name="horizontalSpacer_2">
          <property name="orientation">
           <enum>Qt::Horizontal</enum>
          </property>
          <property name="sizeHint" stdset="0">
           <size>
            <width>13</width>
            <height>20</height>
           </size>
          </property>
         </spacer>
        </item>
       </layout>
      </widget>
     </item>
    </layout>
   </item>
   <item row="7" column="0">
    <widget class="QWidget" name="widget_Pointer" native="true">
     <property name="enabled">
      <bool>true</bool>
     </property>
     <property name="minimumSize">
      <size>
       <width>0</width>
       <height>0</height>
      </size>
     </property>
     <layout class="QVBoxLayout" name="verticalLayout_4">
      <property name="spacing">
       <number>0</number>
      </property>
      <property name="leftMargin">
       <number>0</number>
      </property>
      <property name="topMargin">
       <number>0</number>
      </property>
      <property name="rightMargin">
       <number>0</number>
      </property>
      <property name="bottomMargin">
       <number>0</number>
      </property>
      <item>
       <layout class="QVBoxLayout" name="verticalLayout_Pointers">
        <item>
         <widget class="QLabel" name="label_BaseAddress">
          <property name="text">
           <string>Base Address:</string>
          </property>
         </widget>
        </item>
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout_4">
          <item>
           <widget class="QLineEdit" name="lineEdit_PtrStartAddress"/>
          </item>
          <item>
           <widget class="QLabel" name="label_BaseAddressDeref">
            <property name="text">
             <string notr="true">-&gt; &lt;font color=red&gt;??&lt;/font&gt;</string>
            </property>
            <property name="textInteractionFlags">
             <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
            </property>
           </widget>
          </item>
         </layout>
        </item>
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout_5">
          <item>
           <widget class="QPushButton" name="pushButton_AddOffset">
            <property name="text">
             <string>Add Offset</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="pushButton_RemoveOffset">
            <property name="text">
             <string>Remove Offset</string>
            </property>
           </widget>
          </item>
          <item>
           <spacer name="horizontalSpacer_7">
            <property name="orientation">
             <enum>Qt::Horizontal</enum>
            </property>
            <property name="sizeHint" stdset="0">
             <size>
              <width>40</width>
              <height>20</height>
             </size>
            </property>
           </spacer>
          </item>
         </layout>
        </item>
       </layout>
      </item>
     </layout>
    </widget>
   </item>
   <item row="1" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QLabel" name="label_4">
       <property name="text">
        <string>Description:</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Description">
       <property name="sizePolicy">
        <sizepolicy hsizetype="MinimumExpanding" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="9" column="0" alignment="Qt::AlignLeft">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="maximumSize">
      <size>
       <width>16777215</width>
       <height>35</height>
      </size>
     </property>
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
   <item row="8" column="0">
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeType">
      <enum>QSizePolicy::Minimum</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>20</height>
      </size>
     </property>
    </spacer>
   </item>
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout_2">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Address:</string>
       </property>
      </widget>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout">
       <item>
        <widget class="QLineEdit" name="lineEdit_Address">
         <property name="text">
          <string/>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string notr="true">=</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_Value">
         <property name="text">
          <string/>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
    </layout>
   </item>
   <item row="3" column="0">
    <widget class="QCheckBox" name="checkBox_IsPointer">
     <property name="text">
      <string>Pointer</string>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>286</x>
     <y>399</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>286</x>
     <y>399</y>
    </hint>
    <hint type="destinationlabel">
     <x>283</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/BreakpointInfoWidget.py`:

```py
# Form implementation generated from reading ui file 'BreakpointInfoWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_TabWidget(object):
    def setupUi(self, TabWidget):
        TabWidget.setObjectName("TabWidget")
        TabWidget.resize(659, 496)
        self.tab_BreakpointInfo = QtWidgets.QWidget()
        self.tab_BreakpointInfo.setObjectName("tab_BreakpointInfo")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.tab_BreakpointInfo)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.tableWidget_BreakpointInfo = QtWidgets.QTableWidget(parent=self.tab_BreakpointInfo)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_BreakpointInfo.setFont(font)
        self.tableWidget_BreakpointInfo.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_BreakpointInfo.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_BreakpointInfo.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_BreakpointInfo.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollMode.ScrollPerPixel)
        self.tableWidget_BreakpointInfo.setWordWrap(False)
        self.tableWidget_BreakpointInfo.setObjectName("tableWidget_BreakpointInfo")
        self.tableWidget_BreakpointInfo.setColumnCount(9)
        self.tableWidget_BreakpointInfo.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(6, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(7, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_BreakpointInfo.setHorizontalHeaderItem(8, item)
        self.tableWidget_BreakpointInfo.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_BreakpointInfo.verticalHeader().setVisible(False)
        self.tableWidget_BreakpointInfo.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_BreakpointInfo.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout_2.addWidget(self.tableWidget_BreakpointInfo, 0, 0, 1, 1)
        TabWidget.addTab(self.tab_BreakpointInfo, "")
        self.tab_RawBreakpointInfo = QtWidgets.QWidget()
        self.tab_RawBreakpointInfo.setObjectName("tab_RawBreakpointInfo")
        self.gridLayout = QtWidgets.QGridLayout(self.tab_RawBreakpointInfo)
        self.gridLayout.setObjectName("gridLayout")
        self.textBrowser_BreakpointInfo = QtWidgets.QTextBrowser(parent=self.tab_RawBreakpointInfo)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.textBrowser_BreakpointInfo.setFont(font)
        self.textBrowser_BreakpointInfo.setObjectName("textBrowser_BreakpointInfo")
        self.gridLayout.addWidget(self.textBrowser_BreakpointInfo, 0, 0, 1, 1)
        TabWidget.addTab(self.tab_RawBreakpointInfo, "")

        self.retranslateUi(TabWidget)
        TabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(TabWidget)

    def retranslateUi(self, TabWidget):
        _translate = QtCore.QCoreApplication.translate
        TabWidget.setWindowTitle(_translate("TabWidget", "Breakpoints"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(0)
        item.setText(_translate("TabWidget", "No"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(1)
        item.setText(_translate("TabWidget", "Type"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(2)
        item.setText(_translate("TabWidget", "Disp"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(3)
        item.setText(_translate("TabWidget", "Enabled"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(4)
        item.setText(_translate("TabWidget", "Address"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(5)
        item.setText(_translate("TabWidget", "Size"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(6)
        item.setText(_translate("TabWidget", "On Hit"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(7)
        item.setText(_translate("TabWidget", "Hit Count"))
        item = self.tableWidget_BreakpointInfo.horizontalHeaderItem(8)
        item.setText(_translate("TabWidget", "Condition"))
        TabWidget.setTabText(TabWidget.indexOf(self.tab_BreakpointInfo), _translate("TabWidget", "Interactive"))
        TabWidget.setTabText(TabWidget.indexOf(self.tab_RawBreakpointInfo), _translate("TabWidget", "Raw"))

```

`GUI/BreakpointInfoWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TabWidget</class>
 <widget class="QTabWidget" name="TabWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>659</width>
    <height>496</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Breakpoints</string>
  </property>
  <property name="currentIndex">
   <number>0</number>
  </property>
  <widget class="QWidget" name="tab_BreakpointInfo">
   <attribute name="title">
    <string>Interactive</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout_2">
    <item row="0" column="0">
     <widget class="QTableWidget" name="tableWidget_BreakpointInfo">
      <property name="font">
       <font>
        <family>Monospace</family>
       </font>
      </property>
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::SingleSelection</enum>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectRows</enum>
      </property>
      <property name="horizontalScrollMode">
       <enum>QAbstractItemView::ScrollPerPixel</enum>
      </property>
      <property name="wordWrap">
       <bool>false</bool>
      </property>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <attribute name="verticalHeaderMinimumSectionSize">
       <number>16</number>
      </attribute>
      <attribute name="verticalHeaderDefaultSectionSize">
       <number>16</number>
      </attribute>
      <column>
       <property name="text">
        <string>No</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Type</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Disp</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Enabled</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Address</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Size</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>On Hit</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Hit Count</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Condition</string>
       </property>
      </column>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QWidget" name="tab_RawBreakpointInfo">
   <attribute name="title">
    <string>Raw</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout">
    <item row="0" column="0">
     <widget class="QTextBrowser" name="textBrowser_BreakpointInfo">
      <property name="font">
       <font>
        <family>Monospace</family>
       </font>
      </property>
     </widget>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/ConsoleWidget.py`:

```py
# Form implementation generated from reading ui file 'ConsoleWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(850, 500)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(Form.sizePolicy().hasHeightForWidth())
        Form.setSizePolicy(sizePolicy)
        Form.setMinimumSize(QtCore.QSize(850, 500))
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(Form)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.textBrowser = QtWidgets.QTextBrowser(parent=Form)
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 255, 0))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 255, 0, 128))
        brush.setStyle(QtCore.Qt.BrushStyle.NoBrush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.PlaceholderText, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 255, 0))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 255, 0, 128))
        brush.setStyle(QtCore.Qt.BrushStyle.NoBrush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.PlaceholderText, brush)
        brush = QtGui.QBrush(QtGui.QColor(128, 128, 128))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Text, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Base, brush)
        brush = QtGui.QBrush(QtGui.QColor(0, 255, 0, 128))
        brush.setStyle(QtCore.Qt.BrushStyle.NoBrush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.PlaceholderText, brush)
        self.textBrowser.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        font.setBold(False)
        font.setItalic(False)
        self.textBrowser.setFont(font)
        self.textBrowser.setObjectName("textBrowser")
        self.verticalLayout.addWidget(self.textBrowser)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.lineEdit = QtWidgets.QLineEdit(parent=Form)
        self.lineEdit.setObjectName("lineEdit")
        self.horizontalLayout.addWidget(self.lineEdit)
        self.pushButton_Send = QtWidgets.QPushButton(parent=Form)
        self.pushButton_Send.setObjectName("pushButton_Send")
        self.horizontalLayout.addWidget(self.pushButton_Send)
        self.radioButton_CLI = QtWidgets.QRadioButton(parent=Form)
        self.radioButton_CLI.setObjectName("radioButton_CLI")
        self.horizontalLayout.addWidget(self.radioButton_CLI)
        self.radioButton_MI = QtWidgets.QRadioButton(parent=Form)
        self.radioButton_MI.setChecked(True)
        self.radioButton_MI.setObjectName("radioButton_MI")
        self.horizontalLayout.addWidget(self.radioButton_MI)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.verticalLayout_2.addLayout(self.verticalLayout)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "GDB Console"))
        self.pushButton_Send.setText(_translate("Form", "Send"))
        self.radioButton_CLI.setText(_translate("Form", "CLI"))
        self.radioButton_MI.setText(_translate("Form", "MI"))

```

`GUI/ConsoleWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>850</width>
    <height>500</height>
   </rect>
  </property>
  <property name="sizePolicy">
   <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
    <horstretch>0</horstretch>
    <verstretch>0</verstretch>
   </sizepolicy>
  </property>
  <property name="minimumSize">
   <size>
    <width>850</width>
    <height>500</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>GDB Console</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_2">
   <item>
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QTextBrowser" name="textBrowser">
       <property name="palette">
        <palette>
         <active>
          <colorrole role="Text">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>0</red>
             <green>255</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
          <colorrole role="Base">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>0</red>
             <green>0</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
          <colorrole role="PlaceholderText">
           <brush brushstyle="NoBrush">
            <color alpha="128">
             <red>0</red>
             <green>255</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
         </active>
         <inactive>
          <colorrole role="Text">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>0</red>
             <green>255</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
          <colorrole role="Base">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>0</red>
             <green>0</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
          <colorrole role="PlaceholderText">
           <brush brushstyle="NoBrush">
            <color alpha="128">
             <red>0</red>
             <green>255</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
         </inactive>
         <disabled>
          <colorrole role="Text">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>128</red>
             <green>128</green>
             <blue>128</blue>
            </color>
           </brush>
          </colorrole>
          <colorrole role="Base">
           <brush brushstyle="SolidPattern">
            <color alpha="255">
             <red>255</red>
             <green>255</green>
             <blue>255</blue>
            </color>
           </brush>
          </colorrole>
          <colorrole role="PlaceholderText">
           <brush brushstyle="NoBrush">
            <color alpha="128">
             <red>0</red>
             <green>255</green>
             <blue>0</blue>
            </color>
           </brush>
          </colorrole>
         </disabled>
        </palette>
       </property>
       <property name="font">
        <font>
         <family>Monospace</family>
         <italic>false</italic>
         <bold>false</bold>
        </font>
       </property>
      </widget>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout">
       <item>
        <widget class="QLineEdit" name="lineEdit"/>
       </item>
       <item>
        <widget class="QPushButton" name="pushButton_Send">
         <property name="text">
          <string>Send</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QRadioButton" name="radioButton_CLI">
         <property name="text">
          <string>CLI</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QRadioButton" name="radioButton_MI">
         <property name="text">
          <string>MI</string>
         </property>
         <property name="checked">
          <bool>true</bool>
         </property>
        </widget>
       </item>
      </layout>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/DissectCodeDialog.py`:

```py
# Form implementation generated from reading ui file 'DissectCodeDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(799, 412)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(parent=Dialog)
        self.splitter.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.splitter.setObjectName("splitter")
        self.tableWidget_ExecutableMemoryRegions = QtWidgets.QTableWidget(parent=self.splitter)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_ExecutableMemoryRegions.setFont(font)
        self.tableWidget_ExecutableMemoryRegions.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_ExecutableMemoryRegions.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_ExecutableMemoryRegions.setWordWrap(False)
        self.tableWidget_ExecutableMemoryRegions.setObjectName("tableWidget_ExecutableMemoryRegions")
        self.tableWidget_ExecutableMemoryRegions.setColumnCount(2)
        self.tableWidget_ExecutableMemoryRegions.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_ExecutableMemoryRegions.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_ExecutableMemoryRegions.setHorizontalHeaderItem(1, item)
        self.tableWidget_ExecutableMemoryRegions.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_ExecutableMemoryRegions.verticalHeader().setVisible(False)
        self.tableWidget_ExecutableMemoryRegions.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_ExecutableMemoryRegions.verticalHeader().setMinimumSectionSize(16)
        self.layoutWidget = QtWidgets.QWidget(parent=self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label_ScanInfo = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_ScanInfo.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.label_ScanInfo.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_ScanInfo.setObjectName("label_ScanInfo")
        self.verticalLayout.addWidget(self.label_ScanInfo)
        self.label_RegionInfo = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_RegionInfo.setText("-")
        self.label_RegionInfo.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.label_RegionInfo.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_RegionInfo.setObjectName("label_RegionInfo")
        self.verticalLayout.addWidget(self.label_RegionInfo)
        self.label_RegionCountInfo = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_RegionCountInfo.setText("-")
        self.label_RegionCountInfo.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.label_RegionCountInfo.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_RegionCountInfo.setObjectName("label_RegionCountInfo")
        self.verticalLayout.addWidget(self.label_RegionCountInfo)
        self.label_4 = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_4.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.label_4.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_4.setObjectName("label_4")
        self.verticalLayout.addWidget(self.label_4)
        self.label_CurrentRange = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_CurrentRange.setText("-")
        self.label_CurrentRange.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.label_CurrentRange.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_CurrentRange.setObjectName("label_CurrentRange")
        self.verticalLayout.addWidget(self.label_CurrentRange)
        self.verticalLayout_2.addLayout(self.verticalLayout)
        self.line = QtWidgets.QFrame(parent=self.layoutWidget)
        self.line.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line.setObjectName("line")
        self.verticalLayout_2.addWidget(self.line)
        self.label = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label.setObjectName("label")
        self.verticalLayout_2.addWidget(self.label)
        self.label_StringReferenceCount = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_StringReferenceCount.setText("")
        self.label_StringReferenceCount.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_StringReferenceCount.setObjectName("label_StringReferenceCount")
        self.verticalLayout_2.addWidget(self.label_StringReferenceCount)
        self.label_2 = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_2.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_2.addWidget(self.label_2)
        self.label_JumpReferenceCount = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_JumpReferenceCount.setText("")
        self.label_JumpReferenceCount.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_JumpReferenceCount.setObjectName("label_JumpReferenceCount")
        self.verticalLayout_2.addWidget(self.label_JumpReferenceCount)
        self.label_3 = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_3.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_2.addWidget(self.label_3)
        self.label_CallReferenceCount = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_CallReferenceCount.setText("")
        self.label_CallReferenceCount.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_CallReferenceCount.setObjectName("label_CallReferenceCount")
        self.verticalLayout_2.addWidget(self.label_CallReferenceCount)
        self.line_2 = QtWidgets.QFrame(parent=self.layoutWidget)
        self.line_2.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_2.setObjectName("line_2")
        self.verticalLayout_2.addWidget(self.line_2)
        self.checkBox_DiscardInvalidStrings = QtWidgets.QCheckBox(parent=self.layoutWidget)
        self.checkBox_DiscardInvalidStrings.setChecked(True)
        self.checkBox_DiscardInvalidStrings.setObjectName("checkBox_DiscardInvalidStrings")
        self.verticalLayout_2.addWidget(self.checkBox_DiscardInvalidStrings)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.pushButton_StartCancel = QtWidgets.QPushButton(parent=self.layoutWidget)
        self.pushButton_StartCancel.setText("")
        self.pushButton_StartCancel.setObjectName("pushButton_StartCancel")
        self.horizontalLayout.addWidget(self.pushButton_StartCancel)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        spacerItem2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_2.addItem(spacerItem2)
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dissect Code"))
        item = self.tableWidget_ExecutableMemoryRegions.horizontalHeaderItem(0)
        item.setText(_translate("Dialog", "Regions"))
        item = self.tableWidget_ExecutableMemoryRegions.horizontalHeaderItem(1)
        item.setText(_translate("Dialog", "Path"))
        self.label_ScanInfo.setText(_translate("Dialog", "Selected regions will be scanned"))
        self.label_4.setText(_translate("Dialog", "Currently scanning range:"))
        self.label.setText(_translate("Dialog", "String references found:"))
        self.label_2.setText(_translate("Dialog", "Jumps found:"))
        self.label_3.setText(_translate("Dialog", "Calls found:"))
        self.checkBox_DiscardInvalidStrings.setToolTip(_translate("Dialog", "Entries that can\'t be decoded as utf-8 won\'t be included in referenced strings\n"
"Unchecking it makes ReferencedStringsWidget load slower but allows you to examine non-string pointers on it"))
        self.checkBox_DiscardInvalidStrings.setText(_translate("Dialog", "Discard invalid strings"))

```

`GUI/DissectCodeDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>799</width>
    <height>412</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dissect Code</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QTableWidget" name="tableWidget_ExecutableMemoryRegions">
      <property name="font">
       <font>
        <family>Monospace</family>
       </font>
      </property>
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectRows</enum>
      </property>
      <property name="wordWrap">
       <bool>false</bool>
      </property>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <attribute name="verticalHeaderMinimumSectionSize">
       <number>16</number>
      </attribute>
      <attribute name="verticalHeaderDefaultSectionSize">
       <number>16</number>
      </attribute>
      <column>
       <property name="text">
        <string>Regions</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Path</string>
       </property>
      </column>
     </widget>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <item>
        <layout class="QVBoxLayout" name="verticalLayout">
         <item>
          <widget class="QLabel" name="label_ScanInfo">
           <property name="text">
            <string>Selected regions will be scanned</string>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
           <property name="textInteractionFlags">
            <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_RegionInfo">
           <property name="text">
            <string notr="true">-</string>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
           <property name="textInteractionFlags">
            <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_RegionCountInfo">
           <property name="text">
            <string notr="true">-</string>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
           <property name="textInteractionFlags">
            <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_4">
           <property name="text">
            <string>Currently scanning range:</string>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
           <property name="textInteractionFlags">
            <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QLabel" name="label_CurrentRange">
           <property name="text">
            <string notr="true">-</string>
           </property>
           <property name="alignment">
            <set>Qt::AlignCenter</set>
           </property>
           <property name="textInteractionFlags">
            <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="Line" name="line">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>String references found:</string>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_StringReferenceCount">
         <property name="text">
          <string/>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>Jumps found:</string>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_JumpReferenceCount">
         <property name="text">
          <string/>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_3">
         <property name="text">
          <string>Calls found:</string>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_CallReferenceCount">
         <property name="text">
          <string/>
         </property>
         <property name="textInteractionFlags">
          <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
         </property>
        </widget>
       </item>
       <item>
        <widget class="Line" name="line_2">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QCheckBox" name="checkBox_DiscardInvalidStrings">
         <property name="toolTip">
          <string>Entries that can't be decoded as utf-8 won't be included in referenced strings
Unchecking it makes ReferencedStringsWidget load slower but allows you to examine non-string pointers on it</string>
         </property>
         <property name="text">
          <string>Discard invalid strings</string>
         </property>
         <property name="checked">
          <bool>true</bool>
         </property>
        </widget>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout">
         <item>
          <spacer name="horizontalSpacer_2">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_StartCancel">
           <property name="text">
            <string/>
           </property>
          </widget>
         </item>
         <item>
          <spacer name="horizontalSpacer">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </item>
       <item>
        <spacer name="verticalSpacer">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>40</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/EditInstructionDialog.py`:

```py
# Form implementation generated from reading ui file 'EditInstructionDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.setEnabled(True)
        Dialog.resize(500, 124)
        Dialog.setMaximumSize(QtCore.QSize(16777215, 124))
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.lineEdit_Bytes = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_Bytes.setObjectName("lineEdit_Bytes")
        self.gridLayout.addWidget(self.lineEdit_Bytes, 1, 0, 1, 1)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 2, 0, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit_Address = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_Address.setEnabled(False)
        self.lineEdit_Address.setAutoFillBackground(False)
        self.lineEdit_Address.setReadOnly(True)
        self.lineEdit_Address.setObjectName("lineEdit_Address")
        self.horizontalLayout.addWidget(self.lineEdit_Address)
        self.label_2 = QtWidgets.QLabel(parent=Dialog)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.lineEdit_Instruction = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_Instruction.setObjectName("lineEdit_Instruction")
        self.horizontalLayout.addWidget(self.lineEdit_Instruction)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Edit Instruction"))
        self.label.setText(_translate("Dialog", "Address:"))
        self.label_2.setText(_translate("Dialog", "Instruction:"))
        self.lineEdit_Instruction.setToolTip(_translate("Dialog", "Multiple entries are separated with ;"))

```

`GUI/EditInstructionDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="enabled">
   <bool>true</bool>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>500</width>
    <height>124</height>
   </rect>
  </property>
  <property name="maximumSize">
   <size>
    <width>16777215</width>
    <height>124</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Edit Instruction</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="1" column="0">
    <widget class="QLineEdit" name="lineEdit_Bytes"/>
   </item>
   <item row="2" column="0">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Address:</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Address">
       <property name="enabled">
        <bool>false</bool>
       </property>
       <property name="autoFillBackground">
        <bool>false</bool>
       </property>
       <property name="readOnly">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="label_2">
       <property name="text">
        <string>Instruction:</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Instruction">
       <property name="toolTip">
        <string>Multiple entries are separated with ;</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/EditTypeDialog.py`:

```py
# Form implementation generated from reading ui file 'EditTypeDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(235, 163)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.comboBox_ValueType = QtWidgets.QComboBox(parent=Dialog)
        self.comboBox_ValueType.setObjectName("comboBox_ValueType")
        self.verticalLayout.addWidget(self.comboBox_ValueType)
        self.horizontalLayout_3.addLayout(self.verticalLayout)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.label_2 = QtWidgets.QLabel(parent=Dialog)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_3.addWidget(self.label_2)
        self.comboBox_Endianness = QtWidgets.QComboBox(parent=Dialog)
        self.comboBox_Endianness.setObjectName("comboBox_Endianness")
        self.verticalLayout_3.addWidget(self.comboBox_Endianness)
        self.horizontalLayout_3.addLayout(self.verticalLayout_3)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem)
        self.gridLayout.addLayout(self.horizontalLayout_3, 0, 0, 1, 1)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.checkBox_Hex = QtWidgets.QCheckBox(parent=Dialog)
        self.checkBox_Hex.setObjectName("checkBox_Hex")
        self.horizontalLayout_2.addWidget(self.checkBox_Hex)
        self.checkBox_Signed = QtWidgets.QCheckBox(parent=Dialog)
        self.checkBox_Signed.setObjectName("checkBox_Signed")
        self.horizontalLayout_2.addWidget(self.checkBox_Signed)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem1)
        self.gridLayout.addLayout(self.horizontalLayout_2, 1, 0, 1, 1)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 3, 0, 1, 1, QtCore.Qt.AlignmentFlag.AlignLeft)
        self.widget_Length = QtWidgets.QWidget(parent=Dialog)
        self.widget_Length.setObjectName("widget_Length")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout(self.widget_Length)
        self.horizontalLayout_4.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.label_Length = QtWidgets.QLabel(parent=self.widget_Length)
        self.label_Length.setObjectName("label_Length")
        self.horizontalLayout_4.addWidget(self.label_Length)
        self.lineEdit_Length = QtWidgets.QLineEdit(parent=self.widget_Length)
        self.lineEdit_Length.setText("10")
        self.lineEdit_Length.setObjectName("lineEdit_Length")
        self.horizontalLayout_4.addWidget(self.lineEdit_Length)
        self.checkBox_ZeroTerminate = QtWidgets.QCheckBox(parent=self.widget_Length)
        self.checkBox_ZeroTerminate.setChecked(True)
        self.checkBox_ZeroTerminate.setObjectName("checkBox_ZeroTerminate")
        self.horizontalLayout_4.addWidget(self.checkBox_ZeroTerminate)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem2)
        self.gridLayout.addWidget(self.widget_Length, 2, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Type"))
        self.label.setText(_translate("Dialog", "Type"))
        self.label_2.setText(_translate("Dialog", "Endianness"))
        self.checkBox_Hex.setText(_translate("Dialog", "Hex"))
        self.checkBox_Signed.setText(_translate("Dialog", "Signed"))
        self.label_Length.setText(_translate("Dialog", "Length"))
        self.checkBox_ZeroTerminate.setText(_translate("Dialog", "Zero-Terminated"))

```

`GUI/EditTypeDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>235</width>
    <height>163</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Type</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout_3">
     <item>
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>Type</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QComboBox" name="comboBox_ValueType"/>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QVBoxLayout" name="verticalLayout_3">
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>Endianness</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QComboBox" name="comboBox_Endianness"/>
       </item>
      </layout>
     </item>
     <item>
      <spacer name="horizontalSpacer_3">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QCheckBox" name="checkBox_Hex">
       <property name="text">
        <string>Hex</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_Signed">
       <property name="text">
        <string>Signed</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item row="3" column="0" alignment="Qt::AlignLeft">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
   <item row="2" column="0">
    <widget class="QWidget" name="widget_Length" native="true">
     <layout class="QHBoxLayout" name="horizontalLayout_4">
      <property name="leftMargin">
       <number>0</number>
      </property>
      <property name="topMargin">
       <number>0</number>
      </property>
      <property name="rightMargin">
       <number>0</number>
      </property>
      <property name="bottomMargin">
       <number>0</number>
      </property>
      <item>
       <widget class="QLabel" name="label_Length">
        <property name="text">
         <string>Length</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QLineEdit" name="lineEdit_Length">
        <property name="text">
         <string notr="true">10</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QCheckBox" name="checkBox_ZeroTerminate">
        <property name="text">
         <string>Zero-Terminated</string>
        </property>
        <property name="checked">
         <bool>true</bool>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_2">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
     </layout>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/ExamineReferrersWidget.py`:

```py
# Form implementation generated from reading ui file 'ExamineReferrersWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(1025, 530)
        Form.setToolTip("")
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(parent=Form)
        self.splitter.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtWidgets.QWidget(parent=self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lineEdit_Regex = QtWidgets.QLineEdit(parent=self.layoutWidget)
        self.lineEdit_Regex.setObjectName("lineEdit_Regex")
        self.horizontalLayout_2.addWidget(self.lineEdit_Regex)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(parent=self.layoutWidget)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.horizontalLayout_2.addWidget(self.checkBox_CaseSensitive)
        self.checkBox_Regex = QtWidgets.QCheckBox(parent=self.layoutWidget)
        self.checkBox_Regex.setObjectName("checkBox_Regex")
        self.horizontalLayout_2.addWidget(self.checkBox_Regex)
        self.pushButton_Search = QtWidgets.QPushButton(parent=self.layoutWidget)
        self.pushButton_Search.setObjectName("pushButton_Search")
        self.horizontalLayout_2.addWidget(self.pushButton_Search)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.listWidget_Referrers = QtWidgets.QListWidget(parent=self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.listWidget_Referrers.setFont(font)
        self.listWidget_Referrers.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.listWidget_Referrers.setObjectName("listWidget_Referrers")
        self.verticalLayout.addWidget(self.listWidget_Referrers)
        self.textBrowser_DisasInfo = QtWidgets.QTextBrowser(parent=self.splitter)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.textBrowser_DisasInfo.setFont(font)
        self.textBrowser_DisasInfo.setLineWrapMode(QtWidgets.QTextEdit.LineWrapMode.NoWrap)
        self.textBrowser_DisasInfo.setObjectName("textBrowser_DisasInfo")
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Examine Referrers"))
        self.lineEdit_Regex.setToolTip(_translate("Form", "Enter a string or a python regex"))
        self.lineEdit_Regex.setPlaceholderText(_translate("Form", "Enter a string or a python regex"))
        self.checkBox_CaseSensitive.setToolTip(_translate("Form", "Ignore case if checked"))
        self.checkBox_CaseSensitive.setText(_translate("Form", "Case sensitive"))
        self.checkBox_Regex.setToolTip(_translate("Form", "Your string will be treated as a regex if checked"))
        self.checkBox_Regex.setText(_translate("Form", "Regex"))
        self.pushButton_Search.setText(_translate("Form", "Search(Enter)"))

```

`GUI/ExamineReferrersWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1025</width>
    <height>530</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Examine Referrers</string>
  </property>
  <property name="toolTip">
   <string/>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLineEdit" name="lineEdit_Regex">
           <property name="toolTip">
            <string>Enter a string or a python regex</string>
           </property>
           <property name="placeholderText">
            <string>Enter a string or a python regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_CaseSensitive">
           <property name="toolTip">
            <string>Ignore case if checked</string>
           </property>
           <property name="text">
            <string>Case sensitive</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_Regex">
           <property name="toolTip">
            <string>Your string will be treated as a regex if checked</string>
           </property>
           <property name="text">
            <string>Regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_Search">
           <property name="text">
            <string>Search(Enter)</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QListWidget" name="listWidget_Referrers">
         <property name="font">
          <font>
           <family>Monospace</family>
          </font>
         </property>
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QTextBrowser" name="textBrowser_DisasInfo">
      <property name="font">
       <font>
        <family>Monospace</family>
       </font>
      </property>
      <property name="lineWrapMode">
       <enum>QTextEdit::NoWrap</enum>
      </property>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/FloatRegisterWidget.py`:

```py
# Form implementation generated from reading ui file 'FloatRegisterWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_TabWidget(object):
    def setupUi(self, TabWidget):
        TabWidget.setObjectName("TabWidget")
        TabWidget.resize(400, 316)
        self.FPU = QtWidgets.QWidget()
        self.FPU.setObjectName("FPU")
        self.gridLayout = QtWidgets.QGridLayout(self.FPU)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_FPU = QtWidgets.QTableWidget(parent=self.FPU)
        self.tableWidget_FPU.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_FPU.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_FPU.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_FPU.setWordWrap(False)
        self.tableWidget_FPU.setObjectName("tableWidget_FPU")
        self.tableWidget_FPU.setColumnCount(2)
        self.tableWidget_FPU.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_FPU.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_FPU.setHorizontalHeaderItem(1, item)
        self.tableWidget_FPU.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_FPU.verticalHeader().setVisible(False)
        self.gridLayout.addWidget(self.tableWidget_FPU, 0, 0, 1, 1)
        TabWidget.addTab(self.FPU, "FPU")
        self.XMM = QtWidgets.QWidget()
        self.XMM.setObjectName("XMM")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.XMM)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.tableWidget_XMM = QtWidgets.QTableWidget(parent=self.XMM)
        self.tableWidget_XMM.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_XMM.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_XMM.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_XMM.setObjectName("tableWidget_XMM")
        self.tableWidget_XMM.setColumnCount(2)
        self.tableWidget_XMM.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_XMM.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_XMM.setHorizontalHeaderItem(1, item)
        self.tableWidget_XMM.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_XMM.verticalHeader().setVisible(False)
        self.gridLayout_2.addWidget(self.tableWidget_XMM, 0, 0, 1, 1)
        TabWidget.addTab(self.XMM, "XMM")

        self.retranslateUi(TabWidget)
        TabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(TabWidget)

    def retranslateUi(self, TabWidget):
        _translate = QtCore.QCoreApplication.translate
        TabWidget.setWindowTitle(_translate("TabWidget", "Floating Point Registers"))
        item = self.tableWidget_FPU.horizontalHeaderItem(0)
        item.setText(_translate("TabWidget", "Register"))
        item = self.tableWidget_FPU.horizontalHeaderItem(1)
        item.setText(_translate("TabWidget", "Value"))
        item = self.tableWidget_XMM.horizontalHeaderItem(0)
        item.setText(_translate("TabWidget", "Register"))
        item = self.tableWidget_XMM.horizontalHeaderItem(1)
        item.setText(_translate("TabWidget", "Value"))

```

`GUI/FloatRegisterWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>TabWidget</class>
 <widget class="QTabWidget" name="TabWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>316</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Floating Point Registers</string>
  </property>
  <property name="currentIndex">
   <number>0</number>
  </property>
  <widget class="QWidget" name="FPU">
   <attribute name="title">
    <string notr="true">FPU</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout">
    <item row="0" column="0">
     <widget class="QTableWidget" name="tableWidget_FPU">
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::SingleSelection</enum>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectRows</enum>
      </property>
      <property name="wordWrap">
       <bool>false</bool>
      </property>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <column>
       <property name="text">
        <string>Register</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Value</string>
       </property>
      </column>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QWidget" name="XMM">
   <attribute name="title">
    <string notr="true">XMM</string>
   </attribute>
   <layout class="QGridLayout" name="gridLayout_2">
    <item row="0" column="0">
     <widget class="QTableWidget" name="tableWidget_XMM">
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::SingleSelection</enum>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectRows</enum>
      </property>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <column>
       <property name="text">
        <string>Register</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Value</string>
       </property>
      </column>
     </widget>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/FunctionsInfoWidget.py`:

```py
# Form implementation generated from reading ui file 'FunctionsInfoWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(640, 555)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_SymbolInfo = QtWidgets.QTableWidget(parent=Form)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_SymbolInfo.setFont(font)
        self.tableWidget_SymbolInfo.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_SymbolInfo.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_SymbolInfo.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_SymbolInfo.setWordWrap(False)
        self.tableWidget_SymbolInfo.setObjectName("tableWidget_SymbolInfo")
        self.tableWidget_SymbolInfo.setColumnCount(2)
        self.tableWidget_SymbolInfo.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_SymbolInfo.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_SymbolInfo.setHorizontalHeaderItem(1, item)
        self.tableWidget_SymbolInfo.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_SymbolInfo.verticalHeader().setVisible(False)
        self.tableWidget_SymbolInfo.verticalHeader().setDefaultSectionSize(20)
        self.tableWidget_SymbolInfo.verticalHeader().setMinimumSectionSize(20)
        self.gridLayout.addWidget(self.tableWidget_SymbolInfo, 2, 0, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.lineEdit_SearchInput = QtWidgets.QLineEdit(parent=Form)
        self.lineEdit_SearchInput.setObjectName("lineEdit_SearchInput")
        self.horizontalLayout.addWidget(self.lineEdit_SearchInput)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(parent=Form)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.horizontalLayout.addWidget(self.checkBox_CaseSensitive)
        self.pushButton_Search = QtWidgets.QPushButton(parent=Form)
        self.pushButton_Search.setObjectName("pushButton_Search")
        self.horizontalLayout.addWidget(self.pushButton_Search)
        self.pushButton_Help = QtWidgets.QPushButton(parent=Form)
        self.pushButton_Help.setText("")
        self.pushButton_Help.setObjectName("pushButton_Help")
        self.horizontalLayout.addWidget(self.pushButton_Help)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.textBrowser_AddressInfo = QtWidgets.QTextBrowser(parent=Form)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.textBrowser_AddressInfo.setFont(font)
        self.textBrowser_AddressInfo.setObjectName("textBrowser_AddressInfo")
        self.gridLayout.addWidget(self.textBrowser_AddressInfo, 1, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Functions"))
        self.tableWidget_SymbolInfo.setSortingEnabled(True)
        item = self.tableWidget_SymbolInfo.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_SymbolInfo.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Symbol"))
        self.lineEdit_SearchInput.setPlaceholderText(_translate("Form", "Enter the regex. Leave blank to see all functions"))
        self.checkBox_CaseSensitive.setToolTip(_translate("Form", "Ignore case if checked"))
        self.checkBox_CaseSensitive.setText(_translate("Form", "Case sensitive"))
        self.pushButton_Search.setText(_translate("Form", "Search(Enter)"))

```

`GUI/FunctionsInfoWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>640</width>
    <height>555</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Functions</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="2" column="0">
    <widget class="QTableWidget" name="tableWidget_SymbolInfo">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>20</number>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>20</number>
     </attribute>
     <column>
      <property name="text">
       <string>Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Symbol</string>
      </property>
     </column>
    </widget>
   </item>
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLineEdit" name="lineEdit_SearchInput">
       <property name="placeholderText">
        <string>Enter the regex. Leave blank to see all functions</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_CaseSensitive">
       <property name="toolTip">
        <string>Ignore case if checked</string>
       </property>
       <property name="text">
        <string>Case sensitive</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Search">
       <property name="text">
        <string>Search(Enter)</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Help">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <widget class="QTextBrowser" name="textBrowser_AddressInfo">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/HexEditDialog.py`:

```py
# Form implementation generated from reading ui file 'HexEditDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(515, 138)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit_Address = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_Address.setObjectName("lineEdit_Address")
        self.horizontalLayout.addWidget(self.lineEdit_Address)
        self.label_2 = QtWidgets.QLabel(parent=Dialog)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.lineEdit_Length = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_Length.setObjectName("lineEdit_Length")
        self.horizontalLayout.addWidget(self.lineEdit_Length)
        self.pushButton_Refresh = QtWidgets.QPushButton(parent=Dialog)
        self.pushButton_Refresh.setObjectName("pushButton_Refresh")
        self.horizontalLayout.addWidget(self.pushButton_Refresh)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.lineEdit_AsciiView = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_AsciiView.setObjectName("lineEdit_AsciiView")
        self.gridLayout.addWidget(self.lineEdit_AsciiView, 1, 0, 1, 1)
        self.lineEdit_HexView = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_HexView.setObjectName("lineEdit_HexView")
        self.gridLayout.addWidget(self.lineEdit_HexView, 2, 0, 1, 1)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 3, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Hex Edit"))
        self.label.setText(_translate("Dialog", "Address:"))
        self.label_2.setText(_translate("Dialog", "Length:"))
        self.pushButton_Refresh.setText(_translate("Dialog", "Refresh"))

```

`GUI/HexEditDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>515</width>
    <height>138</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Hex Edit</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Address:</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Address"/>
     </item>
     <item>
      <widget class="QLabel" name="label_2">
       <property name="text">
        <string>Length:</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Length"/>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Refresh">
       <property name="text">
        <string>Refresh</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <widget class="QLineEdit" name="lineEdit_AsciiView"/>
   </item>
   <item row="2" column="0">
    <widget class="QLineEdit" name="lineEdit_HexView"/>
   </item>
   <item row="3" column="0">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/ItemDelegates/HexDelegate.py`:

```py
"""
Copyright (C) Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt6.QtWidgets import QStyledItemDelegate, QLineEdit, QWidget
from PyQt6.QtGui import QRegularExpressionValidator
from PyQt6.QtCore import QModelIndex, Qt, QRegularExpression


class QHexDelegate(QStyledItemDelegate):
    def __init__(self, max_length: int = 2, regexp: str = "[0-9a-fA-F]+", parent=None) -> None:
        super().__init__(parent)
        self.max_length = max_length
        self.regexp = regexp

    def createEditor(self, parent: QWidget, option, index: QModelIndex) -> QLineEdit:
        self.editor = QLineEdit(parent)
        self.editor.setMaxLength(self.max_length)
        hex_validator = QRegularExpressionValidator(QRegularExpression(self.regexp), self.editor)
        self.editor.setValidator(hex_validator)
        self.editor.setText(index.model().data(index, Qt.ItemDataRole.DisplayRole))
        self.editor.textChanged.connect(self.check_text)
        return self.editor

    def setEditorData(self, editor, index) -> None:
        # Initial text was set in createEditor, this is a trick to dodge the textChanged signal
        return

    def check_text(self) -> None:
        if len(self.editor.text()) >= self.max_length:
            self.closeEditor.emit(self.editor, QStyledItemDelegate.EndEditHint.EditNextItem)

```

`GUI/Labels/FlagRegisterLabel.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt6.QtWidgets import QLabel, QMessageBox
from PyQt6.QtGui import QCursor, QMouseEvent, QEnterEvent
from PyQt6.QtCore import Qt
from libpince import debugcore, typedefs
from GUI.Utils import guiutils, utilwidgets
from tr.tr import TranslationConstants as tr


class QFlagRegisterLabel(QLabel):
    def __init__(self, parent=None):
        super().__init__(parent)

    def set_value(self, value):
        new = value
        old = self.text()
        if old != new:
            self.setStyleSheet("color: red")
        else:
            self.setStyleSheet("")
        self.setText(new)

    def enterEvent(self, event: QEnterEvent):
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        super().enterEvent(event)

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        if (
            event.button() != Qt.MouseButton.LeftButton
            or debugcore.currentpid == -1
            or debugcore.inferior_status == typedefs.INFERIOR_STATUS.RUNNING
        ):
            # self.window() is needed to fix messagebox text color being red
            QMessageBox.information(self.window(), tr.ERROR, tr.REQUIRE_PROCESS_STOP)
            return
        registers = debugcore.read_registers()
        current_flag = self.objectName().lower()
        label_text = tr.ENTER_FLAG_VALUE.format(self.objectName())
        parent = guiutils.search_parents_by_function(self, "set_debug_menu_shortcuts")
        register_dialog = utilwidgets.ComboBoxDialog(parent, label_text, ["0", "1"], int(registers[current_flag]))
        if register_dialog.exec():
            # self.window() is needed to fix messagebox text color being red
            if guiutils.check_inferior_running(self.window()):
                return
            debugcore.set_register_flag(current_flag, register_dialog.get_values())
            self.set_value(debugcore.read_registers()[current_flag])

```

`GUI/Labels/RegisterLabel.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt6.QtWidgets import QLabel, QMenu, QApplication, QMessageBox
from PyQt6.QtGui import QCursor, QMouseEvent, QEnterEvent, QContextMenuEvent
from PyQt6.QtCore import Qt
from libpince import debugcore, typedefs, utils
from GUI.Utils import guiutils, utilwidgets
from tr.tr import TranslationConstants as tr


class QRegisterLabel(QLabel):
    def __init__(self, parent=None):
        super().__init__(parent)

    def set_value(self, value):
        new = self.objectName() + "=" + value
        old = self.text()
        if old != new:
            self.setStyleSheet("color: red")
        else:
            self.setStyleSheet("")
        self.setText(new)

    def enterEvent(self, event: QEnterEvent):
        self.setCursor(QCursor(Qt.CursorShape.PointingHandCursor))
        super().enterEvent(event)

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        if (
            event.button() != Qt.MouseButton.LeftButton
            or debugcore.currentpid == -1
            or debugcore.inferior_status == typedefs.INFERIOR_STATUS.RUNNING
        ):
            # self.window() is needed to fix messagebox text color being red
            QMessageBox.information(self.window(), tr.ERROR, tr.REQUIRE_PROCESS_STOP)
            return
        registers = debugcore.read_registers()
        current_register = self.objectName().lower()
        items = [(tr.ENTER_REGISTER_VALUE.format(self.objectName()), registers[current_register])]
        memory_view = guiutils.search_parents_by_function(self, "set_debug_menu_shortcuts")
        register_dialog = utilwidgets.InputDialog(memory_view, items)
        if register_dialog.exec():
            # self.window() is needed to fix messagebox text color being red
            if guiutils.check_inferior_running(self.window()):
                return
            debugcore.set_convenience_variable(current_register, register_dialog.get_values()[0])
            self.set_value(debugcore.read_registers()[current_register])

    def contextMenuEvent(self, event: QContextMenuEvent):
        menu = QMenu()
        copy = menu.addAction(tr.COPY)
        menu.addSeparator()
        show_in_hex_view = menu.addAction(tr.SHOW_HEXVIEW)
        show_in_disassembler = menu.addAction(tr.SHOW_DISASSEMBLER)
        font_size = self.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        memory_view = guiutils.search_parents_by_function(self, "set_debug_menu_shortcuts")
        if action == show_in_hex_view:
            address = self.text().split("=")[-1]
            address_int = utils.safe_str_to_int(address, 16)
            memory_view.hex_dump_address(address_int)
        elif action == show_in_disassembler:
            address = self.text().split("=")[-1]
            memory_view.disassemble_expression(address)
        elif action == copy:
            QApplication.clipboard().setText(self.text().split("=")[1])

```

`GUI/LoadingDialog.py`:

```py
# Form implementation generated from reading ui file 'LoadingDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(107, 71)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.label_Animated = QtWidgets.QLabel(parent=Dialog)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_Animated.sizePolicy().hasHeightForWidth())
        self.label_Animated.setSizePolicy(sizePolicy)
        self.label_Animated.setText("")
        self.label_Animated.setScaledContents(False)
        self.label_Animated.setObjectName("label_Animated")
        self.horizontalLayout.addWidget(self.label_Animated)
        self.label_StatusText = QtWidgets.QLabel(parent=Dialog)
        self.label_StatusText.setObjectName("label_StatusText")
        self.horizontalLayout.addWidget(self.label_StatusText)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.pushButton_Cancel = QtWidgets.QPushButton(parent=Dialog)
        self.pushButton_Cancel.setObjectName("pushButton_Cancel")
        self.gridLayout.addWidget(self.pushButton_Cancel, 1, 0, 1, 1)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        self.label_StatusText.setText(_translate("Dialog", "Processing"))
        self.pushButton_Cancel.setText(_translate("Dialog", "Cancel"))

```

`GUI/LoadingDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>107</width>
    <height>71</height>
   </rect>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QLabel" name="label_Animated">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string/>
       </property>
       <property name="scaledContents">
        <bool>false</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="label_StatusText">
       <property name="text">
        <string>Processing</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <widget class="QPushButton" name="pushButton_Cancel">
     <property name="text">
      <string>Cancel</string>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/LogFileWidget.py`:

```py
# Form implementation generated from reading ui file 'LogFileWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(582, 558)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label_FilePath = QtWidgets.QLabel(parent=Form)
        self.label_FilePath.setTextInteractionFlags(QtCore.Qt.TextInteractionFlag.LinksAccessibleByMouse|QtCore.Qt.TextInteractionFlag.TextSelectableByMouse)
        self.label_FilePath.setObjectName("label_FilePath")
        self.horizontalLayout.addWidget(self.label_FilePath)
        self.label_LoggingStatus = QtWidgets.QLabel(parent=Form)
        self.label_LoggingStatus.setObjectName("label_LoggingStatus")
        self.horizontalLayout.addWidget(self.label_LoggingStatus)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.textBrowser_LogContent = QtWidgets.QTextBrowser(parent=Form)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.textBrowser_LogContent.setFont(font)
        self.textBrowser_LogContent.setLineWrapMode(QtWidgets.QTextEdit.LineWrapMode.NoWrap)
        self.textBrowser_LogContent.setObjectName("textBrowser_LogContent")
        self.gridLayout.addWidget(self.textBrowser_LogContent, 1, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.label_FilePath.setText(_translate("Form", "TextLabel"))
        self.label_LoggingStatus.setText(_translate("Form", "TextLabel"))

```

`GUI/LogFileWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>582</width>
    <height>558</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label_FilePath">
       <property name="text">
        <string>TextLabel</string>
       </property>
       <property name="textInteractionFlags">
        <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="label_LoggingStatus">
       <property name="text">
        <string>TextLabel</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <widget class="QTextBrowser" name="textBrowser_LogContent">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="lineWrapMode">
      <enum>QTextEdit::NoWrap</enum>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/MainWindow.py`:

```py
# Form implementation generated from reading ui file 'MainWindow.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(678, 636)
        MainWindow.setWindowTitle("PINCE")
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setSizeConstraint(QtWidgets.QLayout.SizeConstraint.SetMinAndMaxSize)
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.pushButton_MemoryView = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_MemoryView.setEnabled(False)
        self.pushButton_MemoryView.setObjectName("pushButton_MemoryView")
        self.horizontalLayout_8.addWidget(self.pushButton_MemoryView)
        spacerItem = QtWidgets.QSpacerItem(120, 20, QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem)
        self.pushButton_CopyToAddressTable = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_CopyToAddressTable.setText("")
        self.pushButton_CopyToAddressTable.setObjectName("pushButton_CopyToAddressTable")
        self.horizontalLayout_8.addWidget(self.pushButton_CopyToAddressTable)
        self.pushButton_CleanAddressTable = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_CleanAddressTable.setText("")
        self.pushButton_CleanAddressTable.setObjectName("pushButton_CleanAddressTable")
        self.horizontalLayout_8.addWidget(self.pushButton_CleanAddressTable)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem1)
        self.pushButton_RefreshAdressTable = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_RefreshAdressTable.setText("")
        self.pushButton_RefreshAdressTable.setObjectName("pushButton_RefreshAdressTable")
        self.horizontalLayout_8.addWidget(self.pushButton_RefreshAdressTable)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem2)
        self.pushButton_AddAddressManually = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_AddAddressManually.setEnabled(False)
        self.pushButton_AddAddressManually.setObjectName("pushButton_AddAddressManually")
        self.horizontalLayout_8.addWidget(self.pushButton_AddAddressManually)
        self.gridLayout.addLayout(self.horizontalLayout_8, 2, 0, 1, 1)
        self.treeWidget_AddressTable = QAddressTree(parent=self.centralwidget)
        self.treeWidget_AddressTable.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.treeWidget_AddressTable.setDragDropMode(QtWidgets.QAbstractItemView.DragDropMode.DragDrop)
        self.treeWidget_AddressTable.setDefaultDropAction(QtCore.Qt.DropAction.MoveAction)
        self.treeWidget_AddressTable.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.ExtendedSelection)
        self.treeWidget_AddressTable.setIndentation(12)
        self.treeWidget_AddressTable.setExpandsOnDoubleClick(False)
        self.treeWidget_AddressTable.setObjectName("treeWidget_AddressTable")
        self.gridLayout.addWidget(self.treeWidget_AddressTable, 3, 0, 1, 1)
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.label_MatchCount = QtWidgets.QLabel(parent=self.centralwidget)
        self.label_MatchCount.setObjectName("label_MatchCount")
        self.verticalLayout_6.addWidget(self.label_MatchCount)
        self.tableWidget_valuesearchtable = QtWidgets.QTableWidget(parent=self.centralwidget)
        self.tableWidget_valuesearchtable.setEnabled(True)
        self.tableWidget_valuesearchtable.setAutoFillBackground(False)
        self.tableWidget_valuesearchtable.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.tableWidget_valuesearchtable.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_valuesearchtable.setAlternatingRowColors(True)
        self.tableWidget_valuesearchtable.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_valuesearchtable.setShowGrid(False)
        self.tableWidget_valuesearchtable.setWordWrap(False)
        self.tableWidget_valuesearchtable.setObjectName("tableWidget_valuesearchtable")
        self.tableWidget_valuesearchtable.setColumnCount(3)
        self.tableWidget_valuesearchtable.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_valuesearchtable.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_valuesearchtable.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_valuesearchtable.setHorizontalHeaderItem(2, item)
        self.tableWidget_valuesearchtable.horizontalHeader().setSortIndicatorShown(True)
        self.tableWidget_valuesearchtable.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_valuesearchtable.verticalHeader().setVisible(False)
        self.tableWidget_valuesearchtable.verticalHeader().setDefaultSectionSize(23)
        self.tableWidget_valuesearchtable.verticalHeader().setMinimumSectionSize(20)
        self.verticalLayout_6.addWidget(self.tableWidget_valuesearchtable)
        self.horizontalLayout_9.addLayout(self.verticalLayout_6)
        self.QWidget_Toolbox = QtWidgets.QWidget(parent=self.centralwidget)
        self.QWidget_Toolbox.setEnabled(False)
        self.QWidget_Toolbox.setObjectName("QWidget_Toolbox")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.QWidget_Toolbox)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.pushButton_NewFirstScan = QtWidgets.QPushButton(parent=self.QWidget_Toolbox)
        self.pushButton_NewFirstScan.setObjectName("pushButton_NewFirstScan")
        self.horizontalLayout_6.addWidget(self.pushButton_NewFirstScan)
        self.pushButton_NextScan = QtWidgets.QPushButton(parent=self.QWidget_Toolbox)
        self.pushButton_NextScan.setObjectName("pushButton_NextScan")
        self.horizontalLayout_6.addWidget(self.pushButton_NextScan)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_6.addItem(spacerItem3)
        self.pushButton_UndoScan = QtWidgets.QPushButton(parent=self.QWidget_Toolbox)
        self.pushButton_UndoScan.setObjectName("pushButton_UndoScan")
        self.horizontalLayout_6.addWidget(self.pushButton_UndoScan)
        self.verticalLayout_5.addLayout(self.horizontalLayout_6)
        self.widget_Scan = QtWidgets.QWidget(parent=self.QWidget_Toolbox)
        self.widget_Scan.setObjectName("widget_Scan")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout(self.widget_Scan)
        self.horizontalLayout_7.setContentsMargins(0, -1, 0, 0)
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.checkBox_Hex = QtWidgets.QCheckBox(parent=self.widget_Scan)
        self.checkBox_Hex.setObjectName("checkBox_Hex")
        self.horizontalLayout_7.addWidget(self.checkBox_Hex)
        self.lineEdit_Scan = QtWidgets.QLineEdit(parent=self.widget_Scan)
        self.lineEdit_Scan.setObjectName("lineEdit_Scan")
        self.horizontalLayout_7.addWidget(self.lineEdit_Scan)
        self.label_Between = QtWidgets.QLabel(parent=self.widget_Scan)
        self.label_Between.setText("<->")
        self.label_Between.setObjectName("label_Between")
        self.horizontalLayout_7.addWidget(self.label_Between)
        self.lineEdit_Scan2 = QtWidgets.QLineEdit(parent=self.widget_Scan)
        self.lineEdit_Scan2.setObjectName("lineEdit_Scan2")
        self.horizontalLayout_7.addWidget(self.lineEdit_Scan2)
        self.verticalLayout_5.addWidget(self.widget_Scan)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.widget = QtWidgets.QWidget(parent=self.QWidget_Toolbox)
        self.widget.setObjectName("widget")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.widget)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label = QtWidgets.QLabel(parent=self.widget)
        self.label.setObjectName("label")
        self.horizontalLayout_2.addWidget(self.label)
        self.comboBox_ScanType = QtWidgets.QComboBox(parent=self.widget)
        self.comboBox_ScanType.setObjectName("comboBox_ScanType")
        self.horizontalLayout_2.addWidget(self.comboBox_ScanType)
        self.verticalLayout_4.addLayout(self.horizontalLayout_2)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label_2 = QtWidgets.QLabel(parent=self.widget)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.comboBox_ValueType = QtWidgets.QComboBox(parent=self.widget)
        self.comboBox_ValueType.setObjectName("comboBox_ValueType")
        self.horizontalLayout.addWidget(self.comboBox_ValueType)
        self.verticalLayout_4.addLayout(self.horizontalLayout)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.label_ScanScope = QtWidgets.QLabel(parent=self.widget)
        self.label_ScanScope.setObjectName("label_ScanScope")
        self.horizontalLayout_10.addWidget(self.label_ScanScope)
        self.comboBox_ScanScope = QtWidgets.QComboBox(parent=self.widget)
        self.comboBox_ScanScope.setObjectName("comboBox_ScanScope")
        self.horizontalLayout_10.addWidget(self.comboBox_ScanScope)
        self.verticalLayout_4.addLayout(self.horizontalLayout_10)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_3 = QtWidgets.QLabel(parent=self.widget)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout_3.addWidget(self.label_3)
        self.comboBox_Endianness = QtWidgets.QComboBox(parent=self.widget)
        self.comboBox_Endianness.setObjectName("comboBox_Endianness")
        self.horizontalLayout_3.addWidget(self.comboBox_Endianness)
        self.verticalLayout_4.addLayout(self.horizontalLayout_3)
        self.pushButton_ScanRegions = QtWidgets.QPushButton(parent=self.widget)
        self.pushButton_ScanRegions.setObjectName("pushButton_ScanRegions")
        self.verticalLayout_4.addWidget(self.pushButton_ScanRegions)
        spacerItem4 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_4.addItem(spacerItem4)
        self.horizontalLayout_4.addWidget(self.widget)
        self.widget_2 = QtWidgets.QWidget(parent=self.QWidget_Toolbox)
        self.widget_2.setObjectName("widget_2")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.widget_2)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setSpacing(0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        spacerItem5 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_3.addItem(spacerItem5)
        self.verticalLayout.addLayout(self.verticalLayout_3)
        self.horizontalLayout_4.addWidget(self.widget_2)
        self.verticalLayout_5.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_9.addWidget(self.QWidget_Toolbox)
        self.gridLayout.addLayout(self.horizontalLayout_9, 1, 0, 1, 1)
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_11.addItem(spacerItem6)
        self.pushButton_Notes = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_Notes.setObjectName("pushButton_Notes")
        self.horizontalLayout_11.addWidget(self.pushButton_Notes)
        self.gridLayout.addLayout(self.horizontalLayout_11, 4, 0, 1, 1)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setSizeConstraint(QtWidgets.QLayout.SizeConstraint.SetFixedSize)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.pushButton_AttachProcess = QtWidgets.QPushButton(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButton_AttachProcess.sizePolicy().hasHeightForWidth())
        self.pushButton_AttachProcess.setSizePolicy(sizePolicy)
        self.pushButton_AttachProcess.setText("")
        self.pushButton_AttachProcess.setObjectName("pushButton_AttachProcess")
        self.horizontalLayout_5.addWidget(self.pushButton_AttachProcess)
        self.pushButton_Open = QtWidgets.QPushButton(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButton_Open.sizePolicy().hasHeightForWidth())
        self.pushButton_Open.setSizePolicy(sizePolicy)
        self.pushButton_Open.setText("")
        self.pushButton_Open.setObjectName("pushButton_Open")
        self.horizontalLayout_5.addWidget(self.pushButton_Open)
        self.pushButton_Save = QtWidgets.QPushButton(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButton_Save.sizePolicy().hasHeightForWidth())
        self.pushButton_Save.setSizePolicy(sizePolicy)
        self.pushButton_Save.setText("")
        self.pushButton_Save.setObjectName("pushButton_Save")
        self.horizontalLayout_5.addWidget(self.pushButton_Save)
        self.pushButton_Wiki = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_Wiki.setText("")
        self.pushButton_Wiki.setObjectName("pushButton_Wiki")
        self.horizontalLayout_5.addWidget(self.pushButton_Wiki)
        self.pushButton_About = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_About.setText("")
        self.pushButton_About.setObjectName("pushButton_About")
        self.horizontalLayout_5.addWidget(self.pushButton_About)
        self.label_SelectedProcess = QtWidgets.QLabel(parent=self.centralwidget)
        self.label_SelectedProcess.setObjectName("label_SelectedProcess")
        self.horizontalLayout_5.addWidget(self.label_SelectedProcess)
        self.label_InferiorStatus = QtWidgets.QLabel(parent=self.centralwidget)
        self.label_InferiorStatus.setText("")
        self.label_InferiorStatus.setObjectName("label_InferiorStatus")
        self.horizontalLayout_5.addWidget(self.label_InferiorStatus)
        self.progressBar = QtWidgets.QProgressBar(parent=self.centralwidget)
        self.progressBar.setProperty("value", 0)
        self.progressBar.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.progressBar.setObjectName("progressBar")
        self.horizontalLayout_5.addWidget(self.progressBar)
        self.pushButton_Console = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_Console.setText("")
        self.pushButton_Console.setObjectName("pushButton_Console")
        self.horizontalLayout_5.addWidget(self.pushButton_Console)
        self.pushButton_Settings = QtWidgets.QPushButton(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.pushButton_Settings.sizePolicy().hasHeightForWidth())
        self.pushButton_Settings.setSizePolicy(sizePolicy)
        self.pushButton_Settings.setText("")
        self.pushButton_Settings.setObjectName("pushButton_Settings")
        self.horizontalLayout_5.addWidget(self.pushButton_Settings)
        self.gridLayout.addLayout(self.horizontalLayout_5, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 678, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        self.pushButton_MemoryView.setText(_translate("MainWindow", "Memory View"))
        self.pushButton_CopyToAddressTable.setToolTip(_translate("MainWindow", "Copy selected items to the address table"))
        self.pushButton_CleanAddressTable.setToolTip(_translate("MainWindow", "Erase all the table contents"))
        self.pushButton_RefreshAdressTable.setToolTip(_translate("MainWindow", "Refresh the address table[R]"))
        self.pushButton_AddAddressManually.setText(_translate("MainWindow", "Add Address Manually"))
        self.treeWidget_AddressTable.setSortingEnabled(True)
        self.treeWidget_AddressTable.headerItem().setText(0, _translate("MainWindow", "Freeze"))
        self.treeWidget_AddressTable.headerItem().setToolTip(0, _translate("MainWindow", "Freeze the value. Click just to the right of checkbox to cycle between freeze types:\n"
"- No arrow: Frozen at current value\n"
"- ▲: Allow increments only\n"
"- ▼: Allow decrements only"))
        self.treeWidget_AddressTable.headerItem().setText(1, _translate("MainWindow", "Description"))
        self.treeWidget_AddressTable.headerItem().setText(2, _translate("MainWindow", "Address"))
        self.treeWidget_AddressTable.headerItem().setText(3, _translate("MainWindow", "Type"))
        self.treeWidget_AddressTable.headerItem().setText(4, _translate("MainWindow", "Value"))
        self.label_MatchCount.setText(_translate("MainWindow", "Match count: 0"))
        self.tableWidget_valuesearchtable.setSortingEnabled(True)
        item = self.tableWidget_valuesearchtable.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "Address"))
        item = self.tableWidget_valuesearchtable.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Value"))
        item = self.tableWidget_valuesearchtable.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow", "Previous"))
        self.pushButton_NewFirstScan.setText(_translate("MainWindow", "First Scan"))
        self.pushButton_NextScan.setText(_translate("MainWindow", "Next Scan"))
        self.pushButton_UndoScan.setText(_translate("MainWindow", "Undo Scan"))
        self.checkBox_Hex.setText(_translate("MainWindow", "Hex"))
        self.label.setText(_translate("MainWindow", "Scan Type:"))
        self.label_2.setText(_translate("MainWindow", "Value Type:"))
        self.label_ScanScope.setText(_translate("MainWindow", "Scan Scope:"))
        self.label_3.setText(_translate("MainWindow", "Endianness:"))
        self.pushButton_ScanRegions.setText(_translate("MainWindow", "Manage Scan Regions"))
        self.pushButton_Notes.setToolTip(_translate("MainWindow", "Open session notes"))
        self.pushButton_Notes.setText(_translate("MainWindow", "Notes"))
        self.pushButton_AttachProcess.setToolTip(_translate("MainWindow", "Create or attach to a process"))
        self.pushButton_Open.setToolTip(_translate("MainWindow", "Open a cheat table"))
        self.pushButton_Save.setToolTip(_translate("MainWindow", "Save current table to a file"))
        self.pushButton_Wiki.setToolTip(_translate("MainWindow", "Wiki"))
        self.pushButton_About.setToolTip(_translate("MainWindow", "About"))
        self.label_SelectedProcess.setText(_translate("MainWindow", "No Process Selected"))
        self.pushButton_Console.setToolTip(_translate("MainWindow", "Open a gdb console"))
        self.pushButton_Settings.setToolTip(_translate("MainWindow", "Configure options"))
from GUI.TreeWidgets.AddressTree import QAddressTree

```

`GUI/MainWindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>678</width>
    <height>636</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string notr="true">PINCE</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QGridLayout" name="gridLayout">
    <item row="2" column="0">
     <layout class="QHBoxLayout" name="horizontalLayout_8">
      <property name="sizeConstraint">
       <enum>QLayout::SizeConstraint::SetMinAndMaxSize</enum>
      </property>
      <item>
       <widget class="QPushButton" name="pushButton_MemoryView">
        <property name="enabled">
         <bool>false</bool>
        </property>
        <property name="text">
         <string>Memory View</string>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_2">
        <property name="orientation">
         <enum>Qt::Orientation::Horizontal</enum>
        </property>
        <property name="sizeType">
         <enum>QSizePolicy::Policy::Fixed</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>120</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_CopyToAddressTable">
        <property name="toolTip">
         <string>Copy selected items to the address table</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_CleanAddressTable">
        <property name="toolTip">
         <string>Erase all the table contents</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_7">
        <property name="orientation">
         <enum>Qt::Orientation::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_RefreshAdressTable">
        <property name="toolTip">
         <string>Refresh the address table[R]</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_3">
        <property name="orientation">
         <enum>Qt::Orientation::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_AddAddressManually">
        <property name="enabled">
         <bool>false</bool>
        </property>
        <property name="text">
         <string>Add Address Manually</string>
        </property>
       </widget>
      </item>
     </layout>
    </item>
    <item row="3" column="0">
     <widget class="QAddressTree" name="treeWidget_AddressTable">
      <property name="editTriggers">
       <set>QAbstractItemView::EditTrigger::NoEditTriggers</set>
      </property>
      <property name="dragDropMode">
       <enum>QAbstractItemView::DragDropMode::DragDrop</enum>
      </property>
      <property name="defaultDropAction">
       <enum>Qt::DropAction::MoveAction</enum>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::SelectionMode::ExtendedSelection</enum>
      </property>
      <property name="indentation">
       <number>12</number>
      </property>
      <property name="sortingEnabled">
       <bool>true</bool>
      </property>
      <property name="expandsOnDoubleClick">
       <bool>false</bool>
      </property>
      <column>
       <property name="text">
        <string>Freeze</string>
       </property>
       <property name="toolTip">
        <string>Freeze the value. Click just to the right of checkbox to cycle between freeze types:
- No arrow: Frozen at current value
- ▲: Allow increments only
- ▼: Allow decrements only</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Description</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Address</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Type</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Value</string>
       </property>
      </column>
     </widget>
    </item>
    <item row="1" column="0">
     <layout class="QHBoxLayout" name="horizontalLayout_9">
      <item>
       <layout class="QVBoxLayout" name="verticalLayout_6">
        <item>
         <widget class="QLabel" name="label_MatchCount">
          <property name="text">
           <string>Match count: 0</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QTableWidget" name="tableWidget_valuesearchtable">
          <property name="enabled">
           <bool>true</bool>
          </property>
          <property name="autoFillBackground">
           <bool>false</bool>
          </property>
          <property name="horizontalScrollBarPolicy">
           <enum>Qt::ScrollBarPolicy::ScrollBarAlwaysOff</enum>
          </property>
          <property name="editTriggers">
           <set>QAbstractItemView::EditTrigger::NoEditTriggers</set>
          </property>
          <property name="alternatingRowColors">
           <bool>true</bool>
          </property>
          <property name="selectionBehavior">
           <enum>QAbstractItemView::SelectionBehavior::SelectRows</enum>
          </property>
          <property name="showGrid">
           <bool>false</bool>
          </property>
          <property name="sortingEnabled">
           <bool>true</bool>
          </property>
          <property name="wordWrap">
           <bool>false</bool>
          </property>
          <attribute name="horizontalHeaderShowSortIndicator" stdset="0">
           <bool>true</bool>
          </attribute>
          <attribute name="horizontalHeaderStretchLastSection">
           <bool>true</bool>
          </attribute>
          <attribute name="verticalHeaderVisible">
           <bool>false</bool>
          </attribute>
          <attribute name="verticalHeaderMinimumSectionSize">
           <number>20</number>
          </attribute>
          <attribute name="verticalHeaderDefaultSectionSize">
           <number>23</number>
          </attribute>
          <column>
           <property name="text">
            <string>Address</string>
           </property>
          </column>
          <column>
           <property name="text">
            <string>Value</string>
           </property>
          </column>
          <column>
           <property name="text">
            <string>Previous</string>
           </property>
          </column>
         </widget>
        </item>
       </layout>
      </item>
      <item>
       <widget class="QWidget" name="QWidget_Toolbox" native="true">
        <property name="enabled">
         <bool>false</bool>
        </property>
        <layout class="QVBoxLayout" name="verticalLayout_5">
         <item>
          <layout class="QHBoxLayout" name="horizontalLayout_6">
           <item>
            <widget class="QPushButton" name="pushButton_NewFirstScan">
             <property name="text">
              <string>First Scan</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QPushButton" name="pushButton_NextScan">
             <property name="text">
              <string>Next Scan</string>
             </property>
            </widget>
           </item>
           <item>
            <spacer name="horizontalSpacer">
             <property name="orientation">
              <enum>Qt::Orientation::Horizontal</enum>
             </property>
             <property name="sizeHint" stdset="0">
              <size>
               <width>40</width>
               <height>20</height>
              </size>
             </property>
            </spacer>
           </item>
           <item>
            <widget class="QPushButton" name="pushButton_UndoScan">
             <property name="text">
              <string>Undo Scan</string>
             </property>
            </widget>
           </item>
          </layout>
         </item>
         <item>
          <widget class="QWidget" name="widget_Scan" native="true">
           <layout class="QHBoxLayout" name="horizontalLayout_7">
            <property name="leftMargin">
             <number>0</number>
            </property>
            <property name="rightMargin">
             <number>0</number>
            </property>
            <property name="bottomMargin">
             <number>0</number>
            </property>
            <item>
             <widget class="QCheckBox" name="checkBox_Hex">
              <property name="text">
               <string>Hex</string>
              </property>
             </widget>
            </item>
            <item>
             <widget class="QLineEdit" name="lineEdit_Scan"/>
            </item>
            <item>
             <widget class="QLabel" name="label_Between">
              <property name="text">
               <string notr="true">&lt;-&gt;</string>
              </property>
             </widget>
            </item>
            <item>
             <widget class="QLineEdit" name="lineEdit_Scan2"/>
            </item>
           </layout>
          </widget>
         </item>
         <item>
          <layout class="QHBoxLayout" name="horizontalLayout_4">
           <item>
            <widget class="QWidget" name="widget" native="true">
             <layout class="QVBoxLayout" name="verticalLayout_4">
              <item>
               <layout class="QHBoxLayout" name="horizontalLayout_2">
                <item>
                 <widget class="QLabel" name="label">
                  <property name="text">
                   <string>Scan Type:</string>
                  </property>
                 </widget>
                </item>
                <item>
                 <widget class="QComboBox" name="comboBox_ScanType"/>
                </item>
               </layout>
              </item>
              <item>
               <layout class="QHBoxLayout" name="horizontalLayout">
                <item>
                 <widget class="QLabel" name="label_2">
                  <property name="text">
                   <string>Value Type:</string>
                  </property>
                 </widget>
                </item>
                <item>
                 <widget class="QComboBox" name="comboBox_ValueType"/>
                </item>
               </layout>
              </item>
              <item>
               <layout class="QHBoxLayout" name="horizontalLayout_10">
                <item>
                 <widget class="QLabel" name="label_ScanScope">
                  <property name="text">
                   <string>Scan Scope:</string>
                  </property>
                 </widget>
                </item>
                <item>
                 <widget class="QComboBox" name="comboBox_ScanScope"/>
                </item>
               </layout>
              </item>
              <item>
               <layout class="QHBoxLayout" name="horizontalLayout_3">
                <item>
                 <widget class="QLabel" name="label_3">
                  <property name="text">
                   <string>Endianness:</string>
                  </property>
                 </widget>
                </item>
                <item>
                 <widget class="QComboBox" name="comboBox_Endianness"/>
                </item>
               </layout>
              </item>
              <item>
               <widget class="QPushButton" name="pushButton_ScanRegions">
                <property name="text">
                 <string>Manage Scan Regions</string>
                </property>
               </widget>
              </item>
              <item>
               <spacer name="verticalSpacer">
                <property name="orientation">
                 <enum>Qt::Orientation::Vertical</enum>
                </property>
                <property name="sizeHint" stdset="0">
                 <size>
                  <width>20</width>
                  <height>40</height>
                 </size>
                </property>
               </spacer>
              </item>
             </layout>
            </widget>
           </item>
           <item>
            <widget class="QWidget" name="widget_2" native="true">
             <layout class="QVBoxLayout" name="verticalLayout">
              <property name="spacing">
               <number>0</number>
              </property>
              <property name="leftMargin">
               <number>0</number>
              </property>
              <property name="topMargin">
               <number>0</number>
              </property>
              <property name="rightMargin">
               <number>0</number>
              </property>
              <property name="bottomMargin">
               <number>0</number>
              </property>
              <item>
               <layout class="QVBoxLayout" name="verticalLayout_3">
                <item>
                 <spacer name="verticalSpacer_2">
                  <property name="orientation">
                   <enum>Qt::Orientation::Vertical</enum>
                  </property>
                  <property name="sizeHint" stdset="0">
                   <size>
                    <width>20</width>
                    <height>40</height>
                   </size>
                  </property>
                 </spacer>
                </item>
               </layout>
              </item>
             </layout>
            </widget>
           </item>
          </layout>
         </item>
        </layout>
       </widget>
      </item>
     </layout>
    </item>
    <item row="4" column="0">
     <layout class="QHBoxLayout" name="horizontalLayout_11">
      <item>
       <spacer name="horizontalSpacer_4">
        <property name="orientation">
         <enum>Qt::Orientation::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Notes">
        <property name="toolTip">
         <string>Open session notes</string>
        </property>
        <property name="text">
         <string>Notes</string>
        </property>
       </widget>
      </item>
     </layout>
    </item>
    <item row="0" column="0">
     <layout class="QHBoxLayout" name="horizontalLayout_5">
      <property name="sizeConstraint">
       <enum>QLayout::SizeConstraint::SetFixedSize</enum>
      </property>
      <item>
       <widget class="QPushButton" name="pushButton_AttachProcess">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
        <property name="toolTip">
         <string>Create or attach to a process</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Open">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
        <property name="toolTip">
         <string>Open a cheat table</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Save">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
        <property name="toolTip">
         <string>Save current table to a file</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Wiki">
        <property name="toolTip">
         <string>Wiki</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_About">
        <property name="toolTip">
         <string>About</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QLabel" name="label_SelectedProcess">
        <property name="text">
         <string>No Process Selected</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QLabel" name="label_InferiorStatus">
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QProgressBar" name="progressBar">
        <property name="value">
         <number>0</number>
        </property>
        <property name="orientation">
         <enum>Qt::Orientation::Horizontal</enum>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Console">
        <property name="toolTip">
         <string>Open a gdb console</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Settings">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Minimum" vsizetype="Minimum">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
        <property name="toolTip">
         <string>Configure options</string>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
     </layout>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>678</width>
     <height>22</height>
    </rect>
   </property>
  </widget>
 </widget>
 <customwidgets>
  <customwidget>
   <class>QAddressTree</class>
   <extends>QTreeWidget</extends>
   <header location="global">GUI.TreeWidgets.AddressTree</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`GUI/ManualAddressDialogUtils/PointerChainOffset.py`:

```py
from PyQt6.QtWidgets import QWidget, QFrame, QLabel, QLineEdit, QPushButton, QHBoxLayout, QSizePolicy, QSpacerItem
from PyQt6.QtCore import Qt, pyqtSignal
from operator import add as opAdd, sub as opSub

from GUI.Utils import guiutils
from libpince import utils

# Only intended to be used by ManualAddressForm
class PointerChainOffset(QFrame):
    offset_changed_signal = pyqtSignal(name="offsetChanged")

    def __init__(self, offset_index: int, parent: QWidget | None = None):
        super().__init__(parent)
        self.offset_index = offset_index
        self.initUI()

    def initUI(self):
        offsetLayout = QHBoxLayout(self)
        offsetLayout.setContentsMargins(0, 3, 0, 3)
        self.setLayout(offsetLayout)
        buttonLeft = QPushButton("<", self)
        buttonLeft.setFixedWidth(20)
        offsetLayout.addWidget(buttonLeft)
        self.offsetText = QLineEdit(self)
        self.offsetText.setValidator(guiutils.validator_map["int_hex"])
        self.offsetText.setText(hex(0))
        self.offsetText.setFixedWidth(70)
        self.offsetText.textChanged.connect(self.offset_changed)
        offsetLayout.addWidget(self.offsetText)
        buttonRight = QPushButton(">", self)
        buttonRight.setFixedWidth(20)
        offsetLayout.addWidget(buttonRight)
        spacer = QSpacerItem(40, 20, QSizePolicy.Policy.Expanding)
        self.derefLabel = QLabel(self)
        self.derefLabel.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)
        self.derefLabel.setText(" -> <font color=red>??</font>")
        offsetLayout.addWidget(self.derefLabel)
        offsetLayout.addItem(spacer)
        buttonLeft.clicked.connect(lambda: self.on_offset_arrow_clicked(self.offsetText, opSub))
        buttonRight.clicked.connect(lambda: self.on_offset_arrow_clicked(self.offsetText, opAdd))

    def on_offset_arrow_clicked(self, offsetTextWidget, operator_func):
        offsetText = offsetTextWidget.text()
        try:
            offsetValue = int(offsetText, 16)
            # first parent is the widget_pointer, second parent is the ManualAddressDialog
            sizeVal = self.parent().parent().get_type_size() if hasattr(self.parent().parent(), "get_type_size") else 1
            offsetValue = operator_func(offsetValue, sizeVal)
        except ValueError:
            offsetValue = 0
        offsetTextWidget.setText(utils.upper_hex(hex(offsetValue)))

    def offset_changed(self):
        self.offset_changed_signal.emit()

    def update_deref_label(self, text: str):
        self.derefLabel.setText(text)

```

`GUI/MemoryRegionsWidget.py`:

```py
# Form implementation generated from reading ui file 'MemoryRegionsWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(684, 539)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_MemoryRegions = QtWidgets.QTableWidget(parent=Form)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_MemoryRegions.setFont(font)
        self.tableWidget_MemoryRegions.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_MemoryRegions.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_MemoryRegions.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_MemoryRegions.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollMode.ScrollPerPixel)
        self.tableWidget_MemoryRegions.setWordWrap(False)
        self.tableWidget_MemoryRegions.setObjectName("tableWidget_MemoryRegions")
        self.tableWidget_MemoryRegions.setColumnCount(4)
        self.tableWidget_MemoryRegions.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_MemoryRegions.setHorizontalHeaderItem(3, item)
        self.tableWidget_MemoryRegions.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_MemoryRegions.verticalHeader().setVisible(False)
        self.tableWidget_MemoryRegions.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_MemoryRegions.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_MemoryRegions, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Memory Regions"))
        self.tableWidget_MemoryRegions.setSortingEnabled(True)
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Regions"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Perms"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(2)
        item.setText(_translate("Form", "Offset"))
        item = self.tableWidget_MemoryRegions.horizontalHeaderItem(3)
        item.setText(_translate("Form", "Path"))

```

`GUI/MemoryRegionsWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>684</width>
    <height>539</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Memory Regions</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTableWidget" name="tableWidget_MemoryRegions">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="horizontalScrollMode">
      <enum>QAbstractItemView::ScrollPerPixel</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>Regions</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Perms</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Offset</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Path</string>
      </property>
     </column>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/MemoryViewerWindow.py`:

```py
# Form implementation generated from reading ui file 'MemoryViewerWindow.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_MainWindow_MemoryView(object):
    def setupUi(self, MainWindow_MemoryView):
        MainWindow_MemoryView.setObjectName("MainWindow_MemoryView")
        MainWindow_MemoryView.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow_MemoryView)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_5.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_5.setSpacing(0)
        self.gridLayout_5.setObjectName("gridLayout_5")
        self.splitter_MainMiddle = QtWidgets.QSplitter(parent=self.centralwidget)
        self.splitter_MainMiddle.setLineWidth(1)
        self.splitter_MainMiddle.setOrientation(QtCore.Qt.Orientation.Vertical)
        self.splitter_MainMiddle.setOpaqueResize(True)
        self.splitter_MainMiddle.setHandleWidth(10)
        self.splitter_MainMiddle.setChildrenCollapsible(True)
        self.splitter_MainMiddle.setObjectName("splitter_MainMiddle")
        self.splitter_Disassemble_Registers = QtWidgets.QSplitter(parent=self.splitter_MainMiddle)
        self.splitter_Disassemble_Registers.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.splitter_Disassemble_Registers.setHandleWidth(10)
        self.splitter_Disassemble_Registers.setObjectName("splitter_Disassemble_Registers")
        self.widget_Disassemble = QtWidgets.QWidget(parent=self.splitter_Disassemble_Registers)
        self.widget_Disassemble.setObjectName("widget_Disassemble")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.widget_Disassemble)
        self.gridLayout_2.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_2.setSpacing(0)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.tableWidget_Disassemble = QtWidgets.QTableWidget(parent=self.widget_Disassemble)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_Disassemble.setFont(font)
        self.tableWidget_Disassemble.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.tableWidget_Disassemble.setAutoScroll(False)
        self.tableWidget_Disassemble.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_Disassemble.setAlternatingRowColors(True)
        self.tableWidget_Disassemble.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_Disassemble.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_Disassemble.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollMode.ScrollPerPixel)
        self.tableWidget_Disassemble.setShowGrid(False)
        self.tableWidget_Disassemble.setWordWrap(False)
        self.tableWidget_Disassemble.setObjectName("tableWidget_Disassemble")
        self.tableWidget_Disassemble.setColumnCount(4)
        self.tableWidget_Disassemble.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Disassemble.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Disassemble.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Disassemble.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Disassemble.setHorizontalHeaderItem(3, item)
        self.tableWidget_Disassemble.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Disassemble.verticalHeader().setVisible(False)
        self.tableWidget_Disassemble.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Disassemble.verticalHeader().setMinimumSectionSize(16)
        self.tableWidget_Disassemble.verticalHeader().setStretchLastSection(False)
        self.gridLayout_2.addWidget(self.tableWidget_Disassemble, 0, 0, 1, 1)
        self.verticalScrollBar_Disassemble = QtWidgets.QScrollBar(parent=self.widget_Disassemble)
        self.verticalScrollBar_Disassemble.setOrientation(QtCore.Qt.Orientation.Vertical)
        self.verticalScrollBar_Disassemble.setObjectName("verticalScrollBar_Disassemble")
        self.gridLayout_2.addWidget(self.verticalScrollBar_Disassemble, 0, 1, 1, 1)
        self.widget_Registers = QtWidgets.QWidget(parent=self.splitter_Disassemble_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.widget_Registers.setFont(font)
        self.widget_Registers.setObjectName("widget_Registers")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.widget_Registers)
        self.gridLayout_4.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_4.setSpacing(0)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.scrollArea_Registers = QtWidgets.QScrollArea(parent=self.widget_Registers)
        self.scrollArea_Registers.setWidgetResizable(True)
        self.scrollArea_Registers.setObjectName("scrollArea_Registers")
        self.scrollAreaWidgetContents_Registers = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_Registers.setGeometry(QtCore.QRect(0, 0, 344, 343))
        self.scrollAreaWidgetContents_Registers.setObjectName("scrollAreaWidgetContents_Registers")
        self.gridLayout_8 = QtWidgets.QGridLayout(self.scrollAreaWidgetContents_Registers)
        self.gridLayout_8.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_8.setSpacing(0)
        self.gridLayout_8.setObjectName("gridLayout_8")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setSpacing(0)
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.verticalLayout_19 = QtWidgets.QVBoxLayout()
        self.verticalLayout_19.setSpacing(0)
        self.verticalLayout_19.setObjectName("verticalLayout_19")
        self.label_3 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_3.setFont(font)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_19.addWidget(self.label_3)
        self.line = QtWidgets.QFrame(parent=self.scrollAreaWidgetContents_Registers)
        self.line.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line.setObjectName("line")
        self.verticalLayout_19.addWidget(self.line)
        self.stackedWidget = QtWidgets.QStackedWidget(parent=self.scrollAreaWidgetContents_Registers)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.stackedWidget.sizePolicy().hasHeightForWidth())
        self.stackedWidget.setSizePolicy(sizePolicy)
        self.stackedWidget.setMinimumSize(QtCore.QSize(0, 145))
        self.stackedWidget.setMaximumSize(QtCore.QSize(16777215, 145))
        self.stackedWidget.setObjectName("stackedWidget")
        self.registers_64 = QtWidgets.QWidget()
        self.registers_64.setObjectName("registers_64")
        self.gridLayout_7 = QtWidgets.QGridLayout(self.registers_64)
        self.gridLayout_7.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_7.setSpacing(0)
        self.gridLayout_7.setObjectName("gridLayout_7")
        self.verticalLayout_17 = QtWidgets.QVBoxLayout()
        self.verticalLayout_17.setSpacing(0)
        self.verticalLayout_17.setObjectName("verticalLayout_17")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setSpacing(0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout_16 = QtWidgets.QVBoxLayout()
        self.verticalLayout_16.setSpacing(0)
        self.verticalLayout_16.setObjectName("verticalLayout_16")
        self.RAX = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.RAX.setFont(font)
        self.RAX.setText("RAX=")
        self.RAX.setObjectName("RAX")
        self.verticalLayout_16.addWidget(self.RAX)
        self.RBX = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.RBX.setFont(font)
        self.RBX.setText("RBX=")
        self.RBX.setObjectName("RBX")
        self.verticalLayout_16.addWidget(self.RBX)
        self.RCX = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.RCX.setFont(font)
        self.RCX.setText("RCX=")
        self.RCX.setObjectName("RCX")
        self.verticalLayout_16.addWidget(self.RCX)
        self.RDX = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.RDX.setFont(font)
        self.RDX.setText("RDX=")
        self.RDX.setObjectName("RDX")
        self.verticalLayout_16.addWidget(self.RDX)
        self.RSI = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.RSI.setFont(font)
        self.RSI.setText("RSI=")
        self.RSI.setObjectName("RSI")
        self.verticalLayout_16.addWidget(self.RSI)
        self.RDI = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.RDI.setFont(font)
        self.RDI.setText("RDI=")
        self.RDI.setObjectName("RDI")
        self.verticalLayout_16.addWidget(self.RDI)
        self.RBP = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.RBP.setFont(font)
        self.RBP.setText("RBP=")
        self.RBP.setObjectName("RBP")
        self.verticalLayout_16.addWidget(self.RBP)
        self.RSP = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.RSP.setFont(font)
        self.RSP.setText("RSP=")
        self.RSP.setObjectName("RSP")
        self.verticalLayout_16.addWidget(self.RSP)
        self.horizontalLayout.addLayout(self.verticalLayout_16)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setSpacing(0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.R8 = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.R8.setFont(font)
        self.R8.setText("R8=")
        self.R8.setObjectName("R8")
        self.verticalLayout_3.addWidget(self.R8)
        self.R9 = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.R9.setFont(font)
        self.R9.setText("R9=")
        self.R9.setObjectName("R9")
        self.verticalLayout_3.addWidget(self.R9)
        self.R10 = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.R10.setFont(font)
        self.R10.setText("R10=")
        self.R10.setObjectName("R10")
        self.verticalLayout_3.addWidget(self.R10)
        self.R11 = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.R11.setFont(font)
        self.R11.setText("R11=")
        self.R11.setObjectName("R11")
        self.verticalLayout_3.addWidget(self.R11)
        self.R12 = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.R12.setFont(font)
        self.R12.setText("R12=")
        self.R12.setObjectName("R12")
        self.verticalLayout_3.addWidget(self.R12)
        self.R13 = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.R13.setFont(font)
        self.R13.setText("R13=")
        self.R13.setObjectName("R13")
        self.verticalLayout_3.addWidget(self.R13)
        self.R14 = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.R14.setFont(font)
        self.R14.setText("R14=")
        self.R14.setObjectName("R14")
        self.verticalLayout_3.addWidget(self.R14)
        self.R15 = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.R15.setFont(font)
        self.R15.setText("R15=")
        self.R15.setObjectName("R15")
        self.verticalLayout_3.addWidget(self.R15)
        self.horizontalLayout.addLayout(self.verticalLayout_3)
        self.verticalLayout_17.addLayout(self.horizontalLayout)
        self.horizontalLayout_18 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_18.setSpacing(0)
        self.horizontalLayout_18.setObjectName("horizontalLayout_18")
        self.RIP = QRegisterLabel(parent=self.registers_64)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.RIP.setFont(font)
        self.RIP.setText("RIP=")
        self.RIP.setObjectName("RIP")
        self.horizontalLayout_18.addWidget(self.RIP)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_18.addItem(spacerItem1)
        self.verticalLayout_17.addLayout(self.horizontalLayout_18)
        spacerItem2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_17.addItem(spacerItem2)
        self.gridLayout_7.addLayout(self.verticalLayout_17, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.registers_64)
        self.registers_32 = QtWidgets.QWidget()
        self.registers_32.setObjectName("registers_32")
        self.gridLayout_6 = QtWidgets.QGridLayout(self.registers_32)
        self.gridLayout_6.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_6.setSpacing(0)
        self.gridLayout_6.setObjectName("gridLayout_6")
        self.verticalLayout_14 = QtWidgets.QVBoxLayout()
        self.verticalLayout_14.setSpacing(0)
        self.verticalLayout_14.setObjectName("verticalLayout_14")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setSpacing(0)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setSpacing(0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.EAX = QRegisterLabel(parent=self.registers_32)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.EAX.setFont(font)
        self.EAX.setText("EAX=")
        self.EAX.setObjectName("EAX")
        self.verticalLayout_2.addWidget(self.EAX)
        self.EBX = QRegisterLabel(parent=self.registers_32)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.EBX.setFont(font)
        self.EBX.setText("EBX=")
        self.EBX.setObjectName("EBX")
        self.verticalLayout_2.addWidget(self.EBX)
        self.ECX = QRegisterLabel(parent=self.registers_32)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.ECX.setFont(font)
        self.ECX.setText("ECX=")
        self.ECX.setObjectName("ECX")
        self.verticalLayout_2.addWidget(self.ECX)
        self.EDX = QRegisterLabel(parent=self.registers_32)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.EDX.setFont(font)
        self.EDX.setText("EDX=")
        self.EDX.setObjectName("EDX")
        self.verticalLayout_2.addWidget(self.EDX)
        self.ESI = QRegisterLabel(parent=self.registers_32)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.ESI.setFont(font)
        self.ESI.setText("ESI=")
        self.ESI.setObjectName("ESI")
        self.verticalLayout_2.addWidget(self.ESI)
        self.EDI = QRegisterLabel(parent=self.registers_32)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.EDI.setFont(font)
        self.EDI.setText("EDI=")
        self.EDI.setObjectName("EDI")
        self.verticalLayout_2.addWidget(self.EDI)
        self.EBP = QRegisterLabel(parent=self.registers_32)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.EBP.setFont(font)
        self.EBP.setText("EBP=")
        self.EBP.setObjectName("EBP")
        self.verticalLayout_2.addWidget(self.EBP)
        self.ESP = QRegisterLabel(parent=self.registers_32)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.ESP.setFont(font)
        self.ESP.setText("ESP=")
        self.ESP.setObjectName("ESP")
        self.verticalLayout_2.addWidget(self.ESP)
        self.EIP = QRegisterLabel(parent=self.registers_32)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.EIP.setFont(font)
        self.EIP.setText("EIP=")
        self.EIP.setObjectName("EIP")
        self.verticalLayout_2.addWidget(self.EIP)
        self.horizontalLayout_3.addLayout(self.verticalLayout_2)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem3)
        self.verticalLayout_14.addLayout(self.horizontalLayout_3)
        self.gridLayout_6.addLayout(self.verticalLayout_14, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.registers_32)
        self.verticalLayout_19.addWidget(self.stackedWidget)
        self.label_29 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_29.setFont(font)
        self.label_29.setObjectName("label_29")
        self.verticalLayout_19.addWidget(self.label_29)
        self.line_2 = QtWidgets.QFrame(parent=self.scrollAreaWidgetContents_Registers)
        self.line_2.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_2.setObjectName("line_2")
        self.verticalLayout_19.addWidget(self.line_2)
        self.horizontalLayout_21 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_21.setSpacing(0)
        self.horizontalLayout_21.setObjectName("horizontalLayout_21")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout()
        self.verticalLayout_5.setSpacing(0)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.label_31 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_31.setFont(font)
        self.label_31.setText("CF")
        self.label_31.setObjectName("label_31")
        self.verticalLayout_5.addWidget(self.label_31)
        self.CF = QFlagRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.CF.setFont(font)
        self.CF.setText("0")
        self.CF.setObjectName("CF")
        self.verticalLayout_5.addWidget(self.CF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_5)
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setSpacing(0)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.label_35 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_35.setFont(font)
        self.label_35.setText("PF")
        self.label_35.setObjectName("label_35")
        self.verticalLayout_6.addWidget(self.label_35)
        self.PF = QFlagRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.PF.setFont(font)
        self.PF.setText("0")
        self.PF.setObjectName("PF")
        self.verticalLayout_6.addWidget(self.PF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_6)
        self.verticalLayout_7 = QtWidgets.QVBoxLayout()
        self.verticalLayout_7.setSpacing(0)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.label_37 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_37.setFont(font)
        self.label_37.setText("AF")
        self.label_37.setObjectName("label_37")
        self.verticalLayout_7.addWidget(self.label_37)
        self.AF = QFlagRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.AF.setFont(font)
        self.AF.setText("0")
        self.AF.setObjectName("AF")
        self.verticalLayout_7.addWidget(self.AF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_7)
        self.verticalLayout_8 = QtWidgets.QVBoxLayout()
        self.verticalLayout_8.setSpacing(0)
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.label_39 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_39.setFont(font)
        self.label_39.setText("ZF")
        self.label_39.setObjectName("label_39")
        self.verticalLayout_8.addWidget(self.label_39)
        self.ZF = QFlagRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.ZF.setFont(font)
        self.ZF.setText("0")
        self.ZF.setObjectName("ZF")
        self.verticalLayout_8.addWidget(self.ZF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_8)
        self.verticalLayout_9 = QtWidgets.QVBoxLayout()
        self.verticalLayout_9.setSpacing(0)
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.label_41 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_41.setFont(font)
        self.label_41.setText("SF")
        self.label_41.setObjectName("label_41")
        self.verticalLayout_9.addWidget(self.label_41)
        self.SF = QFlagRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.SF.setFont(font)
        self.SF.setText("0")
        self.SF.setObjectName("SF")
        self.verticalLayout_9.addWidget(self.SF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_9)
        self.verticalLayout_10 = QtWidgets.QVBoxLayout()
        self.verticalLayout_10.setSpacing(0)
        self.verticalLayout_10.setObjectName("verticalLayout_10")
        self.label_43 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_43.setFont(font)
        self.label_43.setText("TF")
        self.label_43.setObjectName("label_43")
        self.verticalLayout_10.addWidget(self.label_43)
        self.TF = QFlagRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.TF.setFont(font)
        self.TF.setText("0")
        self.TF.setObjectName("TF")
        self.verticalLayout_10.addWidget(self.TF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_10)
        self.verticalLayout_11 = QtWidgets.QVBoxLayout()
        self.verticalLayout_11.setSpacing(0)
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.label_45 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_45.setFont(font)
        self.label_45.setText("IF")
        self.label_45.setObjectName("label_45")
        self.verticalLayout_11.addWidget(self.label_45)
        self.IF = QFlagRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.IF.setFont(font)
        self.IF.setText("0")
        self.IF.setObjectName("IF")
        self.verticalLayout_11.addWidget(self.IF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_11)
        self.verticalLayout_12 = QtWidgets.QVBoxLayout()
        self.verticalLayout_12.setSpacing(0)
        self.verticalLayout_12.setObjectName("verticalLayout_12")
        self.label_47 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_47.setFont(font)
        self.label_47.setText("DF")
        self.label_47.setObjectName("label_47")
        self.verticalLayout_12.addWidget(self.label_47)
        self.DF = QFlagRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.DF.setFont(font)
        self.DF.setText("0")
        self.DF.setObjectName("DF")
        self.verticalLayout_12.addWidget(self.DF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_12)
        self.verticalLayout_13 = QtWidgets.QVBoxLayout()
        self.verticalLayout_13.setSpacing(0)
        self.verticalLayout_13.setObjectName("verticalLayout_13")
        self.label_49 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_49.setFont(font)
        self.label_49.setText("OF")
        self.label_49.setObjectName("label_49")
        self.verticalLayout_13.addWidget(self.label_49)
        self.OF = QFlagRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.OF.setFont(font)
        self.OF.setText("0")
        self.OF.setObjectName("OF")
        self.verticalLayout_13.addWidget(self.OF)
        self.horizontalLayout_21.addLayout(self.verticalLayout_13)
        self.verticalLayout_19.addLayout(self.horizontalLayout_21)
        spacerItem4 = QtWidgets.QSpacerItem(20, 15, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Fixed)
        self.verticalLayout_19.addItem(spacerItem4)
        self.label_30 = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.label_30.setFont(font)
        self.label_30.setObjectName("label_30")
        self.verticalLayout_19.addWidget(self.label_30)
        self.line_3 = QtWidgets.QFrame(parent=self.scrollAreaWidgetContents_Registers)
        self.line_3.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_3.setObjectName("line_3")
        self.verticalLayout_19.addWidget(self.line_3)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setSpacing(0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setSpacing(0)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.CS = QRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.CS.setFont(font)
        self.CS.setText("CS=")
        self.CS.setObjectName("CS")
        self.verticalLayout_4.addWidget(self.CS)
        self.ES = QRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.ES.setFont(font)
        self.ES.setText("ES=")
        self.ES.setObjectName("ES")
        self.verticalLayout_4.addWidget(self.ES)
        self.horizontalLayout_2.addLayout(self.verticalLayout_4)
        spacerItem5 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem5)
        self.verticalLayout_15 = QtWidgets.QVBoxLayout()
        self.verticalLayout_15.setSpacing(0)
        self.verticalLayout_15.setObjectName("verticalLayout_15")
        self.SS = QRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.SS.setFont(font)
        self.SS.setText("SS=")
        self.SS.setObjectName("SS")
        self.verticalLayout_15.addWidget(self.SS)
        self.GS = QRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.GS.setFont(font)
        self.GS.setText("GS=")
        self.GS.setObjectName("GS")
        self.verticalLayout_15.addWidget(self.GS)
        self.horizontalLayout_2.addLayout(self.verticalLayout_15)
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem6)
        self.verticalLayout_18 = QtWidgets.QVBoxLayout()
        self.verticalLayout_18.setSpacing(0)
        self.verticalLayout_18.setObjectName("verticalLayout_18")
        self.DS = QRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.DS.setFont(font)
        self.DS.setText("DS=")
        self.DS.setObjectName("DS")
        self.verticalLayout_18.addWidget(self.DS)
        self.FS = QRegisterLabel(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.FS.setFont(font)
        self.FS.setText("FS=")
        self.FS.setObjectName("FS")
        self.verticalLayout_18.addWidget(self.FS)
        self.horizontalLayout_2.addLayout(self.verticalLayout_18)
        self.verticalLayout_19.addLayout(self.horizontalLayout_2)
        self.pushButton_ShowFloatRegisters = QtWidgets.QPushButton(parent=self.scrollAreaWidgetContents_Registers)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.pushButton_ShowFloatRegisters.setFont(font)
        self.pushButton_ShowFloatRegisters.setObjectName("pushButton_ShowFloatRegisters")
        self.verticalLayout_19.addWidget(self.pushButton_ShowFloatRegisters)
        spacerItem7 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_19.addItem(spacerItem7)
        self.horizontalLayout_4.addLayout(self.verticalLayout_19)
        spacerItem8 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem8)
        self.gridLayout_8.addLayout(self.horizontalLayout_4, 0, 0, 1, 1)
        self.scrollArea_Registers.setWidget(self.scrollAreaWidgetContents_Registers)
        self.gridLayout_4.addWidget(self.scrollArea_Registers, 0, 0, 1, 1)
        self.splitter_HexView_StackView = QtWidgets.QSplitter(parent=self.splitter_MainMiddle)
        self.splitter_HexView_StackView.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.splitter_HexView_StackView.setHandleWidth(10)
        self.splitter_HexView_StackView.setObjectName("splitter_HexView_StackView")
        self.widget_HexView = QtWidgets.QWidget(parent=self.splitter_HexView_StackView)
        self.widget_HexView.setObjectName("widget_HexView")
        self.gridLayout = QtWidgets.QGridLayout(self.widget_HexView)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setHorizontalSpacing(0)
        self.gridLayout.setVerticalSpacing(4)
        self.gridLayout.setObjectName("gridLayout")
        self.scrollArea_Hex = QtWidgets.QScrollArea(parent=self.widget_HexView)
        self.scrollArea_Hex.setWidgetResizable(True)
        self.scrollArea_Hex.setObjectName("scrollArea_Hex")
        self.scrollAreaWidgetContents_2 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_2.setGeometry(QtCore.QRect(0, 0, 492, 197))
        self.scrollAreaWidgetContents_2.setObjectName("scrollAreaWidgetContents_2")
        self.gridLayout_11 = QtWidgets.QGridLayout(self.scrollAreaWidgetContents_2)
        self.gridLayout_11.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_11.setSpacing(0)
        self.gridLayout_11.setObjectName("gridLayout_11")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setSpacing(0)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.tableWidget_HexView_Address = QtWidgets.QTableWidget(parent=self.scrollAreaWidgetContents_2)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_HexView_Address.setFont(font)
        self.tableWidget_HexView_Address.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_HexView_Address.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_HexView_Address.setShowGrid(False)
        self.tableWidget_HexView_Address.setWordWrap(False)
        self.tableWidget_HexView_Address.setObjectName("tableWidget_HexView_Address")
        self.tableWidget_HexView_Address.setColumnCount(1)
        self.tableWidget_HexView_Address.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_HexView_Address.setHorizontalHeaderItem(0, item)
        self.tableWidget_HexView_Address.horizontalHeader().setVisible(False)
        self.tableWidget_HexView_Address.verticalHeader().setVisible(False)
        self.horizontalLayout_5.addWidget(self.tableWidget_HexView_Address)
        self.line_5 = QtWidgets.QFrame(parent=self.scrollAreaWidgetContents_2)
        self.line_5.setFrameShape(QtWidgets.QFrame.Shape.VLine)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_5.setObjectName("line_5")
        self.horizontalLayout_5.addWidget(self.line_5)
        self.tableView_HexView_Hex = QHexView(parent=self.scrollAreaWidgetContents_2)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableView_HexView_Hex.setFont(font)
        self.tableView_HexView_Hex.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.SizeAdjustPolicy.AdjustToContents)
        self.tableView_HexView_Hex.setObjectName("tableView_HexView_Hex")
        self.horizontalLayout_5.addWidget(self.tableView_HexView_Hex)
        self.line_4 = QtWidgets.QFrame(parent=self.scrollAreaWidgetContents_2)
        self.line_4.setFrameShape(QtWidgets.QFrame.Shape.VLine)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_4.setObjectName("line_4")
        self.horizontalLayout_5.addWidget(self.line_4)
        self.tableView_HexView_Ascii = QAsciiView(parent=self.scrollAreaWidgetContents_2)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableView_HexView_Ascii.setFont(font)
        self.tableView_HexView_Ascii.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.SizeAdjustPolicy.AdjustToContents)
        self.tableView_HexView_Ascii.setObjectName("tableView_HexView_Ascii")
        self.horizontalLayout_5.addWidget(self.tableView_HexView_Ascii)
        spacerItem9 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_5.addItem(spacerItem9)
        self.gridLayout_11.addLayout(self.horizontalLayout_5, 2, 0, 1, 1)
        self.label_HexView_Information = QtWidgets.QLabel(parent=self.scrollAreaWidgetContents_2)
        self.label_HexView_Information.setText("")
        self.label_HexView_Information.setObjectName("label_HexView_Information")
        self.gridLayout_11.addWidget(self.label_HexView_Information, 0, 0, 1, 1)
        self.line_6 = QtWidgets.QFrame(parent=self.scrollAreaWidgetContents_2)
        self.line_6.setFrameShape(QtWidgets.QFrame.Shape.HLine)
        self.line_6.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        self.line_6.setObjectName("line_6")
        self.gridLayout_11.addWidget(self.line_6, 1, 0, 1, 1)
        self.label_HexView_Information.raise_()
        self.line_6.raise_()
        self.scrollArea_Hex.setWidget(self.scrollAreaWidgetContents_2)
        self.gridLayout.addWidget(self.scrollArea_Hex, 0, 0, 1, 1)
        self.verticalScrollBar_HexView = QtWidgets.QScrollBar(parent=self.widget_HexView)
        self.verticalScrollBar_HexView.setOrientation(QtCore.Qt.Orientation.Vertical)
        self.verticalScrollBar_HexView.setObjectName("verticalScrollBar_HexView")
        self.gridLayout.addWidget(self.verticalScrollBar_HexView, 0, 1, 1, 1)
        self.widget_StackView = QtWidgets.QWidget(parent=self.splitter_HexView_StackView)
        self.widget_StackView.setObjectName("widget_StackView")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.widget_StackView)
        self.gridLayout_3.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_3.setSpacing(0)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.stackedWidget_StackScreens = QtWidgets.QStackedWidget(parent=self.widget_StackView)
        self.stackedWidget_StackScreens.setObjectName("stackedWidget_StackScreens")
        self.StackTrace = QtWidgets.QWidget()
        self.StackTrace.setObjectName("StackTrace")
        self.gridLayout_9 = QtWidgets.QGridLayout(self.StackTrace)
        self.gridLayout_9.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_9.setSpacing(0)
        self.gridLayout_9.setObjectName("gridLayout_9")
        self.tableWidget_StackTrace = QtWidgets.QTableWidget(parent=self.StackTrace)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_StackTrace.setFont(font)
        self.tableWidget_StackTrace.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_StackTrace.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_StackTrace.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_StackTrace.setWordWrap(False)
        self.tableWidget_StackTrace.setObjectName("tableWidget_StackTrace")
        self.tableWidget_StackTrace.setColumnCount(2)
        self.tableWidget_StackTrace.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_StackTrace.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_StackTrace.setHorizontalHeaderItem(1, item)
        self.tableWidget_StackTrace.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_StackTrace.verticalHeader().setVisible(False)
        self.tableWidget_StackTrace.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_StackTrace.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout_9.addWidget(self.tableWidget_StackTrace, 0, 0, 1, 1)
        self.stackedWidget_StackScreens.addWidget(self.StackTrace)
        self.Stack = QtWidgets.QWidget()
        self.Stack.setObjectName("Stack")
        self.gridLayout_10 = QtWidgets.QGridLayout(self.Stack)
        self.gridLayout_10.setContentsMargins(0, 0, 0, 0)
        self.gridLayout_10.setSpacing(0)
        self.gridLayout_10.setObjectName("gridLayout_10")
        self.tableWidget_Stack = QtWidgets.QTableWidget(parent=self.Stack)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_Stack.setFont(font)
        self.tableWidget_Stack.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_Stack.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_Stack.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_Stack.setObjectName("tableWidget_Stack")
        self.tableWidget_Stack.setColumnCount(3)
        self.tableWidget_Stack.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Stack.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Stack.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Stack.setHorizontalHeaderItem(2, item)
        self.tableWidget_Stack.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Stack.verticalHeader().setVisible(False)
        self.tableWidget_Stack.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Stack.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout_10.addWidget(self.tableWidget_Stack, 0, 0, 1, 1)
        self.stackedWidget_StackScreens.addWidget(self.Stack)
        self.gridLayout_3.addWidget(self.stackedWidget_StackScreens, 0, 0, 1, 1)
        self.gridLayout_5.addWidget(self.splitter_MainMiddle, 0, 0, 1, 1)
        MainWindow_MemoryView.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=MainWindow_MemoryView)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 23))
        self.menubar.setObjectName("menubar")
        self.menuView = QtWidgets.QMenu(parent=self.menubar)
        self.menuView.setObjectName("menuView")
        self.menuDebug = QtWidgets.QMenu(parent=self.menubar)
        self.menuDebug.setObjectName("menuDebug")
        self.menuTools = QtWidgets.QMenu(parent=self.menubar)
        self.menuTools.setObjectName("menuTools")
        self.menuFile = QtWidgets.QMenu(parent=self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuHelp = QtWidgets.QMenu(parent=self.menubar)
        self.menuHelp.setObjectName("menuHelp")
        MainWindow_MemoryView.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow_MemoryView)
        self.statusbar.setObjectName("statusbar")
        MainWindow_MemoryView.setStatusBar(self.statusbar)
        self.actionBookmarks = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionBookmarks.setObjectName("actionBookmarks")
        self.actionStackTrace_Info = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionStackTrace_Info.setObjectName("actionStackTrace_Info")
        self.actionInject_so_file = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionInject_so_file.setObjectName("actionInject_so_file")
        self.actionRun = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionRun.setObjectName("actionRun")
        self.actionBreak = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionBreak.setObjectName("actionBreak")
        self.actionStep = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionStep.setObjectName("actionStep")
        self.actionStep_Over = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionStep_Over.setObjectName("actionStep_Over")
        self.actionExecute_Till_Return = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionExecute_Till_Return.setObjectName("actionExecute_Till_Return")
        self.actionToggle_Breakpoint = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionToggle_Breakpoint.setObjectName("actionToggle_Breakpoint")
        self.actionBreakpoints = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionBreakpoints.setObjectName("actionBreakpoints")
        self.actionFunctions = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionFunctions.setObjectName("actionFunctions")
        self.actionSet_Address = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionSet_Address.setObjectName("actionSet_Address")
        self.actionCall_Function = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionCall_Function.setObjectName("actionCall_Function")
        self.actionLoad_Trace = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionLoad_Trace.setObjectName("actionLoad_Trace")
        self.actionLibpince = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionLibpince.setObjectName("actionLibpince")
        self.actionGDB_Log_File = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionGDB_Log_File.setObjectName("actionGDB_Log_File")
        self.actionSearch_Opcode = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionSearch_Opcode.setObjectName("actionSearch_Opcode")
        self.actionMemory_Regions = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionMemory_Regions.setObjectName("actionMemory_Regions")
        self.actionDissect_Code = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionDissect_Code.setObjectName("actionDissect_Code")
        self.actionReferenced_Strings = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionReferenced_Strings.setObjectName("actionReferenced_Strings")
        self.actionReferenced_Calls = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionReferenced_Calls.setObjectName("actionReferenced_Calls")
        self.actionToggle_Attach = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionToggle_Attach.setObjectName("actionToggle_Attach")
        self.actionRestore_Instructions = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionRestore_Instructions.setObjectName("actionRestore_Instructions")
        self.actionLibpince_Engine = QtGui.QAction(parent=MainWindow_MemoryView)
        self.actionLibpince_Engine.setObjectName("actionLibpince_Engine")
        self.menuView.addAction(self.actionBookmarks)
        self.menuView.addAction(self.actionStackTrace_Info)
        self.menuView.addAction(self.actionBreakpoints)
        self.menuView.addAction(self.actionFunctions)
        self.menuView.addAction(self.actionGDB_Log_File)
        self.menuView.addAction(self.actionMemory_Regions)
        self.menuView.addAction(self.actionRestore_Instructions)
        self.menuView.addSeparator()
        self.menuView.addAction(self.actionReferenced_Strings)
        self.menuView.addAction(self.actionReferenced_Calls)
        self.menuDebug.addAction(self.actionRun)
        self.menuDebug.addAction(self.actionBreak)
        self.menuDebug.addSeparator()
        self.menuDebug.addAction(self.actionStep)
        self.menuDebug.addAction(self.actionStep_Over)
        self.menuDebug.addAction(self.actionExecute_Till_Return)
        self.menuDebug.addAction(self.actionToggle_Breakpoint)
        self.menuDebug.addAction(self.actionSet_Address)
        self.menuDebug.addSeparator()
        self.menuDebug.addAction(self.actionToggle_Attach)
        self.menuTools.addAction(self.actionInject_so_file)
        self.menuTools.addAction(self.actionCall_Function)
        self.menuTools.addAction(self.actionSearch_Opcode)
        self.menuTools.addAction(self.actionDissect_Code)
        self.menuTools.addAction(self.actionLibpince_Engine)
        self.menuFile.addAction(self.actionLoad_Trace)
        self.menuHelp.addAction(self.actionLibpince)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuView.menuAction())
        self.menubar.addAction(self.menuDebug.menuAction())
        self.menubar.addAction(self.menuTools.menuAction())
        self.menubar.addAction(self.menuHelp.menuAction())

        self.retranslateUi(MainWindow_MemoryView)
        self.stackedWidget.setCurrentIndex(1)
        self.stackedWidget_StackScreens.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow_MemoryView)

    def retranslateUi(self, MainWindow_MemoryView):
        _translate = QtCore.QCoreApplication.translate
        MainWindow_MemoryView.setWindowTitle(_translate("MainWindow_MemoryView", "Memory Viewer"))
        item = self.tableWidget_Disassemble.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow_MemoryView", "Address"))
        item = self.tableWidget_Disassemble.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow_MemoryView", "Bytes"))
        item = self.tableWidget_Disassemble.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow_MemoryView", "Opcodes"))
        item = self.tableWidget_Disassemble.horizontalHeaderItem(3)
        item.setText(_translate("MainWindow_MemoryView", "Comment"))
        self.label_3.setText(_translate("MainWindow_MemoryView", "Registers"))
        self.label_29.setText(_translate("MainWindow_MemoryView", "Flags"))
        self.label_30.setText(_translate("MainWindow_MemoryView", "Segment Registers"))
        self.pushButton_ShowFloatRegisters.setText(_translate("MainWindow_MemoryView", "Show Float Registers"))
        item = self.tableWidget_HexView_Address.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow_MemoryView", "Address"))
        item = self.tableWidget_StackTrace.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow_MemoryView", "Return Address"))
        item = self.tableWidget_StackTrace.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow_MemoryView", "Frame Address"))
        item = self.tableWidget_Stack.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow_MemoryView", "Address"))
        item = self.tableWidget_Stack.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow_MemoryView", "Value"))
        item = self.tableWidget_Stack.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow_MemoryView", "Points to"))
        self.menuView.setTitle(_translate("MainWindow_MemoryView", "V&iew"))
        self.menuDebug.setTitle(_translate("MainWindow_MemoryView", "&Debug"))
        self.menuTools.setTitle(_translate("MainWindow_MemoryView", "&Tools"))
        self.menuFile.setTitle(_translate("MainWindow_MemoryView", "Fi&le"))
        self.menuHelp.setTitle(_translate("MainWindow_MemoryView", "Help"))
        self.actionBookmarks.setText(_translate("MainWindow_MemoryView", "&Bookmarks"))
        self.actionStackTrace_Info.setText(_translate("MainWindow_MemoryView", "&StackTrace Info"))
        self.actionInject_so_file.setText(_translate("MainWindow_MemoryView", "&Inject .so file"))
        self.actionRun.setText(_translate("MainWindow_MemoryView", "&Break"))
        self.actionBreak.setText(_translate("MainWindow_MemoryView", "&Run"))
        self.actionStep.setText(_translate("MainWindow_MemoryView", "&Step[F7]"))
        self.actionStep_Over.setText(_translate("MainWindow_MemoryView", "Step &Over[F8]"))
        self.actionExecute_Till_Return.setText(_translate("MainWindow_MemoryView", "&Execute Till Return[Shift+F8]"))
        self.actionToggle_Breakpoint.setText(_translate("MainWindow_MemoryView", "&Toggle Breakpoint[F5]"))
        self.actionBreakpoints.setText(_translate("MainWindow_MemoryView", "B&reakpoints"))
        self.actionFunctions.setText(_translate("MainWindow_MemoryView", "&Functions"))
        self.actionSet_Address.setText(_translate("MainWindow_MemoryView", "Set Address[Shift+F4]"))
        self.actionCall_Function.setText(_translate("MainWindow_MemoryView", "&Call Function"))
        self.actionLoad_Trace.setText(_translate("MainWindow_MemoryView", "&Load Trace"))
        self.actionLibpince.setText(_translate("MainWindow_MemoryView", "&Libpince"))
        self.actionGDB_Log_File.setText(_translate("MainWindow_MemoryView", "&GDB Log File"))
        self.actionSearch_Opcode.setText(_translate("MainWindow_MemoryView", "&Search Opcode"))
        self.actionMemory_Regions.setText(_translate("MainWindow_MemoryView", "&Memory Regions"))
        self.actionDissect_Code.setText(_translate("MainWindow_MemoryView", "&Dissect Code"))
        self.actionReferenced_Strings.setText(_translate("MainWindow_MemoryView", "R&eferenced Strings"))
        self.actionReferenced_Calls.setText(_translate("MainWindow_MemoryView", "Referenced &Calls"))
        self.actionToggle_Attach.setText(_translate("MainWindow_MemoryView", "To&ggle Attach"))
        self.actionRestore_Instructions.setText(_translate("MainWindow_MemoryView", "Restore Instructions"))
        self.actionLibpince_Engine.setText(_translate("MainWindow_MemoryView", "Libpince Engine"))
from GUI.Labels.FlagRegisterLabel import QFlagRegisterLabel
from GUI.Labels.RegisterLabel import QRegisterLabel
from GUI.TableViews.AsciiView import QAsciiView
from GUI.TableViews.HexView import QHexView

```

`GUI/MemoryViewerWindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow_MemoryView</class>
 <widget class="QMainWindow" name="MainWindow_MemoryView">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>800</width>
    <height>600</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Memory Viewer</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QGridLayout" name="gridLayout_5">
    <property name="leftMargin">
     <number>0</number>
    </property>
    <property name="topMargin">
     <number>0</number>
    </property>
    <property name="rightMargin">
     <number>0</number>
    </property>
    <property name="bottomMargin">
     <number>0</number>
    </property>
    <property name="spacing">
     <number>0</number>
    </property>
    <item row="0" column="0">
     <widget class="QSplitter" name="splitter_MainMiddle">
      <property name="lineWidth">
       <number>1</number>
      </property>
      <property name="orientation">
       <enum>Qt::Vertical</enum>
      </property>
      <property name="opaqueResize">
       <bool>true</bool>
      </property>
      <property name="handleWidth">
       <number>10</number>
      </property>
      <property name="childrenCollapsible">
       <bool>true</bool>
      </property>
      <widget class="QSplitter" name="splitter_Disassemble_Registers">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="handleWidth">
        <number>10</number>
       </property>
       <widget class="QWidget" name="widget_Disassemble" native="true">
        <layout class="QGridLayout" name="gridLayout_2">
         <property name="leftMargin">
          <number>0</number>
         </property>
         <property name="topMargin">
          <number>0</number>
         </property>
         <property name="rightMargin">
          <number>0</number>
         </property>
         <property name="bottomMargin">
          <number>0</number>
         </property>
         <property name="spacing">
          <number>0</number>
         </property>
         <item row="0" column="0">
          <widget class="QTableWidget" name="tableWidget_Disassemble">
           <property name="font">
            <font>
             <family>Monospace</family>
            </font>
           </property>
           <property name="verticalScrollBarPolicy">
            <enum>Qt::ScrollBarAlwaysOff</enum>
           </property>
           <property name="autoScroll">
            <bool>false</bool>
           </property>
           <property name="editTriggers">
            <set>QAbstractItemView::NoEditTriggers</set>
           </property>
           <property name="alternatingRowColors">
            <bool>true</bool>
           </property>
           <property name="selectionMode">
            <enum>QAbstractItemView::SingleSelection</enum>
           </property>
           <property name="selectionBehavior">
            <enum>QAbstractItemView::SelectRows</enum>
           </property>
           <property name="horizontalScrollMode">
            <enum>QAbstractItemView::ScrollPerPixel</enum>
           </property>
           <property name="showGrid">
            <bool>false</bool>
           </property>
           <property name="wordWrap">
            <bool>false</bool>
           </property>
           <attribute name="horizontalHeaderStretchLastSection">
            <bool>true</bool>
           </attribute>
           <attribute name="verticalHeaderVisible">
            <bool>false</bool>
           </attribute>
           <attribute name="verticalHeaderMinimumSectionSize">
            <number>16</number>
           </attribute>
           <attribute name="verticalHeaderDefaultSectionSize">
            <number>16</number>
           </attribute>
           <attribute name="verticalHeaderStretchLastSection">
            <bool>false</bool>
           </attribute>
           <column>
            <property name="text">
             <string>Address</string>
            </property>
           </column>
           <column>
            <property name="text">
             <string>Bytes</string>
            </property>
           </column>
           <column>
            <property name="text">
             <string>Opcodes</string>
            </property>
           </column>
           <column>
            <property name="text">
             <string>Comment</string>
            </property>
           </column>
          </widget>
         </item>
         <item row="0" column="1">
          <widget class="QScrollBar" name="verticalScrollBar_Disassemble">
           <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
          </widget>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="widget_Registers" native="true">
        <property name="font">
         <font>
          <family>Monospace</family>
         </font>
        </property>
        <layout class="QGridLayout" name="gridLayout_4">
         <property name="leftMargin">
          <number>0</number>
         </property>
         <property name="topMargin">
          <number>0</number>
         </property>
         <property name="rightMargin">
          <number>0</number>
         </property>
         <property name="bottomMargin">
          <number>0</number>
         </property>
         <property name="spacing">
          <number>0</number>
         </property>
         <item row="0" column="0">
          <widget class="QScrollArea" name="scrollArea_Registers">
           <property name="widgetResizable">
            <bool>true</bool>
           </property>
           <widget class="QWidget" name="scrollAreaWidgetContents_Registers">
            <property name="geometry">
             <rect>
              <x>0</x>
              <y>0</y>
              <width>344</width>
              <height>343</height>
             </rect>
            </property>
            <layout class="QGridLayout" name="gridLayout_8">
             <property name="leftMargin">
              <number>0</number>
             </property>
             <property name="topMargin">
              <number>0</number>
             </property>
             <property name="rightMargin">
              <number>0</number>
             </property>
             <property name="bottomMargin">
              <number>0</number>
             </property>
             <property name="spacing">
              <number>0</number>
             </property>
             <item row="0" column="0">
              <layout class="QHBoxLayout" name="horizontalLayout_4">
               <property name="spacing">
                <number>0</number>
               </property>
               <item>
                <layout class="QVBoxLayout" name="verticalLayout_19">
                 <property name="spacing">
                  <number>0</number>
                 </property>
                 <item>
                  <widget class="QLabel" name="label_3">
                   <property name="font">
                    <font>
                     <family>Monospace</family>
                    </font>
                   </property>
                   <property name="text">
                    <string>Registers</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="Line" name="line">
                   <property name="orientation">
                    <enum>Qt::Horizontal</enum>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="QStackedWidget" name="stackedWidget">
                   <property name="sizePolicy">
                    <sizepolicy hsizetype="Preferred" vsizetype="Fixed">
                     <horstretch>0</horstretch>
                     <verstretch>0</verstretch>
                    </sizepolicy>
                   </property>
                   <property name="minimumSize">
                    <size>
                     <width>0</width>
                     <height>145</height>
                    </size>
                   </property>
                   <property name="maximumSize">
                    <size>
                     <width>16777215</width>
                     <height>145</height>
                    </size>
                   </property>
                   <property name="currentIndex">
                    <number>1</number>
                   </property>
                   <widget class="QWidget" name="registers_64">
                    <layout class="QGridLayout" name="gridLayout_7">
                     <property name="leftMargin">
                      <number>0</number>
                     </property>
                     <property name="topMargin">
                      <number>0</number>
                     </property>
                     <property name="rightMargin">
                      <number>0</number>
                     </property>
                     <property name="bottomMargin">
                      <number>0</number>
                     </property>
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item row="0" column="0">
                      <layout class="QVBoxLayout" name="verticalLayout_17">
                       <property name="spacing">
                        <number>0</number>
                       </property>
                       <item>
                        <layout class="QHBoxLayout" name="horizontalLayout">
                         <property name="spacing">
                          <number>0</number>
                         </property>
                         <item>
                          <layout class="QVBoxLayout" name="verticalLayout_16">
                           <property name="spacing">
                            <number>0</number>
                           </property>
                           <item>
                            <widget class="QRegisterLabel" name="RAX">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">RAX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RBX">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">RBX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RCX">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">RCX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RDX">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">RDX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RSI">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">RSI=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RDI">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">RDI=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RBP">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">RBP=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="RSP">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">RSP=</string>
                             </property>
                            </widget>
                           </item>
                          </layout>
                         </item>
                         <item>
                          <spacer name="horizontalSpacer_2">
                           <property name="orientation">
                            <enum>Qt::Horizontal</enum>
                           </property>
                           <property name="sizeHint" stdset="0">
                            <size>
                             <width>40</width>
                             <height>20</height>
                            </size>
                           </property>
                          </spacer>
                         </item>
                         <item>
                          <layout class="QVBoxLayout" name="verticalLayout_3">
                           <property name="spacing">
                            <number>0</number>
                           </property>
                           <item>
                            <widget class="QRegisterLabel" name="R8">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">R8=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R9">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">R9=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R10">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">R10=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R11">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">R11=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R12">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">R12=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R13">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">R13=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R14">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">R14=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="R15">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">R15=</string>
                             </property>
                            </widget>
                           </item>
                          </layout>
                         </item>
                        </layout>
                       </item>
                       <item>
                        <layout class="QHBoxLayout" name="horizontalLayout_18">
                         <property name="spacing">
                          <number>0</number>
                         </property>
                         <item>
                          <widget class="QRegisterLabel" name="RIP">
                           <property name="font">
                            <font>
                             <family>Monospace</family>
                            </font>
                           </property>
                           <property name="text">
                            <string notr="true">RIP=</string>
                           </property>
                          </widget>
                         </item>
                         <item>
                          <spacer name="horizontalSpacer_19">
                           <property name="orientation">
                            <enum>Qt::Horizontal</enum>
                           </property>
                           <property name="sizeHint" stdset="0">
                            <size>
                             <width>40</width>
                             <height>20</height>
                            </size>
                           </property>
                          </spacer>
                         </item>
                        </layout>
                       </item>
                       <item>
                        <spacer name="verticalSpacer">
                         <property name="orientation">
                          <enum>Qt::Vertical</enum>
                         </property>
                         <property name="sizeHint" stdset="0">
                          <size>
                           <width>20</width>
                           <height>40</height>
                          </size>
                         </property>
                        </spacer>
                       </item>
                      </layout>
                     </item>
                    </layout>
                   </widget>
                   <widget class="QWidget" name="registers_32">
                    <layout class="QGridLayout" name="gridLayout_6">
                     <property name="leftMargin">
                      <number>0</number>
                     </property>
                     <property name="topMargin">
                      <number>0</number>
                     </property>
                     <property name="rightMargin">
                      <number>0</number>
                     </property>
                     <property name="bottomMargin">
                      <number>0</number>
                     </property>
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item row="0" column="0">
                      <layout class="QVBoxLayout" name="verticalLayout_14">
                       <property name="spacing">
                        <number>0</number>
                       </property>
                       <item>
                        <layout class="QHBoxLayout" name="horizontalLayout_3">
                         <property name="spacing">
                          <number>0</number>
                         </property>
                         <item>
                          <layout class="QVBoxLayout" name="verticalLayout_2">
                           <property name="spacing">
                            <number>0</number>
                           </property>
                           <item>
                            <widget class="QRegisterLabel" name="EAX">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">EAX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="EBX">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">EBX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="ECX">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">ECX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="EDX">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">EDX=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="ESI">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">ESI=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="EDI">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">EDI=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="EBP">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">EBP=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="ESP">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">ESP=</string>
                             </property>
                            </widget>
                           </item>
                           <item>
                            <widget class="QRegisterLabel" name="EIP">
                             <property name="font">
                              <font>
                               <family>Monospace</family>
                              </font>
                             </property>
                             <property name="text">
                              <string notr="true">EIP=</string>
                             </property>
                            </widget>
                           </item>
                          </layout>
                         </item>
                         <item>
                          <spacer name="horizontalSpacer_10">
                           <property name="orientation">
                            <enum>Qt::Horizontal</enum>
                           </property>
                           <property name="sizeHint" stdset="0">
                            <size>
                             <width>40</width>
                             <height>20</height>
                            </size>
                           </property>
                          </spacer>
                         </item>
                        </layout>
                       </item>
                      </layout>
                     </item>
                    </layout>
                   </widget>
                  </widget>
                 </item>
                 <item>
                  <widget class="QLabel" name="label_29">
                   <property name="font">
                    <font>
                     <family>Monospace</family>
                    </font>
                   </property>
                   <property name="text">
                    <string>Flags</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="Line" name="line_2">
                   <property name="orientation">
                    <enum>Qt::Horizontal</enum>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <layout class="QHBoxLayout" name="horizontalLayout_21">
                   <property name="spacing">
                    <number>0</number>
                   </property>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_5">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_31">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">CF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="CF">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_6">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_35">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">PF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="PF">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_7">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_37">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">AF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="AF">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_8">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_39">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">ZF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="ZF">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_9">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_41">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">SF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="SF">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_10">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_43">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">TF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="TF">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_11">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_45">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">IF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="IF">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_12">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_47">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">DF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="DF">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_13">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QLabel" name="label_49">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">OF</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QFlagRegisterLabel" name="OF">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">0</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                  </layout>
                 </item>
                 <item>
                  <spacer name="verticalSpacer_2">
                   <property name="orientation">
                    <enum>Qt::Vertical</enum>
                   </property>
                   <property name="sizeType">
                    <enum>QSizePolicy::Fixed</enum>
                   </property>
                   <property name="sizeHint" stdset="0">
                    <size>
                     <width>20</width>
                     <height>15</height>
                    </size>
                   </property>
                  </spacer>
                 </item>
                 <item>
                  <widget class="QLabel" name="label_30">
                   <property name="font">
                    <font>
                     <family>Monospace</family>
                    </font>
                   </property>
                   <property name="text">
                    <string>Segment Registers</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="Line" name="line_3">
                   <property name="orientation">
                    <enum>Qt::Horizontal</enum>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <layout class="QHBoxLayout" name="horizontalLayout_2">
                   <property name="spacing">
                    <number>0</number>
                   </property>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_4">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QRegisterLabel" name="CS">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">CS=</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QRegisterLabel" name="ES">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">ES=</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <spacer name="horizontalSpacer">
                     <property name="orientation">
                      <enum>Qt::Horizontal</enum>
                     </property>
                     <property name="sizeHint" stdset="0">
                      <size>
                       <width>40</width>
                       <height>20</height>
                      </size>
                     </property>
                    </spacer>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_15">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QRegisterLabel" name="SS">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">SS=</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QRegisterLabel" name="GS">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">GS=</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                   <item>
                    <spacer name="horizontalSpacer_3">
                     <property name="orientation">
                      <enum>Qt::Horizontal</enum>
                     </property>
                     <property name="sizeHint" stdset="0">
                      <size>
                       <width>40</width>
                       <height>20</height>
                      </size>
                     </property>
                    </spacer>
                   </item>
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_18">
                     <property name="spacing">
                      <number>0</number>
                     </property>
                     <item>
                      <widget class="QRegisterLabel" name="DS">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">DS=</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QRegisterLabel" name="FS">
                       <property name="font">
                        <font>
                         <family>Monospace</family>
                        </font>
                       </property>
                       <property name="text">
                        <string notr="true">FS=</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                  </layout>
                 </item>
                 <item>
                  <widget class="QPushButton" name="pushButton_ShowFloatRegisters">
                   <property name="font">
                    <font>
                     <family>Monospace</family>
                    </font>
                   </property>
                   <property name="text">
                    <string>Show Float Registers</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <spacer name="verticalSpacer_3">
                   <property name="orientation">
                    <enum>Qt::Vertical</enum>
                   </property>
                   <property name="sizeHint" stdset="0">
                    <size>
                     <width>20</width>
                     <height>40</height>
                    </size>
                   </property>
                  </spacer>
                 </item>
                </layout>
               </item>
               <item>
                <spacer name="horizontalSpacer_21">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
            </layout>
           </widget>
          </widget>
         </item>
        </layout>
       </widget>
      </widget>
      <widget class="QSplitter" name="splitter_HexView_StackView">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="handleWidth">
        <number>10</number>
       </property>
       <widget class="QWidget" name="widget_HexView" native="true">
        <layout class="QGridLayout" name="gridLayout">
         <property name="leftMargin">
          <number>0</number>
         </property>
         <property name="topMargin">
          <number>0</number>
         </property>
         <property name="rightMargin">
          <number>0</number>
         </property>
         <property name="bottomMargin">
          <number>0</number>
         </property>
         <property name="horizontalSpacing">
          <number>0</number>
         </property>
         <property name="verticalSpacing">
          <number>4</number>
         </property>
         <item row="0" column="0">
          <widget class="QScrollArea" name="scrollArea_Hex">
           <property name="widgetResizable">
            <bool>true</bool>
           </property>
           <widget class="QWidget" name="scrollAreaWidgetContents_2">
            <property name="geometry">
             <rect>
              <x>0</x>
              <y>0</y>
              <width>492</width>
              <height>197</height>
             </rect>
            </property>
            <layout class="QGridLayout" name="gridLayout_11">
             <property name="leftMargin">
              <number>0</number>
             </property>
             <property name="topMargin">
              <number>0</number>
             </property>
             <property name="rightMargin">
              <number>0</number>
             </property>
             <property name="bottomMargin">
              <number>0</number>
             </property>
             <property name="spacing">
              <number>0</number>
             </property>
             <item row="2" column="0">
              <layout class="QHBoxLayout" name="horizontalLayout_5">
               <property name="spacing">
                <number>0</number>
               </property>
               <item>
                <widget class="QTableWidget" name="tableWidget_HexView_Address">
                 <property name="font">
                  <font>
                   <family>Monospace</family>
                  </font>
                 </property>
                 <property name="editTriggers">
                  <set>QAbstractItemView::NoEditTriggers</set>
                 </property>
                 <property name="selectionBehavior">
                  <enum>QAbstractItemView::SelectRows</enum>
                 </property>
                 <property name="showGrid">
                  <bool>false</bool>
                 </property>
                 <property name="wordWrap">
                  <bool>false</bool>
                 </property>
                 <attribute name="horizontalHeaderVisible">
                  <bool>false</bool>
                 </attribute>
                 <attribute name="verticalHeaderVisible">
                  <bool>false</bool>
                 </attribute>
                 <column>
                  <property name="text">
                   <string>Address</string>
                  </property>
                 </column>
                </widget>
               </item>
               <item>
                <widget class="Line" name="line_5">
                 <property name="orientation">
                  <enum>Qt::Vertical</enum>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QHexView" name="tableView_HexView_Hex">
                 <property name="font">
                  <font>
                   <family>Monospace</family>
                  </font>
                 </property>
                 <property name="sizeAdjustPolicy">
                  <enum>QAbstractScrollArea::AdjustToContents</enum>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="Line" name="line_4">
                 <property name="orientation">
                  <enum>Qt::Vertical</enum>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QAsciiView" name="tableView_HexView_Ascii">
                 <property name="font">
                  <font>
                   <family>Monospace</family>
                  </font>
                 </property>
                 <property name="sizeAdjustPolicy">
                  <enum>QAbstractScrollArea::AdjustToContents</enum>
                 </property>
                </widget>
               </item>
               <item>
                <spacer name="horizontalSpacer_4">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item row="0" column="0">
              <widget class="QLabel" name="label_HexView_Information">
               <property name="text">
                <string/>
               </property>
              </widget>
             </item>
             <item row="1" column="0">
              <widget class="Line" name="line_6">
               <property name="orientation">
                <enum>Qt::Horizontal</enum>
               </property>
              </widget>
             </item>
            </layout>
            <zorder></zorder>
            <zorder>label_HexView_Information</zorder>
            <zorder>line_6</zorder>
           </widget>
          </widget>
         </item>
         <item row="0" column="1">
          <widget class="QScrollBar" name="verticalScrollBar_HexView">
           <property name="orientation">
            <enum>Qt::Vertical</enum>
           </property>
          </widget>
         </item>
        </layout>
       </widget>
       <widget class="QWidget" name="widget_StackView" native="true">
        <layout class="QGridLayout" name="gridLayout_3">
         <property name="leftMargin">
          <number>0</number>
         </property>
         <property name="topMargin">
          <number>0</number>
         </property>
         <property name="rightMargin">
          <number>0</number>
         </property>
         <property name="bottomMargin">
          <number>0</number>
         </property>
         <property name="spacing">
          <number>0</number>
         </property>
         <item row="0" column="0">
          <widget class="QStackedWidget" name="stackedWidget_StackScreens">
           <property name="currentIndex">
            <number>0</number>
           </property>
           <widget class="QWidget" name="StackTrace">
            <layout class="QGridLayout" name="gridLayout_9">
             <property name="leftMargin">
              <number>0</number>
             </property>
             <property name="topMargin">
              <number>0</number>
             </property>
             <property name="rightMargin">
              <number>0</number>
             </property>
             <property name="bottomMargin">
              <number>0</number>
             </property>
             <property name="spacing">
              <number>0</number>
             </property>
             <item row="0" column="0">
              <widget class="QTableWidget" name="tableWidget_StackTrace">
               <property name="font">
                <font>
                 <family>Monospace</family>
                </font>
               </property>
               <property name="editTriggers">
                <set>QAbstractItemView::NoEditTriggers</set>
               </property>
               <property name="selectionMode">
                <enum>QAbstractItemView::SingleSelection</enum>
               </property>
               <property name="selectionBehavior">
                <enum>QAbstractItemView::SelectRows</enum>
               </property>
               <property name="wordWrap">
                <bool>false</bool>
               </property>
               <attribute name="horizontalHeaderStretchLastSection">
                <bool>true</bool>
               </attribute>
               <attribute name="verticalHeaderVisible">
                <bool>false</bool>
               </attribute>
               <attribute name="verticalHeaderMinimumSectionSize">
                <number>16</number>
               </attribute>
               <attribute name="verticalHeaderDefaultSectionSize">
                <number>16</number>
               </attribute>
               <column>
                <property name="text">
                 <string>Return Address</string>
                </property>
               </column>
               <column>
                <property name="text">
                 <string>Frame Address</string>
                </property>
               </column>
              </widget>
             </item>
            </layout>
           </widget>
           <widget class="QWidget" name="Stack">
            <layout class="QGridLayout" name="gridLayout_10">
             <property name="leftMargin">
              <number>0</number>
             </property>
             <property name="topMargin">
              <number>0</number>
             </property>
             <property name="rightMargin">
              <number>0</number>
             </property>
             <property name="bottomMargin">
              <number>0</number>
             </property>
             <property name="spacing">
              <number>0</number>
             </property>
             <item row="0" column="0">
              <widget class="QTableWidget" name="tableWidget_Stack">
               <property name="font">
                <font>
                 <family>Monospace</family>
                </font>
               </property>
               <property name="editTriggers">
                <set>QAbstractItemView::NoEditTriggers</set>
               </property>
               <property name="selectionMode">
                <enum>QAbstractItemView::SingleSelection</enum>
               </property>
               <property name="selectionBehavior">
                <enum>QAbstractItemView::SelectRows</enum>
               </property>
               <attribute name="horizontalHeaderStretchLastSection">
                <bool>true</bool>
               </attribute>
               <attribute name="verticalHeaderVisible">
                <bool>false</bool>
               </attribute>
               <attribute name="verticalHeaderMinimumSectionSize">
                <number>16</number>
               </attribute>
               <attribute name="verticalHeaderDefaultSectionSize">
                <number>16</number>
               </attribute>
               <column>
                <property name="text">
                 <string>Address</string>
                </property>
               </column>
               <column>
                <property name="text">
                 <string>Value</string>
                </property>
               </column>
               <column>
                <property name="text">
                 <string>Points to</string>
                </property>
               </column>
              </widget>
             </item>
            </layout>
           </widget>
          </widget>
         </item>
        </layout>
       </widget>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>800</width>
     <height>23</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuView">
    <property name="title">
     <string>V&amp;iew</string>
    </property>
    <addaction name="actionBookmarks"/>
    <addaction name="actionStackTrace_Info"/>
    <addaction name="actionBreakpoints"/>
    <addaction name="actionFunctions"/>
    <addaction name="actionGDB_Log_File"/>
    <addaction name="actionMemory_Regions"/>
    <addaction name="actionRestore_Instructions"/>
    <addaction name="separator"/>
    <addaction name="actionReferenced_Strings"/>
    <addaction name="actionReferenced_Calls"/>
   </widget>
   <widget class="QMenu" name="menuDebug">
    <property name="title">
     <string>&amp;Debug</string>
    </property>
    <addaction name="actionRun"/>
    <addaction name="actionBreak"/>
    <addaction name="separator"/>
    <addaction name="actionStep"/>
    <addaction name="actionStep_Over"/>
    <addaction name="actionExecute_Till_Return"/>
    <addaction name="actionToggle_Breakpoint"/>
    <addaction name="actionSet_Address"/>
    <addaction name="separator"/>
    <addaction name="actionToggle_Attach"/>
   </widget>
   <widget class="QMenu" name="menuTools">
    <property name="title">
     <string>&amp;Tools</string>
    </property>
    <addaction name="actionInject_so_file"/>
    <addaction name="actionCall_Function"/>
    <addaction name="actionSearch_Opcode"/>
    <addaction name="actionDissect_Code"/>
    <addaction name="actionLibpince_Engine"/>
   </widget>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>Fi&amp;le</string>
    </property>
    <addaction name="actionLoad_Trace"/>
   </widget>
   <widget class="QMenu" name="menuHelp">
    <property name="title">
     <string>Help</string>
    </property>
    <addaction name="actionLibpince"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuView"/>
   <addaction name="menuDebug"/>
   <addaction name="menuTools"/>
   <addaction name="menuHelp"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <action name="actionBookmarks">
   <property name="text">
    <string>&amp;Bookmarks</string>
   </property>
  </action>
  <action name="actionStackTrace_Info">
   <property name="text">
    <string>&amp;StackTrace Info</string>
   </property>
  </action>
  <action name="actionInject_so_file">
   <property name="text">
    <string>&amp;Inject .so file</string>
   </property>
  </action>
  <action name="actionRun">
   <property name="text">
    <string>&amp;Break</string>
   </property>
  </action>
  <action name="actionBreak">
   <property name="text">
    <string>&amp;Run</string>
   </property>
  </action>
  <action name="actionStep">
   <property name="text">
    <string>&amp;Step[F7]</string>
   </property>
  </action>
  <action name="actionStep_Over">
   <property name="text">
    <string>Step &amp;Over[F8]</string>
   </property>
  </action>
  <action name="actionExecute_Till_Return">
   <property name="text">
    <string>&amp;Execute Till Return[Shift+F8]</string>
   </property>
  </action>
  <action name="actionToggle_Breakpoint">
   <property name="text">
    <string>&amp;Toggle Breakpoint[F5]</string>
   </property>
  </action>
  <action name="actionBreakpoints">
   <property name="text">
    <string>B&amp;reakpoints</string>
   </property>
  </action>
  <action name="actionFunctions">
   <property name="text">
    <string>&amp;Functions</string>
   </property>
  </action>
  <action name="actionSet_Address">
   <property name="text">
    <string>Set Address[Shift+F4]</string>
   </property>
  </action>
  <action name="actionCall_Function">
   <property name="text">
    <string>&amp;Call Function</string>
   </property>
  </action>
  <action name="actionLoad_Trace">
   <property name="text">
    <string>&amp;Load Trace</string>
   </property>
  </action>
  <action name="actionLibpince">
   <property name="text">
    <string>&amp;Libpince</string>
   </property>
  </action>
  <action name="actionGDB_Log_File">
   <property name="text">
    <string>&amp;GDB Log File</string>
   </property>
  </action>
  <action name="actionSearch_Opcode">
   <property name="text">
    <string>&amp;Search Opcode</string>
   </property>
  </action>
  <action name="actionMemory_Regions">
   <property name="text">
    <string>&amp;Memory Regions</string>
   </property>
  </action>
  <action name="actionDissect_Code">
   <property name="text">
    <string>&amp;Dissect Code</string>
   </property>
  </action>
  <action name="actionReferenced_Strings">
   <property name="text">
    <string>R&amp;eferenced Strings</string>
   </property>
  </action>
  <action name="actionReferenced_Calls">
   <property name="text">
    <string>Referenced &amp;Calls</string>
   </property>
  </action>
  <action name="actionToggle_Attach">
   <property name="text">
    <string>To&amp;ggle Attach</string>
   </property>
  </action>
  <action name="actionRestore_Instructions">
   <property name="text">
    <string>Restore Instructions</string>
   </property>
  </action>
  <action name="actionLibpince_Engine">
   <property name="text">
    <string>Libpince Engine</string>
   </property>
  </action>
 </widget>
 <customwidgets>
  <customwidget>
   <class>QRegisterLabel</class>
   <extends>QLabel</extends>
   <header location="global">GUI.Labels.RegisterLabel</header>
  </customwidget>
  <customwidget>
   <class>QFlagRegisterLabel</class>
   <extends>QLabel</extends>
   <header location="global">GUI.Labels.FlagRegisterLabel</header>
  </customwidget>
  <customwidget>
   <class>QHexView</class>
   <extends>QTableView</extends>
   <header location="global">GUI.TableViews.HexView</header>
  </customwidget>
  <customwidget>
   <class>QAsciiView</class>
   <extends>QTableView</extends>
   <header location="global">GUI.TableViews.AsciiView</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`GUI/ReferencedCallsWidget.py`:

```py
# Form implementation generated from reading ui file 'ReferencedCallsWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(1025, 530)
        Form.setToolTip("")
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(parent=Form)
        self.splitter.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtWidgets.QWidget(parent=self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lineEdit_Regex = QtWidgets.QLineEdit(parent=self.layoutWidget)
        self.lineEdit_Regex.setObjectName("lineEdit_Regex")
        self.horizontalLayout_2.addWidget(self.lineEdit_Regex)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(parent=self.layoutWidget)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.horizontalLayout_2.addWidget(self.checkBox_CaseSensitive)
        self.checkBox_Regex = QtWidgets.QCheckBox(parent=self.layoutWidget)
        self.checkBox_Regex.setObjectName("checkBox_Regex")
        self.horizontalLayout_2.addWidget(self.checkBox_Regex)
        self.pushButton_Search = QtWidgets.QPushButton(parent=self.layoutWidget)
        self.pushButton_Search.setObjectName("pushButton_Search")
        self.horizontalLayout_2.addWidget(self.pushButton_Search)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.tableWidget_References = QtWidgets.QTableWidget(parent=self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_References.setFont(font)
        self.tableWidget_References.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_References.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_References.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_References.setWordWrap(False)
        self.tableWidget_References.setObjectName("tableWidget_References")
        self.tableWidget_References.setColumnCount(2)
        self.tableWidget_References.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_References.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_References.setHorizontalHeaderItem(1, item)
        self.tableWidget_References.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_References.verticalHeader().setVisible(False)
        self.tableWidget_References.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_References.verticalHeader().setMinimumSectionSize(16)
        self.verticalLayout.addWidget(self.tableWidget_References)
        self.listWidget_Referrers = QtWidgets.QListWidget(parent=self.splitter)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.listWidget_Referrers.setFont(font)
        self.listWidget_Referrers.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.listWidget_Referrers.setObjectName("listWidget_Referrers")
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Referenced Calls"))
        self.lineEdit_Regex.setPlaceholderText(_translate("Form", "Enter a string or a python regex"))
        self.checkBox_CaseSensitive.setToolTip(_translate("Form", "Ignore case if checked"))
        self.checkBox_CaseSensitive.setText(_translate("Form", "Case sensitive"))
        self.checkBox_Regex.setToolTip(_translate("Form", "Your string will be treated as a regex if checked"))
        self.checkBox_Regex.setText(_translate("Form", "Regex"))
        self.pushButton_Search.setText(_translate("Form", "Search(Enter)"))
        self.tableWidget_References.setSortingEnabled(True)
        item = self.tableWidget_References.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_References.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Refcount"))

```

`GUI/ReferencedCallsWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1025</width>
    <height>530</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Referenced Calls</string>
  </property>
  <property name="toolTip">
   <string/>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLineEdit" name="lineEdit_Regex">
           <property name="placeholderText">
            <string>Enter a string or a python regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_CaseSensitive">
           <property name="toolTip">
            <string>Ignore case if checked</string>
           </property>
           <property name="text">
            <string>Case sensitive</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_Regex">
           <property name="toolTip">
            <string>Your string will be treated as a regex if checked</string>
           </property>
           <property name="text">
            <string>Regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_Search">
           <property name="text">
            <string>Search(Enter)</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QTableWidget" name="tableWidget_References">
         <property name="font">
          <font>
           <family>Monospace</family>
          </font>
         </property>
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
         <property name="selectionMode">
          <enum>QAbstractItemView::SingleSelection</enum>
         </property>
         <property name="selectionBehavior">
          <enum>QAbstractItemView::SelectRows</enum>
         </property>
         <property name="sortingEnabled">
          <bool>true</bool>
         </property>
         <property name="wordWrap">
          <bool>false</bool>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <attribute name="verticalHeaderVisible">
          <bool>false</bool>
         </attribute>
         <attribute name="verticalHeaderMinimumSectionSize">
          <number>16</number>
         </attribute>
         <attribute name="verticalHeaderDefaultSectionSize">
          <number>16</number>
         </attribute>
         <column>
          <property name="text">
           <string>Address</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Refcount</string>
          </property>
         </column>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QListWidget" name="listWidget_Referrers">
      <property name="font">
       <font>
        <family>Monospace</family>
       </font>
      </property>
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/ReferencedStringsWidget.py`:

```py
# Form implementation generated from reading ui file 'ReferencedStringsWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(1025, 530)
        Form.setToolTip("")
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(parent=Form)
        self.splitter.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtWidgets.QWidget(parent=self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.lineEdit_Regex = QtWidgets.QLineEdit(parent=self.layoutWidget)
        self.lineEdit_Regex.setObjectName("lineEdit_Regex")
        self.horizontalLayout_2.addWidget(self.lineEdit_Regex)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(parent=self.layoutWidget)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.horizontalLayout_2.addWidget(self.checkBox_CaseSensitive)
        self.checkBox_Regex = QtWidgets.QCheckBox(parent=self.layoutWidget)
        self.checkBox_Regex.setObjectName("checkBox_Regex")
        self.horizontalLayout_2.addWidget(self.checkBox_Regex)
        self.pushButton_Search = QtWidgets.QPushButton(parent=self.layoutWidget)
        self.pushButton_Search.setObjectName("pushButton_Search")
        self.horizontalLayout_2.addWidget(self.pushButton_Search)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.tableWidget_References = QtWidgets.QTableWidget(parent=self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_References.setFont(font)
        self.tableWidget_References.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_References.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_References.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_References.setWordWrap(False)
        self.tableWidget_References.setObjectName("tableWidget_References")
        self.tableWidget_References.setColumnCount(3)
        self.tableWidget_References.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_References.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_References.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_References.setHorizontalHeaderItem(2, item)
        self.tableWidget_References.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_References.verticalHeader().setVisible(False)
        self.tableWidget_References.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_References.verticalHeader().setMinimumSectionSize(16)
        self.verticalLayout.addWidget(self.tableWidget_References)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.comboBox_ValueType = QtWidgets.QComboBox(parent=self.layoutWidget)
        self.comboBox_ValueType.setSizeAdjustPolicy(QtWidgets.QComboBox.SizeAdjustPolicy.AdjustToContents)
        self.comboBox_ValueType.setObjectName("comboBox_ValueType")
        self.horizontalLayout.addWidget(self.comboBox_ValueType)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.listWidget_Referrers = QtWidgets.QListWidget(parent=self.splitter)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.listWidget_Referrers.setFont(font)
        self.listWidget_Referrers.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.listWidget_Referrers.setObjectName("listWidget_Referrers")
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Form)
        self.comboBox_ValueType.setCurrentIndex(-1)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Referenced Strings and Values"))
        self.lineEdit_Regex.setPlaceholderText(_translate("Form", "Enter a string or a python regex"))
        self.checkBox_CaseSensitive.setToolTip(_translate("Form", "Ignore case if checked"))
        self.checkBox_CaseSensitive.setText(_translate("Form", "Case sensitive"))
        self.checkBox_Regex.setToolTip(_translate("Form", "Your string will be treated as a regex if checked"))
        self.checkBox_Regex.setText(_translate("Form", "Regex"))
        self.pushButton_Search.setText(_translate("Form", "Search(Enter)"))
        self.tableWidget_References.setSortingEnabled(True)
        item = self.tableWidget_References.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_References.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Refcount"))
        item = self.tableWidget_References.horizontalHeaderItem(2)
        item.setText(_translate("Form", "Value"))

```

`GUI/ReferencedStringsWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1025</width>
    <height>530</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Referenced Strings and Values</string>
  </property>
  <property name="toolTip">
   <string/>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout_2">
         <item>
          <widget class="QLineEdit" name="lineEdit_Regex">
           <property name="placeholderText">
            <string>Enter a string or a python regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_CaseSensitive">
           <property name="toolTip">
            <string>Ignore case if checked</string>
           </property>
           <property name="text">
            <string>Case sensitive</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QCheckBox" name="checkBox_Regex">
           <property name="toolTip">
            <string>Your string will be treated as a regex if checked</string>
           </property>
           <property name="text">
            <string>Regex</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QPushButton" name="pushButton_Search">
           <property name="text">
            <string>Search(Enter)</string>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QTableWidget" name="tableWidget_References">
         <property name="font">
          <font>
           <family>Monospace</family>
          </font>
         </property>
         <property name="editTriggers">
          <set>QAbstractItemView::NoEditTriggers</set>
         </property>
         <property name="selectionMode">
          <enum>QAbstractItemView::SingleSelection</enum>
         </property>
         <property name="selectionBehavior">
          <enum>QAbstractItemView::SelectRows</enum>
         </property>
         <property name="sortingEnabled">
          <bool>true</bool>
         </property>
         <property name="wordWrap">
          <bool>false</bool>
         </property>
         <attribute name="horizontalHeaderStretchLastSection">
          <bool>true</bool>
         </attribute>
         <attribute name="verticalHeaderVisible">
          <bool>false</bool>
         </attribute>
         <attribute name="verticalHeaderMinimumSectionSize">
          <number>16</number>
         </attribute>
         <attribute name="verticalHeaderDefaultSectionSize">
          <number>16</number>
         </attribute>
         <column>
          <property name="text">
           <string>Address</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Refcount</string>
          </property>
         </column>
         <column>
          <property name="text">
           <string>Value</string>
          </property>
         </column>
        </widget>
       </item>
       <item>
        <layout class="QHBoxLayout" name="horizontalLayout">
         <item>
          <spacer name="horizontalSpacer">
           <property name="orientation">
            <enum>Qt::Horizontal</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>40</width>
             <height>20</height>
            </size>
           </property>
          </spacer>
         </item>
         <item>
          <widget class="QComboBox" name="comboBox_ValueType">
           <property name="currentIndex">
            <number>-1</number>
           </property>
           <property name="sizeAdjustPolicy">
            <enum>QComboBox::AdjustToContents</enum>
           </property>
          </widget>
         </item>
        </layout>
       </item>
      </layout>
     </widget>
     <widget class="QListWidget" name="listWidget_Referrers">
      <property name="font">
       <font>
        <family>Monospace</family>
       </font>
      </property>
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/SearchOpcodeWidget.py`:

```py
# Form implementation generated from reading ui file 'SearchOpcodeWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(631, 490)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label_3 = QtWidgets.QLabel(parent=Form)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout_2.addWidget(self.label_3)
        self.lineEdit_Regex = QtWidgets.QLineEdit(parent=Form)
        self.lineEdit_Regex.setObjectName("lineEdit_Regex")
        self.horizontalLayout_2.addWidget(self.lineEdit_Regex)
        self.checkBox_CaseSensitive = QtWidgets.QCheckBox(parent=Form)
        self.checkBox_CaseSensitive.setObjectName("checkBox_CaseSensitive")
        self.horizontalLayout_2.addWidget(self.checkBox_CaseSensitive)
        self.checkBox_Regex = QtWidgets.QCheckBox(parent=Form)
        self.checkBox_Regex.setObjectName("checkBox_Regex")
        self.horizontalLayout_2.addWidget(self.checkBox_Regex)
        self.pushButton_Search = QtWidgets.QPushButton(parent=Form)
        self.pushButton_Search.setObjectName("pushButton_Search")
        self.horizontalLayout_2.addWidget(self.pushButton_Search)
        self.pushButton_Help = QtWidgets.QPushButton(parent=Form)
        self.pushButton_Help.setText("")
        self.pushButton_Help.setObjectName("pushButton_Help")
        self.horizontalLayout_2.addWidget(self.pushButton_Help)
        self.gridLayout.addLayout(self.horizontalLayout_2, 0, 0, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(parent=Form)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit_Start = QtWidgets.QLineEdit(parent=Form)
        self.lineEdit_Start.setObjectName("lineEdit_Start")
        self.horizontalLayout.addWidget(self.lineEdit_Start)
        self.label_2 = QtWidgets.QLabel(parent=Form)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.lineEdit_End = QtWidgets.QLineEdit(parent=Form)
        self.lineEdit_End.setObjectName("lineEdit_End")
        self.horizontalLayout.addWidget(self.lineEdit_End)
        self.gridLayout.addLayout(self.horizontalLayout, 1, 0, 1, 1)
        self.tableWidget_Opcodes = QtWidgets.QTableWidget(parent=Form)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_Opcodes.setFont(font)
        self.tableWidget_Opcodes.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_Opcodes.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_Opcodes.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_Opcodes.setWordWrap(False)
        self.tableWidget_Opcodes.setObjectName("tableWidget_Opcodes")
        self.tableWidget_Opcodes.setColumnCount(2)
        self.tableWidget_Opcodes.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Opcodes.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Opcodes.setHorizontalHeaderItem(1, item)
        self.tableWidget_Opcodes.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Opcodes.verticalHeader().setVisible(False)
        self.tableWidget_Opcodes.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Opcodes.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_Opcodes, 2, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Search for Opcodes"))
        self.label_3.setText(_translate("Form", "Regex"))
        self.lineEdit_Regex.setPlaceholderText(_translate("Form", "Enter a string or a python regex"))
        self.checkBox_CaseSensitive.setToolTip(_translate("Form", "Ignore case if checked"))
        self.checkBox_CaseSensitive.setText(_translate("Form", "Case sensitive"))
        self.checkBox_Regex.setToolTip(_translate("Form", "Your string will be treated as a regex if checked"))
        self.checkBox_Regex.setText(_translate("Form", "Regex"))
        self.pushButton_Search.setText(_translate("Form", "Search(Enter)"))
        self.label.setText(_translate("Form", "Start"))
        self.label_2.setText(_translate("Form", "End"))
        self.tableWidget_Opcodes.setSortingEnabled(True)
        item = self.tableWidget_Opcodes.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_Opcodes.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Opcodes"))

```

`GUI/SearchOpcodeWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>631</width>
    <height>490</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Search for Opcodes</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout_2">
     <item>
      <widget class="QLabel" name="label_3">
       <property name="text">
        <string>Regex</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Regex">
       <property name="placeholderText">
        <string>Enter a string or a python regex</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_CaseSensitive">
       <property name="toolTip">
        <string>Ignore case if checked</string>
       </property>
       <property name="text">
        <string>Case sensitive</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_Regex">
       <property name="toolTip">
        <string>Your string will be treated as a regex if checked</string>
       </property>
       <property name="text">
        <string>Regex</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Search">
       <property name="text">
        <string>Search(Enter)</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Help">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Start</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_Start"/>
     </item>
     <item>
      <widget class="QLabel" name="label_2">
       <property name="text">
        <string>End</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_End"/>
     </item>
    </layout>
   </item>
   <item row="2" column="0">
    <widget class="QTableWidget" name="tableWidget_Opcodes">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Opcodes</string>
      </property>
     </column>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/SelectProcess.py`:

```py
# Form implementation generated from reading ui file 'SelectProcess.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.setWindowModality(QtCore.Qt.WindowModality.WindowModal)
        MainWindow.resize(443, 420)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(parent=self.centralwidget)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit_SearchProcess = QtWidgets.QLineEdit(parent=self.centralwidget)
        self.lineEdit_SearchProcess.setObjectName("lineEdit_SearchProcess")
        self.horizontalLayout.addWidget(self.lineEdit_SearchProcess)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.tableWidget_ProcessTable = QtWidgets.QTableWidget(parent=self.centralwidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tableWidget_ProcessTable.sizePolicy().hasHeightForWidth())
        self.tableWidget_ProcessTable.setSizePolicy(sizePolicy)
        self.tableWidget_ProcessTable.setAutoFillBackground(False)
        self.tableWidget_ProcessTable.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.SizeAdjustPolicy.AdjustIgnored)
        self.tableWidget_ProcessTable.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_ProcessTable.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_ProcessTable.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_ProcessTable.setWordWrap(False)
        self.tableWidget_ProcessTable.setObjectName("tableWidget_ProcessTable")
        self.tableWidget_ProcessTable.setColumnCount(3)
        self.tableWidget_ProcessTable.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_ProcessTable.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_ProcessTable.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignmentFlag.AlignLeading|QtCore.Qt.AlignmentFlag.AlignVCenter)
        self.tableWidget_ProcessTable.setHorizontalHeaderItem(2, item)
        self.tableWidget_ProcessTable.horizontalHeader().setDefaultSectionSize(70)
        self.tableWidget_ProcessTable.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_ProcessTable.verticalHeader().setVisible(False)
        self.tableWidget_ProcessTable.verticalHeader().setStretchLastSection(False)
        self.verticalLayout.addWidget(self.tableWidget_ProcessTable)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem)
        self.pushButton_Open = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_Open.setObjectName("pushButton_Open")
        self.horizontalLayout_2.addWidget(self.pushButton_Open)
        self.pushButton_Close = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_Close.setObjectName("pushButton_Close")
        self.horizontalLayout_2.addWidget(self.pushButton_Close)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem1)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem2)
        self.pushButton_CreateProcess = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_CreateProcess.setObjectName("pushButton_CreateProcess")
        self.horizontalLayout_3.addWidget(self.pushButton_CreateProcess)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem3)
        self.verticalLayout.addLayout(self.horizontalLayout_3)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Please select a Process"))
        self.label.setText(_translate("MainWindow", "Name or PID of the Process:"))
        self.tableWidget_ProcessTable.setSortingEnabled(True)
        item = self.tableWidget_ProcessTable.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "PID"))
        item = self.tableWidget_ProcessTable.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Username"))
        item = self.tableWidget_ProcessTable.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow", "Process Name"))
        self.pushButton_Open.setToolTip(_translate("MainWindow", "Attach to the selected process"))
        self.pushButton_Open.setText(_translate("MainWindow", "Open"))
        self.pushButton_Close.setText(_translate("MainWindow", "Cancel"))
        self.pushButton_CreateProcess.setToolTip(_translate("MainWindow", "Open an executable"))
        self.pushButton_CreateProcess.setText(_translate("MainWindow", "Create Process[F1]"))

```

`GUI/SelectProcess.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="windowModality">
   <enum>Qt::WindowModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>443</width>
    <height>420</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Please select a Process</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QVBoxLayout" name="verticalLayout">
    <item>
     <layout class="QHBoxLayout" name="horizontalLayout">
      <item>
       <widget class="QLabel" name="label">
        <property name="text">
         <string>Name or PID of the Process:</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QLineEdit" name="lineEdit_SearchProcess"/>
      </item>
     </layout>
    </item>
    <item>
     <widget class="QTableWidget" name="tableWidget_ProcessTable">
      <property name="sizePolicy">
       <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
        <horstretch>0</horstretch>
        <verstretch>0</verstretch>
       </sizepolicy>
      </property>
      <property name="autoFillBackground">
       <bool>false</bool>
      </property>
      <property name="sizeAdjustPolicy">
       <enum>QAbstractScrollArea::AdjustIgnored</enum>
      </property>
      <property name="editTriggers">
       <set>QAbstractItemView::NoEditTriggers</set>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::SingleSelection</enum>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectRows</enum>
      </property>
      <property name="sortingEnabled">
       <bool>true</bool>
      </property>
      <property name="wordWrap">
       <bool>false</bool>
      </property>
      <attribute name="horizontalHeaderDefaultSectionSize">
       <number>70</number>
      </attribute>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <attribute name="verticalHeaderStretchLastSection">
       <bool>false</bool>
      </attribute>
      <column>
       <property name="text">
        <string>PID</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Username</string>
       </property>
      </column>
      <column>
       <property name="text">
        <string>Process Name</string>
       </property>
       <property name="textAlignment">
        <set>AlignLeading|AlignVCenter</set>
       </property>
      </column>
     </widget>
    </item>
    <item>
     <layout class="QHBoxLayout" name="horizontalLayout_2">
      <item>
       <spacer name="horizontalSpacer_3">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Open">
        <property name="toolTip">
         <string>Attach to the selected process</string>
        </property>
        <property name="text">
         <string>Open</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Close">
        <property name="text">
         <string>Cancel</string>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_4">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
     </layout>
    </item>
    <item>
     <layout class="QHBoxLayout" name="horizontalLayout_3">
      <item>
       <spacer name="horizontalSpacer">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_CreateProcess">
        <property name="toolTip">
         <string>Open an executable</string>
        </property>
        <property name="text">
         <string>Create Process[F1]</string>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer_2">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>40</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
     </layout>
    </item>
   </layout>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/Session/session.py`:

```py
import os
from enum import IntFlag, auto

from PyQt6.QtCore import QObject
from PyQt6.QtGui import QCloseEvent
from PyQt6.QtWidgets import QFileDialog, QMessageBox

from GUI.States import states
from libpince import utils, debugcore
from tr.tr import TranslationConstants as tr


class SessionDataChanged(IntFlag):
    NONE = auto()
    ADDRESS_TREE = auto()
    BOOKMARKS = auto()
    NOTES = auto()
    PROCESS_NAME = auto()


def migrate_version(content: any) -> dict[str, any]:
    if not hasattr(content, "version") and type(content) == list:
        return legacy_to_v1(content)

    return content


def is_valid_session_data(content: dict[str, any]) -> bool:
    keys = ["version", "notes", "bookmarks", "address_tree", "process_name"]
    for key in keys:
        if key not in content:
            return False

    return True


def legacy_to_v1(content: list) -> dict[str, any]:
    utils.logger.info("Migrating legacy session data to version 1")
    return {"version": 1, "notes": "", "bookmarks": {}, "address_tree": content, "process_name": ""}


class Session:
    def __init__(self) -> None:
        # Anything labled with pct should be saved to the session file
        self.pct_notes: str = ""
        self.pct_bookmarks: dict[int, dict] = {}
        self.pct_version: int = 1
        self.pct_address_tree: list = []
        self.pct_process_name: str = ""
        self.data_changed = SessionDataChanged.NONE
        self.file_path: str = os.curdir
        self.last_file_name: str = ""  # process name or file name

    def save_session(self) -> bool:
        """
        Save the current session to a file.

        Args:
            None
        Returns:
            bool: True if the session was saved successfully, False otherwise.
        """

        file_path, _ = QFileDialog.getSaveFileName(
            None, tr.SAVE_PCT_FILE, self.file_path + "/" + self.last_file_name, tr.FILE_TYPES_PCT
        )
        if not file_path:
            return False

        # until address tree is model view and properly read from this new session object,
        # address tree must save its data to the session object via signal
        if self.data_changed & SessionDataChanged.ADDRESS_TREE:
            states.session_signals.on_save.emit()

        session = {
            "version": self.pct_version,
            "notes": self.pct_notes,
            "bookmarks": self.pct_bookmarks,
            "address_tree": self.pct_address_tree,
            "process_name": self.pct_process_name,
        }

        file_path = utils.append_file_extension(file_path, "pct")
        if not utils.save_file(session, file_path):
            QMessageBox.information(None, tr.ERROR, tr.FILE_SAVE_ERROR)
            return False

        self.file_path = os.path.dirname(file_path)
        self.last_file_name = os.path.basename(file_path)
        self.data_changed = SessionDataChanged.NONE
        return True

    def check_unsaved_changes(self) -> QMessageBox.StandardButton:
        if self.data_changed == SessionDataChanged.NONE:
            return QMessageBox.StandardButton.No

        unsaved_changes_result = QMessageBox.question(
            None,
            tr.SAVE_SESSION_QUESTION_TITLE,
            tr.SAVE_SESSION_QUESTION_PROMPT,
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No | QMessageBox.StandardButton.Cancel,
        )
        return unsaved_changes_result

    def load_session(self) -> bool:
        """
        Load a pct session file. Will check for unsaved changes and prompt
        the user to save them before loading a new session.
        If the user chooses to cancel, the function will return False.
        Will also attempt to migrate the session data to the latest version.

        Args:
            None
        Returns:
            bool: True if the session was loaded successfully, False otherwise.

        """

        unsaved_changes_result = self.check_unsaved_changes()
        if unsaved_changes_result == QMessageBox.StandardButton.Cancel:
            return False
        elif unsaved_changes_result == QMessageBox.StandardButton.Yes:
            if not self.save_session():
                return False

        file_path, _ = QFileDialog.getOpenFileName(
            None, tr.OPEN_PCT_FILE, self.file_path + "/" + self.last_file_name, tr.FILE_TYPES_PCT
        )
        if not file_path:
            return False

        content = utils.load_file(file_path)
        if content is None:
            QMessageBox.information(None, tr.ERROR, tr.FILE_LOAD_ERROR.format(file_path))
            return False
        content = migrate_version(content)
        if not is_valid_session_data(content):
            QMessageBox.information(None, tr.ERROR, tr.FILE_LOAD_ERROR.format(file_path))
            return False

        self.pct_version = content["version"]
        self.pct_notes = content["notes"]

        # Load bookmarks with symbol resolution
        self.pct_bookmarks = content["bookmarks"]
        self.recalculate_bookmarks()

        self.pct_address_tree = content["address_tree"]

        self.file_path = os.path.dirname(file_path)
        self.last_file_name = os.path.basename(file_path)

        states.session_signals.on_load.emit()
        self.data_changed = SessionDataChanged.NONE
        return True

    def pre_exit(self, close_event: QCloseEvent) -> None:
        """
        Event handler for the close event of the application.
        If there are unsaved changes, prompt the user to save them.
        Accepts or ignores the close event based on the user's choice.

        Args:
            close_event (QCloseEvent): The close event to be handled.
        Returns:
            None
        """

        if self.data_changed == SessionDataChanged.NONE:
            close_event.accept()
            return

        pre_exit_unsaved_changes_result = self.check_unsaved_changes()
        if pre_exit_unsaved_changes_result == QMessageBox.StandardButton.Yes:
            self.save_session()
            close_event.accept()

        elif pre_exit_unsaved_changes_result == QMessageBox.StandardButton.Cancel:
            close_event.ignore()
        else:
            close_event.accept()

    def recalculate_bookmarks(self):
        """
        Recalculate all bookmarks to update their addresses based on their symbols or region info.
        This is useful when the process has changed and the addresses may have shifted.
        Will not mark session as changed.

        Args:
            None
        Returns:
            None
        """

        region_dict = utils.get_region_dict(debugcore.currentpid)

        new_bookmarks: dict[int, dict] = {}
        for addr, value in self.pct_bookmarks.items():
            comment = value["comment"]
            symbol = value["symbol"]
            address_region_details = value["address_region_details"]
            new_addr = addr

            # We used to resolve the symbol first but parentheses in symbols causes the functions to be called
            # For instance, main() won't be resolved to main but rather the function main() will be called
            # Because of this behavior, we rely on resolving via regions
            # Resolving via regions is more reliable unless the binary has been changed
            # TODO: Resolving via symbols could be re-addressed if this behavior were fixed

            # resolve via region details
            region_name, offset, region_index = address_region_details.values()
            region = region_dict.get(region_name, None)
            if region is not None:
                new_addr = utils.safe_str_to_int(region[region_index], 16) + utils.safe_str_to_int(offset, 16)
                if new_addr == 0:
                    continue
            else:
                utils.logger.warning(f"Could not find region with name: {region_name}")
                continue

            new_bookmarks[new_addr] = {
                "symbol": symbol,
                "comment": comment,
                "address_region_details": address_region_details,
            }

        self.pct_bookmarks = new_bookmarks


class SessionManager:
    session = Session()

    @staticmethod
    def get_session() -> Session:
        return SessionManager.session

    @staticmethod
    def reset_session() -> None:
        session = SessionManager.get_session()
        # User has one last chance to save the session before resetting
        # result is ignored, because the session is going to be reset anyway
        session.check_unsaved_changes()
        SessionManager.session = Session()
        states.session_signals.new_session.emit()
        # Reset the session data changed flag
        session.data_changed = SessionDataChanged.NONE

    @staticmethod
    def save_session() -> None:
        SessionManager.get_session().save_session()

    @staticmethod
    def load_session() -> None:
        SessionManager.get_session().load_session()

    @staticmethod
    def on_process_changed() -> None:
        if debugcore.currentpid == -1:
            return

        if states.exiting:
            return

        process_name = utils.get_process_name(debugcore.currentpid)
        session = SessionManager.get_session()

        if session.pct_process_name == process_name:
            # process is the same as last one, probably process restarted / reattached
            session.recalculate_bookmarks()
            return

        if session.pct_process_name == "":
            # silently set the process name and file name if necessary
            session.pct_process_name = process_name
            if session.last_file_name == "":
                session.last_file_name = utils.append_file_extension(process_name, "pct")
            return

        if session.pct_process_name != process_name:
            # Ask if the user wants to keep the session
            keep_session_result = QMessageBox.question(
                None,
                tr.SESSION_PROCESS_CHANGED_TITLE,
                tr.SESSION_PROCESS_CHANGED_PROMPT,
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            )
            if keep_session_result == QMessageBox.StandardButton.Yes:
                session.pct_process_name = process_name
            else:
                SessionManager.reset_session()
                session.pct_process_name = process_name
                session.last_file_name = utils.append_file_extension(process_name, "pct")

```

`GUI/Settings/settings.py`:

```py
from PyQt6.QtCore import QSettings
from PyQt6.QtGui import QIcon
from PyQt6.QtWidgets import QApplication
from GUI.States import states
from GUI.Settings import themes
from tr.tr import get_locale
from libpince import debugcore, utils, typedefs
import json, os

current_settings_version = "36"  # Increase version by one if you change settings

# Due to community feedback, these signals are disabled by default: SIGUSR1, SIGUSR2, SIGPWR, SIGXCPU, SIGXFSZ, SIGSYS
default_signals = [
    ["SIGHUP", True, True],
    ["SIGINT", True, False],
    ["SIGQUIT", True, True],
    ["SIGILL", True, True],
    ["SIGTRAP", True, False],
    ["SIGABRT", True, True],
    ["SIGEMT", True, True],
    ["SIGFPE", True, True],
    ["SIGKILL", True, True],
    ["SIGBUS", True, True],
    ["SIGSEGV", True, True],
    ["SIGSYS", False, True],
    ["SIGPIPE", True, True],
    ["SIGALRM", False, True],
    ["SIGTERM", True, True],
    ["SIGURG", False, True],
    ["SIGSTOP", True, True],
    ["SIGTSTP", True, True],
    ["SIGCONT", True, True],
    ["SIGCHLD", False, True],
    ["SIGTTIN", True, True],
    ["SIGTTOU", True, True],
    ["SIGIO", False, True],
    ["SIGXCPU", False, True],
    ["SIGXFSZ", False, True],
    ["SIGVTALRM", False, True],
    ["SIGPROF", False, True],
    ["SIGWINCH", False, True],
    ["SIGLOST", True, True],
    ["SIGUSR1", False, True],
    ["SIGUSR2", False, True],
    ["SIGPWR", False, True],
    ["SIGPOLL", False, True],
    ["SIGWIND", True, True],
    ["SIGPHONE", True, True],
    ["SIGWAITING", False, True],
    ["SIGLWP", False, True],
    ["SIGDANGER", True, True],
    ["SIGGRANT", True, True],
    ["SIGRETRACT", True, True],
    ["SIGMSG", True, True],
    ["SIGSOUND", True, True],
    ["SIGSAK", True, True],
    ["SIGPRIO", False, True],
    ["SIGCANCEL", False, True],
    ["SIGINFO", True, True],
    ["EXC_BAD_ACCESS", True, True],
    ["EXC_BAD_INSTRUCTION", True, True],
    ["EXC_ARITHMETIC", True, True],
    ["EXC_EMULATION", True, True],
    ["EXC_SOFTWARE", True, True],
    ["EXC_BREAKPOINT", True, True],
    ["SIGLIBRT", False, True],
]
for x in range(32, 128):  # Add signals SIG32-SIG127
    default_signals.append([f"SIG{x}", True, True])


def init_settings():
    settings = QSettings()
    if not os.path.exists(settings.fileName()):
        set_default_settings()
    try:
        settings_version = settings.value("Misc/version", type=str)
    except Exception:
        utils.logger.exception("An exception occurred while reading settings version")
        settings_version = None
    if settings_version != current_settings_version:
        utils.logger.warning("Settings version mismatch, rolling back to the default configuration")
        settings.clear()
        set_default_settings()
    try:
        apply_settings()
    except Exception:
        utils.logger.exception("An exception occurred while loading settings, rolling back to the default configuration")
        settings.clear()
        set_default_settings()


# Please refrain from using python specific objects in settings, use json-compatible ones instead
# Using python objects causes issues when filenames change
def set_default_settings():
    settings = QSettings()
    settings.beginGroup("General")
    settings.setValue("auto_update_address_table", True)
    settings.setValue("address_table_update_interval", 500)
    settings.setValue("freeze_interval", 100)
    settings.setValue("gdb_output_mode", json.dumps([True, True, True]))
    settings.setValue("auto_attach", "")
    settings.setValue("auto_attach_regex", False)
    settings.setValue("locale", get_locale())
    settings.setValue("logo_path", "ozgurozbek/pince_small_transparent.png")
    settings.setValue("theme", themes.Themes.DEFAULT.value)
    settings.endGroup()
    settings.beginGroup("Hotkeys")
    for hotkey in states.hotkeys.get_hotkeys():
        settings.setValue(hotkey.name, hotkey.default)
    settings.endGroup()
    settings.beginGroup("CodeInjection")
    settings.setValue("code_injection_method", typedefs.INJECTION_METHOD.DLOPEN)
    settings.endGroup()
    settings.beginGroup("MemoryView")
    settings.setValue("show_memory_view_on_stop", False)
    settings.setValue("instructions_per_scroll", 3)
    settings.setValue("bytes_per_scroll", 0x40)
    settings.endGroup()
    settings.beginGroup("Debug")
    settings.setValue("gdb_path", typedefs.PATHS.GDB)
    settings.setValue("gdb_logging", False)
    settings.setValue("interrupt_signal", "SIGINT")
    settings.setValue("handle_signals", json.dumps(default_signals))
    settings.endGroup()
    settings.beginGroup("Java")
    settings.setValue("ignore_segfault", True)
    settings.endGroup()
    settings.beginGroup("Misc")
    settings.setValue("version", current_settings_version)
    settings.endGroup()
    apply_settings()


def apply_settings():
    settings = QSettings()
    states.update_table = settings.value("General/auto_update_address_table", type=bool)
    states.table_update_interval = settings.value("General/address_table_update_interval", type=int)
    states.freeze_interval = settings.value("General/freeze_interval", type=int)
    gdb_output_mode = json.loads(settings.value("General/gdb_output_mode", type=str))
    gdb_output_mode = typedefs.gdb_output_mode(*gdb_output_mode)
    states.auto_attach = settings.value("General/auto_attach", type=str)
    states.auto_attach_regex = settings.value("General/auto_attach_regex", type=bool)
    QApplication.setWindowIcon(
        QIcon(os.path.join(utils.get_logo_directory(), settings.value("General/logo_path", type=str)))
    )
    QApplication.setPalette(themes.get_theme(settings.value("General/theme", type=str)))
    debugcore.set_gdb_output_mode(gdb_output_mode)
    for hotkey in states.hotkeys.get_hotkeys():
        try:
            hotkey.change_key(settings.value("Hotkeys/" + hotkey.name))
        except:
            # if the hotkey cannot be applied for whatever reason, reset it to the default
            settings.setValue("Hotkeys/" + hotkey.name, hotkey.default)
            hotkey.change_key(hotkey.default)
    states.show_memory_view_on_stop = settings.value("MemoryView/show_memory_view_on_stop", type=bool)
    states.instructions_per_scroll = settings.value("MemoryView/instructions_per_scroll", type=int)
    states.bytes_per_scroll = settings.value("MemoryView/bytes_per_scroll", type=int)
    states.gdb_path = settings.value("Debug/gdb_path", type=str)
    if debugcore.gdb_initialized:
        apply_after_init()
    states.setting_signals.changed.emit()


def apply_after_init():
    settings = QSettings()
    states.exp_cache.clear()
    states.gdb_logging = settings.value("Debug/gdb_logging", type=bool)
    interrupt_signal = settings.value("Debug/interrupt_signal", type=str)
    handle_signals = json.loads(settings.value("Debug/handle_signals", type=str))
    java_ignore_segfault = settings.value("Java/ignore_segfault", type=bool)
    debugcore.set_logging(states.gdb_logging)

    # Don't handle signals if a process isn't present, a small optimization to gain time on launch and detach
    if debugcore.currentpid != -1:
        debugcore.handle_signals(handle_signals)
        # Not a great method but okayish until the implementation of the libpince engine and the java dissector
        # "jps" command could be used instead if we ever need to install openjdk
        if java_ignore_segfault and utils.get_process_name(debugcore.currentpid).startswith("java"):
            debugcore.handle_signal("SIGSEGV", False, True)
        debugcore.set_interrupt_signal(interrupt_signal)  # Needs to be called after handle_signals

```

`GUI/Settings/themes.py`:

```py
from PyQt6.QtGui import QColor, QPalette
from tr.tr import TranslationConstants as tr
from enum import Enum
from collections import OrderedDict
from libpince import utils

# For settings
class Themes(Enum):
    DARK = "dark"
    LIGHT = "light"
    DEFAULT = "default"
    WONG = "wong"


# For translations
theme_strings = OrderedDict(
    [
        (Themes.DARK.value, tr.DARK),
        (Themes.LIGHT.value, tr.LIGHT),
        (Themes.DEFAULT.value, tr.SYSTEM_DEFAULT),
        (Themes.WONG.value, tr.WONG),
    ]
)

grp_dict = {
    "ACTIVE": QPalette.ColorGroup.Active,
    "INACTIVE": QPalette.ColorGroup.Inactive,
    "DISABLED": QPalette.ColorGroup.Disabled,
}

role_dict = {
    "WINDOW_TEXT": QPalette.ColorRole.WindowText,
    "BUTTON": QPalette.ColorRole.Button,
    "LIGHT": QPalette.ColorRole.Light,
    "MID_LIGHT": QPalette.ColorRole.Midlight,
    "DARK": QPalette.ColorRole.Dark,
    "MID": QPalette.ColorRole.Mid,
    "TEXT": QPalette.ColorRole.Text,
    "BRIGHT_TEXT": QPalette.ColorRole.BrightText,
    "BUTTON_TEXT": QPalette.ColorRole.ButtonText,
    "BASE": QPalette.ColorRole.Base,
    "WINDOW": QPalette.ColorRole.Window,
    "SHADOW": QPalette.ColorRole.Shadow,
    "HIGHLIGHT": QPalette.ColorRole.Highlight,
    "HIGHLIGHTED_TEXT": QPalette.ColorRole.HighlightedText,
    "LINK": QPalette.ColorRole.Link,
    "LINK_VISITED": QPalette.ColorRole.LinkVisited,
    "ALTERNATE_BASE": QPalette.ColorRole.AlternateBase,
    "TOOLTIP_BASE": QPalette.ColorRole.ToolTipBase,
    "TOOLTIP_TEXT": QPalette.ColorRole.ToolTipText,
    "PLACEHOLDER_TEXT": QPalette.ColorRole.PlaceholderText,
}


def get_theme(theme_name):
    """Returns a customized theme based on the specified theme choice

    Args:
        theme_name (str): Predefined theme chosen from Themes

    Returns:
        QPalette: Complete color palette swap for the app
    """
    match theme_name:
        case Themes.DARK.value:
            dup_dict = {
                "WINDOW_TEXT": "#FFFFFF",
                "BUTTON": "#241F31",
                "LIGHT": "#80FFFFFF",
                "MID_LIGHT": "#2D263D",
                "DARK": "#80000000",
                "MID": "#000000",
                "TEXT": "#FFFFFF",
                "BRIGHT_TEXT": "#FFFFFF",
                "BUTTON_TEXT": "#FFFFFF",
                "BASE": "#000000",
                "WINDOW": "#241F31",
                "SHADOW": "#000000",
                "HIGHLIGHT": "#308CC6",
                "HIGHLIGHTED_TEXT": "#FFFFFF",
                "LINK": "#0000FF",
                "LINK_VISITED": "#FF00FF",
                "ALTERNATE_BASE": "#120F18",
                "TOOLTIP_BASE": "#FFFFDC",
                "TOOLTIP_TEXT": "#000000",
                "PLACEHOLDER_TEXT": "#80FFFFFF",
            }

            dark_dict = {
                "ACTIVE": dup_dict,
                "INACTIVE": dup_dict,
                "DISABLED": {
                    "WINDOW_TEXT": "#80FFFFFF",
                    "BUTTON": "#241F31",
                    "LIGHT": "#362E49",
                    "MID_LIGHT": "#2D263D",
                    "DARK": "#120F18",
                    "MID": "#181521",
                    "TEXT": "#44414A",
                    "BRIGHT_TEXT": "#FFFFFF",
                    "BUTTON_TEXT": "#80FFFFFF",
                    "BASE": "#241F31",
                    "WINDOW": "#241F31",
                    "SHADOW": "#000000",
                    "HIGHLIGHT": "#919191",
                    "HIGHLIGHTED_TEXT": "#FFFFFF",
                    "LINK": "#0000FF",
                    "LINK_VISITED": "#FF00FF",
                    "ALTERNATE_BASE": "#241F31",
                    "TOOLTIP_BASE": "#FFFFDC",
                    "TOOLTIP_TEXT": "#000000",
                    "PLACEHOLDER_TEXT": "#80FFFFFF",
                },
            }
            return apply_palette(dark_dict)
        case Themes.LIGHT.value:
            dup_dict = {
                "WINDOW_TEXT": "#000000",
                "BUTTON": "#EFEFEF",
                "LIGHT": "#FFFFFF",
                "MID_LIGHT": "#CACACA",
                "DARK": "#5E5C64",
                "MID": "#B8B8B8",
                "TEXT": "#000000",
                "BRIGHT_TEXT": "#FFFFFF",
                "BUTTON_TEXT": "#000000",
                "BASE": "#FFFFFF",
                "WINDOW": "#EFEFEF",
                "SHADOW": "#767676",
                "HIGHLIGHT": "#308CC6",
                "HIGHLIGHTED_TEXT": "#FFFFFF",
                "LINK": "#0000FF",
                "LINK_VISITED": "#FF00FF",
                "ALTERNATE_BASE": "#F7F7F7",
                "TOOLTIP_BASE": "#FFFFDC",
                "TOOLTIP_TEXT": "#000000",
                "PLACEHOLDER_TEXT": "#80000000",
            }

            light_dict = {
                "ACTIVE": dup_dict,
                "INACTIVE": dup_dict,
                "DISABLED": {
                    "WINDOW_TEXT": "#BEBEBE",
                    "BUTTON": "#EFEFEF",
                    "LIGHT": "#FFFFFF",
                    "MID_LIGHT": "#CACACA",
                    "DARK": "#BEBEBE",
                    "MID": "#B8B8B8",
                    "TEXT": "#BEBEBE",
                    "BRIGHT_TEXT": "#FFFFFF",
                    "BUTTON_TEXT": "#BEBEBE",
                    "BASE": "#EFEFEF",
                    "WINDOW": "#EFEFEF",
                    "SHADOW": "#B1B1B1",
                    "HIGHLIGHT": "#919191",
                    "HIGHLIGHTED_TEXT": "#FFFFFF",
                    "LINK": "#0000FF",
                    "LINK_VISITED": "#FF00FF",
                    "ALTERNATE_BASE": "#F7F7F7",
                    "TOOLTIP_BASE": "#FFFFDC",
                    "TOOLTIP_TEXT": "#000000",
                    "PLACEHOLDER_TEXT": "#80000000",
                },
            }
            return apply_palette(light_dict)
        case Themes.DEFAULT.value:
            palette_with_fix = QPalette()
            palette_with_fix.setColor(
                QPalette.ColorRole.PlaceholderText, palette_with_fix.color(QPalette.ColorRole.Text).darker()
            )
            return palette_with_fix
        case Themes.WONG.value:
            dup_dict = {
                "WINDOW_TEXT": "#000000",
                "BUTTON": "#E69F00",
                "LIGHT": "#FFFFFF",
                "MID_LIGHT": "#000000",
                "DARK": "#000000",
                "MID": "#000000",
                "TEXT": "#000000",
                "BRIGHT_TEXT": "#FFFFFF",
                "BUTTON_TEXT": "#000000",
                "BASE": "#E69F00",
                "WINDOW": "#009E73",
                "SHADOW": "#009E73",
                "HIGHLIGHT": "#0072B2",
                "HIGHLIGHTED_TEXT": "#FFFFFF",
                "LINK": "#56B4E9",
                "LINK_VISITED": "#CC79A7",
                "ALTERNATE_BASE": "#E69F00",
                "TOOLTIP_BASE": "#FFFFDC",
                "TOOLTIP_TEXT": "#000000",
                "PLACEHOLDER_TEXT": "#80000000",
            }

            wong_dict = {
                "ACTIVE": dup_dict,
                "INACTIVE": dup_dict,
                "DISABLED": {
                    "WINDOW_TEXT": "#80000000",
                    "BUTTON": "#E69F00",
                    "LIGHT": "#FFFFFF",
                    "MID_LIGHT": "#FFFFFF",
                    "DARK": "#FFFFFF",
                    "MID": "#FFFFFF",
                    "TEXT": "#FFFFFF",
                    "BRIGHT_TEXT": "#000000",
                    "BUTTON_TEXT": "#80000000",
                    "BASE": "#E69F00",
                    "WINDOW": "#000000",
                    "SHADOW": "#F0E442",
                    "HIGHLIGHT": "#919191",
                    "HIGHLIGHTED_TEXT": "#000000",
                    "LINK": "#56b4E9",
                    "LINK_VISITED": "#CC79A7",
                    "ALTERNATE_BASE": "#919191",
                    "TOOLTIP_BASE": "#000000",
                    "TOOLTIP_TEXT": "#FFFFFF",
                    "PLACEHOLDER_TEXT": "#80000000",
                },
            }
            return apply_palette(wong_dict)
        case _:
            utils.logger.error("There was an error parsing themes")


def apply_palette(theme_dict):
    """Creates a palette based on the given theme dictionary

    Args:
        theme_dict (dict): See the usage in get_theme

    Return:
        QPalette: Self-explanatory
    """
    new_palette = QPalette()

    for group in theme_dict:
        cur_grp = grp_dict[group]

        for color in theme_dict[group]:
            cur_role = role_dict[color]
            new_palette.setColor(cur_grp, cur_role, QColor(theme_dict[group][color]))

    return new_palette

```

`GUI/StackTraceInfoWidget.py`:

```py
# Form implementation generated from reading ui file 'StackTraceInfoWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(768, 440)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(parent=Form)
        self.splitter.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtWidgets.QWidget(parent=self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.listWidget_ReturnAddresses = QtWidgets.QListWidget(parent=self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.listWidget_ReturnAddresses.setFont(font)
        self.listWidget_ReturnAddresses.setObjectName("listWidget_ReturnAddresses")
        self.verticalLayout.addWidget(self.listWidget_ReturnAddresses)
        self.layoutWidget1 = QtWidgets.QWidget(parent=self.splitter)
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget1)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label_2 = QtWidgets.QLabel(parent=self.layoutWidget1)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_2.addWidget(self.label_2)
        self.textBrowser_Info = QtWidgets.QTextBrowser(parent=self.layoutWidget1)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.textBrowser_Info.setFont(font)
        self.textBrowser_Info.setObjectName("textBrowser_Info")
        self.verticalLayout_2.addWidget(self.textBrowser_Info)
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "StackTrace Information"))
        self.label.setText(_translate("Form", "Return Address"))
        self.label_2.setText(_translate("Form", "Info"))

```

`GUI/StackTraceInfoWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>768</width>
    <height>440</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>StackTrace Information</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>Return Address</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QListWidget" name="listWidget_ReturnAddresses">
         <property name="font">
          <font>
           <family>Monospace</family>
          </font>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>Info</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QTextBrowser" name="textBrowser_Info">
         <property name="font">
          <font>
           <family>Monospace</family>
          </font>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/States/states.py`:

```py
from PyQt6.QtCore import QThreadPool
from GUI.Utils import guitypedefs

process_signals = guitypedefs.ProcessSignals()
setting_signals = guitypedefs.SettingSignals()
session_signals = guitypedefs.SessionSignals()

status_thread = guitypedefs.CheckInferiorStatus()
status_thread.start()

threadpool = QThreadPool()
# Placeholder number, may have to be changed in the future
threadpool.setMaxThreadCount(10)

# GDB expression cache
# TODO: Try to find a fast and non-gdb way to calculate symbols so we don't need this
# This is one of the few tricks we do to minimize examine_expression calls
# This solution might bring problems if the symbols are changing frequently
# Pressing the refresh button in the address table or attaching to a new process will clear this cache
# Currently only used in address_table_loop
exp_cache: dict[str, str] = {}

# Set to True when app is about to exit
exiting = False

hotkeys = guitypedefs.Hotkeys()

# The variables below are used for quick global access to settings for optimization or simplification purposes
# Initial values of these variables doesn't matter, they'll be set when apply_settings function is called
# Please don't throw every single settings variable here, only add variables that needs to be accessed frequently
update_table = False
table_update_interval = 0
freeze_interval = 0
auto_attach = ""
auto_attach_regex = False
show_memory_view_on_stop = False
instructions_per_scroll = 0
bytes_per_scroll = 0
gdb_path = ""
gdb_logging = False

```

`GUI/TableViews/AsciiView.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from GUI.TableViews.HexView import QHexView
from GUI.ItemDelegates.HexDelegate import QHexDelegate
from libpince import typedefs


class QAsciiView(QHexView):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.write_type = typedefs.VALUE_INDEX.STRING_UTF8
        self.delegate = QHexDelegate(1, ".+")
        self.delegate.closeEditor.connect(self.on_editor_close)
        self.setItemDelegate(self.delegate)

```

`GUI/TableViews/HexView.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt6.QtGui import QKeyEvent, QWheelEvent
from PyQt6.QtWidgets import QTableView, QAbstractItemView
from PyQt6.QtCore import QItemSelectionModel, QModelIndex, Qt, pyqtSignal
from GUI.ItemDelegates.HexDelegate import QHexDelegate
from GUI.AbstractTableModels.HexModel import QHexModel
from libpince import utils, debugcore, typedefs


class QHexView(QTableView):
    scroll_requested = pyqtSignal(int)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWordWrap(False)
        self.horizontalHeader().setVisible(False)
        self.verticalHeader().setVisible(False)
        self.setShowGrid(False)
        self.setEditTriggers(QAbstractItemView.EditTrigger.DoubleClicked)
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setAutoScroll(False)
        self.write_type = typedefs.VALUE_INDEX.AOB
        self.delegate = QHexDelegate()
        self.delegate.closeEditor.connect(self.on_editor_close)
        self.setItemDelegate(self.delegate)

    def adjust_cell_size(self, char_count: int):
        font_metrics = self.fontMetrics()
        col_width = font_metrics.horizontalAdvance("F" * char_count) + 4 * char_count
        row_height = font_metrics.height()
        self.horizontalHeader().setMinimumSectionSize(col_width)
        self.horizontalHeader().setDefaultSectionSize(col_width)
        self.horizontalHeader().setMaximumSectionSize(col_width)
        self.verticalHeader().setMinimumSectionSize(row_height)
        self.verticalHeader().setDefaultSectionSize(row_height)
        self.verticalHeader().setMaximumSectionSize(row_height)

    def wheelEvent(self, event: QWheelEvent):
        event.ignore()

    def keyPressEvent(self, event: QKeyEvent):
        if event.key() == Qt.Key.Key_Return and self.state() != QAbstractItemView.State.EditingState:
            self.edit(self.currentIndex())
        elif event.key() == Qt.Key.Key_Up and self.currentIndex().row() == 0:
            self.scroll_requested.emit(-1)
        elif event.key() == Qt.Key.Key_Down and self.currentIndex().row() == self.model().rowCount() - 1:
            self.scroll_requested.emit(1)
        else:
            return super().keyPressEvent(event)

    def selectionCommand(self, index: QModelIndex, event: QKeyEvent):
        if event and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            # Disable multi-selection when Ctrl key is pressed
            return QItemSelectionModel.SelectionFlag.ClearAndSelect
        else:
            return super().selectionCommand(index, event)

    def resize_to_contents(self):
        size = self.columnWidth(0) * self.model().columnCount()
        self.setMinimumWidth(size)
        self.setMaximumWidth(size)

    def on_editor_close(self):
        if not self.delegate.editor.isModified():
            return
        model: QHexModel = self.model()
        cell = self.currentIndex()
        index = cell.row() * model.columnCount() + cell.column()
        address = utils.modulo_address(model.current_address + index, debugcore.inferior_arch)
        data = self.delegate.editor.text()
        if self.write_type == typedefs.VALUE_INDEX.AOB:
            data = data.upper()
        debugcore.write_memory(address, self.write_type, data, False)
        model.update_index(index, data)

```

`GUI/TextEditDialog.py`:

```py
# Form implementation generated from reading ui file 'TextEditDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(568, 529)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.textEdit = QtWidgets.QTextEdit(parent=Dialog)
        self.textEdit.setObjectName("textEdit")
        self.gridLayout.addWidget(self.textEdit, 0, 0, 1, 1)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 1, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Dialog"))
        self.textEdit.setPlaceholderText(_translate("Dialog", "Hit Esc to cancel and Ctrl+Enter to accept"))

```

`GUI/TextEditDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>568</width>
    <height>529</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Dialog</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTextEdit" name="textEdit">
     <property name="placeholderText">
      <string>Hit Esc to cancel and Ctrl+Enter to accept</string>
     </property>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/TraceInstructionsPromptDialog.py`:

```py
# Form implementation generated from reading ui file 'TraceInstructionsPromptDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(269, 294)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.lineEdit_MaxTraceCount = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_MaxTraceCount.setText("1000")
        self.lineEdit_MaxTraceCount.setObjectName("lineEdit_MaxTraceCount")
        self.verticalLayout.addWidget(self.lineEdit_MaxTraceCount)
        self.label_3 = QtWidgets.QLabel(parent=Dialog)
        self.label_3.setObjectName("label_3")
        self.verticalLayout.addWidget(self.label_3)
        self.lineEdit_TriggerCondition = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_TriggerCondition.setObjectName("lineEdit_TriggerCondition")
        self.verticalLayout.addWidget(self.lineEdit_TriggerCondition)
        self.label_2 = QtWidgets.QLabel(parent=Dialog)
        self.label_2.setObjectName("label_2")
        self.verticalLayout.addWidget(self.label_2)
        self.lineEdit_StopCondition = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_StopCondition.setObjectName("lineEdit_StopCondition")
        self.verticalLayout.addWidget(self.lineEdit_StopCondition)
        self.checkBox_StepOver = QtWidgets.QCheckBox(parent=Dialog)
        self.checkBox_StepOver.setObjectName("checkBox_StepOver")
        self.verticalLayout.addWidget(self.checkBox_StepOver)
        self.checkBox_StopAfterTrace = QtWidgets.QCheckBox(parent=Dialog)
        self.checkBox_StopAfterTrace.setObjectName("checkBox_StopAfterTrace")
        self.verticalLayout.addWidget(self.checkBox_StopAfterTrace)
        self.checkBox_CollectRegisters = QtWidgets.QCheckBox(parent=Dialog)
        self.checkBox_CollectRegisters.setChecked(True)
        self.checkBox_CollectRegisters.setObjectName("checkBox_CollectRegisters")
        self.verticalLayout.addWidget(self.checkBox_CollectRegisters)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.verticalLayout.addWidget(self.buttonBox)
        self.gridLayout.addLayout(self.verticalLayout, 0, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Parameters for tracing"))
        self.label.setToolTip(_translate("Dialog", "Number of the instructions that\'ll be traced"))
        self.label.setText(_translate("Dialog", "Max trace count(1 or greater):"))
        self.label_3.setToolTip(_translate("Dialog", "Tracing will start if this condition is met"))
        self.label_3.setText(_translate("Dialog", "Trigger condition(Optional, gdb expression):"))
        self.label_2.setToolTip(_translate("Dialog", "Tracing will stop whenever this condition is met"))
        self.label_2.setText(_translate("Dialog", "Stop condition(Optional, gdb expression):"))
        self.checkBox_StepOver.setText(_translate("Dialog", "Step over instead of single step"))
        self.checkBox_StopAfterTrace.setText(_translate("Dialog", "Stop when tracing ends"))
        self.checkBox_CollectRegisters.setText(_translate("Dialog", "Collect registers"))

```

`GUI/TraceInstructionsPromptDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>269</width>
    <height>294</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Parameters for tracing</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="toolTip">
        <string>Number of the instructions that'll be traced</string>
       </property>
       <property name="text">
        <string>Max trace count(1 or greater):</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_MaxTraceCount">
       <property name="text">
        <string notr="true">1000</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="label_3">
       <property name="toolTip">
        <string>Tracing will start if this condition is met</string>
       </property>
       <property name="text">
        <string>Trigger condition(Optional, gdb expression):</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_TriggerCondition"/>
     </item>
     <item>
      <widget class="QLabel" name="label_2">
       <property name="toolTip">
        <string>Tracing will stop whenever this condition is met</string>
       </property>
       <property name="text">
        <string>Stop condition(Optional, gdb expression):</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLineEdit" name="lineEdit_StopCondition"/>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_StepOver">
       <property name="text">
        <string>Step over instead of single step</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_StopAfterTrace">
       <property name="text">
        <string>Stop when tracing ends</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_CollectRegisters">
       <property name="text">
        <string>Collect registers</string>
       </property>
       <property name="checked">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="standardButtons">
        <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/TraceInstructionsWaitWidget.py`:

```py
# Form implementation generated from reading ui file 'TraceInstructionsWaitWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(194, 93)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label_Animated = QtWidgets.QLabel(parent=Form)
        self.label_Animated.setText("")
        self.label_Animated.setObjectName("label_Animated")
        self.verticalLayout.addWidget(self.label_Animated)
        self.label_StatusText = QtWidgets.QLabel(parent=Form)
        self.label_StatusText.setText("")
        self.label_StatusText.setObjectName("label_StatusText")
        self.verticalLayout.addWidget(self.label_StatusText)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.pushButton_Cancel = QtWidgets.QPushButton(parent=Form)
        self.pushButton_Cancel.setObjectName("pushButton_Cancel")
        self.horizontalLayout.addWidget(self.pushButton_Cancel)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.gridLayout.addLayout(self.verticalLayout, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Tracer Status"))
        self.pushButton_Cancel.setText(_translate("Form", "Cancel"))

```

`GUI/TraceInstructionsWaitWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>194</width>
    <height>93</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Tracer Status</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QLabel" name="label_Animated">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="label_StatusText">
       <property name="text">
        <string/>
       </property>
      </widget>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout">
       <item>
        <spacer name="horizontalSpacer">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
       <item>
        <widget class="QPushButton" name="pushButton_Cancel">
         <property name="text">
          <string>Cancel</string>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_2">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/TraceInstructionsWindow.py`:

```py
# Form implementation generated from reading ui file 'TraceInstructionsWindow.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(704, 545)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter = QtWidgets.QSplitter(parent=self.centralwidget)
        self.splitter.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.splitter.setObjectName("splitter")
        self.treeWidget_InstructionInfo = QtWidgets.QTreeWidget(parent=self.splitter)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.treeWidget_InstructionInfo.setFont(font)
        self.treeWidget_InstructionInfo.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.treeWidget_InstructionInfo.setObjectName("treeWidget_InstructionInfo")
        self.treeWidget_InstructionInfo.headerItem().setText(0, "1")
        self.treeWidget_InstructionInfo.header().setVisible(False)
        self.textBrowser_RegisterInfo = QtWidgets.QTextBrowser(parent=self.splitter)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.textBrowser_RegisterInfo.setFont(font)
        self.textBrowser_RegisterInfo.setObjectName("textBrowser_RegisterInfo")
        self.gridLayout.addWidget(self.splitter, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 704, 22))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(parent=self.menubar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionOpen = QtGui.QAction(parent=MainWindow)
        self.actionOpen.setObjectName("actionOpen")
        self.actionSave = QtGui.QAction(parent=MainWindow)
        self.actionSave.setObjectName("actionSave")
        self.actionSave_as_a_text_file = QtGui.QAction(parent=MainWindow)
        self.actionSave_as_a_text_file.setObjectName("actionSave_as_a_text_file")
        self.menuFile.addAction(self.actionOpen)
        self.menuFile.addAction(self.actionSave)
        self.menubar.addAction(self.menuFile.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Tracer"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.actionOpen.setText(_translate("MainWindow", "Open"))
        self.actionSave.setText(_translate("MainWindow", "Save"))
        self.actionSave_as_a_text_file.setText(_translate("MainWindow", "Save as a text file"))

```

`GUI/TraceInstructionsWindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>704</width>
    <height>545</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Tracer</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QGridLayout" name="gridLayout">
    <item row="0" column="0">
     <widget class="QSplitter" name="splitter">
      <property name="orientation">
       <enum>Qt::Horizontal</enum>
      </property>
      <widget class="QTreeWidget" name="treeWidget_InstructionInfo">
       <property name="font">
        <font>
         <family>Monospace</family>
        </font>
       </property>
       <property name="editTriggers">
        <set>QAbstractItemView::NoEditTriggers</set>
       </property>
       <attribute name="headerVisible">
        <bool>false</bool>
       </attribute>
       <column>
        <property name="text">
         <string notr="true">1</string>
        </property>
       </column>
      </widget>
      <widget class="QTextBrowser" name="textBrowser_RegisterInfo">
       <property name="font">
        <font>
         <family>Monospace</family>
        </font>
       </property>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>704</width>
     <height>22</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>File</string>
    </property>
    <addaction name="actionOpen"/>
    <addaction name="actionSave"/>
   </widget>
   <addaction name="menuFile"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <action name="actionOpen">
   <property name="text">
    <string>Open</string>
   </property>
  </action>
  <action name="actionSave">
   <property name="text">
    <string>Save</string>
   </property>
  </action>
  <action name="actionSave_as_a_text_file">
   <property name="text">
    <string>Save as a text file</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/TrackBreakpointWidget.py`:

```py
# Form implementation generated from reading ui file 'TrackBreakpointWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(549, 437)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_TrackInfo = QtWidgets.QTableWidget(parent=Form)
        self.tableWidget_TrackInfo.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_TrackInfo.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_TrackInfo.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_TrackInfo.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollMode.ScrollPerPixel)
        self.tableWidget_TrackInfo.setWordWrap(False)
        self.tableWidget_TrackInfo.setObjectName("tableWidget_TrackInfo")
        self.tableWidget_TrackInfo.setColumnCount(4)
        self.tableWidget_TrackInfo.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_TrackInfo.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_TrackInfo.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_TrackInfo.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_TrackInfo.setHorizontalHeaderItem(3, item)
        self.tableWidget_TrackInfo.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_TrackInfo.verticalHeader().setVisible(False)
        self.tableWidget_TrackInfo.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_TrackInfo.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_TrackInfo, 0, 0, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pushButton_Stop = QtWidgets.QPushButton(parent=Form)
        self.pushButton_Stop.setObjectName("pushButton_Stop")
        self.horizontalLayout.addWidget(self.pushButton_Stop)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.comboBox_ValueType = QtWidgets.QComboBox(parent=Form)
        self.comboBox_ValueType.setToolTip("")
        self.comboBox_ValueType.setSizeAdjustPolicy(QtWidgets.QComboBox.SizeAdjustPolicy.AdjustToContents)
        self.comboBox_ValueType.setObjectName("comboBox_ValueType")
        self.horizontalLayout.addWidget(self.comboBox_ValueType)
        self.gridLayout.addLayout(self.horizontalLayout, 1, 0, 1, 1)

        self.retranslateUi(Form)
        self.comboBox_ValueType.setCurrentIndex(-1)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        item = self.tableWidget_TrackInfo.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Count"))
        item = self.tableWidget_TrackInfo.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_TrackInfo.horizontalHeaderItem(2)
        item.setText(_translate("Form", "Value"))
        item = self.tableWidget_TrackInfo.horizontalHeaderItem(3)
        item.setText(_translate("Form", "Source"))
        self.pushButton_Stop.setText(_translate("Form", "Stop"))

```

`GUI/TrackBreakpointWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>549</width>
    <height>437</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTableWidget" name="tableWidget_TrackInfo">
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="horizontalScrollMode">
      <enum>QAbstractItemView::ScrollPerPixel</enum>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>Count</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Value</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Source</string>
      </property>
     </column>
    </widget>
   </item>
   <item row="1" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QPushButton" name="pushButton_Stop">
       <property name="text">
        <string>Stop</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QComboBox" name="comboBox_ValueType">
       <property name="toolTip">
        <string/>
       </property>
       <property name="currentIndex">
        <number>-1</number>
       </property>
       <property name="sizeAdjustPolicy">
        <enum>QComboBox::AdjustToContents</enum>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/TrackSelectorDialog.py`:

```py
# Form implementation generated from reading ui file 'TrackSelectorDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(165, 99)
        Dialog.setWindowTitle("")
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.pushButton_Pointer = QtWidgets.QPushButton(parent=Dialog)
        self.pushButton_Pointer.setObjectName("pushButton_Pointer")
        self.verticalLayout.addWidget(self.pushButton_Pointer)
        self.pushButton_Pointed = QtWidgets.QPushButton(parent=Dialog)
        self.pushButton_Pointed.setObjectName("pushButton_Pointed")
        self.verticalLayout.addWidget(self.pushButton_Pointed)
        self.gridLayout.addLayout(self.verticalLayout, 0, 0, 1, 1)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        self.label.setText(_translate("Dialog", "Select an address to track"))
        self.pushButton_Pointer.setText(_translate("Dialog", "Pointer"))
        self.pushButton_Pointed.setText(_translate("Dialog", "Pointed Address"))

```

`GUI/TrackSelectorDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>165</width>
    <height>99</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string/>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Select an address to track</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Pointer">
       <property name="text">
        <string>Pointer</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Pointed">
       <property name="text">
        <string>Pointed Address</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/TrackWatchpointWidget.py`:

```py
# Form implementation generated from reading ui file 'TrackWatchpointWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(530, 493)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.splitter_2 = QtWidgets.QSplitter(parent=Form)
        self.splitter_2.setOrientation(QtCore.Qt.Orientation.Vertical)
        self.splitter_2.setObjectName("splitter_2")
        self.splitter = QtWidgets.QSplitter(parent=self.splitter_2)
        self.splitter.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.splitter.setObjectName("splitter")
        self.layoutWidget = QtWidgets.QWidget(parent=self.splitter)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.tableWidget_Opcodes = QtWidgets.QTableWidget(parent=self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_Opcodes.setFont(font)
        self.tableWidget_Opcodes.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_Opcodes.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_Opcodes.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_Opcodes.setWordWrap(False)
        self.tableWidget_Opcodes.setObjectName("tableWidget_Opcodes")
        self.tableWidget_Opcodes.setColumnCount(2)
        self.tableWidget_Opcodes.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Opcodes.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Opcodes.setHorizontalHeaderItem(1, item)
        self.tableWidget_Opcodes.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Opcodes.verticalHeader().setVisible(False)
        self.tableWidget_Opcodes.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Opcodes.verticalHeader().setMinimumSectionSize(16)
        self.verticalLayout.addWidget(self.tableWidget_Opcodes)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pushButton_Refresh = QtWidgets.QPushButton(parent=self.layoutWidget)
        self.pushButton_Refresh.setObjectName("pushButton_Refresh")
        self.horizontalLayout.addWidget(self.pushButton_Refresh)
        self.pushButton_Stop = QtWidgets.QPushButton(parent=self.layoutWidget)
        self.pushButton_Stop.setObjectName("pushButton_Stop")
        self.horizontalLayout.addWidget(self.pushButton_Stop)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.textBrowser_Info = QtWidgets.QTextBrowser(parent=self.splitter)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.textBrowser_Info.setFont(font)
        self.textBrowser_Info.setObjectName("textBrowser_Info")
        self.textBrowser_Disassemble = QtWidgets.QTextBrowser(parent=self.splitter_2)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.textBrowser_Disassemble.setFont(font)
        self.textBrowser_Disassemble.setObjectName("textBrowser_Disassemble")
        self.gridLayout.addWidget(self.splitter_2, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        item = self.tableWidget_Opcodes.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Count"))
        item = self.tableWidget_Opcodes.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Address"))
        self.pushButton_Refresh.setText(_translate("Form", "Refresh"))
        self.pushButton_Stop.setText(_translate("Form", "Stop"))

```

`GUI/TrackWatchpointWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>530</width>
    <height>493</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Form</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QSplitter" name="splitter_2">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <widget class="QSplitter" name="splitter">
      <property name="orientation">
       <enum>Qt::Horizontal</enum>
      </property>
      <widget class="QWidget" name="layoutWidget">
       <layout class="QVBoxLayout" name="verticalLayout">
        <item>
         <widget class="QTableWidget" name="tableWidget_Opcodes">
          <property name="font">
           <font>
            <family>Monospace</family>
           </font>
          </property>
          <property name="editTriggers">
           <set>QAbstractItemView::NoEditTriggers</set>
          </property>
          <property name="selectionMode">
           <enum>QAbstractItemView::SingleSelection</enum>
          </property>
          <property name="selectionBehavior">
           <enum>QAbstractItemView::SelectRows</enum>
          </property>
          <property name="wordWrap">
           <bool>false</bool>
          </property>
          <attribute name="horizontalHeaderStretchLastSection">
           <bool>true</bool>
          </attribute>
          <attribute name="verticalHeaderVisible">
           <bool>false</bool>
          </attribute>
          <attribute name="verticalHeaderMinimumSectionSize">
           <number>16</number>
          </attribute>
          <attribute name="verticalHeaderDefaultSectionSize">
           <number>16</number>
          </attribute>
          <column>
           <property name="text">
            <string>Count</string>
           </property>
          </column>
          <column>
           <property name="text">
            <string>Address</string>
           </property>
          </column>
         </widget>
        </item>
        <item>
         <layout class="QHBoxLayout" name="horizontalLayout">
          <item>
           <widget class="QPushButton" name="pushButton_Refresh">
            <property name="text">
             <string>Refresh</string>
            </property>
           </widget>
          </item>
          <item>
           <widget class="QPushButton" name="pushButton_Stop">
            <property name="text">
             <string>Stop</string>
            </property>
           </widget>
          </item>
         </layout>
        </item>
       </layout>
      </widget>
      <widget class="QTextBrowser" name="textBrowser_Info">
       <property name="font">
        <font>
         <family>Monospace</family>
        </font>
       </property>
      </widget>
     </widget>
     <widget class="QTextBrowser" name="textBrowser_Disassemble">
      <property name="font">
       <font>
        <family>Monospace</family>
       </font>
      </property>
     </widget>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/TreeWidgets/AddressTree.py`:

```py
"""
Copyright (C) Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from PyQt6.QtWidgets import QTreeWidget


class QAddressTree(QTreeWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

    # TODO: If the auto-update is enabled, address table will be updated with a delay after a drop event
    # This probably happens because of the QTimers. It's not critical but a fix would be nice
    def dropEvent(self, event):
        self.parent().parent().update_address_table()
        super().dropEvent(event)

```

`GUI/Utils/__init__.py`:

```py
import keyboard
from . import keyboard_hack

# replace keyboard.parse_hotkey() with fix for literal '+' in hotkey strings
keyboard.parse_hotkey = keyboard_hack.parse_hotkey

```

`GUI/Utils/guitypedefs.py`:

```py
from PyQt6.QtCore import QThread, QRunnable, pyqtSignal, QObject
from keyboard import add_hotkey, remove_hotkey
from typing import Callable
from tr.tr import TranslationConstants as tr
from libpince import debugcore, typedefs
import queue

# Docstrings of pyqtSignal causes Sphinx to throw a warning about inline emphasis strings
# The hack below overwrites the docstrings of pyqtSignal so we avoid the warnings
# TODO: Wait for Qt to fix this issue or find a better way of handling this

pyqtSignal.__doc__ = "pyqtSignal"


class SettingSignals(QObject):
    changed = pyqtSignal()


class WorkerSignals(QObject):
    finished = pyqtSignal()


class ProcessSignals(QObject):
    attach = pyqtSignal()
    exit = pyqtSignal()


class SessionSignals(QObject):
    new_session = pyqtSignal()
    on_save = pyqtSignal()
    on_load = pyqtSignal()


class Worker(QRunnable):
    def __init__(self, fn, *args, **kwargs):
        super().__init__()
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()

    def run(self):
        self.fn(*self.args, **self.kwargs)
        self.signals.finished.emit()


class InterruptableWorker(QThread):
    def __init__(self, fn, *args, **kwargs):
        super().__init__()
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()

    def run(self):
        self.fn(*self.args, **self.kwargs)
        self.signals.finished.emit()

    def stop(self):
        self.terminate()


# Await async output from gdb
class AwaitAsyncOutput(QThread):
    async_output_ready = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.queue_active = True

    def run(self):
        async_output_queue = debugcore.gdb_async_output.register_queue()
        while self.queue_active:
            try:
                async_output = async_output_queue.get(timeout=5)
            except queue.Empty:
                pass
            else:
                self.async_output_ready.emit(async_output)
        debugcore.gdb_async_output.delete_queue(async_output_queue)

    def stop(self):
        self.queue_active = False


# Checks if the inferior has been terminated
class AwaitProcessExit(QThread):
    process_exited = pyqtSignal()

    def run(self):
        while True:
            with debugcore.process_exited_condition:
                debugcore.process_exited_condition.wait()
            self.process_exited.emit()


# Checks if the inferior is running or stopped
class CheckInferiorStatus(QThread):
    process_stopped = pyqtSignal()
    process_running = pyqtSignal()

    def run(self):
        while True:
            with debugcore.status_changed_condition:
                debugcore.status_changed_condition.wait()
            if debugcore.inferior_status == typedefs.INFERIOR_STATUS.STOPPED:
                self.process_stopped.emit()
            elif debugcore.inferior_status == typedefs.INFERIOR_STATUS.RUNNING:
                self.process_running.emit()


class Hotkey:
    def __init__(self, name="", desc="", default="", func=None, custom="", handle=None) -> None:
        self.name = name
        self.desc = desc
        self.default = default
        self.func = func
        self.custom = custom
        if default == "" or func is None:
            self.handle = handle
        else:
            self.handle = add_hotkey(default, func)

    def change_key(self, custom: str) -> None:
        if self.handle is not None:
            remove_hotkey(self.handle)
            self.handle = None
        self.custom = custom
        if custom == "":
            return
        self.handle = add_hotkey(custom.lower(), self.func)

    def change_func(self, func: Callable) -> None:
        self.func = func
        if self.handle is not None:
            remove_hotkey(self.handle)
        if self.custom != "":
            self.handle = add_hotkey(self.custom, func)
        elif self.default != "":
            self.handle = add_hotkey(self.default, func)

    def get_active_key(self) -> str:
        if self.custom == "":
            return self.default
        return self.custom


class Hotkeys:
    def __init__(self) -> None:
        self.pause_hotkey = Hotkey("pause_hotkey", tr.PAUSE_HOTKEY, "F1")
        self.break_hotkey = Hotkey("break_hotkey", tr.BREAK_HOTKEY, "F2")
        self.continue_hotkey = Hotkey("continue_hotkey", tr.CONTINUE_HOTKEY, "F3")
        self.cancel_hotkey = Hotkey("cancel_hotkey", tr.CANCEL_HOTKEY, "Ctrl+k")
        self.toggle_attach_hotkey = Hotkey("toggle_attach_hotkey", tr.TOGGLE_ATTACH_HOTKEY, "Shift+F10")
        self.exact_scan_hotkey = Hotkey("exact_scan_hotkey", tr.EXACT_SCAN_HOTKEY, "")
        self.not_scan_hotkey = Hotkey("not_scan_hotkey", tr.NOT_SCAN_HOTKEY, "")
        self.increased_scan_hotkey = Hotkey("increased_scan_hotkey", tr.INC_SCAN_HOTKEY, "")
        self.increased_by_scan_hotkey = Hotkey("increased_by_scan_hotkey", tr.INC_BY_SCAN_HOTKEY, "")
        self.decreased_scan_hotkey = Hotkey("decreased_scan_hotkey", tr.DEC_SCAN_HOTKEY, "")
        self.decreased_by_scan_hotkey = Hotkey("decreased_by_scan_hotkey", tr.DEC_BY_SCAN_HOTKEY, "")
        self.less_scan_hotkey = Hotkey("less_scan_hotkey", tr.LESS_SCAN_HOTKEY, "")
        self.more_scan_hotkey = Hotkey("more_scan_hotkey", tr.MORE_SCAN_HOTKEY, "")
        self.between_scan_hotkey = Hotkey("between_scan_hotkey", tr.BETWEEN_SCAN_HOTKEY, "")
        self.changed_scan_hotkey = Hotkey("changed_scan_hotkey", tr.CHANGED_SCAN_HOTKEY, "")
        self.unchanged_scan_hotkey = Hotkey("unchanged_scan_hotkey", tr.UNCHANGED_SCAN_HOTKEY, "")

    def get_hotkeys(self) -> list[Hotkey]:
        hotkey_list = []
        for _, value in vars(self).items():
            if isinstance(value, Hotkey):
                hotkey_list.append(value)
        return hotkey_list

```

`GUI/Utils/guiutils.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from PyQt6.QtWidgets import (
    QWidget,
    QScrollBar,
    QTableWidget,
    QTableWidgetItem,
    QTreeWidget,
    QTreeWidgetItem,
    QListWidget,
    QListWidgetItem,
    QComboBox,
    QMenu,
    QLayout,
    QMessageBox,
)
from PyQt6.QtCore import QObject, QRegularExpression
from PyQt6.QtGui import QShortcut, QRegularExpressionValidator
from libpince import debugcore, utils, typedefs, regexes
from tr.tr import TranslationConstants as tr
from typing import overload

validator_map: dict[str, QRegularExpressionValidator | None] = {
    "int": QRegularExpressionValidator(QRegularExpression(regexes.decimal_number.pattern)),  # integers
    "int_hex": QRegularExpressionValidator(QRegularExpression(regexes.hex_number_gui.pattern)),  # hexadecimals
    "float": QRegularExpressionValidator(QRegularExpression(regexes.float_number.pattern)),  # floats
    "bytearray": QRegularExpressionValidator(QRegularExpression(regexes.bytearray_input.pattern)),  # array of bytes
    "string": None,
}


def get_icons_directory():
    """Gets the directory of the icons

    Returns:
        str: Path to the icons directory
    """
    return utils.get_script_directory() + "/media/icons"


def center(window: QWidget):
    """Center the given window to desktop

    Args:
        window (QWidget): The window that'll be centered to desktop
    """
    window.frameGeometry().moveCenter(window.screen().availableGeometry().center())


def center_to_parent(window: QWidget):
    """Center the given window to its parent

    Args:
        window (QWidget): The window that'll be centered to its parent
    """
    parent: QWidget = window.parent()
    window.move(parent.frameGeometry().center() - window.rect().center())


def center_scroll_bar(scrollbar: QScrollBar):
    """Center the given scrollbar

    Args:
        scrollbar (QScrollbar): Self-explanatory
    """
    maximum = scrollbar.maximum()
    minimum = scrollbar.minimum()
    scrollbar.setValue((maximum + minimum) // 2)


def resize_to_contents(tablewidget: QTableWidget):
    """Resizes the columns of the given QTableWidget to its contents
    This also fixes the stretch problem of the last column

    Args:
        tablewidget (QTableWidget): Self-explanatory
    """
    tablewidget.resizeColumnsToContents()
    default_size = tablewidget.horizontalHeader().defaultSectionSize()
    tablewidget.horizontalHeader().resizeSection(tablewidget.columnCount() - 1, default_size)


def fill_value_combobox(combobox: QComboBox, current_index: int = typedefs.VALUE_INDEX.INT32):
    """Fills the given QComboBox with value_index strings

    Args:
        combobox (QComboBox): The combobox that'll be filled
        current_index (int): Can be a member of typedefs.VALUE_INDEX
    """
    for key in typedefs.index_to_text_dict:
        combobox.addItem(typedefs.index_to_text_dict[key])
    combobox.setCurrentIndex(current_index)


def fill_endianness_combobox(combobox: QComboBox, current_index: int = typedefs.ENDIANNESS.HOST):
    """Fills the given QComboBox with endianness strings

    Args:
        combobox (QComboBox): The combobox that'll be filled
        current_index (int): Can be a member of typedefs.ENDIANNESS
    """
    endianness_text = [
        (typedefs.ENDIANNESS.HOST, tr.HOST),
        (typedefs.ENDIANNESS.LITTLE, tr.LITTLE),
        (typedefs.ENDIANNESS.BIG, tr.BIG),
    ]
    for endian, text in endianness_text:
        combobox.addItem(text, endian)
    combobox.setCurrentIndex(current_index)


def get_current_row(tablewidget: QTableWidget):
    r"""Returns the currently selected row index for the given QTableWidget
    If you try to use only selectionModel().currentIndex().row() for this purpose, you'll get the last selected row even
    if it was unselected afterwards. This is why this function exists, it checks the selection state before returning
    the selected row

    Args:
        tablewidget (QTableWidget): Self-explanatory

    Returns:
        int: Currently selected row. Returns -1 if nothing is selected

    Note:
        This function doesn't work properly when used within signals such as currentItemChanged, currentIndexChanged,
        currentChanged and currentRowChanged. Use the row, item, QModelIndex or whatever the signal provides instead.
        This bug occurs because those signals only update the changed row, not the selectionModel. This causes
        selectionModel().selectedRows() to return None and this function to behave improperly

        For developers: You can use the regex \.current.*\.connect to search signals if a cleanup is needed
    """
    if tablewidget.selectionModel().selectedRows():
        return tablewidget.selectionModel().currentIndex().row()
    return -1


@overload
def get_current_item(listwidget: QListWidget) -> QListWidgetItem | None: ...


@overload
def get_current_item(tablewidget: QTableWidget) -> QTableWidgetItem | None: ...


@overload
def get_current_item(treewidget: QTreeWidget) -> QTreeWidgetItem | None: ...


def get_current_item(widget: QListWidget | QTableWidget | QTreeWidget):
    r"""Returns the currently selected item for the given widget
    If you try to use only selectionModel().currentItem() for this purpose, you'll get the last selected item even
    if it was unselected afterwards. This is why this function exists, it checks the selection state before returning
    the selected item. Unlike get_current_row, this function can be used with QTreeWidget

    Args:
        widget (QListWidget | QTableWidget | QTreeWidget): Self-explanatory

    Returns:
        Any: Currently selected item. Returns None if nothing is selected

    Note:
        This function doesn't work properly when used within signals such as currentItemChanged, currentIndexChanged,
        currentChanged and currentRowChanged. Use the row, item, QModelIndex or whatever the signal provides instead.
        This bug occurs because those signals only update the changed row, not the selectionModel. This causes
        selectionModel().selectedRows() to return None and this function to behave improperly

        For developers: You can use the regex \.current.*\.connect to search signals if a cleanup is needed
    """
    if widget.selectionModel().selectedRows():
        return widget.currentItem()


def delete_menu_entries(menu: QMenu, QAction_list: list):
    """Deletes given QActions from the QMenu recursively and cleans up the remaining redundant separators and menus
    Doesn't support menus that includes types other than actions, separators and menus

    Args:
        menu (QMenu): Self-explanatory
        QAction_list (list): List of QActions. Leave blank if you just want to clean the redundant separators up
    """

    def remove_entries(menu: QMenu):
        for action in menu.actions():
            try:
                QAction_list.index(action)
            except ValueError:
                pass
            else:
                menu.removeAction(action)

    def clean_entries(menu: QMenu):
        for action in menu.actions():
            if action.isSeparator():
                actions = menu.actions()
                current_index = actions.index(action)
                if (
                    len(actions) == 1
                    or (current_index == 0 and actions[1].isSeparator())
                    or (current_index == -1 and actions[-2].isSeparator())
                    or (actions[current_index - 1].isSeparator() and actions[current_index + 1].isSeparator())
                ):
                    menu.removeAction(action)

    remove_entries(menu)
    clean_entries(menu)


# TODO: This is a really bad design pattern, remove this function after moving classes to their own files
def search_parents_by_function(qt_object: QObject, func_name: str):
    """Search for func_name in the parents of given QObject. Once function is found, parent that possesses func_name
    is returned

    Args:
        qt_object (QObject): The object that'll be searched for it's parents
        func_name (str): The name of the function that'll be searched
    """
    while qt_object is not None:
        qt_object = qt_object.parent()
        if func_name in dir(qt_object):
            return qt_object


def get_layout_widgets(layout: QLayout):
    """Returns the widgets of a QLayout as a list

    Args:
        layout: Self-explanatory

    Returns:
        list: A list that contains the widgets of the given layout
    """
    return [layout.itemAt(x).widget() for x in range(layout.count())]


def contains_reference_mark(string: str):
    """Checks if given string contains the reference mark

    Args:
        string (str): String that'll be checked for the reference mark

    Returns:
        bool: True if given string contains the reference mark, False otherwise
    """
    return True if regexes.reference_mark.search(string) else False


def append_shortcut_to_tooltip(qt_object: QObject, shortcut: QShortcut):
    """Appends key string of the given QShortcut to the toolTip of the given QObject

    Args:
        qt_object (QObject): Self-explanatory
        shortcut (QShortcut): Self-explanatory
    """
    qt_object.setToolTip(qt_object.toolTip() + "[" + shortcut.key().toString() + "]")


def check_inferior_running(widget: QWidget = None, show_message: bool = True) -> str | None:
    """Checks if a process is selected and is running

    Args:
        widget (QWidget | None): Parent widget for the message box. If None, message box will have no parent
        show_message (bool): If True, a message box will be shown if the inferior is running

    Returns:
        str: The error message, if the inferior is running or no process is selected
        None: If the inferior is stopped and a process is selected
    """
    if debugcore.currentpid == -1:
        if show_message:
            QMessageBox.information(widget, tr.ERROR, tr.NO_PROCESS_SELECTED)
        return tr.NO_PROCESS_SELECTED
    if debugcore.inferior_status == typedefs.INFERIOR_STATUS.RUNNING:
        if show_message:
            QMessageBox.information(widget, tr.ERROR, tr.REQUIRE_PROCESS_STOP)
        return tr.REQUIRE_PROCESS_STOP
    return None

```

`GUI/Utils/keyboard_hack.py`:

```py
from keyboard import key_to_scan_codes
import re as _re

# copied from keyboard.__init__.py
_is_str = lambda x: isinstance(x, str)
_is_number = lambda x: isinstance(x, int)
_is_list = lambda x: isinstance(x, (list, tuple))


def parse_hotkey(hotkey):
    ## function to replace keyboard.parse_hotkey() with fix for literal '+' in hotkey strings
    """
    Parses a user-provided hotkey into nested tuples representing the
    parsed structure, with the bottom values being lists of scan codes.
    Also accepts raw scan codes, which are then wrapped in the required
    number of nestings.

    Example:

        parse_hotkey("alt+shift+a, alt+b, c")
        #    Keys:    ^~^ ^~~~^ ^  ^~^ ^  ^
        #    Steps:   ^~~~~~~~~~^  ^~~~^  ^

        # ((alt_codes, shift_codes, a_codes), (alt_codes, b_codes), (c_codes,))
    """
    if _is_number(hotkey) or len(hotkey) == 1:
        scan_codes = key_to_scan_codes(hotkey)
        step = (scan_codes,)
        steps = (step,)
        return steps
    elif _is_list(hotkey):
        if not any(map(_is_list, hotkey)):
            step = tuple(key_to_scan_codes(k) for k in hotkey)
            steps = (step,)
            return steps
        return hotkey

    steps = []
    # since we dont have spaces in hotkey strings, we can ignore whitespace in the regex
    for step in _re.split(r"(?<!keypad ),(?!$|,)", hotkey):
        keys = _re.split(r"(?<=\+)\+(?=(?:(?:\+\+\w))|[\w ])|(?:(?<!keypad )(?<= |[\w,/*\-÷])\+)|\+(?=\+$)", step)
        steps.append(tuple(key_to_scan_codes(key) for key in keys))
    return tuple(steps)

```

`GUI/Utils/utilwidgets.py`:

```py
from PyQt6.QtWidgets import QDialog, QDialogButtonBox, QVBoxLayout, QLineEdit, QLabel, QWidget, QComboBox
from PyQt6.QtCore import Qt
from GUI.Utils import guiutils

# This module includes utility widgets that doesn't have ui files


class InputDialog(QDialog):
    """A dialog that allows for one or more QLabels and corresponding QLineEdit fields"""

    def __init__(
        self,
        parent: QWidget,
        items: str | list[tuple[str, str]],
        alignment=Qt.AlignmentFlag.AlignCenter,
        cancel_button=True,
    ):
        """
        Args:
            parent (QWidget): Parent of this dialog
            items (str | list[tuple[str, str]]): If a string is provided, a single label will be created
            If a list is provided, it must be in this format -> [(label_text, lineedit_text)]
            Providing a list will create labels and lineedits by using given texts, stacked vertically
            alignment (Qt.AlignmentFlag): Text alignment of the labels
            cancel_button (bool): Both Ok and Cancel buttons will appear if True, only Ok button will appear if False
        """
        super().__init__(parent)
        self.input_fields: list[QLineEdit] = []
        layout = QVBoxLayout()
        if isinstance(items, str):
            label = QLabel(items)
            label.setAlignment(alignment)
            label.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)
            layout.addWidget(label)
        elif isinstance(items, list):
            for label_text, edit_text in items:
                label = QLabel(label_text)
                label.setAlignment(alignment)
                label.setTextInteractionFlags(Qt.TextInteractionFlag.TextSelectableByMouse)
                layout.addWidget(label)
                lineedit = QLineEdit(edit_text)
                layout.addWidget(lineedit)
                self.input_fields.append(lineedit)
        else:
            raise Exception("Type of items isn't str or list")
        if cancel_button:
            button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        else:
            button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        self.setLayout(layout)
        self.adjustSize()
        if self.input_fields:
            self.input_fields[0].setFocus()
        guiutils.center_to_parent(self)

    def get_values(self) -> list[str] | None:
        if self.input_fields:
            return [item.text() for item in self.input_fields]


class ComboBoxDialog(QDialog):
    """A dialog that allows for one QLabel and a corresponding QComboBox"""

    def __init__(self, parent: QWidget, label_text: str, items: list[str], current_index: int = 0):
        """
        Args:
            parent (QWidget): Parent of this dialog
            label_text (str): Text of the label
            items (list[str]): List of strings that'll be used as items of the combobox
            current_index (int): Sets the current index of the combobox
        """
        super().__init__(parent)
        layout = QVBoxLayout()
        label = QLabel(label_text)
        self.combobox = QComboBox()
        self.combobox.addItems(items)
        self.combobox.setCurrentIndex(current_index)
        button_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(label)
        layout.addWidget(self.combobox)
        layout.addWidget(button_box)
        self.setLayout(layout)
        self.adjustSize()
        guiutils.center_to_parent(self)

    def get_values(self):
        return self.combobox.currentText()

```

`GUI/Validators/HexValidator.py`:

```py
from PyQt6.QtGui import QValidator


class QHexValidator(QValidator):
    def __init__(self, max_limit, parent=None):
        super().__init__(parent)
        self.max_limit = max_limit

    def validate(self, p_str, p_int):
        try:
            int_repr = int(p_str, 0)
        except ValueError:
            return QValidator.State.Intermediate, p_str, p_int
        if int_repr > self.max_limit:
            return QValidator.State.Invalid, p_str, p_int
        return QValidator.State.Acceptable, p_str, p_int

```

`GUI/Widgets/Bookmark/Bookmark.py`:

```py
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QKeySequence, QShortcut
from PyQt6.QtWidgets import QListWidgetItem, QMenu, QMessageBox, QWidget

from GUI.Session.session import SessionDataChanged, SessionManager
from GUI.States import states
from GUI.Utils import guiutils, utilwidgets
from GUI.Widgets.Bookmark.Form.BookmarkWidget import Ui_Form
from libpince import debugcore, utils
from tr.tr import TranslationConstants as tr


# This widget is too intertwined with MemoryViewer, it will be need to be reworked if it gets used in anywhere else
class BookmarkWidget(QWidget, Ui_Form):
    bookmarked = pyqtSignal(object)
    comment_changed = pyqtSignal(object)
    double_clicked = pyqtSignal(str)
    deleted = pyqtSignal(object)

    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.listWidget.contextMenuEvent = self.listWidget_context_menu_event
        self.listWidget.currentRowChanged.connect(self.change_display)
        self.listWidget.itemDoubleClicked.connect(self.listWidget_item_double_clicked)
        self.shortcut_delete = QShortcut(QKeySequence("Del"), self)
        self.shortcut_delete.activated.connect(self.delete_record)
        self.shortcut_refresh = QShortcut(QKeySequence("R"), self)
        self.shortcut_refresh.activated.connect(self.refresh_table)
        self.session = SessionManager.get_session()
        self.refresh_table()
        states.session_signals.new_session.connect(self.on_new_session)
        guiutils.center_to_parent(self)

    def refresh_table(self):
        self.listWidget.clear()
        address_list = [hex(address) for address in self.session.pct_bookmarks.keys()]
        if debugcore.currentpid == -1:
            self.listWidget.addItems(address_list)
        else:
            self.listWidget.addItems([item.all for item in debugcore.examine_expressions(address_list)])

    def change_display(self, row):
        if row == -1:
            return
        current_address = utils.extract_hex_address(self.listWidget.item(row).text())
        if debugcore.currentpid == -1:
            self.lineEdit_Info.clear()
        else:
            self.lineEdit_Info.setText(debugcore.get_address_info(current_address))
        self.lineEdit_Comment.setText(self.session.pct_bookmarks[int(current_address, 16)]["comment"])

    def listWidget_item_double_clicked(self, item: QListWidgetItem):
        self.double_clicked.emit(utils.extract_hex_address(item.text()))

    def exec_add_entry_dialog(self):
        entry_dialog = utilwidgets.InputDialog(self, [(tr.ENTER_EXPRESSION, "")])
        if entry_dialog.exec():
            text = entry_dialog.get_values()[0]
            address = debugcore.examine_expression(text).address
            if not address:
                QMessageBox.information(self, tr.ERROR, tr.INVALID_EXPRESSION)
                return
            self.bookmarked.emit(int(address, 16))
            self.refresh_table()
            self.session.data_changed |= SessionDataChanged.BOOKMARKS

    def exec_change_comment_dialog(self, current_address):
        self.comment_changed.emit(current_address)
        self.refresh_table()
        self.session.data_changed |= SessionDataChanged.BOOKMARKS

    def listWidget_context_menu_event(self, event):
        current_item = guiutils.get_current_item(self.listWidget)
        if current_item:
            current_address = utils.safe_str_to_int(utils.extract_hex_address(current_item.text()), 16)
            if current_address not in self.session.pct_bookmarks:
                QMessageBox.information(self, tr.ERROR, tr.INVALID_ENTRY)
                self.refresh_table()
                return
        else:
            current_address = None
        menu = QMenu()
        add_entry = menu.addAction(tr.ADD_ENTRY)
        change_comment = menu.addAction(tr.CHANGE_COMMENT)
        delete_record = menu.addAction(f"{tr.DELETE}[Del]")
        if current_item is None:
            guiutils.delete_menu_entries(menu, [change_comment, delete_record])
        menu.addSeparator()
        refresh = menu.addAction(f"{tr.REFRESH}[R]")
        font_size = self.listWidget.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            add_entry: self.exec_add_entry_dialog,
            change_comment: lambda: self.exec_change_comment_dialog(current_address),
            delete_record: self.delete_record,
            refresh: self.refresh_table,
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def delete_record(self):
        current_item = guiutils.get_current_item(self.listWidget)
        if not current_item:
            return
        current_address = utils.safe_str_to_int(utils.extract_hex_address(current_item.text()), 16)
        self.deleted.emit(current_address)
        self.refresh_table()
        self.session.data_changed |= SessionDataChanged.BOOKMARKS

    def on_new_session(self):
        self.session = SessionManager.get_session()
        self.refresh_table()

```

`GUI/Widgets/Bookmark/Form/BookmarkWidget.py`:

```py
# Form implementation generated from reading ui file 'Widgets/Bookmark/Form/BookmarkWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(900, 300)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.label = QtWidgets.QLabel(parent=Form)
        self.label.setObjectName("label")
        self.verticalLayout.addWidget(self.label)
        self.listWidget = QtWidgets.QListWidget(parent=Form)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.listWidget.setFont(font)
        self.listWidget.setObjectName("listWidget")
        self.verticalLayout.addWidget(self.listWidget)
        self.horizontalLayout.addLayout(self.verticalLayout)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label_2 = QtWidgets.QLabel(parent=Form)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_2.addWidget(self.label_2)
        self.lineEdit_Info = QtWidgets.QLineEdit(parent=Form)
        self.lineEdit_Info.setReadOnly(True)
        self.lineEdit_Info.setObjectName("lineEdit_Info")
        self.verticalLayout_2.addWidget(self.lineEdit_Info)
        self.label_3 = QtWidgets.QLabel(parent=Form)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_2.addWidget(self.label_3)
        self.lineEdit_Comment = QtWidgets.QLineEdit(parent=Form)
        self.lineEdit_Comment.setReadOnly(True)
        self.lineEdit_Comment.setObjectName("lineEdit_Comment")
        self.verticalLayout_2.addWidget(self.lineEdit_Comment)
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_2.addItem(spacerItem)
        self.horizontalLayout.addLayout(self.verticalLayout_2)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Bookmarks"))
        self.label.setText(_translate("Form", "Bookmarked Addresses"))
        self.label_2.setText(_translate("Form", "Info"))
        self.label_3.setText(_translate("Form", "Comment"))

```

`GUI/Widgets/Bookmark/Form/BookmarkWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>900</width>
    <height>300</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Bookmarks</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>Bookmarked Addresses</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QListWidget" name="listWidget">
         <property name="font">
          <font>
           <family>Monospace</family>
          </font>
         </property>
        </widget>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>Info</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLineEdit" name="lineEdit_Info">
         <property name="readOnly">
          <bool>true</bool>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_3">
         <property name="text">
          <string>Comment</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLineEdit" name="lineEdit_Comment">
         <property name="readOnly">
          <bool>true</bool>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="verticalSpacer">
         <property name="orientation">
          <enum>Qt::Vertical</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>20</width>
           <height>40</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/Widgets/HandleSignals/Form/HandleSignalsDialog.py`:

```py
# Form implementation generated from reading ui file 'Widgets/HandleSignals/Form/HandleSignalsDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(363, 523)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_Signals = QtWidgets.QTableWidget(parent=Dialog)
        self.tableWidget_Signals.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_Signals.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_Signals.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_Signals.setObjectName("tableWidget_Signals")
        self.tableWidget_Signals.setColumnCount(3)
        self.tableWidget_Signals.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Signals.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Signals.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Signals.setHorizontalHeaderItem(2, item)
        self.tableWidget_Signals.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Signals.verticalHeader().setVisible(False)
        self.tableWidget_Signals.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Signals.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_Signals, 0, 0, 1, 1)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 1, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Handle Signals"))
        item = self.tableWidget_Signals.horizontalHeaderItem(0)
        item.setText(_translate("Dialog", "Signal"))
        item = self.tableWidget_Signals.horizontalHeaderItem(1)
        item.setText(_translate("Dialog", "Stop & Print"))
        item = self.tableWidget_Signals.horizontalHeaderItem(2)
        item.setText(_translate("Dialog", "Pass to Program"))

```

`GUI/Widgets/HandleSignals/Form/HandleSignalsDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>363</width>
    <height>523</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Handle Signals</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTableWidget" name="tableWidget_Signals">
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>Signal</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Stop &amp; Print</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Pass to Program</string>
      </property>
     </column>
    </widget>
   </item>
   <item row="1" column="0">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/Widgets/HandleSignals/HandleSignals.py`:

```py
from PyQt6.QtWidgets import QDialog, QWidget, QCheckBox, QHBoxLayout, QTableWidgetItem
from PyQt6.QtCore import Qt
from GUI.Utils import guiutils
from GUI.Widgets.HandleSignals.Form.HandleSignalsDialog import Ui_Dialog
import json


class HandleSignalsDialog(QDialog, Ui_Dialog):
    def __init__(self, parent, signal_data):
        super().__init__(parent)
        self.setupUi(self)
        self.signal_data = json.loads(signal_data)
        self.tableWidget_Signals.setRowCount(len(self.signal_data))
        for index, (signal, stop, pass_to_program) in enumerate(self.signal_data):
            self.tableWidget_Signals.setItem(index, 0, QTableWidgetItem(signal))
            widget, checkbox = self.create_checkbox_widget()
            self.tableWidget_Signals.setCellWidget(index, 1, widget)
            if stop:
                checkbox.setCheckState(Qt.CheckState.Checked)
            else:
                checkbox.setCheckState(Qt.CheckState.Unchecked)
            widget, checkbox = self.create_checkbox_widget()
            self.tableWidget_Signals.setCellWidget(index, 2, widget)
            if pass_to_program:
                checkbox.setCheckState(Qt.CheckState.Checked)
            else:
                checkbox.setCheckState(Qt.CheckState.Unchecked)
        self.tableWidget_Signals.resizeColumnsToContents()
        guiutils.center_to_parent(self)

    def create_checkbox_widget(self):
        widget = QWidget()
        checkbox = QCheckBox()
        layout = QHBoxLayout(widget)
        layout.addWidget(checkbox)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.setContentsMargins(0, 0, 0, 0)
        return widget, checkbox

    def get_values(self):
        signal_data = []
        for index in range(len(self.signal_data)):
            current_signal = []
            current_signal.append(self.signal_data[index][0])
            widget = self.tableWidget_Signals.cellWidget(index, 1)
            checkbox = widget.findChild(QCheckBox)
            current_signal.append(True if checkbox.checkState() == Qt.CheckState.Checked else False)
            widget = self.tableWidget_Signals.cellWidget(index, 2)
            checkbox = widget.findChild(QCheckBox)
            current_signal.append(True if checkbox.checkState() == Qt.CheckState.Checked else False)
            signal_data.append(current_signal)
        return json.dumps(signal_data)

```

`GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.py`:

```py
# Form implementation generated from reading ui file 'Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(898, 656)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.tabWidget = QtWidgets.QTabWidget(parent=self.centralwidget)
        self.tabWidget.setTabsClosable(True)
        self.tabWidget.setObjectName("tabWidget")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.tabWidget.addTab(self.tab, "")
        self.gridLayout.addWidget(self.tabWidget, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 898, 23))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(parent=self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuTemplates = QtWidgets.QMenu(parent=self.menubar)
        self.menuTemplates.setObjectName("menuTemplates")
        self.menuHelp = QtWidgets.QMenu(parent=self.menubar)
        self.menuHelp.setObjectName("menuHelp")
        self.menuRun = QtWidgets.QMenu(parent=self.menubar)
        self.menuRun.setObjectName("menuRun")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionCode_Injection = QtGui.QAction(parent=MainWindow)
        self.actionCode_Injection.setObjectName("actionCode_Injection")
        self.actionOpen = QtGui.QAction(parent=MainWindow)
        self.actionOpen.setObjectName("actionOpen")
        self.actionSave = QtGui.QAction(parent=MainWindow)
        self.actionSave.setObjectName("actionSave")
        self.actionLibpince = QtGui.QAction(parent=MainWindow)
        self.actionLibpince.setObjectName("actionLibpince")
        self.actionRun_current_script = QtGui.QAction(parent=MainWindow)
        self.actionRun_current_script.setObjectName("actionRun_current_script")
        self.menuFile.addAction(self.actionOpen)
        self.menuFile.addAction(self.actionSave)
        self.menuTemplates.addAction(self.actionCode_Injection)
        self.menuHelp.addAction(self.actionLibpince)
        self.menuRun.addAction(self.actionRun_current_script)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuTemplates.menuAction())
        self.menubar.addAction(self.menuRun.menuAction())
        self.menubar.addAction(self.menuHelp.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Libpince Engine"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "Tab 1"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.menuTemplates.setTitle(_translate("MainWindow", "Templates"))
        self.menuHelp.setTitle(_translate("MainWindow", "Help"))
        self.menuRun.setTitle(_translate("MainWindow", "Run"))
        self.actionCode_Injection.setText(_translate("MainWindow", "Code Injection"))
        self.actionOpen.setText(_translate("MainWindow", "Open [Ctrl+O]"))
        self.actionSave.setText(_translate("MainWindow", "Save [Ctrl+S]"))
        self.actionLibpince.setText(_translate("MainWindow", "Libpince"))
        self.actionRun_current_script.setText(_translate("MainWindow", "Run current script [Ctrl+R]"))

```

`GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>898</width>
    <height>656</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Libpince Engine</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QGridLayout" name="gridLayout">
    <item row="0" column="0">
     <widget class="QTabWidget" name="tabWidget">
      <property name="tabsClosable">
       <bool>true</bool>
      </property>
      <widget class="QWidget" name="tab">
       <attribute name="title">
        <string>Tab 1</string>
       </attribute>
      </widget>
     </widget>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>898</width>
     <height>23</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>File</string>
    </property>
    <addaction name="actionOpen"/>
    <addaction name="actionSave"/>
   </widget>
   <widget class="QMenu" name="menuTemplates">
    <property name="title">
     <string>Templates</string>
    </property>
    <addaction name="actionCode_Injection"/>
   </widget>
   <widget class="QMenu" name="menuHelp">
    <property name="title">
     <string>Help</string>
    </property>
    <addaction name="actionLibpince"/>
   </widget>
   <widget class="QMenu" name="menuRun">
    <property name="title">
     <string>Run</string>
    </property>
    <addaction name="actionRun_current_script"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuTemplates"/>
   <addaction name="menuRun"/>
   <addaction name="menuHelp"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <action name="actionCode_Injection">
   <property name="text">
    <string>Code Injection</string>
   </property>
  </action>
  <action name="actionOpen">
   <property name="text">
    <string>Open [Ctrl+O]</string>
   </property>
  </action>
  <action name="actionSave">
   <property name="text">
    <string>Save [Ctrl+S]</string>
   </property>
  </action>
  <action name="actionLibpince">
   <property name="text">
    <string>Libpince</string>
   </property>
  </action>
  <action name="actionRun_current_script">
   <property name="text">
    <string>Run current script [Ctrl+R]</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/Widgets/LibpinceEngine/LibpinceEngine.py`:

```py
from PyQt6.QtWidgets import (
    QMainWindow,
    QWidget,
    QPlainTextEdit,
    QVBoxLayout,
    QFileDialog,
    QMessageBox,
    QTabWidget,
)
from PyQt6.QtGui import QKeySequence
from GUI.Utils import guiutils
from GUI.Widgets.LibpinceEngine.Form.LibpinceEngineWindow import Ui_MainWindow
from tr.tr import TranslationConstants as tr
import libpince  # We import the entire libpince instead of just utils as we'll need it for exec()
import os


class ScriptEditor(QPlainTextEdit):
    """Custom text editor that tracks modifications"""

    def __init__(self, tab_widget: QTabWidget):
        super().__init__()
        self.file_path = None
        self.saved_content = ""
        self.is_modified = False
        self.tab_widget = tab_widget
        self.textChanged.connect(self.handle_text_changed)

    def handle_text_changed(self):
        """Check if content differs from saved content and update tab title"""
        current_content = self.toPlainText()
        new_modified_state = current_content != self.saved_content

        if new_modified_state != self.is_modified:
            self.is_modified = new_modified_state
            self.update_tab_title()

    def update_tab_title(self):
        """Updates the tab title based on modification state"""
        parent_tab = self.parent()
        if parent_tab:
            index = self.tab_widget.indexOf(parent_tab)
            if self.file_path:
                base_title = os.path.basename(self.file_path)
                title = f"{base_title}*" if self.is_modified else base_title
            else:
                title = tr.UNTITLED
            self.tab_widget.setTabText(index, title)


class LibpinceEngineWindow(QMainWindow, Ui_MainWindow):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)

        # Remove the default tab
        self.tabWidget.removeTab(0)
        self.create_new_tab()
        self.add_plus_tab()

        self.actionOpen.setShortcut(QKeySequence("Ctrl+O"))
        self.actionSave.setShortcut(QKeySequence("Ctrl+S"))
        self.actionRun_current_script.setShortcut(QKeySequence("Ctrl+R"))

        self.tabWidget.tabBarClicked.connect(self.handle_tab_click)
        self.tabWidget.tabCloseRequested.connect(self.close_tab)
        self.actionOpen.triggered.connect(self.open_file)
        self.actionSave.triggered.connect(self.save_file)
        self.actionLibpince.triggered.connect(self.actionLibpince_triggered)
        self.actionRun_current_script.triggered.connect(self.run_current_script)
        guiutils.center_to_parent(self)

    def add_plus_tab(self):
        """Adds the "+" tab at the end of the tab widget"""
        plus_tab = QWidget()
        index = self.tabWidget.addTab(plus_tab, "+")
        # Remove close button for the "+" tab
        self.tabWidget.tabBar().setTabButton(index, self.tabWidget.tabBar().ButtonPosition.RightSide, None)

    def create_new_tab(self):
        """Creates a new tab with a text editor"""
        new_tab = QWidget()
        layout = QVBoxLayout(new_tab)
        layout.setContentsMargins(0, 0, 0, 0)

        text_editor = ScriptEditor(self.tabWidget)
        layout.addWidget(text_editor)

        # Add the new tab before the "+" tab
        index = self.tabWidget.count() - 1 if self.tabWidget.count() > 0 else 0
        self.tabWidget.insertTab(index, new_tab, tr.UNTITLED)

        # Select the new tab
        self.tabWidget.setCurrentIndex(index)

        return text_editor

    def get_current_editor(self) -> ScriptEditor | None:
        """Gets the text editor of the current tab"""
        current_tab = self.tabWidget.currentWidget()
        if current_tab:
            return current_tab.findChild(ScriptEditor)
        return None

    def handle_tab_click(self, index: int):
        """Handles tab clicks, creates new tab when "+" is clicked"""
        if index == self.tabWidget.count() - 1:  # If "+" tab is clicked
            self.create_new_tab()

    def close_tab(self, index: int):
        """Handles tab closing, prevents closing the "+" tab"""
        if index != self.tabWidget.count() - 1:  # Don't close "+" tab
            current_index = self.tabWidget.currentIndex()
            self.tabWidget.removeTab(index)

            # Switch to previous tab if we're closing the current tab
            if index == current_index and index > 0:
                self.tabWidget.setCurrentIndex(index - 1)

    def open_file(self):
        """Opens a Python script file in a new tab"""
        file_path, _ = QFileDialog.getOpenFileName(self, tr.OPEN_SCRIPT_FILE, "", tr.FILE_TYPES_SCRIPT)

        if file_path:
            editor = self.create_new_tab()

            try:
                with open(file_path, "r") as file:
                    content = file.read()
                    editor.setPlainText(content)
                    editor.file_path = file_path
                    editor.saved_content = content
                    editor.is_modified = False
                    editor.update_tab_title()
            except Exception as e:
                QMessageBox.critical(self, tr.ERROR, str(e))

    def save_file(self):
        """Saves the current tab's content to a file"""
        editor = self.get_current_editor()
        if not editor:
            return

        # If file hasn't been saved before, ask for location
        if not editor.file_path:
            file_path, _ = QFileDialog.getSaveFileName(self, tr.SAVE_SCRIPT_FILE, "", tr.FILE_TYPES_SCRIPT)
            if not file_path:
                return

            # Ensure .py extension
            if not file_path.lower().endswith(".py"):
                file_path += ".py"

            editor.file_path = file_path

        try:
            with open(editor.file_path, "w") as file:
                content = editor.toPlainText()
                file.write(content)
                editor.saved_content = content
                editor.is_modified = False
                editor.update_tab_title()
        except Exception as e:
            QMessageBox.critical(self, tr.ERROR, str(e))

    def run_current_script(self):
        """Runs the current tab's script content"""
        editor = self.get_current_editor()
        if not editor:
            return

        try:
            script_content = editor.toPlainText()
            if not script_content.strip():
                return

            # Execute the script with full access to current context
            exec(script_content, globals(), locals())
        except Exception as e:
            QMessageBox.critical(self, tr.ERROR, f"{tr.SCRIPT_FAILED}\n{str(e)}")

    def actionLibpince_triggered(self):
        libpince.utils.execute_command_as_user('python3 -m webbrowser "https://korcankaraokcu.github.io/PINCE/"')

```

`GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.py`:

```py
# Form implementation generated from reading ui file 'Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(724, 568)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.pushButton_Invert = QtWidgets.QPushButton(parent=Dialog)
        self.pushButton_Invert.setObjectName("pushButton_Invert")
        self.horizontalLayout.addWidget(self.pushButton_Invert)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.tableWidget_Regions = QScanRegionTable(parent=Dialog)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_Regions.setFont(font)
        self.tableWidget_Regions.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_Regions.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_Regions.setWordWrap(False)
        self.tableWidget_Regions.setObjectName("tableWidget_Regions")
        self.tableWidget_Regions.setColumnCount(7)
        self.tableWidget_Regions.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Regions.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Regions.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Regions.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Regions.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Regions.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Regions.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Regions.setHorizontalHeaderItem(6, item)
        self.tableWidget_Regions.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Regions.verticalHeader().setVisible(False)
        self.tableWidget_Regions.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Regions.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_Regions, 1, 0, 1, 1)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.gridLayout.addWidget(self.buttonBox, 2, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Manage Scan Regions"))
        self.label.setText(_translate("Dialog", "Selected regions will be deleted from the current scan"))
        self.pushButton_Invert.setText(_translate("Dialog", "Invert Selection"))
        self.tableWidget_Regions.setSortingEnabled(True)
        item = self.tableWidget_Regions.horizontalHeaderItem(0)
        item.setText(_translate("Dialog", "ID"))
        item = self.tableWidget_Regions.horizontalHeaderItem(1)
        item.setText(_translate("Dialog", "Start Address"))
        item = self.tableWidget_Regions.horizontalHeaderItem(2)
        item.setText(_translate("Dialog", "Size(bytes)"))
        item = self.tableWidget_Regions.horizontalHeaderItem(3)
        item.setText(_translate("Dialog", "Type"))
        item = self.tableWidget_Regions.horizontalHeaderItem(4)
        item.setText(_translate("Dialog", "Load Address"))
        item = self.tableWidget_Regions.horizontalHeaderItem(5)
        item.setText(_translate("Dialog", "Perms"))
        item = self.tableWidget_Regions.horizontalHeaderItem(6)
        item.setText(_translate("Dialog", "File"))
from GUI.Widgets.ManageScanRegions.ScanRegionTable import QScanRegionTable

```

`GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>724</width>
    <height>568</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Manage Scan Regions</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="label">
       <property name="text">
        <string>Selected regions will be deleted from the current scan</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pushButton_Invert">
       <property name="text">
        <string>Invert Selection</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
   <item row="1" column="0">
    <widget class="QScanRegionTable" name="tableWidget_Regions">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>ID</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Start Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Size(bytes)</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Type</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Load Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Perms</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>File</string>
      </property>
     </column>
    </widget>
   </item>
   <item row="2" column="0">
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>QScanRegionTable</class>
   <extends>QTableWidget</extends>
   <header location="global">GUI.Widgets.ManageScanRegions.ScanRegionTable</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/Widgets/ManageScanRegions/ManageScanRegions.py`:

```py
from PyQt6.QtWidgets import QDialog, QTableWidgetItem
from PyQt6.QtCore import Qt
from GUI.Widgets.ManageScanRegions.Form.ManageScanRegionsDialog import Ui_Dialog
from GUI.Utils import guiutils
from libpince import debugcore
import re


class ManageScanRegionsDialog(QDialog, Ui_Dialog):
    def __init__(self, parent) -> None:
        super().__init__(parent)
        self.setupUi(self)
        self.deleted_regions: list[int] = []
        regions_text = debugcore.scanmem.send_command("lregions", True).decode("utf-8")
        regex = re.compile(r"\[\s*(\d+)\] (\w+),\s+(\d+) bytes,\s+(\w+),\s+(\w+),\s+([rwx-]+),\s+(.+)")
        data = regex.findall(regions_text)
        self.tableWidget_Regions.setRowCount(len(data))
        for row, (region_id, start_address, size, region_type, load_address, perms, file) in enumerate(data):
            id_item = QTableWidgetItem(region_id)
            id_item.setCheckState(Qt.CheckState.Unchecked)
            self.tableWidget_Regions.setItem(row, 0, id_item)
            self.tableWidget_Regions.setItem(row, 1, QTableWidgetItem(start_address))
            self.tableWidget_Regions.setItem(row, 2, QTableWidgetItem(size))
            self.tableWidget_Regions.setItem(row, 3, QTableWidgetItem(region_type))
            self.tableWidget_Regions.setItem(row, 4, QTableWidgetItem(load_address))
            self.tableWidget_Regions.setItem(row, 5, QTableWidgetItem(perms))
            self.tableWidget_Regions.setItem(row, 6, QTableWidgetItem(file))
        self.tableWidget_Regions.resizeColumnsToContents()
        guiutils.center_to_parent(self)
        self.pushButton_Invert.clicked.connect(self.invert_selection)

    def invert_selection(self) -> None:
        for row in range(self.tableWidget_Regions.rowCount()):
            item = self.tableWidget_Regions.item(row, 0)
            cur_state = item.checkState()
            new_state = Qt.CheckState.Unchecked if cur_state == Qt.CheckState.Checked else Qt.CheckState.Checked
            item.setCheckState(new_state)

    def get_values(self) -> list[int]:
        return self.deleted_regions

    def accept(self) -> None:
        for row in range(self.tableWidget_Regions.rowCount()):
            item = self.tableWidget_Regions.item(row, 0)
            if item.checkState() == Qt.CheckState.Checked:
                region_id = int(item.text())
                self.deleted_regions.append(region_id)
                debugcore.scanmem.send_command(f"dregion {region_id}")
        return super().accept()

```

`GUI/Widgets/ManageScanRegions/ScanRegionTable.py`:

```py
from PyQt6.QtWidgets import QTableWidget
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QMouseEvent, QKeyEvent


class QScanRegionTable(QTableWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

    def mousePressEvent(self, event: QMouseEvent | None) -> None:
        super().mousePressEvent(event)
        item = self.itemAt(event.pos())
        if item and item.column() == 0:
            row = item.row()
            self.selectRow(row)

    def mouseReleaseEvent(self, event: QMouseEvent | None) -> None:
        super().mouseReleaseEvent(event)
        item = self.itemAt(event.pos())
        if item and item.column() == 0:
            new_state = item.checkState()
            for selected_item in self.selectedItems():
                if selected_item.column() == 0:
                    selected_item.setCheckState(new_state)

    def keyPressEvent(self, event: QKeyEvent | None) -> None:
        if event.key() == Qt.Key.Key_Space:
            current_row = self.currentRow()
            selected_indexes = self.selectedIndexes()
            # If only one item is selected and then clicked while ctrl is being held
            # There'll be no selected rows even with a current row present
            if current_row != -1 and selected_indexes:
                if self.currentItem().isSelected():
                    selected_row = current_row
                else:
                    selected_row = selected_indexes[0].row()
                cur_state = self.item(selected_row, 0).checkState()
                new_state = Qt.CheckState.Unchecked if cur_state == Qt.CheckState.Checked else Qt.CheckState.Checked
                for selected_item in self.selectedItems():
                    if selected_item.column() == 0:
                        selected_item.setCheckState(new_state)
        else:
            super().keyPressEvent(event)

```

`GUI/Widgets/PointerScan/Form/PointerScanWindow.py`:

```py
# Form implementation generated from reading ui file 'Widgets/PointerScan/Form/PointerScanWindow.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(783, 691)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_ScanResult = QtWidgets.QTableWidget(parent=self.centralwidget)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_ScanResult.setFont(font)
        self.tableWidget_ScanResult.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_ScanResult.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_ScanResult.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_ScanResult.setObjectName("tableWidget_ScanResult")
        self.tableWidget_ScanResult.setColumnCount(0)
        self.tableWidget_ScanResult.setRowCount(0)
        self.tableWidget_ScanResult.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_ScanResult.verticalHeader().setVisible(False)
        self.tableWidget_ScanResult.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_ScanResult.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_ScanResult, 2, 0, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pushButton_Sort = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_Sort.setObjectName("pushButton_Sort")
        self.horizontalLayout.addWidget(self.pushButton_Sort)
        self.pushButton_Clear = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton_Clear.setObjectName("pushButton_Clear")
        self.horizontalLayout.addWidget(self.pushButton_Clear)
        spacerItem = QtWidgets.QSpacerItem(684, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        self.textEdit = QtWidgets.QTextEdit(parent=self.centralwidget)
        self.textEdit.setObjectName("textEdit")
        self.gridLayout.addWidget(self.textEdit, 1, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 783, 30))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(parent=self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuActions = QtWidgets.QMenu(parent=self.menubar)
        self.menuActions.setObjectName("menuActions")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionOpen = QtGui.QAction(parent=MainWindow)
        self.actionOpen.setObjectName("actionOpen")
        self.actionSaveAs = QtGui.QAction(parent=MainWindow)
        self.actionSaveAs.setObjectName("actionSaveAs")
        self.actionScan = QtGui.QAction(parent=MainWindow)
        self.actionScan.setObjectName("actionScan")
        self.actionFilter = QtGui.QAction(parent=MainWindow)
        self.actionFilter.setObjectName("actionFilter")
        self.menuFile.addAction(self.actionOpen)
        self.menuFile.addAction(self.actionSaveAs)
        self.menuActions.addAction(self.actionScan)
        self.menuActions.addAction(self.actionFilter)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuActions.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Pointer Scanner"))
        self.tableWidget_ScanResult.setSortingEnabled(True)
        self.pushButton_Sort.setText(_translate("MainWindow", "Sort"))
        self.pushButton_Clear.setText(_translate("MainWindow", "Clear"))
        self.menuFile.setTitle(_translate("MainWindow", "Fi&le"))
        self.menuActions.setTitle(_translate("MainWindow", "Actio&ns"))
        self.actionOpen.setText(_translate("MainWindow", "&Open"))
        self.actionSaveAs.setText(_translate("MainWindow", "&Save As..."))
        self.actionScan.setText(_translate("MainWindow", "&Scan"))
        self.actionFilter.setText(_translate("MainWindow", "&Filter"))

```

`GUI/Widgets/PointerScan/Form/PointerScanWindow.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>MainWindow</class>
 <widget class="QMainWindow" name="MainWindow">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>783</width>
    <height>691</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Pointer Scanner</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <layout class="QGridLayout" name="gridLayout">
    <item row="2" column="0">
     <widget class="QTableWidget" name="tableWidget_ScanResult">
      <property name="font">
       <font>
        <family>Monospace</family>
       </font>
      </property>
      <property name="editTriggers">
       <set>QAbstractItemView::EditTrigger::NoEditTriggers</set>
      </property>
      <property name="selectionMode">
       <enum>QAbstractItemView::SelectionMode::SingleSelection</enum>
      </property>
      <property name="selectionBehavior">
       <enum>QAbstractItemView::SelectionBehavior::SelectRows</enum>
      </property>
      <property name="sortingEnabled">
       <bool>true</bool>
      </property>
      <attribute name="horizontalHeaderStretchLastSection">
       <bool>true</bool>
      </attribute>
      <attribute name="verticalHeaderVisible">
       <bool>false</bool>
      </attribute>
      <attribute name="verticalHeaderMinimumSectionSize">
       <number>16</number>
      </attribute>
      <attribute name="verticalHeaderDefaultSectionSize">
       <number>16</number>
      </attribute>
     </widget>
    </item>
    <item row="0" column="0">
     <layout class="QHBoxLayout" name="horizontalLayout">
      <item>
       <widget class="QPushButton" name="pushButton_Sort">
        <property name="text">
         <string>Sort</string>
        </property>
       </widget>
      </item>
      <item>
       <widget class="QPushButton" name="pushButton_Clear">
        <property name="text">
         <string>Clear</string>
        </property>
       </widget>
      </item>
      <item>
       <spacer name="horizontalSpacer">
        <property name="orientation">
         <enum>Qt::Orientation::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
          <width>684</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
     </layout>
    </item>
    <item row="1" column="0">
     <widget class="QTextEdit" name="textEdit"/>
    </item>
   </layout>
  </widget>
  <widget class="QMenuBar" name="menubar">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>0</y>
     <width>783</width>
     <height>30</height>
    </rect>
   </property>
   <widget class="QMenu" name="menuFile">
    <property name="title">
     <string>Fi&amp;le</string>
    </property>
    <addaction name="actionOpen"/>
    <addaction name="actionSaveAs"/>
   </widget>
   <widget class="QMenu" name="menuActions">
    <property name="title">
     <string>Actio&amp;ns</string>
    </property>
    <addaction name="actionScan"/>
    <addaction name="actionFilter"/>
   </widget>
   <addaction name="menuFile"/>
   <addaction name="menuActions"/>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <action name="actionOpen">
   <property name="text">
    <string>&amp;Open</string>
   </property>
  </action>
  <action name="actionSaveAs">
   <property name="text">
    <string>&amp;Save As...</string>
   </property>
  </action>
  <action name="actionScan">
   <property name="text">
    <string>&amp;Scan</string>
   </property>
  </action>
  <action name="actionFilter">
   <property name="text">
    <string>&amp;Filter</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/Widgets/PointerScan/PointerScan.py`:

```py
from PyQt6.QtWidgets import QMainWindow, QFileDialog
from GUI.Widgets.PointerScan.Form.PointerScanWindow import Ui_MainWindow
from GUI.Widgets.PointerScanFilter.PointerScanFilter import PointerScanFilterDialog
from GUI.Widgets.PointerScanSearch.PointerScanSearch import PointerScanSearchDialog
from GUI.Utils import guiutils
from GUI.States import states
from libpince import debugcore, utils
from tr.tr import TranslationConstants as tr
import os


class PointerScanWindow(QMainWindow, Ui_MainWindow):
    def __init__(self, parent) -> None:
        super().__init__(parent)
        self.setupUi(self)
        self.tableWidget_ScanResult.hide()
        states.process_signals.attach.connect(self.on_process_changed)
        states.process_signals.exit.connect(self.on_process_changed)
        self.pushButton_Clear.pressed.connect(self.pushButton_Clear_pressed)
        self.pushButton_Sort.pressed.connect(self.pushButton_Sort_pressed)
        self.actionOpen.triggered.connect(self.actionOpen_triggered)
        self.actionSaveAs.triggered.connect(self.actionSaveAs_triggered)
        self.actionScan.triggered.connect(self.scan_triggered)
        self.actionFilter.triggered.connect(self.filter_triggered)
        if debugcore.currentpid == -1:
            self.actionScan.setEnabled(False)
        guiutils.center_to_parent(self)

    def on_process_changed(self) -> None:
        val: bool = False if debugcore.currentpid == -1 else True
        self.actionScan.setEnabled(val)

    def pushButton_Clear_pressed(self) -> None:
        self.textEdit.clear()

    def pushButton_Sort_pressed(self) -> None:
        text: str = self.textEdit.toPlainText()
        if text == "":
            return
        text_list: list[str] = text.split(os.linesep)
        # Sometimes files will have ending newlines.
        # We want to get rid of them otherwise they'll be at top.
        if text_list[-1] == "":
            del text_list[-1]
        text_list.sort()
        self.textEdit.setText(os.linesep.join(text_list))

    def actionOpen_triggered(self) -> None:
        file_path, _ = QFileDialog.getOpenFileName(self, tr.SELECT_POINTER_MAP, None, tr.FILE_TYPES_SCANDATA)
        if file_path != "":
            self.textEdit.clear()
            with open(file_path) as file:
                self.textEdit.setText(file.read())

    def actionSaveAs_triggered(self) -> None:
        file_path, _ = QFileDialog.getSaveFileName(self, tr.SELECT_POINTER_MAP, None, tr.FILE_TYPES_SCANDATA)
        if file_path != "":
            file_path = utils.append_file_extension(file_path, "scandata")
            with open(file_path, "w") as file:
                file.write(self.textEdit.toPlainText())

    def scan_triggered(self) -> None:
        dialog = PointerScanSearchDialog(self, "0x0")
        dialog.exec()

    def filter_triggered(self) -> None:
        dialog = PointerScanFilterDialog(self)
        if dialog.exec():
            filter_result: list[str] | None = dialog.get_filter_result()
            if filter_result == None:
                return
            self.textEdit.clear()
            self.textEdit.setText(os.linesep.join(filter_result))

```

`GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.py`:

```py
# Form implementation generated from reading ui file 'Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(400, 129)
        Dialog.setMinimumSize(QtCore.QSize(400, 129))
        Dialog.setMaximumSize(QtCore.QSize(400, 129))
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setContentsMargins(0, -1, -1, -1)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setScaledContents(False)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit_File1Path = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_File1Path.setReadOnly(True)
        self.lineEdit_File1Path.setObjectName("lineEdit_File1Path")
        self.horizontalLayout.addWidget(self.lineEdit_File1Path)
        self.pushButton_File1Browse = QtWidgets.QPushButton(parent=Dialog)
        self.pushButton_File1Browse.setObjectName("pushButton_File1Browse")
        self.horizontalLayout.addWidget(self.pushButton_File1Browse)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label_2 = QtWidgets.QLabel(parent=Dialog)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_2.addWidget(self.label_2)
        self.lineEdit_File2Path = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_File2Path.setReadOnly(True)
        self.lineEdit_File2Path.setObjectName("lineEdit_File2Path")
        self.horizontalLayout_2.addWidget(self.lineEdit_File2Path)
        self.pushButton_File2Browse = QtWidgets.QPushButton(parent=Dialog)
        self.pushButton_File2Browse.setObjectName("pushButton_File2Browse")
        self.horizontalLayout_2.addWidget(self.pushButton_File2Browse)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel)
        self.buttonBox.setObjectName("buttonBox")
        self.verticalLayout.addWidget(self.buttonBox)
        self.gridLayout.addLayout(self.verticalLayout, 0, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Filter Pointers"))
        self.label.setText(_translate("Dialog", "File 1:"))
        self.pushButton_File1Browse.setText(_translate("Dialog", "Browse"))
        self.label_2.setText(_translate("Dialog", "File 2:"))
        self.pushButton_File2Browse.setText(_translate("Dialog", "Browse"))

```

`GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>400</width>
    <height>129</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>400</width>
    <height>129</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>400</width>
    <height>129</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Filter Pointers</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <property name="leftMargin">
      <number>0</number>
     </property>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout">
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>File 1:</string>
         </property>
         <property name="scaledContents">
          <bool>false</bool>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLineEdit" name="lineEdit_File1Path">
         <property name="readOnly">
          <bool>true</bool>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="pushButton_File1Browse">
         <property name="text">
          <string>Browse</string>
         </property>
        </widget>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_2">
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>File 2:</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLineEdit" name="lineEdit_File2Path">
         <property name="readOnly">
          <bool>true</bool>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="pushButton_File2Browse">
         <property name="text">
          <string>Browse</string>
         </property>
        </widget>
       </item>
      </layout>
     </item>
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="orientation">
        <enum>Qt::Horizontal</enum>
       </property>
       <property name="standardButtons">
        <set>QDialogButtonBox::Cancel</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/Widgets/PointerScanFilter/PointerScanFilter.py`:

```py
from PyQt6.QtWidgets import QDialog, QDialogButtonBox, QFileDialog, QPushButton, QLineEdit
from GUI.Widgets.PointerScanFilter.Form.PointerScanFilterDialog import Ui_Dialog
from GUI.Utils import guiutils
from tr.tr import TranslationConstants as tr
import os, collections


class PointerScanFilterDialog(QDialog, Ui_Dialog):
    def __init__(self, parent) -> None:
        super().__init__(parent)
        self.setupUi(self)
        guiutils.center_to_parent(self)
        self.pushButton_File1Browse.clicked.connect(self.pushButton_File1Browse_clicked)
        self.pushButton_File2Browse.clicked.connect(self.pushButton_File2Browse_clicked)
        self.filter_button: QPushButton | None = self.buttonBox.addButton(
            tr.FILTER, QDialogButtonBox.ButtonRole.ActionRole
        )
        if self.filter_button:
            self.filter_button.clicked.connect(self.filter_button_clicked)
            self.filter_button.setEnabled(False)
        self.filter_result: list[str] | None = None

    def browse_scandata_file(self, file_path_field: QLineEdit) -> None:
        file_path, _ = QFileDialog.getOpenFileName(self, tr.SELECT_POINTER_MAP, None, tr.FILE_TYPES_SCANDATA)
        if file_path != "":
            file_path_field.setText(file_path)
            self.check_filterable_state()

    def check_filterable_state(self) -> None:
        if self.lineEdit_File1Path.text() != "" and self.lineEdit_File2Path.text() != "" and self.filter_button:
            self.filter_button.setEnabled(True)

    def pushButton_File1Browse_clicked(self) -> None:
        self.browse_scandata_file(self.lineEdit_File1Path)

    def pushButton_File2Browse_clicked(self) -> None:
        self.browse_scandata_file(self.lineEdit_File2Path)

    def filter_button_clicked(self) -> None:
        if self.lineEdit_File1Path.text() == "" or self.lineEdit_File2Path.text() == "" or self.filter_button == None:
            return
        self.filter_button.setEnabled(False)
        self.filter_button.setText(tr.FILTERING)
        lines: list[str]
        with open(self.lineEdit_File1Path.text()) as file:
            lines = file.read().split(os.linesep)
        with open(self.lineEdit_File2Path.text()) as file:
            lines.extend(file.read().split(os.linesep))
        counts = collections.Counter(lines)
        self.filter_result = list(set([line for line in lines if counts[line] > 1 and line != ""]))
        self.accept()

    def get_filter_result(self) -> list[str] | None:
        return self.filter_result

```

`GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.py`:

```py
# Form implementation generated from reading ui file 'Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(404, 390)
        Dialog.setMinimumSize(QtCore.QSize(404, 390))
        Dialog.setMaximumSize(QtCore.QSize(404, 390))
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(parent=Dialog)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit_Address = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_Address.setObjectName("lineEdit_Address")
        self.horizontalLayout.addWidget(self.lineEdit_Address)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.label_2 = QtWidgets.QLabel(parent=Dialog)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout.addWidget(self.label_2)
        self.spinBox_Depth = QtWidgets.QSpinBox(parent=Dialog)
        self.spinBox_Depth.setMinimum(1)
        self.spinBox_Depth.setProperty("value", 3)
        self.spinBox_Depth.setObjectName("spinBox_Depth")
        self.horizontalLayout.addWidget(self.spinBox_Depth)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label_3 = QtWidgets.QLabel(parent=Dialog)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout_2.addWidget(self.label_3)
        self.spinBox_ScanRangeStart = QtWidgets.QSpinBox(parent=Dialog)
        self.spinBox_ScanRangeStart.setMaximum(16777215)
        self.spinBox_ScanRangeStart.setDisplayIntegerBase(16)
        self.spinBox_ScanRangeStart.setObjectName("spinBox_ScanRangeStart")
        self.horizontalLayout_2.addWidget(self.spinBox_ScanRangeStart)
        self.label_4 = QtWidgets.QLabel(parent=Dialog)
        self.label_4.setObjectName("label_4")
        self.horizontalLayout_2.addWidget(self.label_4)
        self.spinBox_ScanRangeEnd = QtWidgets.QSpinBox(parent=Dialog)
        self.spinBox_ScanRangeEnd.setSuffix("")
        self.spinBox_ScanRangeEnd.setMaximum(16777215)
        self.spinBox_ScanRangeEnd.setProperty("value", 1000)
        self.spinBox_ScanRangeEnd.setDisplayIntegerBase(16)
        self.spinBox_ScanRangeEnd.setObjectName("spinBox_ScanRangeEnd")
        self.horizontalLayout_2.addWidget(self.spinBox_ScanRangeEnd)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem2)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.label_10 = QtWidgets.QLabel(parent=Dialog)
        self.label_10.setObjectName("label_10")
        self.horizontalLayout_7.addWidget(self.label_10)
        self.lineEdit_Path = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_Path.setEnabled(True)
        self.lineEdit_Path.setText("")
        self.lineEdit_Path.setDragEnabled(False)
        self.lineEdit_Path.setReadOnly(True)
        self.lineEdit_Path.setClearButtonEnabled(False)
        self.lineEdit_Path.setObjectName("lineEdit_Path")
        self.horizontalLayout_7.addWidget(self.lineEdit_Path)
        self.pushButton_PathBrowse = QtWidgets.QPushButton(parent=Dialog)
        self.pushButton_PathBrowse.setEnabled(True)
        self.pushButton_PathBrowse.setObjectName("pushButton_PathBrowse")
        self.horizontalLayout_7.addWidget(self.pushButton_PathBrowse)
        self.verticalLayout.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.label_11 = QtWidgets.QLabel(parent=Dialog)
        self.label_11.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.label_11.setObjectName("label_11")
        self.horizontalLayout_8.addWidget(self.label_11)
        self.verticalLayout.addLayout(self.horizontalLayout_8)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_5 = QtWidgets.QLabel(parent=Dialog)
        self.label_5.setObjectName("label_5")
        self.horizontalLayout_3.addWidget(self.label_5)
        self.spinBox_ScanLRangeStart = QtWidgets.QSpinBox(parent=Dialog)
        self.spinBox_ScanLRangeStart.setMaximum(16777215)
        self.spinBox_ScanLRangeStart.setProperty("value", 0)
        self.spinBox_ScanLRangeStart.setDisplayIntegerBase(16)
        self.spinBox_ScanLRangeStart.setObjectName("spinBox_ScanLRangeStart")
        self.horizontalLayout_3.addWidget(self.spinBox_ScanLRangeStart)
        self.label_9 = QtWidgets.QLabel(parent=Dialog)
        self.label_9.setObjectName("label_9")
        self.horizontalLayout_3.addWidget(self.label_9)
        self.spinBox_ScanLRangeEnd = QtWidgets.QSpinBox(parent=Dialog)
        self.spinBox_ScanLRangeEnd.setMaximum(16777215)
        self.spinBox_ScanLRangeEnd.setProperty("value", 0)
        self.spinBox_ScanLRangeEnd.setDisplayIntegerBase(16)
        self.spinBox_ScanLRangeEnd.setObjectName("spinBox_ScanLRangeEnd")
        self.horizontalLayout_3.addWidget(self.spinBox_ScanLRangeEnd)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem3)
        self.verticalLayout.addLayout(self.horizontalLayout_3)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.label_6 = QtWidgets.QLabel(parent=Dialog)
        self.label_6.setObjectName("label_6")
        self.horizontalLayout_4.addWidget(self.label_6)
        self.spinBox_Node = QtWidgets.QSpinBox(parent=Dialog)
        self.spinBox_Node.setMinimum(0)
        self.spinBox_Node.setProperty("value", 0)
        self.spinBox_Node.setObjectName("spinBox_Node")
        self.horizontalLayout_4.addWidget(self.spinBox_Node)
        spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem4)
        self.verticalLayout.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.label_7 = QtWidgets.QLabel(parent=Dialog)
        self.label_7.setObjectName("label_7")
        self.horizontalLayout_5.addWidget(self.label_7)
        self.lineEdit_Last = QtWidgets.QLineEdit(parent=Dialog)
        self.lineEdit_Last.setObjectName("lineEdit_Last")
        self.horizontalLayout_5.addWidget(self.lineEdit_Last)
        spacerItem5 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_5.addItem(spacerItem5)
        self.verticalLayout.addLayout(self.horizontalLayout_5)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.label_8 = QtWidgets.QLabel(parent=Dialog)
        self.label_8.setObjectName("label_8")
        self.horizontalLayout_6.addWidget(self.label_8)
        self.spinBox_Max = QtWidgets.QSpinBox(parent=Dialog)
        self.spinBox_Max.setMaximum(1000)
        self.spinBox_Max.setProperty("value", 0)
        self.spinBox_Max.setObjectName("spinBox_Max")
        self.horizontalLayout_6.addWidget(self.spinBox_Max)
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_6.addItem(spacerItem6)
        self.verticalLayout.addLayout(self.horizontalLayout_6)
        self.checkBox_Cycle = QtWidgets.QCheckBox(parent=Dialog)
        self.checkBox_Cycle.setObjectName("checkBox_Cycle")
        self.verticalLayout.addWidget(self.checkBox_Cycle)
        spacerItem7 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout.addItem(spacerItem7)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel)
        self.buttonBox.setObjectName("buttonBox")
        self.verticalLayout.addWidget(self.buttonBox)
        self.gridLayout.addLayout(self.verticalLayout, 0, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Scan for Pointers"))
        self.label.setText(_translate("Dialog", "Address"))
        self.label_2.setText(_translate("Dialog", "Depth"))
        self.label_3.setText(_translate("Dialog", "Scan Range"))
        self.spinBox_ScanRangeStart.setPrefix(_translate("Dialog", "0x"))
        self.label_4.setText(_translate("Dialog", "<->"))
        self.spinBox_ScanRangeEnd.setPrefix(_translate("Dialog", "0x"))
        self.label_10.setText(_translate("Dialog", "File Path:"))
        self.pushButton_PathBrowse.setText(_translate("Dialog", "Browse"))
        self.label_11.setText(_translate("Dialog", "Optional Parameters (0 or empty will use defaults)"))
        self.label_5.setText(_translate("Dialog", "Last Offset Scan Range"))
        self.spinBox_ScanLRangeStart.setPrefix(_translate("Dialog", "0x"))
        self.label_9.setText(_translate("Dialog", "<->"))
        self.spinBox_ScanLRangeEnd.setPrefix(_translate("Dialog", "0x"))
        self.label_6.setText(_translate("Dialog", "Minimum Chain Length"))
        self.label_7.setText(_translate("Dialog", "Last Offset Value"))
        self.label_8.setText(_translate("Dialog", "Max Results"))
        self.checkBox_Cycle.setText(_translate("Dialog", "Solve Circular References"))

```

`GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>404</width>
    <height>390</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>404</width>
    <height>390</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>404</width>
    <height>390</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>Scan for Pointers</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout">
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>Address</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLineEdit" name="lineEdit_Address"/>
       </item>
       <item>
        <spacer name="horizontalSpacer">
         <property name="orientation">
          <enum>Qt::Orientation::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
       <item>
        <widget class="QLabel" name="label_2">
         <property name="text">
          <string>Depth</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QSpinBox" name="spinBox_Depth">
         <property name="minimum">
          <number>1</number>
         </property>
         <property name="value">
          <number>3</number>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_7">
         <property name="orientation">
          <enum>Qt::Orientation::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_2">
       <item>
        <widget class="QLabel" name="label_3">
         <property name="text">
          <string>Scan Range</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QSpinBox" name="spinBox_ScanRangeStart">
         <property name="prefix">
          <string>0x</string>
         </property>
         <property name="maximum">
          <number>16777215</number>
         </property>
         <property name="displayIntegerBase">
          <number>16</number>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_4">
         <property name="text">
          <string>&lt;-&gt;</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QSpinBox" name="spinBox_ScanRangeEnd">
         <property name="suffix">
          <string/>
         </property>
         <property name="prefix">
          <string>0x</string>
         </property>
         <property name="maximum">
          <number>16777215</number>
         </property>
         <property name="value">
          <number>1000</number>
         </property>
         <property name="displayIntegerBase">
          <number>16</number>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_6">
         <property name="orientation">
          <enum>Qt::Orientation::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_7">
       <item>
        <widget class="QLabel" name="label_10">
         <property name="text">
          <string>File Path:</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLineEdit" name="lineEdit_Path">
         <property name="enabled">
          <bool>true</bool>
         </property>
         <property name="text">
          <string/>
         </property>
         <property name="dragEnabled">
          <bool>false</bool>
         </property>
         <property name="readOnly">
          <bool>true</bool>
         </property>
         <property name="clearButtonEnabled">
          <bool>false</bool>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QPushButton" name="pushButton_PathBrowse">
         <property name="enabled">
          <bool>true</bool>
         </property>
         <property name="text">
          <string>Browse</string>
         </property>
        </widget>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_8">
       <item>
        <widget class="QLabel" name="label_11">
         <property name="text">
          <string>Optional Parameters (0 or empty will use defaults)</string>
         </property>
         <property name="alignment">
          <set>Qt::AlignmentFlag::AlignCenter</set>
         </property>
        </widget>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_3">
       <item>
        <widget class="QLabel" name="label_5">
         <property name="text">
          <string>Last Offset Scan Range</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QSpinBox" name="spinBox_ScanLRangeStart">
         <property name="prefix">
          <string>0x</string>
         </property>
         <property name="maximum">
          <number>16777215</number>
         </property>
         <property name="value">
          <number>0</number>
         </property>
         <property name="displayIntegerBase">
          <number>16</number>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLabel" name="label_9">
         <property name="text">
          <string>&lt;-&gt;</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QSpinBox" name="spinBox_ScanLRangeEnd">
         <property name="prefix">
          <string>0x</string>
         </property>
         <property name="maximum">
          <number>16777215</number>
         </property>
         <property name="value">
          <number>0</number>
         </property>
         <property name="displayIntegerBase">
          <number>16</number>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_5">
         <property name="orientation">
          <enum>Qt::Orientation::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_4">
       <item>
        <widget class="QLabel" name="label_6">
         <property name="text">
          <string>Minimum Chain Length</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QSpinBox" name="spinBox_Node">
         <property name="minimum">
          <number>0</number>
         </property>
         <property name="value">
          <number>0</number>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_4">
         <property name="orientation">
          <enum>Qt::Orientation::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_5">
       <item>
        <widget class="QLabel" name="label_7">
         <property name="text">
          <string>Last Offset Value</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QLineEdit" name="lineEdit_Last"/>
       </item>
       <item>
        <spacer name="horizontalSpacer_2">
         <property name="orientation">
          <enum>Qt::Orientation::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_6">
       <item>
        <widget class="QLabel" name="label_8">
         <property name="text">
          <string>Max Results</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QSpinBox" name="spinBox_Max">
         <property name="maximum">
          <number>1000</number>
         </property>
         <property name="value">
          <number>0</number>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_3">
         <property name="orientation">
          <enum>Qt::Orientation::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
      </layout>
     </item>
     <item>
      <widget class="QCheckBox" name="checkBox_Cycle">
       <property name="text">
        <string>Solve Circular References</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="verticalSpacer">
       <property name="orientation">
        <enum>Qt::Orientation::Vertical</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>20</width>
         <height>40</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="orientation">
        <enum>Qt::Orientation::Horizontal</enum>
       </property>
       <property name="standardButtons">
        <set>QDialogButtonBox::StandardButton::Cancel</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`GUI/Widgets/PointerScanSearch/PointerScanSearch.py`:

```py
from PyQt6.QtWidgets import QDialog, QDialogButtonBox, QFileDialog, QPushButton, QMessageBox
from GUI.Widgets.PointerScanSearch.Form.PointerScanSearchDialog import Ui_Dialog
from GUI.Utils import guiutils, guitypedefs
from libpince import debugcore, utils
from libpince.debugcore import ptrscan
from libpince.libptrscan.ptrscan import FFIRange, FFIParam
from tr.tr import TranslationConstants as tr
import os


class PointerScanSearchDialog(QDialog, Ui_Dialog):
    def __init__(self, parent, address) -> None:
        super().__init__(parent)
        self.setupUi(self)
        guiutils.center_to_parent(self)
        self.lineEdit_Address.setText(address)
        self.lineEdit_Path.setText(os.getcwd() + f"/{utils.get_process_name(debugcore.currentpid)}.scandata")
        self.pushButton_PathBrowse.clicked.connect(self.pushButton_PathBrowse_clicked)
        self.scan_button: QPushButton | None = self.buttonBox.addButton(tr.SCAN, QDialogButtonBox.ButtonRole.ActionRole)
        if self.scan_button:
            self.scan_button.clicked.connect(self.scan_button_clicked)
        self.ptrscan_thread: guitypedefs.InterruptableWorker | None = None

    def pushButton_PathBrowse_clicked(self) -> None:
        file_path, _ = QFileDialog.getSaveFileName(self, tr.SELECT_POINTER_MAP, None, tr.FILE_TYPES_SCANDATA)
        if file_path != "":
            file_path = utils.append_file_extension(file_path, "scandata")
            self.lineEdit_Path.setText(file_path)

    def reject(self) -> None:
        if self.ptrscan_thread:
            self.ptrscan_thread.stop()
        return super().reject()

    def scan_button_clicked(self) -> None:
        if debugcore.currentpid == -1 or self.scan_button == None:
            return
        self.scan_button.setText(tr.SCANNING)
        self.scan_button.setEnabled(False)
        self.pushButton_PathBrowse.setEnabled(False)
        params: FFIParam = FFIParam()
        addr_val = utils.safe_str_to_int(self.lineEdit_Address.text(), 16)
        params.addr(addr_val)
        params.depth(self.spinBox_Depth.value())
        params.srange(FFIRange(self.spinBox_ScanRangeStart.value(), self.spinBox_ScanRangeEnd.value()))
        lrange_start: int = self.spinBox_ScanLRangeStart.value()
        lrange_end: int = self.spinBox_ScanLRangeEnd.value()
        if lrange_start == 0 and lrange_end == 0:
            lrange_val = None
        else:
            lrange_val = FFIRange(lrange_start, lrange_end)
        params.lrange(lrange_val)
        params.node(utils.return_optional_int(self.spinBox_Node.value()))
        try:
            last_val = int(self.lineEdit_Last.text(), 16)
        except ValueError:
            last_val = None
        params.last(last_val)
        params.max(utils.return_optional_int(self.spinBox_Max.value()))
        params.cycle(self.checkBox_Cycle.isChecked())
        ptrscan.set_modules(ptrscan.list_modules_pince())  # TODO: maybe cache this and let user refresh with a button
        ptrscan.create_pointer_map()  # TODO: maybe cache this and let user refresh with a button
        ptrmap_file_path = self.lineEdit_Path.text()
        if os.path.isfile(ptrmap_file_path):
            os.remove(ptrmap_file_path)
        self.ptrscan_thread = guitypedefs.InterruptableWorker(ptrscan.scan_pointer_chain, params, ptrmap_file_path)
        self.ptrscan_thread.signals.finished.connect(self.ptrscan_callback)
        self.ptrscan_thread.start()

    def ptrscan_callback(self) -> None:
        self.accept()
        QMessageBox.information(self, tr.SUCCESS, tr.POINTER_SCAN_SUCCESS)

```

`GUI/Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.py`:

```py
# Form implementation generated from reading ui file 'Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(429, 420)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setObjectName("gridLayout")
        self.tableWidget_Instructions = QtWidgets.QTableWidget(parent=Form)
        font = QtGui.QFont()
        font.setFamily("Monospace")
        self.tableWidget_Instructions.setFont(font)
        self.tableWidget_Instructions.setEditTriggers(QtWidgets.QAbstractItemView.EditTrigger.NoEditTriggers)
        self.tableWidget_Instructions.setSelectionMode(QtWidgets.QAbstractItemView.SelectionMode.SingleSelection)
        self.tableWidget_Instructions.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectionBehavior.SelectRows)
        self.tableWidget_Instructions.setWordWrap(False)
        self.tableWidget_Instructions.setObjectName("tableWidget_Instructions")
        self.tableWidget_Instructions.setColumnCount(3)
        self.tableWidget_Instructions.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Instructions.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Instructions.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget_Instructions.setHorizontalHeaderItem(2, item)
        self.tableWidget_Instructions.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_Instructions.verticalHeader().setVisible(False)
        self.tableWidget_Instructions.verticalHeader().setDefaultSectionSize(16)
        self.tableWidget_Instructions.verticalHeader().setMinimumSectionSize(16)
        self.gridLayout.addWidget(self.tableWidget_Instructions, 0, 0, 1, 1)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Restore Instructions"))
        self.tableWidget_Instructions.setSortingEnabled(True)
        item = self.tableWidget_Instructions.horizontalHeaderItem(0)
        item.setText(_translate("Form", "Address"))
        item = self.tableWidget_Instructions.horizontalHeaderItem(1)
        item.setText(_translate("Form", "Original OpCode"))
        item = self.tableWidget_Instructions.horizontalHeaderItem(2)
        item.setText(_translate("Form", "Original Instruction"))

```

`GUI/Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Form</class>
 <widget class="QWidget" name="Form">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>429</width>
    <height>420</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Restore Instructions</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <widget class="QTableWidget" name="tableWidget_Instructions">
     <property name="font">
      <font>
       <family>Monospace</family>
      </font>
     </property>
     <property name="editTriggers">
      <set>QAbstractItemView::NoEditTriggers</set>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SingleSelection</enum>
     </property>
     <property name="selectionBehavior">
      <enum>QAbstractItemView::SelectRows</enum>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <property name="wordWrap">
      <bool>false</bool>
     </property>
     <attribute name="horizontalHeaderStretchLastSection">
      <bool>true</bool>
     </attribute>
     <attribute name="verticalHeaderVisible">
      <bool>false</bool>
     </attribute>
     <attribute name="verticalHeaderMinimumSectionSize">
      <number>16</number>
     </attribute>
     <attribute name="verticalHeaderDefaultSectionSize">
      <number>16</number>
     </attribute>
     <column>
      <property name="text">
       <string>Address</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Original OpCode</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Original Instruction</string>
      </property>
     </column>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/Widgets/RestoreInstructions/RestoreInstructions.py`:

```py
from PyQt6.QtWidgets import QWidget, QTableWidgetItem, QMenu
from PyQt6.QtCore import Qt, QKeyCombination, pyqtSignal
from PyQt6.QtGui import QKeyEvent, QContextMenuEvent
from GUI.Utils import guiutils
from GUI.Widgets.RestoreInstructions.Form.RestoreInstructionsWidget import Ui_Form
from tr.tr import TranslationConstants as tr
from libpince import debugcore, utils, typedefs

ADDR_COL = 0
AOB_COL = 1
NAME_COL = 2


class RestoreInstructionsWidget(QWidget, Ui_Form):
    restored = pyqtSignal()
    double_clicked = pyqtSignal(str)

    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableWidget_Instructions_keyPressEvent_original = self.tableWidget_Instructions.keyPressEvent
        self.tableWidget_Instructions.keyPressEvent = self.tableWidget_Instructions_key_press_event
        self.tableWidget_Instructions.contextMenuEvent = self.tableWidget_Instructions_context_menu_event
        self.tableWidget_Instructions.itemDoubleClicked.connect(self.tableWidget_Instructions_double_clicked)
        self.refresh()
        guiutils.center_to_parent(self)

    def tableWidget_Instructions_context_menu_event(self, event: QContextMenuEvent):
        selected_row = guiutils.get_current_row(self.tableWidget_Instructions)
        menu = QMenu()
        restore_instruction = menu.addAction(tr.RESTORE_INSTRUCTION)
        if selected_row != -1:
            selected_address_text = self.tableWidget_Instructions.item(selected_row, ADDR_COL).text()
            selected_address = int(utils.extract_hex_address(selected_address_text), 16)
        else:
            guiutils.delete_menu_entries(menu, [restore_instruction])
            selected_address = None
        menu.addSeparator()
        refresh = menu.addAction(f"{tr.REFRESH}[R]")
        font_size = self.tableWidget_Instructions.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {restore_instruction: lambda: self.restore_instruction(selected_address), refresh: self.refresh}
        try:
            actions[action]()
        except KeyError:
            pass

    def restore_instruction(self, selected_address: int):
        debugcore.restore_instruction(selected_address)
        self.refresh()
        self.restored.emit()

    def refresh(self):
        modified_instructions = debugcore.get_modified_instructions()
        self.tableWidget_Instructions.setRowCount(len(modified_instructions))
        for row, (address, aob) in enumerate(modified_instructions.items()):
            self.tableWidget_Instructions.setItem(row, ADDR_COL, QTableWidgetItem(hex(address)))
            self.tableWidget_Instructions.setItem(row, AOB_COL, QTableWidgetItem(aob))
            instr_name = utils.disassemble(aob, address, debugcore.get_inferior_arch())
            if not instr_name:
                instr_name = "??"
            self.tableWidget_Instructions.setItem(row, NAME_COL, QTableWidgetItem(instr_name))
        guiutils.resize_to_contents(self.tableWidget_Instructions)

    def tableWidget_Instructions_key_press_event(self, event: QKeyEvent):
        actions = typedefs.KeyboardModifiersTupleDict(
            [(QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_R), self.refresh)]
        )
        try:
            actions[QKeyCombination(event.modifiers(), Qt.Key(event.key()))]()
        except KeyError:
            pass
        self.tableWidget_Instructions_keyPressEvent_original(event)

    def tableWidget_Instructions_double_clicked(self, index: QTableWidgetItem):
        current_address_text = self.tableWidget_Instructions.item(index.row(), ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        self.double_clicked.emit(current_address)

```

`GUI/Widgets/SessionNotes/Form/SessionNotes.py`:

```py
# Form implementation generated from reading ui file 'Widgets/SessionNotes/Form/SessionNotes.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_SessionNotes(object):
    def setupUi(self, SessionNotes):
        SessionNotes.setObjectName("SessionNotes")
        SessionNotes.setWindowModality(QtCore.Qt.WindowModality.WindowModal)
        SessionNotes.resize(259, 190)
        self.gridLayout = QtWidgets.QGridLayout(SessionNotes)
        self.gridLayout.setObjectName("gridLayout")
        self.textEdit_Notes = QtWidgets.QTextEdit(parent=SessionNotes)
        self.textEdit_Notes.setMinimumSize(QtCore.QSize(50, 50))
        self.textEdit_Notes.setObjectName("textEdit_Notes")
        self.gridLayout.addWidget(self.textEdit_Notes, 1, 0, 1, 1)
        self.label = QtWidgets.QLabel(parent=SessionNotes)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)

        self.retranslateUi(SessionNotes)
        QtCore.QMetaObject.connectSlotsByName(SessionNotes)

    def retranslateUi(self, SessionNotes):
        _translate = QtCore.QCoreApplication.translate
        SessionNotes.setWindowTitle(_translate("SessionNotes", "Notes"))
        self.label.setText(_translate("SessionNotes", "Session Notes"))

```

`GUI/Widgets/SessionNotes/Form/SessionNotes.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>SessionNotes</class>
 <widget class="QWidget" name="SessionNotes">
  <property name="windowModality">
   <enum>Qt::WindowModality::WindowModal</enum>
  </property>
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>259</width>
    <height>190</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Notes</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="1" column="0">
    <widget class="QTextEdit" name="textEdit_Notes">
     <property name="minimumSize">
      <size>
       <width>50</width>
       <height>50</height>
      </size>
     </property>
    </widget>
   </item>
   <item row="0" column="0">
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Session Notes</string>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`GUI/Widgets/SessionNotes/SessionNotes.py`:

```py
from GUI.Widgets.SessionNotes.Form.SessionNotes import Ui_SessionNotes as SessionNotesForm
from GUI.Session.session import SessionManager, SessionDataChanged
from PyQt6.QtWidgets import QWidget
from GUI.States import states


class SessionNotesWidget(QWidget, SessionNotesForm):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.textEdit_Notes.textChanged.connect(self.on_textEdit_notes_textChanged)
        states.session_signals.on_load.connect(self.on_load)
        states.session_signals.new_session.connect(self.on_new_session)
        self.session = SessionManager.get_session()

    def on_new_session(self):
        self.textEdit_Notes.clear()
        self.session = SessionManager.get_session()

    def on_load(self):
        self.textEdit_Notes.setText(SessionManager.session.pct_notes)

    def on_textEdit_notes_textChanged(self):
        SessionManager.session.pct_notes = self.textEdit_Notes.toPlainText()
        SessionManager.session.data_changed |= SessionDataChanged.NOTES

    def toggle_visibility(self):
        self.setVisible(not self.isVisible())

```

`GUI/Widgets/Settings/Form/SettingsDialog.py`:

```py
# Form implementation generated from reading ui file 'Widgets/Settings/Form/SettingsDialog.ui'
#
# Created by: PyQt6 UI code generator 6.6.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets


class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(884, 633)
        self.gridLayout = QtWidgets.QGridLayout(Dialog)
        self.gridLayout.setObjectName("gridLayout")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.listWidget_Options = QtWidgets.QListWidget(parent=Dialog)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.listWidget_Options.sizePolicy().hasHeightForWidth())
        self.listWidget_Options.setSizePolicy(sizePolicy)
        self.listWidget_Options.setMaximumSize(QtCore.QSize(130, 16777215))
        self.listWidget_Options.setObjectName("listWidget_Options")
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget_Options.addItem(item)
        self.horizontalLayout_2.addWidget(self.listWidget_Options)
        self.stackedWidget = QtWidgets.QStackedWidget(parent=Dialog)
        self.stackedWidget.setMinimumSize(QtCore.QSize(500, 500))
        self.stackedWidget.setObjectName("stackedWidget")
        self.page = QtWidgets.QWidget()
        self.page.setObjectName("page")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.page)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout()
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.checkBox_AutoUpdateAddressTable = QtWidgets.QCheckBox(parent=self.page)
        self.checkBox_AutoUpdateAddressTable.setObjectName("checkBox_AutoUpdateAddressTable")
        self.verticalLayout_2.addWidget(self.checkBox_AutoUpdateAddressTable)
        self.verticalLayout_3.addLayout(self.verticalLayout_2)
        self.QWidget_UpdateInterval = QtWidgets.QWidget(parent=self.page)
        self.QWidget_UpdateInterval.setObjectName("QWidget_UpdateInterval")
        self.horizontalLayout_UpdateInterval = QtWidgets.QHBoxLayout(self.QWidget_UpdateInterval)
        self.horizontalLayout_UpdateInterval.setContentsMargins(-1, 0, -1, -1)
        self.horizontalLayout_UpdateInterval.setObjectName("horizontalLayout_UpdateInterval")
        self.label = QtWidgets.QLabel(parent=self.QWidget_UpdateInterval)
        self.label.setMinimumSize(QtCore.QSize(102, 0))
        self.label.setObjectName("label")
        self.horizontalLayout_UpdateInterval.addWidget(self.label)
        self.spinBox_UpdateInterval = QtWidgets.QSpinBox(parent=self.QWidget_UpdateInterval)
        self.spinBox_UpdateInterval.setMinimum(100)
        self.spinBox_UpdateInterval.setMaximum(10000)
        self.spinBox_UpdateInterval.setSingleStep(100)
        self.spinBox_UpdateInterval.setObjectName("spinBox_UpdateInterval")
        self.horizontalLayout_UpdateInterval.addWidget(self.spinBox_UpdateInterval)
        self.label_2 = QtWidgets.QLabel(parent=self.QWidget_UpdateInterval)
        self.label_2.setText("ms")
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_UpdateInterval.addWidget(self.label_2)
        self.verticalLayout_3.addWidget(self.QWidget_UpdateInterval)
        self.LockInterval = QtWidgets.QWidget(parent=self.page)
        self.LockInterval.setObjectName("LockInterval")
        self.horizontalLayout_14 = QtWidgets.QHBoxLayout(self.LockInterval)
        self.horizontalLayout_14.setContentsMargins(-1, 0, -1, -1)
        self.horizontalLayout_14.setObjectName("horizontalLayout_14")
        self.label_12 = QtWidgets.QLabel(parent=self.LockInterval)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_12.sizePolicy().hasHeightForWidth())
        self.label_12.setSizePolicy(sizePolicy)
        self.label_12.setMinimumSize(QtCore.QSize(102, 0))
        self.label_12.setBaseSize(QtCore.QSize(0, 0))
        self.label_12.setObjectName("label_12")
        self.horizontalLayout_14.addWidget(self.label_12)
        self.spinBox_FreezeInterval = QtWidgets.QSpinBox(parent=self.LockInterval)
        self.spinBox_FreezeInterval.setMinimum(100)
        self.spinBox_FreezeInterval.setMaximum(10000)
        self.spinBox_FreezeInterval.setSingleStep(100)
        self.spinBox_FreezeInterval.setObjectName("spinBox_FreezeInterval")
        self.horizontalLayout_14.addWidget(self.spinBox_FreezeInterval)
        self.label_10 = QtWidgets.QLabel(parent=self.LockInterval)
        self.label_10.setText("ms")
        self.label_10.setObjectName("label_10")
        self.horizontalLayout_14.addWidget(self.label_10)
        self.verticalLayout_3.addWidget(self.LockInterval)
        self.horizontalLayout_7.addLayout(self.verticalLayout_3)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_7.addItem(spacerItem)
        self.verticalLayout_5.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_8 = QtWidgets.QLabel(parent=self.page)
        self.label_8.setObjectName("label_8")
        self.horizontalLayout_3.addWidget(self.label_8)
        self.checkBox_OutputModeAsync = QtWidgets.QCheckBox(parent=self.page)
        self.checkBox_OutputModeAsync.setObjectName("checkBox_OutputModeAsync")
        self.horizontalLayout_3.addWidget(self.checkBox_OutputModeAsync)
        self.checkBox_OutputModeCommand = QtWidgets.QCheckBox(parent=self.page)
        self.checkBox_OutputModeCommand.setObjectName("checkBox_OutputModeCommand")
        self.horizontalLayout_3.addWidget(self.checkBox_OutputModeCommand)
        self.checkBox_OutputModeCommandInfo = QtWidgets.QCheckBox(parent=self.page)
        self.checkBox_OutputModeCommandInfo.setObjectName("checkBox_OutputModeCommandInfo")
        self.horizontalLayout_3.addWidget(self.checkBox_OutputModeCommandInfo)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem1)
        self.verticalLayout_5.addLayout(self.horizontalLayout_3)
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.label_9 = QtWidgets.QLabel(parent=self.page)
        self.label_9.setObjectName("label_9")
        self.horizontalLayout_12.addWidget(self.label_9)
        self.lineEdit_AutoAttach = QtWidgets.QLineEdit(parent=self.page)
        self.lineEdit_AutoAttach.setObjectName("lineEdit_AutoAttach")
        self.horizontalLayout_12.addWidget(self.lineEdit_AutoAttach)
        self.checkBox_AutoAttachRegex = QtWidgets.QCheckBox(parent=self.page)
        self.checkBox_AutoAttachRegex.setObjectName("checkBox_AutoAttachRegex")
        self.horizontalLayout_12.addWidget(self.checkBox_AutoAttachRegex)
        self.verticalLayout_5.addLayout(self.horizontalLayout_12)
        self.horizontalLayout_13 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_13.setObjectName("horizontalLayout_13")
        self.label_13 = QtWidgets.QLabel(parent=self.page)
        self.label_13.setObjectName("label_13")
        self.horizontalLayout_13.addWidget(self.label_13)
        self.comboBox_Language = QtWidgets.QComboBox(parent=self.page)
        self.comboBox_Language.setObjectName("comboBox_Language")
        self.horizontalLayout_13.addWidget(self.comboBox_Language)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_13.addItem(spacerItem2)
        self.verticalLayout_5.addLayout(self.horizontalLayout_13)
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_15.setObjectName("horizontalLayout_15")
        self.label_11 = QtWidgets.QLabel(parent=self.page)
        self.label_11.setObjectName("label_11")
        self.horizontalLayout_15.addWidget(self.label_11)
        self.comboBox_Logo = QtWidgets.QComboBox(parent=self.page)
        self.comboBox_Logo.setObjectName("comboBox_Logo")
        self.horizontalLayout_15.addWidget(self.comboBox_Logo)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_15.addItem(spacerItem3)
        self.verticalLayout_5.addLayout(self.horizontalLayout_15)
        self.horizontalLayout_17 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_17.setObjectName("horizontalLayout_17")
        self.label_14 = QtWidgets.QLabel(parent=self.page)
        self.label_14.setObjectName("label_14")
        self.horizontalLayout_17.addWidget(self.label_14)
        self.comboBox_Theme = QtWidgets.QComboBox(parent=self.page)
        self.comboBox_Theme.setObjectName("comboBox_Theme")
        self.horizontalLayout_17.addWidget(self.comboBox_Theme)
        spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_17.addItem(spacerItem4)
        self.verticalLayout_5.addLayout(self.horizontalLayout_17)
        spacerItem5 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_5.addItem(spacerItem5)
        self.gridLayout_2.addLayout(self.verticalLayout_5, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.page)
        self.page_2 = QtWidgets.QWidget()
        self.page_2.setObjectName("page_2")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.page_2)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.label_3 = QtWidgets.QLabel(parent=self.page_2)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_4.addWidget(self.label_3)
        self.listWidget_Functions = QtWidgets.QListWidget(parent=self.page_2)
        self.listWidget_Functions.setObjectName("listWidget_Functions")
        self.verticalLayout_4.addWidget(self.listWidget_Functions)
        self.horizontalLayout_5.addLayout(self.verticalLayout_4)
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.verticalLayout_Hotkey = QtWidgets.QVBoxLayout()
        self.verticalLayout_Hotkey.setObjectName("verticalLayout_Hotkey")
        self.label_4 = QtWidgets.QLabel(parent=self.page_2)
        self.label_4.setObjectName("label_4")
        self.verticalLayout_Hotkey.addWidget(self.label_4)
        self.lineEdit_Hotkey = QtWidgets.QLineEdit(parent=self.page_2)
        self.lineEdit_Hotkey.setReadOnly(True)
        self.lineEdit_Hotkey.setObjectName("lineEdit_Hotkey")
        self.verticalLayout_Hotkey.addWidget(self.lineEdit_Hotkey)
        self.verticalLayout_6.addLayout(self.verticalLayout_Hotkey)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem6)
        self.pushButton_ClearHotkey = QtWidgets.QPushButton(parent=self.page_2)
        self.pushButton_ClearHotkey.setObjectName("pushButton_ClearHotkey")
        self.horizontalLayout_4.addWidget(self.pushButton_ClearHotkey)
        self.verticalLayout_6.addLayout(self.horizontalLayout_4)
        spacerItem7 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_6.addItem(spacerItem7)
        self.horizontalLayout_5.addLayout(self.verticalLayout_6)
        self.gridLayout_3.addLayout(self.horizontalLayout_5, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.page_2)
        self.page_3 = QtWidgets.QWidget()
        self.page_3.setObjectName("page_3")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.page_3)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout()
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout()
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.label_5 = QtWidgets.QLabel(parent=self.page_3)
        self.label_5.setObjectName("label_5")
        self.verticalLayout_8.addWidget(self.label_5)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout()
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.radioButton_SimpleDLopenCall = QtWidgets.QRadioButton(parent=self.page_3)
        self.radioButton_SimpleDLopenCall.setObjectName("radioButton_SimpleDLopenCall")
        self.verticalLayout_7.addWidget(self.radioButton_SimpleDLopenCall)
        self.radioButton_AdvancedInjection = QtWidgets.QRadioButton(parent=self.page_3)
        self.radioButton_AdvancedInjection.setEnabled(False)
        self.radioButton_AdvancedInjection.setObjectName("radioButton_AdvancedInjection")
        self.verticalLayout_7.addWidget(self.radioButton_AdvancedInjection)
        self.horizontalLayout_6.addLayout(self.verticalLayout_7)
        self.verticalLayout_8.addLayout(self.horizontalLayout_6)
        self.horizontalLayout_8.addLayout(self.verticalLayout_8)
        spacerItem8 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_8.addItem(spacerItem8)
        self.verticalLayout_9.addLayout(self.horizontalLayout_8)
        spacerItem9 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_9.addItem(spacerItem9)
        self.gridLayout_4.addLayout(self.verticalLayout_9, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.page_3)
        self.page_4 = QtWidgets.QWidget()
        self.page_4.setObjectName("page_4")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.page_4)
        self.gridLayout_5.setObjectName("gridLayout_5")
        self.verticalLayout_10 = QtWidgets.QVBoxLayout()
        self.verticalLayout_10.setObjectName("verticalLayout_10")
        self.checkBox_ShowMemoryViewOnStop = QtWidgets.QCheckBox(parent=self.page_4)
        self.checkBox_ShowMemoryViewOnStop.setObjectName("checkBox_ShowMemoryViewOnStop")
        self.verticalLayout_10.addWidget(self.checkBox_ShowMemoryViewOnStop)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.label_6 = QtWidgets.QLabel(parent=self.page_4)
        self.label_6.setObjectName("label_6")
        self.horizontalLayout_10.addWidget(self.label_6)
        self.spinBox_InstructionsPerScroll = QtWidgets.QSpinBox(parent=self.page_4)
        self.spinBox_InstructionsPerScroll.setObjectName("spinBox_InstructionsPerScroll")
        self.horizontalLayout_10.addWidget(self.spinBox_InstructionsPerScroll)
        spacerItem10 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_10.addItem(spacerItem10)
        self.verticalLayout_10.addLayout(self.horizontalLayout_10)
        self.horizontalLayout_19 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_19.setObjectName("horizontalLayout_19")
        self.label_16 = QtWidgets.QLabel(parent=self.page_4)
        self.label_16.setObjectName("label_16")
        self.horizontalLayout_19.addWidget(self.label_16)
        self.spinBox_BytesPerScroll = QtWidgets.QSpinBox(parent=self.page_4)
        self.spinBox_BytesPerScroll.setPrefix("0x")
        self.spinBox_BytesPerScroll.setMaximum(4096)
        self.spinBox_BytesPerScroll.setSingleStep(16)
        self.spinBox_BytesPerScroll.setDisplayIntegerBase(16)
        self.spinBox_BytesPerScroll.setObjectName("spinBox_BytesPerScroll")
        self.horizontalLayout_19.addWidget(self.spinBox_BytesPerScroll)
        spacerItem11 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_19.addItem(spacerItem11)
        self.verticalLayout_10.addLayout(self.horizontalLayout_19)
        spacerItem12 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_10.addItem(spacerItem12)
        self.gridLayout_5.addLayout(self.verticalLayout_10, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.page_4)
        self.page_5 = QtWidgets.QWidget()
        self.page_5.setObjectName("page_5")
        self.gridLayout_6 = QtWidgets.QGridLayout(self.page_5)
        self.gridLayout_6.setObjectName("gridLayout_6")
        self.verticalLayout_11 = QtWidgets.QVBoxLayout()
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        self.horizontalLayout_101 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_101.setObjectName("horizontalLayout_101")
        self.label_GDBPath = QtWidgets.QLabel(parent=self.page_5)
        self.label_GDBPath.setObjectName("label_GDBPath")
        self.horizontalLayout_101.addWidget(self.label_GDBPath)
        self.lineEdit_GDBPath = QtWidgets.QLineEdit(parent=self.page_5)
        self.lineEdit_GDBPath.setObjectName("lineEdit_GDBPath")
        self.horizontalLayout_101.addWidget(self.lineEdit_GDBPath)
        self.horizontalLayout_11.addLayout(self.horizontalLayout_101)
        self.pushButton_GDBPath = QtWidgets.QPushButton(parent=self.page_5)
        self.pushButton_GDBPath.setObjectName("pushButton_GDBPath")
        self.horizontalLayout_11.addWidget(self.pushButton_GDBPath)
        self.verticalLayout_11.addLayout(self.horizontalLayout_11)
        self.checkBox_GDBLogging = QtWidgets.QCheckBox(parent=self.page_5)
        self.checkBox_GDBLogging.setObjectName("checkBox_GDBLogging")
        self.verticalLayout_11.addWidget(self.checkBox_GDBLogging)
        self.horizontalLayout_18 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_18.setObjectName("horizontalLayout_18")
        self.label_15 = QtWidgets.QLabel(parent=self.page_5)
        self.label_15.setObjectName("label_15")
        self.horizontalLayout_18.addWidget(self.label_15)
        self.comboBox_InterruptSignal = QtWidgets.QComboBox(parent=self.page_5)
        self.comboBox_InterruptSignal.setObjectName("comboBox_InterruptSignal")
        self.horizontalLayout_18.addWidget(self.comboBox_InterruptSignal)
        spacerItem13 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_18.addItem(spacerItem13)
        self.verticalLayout_11.addLayout(self.horizontalLayout_18)
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_16.setObjectName("horizontalLayout_16")
        self.pushButton_HandleSignals = QtWidgets.QPushButton(parent=self.page_5)
        self.pushButton_HandleSignals.setObjectName("pushButton_HandleSignals")
        self.horizontalLayout_16.addWidget(self.pushButton_HandleSignals)
        spacerItem14 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout_16.addItem(spacerItem14)
        self.verticalLayout_11.addLayout(self.horizontalLayout_16)
        spacerItem15 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.verticalLayout_11.addItem(spacerItem15)
        self.gridLayout_6.addLayout(self.verticalLayout_11, 0, 0, 1, 1)
        self.stackedWidget.addWidget(self.page_5)
        self.page_6 = QtWidgets.QWidget()
        self.page_6.setObjectName("page_6")
        self.gridLayout_7 = QtWidgets.QGridLayout(self.page_6)
        self.gridLayout_7.setObjectName("gridLayout_7")
        self.checkBox_JavaSegfault = QtWidgets.QCheckBox(parent=self.page_6)
        self.checkBox_JavaSegfault.setObjectName("checkBox_JavaSegfault")
        self.gridLayout_7.addWidget(self.checkBox_JavaSegfault, 0, 0, 1, 1)
        spacerItem16 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Policy.Minimum, QtWidgets.QSizePolicy.Policy.Expanding)
        self.gridLayout_7.addItem(spacerItem16, 1, 0, 1, 1)
        self.stackedWidget.addWidget(self.page_6)
        self.horizontalLayout_2.addWidget(self.stackedWidget)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.pushButton_ResetSettings = QtWidgets.QPushButton(parent=Dialog)
        self.pushButton_ResetSettings.setObjectName("pushButton_ResetSettings")
        self.horizontalLayout.addWidget(self.pushButton_ResetSettings)
        spacerItem17 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Policy.Expanding, QtWidgets.QSizePolicy.Policy.Minimum)
        self.horizontalLayout.addItem(spacerItem17)
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.StandardButton.Cancel|QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.setObjectName("buttonBox")
        self.horizontalLayout.addWidget(self.buttonBox)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.gridLayout.addLayout(self.verticalLayout, 0, 0, 1, 1)

        self.retranslateUi(Dialog)
        self.stackedWidget.setCurrentIndex(0)
        self.listWidget_Functions.setCurrentRow(-1)
        self.buttonBox.accepted.connect(Dialog.accept) # type: ignore
        self.buttonBox.rejected.connect(Dialog.reject) # type: ignore
        QtCore.QMetaObject.connectSlotsByName(Dialog)

    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Settings"))
        __sortingEnabled = self.listWidget_Options.isSortingEnabled()
        self.listWidget_Options.setSortingEnabled(False)
        item = self.listWidget_Options.item(0)
        item.setText(_translate("Dialog", "General"))
        item = self.listWidget_Options.item(1)
        item.setText(_translate("Dialog", "Hotkeys"))
        item = self.listWidget_Options.item(2)
        item.setText(_translate("Dialog", "Code Injection"))
        item = self.listWidget_Options.item(3)
        item.setText(_translate("Dialog", "Memory View"))
        item = self.listWidget_Options.item(4)
        item.setText(_translate("Dialog", "Debug"))
        item = self.listWidget_Options.item(5)
        item.setText(_translate("Dialog", "Java"))
        self.listWidget_Options.setSortingEnabled(__sortingEnabled)
        self.checkBox_AutoUpdateAddressTable.setText(_translate("Dialog", "Auto-update address table"))
        self.label.setText(_translate("Dialog", "Update Interval"))
        self.label_12.setText(_translate("Dialog", "Freeze Interval"))
        self.label_8.setText(_translate("Dialog", "GDB output:"))
        self.checkBox_OutputModeAsync.setText(_translate("Dialog", "Async"))
        self.checkBox_OutputModeCommand.setText(_translate("Dialog", "Command"))
        self.checkBox_OutputModeCommandInfo.setText(_translate("Dialog", "Command info"))
        self.label_9.setToolTip(_translate("Dialog", "On start, automatically attach to processes with name matching one of the entries\n"
"Patterns at former positions have higher priority if regex is off"))
        self.label_9.setText(_translate("Dialog", "Auto-attach to processes named"))
        self.checkBox_AutoAttachRegex.setText(_translate("Dialog", "Regex"))
        self.label_13.setText(_translate("Dialog", "Language"))
        self.label_11.setText(_translate("Dialog", "Logo"))
        self.label_14.setText(_translate("Dialog", "Theme"))
        self.label_3.setText(_translate("Dialog", "Functions"))
        self.label_4.setText(_translate("Dialog", "Hotkey"))
        self.lineEdit_Hotkey.setPlaceholderText(_translate("Dialog", "Press shortcut"))
        self.pushButton_ClearHotkey.setText(_translate("Dialog", "Clear"))
        self.label_5.setText(_translate("Dialog", "Code injection method:"))
        self.radioButton_SimpleDLopenCall.setText(_translate("Dialog", "Simp&le dlopen call"))
        self.radioButton_AdvancedInjection.setText(_translate("Dialog", "Advanced In&jection"))
        self.checkBox_ShowMemoryViewOnStop.setText(_translate("Dialog", "Bring Memory View to front when the inferior is stopped"))
        self.label_6.setText(_translate("Dialog", "Instructions shown per scroll in Disassembly View"))
        self.label_16.setText(_translate("Dialog", "Bytes shown per scroll in Hex View"))
        self.label_GDBPath.setText(_translate("Dialog", "GDB Path"))
        self.checkBox_GDBLogging.setText(_translate("Dialog", "GDB Logging"))
        self.label_15.setText(_translate("Dialog", "Interruption signal"))
        self.pushButton_HandleSignals.setText(_translate("Dialog", "Handle Signals"))
        self.checkBox_JavaSegfault.setText(_translate("Dialog", "Ignore SIGSEGV for Java processes (overrides signal settings if enabled)"))
        self.pushButton_ResetSettings.setText(_translate("Dialog", "Reset Settings"))

```

`GUI/Widgets/Settings/Form/SettingsDialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>Dialog</class>
 <widget class="QDialog" name="Dialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>884</width>
    <height>633</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Settings</string>
  </property>
  <layout class="QGridLayout" name="gridLayout">
   <item row="0" column="0">
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_2">
       <item>
        <widget class="QListWidget" name="listWidget_Options">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Fixed" vsizetype="Expanding">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="maximumSize">
          <size>
           <width>130</width>
           <height>16777215</height>
          </size>
         </property>
         <item>
          <property name="text">
           <string>General</string>
          </property>
         </item>
         <item>
          <property name="text">
           <string>Hotkeys</string>
          </property>
         </item>
         <item>
          <property name="text">
           <string>Code Injection</string>
          </property>
         </item>
         <item>
          <property name="text">
           <string>Memory View</string>
          </property>
         </item>
         <item>
          <property name="text">
           <string>Debug</string>
          </property>
         </item>
         <item>
          <property name="text">
           <string>Java</string>
          </property>
         </item>
        </widget>
       </item>
       <item>
        <widget class="QStackedWidget" name="stackedWidget">
         <property name="minimumSize">
          <size>
           <width>500</width>
           <height>500</height>
          </size>
         </property>
         <property name="currentIndex">
          <number>0</number>
         </property>
         <widget class="QWidget" name="page">
          <layout class="QGridLayout" name="gridLayout_2">
           <item row="0" column="0">
            <layout class="QVBoxLayout" name="verticalLayout_5">
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_7">
               <item>
                <layout class="QVBoxLayout" name="verticalLayout_3">
                 <item>
                  <layout class="QVBoxLayout" name="verticalLayout_2">
                   <item>
                    <widget class="QCheckBox" name="checkBox_AutoUpdateAddressTable">
                     <property name="text">
                      <string>Auto-update address table</string>
                     </property>
                    </widget>
                   </item>
                  </layout>
                 </item>
                 <item>
                  <widget class="QWidget" name="QWidget_UpdateInterval" native="true">
                   <layout class="QHBoxLayout" name="horizontalLayout_UpdateInterval">
                    <property name="topMargin">
                     <number>0</number>
                    </property>
                    <item>
                     <widget class="QLabel" name="label">
                      <property name="minimumSize">
                       <size>
                        <width>102</width>
                        <height>0</height>
                       </size>
                      </property>
                      <property name="text">
                       <string>Update Interval</string>
                      </property>
                     </widget>
                    </item>
                    <item>
                     <widget class="QSpinBox" name="spinBox_UpdateInterval">
                      <property name="minimum">
                       <number>100</number>
                      </property>
                      <property name="maximum">
                       <number>10000</number>
                      </property>
                      <property name="singleStep">
                       <number>100</number>
                      </property>
                     </widget>
                    </item>
                    <item>
                     <widget class="QLabel" name="label_2">
                      <property name="text">
                       <string notr="true">ms</string>
                      </property>
                     </widget>
                    </item>
                   </layout>
                  </widget>
                 </item>
                 <item>
                  <widget class="QWidget" name="LockInterval" native="true">
                   <layout class="QHBoxLayout" name="horizontalLayout_14">
                    <property name="topMargin">
                     <number>0</number>
                    </property>
                    <item>
                     <widget class="QLabel" name="label_12">
                      <property name="sizePolicy">
                       <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
                        <horstretch>0</horstretch>
                        <verstretch>0</verstretch>
                       </sizepolicy>
                      </property>
                      <property name="minimumSize">
                       <size>
                        <width>102</width>
                        <height>0</height>
                       </size>
                      </property>
                      <property name="baseSize">
                       <size>
                        <width>0</width>
                        <height>0</height>
                       </size>
                      </property>
                      <property name="text">
                       <string>Freeze Interval</string>
                      </property>
                     </widget>
                    </item>
                    <item>
                     <widget class="QSpinBox" name="spinBox_FreezeInterval">
                      <property name="minimum">
                       <number>100</number>
                      </property>
                      <property name="maximum">
                       <number>10000</number>
                      </property>
                      <property name="singleStep">
                       <number>100</number>
                      </property>
                     </widget>
                    </item>
                    <item>
                     <widget class="QLabel" name="label_10">
                      <property name="text">
                       <string notr="true">ms</string>
                      </property>
                     </widget>
                    </item>
                   </layout>
                  </widget>
                 </item>
                </layout>
               </item>
               <item>
                <spacer name="horizontalSpacer_4">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_3">
               <item>
                <widget class="QLabel" name="label_8">
                 <property name="text">
                  <string>GDB output:</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QCheckBox" name="checkBox_OutputModeAsync">
                 <property name="text">
                  <string>Async</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QCheckBox" name="checkBox_OutputModeCommand">
                 <property name="text">
                  <string>Command</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QCheckBox" name="checkBox_OutputModeCommandInfo">
                 <property name="text">
                  <string>Command info</string>
                 </property>
                </widget>
               </item>
               <item>
                <spacer name="horizontalSpacer_7">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_12">
               <item>
                <widget class="QLabel" name="label_9">
                 <property name="toolTip">
                  <string>On start, automatically attach to processes with name matching one of the entries
Patterns at former positions have higher priority if regex is off</string>
                 </property>
                 <property name="text">
                  <string>Auto-attach to processes named</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QLineEdit" name="lineEdit_AutoAttach"/>
               </item>
               <item>
                <widget class="QCheckBox" name="checkBox_AutoAttachRegex">
                 <property name="text">
                  <string>Regex</string>
                 </property>
                </widget>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_13">
               <item>
                <widget class="QLabel" name="label_13">
                 <property name="text">
                  <string>Language</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QComboBox" name="comboBox_Language"/>
               </item>
               <item>
                <spacer name="horizontalSpacer_10">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_15">
               <item>
                <widget class="QLabel" name="label_11">
                 <property name="text">
                  <string>Logo</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QComboBox" name="comboBox_Logo"/>
               </item>
               <item>
                <spacer name="horizontalSpacer_8">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_17">
               <item>
                <widget class="QLabel" name="label_14">
                 <property name="text">
                  <string>Theme</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QComboBox" name="comboBox_Theme"/>
               </item>
               <item>
                <spacer name="horizontalSpacer_11">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <spacer name="verticalSpacer_2">
               <property name="orientation">
                <enum>Qt::Vertical</enum>
               </property>
               <property name="sizeHint" stdset="0">
                <size>
                 <width>20</width>
                 <height>40</height>
                </size>
               </property>
              </spacer>
             </item>
            </layout>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="page_2">
          <layout class="QGridLayout" name="gridLayout_3">
           <item row="0" column="0">
            <layout class="QHBoxLayout" name="horizontalLayout_5">
             <item>
              <layout class="QVBoxLayout" name="verticalLayout_4">
               <item>
                <widget class="QLabel" name="label_3">
                 <property name="text">
                  <string>Functions</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QListWidget" name="listWidget_Functions">
                 <property name="currentRow">
                  <number>-1</number>
                 </property>
                </widget>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QVBoxLayout" name="verticalLayout_6">
               <item>
                <layout class="QVBoxLayout" name="verticalLayout_Hotkey">
                 <item>
                  <widget class="QLabel" name="label_4">
                   <property name="text">
                    <string>Hotkey</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="QLineEdit" name="lineEdit_Hotkey">
                   <property name="readOnly">
                    <bool>true</bool>
                   </property>
                   <property name="placeholderText">
                    <string>Press shortcut</string>
                   </property>
                  </widget>
                 </item>
                </layout>
               </item>
               <item>
                <layout class="QHBoxLayout" name="horizontalLayout_4">
                 <item>
                  <spacer name="horizontalSpacer">
                   <property name="orientation">
                    <enum>Qt::Horizontal</enum>
                   </property>
                   <property name="sizeHint" stdset="0">
                    <size>
                     <width>40</width>
                     <height>20</height>
                    </size>
                   </property>
                  </spacer>
                 </item>
                 <item>
                  <widget class="QPushButton" name="pushButton_ClearHotkey">
                   <property name="text">
                    <string>Clear</string>
                   </property>
                  </widget>
                 </item>
                </layout>
               </item>
               <item>
                <spacer name="verticalSpacer">
                 <property name="orientation">
                  <enum>Qt::Vertical</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>20</width>
                   <height>40</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
            </layout>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="page_3">
          <layout class="QGridLayout" name="gridLayout_4">
           <item row="0" column="0">
            <layout class="QVBoxLayout" name="verticalLayout_9">
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_8">
               <item>
                <layout class="QVBoxLayout" name="verticalLayout_8">
                 <item>
                  <widget class="QLabel" name="label_5">
                   <property name="text">
                    <string>Code injection method:</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <layout class="QHBoxLayout" name="horizontalLayout_6">
                   <item>
                    <layout class="QVBoxLayout" name="verticalLayout_7">
                     <item>
                      <widget class="QRadioButton" name="radioButton_SimpleDLopenCall">
                       <property name="text">
                        <string>Simp&amp;le dlopen call</string>
                       </property>
                      </widget>
                     </item>
                     <item>
                      <widget class="QRadioButton" name="radioButton_AdvancedInjection">
                       <property name="enabled">
                        <bool>false</bool>
                       </property>
                       <property name="text">
                        <string>Advanced In&amp;jection</string>
                       </property>
                      </widget>
                     </item>
                    </layout>
                   </item>
                  </layout>
                 </item>
                </layout>
               </item>
               <item>
                <spacer name="horizontalSpacer_5">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <spacer name="verticalSpacer_3">
               <property name="orientation">
                <enum>Qt::Vertical</enum>
               </property>
               <property name="sizeHint" stdset="0">
                <size>
                 <width>20</width>
                 <height>40</height>
                </size>
               </property>
              </spacer>
             </item>
            </layout>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="page_4">
          <layout class="QGridLayout" name="gridLayout_5">
           <item row="0" column="0">
            <layout class="QVBoxLayout" name="verticalLayout_10">
             <item>
              <widget class="QCheckBox" name="checkBox_ShowMemoryViewOnStop">
               <property name="text">
                <string>Bring Memory View to front when the inferior is stopped</string>
               </property>
              </widget>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_10">
               <item>
                <widget class="QLabel" name="label_6">
                 <property name="text">
                  <string>Instructions shown per scroll in Disassembly View</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QSpinBox" name="spinBox_InstructionsPerScroll"/>
               </item>
               <item>
                <spacer name="horizontalSpacer_6">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_19">
               <item>
                <widget class="QLabel" name="label_16">
                 <property name="text">
                  <string>Bytes shown per scroll in Hex View</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QSpinBox" name="spinBox_BytesPerScroll">
                 <property name="prefix">
                  <string notr="true">0x</string>
                 </property>
                 <property name="maximum">
                  <number>4096</number>
                 </property>
                 <property name="singleStep">
                  <number>16</number>
                 </property>
                 <property name="displayIntegerBase">
                  <number>16</number>
                 </property>
                </widget>
               </item>
               <item>
                <spacer name="horizontalSpacer_2">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <spacer name="verticalSpacer_4">
               <property name="orientation">
                <enum>Qt::Vertical</enum>
               </property>
               <property name="sizeHint" stdset="0">
                <size>
                 <width>20</width>
                 <height>40</height>
                </size>
               </property>
              </spacer>
             </item>
            </layout>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="page_5">
          <layout class="QGridLayout" name="gridLayout_6">
           <item row="0" column="0">
            <layout class="QVBoxLayout" name="verticalLayout_11">
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_11">
               <item>
                <layout class="QHBoxLayout" name="horizontalLayout_10">
                 <item>
                  <widget class="QLabel" name="label_GDBPath">
                   <property name="text">
                    <string>GDB Path</string>
                   </property>
                  </widget>
                 </item>
                 <item>
                  <widget class="QLineEdit" name="lineEdit_GDBPath"/>
                 </item>
                </layout>
               </item>
               <item>
                <widget class="QPushButton" name="pushButton_GDBPath"/>
               </item>
              </layout>
             </item>
             <item>
              <widget class="QCheckBox" name="checkBox_GDBLogging">
               <property name="text">
                <string>GDB Logging</string>
               </property>
              </widget>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_18">
               <item>
                <widget class="QLabel" name="label_15">
                 <property name="text">
                  <string>Interruption signal</string>
                 </property>
                </widget>
               </item>
               <item>
                <widget class="QComboBox" name="comboBox_InterruptSignal"/>
               </item>
               <item>
                <spacer name="horizontalSpacer_12">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <layout class="QHBoxLayout" name="horizontalLayout_16">
               <item>
                <widget class="QPushButton" name="pushButton_HandleSignals">
                 <property name="text">
                  <string>Handle Signals</string>
                 </property>
                </widget>
               </item>
               <item>
                <spacer name="horizontalSpacer_9">
                 <property name="orientation">
                  <enum>Qt::Horizontal</enum>
                 </property>
                 <property name="sizeHint" stdset="0">
                  <size>
                   <width>40</width>
                   <height>20</height>
                  </size>
                 </property>
                </spacer>
               </item>
              </layout>
             </item>
             <item>
              <spacer name="verticalSpacer_5">
               <property name="orientation">
                <enum>Qt::Vertical</enum>
               </property>
               <property name="sizeHint" stdset="0">
                <size>
                 <width>20</width>
                 <height>40</height>
                </size>
               </property>
              </spacer>
             </item>
            </layout>
           </item>
          </layout>
         </widget>
         <widget class="QWidget" name="page_6">
          <layout class="QGridLayout" name="gridLayout_7">
           <item row="0" column="0">
            <widget class="QCheckBox" name="checkBox_JavaSegfault">
             <property name="text">
              <string>Ignore SIGSEGV for Java processes (overrides signal settings if enabled)</string>
             </property>
            </widget>
           </item>
           <item row="1" column="0">
            <spacer name="verticalSpacer_6">
             <property name="orientation">
              <enum>Qt::Vertical</enum>
             </property>
             <property name="sizeHint" stdset="0">
              <size>
               <width>20</width>
               <height>40</height>
              </size>
             </property>
            </spacer>
           </item>
          </layout>
         </widget>
        </widget>
       </item>
      </layout>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout">
       <item>
        <widget class="QPushButton" name="pushButton_ResetSettings">
         <property name="text">
          <string>Reset Settings</string>
         </property>
        </widget>
       </item>
       <item>
        <spacer name="horizontalSpacer_3">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="sizeHint" stdset="0">
          <size>
           <width>40</width>
           <height>20</height>
          </size>
         </property>
        </spacer>
       </item>
       <item>
        <widget class="QDialogButtonBox" name="buttonBox">
         <property name="orientation">
          <enum>Qt::Horizontal</enum>
         </property>
         <property name="standardButtons">
          <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
         </property>
        </widget>
       </item>
      </layout>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>Dialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>Dialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
 <designerdata>
  <property name="gridDeltaX">
   <number>5</number>
  </property>
  <property name="gridDeltaY">
   <number>5</number>
  </property>
  <property name="gridSnapX">
   <bool>true</bool>
  </property>
  <property name="gridSnapY">
   <bool>true</bool>
  </property>
  <property name="gridVisible">
   <bool>true</bool>
  </property>
 </designerdata>
</ui>

```

`GUI/Widgets/Settings/Settings.py`:

```py
from PyQt6.QtWidgets import QDialog, QMessageBox, QFileDialog, QApplication
from PyQt6.QtCore import Qt, QSettings, QSignalBlocker
from PyQt6.QtGui import QKeyEvent, QIcon, QPixmap, QStandardItemModel, QStandardItem
from GUI.States import states
from GUI.Settings import settings, themes
from GUI.Utils import guiutils, utilwidgets
from GUI.Widgets.Settings.Form.SettingsDialog import Ui_Dialog
from GUI.Widgets.HandleSignals.HandleSignals import HandleSignalsDialog
from tr.tr import TranslationConstants as tr
from tr.tr import language_list
from libpince import debugcore, utils, typedefs
from keyboard import KeyboardEvent, _pressed_events
from keyboard._nixkeyboard import to_name
import os, signal, json, re


class SettingsDialog(QDialog, Ui_Dialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.settings = QSettings()
        self.hotkey_to_value = {}  # Dict[str:str]-->Dict[Hotkey.name:settings_value]
        self.handle_signals_data = ""
        icons_directory = guiutils.get_icons_directory()
        self.pushButton_GDBPath.setIcon(QIcon(QPixmap(icons_directory + "/folder.png")))
        locale_model = QStandardItemModel()
        for loc, name in language_list.items():
            item = QStandardItem()
            item.setData(name, Qt.ItemDataRole.DisplayRole)
            item.setData(loc, Qt.ItemDataRole.UserRole)
            locale_model.appendRow(item)
        self.comboBox_Language.setModel(locale_model)
        self.comboBox_InterruptSignal.addItem("SIGINT")
        self.comboBox_InterruptSignal.addItems([f"SIG{x}" for x in range(signal.SIGRTMIN, signal.SIGRTMAX + 1)])
        self.comboBox_InterruptSignal.setStyleSheet("combobox-popup: 0;")  # maxVisibleItems doesn't work otherwise
        self.comboBox_Theme.addItems(themes.theme_strings.values())
        logo_directory = utils.get_logo_directory()
        logo_list = utils.search_files(logo_directory, r"\.(png|jpg|jpeg|svg)$")
        for logo in logo_list:
            self.comboBox_Logo.addItem(QIcon(os.path.join(logo_directory, logo)), logo)
        for hotkey in states.hotkeys.get_hotkeys():
            self.listWidget_Functions.addItem(hotkey.desc)
        self.config_gui()

        self.listWidget_Options.currentRowChanged.connect(self.change_display)
        self.listWidget_Functions.currentRowChanged.connect(self.listWidget_Functions_current_row_changed)
        self.pushButton_ClearHotkey.clicked.connect(self.pushButton_ClearHotkey_clicked)
        self.pushButton_ResetSettings.clicked.connect(self.pushButton_ResetSettings_clicked)
        self.pushButton_GDBPath.clicked.connect(self.pushButton_GDBPath_clicked)
        self.checkBox_AutoUpdateAddressTable.stateChanged.connect(self.checkBox_AutoUpdateAddressTable_state_changed)
        self.checkBox_AutoAttachRegex.stateChanged.connect(self.checkBox_AutoAttachRegex_state_changed)
        self.comboBox_Logo.currentIndexChanged.connect(self.comboBox_Logo_current_index_changed)
        self.comboBox_Theme.currentIndexChanged.connect(self.comboBox_Theme_current_index_changed)
        self.pushButton_HandleSignals.clicked.connect(self.pushButton_HandleSignals_clicked)
        self.lineEdit_Hotkey.keyPressEvent = self.lineEdit_Hotkey_key_pressed_event
        guiutils.center_to_parent(self)

    def accept(self):
        self.settings.setValue("General/auto_update_address_table", self.checkBox_AutoUpdateAddressTable.isChecked())
        if self.checkBox_AutoUpdateAddressTable.isChecked():
            self.settings.setValue("General/address_table_update_interval", self.spinBox_UpdateInterval.value())
        self.settings.setValue("General/freeze_interval", self.spinBox_FreezeInterval.value())
        output_mode = [
            self.checkBox_OutputModeAsync.isChecked(),
            self.checkBox_OutputModeCommand.isChecked(),
            self.checkBox_OutputModeCommandInfo.isChecked(),
        ]
        self.settings.setValue("General/gdb_output_mode", json.dumps(output_mode))
        if self.checkBox_AutoAttachRegex.isChecked():
            try:
                re.compile(self.lineEdit_AutoAttach.text())
            except:
                QMessageBox.information(self, tr.ERROR, tr.IS_INVALID_REGEX.format(self.lineEdit_AutoAttach.text()))
                return
        self.settings.setValue("General/auto_attach", self.lineEdit_AutoAttach.text())
        self.settings.setValue("General/auto_attach_regex", self.checkBox_AutoAttachRegex.isChecked())
        new_locale = self.comboBox_Language.currentData(Qt.ItemDataRole.UserRole)
        current_locale = self.settings.value("General/locale", type=str)
        if new_locale != current_locale:
            QMessageBox.information(self, tr.INFO, tr.LANG_RESET)
        self.settings.setValue("General/locale", new_locale)
        self.settings.setValue("General/logo_path", self.comboBox_Logo.currentText())
        self.settings.setValue("General/theme", list(themes.Themes)[self.comboBox_Theme.currentIndex()].value)
        for hotkey in states.hotkeys.get_hotkeys():
            self.settings.setValue("Hotkeys/" + hotkey.name, self.hotkey_to_value[hotkey.name])
        if self.radioButton_SimpleDLopenCall.isChecked():
            injection_method = typedefs.INJECTION_METHOD.DLOPEN
        elif self.radioButton_AdvancedInjection.isChecked():
            injection_method = typedefs.INJECTION_METHOD.ADVANCED
        self.settings.setValue("CodeInjection/code_injection_method", injection_method)
        self.settings.setValue("MemoryView/show_memory_view_on_stop", self.checkBox_ShowMemoryViewOnStop.isChecked())
        self.settings.setValue("MemoryView/instructions_per_scroll", self.spinBox_InstructionsPerScroll.value())
        self.settings.setValue("MemoryView/bytes_per_scroll", self.spinBox_BytesPerScroll.value())
        if not os.environ.get("APPDIR"):
            selected_gdb_path = self.lineEdit_GDBPath.text()
            if selected_gdb_path != states.gdb_path:
                if utilwidgets.InputDialog(self, tr.GDB_RESET).exec():
                    debugcore.init_gdb(selected_gdb_path)
            self.settings.setValue("Debug/gdb_path", selected_gdb_path)
        self.settings.setValue("Debug/gdb_logging", self.checkBox_GDBLogging.isChecked())
        self.settings.setValue("Debug/interrupt_signal", self.comboBox_InterruptSignal.currentText())
        self.settings.setValue("Java/ignore_segfault", self.checkBox_JavaSegfault.isChecked())
        if self.handle_signals_data:
            self.settings.setValue("Debug/handle_signals", self.handle_signals_data)
        settings.apply_settings()
        super().accept()

    def reject(self):
        logo_path = self.settings.value("General/logo_path", type=str)
        QApplication.setWindowIcon(QIcon(os.path.join(utils.get_logo_directory(), logo_path)))
        theme = self.settings.value("General/theme", type=str)
        QApplication.setPalette(themes.get_theme(theme))
        super().reject()

    def config_gui(self):
        self.checkBox_AutoUpdateAddressTable.setChecked(
            self.settings.value("General/auto_update_address_table", type=bool)
        )
        self.spinBox_UpdateInterval.setValue(self.settings.value("General/address_table_update_interval", type=int))
        self.spinBox_FreezeInterval.setValue(self.settings.value("General/freeze_interval", type=int))
        output_mode = json.loads(self.settings.value("General/gdb_output_mode", type=str))
        output_mode = typedefs.gdb_output_mode(*output_mode)
        self.checkBox_OutputModeAsync.setChecked(output_mode.async_output)
        self.checkBox_OutputModeCommand.setChecked(output_mode.command_output)
        self.checkBox_OutputModeCommandInfo.setChecked(output_mode.command_info)
        self.lineEdit_AutoAttach.setText(self.settings.value("General/auto_attach", type=str))
        self.checkBox_AutoAttachRegex.setChecked(self.settings.value("General/auto_attach_regex", type=bool))
        current_locale = self.settings.value("General/locale", type=str)
        self.comboBox_Language.setCurrentText(language_list.get(current_locale, "en_US"))
        with QSignalBlocker(self.comboBox_Theme):
            self.comboBox_Theme.setCurrentText(themes.theme_strings[self.settings.value("General/theme", type=str)])
        with QSignalBlocker(self.comboBox_Logo):
            self.comboBox_Logo.setCurrentText(self.settings.value("General/logo_path", type=str))
        self.hotkey_to_value.clear()
        for hotkey in states.hotkeys.get_hotkeys():
            self.hotkey_to_value[hotkey.name] = self.settings.value("Hotkeys/" + hotkey.name)
        self.listWidget_Functions_current_row_changed(self.listWidget_Functions.currentRow())
        code_injection_method = self.settings.value("CodeInjection/code_injection_method", type=int)
        if code_injection_method == typedefs.INJECTION_METHOD.DLOPEN:
            self.radioButton_SimpleDLopenCall.setChecked(True)
        elif code_injection_method == typedefs.INJECTION_METHOD.ADVANCED:
            self.radioButton_AdvancedInjection.setChecked(True)

        self.checkBox_ShowMemoryViewOnStop.setChecked(
            self.settings.value("MemoryView/show_memory_view_on_stop", type=bool)
        )
        self.spinBox_InstructionsPerScroll.setValue(self.settings.value("MemoryView/instructions_per_scroll", type=int))
        self.spinBox_BytesPerScroll.setValue(self.settings.value("MemoryView/bytes_per_scroll", type=int))
        self.lineEdit_GDBPath.setText(str(self.settings.value("Debug/gdb_path", type=str)))
        if os.environ.get("APPDIR"):
            self.label_GDBPath.setDisabled(True)
            self.label_GDBPath.setToolTip(tr.UNUSED_APPIMAGE_SETTING)
            self.lineEdit_GDBPath.setDisabled(True)
            self.lineEdit_GDBPath.setToolTip(tr.UNUSED_APPIMAGE_SETTING)
            self.pushButton_GDBPath.setDisabled(True)
            self.pushButton_GDBPath.setToolTip(tr.UNUSED_APPIMAGE_SETTING)
        self.checkBox_GDBLogging.setChecked(self.settings.value("Debug/gdb_logging", type=bool))
        self.comboBox_InterruptSignal.setCurrentText(self.settings.value("Debug/interrupt_signal", type=str))
        self.checkBox_JavaSegfault.setChecked(self.settings.value("Java/ignore_segfault", type=bool))

    def change_display(self, index):
        self.stackedWidget.setCurrentIndex(index)

    def listWidget_Functions_current_row_changed(self, index):
        if index == -1:
            self.lineEdit_Hotkey.clear()
        else:
            self.lineEdit_Hotkey.setText(self.hotkey_to_value[states.hotkeys.get_hotkeys()[index].name])

    def pushButton_ClearHotkey_clicked(self):
        self.lineEdit_Hotkey.clear()
        index = self.listWidget_Functions.currentIndex().row()
        if index != -1:
            self.hotkey_to_value[states.hotkeys.get_hotkeys()[index].name] = self.lineEdit_Hotkey.text()

    def pushButton_ResetSettings_clicked(self):
        if utilwidgets.InputDialog(self, tr.RESET_DEFAULT_SETTINGS).exec():
            settings.set_default_settings()
            self.handle_signals_data = ""
            self.config_gui()

    def checkBox_AutoUpdateAddressTable_state_changed(self):
        if self.checkBox_AutoUpdateAddressTable.isChecked():
            self.QWidget_UpdateInterval.setEnabled(True)
        else:
            self.QWidget_UpdateInterval.setEnabled(False)

    def checkBox_AutoAttachRegex_state_changed(self):
        if self.checkBox_AutoAttachRegex.isChecked():
            self.lineEdit_AutoAttach.setPlaceholderText(tr.MOUSE_OVER_EXAMPLES)
            self.lineEdit_AutoAttach.setToolTip(tr.AUTO_ATTACH_TOOLTIP)
        else:
            self.lineEdit_AutoAttach.setPlaceholderText(tr.SEPARATE_PROCESSES_WITH.format(";"))
            self.lineEdit_AutoAttach.setToolTip("")

    def comboBox_Logo_current_index_changed(self):
        logo_path = self.comboBox_Logo.currentText()
        QApplication.setWindowIcon(QIcon(os.path.join(utils.get_logo_directory(), logo_path)))

    def comboBox_Theme_current_index_changed(self, index: int):
        QApplication.setPalette(themes.get_theme(list(themes.Themes)[index].value))

    def pushButton_GDBPath_clicked(self):
        current_path = self.lineEdit_GDBPath.text()
        file_path, _ = QFileDialog.getOpenFileName(self, tr.SELECT_GDB_BINARY, os.path.dirname(current_path))
        if file_path:
            self.lineEdit_GDBPath.setText(file_path)

    def pushButton_HandleSignals_clicked(self):
        if not self.handle_signals_data:
            self.handle_signals_data = self.settings.value("Debug/handle_signals", type=str)
        signal_dialog = HandleSignalsDialog(self, self.handle_signals_data)
        if signal_dialog.exec():
            self.handle_signals_data = signal_dialog.get_values()

    def lineEdit_Hotkey_key_pressed_event(self, event: QKeyEvent):
        """
        Instead of relying on the QT Event, we grab input from keyboard lib directly.
        This reduces the amount of parsing from keys necessary and catches some more edge cases.

        One final caveat exists: system hotkeys or system wide defined hotkeys (xserver)
        take precedence over the keyboard lib and are not caught completely.
        """
        pressed_events: list[KeyboardEvent] = list(_pressed_events.values())
        if len(pressed_events) == 0:
            # the keypress time was so short its not recognized by keyboard lib.
            return
        hotkey_string = ""
        for ev in pressed_events:
            # replacing keys with their respective base key, e.g "!" --> "1"
            ev.name = to_name[(ev.scan_code, ())][-1]
            # keyboard does recognize meta key (win key) as alt, setting manually
            if ev.scan_code == 125 or ev.scan_code == 126:
                ev.name = "windows"
            hotkey_string += ev.name + "+"

        # remove the last plus
        hotkey_string = hotkey_string[:-1]

        # moved from old keySequenceChanged event
        self.lineEdit_Hotkey.setText(hotkey_string)
        index = self.listWidget_Functions.currentIndex().row()
        if index == -1:
            self.lineEdit_Hotkey.clear()
        else:
            self.hotkey_to_value[states.hotkeys.get_hotkeys()[index].name] = self.lineEdit_Hotkey.text()

```

`GUI/ui_to_py.sh`:

```sh
#!/bin/bash
script_dir="$(dirname "$(readlink -f "$0")")"
cd $script_dir
venv_activator="../.venv/bin/activate"

if [ -f "$venv_activator" ]; then
	. "$venv_activator"
else
    echo "ERROR: Virtual environment not found, please use install.sh to install PINCE first"
    exit
fi

for uifile in *.ui Widgets/*/Form/*.ui
do
    pyfile="${uifile%.ui}.py"
    pyuic6 "$uifile" -o "$pyfile"
done

```

`PINCE.py`:

```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>
Copyright (C) 2016-2017 Çağrı Ulaş <cagriulas@gmail.com>
Copyright (C) 2016-2017 Jakob Kreuze <jakob@memeware.net>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import ast
import collections
import copy
import importlib
import io
import os
import re
import signal
import sys
import traceback
from time import sleep, time

from PyQt6.QtCore import (
    QByteArray,
    QEvent,
    QItemSelection,
    QItemSelectionModel,
    QKeyCombination,
    QLocale,
    QSettings,
    QSignalBlocker,
    QSize,
    QStringListModel,
    Qt,
    QThread,
    QTimer,
    QTranslator,
    pyqtSignal,
)
from PyQt6.QtGui import (
    QBrush,
    QCloseEvent,
    QColor,
    QColorConstants,
    QContextMenuEvent,
    QCursor,
    QIcon,
    QKeyEvent,
    QKeySequence,
    QMouseEvent,
    QMovie,
    QPixmap,
    QShortcut,
    QTextCursor,
    QWheelEvent,
)
from PyQt6.QtWidgets import (
    QAbstractItemView,
    QApplication,
    QCompleter,
    QDialog,
    QDialogButtonBox,
    QFileDialog,
    QMainWindow,
    QMenu,
    QMessageBox,
    QTableWidgetItem,
    QTabWidget,
    QTreeWidgetItem,
    QTreeWidgetItemIterator,
    QWidget,
)

from GUI.AboutWidget import Ui_TabWidget as AboutWidget
from GUI.AbstractTableModels.AsciiModel import QAsciiModel
from GUI.AbstractTableModels.HexModel import QHexModel
from GUI.AddAddressManuallyDialog import Ui_Dialog as ManualAddressDialog
from GUI.BreakpointInfoWidget import Ui_TabWidget as BreakpointInfoWidget
from GUI.ConsoleWidget import Ui_Form as ConsoleWidget
from GUI.DissectCodeDialog import Ui_Dialog as DissectCodeDialog
from GUI.EditInstructionDialog import Ui_Dialog as EditInstructionDialog
from GUI.EditTypeDialog import Ui_Dialog as EditTypeDialog
from GUI.ExamineReferrersWidget import Ui_Form as ExamineReferrersWidget
from GUI.FloatRegisterWidget import Ui_TabWidget as FloatRegisterWidget
from GUI.FunctionsInfoWidget import Ui_Form as FunctionsInfoWidget
from GUI.HexEditDialog import Ui_Dialog as HexEditDialog
from GUI.LoadingDialog import Ui_Dialog as LoadingDialog
from GUI.LogFileWidget import Ui_Form as LogFileWidget
from GUI.MainWindow import Ui_MainWindow as MainWindow
from GUI.ManualAddressDialogUtils.PointerChainOffset import PointerChainOffset
from GUI.MemoryRegionsWidget import Ui_Form as MemoryRegionsWidget

# If you are going to change the name "Ui_MainWindow_MemoryView", review GUI/Labels/RegisterLabel.py as well
from GUI.MemoryViewerWindow import Ui_MainWindow_MemoryView as MemoryViewWindow
from GUI.ReferencedCallsWidget import Ui_Form as ReferencedCallsWidget
from GUI.ReferencedStringsWidget import Ui_Form as ReferencedStringsWidget
from GUI.SearchOpcodeWidget import Ui_Form as SearchOpcodeWidget
from GUI.SelectProcess import Ui_MainWindow as ProcessWindow
from GUI.Session.session import SessionDataChanged, SessionManager
from GUI.Settings import settings, themes
from GUI.StackTraceInfoWidget import Ui_Form as StackTraceInfoWidget
from GUI.States import states
from GUI.TextEditDialog import Ui_Dialog as TextEditDialog
from GUI.TraceInstructionsPromptDialog import Ui_Dialog as TraceInstructionsPromptDialog
from GUI.TraceInstructionsWaitWidget import Ui_Form as TraceInstructionsWaitWidget
from GUI.TraceInstructionsWindow import Ui_MainWindow as TraceInstructionsWindow
from GUI.TrackBreakpointWidget import Ui_Form as TrackBreakpointWidget
from GUI.TrackSelectorDialog import Ui_Dialog as TrackSelectorDialog
from GUI.TrackWatchpointWidget import Ui_Form as TrackWatchpointWidget
from GUI.Utils import guitypedefs, guiutils, utilwidgets
from GUI.Validators.HexValidator import QHexValidator
from GUI.Widgets.Bookmark.Bookmark import BookmarkWidget
from GUI.Widgets.LibpinceEngine.LibpinceEngine import LibpinceEngineWindow
from GUI.Widgets.ManageScanRegions.ManageScanRegions import ManageScanRegionsDialog
from GUI.Widgets.PointerScan.PointerScan import PointerScanWindow
from GUI.Widgets.PointerScanSearch.PointerScanSearch import PointerScanSearchDialog
from GUI.Widgets.RestoreInstructions.RestoreInstructions import RestoreInstructionsWidget
from GUI.Widgets.SessionNotes.SessionNotes import SessionNotesWidget
from GUI.Widgets.Settings.Settings import SettingsDialog
from libpince import debugcore, typedefs, utils
from libpince.utils import safe_str_to_int, safe_int_cast, logger
from libpince.debugcore import ptrscan, scanmem
from tr.tr import TranslationConstants as tr
from tr.tr import get_locale

if __name__ == "__main__":
    app = QApplication([])
    app.setApplicationName("PINCE")
    app.setOrganizationName("PINCE")
    app.setOrganizationDomain("github.io")
    app.setDesktopFileName("io.github.korcankaraokcu.PINCE")
    QSettings.setPath(
        QSettings.Format.NativeFormat, QSettings.Scope.UserScope, utils.get_user_path(typedefs.USER_PATHS.CONFIG)
    )
    settings_instance = QSettings()
    translator = QTranslator()
    try:
        locale = settings_instance.value("General/locale", type=str)
    except SystemError:
        # We're reading the settings for the first time here
        # If there's an error due to python objects, clear settings
        settings_instance.clear()
        locale = None
    if not locale:
        locale = get_locale()
    locale_file = utils.get_script_directory() + f"/i18n/qm/{locale}.qm"
    translator.load(locale_file)
    app.installTranslator(translator)
    tr.translate()
    # Reload states after QApplication instance to ensure that variables are correctly initiated
    # Reloading states after translations also ensures that hotkeys are correctly translated
    importlib.reload(states)
    importlib.reload(themes)  # Needed for correct translations, might not be needed after refactorization

# represents the index of columns in breakpoint table
BREAK_NUM_COL = 0
BREAK_TYPE_COL = 1
BREAK_DISP_COL = 2
BREAK_ENABLED_COL = 3
BREAK_ADDR_COL = 4
BREAK_SIZE_COL = 5
BREAK_ON_HIT_COL = 6
BREAK_HIT_COUNT_COL = 7
BREAK_COND_COL = 8

# row colors for disassemble qtablewidget
PC_COLOR = QColorConstants.Blue
BOOKMARK_COLOR = QColorConstants.Cyan
BREAKPOINT_COLOR = QColorConstants.Red
REF_COLOR = QColorConstants.LightGray

# represents the index of columns in address table
FROZEN_COL = 0  # Frozen
DESC_COL = 1  # Description
ADDR_COL = 2  # Address
TYPE_COL = 3  # Type
VALUE_COL = 4  # Value

# represents the index of columns in search results table
SEARCH_TABLE_ADDRESS_COL = 0
SEARCH_TABLE_VALUE_COL = 1
SEARCH_TABLE_PREVIOUS_COL = 2

# represents the index of columns in disassemble table
DISAS_ADDR_COL = 0
DISAS_BYTES_COL = 1
DISAS_OPCODES_COL = 2
DISAS_COMMENT_COL = 3

# represents the index of columns in floating point table
FLOAT_REGISTERS_NAME_COL = 0
FLOAT_REGISTERS_VALUE_COL = 1

# represents the index of columns in stacktrace table
STACKTRACE_RETURN_ADDRESS_COL = 0
STACKTRACE_FRAME_ADDRESS_COL = 1

# represents the index of columns in stack table
STACK_POINTER_ADDRESS_COL = 0
STACK_VALUE_COL = 1
STACK_POINTS_TO_COL = 2

# represents row and column counts of Hex table
HEX_VIEW_COL_COUNT = 16
HEX_VIEW_ROW_COUNT = 42  # J-JUST A COINCIDENCE, I SWEAR!

# represents the index of columns in track watchpoint table(what accesses this address thingy)
TRACK_WATCHPOINT_COUNT_COL = 0
TRACK_WATCHPOINT_ADDR_COL = 1

# represents the index of columns in track breakpoint table(which addresses this instruction accesses thingy)
TRACK_BREAKPOINT_COUNT_COL = 0
TRACK_BREAKPOINT_ADDR_COL = 1
TRACK_BREAKPOINT_VALUE_COL = 2
TRACK_BREAKPOINT_SOURCE_COL = 3

# represents the index of columns in function info table
FUNCTIONS_INFO_ADDR_COL = 0
FUNCTIONS_INFO_SYMBOL_COL = 1

# represents the index of columns in libpince reference resources table
LIBPINCE_REFERENCE_ITEM_COL = 0
LIBPINCE_REFERENCE_VALUE_COL = 1

# represents the index of columns in search opcode table
SEARCH_OPCODE_ADDR_COL = 0
SEARCH_OPCODE_OPCODES_COL = 1

# represents the index of columns in memory regions table
MEMORY_REGIONS_ADDR_COL = 0
MEMORY_REGIONS_PERM_COL = 1
MEMORY_REGIONS_OFFSET_COL = 2
MEMORY_REGIONS_PATH_COL = 3

# represents the index of columns in dissect code table
DISSECT_CODE_ADDR_COL = 0
DISSECT_CODE_PATH_COL = 1

# represents the index of columns in referenced strings table
REF_STR_ADDR_COL = 0
REF_STR_COUNT_COL = 1
REF_STR_VAL_COL = 2

# represents the index of columns in referenced calls table
REF_CALL_ADDR_COL = 0
REF_CALL_COUNT_COL = 1


def except_hook(exception_type, value, tb):
    focused_widget = app.focusWidget()
    if focused_widget and exception_type == typedefs.GDBInitializeException:
        QMessageBox.information(focused_widget, tr.ERROR, tr.GDB_INIT)
    traceback.print_exception(exception_type, value, tb)


# From version 5.5 and onwards, PyQT calls qFatal() when an exception has been encountered
# So, we must override sys.excepthook to avoid calling of qFatal()
sys.excepthook = except_hook


def signal_handler(signal, frame):
    with QSignalBlocker(app):
        debugcore.detach()
        quit()


signal.signal(signal.SIGINT, signal_handler)


class MainForm(QMainWindow, MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.deleted_regions: list[int] = []
        hotkey_to_func = {
            states.hotkeys.pause_hotkey: self.pause_hotkey_pressed,
            states.hotkeys.break_hotkey: self.break_hotkey_pressed,
            states.hotkeys.continue_hotkey: self.continue_hotkey_pressed,
            states.hotkeys.cancel_hotkey: self.cancel_hotkey_pressed,
            states.hotkeys.toggle_attach_hotkey: self.toggle_attach_hotkey_pressed,
            states.hotkeys.exact_scan_hotkey: lambda: self.nextscan_hotkey_pressed(typedefs.SCAN_TYPE.EXACT),
            states.hotkeys.not_scan_hotkey: lambda: self.nextscan_hotkey_pressed(typedefs.SCAN_TYPE.NOT),
            states.hotkeys.increased_scan_hotkey: lambda: self.nextscan_hotkey_pressed(typedefs.SCAN_TYPE.INCREASED),
            states.hotkeys.increased_by_scan_hotkey: lambda: self.nextscan_hotkey_pressed(
                typedefs.SCAN_TYPE.INCREASED_BY
            ),
            states.hotkeys.decreased_scan_hotkey: lambda: self.nextscan_hotkey_pressed(typedefs.SCAN_TYPE.DECREASED),
            states.hotkeys.decreased_by_scan_hotkey: lambda: self.nextscan_hotkey_pressed(
                typedefs.SCAN_TYPE.DECREASED_BY
            ),
            states.hotkeys.less_scan_hotkey: lambda: self.nextscan_hotkey_pressed(typedefs.SCAN_TYPE.LESS),
            states.hotkeys.more_scan_hotkey: lambda: self.nextscan_hotkey_pressed(typedefs.SCAN_TYPE.MORE),
            states.hotkeys.between_scan_hotkey: lambda: self.nextscan_hotkey_pressed(typedefs.SCAN_TYPE.BETWEEN),
            states.hotkeys.changed_scan_hotkey: lambda: self.nextscan_hotkey_pressed(typedefs.SCAN_TYPE.CHANGED),
            states.hotkeys.unchanged_scan_hotkey: lambda: self.nextscan_hotkey_pressed(typedefs.SCAN_TYPE.UNCHANGED),
        }
        for hotkey, func in hotkey_to_func.items():
            hotkey.change_func(func)
        self.treeWidget_AddressTable.setColumnWidth(FROZEN_COL, 50)
        self.treeWidget_AddressTable.setColumnWidth(DESC_COL, 150)
        self.treeWidget_AddressTable.setColumnWidth(ADDR_COL, 150)
        self.treeWidget_AddressTable.setColumnWidth(TYPE_COL, 150)
        self.tableWidget_valuesearchtable.setColumnWidth(SEARCH_TABLE_ADDRESS_COL, 120)
        self.tableWidget_valuesearchtable.setColumnWidth(SEARCH_TABLE_VALUE_COL, 80)
        self.tableWidget_valuesearchtable.horizontalHeader().setSortIndicatorClearable(True)
        self.await_exit_thread = guitypedefs.AwaitProcessExit()
        self.auto_attach_timer = QTimer(timeout=self.auto_attach_loop)

        settings.init_settings()
        self.settings_changed()
        self.memory_view_window = MemoryViewWindowForm(self)
        self.session_notes = SessionNotesWidget(None)

        if os.environ.get("APPDIR"):
            gdb_path = utils.get_default_gdb_path()
        else:
            gdb_path = states.gdb_path
        if debugcore.init_gdb(gdb_path):
            settings.apply_after_init()
        else:
            utilwidgets.InputDialog(self, tr.GDB_INIT_ERROR, cancel_button=False).exec()
        self.await_exit_thread.process_exited.connect(self.on_inferior_exit)
        self.await_exit_thread.start()
        states.status_thread.process_stopped.connect(self.on_status_stopped)
        states.status_thread.process_running.connect(self.on_status_running)
        states.setting_signals.changed.connect(self.settings_changed)
        self.address_table_timer = QTimer(timeout=self.address_table_loop, singleShot=True)
        self.address_table_timer.start()
        self.search_table_timer = QTimer(timeout=self.search_table_loop, singleShot=True)
        self.search_table_timer.start()
        self.freeze_timer = QTimer(timeout=self.freeze_loop, singleShot=True)
        self.freeze_timer.start()
        self.shortcut_open_file = QShortcut(QKeySequence("Ctrl+O"), self)
        self.shortcut_open_file.activated.connect(SessionManager.load_session)
        guiutils.append_shortcut_to_tooltip(self.pushButton_Open, self.shortcut_open_file)
        self.shortcut_save_file = QShortcut(QKeySequence("Ctrl+S"), self)
        self.shortcut_save_file.activated.connect(SessionManager.save_session)
        guiutils.append_shortcut_to_tooltip(self.pushButton_Save, self.shortcut_save_file)

        # Saving the original function because super() doesn't work when we override functions like this
        self.treeWidget_AddressTable.mousePressEvent_original = self.treeWidget_AddressTable.mousePressEvent
        self.treeWidget_AddressTable.mousePressEvent = self.treeWidget_AddressTable_mouse_press_event
        self.treeWidget_AddressTable.mouseReleaseEvent_original = self.treeWidget_AddressTable.mouseReleaseEvent
        self.treeWidget_AddressTable.mouseReleaseEvent = self.treeWidget_AddressTable_mouse_release_event
        self.treeWidget_AddressTable.keyPressEvent_original = self.treeWidget_AddressTable.keyPressEvent
        self.treeWidget_AddressTable.keyPressEvent = self.treeWidget_AddressTable_key_press_event
        self.treeWidget_AddressTable.contextMenuEvent = self.treeWidget_AddressTable_context_menu_event
        self.pushButton_AttachProcess.clicked.connect(self.pushButton_AttachProcess_clicked)
        self.pushButton_Open.clicked.connect(SessionManager.load_session)
        self.pushButton_Save.clicked.connect(SessionManager.save_session)
        states.session_signals.on_save.connect(self.on_session_save)
        states.session_signals.on_load.connect(self.on_session_loaded)
        states.session_signals.new_session.connect(self.on_new_session)
        self.session = SessionManager.get_session()
        self.pushButton_NewFirstScan.clicked.connect(self.pushButton_NewFirstScan_clicked)
        self.pushButton_UndoScan.clicked.connect(self.pushButton_UndoScan_clicked)
        self.pushButton_NextScan.clicked.connect(self.pushButton_NextScan_clicked)
        self.pushButton_ScanRegions.clicked.connect(self.pushButton_ScanRegions_clicked)
        self.scan_mode = typedefs.SCAN_MODE.NEW
        self.pushButton_NewFirstScan_clicked()
        self.comboBox_ScanScope_init()
        self.comboBox_ValueType_init()
        guiutils.fill_endianness_combobox(self.comboBox_Endianness)
        self.comboBox_Endianness.currentIndexChanged.connect(self.on_endianness_changed)
        self.checkBox_Hex.stateChanged.connect(self.checkBox_Hex_stateChanged)
        self.comboBox_ValueType.currentIndexChanged.connect(self.comboBox_ValueType_current_index_changed)
        self.lineEdit_Scan.setValidator(guiutils.validator_map.get("int"))
        self.lineEdit_Scan2.setValidator(guiutils.validator_map.get("int"))
        self.lineEdit_Scan.keyPressEvent_original = self.lineEdit_Scan.keyPressEvent
        self.lineEdit_Scan2.keyPressEvent_original = self.lineEdit_Scan2.keyPressEvent
        self.lineEdit_Scan.keyPressEvent = self.lineEdit_Scan_on_key_press_event
        self.lineEdit_Scan2.keyPressEvent = self.lineEdit_Scan2_on_key_press_event
        self.comboBox_ScanType.currentIndexChanged.connect(self.comboBox_ScanType_current_index_changed)
        self.comboBox_ScanType_current_index_changed()
        self.pushButton_Settings.clicked.connect(self.pushButton_Settings_clicked)
        self.pushButton_Console.clicked.connect(self.pushButton_Console_clicked)
        self.pushButton_Wiki.clicked.connect(self.pushButton_Wiki_clicked)
        self.pushButton_About.clicked.connect(self.pushButton_About_clicked)
        self.pushButton_AddAddressManually.clicked.connect(self.pushButton_AddAddressManually_clicked)
        self.pushButton_MemoryView.clicked.connect(self.pushButton_MemoryView_clicked)
        self.pushButton_RefreshAdressTable.clicked.connect(self.pushButton_RefreshAdressTable_clicked)
        self.pushButton_CopyToAddressTable.clicked.connect(self.copy_to_address_table)
        self.pushButton_CleanAddressTable.clicked.connect(self.clear_address_table)
        self.tableWidget_valuesearchtable.cellDoubleClicked.connect(
            self.tableWidget_valuesearchtable_cell_double_clicked
        )
        self.tableWidget_valuesearchtable.keyPressEvent_original = self.tableWidget_valuesearchtable.keyPressEvent
        self.tableWidget_valuesearchtable.keyPressEvent = self.tableWidget_valuesearchtable_key_press_event
        self.tableWidget_valuesearchtable.contextMenuEvent = self.tableWidget_valuesearchtable_context_menu_event
        self.treeWidget_AddressTable.itemDoubleClicked.connect(self.treeWidget_AddressTable_item_double_clicked)
        self.treeWidget_AddressTable.expanded.connect(self.resize_address_table)
        self.treeWidget_AddressTable.collapsed.connect(self.resize_address_table)
        self.treeWidget_AddressTable.header().setSortIndicatorClearable(True)
        self.treeWidget_AddressTable.header().setSortIndicator(-1, Qt.SortOrder.AscendingOrder)  # Clear sort indicator
        icons_directory = guiutils.get_icons_directory()
        self.pushButton_AttachProcess.setIcon(QIcon(QPixmap(icons_directory + "/monitor.png")))
        self.pushButton_Open.setIcon(QIcon(QPixmap(icons_directory + "/folder.png")))
        self.pushButton_Save.setIcon(QIcon(QPixmap(icons_directory + "/disk.png")))
        self.pushButton_Settings.setIcon(QIcon(QPixmap(icons_directory + "/wrench.png")))
        self.pushButton_CopyToAddressTable.setIcon(QIcon(QPixmap(icons_directory + "/arrow_down.png")))
        self.pushButton_CleanAddressTable.setIcon(QIcon(QPixmap(icons_directory + "/bin_closed.png")))
        self.pushButton_RefreshAdressTable.setIcon(QIcon(QPixmap(icons_directory + "/table_refresh.png")))
        self.pushButton_Console.setIcon(QIcon(QPixmap(icons_directory + "/application_xp_terminal.png")))
        self.pushButton_Wiki.setIcon(QIcon(QPixmap(icons_directory + "/book_open.png")))
        self.pushButton_About.setIcon(QIcon(QPixmap(icons_directory + "/information.png")))
        self.pushButton_NextScan.setEnabled(False)
        self.pushButton_UndoScan.setEnabled(False)
        self.flashAttachButton = True
        self.flashAttachButtonTimer = QTimer()
        self.flashAttachButtonTimer.timeout.connect(self.flash_attach_button)
        self.flashAttachButton_gradiantState = 0
        self.flashAttachButtonTimer.start(100)
        self.is_scanning = False

        self.pushButton_Notes.clicked.connect(self.session_notes.toggle_visibility)
        guiutils.center(self)

    def settings_changed(self):
        if states.auto_attach:
            self.auto_attach_timer.start(100)
        else:
            self.auto_attach_timer.stop()

    # Check if any process should be attached to automatically
    # Patterns at former positions have higher priority if regex is off
    def auto_attach_loop(self):
        if debugcore.currentpid != -1:
            return
        if states.auto_attach_regex:
            try:
                compiled_re = re.compile(states.auto_attach)
            except:
                logger.exception(f"Auto-attach failed: {states.auto_attach} isn't a valid regex")
                return
            for pid, _, name in utils.get_process_list():
                if compiled_re.search(name):
                    self.attach_to_pid(int(pid))
                    return
        else:
            for target in states.auto_attach.split(";"):
                for pid, _, name in utils.get_process_list():
                    if name.find(target) != -1:
                        self.attach_to_pid(int(pid))
                        return

    # Keyboard package has an issue with exceptions, any trigger function that throws an exception stops the event loop
    # Writing a custom event loop instead of ignoring exceptions could work as well but honestly, this looks cleaner
    # Keyboard package does not play well with Qt, do not use anything Qt related with hotkeys
    # Instead of using Qt functions, try to use their signals to prevent crashes
    @utils.ignore_exceptions
    def pause_hotkey_pressed(self):
        if not debugcore.active_trace:
            debugcore.interrupt_inferior(typedefs.STOP_REASON.PAUSE)

    @utils.ignore_exceptions
    def break_hotkey_pressed(self):
        if not debugcore.active_trace:
            debugcore.interrupt_inferior()

    @utils.ignore_exceptions
    def continue_hotkey_pressed(self):
        if not (
            debugcore.currentpid == -1
            or debugcore.inferior_status == typedefs.INFERIOR_STATUS.RUNNING
            or debugcore.active_trace
        ):
            debugcore.continue_inferior()

    @utils.ignore_exceptions
    def cancel_hotkey_pressed(self):
        if debugcore.cancel_ongoing_command():
            logger.info("Cancelled the ongoing GDB command")

    @utils.ignore_exceptions
    def toggle_attach_hotkey_pressed(self):
        result = debugcore.toggle_attach()
        if not result:
            logger.error("Unable to toggle attach")
        elif result == typedefs.TOGGLE_ATTACH.DETACHED:
            self.on_status_detached()
        else:
            # Attaching back doesn't update the status if the process is already stopped before detachment
            with debugcore.status_changed_condition:
                debugcore.status_changed_condition.notify_all()

    @utils.ignore_exceptions
    def nextscan_hotkey_pressed(self, index):
        if self.scan_mode == typedefs.SCAN_MODE.NEW or self.is_scanning:
            return
        self.comboBox_ScanType.setCurrentIndex(index)
        self.pushButton_NextScan.clicked.emit()

    def treeWidget_AddressTable_context_menu_event(self, event):
        current_row = guiutils.get_current_item(self.treeWidget_AddressTable)
        current_address = current_row.text(ADDR_COL) if current_row else None
        header = self.treeWidget_AddressTable.headerItem()
        menu = QMenu()
        delete_record = menu.addAction(f"{tr.DELETE}[Del]")
        edit_menu = menu.addMenu(tr.EDIT)
        edit_desc = edit_menu.addAction(f"{header.text(DESC_COL)}[Ctrl+Enter]")
        edit_address = edit_menu.addAction(f"{header.text(ADDR_COL)}[Ctrl+Alt+Enter]")
        edit_type = edit_menu.addAction(f"{header.text(TYPE_COL)}[Alt+Enter]")
        edit_value = edit_menu.addAction(f"{header.text(VALUE_COL)}[Enter]")
        show_hex = menu.addAction(tr.SHOW_HEX)
        show_dec = menu.addAction(tr.SHOW_DEC)
        show_unsigned = menu.addAction(tr.SHOW_UNSIGNED)
        show_signed = menu.addAction(tr.SHOW_SIGNED)
        toggle_record = menu.addAction(f"{tr.TOGGLE}[Space]")
        toggle_children = menu.addAction(f"{tr.TOGGLE_CHILDREN}[Ctrl+Space]")
        menu.addSeparator()
        browse_region = menu.addAction(f"{tr.BROWSE_MEMORY_REGION}[Ctrl+B]")
        disassemble = menu.addAction(f"{tr.DISASSEMBLE_ADDRESS}[Ctrl+D]")
        menu.addSeparator()
        pointer_scanner = menu.addAction(tr.POINTER_SCANNER)
        pointer_scan = menu.addAction(tr.POINTER_SCAN)
        menu.addSeparator()
        what_writes = menu.addAction(tr.WHAT_WRITES)
        what_reads = menu.addAction(tr.WHAT_READS)
        what_accesses = menu.addAction(tr.WHAT_ACCESSES)
        menu.addSeparator()
        cut_record = menu.addAction(f"{tr.CUT}[Ctrl+X]")
        copy_record = menu.addAction(f"{tr.COPY}[Ctrl+C]")
        paste_record = menu.addAction(f"{tr.PASTE}[Ctrl+V]")
        paste_inside = menu.addAction(f"{tr.PASTE_INSIDE}[V]")
        menu.addSeparator()
        add_group = menu.addAction(tr.ADD_GROUP)
        create_group = menu.addAction(tr.CREATE_GROUP)
        if current_row is None:
            deletion_list = [
                edit_menu.menuAction(),
                show_hex,
                show_dec,
                show_unsigned,
                show_signed,
                toggle_record,
                toggle_children,
                browse_region,
                disassemble,
                pointer_scan,
                what_writes,
                what_reads,
                what_accesses,
                cut_record,
                copy_record,
                paste_inside,
                delete_record,
                add_group,
            ]
            guiutils.delete_menu_entries(menu, deletion_list)
        else:
            value_type = current_row.data(TYPE_COL, Qt.ItemDataRole.UserRole)
            if typedefs.VALUE_INDEX.is_integer(value_type.value_index):
                if value_type.value_repr is typedefs.VALUE_REPR.HEX:
                    guiutils.delete_menu_entries(menu, [show_unsigned, show_signed, show_hex])
                elif value_type.value_repr is typedefs.VALUE_REPR.UNSIGNED:
                    guiutils.delete_menu_entries(menu, [show_unsigned, show_dec])
                elif value_type.value_repr is typedefs.VALUE_REPR.SIGNED:
                    guiutils.delete_menu_entries(menu, [show_signed, show_dec])
            else:
                guiutils.delete_menu_entries(menu, [show_hex, show_dec, show_unsigned, show_signed])
            if current_row.childCount() == 0:
                guiutils.delete_menu_entries(menu, [toggle_children])
            guiutils.delete_menu_entries(menu, [pointer_scanner])
            if debugcore.currentpid == -1:
                browse_region.setEnabled(False)
                disassemble.setEnabled(False)
                pointer_scan.setEnabled(False)
            if not debugcore.is_attached():
                what_writes.setEnabled(False)
                what_reads.setEnabled(False)
                what_accesses.setEnabled(False)
        font_size = self.treeWidget_AddressTable.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            delete_record: self.delete_records,
            edit_desc: self.treeWidget_AddressTable_edit_desc,
            edit_address: self.treeWidget_AddressTable_edit_address,
            edit_type: self.treeWidget_AddressTable_edit_type,
            edit_value: self.treeWidget_AddressTable_edit_value,
            show_hex: lambda: self.treeWidget_AddressTable_change_repr(typedefs.VALUE_REPR.HEX),
            show_dec: lambda: self.treeWidget_AddressTable_change_repr(typedefs.VALUE_REPR.UNSIGNED),
            show_unsigned: lambda: self.treeWidget_AddressTable_change_repr(typedefs.VALUE_REPR.UNSIGNED),
            show_signed: lambda: self.treeWidget_AddressTable_change_repr(typedefs.VALUE_REPR.SIGNED),
            toggle_record: self.toggle_records,
            toggle_children: lambda: self.toggle_records(True),
            browse_region: lambda: self.browse_region_for_address(current_address),
            disassemble: lambda: self.disassemble_for_address(current_address),
            pointer_scanner: self.exec_pointer_scanner,
            pointer_scan: self.exec_pointer_scan,
            what_writes: lambda: self.exec_track_watchpoint_widget(typedefs.WATCHPOINT_TYPE.WRITE_ONLY),
            what_reads: lambda: self.exec_track_watchpoint_widget(typedefs.WATCHPOINT_TYPE.READ_ONLY),
            what_accesses: lambda: self.exec_track_watchpoint_widget(typedefs.WATCHPOINT_TYPE.BOTH),
            cut_record: self.cut_records,
            copy_record: self.copy_records,
            paste_record: self.paste_records,
            paste_inside: lambda: self.paste_records(True),
            add_group: self.group_records,
            create_group: self.create_group,
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def exec_pointer_scanner(self):
        pointer_window = PointerScanWindow(self)
        pointer_window.show()

    def exec_pointer_scan(self):
        selected_row = guiutils.get_current_item(self.treeWidget_AddressTable)
        if not selected_row:
            return
        address = selected_row.text(ADDR_COL).strip("P->")
        pointer_window = PointerScanWindow(self)
        pointer_window.show()
        dialog = PointerScanSearchDialog(pointer_window, address)
        dialog.exec()

    def exec_track_watchpoint_widget(self, watchpoint_type):
        selected_row = guiutils.get_current_item(self.treeWidget_AddressTable)
        if not selected_row:
            return
        address = selected_row.text(ADDR_COL).strip("P->")  # @todo Maybe rework address grabbing logic in the future
        address_data = selected_row.data(ADDR_COL, Qt.ItemDataRole.UserRole)
        if isinstance(address_data, typedefs.PointerChainRequest):
            selection_dialog = TrackSelectorDialogForm(self)
            selection_dialog.exec()
            if not selection_dialog.selection:
                return
            if selection_dialog.selection == "pointer":
                address = address_data.get_base_address_as_str()
        value_type = selected_row.data(TYPE_COL, Qt.ItemDataRole.UserRole)
        if typedefs.VALUE_INDEX.is_string(value_type.value_index):
            value_text = selected_row.text(VALUE_COL)
            encoding, option = typedefs.string_index_to_encoding_dict[value_type.value_index]
            byte_len = len(value_text.encode(encoding, option))
        elif value_type.value_index == typedefs.VALUE_INDEX.AOB:
            byte_len = value_type.length
        else:
            byte_len = typedefs.index_to_valuetype_dict[value_type.value_index][0]
        TrackWatchpointWidgetForm(self, address, byte_len, watchpoint_type)

    def browse_region_for_address(self, address: str):
        if address:
            self.memory_view_window.hex_dump_address(int(address.strip("P->"), 16))
            self.memory_view_window.show()
            self.memory_view_window.activateWindow()

    def disassemble_for_address(self, address: str):
        if address and self.memory_view_window.disassemble_expression(address.strip("P->")):
            self.memory_view_window.show()
            self.memory_view_window.activateWindow()

    def change_freeze_type(self, freeze_type: int | None = None, row: QTreeWidgetItem | None = None) -> None:
        if freeze_type == None:
            # No type has been specified, iterate through the freeze types
            # This usually happens if user clicks the freeze type text instead of the checkbox
            frozen: typedefs.Frozen = row.data(FROZEN_COL, Qt.ItemDataRole.UserRole)
            if frozen.freeze_type == typedefs.FREEZE_TYPE.ALLOW_DECREMENT:
                # Decrement is the last freeze type
                freeze_type = typedefs.FREEZE_TYPE.DEFAULT
            else:
                freeze_type = frozen.freeze_type + 1
        rows = [row] if row else self.treeWidget_AddressTable.selectedItems()
        for row in rows:
            frozen: typedefs.Frozen = row.data(FROZEN_COL, Qt.ItemDataRole.UserRole)
            if row.checkState(FROZEN_COL) == Qt.CheckState.Checked:
                frozen.freeze_type = freeze_type
                if freeze_type == typedefs.FREEZE_TYPE.DEFAULT:
                    row.setText(FROZEN_COL, "")
                    row.setForeground(FROZEN_COL, QBrush())
                elif freeze_type == typedefs.FREEZE_TYPE.ALLOW_INCREMENT:
                    row.setText(FROZEN_COL, "▲")
                    row.setForeground(FROZEN_COL, QBrush(QColor(0, 255, 0)))
                elif freeze_type == typedefs.FREEZE_TYPE.ALLOW_DECREMENT:
                    row.setText(FROZEN_COL, "▼")
                    row.setForeground(FROZEN_COL, QBrush(QColor(255, 0, 0)))
            else:
                frozen.freeze_type = typedefs.FREEZE_TYPE.DEFAULT
                row.setText(FROZEN_COL, "")
                row.setForeground(FROZEN_COL, QBrush())

    def toggle_records(self, toggle_children=False):
        row = guiutils.get_current_item(self.treeWidget_AddressTable)
        selected_items = self.treeWidget_AddressTable.selectedItems()
        # If only one item is selected and then clicked while ctrl is being held
        # There'll be no selected rows even with a current row present
        if row and selected_items:
            if not row.isSelected():
                row = selected_items[0]
            check_state = row.checkState(FROZEN_COL)
            new_state = Qt.CheckState.Checked if check_state == Qt.CheckState.Unchecked else Qt.CheckState.Unchecked
            for row in selected_items:
                self.handle_freeze_change(row, new_state)
                if toggle_children:
                    for index in range(row.childCount()):
                        child = row.child(index)
                        self.handle_freeze_change(child, new_state)

    def cut_records(self):
        self.copy_records()
        self.delete_records()

    def copy_records(self):
        # Recursive copy
        items = self.treeWidget_AddressTable.selectedItems()

        def index_of(item):
            """Returns the index used to access the given QTreeWidgetItem
            as a list of ints."""
            result = []
            while True:
                parent = item.parent()
                if parent:
                    result.append(parent.indexOfChild(item))
                    item = parent
                else:
                    result.append(item.treeWidget().indexOfTopLevelItem(item))
                    return result[::-1]

        # First, order the items by their indices in the tree widget.
        # Store the indices for later usage.
        index_items = [(index_of(item), item) for item in items]
        index_items.sort(key=lambda x: x[0])  # sort by index

        # Now filter any selected items that is a descendant of another selected items.
        items = []
        last_index = [-1]  # any invalid list of indices are fine
        for index, item in index_items:
            if index[: len(last_index)] == last_index:
                continue  # this item is a descendant of the last item
            items.append(item)
            last_index = index

        app.clipboard().setText(repr([self.read_address_table_recursively(item) for item in items]))

    def insert_records(self, records, parent_row, insert_index):
        # parent_row should be a QTreeWidgetItem in treeWidget_AddressTable
        # records should be an iterable of valid output of read_address_table_recursively
        assert isinstance(parent_row, QTreeWidgetItem)
        for rec in records:
            row = QTreeWidgetItem()
            row.setCheckState(FROZEN_COL, Qt.CheckState.Unchecked)
            frozen = typedefs.Frozen("", typedefs.FREEZE_TYPE.DEFAULT)
            row.setData(FROZEN_COL, Qt.ItemDataRole.UserRole, frozen)

            # Deserialize address_expr and value_type from rec
            if isinstance(rec[1], (list, tuple)):
                address_expr = typedefs.PointerChainRequest(*rec[1])
            else:
                address_expr = rec[1]
            value_type = typedefs.ValueType(*rec[2])
            self.change_address_table_entries(row, rec[0], address_expr, value_type)

            # Insert the row at the current insert_index
            parent_row.insertChild(insert_index, row)
            insert_index += 1

            # Recursively insert children of this row
            self.insert_records(rec[-1], row, 0)
        parent_row.setExpanded(True)
        self.session.data_changed |= SessionDataChanged.ADDRESS_TREE

    def paste_records(self, insert_inside=False):
        try:
            records = ast.literal_eval(app.clipboard().text())
        except (SyntaxError, ValueError):
            QMessageBox.information(self, tr.ERROR, tr.INVALID_CLIPBOARD)
            return

        insert_row = guiutils.get_current_item(self.treeWidget_AddressTable)
        root = self.treeWidget_AddressTable.invisibleRootItem()
        if not insert_row:  # this is common when the treeWidget_AddressTable is empty
            self.insert_records(records, root, self.treeWidget_AddressTable.topLevelItemCount())
        elif insert_inside:
            self.insert_records(records, insert_row, 0)
        else:
            parent = insert_row.parent() or root
            self.insert_records(records, parent, parent.indexOfChild(insert_row) + 1)
        self.update_address_table()

    def group_records(self):
        selected_items = self.treeWidget_AddressTable.selectedItems()
        if self.create_group():
            item_count = self.treeWidget_AddressTable.topLevelItemCount()
            last_item = self.treeWidget_AddressTable.topLevelItem(item_count - 1)
            for item in selected_items:
                parent = item.parent()
                if parent:
                    parent.removeChild(item)
                else:
                    index = self.treeWidget_AddressTable.indexOfTopLevelItem(item)
                    self.treeWidget_AddressTable.takeTopLevelItem(index)
                last_item.addChild(item)
            self.treeWidget_AddressTable.setCurrentItem(last_item)
            last_item.setExpanded(True)

    def create_group(self):
        dialog = utilwidgets.InputDialog(self, [(tr.ENTER_DESCRIPTION, tr.GROUP)])
        if dialog.exec():
            desc = dialog.get_values()[0]
            self.add_entry_to_addresstable(desc, "0x0")
            return True
        return False

    def delete_records(self):
        root = self.treeWidget_AddressTable.invisibleRootItem()
        for item in self.treeWidget_AddressTable.selectedItems():
            (item.parent() or root).removeChild(item)

    def treeWidget_AddressTable_mouse_press_event(self, event: QMouseEvent) -> None:
        self.treeWidget_AddressTable.mousePressEvent_original(event)
        item = self.treeWidget_AddressTable.itemAt(event.pos())
        column = self.treeWidget_AddressTable.columnAt(event.pos().x())
        # Qt doesn't select rows when checkboxes are clicked
        # Ensure that the row is selected when frozen col is clicked
        if item and column == FROZEN_COL:
            item.setSelected(True)

    def treeWidget_AddressTable_mouse_release_event(self, event: QMouseEvent) -> None:
        item = self.treeWidget_AddressTable.itemAt(event.pos())
        column = self.treeWidget_AddressTable.columnAt(event.pos().x())
        if item and column == FROZEN_COL:
            old_state = item.checkState(FROZEN_COL)
            self.treeWidget_AddressTable.mouseReleaseEvent_original(event)
            new_state = item.checkState(FROZEN_COL)
            item.setSelected(True)
            box_clicked = old_state != new_state
            current_item = self.treeWidget_AddressTable.currentItem()
            if not box_clicked and new_state == Qt.CheckState.Checked:
                self.change_freeze_type(row=current_item)
                frozen: typedefs.Frozen = current_item.data(FROZEN_COL, Qt.ItemDataRole.UserRole)
                freeze_type = frozen.freeze_type
            for selected_item in self.treeWidget_AddressTable.selectedItems():
                if box_clicked:
                    self.handle_freeze_change(selected_item, new_state)
                elif new_state == Qt.CheckState.Checked:
                    self.change_freeze_type(freeze_type, selected_item)
        else:
            self.treeWidget_AddressTable.mouseReleaseEvent_original(event)

    def treeWidget_AddressTable_key_press_event(self, event: QKeyEvent):
        current_row = guiutils.get_current_item(self.treeWidget_AddressTable)
        current_address = current_row.text(ADDR_COL) if current_row else None
        actions = typedefs.KeyboardModifiersTupleDict(
            [
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_Delete), self.delete_records),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_B),
                    lambda: self.browse_region_for_address(current_address),
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_D),
                    lambda: self.disassemble_for_address(current_address),
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_R),
                    self.pushButton_RefreshAdressTable_clicked,
                ),
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_Space), self.toggle_records),
                (QKeyCombination(Qt.KeyboardModifier.ShiftModifier, Qt.Key.Key_Space), self.toggle_records),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_Space),
                    lambda: self.toggle_records(True),
                ),
                (QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_X), self.cut_records),
                (QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_C), self.copy_records),
                (QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_V), self.paste_records),
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_V), lambda: self.paste_records(True)),
                (
                    QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_Return),
                    self.treeWidget_AddressTable_edit_value,
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.KeypadModifier, Qt.Key.Key_Enter),
                    self.treeWidget_AddressTable_edit_value,
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_Return),
                    self.treeWidget_AddressTable_edit_desc,
                ),
                (
                    QKeyCombination(
                        Qt.KeyboardModifier.ControlModifier | Qt.KeyboardModifier.AltModifier, Qt.Key.Key_Return
                    ),
                    self.treeWidget_AddressTable_edit_address,
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.AltModifier, Qt.Key.Key_Return),
                    self.treeWidget_AddressTable_edit_type,
                ),
            ]
        )
        try:
            actions[QKeyCombination(event.modifiers(), Qt.Key(event.key()))]()
        except KeyError:
            self.treeWidget_AddressTable.keyPressEvent_original(event)

    def update_address_table(self):
        if debugcore.currentpid == -1 or self.treeWidget_AddressTable.topLevelItemCount() == 0:
            return
        it = QTreeWidgetItemIterator(self.treeWidget_AddressTable)
        mem_handle = debugcore.memory_handle()
        basic_math_exp = re.compile(r"^[0-9a-fA-F][/*+\-0-9a-fA-FxX]+$")
        while True:
            row = it.value()
            if not row:
                break
            it += 1
            address_data = row.data(ADDR_COL, Qt.ItemDataRole.UserRole)
            if isinstance(address_data, typedefs.PointerChainRequest):
                expression = address_data.base_address
            else:
                expression = address_data
            parent = row.parent()
            if parent and expression.startswith(("+", "-")):
                expression = parent.data(ADDR_COL, Qt.ItemDataRole.UserRole + 1) + expression
            if expression in states.exp_cache:
                address = states.exp_cache[expression]
            elif expression.startswith(("+", "-")):  # If parent has an empty address
                address = expression
            elif basic_math_exp.match(expression.replace(" ", "")):
                try:
                    address = hex(eval(expression))
                except:
                    address = debugcore.examine_expression(expression).address
                    states.exp_cache[expression] = address
            else:
                address = debugcore.examine_expression(expression).address
                states.exp_cache[expression] = address
            vt = row.data(TYPE_COL, Qt.ItemDataRole.UserRole)
            if isinstance(address_data, typedefs.PointerChainRequest):
                # The original base could be a symbol so we have to save it
                # This little hack avoids the unnecessary examine_expression call
                # TODO: Consider implementing exp_cache inside libpince so we don't need this hack
                pointer_chain_req = address_data
                if address:
                    old_base = pointer_chain_req.base_address  # save the old base
                    pointer_chain_req.base_address = address
                    pointer_chain_result = debugcore.read_pointer_chain(pointer_chain_req)
                    if pointer_chain_result and pointer_chain_result.get_final_address():
                        address = pointer_chain_result.get_final_address_as_hex()
                    else:
                        address = None
                    address_data.base_address = old_base  # then set it back
                    if address:
                        row.setText(ADDR_COL, f"P->{address}")
                    else:
                        row.setText(ADDR_COL, "P->??")
                else:
                    row.setText(ADDR_COL, "P->??")
            else:
                row.setText(ADDR_COL, address or address_data)
            address = "" if not address else address
            row.setData(ADDR_COL, Qt.ItemDataRole.UserRole + 1, address)
            value = debugcore.read_memory(
                address, vt.value_index, vt.length, vt.zero_terminate, vt.value_repr, vt.endian, mem_handle=mem_handle
            )
            value = "" if value is None else str(value)
            row.setText(VALUE_COL, value)

    def scan_values(self):
        if debugcore.currentpid == -1:
            return
        search_for = self.validate_search(self.lineEdit_Scan.text(), self.lineEdit_Scan2.text())
        self.QWidget_Toolbox.setEnabled(False)
        self.progressBar.setValue(0)
        self.progress_bar_timer = QTimer(timeout=self.update_progress_bar)
        self.progress_bar_timer.start(100)
        scan_thread = guitypedefs.Worker(scanmem.send_command, search_for)
        scan_thread.signals.finished.connect(self.scan_callback)
        states.threadpool.start(scan_thread)
        self.is_scanning = True

    def resize_address_table(self):
        self.treeWidget_AddressTable.resizeColumnToContents(FROZEN_COL)

    # gets the information from the dialog then adds it to addresstable
    def pushButton_AddAddressManually_clicked(self):
        manual_address_dialog = ManualAddressDialogForm(self)
        if manual_address_dialog.exec():
            desc, address_expr, vt = manual_address_dialog.get_values()
            self.add_entry_to_addresstable(desc, address_expr, vt)
            self.update_address_table()

    def pushButton_RefreshAdressTable_clicked(self):
        states.exp_cache.clear()
        self.update_address_table()

    def pushButton_MemoryView_clicked(self):
        self.memory_view_window.showMaximized()
        self.memory_view_window.activateWindow()

    def pushButton_Wiki_clicked(self):
        utils.execute_command_as_user('python3 -m webbrowser "https://github.com/korcankaraokcu/PINCE/wiki"')

    def pushButton_About_clicked(self):
        about_widget = AboutWidgetForm(self)
        about_widget.show()
        about_widget.activateWindow()

    def pushButton_Settings_clicked(self):
        SettingsDialog(self).exec()

    def pushButton_Console_clicked(self):
        console_widget = ConsoleWidgetForm(self)
        console_widget.showMaximized()

    def checkBox_Hex_stateChanged(self, state):
        if Qt.CheckState(state) == Qt.CheckState.Checked:
            # allows only things that are hex, can also start with 0x
            self.lineEdit_Scan.setValidator(guiutils.validator_map.get("int_hex"))
            self.lineEdit_Scan2.setValidator(guiutils.validator_map.get("int_hex"))
        else:
            # sets it back to integers only
            self.lineEdit_Scan.setValidator(guiutils.validator_map.get("int"))
            self.lineEdit_Scan2.setValidator(guiutils.validator_map.get("int"))

    def pushButton_NewFirstScan_clicked(self):
        if debugcore.currentpid == -1:
            self.comboBox_ScanType_init()
            return
        if self.scan_mode == typedefs.SCAN_MODE.ONGOING:
            self.reset_scan()
        else:
            self.scan_mode = typedefs.SCAN_MODE.ONGOING
            self.pushButton_NewFirstScan.setText(tr.NEW_SCAN)
            self.comboBox_ValueType.setEnabled(False)
            self.pushButton_NextScan.setEnabled(True)
            scanmem.reset()
            for region_id in self.deleted_regions:
                debugcore.scanmem.send_command(f"dregion {region_id}")
            self.comboBox_ScanScope.setEnabled(False)
            self.comboBox_Endianness.setEnabled(False)
            self.scan_values()
        self.comboBox_ScanType_init()

    def handle_line_edit_scan_key_press_event(self, event):
        valid_keys = [Qt.Key.Key_Return, Qt.Key.Key_Enter]
        if event.key() in valid_keys and Qt.KeyboardModifier.ControlModifier in event.modifiers():
            self.pushButton_NewFirstScan_clicked()
            return

        if event.key() in valid_keys:
            if self.scan_mode == typedefs.SCAN_MODE.ONGOING:
                self.pushButton_NextScan_clicked()
            else:
                self.pushButton_NewFirstScan_clicked()
            return

    def lineEdit_Scan_on_key_press_event(self, event):
        self.handle_line_edit_scan_key_press_event(event)
        self.lineEdit_Scan.keyPressEvent_original(event)

    def lineEdit_Scan2_on_key_press_event(self, event):
        self.handle_line_edit_scan_key_press_event(event)
        self.lineEdit_Scan2.keyPressEvent_original(event)

    def pushButton_UndoScan_clicked(self):
        if debugcore.currentpid == -1:
            return
        undo_thread = guitypedefs.Worker(scanmem.undo_scan)
        undo_thread.signals.finished.connect(self.scan_callback)
        states.threadpool.start(undo_thread)
        self.pushButton_UndoScan.setEnabled(False)  # we can undo once so set it to false and re-enable at next scan

    def comboBox_ScanType_current_index_changed(self):
        hidden_types = [
            typedefs.SCAN_TYPE.INCREASED,
            typedefs.SCAN_TYPE.DECREASED,
            typedefs.SCAN_TYPE.CHANGED,
            typedefs.SCAN_TYPE.UNCHANGED,
            typedefs.SCAN_TYPE.UNKNOWN,
        ]
        if self.comboBox_ScanType.currentData(Qt.ItemDataRole.UserRole) in hidden_types:
            self.widget_Scan.setEnabled(False)
        else:
            self.widget_Scan.setEnabled(True)
        if self.comboBox_ScanType.currentData(Qt.ItemDataRole.UserRole) == typedefs.SCAN_TYPE.BETWEEN:
            self.label_Between.setVisible(True)
            self.lineEdit_Scan2.setVisible(True)
        else:
            self.label_Between.setVisible(False)
            self.lineEdit_Scan2.setVisible(False)

    def comboBox_ScanType_init(self):
        scan_type_text = {
            typedefs.SCAN_TYPE.EXACT: tr.EXACT,
            typedefs.SCAN_TYPE.NOT: tr.NOT,
            typedefs.SCAN_TYPE.INCREASED: tr.INCREASED,
            typedefs.SCAN_TYPE.INCREASED_BY: tr.INCREASED_BY,
            typedefs.SCAN_TYPE.DECREASED: tr.DECREASED,
            typedefs.SCAN_TYPE.DECREASED_BY: tr.DECREASED_BY,
            typedefs.SCAN_TYPE.LESS: tr.LESS_THAN,
            typedefs.SCAN_TYPE.MORE: tr.MORE_THAN,
            typedefs.SCAN_TYPE.BETWEEN: tr.BETWEEN,
            typedefs.SCAN_TYPE.CHANGED: tr.CHANGED,
            typedefs.SCAN_TYPE.UNCHANGED: tr.UNCHANGED,
            typedefs.SCAN_TYPE.UNKNOWN: tr.UNKNOWN_VALUE,
        }
        current_type = self.comboBox_ScanType.currentData(Qt.ItemDataRole.UserRole)
        value_type = self.comboBox_ValueType.currentData(Qt.ItemDataRole.UserRole)
        self.comboBox_ScanType.clear()
        items = typedefs.SCAN_TYPE.get_list(self.scan_mode, value_type)
        old_index = 0
        for index, type_index in enumerate(items):
            if current_type == type_index:
                old_index = index
            self.comboBox_ScanType.addItem(scan_type_text[type_index], type_index)
        self.comboBox_ScanType.setCurrentIndex(old_index)

    def comboBox_ScanScope_init(self):
        scan_scope_text = [
            (typedefs.SCAN_SCOPE.BASIC, tr.BASIC),
            (typedefs.SCAN_SCOPE.NORMAL, tr.NORMAL),
            (typedefs.SCAN_SCOPE.FULL_RW, tr.RW),
            (typedefs.SCAN_SCOPE.FULL, tr.FULL),
        ]
        for scope, text in scan_scope_text:
            self.comboBox_ScanScope.addItem(text, scope)
        self.comboBox_ScanScope.setCurrentIndex(1)  # typedefs.SCAN_SCOPE.NORMAL
        self.comboBox_ScanScope.currentIndexChanged.connect(self.on_scan_regions_changed)

    def on_scan_regions_changed(self):
        search_scope = self.comboBox_ScanScope.currentData(Qt.ItemDataRole.UserRole)
        scanmem.send_command(f"option region_scan_level {search_scope}")
        scanmem.reset()

    def on_endianness_changed(self):
        endian = self.comboBox_Endianness.currentData(Qt.ItemDataRole.UserRole)
        scanmem.send_command(f"option endianness {endian}")

    def comboBox_ValueType_init(self):
        self.comboBox_ValueType.clear()
        for value_index, value_text in typedefs.scan_index_to_text_dict.items():
            self.comboBox_ValueType.addItem(value_text, value_index)
        self.comboBox_ValueType.setCurrentIndex(typedefs.SCAN_INDEX.INT32)
        self.comboBox_ValueType_current_index_changed()

    # adds things like 0x when searching for etc, basically just makes the line valid for scanmem
    # this should cover most things, more things might be added later if need be
    def validate_search(self, search_for: str, search_for2: str):
        type_index = self.comboBox_ScanType.currentData(Qt.ItemDataRole.UserRole)
        symbol_map = {
            typedefs.SCAN_TYPE.INCREASED: "+",
            typedefs.SCAN_TYPE.DECREASED: "-",
            typedefs.SCAN_TYPE.CHANGED: "!=",
            typedefs.SCAN_TYPE.UNCHANGED: "=",
            typedefs.SCAN_TYPE.UNKNOWN: "snapshot",
        }
        if type_index in symbol_map:
            return symbol_map[type_index]

        # Manually fix an edge case in number validators
        if search_for == "-":
            search_for = ""
        if search_for2 == "-":
            search_for2 = ""

        # none of these should be possible to be true at the same time
        scan_index = self.comboBox_ValueType.currentData(Qt.ItemDataRole.UserRole)
        if scan_index >= typedefs.SCAN_INDEX.FLOAT_ANY and scan_index <= typedefs.SCAN_INDEX.FLOAT64:
            # Manually fix an edge case in float_number validator
            if len(search_for) != 0 and search_for[-1] in {"e", "E"}:
                search_for += "0"
            if len(search_for2) != 0 and search_for2[-1] in {"e", "E"}:
                search_for2 += "0"
            # Adjust to locale whatever the input
            if QLocale.system().decimalPoint() == ".":
                search_for = search_for.replace(",", ".")
                search_for2 = search_for2.replace(",", ".")
            else:
                search_for = search_for.replace(".", ",")
                search_for2 = search_for2.replace(".", ",")
        elif scan_index == typedefs.SCAN_INDEX.STRING:
            search_for = '" ' + search_for
        elif self.checkBox_Hex.isChecked():
            if not search_for.startswith(("0x", "-0x")):
                negative_str = "-" if search_for.startswith("-") else ""
                search_for = negative_str + "0x" + search_for.lstrip("-")
            if not search_for2.startswith(("0x", "-0x")):
                negative_str = "-" if search_for.startswith("-") else ""
                search_for2 = negative_str + "0x" + search_for2.lstrip("-")

        if type_index == typedefs.SCAN_TYPE.BETWEEN:
            return search_for + ".." + search_for2
        cmp_symbols = {
            typedefs.SCAN_TYPE.INCREASED_BY: "+",
            typedefs.SCAN_TYPE.DECREASED_BY: "-",
            typedefs.SCAN_TYPE.LESS: "<",
            typedefs.SCAN_TYPE.MORE: ">",
        }
        if type_index in cmp_symbols:
            return cmp_symbols[type_index] + " " + search_for

        if type_index == typedefs.SCAN_TYPE.NOT:
            search_for = "!= " + search_for
        return search_for

    def pushButton_NextScan_clicked(self):
        self.scan_values()
        self.pushButton_UndoScan.setEnabled(True)

    def pushButton_ScanRegions_clicked(self):
        scan_regions_dialog = ManageScanRegionsDialog(self)
        if scan_regions_dialog.exec():
            self.deleted_regions.extend(scan_regions_dialog.get_values())

    def scan_callback(self):
        self.is_scanning = False
        self.progress_bar_timer.stop()
        self.progressBar.setValue(100)
        matches = scanmem.matches()
        self.update_match_count()
        self.tableWidget_valuesearchtable.setRowCount(0)
        current_type = self.comboBox_ValueType.currentData(Qt.ItemDataRole.UserRole)
        length = self._scan_to_length(current_type)
        mem_handle = debugcore.memory_handle()
        row = 0  # go back to using n when unknown issue gets fixed
        self.tableWidget_valuesearchtable.setSortingEnabled(False)
        for n, address, offset, region_type, val, result_type in matches:
            address = "0x" + address
            result = result_type.split(" ")[0]
            if result == "unknown":  # Ignore unknown entries for now
                continue
            value_index = typedefs.scanmem_result_to_index_dict[result]
            if self.checkBox_Hex.isChecked():
                value_repr = typedefs.VALUE_REPR.HEX
            elif typedefs.VALUE_INDEX.is_integer(value_index) and result.endswith("s"):
                value_repr = typedefs.VALUE_REPR.SIGNED
            else:
                value_repr = typedefs.VALUE_REPR.UNSIGNED
            endian = self.comboBox_Endianness.currentData(Qt.ItemDataRole.UserRole)
            current_item = QTableWidgetItem(address)
            current_item.setData(Qt.ItemDataRole.UserRole, (value_index, value_repr, endian))
            value = str(debugcore.read_memory(address, value_index, length, True, value_repr, endian, mem_handle))
            if debugcore.is_address_static(address):
                current_item.setForeground(QColor(0, 136, 85))
            self.tableWidget_valuesearchtable.insertRow(row)
            self.tableWidget_valuesearchtable.setItem(row, SEARCH_TABLE_ADDRESS_COL, current_item)
            self.tableWidget_valuesearchtable.setItem(row, SEARCH_TABLE_VALUE_COL, QTableWidgetItem(value))
            self.tableWidget_valuesearchtable.setItem(row, SEARCH_TABLE_PREVIOUS_COL, QTableWidgetItem(value))
            row += 1
            if row == 1000:
                break
        self.tableWidget_valuesearchtable.resizeColumnsToContents()
        self.tableWidget_valuesearchtable.setSortingEnabled(True)
        self.QWidget_Toolbox.setEnabled(True)

    def _scan_to_length(self, type_index):
        if type_index == typedefs.SCAN_INDEX.AOB:
            return self.lineEdit_Scan.text().count(" ") + 1
        if type_index == typedefs.SCAN_INDEX.STRING:
            return len(self.lineEdit_Scan.text())
        return 0

    def update_match_count(self):
        match_count = scanmem.get_match_count()
        if match_count > 1000:
            self.label_MatchCount.setText(tr.MATCH_COUNT_LIMITED.format(match_count, 1000))
        else:
            self.label_MatchCount.setText(tr.MATCH_COUNT.format(match_count))

    def tableWidget_valuesearchtable_cell_double_clicked(self, row, col):
        current_item = self.tableWidget_valuesearchtable.item(row, SEARCH_TABLE_ADDRESS_COL)
        value_index, value_repr, endian = current_item.data(Qt.ItemDataRole.UserRole)
        length = self._scan_to_length(self.comboBox_ValueType.currentData(Qt.ItemDataRole.UserRole))
        vt = typedefs.ValueType(value_index, length, True, value_repr, endian)
        self.add_entry_to_addresstable(tr.NO_DESCRIPTION, current_item.text(), vt)
        self.update_address_table()

    def tableWidget_valuesearchtable_key_press_event(self, event: QKeyEvent) -> None:
        current_item = self.tableWidget_valuesearchtable.currentItem()
        if debugcore.currentpid == -1 or not current_item:
            return
        current_address = self.tableWidget_valuesearchtable.item(current_item.row(), SEARCH_TABLE_ADDRESS_COL).text()
        actions = typedefs.KeyboardModifiersTupleDict(
            [
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_C),
                    self.copy_valuesearchtable_selection,
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_B),
                    lambda: self.browse_region_for_address(current_address),
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_D),
                    lambda: self.disassemble_for_address(current_address),
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_Delete),
                    self.delete_valuesearchtable_selection,
                ),
            ]
        )
        try:
            actions[QKeyCombination(event.modifiers(), Qt.Key(event.key()))]()
        except KeyError:
            self.tableWidget_valuesearchtable.keyPressEvent_original(event)

    def tableWidget_valuesearchtable_context_menu_event(self, event: QContextMenuEvent) -> None:
        selected_indexes = self.tableWidget_valuesearchtable.selectionModel().selectedRows()
        if debugcore.currentpid == -1 or not selected_indexes:
            return
        current_row = self.tableWidget_valuesearchtable.currentItem().row()
        address = self.tableWidget_valuesearchtable.item(current_row, SEARCH_TABLE_ADDRESS_COL).text()
        menu = QMenu()
        if len(selected_indexes) > 1:
            copy_selection = menu.addAction(f"{tr.COPY_ADDRESSES}[Ctrl+C]")
        else:
            copy_selection = menu.addAction(f"{tr.COPY_ADDRESS}[Ctrl+C]")
        menu.addSeparator()
        browse_region = menu.addAction(f"{tr.BROWSE_MEMORY_REGION}[Ctrl+B]")
        disassemble = menu.addAction(f"{tr.DISASSEMBLE_ADDRESS}[Ctrl+D]")
        menu.addSeparator()
        delete_selection = menu.addAction(f"{tr.DELETE_SELECTION}[Del]")
        font_size = self.tableWidget_valuesearchtable.font().pointSize()
        menu.setStyleSheet(f"font-size: {font_size}pt;")
        action = menu.exec(event.globalPos())
        actions = {
            copy_selection: self.copy_valuesearchtable_selection,
            browse_region: lambda: self.browse_region_for_address(address),
            disassemble: lambda: self.disassemble_for_address(address),
            delete_selection: self.delete_valuesearchtable_selection,
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def copy_valuesearchtable_selection(self):
        selected_indexes = self.tableWidget_valuesearchtable.selectionModel().selectedRows()
        address_list = []
        for index in selected_indexes:
            row = index.row()
            address = self.tableWidget_valuesearchtable.item(row, SEARCH_TABLE_ADDRESS_COL).text()
            address_list.append(address)
        app.clipboard().setText(" ".join(address_list))

    def delete_valuesearchtable_selection(self):
        selected_rows = self.tableWidget_valuesearchtable.selectedItems()
        if not selected_rows:
            return

        # get the row indexes
        rows = set()
        for item in selected_rows:
            rows.add(item.row())

        scanmem.send_command("delete {}".format(",".join([str(row) for row in rows])))

        # remove the rows from the table - removing in reverse sorted order to avoid index issues
        for row in sorted(rows, reverse=True):
            self.tableWidget_valuesearchtable.removeRow(row)
        self.update_match_count()

    def comboBox_ValueType_current_index_changed(self):
        current_type = self.comboBox_ValueType.currentData(Qt.ItemDataRole.UserRole)
        scanmem_type = typedefs.scan_index_to_scanmem_dict[current_type]
        validator_str = scanmem_type  # used to get the correct validator

        # TODO this can probably be made to look nicer, though it doesn't really matter
        if "int" in validator_str:
            validator_str = "int"
            self.checkBox_Hex.setEnabled(True)
            # keep hex validator if hex is checked
            if self.checkBox_Hex.isChecked():
                validator_str = "int_hex"
        else:
            self.checkBox_Hex.setChecked(False)
            self.checkBox_Hex.setEnabled(False)
        if "float" in validator_str or validator_str == "number":
            validator_str = "float"

        self.comboBox_ScanType_init()
        self.lineEdit_Scan.setValidator(guiutils.validator_map[validator_str])
        self.lineEdit_Scan2.setValidator(guiutils.validator_map[validator_str])
        scanmem.send_command("option scan_data_type {}".format(scanmem_type))
        # according to scanmem instructions you should always do `reset` after changing type
        scanmem.reset()

    def pushButton_AttachProcess_clicked(self):
        self.processwindow = ProcessForm(self)
        self.processwindow.show()

    def on_session_save(self):
        content = [
            self.read_address_table_recursively(self.treeWidget_AddressTable.topLevelItem(i))
            for i in range(self.treeWidget_AddressTable.topLevelItemCount())
        ]
        SessionManager.get_session().pct_address_tree = content

    def on_session_loaded(self):
        self.clear_address_table()
        self.insert_records(
            SessionManager.get_session().pct_address_tree,
            self.treeWidget_AddressTable.invisibleRootItem(),
            self.treeWidget_AddressTable.topLevelItemCount(),
        )

    def on_new_session(self):
        self.clear_address_table()

    # Returns: a bool value indicates whether the operation succeeded.
    def attach_to_pid(self, pid: int):
        if os.environ.get("APPDIR"):
            gdb_path = utils.get_default_gdb_path()
        else:
            gdb_path = states.gdb_path
        attach_result = debugcore.attach(pid, gdb_path)
        if attach_result == typedefs.ATTACH_RESULT.SUCCESSFUL:
            settings.apply_after_init()
            scanmem.pid(pid)
            ptrscan.set_process(pid)
            if debugcore.get_inferior_arch() == typedefs.INFERIOR_ARCH.ARCH_64:
                ptr_size = 8
            else:
                ptr_size = 4
            ptrscan.set_bitness(ptr_size)
            self.on_new_process()
            SessionManager.on_process_changed()
            states.process_signals.attach.emit()

            # TODO: This makes PINCE call on_process_stop twice when attaching
            # TODO: Signal design might have to change to something like mutexes eventually
            self.memory_view_window.on_process_stop()
            debugcore.continue_inferior()
            return True
        else:
            messages = {
                typedefs.ATTACH_RESULT.ATTACH_SELF: tr.SMARTASS,  # easter egg
                typedefs.ATTACH_RESULT.PROCESS_NOT_VALID: tr.PROCESS_NOT_VALID,
                typedefs.ATTACH_RESULT.ALREADY_DEBUGGING: tr.ALREADY_DEBUGGING,
                typedefs.ATTACH_RESULT.ALREADY_TRACED: tr.ALREADY_TRACED.format(utils.is_traced(pid)),
                typedefs.ATTACH_RESULT.PERM_DENIED: tr.PERM_DENIED,
            }
            QMessageBox.information(app.focusWidget(), tr.ERROR, messages[attach_result])
            return False

    # Returns: a bool value indicates whether the operation succeeded.
    def create_new_process(self, file_path, args, ld_preload_path):
        if debugcore.create_process(file_path, args, ld_preload_path):
            settings.apply_after_init()
            self.on_new_process()
            return True
        else:
            QMessageBox.information(app.focusWidget(), tr.ERROR, tr.CREATE_PROCESS_ERROR)
            self.on_inferior_exit()
            return False

    # Changes appearance whenever a new process is created or attached
    def on_new_process(self):
        name = utils.get_process_name(debugcore.currentpid)
        self.label_SelectedProcess.setText(str(debugcore.currentpid) + " - " + name)

        # enable scan GUI
        self.lineEdit_Scan.setPlaceholderText(tr.SCAN_FOR)
        self.QWidget_Toolbox.setEnabled(True)
        self.pushButton_NextScan.setEnabled(False)
        self.pushButton_UndoScan.setEnabled(False)
        self.pushButton_AddAddressManually.setEnabled(True)
        self.pushButton_MemoryView.setEnabled(True)

        # stop flashing attach button, timer will stop automatically on false value
        self.flashAttachButton = False

    def clear_address_table(self):
        if self.treeWidget_AddressTable.topLevelItemCount() == 0:
            return
        self.treeWidget_AddressTable.clear()

    def copy_to_address_table(self):
        i = -1
        length = self._scan_to_length(self.comboBox_ValueType.currentData(Qt.ItemDataRole.UserRole))
        for row in self.tableWidget_valuesearchtable.selectedItems():
            i = i + 1
            if i % 3 == 0:
                value_index, value_repr, endian = row.data(Qt.ItemDataRole.UserRole)
                vt = typedefs.ValueType(value_index, length, True, value_repr, endian)
                self.add_entry_to_addresstable(tr.NO_DESCRIPTION, row.text(), vt)
        self.update_address_table()
        self.session.data_changed |= SessionDataChanged.ADDRESS_TREE

    def reset_scan(self):
        self.scan_mode = typedefs.SCAN_MODE.NEW
        self.pushButton_NewFirstScan.setText(tr.FIRST_SCAN)
        scanmem.reset()
        self.deleted_regions.clear()
        self.tableWidget_valuesearchtable.setRowCount(0)
        self.comboBox_ValueType.setEnabled(True)
        self.comboBox_ScanScope.setEnabled(True)
        self.comboBox_Endianness.setEnabled(True)
        self.pushButton_NextScan.setEnabled(False)
        self.pushButton_UndoScan.setEnabled(False)
        self.progressBar.setValue(0)
        self.label_MatchCount.setText(tr.MATCH_COUNT.format(0))

    def on_inferior_exit(self):
        self.pushButton_MemoryView.setEnabled(False)
        self.pushButton_AddAddressManually.setEnabled(False)
        self.QWidget_Toolbox.setEnabled(False)
        self.lineEdit_Scan.setText("")
        self.reset_scan()
        self.on_status_running()
        self.flashAttachButton = True
        self.flashAttachButtonTimer.start(100)
        self.label_SelectedProcess.setText(tr.NO_PROCESS_SELECTED)
        self.memory_view_window.setWindowTitle(tr.NO_PROCESS_SELECTED)
        if os.environ.get("APPDIR"):
            gdb_path = utils.get_default_gdb_path()
        else:
            gdb_path = states.gdb_path
        debugcore.init_gdb(gdb_path)
        settings.apply_after_init()
        SessionManager.on_process_changed()
        states.process_signals.exit.emit()

    def on_status_detached(self):
        self.label_SelectedProcess.setStyleSheet("color: blue")
        self.label_InferiorStatus.setText(tr.STATUS_DETACHED)
        self.label_InferiorStatus.setVisible(True)
        self.label_InferiorStatus.setStyleSheet("color: blue")

    def on_status_stopped(self):
        self.label_SelectedProcess.setStyleSheet("color: red")
        self.label_InferiorStatus.setText(tr.STATUS_STOPPED)
        self.label_InferiorStatus.setVisible(True)
        self.label_InferiorStatus.setStyleSheet("color: red")

    def on_status_running(self):
        self.label_SelectedProcess.setStyleSheet("")
        self.label_InferiorStatus.setVisible(False)

    # closes all windows on exit
    def closeEvent(self, event: QCloseEvent):
        # you can no longer emit events at this point.
        SessionManager.get_session().pre_exit(event)
        if not event.isAccepted():
            # user cancelled the exit
            return

        debugcore.detach()
        app.closeAllWindows()
        logger.info("All PINCE windows closed")

    # Call update_address_table manually after this
    def add_entry_to_addresstable(self, description, address_expr, value_type=None):
        current_row = QTreeWidgetItem()
        current_row.setCheckState(FROZEN_COL, Qt.CheckState.Unchecked)
        frozen = typedefs.Frozen("", typedefs.FREEZE_TYPE.DEFAULT)
        current_row.setData(FROZEN_COL, Qt.ItemDataRole.UserRole, frozen)
        value_type = typedefs.ValueType() if not value_type else value_type
        self.treeWidget_AddressTable.addTopLevelItem(current_row)
        self.change_address_table_entries(current_row, description, address_expr, value_type)
        self.show()  # In case of getting called from elsewhere
        self.activateWindow()
        self.session.data_changed |= SessionDataChanged.ADDRESS_TREE

    def treeWidget_AddressTable_item_double_clicked(self, row, column):
        action_for_column = {
            VALUE_COL: self.treeWidget_AddressTable_edit_value,
            DESC_COL: self.treeWidget_AddressTable_edit_desc,
            ADDR_COL: self.treeWidget_AddressTable_edit_address,
            TYPE_COL: self.treeWidget_AddressTable_edit_type,
        }
        action_for_column = collections.defaultdict(lambda *args: lambda: None, action_for_column)
        action_for_column[column]()

    # ----------------------------------------------------
    # QTimer loops

    def update_progress_bar(self):
        value = int(round(scanmem.get_scan_progress() * 100))
        self.progressBar.setValue(value)

    # Loop restarts itself to wait for function execution, same for the functions below
    def address_table_loop(self):
        if states.update_table and not states.exiting:
            try:
                self.update_address_table()
            except:
                traceback.print_exc()
        self.address_table_timer.start(states.table_update_interval)

    def search_table_loop(self):
        if not states.exiting:
            try:
                self.update_search_table()
            except:
                traceback.print_exc()
        self.search_table_timer.start(500)

    def freeze_loop(self):
        if not states.exiting:
            try:
                self.freeze()
            except:
                traceback.print_exc()
        self.freeze_timer.start(states.freeze_interval)

    # ----------------------------------------------------

    def update_search_table(self):
        if debugcore.currentpid == -1:
            return
        row_count = self.tableWidget_valuesearchtable.rowCount()
        if row_count > 0:
            length = self._scan_to_length(self.comboBox_ValueType.currentData(Qt.ItemDataRole.UserRole))
            mem_handle = debugcore.memory_handle()
            for row_index in range(row_count):
                address_item = self.tableWidget_valuesearchtable.item(row_index, SEARCH_TABLE_ADDRESS_COL)
                value_item = self.tableWidget_valuesearchtable.item(row_index, SEARCH_TABLE_VALUE_COL)
                previous_text = self.tableWidget_valuesearchtable.item(row_index, SEARCH_TABLE_PREVIOUS_COL).text()
                value_index, value_repr, endian = address_item.data(Qt.ItemDataRole.UserRole)
                address = address_item.text()
                new_value = str(
                    debugcore.read_memory(
                        address, value_index, length, value_repr=value_repr, endian=endian, mem_handle=mem_handle
                    )
                )
                if new_value != previous_text:
                    value_item.setForeground(QBrush(QColor(255, 0, 0)))
                    value_item.setText(new_value)

    def freeze(self):
        if debugcore.currentpid == -1:
            return
        it = QTreeWidgetItemIterator(self.treeWidget_AddressTable)
        while True:
            row = it.value()
            if not row:
                break
            it += 1
            if row.checkState(FROZEN_COL) == Qt.CheckState.Checked:
                vt: typedefs.ValueType = row.data(TYPE_COL, Qt.ItemDataRole.UserRole)
                address = row.text(ADDR_COL).strip("P->")
                frozen: typedefs.Frozen = row.data(FROZEN_COL, Qt.ItemDataRole.UserRole)
                value = frozen.value
                freeze_type = frozen.freeze_type
                if typedefs.VALUE_INDEX.is_number(vt.value_index):
                    new_value = debugcore.read_memory(address, vt.value_index, endian=vt.endian)
                    if new_value == None:
                        continue
                    if (
                        freeze_type == typedefs.FREEZE_TYPE.ALLOW_INCREMENT
                        and new_value > value
                        or freeze_type == typedefs.FREEZE_TYPE.ALLOW_DECREMENT
                        and new_value < value
                    ):
                        frozen.value = new_value
                        debugcore.write_memory(address, vt.value_index, new_value, endian=vt.endian)
                        continue
                debugcore.write_memory(address, vt.value_index, value, vt.zero_terminate, vt.endian)

    def handle_freeze_change(self, row: QTreeWidgetItem, check_state: Qt.CheckState) -> None:
        frozen: typedefs.Frozen = row.data(FROZEN_COL, Qt.ItemDataRole.UserRole)
        is_checked = check_state == Qt.CheckState.Checked
        frozen_state_toggled = (is_checked and not frozen.enabled) or (not is_checked and frozen.enabled)
        row.setCheckState(FROZEN_COL, check_state)
        # this helps determine whether the user clicked checkbox or the text
        # if the user clicked the text, change the freeze type

        if frozen_state_toggled:
            if is_checked:
                frozen.enabled = True
                # reapply the freeze type, to reflect the current freeze type in the UI
                # otherwise the UI will show DEFAULT freeze type after enabling instead of the actual type
                self.change_freeze_type(frozen.freeze_type, row)
                vt: typedefs.ValueType = row.data(TYPE_COL, Qt.ItemDataRole.UserRole)
                frozen.value = utils.parse_string(row.text(VALUE_COL), vt.value_index)
            else:
                frozen.enabled = False  # it has just been toggled off
                self.change_freeze_type(typedefs.FREEZE_TYPE.DEFAULT, row)

    def treeWidget_AddressTable_change_repr(self, new_repr):
        value_type = guiutils.get_current_item(self.treeWidget_AddressTable).data(TYPE_COL, Qt.ItemDataRole.UserRole)
        value_type.value_repr = new_repr
        for row in self.treeWidget_AddressTable.selectedItems():
            row.setData(TYPE_COL, Qt.ItemDataRole.UserRole, value_type)
            row.setText(TYPE_COL, value_type.text())
        self.update_address_table()

    def treeWidget_AddressTable_edit_value(self):
        row = guiutils.get_current_item(self.treeWidget_AddressTable)
        if not row:
            return
        value = row.text(VALUE_COL)
        value_index = row.data(TYPE_COL, Qt.ItemDataRole.UserRole).value_index
        dialog = utilwidgets.InputDialog(self, [(tr.ENTER_VALUE, value)])
        if dialog.exec():
            new_value = dialog.get_values()[0]
            if utils.parse_string(new_value, value_index) == None:
                QMessageBox.information(self, tr.ERROR, tr.PARSE_ERROR)
                return
            for row in self.treeWidget_AddressTable.selectedItems():
                address = row.text(ADDR_COL).strip("P->")
                vt: typedefs.ValueType = row.data(TYPE_COL, Qt.ItemDataRole.UserRole)
                parsed_value = utils.parse_string(new_value, vt.value_index)
                if typedefs.VALUE_INDEX.has_length(vt.value_index) and parsed_value != None:
                    vt.length = len(parsed_value)
                    row.setText(TYPE_COL, vt.text())
                frozen: typedefs.Frozen = row.data(FROZEN_COL, Qt.ItemDataRole.UserRole)
                frozen.value = parsed_value
                debugcore.write_memory(address, vt.value_index, parsed_value, vt.zero_terminate, vt.endian)
            self.update_address_table()

    def treeWidget_AddressTable_edit_desc(self):
        row = guiutils.get_current_item(self.treeWidget_AddressTable)
        if not row:
            return
        description = row.text(DESC_COL)
        dialog = utilwidgets.InputDialog(self, [(tr.ENTER_DESCRIPTION, description)])
        if dialog.exec():
            description_text = dialog.get_values()[0]
            for row in self.treeWidget_AddressTable.selectedItems():
                row.setText(DESC_COL, description_text)

    def treeWidget_AddressTable_edit_address(self):
        row = guiutils.get_current_item(self.treeWidget_AddressTable)
        if not row:
            return
        desc, address_expr, vt = self.read_address_table_entries(row)
        manual_address_dialog = ManualAddressDialogForm(self, desc, address_expr, vt)
        manual_address_dialog.setWindowTitle(tr.EDIT_ADDRESS)
        if manual_address_dialog.exec():
            desc, address_expr, vt = manual_address_dialog.get_values()
            self.change_address_table_entries(row, desc, address_expr, vt)
            self.update_address_table()
            self.session.data_changed |= SessionDataChanged.ADDRESS_TREE

    def treeWidget_AddressTable_edit_type(self):
        row = guiutils.get_current_item(self.treeWidget_AddressTable)
        if not row:
            return
        vt = row.data(TYPE_COL, Qt.ItemDataRole.UserRole)
        dialog = EditTypeDialogForm(self, vt)
        if dialog.exec():
            vt = dialog.get_values()
            for row in self.treeWidget_AddressTable.selectedItems():
                row.setData(TYPE_COL, Qt.ItemDataRole.UserRole, vt)
                row.setText(TYPE_COL, vt.text())
            self.update_address_table()
            self.session.data_changed |= SessionDataChanged.ADDRESS_TREE

    # Changes the column values of the given row
    def change_address_table_entries(self, row, description=tr.NO_DESCRIPTION, address_expr="", vt=None):
        assert isinstance(row, QTreeWidgetItem)
        row.setText(DESC_COL, description)
        row.setData(ADDR_COL, Qt.ItemDataRole.UserRole, address_expr)
        if utils.extract_hex_address(address_expr) and debugcore.is_address_static(address_expr):
            row.setForeground(ADDR_COL, QColor(0, 136, 85))
        else:
            row.setForeground(ADDR_COL, self.palette().text().color())
        row.setData(TYPE_COL, Qt.ItemDataRole.UserRole, vt)
        row.setText(TYPE_COL, vt.text())

    # Returns the column values of the given row
    def read_address_table_entries(self, row, serialize=False):
        description = row.text(DESC_COL)
        if serialize:
            address_data = row.data(ADDR_COL, Qt.ItemDataRole.UserRole)
            if isinstance(address_data, typedefs.PointerChainRequest):
                address_expr = address_data.serialize()
            else:
                address_expr = address_data
            value_type = row.data(TYPE_COL, Qt.ItemDataRole.UserRole).serialize()
        else:
            address_expr = row.data(ADDR_COL, Qt.ItemDataRole.UserRole)
            value_type = row.data(TYPE_COL, Qt.ItemDataRole.UserRole)
        return description, address_expr, value_type

    # Returns the values inside the given row and all of its descendants.
    # All values except the last are the same as read_address_table_entries output.
    # Last value is an iterable of information about its direct children.
    def read_address_table_recursively(self, row):
        return self.read_address_table_entries(row, True) + (
            [self.read_address_table_recursively(row.child(i)) for i in range(row.childCount())],
        )

    # Flashing Attach Button when the process is not attached
    def flash_attach_button(self):
        if not self.flashAttachButton:
            self.flashAttachButtonTimer.stop()
            self.pushButton_AttachProcess.setStyleSheet("")
            return

        case = self.flashAttachButton_gradiantState % 32

        if case < 16:
            borderstring = "QPushButton {border: 3px solid rgba(0,255,0," + str(case / 16) + ");}"
        else:
            borderstring = "QPushButton {border: 3px solid rgba(0,255,0," + str((32 - case) / 16) + ");}"

        self.pushButton_AttachProcess.setStyleSheet(borderstring)
        self.flashAttachButton_gradiantState += 1
        if self.flashAttachButton_gradiantState > 768:  # 32*24
            self.flashAttachButton_gradiantState = 0


# process select window
class ProcessForm(QMainWindow, ProcessWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setupUi(self)
        self.refresh_process_table(self.tableWidget_ProcessTable, utils.get_process_list())
        self.pushButton_Close.clicked.connect(self.close)
        self.pushButton_Open.clicked.connect(self.pushButton_Open_clicked)
        self.pushButton_CreateProcess.clicked.connect(self.pushButton_CreateProcess_clicked)
        self.lineEdit_SearchProcess.textChanged.connect(self.generate_new_list)
        self.tableWidget_ProcessTable.itemDoubleClicked.connect(self.pushButton_Open_clicked)
        guiutils.center_to_parent(self)

    # refreshes process list
    def generate_new_list(self):
        text = self.lineEdit_SearchProcess.text()
        processlist = utils.search_processes(text)
        self.refresh_process_table(self.tableWidget_ProcessTable, processlist)

    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Escape:
            self.close()
        elif event.key() == Qt.Key.Key_Return or event.key() == Qt.Key.Key_Enter:
            self.pushButton_Open_clicked()
        elif event.key() == Qt.Key.Key_F1:
            self.pushButton_CreateProcess_clicked()
        else:
            return super().keyPressEvent(event)

    # lists currently working processes to table
    def refresh_process_table(self, tablewidget, processlist):
        tablewidget.setRowCount(0)
        for pid, user, name in processlist:
            current_row = tablewidget.rowCount()
            tablewidget.insertRow(current_row)
            tablewidget.setItem(current_row, 0, QTableWidgetItem(pid))
            tablewidget.setItem(current_row, 1, QTableWidgetItem(user))
            tablewidget.setItem(current_row, 2, QTableWidgetItem(name))

    # gets the pid out of the selection to attach
    def pushButton_Open_clicked(self):
        index = self.tableWidget_ProcessTable.currentIndex()
        row_count = self.tableWidget_ProcessTable.rowCount()
        if index.row() == -1 and row_count == 1:
            # autoselect first row if there is only one row
            self.tableWidget_ProcessTable.setCurrentCell(0, 0)

        current_item = self.tableWidget_ProcessTable.item(self.tableWidget_ProcessTable.currentIndex().row(), 0)
        if current_item is None:
            QMessageBox.information(self, tr.ERROR, tr.SELECT_PROCESS)
        else:
            pid = int(current_item.text())
            self.setCursor(QCursor(Qt.CursorShape.WaitCursor))
            if self.parent().attach_to_pid(pid):
                self.close()
            self.setCursor(QCursor(Qt.CursorShape.ArrowCursor))

    def pushButton_CreateProcess_clicked(self):
        file_path, _ = QFileDialog.getOpenFileName(self, tr.SELECT_BINARY)
        if file_path:
            arg_dialog = utilwidgets.InputDialog(self, [(tr.ENTER_OPTIONAL_ARGS, ""), (tr.LD_PRELOAD_OPTIONAL, "")])
            if arg_dialog.exec():
                args, ld_preload_path = arg_dialog.get_values()
            else:
                return
            self.setCursor(QCursor(Qt.CursorShape.WaitCursor))
            if self.parent().create_new_process(file_path, args, ld_preload_path):
                self.close()
            self.setCursor(QCursor(Qt.CursorShape.ArrowCursor))


# Add Address Manually Dialog
class ManualAddressDialogForm(QDialog, ManualAddressDialog):
    def __init__(self, parent, description=tr.NO_DESCRIPTION, address="0x", value_type=None):
        super().__init__(parent)
        self.setupUi(self)
        self.lineEdit_PtrStartAddress.setFixedWidth(180)
        self.lineEdit_Address.setFixedWidth(180)
        vt = typedefs.ValueType() if not value_type else value_type
        self.lineEdit_Length.setValidator(QHexValidator(99, self))
        guiutils.fill_value_combobox(self.comboBox_ValueType, vt.value_index)
        guiutils.fill_endianness_combobox(self.comboBox_Endianness, vt.endian)
        self.lineEdit_Description.setText(description)
        self.lineEdit_Description.setFixedWidth(180)
        self.offsetsList: list[PointerChainOffset] = []
        if not isinstance(address, typedefs.PointerChainRequest):
            self.lineEdit_Address.setText(address)
            self.widget_Pointer.hide()
        else:
            self.checkBox_IsPointer.setChecked(True)
            self.lineEdit_Address.setReadOnly(True)
            self.lineEdit_PtrStartAddress.setText(address.get_base_address_as_str())
            self.create_offsets_list(address)
            self.widget_Pointer.show()
        if typedefs.VALUE_INDEX.is_string(self.comboBox_ValueType.currentIndex()):
            self.widget_Length.show()
            try:
                length = str(vt.length)
            except:
                length = "10"
            self.lineEdit_Length.setText(length)
            self.checkBox_ZeroTerminate.show()
            self.checkBox_ZeroTerminate.setChecked(vt.zero_terminate)
        elif self.comboBox_ValueType.currentIndex() == typedefs.VALUE_INDEX.AOB:
            self.widget_Length.show()
            try:
                length = str(vt.length)
            except:
                length = "10"
            self.lineEdit_Length.setText(length)
            self.checkBox_ZeroTerminate.hide()
        else:
            self.widget_Length.hide()
        if vt.value_repr == typedefs.VALUE_REPR.HEX:
            self.checkBox_Hex.setChecked(True)
            self.checkBox_Signed.setEnabled(False)
        elif vt.value_repr == typedefs.VALUE_REPR.SIGNED:
            self.checkBox_Signed.setChecked(True)
        else:
            self.checkBox_Signed.setChecked(False)
        self.comboBox_ValueType.currentIndexChanged.connect(self.comboBox_ValueType_current_index_changed)
        self.comboBox_Endianness.currentIndexChanged.connect(self.update_value)
        self.lineEdit_Length.textChanged.connect(self.update_value)
        self.checkBox_Hex.stateChanged.connect(self.repr_changed)
        self.checkBox_Signed.stateChanged.connect(self.repr_changed)
        self.checkBox_ZeroTerminate.stateChanged.connect(self.update_value)
        self.checkBox_IsPointer.stateChanged.connect(self.checkBox_IsPointer_state_changed)
        self.lineEdit_PtrStartAddress.textChanged.connect(self.update_value)
        self.lineEdit_Address.textChanged.connect(self.update_value)
        self.pushButton_AddOffset.clicked.connect(lambda: self.addOffsetLayout(True))
        self.pushButton_RemoveOffset.clicked.connect(self.removeOffsetLayout)
        self.label_Value.contextMenuEvent = self.label_Value_context_menu_event
        self.update_value()
        guiutils.center_to_parent(self)

    def label_Value_context_menu_event(self, event):
        menu = QMenu()
        refresh = menu.addAction(tr.REFRESH)
        font_size = self.label_Value.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {refresh: self.update_value}
        try:
            actions[action]()
        except KeyError:
            pass

    def addOffsetLayout(self, should_update=True):
        offsetFrame = PointerChainOffset(len(self.offsetsList), self.widget_Pointer)
        self.offsetsList.append(offsetFrame)
        self.verticalLayout_Pointers.insertWidget(0, self.offsetsList[-1])
        offsetFrame.offset_changed_signal.connect(self.update_value)
        if should_update:
            self.update_value()

    def removeOffsetLayout(self):
        if len(self.offsetsList) == 1:
            return
        frame = self.offsetsList[-1]
        frame.deleteLater()
        self.verticalLayout_Pointers.removeWidget(frame)
        del self.offsetsList[-1]
        self.update_value()

    def update_deref_labels(self, pointer_chain_result: typedefs.PointerChainResult):
        if pointer_chain_result != None:
            base_deref = self.caps_hex_or_error_indicator(pointer_chain_result.pointer_chain[0])
            self.label_BaseAddressDeref.setText(f" → {base_deref}")
            for index, offsetFrame in enumerate(self.offsetsList):
                if index + 1 >= len(pointer_chain_result.pointer_chain):
                    offsetFrame.update_deref_label("<font color=red>??</font>")
                    continue
                previousDerefText = self.caps_hex_or_error_indicator(pointer_chain_result.pointer_chain[index])
                currentDerefText = self.caps_hex_or_error_indicator(pointer_chain_result.pointer_chain[index + 1])
                offsetText = utils.upper_hex(offsetFrame.offsetText.text())
                operationalSign = "" if offsetText.startswith("-") else "+"
                calculation = f"{previousDerefText} {operationalSign} {offsetText}"
                if index + 1 != len(pointer_chain_result.pointer_chain) - 1:
                    offsetFrame.update_deref_label(f" [{calculation}] → {currentDerefText}")
                else:
                    offsetFrame.update_deref_label(f" {calculation} = {currentDerefText}")
        else:
            self.label_BaseAddressDeref.setText(" → <font color=red>??</font>")
            for offsetFrame in self.offsetsList:
                offsetFrame.update_deref_label("<font color=red>??</font>")

    def caps_hex_or_error_indicator(self, address: int):
        if address == 0:
            return "<font color=red>??</font>"
        return utils.upper_hex(hex(address))

    def update_value(self):
        if self.checkBox_IsPointer.isChecked():
            hex_converted_expr = debugcore.convert_to_hex(self.lineEdit_PtrStartAddress.text())
            pointer_chain_req = typedefs.PointerChainRequest(hex_converted_expr, self.get_offsets_int_list())
            pointer_chain_result = debugcore.read_pointer_chain(pointer_chain_req)
            address = None
            if pointer_chain_result != None and pointer_chain_result.get_final_address() not in {0, None}:
                address_text = pointer_chain_result.get_final_address_as_hex()
                address = pointer_chain_result.get_final_address()
            else:
                address_text = "??"
            self.lineEdit_Address.setText(address_text)
            self.update_deref_labels(pointer_chain_result)
        else:
            hex_converted_expr = debugcore.convert_to_hex(self.lineEdit_Address.text())
            address = debugcore.examine_expression(hex_converted_expr).address
        if self.checkBox_Hex.isChecked():
            value_repr = typedefs.VALUE_REPR.HEX
        elif self.checkBox_Signed.isChecked():
            value_repr = typedefs.VALUE_REPR.SIGNED
        else:
            value_repr = typedefs.VALUE_REPR.UNSIGNED
        address_type = self.comboBox_ValueType.currentIndex()
        length = self.lineEdit_Length.text()
        zero_terminate = self.checkBox_ZeroTerminate.isChecked()
        endian = self.comboBox_Endianness.currentData(Qt.ItemDataRole.UserRole)
        value = debugcore.read_memory(address, address_type, length, zero_terminate, value_repr, endian)
        self.label_Value.setText("<font color=red>??</font>" if value is None else str(value))
        old_width = self.width()
        app.processEvents()
        self.adjustSize()
        self.resize(old_width, self.minimumHeight())

    def comboBox_ValueType_current_index_changed(self):
        if typedefs.VALUE_INDEX.is_string(self.comboBox_ValueType.currentIndex()):
            self.widget_Length.show()
            self.checkBox_ZeroTerminate.show()
        elif self.comboBox_ValueType.currentIndex() == typedefs.VALUE_INDEX.AOB:
            self.widget_Length.show()
            self.checkBox_ZeroTerminate.hide()
        else:
            self.widget_Length.hide()
        self.update_value()

    def repr_changed(self):
        if self.checkBox_Hex.isChecked():
            self.checkBox_Signed.setEnabled(False)
        else:
            self.checkBox_Signed.setEnabled(True)
        self.update_value()

    def checkBox_IsPointer_state_changed(self):
        if self.checkBox_IsPointer.isChecked():
            self.lineEdit_Address.setReadOnly(True)
            self.lineEdit_PtrStartAddress.setText(self.lineEdit_Address.text())
            if len(self.offsetsList) == 0:
                self.addOffsetLayout(False)
            self.widget_Pointer.show()
        else:
            self.lineEdit_Address.setText(self.lineEdit_PtrStartAddress.text())
            self.lineEdit_PtrStartAddress.setText("")
            self.lineEdit_Address.setReadOnly(False)
            self.widget_Pointer.hide()
        self.update_value()

    def reject(self):
        super().reject()

    def accept(self):
        if self.label_Length.isVisible():
            length = self.lineEdit_Length.text()
            try:
                length = int(length, 0)
            except:
                QMessageBox.information(self, tr.ERROR, tr.LENGTH_NOT_VALID)
                return
            if not length > 0:
                QMessageBox.information(self, tr.ERROR, tr.LENGTH_GT)
                return
        super().accept()

    def get_values(self):
        description = self.lineEdit_Description.text()
        length = self.lineEdit_Length.text()
        length = safe_str_to_int(length, 0)
        zero_terminate = self.checkBox_ZeroTerminate.isChecked()
        value_index = self.comboBox_ValueType.currentIndex()
        if self.checkBox_Hex.isChecked():
            value_repr = typedefs.VALUE_REPR.HEX
        elif self.checkBox_Signed.isChecked():
            value_repr = typedefs.VALUE_REPR.SIGNED
        else:
            value_repr = typedefs.VALUE_REPR.UNSIGNED
        endian = self.comboBox_Endianness.currentData(Qt.ItemDataRole.UserRole)
        vt = typedefs.ValueType(value_index, length, zero_terminate, value_repr, endian)
        if self.checkBox_IsPointer.isChecked():
            base_expression = debugcore.convert_to_hex(self.lineEdit_PtrStartAddress.text())
            address = typedefs.PointerChainRequest(base_expression, self.get_offsets_int_list())
        else:
            address = debugcore.convert_to_hex(self.lineEdit_Address.text())
        return description, address, vt

    def get_offsets_int_list(self):
        offsetsIntList = []
        for frame in self.offsetsList:
            offsetText = frame.layout().itemAt(1).widget().text()
            try:
                offsetValue = int(offsetText, 16)
            except ValueError:
                break
            offsetsIntList.append(offsetValue)
        return offsetsIntList

    def create_offsets_list(self, pointer_chain_req: typedefs.PointerChainRequest):
        if not isinstance(pointer_chain_req, typedefs.PointerChainRequest):
            raise TypeError("Passed non-PointerChainRequest type to create_offsets_list!")

        for offset in pointer_chain_req.offsets_list:
            self.addOffsetLayout(False)
            frame = self.offsetsList[-1]
            frame.layout().itemAt(1).widget().setText(hex(offset))

    def get_type_size(self):
        return typedefs.index_to_valuetype_dict[self.comboBox_ValueType.currentIndex()][0]


class EditTypeDialogForm(QDialog, EditTypeDialog):
    def __init__(self, parent, value_type=None):
        super().__init__(parent)
        self.setupUi(self)
        vt = typedefs.ValueType() if not value_type else value_type
        self.lineEdit_Length.setValidator(QHexValidator(99, self))
        self.lineEdit_Length.setFixedWidth(40)
        guiutils.fill_value_combobox(self.comboBox_ValueType, vt.value_index)
        guiutils.fill_endianness_combobox(self.comboBox_Endianness, vt.endian)
        if typedefs.VALUE_INDEX.is_string(self.comboBox_ValueType.currentIndex()):
            self.widget_Length.show()
            try:
                length = str(vt.length)
            except:
                length = "10"
            self.lineEdit_Length.setText(length)
            self.checkBox_ZeroTerminate.show()
            self.checkBox_ZeroTerminate.setChecked(vt.zero_terminate)
        elif self.comboBox_ValueType.currentIndex() == typedefs.VALUE_INDEX.AOB:
            self.widget_Length.show()
            try:
                length = str(vt.length)
            except:
                length = "10"
            self.lineEdit_Length.setText(length)
            self.checkBox_ZeroTerminate.hide()
        else:
            self.widget_Length.hide()
        if vt.value_repr == typedefs.VALUE_REPR.HEX:
            self.checkBox_Hex.setChecked(True)
            self.checkBox_Signed.setEnabled(False)
        elif vt.value_repr == typedefs.VALUE_REPR.SIGNED:
            self.checkBox_Signed.setChecked(True)
        else:
            self.checkBox_Signed.setChecked(False)
        self.comboBox_ValueType.currentIndexChanged.connect(self.comboBox_ValueType_current_index_changed)
        self.checkBox_Hex.stateChanged.connect(self.repr_changed)
        app.processEvents()
        self.adjustSize()
        guiutils.center_to_parent(self)

    def comboBox_ValueType_current_index_changed(self):
        if typedefs.VALUE_INDEX.is_string(self.comboBox_ValueType.currentIndex()):
            self.widget_Length.show()
            self.checkBox_ZeroTerminate.show()
        elif self.comboBox_ValueType.currentIndex() == typedefs.VALUE_INDEX.AOB:
            self.widget_Length.show()
            self.checkBox_ZeroTerminate.hide()
        else:
            self.widget_Length.hide()
        app.processEvents()
        self.adjustSize()

    def repr_changed(self):
        if self.checkBox_Hex.isChecked():
            self.checkBox_Signed.setEnabled(False)
        else:
            self.checkBox_Signed.setEnabled(True)

    def reject(self):
        super().reject()

    def accept(self):
        if self.label_Length.isVisible():
            length = self.lineEdit_Length.text()
            try:
                length = int(length, 0)
            except:
                QMessageBox.information(self, tr.ERROR, tr.LENGTH_NOT_VALID)
                return
            if not length > 0:
                QMessageBox.information(self, tr.ERROR, tr.LENGTH_GT)
                return
        super().accept()

    def get_values(self):
        value_index = self.comboBox_ValueType.currentIndex()
        length = self.lineEdit_Length.text()
        length = safe_str_to_int(length, 0)
        zero_terminate = self.checkBox_ZeroTerminate.isChecked()
        if self.checkBox_Hex.isChecked():
            value_repr = typedefs.VALUE_REPR.HEX
        elif self.checkBox_Signed.isChecked():
            value_repr = typedefs.VALUE_REPR.SIGNED
        else:
            value_repr = typedefs.VALUE_REPR.UNSIGNED
        endian = self.comboBox_Endianness.currentData(Qt.ItemDataRole.UserRole)
        return typedefs.ValueType(value_index, length, zero_terminate, value_repr, endian)


class TrackSelectorDialogForm(QDialog, TrackSelectorDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.selection = None
        self.pushButton_Pointer.clicked.connect(lambda: self.change_selection("pointer"))
        self.pushButton_Pointed.clicked.connect(lambda: self.change_selection("pointed"))
        guiutils.center_to_parent(self)

    def change_selection(self, selection):
        self.selection = selection
        self.close()


class LoadingDialogForm(QDialog, LoadingDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(self.windowFlags())
        self.keyPressEvent = QEvent.ignore

        # Make use of this background_thread when you spawn a LoadingDialogForm
        # Warning: overrided_func() can only return one value, so if your overridden function returns more than one
        # value, refactor your overriden function to return only one object(convert tuple to list etc.)
        # Check refresh_table method of FunctionsInfoWidgetForm for exemplary usage
        self.background_thread = self.BackgroundThread()
        self.background_thread.output_ready.connect(self.accept)
        self.pushButton_Cancel.clicked.connect(self.close)
        media_directory = utils.get_media_directory()
        self.movie = QMovie(media_directory + "/LoadingDialog/ajax-loader.gif", QByteArray())
        self.label_Animated.setMovie(self.movie)
        self.movie.setScaledSize(QSize(25, 25))
        self.movie.setCacheMode(QMovie.CacheMode.CacheAll)
        self.movie.setSpeed(100)
        self.movie.start()
        guiutils.center_to_parent(self)

    # TODO: This function only cancels the last command sent, redesign this if it's needed to cancel non-gdb functions
    def cancel_thread(self):
        debugcore.cancel_ongoing_command()
        self.background_thread.wait()

    def exec(self):
        self.background_thread.start()
        super().exec()

    def closeEvent(self, event: QCloseEvent):
        self.cancel_thread()
        super().closeEvent(event)

    class BackgroundThread(QThread):
        output_ready = pyqtSignal(object)

        def __init__(self):
            super().__init__()

        # Unhandled exceptions in this thread freezes PINCE
        def run(self):
            try:
                output = self.overrided_func()
            except:
                traceback.print_exc()
                output = None
            self.output_ready.emit(output)

        def overrided_func(self):
            logger.debug("Override this function")
            return 0


class TextEditDialogForm(QDialog, TextEditDialog):
    def __init__(self, parent, text=""):
        super().__init__(parent)
        self.setupUi(self)
        self.textEdit.setPlainText(str(text))
        self.accept_shortcut = QShortcut(QKeySequence("Ctrl+Return"), self)
        self.accept_shortcut.activated.connect(self.accept)
        guiutils.center_to_parent(self)

    def get_values(self):
        return self.textEdit.toPlainText()

    def keyPressEvent(self, QKeyEvent):
        if QKeyEvent.key() == Qt.Key.Key_Enter:
            pass
        else:
            super().keyPressEvent(QKeyEvent)


class ConsoleWidgetForm(QWidget, ConsoleWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.completion_model = QStringListModel()
        self.completer = QCompleter()
        self.completer.setModel(self.completion_model)
        self.completer.setCompletionMode(QCompleter.CompletionMode.UnfilteredPopupCompletion)
        self.completer.setMaxVisibleItems(8)
        self.lineEdit.setCompleter(self.completer)
        self.quit_commands = ("q", "quit", "-gdb-exit")
        self.continue_commands = ("c", "continue", "-exec-continue")
        self.input_history = [""]
        self.current_history_index = -1
        self.await_async_output_thread = guitypedefs.AwaitAsyncOutput()
        self.await_async_output_thread.async_output_ready.connect(self.on_async_output)
        self.await_async_output_thread.start()
        self.pushButton_Send.clicked.connect(self.communicate)
        self.shortcut_send = QShortcut(QKeySequence("Return"), self)
        self.shortcut_send.activated.connect(self.communicate)
        self.shortcut_complete_command = QShortcut(QKeySequence("Tab"), self)
        self.shortcut_complete_command.activated.connect(self.complete_command)
        self.shortcut_multiline_mode = QShortcut(QKeySequence("Ctrl+Return"), self)
        self.shortcut_multiline_mode.activated.connect(self.enter_multiline_mode)
        self.lineEdit.textEdited.connect(self.finish_completion)

        # Saving the original function because super() doesn't work when we override functions like this
        self.lineEdit.keyPressEvent_original = self.lineEdit.keyPressEvent
        self.lineEdit.keyPressEvent = self.lineEdit_key_press_event
        self.reset_console_text()
        guiutils.center_to_parent(self)

    def communicate(self):
        self.current_history_index = -1
        self.input_history[-1] = ""
        console_input = self.lineEdit.text()
        last_input = self.input_history[-2] if len(self.input_history) > 1 else ""
        if console_input != last_input and console_input != "":
            self.input_history[-1] = console_input
            self.input_history.append("")
        if console_input.lower() == "/clear":
            self.lineEdit.clear()
            self.reset_console_text()
            return
        self.lineEdit.clear()
        if console_input.strip().lower() in self.quit_commands:
            console_output = tr.QUIT_SESSION_CRASH
        if console_input.strip().lower() in self.continue_commands:
            console_output = tr.CONT_SESSION_CRASH
        else:
            if self.radioButton_CLI.isChecked():
                console_output = debugcore.send_command(console_input, cli_output=True)
            else:
                console_output = debugcore.send_command(console_input)
        self.textBrowser.append("-->" + console_input)
        if console_output:
            self.textBrowser.append(console_output)
        self.scroll_to_bottom()

    def reset_console_text(self):
        self.textBrowser.clear()
        self.textBrowser.append(tr.GDB_CONSOLE_INIT)

    def scroll_to_bottom(self):
        cursor = self.textBrowser.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.End)
        self.textBrowser.setTextCursor(cursor)
        self.textBrowser.ensureCursorVisible()

    def enter_multiline_mode(self):
        multiline_dialog = TextEditDialogForm(self, self.lineEdit.text())
        if multiline_dialog.exec():
            self.lineEdit.setText(multiline_dialog.get_values())
            self.communicate()

    def on_async_output(self, async_output):
        self.textBrowser.append(async_output)
        self.scroll_to_bottom()

    def scroll_backwards_history(self):
        try:
            new_text = self.input_history[self.current_history_index - 1]
        except IndexError:
            return
        self.input_history[self.current_history_index] = self.lineEdit.text()
        self.current_history_index -= 1
        self.lineEdit.setText(new_text)

    def scroll_forwards_history(self):
        if self.current_history_index == -1:
            return
        self.input_history[self.current_history_index] = self.lineEdit.text()
        self.current_history_index += 1
        self.lineEdit.setText(self.input_history[self.current_history_index])

    def lineEdit_key_press_event(self, event):
        actions = typedefs.KeyboardModifiersTupleDict(
            [
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_Up), self.scroll_backwards_history),
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_Down), self.scroll_forwards_history),
            ]
        )
        try:
            actions[QKeyCombination(event.modifiers(), Qt.Key(event.key()))]()
        except KeyError:
            self.lineEdit.keyPressEvent_original(event)

    def finish_completion(self):
        self.completion_model.setStringList([])

    def complete_command(self):
        if debugcore.gdb_initialized and debugcore.currentpid != -1 and self.lineEdit.text():
            self.completion_model.setStringList(debugcore.complete_command(self.lineEdit.text()))
            self.completer.complete()
        else:
            self.finish_completion()

    def closeEvent(self, event):
        self.await_async_output_thread.stop()


class AboutWidgetForm(QTabWidget, AboutWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)

        # This section has untranslated text since it's just a placeholder
        pince_dir = utils.get_script_directory()
        license_text = open(f"{pince_dir}/COPYING").read()
        authors_text = open(f"{pince_dir}/AUTHORS").read()
        thanks_text = open(f"{pince_dir}/THANKS").read()
        self.textBrowser_License.setPlainText(license_text)
        self.textBrowser_Contributors.append(
            "This is only a placeholder, this section may look different when the project finishes"
            + "\nIn fact, something like a demo-scene for here would look absolutely fabulous <:"
        )
        self.textBrowser_Contributors.append("\n########")
        self.textBrowser_Contributors.append("#AUTHORS#")
        self.textBrowser_Contributors.append("########\n")
        self.textBrowser_Contributors.append(authors_text)
        self.textBrowser_Contributors.append("\n#######")
        self.textBrowser_Contributors.append("#THANKS#")
        self.textBrowser_Contributors.append("#######\n")
        self.textBrowser_Contributors.append(thanks_text)
        guiutils.center_to_parent(self)


class MemoryViewWindowForm(QMainWindow, MemoryViewWindow):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.updating_memoryview = False
        self.stack_from_base_pointer = False
        self.stacktrace_info_widget = StackTraceInfoWidgetForm(self)
        self.float_registers_widget = FloatRegisterWidgetForm(self)
        states.status_thread.process_stopped.connect(self.on_process_stop)
        states.status_thread.process_running.connect(self.on_process_running)
        states.setting_signals.changed.connect(self.set_dynamic_debug_hotkeys)
        states.session_signals.new_session.connect(self.on_new_session)
        self.session = SessionManager.get_session()
        self.set_debug_menu_shortcuts()
        self.set_dynamic_debug_hotkeys()
        self.initialize_file_context_menu()
        self.initialize_view_context_menu()
        self.initialize_debug_context_menu()
        self.initialize_tools_context_menu()
        self.initialize_help_context_menu()
        self.initialize_disassemble_view()
        self.initialize_register_view()
        self.initialize_stack_view()
        self.initialize_hex_view()

        self.label_HexView_Information.contextMenuEvent = self.label_HexView_Information_context_menu_event

        self.splitter_Disassemble_Registers.setStretchFactor(0, 1)
        self.splitter_MainMiddle.setStretchFactor(1, 1)
        self.widget_StackView.resize(660, self.widget_StackView.height())
        self.widget_Registers.resize(330, self.widget_Registers.height())
        guiutils.center(self)

    def set_dynamic_debug_hotkeys(self):
        self.actionBreak.setText(tr.BREAK.format(states.hotkeys.break_hotkey.get_active_key()))
        self.actionRun.setText(tr.RUN.format(states.hotkeys.continue_hotkey.get_active_key()))
        self.actionToggle_Attach.setText(tr.TOGGLE_ATTACH.format(states.hotkeys.toggle_attach_hotkey.get_active_key()))

    def set_debug_menu_shortcuts(self):
        self.shortcut_step = QShortcut(QKeySequence("F7"), self)
        self.shortcut_step.activated.connect(self.step_instruction)
        self.shortcut_step_over = QShortcut(QKeySequence("F8"), self)
        self.shortcut_step_over.activated.connect(self.step_over_instruction)
        self.shortcut_execute_till_return = QShortcut(QKeySequence("Shift+F8"), self)
        self.shortcut_execute_till_return.activated.connect(self.execute_till_return)
        self.shortcut_toggle_breakpoint = QShortcut(QKeySequence("F5"), self)
        self.shortcut_toggle_breakpoint.activated.connect(self.toggle_breakpoint)
        self.shortcut_set_address = QShortcut(QKeySequence("Shift+F4"), self)
        self.shortcut_set_address.activated.connect(self.set_address)

    def initialize_file_context_menu(self):
        self.actionLoad_Trace.triggered.connect(self.show_trace_window)

    def initialize_debug_context_menu(self):
        self.actionBreak.triggered.connect(debugcore.interrupt_inferior)
        self.actionRun.triggered.connect(debugcore.continue_inferior)
        self.actionToggle_Attach.triggered.connect(lambda: self.parent().toggle_attach_hotkey_pressed())
        self.actionStep.triggered.connect(self.step_instruction)
        self.actionStep_Over.triggered.connect(self.step_over_instruction)
        self.actionExecute_Till_Return.triggered.connect(self.execute_till_return)

        # Ignore the "checked" bool param as we don't make use of it
        self.actionToggle_Breakpoint.triggered.connect(lambda checked: self.toggle_breakpoint())
        self.actionSet_Address.triggered.connect(self.set_address)

    def initialize_view_context_menu(self):
        self.actionBookmarks.triggered.connect(self.actionBookmarks_triggered)
        self.actionStackTrace_Info.triggered.connect(self.actionStackTrace_Info_triggered)
        self.actionBreakpoints.triggered.connect(self.actionBreakpoints_triggered)
        self.actionFunctions.triggered.connect(self.actionFunctions_triggered)
        self.actionGDB_Log_File.triggered.connect(self.actionGDB_Log_File_triggered)
        self.actionMemory_Regions.triggered.connect(self.actionMemory_Regions_triggered)
        self.actionRestore_Instructions.triggered.connect(self.actionRestore_Instructions_triggered)
        self.actionReferenced_Strings.triggered.connect(self.actionReferenced_Strings_triggered)
        self.actionReferenced_Calls.triggered.connect(self.actionReferenced_Calls_triggered)

    def initialize_tools_context_menu(self):
        self.actionInject_so_file.triggered.connect(self.actionInject_so_file_triggered)
        self.actionCall_Function.triggered.connect(self.actionCall_Function_triggered)
        self.actionSearch_Opcode.triggered.connect(self.actionSearch_Opcode_triggered)
        self.actionDissect_Code.triggered.connect(self.actionDissect_Code_triggered)
        self.actionLibpince_Engine.triggered.connect(self.actionLibpince_Engine_triggered)

    def initialize_help_context_menu(self):
        self.actionLibpince.triggered.connect(self.actionLibpince_triggered)

    def initialize_register_view(self):
        self.pushButton_ShowFloatRegisters.clicked.connect(self.pushButton_ShowFloatRegisters_clicked)
        if guiutils.check_inferior_running(self, show_message=False):
            self.pushButton_ShowFloatRegisters.setEnabled(False)

    def initialize_stack_view(self):
        self.stackedWidget_StackScreens.setCurrentWidget(self.StackTrace)
        self.tableWidget_StackTrace.setColumnWidth(STACKTRACE_RETURN_ADDRESS_COL, 350)

        self.tableWidget_Stack.contextMenuEvent = self.tableWidget_Stack_context_menu_event
        self.tableWidget_StackTrace.contextMenuEvent = self.tableWidget_StackTrace_context_menu_event
        self.tableWidget_Stack.itemDoubleClicked.connect(self.tableWidget_Stack_double_click)
        self.tableWidget_StackTrace.itemDoubleClicked.connect(self.tableWidget_StackTrace_double_click)

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableWidget_Stack.keyPressEvent_original = self.tableWidget_Stack.keyPressEvent
        self.tableWidget_Stack.keyPressEvent = self.tableWidget_Stack_key_press_event

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableWidget_StackTrace.keyPressEvent_original = self.tableWidget_StackTrace.keyPressEvent
        self.tableWidget_StackTrace.keyPressEvent = self.tableWidget_StackTrace_key_press_event

    def initialize_disassemble_view(self):
        self.tableWidget_Disassemble.setColumnWidth(DISAS_ADDR_COL, 300)
        self.tableWidget_Disassemble.setColumnWidth(DISAS_BYTES_COL, 150)
        self.tableWidget_Disassemble.setColumnWidth(DISAS_OPCODES_COL, 400)

        self.disassemble_last_selected_address_int = 0
        self.disassemble_currently_displayed_address = "0"
        self.widget_Disassemble.wheelEvent = self.widget_Disassemble_wheel_event

        self.bDisassemblyScrolling = False  # rejects new scroll requests while scrolling
        self.tableWidget_Disassemble_wheelEvent_original = self.tableWidget_Disassemble.wheelEvent
        self.tableWidget_Disassemble.wheelEvent = QEvent.ignore
        self.verticalScrollBar_Disassemble.wheelEvent = QEvent.ignore
        self.verticalScrollBar_Disassemble.sliderChange = self.disassemble_scrollbar_sliderchanged
        guiutils.center_scroll_bar(self.verticalScrollBar_Disassemble)

        # Format: [address1, address2, ...]
        self.tableWidget_Disassemble.travel_history = []

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableWidget_Disassemble.keyPressEvent_original = self.tableWidget_Disassemble.keyPressEvent
        self.tableWidget_Disassemble.keyPressEvent = self.tableWidget_Disassemble_key_press_event
        self.tableWidget_Disassemble.contextMenuEvent = self.tableWidget_Disassemble_context_menu_event

        self.tableWidget_Disassemble.itemDoubleClicked.connect(self.tableWidget_Disassemble_item_double_clicked)
        self.tableWidget_Disassemble.itemSelectionChanged.connect(self.tableWidget_Disassemble_item_selection_changed)

    def initialize_hex_view(self):
        # Determines where selection starts and ends
        self.hex_selection_start = 0
        self.hex_selection_end = 0
        # Actual start and end addresses of the selection
        self.hex_selection_address_begin = 0
        self.hex_selection_address_end = 0
        self.hex_view_current_region = typedefs.tuple_region_info(0, 0, None, None, None)
        self.hex_model = QHexModel(HEX_VIEW_ROW_COUNT, HEX_VIEW_COL_COUNT)
        self.ascii_model = QAsciiModel(HEX_VIEW_ROW_COUNT, HEX_VIEW_COL_COUNT)
        self.tableView_HexView_Hex.setModel(self.hex_model)
        self.tableView_HexView_Ascii.setModel(self.ascii_model)
        # Adjust cell sizes after setting model to ensure correct size
        self.tableView_HexView_Hex.adjust_cell_size(2)
        self.tableView_HexView_Ascii.adjust_cell_size(1)

        self.widget_HexView.wheelEvent = self.widget_HexView_wheel_event
        # Saving the original function because super() doesn't work when we override functions like this
        self.widget_HexView.keyPressEvent_original = self.widget_HexView.keyPressEvent
        self.widget_HexView.keyPressEvent = self.widget_HexView_key_press_event

        self.tableView_HexView_Hex.contextMenuEvent = self.widget_HexView_context_menu_event
        self.tableView_HexView_Ascii.contextMenuEvent = self.widget_HexView_context_menu_event

        self.bHexViewScrolling = False  # rejects new scroll requests while scrolling
        self.verticalScrollBar_HexView.wheelEvent = QEvent.ignore
        self.verticalScrollBar_HexView.sliderChange = self.hex_view_scrollbar_sliderchanged
        guiutils.center_scroll_bar(self.verticalScrollBar_HexView)

        self.tableWidget_HexView_Address.wheelEvent = QEvent.ignore
        self.tableWidget_HexView_Address.setAutoScroll(False)
        self.tableWidget_HexView_Address.setSelectionMode(QAbstractItemView.SelectionMode.NoSelection)

        self.tableView_HexView_Hex.selectionModel().selectionChanged.connect(self.hex_view_selection_changed)
        self.tableView_HexView_Ascii.selectionModel().selectionChanged.connect(self.hex_view_selection_changed)
        self.tableView_HexView_Hex.scroll_requested.connect(self.hex_view_scroll_by_row)
        self.tableView_HexView_Ascii.scroll_requested.connect(self.hex_view_scroll_by_row)

        self.scrollArea_Hex.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.scrollArea_Hex.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.tableWidget_HexView_Address.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.tableWidget_HexView_Address.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.tableWidget_HexView_Address.verticalHeader().setMinimumSectionSize(
            self.tableView_HexView_Hex.verticalHeader().minimumSectionSize()
        )
        self.tableWidget_HexView_Address.verticalHeader().setDefaultSectionSize(
            self.tableView_HexView_Hex.verticalHeader().defaultSectionSize()
        )
        self.tableWidget_HexView_Address.verticalHeader().setMaximumSectionSize(
            self.tableView_HexView_Hex.verticalHeader().maximumSectionSize()
        )

        self.hex_update_timer = QTimer(timeout=self.hex_update_loop)
        self.hex_update_timer.start(200)

    def show_trace_window(self):
        TraceInstructionsWindowForm(self, prompt_dialog=False)

    def step_instruction(self):
        if not (
            debugcore.currentpid == -1
            or debugcore.active_trace
            or debugcore.inferior_status == typedefs.INFERIOR_STATUS.RUNNING
            or self.updating_memoryview
        ):
            debugcore.step_instruction()

    def step_over_instruction(self):
        if not (
            debugcore.currentpid == -1
            or debugcore.active_trace
            or debugcore.inferior_status == typedefs.INFERIOR_STATUS.RUNNING
            or self.updating_memoryview
        ):
            debugcore.step_over_instruction()

    def execute_till_return(self):
        if not (
            debugcore.currentpid == -1
            or debugcore.active_trace
            or debugcore.inferior_status == typedefs.INFERIOR_STATUS.RUNNING
            or self.updating_memoryview
        ):
            debugcore.execute_till_return()

    def set_address(self):
        if guiutils.check_inferior_running(self):
            return
        selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        debugcore.set_convenience_variable("pc", current_address)
        self.refresh_disassemble_view()

    def edit_instruction(self):
        selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        bytes_aob = self.tableWidget_Disassemble.item(selected_row, DISAS_BYTES_COL).text()
        EditInstructionDialogForm(self, current_address, bytes_aob).exec()

    def nop_instruction(self):
        if debugcore.currentpid == -1:
            return
        selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        current_address_int = safe_str_to_int(current_address, 16)
        if current_address_int == 0:
            return
        array_of_bytes = self.tableWidget_Disassemble.item(selected_row, DISAS_BYTES_COL).text()
        debugcore.nop_instruction(current_address_int, len(array_of_bytes.split()))
        self.refresh_disassemble_view()

    def toggle_breakpoint(self):
        if debugcore.currentpid == -1:
            return
        selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        current_address_int = safe_str_to_int(current_address, 16)
        if current_address_int == 0:
            return
        breakpoints = debugcore.get_breakpoints_in_range(current_address_int)
        if breakpoints:
            for breakpoint in breakpoints:
                debugcore.delete_breakpoint(safe_int_cast(breakpoint.number))
        else:
            if not debugcore.add_breakpoint(current_address):
                QMessageBox.information(self, tr.ERROR, tr.BREAKPOINT_FAILED.format(current_address))
        self.refresh_disassemble_view()

    def toggle_watchpoint(self, address, length, watchpoint_type=typedefs.WATCHPOINT_TYPE.BOTH):
        if debugcore.currentpid == -1:
            return
        breakpoints = debugcore.get_breakpoints_in_range(address, length)
        if not breakpoints:
            if len(debugcore.add_watchpoint(hex(address), length, watchpoint_type)) < 1:
                QMessageBox.information(self, tr.ERROR, tr.WATCHPOINT_FAILED.format(hex(address)))
        else:
            for bp in breakpoints:
                debugcore.delete_breakpoint(safe_int_cast(bp.number))
        self.refresh_hex_view()

    def label_HexView_Information_context_menu_event(self, event):
        if debugcore.currentpid == -1:
            return

        def copy_to_clipboard():
            app.clipboard().setText(self.label_HexView_Information.text())

        menu = QMenu()
        copy_label = menu.addAction(tr.COPY_CLIPBOARD)
        font_size = self.label_HexView_Information.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {copy_label: copy_to_clipboard}
        try:
            actions[action]()
        except KeyError:
            pass

    def widget_HexView_context_menu_event(self, event):
        if debugcore.currentpid == -1:
            return
        addr = self.hex_selection_address_begin
        length = self.get_hex_selection_length()
        menu = QMenu()
        edit = menu.addAction(tr.EDIT)
        menu.addSeparator()
        go_to = menu.addAction(f"{tr.GO_TO_EXPRESSION}[Ctrl+G]")
        disassemble = menu.addAction(f"{tr.DISASSEMBLE_ADDRESS}[Ctrl+D]")
        menu.addSeparator()
        add_address = menu.addAction(f"{tr.ADD_TO_ADDRESS_LIST}[Ctrl+A]")
        menu.addSeparator()
        copy_selection = menu.addAction(f"{tr.COPY}[Ctrl+C]")
        refresh = menu.addAction(f"{tr.REFRESH}[R]")
        menu.addSeparator()
        watchpoint_menu = menu.addMenu(tr.SET_WATCHPOINT)
        watchpoint_write = watchpoint_menu.addAction(tr.WRITE_ONLY)
        watchpoint_read = watchpoint_menu.addAction(tr.READ_ONLY)
        watchpoint_both = watchpoint_menu.addAction(tr.BOTH)
        add_condition = menu.addAction(tr.CHANGE_BREAKPOINT_CONDITION)
        delete_breakpoint = menu.addAction(tr.DELETE_BREAKPOINT)
        if not debugcore.get_breakpoints_in_range(addr, length):
            guiutils.delete_menu_entries(menu, [add_condition, delete_breakpoint])
        else:
            guiutils.delete_menu_entries(menu, [watchpoint_menu.menuAction()])
        font_size = self.widget_HexView.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            edit: self.exec_hex_view_edit_dialog,
            go_to: self.exec_hex_view_go_to_dialog,
            disassemble: lambda: self.disassemble_expression(hex(addr)),
            add_address: self.exec_hex_view_add_address_dialog,
            copy_selection: self.copy_hex_view_selection,
            refresh: self.refresh_hex_view,
            watchpoint_write: lambda: self.toggle_watchpoint(addr, length, typedefs.WATCHPOINT_TYPE.WRITE_ONLY),
            watchpoint_read: lambda: self.toggle_watchpoint(addr, length, typedefs.WATCHPOINT_TYPE.READ_ONLY),
            watchpoint_both: lambda: self.toggle_watchpoint(addr, length, typedefs.WATCHPOINT_TYPE.BOTH),
            add_condition: lambda: self.add_breakpoint_condition(addr, length),
            delete_breakpoint: lambda: self.toggle_watchpoint(addr, length),
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def exec_hex_view_edit_dialog(self):
        if debugcore.currentpid == -1:
            return
        HexEditDialogForm(self, self.hex_selection_address_begin, self.get_hex_selection_length()).exec()
        self.refresh_hex_view()

    def exec_hex_view_go_to_dialog(self):
        if debugcore.currentpid == -1:
            return
        go_to_dialog = utilwidgets.InputDialog(self, [(tr.ENTER_EXPRESSION, hex(self.hex_selection_address_begin))])
        if go_to_dialog.exec():
            expression = go_to_dialog.get_values()[0]
            dest_address = debugcore.examine_expression(expression).address
            if not dest_address:
                QMessageBox.information(self, tr.ERROR, tr.INVALID.format(expression))
                return
            self.hex_dump_address(int(dest_address, 16))

    def exec_hex_view_add_address_dialog(self):
        if debugcore.currentpid == -1:
            return
        vt = typedefs.ValueType(typedefs.VALUE_INDEX.AOB, self.get_hex_selection_length())
        address_dialog = ManualAddressDialogForm(self, address=hex(self.hex_selection_address_begin), value_type=vt)
        if address_dialog.exec():
            desc, address, vt = address_dialog.get_values()
            self.parent().add_entry_to_addresstable(desc, address, vt)
            self.parent().update_address_table()

    def copy_hex_view_selection(self):
        data = debugcore.hex_dump(self.hex_selection_address_begin, self.get_hex_selection_length())
        if self.focusWidget() == self.tableView_HexView_Ascii:
            display_text = utils.aob_to_str(data)
        else:
            display_text = " ".join(data)
        app.clipboard().setText(display_text)

    def hex_view_scroll_up(self):
        self.verticalScrollBar_HexView.setValue(1)

    def hex_view_scroll_down(self):
        self.verticalScrollBar_HexView.setValue(-1)

    def hex_view_scroll_by_row(self, direction):
        if debugcore.currentpid == -1:
            return
        offset = direction * HEX_VIEW_COL_COUNT
        self.hex_selection_start += offset
        self.hex_selection_end += offset
        self.hex_selection_address_begin += offset
        self.hex_selection_address_end += offset
        self.hex_dump_address(self.hex_model.current_address + offset)

    def hex_view_scrollbar_sliderchanged(self, event):
        if self.bHexViewScrolling:
            return
        self.bHexViewScrolling = True
        maximum = self.verticalScrollBar_HexView.maximum()
        minimum = self.verticalScrollBar_HexView.minimum()
        midst = (maximum + minimum) / 2
        current_value = self.verticalScrollBar_HexView.value()
        current_address = self.hex_model.current_address
        if current_value < midst:
            next_address = current_address - states.bytes_per_scroll
        else:
            next_address = current_address + states.bytes_per_scroll
        self.hex_dump_address(next_address)
        guiutils.center_scroll_bar(self.verticalScrollBar_HexView)
        self.bHexViewScrolling = False

    def disassemble_scroll_up(self):
        self.verticalScrollBar_Disassemble.setValue(1)

    def disassemble_scroll_down(self):
        self.verticalScrollBar_Disassemble.setValue(-1)

    def disassemble_scrollbar_sliderchanged(self, even):
        if self.bDisassemblyScrolling:
            return
        self.bDisassemblyScrolling = True
        maximum = self.verticalScrollBar_Disassemble.maximum()
        minimum = self.verticalScrollBar_Disassemble.minimum()
        midst = (maximum + minimum) / 2
        current_value = self.verticalScrollBar_Disassemble.value()
        if current_value < midst:
            self.tableWidget_Disassemble_scroll("previous", states.instructions_per_scroll)
        else:
            self.tableWidget_Disassemble_scroll("next", states.instructions_per_scroll)
        guiutils.center_scroll_bar(self.verticalScrollBar_Disassemble)
        self.bDisassemblyScrolling = False

    def hex_view_selection_changed(self, selected, deselected):
        sender_selection_model: QItemSelectionModel = self.sender()
        sender_selection = sorted([(idx.row(), idx.column()) for idx in sender_selection_model.selectedIndexes()])
        first_selection = sender_selection[0]
        last_selection = sender_selection[-1]
        hex_start = self.address_to_hex_point(self.hex_selection_start)
        hex_end = self.address_to_hex_point(self.hex_selection_end)
        hex_start, hex_end = self.fix_selection_at_borders(hex_start, hex_end)
        if len(sender_selection) == 1:
            hex_start = first_selection
            hex_end = first_selection
        else:
            # Selection ends in top left
            if last_selection == hex_start:
                hex_end = first_selection
            # Selection ends in top right
            elif last_selection[0] == hex_start[0]:
                hex_end = (first_selection[0], last_selection[1])
            # Selection ends in bottom left
            elif last_selection[1] == hex_start[1]:
                hex_end = (last_selection[0], first_selection[1])
            # Selection ends in bottom right
            else:
                hex_end = last_selection
        if hex_start < hex_end:
            address_begin = hex_start
            address_end = hex_end
        else:
            address_begin = hex_end
            address_end = hex_start
        self.hex_selection_start = self.hex_point_to_address(hex_start)
        self.hex_selection_end = self.hex_point_to_address(hex_end)
        self.hex_selection_address_begin = self.hex_point_to_address(address_begin)
        self.hex_selection_address_end = self.hex_point_to_address(address_end)
        self.handle_hex_selection()

    def handle_hex_selection(self):
        hex_view = self.tableView_HexView_Hex
        ascii_view = self.tableView_HexView_Ascii
        addr_view = self.tableWidget_HexView_Address
        hex_enabled = hex_view.updatesEnabled()
        ascii_enabled = ascii_view.updatesEnabled()
        addr_enabled = addr_view.updatesEnabled()
        hex_view.setUpdatesEnabled(False)
        ascii_view.setUpdatesEnabled(False)
        addr_view.setUpdatesEnabled(False)
        hex_selection_model = hex_view.selectionModel()
        ascii_selection_model = ascii_view.selectionModel()
        start_point = self.address_to_hex_point(self.hex_selection_address_begin)
        end_point = self.address_to_hex_point(self.hex_selection_address_end)
        with QSignalBlocker(hex_selection_model), QSignalBlocker(ascii_selection_model):
            hex_selection_model.clearSelection()
            ascii_selection_model.clearSelection()
            addr_view.clearSelection()
            if start_point or end_point:
                start_point, end_point = self.fix_selection_at_borders(start_point, end_point)
                model = hex_selection_model.model()
                selection = QItemSelection()
                if start_point[0] == end_point[0]:
                    selection.select(model.index(*start_point), model.index(*end_point))
                else:
                    # First line
                    selection.select(model.index(*start_point), model.index(start_point[0], HEX_VIEW_COL_COUNT - 1))
                    # Middle
                    if end_point[0] - start_point[0] > 1:
                        selection.select(
                            model.index(start_point[0] + 1, 0),
                            model.index(end_point[0] - 1, HEX_VIEW_COL_COUNT - 1),
                        )
                    # Last line
                    selection.select(model.index(end_point[0], 0), model.index(*end_point))
                hex_selection_model.select(selection, QItemSelectionModel.SelectionFlag.Select)
                ascii_selection_model.select(selection, QItemSelectionModel.SelectionFlag.Select)
                addr_view.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection)
                for row in range(start_point[0], end_point[0] + 1):
                    addr_view.selectRow(row)
                addr_view.setSelectionMode(QAbstractItemView.SelectionMode.NoSelection)
        hex_view.setUpdatesEnabled(hex_enabled)
        ascii_view.setUpdatesEnabled(ascii_enabled)
        addr_view.setUpdatesEnabled(addr_enabled)

    def hex_point_to_address(self, point):
        address = self.hex_model.current_address + point[0] * HEX_VIEW_COL_COUNT + point[1]
        return utils.modulo_address(address, debugcore.inferior_arch)

    def address_to_hex_point(self, address):
        diff = address - self.hex_model.current_address
        if 0 <= diff < HEX_VIEW_ROW_COUNT * HEX_VIEW_COL_COUNT:
            return diff // HEX_VIEW_COL_COUNT, diff % HEX_VIEW_COL_COUNT

    def get_hex_selection_length(self):
        return self.hex_selection_address_end - self.hex_selection_address_begin + 1

    def fix_selection_at_borders(self, start_point, end_point):
        if not start_point:
            start_point = (0, 0)
        if not end_point:
            end_point = (HEX_VIEW_ROW_COUNT - 1, HEX_VIEW_COL_COUNT - 1)
        return start_point, end_point

    def hex_update_loop(self):
        offset = HEX_VIEW_ROW_COUNT * HEX_VIEW_COL_COUNT
        if debugcore.currentpid == -1 or states.exiting:
            updated_array = ["??"] * offset
        else:
            updated_array = debugcore.hex_dump(self.hex_model.current_address, offset)
        self.hex_model.update_loop(updated_array)
        self.ascii_model.update_loop(updated_array)

    # TODO: Consider merging HexView_Address, HexView_Hex and HexView_Ascii into one UI class
    # TODO: Move this function to that class if that happens
    # TODO: Also consider moving shared fields of HexView and HexModel to that class(such as HexModel.current_address)
    def hex_dump_address(self, int_address, offset=HEX_VIEW_ROW_COUNT * HEX_VIEW_COL_COUNT):
        if debugcore.currentpid == -1:
            return
        self.tableView_HexView_Hex.setUpdatesEnabled(False)
        self.tableView_HexView_Ascii.setUpdatesEnabled(False)
        self.tableWidget_HexView_Address.setUpdatesEnabled(False)
        int_address = utils.modulo_address(int_address, debugcore.inferior_arch)
        if not (self.hex_view_current_region.start <= int_address < self.hex_view_current_region.end):
            info = utils.get_region_info(debugcore.currentpid, int_address)
            if info:
                self.hex_view_current_region = info
                self.label_HexView_Information.setText(
                    tr.REGION_INFO.format(info.perms, hex(info.start), hex(info.end), info.file_name)
                )
            else:
                self.hex_view_current_region = typedefs.tuple_region_info(0, 0, None, None, None)
                self.label_HexView_Information.setText(tr.INVALID_REGION)
        self.tableWidget_HexView_Address.setRowCount(0)
        self.tableWidget_HexView_Address.setRowCount(HEX_VIEW_ROW_COUNT * HEX_VIEW_COL_COUNT)
        for row, current_offset in enumerate(range(HEX_VIEW_ROW_COUNT)):
            row_address = hex(utils.modulo_address(int_address + current_offset * 16, debugcore.inferior_arch))
            self.tableWidget_HexView_Address.setItem(row, 0, QTableWidgetItem(utils.upper_hex(row_address)))
        tableWidget_HexView_column_size = self.tableWidget_HexView_Address.sizeHintForColumn(0) + 5
        self.tableWidget_HexView_Address.setMaximumWidth(tableWidget_HexView_column_size)
        self.tableWidget_HexView_Address.setMinimumWidth(tableWidget_HexView_column_size)
        self.tableWidget_HexView_Address.setColumnWidth(0, tableWidget_HexView_column_size)
        data_array = debugcore.hex_dump(int_address, offset)
        breakpoint_info = debugcore.get_breakpoint_info()
        self.hex_model.refresh(int_address, offset, data_array, breakpoint_info)
        self.ascii_model.refresh(int_address, offset, data_array, breakpoint_info)
        self.handle_hex_selection()
        self.tableWidget_HexView_Address.setUpdatesEnabled(True)
        self.tableView_HexView_Ascii.setUpdatesEnabled(True)
        self.tableView_HexView_Hex.setUpdatesEnabled(True)

    def refresh_hex_view(self):
        if debugcore.currentpid == -1:
            return
        if self.tableWidget_HexView_Address.rowCount() == 0:
            entry_point = debugcore.find_entry_point()
            if not entry_point:
                # **Shrugs**
                entry_point = "0x00400000"
            self.hex_dump_address(int(entry_point, 16))
            self.tableView_HexView_Hex.resize_to_contents()
            self.tableView_HexView_Ascii.resize_to_contents()
        else:
            self.hex_dump_address(self.hex_model.current_address)

    # offset can also be an address as hex str
    # returns True if the given expression is disassembled correctly, False if not
    def disassemble_expression(self, expression, offset="+200", append_history=True):
        if debugcore.currentpid == -1:
            return
        disas_data = debugcore.disassemble(expression, offset)
        if not disas_data:
            QMessageBox.information(app.focusWidget(), tr.ERROR, tr.EXPRESSION_ACCESS_ERROR.format(expression))
            return False
        program_counter = debugcore.examine_expression("$pc").address
        program_counter_int = int(program_counter, 16) if program_counter else None
        row_color = {}
        breakpoint_info = debugcore.get_breakpoint_info()

        # TODO: Change this nonsense when the huge refactorization happens
        current_first_address = utils.extract_hex_address(disas_data[0][0])  # address of first list entry
        try:
            previous_first_address = utils.extract_hex_address(
                self.tableWidget_Disassemble.item(0, DISAS_ADDR_COL).text()
            )
        except AttributeError:
            previous_first_address = current_first_address

        self.tableWidget_Disassemble.setRowCount(0)
        self.tableWidget_Disassemble.setRowCount(len(disas_data))
        jmp_dict, call_dict = debugcore.get_dissect_code_data(False, True, True)
        for row, (address_info, bytes_aob, opcode) in enumerate(disas_data):
            comment = ""
            current_address_str = utils.extract_hex_address(address_info)
            current_address = safe_str_to_int(current_address_str, 16)
            jmp_ref_exists = False
            call_ref_exists = False
            try:
                jmp_referrers = jmp_dict[current_address_str]
                jmp_ref_exists = True
            except KeyError:
                pass
            try:
                call_referrers = call_dict[current_address_str]
                call_ref_exists = True
            except KeyError:
                pass
            if jmp_ref_exists or call_ref_exists:
                tooltip_text = f"{tr.REFERENCED_BY}\n"
                ref_count = 0
                if jmp_ref_exists:
                    for referrer in jmp_referrers:
                        if ref_count > 30:
                            break
                        tooltip_text += "\n" + hex(referrer) + "(" + jmp_referrers[referrer] + ")"
                        ref_count += 1
                if call_ref_exists:
                    for referrer in call_referrers:
                        if ref_count > 30:
                            break
                        tooltip_text += "\n" + hex(referrer) + "(call)"
                        ref_count += 1
                if ref_count > 30:
                    tooltip_text += "\n..."
                tooltip_text += f"\n\n{tr.SEE_REFERRERS}"
                try:
                    row_color[row].append(REF_COLOR)
                except KeyError:
                    row_color[row] = [REF_COLOR]
                real_ref_count = 0
                if jmp_ref_exists:
                    real_ref_count += len(jmp_referrers)
                if call_ref_exists:
                    real_ref_count += len(call_referrers)
                address_info = "{" + str(real_ref_count) + "}" + address_info
            if current_address == program_counter_int:
                address_info = ">>>" + address_info
                try:
                    row_color[row].append(PC_COLOR)
                except KeyError:
                    row_color[row] = [PC_COLOR]

            for bookmark_item in self.session.pct_bookmarks.keys():
                if current_address == bookmark_item:
                    try:
                        row_color[row].append(BOOKMARK_COLOR)
                    except KeyError:
                        row_color[row] = [BOOKMARK_COLOR]
                    address_info = "(M)" + address_info
                    comment = self.session.pct_bookmarks[bookmark_item]["comment"]
                    break
            for breakpoint in breakpoint_info:
                # Catchpoints won't have an address
                if type(breakpoint.address) != str:
                    continue
                int_breakpoint_address = safe_str_to_int(breakpoint.address, 16)
                if current_address == int_breakpoint_address:
                    try:
                        row_color[row].append(BREAKPOINT_COLOR)
                    except KeyError:
                        row_color[row] = [BREAKPOINT_COLOR]
                    breakpoint_mark = "(B"
                    if breakpoint.enabled == "n":
                        breakpoint_mark += "-disabled"
                    else:
                        if breakpoint.disp != "keep":
                            breakpoint_mark += "-" + breakpoint.disp
                        if breakpoint.enable_count:
                            breakpoint_mark += "-" + breakpoint.enable_count
                    breakpoint_mark += ")"
                    address_info = breakpoint_mark + address_info
                    break
            if current_address == self.disassemble_last_selected_address_int:
                self.tableWidget_Disassemble.selectRow(row)
            addr_item = QTableWidgetItem(address_info)
            bytes_item = QTableWidgetItem(bytes_aob)
            opcodes_item = QTableWidgetItem(opcode)
            comment_item = QTableWidgetItem(comment)
            if jmp_ref_exists or call_ref_exists:
                addr_item.setToolTip(tooltip_text)
                bytes_item.setToolTip(tooltip_text)
                opcodes_item.setToolTip(tooltip_text)
                comment_item.setToolTip(tooltip_text)
            self.tableWidget_Disassemble.setItem(row, DISAS_ADDR_COL, addr_item)
            self.tableWidget_Disassemble.setItem(row, DISAS_BYTES_COL, bytes_item)
            self.tableWidget_Disassemble.setItem(row, DISAS_OPCODES_COL, opcodes_item)
            self.tableWidget_Disassemble.setItem(row, DISAS_COMMENT_COL, comment_item)
        jmp_dict.close()
        call_dict.close()
        self.handle_colors(row_color)

        # We append the old record to travel history as last action because we wouldn't like to see unnecessary
        # addresses in travel history if any error occurs while displaying the next location
        if append_history:
            self.tableWidget_Disassemble.travel_history.append(previous_first_address)
        self.disassemble_currently_displayed_address = current_first_address
        return True

    def refresh_disassemble_view(self):
        if debugcore.currentpid == -1:
            return
        self.disassemble_expression(self.disassemble_currently_displayed_address, append_history=False)

    # Set color of a row if a specific address is encountered(e.g $pc, a bookmarked address etc.)
    def handle_colors(self, row_color):
        if debugcore.currentpid == -1:
            return
        for row in row_color:
            current_row = row_color[row]
            if PC_COLOR in current_row:
                if BREAKPOINT_COLOR in current_row:
                    color = QColorConstants.Green
                elif BOOKMARK_COLOR in current_row:
                    color = QColorConstants.Yellow
                else:
                    color = PC_COLOR
                self.set_row_color(row, color)
                continue
            if BREAKPOINT_COLOR in current_row:
                if BOOKMARK_COLOR in current_row:
                    color = QColorConstants.Magenta
                else:
                    color = BREAKPOINT_COLOR
                self.set_row_color(row, color)
                continue
            if BOOKMARK_COLOR in current_row:
                self.set_row_color(row, BOOKMARK_COLOR)
                continue
            if REF_COLOR in current_row:
                self.set_row_color(row, REF_COLOR)

    def set_row_color(self, row, color):
        if debugcore.currentpid == -1:
            return
        for col in range(self.tableWidget_Disassemble.columnCount()):
            color = QColor(color)
            color.setAlpha(96)
            self.tableWidget_Disassemble.item(row, col).setData(Qt.ItemDataRole.BackgroundRole, color)

    def on_process_stop(self):
        if debugcore.stop_reason == typedefs.STOP_REASON.PAUSE:
            self.setWindowTitle(tr.MV_PAUSED)
            return
        self.updating_memoryview = True
        time0 = time()
        self.setWindowTitle(tr.MV_DEBUGGING.format(debugcore.get_thread_info()))
        self.disassemble_expression("$pc", append_history=False)
        self.update_registers()
        if self.stackedWidget_StackScreens.currentWidget() == self.StackTrace:
            self.update_stacktrace()
        elif self.stackedWidget_StackScreens.currentWidget() == self.Stack:
            self.update_stack()

        # These tableWidgets are never emptied but initially both are empty, so this runs only once
        if self.tableWidget_StackTrace.rowCount() == 0:
            self.update_stacktrace()
        if self.tableWidget_Stack.rowCount() == 0:
            self.update_stack()
        self.refresh_hex_view()
        if states.show_memory_view_on_stop:
            self.showMaximized()
            self.activateWindow()
        if self.stacktrace_info_widget.isVisible():
            self.stacktrace_info_widget.update_stacktrace()
        self.pushButton_ShowFloatRegisters.setEnabled(True)
        if self.float_registers_widget.isVisible():
            self.float_registers_widget.update_registers()
        app.processEvents()
        time1 = time()
        logger.debug(f"Updated memory view in: {str(time1 - time0)}")
        self.updating_memoryview = False

    def on_process_running(self):
        self.setWindowTitle(tr.MV_RUNNING)
        self.pushButton_ShowFloatRegisters.setEnabled(False)

    def add_breakpoint_condition(self, int_address, length=1):
        if debugcore.currentpid == -1:
            return
        breakpoints = debugcore.get_breakpoints_in_range(int_address, length)
        if breakpoints:
            condition_line_edit_text = breakpoints[0].condition
        else:
            condition_line_edit_text = ""
        items = [(tr.ENTER_BP_CONDITION, condition_line_edit_text)]
        condition_dialog = utilwidgets.InputDialog(self, items, Qt.AlignmentFlag.AlignLeft)
        if condition_dialog.exec():
            condition = condition_dialog.get_values()[0]
            for bp in breakpoints:
                if not debugcore.modify_breakpoint(
                    safe_int_cast(bp.number), typedefs.BREAKPOINT_MODIFY.CONDITION, condition
                ):
                    QMessageBox.information(app.focusWidget(), tr.ERROR, tr.BP_CONDITION_FAILED.format(bp.address))

    def update_registers(self):
        if debugcore.currentpid == -1:
            return
        registers = debugcore.read_registers()
        if debugcore.inferior_arch == typedefs.INFERIOR_ARCH.ARCH_64:
            self.stackedWidget.setCurrentWidget(self.registers_64)
            self.RAX.set_value(registers["rax"])
            self.RBX.set_value(registers["rbx"])
            self.RCX.set_value(registers["rcx"])
            self.RDX.set_value(registers["rdx"])
            self.RSI.set_value(registers["rsi"])
            self.RDI.set_value(registers["rdi"])
            self.RBP.set_value(registers["rbp"])
            self.RSP.set_value(registers["rsp"])
            self.RIP.set_value(registers["rip"])
            self.R8.set_value(registers["r8"])
            self.R9.set_value(registers["r9"])
            self.R10.set_value(registers["r10"])
            self.R11.set_value(registers["r11"])
            self.R12.set_value(registers["r12"])
            self.R13.set_value(registers["r13"])
            self.R14.set_value(registers["r14"])
            self.R15.set_value(registers["r15"])
        elif debugcore.inferior_arch == typedefs.INFERIOR_ARCH.ARCH_32:
            self.stackedWidget.setCurrentWidget(self.registers_32)
            self.EAX.set_value(registers["eax"])
            self.EBX.set_value(registers["ebx"])
            self.ECX.set_value(registers["ecx"])
            self.EDX.set_value(registers["edx"])
            self.ESI.set_value(registers["esi"])
            self.EDI.set_value(registers["edi"])
            self.EBP.set_value(registers["ebp"])
            self.ESP.set_value(registers["esp"])
            self.EIP.set_value(registers["eip"])
        self.CF.set_value(registers["cf"])
        self.PF.set_value(registers["pf"])
        self.AF.set_value(registers["af"])
        self.ZF.set_value(registers["zf"])
        self.SF.set_value(registers["sf"])
        self.TF.set_value(registers["tf"])
        self.IF.set_value(registers["if"])
        self.DF.set_value(registers["df"])
        self.OF.set_value(registers["of"])
        self.CS.set_value(registers["cs"])
        self.SS.set_value(registers["ss"])
        self.DS.set_value(registers["ds"])
        self.ES.set_value(registers["es"])
        self.GS.set_value(registers["gs"])
        self.FS.set_value(registers["fs"])

    def update_stacktrace(self):
        if guiutils.check_inferior_running(self, show_message=False):
            return
        stack_trace_info = debugcore.get_stacktrace_info()
        self.tableWidget_StackTrace.setRowCount(0)
        self.tableWidget_StackTrace.setRowCount(len(stack_trace_info))
        for row, item in enumerate(stack_trace_info):
            self.tableWidget_StackTrace.setItem(row, STACKTRACE_RETURN_ADDRESS_COL, QTableWidgetItem(item[0]))
            self.tableWidget_StackTrace.setItem(row, STACKTRACE_FRAME_ADDRESS_COL, QTableWidgetItem(item[1]))

    def set_stack_widget(self, stack_widget):
        if debugcore.currentpid == -1:
            return
        self.stackedWidget_StackScreens.setCurrentWidget(stack_widget)
        if stack_widget == self.Stack:
            self.update_stack()
        elif stack_widget == self.StackTrace:
            self.update_stacktrace()

    def tableWidget_StackTrace_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_StackTrace.item(row, column).text())

        selected_row = guiutils.get_current_row(self.tableWidget_StackTrace)
        menu = QMenu()
        switch_to_stack = menu.addAction(tr.FULL_STACK)
        menu.addSeparator()
        clipboard_menu = menu.addMenu(tr.COPY_CLIPBOARD)
        copy_return = clipboard_menu.addAction(tr.COPY_RETURN_ADDRESS)
        copy_frame = clipboard_menu.addAction(tr.COPY_FRAME_ADDRESS)
        if selected_row == -1:
            guiutils.delete_menu_entries(menu, [clipboard_menu.menuAction()])
        refresh = menu.addAction(f"{tr.REFRESH}[R]")
        if guiutils.check_inferior_running(self, show_message=False):
            refresh.setEnabled(False)
        if debugcore.currentpid == -1:
            menu.clear()
            menu.addMenu(clipboard_menu)
        font_size = self.tableWidget_StackTrace.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            switch_to_stack: lambda: self.set_stack_widget(self.Stack),
            copy_return: lambda: copy_to_clipboard(selected_row, STACKTRACE_RETURN_ADDRESS_COL),
            copy_frame: lambda: copy_to_clipboard(selected_row, STACKTRACE_FRAME_ADDRESS_COL),
            refresh: self.update_stacktrace,
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def update_stack(self):
        if guiutils.check_inferior_running(self, show_message=False):
            return
        stack_info: list[str] = debugcore.get_stack_info(from_base_pointer=self.stack_from_base_pointer)
        self.tableWidget_Stack.setRowCount(0)
        self.tableWidget_Stack.setRowCount(len(stack_info))
        for row, item in enumerate(stack_info):
            self.tableWidget_Stack.setItem(row, STACK_POINTER_ADDRESS_COL, QTableWidgetItem(item[0]))
            self.tableWidget_Stack.setItem(row, STACK_VALUE_COL, QTableWidgetItem(item[1]))
            self.tableWidget_Stack.setItem(row, STACK_POINTS_TO_COL, QTableWidgetItem(item[2]))
        self.tableWidget_Stack.resizeColumnToContents(STACK_POINTER_ADDRESS_COL)
        self.tableWidget_Stack.resizeColumnToContents(STACK_VALUE_COL)

    def toggle_stack_from_sp_bp(self):
        self.stack_from_base_pointer = not self.stack_from_base_pointer
        self.update_stack()

    def tableWidget_Stack_key_press_event(self, event):
        if debugcore.currentpid == -1:
            return
        selected_row = guiutils.get_current_row(self.tableWidget_Stack)
        if selected_row == -1:
            actions = typedefs.KeyboardModifiersTupleDict(
                [(QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_R), self.update_stack)]
            )
        else:
            current_address_text = self.tableWidget_Stack.item(selected_row, STACK_VALUE_COL).text()
            current_address = utils.extract_hex_address(current_address_text)

            actions = typedefs.KeyboardModifiersTupleDict(
                [
                    (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_R), self.update_stack),
                    (
                        QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_D),
                        lambda: self.disassemble_expression(current_address),
                    ),
                    (
                        QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_H),
                        lambda: self.hex_dump_address(safe_str_to_int(current_address, 16)),
                    ),
                ]
            )
        try:
            actions[QKeyCombination(event.modifiers(), Qt.Key(event.key()))]()
        except KeyError:
            pass
        self.tableWidget_Stack.keyPressEvent_original(event)

    def tableWidget_Stack_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_Stack.item(row, column).text())

        selected_row = guiutils.get_current_row(self.tableWidget_Stack)
        if selected_row == -1:
            current_address = None
        else:
            current_address_text = self.tableWidget_Stack.item(selected_row, STACK_VALUE_COL).text()
            current_address = utils.extract_hex_address(current_address_text)
        menu = QMenu()
        switch_to_stacktrace = menu.addAction(tr.STACKTRACE)
        toggle_stack_pointer = menu.addAction(tr.TOGGLE_STACK_FROM_SP_BP)
        if guiutils.check_inferior_running(self, show_message=False):
            toggle_stack_pointer.setEnabled(False)
        menu.addSeparator()
        clipboard_menu = menu.addMenu(tr.COPY_CLIPBOARD)
        copy_address = clipboard_menu.addAction(tr.COPY_ADDRESS)
        copy_value = clipboard_menu.addAction(tr.COPY_VALUE)
        copy_points_to = clipboard_menu.addAction(tr.COPY_POINTS_TO)
        refresh = menu.addAction(f"{tr.REFRESH}[R]")
        if guiutils.check_inferior_running(self, show_message=False):
            refresh.setEnabled(False)
        menu.addSeparator()
        show_in_disas = menu.addAction(f"{tr.DISASSEMBLE_VALUE_POINTER}[Ctrl+D]")
        show_in_hex = menu.addAction(f"{tr.HEXVIEW_VALUE_POINTER}[Ctrl+H]")
        if selected_row == -1:
            guiutils.delete_menu_entries(menu, [clipboard_menu.menuAction(), show_in_disas, show_in_hex])
        if debugcore.currentpid == -1:
            menu.clear()
            menu.addMenu(clipboard_menu)
        font_size = self.tableWidget_Stack.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            switch_to_stacktrace: lambda: self.set_stack_widget(self.StackTrace),
            toggle_stack_pointer: self.toggle_stack_from_sp_bp,
            copy_address: lambda: copy_to_clipboard(selected_row, STACK_POINTER_ADDRESS_COL),
            copy_value: lambda: copy_to_clipboard(selected_row, STACK_VALUE_COL),
            copy_points_to: lambda: copy_to_clipboard(selected_row, STACK_POINTS_TO_COL),
            refresh: self.update_stack,
            show_in_disas: lambda: self.disassemble_expression(current_address),
            show_in_hex: lambda: self.hex_dump_address(safe_str_to_int(current_address, 16)),
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def tableWidget_Stack_double_click(self, index):
        if debugcore.currentpid == -1:
            return
        selected_row = guiutils.get_current_row(self.tableWidget_Stack)
        if index.column() == STACK_POINTER_ADDRESS_COL:
            current_address_text = self.tableWidget_Stack.item(selected_row, STACK_POINTER_ADDRESS_COL).text()
            current_address = utils.extract_hex_address(current_address_text)
            self.hex_dump_address(safe_str_to_int(current_address, 16))
        else:
            points_to_text = self.tableWidget_Stack.item(selected_row, STACK_POINTS_TO_COL).text()
            current_address_text = self.tableWidget_Stack.item(selected_row, STACK_VALUE_COL).text()
            current_address = utils.extract_hex_address(current_address_text)
            if points_to_text.startswith("(str)"):
                self.hex_dump_address(safe_str_to_int(current_address, 16))
            else:
                self.disassemble_expression(current_address)

    def tableWidget_StackTrace_double_click(self, index):
        if debugcore.currentpid == -1:
            return
        selected_row = guiutils.get_current_row(self.tableWidget_StackTrace)
        if index.column() == STACKTRACE_RETURN_ADDRESS_COL:
            current_address_text = self.tableWidget_StackTrace.item(selected_row, STACKTRACE_RETURN_ADDRESS_COL).text()
            current_address = utils.extract_hex_address(current_address_text)
            self.disassemble_expression(current_address)
        if index.column() == STACKTRACE_FRAME_ADDRESS_COL:
            current_address_text = self.tableWidget_StackTrace.item(selected_row, STACKTRACE_FRAME_ADDRESS_COL).text()
            current_address = utils.extract_hex_address(current_address_text)
            self.hex_dump_address(safe_str_to_int(current_address, 16))

    def tableWidget_StackTrace_key_press_event(self, event):
        if debugcore.currentpid == -1:
            return
        actions = typedefs.KeyboardModifiersTupleDict(
            [(QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_R), self.update_stacktrace)]
        )
        try:
            actions[QKeyCombination(event.modifiers(), Qt.Key(event.key()))]()
        except KeyError:
            pass
        self.tableWidget_StackTrace.keyPressEvent_original(event)

    def widget_Disassemble_wheel_event(self, event: QWheelEvent):
        steps = event.angleDelta()
        if steps.x() != 0:
            self.tableWidget_Disassemble_wheelEvent_original(event)
        if debugcore.currentpid == -1:
            return
        if steps.y() > 0:
            self.tableWidget_Disassemble_scroll("previous", states.instructions_per_scroll)
        elif steps.y() < 0:
            self.tableWidget_Disassemble_scroll("next", states.instructions_per_scroll)

    def disassemble_check_viewport(self, where, instruction_count):
        if debugcore.currentpid == -1:
            return
        current_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        current_row_height = self.tableWidget_Disassemble.rowViewportPosition(current_row)
        row_height = self.tableWidget_Disassemble.verticalHeader().defaultSectionSize()
        max_height = self.tableWidget_Disassemble.maximumViewportSize().height()
        # visible_height = max_height - row_height
        height = max_height - row_height * 3  # lets us see the next 2 instructions after the last visible row
        if current_row_height > max_height:
            last_visible_row = 0
            for row in range(self.tableWidget_Disassemble.rowCount()):
                if self.tableWidget_Disassemble.rowViewportPosition(row) > height:
                    break
                last_visible_row += 1
            current_address = utils.extract_hex_address(
                self.tableWidget_Disassemble.item(current_row, DISAS_ADDR_COL).text()
            )
            new_address = debugcore.find_closest_instruction_address(current_address, "previous", last_visible_row)
            self.disassemble_expression(new_address, append_history=False)
        elif (where == "previous" and current_row == 0) or (where == "next" and current_row_height > height):
            self.tableWidget_Disassemble_scroll(where, instruction_count)

    def tableWidget_Disassemble_scroll(self, where, instruction_count):
        if debugcore.currentpid == -1:
            return
        current_address = self.disassemble_currently_displayed_address
        new_address = debugcore.find_closest_instruction_address(current_address, where, instruction_count)
        self.disassemble_expression(new_address, append_history=False)

    def widget_HexView_wheel_event(self, event):
        if debugcore.currentpid == -1:
            return
        steps = event.angleDelta()
        current_address = self.hex_model.current_address
        if steps.y() > 0:
            next_address = current_address - states.bytes_per_scroll
        else:
            next_address = current_address + states.bytes_per_scroll
        self.hex_dump_address(next_address)

    def widget_HexView_key_press_event(self, event):
        if debugcore.currentpid == -1:
            return
        actions = typedefs.KeyboardModifiersTupleDict(
            [
                (QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_G), self.exec_hex_view_go_to_dialog),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_D),
                    lambda: self.disassemble_expression(hex(self.hex_selection_address_begin)),
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_A),
                    self.exec_hex_view_add_address_dialog,
                ),
                (QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_C), self.copy_hex_view_selection),
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_R), self.refresh_hex_view),
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_PageUp), self.hex_view_scroll_up),
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_PageDown), self.hex_view_scroll_down),
            ]
        )
        try:
            actions[QKeyCombination(event.modifiers(), Qt.Key(event.key()))]()
        except KeyError:
            pass
        self.widget_HexView.keyPressEvent_original(event)

    def tableWidget_Disassemble_key_press_event(self, event):
        if debugcore.currentpid == -1:
            return
        selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        if selected_row == -1:
            selected_row = 0
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        current_address_int = safe_str_to_int(current_address, 16)

        actions = typedefs.KeyboardModifiersTupleDict(
            [
                (
                    QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_Space),
                    lambda: self.follow_instruction(selected_row),
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_E),
                    lambda: self.exec_examine_referrers_widget(current_address_text),
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_G),
                    self.exec_disassemble_go_to_dialog,
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_H),
                    lambda: self.hex_dump_address(current_address_int),
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_B),
                    lambda: self.bookmark_address(current_address_int),
                ),
                (QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_D), self.dissect_current_region),
                (
                    QKeyCombination(Qt.KeyboardModifier.ControlModifier, Qt.Key.Key_T),
                    self.exec_trace_instructions_dialog,
                ),
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_R), self.refresh_disassemble_view),
                (
                    QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_Down),
                    lambda: self.disassemble_check_viewport("next", 1),
                ),
                (
                    QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_Up),
                    lambda: self.disassemble_check_viewport("previous", 1),
                ),
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_PageUp), self.disassemble_scroll_up),
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_PageDown), self.disassemble_scroll_down),
            ]
        )
        try:
            actions[QKeyCombination(event.modifiers(), Qt.Key(event.key()))]()
        except KeyError:
            pass
        self.tableWidget_Disassemble.keyPressEvent_original(event)

    def tableWidget_Disassemble_item_double_clicked(self, index):
        if debugcore.currentpid == -1:
            return
        if index.column() == DISAS_COMMENT_COL:
            selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
            current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
            current_address = safe_str_to_int(utils.extract_hex_address(current_address_text), 16)
            if current_address in self.session.pct_bookmarks:
                self.change_bookmark_comment(current_address)
            else:
                self.bookmark_address(current_address)

    def tableWidget_Disassemble_item_selection_changed(self):
        if debugcore.currentpid == -1:
            return
        try:
            selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
            selected_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
            self.disassemble_last_selected_address_int = int(utils.extract_hex_address(selected_address_text), 16)
        except (TypeError, ValueError, AttributeError):
            pass

    # Search the item in given row for location changing instructions
    # Go to the address pointed by that instruction if it contains any
    def follow_instruction(self, selected_row):
        if debugcore.currentpid == -1:
            return
        address = utils.instruction_follow_address(
            self.tableWidget_Disassemble.item(selected_row, DISAS_OPCODES_COL).text()
        )
        if address:
            self.disassemble_expression(address)

    def disassemble_go_back(self):
        if debugcore.currentpid == -1:
            return
        if self.tableWidget_Disassemble.travel_history:
            last_location = self.tableWidget_Disassemble.travel_history[-1]
            self.disassemble_expression(last_location, append_history=False)
            self.tableWidget_Disassemble.travel_history.pop()

    def tableWidget_Disassemble_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_Disassemble.item(row, column).text())

        def copy_all_columns(row):
            copied_string = ""
            for column in range(self.tableWidget_Disassemble.columnCount()):
                copied_string += self.tableWidget_Disassemble.item(row, column).text() + "\t"
            app.clipboard().setText(copied_string)

        selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        current_address_int = safe_str_to_int(current_address, 16)

        menu = QMenu()
        go_to = menu.addAction(f"{tr.GO_TO_EXPRESSION}[Ctrl+G]")
        back = menu.addAction(tr.BACK)
        show_in_hex_view = menu.addAction(f"{tr.HEXVIEW_ADDRESS}[Ctrl+H]")
        menu.addSeparator()
        followable = utils.instruction_follow_address(
            self.tableWidget_Disassemble.item(selected_row, DISAS_OPCODES_COL).text()
        )
        follow = menu.addAction(f"{tr.FOLLOW}[Space]")
        if not followable:
            guiutils.delete_menu_entries(menu, [follow])
        examine_referrers = menu.addAction(f"{tr.EXAMINE_REFERRERS}[Ctrl+E]")
        if not guiutils.contains_reference_mark(current_address_text):
            guiutils.delete_menu_entries(menu, [examine_referrers])
        bookmark = menu.addAction(f"{tr.BOOKMARK_ADDRESS}[Ctrl+B]")
        delete_bookmark = menu.addAction(tr.DELETE_BOOKMARK)
        change_comment = menu.addAction(tr.CHANGE_COMMENT)
        is_bookmarked = current_address_int in self.session.pct_bookmarks
        if not is_bookmarked:
            guiutils.delete_menu_entries(menu, [delete_bookmark, change_comment])
        else:
            guiutils.delete_menu_entries(menu, [bookmark])
        go_to_bookmark = menu.addMenu(tr.GO_TO_BOOKMARK_ADDRESS)
        address_list = [hex(address) for address in self.session.pct_bookmarks.keys()]
        bookmark_actions = [go_to_bookmark.addAction(item.all) for item in debugcore.examine_expressions(address_list)]
        menu.addSeparator()
        toggle_breakpoint = menu.addAction(f"{tr.TOGGLE_BREAKPOINT}[F5]")
        add_condition = menu.addAction(tr.CHANGE_BREAKPOINT_CONDITION)
        if not debugcore.get_breakpoints_in_range(current_address_int):
            guiutils.delete_menu_entries(menu, [add_condition])
        menu.addSeparator()
        edit_instruction = menu.addAction(tr.EDIT_INSTRUCTION)
        nop_instruction = menu.addAction(tr.REPLACE_WITH_NOPS)
        if self.tableWidget_Disassemble.item(selected_row, DISAS_BYTES_COL).text() == "90":
            guiutils.delete_menu_entries(menu, [nop_instruction])
        menu.addSeparator()
        track_breakpoint = menu.addAction(tr.WHAT_ACCESSES_INSTRUCTION)
        trace_instructions = menu.addAction(f"{tr.TRACE_INSTRUCTION}[Ctrl+T]")
        dissect_region = menu.addAction(f"{tr.DISSECT_REGION}[Ctrl+D]")
        menu.addSeparator()
        refresh = menu.addAction(f"{tr.REFRESH}[R]")
        menu.addSeparator()
        if debugcore.currentpid == -1:
            menu.clear()
        clipboard_menu = menu.addMenu(tr.COPY_CLIPBOARD)
        copy_address = clipboard_menu.addAction(tr.COPY_ADDRESS)
        copy_bytes = clipboard_menu.addAction(tr.COPY_BYTES)
        copy_opcode = clipboard_menu.addAction(tr.COPY_OPCODE)
        copy_comment = clipboard_menu.addAction(tr.COPY_COMMENT)
        copy_all = clipboard_menu.addAction(tr.COPY_ALL)
        font_size = self.tableWidget_Disassemble.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            go_to: self.exec_disassemble_go_to_dialog,
            back: self.disassemble_go_back,
            show_in_hex_view: lambda: self.hex_dump_address(current_address_int),
            follow: lambda: self.follow_instruction(selected_row),
            examine_referrers: lambda: self.exec_examine_referrers_widget(current_address_text),
            bookmark: lambda: self.bookmark_address(current_address_int),
            delete_bookmark: lambda: self.delete_bookmark(current_address_int),
            change_comment: lambda: self.change_bookmark_comment(current_address_int),
            toggle_breakpoint: self.toggle_breakpoint,
            add_condition: lambda: self.add_breakpoint_condition(current_address_int),
            edit_instruction: self.edit_instruction,
            nop_instruction: self.nop_instruction,
            track_breakpoint: self.exec_track_breakpoint_dialog,
            trace_instructions: self.exec_trace_instructions_dialog,
            dissect_region: self.dissect_current_region,
            refresh: self.refresh_disassemble_view,
            copy_address: lambda: copy_to_clipboard(selected_row, DISAS_ADDR_COL),
            copy_bytes: lambda: copy_to_clipboard(selected_row, DISAS_BYTES_COL),
            copy_opcode: lambda: copy_to_clipboard(selected_row, DISAS_OPCODES_COL),
            copy_comment: lambda: copy_to_clipboard(selected_row, DISAS_COMMENT_COL),
            copy_all: lambda: copy_all_columns(selected_row),
        }
        try:
            actions[action]()
        except KeyError:
            pass
        if action in bookmark_actions:
            self.disassemble_expression(utils.extract_hex_address(action.text()))

    def dissect_current_region(self):
        if debugcore.currentpid == -1:
            return
        selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        if selected_row == -1:
            selected_row = 0
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        dissect_code_dialog = DissectCodeDialogForm(self, safe_str_to_int(current_address, 16))
        dissect_code_dialog.scan_finished_signal.connect(dissect_code_dialog.accept)
        dissect_code_dialog.exec()
        self.refresh_disassemble_view()

    def exec_examine_referrers_widget(self, current_address_text):
        if debugcore.currentpid == -1:
            return
        if not guiutils.contains_reference_mark(current_address_text):
            return
        current_address = utils.extract_hex_address(current_address_text)
        current_address_int = safe_str_to_int(current_address, 16)
        examine_referrers_widget = ExamineReferrersWidgetForm(self, current_address_int)
        examine_referrers_widget.show()

    def exec_trace_instructions_dialog(self):
        if debugcore.currentpid == -1:
            return
        selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        if selected_row == -1:
            selected_row = 0
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        TraceInstructionsWindowForm(self, current_address)

    def exec_track_breakpoint_dialog(self):
        if debugcore.currentpid == -1:
            return
        selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        current_instruction = self.tableWidget_Disassemble.item(selected_row, DISAS_OPCODES_COL).text()
        register_expression_dialog = utilwidgets.InputDialog(self, [(tr.ENTER_TRACK_BP_EXPRESSION, "")])
        if register_expression_dialog.exec():
            exp = register_expression_dialog.get_values()[0]
            TrackBreakpointWidgetForm(self, current_address, current_instruction, exp)

    def exec_disassemble_go_to_dialog(self):
        if debugcore.currentpid == -1:
            return
        selected_row = guiutils.get_current_row(self.tableWidget_Disassemble)
        if selected_row == -1:
            selected_row = 0
        current_address_text = self.tableWidget_Disassemble.item(selected_row, DISAS_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)

        go_to_dialog = utilwidgets.InputDialog(self, [(tr.ENTER_EXPRESSION, current_address)])
        if go_to_dialog.exec():
            traveled_exp = go_to_dialog.get_values()[0]
            self.disassemble_expression(traveled_exp)

    def bookmark_address(self, address: int):
        if debugcore.currentpid == -1:
            return
        if address in self.session.pct_bookmarks:
            QMessageBox.information(app.focusWidget(), tr.ERROR, tr.ALREADY_BOOKMARKED)
            return
        comment_dialog = utilwidgets.InputDialog(self, [(tr.ENTER_BOOKMARK_COMMENT, "")])
        if comment_dialog.exec():
            comment_data = comment_dialog.get_values()
            comment = comment_data[0] if comment_data else ""
        else:
            return
        exam_result = debugcore.examine_expression(hex(address))
        symbol = utils.extract_symbol_name(exam_result.symbol) if exam_result.symbol else ""

        region_info = utils.get_region_info(debugcore.currentpid, address)

        if not region_info:
            logger.error("Address does not belong to any mapped region, aborting")
            return

        if region_info.file_name == "[heap]" or region_info.file_name == "[stack]":
            logger.warning("Address belongs to the heap or stack, cannot bookmark")
            return

        address_region_details = {
            "region_name": region_info.file_name,
            "offset_in_region": hex(address - region_info.start),
            "region_index": region_info.region_index,
        }
        self.session.pct_bookmarks[address] = {
            "symbol": symbol,
            "comment": comment,
            "address_region_details": address_region_details,
        }
        logger.info(self.session.pct_bookmarks)
        self.refresh_disassemble_view()

    def change_bookmark_comment(self, address: int):
        if debugcore.currentpid == -1:
            return
        current_comment = self.session.pct_bookmarks[address]["comment"]
        comment_dialog = utilwidgets.InputDialog(self, [(tr.ENTER_BOOKMARK_COMMENT, current_comment)])
        if comment_dialog.exec():
            new_comment = comment_dialog.get_values()[0]
        else:
            return
        self.session.pct_bookmarks[address]["comment"] = new_comment
        self.refresh_disassemble_view()

    def delete_bookmark(self, address: int):
        if debugcore.currentpid == -1:
            return
        if address in self.session.pct_bookmarks:
            del self.session.pct_bookmarks[address]
            self.refresh_disassemble_view()

    def actionBookmarks_triggered(self):
        bookmark_widget = BookmarkWidget(self)
        bookmark_widget.bookmarked.connect(self.bookmark_address)
        bookmark_widget.comment_changed.connect(self.change_bookmark_comment)
        bookmark_widget.double_clicked.connect(self.disassemble_expression)
        bookmark_widget.deleted.connect(self.delete_bookmark)
        bookmark_widget.show()
        bookmark_widget.activateWindow()

    def actionStackTrace_Info_triggered(self):
        if debugcore.currentpid == -1:
            return
        self.stacktrace_info_widget.update_stacktrace()
        guiutils.center_to_parent(self.stacktrace_info_widget)
        self.stacktrace_info_widget.show()
        self.stacktrace_info_widget.activateWindow()

    def actionBreakpoints_triggered(self):
        if debugcore.currentpid == -1:
            return
        breakpoint_widget = BreakpointInfoWidgetForm(self)
        breakpoint_widget.show()
        breakpoint_widget.activateWindow()

    def actionFunctions_triggered(self):
        if debugcore.currentpid == -1:
            return
        functions_info_widget = FunctionsInfoWidgetForm(self)
        functions_info_widget.show()

    def actionGDB_Log_File_triggered(self):
        log_file_widget = LogFileWidgetForm(self)
        log_file_widget.showMaximized()

    def actionMemory_Regions_triggered(self):
        if debugcore.currentpid == -1:
            return
        memory_regions_widget = MemoryRegionsWidgetForm(self)
        memory_regions_widget.show()

    def actionRestore_Instructions_triggered(self):
        if debugcore.currentpid == -1:
            return
        restore_instructions_widget = RestoreInstructionsWidget(self)
        restore_instructions_widget.restored.connect(self.refresh_hex_view)
        restore_instructions_widget.restored.connect(self.refresh_disassemble_view)
        restore_instructions_widget.double_clicked.connect(self.disassemble_expression)
        restore_instructions_widget.show()
        restore_instructions_widget.activateWindow()

    def actionReferenced_Strings_triggered(self):
        if debugcore.currentpid == -1:
            return
        ref_str_widget = ReferencedStringsWidgetForm(self)
        ref_str_widget.show()

    def actionReferenced_Calls_triggered(self):
        if debugcore.currentpid == -1:
            return
        ref_call_widget = ReferencedCallsWidgetForm(self)
        ref_call_widget.show()

    def actionInject_so_file_triggered(self):
        if debugcore.currentpid == -1:
            return
        file_path, _ = QFileDialog.getOpenFileName(self, tr.SELECT_SO_FILE, "", tr.SHARED_OBJECT_TYPE)
        if file_path:
            if debugcore.inject_with_dlopen_call(file_path):
                QMessageBox.information(self, tr.SUCCESS, tr.FILE_INJECTED)
            else:
                QMessageBox.information(self, tr.ERROR, tr.FILE_INJECT_FAILED)

    def actionCall_Function_triggered(self):
        if debugcore.currentpid == -1:
            return
        call_dialog = utilwidgets.InputDialog(self, [(tr.ENTER_CALL_EXPRESSION, "")])
        if call_dialog.exec():
            result = debugcore.call_function_from_inferior(call_dialog.get_values()[0])
            if result[0]:
                QMessageBox.information(self, tr.SUCCESS, result[0] + " = " + result[1])
            else:
                QMessageBox.information(self, tr.ERROR, tr.CALL_EXPRESSION_FAILED.format(call_dialog.get_values()))

    def actionSearch_Opcode_triggered(self):
        if debugcore.currentpid == -1:
            return
        start_address = safe_str_to_int(self.disassemble_currently_displayed_address, 16)
        end_address = start_address + 0x30000
        search_opcode_widget = SearchOpcodeWidgetForm(self, hex(start_address), hex(end_address))
        search_opcode_widget.show()

    def actionDissect_Code_triggered(self):
        if debugcore.currentpid == -1:
            return
        dissect_code_dialog = DissectCodeDialogForm(self)
        dissect_code_dialog.exec()
        self.refresh_disassemble_view()

    def actionLibpince_Engine_triggered(self):
        libpince_engine_window = LibpinceEngineWindow(self)
        libpince_engine_window.show()
        libpince_engine_window.activateWindow()

    def actionLibpince_triggered(self):
        utils.execute_command_as_user('python3 -m webbrowser "https://korcankaraokcu.github.io/PINCE/"')

    def pushButton_ShowFloatRegisters_clicked(self):
        if guiutils.check_inferior_running(self):
            return
        self.float_registers_widget.update_registers()
        guiutils.center_to_parent(self.float_registers_widget)
        self.float_registers_widget.show()
        self.float_registers_widget.activateWindow()

    def on_new_session(self):
        self.session = SessionManager.get_session()


class FloatRegisterWidgetForm(QTabWidget, FloatRegisterWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.tableWidget_FPU.itemDoubleClicked.connect(self.set_register)
        self.tableWidget_XMM.itemDoubleClicked.connect(self.set_register)

    def update_registers(self):
        self.tableWidget_FPU.setRowCount(0)
        self.tableWidget_FPU.setRowCount(8)
        self.tableWidget_XMM.setRowCount(0)
        self.tableWidget_XMM.setRowCount(16)
        float_registers = list(debugcore.read_float_registers().items())
        st_registers = float_registers[:8]
        xmm_registers = float_registers[8:]
        for row, (name, value) in enumerate(st_registers):
            self.tableWidget_FPU.setItem(row, FLOAT_REGISTERS_NAME_COL, QTableWidgetItem(name))
            self.tableWidget_FPU.setItem(row, FLOAT_REGISTERS_VALUE_COL, QTableWidgetItem(value))
        for row, (name, value) in enumerate(xmm_registers):
            self.tableWidget_XMM.setItem(row, FLOAT_REGISTERS_NAME_COL, QTableWidgetItem(name))
            self.tableWidget_XMM.setItem(row, FLOAT_REGISTERS_VALUE_COL, QTableWidgetItem(value))

    def set_register(self, index):
        if guiutils.check_inferior_running(self):
            return
        current_row = index.row()
        if self.currentWidget() == self.FPU:
            current_table_widget = self.tableWidget_FPU
        elif self.currentWidget() == self.XMM:
            current_table_widget = self.tableWidget_XMM
        else:
            raise Exception("Current widget is invalid: " + str(self.currentWidget().objectName()))
        current_register = current_table_widget.item(current_row, FLOAT_REGISTERS_NAME_COL).text()
        current_value = current_table_widget.item(current_row, FLOAT_REGISTERS_VALUE_COL).text()
        label_text = tr.ENTER_REGISTER_VALUE.format(current_register.upper())
        register_dialog = utilwidgets.InputDialog(self, [(label_text, current_value)])
        if register_dialog.exec():
            if guiutils.check_inferior_running(self):
                return
            if self.currentWidget() == self.XMM:
                current_register += ".v4_float"
            debugcore.set_convenience_variable(current_register, register_dialog.get_values()[0])
            self.update_registers()


class StackTraceInfoWidgetForm(QWidget, StackTraceInfoWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.listWidget_ReturnAddresses.currentRowChanged.connect(self.update_frame_info)

    def update_stacktrace(self):
        self.listWidget_ReturnAddresses.clear()
        self.textBrowser_Info.clear()
        error_message = guiutils.check_inferior_running(self, show_message=False)
        if error_message:
            self.textBrowser_Info.setText(error_message)
            return
        return_addresses = debugcore.get_stack_frame_return_addresses()
        self.listWidget_ReturnAddresses.addItems(return_addresses)

    def update_frame_info(self, index):
        self.textBrowser_Info.clear()
        error_message = guiutils.check_inferior_running(self, show_message=False)
        if error_message:
            self.textBrowser_Info.setText(error_message)
            return
        frame_info = debugcore.get_stack_frame_info(index)
        self.textBrowser_Info.setText(frame_info)


class BreakpointInfoWidgetForm(QTabWidget, BreakpointInfoWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.tableWidget_BreakpointInfo.contextMenuEvent = self.tableWidget_BreakpointInfo_context_menu_event

        # Saving the original function because super() doesn't work when we override functions like this
        self.tableWidget_BreakpointInfo.keyPressEvent_original = self.tableWidget_BreakpointInfo.keyPressEvent
        self.tableWidget_BreakpointInfo.keyPressEvent = self.tableWidget_BreakpointInfo_key_press_event
        self.tableWidget_BreakpointInfo.itemDoubleClicked.connect(self.tableWidget_BreakpointInfo_double_clicked)
        self.refresh()
        guiutils.center_to_parent(self)

    def refresh(self):
        break_info = debugcore.get_breakpoint_info()
        self.tableWidget_BreakpointInfo.setRowCount(0)
        self.tableWidget_BreakpointInfo.setRowCount(len(break_info))
        for row, item in enumerate(break_info):
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_NUM_COL, QTableWidgetItem(item.number))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_TYPE_COL, QTableWidgetItem(item.breakpoint_type))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_DISP_COL, QTableWidgetItem(item.disp))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_ENABLED_COL, QTableWidgetItem(item.enabled))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_ADDR_COL, QTableWidgetItem(item.address))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_SIZE_COL, QTableWidgetItem(str(item.size)))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_ON_HIT_COL, QTableWidgetItem(item.on_hit))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_HIT_COUNT_COL, QTableWidgetItem(item.hit_count))
            self.tableWidget_BreakpointInfo.setItem(row, BREAK_COND_COL, QTableWidgetItem(item.condition))
        guiutils.resize_to_contents(self.tableWidget_BreakpointInfo)
        self.textBrowser_BreakpointInfo.clear()
        self.textBrowser_BreakpointInfo.setText(debugcore.send_command("info break", cli_output=True))

    def delete_breakpoint(self, breakpoint_num):
        if breakpoint_num is not None:
            debugcore.delete_breakpoint(breakpoint_num)
            self.refresh_all()

    def tableWidget_BreakpointInfo_key_press_event(self, event):
        selected_row = guiutils.get_current_row(self.tableWidget_BreakpointInfo)
        if selected_row != -1:
            breakpoint_num = safe_int_cast(self.tableWidget_BreakpointInfo.item(selected_row, BREAK_ADDR_COL).text())
        else:
            breakpoint_num = None

        actions = typedefs.KeyboardModifiersTupleDict(
            [
                (
                    QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_Delete),
                    lambda: self.delete_breakpoint(breakpoint_num),
                ),
                (QKeyCombination(Qt.KeyboardModifier.NoModifier, Qt.Key.Key_R), self.refresh),
            ]
        )
        try:
            actions[QKeyCombination(event.modifiers(), Qt.Key(event.key()))]()
        except KeyError:
            pass
        self.tableWidget_BreakpointInfo.keyPressEvent_original(event)

    def exec_enable_count_dialog(self, breakpoint_number):
        hit_count_dialog = utilwidgets.InputDialog(self, [(tr.ENTER_HIT_COUNT.format(1), "")])
        if hit_count_dialog.exec():
            count = hit_count_dialog.get_values()[0]
            try:
                count = int(count)
            except ValueError:
                QMessageBox.information(self, tr.ERROR, tr.HIT_COUNT_ASSERT_INT)
            else:
                if count < 1:
                    QMessageBox.information(self, tr.ERROR, tr.HIT_COUNT_ASSERT_LT.format(1))
                else:
                    debugcore.modify_breakpoint(breakpoint_number, typedefs.BREAKPOINT_MODIFY.ENABLE_COUNT, count=count)

    def tableWidget_BreakpointInfo_context_menu_event(self, event):
        selected_row = guiutils.get_current_row(self.tableWidget_BreakpointInfo)
        if selected_row != -1:
            bp_num = safe_int_cast(self.tableWidget_BreakpointInfo.item(selected_row, BREAK_NUM_COL).text())
            current_address_text = self.tableWidget_BreakpointInfo.item(selected_row, BREAK_ADDR_COL).text()
            current_address = utils.extract_hex_address(current_address_text)
            if current_address:
                current_address_int = safe_str_to_int(current_address, 16)
            else:
                current_address_int = None
        else:
            bp_num = None
            current_address_int = None

        menu = QMenu()
        change_condition = menu.addAction(tr.CHANGE_CONDITION)
        enable = menu.addAction(tr.ENABLE)
        disable = menu.addAction(tr.DISABLE)
        enable_once = menu.addAction(tr.DISABLE_AFTER_HIT)
        enable_count = menu.addAction(tr.DISABLE_AFTER_COUNT)
        enable_delete = menu.addAction(tr.DELETE_AFTER_HIT)
        menu.addSeparator()
        delete_breakpoint = menu.addAction(f"{tr.DELETE}[Del]")
        menu.addSeparator()
        if bp_num is None:
            deletion_list = [
                change_condition,
                enable,
                disable,
                enable_once,
                enable_count,
                enable_delete,
                delete_breakpoint,
            ]
            guiutils.delete_menu_entries(menu, deletion_list)
        if current_address_int is None:
            deletion_list = [
                change_condition,
            ]
            guiutils.delete_menu_entries(menu, deletion_list)
        refresh = menu.addAction(f"{tr.REFRESH}[R]")
        font_size = self.tableWidget_BreakpointInfo.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            change_condition: lambda: self.parent().add_breakpoint_condition(current_address_int),
            enable: lambda: debugcore.modify_breakpoint(bp_num, typedefs.BREAKPOINT_MODIFY.ENABLE),
            disable: lambda: debugcore.modify_breakpoint(bp_num, typedefs.BREAKPOINT_MODIFY.DISABLE),
            enable_once: lambda: debugcore.modify_breakpoint(bp_num, typedefs.BREAKPOINT_MODIFY.ENABLE_ONCE),
            enable_count: lambda: self.exec_enable_count_dialog(bp_num),
            enable_delete: lambda: debugcore.modify_breakpoint(bp_num, typedefs.BREAKPOINT_MODIFY.ENABLE_DELETE),
            delete_breakpoint: lambda: debugcore.delete_breakpoint(bp_num),
            refresh: self.refresh,
        }
        try:
            actions[action]()
        except KeyError:
            pass
        if action != -1 and action is not None:
            self.refresh_all()

    def refresh_all(self):
        self.parent().refresh_hex_view()
        self.parent().refresh_disassemble_view()
        self.refresh()

    def tableWidget_BreakpointInfo_double_clicked(self, index):
        current_address_text = self.tableWidget_BreakpointInfo.item(index.row(), BREAK_ADDR_COL).text()
        current_address = utils.extract_hex_address(current_address_text)
        if current_address is None:
            # Catchpoints won't have an address, we don't need to change conditions or hex_dump
            return
        current_address_int = safe_str_to_int(current_address, 16)

        if index.column() == BREAK_COND_COL:
            self.parent().add_breakpoint_condition(current_address_int)
            self.refresh_all()
        else:
            current_breakpoint_type = self.tableWidget_BreakpointInfo.item(index.row(), BREAK_TYPE_COL).text()
            if "breakpoint" in current_breakpoint_type:
                self.parent().disassemble_expression(current_address)
            else:
                self.parent().hex_dump_address(current_address_int)


class TrackWatchpointWidgetForm(QWidget, TrackWatchpointWidget):
    def __init__(self, parent, address, length, watchpoint_type):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.update_timer = QTimer(timeout=self.update_list)
        self.stopped = False
        self.address = address
        self.info = {}
        self.last_selected_row = 0
        if watchpoint_type == typedefs.WATCHPOINT_TYPE.WRITE_ONLY:
            string = tr.OPCODE_WRITING_TO.format(address)
        elif watchpoint_type == typedefs.WATCHPOINT_TYPE.READ_ONLY:
            string = tr.OPCODE_READING_FROM.format(address)
        elif watchpoint_type == typedefs.WATCHPOINT_TYPE.BOTH:
            string = tr.OPCODE_ACCESSING_TO.format(address)
        else:
            raise Exception("Watchpoint type is invalid: " + str(watchpoint_type))
        self.setWindowTitle(string)
        guiutils.center_to_parent(self)  # Called before the QMessageBox to center its position properly
        self.breakpoints = debugcore.track_watchpoint(address, length, watchpoint_type)
        if not self.breakpoints:
            QMessageBox.information(self, tr.ERROR, tr.TRACK_WATCHPOINT_FAILED.format(address))
            self.close()
            return
        self.pushButton_Stop.clicked.connect(self.pushButton_Stop_clicked)
        self.pushButton_Refresh.clicked.connect(self.update_list)
        self.tableWidget_Opcodes.itemDoubleClicked.connect(self.tableWidget_Opcodes_item_double_clicked)
        self.tableWidget_Opcodes.selectionModel().currentChanged.connect(self.tableWidget_Opcodes_current_changed)
        self.update_timer.start(100)
        self.show()

    def update_list(self):
        info = debugcore.get_track_watchpoint_info(self.breakpoints)
        if not info or self.info == info:
            return
        self.info = info
        self.tableWidget_Opcodes.setRowCount(0)
        self.tableWidget_Opcodes.setRowCount(len(info))
        for row, key in enumerate(info):
            self.tableWidget_Opcodes.setItem(row, TRACK_WATCHPOINT_COUNT_COL, QTableWidgetItem(str(info[key][0])))
            self.tableWidget_Opcodes.setItem(row, TRACK_WATCHPOINT_ADDR_COL, QTableWidgetItem(info[key][1]))
        guiutils.resize_to_contents(self.tableWidget_Opcodes)
        self.tableWidget_Opcodes.selectRow(self.last_selected_row)

    def tableWidget_Opcodes_current_changed(self, QModelIndex_current):
        current_row = QModelIndex_current.row()
        if current_row >= 0:
            self.last_selected_row = current_row

        info = self.info
        key_list = list(info)
        key = key_list[self.last_selected_row]
        self.textBrowser_Info.clear()
        for item in info[key][2]:
            self.textBrowser_Info.append(item + "=" + info[key][2][item])
        self.textBrowser_Info.append(" ")
        for item in info[key][3]:
            self.textBrowser_Info.append(item + "=" + info[key][3][item])
        self.textBrowser_Info.verticalScrollBar().setValue(self.textBrowser_Info.verticalScrollBar().minimum())
        self.textBrowser_Disassemble.setPlainText(info[key][4])

    def tableWidget_Opcodes_item_double_clicked(self, index):
        self.parent().memory_view_window.disassemble_expression(
            self.tableWidget_Opcodes.item(index.row(), TRACK_WATCHPOINT_ADDR_COL).text()
        )
        self.parent().memory_view_window.show()
        self.parent().memory_view_window.activateWindow()

    def pushButton_Stop_clicked(self):
        if self.stopped:
            self.close()
            return
        # Internal chained breakpoints check will delete the rest from self.breakpoints
        if not debugcore.delete_breakpoint(safe_int_cast(self.breakpoints[0])):
            QMessageBox.information(self, tr.ERROR, tr.DELETE_WATCHPOINT_FAILED.format(self.address))
            return
        self.stopped = True
        self.pushButton_Stop.setText(tr.CLOSE)

    def closeEvent(self, event: QCloseEvent):
        self.update_timer.stop()
        if self.breakpoints:
            if not self.stopped:
                # Internal chained breakpoints check will delete the rest from self.breakpoints
                debugcore.delete_breakpoint(safe_int_cast(self.breakpoints[0]))
            watchpoint_file = utils.get_track_watchpoint_file(debugcore.currentpid, self.breakpoints)
            if os.path.exists(watchpoint_file):
                os.remove(watchpoint_file)
        super().closeEvent(event)


class TrackBreakpointWidgetForm(QWidget, TrackBreakpointWidget):
    def __init__(self, parent, address, instruction, register_expressions):
        super().__init__(parent)
        self.setupUi(self)
        self.update_list_timer = QTimer(timeout=self.update_list)
        self.update_values_timer = QTimer(timeout=self.update_values)
        self.stopped = False
        self.address = address
        self.info = {}
        self.last_selected_row = 0
        self.setWindowFlags(Qt.WindowType.Window)
        self.setWindowTitle(tr.ACCESSED_BY_INSTRUCTION.format(instruction))
        guiutils.center_to_parent(self)  # Called before the QMessageBox to center its position properly
        self.breakpoint = debugcore.track_breakpoint(address, register_expressions)
        if not self.breakpoint:
            QMessageBox.information(self, tr.ERROR, tr.TRACK_BREAKPOINT_FAILED.format(address))
            self.close()
            return
        guiutils.fill_value_combobox(self.comboBox_ValueType)
        self.pushButton_Stop.clicked.connect(self.pushButton_Stop_clicked)
        self.tableWidget_TrackInfo.itemDoubleClicked.connect(self.tableWidget_TrackInfo_item_double_clicked)
        self.tableWidget_TrackInfo.selectionModel().currentChanged.connect(self.tableWidget_TrackInfo_current_changed)
        self.comboBox_ValueType.currentIndexChanged.connect(self.update_values)
        self.update_list_timer.start(100)
        self.update_values_timer.start(500)
        self.parent().refresh_disassemble_view()
        self.show()

    def update_list(self):
        info = debugcore.get_track_breakpoint_info(self.breakpoint)
        if not info:
            return
        if info == self.info:
            return
        self.info = info
        self.tableWidget_TrackInfo.setRowCount(0)
        for register_expression in info:
            for row, address in enumerate(info[register_expression]):
                self.tableWidget_TrackInfo.setRowCount(self.tableWidget_TrackInfo.rowCount() + 1)
                self.tableWidget_TrackInfo.setItem(
                    row, TRACK_BREAKPOINT_COUNT_COL, QTableWidgetItem(str(info[register_expression][address]))
                )
                self.tableWidget_TrackInfo.setItem(row, TRACK_BREAKPOINT_ADDR_COL, QTableWidgetItem(address))
                self.tableWidget_TrackInfo.setItem(
                    row, TRACK_BREAKPOINT_SOURCE_COL, QTableWidgetItem("[" + register_expression + "]")
                )
        self.update_values()

    def update_values(self):
        mem_handle = debugcore.memory_handle()
        value_type = self.comboBox_ValueType.currentIndex()
        for row in range(self.tableWidget_TrackInfo.rowCount()):
            address = self.tableWidget_TrackInfo.item(row, TRACK_BREAKPOINT_ADDR_COL).text()
            value = debugcore.read_memory(address, value_type, 10, mem_handle=mem_handle)
            value = "" if value is None else str(value)
            self.tableWidget_TrackInfo.setItem(row, TRACK_BREAKPOINT_VALUE_COL, QTableWidgetItem(value))
        guiutils.resize_to_contents(self.tableWidget_TrackInfo)
        self.tableWidget_TrackInfo.selectRow(self.last_selected_row)

    def tableWidget_TrackInfo_current_changed(self, QModelIndex_current):
        current_row = QModelIndex_current.row()
        if current_row >= 0:
            self.last_selected_row = current_row

    def tableWidget_TrackInfo_item_double_clicked(self, index):
        address = self.tableWidget_TrackInfo.item(index.row(), TRACK_BREAKPOINT_ADDR_COL).text()
        vt = typedefs.ValueType(self.comboBox_ValueType.currentIndex())
        self.parent().parent().add_entry_to_addresstable(tr.ACCESSED_BY.format(self.address), address, vt)
        self.parent().parent().update_address_table()

    def pushButton_Stop_clicked(self):
        if self.stopped:
            self.close()
            return
        if not debugcore.delete_breakpoint(safe_int_cast(self.breakpoint)):
            QMessageBox.information(self, tr.ERROR, tr.DELETE_BREAKPOINT_FAILED.format(self.address))
            return
        self.stopped = True
        self.pushButton_Stop.setText(tr.CLOSE)
        self.parent().refresh_disassemble_view()

    def closeEvent(self, event: QCloseEvent):
        self.update_list_timer.stop()
        self.update_values_timer.stop()
        if self.breakpoint:
            if not self.stopped:
                debugcore.delete_breakpoint(safe_int_cast(self.breakpoint))
            breakpoint_file = utils.get_track_breakpoint_file(debugcore.currentpid, self.breakpoint)
            if os.path.exists(breakpoint_file):
                os.remove(breakpoint_file)
        self.parent().refresh_disassemble_view()
        super().closeEvent(event)


class TraceInstructionsPromptDialogForm(QDialog, TraceInstructionsPromptDialog):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        guiutils.center_to_parent(self)

    def get_values(self):
        max_trace_count = int(self.lineEdit_MaxTraceCount.text())
        trigger_condition = self.lineEdit_TriggerCondition.text()
        stop_condition = self.lineEdit_StopCondition.text()
        if self.checkBox_StepOver.isChecked():
            step_mode = typedefs.STEP_MODE.STEP_OVER
        else:
            step_mode = typedefs.STEP_MODE.SINGLE_STEP
        stop_after_trace = self.checkBox_StopAfterTrace.isChecked()
        collect_registers = self.checkBox_CollectRegisters.isChecked()
        return max_trace_count, trigger_condition, stop_condition, step_mode, stop_after_trace, collect_registers

    def accept(self):
        if int(self.lineEdit_MaxTraceCount.text()) >= 1:
            super().accept()
        else:
            QMessageBox.information(self, tr.ERROR, tr.MAX_TRACE_COUNT_ASSERT_GT.format(1))


class TraceInstructionsWaitWidgetForm(QWidget, TraceInstructionsWaitWidget):
    widget_closed = pyqtSignal()

    def __init__(self, parent, address: str, tracer: debugcore.Tracer):
        super().__init__(parent)
        self.setupUi(self)
        self.status_to_text = {
            typedefs.TRACE_STATUS.IDLE: tr.WAITING_FOR_BREAKPOINT,
            typedefs.TRACE_STATUS.FINISHED: tr.TRACING_COMPLETED,
        }
        self.setWindowFlags(Qt.WindowType.Window)
        self.address = address
        self.tracer = tracer
        media_directory = utils.get_media_directory()
        self.movie = QMovie(media_directory + "/TraceInstructionsWaitWidget/ajax-loader.gif", QByteArray())
        self.label_Animated.setMovie(self.movie)
        self.movie.setScaledSize(QSize(215, 100))
        self.movie.setCacheMode(QMovie.CacheMode.CacheAll)
        self.movie.setSpeed(100)
        self.movie.start()
        self.pushButton_Cancel.clicked.connect(self.close)
        tracer_thread = guitypedefs.Worker(tracer.tracer_loop)
        tracer_thread.signals.finished.connect(self.close)
        states.threadpool.start(tracer_thread)
        self.status_timer = QTimer()
        self.status_timer.setInterval(50)
        self.status_timer.timeout.connect(self.change_status)
        self.status_timer.start()
        guiutils.center_to_parent(self)

    def change_status(self):
        if self.tracer.trace_status == typedefs.TRACE_STATUS.TRACING:
            self.label_StatusText.setText(f"{self.tracer.current_trace_count} / {self.tracer.max_trace_count}")
        else:
            self.label_StatusText.setText(self.status_to_text[self.tracer.trace_status])
        app.processEvents()

    def closeEvent(self, event: QCloseEvent):
        self.status_timer.stop()
        self.label_StatusText.setText(tr.TRACING_COMPLETED)
        self.pushButton_Cancel.setVisible(False)
        self.adjustSize()
        app.processEvents()
        if self.tracer.trace_status == typedefs.TRACE_STATUS.TRACING:
            self.tracer.cancel_trace()
            while self.tracer.trace_status != typedefs.TRACE_STATUS.FINISHED:
                sleep(0.1)
                app.processEvents()
        self.widget_closed.emit()
        super().closeEvent(event)


class TraceInstructionsWindowForm(QMainWindow, TraceInstructionsWindow):
    def __init__(self, parent, address="", prompt_dialog=True):
        super().__init__(parent)
        self.setupUi(self)
        self.address = address
        self.tracer = debugcore.Tracer()
        self.treeWidget_InstructionInfo.currentItemChanged.connect(self.display_collected_data)
        self.treeWidget_InstructionInfo.itemDoubleClicked.connect(self.treeWidget_InstructionInfo_item_double_clicked)
        self.treeWidget_InstructionInfo.contextMenuEvent = self.treeWidget_InstructionInfo_context_menu_event
        self.actionOpen.triggered.connect(self.load_file)
        self.actionSave.triggered.connect(self.save_file)
        self.splitter.setStretchFactor(0, 1)
        guiutils.center_to_parent(self)
        if not prompt_dialog:
            self.showMaximized()
            return
        prompt_dialog = TraceInstructionsPromptDialogForm(self)
        if prompt_dialog.exec():
            params = (address,) + prompt_dialog.get_values()
            breakpoint = self.tracer.set_breakpoint(*params)
            if not breakpoint:
                QMessageBox.information(self, tr.ERROR, tr.BREAKPOINT_FAILED.format(address))
                self.close()
                return
            self.showMaximized()
            self.wait_dialog = TraceInstructionsWaitWidgetForm(self, address, self.tracer)
            self.wait_dialog.widget_closed.connect(self.show_trace_info)
            self.wait_dialog.show()
        else:
            self.close()

    def display_collected_data(self, QTreeWidgetItem_current):
        self.textBrowser_RegisterInfo.clear()
        current_dict = QTreeWidgetItem_current.trace_data[1]
        if current_dict:
            for key in current_dict:
                self.textBrowser_RegisterInfo.append(str(key) + " = " + str(current_dict[key]))
            self.textBrowser_RegisterInfo.verticalScrollBar().setValue(
                self.textBrowser_RegisterInfo.verticalScrollBar().minimum()
            )

    def show_trace_info(self):
        self.treeWidget_InstructionInfo.setStyleSheet("QTreeWidget::item{ height: 16px; }")
        parent = QTreeWidgetItem(self.treeWidget_InstructionInfo)
        self.treeWidget_InstructionInfo.setRootIndex(self.treeWidget_InstructionInfo.indexFromItem(parent))
        trace_tree, current_root_index = copy.deepcopy(self.tracer.trace_data)
        while current_root_index is not None:
            try:
                current_index = trace_tree[current_root_index][2][0]  # Get the first child
                current_item = trace_tree[current_index][0]
                del trace_tree[current_root_index][2][0]  # Delete it
            except IndexError:  # We've depleted the children
                current_root_index = trace_tree[current_root_index][1]  # traverse upwards
                parent = parent.parent()
                continue
            child = QTreeWidgetItem(parent)
            child.trace_data = current_item
            child.setText(0, current_item[0])
            if trace_tree[current_index][2]:  # If current item has children, traverse them
                current_root_index = current_index  # traverse downwards
                parent = child
        self.treeWidget_InstructionInfo.expandAll()

    def save_file(self):
        file_path, _ = QFileDialog.getSaveFileName(self, tr.SAVE_TRACE_FILE, None, tr.FILE_TYPES_TRACE)
        if file_path:
            file_path = utils.append_file_extension(file_path, "trace")
            if not utils.save_file(self.tracer.trace_data, file_path):
                QMessageBox.information(self, tr.ERROR, tr.FILE_SAVE_ERROR)

    def load_file(self):
        file_path, _ = QFileDialog.getOpenFileName(self, tr.OPEN_TRACE_FILE, None, tr.FILE_TYPES_TRACE)
        if file_path:
            content = utils.load_file(file_path)
            if content is None:
                QMessageBox.information(self, tr.ERROR, tr.FILE_LOAD_ERROR.format(file_path))
                return
            self.treeWidget_InstructionInfo.clear()
            self.tracer.trace_data = content
            self.show_trace_info()

    def treeWidget_InstructionInfo_context_menu_event(self, event):
        menu = QMenu()
        expand_all = menu.addAction(tr.EXPAND_ALL)
        collapse_all = menu.addAction(tr.COLLAPSE_ALL)
        font_size = self.treeWidget_InstructionInfo.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            expand_all: self.treeWidget_InstructionInfo.expandAll,
            collapse_all: self.treeWidget_InstructionInfo.collapseAll,
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def treeWidget_InstructionInfo_item_double_clicked(self, index):
        current_item = guiutils.get_current_item(self.treeWidget_InstructionInfo)
        if not current_item:
            return
        address = utils.extract_hex_address(current_item.trace_data[0])
        if address:
            self.parent().disassemble_expression(address)


class FunctionsInfoWidgetForm(QWidget, FunctionsInfoWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.textBrowser_AddressInfo.setFixedHeight(100)
        self.pushButton_Search.clicked.connect(self.refresh_table)
        self.shortcut_search = QShortcut(QKeySequence("Return"), self)
        self.shortcut_search.activated.connect(self.refresh_table)
        self.tableWidget_SymbolInfo.selectionModel().currentChanged.connect(self.tableWidget_SymbolInfo_current_changed)
        self.tableWidget_SymbolInfo.itemDoubleClicked.connect(self.tableWidget_SymbolInfo_item_double_clicked)
        self.tableWidget_SymbolInfo.contextMenuEvent = self.tableWidget_SymbolInfo_context_menu_event
        icons_directory = guiutils.get_icons_directory()
        self.pushButton_Help.setIcon(QIcon(QPixmap(icons_directory + "/help.png")))
        self.pushButton_Help.clicked.connect(self.pushButton_Help_clicked)
        guiutils.center_to_parent(self)

    def refresh_table(self):
        input_text = self.lineEdit_SearchInput.text()
        case_sensitive = self.checkBox_CaseSensitive.isChecked()
        self.loading_dialog = LoadingDialogForm(self)
        self.background_thread = self.loading_dialog.background_thread
        self.background_thread.overrided_func = lambda: self.process_data(input_text, case_sensitive)
        self.background_thread.output_ready.connect(self.apply_data)
        self.loading_dialog.exec()

    def process_data(self, gdb_input, case_sensitive):
        return debugcore.search_functions(gdb_input, case_sensitive)

    def apply_data(self, output):
        self.tableWidget_SymbolInfo.setSortingEnabled(False)
        self.tableWidget_SymbolInfo.setRowCount(0)
        self.tableWidget_SymbolInfo.setRowCount(len(output))
        defined_color = QColor(QColorConstants.Green)
        defined_color.setAlpha(96)
        for row, item in enumerate(output):
            address = item[0]
            if address:
                address_item = QTableWidgetItem(address)
            else:
                address_item = QTableWidgetItem(tr.DEFINED)
                address_item.setBackground(defined_color)
            self.tableWidget_SymbolInfo.setItem(row, FUNCTIONS_INFO_ADDR_COL, address_item)
            self.tableWidget_SymbolInfo.setItem(row, FUNCTIONS_INFO_SYMBOL_COL, QTableWidgetItem(item[1]))
        self.tableWidget_SymbolInfo.setSortingEnabled(True)
        guiutils.resize_to_contents(self.tableWidget_SymbolInfo)

    def tableWidget_SymbolInfo_current_changed(self, QModelIndex_current):
        self.textBrowser_AddressInfo.clear()
        current_row = QModelIndex_current.row()
        if current_row < 0:
            return
        address = self.tableWidget_SymbolInfo.item(current_row, FUNCTIONS_INFO_ADDR_COL).text()
        if utils.extract_hex_address(address):
            symbol = self.tableWidget_SymbolInfo.item(current_row, FUNCTIONS_INFO_SYMBOL_COL).text()
            for item in utils.split_symbol(symbol):
                info = debugcore.get_symbol_info(item)
                self.textBrowser_AddressInfo.append(info)
        else:
            self.textBrowser_AddressInfo.append(tr.DEFINED_SYMBOL)

    def tableWidget_SymbolInfo_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_SymbolInfo.item(row, column).text())

        selected_row = guiutils.get_current_row(self.tableWidget_SymbolInfo)

        menu = QMenu()
        copy_address = menu.addAction(tr.COPY_ADDRESS)
        copy_symbol = menu.addAction(tr.COPY_SYMBOL)
        if selected_row == -1:
            guiutils.delete_menu_entries(menu, [copy_address, copy_symbol])
        font_size = self.tableWidget_SymbolInfo.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            copy_address: lambda: copy_to_clipboard(selected_row, FUNCTIONS_INFO_ADDR_COL),
            copy_symbol: lambda: copy_to_clipboard(selected_row, FUNCTIONS_INFO_SYMBOL_COL),
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def tableWidget_SymbolInfo_item_double_clicked(self, index):
        address = self.tableWidget_SymbolInfo.item(index.row(), FUNCTIONS_INFO_ADDR_COL).text()
        if address == tr.DEFINED:
            return
        self.parent().disassemble_expression(address)

    def pushButton_Help_clicked(self):
        utilwidgets.InputDialog(self, tr.FUNCTIONS_INFO_HELPER, Qt.AlignmentFlag.AlignLeft, False).exec()


class EditInstructionDialogForm(QDialog, EditInstructionDialog):
    def __init__(self, parent, address, bytes_aob):
        super().__init__(parent)
        self.setupUi(self)
        self.orig_bytes = bytes_aob
        self.lineEdit_Address.setText(address)
        self.lineEdit_Bytes.setText(bytes_aob)
        self.lineEdit_Bytes_text_edited()
        self.lineEdit_Bytes.textEdited.connect(self.lineEdit_Bytes_text_edited)
        self.lineEdit_Instruction.textEdited.connect(self.lineEdit_Instruction_text_edited)
        guiutils.center_to_parent(self)

    def set_valid(self, valid):
        if valid:
            self.is_valid = True
            self.buttonBox.button(QDialogButtonBox.StandardButton.Ok).setEnabled(True)
        else:
            self.is_valid = False
            self.buttonBox.button(QDialogButtonBox.StandardButton.Ok).setEnabled(False)

    def lineEdit_Bytes_text_edited(self):
        bytes_aob = self.lineEdit_Bytes.text()
        if utils.parse_string(bytes_aob, typedefs.VALUE_INDEX.AOB):
            address = safe_str_to_int(self.lineEdit_Address.text(), 0)
            instruction = utils.disassemble(bytes_aob, address, debugcore.inferior_arch)
            if instruction:
                self.set_valid(True)
                self.lineEdit_Instruction.setText(instruction)
                return
        self.set_valid(False)
        self.lineEdit_Instruction.setText("??")

    def lineEdit_Instruction_text_edited(self):
        instruction = self.lineEdit_Instruction.text()
        address = safe_str_to_int(self.lineEdit_Address.text(), 0)
        result = utils.assemble(instruction, address, debugcore.inferior_arch)
        if result:
            byte_list = result[0]
            self.set_valid(True)
            bytes_str = " ".join([format(num, "02x") for num in byte_list])
            self.lineEdit_Bytes.setText(bytes_str)
        else:
            self.set_valid(False)
            self.lineEdit_Bytes.setText("??")

    def accept(self):
        if not self.is_valid:
            return

        # No need to check for validity since address is not editable and opcode is checked in text_edited
        address = safe_str_to_int(self.lineEdit_Address.text(), 0)
        bytes_aob = self.lineEdit_Bytes.text()
        if bytes_aob != self.orig_bytes:
            new_length = len(bytes_aob.split())
            old_length = len(self.orig_bytes.split())
            if new_length < old_length:
                bytes_aob += " 90" * (old_length - new_length)  # Append NOPs if we are short on bytes
            elif new_length > old_length:
                if not utilwidgets.InputDialog(self, tr.NEW_OPCODE.format(new_length, old_length)).exec():
                    return
            debugcore.modify_instruction(address, bytes_aob)
        self.parent().refresh_hex_view()
        self.parent().refresh_disassemble_view()
        super().accept()


class HexEditDialogForm(QDialog, HexEditDialog):
    def __init__(self, parent, address, length=20):
        super().__init__(parent)
        self.setupUi(self)
        self.lineEdit_Length.setValidator(QHexValidator(999, self))
        self.lineEdit_Address.setText(hex(address))
        self.lineEdit_Length.setText(str(length))
        self.refresh_view()
        self.lineEdit_AsciiView.selectionChanged.connect(self.lineEdit_AsciiView_selection_changed)
        guiutils.center_to_parent(self)

        # TODO: Implement this
        # self.lineEdit_HexView.selectionChanged.connect(self.lineEdit_HexView_selection_changed)
        self.lineEdit_HexView.textEdited.connect(self.lineEdit_HexView_text_edited)
        self.lineEdit_AsciiView.textEdited.connect(self.lineEdit_AsciiView_text_edited)
        self.pushButton_Refresh.pressed.connect(self.refresh_view)
        self.lineEdit_Address.textChanged.connect(self.refresh_view)
        self.lineEdit_Length.textChanged.connect(self.refresh_view)

    def lineEdit_AsciiView_selection_changed(self):
        length = len(utils.str_to_aob(self.lineEdit_AsciiView.selectedText(), "utf-8"))
        start_index = self.lineEdit_AsciiView.selectionStart()
        start_index = len(utils.str_to_aob(self.lineEdit_AsciiView.text()[0:start_index], "utf-8"))
        if start_index > 0:
            start_index += 1
        self.lineEdit_HexView.deselect()
        self.lineEdit_HexView.setSelection(start_index, length)

    def lineEdit_HexView_selection_changed(self):
        # TODO: Implement this
        logger.debug("TODO: Implement selectionChanged signal of lineEdit_HexView")
        raise NotImplementedError

    def lineEdit_HexView_text_edited(self):
        aob_string = self.lineEdit_HexView.text()
        if not utils.parse_string(aob_string, typedefs.VALUE_INDEX.AOB):
            self.lineEdit_HexView.setStyleSheet("QLineEdit {background-color: rgba(255, 0, 0, 96);}")
            return
        aob_array = aob_string.split()
        try:
            self.lineEdit_AsciiView.setText(utils.aob_to_str(aob_array, "utf-8", replace_unprintable=False))
            self.lineEdit_HexView.setStyleSheet("")  # This should set background color back to QT default
        except ValueError:
            self.lineEdit_HexView.setStyleSheet("QLineEdit {background-color: rgba(255, 0, 0, 96);}")

    def lineEdit_AsciiView_text_edited(self):
        ascii_str = self.lineEdit_AsciiView.text()
        try:
            self.lineEdit_HexView.setText(utils.str_to_aob(ascii_str, "utf-8"))
            self.lineEdit_AsciiView.setStyleSheet("")
        except ValueError:
            self.lineEdit_AsciiView.setStyleSheet("QLineEdit {background-color: rgba(255, 0, 0, 96);}")

    def refresh_view(self):
        self.lineEdit_AsciiView.clear()
        self.lineEdit_HexView.clear()
        address = debugcore.examine_expression(self.lineEdit_Address.text()).address
        if not address:
            return
        length = self.lineEdit_Length.text()
        try:
            length = int(length, 0)
            address = int(address, 0)
        except ValueError:
            return
        aob_array = debugcore.hex_dump(address, length)
        ascii_str = utils.aob_to_str(aob_array, "utf-8", replace_unprintable=False)
        self.lineEdit_AsciiView.setText(ascii_str)
        self.lineEdit_HexView.setText(" ".join(aob_array))

    def accept(self):
        expression = self.lineEdit_Address.text()
        address = debugcore.examine_expression(expression).address
        if not address:
            QMessageBox.information(self, tr.ERROR, tr.IS_INVALID_EXPRESSION.format(expression))
            return
        value = self.lineEdit_HexView.text()
        debugcore.write_memory(address, typedefs.VALUE_INDEX.AOB, value)
        super().accept()


class LogFileWidgetForm(QWidget, LogFileWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.contents = ""
        self.refresh_contents()
        self.refresh_timer = QTimer()
        self.refresh_timer.setInterval(500)
        self.refresh_timer.timeout.connect(self.refresh_contents)
        self.refresh_timer.start()
        guiutils.center_to_parent(self)

    def refresh_contents(self):
        log_path = utils.get_logging_file(debugcore.currentpid)
        self.setWindowTitle(tr.LOG_FILE.format(debugcore.currentpid))
        self.label_FilePath.setText(tr.LOG_CONTENTS.format(log_path, 20000))
        log_status = f"<font color=blue>{tr.ON}</font>" if states.gdb_logging else f"<font color=red>{tr.OFF}</font>"
        self.label_LoggingStatus.setText(f"<b>{tr.LOG_STATUS.format(log_status)}</b>")
        try:
            log_file = open(log_path)
        except OSError:
            self.textBrowser_LogContent.clear()
            error_message = tr.LOG_READ_ERROR.format(log_path) + "\n"
            if not states.gdb_logging:
                error_message += tr.SETTINGS_ENABLE_LOG
            self.textBrowser_LogContent.setText(error_message)
            return
        log_file.seek(0, io.SEEK_END)
        end_pos = log_file.tell()
        if end_pos > 20000:
            log_file.seek(end_pos - 20000, io.SEEK_SET)
        else:
            log_file.seek(0, io.SEEK_SET)
        contents = log_file.read().split("\n", 1)[-1]
        if contents != self.contents:
            self.contents = contents
            self.textBrowser_LogContent.clear()
            self.textBrowser_LogContent.setPlainText(contents)

            # Scrolling to bottom
            cursor = self.textBrowser_LogContent.textCursor()
            cursor.movePosition(QTextCursor.MoveOperation.End)
            self.textBrowser_LogContent.setTextCursor(cursor)
            self.textBrowser_LogContent.ensureCursorVisible()
        log_file.close()

    def closeEvent(self, event: QCloseEvent):
        self.refresh_timer.stop()
        super().closeEvent(event)


class SearchOpcodeWidgetForm(QWidget, SearchOpcodeWidget):
    def __init__(self, parent, start="", end=""):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.lineEdit_Start.setText(start)
        self.lineEdit_End.setText(end)
        self.tableWidget_Opcodes.setColumnWidth(SEARCH_OPCODE_ADDR_COL, 250)
        icons_directory = guiutils.get_icons_directory()
        self.pushButton_Help.setIcon(QIcon(QPixmap(icons_directory + "/help.png")))
        self.pushButton_Help.clicked.connect(self.pushButton_Help_clicked)
        self.pushButton_Search.clicked.connect(self.refresh_table)
        self.shortcut_search = QShortcut(QKeySequence("Return"), self)
        self.shortcut_search.activated.connect(self.refresh_table)
        self.tableWidget_Opcodes.itemDoubleClicked.connect(self.tableWidget_Opcodes_item_double_clicked)
        self.tableWidget_Opcodes.contextMenuEvent = self.tableWidget_Opcodes_context_menu_event
        guiutils.center_to_parent(self)

    def refresh_table(self):
        start_address = self.lineEdit_Start.text()
        end_address = self.lineEdit_End.text()
        regex = self.lineEdit_Regex.text()
        case_sensitive = self.checkBox_CaseSensitive.isChecked()
        enable_regex = self.checkBox_Regex.isChecked()
        self.loading_dialog = LoadingDialogForm(self)
        self.background_thread = self.loading_dialog.background_thread
        self.background_thread.overrided_func = lambda: self.process_data(
            regex, start_address, end_address, case_sensitive, enable_regex
        )
        self.background_thread.output_ready.connect(self.apply_data)
        self.loading_dialog.exec()

    def process_data(self, regex, start_address, end_address, case_sensitive, enable_regex):
        return debugcore.search_opcode(regex, start_address, end_address, case_sensitive, enable_regex)

    def apply_data(self, disas_data):
        if disas_data is None:
            QMessageBox.information(self, tr.ERROR, tr.INVALID_REGEX)
            return
        self.tableWidget_Opcodes.setSortingEnabled(False)
        self.tableWidget_Opcodes.setRowCount(0)
        self.tableWidget_Opcodes.setRowCount(len(disas_data))
        for row, item in enumerate(disas_data):
            self.tableWidget_Opcodes.setItem(row, SEARCH_OPCODE_ADDR_COL, QTableWidgetItem(item[0]))
            self.tableWidget_Opcodes.setItem(row, SEARCH_OPCODE_OPCODES_COL, QTableWidgetItem(item[1]))
        self.tableWidget_Opcodes.setSortingEnabled(True)

    def pushButton_Help_clicked(self):
        utilwidgets.InputDialog(self, tr.SEARCH_OPCODE_HELPER, Qt.AlignmentFlag.AlignLeft, False).exec()

    def tableWidget_Opcodes_item_double_clicked(self, index):
        row = index.row()
        address = self.tableWidget_Opcodes.item(row, SEARCH_OPCODE_ADDR_COL).text()
        self.parent().disassemble_expression(utils.extract_hex_address(address))

    def tableWidget_Opcodes_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_Opcodes.item(row, column).text())

        selected_row = guiutils.get_current_row(self.tableWidget_Opcodes)

        menu = QMenu()
        copy_address = menu.addAction(tr.COPY_ADDRESS)
        copy_opcode = menu.addAction(tr.COPY_OPCODE)
        if selected_row == -1:
            guiutils.delete_menu_entries(menu, [copy_address, copy_opcode])
        font_size = self.tableWidget_Opcodes.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            copy_address: lambda: copy_to_clipboard(selected_row, SEARCH_OPCODE_ADDR_COL),
            copy_opcode: lambda: copy_to_clipboard(selected_row, SEARCH_OPCODE_OPCODES_COL),
        }
        try:
            actions[action]()
        except KeyError:
            pass


class MemoryRegionsWidgetForm(QWidget, MemoryRegionsWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.refresh_table()
        self.tableWidget_MemoryRegions.contextMenuEvent = self.tableWidget_MemoryRegions_context_menu_event
        self.tableWidget_MemoryRegions.itemDoubleClicked.connect(self.tableWidget_MemoryRegions_item_double_clicked)
        self.shortcut_refresh = QShortcut(QKeySequence("R"), self)
        self.shortcut_refresh.activated.connect(self.refresh_table)
        guiutils.center_to_parent(self)

    def refresh_table(self):
        memory_regions = utils.get_regions(debugcore.currentpid)
        self.tableWidget_MemoryRegions.setRowCount(0)
        self.tableWidget_MemoryRegions.setRowCount(len(memory_regions))
        region_index = 0
        for row, (start, end, perms, offset, _, _, path) in enumerate(memory_regions):
            if safe_str_to_int(offset, 16) == 0:
                region_index = 0
            else:
                region_index += 1
            address = start + "-" + end
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_ADDR_COL, QTableWidgetItem(address))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_PERM_COL, QTableWidgetItem(perms))
            self.tableWidget_MemoryRegions.setItem(row, MEMORY_REGIONS_OFFSET_COL, QTableWidgetItem(offset))
            self.tableWidget_MemoryRegions.setItem(
                row, MEMORY_REGIONS_PATH_COL, QTableWidgetItem(path + f"[{region_index}]")
            )

        guiutils.resize_to_contents(self.tableWidget_MemoryRegions)

    def tableWidget_MemoryRegions_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_MemoryRegions.item(row, column).text())

        selected_row = guiutils.get_current_row(self.tableWidget_MemoryRegions)

        menu = QMenu()
        refresh = menu.addAction(f"{tr.REFRESH}[R]")
        menu.addSeparator()
        copy_addresses = menu.addAction(tr.COPY_ADDRESSES)
        copy_offset = menu.addAction(tr.COPY_OFFSET)
        copy_path = menu.addAction(tr.COPY_PATH)
        if selected_row == -1:
            guiutils.delete_menu_entries(menu, [copy_addresses, copy_offset, copy_path])
        font_size = self.tableWidget_MemoryRegions.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            refresh: self.refresh_table,
            copy_addresses: lambda: copy_to_clipboard(selected_row, MEMORY_REGIONS_ADDR_COL),
            copy_offset: lambda: copy_to_clipboard(selected_row, MEMORY_REGIONS_OFFSET_COL),
            copy_path: lambda: copy_to_clipboard(selected_row, MEMORY_REGIONS_PATH_COL),
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def tableWidget_MemoryRegions_item_double_clicked(self, index):
        row = index.row()
        address = self.tableWidget_MemoryRegions.item(row, MEMORY_REGIONS_ADDR_COL).text()
        address_int = safe_str_to_int(address.split("-")[0], 16)
        self.parent().hex_dump_address(address_int)


class DissectCodeDialogForm(QDialog, DissectCodeDialog):
    scan_finished_signal = pyqtSignal()

    def __init__(self, parent, int_address=-1):
        super().__init__(parent)
        self.setupUi(self)
        self.init_pre_scan_gui()
        self.update_dissect_results()
        self.show_memory_regions()
        self.splitter.setStretchFactor(0, 1)
        self.pushButton_StartCancel.clicked.connect(self.pushButton_StartCancel_clicked)
        self.refresh_timer = QTimer()
        self.refresh_timer.setInterval(100)
        self.refresh_timer.timeout.connect(self.refresh_dissect_status)
        if int_address != -1:
            for row in range(self.tableWidget_ExecutableMemoryRegions.rowCount()):
                item = self.tableWidget_ExecutableMemoryRegions.item(row, DISSECT_CODE_ADDR_COL).text()
                start_addr, end_addr = item.split("-")
                if safe_str_to_int(start_addr, 16) <= int_address <= safe_str_to_int(end_addr, 16):
                    self.tableWidget_ExecutableMemoryRegions.clearSelection()
                    self.tableWidget_ExecutableMemoryRegions.selectRow(row)
                    self.pushButton_StartCancel_clicked()
                    break
            else:
                QMessageBox.information(self, tr.ERROR, tr.INVALID_REGION)
        else:
            if self.tableWidget_ExecutableMemoryRegions.rowCount() > 0:
                self.tableWidget_ExecutableMemoryRegions.selectRow(0)
        guiutils.center_to_parent(self)

    class BackgroundThread(QThread):
        output_ready = pyqtSignal()
        is_canceled = False

        def __init__(self, region_list, discard_invalid_strings):
            super().__init__()
            self.region_list = region_list
            self.discard_invalid_strings = discard_invalid_strings

        def run(self):
            debugcore.dissect_code(self.region_list, self.discard_invalid_strings)
            if not self.is_canceled:
                self.output_ready.emit()

    def init_pre_scan_gui(self):
        self.is_scanning = False
        self.is_canceled = False
        self.pushButton_StartCancel.setText(tr.START)

    def init_after_scan_gui(self):
        self.is_scanning = True
        self.label_ScanInfo.setText(tr.CURRENT_SCAN_REGION)
        self.pushButton_StartCancel.setText(tr.CANCEL)

    def refresh_dissect_status(self):
        region, region_count, range, string_count, jump_count, call_count = debugcore.get_dissect_code_status()
        if not region:
            return
        self.label_RegionInfo.setText(region)
        self.label_RegionCountInfo.setText(region_count)
        self.label_CurrentRange.setText(range)
        self.label_StringReferenceCount.setText(str(string_count))
        self.label_JumpReferenceCount.setText(str(jump_count))
        self.label_CallReferenceCount.setText(str(call_count))

    def update_dissect_results(self):
        try:
            referenced_strings, referenced_jumps, referenced_calls = debugcore.get_dissect_code_data()
        except:
            return
        self.label_StringReferenceCount.setText(str(len(referenced_strings)))
        self.label_JumpReferenceCount.setText(str(len(referenced_jumps)))
        self.label_CallReferenceCount.setText(str(len(referenced_calls)))

    def show_memory_regions(self):
        executable_regions = utils.filter_regions(debugcore.currentpid, "permissions", "..x.")
        self.region_list = []
        self.tableWidget_ExecutableMemoryRegions.setRowCount(0)
        self.tableWidget_ExecutableMemoryRegions.setRowCount(len(executable_regions))
        for row, (start, end, _, _, _, _, path) in enumerate(executable_regions):
            address = start + "-" + end
            self.region_list.append((start, end))
            self.tableWidget_ExecutableMemoryRegions.setItem(row, DISSECT_CODE_ADDR_COL, QTableWidgetItem(address))
            self.tableWidget_ExecutableMemoryRegions.setItem(row, DISSECT_CODE_PATH_COL, QTableWidgetItem(path))
        guiutils.resize_to_contents(self.tableWidget_ExecutableMemoryRegions)

    def scan_finished(self):
        self.init_pre_scan_gui()
        if not self.is_canceled:
            self.label_ScanInfo.setText(tr.SCAN_FINISHED)
        self.is_canceled = False
        self.refresh_timer.stop()
        self.refresh_dissect_status()
        self.update_dissect_results()
        self.scan_finished_signal.emit()

    def pushButton_StartCancel_clicked(self):
        if self.is_scanning:
            self.is_canceled = True
            self.background_thread.is_canceled = True
            debugcore.cancel_dissect_code()
            self.refresh_timer.stop()
            self.update_dissect_results()
            self.label_ScanInfo.setText(tr.SCAN_CANCELED)
            self.init_pre_scan_gui()
        else:
            selected_rows = self.tableWidget_ExecutableMemoryRegions.selectionModel().selectedRows()
            if not selected_rows:
                QMessageBox.information(self, tr.ERROR, tr.SELECT_ONE_REGION)
                return
            selected_indexes = [selected_row.row() for selected_row in selected_rows]
            selected_regions = [self.region_list[selected_index] for selected_index in selected_indexes]
            self.background_thread = self.BackgroundThread(
                selected_regions, self.checkBox_DiscardInvalidStrings.isChecked()
            )
            self.background_thread.output_ready.connect(self.scan_finished)
            self.init_after_scan_gui()
            self.refresh_timer.start()
            self.background_thread.start()

    def closeEvent(self, event: QCloseEvent):
        debugcore.cancel_dissect_code()
        self.refresh_timer.stop()
        super().closeEvent(event)


class ReferencedStringsWidgetForm(QWidget, ReferencedStringsWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        guiutils.fill_value_combobox(self.comboBox_ValueType, typedefs.VALUE_INDEX.STRING_UTF8)
        self.setWindowFlags(Qt.WindowType.Window)
        self.tableWidget_References.setColumnWidth(REF_STR_ADDR_COL, 150)
        self.tableWidget_References.setColumnWidth(REF_STR_COUNT_COL, 80)
        self.splitter.setStretchFactor(0, 1)
        self.listWidget_Referrers.resize(400, self.listWidget_Referrers.height())
        guiutils.center_to_parent(self)
        self.hex_len = 16 if debugcore.inferior_arch == typedefs.INFERIOR_ARCH.ARCH_64 else 8
        str_dict, jmp_dict, call_dict = debugcore.get_dissect_code_data()
        str_dict_len, jmp_dict_len, call_dict_len = len(str_dict), len(jmp_dict), len(call_dict)
        str_dict.close()
        jmp_dict.close()
        call_dict.close()
        if str_dict_len == 0 and jmp_dict_len == 0 and call_dict_len == 0:
            if utilwidgets.InputDialog(self, tr.DISSECT_CODE).exec():
                dissect_code_dialog = DissectCodeDialogForm(self)
                dissect_code_dialog.scan_finished_signal.connect(dissect_code_dialog.accept)
                dissect_code_dialog.exec()
        self.refresh_table()
        self.tableWidget_References.sortByColumn(REF_STR_ADDR_COL, Qt.SortOrder.AscendingOrder)
        self.tableWidget_References.selectionModel().currentChanged.connect(self.tableWidget_References_current_changed)
        self.listWidget_Referrers.itemDoubleClicked.connect(self.listWidget_Referrers_item_double_clicked)
        self.tableWidget_References.itemDoubleClicked.connect(self.tableWidget_References_item_double_clicked)
        self.tableWidget_References.contextMenuEvent = self.tableWidget_References_context_menu_event
        self.listWidget_Referrers.contextMenuEvent = self.listWidget_Referrers_context_menu_event
        self.pushButton_Search.clicked.connect(self.refresh_table)
        self.comboBox_ValueType.currentIndexChanged.connect(self.refresh_table)
        self.shortcut_search = QShortcut(QKeySequence("Return"), self)
        self.shortcut_search.activated.connect(self.refresh_table)

    def pad_hex(self, hex_str):
        index = hex_str.find(" ")
        if index == -1:
            self_len = 0
        else:
            self_len = len(hex_str) - index
        return "0x" + hex_str[2:].zfill(self.hex_len + self_len)

    def refresh_table(self):
        item_list = debugcore.search_referenced_strings(
            self.lineEdit_Regex.text(),
            self.comboBox_ValueType.currentIndex(),
            self.checkBox_CaseSensitive.isChecked(),
            self.checkBox_Regex.isChecked(),
        )
        if item_list is None:
            QMessageBox.information(self, tr.ERROR, tr.INVALID_REGEX)
            return
        self.tableWidget_References.setSortingEnabled(False)
        self.tableWidget_References.setRowCount(0)
        self.tableWidget_References.setRowCount(len(item_list))
        for row, item in enumerate(item_list):
            self.tableWidget_References.setItem(row, REF_STR_ADDR_COL, QTableWidgetItem(self.pad_hex(item[0])))
            table_widget_item = QTableWidgetItem()
            table_widget_item.setData(Qt.ItemDataRole.EditRole, item[1])
            self.tableWidget_References.setItem(row, REF_STR_COUNT_COL, table_widget_item)
            table_widget_item = QTableWidgetItem()
            table_widget_item.setData(Qt.ItemDataRole.EditRole, item[2])
            self.tableWidget_References.setItem(row, REF_STR_VAL_COL, table_widget_item)
        self.tableWidget_References.setSortingEnabled(True)

    def tableWidget_References_current_changed(self, QModelIndex_current):
        if QModelIndex_current.row() < 0:
            return
        self.listWidget_Referrers.clear()
        str_dict = debugcore.get_dissect_code_data(True, False, False)[0]
        addr = self.tableWidget_References.item(QModelIndex_current.row(), REF_STR_ADDR_COL).text()
        referrers = str_dict[addr]
        addrs = [hex(address) for address in referrers]
        self.listWidget_Referrers.addItems([self.pad_hex(item.all) for item in debugcore.examine_expressions(addrs)])
        self.listWidget_Referrers.sortItems(Qt.SortOrder.AscendingOrder)
        str_dict.close()

    def tableWidget_References_item_double_clicked(self, index):
        row = index.row()
        address = self.tableWidget_References.item(row, REF_STR_ADDR_COL).text()
        self.parent().hex_dump_address(safe_str_to_int(address, 16))

    def listWidget_Referrers_item_double_clicked(self, item):
        self.parent().disassemble_expression(utils.extract_hex_address(item.text()))

    def tableWidget_References_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_References.item(row, column).text())

        selected_row = guiutils.get_current_row(self.tableWidget_References)

        menu = QMenu()
        copy_address = menu.addAction(tr.COPY_ADDRESS)
        copy_value = menu.addAction(tr.COPY_VALUE)
        if selected_row == -1:
            guiutils.delete_menu_entries(menu, [copy_address, copy_value])
        font_size = self.tableWidget_References.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {
            copy_address: lambda: copy_to_clipboard(selected_row, REF_STR_ADDR_COL),
            copy_value: lambda: copy_to_clipboard(selected_row, REF_STR_VAL_COL),
        }
        try:
            actions[action]()
        except KeyError:
            pass

    def listWidget_Referrers_context_menu_event(self, event):
        def copy_to_clipboard(row):
            app.clipboard().setText(self.listWidget_Referrers.item(row).text())

        selected_row = guiutils.get_current_row(self.listWidget_Referrers)

        menu = QMenu()
        copy_address = menu.addAction(tr.COPY_ADDRESS)
        if selected_row == -1:
            guiutils.delete_menu_entries(menu, [copy_address])
        font_size = self.listWidget_Referrers.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {copy_address: lambda: copy_to_clipboard(selected_row)}
        try:
            actions[action]()
        except KeyError:
            pass


class ReferencedCallsWidgetForm(QWidget, ReferencedCallsWidget):
    def __init__(self, parent):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.tableWidget_References.setColumnWidth(REF_CALL_ADDR_COL, 480)
        self.splitter.setStretchFactor(0, 1)
        self.listWidget_Referrers.resize(400, self.listWidget_Referrers.height())
        guiutils.center_to_parent(self)
        self.hex_len = 16 if debugcore.inferior_arch == typedefs.INFERIOR_ARCH.ARCH_64 else 8
        str_dict, jmp_dict, call_dict = debugcore.get_dissect_code_data()
        str_dict_len, jmp_dict_len, call_dict_len = len(str_dict), len(jmp_dict), len(call_dict)
        str_dict.close()
        jmp_dict.close()
        call_dict.close()
        if str_dict_len == 0 and jmp_dict_len == 0 and call_dict_len == 0:
            if utilwidgets.InputDialog(self, tr.DISSECT_CODE).exec():
                dissect_code_dialog = DissectCodeDialogForm(self)
                dissect_code_dialog.scan_finished_signal.connect(dissect_code_dialog.accept)
                dissect_code_dialog.exec()
        self.refresh_table()
        self.tableWidget_References.sortByColumn(REF_CALL_ADDR_COL, Qt.SortOrder.AscendingOrder)
        self.tableWidget_References.selectionModel().currentChanged.connect(self.tableWidget_References_current_changed)
        self.listWidget_Referrers.itemDoubleClicked.connect(self.listWidget_Referrers_item_double_clicked)
        self.tableWidget_References.itemDoubleClicked.connect(self.tableWidget_References_item_double_clicked)
        self.tableWidget_References.contextMenuEvent = self.tableWidget_References_context_menu_event
        self.listWidget_Referrers.contextMenuEvent = self.listWidget_Referrers_context_menu_event
        self.pushButton_Search.clicked.connect(self.refresh_table)
        self.shortcut_search = QShortcut(QKeySequence("Return"), self)
        self.shortcut_search.activated.connect(self.refresh_table)

    def pad_hex(self, hex_str):
        index = hex_str.find(" ")
        if index == -1:
            self_len = 0
        else:
            self_len = len(hex_str) - index
        return "0x" + hex_str[2:].zfill(self.hex_len + self_len)

    def refresh_table(self):
        item_list = debugcore.search_referenced_calls(
            self.lineEdit_Regex.text(), self.checkBox_CaseSensitive.isChecked(), self.checkBox_Regex.isChecked()
        )
        if item_list is None:
            QMessageBox.information(self, tr.ERROR, tr.INVALID_REGEX)
            return
        self.tableWidget_References.setSortingEnabled(False)
        self.tableWidget_References.setRowCount(0)
        self.tableWidget_References.setRowCount(len(item_list))
        for row, item in enumerate(item_list):
            self.tableWidget_References.setItem(row, REF_CALL_ADDR_COL, QTableWidgetItem(self.pad_hex(item[0])))
            table_widget_item = QTableWidgetItem()
            table_widget_item.setData(Qt.ItemDataRole.EditRole, item[1])
            self.tableWidget_References.setItem(row, REF_CALL_COUNT_COL, table_widget_item)
        self.tableWidget_References.setSortingEnabled(True)

    def tableWidget_References_current_changed(self, QModelIndex_current):
        if QModelIndex_current.row() < 0:
            return
        self.listWidget_Referrers.clear()
        call_dict = debugcore.get_dissect_code_data(False, False, True)[0]
        addr = self.tableWidget_References.item(QModelIndex_current.row(), REF_CALL_ADDR_COL).text()
        referrers = call_dict[utils.extract_hex_address(addr)]
        addrs = [hex(address) for address in referrers]
        self.listWidget_Referrers.addItems([self.pad_hex(item.all) for item in debugcore.examine_expressions(addrs)])
        self.listWidget_Referrers.sortItems(Qt.SortOrder.AscendingOrder)
        call_dict.close()

    def tableWidget_References_item_double_clicked(self, index):
        row = index.row()
        address = self.tableWidget_References.item(row, REF_CALL_ADDR_COL).text()
        self.parent().disassemble_expression(utils.extract_hex_address(address))

    def listWidget_Referrers_item_double_clicked(self, item):
        self.parent().disassemble_expression(utils.extract_hex_address(item.text()))

    def tableWidget_References_context_menu_event(self, event):
        def copy_to_clipboard(row, column):
            app.clipboard().setText(self.tableWidget_References.item(row, column).text())

        selected_row = guiutils.get_current_row(self.tableWidget_References)

        menu = QMenu()
        copy_address = menu.addAction(tr.COPY_ADDRESS)
        if selected_row == -1:
            guiutils.delete_menu_entries(menu, [copy_address])
        font_size = self.tableWidget_References.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {copy_address: lambda: copy_to_clipboard(selected_row, REF_CALL_ADDR_COL)}
        try:
            actions[action]()
        except KeyError:
            pass

    def listWidget_Referrers_context_menu_event(self, event):
        def copy_to_clipboard(row):
            app.clipboard().setText(self.listWidget_Referrers.item(row).text())

        selected_row = guiutils.get_current_row(self.listWidget_Referrers)

        menu = QMenu()
        copy_address = menu.addAction(tr.COPY_ADDRESS)
        if selected_row == -1:
            guiutils.delete_menu_entries(menu, [copy_address])
        font_size = self.listWidget_Referrers.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {copy_address: lambda: copy_to_clipboard(selected_row)}
        try:
            actions[action]()
        except KeyError:
            pass


class ExamineReferrersWidgetForm(QWidget, ExamineReferrersWidget):
    def __init__(self, parent, int_address):
        super().__init__(parent)
        self.setupUi(self)
        self.setWindowFlags(Qt.WindowType.Window)
        self.splitter.setStretchFactor(0, 1)
        self.textBrowser_DisasInfo.resize(600, self.textBrowser_DisasInfo.height())
        self.referenced_hex = hex(int_address)
        self.hex_len = 16 if debugcore.inferior_arch == typedefs.INFERIOR_ARCH.ARCH_64 else 8
        self.collect_referrer_data()
        self.refresh_table()
        self.listWidget_Referrers.sortItems(Qt.SortOrder.AscendingOrder)
        self.listWidget_Referrers.selectionModel().currentChanged.connect(self.listWidget_Referrers_current_changed)
        self.listWidget_Referrers.itemDoubleClicked.connect(self.listWidget_Referrers_item_double_clicked)
        self.listWidget_Referrers.contextMenuEvent = self.listWidget_Referrers_context_menu_event
        self.pushButton_Search.clicked.connect(self.refresh_table)
        self.shortcut_search = QShortcut(QKeySequence("Return"), self)
        self.shortcut_search.activated.connect(self.refresh_table)
        guiutils.center_to_parent(self)

    def pad_hex(self, hex_str):
        index = hex_str.find(" ")
        if index == -1:
            self_len = 0
        else:
            self_len = len(hex_str) - index
        return "0x" + hex_str[2:].zfill(self.hex_len + self_len)

    def collect_referrer_data(self):
        jmp_dict, call_dict = debugcore.get_dissect_code_data(False, True, True)
        self.referrer_data = []
        try:
            jmp_referrers = jmp_dict[self.referenced_hex]
        except KeyError:
            pass
        else:
            jmp_referrers = [hex(item) for item in jmp_referrers]
            self.referrer_data.extend([item.all for item in debugcore.examine_expressions(jmp_referrers)])
        try:
            call_referrers = call_dict[self.referenced_hex]
        except KeyError:
            pass
        else:
            call_referrers = [hex(item) for item in call_referrers]
            self.referrer_data.extend([item.all for item in debugcore.examine_expressions(call_referrers)])
        jmp_dict.close()
        call_dict.close()

    def refresh_table(self):
        searched_str = self.lineEdit_Regex.text()
        case_sensitive = self.checkBox_CaseSensitive.isChecked()
        enable_regex = self.checkBox_Regex.isChecked()
        if enable_regex:
            try:
                if case_sensitive:
                    regex = re.compile(searched_str)
                else:
                    regex = re.compile(searched_str, re.IGNORECASE)
            except:
                QMessageBox.information(self, tr.ERROR, tr.INVALID_REGEX)
                return
        self.listWidget_Referrers.setSortingEnabled(False)
        self.listWidget_Referrers.clear()
        for row, item in enumerate(self.referrer_data):
            if enable_regex:
                if not regex.search(item):
                    continue
            else:
                if case_sensitive:
                    if item.find(searched_str) == -1:
                        continue
                else:
                    if item.lower().find(searched_str.lower()) == -1:
                        continue
            self.listWidget_Referrers.addItem(item)
        self.listWidget_Referrers.setSortingEnabled(True)
        self.listWidget_Referrers.sortItems(Qt.SortOrder.AscendingOrder)

    def listWidget_Referrers_current_changed(self, QModelIndex_current):
        if QModelIndex_current.row() < 0:
            return
        self.textBrowser_DisasInfo.clear()
        disas_data = debugcore.disassemble(
            utils.extract_hex_address(self.listWidget_Referrers.item(QModelIndex_current.row()).text()), "+200"
        )
        for address_info, _, opcode in disas_data:
            self.textBrowser_DisasInfo.append(address_info + opcode)
        cursor = self.textBrowser_DisasInfo.textCursor()
        cursor.movePosition(QTextCursor.MoveOperation.Start)
        self.textBrowser_DisasInfo.setTextCursor(cursor)
        self.textBrowser_DisasInfo.ensureCursorVisible()

    def listWidget_Referrers_item_double_clicked(self, item):
        self.parent().disassemble_expression(utils.extract_hex_address(item.text()))

    def listWidget_Referrers_context_menu_event(self, event):
        def copy_to_clipboard(row):
            app.clipboard().setText(self.listWidget_Referrers.item(row).text())

        selected_row = guiutils.get_current_row(self.listWidget_Referrers)

        menu = QMenu()
        copy_address = menu.addAction(tr.COPY_ADDRESS)
        if selected_row == -1:
            guiutils.delete_menu_entries(menu, [copy_address])
        font_size = self.listWidget_Referrers.font().pointSize()
        menu.setStyleSheet("font-size: " + str(font_size) + "pt;")
        action = menu.exec(event.globalPos())
        actions = {copy_address: lambda: copy_to_clipboard(selected_row)}
        try:
            actions[action]()
        except KeyError:
            pass


def handle_exit():
    states.exiting = True


if __name__ == "__main__":
    app.aboutToQuit.connect(handle_exit)
    window = MainForm()
    window.show()
    sys.exit(app.exec())

```

`PINCE.sh`:

```sh
#!/bin/bash
: '
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'

if [ "$(id -u)" = "0" ]; then
	echo "Please do not run this script as root!"
	exit 1
fi

SCRIPTDIR=$(cd -- "$(dirname -- "$0")" && pwd -P)
if [ ! -d "${SCRIPTDIR}/.venv/bin" ]; then
	echo "Please run \"sh install.sh\" first!"
	exit 1
fi
. ${SCRIPTDIR}/.venv/bin/activate

PYTHON="${SCRIPTDIR}/.venv/bin/python3"
PINCE_PY="${SCRIPTDIR}/PINCE.py"

if type pkexec &> /dev/null; then
	# Preserve env vars to keep settings like theme preferences.
	# Pkexec does not support passing all of env via a flag like `-E` so we need to
	# rebuild the env and then pass it through.
	ENV=()
	while IFS= read -r line
	do
		ENV+=("$line")
	done < <(printenv)

	pkexec env "${ENV[@]}" "$PYTHON" "$PINCE_PY"
elif type sudo &> /dev/null; then
	# Debian/Ubuntu does not preserve PATH through sudo even with -E for security reasons
	# so we need to force PATH preservation with venv activated user's PATH.
	sudo -E --preserve-env=PATH PYTHONDONTWRITEBYTECODE=1 "$PYTHON" "$PINCE_PY"
else
	echo "No supported privilege escalation utility found. Please run this as root manually."
	exit 1
fi

```

`README.md`:

```md
# PINCE
<!---
TODO: Include build status with the title when test coverage increases and Travis is maintained
[![Build Status](https://travis-ci.org/korcankaraokcu/PINCE.svg?branch=master)](https://travis-ci.org/korcankaraokcu/PINCE)
-->
PINCE is a front-end/reverse engineering tool for the GNU Project Debugger (GDB), focused on games. However, it can be used for any reverse-engineering related stuff. PINCE is an abbreviation for "PINCE is not Cheat Engine". PINCE is in development right now, read [Features](#features) part of the project to see what is done and [Roadmap](CONTRIBUTING.md#roadmap) part to see what is currently planned. Also, please read [Wiki Page](https://github.com/korcankaraokcu/PINCE/wiki) of the project to understand how PINCE works.  

### [Feel free to join our discord server!](https://discord.gg/jVt3BzTSpz)  

*Disclaimer: Do not trust to any source other than [Trusted Sources](#trusted-sources) that claims to have the source code or package for PINCE and remember to report them **immediately***

*Disclaimer: **YOU** are responsible for your actions. PINCE does **NOT** take any responsibility for the damage caused by the users*

![pince1](https://github.com/user-attachments/assets/7344c33d-3ea7-408a-8a5b-793f0b4c78ec)
![pince2](https://github.com/user-attachments/assets/271cbbe7-b588-48e0-b939-f59e82f36812)
![pince3](https://github.com/user-attachments/assets/479b4f56-7b62-4100-a3d9-3f9cd11ff5b8)
![pince4](https://github.com/user-attachments/assets/08d8a6fe-6960-481b-9b55-aa550f860dc7)

# Features  
- **Memory scanning:** PINCE uses a specialized fork of [libscanmem](https://github.com/brkzlr/scanmem-PINCE) to scan the memory efficiently
- **Pointer scanning:** PINCE uses [PointerScanner-X](https://github.com/kekeimiku/PointerSearcher-X/) to scan pointers efficiently
- **Background Execution:** PINCE uses background execution by default, allowing users to run GDB commands while process is running
- **Variable Inspection&Modification**
  * **CheatEngine-like value type support:** Currently supports all types of CE and scanmem along with extended strings(utf-8, utf-16, utf-32)
  * **Symbol Recognition:** See [here](https://github.com/korcankaraokcu/PINCE/wiki/GDB-Expressions)
  * **Automatic Variable Allocation:** See [here](https://github.com/korcankaraokcu/PINCE/wiki/GDB-Expressions)
  * **Dynamic Address Table:** Supports drag&drop, recursive copy&pasting&inserting and many more
  * **Smart casting:** PINCE lets you modify multiple different-type values together as long as the input is parsable. All parsing/memory errors are directed to the terminal
  * **Variable Locking:** PINCE lets you freeze(constantly write a value to memory cell) variables
- **Memory View**
  * **Assembler:** PINCE uses keystone engine to assemble code on the fly
  * **Dissect Code:** You can dissect desired memory regions to find referenced calls, jumps and strings. Disassemble screen will automatically handle the referenced data and show you if there's a referenced address in the current dissasemble view. It can be used from Tools->Dissect Code in the MemoryView window. Using its hotkey instead in the MemoryView window automatically dissects the currently viewed region. You can separately view referenced calls and strings after the search from View->Referenced Calls/Strings. *Note: If you decide to uncheck 'Discard invalid strings' before the search, PINCE will try to search for regular pointers as well*
  * **Bookmarking:** Bookmark menu is dynamically created when right clicked in the disassemble screen. So unlike Cheat Engine, PINCE lets you set unlimited number of bookmarks. List of bookmarks can also be viewed from View->Bookmarks in the MemoryView window. Commenting on an address automatically bookmarks it
  * **Modify on the fly:** PINCE lets you modify registers on the fly. Check [GDB expressions in the Wiki page](https://github.com/korcankaraokcu/PINCE/wiki/GDB-Expressions) for additional information
  * **Opcode Search:** You can search opcodes with python regular expressions. To use this feature, click Tools->Search Opcode in the MemoryView window
- **Debugging**
  * Has basic debugging features such as stepping, stepping over, execute till return, break, continue. Also has breakpoints, watchpoints and breakpoint conditions. Has advanced debugging utilities such as Watchpoint/Breakpoint Tracking and Tracing
  * **Chained Breakpoints:** Just like CE, PINCE allows you to set multiple, connected breakpoints at once. If an event(such as condition modification or deletion) happens in one of the breakpoints, other connected breakpoints will get affected as well
  * **Watchpoint Tracking:** Allows you to see which instructions have been accessing to the specified address, just like "What accesses/writes to this address" feature in CE
  * **Breakpoint Tracking:** Allows you to track down addresses calculated by the given register expressions at the specified instruction, just like "Find out what addresses this instruction accesses" feature in CE with a little addon, you can enter multiple register expressions, this allows you to check the value of "esi" even if the instruction is something irrelevant like "mov [eax],edx"
  * **Tracing:** Almost the same with CE. But unlike CE, you can stop tracing whenever you want. Created from scratch with custom features instead of using gdb's built-in trace commands, this allows tracing to be done without the need of a gdbserver
  * **Collision Detection:** GDB normally permits setting unlimited watchpoints next to each other. But this behaviour leads to unexpected outcomes such as causing GDB or the inferior become completely inoperable. GDB also doesn't care about the number(max 4) or the size(x86->max 4, x64->max 8) of hardware breakpoints. Fortunately, PINCE checks for these problems whenever you set a new breakpoint and detects them before they happen and then inhibits them in a smart way. Lets say you want to set a breakpoint in the size of 32 bytes. But the maximum size for a breakpoint is 8! So, PINCE creates 4 different breakpoints with the size of 8 bytes and then chains them for future actions
- **Code Injection**
  * **Run-time injection:** Only .so injection is supported for now. In Memory View window, click Tools->Inject .so file to select the .so file. An example for creating .so file can be found in "libpince/Injection/". PINCE will be able to inject single line instructions or code caves in near future
- **GDB Console:** You can use the GDB Console to interact with GDB, it's on the top right in main window
- **libpince:** PINCE provides a reusable python library. You can either read the code or check the [Github Pages](https://korcankaraokcu.github.io/PINCE/) for documentation. Currently, libpince can be used via console by following [these instructions](https://github.com/korcankaraokcu/PINCE/issues/232#issuecomment-1872906700). In the future, it'll be directly integrated into PINCE when we develop the scripting engine (IDE for PINCE)
- **Extendable with .so files at runtime:** See [here](https://github.com/korcankaraokcu/PINCE/wiki/Extending-PINCE-with-.so-files)

# Installing and running PINCE
### Users
No need to install anything. Just grab the latest AppImage over at [Releases](https://github.com/korcankaraokcu/PINCE/releases) and mark it as executable. You can then double click on the AppImage or run it through terminal, however you prefer.

To mark as executable, either:
- Run the following command in terminal in the same folder as the downloaded AppImage: `chmod +x PINCE-x86_64.AppImage`
- Or you can right-click on the AppImage, click on Properties and tick "Allow this file to run as a program" under "Permissions"
  - The last step might be different depending on your desktop environment, but most of them should have similar words so just make sure to edit permissions to allow running as executable.

### Developers and Contributors
- If you want to have a local install of PINCE so you can modify code or contribute with PRs, you'll have to use our installer script in the repo to setup a venv dev environment or do it yourself.
- To install local dev environment, run the following commands in a terminal anywhere you'd like to have the PINCE folder:
```bash
git clone --recursive https://github.com/korcankaraokcu/PINCE
sh PINCE/install.sh
```
- Make sure to check our [Officially supported platforms](#officially-supported-platforms) section below. Our installer might not work on distros that are not listed there, but it will still try to install using some package managers, just follow the on-screen instructions.
- If installer fails trying to install on an unsupported distro, you're on your own on trying to get the local dev environment up and running. Check `install.sh` to get an idea about what you might need.
- If you'd like to uninstall PINCE, just delete this folder, almost everything is installed locally. Config and user files of PINCE can be found in "~/.config/PINCE", you can manually delete them as well if you want.

### Notes
- If you are having problems with your default gdb version, you can use the `compile_gdb.sh` script to compile another version locally. Read the comments in it for more information
- Check https://github.com/korcankaraokcu/PINCE/issues/116 for a possible fix if you encounter `'GtkSettings' has no property named 'gtk-fallback-icon-theme'`

# Officially supported platforms
### AppImage
Our AppImage should run on any distro that is as new or newer than Ubuntu 22.04. Anything older than this might not work and is not officially supported.

### Local dev
Local dev installs of PINCE should technically run on any distro that comes with **Python 3.11+** and **PyQt 6.10+** installed or available in the package manager, but below is the list of distros that we officially support, as in we actively test on these and help with issues:
- Kubuntu 22.04+
- Arch Linux (**Not AUR**)

Additionally the distros below are "partially" supported as our installer will try to install on them but ***they're not actively tested***:
- Debian 12+ (or Testing)
- Fedora 35+
- OpenSUSE

### Notes
- If you encounter issues installing local dev and you're on one of these distros, feel free to open a PR fixing the installation process for your platform.
- If your distro has any of the above as its base, you can still try to use the installer anyway and pick the relevant package manager. If this still does not work then sorry, you're on your own.
- ***DO NOT open issues if you cannot repro using a local dev build on a supported distro from above or AppImage!***
  - **This includes AUR or NIXPKGS. We don't care about the issues present on these packaged versions unless you can repro them on AppImage (or also local dev if you're on Arch).**

# Contributing
Want to help? Check out [CONTRIBUTING.md](CONTRIBUTING.md)

# License
GPLv3+. See [COPYING](COPYING) file for details

# Trusted Sources
  * [Official github page](https://github.com/korcankaraokcu/PINCE)

```

`THANKS`:

```
Sebastian Parschauer <s.parschauer@gmx.de>
Andrea Stacchiotti <https://github.com/12345ieee>
XutaxKamay <https://github.com/XutaxKamay>
Salih Marangoz <salihmarangoz.github@gmail.com>
Hjalte Skjold Hørsdal <hjaltello@gmail.com>
Juuso Lapinlampi <wub@partyvan.eu>
Özcan Esen <ozcanesen@gmail.com>

```

`ci/package.sh`:

```sh
#!/bin/bash
: '
Copyright (C) 2024 brkzlr <brkozler@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'

# Check if the file is in the correct directory and cd there
# This script should be only in PINCE/ci folder
PACKAGEDIR="$(dirname "$(readlink -f "$0")")"
case $PACKAGEDIR in
	*"PINCE/ci") ;;
	*) echo "package.sh is not in PINCE/ci folder!"; exit 1;;
esac
cd $PACKAGEDIR

# Check what distro we use for lrelease path
LSB_RELEASE="$(command -v lsb_release)"
if [ -n "$LSB_RELEASE" ]; then
    OS_NAME="$(${LSB_RELEASE} -d -s)"
else
    # shellcheck disable=SC1091
    . /etc/os-release
    OS_NAME="$NAME"
fi
case $OS_NAME in
*SUSE*)
	LRELEASE_CMD="lrelease6"
	;;
*Arch*)
	LRELEASE_CMD="/usr/lib/qt6/bin/lrelease"
	export NO_STRIP=1
	;;
*Fedora*)
	LRELEASE_CMD="lrelease-qt6"
	;;
*Debian*|*Ubuntu*)
	LRELEASE_CMD="/usr/lib/qt6/bin/lrelease"
	;;
*)
	LRELEASE_CMD="$(which lrelease6)" # Placeholder
	;;
esac

# Download necessary tools
curl -L -O https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
DEPLOYTOOL=./linuxdeploy-x86_64.AppImage
chmod +x $DEPLOYTOOL

curl -L -O https://raw.githubusercontent.com/TheAssassin/linuxdeploy-plugin-conda/master/linuxdeploy-plugin-conda.sh
CONDAPLUGIN=./linuxdeploy-plugin-conda.sh
chmod +x $CONDAPLUGIN

# Create cleanup function to remove remaining deps/files
cleanup () {
	cd $PACKAGEDIR
	# Remove everything outside of package.sh and AppImage output
	ls --hide=package.sh --hide=PINCE*.AppImage | xargs rm -rf
}
trap cleanup EXIT

# Error checking function
exit_on_failure() {
    if [ "$?" -ne 0 ]; then
        echo
        echo "Error occured while creating AppImage! Check the log above!"
        exit 1
    fi
}

# Create AppImage's AppDir with a Conda environment pre-baked
# containing our required pip packages
export PIP_REQUIREMENTS="-r ../requirements.txt"
# Need this to get libstdc++ higher than default 6.0.29 and libxcb-cursor for Debian family
export CONDA_PACKAGES="libstdcxx-ng;xcb-util-cursor"
$DEPLOYTOOL --appdir AppDir -pconda || exit_on_failure

# Create PINCE directory
mkdir -p AppDir/opt/PINCE

# Install libscanmem
NUM_MAKE_JOBS="$(nproc --ignore=1)"
cd ..
git submodule update --init --recursive
if [ ! -d "libpince/libscanmem" ]; then
	mkdir libpince/libscanmem
fi
cd libscanmem-PINCE
cmake -DCMAKE_BUILD_TYPE=Release . || exit_on_failure
make -j"$NUM_MAKE_JOBS" || exit_on_failure
cp --preserve libscanmem.so ../libpince/libscanmem
cp --preserve wrappers/scanmem.py ../libpince/libscanmem
cd ..

# Install libptrscan
if [ ! -d "libpince/libptrscan" ]; then
	mkdir libpince/libptrscan
fi
cd libpince/libptrscan
curl -L -o libptrscan.tar.gz https://github.com/kekeimiku/PointerSearcher-X/releases/download/v0.7.4-dylib/libptrscan_pince-x86_64-unknown-linux-gnu.tar.gz || exit_on_failure
tar xf libptrscan.tar.gz --strip-components 1 || exit_on_failure
rm -f libptrscan.tar.gz
cd ../..

# Compile translations
${LRELEASE_CMD} i18n/ts/* || exit_on_failure
mkdir -p i18n/qm
mv i18n/ts/*.qm i18n/qm/

# Copy necessary PINCE folders/files to inside AppDir
cp -r GUI i18n libpince media tr AUTHORS COPYING COPYING.CC-BY PINCE.py THANKS ci/AppDir/opt/PINCE/
cd ci

# Create a wrapper so GDB can correctly link against the
# included conda's python environment to ensure compatibility
# Taken from: https://github.com/pwndbg/pwndbg/pull/892
cat > wrapper.sh <<\EOF
#!/bin/bash
if [[ -z "$CONDA_PREFIX" ]]; then
	echo "Error: CONDA_PREFIX not set"
	exit 2
fi
echo "$(date +%F) -- $@" >> /tmp/args.txt
if [[ $1 != *"python-config.py"* ]]; then
	exec "$CONDA_PREFIX"/bin/python3
fi
# get rid of the first parameter, which is the path to the python-config.py script
shift
# python3-config --ldflags lacks the python library
# also gdb won't link on GitHub actions without libtinfow, which is not provided by the conda environment
if [[ "$1" == "--ldflags" ]]; then
	echo -n "-lpython3.13 -ltinfow "
fi
exec "$CONDA_PREFIX"/bin/python3-config "$@"
EOF
chmod +x wrapper.sh

# Prepare some env vars for GDB compilation
INSTALLDIR=$(pwd)/AppDir
export CONDA_PREFIX="$(readlink -f $INSTALLDIR/usr/conda)"

# Grab latest GDB at time of writing and compile it with our conda Python
curl -L -O "https://ftp.gnu.org/gnu/gdb/gdb-17.1.tar.gz"
tar xf gdb-17.1.tar.gz
rm gdb-17.1.tar.gz
cd gdb-17.1
./configure --with-python="$(readlink -f ../wrapper.sh)" --prefix=/usr || exit_on_failure
make -j"$NUM_MAKE_JOBS" || exit_on_failure
make install DESTDIR=$INSTALLDIR
cd ..
rm -rf gdb-17.1
rm wrapper.sh

# Create a desktop file for AppImage
cat > AppDir/usr/share/applications/PINCE.desktop <<\EOF
[Desktop Entry]
Name=PINCE
Exec=PINCE
Icon=PINCE
Type=Application
Categories=Development;
EOF

# Copy icon for the above desktop file
cp ../media/logo/ozgurozbek/pince_appimage.png PINCE.png

# Create main running script
cat > AppRun.sh <<\EOF
#!/bin/bash

if [ "$(id -u)" != "0" ]; then
	if type pkexec &> /dev/null; then
		# Preserve env vars to keep settings like theme preferences.
		# Pkexec does not support passing all of env via a flag like `-E` so we need to
		# rebuild the env and then pass it through.
		ENV=()
		while IFS= read -r line
		do
			ENV+=("$line")
		done < <(printenv)

		pkexec env "${ENV[@]}" "$APPIMAGE"
	elif type sudo &> /dev/null; then
		# Debian/Ubuntu does not preserve PATH through sudo even with -E for security reasons
		# so we need to force PATH preservation with venv activated user's PATH.
		sudo -E --preserve-env=PATH PYTHONDONTWRITEBYTECODE=1 "$APPIMAGE"
	else
		echo "No supported privilege escalation utility found. Please run this as root manually."
		exit 1
	fi

	exit
fi
export APPDIR="$(dirname "$0")"
export PYTHONHOME=$APPDIR/usr/conda
$APPDIR/usr/bin/python3 $APPDIR/opt/PINCE/PINCE.py
EOF
chmod +x AppRun.sh

# Patch libqxcb's runpath (not rpath) to point to our packaged libxcb-cursor to fix X11 issues
patchelf --add-rpath "\$ORIGIN/../../../../../../" AppDir/usr/conda/lib/python3.13/site-packages/PyQt6/Qt6/plugins/platforms/libqxcb.so

# Package AppDir into AppImage
export LD_LIBRARY_PATH="$(readlink -f ./AppDir/usr/conda/lib)"
$DEPLOYTOOL --icon-file PINCE.png --appdir AppDir/ --output appimage --custom-apprun AppRun.sh || exit_on_failure

```

`compile_gdb.sh`:

```sh
#!/bin/bash
: '
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'

# This script installs a specific gdb version locally, the default installation script doesn't need this anymore, you can use it as a fallback if system gdb is being problematic
# After installing a local gdb, you must specify its binary location via the Settings->Debug

echo "This script will install GDB locally in the gdb_pince folder"
echo "To see the available GDB versions, visit -> https://ftp.gnu.org/gnu/gdb/"
read -r -p "Enter the GDB version number (e.g., 14.1): " version_number

GDB_VERSION="gdb-$version_number"

if [ -z "$NUM_MAKE_JOBS" ]; then
    NUM_MAKE_JOBS=$(lscpu -p=core | uniq | awk '!/#/' | wc -l)
    MAX_NUM_MAKE_JOBS=8
    if [ "$NUM_MAKE_JOBS" -gt "$MAX_NUM_MAKE_JOBS" ]; then # set an upper limit to prevent Out-Of-Memory
        NUM_MAKE_JOBS=$MAX_NUM_MAKE_JOBS
    fi
    if ! echo "$NUM_MAKE_JOBS" | grep -Eq '^[0-9]+$'; then # fallback
        NUM_MAKE_JOBS=$MAX_NUM_MAKE_JOBS
    fi
fi

mkdir -p gdb_pince
cd gdb_pince || exit

# clean the directory if another installation happened
rm -rf "$GDB_VERSION"

if [ ! -e "${GDB_VERSION}".tar.gz ] ; then
    wget "http://ftp.gnu.org/gnu/gdb/${GDB_VERSION}.tar.gz" || exit
fi
tar -zxvf "${GDB_VERSION}".tar.gz
cd "$GDB_VERSION" || exit
echo "-------------------------------------------------------------------------"
echo "DISCLAIMER"
echo "-------------------------------------------------------------------------"
echo "If you're not on debian or a similar distro with the 'apt' package manager the follow will not work if you don't have gcc and g++ installed"
echo "Please install them manually for this to work, this issue will be addressed at a later date"

sudo apt-get install python3-dev libgmp3-dev libmpc-dev

CC=gcc CXX=g++ ./configure --prefix="$(pwd)" --with-python=python3 && make -j"$NUM_MAKE_JOBS" MAKEINFO=true && sudo make -C gdb install

if [ ! -e bin/gdb ] ; then
    echo "Failed to install GDB, restart the installation process"
    exit 1
fi

# In case of python part of gdb installation fails
sudo cp -R gdb/data-directory/* share/gdb/

```

`compile_ts.sh`:

```sh
#!/bin/bash
script_dir="$(dirname "$(readlink -f "$0")")"
cd $script_dir
venv_activator=".venv/bin/activate"

if [ -f "$venv_activator" ]; then
	. "$venv_activator"
else
    echo "ERROR: Virtual environment not found, please use install.sh to install PINCE first"
	exit
fi

supported_locale_list=$(python3 -c "
import locale
print('\n'.join(value.split('.')[0] for value in locale.locale_alias.values()))
")
list_ts=$(find i18n/ts -maxdepth 1 -type f -name '*.ts')

# If there's a user parameter, create a new locale based on it
if [ -n "$1" ]; then
    list_ts="$list_ts i18n/ts/$1.ts"
fi

for ts in $list_ts; do
	# Check if the locale is valid
	if echo "$supported_locale_list" | grep -q "$(basename "$ts" .ts)"; then
		pylupdate6 GUI/*.ui GUI/Widgets/*/Form/*.ui tr/tr.py --no-obsolete --ts "$ts"
		python3 fix_ts.py "$ts"
	else
		list_invalidts="$list_invalidts $ts"
	fi
done

if [ -n "$list_invalidts" ]; then
	echo
	echo "ERROR: The following locales are invalid, please check:"
	echo "$list_invalidts"
	exit 1
fi

```

`docs/Makefile`:

```
# Minimal makefile for Sphinx documentation
#

# You can set these variables from the command line, and also
# from the environment for the first two.
SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = source
BUILDDIR      = build

# Put it first so that "make" without argument is like "make help".
help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

# Catch-all target: route all unknown targets to Sphinx using the new
# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

```

`docs/build_html.sh`:

```sh
#!/bin/bash
script_dir="$(dirname "$(readlink -f "$0")")"
cd $script_dir
venv_activator="../.venv/bin/activate"

if [ -f "$venv_activator" ]; then
	. "$venv_activator"
else
    echo "ERROR: Virtual environment not found, please use install.sh to install PINCE first"
    exit
fi

make clean
make html

```

`docs/install_sphinx.sh`:

```sh
#!/bin/bash
script_dir="$(dirname "$(readlink -f "$0")")"
cd $script_dir
venv_activator="../.venv/bin/activate"

if [ -f "$venv_activator" ]; then
	. "$venv_activator"
else
    echo "ERROR: Virtual environment not found, please use install.sh to install PINCE first"
    exit
fi

pip install sphinx
pip install sphinx-autodoc-typehints

```

`docs/source/conf.py`:

```py
# Configuration file for the Sphinx documentation builder.
#
# For the full list of built-in configuration values, see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

# -- Project information -----------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information

import os
import sys

sys.path.insert(0, os.path.abspath(os.path.join("..", "..")))

project = "PINCE"
copyright = "2024, PINCE Contributors"
author = "PINCE Contributors"

# -- General configuration ---------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#general-configuration

extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.napoleon",
    "sphinx.ext.todo",
    "sphinx.ext.viewcode",
    "sphinx.ext.intersphinx",
    "sphinx_autodoc_typehints",
]

templates_path = ["_templates"]
exclude_patterns = []

# Mock imports for compiled C extensions and modules that aren't needed for documentation
autodoc_mock_imports = [
    "libpince.libscanmem",
    "libpince.libscanmem.scanmem",
    "libpince.libptrscan",
]


# -- Options for HTML output -------------------------------------------------
# https://www.sphinx-doc.org/en/master/usage/configuration.html#options-for-html-output

html_theme = "alabaster"
html_static_path = ["_static"]

```

`docs/source/gui_utils.rst`:

```rst
GUI.Utils package
=================

Submodules
----------

GUI.Utils.guiutils module
-------------------------

.. automodule:: GUI.Utils.guiutils
   :members:
   :undoc-members:
   :show-inheritance:

GUI.Utils.guitypedefs module
----------------------------

.. automodule:: GUI.Utils.guitypedefs
   :members:
   :undoc-members:
   :show-inheritance:

GUI.Utils.utilwidgets module
----------------------------

.. automodule:: GUI.Utils.utilwidgets
   :members:
   :undoc-members:
   :show-inheritance:

```

`docs/source/index.rst`:

```rst
.. PINCE documentation master file, created by sphinx-quickstart
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Welcome to PINCE's documentation!
=================================

.. toctree::
   :maxdepth: 2
   :caption: Contents:

   modules

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`

```

`docs/source/libpince.rst`:

```rst
libpince package
================

Submodules
----------

libpince.debugcore module
-------------------------

.. automodule:: libpince.debugcore
   :members:
   :undoc-members:
   :show-inheritance:

libpince.regexes module
-----------------------

.. automodule:: libpince.regexes
   :members:
   :undoc-members:
   :show-inheritance:

libpince.typedefs module
------------------------

.. automodule:: libpince.typedefs
   :members:
   :undoc-members:
   :show-inheritance:

libpince.utils module
---------------------

.. automodule:: libpince.utils
   :members:
   :undoc-members:
   :show-inheritance:

Module contents
---------------

.. automodule:: libpince
   :members:
   :undoc-members:
   :show-inheritance:

```

`docs/source/modules.rst`:

```rst
libpince
========

.. toctree::
   :maxdepth: 4

   libpince

GUI.Utils
=========

.. toctree::
   :maxdepth: 4

   gui_utils

```

`fix_ts.py`:

```py
import xml.etree.ElementTree as ET
import sys
import os

file = sys.argv[1]
tree = ET.parse(file, parser=ET.XMLParser(encoding="utf-8"))
root = tree.getroot()

# pylupdate6 doesn't set locale on creation, make sure it's there
locale = os.path.splitext(os.path.basename(file))[0]
root.set("language", locale)

# Removing line info so updating tr.py affects git history much less
for location in root.findall(".//location"):
    location.set("line", "0")

modified_xml = ET.tostring(root, encoding="utf-8", xml_declaration=False).decode()
with open(file, "r", encoding="utf-8") as f:
    original_xml = f.read()

# These declarations are hardcoded in pylupdate6, make sure everything is correct
declarations = original_xml.split("\n", 2)[:2]
assert declarations[0] == '<?xml version="1.0" encoding="utf-8"?>', "xml format has changed"
assert declarations[1] == "<!DOCTYPE TS>", "doctype format has changed"
final_xml = "\n".join(declarations) + "\n" + modified_xml + "\n"

with open(file, "w", encoding="utf-8") as f:
    f.write(final_xml)

```

`i18n/ts/it_IT.ts`:

```ts
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.1" language="it_IT">
  <context>
    <name>Dialog</name>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Add Address Manually</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Type:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Endianness:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Hex</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Signed</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/HexEditDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Length:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Zero-Terminated</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Base Address:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Add Offset</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Remove Offset</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Description:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/HexEditDialog.ui" line="0" />
        <location filename="../../GUI/EditInstructionDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Address:</source>
        <translation>Indirizzo:</translation>
    </message>
    <message>
        <location filename="../../GUI/TrackSelectorDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Pointer</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Dissect Code</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Regions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Path</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Selected regions will be scanned</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Currently scanning range:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>String references found:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Jumps found:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Calls found:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Entries that can't be decoded as utf-8 won't be included in referenced strings
Unchecking it makes ReferencedStringsWidget load slower but allows you to examine non-string pointers on it</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Discard invalid strings</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/EditInstructionDialog.ui" line="0" />
        <source>Edit Instruction</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/EditInstructionDialog.ui" line="0" />
        <source>Instruction:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/EditInstructionDialog.ui" line="0" />
        <source>Multiple entries are separated with ;</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <source>Type</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <source>Endianness</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <source>Length</source>
        <translation type="unfinished">Lunghezza</translation>
    </message>
    <message>
        <location filename="../../GUI/HexEditDialog.ui" line="0" />
        <source>Hex Edit</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/HexEditDialog.ui" line="0" />
        <source>Refresh</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/LoadingDialog.ui" line="0" />
        <source>Processing</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/LoadingDialog.ui" line="0" />
        <source>Cancel</source>
        <translation>Annulla</translation>
    </message>
    <message>
        <location filename="../../GUI/TextEditDialog.ui" line="0" />
        <source>Dialog</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TextEditDialog.ui" line="0" />
        <source>Hit Esc to cancel and Ctrl+Enter to accept</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Parameters for tracing</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Number of the instructions that'll be traced</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Max trace count(1 or greater):</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Tracing will start if this condition is met</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Trigger condition(Optional, gdb expression):</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Tracing will stop whenever this condition is met</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Stop condition(Optional, gdb expression):</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Step over instead of single step</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Stop when tracing ends</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Collect registers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TrackSelectorDialog.ui" line="0" />
        <source>Select an address to track</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TrackSelectorDialog.ui" line="0" />
        <source>Pointed Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/HandleSignals/Form/HandleSignalsDialog.ui" line="0" />
        <source>Handle Signals</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/HandleSignals/Form/HandleSignalsDialog.ui" line="0" />
        <source>Signal</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/HandleSignals/Form/HandleSignalsDialog.ui" line="0" />
        <source>Stop &amp; Print</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/HandleSignals/Form/HandleSignalsDialog.ui" line="0" />
        <source>Pass to Program</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Manage Scan Regions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Selected regions will be deleted from the current scan</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Invert Selection</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>ID</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Start Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Size(bytes)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Load Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Perms</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>File</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui" line="0" />
        <source>Filter Pointers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui" line="0" />
        <source>File 1:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui" line="0" />
        <source>Browse</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui" line="0" />
        <source>File 2:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Scan for Pointers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Address</source>
        <translation type="unfinished">Indirizzo</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Depth</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Scan Range</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>0x</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>&lt;-&gt;</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>File Path:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Optional Parameters (0 or empty will use defaults)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Last Offset Scan Range</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Minimum Chain Length</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Last Offset Value</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Max Results</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Solve Circular References</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Settings</source>
        <translation>Impostazioni</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>General</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Hotkeys</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Code Injection</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Memory View</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Debug</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Java</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Auto-update address table</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Update Interval</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Freeze Interval</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>GDB output:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Async</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Command</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Command info</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>On start, automatically attach to processes with name matching one of the entries
Patterns at former positions have higher priority if regex is off</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Auto-attach to processes named</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Regex</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Language</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Logo</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Theme</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Functions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Hotkey</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Press shortcut</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Clear</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Code injection method:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Simp&amp;le dlopen call</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Advanced In&amp;jection</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Bring Memory View to front when the inferior is stopped</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Instructions shown per scroll in Disassembly View</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Bytes shown per scroll in Hex View</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>GDB Path</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>GDB Logging</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Interruption signal</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Ignore SIGSEGV for Java processes (overrides signal settings if enabled)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Reset Settings</source>
        <translation type="unfinished" />
    </message>
</context><context>
    <name>Form</name>
    <message>
        <location filename="../../GUI/ConsoleWidget.ui" line="0" />
        <source>GDB Console</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/ConsoleWidget.ui" line="0" />
        <source>Send</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/ConsoleWidget.ui" line="0" />
        <source>CLI</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/ConsoleWidget.ui" line="0" />
        <source>MI</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Examine Referrers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Enter a string or a python regex</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Ignore case if checked</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Case sensitive</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Your string will be treated as a regex if checked</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Regex</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Search(Enter)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <source>Functions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.ui" line="0" />
        <location filename="../../GUI/TrackWatchpointWidget.ui" line="0" />
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <source>Address</source>
        <translation type="unfinished">Indirizzo</translation>
    </message>
    <message>
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <source>Symbol</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <source>Enter the regex. Leave blank to see all functions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TrackWatchpointWidget.ui" line="0" />
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <location filename="../../GUI/LogFileWidget.ui" line="0" />
        <source>Form</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/LogFileWidget.ui" line="0" />
        <location filename="../../GUI/LogFileWidget.ui" line="0" />
        <source>TextLabel</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryRegionsWidget.ui" line="0" />
        <source>Memory Regions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryRegionsWidget.ui" line="0" />
        <source>Regions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryRegionsWidget.ui" line="0" />
        <source>Perms</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryRegionsWidget.ui" line="0" />
        <source>Offset</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryRegionsWidget.ui" line="0" />
        <source>Path</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <source>Referenced Calls</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <source>Refcount</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <source>Referenced Strings and Values</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <source>Value</source>
        <translation type="unfinished">Valore</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <source>Search for Opcodes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <source>Start</source>
        <translation>Inizio</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <source>End</source>
        <translation>Fine</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <source>Opcodes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/StackTraceInfoWidget.ui" line="0" />
        <source>StackTrace Information</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/StackTraceInfoWidget.ui" line="0" />
        <source>Return Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Bookmark/Form/BookmarkWidget.ui" line="0" />
        <location filename="../../GUI/StackTraceInfoWidget.ui" line="0" />
        <source>Info</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWaitWidget.ui" line="0" />
        <source>Tracer Status</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWaitWidget.ui" line="0" />
        <source>Cancel</source>
        <translation type="unfinished">Annulla</translation>
    </message>
    <message>
        <location filename="../../GUI/TrackWatchpointWidget.ui" line="0" />
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <source>Count</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <source>Source</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TrackWatchpointWidget.ui" line="0" />
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <source>Stop</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TrackWatchpointWidget.ui" line="0" />
        <source>Refresh</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Bookmark/Form/BookmarkWidget.ui" line="0" />
        <source>Bookmarks</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Bookmark/Form/BookmarkWidget.ui" line="0" />
        <source>Bookmarked Addresses</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Bookmark/Form/BookmarkWidget.ui" line="0" />
        <source>Comment</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.ui" line="0" />
        <source>Restore Instructions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.ui" line="0" />
        <source>Original OpCode</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.ui" line="0" />
        <source>Original Instruction</source>
        <translation type="unfinished" />
    </message>
</context><context>
    <name>MainWindow</name>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Memory View</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Copy selected items to the address table</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Erase all the table contents</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Refresh the address table[R]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Add Address Manually</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Freeze</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Freeze the value. Click just to the right of checkbox to cycle between freeze types:
- No arrow: Frozen at current value
- ▲: Allow increments only
- ▼: Allow decrements only</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Description</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Address</source>
        <translation>Indirizzo</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Type</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Value</source>
        <translation>Valore</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Match count: 0</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Previous</source>
        <translation>Precedente</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>First Scan</source>
        <translation>Prima Ricerca</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Next Scan</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Undo Scan</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Hex</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Scan Type:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Value Type:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Scan Scope:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Endianness:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Manage Scan Regions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Open session notes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Notes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Create or attach to a process</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Open a cheat table</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Save current table to a file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Wiki</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>About</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>No Process Selected</source>
        <translation type="unfinished">Nessun Processo Selezionato</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Open a gdb console</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Configure options</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Please select a Process</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Name or PID of the Process:</source>
        <translation>Nome o PID del processo:</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>PID</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Username</source>
        <translation>Nome Utente</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Process Name</source>
        <translation>Nome Processo</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Attach to the selected process</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWindow.ui" line="0" />
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Open</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Cancel</source>
        <translation>Annulla</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Open an executable</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Create Process[F1]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWindow.ui" line="0" />
        <source>Tracer</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <location filename="../../GUI/TraceInstructionsWindow.ui" line="0" />
        <source>File</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWindow.ui" line="0" />
        <source>Save</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWindow.ui" line="0" />
        <source>Save as a text file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Libpince Engine</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Tab 1</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Templates</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Help</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Run</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Code Injection</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Open [Ctrl+O]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Save [Ctrl+S]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Libpince</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Run current script [Ctrl+R]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>Pointer Scanner</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>Sort</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>Clear</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>Fi&amp;le</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>Actio&amp;ns</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>&amp;Open</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>&amp;Save As...</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>&amp;Scan</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>&amp;Filter</source>
        <translation type="unfinished" />
    </message>
</context><context>
    <name>MainWindow_MemoryView</name>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Memory Viewer</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Address</source>
        <translation type="unfinished">Indirizzo</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Bytes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Opcodes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Comment</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Registers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Flags</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Segment Registers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Show Float Registers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Return Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Frame Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Value</source>
        <translation type="unfinished">Valore</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Points to</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>V&amp;iew</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Debug</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Tools</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Fi&amp;le</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Help</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Bookmarks</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;StackTrace Info</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Inject .so file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Break</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Run</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Step[F7]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Step &amp;Over[F8]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Execute Till Return[Shift+F8]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Toggle Breakpoint[F5]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>B&amp;reakpoints</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Functions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Set Address[Shift+F4]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Call Function</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Load Trace</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Libpince</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;GDB Log File</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Search Opcode</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Memory Regions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Dissect Code</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>R&amp;eferenced Strings</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Referenced &amp;Calls</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>To&amp;ggle Attach</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Restore Instructions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Libpince Engine</source>
        <translation type="unfinished" />
    </message>
</context><context>
    <name>QPlatformTheme</name>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>OK</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>&amp;Open</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>&amp;Save</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cancel</source>
        <translation type="unfinished">Annulla</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Close</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Discard</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Apply</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Reset</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Restore Defaults</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Help</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Save All</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>&amp;Yes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>&amp;No</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Abort</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Retry</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Ignore</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>N&amp;o to All</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Yes to &amp;All</source>
        <translation type="unfinished" />
    </message>
</context><context>
    <name>SessionNotes</name>
    <message>
        <location filename="../../GUI/Widgets/SessionNotes/Form/SessionNotes.ui" line="0" />
        <source>Notes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/SessionNotes/Form/SessionNotes.ui" line="0" />
        <source>Session Notes</source>
        <translation type="unfinished" />
    </message>
</context><context>
    <name>TabWidget</name>
    <message>
        <location filename="../../GUI/AboutWidget.ui" line="0" />
        <source>About PINCE</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/AboutWidget.ui" line="0" />
        <source>Contributors</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/AboutWidget.ui" line="0" />
        <source>License</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Breakpoints</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Interactive</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>No</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Type</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Disp</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Enabled</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Address</source>
        <translation type="unfinished">Indirizzo</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Size</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>On Hit</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Hit Count</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Condition</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Raw</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/FloatRegisterWidget.ui" line="0" />
        <source>Floating Point Registers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/FloatRegisterWidget.ui" line="0" />
        <location filename="../../GUI/FloatRegisterWidget.ui" line="0" />
        <source>Register</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/FloatRegisterWidget.ui" line="0" />
        <location filename="../../GUI/FloatRegisterWidget.ui" line="0" />
        <source>Value</source>
        <translation type="unfinished">Valore</translation>
    </message>
</context><context>
    <name>TranslationConstants</name>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Pause the process</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Break the process</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Continue the process</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cancel ongoing GDB command</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle attach/detach</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Exact</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Not</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Increased</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Increased By</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Decreased</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Decreased By</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Less Than</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - More Than</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Between</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Changed</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Unchanged</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Error</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Success</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Information</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>GDB isn't initialized yet</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to initialize GDB
You might want to reinstall GDB or use the system GDB
To change the current GDB path, check Settings-&gt;Debug</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Edit</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show as hexadecimal</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show as decimal</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show as unsigned</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show as signed</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle including children</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Freeze</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Default</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Browse this memory region</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Disassemble this address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Delete</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Delete selection</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cut</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Paste</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Paste inside</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Pointer scan for this address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Open pointer scanner</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Pointer scan finished.

Don't forget to open the scandata file (File-&gt;Open)!</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Find out what writes to this address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Find out what reads this address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Find out what accesses this address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Add to a new group</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Create a new group</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Group</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Invalid clipboard content</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>New Scan</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Match count: {} ({} shown)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Match count: {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>No Description</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Open PCT file(s)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Open script file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Save script file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>(untitled)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Script execution failed:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>PINCE Cheat Table (*.pct)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Python Scripts (*.py)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Shared object library (*.so)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Trace File (*.trace)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Pointer Scan Data (*.scandata)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Clear address table?</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>File {} is inaccessible or contains invalid content</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Save PCT file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cannot save to file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Nice try, smartass</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Selected process is not valid</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>You're debugging this process already</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>That process is already being traced by {}, could not attach to the process</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Permission denied, could not attach to the process</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>An error occurred while trying to create process</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Scan for</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>First Scan</source>
        <translation type="unfinished">Prima Ricerca</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>No Process Selected</source>
        <translation type="unfinished">Nessun Processo Selezionato</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>[detached]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>[stopped]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>This requires the process to be stopped</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the new value</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the new description</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Edit Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Please select a process first</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Select the target binary</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the optional arguments</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>LD_PRELOAD .so path (optional)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Refresh</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Length is not valid</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Length must be greater than 0</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Can't parse the input</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>{} isn't a valid regex</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Language settings will take effect upon the next restart</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>You have changed the GDB path, reset GDB now?</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>This will reset to the default settings
Proceed?</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Mouse over on this text for examples</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>asdf|qwer --&gt; search for asdf or qwer
[as]df --&gt; search for both adf and sdf
Use the char \ to escape special chars such as [
\[asdf\] --&gt; search for opcodes that contain [asdf]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Separate processes with {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>This setting is unused in AppImage builds</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Select the gdb binary</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Quitting current session will crash PINCE</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Use global hotkeys or the commands 'interrupt' and 'c&amp;' to stop/run the inferior</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Hotkeys:
-----------------------------
Send: Enter                 |
Multi-line mode: Ctrl+Enter |
Complete command: Tab       |
-----------------------------
Commands:
----------------------------------------------------------
/clear: Clear the console                                |
phase-out: Detach from the current process               |
phase-in: Attach back to the previously detached process |
---------------------------------------------------------------------------------------------------
You can change the output mode from bottom right
Changing output mode only affects commands sent. Any other output coming from external sources(e.g async output) will be shown in MI format</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Break[{}]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Run[{}]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle Attach[{}]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Failed to set breakpoint at address {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Failed to set watchpoint at address {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy to Clipboard</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Go to expression</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Add this address to address list</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Set Watchpoint</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Write Only</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Read Only</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Both</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Add/Change condition for breakpoint</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Delete Breakpoint</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the expression</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>{} is invalid</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Protection:{} | Base:{}-{} | Module:{}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Invalid Region</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cannot access memory at expression {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Referenced by:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Press 'Ctrl+E' to see a detailed list of referrers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Memory Viewer - Paused</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Memory Viewer - Currently debugging {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Memory Viewer - Running</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the expression for condition, for instance:

$eax==0x523
$rax&gt;0 &amp;&amp; ($rbp&lt;0 || $rsp==0)
printf($r10)==3</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Failed to set condition for address {}
Check terminal for details</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Full Stack</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Return Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Frame Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Stacktrace</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle stack from BP/SP register</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Value</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Points to</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Disassemble 'value' pointer address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show 'value' pointer in HexView</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Back</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show this address in HexView</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Follow</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Examine Referrers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Bookmark this address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Delete this bookmark</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Change comment</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Go to bookmarked address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle Breakpoint</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Edit instruction</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Replace instruction with NOPs</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Find out which addresses this instruction accesses</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Break and trace instructions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Dissect this region</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Bytes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Opcode</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Comment</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy All</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the register expression(s) you want to track
Register names must start with $
Each expression must be separated with a comma

For instance:
Let's say the instruction is mov [rax+rbx],30
Then you should enter $rax+$rbx
So PINCE can track address [rax+rbx]

Another example:
If you enter $rax,$rbx*$rcx+4,$rbp
PINCE will track down addresses [rax],[rbx*rcx+4] and [rbp]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>This address has already been bookmarked</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the comment for bookmarked address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Select the .so file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>The file has been injected</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Failed to inject the .so file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the expression for the function that'll be called from the inferior
You can view functions list from View-&gt;Functions

For instance:
Calling printf("1234") will yield something like this
↓
$28 = 4

$28 is the assigned convenience variable
4 is the result
You can use the assigned variable from the GDB Console</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Failed to call the expression {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Invalid expression or address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Invalid entries detected, refreshing the page</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Add new entry</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the new value of register {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the new value of flag {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Restore this instruction</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the hit count({} or higher)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Hit count must be an integer</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Hit count can't be lower than {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Change condition</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enable</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Disable</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Disable after hit</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Disable after X hits</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Delete after hit</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Opcodes writing to the address {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Opcodes reading from the address {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Opcodes accessing to the address {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to track watchpoint at expression {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to delete watchpoint at expression {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Close</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Addresses accessed by instruction {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to track breakpoint at expression {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Accessed by {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to delete breakpoint at expression {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Max trace count must be greater than or equal to {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Save trace file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Open trace file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Expand All</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Collapse All</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Select a pointer map file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Scan</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Scanning</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Filter</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Filtering</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>DEFINED</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>This symbol is defined. You can use its body as a gdb expression. For instance:

void func(param) can be used as 'func' as a gdb expression</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Symbol</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>	Here's some useful regex tips:
^quaso --&gt; search for everything that starts with quaso
[ab]cd --&gt; search for both acd and bcd

	How to interpret symbols:
A symbol that looks like 'func(param)@plt' consists of 3 pieces
func, func(param), func(param)@plt
These 3 functions will have different addresses
@plt means this function is a subroutine for the original one
There can be more than one of the same function
It means that the function is overloaded</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>New opcode is {} bytes long but old opcode is only {} bytes long
This will cause an overflow, proceed?</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>{} isn't a valid expression</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Log File of PID {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Contents of {} (only last {} bytes are shown)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>ON</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>OFF</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>LOGGING: {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to read log file at {}</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Go to Settings-&gt;Debug to enable logging</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Invalid Regex</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>	Here's some useful regex examples:
call|rax --&gt; search for opcodes that contain call or rax
[re]cx --&gt; search for both rcx and ecx
Use the char \ to escape special chars such as [
\[rsp\] --&gt; search for opcodes that contain [rsp]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Addresses</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Offset</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Path</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Start</source>
        <translation type="unfinished">Inizio</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Currently scanning region:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cancel</source>
        <translation type="unfinished">Annulla</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Scan finished</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Scan was canceled</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Select at least one region</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>You need to dissect code first
Proceed?</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Waiting for breakpoint to trigger</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Tracing has been completed</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Not</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Exact</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Increased</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Increased by</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Decreased</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Decreased by</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Less Than</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>More Than</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Between</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Changed</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unchanged</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unknown Value</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Basic</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Normal</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Read+Write</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Full</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Host</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Little</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Big</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show in HexView</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show in Disassembler</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Dark</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Light</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>System Default</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Wong (Colorblind Friendly)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Session - Unsaved changes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>You have unsaved changes.
Do you want to save the current session?</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Session - Process changed</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>The process name has changed.
Do you want to keep the current session with the new process?</source>
        <translation type="unfinished" />
    </message>
</context></TS>

```

`i18n/ts/zh_CN.ts`:

```ts
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.1" language="zh_CN">
  <context>
    <name>Dialog</name>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Add Address Manually</source>
        <translation>手动添加地址</translation>
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Type:</source>
        <translation>类型：</translation>
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Endianness:</source>
        <translation>字节序：</translation>
    </message>
    <message>
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Hex</source>
        <translation>十六进制</translation>
    </message>
    <message>
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Signed</source>
        <translation>有符号</translation>
    </message>
    <message>
        <location filename="../../GUI/HexEditDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Length:</source>
        <translation>长度：</translation>
    </message>
    <message>
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Zero-Terminated</source>
        <translation>以零终止</translation>
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Base Address:</source>
        <translation>基址：</translation>
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Add Offset</source>
        <translation>添加偏移量</translation>
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Remove Offset</source>
        <translation>移除偏移量</translation>
    </message>
    <message>
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Description:</source>
        <translation>备注：</translation>
    </message>
    <message>
        <location filename="../../GUI/HexEditDialog.ui" line="0" />
        <location filename="../../GUI/EditInstructionDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Address:</source>
        <translation>地址：</translation>
    </message>
    <message>
        <location filename="../../GUI/TrackSelectorDialog.ui" line="0" />
        <location filename="../../GUI/AddAddressManuallyDialog.ui" line="0" />
        <source>Pointer</source>
        <translation>指针</translation>
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Dissect Code</source>
        <translation>分析代码</translation>
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Regions</source>
        <translation>区域</translation>
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Path</source>
        <translation>路径</translation>
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Selected regions will be scanned</source>
        <translation>选中区域将会被扫描</translation>
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Currently scanning range:</source>
        <translation>当前扫描范围：</translation>
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>String references found:</source>
        <translation>找到的 字符串引用：</translation>
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Jumps found:</source>
        <translation>找到的 跳转：</translation>
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Calls found:</source>
        <translation>找到的 调用：</translation>
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Entries that can't be decoded as utf-8 won't be included in referenced strings
Unchecking it makes ReferencedStringsWidget load slower but allows you to examine non-string pointers on it</source>
        <translation>无法解码为 UTF-8 的条目将不会包含在引用的字符串中
取消勾选此选项会导致 ReferencedStringsWidget 加载变慢，但允许你检查其中的非字符串指针</translation>
    </message>
    <message>
        <location filename="../../GUI/DissectCodeDialog.ui" line="0" />
        <source>Discard invalid strings</source>
        <translation>丢弃无效的字符串</translation>
    </message>
    <message>
        <location filename="../../GUI/EditInstructionDialog.ui" line="0" />
        <source>Edit Instruction</source>
        <translation>编辑指令</translation>
    </message>
    <message>
        <location filename="../../GUI/EditInstructionDialog.ui" line="0" />
        <source>Instruction:</source>
        <translation>指令：</translation>
    </message>
    <message>
        <location filename="../../GUI/EditInstructionDialog.ui" line="0" />
        <source>Multiple entries are separated with ;</source>
        <translation>多个条目用分号（;）分隔</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <source>Type</source>
        <translation>类型</translation>
    </message>
    <message>
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <source>Endianness</source>
        <translation>字节序</translation>
    </message>
    <message>
        <location filename="../../GUI/EditTypeDialog.ui" line="0" />
        <source>Length</source>
        <translation>长度</translation>
    </message>
    <message>
        <location filename="../../GUI/HexEditDialog.ui" line="0" />
        <source>Hex Edit</source>
        <translation>十六进制编辑</translation>
    </message>
    <message>
        <location filename="../../GUI/HexEditDialog.ui" line="0" />
        <source>Refresh</source>
        <translation>刷新</translation>
    </message>
    <message>
        <location filename="../../GUI/LoadingDialog.ui" line="0" />
        <source>Processing</source>
        <translation>处理中</translation>
    </message>
    <message>
        <location filename="../../GUI/LoadingDialog.ui" line="0" />
        <source>Cancel</source>
        <translation>取消</translation>
    </message>
    <message>
        <location filename="../../GUI/TextEditDialog.ui" line="0" />
        <source>Dialog</source>
        <translation>对话框</translation>
    </message>
    <message>
        <location filename="../../GUI/TextEditDialog.ui" line="0" />
        <source>Hit Esc to cancel and Ctrl+Enter to accept</source>
        <translation>按 Esc 取消，按 Ctrl+Enter 接受</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Parameters for tracing</source>
        <translation>用于追踪的参数</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Number of the instructions that'll be traced</source>
        <translation>将被追踪的指令数量</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Max trace count(1 or greater):</source>
        <translation>最大追踪次数（1 或更多）：</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Tracing will start if this condition is met</source>
        <translation>如果满足此条件，将开始追踪</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Trigger condition(Optional, gdb expression):</source>
        <translation>触发条件（可选，gdb表达式）：</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Tracing will stop whenever this condition is met</source>
        <translation>每当满足此条件时，追踪将停止</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Stop condition(Optional, gdb expression):</source>
        <translation>停止条件（可选，gdb表达式）：</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Step over instead of single step</source>
        <translation>步过（Step over）而不是单步</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Stop when tracing ends</source>
        <translation>当追踪结束时停止</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsPromptDialog.ui" line="0" />
        <source>Collect registers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TrackSelectorDialog.ui" line="0" />
        <source>Select an address to track</source>
        <translation>选择要跟踪的地址</translation>
    </message>
    <message>
        <location filename="../../GUI/TrackSelectorDialog.ui" line="0" />
        <source>Pointed Address</source>
        <translation>指向的地址</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/HandleSignals/Form/HandleSignalsDialog.ui" line="0" />
        <source>Handle Signals</source>
        <translation>处理信号</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/HandleSignals/Form/HandleSignalsDialog.ui" line="0" />
        <source>Signal</source>
        <translation>信号</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/HandleSignals/Form/HandleSignalsDialog.ui" line="0" />
        <source>Stop &amp; Print</source>
        <translation>停止和打印</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/HandleSignals/Form/HandleSignalsDialog.ui" line="0" />
        <source>Pass to Program</source>
        <translation>传递到程序</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Manage Scan Regions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Selected regions will be deleted from the current scan</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Invert Selection</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>ID</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Start Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Size(bytes)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Load Address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>Perms</source>
        <translation type="unfinished">权限</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/ManageScanRegions/Form/ManageScanRegionsDialog.ui" line="0" />
        <source>File</source>
        <translation type="unfinished">文件</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui" line="0" />
        <source>Filter Pointers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui" line="0" />
        <source>File 1:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui" line="0" />
        <source>Browse</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanFilter/Form/PointerScanFilterDialog.ui" line="0" />
        <source>File 2:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Scan for Pointers</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Address</source>
        <translation type="unfinished">地址</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Depth</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Scan Range</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>0x</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>&lt;-&gt;</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>File Path:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Optional Parameters (0 or empty will use defaults)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Last Offset Scan Range</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Minimum Chain Length</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Last Offset Value</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Max Results</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScanSearch/Form/PointerScanSearchDialog.ui" line="0" />
        <source>Solve Circular References</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Settings</source>
        <translation>设置</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>General</source>
        <translation>通用</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Hotkeys</source>
        <translation>热键</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Code Injection</source>
        <translation>代码注入</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Memory View</source>
        <translation type="unfinished">内存查看器</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Debug</source>
        <translation>调试</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Java</source>
        <translation>Java</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Auto-update address table</source>
        <translation>自动更新地址表</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Update Interval</source>
        <translation>更新间隔</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Freeze Interval</source>
        <translation>冻结间隔</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>GDB output:</source>
        <translation>GDB 输出：</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Async</source>
        <translation>异步</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Command</source>
        <translation>命令</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Command info</source>
        <translation>命令信息</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>On start, automatically attach to processes with name matching one of the entries
Patterns at former positions have higher priority if regex is off</source>
        <translation>启动时，自动附加到名称与其中一个条目匹配的进程
如果正则表达式关闭，靠前的条目有更高的优先级</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Auto-attach to processes named</source>
        <translation>自动附加到的进程名为</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Regex</source>
        <translation>正则表达式</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Language</source>
        <translation>语言</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Logo</source>
        <translation>图标</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Theme</source>
        <translation>主题</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Functions</source>
        <translation>功能</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Hotkey</source>
        <translation>热键</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Press shortcut</source>
        <translation>按下快捷键</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Clear</source>
        <translation>清除</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Code injection method:</source>
        <translation>代码注入模式：</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Simp&amp;le dlopen call</source>
        <translation>简单的 dlopen 调用[&amp;l]</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Advanced In&amp;jection</source>
        <translation>高级注入[&amp;j]</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Bring Memory View to front when the inferior is stopped</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Instructions shown per scroll in Disassembly View</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Bytes shown per scroll in Hex View</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>GDB Path</source>
        <translation>GDB 路径</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>GDB Logging</source>
        <translation>GDB 日志记录</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Interruption signal</source>
        <translation>中断信号</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Ignore SIGSEGV for Java processes (overrides signal settings if enabled)</source>
        <translation>忽略 Java 进程的分段错误（SIGSEGV）（如果启用，将会覆盖信号设置）</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Settings/Form/SettingsDialog.ui" line="0" />
        <source>Reset Settings</source>
        <translation>重置设置</translation>
    </message>
</context><context>
    <name>Form</name>
    <message>
        <location filename="../../GUI/ConsoleWidget.ui" line="0" />
        <source>GDB Console</source>
        <translation>GDB 控制台</translation>
    </message>
    <message>
        <location filename="../../GUI/ConsoleWidget.ui" line="0" />
        <source>Send</source>
        <translation>发送</translation>
    </message>
    <message>
        <location filename="../../GUI/ConsoleWidget.ui" line="0" />
        <source>CLI</source>
        <translation>CLI</translation>
    </message>
    <message>
        <location filename="../../GUI/ConsoleWidget.ui" line="0" />
        <source>MI</source>
        <translation>MI</translation>
    </message>
    <message>
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Examine Referrers</source>
        <translation>检查引用来源</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Enter a string or a python regex</source>
        <translation>输入字符串或 Python 正则表达式</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Ignore case if checked</source>
        <translation>如果选中则忽略大小写</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Case sensitive</source>
        <translation>大小写敏感</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Your string will be treated as a regex if checked</source>
        <translation>如果选中，你的字符串将被视为正则表达式</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Regex</source>
        <translation>正则</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <location filename="../../GUI/ExamineReferrersWidget.ui" line="0" />
        <source>Search(Enter)</source>
        <translation>搜索（Enter）</translation>
    </message>
    <message>
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <source>Functions</source>
        <translation>函数</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.ui" line="0" />
        <location filename="../../GUI/TrackWatchpointWidget.ui" line="0" />
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <source>Address</source>
        <translation>地址</translation>
    </message>
    <message>
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <source>Symbol</source>
        <translation>符号</translation>
    </message>
    <message>
        <location filename="../../GUI/FunctionsInfoWidget.ui" line="0" />
        <source>Enter the regex. Leave blank to see all functions</source>
        <translation>请输入正则表达式。如果不输入任何内容，则会显示所有函数</translation>
    </message>
    <message>
        <location filename="../../GUI/TrackWatchpointWidget.ui" line="0" />
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <location filename="../../GUI/LogFileWidget.ui" line="0" />
        <source>Form</source>
        <translation>表格</translation>
    </message>
    <message>
        <location filename="../../GUI/LogFileWidget.ui" line="0" />
        <location filename="../../GUI/LogFileWidget.ui" line="0" />
        <source>TextLabel</source>
        <translation>文本标签</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryRegionsWidget.ui" line="0" />
        <source>Memory Regions</source>
        <translation>内存区域</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryRegionsWidget.ui" line="0" />
        <source>Regions</source>
        <translation>区域</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryRegionsWidget.ui" line="0" />
        <source>Perms</source>
        <translation>权限</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryRegionsWidget.ui" line="0" />
        <source>Offset</source>
        <translation>偏移量</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryRegionsWidget.ui" line="0" />
        <source>Path</source>
        <translation>路径</translation>
    </message>
    <message>
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <source>Referenced Calls</source>
        <translation>引用的调用</translation>
    </message>
    <message>
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedCallsWidget.ui" line="0" />
        <source>Refcount</source>
        <translation>引用计数</translation>
    </message>
    <message>
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <source>Referenced Strings and Values</source>
        <translation>引用的字符串和值</translation>
    </message>
    <message>
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <location filename="../../GUI/ReferencedStringsWidget.ui" line="0" />
        <source>Value</source>
        <translation>值</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <source>Search for Opcodes</source>
        <translation>搜索操作码</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <source>Start</source>
        <translation>开始</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <source>End</source>
        <translation>结束</translation>
    </message>
    <message>
        <location filename="../../GUI/SearchOpcodeWidget.ui" line="0" />
        <source>Opcodes</source>
        <translation>操作码</translation>
    </message>
    <message>
        <location filename="../../GUI/StackTraceInfoWidget.ui" line="0" />
        <source>StackTrace Information</source>
        <translation>堆栈跟踪信息</translation>
    </message>
    <message>
        <location filename="../../GUI/StackTraceInfoWidget.ui" line="0" />
        <source>Return Address</source>
        <translation>返回地址</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Bookmark/Form/BookmarkWidget.ui" line="0" />
        <location filename="../../GUI/StackTraceInfoWidget.ui" line="0" />
        <source>Info</source>
        <translation>信息</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWaitWidget.ui" line="0" />
        <source>Tracer Status</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWaitWidget.ui" line="0" />
        <source>Cancel</source>
        <translation>取消</translation>
    </message>
    <message>
        <location filename="../../GUI/TrackWatchpointWidget.ui" line="0" />
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <source>Count</source>
        <translation>计数</translation>
    </message>
    <message>
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <source>Source</source>
        <translation>源</translation>
    </message>
    <message>
        <location filename="../../GUI/TrackWatchpointWidget.ui" line="0" />
        <location filename="../../GUI/TrackBreakpointWidget.ui" line="0" />
        <source>Stop</source>
        <translation>停止</translation>
    </message>
    <message>
        <location filename="../../GUI/TrackWatchpointWidget.ui" line="0" />
        <source>Refresh</source>
        <translation>刷新</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Bookmark/Form/BookmarkWidget.ui" line="0" />
        <source>Bookmarks</source>
        <translation>书签</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Bookmark/Form/BookmarkWidget.ui" line="0" />
        <source>Bookmarked Addresses</source>
        <translation>书签地址</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/Bookmark/Form/BookmarkWidget.ui" line="0" />
        <source>Comment</source>
        <translation>注解</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.ui" line="0" />
        <source>Restore Instructions</source>
        <translation>还原指令</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.ui" line="0" />
        <source>Original OpCode</source>
        <translation>原始操作码</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/RestoreInstructions/Form/RestoreInstructionsWidget.ui" line="0" />
        <source>Original Instruction</source>
        <translation>原始指令</translation>
    </message>
</context><context>
    <name>MainWindow</name>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Memory View</source>
        <translation>内存查看器</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Copy selected items to the address table</source>
        <translation>将所选项目复制到地址表</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Erase all the table contents</source>
        <translation>删除地址表中所有内容</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Refresh the address table[R]</source>
        <translation>刷新地址表[R]</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Add Address Manually</source>
        <translation>手动添加地址</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Freeze</source>
        <translation>冻结</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Freeze the value. Click just to the right of checkbox to cycle between freeze types:
- No arrow: Frozen at current value
- ▲: Allow increments only
- ▼: Allow decrements only</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Description</source>
        <translation>备注</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Address</source>
        <translation>地址</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Type</source>
        <translation>类型</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Value</source>
        <translation>值</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Match count: 0</source>
        <translation>匹配次数：0</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Previous</source>
        <translation>先前的值</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>First Scan</source>
        <translation>首次扫描</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Next Scan</source>
        <translation>再次扫描</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Undo Scan</source>
        <translation>撤销扫描</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Hex</source>
        <translation>十六进制</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Scan Type:</source>
        <translation>扫描类型：</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Value Type:</source>
        <translation>值类型：</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Scan Scope:</source>
        <translation>扫描范围：</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Endianness:</source>
        <translation>字节序：</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Manage Scan Regions</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Open session notes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Notes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Create or attach to a process</source>
        <translation>创建或附加到进程</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Open a cheat table</source>
        <translation>打开一个PCT文件</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Save current table to a file</source>
        <translation>将当前表保存到文件</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Wiki</source>
        <translation>文档</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>About</source>
        <translation>关于</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>No Process Selected</source>
        <translation>未附加到任何进程</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Open a gdb console</source>
        <translation>打开一个 GDB 控制台</translation>
    </message>
    <message>
        <location filename="../../GUI/MainWindow.ui" line="0" />
        <source>Configure options</source>
        <translation>配置选项</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Please select a Process</source>
        <translation>请选择一个进程</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Name or PID of the Process:</source>
        <translation>进程名称或PID：</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>PID</source>
        <translation>PID</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Username</source>
        <translation>用户名</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Process Name</source>
        <translation>进程名称</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Attach to the selected process</source>
        <translation>附加到选中进程</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWindow.ui" line="0" />
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Open</source>
        <translation>打开</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Cancel</source>
        <translation>取消</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Open an executable</source>
        <translation>打开一个可执行程序</translation>
    </message>
    <message>
        <location filename="../../GUI/SelectProcess.ui" line="0" />
        <source>Create Process[F1]</source>
        <translation>创建进程[F1]</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWindow.ui" line="0" />
        <source>Tracer</source>
        <translation>追踪器</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <location filename="../../GUI/TraceInstructionsWindow.ui" line="0" />
        <source>File</source>
        <translation>文件</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWindow.ui" line="0" />
        <source>Save</source>
        <translation>保存</translation>
    </message>
    <message>
        <location filename="../../GUI/TraceInstructionsWindow.ui" line="0" />
        <source>Save as a text file</source>
        <translation>保存为文本文件</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Libpince Engine</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Tab 1</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Templates</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Help</source>
        <translation type="unfinished">帮助</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Run</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Code Injection</source>
        <translation type="unfinished">代码注入</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Open [Ctrl+O]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Save [Ctrl+S]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Libpince</source>
        <translation>&amp;Libpince</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/LibpinceEngine/Form/LibpinceEngineWindow.ui" line="0" />
        <source>Run current script [Ctrl+R]</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>Pointer Scanner</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>Sort</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>Clear</source>
        <translation type="unfinished">清除</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>Fi&amp;le</source>
        <translation type="unfinished">文件[&amp;l]</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>Actio&amp;ns</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>&amp;Open</source>
        <translation type="unfinished">打开[&amp;O]</translation>
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>&amp;Save As...</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>&amp;Scan</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/PointerScan/Form/PointerScanWindow.ui" line="0" />
        <source>&amp;Filter</source>
        <translation type="unfinished" />
    </message>
</context><context>
    <name>MainWindow_MemoryView</name>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Memory Viewer</source>
        <translation>内存查看器</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Address</source>
        <translation>地址</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Bytes</source>
        <translation>字节</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Opcodes</source>
        <translation>操作码</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Comment</source>
        <translation>注解</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Registers</source>
        <translation>寄存器（Registers）</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Flags</source>
        <translation>状态标志（Flags）</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Segment Registers</source>
        <translation>段（Segment）寄存器</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Show Float Registers</source>
        <translation>显示浮点（Float）寄存器</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Return Address</source>
        <translation>返回地址</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Frame Address</source>
        <translation>帧地址</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Value</source>
        <translation>值</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Points to</source>
        <translation>指向</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>V&amp;iew</source>
        <translation>视图[&amp;i]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Debug</source>
        <translation>调试[&amp;D]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Tools</source>
        <translation>工具[&amp;T]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Fi&amp;le</source>
        <translation>文件[&amp;l]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Help</source>
        <translation>帮助</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Bookmarks</source>
        <translation>书签[&amp;B]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;StackTrace Info</source>
        <translation>堆栈跟踪信息[&amp;S]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Inject .so file</source>
        <translation>注入 .so 文件[&amp;I]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Break</source>
        <translation>中断[&amp;B]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Run</source>
        <translation>运行[&amp;R]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Step[F7]</source>
        <translation>步进[&amp;S][F7]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Step &amp;Over[F8]</source>
        <translation>步过[&amp;O][F8]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Execute Till Return[Shift+F8]</source>
        <translation>执行直到返回[&amp;E][Shift+F8]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Toggle Breakpoint[F5]</source>
        <translation>切换断点[&amp;T][F5]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>B&amp;reakpoints</source>
        <translation>断点[&amp;r]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Functions</source>
        <translation>函数[&amp;F]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Set Address[Shift+F4]</source>
        <translation>设置地址[Shift+F4]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Call Function</source>
        <translation>调用函数[&amp;C]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Load Trace</source>
        <translation>加载追踪[&amp;L]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Libpince</source>
        <translation>&amp;Libpince</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;GDB Log File</source>
        <translation>&amp;GDB 日志文件</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Search Opcode</source>
        <translation>搜索操作码[&amp;S]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Memory Regions</source>
        <translation>内存区域[&amp;M]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>&amp;Dissect Code</source>
        <translation>分析代码[&amp;D]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>R&amp;eferenced Strings</source>
        <translation>引用的字符串[&amp;e]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Referenced &amp;Calls</source>
        <translation>引用的调用[&amp;C]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>To&amp;ggle Attach</source>
        <translation>切换附加​​[&amp;g]</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Restore Instructions</source>
        <translation>还原指令</translation>
    </message>
    <message>
        <location filename="../../GUI/MemoryViewerWindow.ui" line="0" />
        <source>Libpince Engine</source>
        <translation type="unfinished" />
    </message>
</context><context>
    <name>QPlatformTheme</name>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>OK</source>
        <translation>确认</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>&amp;Open</source>
        <translation>打开[&amp;O]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>&amp;Save</source>
        <translation>保存[&amp;S]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cancel</source>
        <translation>取消</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Close</source>
        <translation>关闭</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Discard</source>
        <translation>撤销</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Apply</source>
        <translation>应用</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Reset</source>
        <translation>复位</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Restore Defaults</source>
        <translation>恢复为默认</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Help</source>
        <translation>帮助</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Save All</source>
        <translation>全部保存</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>&amp;Yes</source>
        <translation>是[&amp;Y]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>&amp;No</source>
        <translation>否[&amp;N]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Abort</source>
        <translation>关于</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Retry</source>
        <translation>重试</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Ignore</source>
        <translation>忽略</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>N&amp;o to All</source>
        <translation>全部否[&amp;o]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Yes to &amp;All</source>
        <translation>全部是[&amp;A]</translation>
    </message>
</context><context>
    <name>SessionNotes</name>
    <message>
        <location filename="../../GUI/Widgets/SessionNotes/Form/SessionNotes.ui" line="0" />
        <source>Notes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../GUI/Widgets/SessionNotes/Form/SessionNotes.ui" line="0" />
        <source>Session Notes</source>
        <translation type="unfinished" />
    </message>
</context><context>
    <name>TabWidget</name>
    <message>
        <location filename="../../GUI/AboutWidget.ui" line="0" />
        <source>About PINCE</source>
        <translation>关于 PINCE</translation>
    </message>
    <message>
        <location filename="../../GUI/AboutWidget.ui" line="0" />
        <source>Contributors</source>
        <translation>贡献者</translation>
    </message>
    <message>
        <location filename="../../GUI/AboutWidget.ui" line="0" />
        <source>License</source>
        <translation>许可</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Breakpoints</source>
        <translation>断点</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Interactive</source>
        <translation>交互</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>No</source>
        <translation>No</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Type</source>
        <translation>类型</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Disp</source>
        <translation>显示</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Enabled</source>
        <translation>启用</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Address</source>
        <translation>地址</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Size</source>
        <translation>大小</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>On Hit</source>
        <translation>命中时</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Hit Count</source>
        <translation>命中计数</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Condition</source>
        <translation>条件</translation>
    </message>
    <message>
        <location filename="../../GUI/BreakpointInfoWidget.ui" line="0" />
        <source>Raw</source>
        <translation>原始</translation>
    </message>
    <message>
        <location filename="../../GUI/FloatRegisterWidget.ui" line="0" />
        <source>Floating Point Registers</source>
        <translation>浮点寄存器</translation>
    </message>
    <message>
        <location filename="../../GUI/FloatRegisterWidget.ui" line="0" />
        <location filename="../../GUI/FloatRegisterWidget.ui" line="0" />
        <source>Register</source>
        <translation>寄存器</translation>
    </message>
    <message>
        <location filename="../../GUI/FloatRegisterWidget.ui" line="0" />
        <location filename="../../GUI/FloatRegisterWidget.ui" line="0" />
        <source>Value</source>
        <translation>值</translation>
    </message>
</context><context>
    <name>TranslationConstants</name>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Pause the process</source>
        <translation>暂停进程</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Break the process</source>
        <translation>中断进程</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Continue the process</source>
        <translation>继续进程</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cancel ongoing GDB command</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle attach/detach</source>
        <translation>切换附加 / 分离</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Exact</source>
        <translation>再次扫描 - 精确</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Not</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Increased</source>
        <translation>再次扫描 - 增加</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Increased By</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Decreased</source>
        <translation>再次扫描 - 减少</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Decreased By</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Less Than</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - More Than</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Between</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Changed</source>
        <translation>再次扫描 - 改变</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Next Scan - Unchanged</source>
        <translation>再次扫描 - 未变</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Error</source>
        <translation>错误</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Success</source>
        <translation>成功</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Information</source>
        <translation>信息</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>GDB isn't initialized yet</source>
        <translation>GDB 尚未初始化</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to initialize GDB
You might want to reinstall GDB or use the system GDB
To change the current GDB path, check Settings-&gt;Debug</source>
        <translation>无法初始化 GDB
你可能想重新安装 GDB 或者使用系统 GDB
要更改当前 GDB 路径，请检查 “设置” -&gt; “调试”</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Edit</source>
        <translation>编辑</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show as hexadecimal</source>
        <translation>显示为十六进制</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show as decimal</source>
        <translation>显示为十进制</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show as unsigned</source>
        <translation>显示为无符号数</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show as signed</source>
        <translation>显示为有符号数</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle</source>
        <translation>切换</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle including children</source>
        <translation>切换包括子项</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Freeze</source>
        <translation>冻结</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Default</source>
        <translation>默认</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Browse this memory region</source>
        <translation>浏览此内存区域</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Disassemble this address</source>
        <translation>反汇编这个地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Delete</source>
        <translation>删除</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Delete selection</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cut</source>
        <translation>剪切</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy</source>
        <translation>复制</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Paste</source>
        <translation>粘贴</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Paste inside</source>
        <translation>粘贴在里</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Pointer scan for this address</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Open pointer scanner</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Pointer scan finished.

Don't forget to open the scandata file (File-&gt;Open)!</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Find out what writes to this address</source>
        <translation>找出是什么写入了这个地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Find out what reads this address</source>
        <translation>找出是什么读取了这个地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Find out what accesses this address</source>
        <translation>找出是什么访问了这个地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Add to a new group</source>
        <translation>加入一个新组</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Create a new group</source>
        <translation>创建一个新组</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Group</source>
        <translation>组</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Invalid clipboard content</source>
        <translation>剪贴板内容无效</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>New Scan</source>
        <translation>新的扫描</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Match count: {} ({} shown)</source>
        <translation>匹配次数：{}（显示了{}个）</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Match count: {}</source>
        <translation>匹配次数：{}</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>No Description</source>
        <translation>无备注</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Open PCT file(s)</source>
        <translation>打开 PCT 文件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Open script file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Save script file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>(untitled)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Script execution failed:</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>PINCE Cheat Table (*.pct)</source>
        <translation>PINCE 作弊表 (*.pct)</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Python Scripts (*.py)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Shared object library (*.so)</source>
        <translation>共享对象库 (*.so)</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Trace File (*.trace)</source>
        <translation>追踪文件 (*.trace)</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Pointer Scan Data (*.scandata)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Clear address table?</source>
        <translation>清除地址表？</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>File {} is inaccessible or contains invalid content</source>
        <translation>文件 {} 无法访问或包含无效的内容</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Save PCT file</source>
        <translation>保存 PCT 文件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cannot save to file</source>
        <translation>无法保存为文件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Nice try, smartass</source>
        <translation>好会试，聪明屁股</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Selected process is not valid</source>
        <translation>所选进程无效</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>You're debugging this process already</source>
        <translation>你已经在调试这个进程了</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>That process is already being traced by {}, could not attach to the process</source>
        <translation>此进程已被 {} 追踪，无法附加到此进程</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Permission denied, could not attach to the process</source>
        <translation>请求被拒，无法附加到此进程</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>An error occurred while trying to create process</source>
        <translation>尝试创建进程时发生错误</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Scan for</source>
        <translation>在这里输入扫描内容</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>First Scan</source>
        <translation>首次扫描</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>No Process Selected</source>
        <translation>未附加到任何进程</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>[detached]</source>
        <translation>[已分离]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>[stopped]</source>
        <translation>[已停止]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>This requires the process to be stopped</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the new value</source>
        <translation>输入新值</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the new description</source>
        <translation>输入新备注</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Edit Address</source>
        <translation>编辑地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Please select a process first</source>
        <translation>请先选择一个进程</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Select the target binary</source>
        <translation>选择目标二进制文件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the optional arguments</source>
        <translation>输入可选参数</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>LD_PRELOAD .so path (optional)</source>
        <translation>LD_PRELOAD .so 路径（可选）</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Refresh</source>
        <translation>刷新</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Length is not valid</source>
        <translation>长度无效</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Length must be greater than 0</source>
        <translation>长度必须大于0</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Can't parse the input</source>
        <translation>无法解析输入</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>{} isn't a valid regex</source>
        <translation>{} 非有效正则表达式</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Language settings will take effect upon the next restart</source>
        <translation>语言设置会在下次重启时生效</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>You have changed the GDB path, reset GDB now?</source>
        <translation>你已经更改了 GDB 路径，现在重置 GDB 吗？</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>This will reset to the default settings
Proceed?</source>
        <translation>这将会重置设置为默认
继续？</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Mouse over on this text for examples</source>
        <translation>将鼠标悬停在此文本上查看示例</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>asdf|qwer --&gt; search for asdf or qwer
[as]df --&gt; search for both adf and sdf
Use the char \ to escape special chars such as [
\[asdf\] --&gt; search for opcodes that contain [asdf]</source>
        <translation>asdf|qwer --&gt; 搜索 asdf 或 qwer
[as]df --&gt; 搜索 adf 和 sdf
使用字符 \ 转义特殊字符，如 [
\[asdf\] --&gt; 搜索包含 [asdf] 的操作码</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Separate processes with {}</source>
        <translation>使用 {} 分隔进程</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>This setting is unused in AppImage builds</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Select the gdb binary</source>
        <translation>选择 GDB 的可执行文件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Quitting current session will crash PINCE</source>
        <translation>退出当前会话会导致 PINCE 崩溃</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Use global hotkeys or the commands 'interrupt' and 'c&amp;' to stop/run the inferior</source>
        <translation>使用全局快捷键或者命令 'interrupt' 和 'c&amp;' 停止/运行被调试程序（inferior）</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Hotkeys:
-----------------------------
Send: Enter                 |
Multi-line mode: Ctrl+Enter |
Complete command: Tab       |
-----------------------------
Commands:
----------------------------------------------------------
/clear: Clear the console                                |
phase-out: Detach from the current process               |
phase-in: Attach back to the previously detached process |
---------------------------------------------------------------------------------------------------
You can change the output mode from bottom right
Changing output mode only affects commands sent. Any other output coming from external sources(e.g async output) will be shown in MI format</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Break[{}]</source>
        <translation>中断[{}]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Run[{}]</source>
        <translation>运行[{}]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle Attach[{}]</source>
        <translation>切换附加[{}]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Failed to set breakpoint at address {}</source>
        <translation>在地址 {} 处设置断点失败</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Failed to set watchpoint at address {}</source>
        <translation>无法在地址 {} 设置监视点</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy to Clipboard</source>
        <translation>复制到剪切板</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Go to expression</source>
        <translation>跳转到表达式</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Add this address to address list</source>
        <translation>添加此地址到地址列表</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Set Watchpoint</source>
        <translation>设置监视点</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Write Only</source>
        <translation>仅写入</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Read Only</source>
        <translation>仅读取</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Both</source>
        <translation>两者都</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Add/Change condition for breakpoint</source>
        <translation>添加/更改断点条件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Delete Breakpoint</source>
        <translation>删除断点</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the expression</source>
        <translation>输入表达式</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>{} is invalid</source>
        <translation>{} 无效</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Protection:{} | Base:{}-{} | Module:{}</source>
        <translation>保护:{} | 基础:{}-{} | 模块:{}</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Invalid Region</source>
        <translation>无效的区域</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cannot access memory at expression {}</source>
        <translation>无法访问表达式 {} 处的内存</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Referenced by:</source>
        <translation>引用自：</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Press 'Ctrl+E' to see a detailed list of referrers</source>
        <translation>按下 'Ctrl+E' 可以查看引用来源的详细列表</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Memory Viewer - Paused</source>
        <translation>内存查看器 - 已暂停</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Memory Viewer - Currently debugging {}</source>
        <translation>内存查看器 - 正调试 {}</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Memory Viewer - Running</source>
        <translation>内存查看器 - 运行中</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the expression for condition, for instance:

$eax==0x523
$rax&gt;0 &amp;&amp; ($rbp&lt;0 || $rsp==0)
printf($r10)==3</source>
        <translation>输入条件表达式，例如：

$eax==0x523
$rax&gt;0 &amp;&amp; ($rbp&lt;0 || $rsp==0)
printf($r10)==3</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Failed to set condition for address {}
Check terminal for details</source>
        <translation>无法设置地址 {} 的条件
检查终端了解详情</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Full Stack</source>
        <translation>全栈</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Return Address</source>
        <translation>复制返回地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Frame Address</source>
        <translation>复制帧地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Stacktrace</source>
        <translation>堆栈跟踪</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle stack from BP/SP register</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Address</source>
        <translation>复制地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Value</source>
        <translation>复制值</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Points to</source>
        <translation>复制指向</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Disassemble 'value' pointer address</source>
        <translation>反汇编 '值' 指针地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show 'value' pointer in HexView</source>
        <translation>在十六进制视图中显示 '值' 指针</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Back</source>
        <translation>后退</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show this address in HexView</source>
        <translation>在十六进制视图中显示这个地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Follow</source>
        <translation>跟踪</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Examine Referrers</source>
        <translation>检查引用来源</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Bookmark this address</source>
        <translation>添加此地址到书签</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Delete this bookmark</source>
        <translation>删除此书签</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Change comment</source>
        <translation>更改注解</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Go to bookmarked address</source>
        <translation>跳转到已添加书签的地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Toggle Breakpoint</source>
        <translation>切换断点</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Edit instruction</source>
        <translation>编辑指令</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Replace instruction with NOPs</source>
        <translation>用 NOPs 替换指令</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Find out which addresses this instruction accesses</source>
        <translation>找出此指令访问的地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Break and trace instructions</source>
        <translation>中断并跟踪指令</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Dissect this region</source>
        <translation>分析此区域</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Bytes</source>
        <translation>复制字节</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Opcode</source>
        <translation>复制操作码</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Comment</source>
        <translation>复制注解</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy All</source>
        <translation>复制全部</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the register expression(s) you want to track
Register names must start with $
Each expression must be separated with a comma

For instance:
Let's say the instruction is mov [rax+rbx],30
Then you should enter $rax+$rbx
So PINCE can track address [rax+rbx]

Another example:
If you enter $rax,$rbx*$rcx+4,$rbp
PINCE will track down addresses [rax],[rbx*rcx+4] and [rbp]</source>
        <translation>请输入你想要追踪的寄存器表达式
寄存器名称必须以$开头
每个表达式必须用逗号分隔

例如：
假设指令是 mov [rax+rbx],30
那么你应该输入 $rax+$rbx
这样 PINCE 就可以追踪地址 [rax+rbx]

另一个例子：
如果你输入 $rax,$rbx*$rcx+4,$rbp
PINCE 将追踪地址 [rax]，[rbx*rcx+4] 和 [rbp]</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>This address has already been bookmarked</source>
        <translation>这个地址已经被添加到书签了</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the comment for bookmarked address</source>
        <translation>输入已书签地址的注解</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Select the .so file</source>
        <translation>选择 .so 文件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>The file has been injected</source>
        <translation>此文件已被注入</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Failed to inject the .so file</source>
        <translation>注入 .so 文件失败</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the expression for the function that'll be called from the inferior
You can view functions list from View-&gt;Functions

For instance:
Calling printf("1234") will yield something like this
↓
$28 = 4

$28 is the assigned convenience variable
4 is the result
You can use the assigned variable from the GDB Console</source>
        <translation>请输入从被调试程序（inferior）中将要调用的函数表达式
你可以从 视图 -&gt; 函数 查看函数列表

例如：
调用 printf("1234") 将产生类似下面的结果
↓
$28 = 4

$28 是分配的便利变量
4 是函数调用的结果
你可以从 GDB 控制台中使用分配的变量</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Failed to call the expression {}</source>
        <translation>调用表达式 {} 失败</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Invalid expression or address</source>
        <translation>无效的表达式或地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Invalid entries detected, refreshing the page</source>
        <translation>检测到无效条目，正在刷新页面</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Add new entry</source>
        <translation>添加新条目</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the new value of register {}</source>
        <translation>输入寄存器{}的新值</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the new value of flag {}</source>
        <translation>输入标志（flag）{}的新值</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Restore this instruction</source>
        <translation>还原此指令</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enter the hit count({} or higher)</source>
        <translation>输入命中计数（{}或更高）</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Hit count must be an integer</source>
        <translation>命中计数必须是整数</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Hit count can't be lower than {}</source>
        <translation>命中计数不能少于 {}</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Change condition</source>
        <translation>更改条件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Enable</source>
        <translation>开启</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Disable</source>
        <translation>关闭</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Disable after hit</source>
        <translation>命中后关闭</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Disable after X hits</source>
        <translation>命中 X 次后关闭</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Delete after hit</source>
        <translation>命中后删除</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Opcodes writing to the address {}</source>
        <translation>写入地址 {} 的操作码</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Opcodes reading from the address {}</source>
        <translation>读取地址 {} 的操作码</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Opcodes accessing to the address {}</source>
        <translation>访问地址 {} 的操作码</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to track watchpoint at expression {}</source>
        <translation>无法追踪表达式 {} 处的监视点</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to delete watchpoint at expression {}</source>
        <translation>无法删除表达式 {} 处的监视点</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Close</source>
        <translation>关闭</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Addresses accessed by instruction {}</source>
        <translation>指令 {} 访问的地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to track breakpoint at expression {}</source>
        <translation>无法跟踪表达式 {} 处的断点</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Accessed by {}</source>
        <translation>访问自 {}</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to delete breakpoint at expression {}</source>
        <translation>无法删除表达式 {} 处的断点</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Max trace count must be greater than or equal to {}</source>
        <translation>最大追踪次数必须大或等于 {}</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Save trace file</source>
        <translation>保存追踪文件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Open trace file</source>
        <translation>打开追踪文件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Expand All</source>
        <translation>展开全部</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Collapse All</source>
        <translation>收起全部</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Select a pointer map file</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Scan</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Scanning</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Filter</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Filtering</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>DEFINED</source>
        <translation>定义</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>This symbol is defined. You can use its body as a gdb expression. For instance:

void func(param) can be used as 'func' as a gdb expression</source>
        <translation>该符号已定义。您可以将其作为 GDB 表达式使用其主体。例如：

void func(param) 可以作为 'func' 作为 GDB 表达式使用</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Symbol</source>
        <translation>复制符号</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>	Here's some useful regex tips:
^quaso --&gt; search for everything that starts with quaso
[ab]cd --&gt; search for both acd and bcd

	How to interpret symbols:
A symbol that looks like 'func(param)@plt' consists of 3 pieces
func, func(param), func(param)@plt
These 3 functions will have different addresses
@plt means this function is a subroutine for the original one
There can be more than one of the same function
It means that the function is overloaded</source>
        <translation>	以下是一些有用的正则表达式提示：
^quaso --&gt; 搜索以 quaso 开头的所有内容
[ab]cd --&gt; 搜索同时包含 acd 和 bcd 的内容

	如何解释符号：
一个看起来像 'func(param)@plt' 的符号由三个部分组成：
func, func(param), func(param)@plt
这三个函数将有不同的地址
@plt 表示该函数是原始函数的一个子程序
同一个函数可能有多个
这意味着函数是重载的</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>New opcode is {} bytes long but old opcode is only {} bytes long
This will cause an overflow, proceed?</source>
        <translation>新的操作码长度为 {} 字节，但旧的操作码只有 {} 字节长
这将导致溢出，是否继续？</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>{} isn't a valid expression</source>
        <translation>{} 不是有效的表达式</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Log File of PID {}</source>
        <translation>PID {} 的日志文件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Contents of {} (only last {} bytes are shown)</source>
        <translation>{} 的内容（仅显示最后 {} 字节）</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>ON</source>
        <translation>开</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>OFF</source>
        <translation>关</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>LOGGING: {}</source>
        <translation>日志: {}</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unable to read log file at {}</source>
        <translation>无法读取位于 {} 的日志文件</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Go to Settings-&gt;Debug to enable logging</source>
        <translation>请转到“设置”-&gt;“调试”以启用日志记录</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Invalid Regex</source>
        <translation>无效的正则表达式</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>	Here's some useful regex examples:
call|rax --&gt; search for opcodes that contain call or rax
[re]cx --&gt; search for both rcx and ecx
Use the char \ to escape special chars such as [
\[rsp\] --&gt; search for opcodes that contain [rsp]</source>
        <translation>	这里有一些有用的正则表达式示例：
call|rax --&gt; 搜索包含 call 或 rax 的操作码
[re]cx --&gt; 搜索 rcx 和 ecx
使用字符 \ 转义特殊字符，如 [
\[rsp\] --&gt; 搜索包含 [rsp] 的操作码</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Addresses</source>
        <translation>复制地址</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Offset</source>
        <translation>复制偏移量</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Copy Path</source>
        <translation>复制路径</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Start</source>
        <translation>开始</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Currently scanning region:</source>
        <translation>当前扫描区域：</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Cancel</source>
        <translation>取消</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Scan finished</source>
        <translation>扫描完成</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Scan was canceled</source>
        <translation>扫描被取消了</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Select at least one region</source>
        <translation>选中至少一个区域</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>You need to dissect code first
Proceed?</source>
        <translation>你需要先分析代码
是否继续？</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Waiting for breakpoint to trigger</source>
        <translation>等待断点被触发</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Tracing has been completed</source>
        <translation>追踪已完成</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Not</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Exact</source>
        <translation>精确</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Increased</source>
        <translation>增加</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Increased by</source>
        <translation>增加自</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Decreased</source>
        <translation>减少</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Decreased by</source>
        <translation>减少自</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Less Than</source>
        <translation>少于</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>More Than</source>
        <translation>多于</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Between</source>
        <translation>介于</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Changed</source>
        <translation>改变</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unchanged</source>
        <translation>未变</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Unknown Value</source>
        <translation>未知值</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Basic</source>
        <translation>基础</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Normal</source>
        <translation>正常</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Read+Write</source>
        <translation>读+写</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Full</source>
        <translation>全部</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Host</source>
        <translation>主机</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Little</source>
        <translation>小</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Big</source>
        <translation>大</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show in HexView</source>
        <translation>在十六进制视图中显示</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Show in Disassembler</source>
        <translation>在反汇编器中显示</translation>
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Dark</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Light</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>System Default</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Wong (Colorblind Friendly)</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Session - Unsaved changes</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>You have unsaved changes.
Do you want to save the current session?</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>Session - Process changed</source>
        <translation type="unfinished" />
    </message>
    <message>
        <location filename="../../tr/tr.py" line="0" />
        <source>The process name has changed.
Do you want to keep the current session with the new process?</source>
        <translation type="unfinished" />
    </message>
</context></TS>

```

`install.sh`:

```sh
#!/bin/bash
: '
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'

if [ "$(id -u)" = "0" ]; then
	echo "Please do not run this script as root!"
	exit 1
fi

SCRIPTDIR=$(cd -- "$(dirname -- "$0")" && pwd -P)
cd $SCRIPTDIR
if [ ! -d ".git" ]; then
	echo "Error! Could not find \".git\" folder!"
	echo "This can happen if you downloaded the ZIP file instead of cloning through git."
	echo "Please clone the PINCE repository using the \"--recursive\" flag and try again!"
	echo "For more information, please follow the installation instructions on GitHub."
	exit 1
fi

CURRENT_USER="$(whoami)"

if [ -z "$NUM_MAKE_JOBS" ]; then
    NUM_MAKE_JOBS=$(lscpu -p=core | uniq | awk '!/#/' | wc -l)
    MAX_NUM_MAKE_JOBS=8
    if [ "$NUM_MAKE_JOBS" -gt "$MAX_NUM_MAKE_JOBS" ]; then # set an upper limit to prevent Out-Of-Memory
        NUM_MAKE_JOBS=$MAX_NUM_MAKE_JOBS
    fi
    if ! echo "$NUM_MAKE_JOBS" | grep -Eq '^[0-9]+$'; then # fallback
        NUM_MAKE_JOBS=$MAX_NUM_MAKE_JOBS
    fi
fi

exit_on_error() {
    if [ "$?" -ne 0 ]; then
        echo
        echo "Error occured while installing PINCE, check the output above for more information"
        echo "Installation failed."
        exit 1
    fi
}

# assumes you're in libscanmem directory
compile_libscanmem() {
    cmake -DCMAKE_BUILD_TYPE=Release . || return 1
    make -j"$NUM_MAKE_JOBS" || return 1
    chown -R "${CURRENT_USER}":"${CURRENT_USER}" . # give permissions for normal user to change file
    return 0
}

install_libscanmem() {
    echo "Downloading libscanmem"
    git submodule update --init --recursive || return 1

    if [ ! -d "libpince/libscanmem" ]; then
        mkdir libpince/libscanmem
        chown -R "${CURRENT_USER}":"${CURRENT_USER}" libpince/libscanmem
    fi
    (
        echo "Entering libscanmem directory"
        cd libscanmem-PINCE || return 1
        if [ -f "./libscanmem.so" ]; then
            echo "Recompile libscanmem? [y/n]"
            read -r answer
            if echo "$answer" | grep -iq "^[Yy]"; then
                make clean
                compile_libscanmem || return 1
            fi
        else
            compile_libscanmem || return 1
        fi
        cp --preserve libscanmem.so ../libpince/libscanmem/
        cp --preserve wrappers/scanmem.py ../libpince/libscanmem
        echo "Exiting libscanmem directory"
    ) || return 1
    return 0
}

install_libptrscan() {
	echo "Downloading libptrscan"

    if [ ! -d "libpince/libptrscan" ]; then
        mkdir libpince/libptrscan
        chown -R "${CURRENT_USER}":"${CURRENT_USER}" libpince/libptrscan
    fi
    (
		cd libpince/libptrscan
		# Source code download as we might be forced to distribute it due to licence
		curl -L -O https://github.com/kekeimiku/PointerSearcher-X/archive/refs/tags/v0.7.4-dylib.tar.gz || return 1
		# Actual .so and py wrapper
		curl -L -o libptrscan.tar.gz https://github.com/kekeimiku/PointerSearcher-X/releases/download/v0.7.4-dylib/libptrscan_pince-x86_64-unknown-linux-gnu.tar.gz || return 1
		tar xf libptrscan.tar.gz --strip-components 1 || return 1
		rm -f libptrscan.tar.gz
		cd ../..
    ) || return 1
    return 0
}

ask_pkg_mgr() {
	echo
	echo "Your distro is not officially supported! Trying to install anyway."
	echo "Please choose your package manager."
	echo "1) APT"
	echo "2) Pacman"
	echo "3) DNF"
	echo "4) Zypper"
	echo "5) None of the above"

	read -r -p "Choose: " OPTION
	OPTION=$(echo $OPTION | tr '[:lower:]' '[:upper:]')

	case $OPTION in
	1|*APT*)
		OS_NAME="Debian"
		;;
	2|*PACMAN*)
		OS_NAME="Arch"
		;;
	3|*DNF*)
		OS_NAME="Fedora"
		;;
	4|*ZYPPER*)
		OS_NAME="SUSE"
		;;
	*)
		return 1
		;;
	esac

	return 0
}

# About xcb packages -> https://github.com/cdgriffith/FastFlix/wiki/Common-questions-and-problems
PKG_NAMES_ALL="python3-pip gdb cmake"
PKG_NAMES_DEBIAN="$PKG_NAMES_ALL python3-dev python3-venv pkg-config qt6-l10n-tools libcairo2-dev libxcb-randr0-dev libxcb-xtest0-dev libxcb-xinerama0-dev libxcb-shape0-dev libxcb-xkb-dev libxcb-cursor0"
PKG_NAMES_SUSE="$PKG_NAMES_ALL gcc python3-devel qt6-tools-linguist cairo-devel make"
PKG_NAMES_FEDORA="$PKG_NAMES_ALL python3-devel qt6-linguist redhat-lsb cairo-devel"
PKG_NAMES_ARCH="python-pip qt6-tools gdb cmake lsb-release pkgconf" # arch defaults to py3 nowadays

INSTALL_COMMAND="install"

set_install_vars() {
	case $1 in
	*SUSE*)
		PKG_MGR="zypper"
		PKG_NAMES="$PKG_NAMES_SUSE"
		LRELEASE_CMD="lrelease6"
		;;
	*Arch*)
		PKG_MGR="pacman"
		PKG_NAMES="$PKG_NAMES_ARCH"
		INSTALL_COMMAND="-S --needed"
		LRELEASE_CMD="/usr/lib/qt6/bin/lrelease"
		;;
	*Fedora*)
		PKG_MGR="dnf -y"
		PKG_NAMES="$PKG_NAMES_FEDORA"
		LRELEASE_CMD="lrelease-qt6"
		;;
	*Debian*|*Ubuntu*)
		PKG_MGR="apt -y"
		PKG_NAMES="$PKG_NAMES_DEBIAN"
		LRELEASE_CMD="/usr/lib/qt6/bin/lrelease"
		;;
	*)
		return 1
		;;
	esac

	return 0
}

compile_translations() {
	${LRELEASE_CMD} i18n/ts/*
	mkdir -p i18n/qm
	mv i18n/ts/*.qm i18n/qm/
}

LSB_RELEASE="$(command -v lsb_release)"
if [ -n "$LSB_RELEASE" ]; then
    OS_NAME="$(${LSB_RELEASE} -d -s)"
else
    # shellcheck disable=SC1091
    . /etc/os-release
    OS_NAME="$NAME"
fi

set_install_vars $OS_NAME

if [ "$?" -ne 0  ]; then
	ask_pkg_mgr
	if [ "$?" -ne 0 ]; then
		echo
		echo "Sorry, your distro is not supported!"
		exit 1
	fi

	set_install_vars $OS_NAME
fi

# shellcheck disable=SC2086
sudo ${PKG_MGR} ${INSTALL_COMMAND} ${PKG_NAMES} || exit_on_error

# Prepare Python virtual environment
if [ ! -d ".venv/bin" ]; then
	python3 -m venv .venv
fi
. .venv/bin/activate
pip3 install --upgrade pip || exit_on_error

# shellcheck disable=SC2086
pip3 install -r requirements.txt || exit_on_error

install_libscanmem || exit_on_error
install_libptrscan || exit_on_error

compile_translations || exit_on_error

echo
echo "PINCE has been installed successfully!"
echo "Now, just run 'sh PINCE.sh' from terminal"

```

`libpince/debugcore.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from threading import Lock, Thread, Condition
from time import sleep, time
from collections import OrderedDict, defaultdict
import pexpect, os, sys, ctypes, pickle, shelve, re, struct, io, traceback
from . import utils, typedefs, regexes
from .utils import safe_str_to_int, safe_int_cast, logger
from .libscanmem.scanmem import Scanmem
from .libptrscan.ptrscan import PointerScan

self_pid = os.getpid()
libc = ctypes.CDLL("libc.so.6")
system_endianness = typedefs.ENDIANNESS.LITTLE if sys.byteorder == "little" else typedefs.ENDIANNESS.BIG

scanmem = Scanmem(os.path.join(utils.get_libpince_directory(), "libscanmem", "libscanmem.so"))
ptrscan = PointerScan(os.path.join(utils.get_libpince_directory(), "libptrscan", "libptrscan.so"))
ptrscan.set_pointer_offset_symbol("->")

# A boolean value. True if gdb is initialized, False if not
gdb_initialized = False

# An integer. Can be a member of typedefs.INFERIOR_ARCH
inferior_arch = int

# An integer. Can be a member of typedefs.INFERIOR_STATUS
inferior_status = -1

# An integer. PID of the current attached/created process
currentpid = -1

# An integer. Can be a member of typedefs.STOP_REASON
stop_reason = int

# A dictionary. Holds breakpoint numbers and what to do on hit
# Format: {bp_num1:on_hit1, bp_num2:on_hit2, ...}
breakpoint_on_hit_dict = {}

# A dictionary. Holds address and aob of instructions that were nop'ed out
# Format: {address1:orig_instruction1_aob, address2:orig_instruction2_aob, ...}
modified_instructions_dict = {}

# If an action such as deletion or condition modification happens in one of the breakpoints in a list, others in the
# same list will get affected as well
# Format: [[bp_num1, bp_num2, ...], [bp_num1, ...], ...]
chained_breakpoints = []

child = object  # this object will be used with pexpect operations

# This Lock is used by the function send_command to ensure synchronous execution
lock_send_command = Lock()

# This condition is notified whenever status of the inferior changes
# Use the variable inferior_status to get information about inferior's status
# See CheckInferiorStatus class for an example
status_changed_condition = Condition()

# This condition is notified if the current inferior gets terminated
# See AwaitProcessExit class for an example
process_exited_condition = Condition()

# This condition is notified if gdb starts to wait for the prompt output
# See function send_command for an example
gdb_waiting_for_prompt_condition = Condition()

# A string. Stores the output of the last command
gdb_output = ""

# An instance of typedefs.RegisterQueue. Updated whenever GDB receives an async event such as breakpoint modification
# See AwaitAsyncOutput class for an example of usage
gdb_async_output = typedefs.RegisterQueue()

# A boolean value. Used to cancel the last gdb command sent
# Use the function cancel_ongoing_command to make use of this variable
# Return value of the current send_command call will be an empty string
cancel_send_command = False

# A boolean value. Used by state_observe_thread to check if a trace session is active
active_trace = False

# A boolean value. Set to True when a tracking breakpoint (on_hit != BREAK) was the last stop
# This prevents the subsequent *running event from notifying the UI
last_stop_was_tracking = False

# A string. Holds the last command sent to gdb
last_gdb_command = ""

# A list of booleans. Used to adjust gdb output
# Use the function set_gdb_output_mode to make use of this variable
gdb_output_mode = typedefs.gdb_output_mode(True, True, True)

# A string. memory file of the currently attached/created process
mem_file = "/proc/" + str(currentpid) + "/mem"

# A string. Determines which signal to use to interrupt the process
interrupt_signal = "SIGINT"

# Dictionary that maps an id or name to allocated memory.
# If an user allocates memory without a name, it will be given a random ID set as string.
allocated_memory_chunks: dict[str, typedefs.AllocatedMemory] = {}

# ID generator used for the above
allocated_memory_gen_id = 0

"""
When PINCE was first launched, it used gdb 7.7.1, which is a very outdated version of gdb
interpreter-exec mi command of gdb showed some buggy behaviour at that time
Because of that, PINCE couldn't support gdb/mi commands for a while
But PINCE is now updated with the new versions of gdb as much as possible and the interpreter-exec works much better
So, old parts of codebase still get their required information by parsing gdb console output
New parts can try to rely on gdb/mi output
"""

"""
Functions that require breakpoint commands, such as track_watchpoint and track_breakpoint, requires process to be
stopped beforehand. If the process is running before we give the breakpoint its commands, there's a chance that the
breakpoint will be triggered before we give it commands. The process must be stopped to avoid this race condition
It's also necessary to stop the process to run commands like "watch"
"""


def set_gdb_output_mode(output_mode_tuple):
    """Adjusts gdb output

    Args:
        output_mode_tuple (typedefs.gdb_output_mode): Setting any field True will enable the output that's associated
        with that field. Setting it False will disable the associated output
    """
    global gdb_output_mode
    gdb_output_mode = output_mode_tuple


def cancel_ongoing_command() -> bool:
    """Cancels the last gdb command sent if it's still present

    Returns:
        bool: True if cancel was successful, False if nothing to cancel
    """
    if lock_send_command.locked():
        global cancel_send_command
        cancel_send_command = True
        return True
    return False


def send_command(
    command, control=False, cli_output=False, send_with_file=False, file_contents_send=None, recv_with_file=False
):
    """Issues the command sent, raises an exception if gdb isn't initiated

    Args:
        command (str): The command that'll be sent
        control (bool): This param should be True if the command sent is ctrl+key instead of the regular command
        cli_output (bool): If True, returns a readable cli output instead of gdb/mi output
        send_with_file (bool): Custom commands declared in gdbextensions.py requires file communication. If
        called command has any parameters, pass this as True
        file_contents_send (any): Arguments for the custom gdb command called
        recv_with_file (bool): Pass this as True if the called custom gdb command returns something

    Examples:
        send_command(c,control=True)--> Sends ctrl+c instead of the str "c"
        send_command("pince-read-addresses", file_contents_send=nested_list, recv_file=True)--> This line calls the
        custom gdb command "pince-read-addresses" with parameter nested_list and since that gdb command returns the
        addresses read as a list, we also pass the parameter recv_file as True

    Returns:
        str: Result of the command sent, commands in the form of "ctrl+key" always returns a null string
        ???: If recv_with_file is True. Content of the returned thing depends on the command sent

    Note:
        TODO:This bug doesn't seem like to exist anymore. Remove the unnecessary file communication layer of IPC
        File communication system is used to avoid BEL emitting bug of pexpect. If you send more than a certain amount
        of characters to gdb, the input will be sheared at somewhere and gdb won't be receiving all of the input
        Visit this page for more information-->http://pexpect.readthedocs.io/en/stable/commonissues.html

        You don't have to write interpreter-exec while sending a gdb/mi command. Just pass the gdb/mi command as itself.
        This function will convert it automatically.
    """
    global child
    global gdb_output
    global cancel_send_command
    global last_gdb_command
    with lock_send_command:
        if gdb_output_mode.command_info:
            time0 = time()
        if not gdb_initialized:
            raise typedefs.GDBInitializeException
        gdb_output = ""
        if send_with_file:
            send_file = utils.get_from_pince_file(currentpid)
            pickle.dump(file_contents_send, open(send_file, "wb"))
        if recv_with_file or cli_output:
            recv_file = utils.get_to_pince_file(currentpid)

            # Truncating the recv_file because we wouldn't like to see output of previous command in case of errors
            open(recv_file, "w").close()
        command = str(command)
        command = 'interpreter-exec mi "' + command + '"' if command.startswith("-") else command
        last_gdb_command = command if not control else "Ctrl+" + command
        if gdb_output_mode.command_info:
            logger.debug(f"Last gdb command: {last_gdb_command}")
        if control:
            child.sendcontrol(command)
        else:
            command_file = utils.get_gdb_command_file(currentpid)
            command_fd = open(command_file, "r+")
            command_fd.truncate()
            command_fd.write(command)
            command_fd.close()
            if not cli_output:
                child.sendline("source " + command_file)
            else:
                child.sendline("cli-output source " + command_file)
        if not control:
            while not gdb_output:
                sleep(typedefs.CONST_TIME.GDB_INPUT_SLEEP)
                if cancel_send_command:
                    break
            if not cancel_send_command:
                if recv_with_file or cli_output:
                    output = pickle.load(open(recv_file, "rb"))
                else:
                    output = gdb_output
            else:
                output = ""
                child.sendcontrol("c")
                with gdb_waiting_for_prompt_condition:
                    gdb_waiting_for_prompt_condition.wait()
        else:
            output = ""
        if gdb_output_mode.command_info:
            time1 = time()
            try:
                logger.debug(f"Processed gdb command in: {str(time1 - time0)}")
            except NameError:
                pass
        cancel_send_command = False
        return output


def state_observe_thread():
    """
    Observes the state of gdb, uses conditions to inform other functions and threads about gdb's state
    Also generates output for send_command function
    Should be called by creating a thread. Usually called in initialization process by attach function
    """

    def check_inferior_status():
        matches = regexes.gdb_state_observe.findall(child.before)
        if len(matches) > 0:
            global stop_reason
            global inferior_status
            global last_stop_was_tracking
            old_status = inferior_status
            for match in matches:
                if match[0].startswith('stopped,reason="exited'):
                    with process_exited_condition:
                        detach()
                        logger.info(f"Process terminated (PID: {currentpid})")
                        process_exited_condition.notify_all()
                        return

            # For multiline outputs, only the last async event is important
            # Get the last match only to optimize parsing
            stop_info = matches[-1][0]
            if stop_info:
                stop_reason = typedefs.STOP_REASON.DEBUG
                inferior_status = typedefs.INFERIOR_STATUS.STOPPED
            else:
                inferior_status = typedefs.INFERIOR_STATUS.RUNNING

            # Check if the FINAL stopped event in this batch is a tracking breakpoint
            # We need to check the last *stopped event, not just any tracking bp in the batch
            # Because there might be multiple events arriving in same buffer
            if inferior_status == typedefs.INFERIOR_STATUS.STOPPED:
                # Find the LAST stopped event in matches (working backwards)
                last_stop_was_tracking = False
                for match in reversed(matches):
                    if match[0]:  # This is a *stopped event
                        bp_match = regexes.breakpoint_number.search(match[0])
                        if bp_match:
                            bp_num_str = bp_match.group(1)
                            # We'll use a default of BREAK as users might use the gdb console to place break conditions
                            # such as catchpoints, where they won't be added to breakpoint_on_hit_dict.
                            # Our own tracer which we must ignore will correctly use this dictionary so no worries there.
                            bp_on_hit = breakpoint_on_hit_dict.get(bp_num_str, typedefs.BREAKPOINT_ON_HIT.BREAK)
                            last_stop_was_tracking = bp_on_hit != typedefs.BREAKPOINT_ON_HIT.BREAK
                        # Found the last stopped event, stop searching
                        break
            # If we ended in RUNNING state, last_stop_was_tracking persists from previous STOPPED event

            # Don't notify UI if:
            # 1. Status hasn't changed
            # 2. Last stop was a tracking breakpoint
            # 3. A trace is active
            should_not_notify = old_status == inferior_status or last_stop_was_tracking or active_trace

            if not should_not_notify:
                with status_changed_condition:
                    status_changed_condition.notify_all()

    global child
    global gdb_output
    try:
        while True:
            child.expect_exact("\r\n")  # A new line for TTY devices
            child.before = child.before.strip()
            if not child.before:
                continue
            check_inferior_status()
            command_file = re.escape(utils.get_gdb_command_file(currentpid))
            if regexes.gdb_command_source(command_file).search(child.before):
                child.expect_exact("(gdb)")
                child.before = child.before.strip()
                check_inferior_status()
                gdb_output = child.before
                with gdb_waiting_for_prompt_condition:
                    gdb_waiting_for_prompt_condition.notify_all()
                if gdb_output_mode.command_output:
                    logger.debug(child.before)
            else:
                if gdb_output_mode.async_output:
                    logger.debug(child.before)
                gdb_async_output.broadcast_message(child.before)
    except (OSError, ValueError, pexpect.EOF) as e:
        if isinstance(e, pexpect.EOF):
            logger.exception(f"EOF exception caught within pexpect, here's the contents of child.before:\n{child.before}")
        logger.info("Exiting state_observe_thread")


def execute_func_temporary_interruption(func, *args, **kwargs):
    """Interrupts the inferior before executing the given function, continues inferior's execution after calling the
    given function

    !!!WARNING!!! This function is NOT thread-safe. Use it with caution!

    Args:
        func (function): The function that'll be called between interrupt&continue routine
        *args (args): Arguments for the function that'll be called
        **kwargs (kwargs): Keyword arguments for the function that'll be called

    Returns:
        ???: Result of the given function. Return type depends on the given function
    """
    old_status = inferior_status
    if old_status == typedefs.INFERIOR_STATUS.RUNNING:
        interrupt_inferior(typedefs.STOP_REASON.PAUSE)
    result = func(*args, **kwargs)
    if old_status == typedefs.INFERIOR_STATUS.RUNNING:
        continue_inferior()
    return result


def execute_with_temporary_interruption(func):
    """Decorator version of execute_func_temporary_interruption"""

    def wrapper(*args, **kwargs):
        return execute_func_temporary_interruption(func, *args, **kwargs)

    return wrapper


def can_attach(pid):
    """Check if we can attach to the target

    Args:
        pid (int,str): PID of the process that'll be attached

    Returns:
        bool: True if attaching is successful, False otherwise
    """
    pid_int = safe_int_cast(pid)
    if pid_int == 0:
        return False
    result = libc.ptrace(16, pid_int, 0, 0)  # 16 is PTRACE_ATTACH, check ptrace.h for details
    if result == -1:
        return False
    os.waitpid(pid_int, 0)
    libc.ptrace(17, pid_int, 0, 17)  # 17 is PTRACE_DETACH, check ptrace.h for details
    sleep(0.01)
    return True


def wait_for_stop(timeout=0):
    """Block execution till the inferior stops

    Args:
        timeout (float): Timeout time in seconds, passing 0 will wait for stop indefinitely
    """
    remaining_time = timeout
    while inferior_status == typedefs.INFERIOR_STATUS.RUNNING:
        sleep(0.0001)
        if timeout == 0:
            continue
        remaining_time -= 0.0001
        if remaining_time < 0:
            break


def interrupt_inferior(interrupt_reason=typedefs.STOP_REASON.DEBUG):
    """Interrupt the inferior

    Args:
        interrupt_reason (int): Just changes the global variable stop_reason. Can be a member of typedefs.STOP_REASON
    """
    if currentpid == -1:
        return
    global stop_reason
    if interrupt_signal == "SIGINT":
        send_command("interrupt")
    elif inferior_status == typedefs.INFERIOR_STATUS.RUNNING:
        sig_num = interrupt_signal[3:]
        if sig_num.isnumeric():
            os.system(f"kill -{sig_num} {currentpid}")
        else:
            os.system(f"kill -s {interrupt_signal} {currentpid}")
    wait_for_stop(1)
    stop_reason = interrupt_reason


def continue_inferior():
    """Continue the inferior"""
    if currentpid == -1:
        return
    send_command("c&")


def step_instruction():
    """Step one assembly instruction"""
    send_command("stepi&")


def step_over_instruction():
    """Step over one assembly instruction"""
    send_command("nexti&")


def execute_till_return():
    """Continues inferior till current stack frame returns"""
    send_command("finish&")


def set_interrupt_signal(signal_name):
    """Decides on what signal to use to stop the process

    Args:
        signal_name (str): Name of the signal
    """
    global interrupt_signal
    handle_signal(signal_name, True, False)
    interrupt_signal = signal_name


def handle_signal(signal_name: str, stop: bool, pass_to_program: bool) -> None:
    """Decides on what will GDB do when the process recieves a signal

    Args:
        signal_name (str): Name of the signal
        stop (bool): Stop the program and print to the console
        pass_to_program (bool): Pass signal to program
    """
    params = [[signal_name, stop, pass_to_program]]
    send_command("pince-handle-signals", send_with_file=True, file_contents_send=params)


def handle_signals(signal_list):
    """Optimized version of handle_signal for multiple signals

    Args:
        signal_list (list): A list of the parameters of handle_signal
    """
    send_command("pince-handle-signals", send_with_file=True, file_contents_send=signal_list)


def init_gdb(gdb_path=utils.get_default_gdb_path()):
    """Spawns gdb and initializes/resets some of the global variables

    Args:
        gdb_path (str): Path of the gdb binary

    Returns:
        bool: True if initialization is successful, False otherwise

    Note:
        Calling init_gdb() will reset the current session
    """
    global child
    global gdb_initialized
    global breakpoint_on_hit_dict
    global chained_breakpoints
    global gdb_output
    global cancel_send_command
    global last_gdb_command
    global last_stop_was_tracking
    utils.init_user_files()
    detach()

    # Temporary IPC_PATH, this little hack is needed because send_command requires a valid IPC_PATH
    utils.create_ipc_path(currentpid)
    utils.create_tmp_path(currentpid)

    breakpoint_on_hit_dict.clear()
    chained_breakpoints.clear()
    gdb_output = ""
    cancel_send_command = False
    last_gdb_command = ""
    last_stop_was_tracking = False

    libpince_dir = utils.get_libpince_directory()
    child = pexpect.spawn(
        f"{gdb_path} --nx --interpreter=mi",
        cwd=libpince_dir,
        env=os.environ | {'LC_NUMERIC': 'C'},
        encoding="utf-8",
        codec_errors="replace",
    )
    child.setecho(False)
    child.delaybeforesend = 0
    child.timeout = None
    try:
        child.expect_exact("(gdb)")
    except pexpect.EOF:
        logger.exception(f"EOF exception caught within pexpect, here's the contents of child.before:\n{child.before}")
        return False
    status_thread = Thread(target=state_observe_thread)
    status_thread.daemon = True
    status_thread.start()
    gdb_initialized = True
    set_logging(False)
    if not os.environ.get("APPDIR"):
        send_command("source ./gdbinit_venv")
    set_pince_paths()
    send_command("source " + utils.get_user_path(typedefs.USER_PATHS.GDBINIT))
    utils.execute_script(utils.get_user_path(typedefs.USER_PATHS.PINCEINIT))
    return True


def set_logging(state):
    """Sets logging on or off

    Args:
        state (bool): Sets logging on if True, off if False
    """
    send_command("set logging enabled off")
    send_command("set logging file " + utils.get_logging_file(currentpid))
    if state:
        send_command("set logging enabled on")


def set_pince_paths():
    """Initializes $PINCE_PATH and $GDBINIT_AA_PATH convenience variables to make commands in gdbextensions.py
    and gdbutils.py work. GDB scripts need to know libpince and .config directories, unfortunately they don't start
    from the place where script exists
    """
    libpince_dir = utils.get_libpince_directory()
    pince_dir = os.path.dirname(libpince_dir)
    gdbinit_aa_dir = utils.get_user_path(typedefs.USER_PATHS.GDBINIT_AA)
    send_command("set $GDBINIT_AA_PATH=" + '"' + gdbinit_aa_dir + '"')
    send_command("set $PINCE_PATH=" + '"' + pince_dir + '"')
    send_command("source gdb_python_scripts/gdbextensions.py")


def init_referenced_dicts(pid):
    """Initializes referenced dict shelve databases

    Args:
        pid (int,str): PID of the attached process
    """
    shelve.open(utils.get_referenced_strings_file(pid), "c")
    shelve.open(utils.get_referenced_jumps_file(pid), "c")
    shelve.open(utils.get_referenced_calls_file(pid), "c")


def attach(pid, gdb_path=utils.get_default_gdb_path()):
    """Attaches gdb to the target and initializes some of the global variables

    Args:
        pid (int,str): PID of the process that'll be attached to
        gdb_path (str): Path of the gdb binary

    Returns:
        int: A member of typedefs.ATTACH_RESULT

    Note:
        If gdb is already initialized, gdb_path will be ignored
    """
    global currentpid
    pid = int(pid)
    traced_by = utils.is_traced(pid)
    pid_control_list = [
        # Attaching PINCE to itself makes PINCE freeze immediately because gdb freezes the target on attach
        (lambda: pid == self_pid, typedefs.ATTACH_RESULT.ATTACH_SELF),
        (lambda: not utils.is_process_valid(pid), typedefs.ATTACH_RESULT.PROCESS_NOT_VALID),
        (lambda: pid == currentpid, typedefs.ATTACH_RESULT.ALREADY_DEBUGGING),
        (lambda: traced_by is not None, typedefs.ATTACH_RESULT.ALREADY_TRACED),
        (lambda: not can_attach(pid), typedefs.ATTACH_RESULT.PERM_DENIED),
    ]
    for control_func, attach_result in pid_control_list:
        if control_func():
            return attach_result
    if currentpid != -1 or not gdb_initialized:
        init_gdb(gdb_path)
    global inferior_arch
    global mem_file
    currentpid = pid
    mem_file = "/proc/" + str(currentpid) + "/mem"
    utils.create_ipc_path(pid)
    utils.create_tmp_path(pid)
    send_command("attach " + str(pid))
    set_pince_paths()
    init_referenced_dicts(pid)
    inferior_arch = get_inferior_arch()
    utils.execute_script(utils.get_user_path(typedefs.USER_PATHS.PINCEINIT_AA))
    return typedefs.ATTACH_RESULT.SUCCESSFUL


def create_process(process_path, args="", ld_preload_path="", gdb_path=utils.get_default_gdb_path()):
    """Creates a new process for debugging and initializes some of the global variables
    Current process will be detached even if the create_process call fails
    Make sure to save your data before calling this monstrosity

    Args:
        process_path (str): Absolute path of the target binary
        args (str): Arguments of the inferior, optional
        ld_preload_path (str): Path of the preloaded .so file, optional
        gdb_path (str): Path of the gdb binary

    Returns:
        bool: True if the process has been created successfully, False otherwise

    Note:
        If gdb is already initialized, gdb_path will be ignored
    """
    global currentpid
    global inferior_arch
    global mem_file
    if currentpid != -1 or not gdb_initialized:
        init_gdb(gdb_path)
    output = send_command("file " + process_path)
    if regexes.gdb_error.search(output):
        logger.error(f"An error occurred while trying to create process from the file at {process_path}")
        detach()
        return False
    send_command("starti")
    wait_for_stop()
    entry_point = find_entry_point()
    if entry_point:
        send_command("tbreak *" + entry_point)
    else:
        send_command("tbreak _start")
    send_command("set args " + args)
    if ld_preload_path:
        send_command("set exec-wrapper env 'LD_PRELOAD=" + ld_preload_path + "'")
    send_command("run")

    # We have to wait till breakpoint hits
    wait_for_stop()
    pid = get_inferior_pid()
    currentpid = int(pid)
    mem_file = "/proc/" + str(currentpid) + "/mem"
    utils.create_ipc_path(pid)
    utils.create_tmp_path(pid)
    set_pince_paths()
    init_referenced_dicts(pid)
    inferior_arch = get_inferior_arch()
    utils.execute_script(utils.get_user_path(typedefs.USER_PATHS.PINCEINIT_AA))
    return True


def detach():
    """See you, space cowboy"""
    global gdb_initialized
    global currentpid
    old_pid = currentpid
    if gdb_initialized:
        global child
        global inferior_status
        currentpid = -1
        inferior_status = -1
        gdb_initialized = False
        child.close()
    if old_pid != -1:
        utils.delete_ipc_path(old_pid)
    logger.info(f"Detached from the process with PID: {str(old_pid)}")


def toggle_attach():
    """Detaches from the current process without ending the season if currently attached. Attaches back if detached

    Returns:
        int: The new state of the process as a member of typedefs.TOGGLE_ATTACH
        None: If detaching or attaching fails
    """
    if currentpid == -1:
        return
    if is_attached():
        if regexes.gdb_error.search(send_command("phase-out")):
            return
        return typedefs.TOGGLE_ATTACH.DETACHED
    if regexes.gdb_error.search(send_command("phase-in")):
        return
    return typedefs.TOGGLE_ATTACH.ATTACHED


def is_attached():
    """Checks if gdb is attached to the current process

    Returns:
        bool: True if attached, False if not
    """
    if regexes.gdb_error.search(send_command("info proc")):
        return False
    return True


def inject_with_advanced_injection(library_path):
    """Injects the given .so file to current process

    Args:
        library_path (str): Path to the .so file that'll be injected

    Returns:
        bool: Result of the injection

    Note:
        This function was reserved for linux-inject and since linux-inject is no more(F to pay respects), I'll leave
        this function as a template for now
    """
    raise NotImplementedError


def inject_with_dlopen_call(library_path):
    """Injects the given .so file to current process
    This is a variant of the function inject_with_advanced_injection
    This function won't break the target process unlike other complex injection methods
    The downside is it fails if the target doesn't support dlopen calls or simply doesn't have the library

    Args:
        library_path (str): Path to the .so file that'll be injected

    Returns:
        bool: Result of the injection
    """
    # TODO: Merge injection functions and rename them to inject_so once advanced injection is implemented
    injectionpath = '"' + library_path + '"'
    result = call_function_from_inferior("dlopen(" + injectionpath + ", 1)")[1]
    if result == "0" or not result:
        new_result = call_function_from_inferior("__libc_dlopen_mode(" + injectionpath + ", 1)")[1]
        if new_result == "0" or not new_result:
            return False
        return True
    return True


def read_pointer_chain(pointer_request: typedefs.PointerChainRequest) -> typedefs.PointerChainResult | None:
    """Reads the addresses pointed by this pointer chain

    Args:
        pointer_request (typedefs.PointerChainRequest): class containing a base_address and an offsets list

    Returns:
        typedefs.PointerChainResult: Class containing every pointer dereference result while walking the chain
        None: If an error occurs while reading the given pointer chain
    """
    if not isinstance(pointer_request, typedefs.PointerChainRequest):
        raise TypeError("Passed non-PointerChainRequest type to read_pointer_chain!")

    if inferior_arch == typedefs.INFERIOR_ARCH.ARCH_32:
        value_index = typedefs.VALUE_INDEX.INT32
    else:
        value_index = typedefs.VALUE_INDEX.INT64

    # Simple addresses first, examine_expression takes much longer time, especially for larger tables
    try:
        start_address = int(pointer_request.base_address, 0)
    except (ValueError, TypeError):
        start_address = examine_expression(pointer_request.base_address).address

    pointer_results: typedefs.PointerChainResult = typedefs.PointerChainResult()
    try:
        with memory_handle() as mem_handle:
            # Dereference the first address which is the base or (base + offset)
            deref_address = read_memory(start_address, value_index, mem_handle=mem_handle)
            if deref_address is None:
                # Simply return None because no point reading further if base is not valid
                return None
            pointer_results.pointer_chain.append(deref_address)

            for index, offset in enumerate(pointer_request.offsets_list):
                # If deref_address is 0, we found an invalid read in the chain
                # so we can just keep adding 0 until the end of offsets list
                if deref_address == 0:
                    pointer_results.pointer_chain.append(0)
                    continue
                offset_address = deref_address + offset
                if index != len(pointer_request.offsets_list) - 1:  # CE derefs every offset except for the last one
                    deref_address = read_memory(offset_address, value_index, mem_handle=mem_handle)
                    if deref_address is None:
                        deref_address = 0
                else:
                    deref_address = offset_address
                pointer_results.pointer_chain.append(deref_address)
    except OSError:
        return None
    return pointer_results


def memory_handle():
    """
    Acquire the handle of the currently attached process

    Returns:
        BinaryIO: A file handle that points to the memory file of the current process
    """
    return open(mem_file, "rb")


@execute_with_temporary_interruption
def allocate_memory(size: int, name: str | None) -> int:
    global allocated_memory_chunks
    global allocated_memory_gen_id
    if size == 0:
        return 0
    if name == None:
        allocated_memory_gen_id += 1
        name = str(allocated_memory_gen_id)
    output = send_command(f"p (void*)malloc({size})")
    match = regexes.hex_number.search(output)
    if match == None:
        logger.error("Memory allocation failed!")
        return 0
    allocated_address = safe_str_to_int(match[0], 16)
    if allocated_address == 0:
        logger.error(f"Couldn't find allocation address! Allocation output: {output}")
        return 0
    allocated_memory = typedefs.AllocatedMemory(allocated_address, size)
    allocated_memory_chunks[name] = allocated_memory
    page_size = os.sysconf("SC_PAGE_SIZE")
    page_memory_addr = allocated_memory.address & ~(page_size - 1)
    send_command(f"p (int)mprotect({page_memory_addr}, {page_size}, 7)")  # PROT_READ | PROT_WRITE | PROT_EXEC = 7
    return allocated_memory.address


@execute_with_temporary_interruption
def free_memory(name: str) -> bool:
    global allocated_memory_chunks
    if str == None or str == "":
        # TODO brkzlr: Maybe error log?
        return False
    address = allocated_memory_chunks.get(name)
    if address == None:
        # TODO brkzlr: log wrong key
        return False
    # This shit will crash the process if you call it on invalid or already freed memory.
    send_command(f"p (void)free({address})")
    del allocated_memory_chunks[name]
    return True


def read_memory(
    address: str | int,
    value_index: int,
    length: int = 0,
    zero_terminate: bool = True,
    value_repr: int = typedefs.VALUE_REPR.UNSIGNED,
    endian: int = typedefs.ENDIANNESS.HOST,
    mem_handle: io.BufferedReader | None = None,
) -> str | float | int | None:
    """Reads value from the given address

    Args:
        address (str, int): Can be a hex string or an integer.
        value_index (int): Determines the type of data read. Can be a member of typedefs.VALUE_INDEX
        length (int): Length of the data that'll be read. Must be greater than 0. Only used when the value_index is
        STRING or AOB. Ignored otherwise
        zero_terminate (bool): If True, data will be split when a null character has been read. Only used when
        value_index is STRING. Ignored otherwise
        value_repr (int): Can be a member of typedefs.VALUE_REPR. Only usable with integer types
        endian (int): Can be a member of typedefs.ENDIANNESS
        mem_handle (io.BufferedReader, None): A file handle that points to the memory file of the current process
        This parameter is used for optimization, See memory_handle
        Don't forget to close the handle after you're done if you use this parameter manually

    Returns:
        str: If the value_index is STRING or AOB, also when value_repr is HEX
        float: If the value_index is FLOAT32 or FLOAT64
        int: If the value_index is anything else
        None: If an error occurs while reading the given address
    """
    try:
        value_index = int(value_index)
    except:
        return
    if not type(address) == int:
        try:
            address = int(address, 0)
        except:
            return
    packed_data = typedefs.index_to_valuetype_dict.get(value_index, -1)
    if typedefs.VALUE_INDEX.is_string(value_index):
        try:
            length = int(length)
        except:
            return
        if not length > 0:
            return
        expected_length = length * typedefs.string_index_to_multiplier_dict.get(value_index, 1)
    elif value_index is typedefs.VALUE_INDEX.AOB:
        try:
            expected_length = int(length)
        except:
            return
        if not expected_length > 0:
            return
    else:
        expected_length = packed_data[0]
        data_type = packed_data[1]
    try:
        if not mem_handle:
            mem_handle = open(mem_file, "rb")
        mem_handle.seek(address)
        data_read = mem_handle.read(expected_length)
        if endian != typedefs.ENDIANNESS.HOST and system_endianness != endian:
            data_read = data_read[::-1]
    except (OSError, ValueError):
        # TODO (read/write error output)
        # Disabled read error printing. If needed, find a way to implement error logging with this function
        # I've initially thought about enabling it on demand via a parameter but this function already has too many
        # Maybe creating a function that toggles logging on and off? Other functions could use it too
        # print("Can't access the memory at address " + hex(address) + " or offset " + hex(address + expected_length))
        return
    if typedefs.VALUE_INDEX.is_string(value_index):
        encoding, option = typedefs.string_index_to_encoding_dict[value_index]
        returned_string = data_read.decode(encoding, option)
        if zero_terminate:
            if returned_string.startswith("\x00"):
                returned_string = "\x00"
            else:
                returned_string = returned_string.split("\x00")[0]
        return returned_string[0:length]
    elif value_index is typedefs.VALUE_INDEX.AOB:
        return " ".join(format(n, "02x") for n in data_read)
    else:
        is_integer = typedefs.VALUE_INDEX.is_integer(value_index)
        if is_integer and value_repr == typedefs.VALUE_REPR.SIGNED:
            data_type = data_type.lower()
        result = struct.unpack_from(data_type, data_read)[0]
        if is_integer and value_repr == typedefs.VALUE_REPR.HEX:
            return hex(result)
        return result


def write_memory(
    address: str | int,
    value_index: int,
    value: str | int | float | list[int],
    zero_terminate=True,
    endian=typedefs.ENDIANNESS.HOST,
):
    """Sets the given value to the given address

    If any errors occurs while setting value to the according address, it'll be ignored but the information about
    error will be printed to the terminal.

    Args:
        address (str, int): Can be a hex string or an integer
        value_index (int): Can be a member of typedefs.VALUE_INDEX
        value (str, int, float, list): The value that'll be written to the given address
        zero_terminate (bool): If True, appends a null byte to the value. Only used when value_index is STRING
        endian (int): Can be a member of typedefs.ENDIANNESS

    Notes:
        TODO: Implement a mem_handle parameter for optimization, check read_memory for an example
        If a file handle fails to write to an address, it becomes unusable
        You have to reopen the file to continue writing
    """
    if not type(address) == int:
        try:
            address = int(address, 0)
        except:
            return
    if isinstance(value, str):
        write_data = utils.parse_string(value, value_index)
        if write_data is None:
            return
    else:
        write_data = value
    encoding, option = typedefs.string_index_to_encoding_dict.get(value_index, (None, None))
    if encoding is None:
        if value_index is typedefs.VALUE_INDEX.AOB:
            write_data = bytearray(write_data)
        else:
            data_type = typedefs.index_to_struct_pack_dict.get(value_index, -1)
            write_data = struct.pack(data_type, write_data)
    else:
        write_data = write_data.encode(encoding, option)
        if zero_terminate:
            write_data += b"\x00"
    if endian != typedefs.ENDIANNESS.HOST and system_endianness != endian:
        write_data = write_data[::-1]
    FILE = open(mem_file, "rb+")
    try:
        FILE.seek(address)
        FILE.write(write_data)
        FILE.close()
    except (OSError, ValueError):
        # Refer to TODO (read/write error output)
        # print("Can't access the memory at address " + hex(address) + " or offset " + hex(address + len(write_data)))
        return


def disassemble(expression, offset_or_address):
    """Disassembles the address evaluated by the given expression

    Args:
        expression (str): Any gdb expression
        offset_or_address (str): If you pass this parameter as an offset, you should add "+" in front of it
        (e.g "+42" or "+0x42"). If you pass this parameter as an hex address, the address range between the expression
        and the secondary address is disassembled
        If the second parameter is an address, it always should be bigger than the first address

    Returns:
        list: A list of str values in this format-->[(address1, bytes1, opcodes1), (address2, ...), ...]
    """
    output = send_command("disas /r " + expression + "," + offset_or_address)
    disas_data = []
    for line in output.splitlines():
        result = regexes.disassemble_output.search(line)
        if result:
            disas_data.append(result.groups())
    return disas_data


def convert_to_hex(expression):
    """Converts numeric values in the expression into their hex equivalents
    Respects edge cases like indexed maps and keeps indices as decimals

    Args:
        expression (str): Any gdb expression

    Returns:
        str: Converted str
    """
    # TODO (lldb): We'll most likely write our own expression parser once we switch to lldb
    # Merge this function with examine_expression and gdbutils.examine_expression once that happens
    return regexes.expression_with_hex.sub(
        lambda m: "0x" + m.group(1) if m.group(1) and not examine_expression(m.group(1)).symbol else m.group(0),
        expression,
    )


def examine_expression(expression):
    """Evaluates the given expression and returns evaluated value, address and symbol

    Args:
        expression (str): Any gdb expression

    Returns:
        typedefs.tuple_examine_expression: Evaluated value, address and symbol in a tuple
        Any erroneous field will be returned as None instead of str
    """
    if currentpid == -1:
        return typedefs.tuple_examine_expression(None, None, None)
    return send_command(
        "pince-examine-expressions", send_with_file=True, file_contents_send=[expression], recv_with_file=True
    )[0]


def examine_expressions(expression_list):
    """Optimized version of examine_expression for multiple inputs

    Args:
        expression_list (list): List of gdb expressions as str

    Returns:
        list: List of typedefs.tuple_examine_expression
    """
    if not expression_list:
        return []
    if currentpid == -1:
        return [typedefs.tuple_examine_expression(None, None, None) for _ in range(len(expression_list))]
    return send_command(
        "pince-examine-expressions", send_with_file=True, file_contents_send=expression_list, recv_with_file=True
    )


def parse_and_eval(expression, cast=str):
    """Calls gdb.parse_and_eval with the given expression and returns the value after casting with the given type
    Use examine_expression if your data can be expressed as an address or a symbol, use this function otherwise
    Unlike examine_expression, this function can read data that has void type or multiple type representations
    For instance:

    - $eflags has both str and int reprs
    - $_siginfo is a struct with many fields
    - x64 register convenience vars such as $rax are void if the process is x86

    Args:
        expression (str): Any gdb expression
        cast (type): Evaluated value will be cast to this type in gdb

    Returns:
        cast: Self-explanatory
        None: If casting fails
    """
    return send_command(
        "pince-parse-and-eval", send_with_file=True, file_contents_send=(expression, cast), recv_with_file=True
    )


def is_address_static(address: str | int) -> bool:
    """Uses gdb's 'info symbol' command to check if an address belongs to an ELF section
    which would guarantee a static address

    Args:
        address (str | int): Address to check in either hex str or int format

    Returns:
        bool: True is address is static, False otherwise
    """
    if type(address) == int:
        address_str = hex(address)
    elif type(address) == str:
        address_str = utils.extract_hex_address(address)
        if not address_str:
            logger.error(f"Invalid hex address string 'f{address}'")
            return False
    else:
        logger.error(f"Passed wrong type '{type(address)}' instead of str or int")
        return False
    result = send_command(f"info symbol {address_str}")
    if regexes.elf_section.search(result):
        return True
    else:
        return False


def get_thread_info():
    """Invokes "info threads" command and returns the line corresponding to the current thread

    Returns:
        str: Current thread information
        None: If the output doesn't fit the regex
    """
    thread_info = send_command("info threads")
    return re.sub(r'\\"', r'"', regexes.thread_info.search(thread_info).group(1))


def find_closest_instruction_address(address, instruction_location="next", instruction_count=1):
    """Finds address of the closest instruction next to the given address, assuming that the given address is valid

    Args:
        address (str): Hex address or any gdb expression that can be used in disas command
        instruction_location (str): If it's "next", instructions coming after the address is searched
        If it's "previous", the instructions coming before the address is searched instead
        instruction_count (int): Number of the instructions that'll be looked for

    Returns:
        str: The address found as hex string. If starting/ending of a valid memory range is reached, starting/ending
        address is returned instead as hex string.

    Note:
        From gdb version 7.12 and onwards, inputting negative numbers in x command are supported(x/-3i for instance)
        So, modifying this function according to the changes in 7.12 may speed up things a little bit but also breaks
        the backwards compatibility. The speed gain is not much of a big deal compared to backwards compatibility, so
        I'm not changing this function for now
    """
    assert instruction_location in ["next", "previous"], "invalid instruction_location"
    if instruction_location == "next":
        offset = "+" + str(instruction_count * 30)
        disas_data = disassemble(address, address + offset)
    else:
        offset = "-" + str(instruction_count * 30)
        disas_data = disassemble(address + offset, address)
    if not disas_data:
        if instruction_location != "next":
            start_address = hex(utils.get_region_info(currentpid, address).start)
            disas_data = disassemble(start_address, address)
    if instruction_location == "next":
        try:
            return utils.extract_hex_address(disas_data[instruction_count][0])
        except IndexError:
            return hex(utils.get_region_info(currentpid, address).end)
    else:
        try:
            return utils.extract_hex_address(disas_data[-instruction_count][0])
        except IndexError:
            try:
                return start_address
            except UnboundLocalError:
                return hex(utils.get_region_info(currentpid, address).start)


def get_address_info(expression):
    """Runs the gdb command "info symbol" for given expression and returns the result of it

    Args:
        expression (str): Any gdb expression

    Returns:
        str: The result of the command "info symbol" for given expression
    """
    return send_command("info symbol " + expression, cli_output=True)


def get_symbol_info(expression):
    """Runs the gdb command "info address" for given expression and returns the result of it

    Args:
        expression (str): Any gdb expression

    Returns:
        str: The result of the command "info address" for given expression
    """
    return send_command("info address " + expression, cli_output=True)


def search_functions(expression, case_sensitive=False):
    """Runs the gdb command "info functions" for given expression and returns the result of it

    Args:
        expression (str): Any gdb expression
        case_sensitive (bool): If True, search will be case sensitive

    Returns:
        list: A list of str-->[(address1, symbol1), (address2, symbol2), ...]
            address will be None if the corresponding symbol is in defined category

    Todo:
        GDB-MI wiki points out to the command -symbol-list-functions but apparently it isn't implemented yet
        If the feature below gets implemented, use it instead
        https://sourceware.org/bugzilla/show_bug.cgi?id=23796

        Add ability to show addresses of defined symbols when it gets implemented by gdb
        Please don't try to write a symbol parser for every single language out there, it's an overkill
        https://sourceware.org/bugzilla/show_bug.cgi?id=23899
    """
    return send_command(
        "pince-search-functions",
        send_with_file=True,
        file_contents_send=(expression, case_sensitive),
        recv_with_file=True,
    )


def get_inferior_pid():
    """Get pid of the current inferior

    Returns:
        str: pid
    """
    output = send_command("info inferior")
    return regexes.inferior_pid.search(output).group(1)


def get_inferior_arch():
    """Returns the architecture of the current inferior

    Returns:
        int: A member of typedefs.INFERIOR_ARCH
    """
    if parse_and_eval("$rax") == "void":
        return typedefs.INFERIOR_ARCH.ARCH_32
    return typedefs.INFERIOR_ARCH.ARCH_64


def read_registers():
    """Returns the current registers

    Returns:
        dict: A dict that holds general, flag and segment registers. Check typedefs.REGISTERS for the full list
    """
    return send_command("pince-read-registers", recv_with_file=True)


def read_float_registers() -> OrderedDict[str, str]:
    """Returns the current floating point registers

    Returns:
        OrderedDict[str, str]: A dict that holds floating point registers. Check typedefs.REGISTERS.FLOAT for the full list

    Note:
        Returned xmm values are based on xmm.v4_float
    """
    return send_command("pince-read-float-registers", recv_with_file=True)


def set_convenience_variable(variable, value):
    """Sets given convenience variable to given value
    Can be also used for modifying registers directly

    Args:
        variable (str): Any gdb convenience variable(with "$" character removed)
        value (str): Anything
    """
    send_command("set $" + variable + "=" + value)


def set_register_flag(flag, value):
    """Sets given register flag to given value

    Args:
        flag (str): A member of typedefs.REGISTERS.FLAG
        value (Union[int,str]): 0 or 1
    """
    registers = read_registers()
    value = str(value)
    registers[flag] = value
    if value != "0" and value != "1":
        raise Exception(value + " isn't valid value. It can be only 0 or 1")
    if flag not in typedefs.REGISTERS.FLAG:
        raise Exception(flag + " isn't a valid flag, must be a member of typedefs.REGISTERS.FLAG")
    eflags_hex_value = hex(
        int(
            registers["of"]
            + registers["df"]
            + registers["if"]
            + registers["tf"]
            + registers["sf"]
            + registers["zf"]
            + "0"
            + registers["af"]
            + "0"
            + registers["pf"]
            + "0"
            + registers["cf"],
            2,
        )
    )
    set_convenience_variable("eflags", eflags_hex_value)


def get_stacktrace_info():
    """Returns information about current stacktrace

    Returns:
        list: A list of str values in this format-->[[return_address_info1,frame_address_info1],[info2, ...], ...]

        return_address_info looks like this-->Return address of frame+symbol-->0x40c431 <_start>
        frame_address_info looks like this-->Beginning of frame+distance from stack pointer-->0x7ffe1e989a40(rsp+0x100)
    """
    return send_command("pince-get-stack-trace-info", recv_with_file=True)


def get_stack_info(from_base_pointer: bool = False) -> list[str]:
    """Returns information about current stack
    Also can view stack from EBP or RBP register

    Returns:
        list: A list of str values in this format--▼
        [[stack_pointer_info1,hex_value1,pointer_info1],[stack_pointer_info2, ...], ...]

        stack_pointer_info looks like this-->Hex address+distance from stack pointer-->0x7ffd0d232f88(rsp+0xff8)
        hex_value looks like this-->Value hold by corresponding address-->0x1bfda20
        pointer_info shows the value hold by hex_value address. It looks like this--▼
        if points to a string-->(str)Some String
        if points to a symbol-->(ptr)<function_name>
        pointer_info becomes a null string if pointer isn't valid
    """
    if from_base_pointer:
        return send_command("pince-get-stack-info from-base-pointer", recv_with_file=True)
    else:
        return send_command("pince-get-stack-info", recv_with_file=True)


def get_stack_frame_return_addresses():
    """Returns return addresses of stack frames

    Returns:
        list: A list of str values in this format-->[return_address_info1,return_address_info2, ...]

        return_address_info looks like this-->Return address of frame+symbol-->0x40c431 <_start>
    """
    return send_command("pince-get-frame-return-addresses", recv_with_file=True)


def get_stack_frame_info(index):
    """Returns information about stack by the given index

    Args:
        index (int,str): Index of the frame

    Returns:
        str: Information that looks like this::

        Stack level 0, frame at 0x7ffc5f87f6a0:
            rip = 0x7fd1d639412d in poll (../sysdeps/unix/syscall-template.S:81); saved rip = 0x7fd1d27fcfe4
            called by frame at 0x7ffc5f87f700
            source language asm.
            Arglist at 0x7ffc5f87f688, args:
            Locals at 0x7ffc5f87f688, Previous frame's sp is 0x7ffc5f87f6a0
            Saved registers:
                rip at 0x7ffc5f87f698
    """
    return send_command("pince-get-frame-info", send_with_file=True, file_contents_send=str(index), recv_with_file=True)


def hex_dump(address, offset):
    """Returns hex dump of range (address to address+offset)

    Args:
        address (int): Self-explanatory
        offset (int): The range that'll be read

    Returns:
        list: List of strings read as str. If an error occurs while reading a memory cell, that cell is returned as "??"
        An empty list is returned if an error occurs

    Examples:
        returned list-->["??","??","??","7f","43","67","40","??","??, ...]
    """
    hex_byte_list = []
    with open(mem_file, "rb") as FILE:
        try:
            FILE.seek(address)
        except (OSError, ValueError):
            pass
        for item in range(offset):
            try:
                current_item = " ".join(format(n, "02x") for n in FILE.read(1))
            except OSError:
                current_item = "??"
                try:
                    FILE.seek(1, io.SEEK_CUR)  # Necessary since read() failed to execute
                except (OSError, ValueError):
                    pass
            hex_byte_list.append(utils.upper_hex(current_item))
    return hex_byte_list


def get_modified_instructions():
    """Returns currently modified instructions

    Returns:
        dict: A dictionary where the key is the start address of instruction and value is the aob before modifying

    """
    global modified_instructions_dict
    return modified_instructions_dict


def nop_instruction(start_address, length_of_instr):
    """Replaces an instruction's opcodes with NOPs

    Args:
        start_address (int): Self-explanatory
        length_of_instr (int): Length of the instruction that'll be NOP'ed

    Returns:
        None
    """
    old_aob = " ".join(hex_dump(start_address, length_of_instr))
    global modified_instructions_dict
    if start_address not in modified_instructions_dict:
        modified_instructions_dict[start_address] = old_aob

    nop_aob = "90 " * length_of_instr
    write_memory(start_address, typedefs.VALUE_INDEX.AOB, nop_aob)


def modify_instruction(start_address, array_of_bytes):
    """Replaces an instruction's opcodes with a new AOB

    Args:
        start_address (int): Self-explanatory
        array_of_bytes (str): String that contains the replacement bytes of the instruction

    Returns:
        None
    """
    length = len(array_of_bytes.split())
    old_aob = " ".join(hex_dump(start_address, length))

    global modified_instructions_dict
    if start_address not in modified_instructions_dict:
        modified_instructions_dict[start_address] = old_aob
    write_memory(start_address, typedefs.VALUE_INDEX.AOB, array_of_bytes)


def restore_instruction(start_address):
    """Restores a modified instruction to it's original opcodes

    Args:
        start_address (int): Self-explanatory

    Returns:
        None
    """
    global modified_instructions_dict
    array_of_bytes = modified_instructions_dict.pop(start_address)
    write_memory(start_address, typedefs.VALUE_INDEX.AOB, array_of_bytes)


def get_breakpoint_info() -> list[typedefs.tuple_breakpoint_info]:
    """Returns current breakpoint/watchpoint list

    Returns:
        list: A list of typedefs.tuple_breakpoint_info where;
            number is the gdb breakpoint number
            breakpoint_type is the breakpoint type
            disp shows what will be done after breakpoint hits
            enabled shows if the breakpoint enabled or disabled
            address is the address of breakpoint
            size is the size of breakpoint
            on_hit is the action that'll happen when the breakpoint is reached
            hit_count shows how many times the breakpoint has been hit
            enable_count shows how many times the breakpoint will get hit before it gets disabled
            condition is the condition of breakpoint

            size-->int
            everything else-->str

    Note:
        GDB's python API can't detect hardware breakpoints, that's why we are using parser for this job
    """
    returned_list = []
    multiple_break_data = OrderedDict()
    raw_info = send_command("-break-list")
    # Temporary fix for https://sourceware.org/bugzilla/show_bug.cgi?id=9659
    # TODO:Delete this line when gdb or pygdbmi fixes the problem
    raw_info = re.sub(r"script={(.*?)}", r"script=[\g<1>]", raw_info)  # Please refer to issue #53
    for item in utils.parse_response(raw_info)["payload"]["BreakpointTable"]["body"]:
        item = defaultdict(lambda: "", item)
        number, breakpoint_type, disp, enabled, address, what, condition, hit_count, enable_count = (
            item["number"],
            item["type"],
            item["disp"],
            item["enabled"],
            item["addr"],
            item["what"],
            item["cond"],
            item["times"],
            item["enable"],
        )
        if address == "<MULTIPLE>":
            multiple_break_data[number] = (breakpoint_type, disp, condition, hit_count)
            continue
        if not breakpoint_type:
            number = number.split(".")[0]
            breakpoint_type, disp, condition, hit_count = multiple_break_data[number]
        if what:
            address = utils.extract_hex_address(what)
            if not address:
                address = examine_expression(what).address
        on_hit_dict_value = breakpoint_on_hit_dict.get(number, typedefs.BREAKPOINT_ON_HIT.BREAK)
        on_hit = typedefs.on_hit_to_text_dict.get(on_hit_dict_value, "Unknown")
        if breakpoint_type.find("breakpoint") >= 0:
            size = 1
        else:
            possible_size = regexes.breakpoint_size.search(what)
            if possible_size:
                size = int(possible_size.group(1))
            else:
                size = 1
        returned_list.append(
            typedefs.tuple_breakpoint_info(
                number, breakpoint_type, disp, enabled, address, size, on_hit, hit_count, enable_count, condition
            )
        )
    return returned_list


def get_breakpoints_in_range(address: str | int, length: int = 1) -> list[typedefs.tuple_breakpoint_info]:
    """Checks if given address exists in breakpoint list

    Args:
        address (str,int): Start address of the range, hex address or an int
        length (int): If this parameter is bigger than 1, the range between address and address+length-1 will be
        checked instead of just the address itself

    Returns:
        list: A list of typedefs.tuple_breakpoint_info, info of the existing breakpoints for given address range
    """
    breakpoint_list = []
    if type(address) != int:
        address = safe_str_to_int(address, 0)
        if address == 0:
            return breakpoint_list
    max_address = max(address, address + length - 1)
    min_address = min(address, address + length - 1)
    breakpoint_info = get_breakpoint_info()
    for item in breakpoint_info:
        breakpoint_address = safe_str_to_int(item.address, 16)
        if not (max_address < breakpoint_address or min_address > breakpoint_address + item.size - 1):
            breakpoint_list.append(item)
    return breakpoint_list


def hardware_breakpoint_available() -> bool:
    """Checks if there is an available hardware breakpoint slot

    Returns:
        bool: True if there is at least one available slot, False if not

    Todo:
        Check debug registers to determine hardware breakpoint state rather than relying on gdb output because inferior
        might modify its own debug registers
    """
    breakpoint_info = get_breakpoint_info()
    hw_bp_total = 0
    for item in breakpoint_info:
        if regexes.hw_breakpoint_count.search(item.breakpoint_type):
            hw_bp_total += 1

    # Maximum number of hardware breakpoints is limited to 4 in x86 architecture
    return hw_bp_total < 4


def add_breakpoint(
    expression, breakpoint_type=typedefs.BREAKPOINT_TYPE.HARDWARE, on_hit=typedefs.BREAKPOINT_ON_HIT.BREAK
) -> int | None:
    """Adds a breakpoint at the address evaluated by the given expression. Uses a software breakpoint if all hardware
    breakpoint slots are being used

    Args:
        expression (str): Any gdb expression
        breakpoint_type (int): Can be a member of typedefs.BREAKPOINT_TYPE
        on_hit (int): Can be a member of typedefs.BREAKPOINT_ON_HIT

    Returns:
        int: Number of the breakpoint set
        None: If setting breakpoint fails
    """
    output = ""
    str_address = examine_expression(expression).address
    if not str_address:
        logger.error(f"Failed to add breakpoint. Expression {expression} is not valid")
        return
    if get_breakpoints_in_range(str_address):
        logger.error(f"Breakpoint/Watchpoint for address {str_address} is already set")
        return
    if breakpoint_type == typedefs.BREAKPOINT_TYPE.HARDWARE:
        if hardware_breakpoint_available():
            output = send_command("hbreak *" + str_address)
        else:
            logger.warning("All hardware breakpoint slots are being used, using a software breakpoint instead")
            output = send_command("break *" + str_address)
    elif breakpoint_type == typedefs.BREAKPOINT_TYPE.SOFTWARE:
        output = send_command("break *" + str_address)
    if regexes.breakpoint_created.search(output):
        global breakpoint_on_hit_dict
        number = regexes.breakpoint_number.search(output).group(1)
        breakpoint_on_hit_dict[number] = on_hit
        return int(number)
    else:
        return


@execute_with_temporary_interruption
def add_watchpoint(
    expression: str,
    length: int = 4,
    watchpoint_type: int = typedefs.WATCHPOINT_TYPE.BOTH,
    on_hit: int = typedefs.BREAKPOINT_ON_HIT.BREAK,
) -> list[str] | None:
    """Adds a watchpoint at the address evaluated by the given expression

    Args:
        expression (str): Any gdb expression
        length (int): Length of the watchpoint
        watchpoint_type (int): Can be a member of typedefs.WATCHPOINT_TYPE
        on_hit (int): Can be a member of typedefs.BREAKPOINT_ON_HIT

    Returns:
        list: Numbers of the successfully set breakpoints as strings
        None: If setting watchpoint fails
    """
    str_address = examine_expression(expression).address
    if not str_address:
        logger.error(f"Expression '{expression}' for watchpoint is not valid")
        return
    if watchpoint_type == typedefs.WATCHPOINT_TYPE.WRITE_ONLY:
        watch_command = "watch"
    elif watchpoint_type == typedefs.WATCHPOINT_TYPE.READ_ONLY:
        watch_command = "rwatch"
    elif watchpoint_type == typedefs.WATCHPOINT_TYPE.BOTH:
        watch_command = "awatch"
    remaining_length = length
    breakpoints_set = []
    breakpoints_nums = []
    arch = get_inferior_arch()
    str_address_int = int(str_address, 16)
    if arch == typedefs.INFERIOR_ARCH.ARCH_64:
        max_length = 8
    else:
        max_length = 4
    while remaining_length > 0:
        if remaining_length >= max_length:
            breakpoint_length = max_length
        else:
            breakpoint_length = remaining_length
        if get_breakpoints_in_range(str_address_int, breakpoint_length):
            logger.error(f"Breakpoint/Watchpoint for address {hex(str_address_int)} is already set. Bailing out...")
            break
        if not hardware_breakpoint_available():
            logger.error("All hardware breakpoint slots are being used, unable to set a new watchpoint. Bailing out...")
            break
        cmd = f"{watch_command} * (char[{breakpoint_length}] *) {hex(str_address_int)}"
        output = execute_func_temporary_interruption(send_command, cmd)
        if not regexes.breakpoint_created.search(output):
            logger.error(f"Failed to create a watchpoint at address {hex(str_address_int)}. Bailing out...")
            break
        breakpoint_number = regexes.breakpoint_number.search(output).group(1)
        breakpoints_set.append(breakpoint_number)
        breakpoints_nums.append(safe_int_cast(breakpoint_number))
        global breakpoint_on_hit_dict
        breakpoint_on_hit_dict[breakpoint_number] = on_hit
        remaining_length -= max_length
        str_address_int += max_length
    global chained_breakpoints
    chained_breakpoints.append(breakpoints_nums)
    return breakpoints_set


def modify_breakpoint(breakpoint_number, modify_what, condition=None, count=None) -> bool:
    """Adds a condition to an existing breakpoint

    Args:
        breakpoint_number (int): Breakpoint number in gdb
        modify_what (typedefs.BREAKPOINT_MODIFY): This param controls how the function modifies the breakpoint:
        - Modifies condition of the breakpoint if CONDITION
        - Enables the breakpoint if ENABLE
        - Disables the breakpoint if DISABLE
        - Enables once then disables after hit if ENABLE_ONCE
        - Enables for specified count then disables after the count is reached if ENABLE_COUNT
        - Enables once then deletes the breakpoint if ENABLE_DELETE
        condition (str | None): Any gdb condition expression. This parameter is only used if modify_what passed as CONDITION
        count (int | None): Only used if modify_what passed as ENABLE_COUNT

    Returns:
        bool: True if the condition has been set successfully, False otherwise

    Examples:
        modify_what-->typedefs.BREAKPOINT_MODIFY.CONDITION
        condition-->$eax==0x523
        condition-->$rax>0 && ($rbp<0 || $rsp==0)
        condition-->printf($r10)==3

        modify_what-->typedefs.BREAKPOINT_MODIFY.ENABLE_COUNT
        count-->10
    """
    modification_list = [breakpoint_number]
    global chained_breakpoints
    for _, item in enumerate(chained_breakpoints):
        for breakpoint in item:
            if breakpoint == breakpoint_number:
                modification_list = item
                break
    for breakpoint in modification_list:
        if modify_what == typedefs.BREAKPOINT_MODIFY.CONDITION:
            if condition is None:
                logger.error("Missing condition for breakpoint modification")
                return False
            send_command(f"condition {breakpoint} {condition}")
        elif modify_what == typedefs.BREAKPOINT_MODIFY.ENABLE:
            send_command(f"enable {breakpoint}")
        elif modify_what == typedefs.BREAKPOINT_MODIFY.DISABLE:
            send_command(f"disable {breakpoint}")
        elif modify_what == typedefs.BREAKPOINT_MODIFY.ENABLE_ONCE:
            send_command(f"enable once {breakpoint}")
        elif modify_what == typedefs.BREAKPOINT_MODIFY.ENABLE_COUNT:
            if count is None:
                logger.error("Missing count parameter for ENABLE_COUNT breakpoint modification")
                return False
            elif count < 1:
                logger.error(f"Count parameter can't be less than 1 for ENABLE_COUNT breakpoint modification")
                return False
            send_command(f"enable count {count} {breakpoint}")
        elif modify_what == typedefs.BREAKPOINT_MODIFY.ENABLE_DELETE:
            send_command(f"enable delete {breakpoint}")
        else:
            logger.error("Parameter modify_what is not valid")
            return False
    return True


def delete_breakpoint(breakpoint_number: int) -> bool:
    """Deletes a breakpoint by given number

    Args:
        breakpoint_number (int)

    Returns:
        bool: True if the breakpoint has been deleted successfully, False otherwise
    """
    deletion_list = [breakpoint_number]
    global chained_breakpoints
    for n, item in enumerate(chained_breakpoints):
        for breakpoint in item:
            if breakpoint == breakpoint_number:
                deletion_list = item
                del chained_breakpoints[n]
                break
    for breakpoint in deletion_list:
        global breakpoint_on_hit_dict
        try:
            del breakpoint_on_hit_dict[str(breakpoint)]
        except KeyError:
            pass
        send_command(f"delete {breakpoint}")
    return True


@execute_with_temporary_interruption
def track_watchpoint(expression, length, watchpoint_type):
    """Starts tracking a value by setting a watchpoint at the address holding it
    Use get_track_watchpoint_info() to get info about the watchpoint you set

    Args:
        expression (str): Any gdb expression
        length (int): Length of the watchpoint
        watchpoint_type (int): Can be a member of typedefs.WATCHPOINT_TYPE

    Returns:
        list: Numbers of the successfully set breakpoints as strings
        None: If fails to set any watchpoint
    """
    breakpoints = add_watchpoint(expression, length, watchpoint_type, typedefs.BREAKPOINT_ON_HIT.FIND_CODE)
    if not breakpoints:
        return
    for breakpoint in breakpoints:
        send_command(
            "commands " + breakpoint + "\npince-get-track-watchpoint-info " + str(breakpoints) + "\nc&" + "\nend"
        )
    return breakpoints


def get_track_watchpoint_info(watchpoint_list):
    """Gathers the information for the tracked watchpoint(s)

    Args:
        watchpoint_list (list): A list that holds the watchpoint numbers, must be returned from track_watchpoint()

    Returns:
        dict: Holds the program counter addresses at the moment watchpoint hits as keys
        Format of dict--> {address1:info_list1, address2:info_list2, ...}
        Format of info_list--> [count, previous_pc_address, register_info, float_info, disas_info]
        count-->(int) Count of the hits for the same pc address
        previous_pc_address-->(str) The address of the instruction that comes before the instruction pc address
        holds. If there's no previous address available(end of region etc.), previous_pc_address=pc_address
        register_info-->(dict) Same dict returned from read_registers()
        float_info-->(dict) Same dict returned from read_float_registers()
        disas_info-->(str) A small section that's disassembled just after previous_pc_counter
    """
    track_watchpoint_file = utils.get_track_watchpoint_file(currentpid, watchpoint_list)
    try:
        output = pickle.load(open(track_watchpoint_file, "rb"))
    except:
        output = ""
    return output


@execute_with_temporary_interruption
def track_breakpoint(expression, register_expressions) -> int | None:
    """Starts tracking a value by setting a breakpoint at the address holding it
    Use get_track_breakpoint_info() to get info about the breakpoint you set

    Args:
        expression (str): Any gdb expression
        register_expressions (str): Register expressions, separated by a comma. Registers should start with "$"
        PINCE will gather info about values presented by register expressions every time the breakpoint is reached
        For instance, passing "$rax,$rcx+5,$rbp+$r12" will make PINCE track values rax, rcx+5 and rbp+r12

    Returns:
        int: Number of the breakpoint set
        None: If fails to set any breakpoint
    """
    breakpoint = add_breakpoint(expression, on_hit=typedefs.BREAKPOINT_ON_HIT.FIND_ADDR)
    if not breakpoint:
        return
    # TODO (lldb): When we switch to LLDB, remove c& and only continue if there isn't an active trace
    # Apply the same for track_watchpoint
    send_command(f"commands {breakpoint}\npince-get-track-breakpoint-info {register_expressions.replace(' ', '')},{breakpoint}\nc&\nend")
    return breakpoint


def get_track_breakpoint_info(breakpoint_number: int):
    """Gathers the information for the tracked breakpoint

    Args:
        breakpoint_number (int): breakpoint number, must be returned from track_breakpoint()

    Returns:
        dict: Holds the register expressions as keys and their info as values
        Format of dict--> {expression1:expression_info_dict1, expression2:expression_info_dict2, ...}
        expression-->(str) The register expression
        Format of expression_info_dict--> {value1:count1, value2:count2, ...}
        value-->(str) Value calculated by given register expression as hex str
        count-->(int) How many times this expression has been reached
    """
    track_breakpoint_file = utils.get_track_breakpoint_file(currentpid, breakpoint_number)
    try:
        output = pickle.load(open(track_breakpoint_file, "rb"))
    except:
        output = ""
    return output


class Tracer:
    def __init__(self) -> None:
        """Use set_breakpoint after init and if it succeeds, use tracer_loop within a thread
        There can be only one trace session at a time. Don't create new trace sessions before finishing the last one"""
        self.bp_num = -1
        self.max_trace_count = 1000
        self.stop_condition = ""
        self.step_mode = typedefs.STEP_MODE.SINGLE_STEP
        self.stop_after_trace = False
        self.collect_registers = True
        self.trace_status = typedefs.TRACE_STATUS.IDLE
        self.current_trace_count = 0
        self.trace_data = ([], None)
        self.cancel = False
        utils.change_trace_status(currentpid, self.trace_status)

    @execute_with_temporary_interruption
    def set_breakpoint(
        self,
        expression: str,
        max_trace_count: int = 1000,
        trigger_condition: str = "",
        stop_condition: str = "",
        step_mode: typedefs.STEP_MODE = typedefs.STEP_MODE.SINGLE_STEP,
        stop_after_trace: bool = False,
        collect_registers: bool = True,
    ) -> int | None:
        """Sets the breakpoint for tracing instructions at the address evaluated by the given expression

        Args:
            expression (str): Any gdb expression
            max_trace_count (int): Maximum number of steps taken while tracing. Must be greater than or equal to 1
            trigger_condition (str): Optional, any gdb expression. Tracing will start if the condition is met
            stop_condition (str): Optional, any gdb expression. Tracing will stop whenever the condition is met
            step_mode (int): Can be a member of typedefs.STEP_MODE
            stop_after_trace (bool): Inferior won't be continuing after the tracing process
            collect_registers (bool): Collect registers while stepping

        Returns:
            int: Number of the breakpoint set
            None: If fails to set any breakpoint or if max_trace_count is not valid
        """
        if max_trace_count < 1:
            logger.error("max_trace_count must be greater than or equal to 1")
            return
        if type(max_trace_count) != int:
            logger.error(f"max_trace_count must be an integer. Was given type '{type(max_trace_count)}'")
            return
        breakpoint = add_breakpoint(expression, on_hit=typedefs.BREAKPOINT_ON_HIT.TRACE)
        if not breakpoint:
            return
        modify_breakpoint(breakpoint, typedefs.BREAKPOINT_MODIFY.CONDITION, condition=trigger_condition)
        (
            self.bp_num,
            self.max_trace_count,
            self.stop_condition,
            self.step_mode,
            self.stop_after_trace,
            self.collect_registers,
        ) = (breakpoint, max_trace_count, stop_condition, step_mode, stop_after_trace, collect_registers)
        send_command(f"commands {breakpoint}\npince-trace-instructions\nend")
        return breakpoint

    def tracer_loop(self):
        """The main tracer loop, call within a thread"""
        self.current_trace_count = 0
        trace_status_file = utils.get_trace_status_file(currentpid)
        while not (self.trace_status != typedefs.TRACE_STATUS.IDLE or self.cancel or currentpid == -1):
            try:
                with open(trace_status_file, "r") as trace_file:
                    self.trace_status = int(trace_file.read())
            except (ValueError, FileNotFoundError):
                pass
            sleep(0.1)
        global active_trace
        active_trace = True
        delete_breakpoint(self.bp_num)
        self.trace_status = typedefs.TRACE_STATUS.TRACING

        # The reason we don't use a tree class is to make the tree json-compatible
        # tree format-->[node1, node2, node3, ...]
        # node-->[(line_info, register_dict), parent_index, child_index_list]
        tree = []
        current_index = 0  # Avoid calling len()
        current_root_index = 0
        root_index = 0

        # Root always be an empty node, it's up to you to use or delete it
        tree.append([("", None), None, []])
        try:  # In case process exits during the trace session
            for x in range(self.max_trace_count):
                if self.cancel or currentpid == -1:
                    break
                line_info = send_command("x/i $pc", cli_output=True).splitlines()[0].split(maxsplit=1)[1]
                collect_dict = OrderedDict()
                if self.collect_registers:
                    collect_dict.update(read_registers())
                    collect_dict.update(read_float_registers())
                current_index += 1
                tree.append([(line_info, collect_dict), current_root_index, []])
                tree[current_root_index][2].append(current_index)  # Add a child
                self.current_trace_count = x + 1
                if regexes.trace_instructions_ret.search(line_info):
                    if tree[current_root_index][1] is None:  # If no parents exist
                        current_index += 1
                        tree.append([("", None), None, [current_root_index]])
                        tree[current_root_index][1] = current_index  # Set new parent
                        current_root_index = current_index  # current_node=current_node.parent
                        root_index = current_root_index  # set new root
                    else:
                        current_root_index = tree[current_root_index][1]  # current_node=current_node.parent
                elif self.step_mode == typedefs.STEP_MODE.SINGLE_STEP:
                    if regexes.trace_instructions_call.search(line_info):
                        current_root_index = current_index
                if self.stop_condition:
                    try:
                        if str(parse_and_eval(self.stop_condition)) == "1":
                            break
                    except:
                        pass
                if self.step_mode == typedefs.STEP_MODE.SINGLE_STEP:
                    step_instruction()
                elif self.step_mode == typedefs.STEP_MODE.STEP_OVER:
                    step_over_instruction()
                wait_for_stop()
        except:
            traceback.print_exc()
        self.trace_data = (tree, root_index)
        self.trace_status = typedefs.TRACE_STATUS.FINISHED
        active_trace = False
        if not self.stop_after_trace:
            continue_inferior()

    def cancel_trace(self):
        """Prematurely ends the trace session, trace data will still be collected"""
        self.cancel = True


def call_function_from_inferior(expression):
    """Calls the given function expression from the inferior

    Args:
        expression (str): Any gdb expression

    Returns:
        tuple: A tuple containing assigned value and result, both as str
        Returns a tuple of (False, False) if the call fails

    Examples:
        call_function_from_inferior("printf('123')") returns ("$26","3")
    """
    result = execute_func_temporary_interruption(send_command, f"call (void*(*)(char*, int)) {expression}")
    filtered_result = regexes.convenience_variable.search(result)
    if filtered_result:
        return filtered_result.group(1), filtered_result.group(2)
    return False, False


def find_entry_point():
    """Finds entry point of the inferior

    Returns:
        str: Entry point as hex str
        None: If fails to find an entry point
    """
    result = send_command("info file")
    filtered_result = regexes.entry_point.search(result)
    if filtered_result:
        return filtered_result.group(1)


def search_opcode(searched_str, starting_address, ending_address_or_offset, case_sensitive=False, enable_regex=False):
    """Searches for the given str in the disassembled output

    Args:
        searched_str (str): String that will be searched
        starting_address (str): Any gdb expression
        ending_address_or_offset (str): If you pass this parameter as an offset, you should add "+" in front of it
        (e.g "+42" or "+0x42"). If you pass this parameter as an hex address, the address range between the expression
        and the secondary address is disassembled.
        If the second parameter is an address. it always should be bigger than the first address.
        case_sensitive (bool): If True, search will be case sensitive
        enable_regex (bool): If True, searched_str will be treated as a regex expression

    Returns:
        list: A list of str values in this format-->[[address1,opcodes1],[address2, ...], ...]
        None: If enable_regex is True and given regex isn't valid
    """
    if enable_regex:
        try:
            if case_sensitive:
                regex = re.compile(searched_str)
            else:
                regex = re.compile(searched_str, re.IGNORECASE)
        except Exception:
            logger.exception(f"An exception occurred while trying to compile the given regex '{searched_str}'")
            return
    returned_list = []
    disas_output = disassemble(starting_address, ending_address_or_offset)
    for item in disas_output:
        address = item[0]
        opcode = item[2]
        if enable_regex:
            if not regex.search(opcode):
                continue
        else:
            if case_sensitive:
                if opcode.find(searched_str) == -1:
                    continue
            else:
                if opcode.lower().find(searched_str.lower()) == -1:
                    continue
        returned_list.append([address, opcode])
    return returned_list


def dissect_code(region_list, discard_invalid_strings=True):
    """Searches given regions for jumps, calls and string references
    Use function get_dissect_code_data() to gather the results

    Args:
        region_list (list): A list of (start_address, end_address) -> (str, str)
        Can be returned from functions like utils.filter_regions
        discard_invalid_strings (bool): Entries that can't be decoded as utf-8 won't be included in referenced strings
    """
    send_command("pince-dissect-code", send_with_file=True, file_contents_send=(region_list, discard_invalid_strings))


def get_dissect_code_status():
    """Returns the current state of dissect code process

    Returns:
        tuple:(current_region, current_region_count, referenced_strings_count,
                               referenced_jumps_count, referenced_calls_count)

        current_region-->(str) Currently scanned memory region
        current_region_count-->(str) "Region x of y"
        current_range-->(str) Currently scanned memory range(current buffer)
        referenced_strings_count-->(int) Count of referenced strings
        referenced_jumps_count-->(int) Count of referenced jumps
        referenced_calls_count-->(int) Count of referenced calls

        Returns a tuple of ("", "", "", 0, 0, 0) if fails to gather info
    """
    dissect_code_status_file = utils.get_dissect_code_status_file(currentpid)
    try:
        output = pickle.load(open(dissect_code_status_file, "rb"))
    except:
        output = "", "", "", 0, 0, 0
    return output


def cancel_dissect_code():
    """Finishes the current dissect code process early on"""
    if last_gdb_command.find("pince-dissect-code") != -1:
        cancel_ongoing_command()


def get_dissect_code_data(referenced_strings=True, referenced_jumps=True, referenced_calls=True):
    """Returns shelve.DbfilenameShelf objects of referenced dicts

    Args:
        referenced_strings (bool): If True, include referenced strings in the returned list
        referenced_jumps (bool): If True, include referenced jumps in the returned list
        referenced_calls (bool): If True, include referenced calls in the returned list

    Returns:
        list: A list of shelve.DbfilenameShelf objects. Can be used as dicts, they are backwards compatible

        For instance, if you call this function with default params, you'll get this--▼
        [referenced_strings_dict,referenced_jumps_dict,referenced_calls_dict]

        And if you, let's say, pass referenced_jumps as False, you'll get this instead--▼
        [referenced_strings_dict,referenced_calls_dict]

        referenced_strings_dict-->(shelve.DbfilenameShelf object) Holds referenced string addresses
        Format: {referenced_address1:referrer_address_set1, referenced_address2:referrer_address_set2, ...}

        referenced_jumps_dict-->(shelve.DbfilenameShelf object) Holds referenced jump addresses
        Format: {referenced_address1:referenced_by_dict1, referenced_address2:referenced_by_dict2, ...}
        Format of referenced_by_dict: {address1:opcode1, address2:opcode2, ...}

        referenced_calls_dict-->(shelve.DbfilenameShelf object) Holds referenced call addresses
        Format: {referenced_address1:referrer_address_set1, referenced_address2:referrer_address_set2, ...}
    """
    dict_list = []
    if referenced_strings:
        dict_list.append(shelve.open(utils.get_referenced_strings_file(currentpid), "r"))
    if referenced_jumps:
        dict_list.append(shelve.open(utils.get_referenced_jumps_file(currentpid), "r"))
    if referenced_calls:
        dict_list.append(shelve.open(utils.get_referenced_calls_file(currentpid), "r"))
    return dict_list


def search_referenced_strings(
    searched_str, value_index=typedefs.VALUE_INDEX.STRING_UTF8, case_sensitive=False, enable_regex=False
):
    """Searches for given str in the referenced strings

    Args:
        searched_str (str): String that will be searched
        value_index (int): Can be a member of typedefs.VALUE_INDEX
        case_sensitive (bool): If True, search will be case sensitive
        enable_regex (bool): If True, searched_str will be treated as a regex expression

    Returns:
        list: [[referenced_address1, reference_count1, found_value1], ...]
        None: If enable_regex is True and searched_str isn't a valid regex expression
    """
    if enable_regex:
        try:
            if case_sensitive:
                regex = re.compile(searched_str)
            else:
                regex = re.compile(searched_str, re.IGNORECASE)
        except Exception:
            logger.exception(f"An exception occurred while trying to compile the given regex '{searched_str}'")
            return
    str_dict = get_dissect_code_data(True, False, False)[0]
    mem_handle = memory_handle()
    returned_list = []
    for address, refs in str_dict.items():
        value = read_memory(int(address, 16), value_index, 100, mem_handle=mem_handle)
        value_str = "" if value is None else str(value)
        if not value_str:
            continue
        if enable_regex:
            if not regex.search(value_str):
                continue
        else:
            if case_sensitive:
                if value_str.find(searched_str) == -1:
                    continue
            else:
                if value_str.lower().find(searched_str.lower()) == -1:
                    continue
        returned_list.append((address, len(refs), value))
    str_dict.close()
    mem_handle.close()
    return returned_list


def search_referenced_calls(searched_str, case_sensitive=True, enable_regex=False):
    """Searches for given str in the referenced calls

    Args:
        searched_str (str): String that will be searched
        case_sensitive (bool): If True, search will be case sensitive
        enable_regex (bool): If True, searched_str will be treated as a regex expression

    Returns:
        list: [[referenced_address1, found_string1], ...]
        None: If enable_regex is True and searched_str isn't a valid regex expression
    """
    param_str = (searched_str, case_sensitive, enable_regex)
    return send_command("pince-search-referenced-calls " + str(param_str), recv_with_file=True)


def complete_command(gdb_command):
    """Tries to complete the given gdb command and returns completion possibilities

    Args:
        gdb_command (str): The gdb command that'll be completed

    Returns:
        list: Possible completions as a list of str
    """
    returned_list = []
    for item in send_command("complete " + gdb_command, cli_output=True).splitlines():
        if not regexes.max_completions_reached.search(item):
            returned_list.append(item)
    return returned_list

```

`libpince/gdb_python_scripts/gdbextensions.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import gdb, pickle, sys, re, struct, ctypes, os, shelve, importlib
from capstone import Cs, CsError, CS_ARCH_X86, CS_MODE_32, CS_MODE_64
from collections import OrderedDict

# This is some retarded hack
gdbvalue = gdb.parse_and_eval("$PINCE_PATH")
PINCE_PATH = gdbvalue.string()
sys.path.append(PINCE_PATH)  # Adds the PINCE directory to PYTHONPATH to import libraries from PINCE

from libpince.gdb_python_scripts import gdbutils
from libpince import utils, typedefs, regexes
from libpince.utils import logger

importlib.reload(gdbutils)
pid = gdbutils.pid
recv_file = utils.get_from_pince_file(pid)
send_file = utils.get_to_pince_file(pid)
lib = None

# Format of info_list: [count, previous_pc_address, register_info, float_info, disas_info]
# Format of watchpoint_dict: {address1:info_list1, address2:info_list2, ...}
# Format of watchpoint_numbers: str([1,2,3,4,..])
# Format: {watchpoint_numbers1:watchpoint_dict1, watchpoint_numbers2:track_watchpoint_dict2, ...}
track_watchpoint_dict = {}

# Format of expression_info_dict: {value1:count1, value2:count2, ...}
# Format of register_expression_dict: {expression1:expression_info_dict1, expression2:expression_info_dict2, ...}
# Format: {breakpoint_number1:register_expression_dict1, breakpoint_number2:register_expression_dict2, ...}
track_breakpoint_dict = {}


def receive_from_pince():
    return pickle.load(open(recv_file, "rb"))


def send_to_pince(contents_send):
    pickle.dump(contents_send, open(send_file, "wb"))


gdbutils.gdbinit()


class IgnoreErrors(gdb.Command):
    def __init__(self):
        super(IgnoreErrors, self).__init__("ignore-errors", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        try:
            gdb.execute(arg, from_tty)
        except:
            pass


class CLIOutput(gdb.Command):
    def __init__(self):
        super(CLIOutput, self).__init__("cli-output", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        try:
            contents_send = gdb.execute(arg, from_tty, to_string=True)
        except Exception as e:
            contents_send = str(e)
        logger.debug(contents_send)
        send_to_pince(contents_send)


class HandleSignals(gdb.Command):
    def __init__(self):
        super().__init__("pince-handle-signals", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        signal_data = receive_from_pince()
        for signal, stop, pass_to_program in signal_data:
            stop = "stop print" if stop else "nostop noprint"
            pass_to_program = "pass" if pass_to_program else "nopass"
            gdb.execute(f"handle {signal} {stop} {pass_to_program}", from_tty, to_string=True)


class ParseAndEval(gdb.Command):
    def __init__(self):
        super(ParseAndEval, self).__init__("pince-parse-and-eval", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        expression, cast = receive_from_pince()
        try:
            value = gdb.parse_and_eval(expression)
            parsed_value = cast(value)
        except Exception:
            logger.exception(f"An exception occurred while trying to parse expression '{expression}' and cast to type '{str(cast)}'")
            parsed_value = None
        send_to_pince(parsed_value)


class ReadRegisters(gdb.Command):
    def __init__(self):
        super(ReadRegisters, self).__init__("pince-read-registers", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        registers = gdbutils.get_general_registers()
        for key, value in registers.items():
            registers[key] = utils.upper_hex(value)
        registers.update(gdbutils.get_flag_registers())
        registers.update(gdbutils.get_segment_registers())
        send_to_pince(registers)


class ReadFloatRegisters(gdb.Command):
    def __init__(self):
        super(ReadFloatRegisters, self).__init__("pince-read-float-registers", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        send_to_pince(gdbutils.get_float_registers())


class GetStackTraceInfo(gdb.Command):
    def __init__(self):
        super(GetStackTraceInfo, self).__init__("pince-get-stack-trace-info", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        stacktrace_info_list = []
        if gdbutils.current_arch == typedefs.INFERIOR_ARCH.ARCH_64:
            sp_register = "rsp"
        else:
            sp_register = "esp"
        stack_pointer = gdbutils.examine_expression(f"${sp_register}").address
        if not stack_pointer:
            logger.error(f"Cannot get the value of ${sp_register}")
            send_to_pince(stacktrace_info_list)
            return
        stack_pointer = int(stack_pointer, 16)
        result = gdb.execute("bt", from_tty, to_string=True)
        max_frame = regexes.max_frame_count.findall(result)[-1]

        # +1 because frame numbers start from 0
        for item in range(int(max_frame) + 1):
            try:
                result = gdb.execute(f"info frame {item}", from_tty, to_string=True)
            except:
                break
            frame_address = regexes.frame_address.search(result).group(1)
            difference = hex(int(frame_address, 16) - stack_pointer)
            frame_address_with_difference = frame_address + "(" + sp_register + "+" + difference + ")"
            return_address = regexes.return_address.search(result)
            if return_address:
                return_address_with_info = gdbutils.examine_expression(return_address.group(1)).all
            else:
                return_address_with_info = "<>"
            stacktrace_info_list.append([return_address_with_info, frame_address_with_difference])
        send_to_pince(stacktrace_info_list)


class GetStackInfo(gdb.Command):
    def __init__(self):
        super(GetStackInfo, self).__init__("pince-get-stack-info", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        stack_info_list = []
        if gdbutils.current_arch == typedefs.INFERIOR_ARCH.ARCH_64:
            chunk_size = 8
            int_format = "Q"

            if arg == "from-base-pointer":
                stack_register = "rbp"
            else:
                stack_register = "rsp"
        else:
            chunk_size = 4
            int_format = "I"

            if arg == "from-base-pointer":
                stack_register = "ebp"
            else:
                stack_register = "esp"

        sp_address = gdbutils.examine_expression(f"${stack_register}").address
        if not sp_address:
            logger.error(f"Cannot get the value of ${stack_register}")
            send_to_pince(stack_info_list)
            return
        sp_address = int(sp_address, 16)
        with open(gdbutils.mem_file, "rb") as FILE:
            try:
                old_position = FILE.seek(sp_address)
            except (OSError, ValueError):
                logger.exception(f"Cannot accesss the memory at {hex(sp_address)}")
                send_to_pince(stack_info_list)
                return
            for index in range(int(4096 / chunk_size)):
                current_offset = chunk_size * index
                stack_indicator = (
                    hex(sp_address + current_offset) + "(" + stack_register + "+" + hex(current_offset) + ")"
                )
                try:
                    FILE.seek(old_position)
                    read = FILE.read(chunk_size)
                except (OSError, ValueError):
                    logger.exception(f"Can't access the stack after address {stack_indicator}")
                    break
                old_position = FILE.tell()
                int_addr = struct.unpack_from(int_format, read)[0]
                hex_repr = hex(int_addr)
                try:
                    FILE.seek(int_addr)
                    read_pointer = FILE.read(20)
                except (OSError, ValueError):
                    pointer_data = ""
                else:
                    symbol = gdbutils.examine_expression(hex_repr).symbol
                    if not symbol:
                        pointer_data = "(str)" + read_pointer.decode("utf-8", "ignore")
                    else:
                        pointer_data = "(ptr)" + symbol
                stack_info_list.append([stack_indicator, hex_repr, pointer_data])
        send_to_pince(stack_info_list)


class GetFrameReturnAddresses(gdb.Command):
    def __init__(self):
        super(GetFrameReturnAddresses, self).__init__("pince-get-frame-return-addresses", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        return_address_list = []
        result = gdb.execute("bt", from_tty, to_string=True)
        max_frame = regexes.max_frame_count.findall(result)[-1]

        # +1 because frame numbers start from 0
        for item in range(int(max_frame) + 1):
            try:
                result = gdb.execute(f"info frame {item}", from_tty, to_string=True)
            except:
                break
            return_address = regexes.return_address.search(result)
            if return_address:
                return_address_with_info = gdbutils.examine_expression(return_address.group(1)).all
            else:
                return_address_with_info = "<>"
            return_address_list.append(return_address_with_info)
        send_to_pince(return_address_list)


class GetFrameInfo(gdb.Command):
    def __init__(self):
        super(GetFrameInfo, self).__init__("pince-get-frame-info", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        frame_number = receive_from_pince()
        result = gdb.execute("bt", from_tty, to_string=True)
        max_frame = regexes.max_frame_count.findall(result)[-1]
        if 0 <= int(frame_number) <= int(max_frame):
            frame_info = gdb.execute("info frame " + frame_number, from_tty, to_string=True)
        else:
            logger.error(f"Frame {frame_number} doesn't exist")
            frame_info = None
        send_to_pince(frame_info)


class GetTrackWatchpointInfo(gdb.Command):
    def __init__(self):
        super(GetTrackWatchpointInfo, self).__init__("pince-get-track-watchpoint-info", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        breakpoints = arg
        current_pc = str(gdb.parse_and_eval("$pc"))
        current_pc_addr = utils.extract_hex_address(current_pc)
        # Sometimes GDB will return a decimal address str instead of a hex str
        if current_pc_addr is None:
            result = regexes.decimal_number.search(current_pc)
            if result:
                current_pc_addr = result.group(0)
            else:
                logger.error("Failed to grab address from $pc")
                return
        current_pc_int = int(current_pc_addr, 0)
        try:
            disas_output = gdb.execute("disas $pc-30,$pc", to_string=True)

            # Just before the line "End of assembler dump"
            last_instruction = disas_output.splitlines()[-2]
            previous_pc_address = utils.extract_hex_address(last_instruction)
        except:
            previous_pc_address = hex(current_pc_int)
        global track_watchpoint_dict
        try:
            count = track_watchpoint_dict[breakpoints][current_pc_int][0] + 1
        except KeyError:
            if breakpoints not in track_watchpoint_dict:
                track_watchpoint_dict[breakpoints] = OrderedDict()
            count = 1
        register_info = gdbutils.get_general_registers()
        register_info.update(gdbutils.get_flag_registers())
        register_info.update(gdbutils.get_segment_registers())
        float_info = gdbutils.get_float_registers()
        disas_info = gdb.execute("disas " + previous_pc_address + ",+40", to_string=True).replace("=>", "  ")
        track_watchpoint_dict[breakpoints][current_pc_int] = [
            count,
            previous_pc_address,
            register_info,
            float_info,
            disas_info,
        ]
        track_watchpoint_file = utils.get_track_watchpoint_file(pid, breakpoints)
        pickle.dump(track_watchpoint_dict[breakpoints], open(track_watchpoint_file, "wb"))


class GetTrackBreakpointInfo(gdb.Command):
    def __init__(self):
        super(GetTrackBreakpointInfo, self).__init__("pince-get-track-breakpoint-info", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        arg_list = arg.split(",")
        breakpoint_number = arg_list.pop()
        register_expressions = arg_list
        global track_breakpoint_dict
        if not breakpoint_number in track_breakpoint_dict:
            track_breakpoint_dict[breakpoint_number] = OrderedDict()
        for register_expression in register_expressions:
            if not register_expression:
                continue
            if not register_expression in track_breakpoint_dict[breakpoint_number]:
                track_breakpoint_dict[breakpoint_number][register_expression] = OrderedDict()
            try:
                address = gdbutils.examine_expression(register_expression).address
            except:
                address = None
            if address:
                if address not in track_breakpoint_dict[breakpoint_number][register_expression]:
                    track_breakpoint_dict[breakpoint_number][register_expression][address] = 1
                else:
                    track_breakpoint_dict[breakpoint_number][register_expression][address] += 1
        track_breakpoint_file = utils.get_track_breakpoint_file(pid, breakpoint_number)
        pickle.dump(track_breakpoint_dict[breakpoint_number], open(track_breakpoint_file, "wb"))


class PhaseOut(gdb.Command):
    def __init__(self):
        super(PhaseOut, self).__init__("phase-out", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        gdb.execute("detach")
        gdb.execute("echo Successfully detached from the target pid: " + str(pid))


class PhaseIn(gdb.Command):
    def __init__(self):
        super(PhaseIn, self).__init__("phase-in", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        gdb.execute("attach " + str(pid))
        gdb.execute("echo Successfully attached back to the target pid: " + str(pid))


class TraceInstructions(gdb.Command):
    def __init__(self):
        super(TraceInstructions, self).__init__("pince-trace-instructions", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        utils.change_trace_status(pid, typedefs.TRACE_STATUS.TRACING)


class DissectCode(gdb.Command):
    def __init__(self):
        super(DissectCode, self).__init__("pince-dissect-code", gdb.COMMAND_USER)

    def is_memory_valid(self, int_address, discard_invalid_strings=False):
        try:
            self.memory.seek(int_address)
        except (OSError, ValueError):
            return False  # vsyscall is ignored if vDSO is present, so we can safely ignore vsyscall
        try:
            if discard_invalid_strings:
                data_read = self.memory.read(32)
                if data_read.startswith(b"\0"):
                    return False
                data_read = data_read.split(b"\0", maxsplit=1)[0]
                data_read.decode("utf-8")
            else:
                self.memory.read(1)
        except:
            return False
        return True

    def invoke(self, arg, from_tty):
        if gdbutils.current_arch == typedefs.INFERIOR_ARCH.ARCH_64:
            disassembler = Cs(CS_ARCH_X86, CS_MODE_64)
        else:
            disassembler = Cs(CS_ARCH_X86, CS_MODE_32)
        disassembler.skipdata = True
        referenced_strings_dict = shelve.open(utils.get_referenced_strings_file(pid), writeback=True)
        referenced_jumps_dict = shelve.open(utils.get_referenced_jumps_file(pid), writeback=True)
        referenced_calls_dict = shelve.open(utils.get_referenced_calls_file(pid), writeback=True)
        region_list, discard_invalid_strings = receive_from_pince()
        dissect_code_status_file = utils.get_dissect_code_status_file(pid)
        region_count = len(region_list)
        self.memory = open(gdbutils.mem_file, "rb")
        ref_str_count = len(referenced_strings_dict)
        ref_jmp_count = len(referenced_jumps_dict)
        ref_call_count = len(referenced_calls_dict)
        for region_index, (start_addr, end_addr) in enumerate(region_list):
            region_info = start_addr + "-" + end_addr, str(region_index + 1) + " / " + str(region_count)
            start_addr = int(start_addr, 16)  # Becomes address of the last disassembled instruction later on
            end_addr = int(end_addr, 16)
            status_info = region_info + (
                hex(start_addr)[2:] + "-" + hex(end_addr)[2:],
                ref_str_count,
                ref_jmp_count,
                ref_call_count,
            )
            pickle.dump(status_info, open(dissect_code_status_file, "wb"))
            try:
                self.memory.seek(start_addr)
            except (OSError, ValueError):
                break
            buffer_size = end_addr - start_addr
            code = self.memory.read(buffer_size)
            try:
                disas_data = disassembler.disasm_lite(code, start_addr)
            except CsError:
                logger.exception("An exception occurred while trying to dissect code")
                break
            for instruction_addr, _, mnemonic, operands in disas_data:
                instruction = f"{mnemonic} {operands}" if operands != "" else mnemonic
                found = regexes.dissect_code_valid_address.search(instruction)
                if not found:
                    continue
                if instruction.startswith("j") or instruction.startswith("loop"):
                    referenced_address_str = regexes.hex_number.search(found.group(0)).group(0)
                    referenced_address_int = int(referenced_address_str, 16)
                    if self.is_memory_valid(referenced_address_int):
                        instruction_only = regexes.alphanumerics.search(instruction).group(0).casefold()
                        try:
                            referenced_jumps_dict[referenced_address_str][instruction_addr] = instruction_only
                        except KeyError:
                            referenced_jumps_dict[referenced_address_str] = {}
                            referenced_jumps_dict[referenced_address_str][instruction_addr] = instruction_only
                            ref_jmp_count += 1
                elif instruction.startswith("call"):
                    referenced_address_str = regexes.hex_number.search(found.group(0)).group(0)
                    referenced_address_int = int(referenced_address_str, 16)
                    if self.is_memory_valid(referenced_address_int):
                        try:
                            referenced_calls_dict[referenced_address_str].add(instruction_addr)
                        except KeyError:
                            referenced_calls_dict[referenced_address_str] = set()
                            referenced_calls_dict[referenced_address_str].add(instruction_addr)
                            ref_call_count += 1
                else:
                    referenced_address_str = regexes.hex_number.search(found.group(0)).group(0)
                    referenced_address_int = int(referenced_address_str, 16)
                    if self.is_memory_valid(referenced_address_int, discard_invalid_strings):
                        try:
                            referenced_strings_dict[referenced_address_str].add(instruction_addr)
                        except KeyError:
                            referenced_strings_dict[referenced_address_str] = set()
                            referenced_strings_dict[referenced_address_str].add(instruction_addr)
                            ref_str_count += 1
        self.memory.close()


class SearchReferencedCalls(gdb.Command):
    def __init__(self):
        super(SearchReferencedCalls, self).__init__("pince-search-referenced-calls", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        searched_str, case_sensitive, enable_regex = eval(arg)
        if enable_regex:
            try:
                if case_sensitive:
                    regex = re.compile(searched_str)
                else:
                    regex = re.compile(searched_str, re.IGNORECASE)
            except Exception:
                logger.exception(f"An exception occurred while trying to compile the given regex '{searched_str}'")
                return
        str_dict = shelve.open(utils.get_referenced_calls_file(pid), "r")
        returned_list = []
        for index, item in enumerate(str_dict):
            symbol = gdbutils.examine_expression(item).all
            if not symbol:
                continue
            if enable_regex:
                if not regex.search(symbol):
                    continue
            else:
                if case_sensitive:
                    if symbol.find(searched_str) == -1:
                        continue
                else:
                    if symbol.lower().find(searched_str.lower()) == -1:
                        continue
            returned_list.append((symbol, len(str_dict[item])))
        str_dict.close()
        send_to_pince(returned_list)


class ExamineExpressions(gdb.Command):
    def __init__(self):
        super(ExamineExpressions, self).__init__("pince-examine-expressions", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        data_read_list = []
        contents_recv = receive_from_pince()
        # contents_recv format: [expression1, expression2, ...]

        regions = utils.get_region_dict(pid)
        for expression in contents_recv:
            result_tuple = gdbutils.examine_expression(expression, regions)
            data_read_list.append(result_tuple)
        send_to_pince(data_read_list)


class SearchFunctions(gdb.Command):
    def __init__(self):
        super(SearchFunctions, self).__init__("pince-search-functions", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        expression, case_sensitive = receive_from_pince()
        function_list = []
        if case_sensitive:
            gdb.execute("set case-sensitive on")
        else:
            gdb.execute("set case-sensitive off")
        try:
            output = gdb.execute("info functions " + expression, to_string=True)
        except Exception:
            logger.exception("An exception occurred while trying to search functions")
            output = ""
        gdb.execute("set case-sensitive auto")
        for line in output.splitlines():
            non_debugging = regexes.info_functions_non_debugging.search(line)
            if non_debugging:
                function_list.append((non_debugging.group(1), non_debugging.group(2)))
            else:
                if line.endswith(";"):  # defined
                    function_list.append((None, line[:-1]))
        send_to_pince(function_list)


IgnoreErrors()
CLIOutput()
HandleSignals()
ParseAndEval()
ReadRegisters()
ReadFloatRegisters()
GetStackTraceInfo()
GetStackInfo()
GetFrameReturnAddresses()
GetFrameInfo()
GetTrackWatchpointInfo()
GetTrackBreakpointInfo()
PhaseOut()
PhaseIn()
TraceInstructions()
DissectCode()
SearchReferencedCalls()
ExamineExpressions()
SearchFunctions()

```

`libpince/gdb_python_scripts/gdbutils.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import gdb, sys, traceback, functools
from collections import OrderedDict

# This is some retarded hack
PINCE_PATH = gdb.parse_and_eval("$PINCE_PATH").string()
GDBINIT_AA_PATH = gdb.parse_and_eval("$GDBINIT_AA_PATH").string()
sys.path.append(PINCE_PATH)  # Adds the PINCE directory to PYTHONPATH to import libraries from PINCE

from libpince import typedefs, regexes, utils

inferior = gdb.selected_inferior()
pid = -1 if inferior.pid == 0 else inferior.pid
mem_file = "/proc/" + str(pid) + "/mem"

void_ptr = gdb.lookup_type("void").pointer()

if str(gdb.parse_and_eval("$rax")) == "void":
    current_arch = typedefs.INFERIOR_ARCH.ARCH_32
else:
    current_arch = typedefs.INFERIOR_ARCH.ARCH_64


# Use this function instead of the .gdbinit file
# If you have to load a .gdbinit file, just load it in this function with command "source"
def gdbinit():
    try:
        gdb.execute("source " + GDBINIT_AA_PATH)
    except Exception:
        utils.logger.exception("An exception occurred while trying to source gdbinit")
    gdb.execute("set disassembly-flavor intel")
    gdb.execute("set case-sensitive auto")
    gdb.execute("set code-cache off")
    gdb.execute("set stack-cache off")


# A decorator for printing exception information because GDB doesn't give proper information about exceptions
# GDB also overrides sys.excepthook apparently. So this is a proper solution to the exception problem
def print_exception(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        try:
            func(*args, **kwargs)
        except Exception as e:
            traceback.print_exception(type(e), e, e.__traceback__)

    return wrapper


def get_general_registers():
    contents_send = OrderedDict()
    if current_arch == typedefs.INFERIOR_ARCH.ARCH_64:
        general_register_list = typedefs.REGISTERS.GENERAL_64
    else:
        general_register_list = typedefs.REGISTERS.GENERAL_32
    for item in general_register_list:
        contents_send[item] = examine_expression("$" + item).address
    return contents_send


def get_flag_registers():
    contents_send = OrderedDict()
    bitwise_flags = bin(int(gdb.parse_and_eval("$eflags")))[2:]
    reversed_bitwise_flags = "".join(reversed(bitwise_flags))
    (
        contents_send["cf"],
        contents_send["pf"],
        contents_send["af"],
        contents_send["zf"],
        contents_send["sf"],
        contents_send["tf"],
        contents_send["if"],
        contents_send["df"],
        contents_send["of"],
    ) = ["0"] * 9
    try:
        contents_send["cf"] = reversed_bitwise_flags[0]
        contents_send["pf"] = reversed_bitwise_flags[2]
        contents_send["af"] = reversed_bitwise_flags[4]
        contents_send["zf"] = reversed_bitwise_flags[6]
        contents_send["sf"] = reversed_bitwise_flags[7]
        contents_send["tf"] = reversed_bitwise_flags[8]
        contents_send["if"] = reversed_bitwise_flags[9]
        contents_send["df"] = reversed_bitwise_flags[10]
        contents_send["of"] = reversed_bitwise_flags[11]
    except IndexError:
        pass
    return contents_send


def get_segment_registers():
    contents_send = OrderedDict()
    for item in typedefs.REGISTERS.SEGMENT:
        contents_send[item] = examine_expression("$" + item).address
    return contents_send


def get_float_registers():
    contents_send = OrderedDict()
    for register in typedefs.REGISTERS.FLOAT.ST:
        value = gdb.parse_and_eval("$" + register)
        contents_send[register] = str(value)
    if current_arch == typedefs.INFERIOR_ARCH.ARCH_64:
        xmm_registers = typedefs.REGISTERS.FLOAT.XMM_64
    else:
        xmm_registers = typedefs.REGISTERS.FLOAT.XMM_32
    for register in xmm_registers:
        value = gdb.parse_and_eval("$" + register + ".v4_float")
        contents_send[register] = str(value)
    return contents_send


def examine_expression(expression: str, regions=None):
    try:
        value = gdb.parse_and_eval(expression).cast(void_ptr)
    except Exception:
        if regions:  # this check comes first for optimization
            offset = regexes.offset_expression.search(expression)
            if offset:
                offset = offset.group(0)
                expression = expression.split(offset[0])[0]
            else:
                offset = "+0"
            index = regexes.index.search(expression)
            if index:
                expression = expression[: index.start()]
                index = int(index.group(1))
            else:
                index = 0
            if expression in regions:
                start_address_list = regions[expression]
                if len(start_address_list) > index:
                    address = start_address_list[index]
                    try:
                        address = hex(eval(address + offset))
                    except Exception:
                        utils.logger.exception("An exception occurred while trying to extract address from region")
                        return typedefs.tuple_examine_expression(None, None, None)
                    return typedefs.tuple_examine_expression(f"{address} {expression}", address, expression)
            return typedefs.tuple_examine_expression(None, None, None)
        utils.logger.exception("An exception occurred while trying to evaluate a gdb expression")
        return typedefs.tuple_examine_expression(None, None, None)
    result = regexes.address_with_symbol.search(str(value))
    return typedefs.tuple_examine_expression(*result.groups())

```

`libpince/gdb_python_scripts/tests/Notes.txt`:

```txt
You can create a .so file from example.c by executing "gcc -shared -o example.so -fPIC example.c" in terminal
```

`libpince/gdb_python_scripts/tests/example.c`:

```c
/*
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <stdio.h>

int hello_world(int count);

int hello_world(int count)
{
  int a;
  for(a=42;a<count+42;a++){
    printf("Hello World! for %d times\n", a-41);
  }
  return a-41;
}
```

`libpince/gdbinit_venv`:

```
# Update GDB's Python paths with the `sys.path` values of the local
# Python installation, whether that is brew'ed Python, a virtualenv,
# or another system python.

# Convert GDB to interpret in Python
python
import os,subprocess,sys

# Execute a Python using the user's shell and pull out the sys.path (for site-packages)
paths = subprocess.check_output('python3 -c "import os,sys;print(os.linesep.join(sys.path).strip())"',shell=True).decode("utf-8").split()

# Replace GDB's Python's search paths with venv ones
sys.path = paths
end

```

`libpince/injection/Notes.txt`:

```txt
Compile C files with -g option for gdb to read their symbols.

For example:

"gcc -pthread -shared -g -O2 -o example.so -fPIC example.c"

```

`libpince/injection/example.c`:

```c
/*
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <stdlib.h>

void *infinite_thread(void *a);

//Injects a thread that runs forever at the background
__attribute__((constructor))
void inject_infinite_thread()
{
	int *a=1;
	pthread_t* threadinf=(pthread_t*) malloc(sizeof(pthread_t));
	pthread_create(threadinf, NULL, infinite_thread, (void*) a);
}

void *infinite_thread(void *a)
{
	while(1)
	{
		sleep(1);
	}
}
```

`libpince/regexes.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
from re import compile, VERBOSE, MULTILINE

# The comments near regular expressions shows the expected gdb output, hope it helps to the future developers

# --------------------------------------------debugcore----------------------------------------------------------------

gdb_state_observe = compile(r"^\*(stopped.+)|^\*(running)", MULTILINE)
gdb_error = compile(r"\^error")
hex_plain = compile(r"[0-9a-fA-F]+")
hex_number = compile(r"0x" + hex_plain.pattern)
hex_number_grouped = compile(r"(" + hex_number.pattern + r")")
symbol = compile(r"<(.+?)>")
address_with_symbol = compile(r"(" + hex_number_grouped.pattern + r"\s*(<.+>)?)")  # 0x7f3067f1174d <poll+45>\n
thread_info = compile(r"\*\s+\d+\s+(.*)\\n")
inferior_pid = compile(r"process\s+(\d+)")
hw_breakpoint_count = compile(r"(hw|read|acc)")
breakpoint_size = compile(r"char\[(\d+)\]")
breakpoint_created = compile(r"breakpoint-created")
breakpoint_number = compile(r"(?:number|bkptno)=\"(\d+)\"")
convenience_variable = compile(r'"(\$\d+)\s+=\s+(.*)"')  # "$26 = 3"
entry_point = compile(r"Entry\s+point:\s+" + hex_number_grouped.pattern)
# The command will always start with the word "source", check debugcore.send_command function for the cause
gdb_command_source = lambda command_file: compile(r"&\".*source\s" + command_file + r"\\n\"")  # &"command\n"
# This will only match hex patterns without 0x and ignore the ones below:
# Hex patterns with 0x such as 0x5123
# Map symbols of PINCE, such as kmines[2]
expression_with_hex = compile(r"\b0x[0-9a-fA-F]+|\w*(?:\.*\w*)+\[\d+\]|\b(?<!\.)([0-9a-fA-F]+)\b")
# 0x00007fd81d4c7400 <__printf+0>:\t48 81 ec d8 00 00 00\tsub    rsp,0xd8\n
disassemble_output = compile(
    r"""
    ([0-9a-fA-F]+.*)\\t                     # Address with symbol
    (.*?[0-9a-fA-F]{2})\s*\\t               # Bytes, ignore padding
    (.+)\\n                                 # Opcode
""",
    VERBOSE,
)
info_functions_non_debugging = compile(hex_number_grouped.pattern + r"\s+(.*)")
max_completions_reached = compile(r"\*\*\*\s+List\s+may\s+be\s+truncated,\s+max-completions\s+reached\.\s+\*\*\*")
elf_section = compile(r"section\s*\.(?:data|bss|text|rodata)\s")

# --------------------------------------------utils------------------------------------------------------------------

instruction_follow = compile(r"(j|call|loop).*\s+" + hex_number_grouped.pattern)
docstring_variable = compile(r"(\w+)\s*=")
docstring_function_or_variable = compile(r"def\s+(\w+)|" + docstring_variable.pattern)
whitespaces = compile(r"\s+")
ps = compile(
    r"""
    \s+(\d+)\s+                             # PID
    (\S+)\s+                                # Username
    (.*)$                                   # Process name
""",
    VERBOSE,
)
maps = compile(
    r"""
    ([0-9a-f]+)-([0-9a-f]+)\s+              # Address (start-end)
    (\S+)\s+                                # Permissions
    ([0-9a-f]+)\s+                          # Map offset
    (\S+)\s+                                # Device node
    (\d+)\s+                                # Inode
    (.*)$                                   # Pathname
""",
    VERBOSE,
)

# --------------------------------------------guiutils------------------------------------------------------------------

reference_mark = compile(r"\{\d*\}")
float_number = compile(r"-?\d+[.,]?\d*(?:[eE][-+]?\d+)?")
bytearray_input = compile(r"^(([A-Fa-f0-9?]{2} +)+)$")
decimal_number = compile(r"-?\d+")
hex_number_gui = compile(r"-?(0x)?[0-9a-fA-F]*")  # contains optional 0x prefix

# --------------------------------------------gdbextensions------------------------------------------------------

max_frame_count = compile(r"#(\d+)\s+.*")
frame_address = compile(r"frame\s+at\s+" + hex_number_grouped.pattern)  # frame at 0x7ffe1e989950
return_address = compile(r"saved.*=\s+" + hex_number_grouped.pattern)  # saved rip = 0x7f633a853fe4
trace_instructions_ret = compile(r":\s+ret")  # 0x7f71a4dc5ff8 <poll+72>:	ret
trace_instructions_call = compile(r":\s+call")  # 0x7f71a4dc5fe4 <poll+52>:	call   0x7f71a4de1100
dissect_code_valid_address = compile(r"(\s+|\[|,)" + hex_number.pattern + r"(\s+|\]|,|$)")
alphanumerics = compile(r"\w+")
file_with_extension = compile(r".+?\.\w+")
offset_expression = compile(r"[/*+\-][0-9a-fA-FxX/*+\-\[\]]+$")
index = compile(r"\[(\d+)\]$")

```

`libpince/typedefs.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

# IMPORTANT: Any constant involving only PINCE.py should be declared in PINCE.py

import collections.abc, queue, sys


class CONST_TIME:
    GDB_INPUT_SLEEP = sys.float_info.min


class PATHS:
    GDB = "/bin/gdb"  # Use utils.get_default_gdb_path()
    TMP = "/tmp/PINCE/"  # Use utils.get_tmp_path()
    IPC = "/dev/shm/PINCE_IPC/"  # Use utils.get_ipc_path()
    FROM_PINCE = "/from_PINCE"  # Use utils.get_from_pince_file()
    TO_PINCE = "/to_PINCE"  # Use utils.get_to_pince_file()


class USER_PATHS:
    # Use utils.get_user_path() to make use of these
    CONFIG = ".config/"
    ROOT = CONFIG + "PINCE/"
    GDBINIT = ROOT + "gdbinit"
    GDBINIT_AA = ROOT + "gdbinit_after_attach"
    PINCEINIT = ROOT + "pinceinit.py"
    PINCEINIT_AA = ROOT + "pinceinit_after_attach.py"

    @staticmethod
    def get_init_files():
        return (
            USER_PATHS.GDBINIT,
            USER_PATHS.GDBINIT_AA,
            USER_PATHS.PINCEINIT,
            USER_PATHS.PINCEINIT_AA,
        )


class INFERIOR_STATUS:
    RUNNING = 1
    STOPPED = 2


class INFERIOR_ARCH:
    ARCH_32 = 1
    ARCH_64 = 2


class INJECTION_METHOD:
    DLOPEN = 1
    ADVANCED = 2


class BREAKPOINT_TYPE:
    HARDWARE = 1
    SOFTWARE = 2


class WATCHPOINT_TYPE:
    WRITE_ONLY = 1
    READ_ONLY = 2
    BOTH = 3


class BREAKPOINT_ON_HIT:
    BREAK = 1
    FIND_CODE = 2
    FIND_ADDR = 3
    TRACE = 4


class BREAKPOINT_MODIFY:
    CONDITION = 1
    ENABLE = 2
    DISABLE = 3
    ENABLE_ONCE = 4
    ENABLE_COUNT = 5
    ENABLE_DELETE = 6


class STEP_MODE:
    SINGLE_STEP = 1
    STEP_OVER = 2


class TRACE_STATUS:
    IDLE = 1
    TRACING = 2
    CANCELED = 3
    FINISHED = 4


class STOP_REASON:
    PAUSE = 1
    DEBUG = 2


class ATTACH_RESULT:
    ATTACH_SELF = 1
    SUCCESSFUL = 2
    PROCESS_NOT_VALID = 3
    ALREADY_DEBUGGING = 4
    ALREADY_TRACED = 5
    PERM_DENIED = 6


class TOGGLE_ATTACH:
    ATTACHED = 1
    DETACHED = 2


class REGISTERS:
    GENERAL_32 = ["eax", "ebx", "ecx", "edx", "esi", "edi", "ebp", "esp", "eip"]
    GENERAL_64 = [
        "rax",
        "rbx",
        "rcx",
        "rdx",
        "rsi",
        "rdi",
        "rbp",
        "rsp",
        "rip",
        "r8",
        "r9",
        "r10",
        "r11",
        "r12",
        "r13",
        "r14",
        "r15",
    ]
    SEGMENT = ["cs", "ss", "ds", "es", "fs", "gs"]
    FLAG = ["cf", "pf", "af", "zf", "sf", "tf", "if", "df", "of"]

    class FLOAT:
        ST = ["st" + str(i) for i in range(8)]
        XMM_32 = ["xmm" + str(i) for i in range(8)]
        XMM_64 = ["xmm" + str(i) for i in range(16)]


class FREEZE_TYPE:
    DEFAULT = 0
    ALLOW_INCREMENT = 1
    ALLOW_DECREMENT = 2


class VALUE_REPR:
    UNSIGNED = 0
    SIGNED = 1
    HEX = 2


class VALUE_INDEX:
    # Beginning of the integer indexes, new integer indexes should be added between 0 and 3
    INT8 = 0
    INT16 = 1
    INT32 = 2
    INT64 = 3
    # Ending of the integer indexes

    FLOAT32 = 4
    FLOAT64 = 5

    # Beginning of the string indexes, new string indexes should be added between 6 and 9
    STRING_ASCII = 6
    STRING_UTF8 = 7
    STRING_UTF16 = 8
    STRING_UTF32 = 9
    # Ending of the string indexes

    AOB = 10  # Array of Bytes

    @staticmethod
    def is_integer(value_index: int):
        return VALUE_INDEX.INT8 <= value_index <= VALUE_INDEX.INT64

    @staticmethod
    def is_float(value_index: int):
        return VALUE_INDEX.FLOAT32 <= value_index <= VALUE_INDEX.FLOAT64

    @staticmethod
    def is_number(value_index: int):
        return VALUE_INDEX.INT8 <= value_index <= VALUE_INDEX.FLOAT64

    @staticmethod
    def is_string(value_index: int):
        return VALUE_INDEX.STRING_ASCII <= value_index <= VALUE_INDEX.STRING_UTF32

    @staticmethod
    def has_length(value_index: int):
        return VALUE_INDEX.STRING_ASCII <= value_index <= VALUE_INDEX.AOB


class SCAN_INDEX:
    INT_ANY = 0
    INT8 = 1
    INT16 = 2
    INT32 = 3
    INT64 = 4
    FLOAT_ANY = 5
    FLOAT32 = 6
    FLOAT64 = 7
    ANY = 8
    STRING = 9
    AOB = 10  # Array of Bytes


# GDB already provides breakpoint info in english, no need to make these translatable
on_hit_to_text_dict = {
    BREAKPOINT_ON_HIT.BREAK: "Break",
    BREAKPOINT_ON_HIT.FIND_CODE: "Find Code",
    BREAKPOINT_ON_HIT.FIND_ADDR: "Find Address",
    BREAKPOINT_ON_HIT.TRACE: "Trace",
}

# Represents the texts at indexes in the address table
# TODO: This class is mostly an UI helper, maybe integrate it into the the UI completely in the future?
index_to_text_dict = collections.OrderedDict(
    [
        (VALUE_INDEX.INT8, "Int8"),
        (VALUE_INDEX.INT16, "Int16"),
        (VALUE_INDEX.INT32, "Int32"),
        (VALUE_INDEX.INT64, "Int64"),
        (VALUE_INDEX.FLOAT32, "Float32"),
        (VALUE_INDEX.FLOAT64, "Float64"),
        (VALUE_INDEX.STRING_ASCII, "String_ASCII"),
        (VALUE_INDEX.STRING_UTF8, "String_UTF8"),
        (VALUE_INDEX.STRING_UTF16, "String_UTF16"),
        (VALUE_INDEX.STRING_UTF32, "String_UTF32"),
        (VALUE_INDEX.AOB, "ByteArray"),
    ]
)

text_to_index_dict = collections.OrderedDict()
for key in index_to_text_dict:
    text_to_index_dict[index_to_text_dict[key]] = key

scanmem_result_to_index_dict = collections.OrderedDict(
    [
        ("I8", VALUE_INDEX.INT8),
        ("I8u", VALUE_INDEX.INT8),
        ("I8s", VALUE_INDEX.INT8),
        ("I16", VALUE_INDEX.INT16),
        ("I16u", VALUE_INDEX.INT16),
        ("I16s", VALUE_INDEX.INT16),
        ("I32", VALUE_INDEX.INT32),
        ("I32u", VALUE_INDEX.INT32),
        ("I32s", VALUE_INDEX.INT32),
        ("I64", VALUE_INDEX.INT64),
        ("I64u", VALUE_INDEX.INT64),
        ("I64s", VALUE_INDEX.INT64),
        ("F32", VALUE_INDEX.FLOAT32),
        ("F64", VALUE_INDEX.FLOAT64),
        ("string", VALUE_INDEX.STRING_UTF8),
        ("bytearray", VALUE_INDEX.AOB),
    ]
)

# Represents the texts at indexes in scan combobox
# TODO: Same as index_to_text_dict, consider integrating into UI completely
scan_index_to_text_dict = collections.OrderedDict(
    [
        (SCAN_INDEX.INT_ANY, "Int(any)"),
        (SCAN_INDEX.INT8, "Int8"),
        (SCAN_INDEX.INT16, "Int16"),
        (SCAN_INDEX.INT32, "Int32"),
        (SCAN_INDEX.INT64, "Int64"),
        (SCAN_INDEX.FLOAT_ANY, "Float(any)"),
        (SCAN_INDEX.FLOAT32, "Float32"),
        (SCAN_INDEX.FLOAT64, "Float64"),
        (SCAN_INDEX.ANY, "Any(int, float)"),
        (SCAN_INDEX.STRING, "String"),
        (VALUE_INDEX.AOB, "ByteArray"),
    ]
)

# Used in scan_data_type option of scanmem
scan_index_to_scanmem_dict = collections.OrderedDict(
    [
        (SCAN_INDEX.INT_ANY, "int"),
        (SCAN_INDEX.INT8, "int8"),
        (SCAN_INDEX.INT16, "int16"),
        (SCAN_INDEX.INT32, "int32"),
        (SCAN_INDEX.INT64, "int64"),
        (SCAN_INDEX.FLOAT_ANY, "float"),
        (SCAN_INDEX.FLOAT32, "float32"),
        (SCAN_INDEX.FLOAT64, "float64"),
        (SCAN_INDEX.ANY, "number"),
        (SCAN_INDEX.STRING, "string"),
        (VALUE_INDEX.AOB, "bytearray"),
    ]
)


# TODO: Same as index_to_text_dict, consider integrating into UI completely
class SCAN_TYPE:
    EXACT = 0
    NOT = 1
    INCREASED = 2
    INCREASED_BY = 3
    DECREASED = 4
    DECREASED_BY = 5
    LESS = 6
    MORE = 7
    BETWEEN = 8
    CHANGED = 9
    UNCHANGED = 10
    UNKNOWN = 11

    @staticmethod
    def get_list(scan_mode, value_type):
        if scan_mode == SCAN_MODE.NEW:
            if value_type == SCAN_INDEX.STRING or value_type == SCAN_INDEX.AOB:
                list = [
                    SCAN_TYPE.EXACT,
                    SCAN_TYPE.UNKNOWN,
                ]
            else:
                list = [
                    SCAN_TYPE.EXACT,
                    SCAN_TYPE.NOT,
                    SCAN_TYPE.LESS,
                    SCAN_TYPE.MORE,
                    SCAN_TYPE.BETWEEN,
                    SCAN_TYPE.UNKNOWN,
                ]
        else:
            if value_type == SCAN_INDEX.STRING or value_type == SCAN_INDEX.AOB:
                list = [SCAN_TYPE.EXACT]
            else:
                list = [
                    SCAN_TYPE.EXACT,
                    SCAN_TYPE.NOT,
                    SCAN_TYPE.INCREASED,
                    SCAN_TYPE.INCREASED_BY,
                    SCAN_TYPE.DECREASED,
                    SCAN_TYPE.DECREASED_BY,
                    SCAN_TYPE.LESS,
                    SCAN_TYPE.MORE,
                    SCAN_TYPE.BETWEEN,
                    SCAN_TYPE.CHANGED,
                    SCAN_TYPE.UNCHANGED,
                ]

        return list


class SCAN_MODE:
    NEW = 0
    ONGOING = 1


class SCAN_SCOPE:
    BASIC = 1
    NORMAL = 2
    FULL_RW = 3
    FULL = 4


class ENDIANNESS:
    HOST = 0
    LITTLE = 1
    BIG = 2


string_index_to_encoding_dict = {
    VALUE_INDEX.STRING_UTF8: ["utf-8", "surrogateescape"],
    VALUE_INDEX.STRING_UTF16: ["utf-16", "replace"],
    VALUE_INDEX.STRING_UTF32: ["utf-32", "replace"],
    VALUE_INDEX.STRING_ASCII: ["ascii", "replace"],
}

string_index_to_multiplier_dict = {
    VALUE_INDEX.STRING_UTF8: 2,
    VALUE_INDEX.STRING_UTF16: 4,
    VALUE_INDEX.STRING_UTF32: 8,
}

# first value is the length and the second one is the type
# Check gdbutils for an exemplary usage
index_to_valuetype_dict = {
    VALUE_INDEX.INT8: [1, "B"],
    VALUE_INDEX.INT16: [2, "H"],
    VALUE_INDEX.INT32: [4, "I"],
    VALUE_INDEX.INT64: [8, "Q"],
    VALUE_INDEX.FLOAT32: [4, "f"],
    VALUE_INDEX.FLOAT64: [8, "d"],
    VALUE_INDEX.STRING_ASCII: [None, None],
    VALUE_INDEX.STRING_UTF8: [None, None],
    VALUE_INDEX.STRING_UTF16: [None, None],
    VALUE_INDEX.STRING_UTF32: [None, None],
    VALUE_INDEX.AOB: [None, None],
}

# Check gdbutils for an exemplary usage
index_to_struct_pack_dict = {
    VALUE_INDEX.INT8: "B",
    VALUE_INDEX.INT16: "H",
    VALUE_INDEX.INT32: "I",
    VALUE_INDEX.INT64: "Q",
    VALUE_INDEX.FLOAT32: "f",
    VALUE_INDEX.FLOAT64: "d",
}

# Format: {tag:tag_description}
tag_to_string = collections.OrderedDict(
    [
        ("MemoryRW", "Memory Read/Write"),
        ("ValueType", "Value Type"),
        ("Injection", "Injection"),
        ("Debug", "Debugging"),
        ("BreakWatchpoints", "Breakpoints&Watchpoints"),
        ("Threads", "Threads"),
        ("Registers", "Registers"),
        ("Stack", "Stack&StackTrace"),
        ("Assembly", "Disassemble&Assemble"),
        ("GDBExpressions", "GDB Expressions"),
        ("GDBCommunication", "GDB Communication"),
        ("Tools", "Tools"),
        ("Utilities", "Utilities"),
        ("Processes", "Processes"),
        ("GUI", "GUI"),
        ("ConditionsLocks", "Conditions&Locks"),
        ("GDBInformation", "GDB Information"),
        ("InferiorInformation", "Inferior Information"),
    ]
)

# size-->int, any other field-->str
tuple_breakpoint_info = collections.namedtuple(
    "tuple_breakpoint_info",
    "number breakpoint_type disp enabled address size on_hit hit_count enable_count condition",
)

# start, end-->int, perms-->str, file_name-->str
tuple_region_info = collections.namedtuple("tuple_region_info", "start end perms file_name region_index")

# all fields-->str/None
tuple_examine_expression = collections.namedtuple("tuple_examine_expression", "all address symbol")

# all fields-->bool
gdb_output_mode = collections.namedtuple("gdb_output_mode", "async_output command_output command_info")


class GDBInitializeException(Exception):
    def __init__(self, message="GDB not initialized"):
        super(GDBInitializeException, self).__init__(message)


class Frozen:
    def __init__(self, value, freeze_type=FREEZE_TYPE.DEFAULT):
        self.value = value
        self.freeze_type = freeze_type
        self.enabled = False


class ValueType:
    def __init__(
        self,
        value_index=VALUE_INDEX.INT32,
        length=10,
        zero_terminate=True,
        value_repr=VALUE_REPR.UNSIGNED,
        endian=ENDIANNESS.HOST,
    ):
        """
        Args:
            value_index (int): Determines the type of data. Can be a member of VALUE_INDEX
            length (int): Length of the data. Only used when the value_index is STRING or AOB
            zero_terminate (bool): If False, ",NZT" will be appended to the text representation
            Only used when value_index is STRING. Ignored otherwise. "NZT" stands for "Non-Zero Terminate"
            value_repr (int): Determines how the data is represented. Can be a member of VALUE_REPR
            endian (int): Determines the endianness. Can be a member of ENDIANNESS
        """
        self.value_index = value_index
        self.length = length
        self.zero_terminate = zero_terminate
        self.value_repr = value_repr
        self.endian = endian

    def serialize(self):
        return (
            self.value_index,
            self.length,
            self.zero_terminate,
            self.value_repr,
            self.endian,
        )

    def text(self):
        """Returns the text representation according to its members

        Returns:
            str: A str generated by given parameters

        Examples:
            value_index=VALUE_INDEX.STRING_UTF16, length=15, zero_terminate=False--▼
            returned str="String_UTF16[15],NZT"
            value_index=VALUE_INDEX.AOB, length=42-->returned str="AoB[42]"
        """
        returned_string = index_to_text_dict[self.value_index]
        if VALUE_INDEX.is_string(self.value_index):
            returned_string += f"[{self.length}]"
            if not self.zero_terminate:
                returned_string += ",NZT"
        elif self.value_index == VALUE_INDEX.AOB:
            returned_string += f"[{self.length}]"
        if VALUE_INDEX.is_integer(self.value_index):
            if self.value_repr == VALUE_REPR.SIGNED:
                returned_string += "(s)"
            elif self.value_repr == VALUE_REPR.HEX:
                returned_string += "(h)"
        if self.endian == ENDIANNESS.LITTLE:
            returned_string += "<L>"
        elif self.endian == ENDIANNESS.BIG:
            returned_string += "<B>"
        return returned_string


class PointerChainResult:
    def __init__(self):
        self.pointer_chain: list[int] = []

    def get_pointer_by_index(self, index) -> int | None:
        if index >= len(self.pointer_chain):
            return None
        return self.pointer_chain[index]

    def get_final_address(self) -> int | None:
        return self.pointer_chain[-1] if self.pointer_chain else None

    def get_final_address_as_hex(self) -> str | None:
        """
        Returns the hex representation of this pointer chain's final/destination address
        """
        return hex(self.pointer_chain[-1]) if self.pointer_chain else None


class PointerChainRequest:
    def __init__(self, base_address: str | int, offsets_list: list[int] = None):
        """
        Args:
            base_address (str, int): The base address of where this pointer chain starts from. Can be str expression or int.
            offsets_list (list): List of offsets to reach the final pointed data. Can be None for no offsets.
            Last offset in list won't be dereferenced to emulate CE behaviour.
        """
        self.base_address: str | int = base_address
        self.offsets_list: list[int] = [] if not offsets_list else offsets_list

    def serialize(self) -> tuple[str | int, list[int]]:
        return self.base_address, self.offsets_list

    def get_base_address_as_str(self) -> str:
        """
        Returns the text representation of this pointer's base address
        """
        return hex(self.base_address) if type(self.base_address) != str else self.base_address


class RegisterQueue:
    def __init__(self):
        self.queue_list = []

    def register_queue(self):
        new_queue = queue.Queue()
        self.queue_list.append(new_queue)
        return new_queue

    def broadcast_message(self, message):
        for item in self.queue_list:
            item.put(message)

    def delete_queue(self, queue_instance):
        try:
            self.queue_list.remove(queue_instance)
        except ValueError:
            pass


class KeyboardModifiersTupleDict(collections.abc.Mapping):
    def __init__(self, OrderedDict_like_list):
        new_dict = {}
        for keycomb, value in OrderedDict_like_list:
            new_dict[keycomb] = value
        self._storage = new_dict

    def __getitem__(self, keycomb):
        return self._storage[keycomb]

    def __iter__(self):
        return iter(self._storage)

    def __len__(self):
        return len(self._storage)


class AllocatedMemory:
    def __init__(self, address: int, size: int):
        self.address = address
        self.size = size
        # TODO brkzlr: Maybe expand with starting page address and old protection to restore state after deleting allocated memory

```

`libpince/utils.py`:

```py
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import os, shutil, sys, binascii, pickle, json, traceback, re, pwd, pathlib, logging
from . import typedefs, regexes
from capstone import Cs, CsError, CS_ARCH_X86, CS_MODE_32, CS_MODE_64
from keystone import Ks, KsError, KS_ARCH_X86, KS_MODE_32, KS_MODE_64
from collections import OrderedDict
from importlib.machinery import SourceFileLoader
from pygdbmi import gdbmiparser

# Capstone initialization
cs_32 = Cs(CS_ARCH_X86, CS_MODE_32)
cs_64 = Cs(CS_ARCH_X86, CS_MODE_64)

# Keystone initialization
ks_32 = Ks(KS_ARCH_X86, KS_MODE_32)
ks_64 = Ks(KS_ARCH_X86, KS_MODE_64)

# Initialize logging
logger = logging.getLogger("PINCE")
def __init_logging() -> None:
    global logger
    if len(logger.handlers) != 0:
        return
    logger.setLevel(logging.DEBUG)
    log_format = logging.Formatter("[%(levelname)s][%(funcName)s] %(message)s")
    # File logging
    file_handler = logging.FileHandler("/var/log/pince.log", mode='w')  # Maybe change this to be per-process
    file_handler.setLevel(logging.INFO)
    file_handler.setFormatter(log_format)
    # Terminal logging
    terminal_handler = logging.StreamHandler(sys.stdout)
    terminal_handler.setLevel(logging.DEBUG)
    terminal_handler.setFormatter(log_format)
    ##################
    logger.addHandler(file_handler)
    logger.addHandler(terminal_handler)
__init_logging()

def get_process_list() -> list[str, str, str]:
    """Returns a list of processes

    Returns:
        list: List of (pid, user, process_name) -> (str, str, str)
    """
    process_list = []
    for line in os.popen("ps -eo pid:11,user,comm").read().splitlines():
        info = regexes.ps.match(line)
        if info:
            process_list.append(info.groups())
    return process_list


def get_process_name(pid: int | str) -> str:
    """Returns the process name of given pid

    Args:
        pid (int, str): PID of the process

    Returns:
        str: Process name
    """
    with open(f"/proc/{pid}/comm") as f:
        return f.read().splitlines()[0]


def search_processes(name_or_pid):
    """Searches processes and returns a list of the ones that contain given process name or pid

    Args:
        name_or_pid (str): Name or PID of the process that'll be searched for

    Returns:
        list: List of (pid, user, process_name) -> (str, str, str)
    """
    processlist = []
    for pid, user, name in get_process_list():
        if name_or_pid.lower() in name.lower() or name_or_pid in pid:
            processlist.append((pid, user, name))
    return processlist


def get_regions(pid):
    """Returns memory regions of a process

    Args:
        pid (int): PID of the process

    Returns:
        list: List of (start_address, end_address, permissions, map_offset, device_node, inode, path) -> all str
    """
    with open("/proc/" + str(pid) + "/maps") as f:
        regions = []
        for line in f.read().splitlines():
            regions.append(regexes.maps.match(line).groups())
        return regions


def get_region_dict(pid: int) -> dict[str, list[str]]:
    """Returns memory regions of a process as a dictionary where key is the path tail and value is the list of the
    corresponding start addresses of the tail, empty paths will be ignored. Also adds shortcuts for file extensions,
    returned dict will include both sonames, with and without version information

    Args:
        pid (int): PID of the process

    Returns:
        dict: {file_name:start_address_list}
    """
    region_dict: dict[str, list[str]] = {}
    for item in get_regions(pid):
        start_addr, _, _, _, _, _, path = item
        if not path:
            continue
        _, tail = os.path.split(path)
        start_addr = "0x" + start_addr
        short_name = regexes.file_with_extension.search(tail)
        if short_name:
            short_name = short_name.group(0)
            if short_name == tail:
                short_name = None
        if tail in region_dict:
            region_dict[tail].append(start_addr)
            if short_name:
                region_dict[short_name].append(start_addr)
        else:
            region_dict[tail] = [start_addr]
            if short_name:
                region_dict[short_name] = [start_addr]
    return region_dict


def get_region_info(pid, address):
    """Finds the closest valid starting/ending address and region to given address, assuming given address is in the
    valid address range

    Args:
        pid (int): PID of the process
        address (int,str): Can be an int or a hex str

    Returns:
        list: List of (start_address, end_address, permissions, file_name) -> (int, int, str, str)
        None: If the given address isn't in any valid address range
    """
    if type(pid) != int:
        pid = safe_int_cast(pid)
    if type(address) != int:
        address = safe_str_to_int(address, 0)
    region_list = get_regions(pid)
    region_index = 0
    for start, end, perms, map_offset, _, _, path in region_list:
        start = safe_str_to_int(start, 16)
        end = safe_str_to_int(end, 16)
        file_name = os.path.split(path)[1]

        # get region index for the given address
        if safe_str_to_int(map_offset, 16) == 0:
            region_index = 0
        else:
            region_index += 1

        if start <= address < end:
            return typedefs.tuple_region_info(start, end, perms, file_name, region_index)


def filter_regions(pid, attribute, regex, case_sensitive=False):
    """Filters memory regions by searching for the given regex within the given attribute

    Args:
        pid (int): PID of the process
        attribute (str): The attribute that'll be filtered. Can be one of the below
        start_address, end_address, permissions, map_offset, device_node, inode, path
        regex (str): Regex statement that'll be searched
        case_sensitive (bool): If True, search will be case sensitive

    Returns:
        list: List of (start_address, end_address, permissions, map_offset, device_node, inode, path) -> all str
    """
    index = ["start_address", "end_address", "permissions", "map_offset", "device_node", "inode", "path"].index(
        attribute
    )
    if index == -1:
        raise Exception("Invalid attribute")
    if case_sensitive:
        compiled_regex = re.compile(regex)
    else:
        compiled_regex = re.compile(regex, re.IGNORECASE)
    filtered_regions = []
    for region in get_regions(pid):
        if compiled_regex.search(region[index]):
            filtered_regions.append(region)
    return filtered_regions


def is_traced(pid):
    """Check if the process corresponding to given pid traced by any other process

    Args:
        pid (int): PID of the process

    Returns:
        str: Name of the tracer if the specified process is being traced
        None: if the specified process is not being traced or the process doesn't exist anymore
    """
    try:
        status_file = open("/proc/%d/status" % pid)
    except FileNotFoundError:
        return
    for line in status_file.readlines():
        if line.startswith("TracerPid:"):
            tracer_pid = line.split(":", 1)[1].strip()
            if tracer_pid != "0":
                return get_process_name(tracer_pid)


def is_process_valid(pid):
    """Check if the process corresponding to given pid is valid

    Args:
        pid (int): PID of the process

    Returns:
        bool: True if the process is still running, False if not
    """
    return os.path.exists("/proc/%d" % pid)


def get_script_directory():
    """Get main script directory

    Returns:
        str: A string pointing to the main script directory
    """
    return sys.path[0]


def get_media_directory():
    """Get media directory

    Returns:
        str: A string pointing to the media directory
    """
    return get_script_directory() + "/media"


def get_logo_directory():
    """Get logo directory

    Returns:
        str: A string pointing to the logo directory
    """
    return get_script_directory() + "/media/logo"


def get_libpince_directory():
    """Get libpince directory

    Returns:
        str: A string pointing to the libpince directory

    Note:
        In fact this function returns the directory where utils in and considering the fact that utils resides in
        libpince, it works. So, please don't move out utils outside of libpince folder!
    """
    return os.path.dirname(os.path.realpath(__file__))


def delete_ipc_path(pid):
    """Deletes the IPC directory of given pid

    Args:
        pid (int,str): PID of the process
    """
    path = get_ipc_path(pid)
    if os.path.exists(path):
        shutil.rmtree(path)


def create_ipc_path(pid):
    """Creates the IPC directory of given pid

    Args:
        pid (int,str): PID of the process
    """
    path = get_ipc_path(pid)
    if os.path.exists(path):
        shutil.rmtree(path)
    os.makedirs(path)

    # Opening the command file with 'w' each time debugcore.send_command() gets invoked slows down the process
    # Instead, here we create the command file for only once when IPC path gets initialized
    # Then, open the command file with 'r' in debugcore.send_command() to get a better performance
    command_file = get_gdb_command_file(pid)
    open(command_file, "w").close()


def create_tmp_path(pid):
    """Creates the tmp directory of given pid

    Args:
        pid (int,str): PID of the process
    """
    path = get_tmp_path(pid)
    if os.path.exists(path):
        shutil.rmtree(path)
    os.makedirs(path)


def get_ipc_path(pid):
    """Get the IPC directory of given pid

    Args:
        pid (int): PID of the process

    Returns:
        str: Path of IPC directory
    """
    return typedefs.PATHS.IPC + str(pid)


def get_tmp_path(pid):
    """Get the tmp directory of given pid

    Args:
        pid (int): PID of the process

    Returns:
        str: Path of tmp directory
    """
    return typedefs.PATHS.TMP + str(pid)


def get_logging_file(pid):
    """Get the path of gdb logfile of given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of gdb logfile
    """
    return get_tmp_path(pid) + "/gdb_log.txt"


def get_gdb_command_file(pid):
    """Get the path of gdb command file of given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of gdb command file
    """
    return get_ipc_path(pid) + "/gdb_command.txt"


def get_track_watchpoint_file(pid, watchpoint_list):
    """Get the path of track watchpoint file for given pid and watchpoint

    Args:
        pid (int,str): PID of the process
        watchpoint_list (list,str): Numbers of the watchpoints

    Returns:
        str: Path of track watchpoint file
    """
    return get_ipc_path(pid) + "/" + str(watchpoint_list) + "_track_watchpoint.txt"


def get_track_breakpoint_file(pid, breakpoint_number):
    """Get the path of track breakpoint file for given pid and breakpoint

    Args:
        pid (int,str): PID of the process
        breakpoint_number (int)

    Returns:
        str: Path of track breakpoint file
    """
    return f"{get_ipc_path(pid)}/{breakpoint_number}_track_breakpoint.txt"


def append_file_extension(string, extension):
    """Appends the given extension to the given string if it doesn't end with the given extension

    Args:
        string (str): Self-explanatory
        extension (str): Self-explanatory, you don't have to include the dot

    Returns:
        str: Given string with the extension
    """
    extension = extension.strip(".")
    return string if string.endswith("." + extension) else string + "." + extension


def save_file(data, file_path, save_method="json"):
    """Saves the specified data to given path

    Args:
        data (??): Saved data, can be anything, must be supported by save_method
        file_path (str): Path of the saved file
        save_method (str): Can be "json" or "pickle"

    Returns:
        bool: True if saved successfully, False if not
    """
    if save_method == "json":
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            json.dump(data, open(file_path, "w"))
            return True
        except Exception:
            logger.exception("Encountered an exception while dumping the data in JSON format\n")
            return False
    elif save_method == "pickle":
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            pickle.dump(data, open(file_path, "wb"))
            return True
        except Exception:
            logger.exception("Encountered an exception while pickling the data\n")
            return False
    else:
        logger.error("Unsupported save_method, bailing out...")
        return False


def load_file(file_path, load_method="json"):
    """Loads data from the given path

    Args:
        file_path (str): Path of the saved file
        load_method (str): Can be "json" or "pickle"

    Returns:
        ??: file_path is like a box of chocolates, you never know what you're gonna get
        None: If loading fails
    """
    if load_method == "json":
        try:
            output = json.load(open(file_path, "r"), object_pairs_hook=OrderedDict)
        except Exception as e:
            logger.exception("Encountered an exception while loading the JSON data\n", e)
            return
    elif load_method == "pickle":
        try:
            output = pickle.load(open(file_path, "rb"))
        except Exception as e:
            logger.exception("Encountered an exception while unpickling the data\n", e)
            return
    else:
        logger.error("Unsupported load_method, bailing out...")
        return
    return output


def get_trace_status_file(pid):
    """Get the path of trace status file for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of trace status file
    """
    return get_ipc_path(pid) + "/_trace_status.txt"


def change_trace_status(pid: int | str, trace_status: int):
    """Change trace status for given pid

    Args:
        pid (int,str): PID of the process
        trace_status (int): New trace status, can be a member of typedefs.TRACE_STATUS
    """
    trace_status_file = get_trace_status_file(pid)
    with open(trace_status_file, "w") as trace_file:
        trace_file.write(str(trace_status))


def get_dissect_code_status_file(pid):
    """Get the path of dissect code status file for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of dissect code status file
    """
    return get_ipc_path(pid) + "/dissect_code_status.txt"


def get_referenced_strings_file(pid):
    """Get the path of referenced strings dict file for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of referenced strings dict file
    """
    return get_tmp_path(pid) + "/referenced_strings_dict.txt"


def get_referenced_jumps_file(pid):
    """Get the path of referenced jumps dict file for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of referenced jumps dict file
    """
    return get_tmp_path(pid) + "/referenced_jumps_dict.txt"


def get_referenced_calls_file(pid):
    """Get the path of referenced strings dict file for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of referenced calls dict file
    """
    return get_tmp_path(pid) + "/referenced_calls_dict.txt"


def get_from_pince_file(pid):
    """Get the path of IPC file sent to custom gdb commands from PINCE for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of IPC file
    """
    return get_ipc_path(pid) + typedefs.PATHS.FROM_PINCE


def get_to_pince_file(pid):
    """Get the path of IPC file sent to PINCE from custom gdb commands for given pid

    Args:
        pid (int,str): PID of the process

    Returns:
        str: Path of IPC file
    """
    return get_ipc_path(pid) + typedefs.PATHS.TO_PINCE


def parse_string(string: str, value_index: int):
    """Parses the string according to the given value_index

    Args:
        string (str): String that'll be parsed
        value_index (int): Determines the type of data. Can be a member of typedefs.VALUE_INDEX

    Returns:
        str: If the value_index is STRING
        list: If the value_index is AOB. A list of ints is returned
        float: If the value_index is FLOAT32 or FLOAT64
        int: If the value_index is anything else
        None: If the string is not parsable by using the parameter value_index

    Examples:
        string="42 DE AD BE EF 24",value_index=typedefs.VALUE_INDEX.AOB--▼
        returned_list=[66, 222, 173, 190, 239, 36]
    """
    if not string:
        logger.error("Missing string parameter")
        return
    try:
        value_index = int(value_index)
    except:
        logger.exception(f"Value index ({value_index}) can't be converted to int")
        return
    if typedefs.VALUE_INDEX.is_string(value_index):
        return string
    string = string.strip()
    if value_index == typedefs.VALUE_INDEX.AOB:
        try:
            string_list = regexes.whitespaces.split(string)
            for item in string_list:
                if len(item) > 2:
                    logger.error(f"{string} can't be parsed as array of bytes")
                    return
            hex_list = [int(x, 16) for x in string_list]
            return hex_list
        except:
            logger.exception(f"{string} can't be parsed as array of bytes")
            return
    elif typedefs.VALUE_INDEX.is_float(value_index):
        try:
            string = float(string)
        except:
            try:
                string = float(int(string, 0))
            except:
                logger.exception(f"{string} can't be parsed as floating point variable")
                return
        return string
    else:
        try:
            string = int(string, 0)
        except:
            try:
                string = int(float(string))
            except:
                logger.exception(f"{string} can't be parsed as integer or hexadecimal")
                return
        if value_index == typedefs.VALUE_INDEX.INT8:
            string = string % 0x100  # 256
        elif value_index == typedefs.VALUE_INDEX.INT16:
            string = string % 0x10000  # 65536
        elif value_index == typedefs.VALUE_INDEX.INT32:
            string = string % 0x100000000  # 4294967296
        elif value_index == typedefs.VALUE_INDEX.INT64:
            string = string % 0x10000000000000000  # 18446744073709551616
        return string


def instruction_follow_address(string):
    """Searches for the location changing instructions such as Jcc, CALL and LOOPcc in the given string. Returns the hex
    address the instruction jumps to

    Args:
        string (str): An assembly expression

    Returns:
        str: Hex address
        None: If no hex address is found or no location changing instructions found
    """
    result = regexes.instruction_follow.search(string)
    if result:
        return result.group(2)


def extract_hex_address(string):
    """Extracts hex address from the given string

    Args:
        string (str): The string that the hex address will be extracted from

    Returns:
        str: Hex address
        None: If no hex address is found
    """
    if type(string) != str:
        return
    result = regexes.hex_number.search(string)
    if result:
        return result.group(0)


def modulo_address(int_address, arch_type):
    """Calculates the modulo of the given integer based on the given architecture type to make sure that it doesn't
    exceed the borders of the given architecture type (0xffffffff->x86, 0xffffffffffffffff->x64)

    Args:
        int_address (int): Self-explanatory
        arch_type (int): Architecture type (x86, x64). Can be a member of typedefs.INFERIOR_ARCH

    Returns:
        int: Modulo of the given integer based on the given architecture type
    """
    if arch_type == typedefs.INFERIOR_ARCH.ARCH_32:
        return int_address % 0x100000000
    elif arch_type == typedefs.INFERIOR_ARCH.ARCH_64:
        return int_address % 0x10000000000000000
    raise Exception("arch_type must be a member of typedefs.INFERIOR_ARCH")


def disassemble(aob, address, inferior_arch):
    """Returns the instructions from the given array of bytes

    Args:
        aob (str): Bytes of the opcode as an array of bytes
        address (int): The address where the opcode starts from
        inferior_arch (int): Architecture type (x86, x64). Can be a member of typedefs.INFERIOR_ARCH

    Returns:
        str: Opcodes, multiple entries are separated with ;
        None: If there was an error
    """
    if inferior_arch == typedefs.INFERIOR_ARCH.ARCH_64:
        disassembler = cs_64
    else:
        disassembler = cs_32
    disassembler.skipdata = True
    try:
        bytecode = bytes.fromhex(aob.replace(" ", ""))
    except ValueError:
        return
    try:
        disas_data = disassembler.disasm_lite(bytecode, address)
        return "; ".join([f"{data[2]} {data[3]}" if data[3] != "" else data[2] for data in disas_data])
    except CsError:
        logger.exception("Failed to disassemble bytes")


def assemble(instructions, address, inferior_arch):
    """Assembles the given instructions

    Args:
        instructions (str): A string of instructions, multiple entries separated by ;
        address (int): Starting address of the instructions
        inferior_arch (int): Can be a member of typedefs.INFERIOR_ARCH

    Returns:
        tuple: A tuple of (list, int) --> Assembled bytes (list of int) and instruction count (int)
        None: If there was an error
    """
    try:
        if inferior_arch == typedefs.INFERIOR_ARCH.ARCH_64:
            return ks_64.asm(instructions, address)
        else:
            return ks_32.asm(instructions, address)
    except KsError:
        logger.exception("Failed to assemble bytes")


def aob_to_str(list_of_bytes, encoding="ascii", replace_unprintable=True):
    """Converts given array of hex strings to str

    Args:
        list_of_bytes (list): Must be returned from debugcore.hex_dump()
        encoding (str): See here-->https://docs.python.org/3/library/codecs.html#standard-encodings
        replace_unprintable (bool): If True, replaces non-printable characters with a period (.)

    Returns:
        str: str equivalent of array
    """

    ### make an actual list of bytes
    hexString = ""
    byteList = list_of_bytes
    if isinstance(list_of_bytes, list):
        byteList = list_of_bytes
    else:
        byteList = []
        byteList.append(list_of_bytes)
    for sByte in byteList:
        if sByte == "??":
            hexString += f"{63:02x}"  # replace ?? with a single ?
        else:
            if isinstance(sByte, int):
                byte = sByte
            else:
                byte = safe_str_to_int(sByte, 16)
            if replace_unprintable and ((byte < 32) or (byte > 126)):
                hexString += f"{46:02x}"  # replace non-printable chars with a period (.)
            else:
                hexString += f"{byte:02x}"
    hexBytes = bytes.fromhex(hexString)
    return hexBytes.decode(encoding, "surrogateescape")


def str_to_aob(string, encoding="ascii"):
    """Converts given string to aob string

    Args:
        string (str): Any string
        encoding (str): See here-->https://docs.python.org/3/library/codecs.html#standard-encodings

    Returns:
        str: AoB equivalent of the given string
    """
    s = str(binascii.hexlify(string.encode(encoding, "surrogateescape")), encoding).upper()
    return " ".join(s[i : i + 2] for i in range(0, len(s), 2))


def split_symbol(symbol_string):
    """Splits symbol part of typedefs.tuple_function_info into smaller fractions
    Fraction count depends on the the symbol_string. See Examples section for demonstration

    Args:
        symbol_string (str): symbol part of typedefs.tuple_function_info

    Returns:
        list: A list containing parts of the splitted symbol

    Examples:
        symbol_string-->"func(param)@plt"
        returned_list-->["func","func(param)","func(param)@plt"]

        symbol_string-->"malloc@plt"
        returned_list-->["malloc", "malloc@plt"]

        symbol_string-->"printf"
        returned_list-->["printf"]
    """
    returned_list = []
    p_count = 0
    # this algorithm searches for balanced parentheses and removes the outer group
    # using string reversing with recursive re.split makes the code confusing as hell, going with this one instead
    # searching for balanced parentheses works because apparently no demangled symbol can finish with <.*>
    # XXX: run this code to test while attached to a process and open a detailed issue if you get a result
    """
    from libpince import debugcore
    import re
    result=debugcore.search_functions("")
    for address, symbol in result:
        if re.search("<.*>[^()]+$", symbol):
            print(symbol)
    """
    for index, letter in enumerate(symbol_string[::-1]):
        if letter == ")":
            p_count += 1
        elif letter == "(":
            p_count -= 1
            if p_count == 0:
                returned_list.append((symbol_string[: -(index + 1)]))
                break
            assert p_count >= 0, (
                symbol_string + " contains unhealthy amount of left parentheses\nGotta give him some"
                ' right parentheses. Like Bob always says "everyone needs a friend"'
            )
    assert p_count == 0, symbol_string + " contains unbalanced parentheses"
    if "@plt" in symbol_string:
        returned_list.append(symbol_string.rsplit("@plt", maxsplit=1)[0])
    returned_list.append(symbol_string)
    return returned_list


def extract_symbol_name(symbol_string: str) -> str:
    """Extract symbol name from examine_expression result

    Args:
        symbol_string (str): A string that contains a symbol in format <symbol_name>

    Returns:
        str: Symbol name without brackets or empty string if no symbol is found
    """
    result = regexes.symbol.search(symbol_string)
    return result.group(1) if result else ""


def execute_command_as_user(command):
    """Executes given command as user

    Args:
        command (str): Command that'll be invoked from the shell
    """
    uid, gid = get_user_ids()
    os.system("sudo -Eu '#" + uid + "' " + command)


def get_module_name(module):
    """Gets the name of the given module without the package name

    Args:
        module (module): A module

    Returns:
        str: Name of the module
    """
    return module.__name__.replace(module.__package__ + ".", "", 1)


def init_user_files():
    """Initializes user files"""
    root_path = get_user_path(typedefs.USER_PATHS.ROOT)
    if not os.path.exists(root_path):
        os.makedirs(root_path)
    for file in typedefs.USER_PATHS.get_init_files():
        file = get_user_path(file)
        try:
            open(file).close()
        except FileNotFoundError:
            open(file, "w").close()


def get_user_ids():
    """Gets uid and gid of the current user

    Returns:
        tuple: (str, str)-->uid and gid of the current user
    """
    uid = os.getenv("SUDO_UID") or str(os.getuid())
    gid = os.getenv("SUDO_GID") or str(os.getgid())
    return uid, gid


def get_user_home_dir():
    """Returns the home directory of the current user

    Returns:
        str: Home directory of the current user
    """
    uid, _ = get_user_ids()
    return pwd.getpwuid(int(uid)).pw_dir


def get_user_path(user_path):
    """Returns the specified user path for the current user

    Args:
        user_path (str): Can be a member of typedefs.USER_PATHS

    Returns:
        str: Specified user path of the current user
    """
    # TODO: Use XDG specification
    homedir = get_user_home_dir()
    return os.path.join(homedir, user_path)


def get_default_gdb_path():
    appdir = os.environ.get("APPDIR")
    if appdir:
        return appdir + "/usr/bin/gdb"
    return typedefs.PATHS.GDB


def execute_script(file_path):
    """Loads and executes the script in the given path

    Args:
        file_path (str): Self-explanatory

    Returns:
        tuple: (module, exception)
        module--> Loaded script as module
        exception--> traceback as str

        Returns (None, exception) if fails to load the script
        Returns (module, None) if script gets loaded successfully
    """
    head, tail = os.path.split(file_path)
    file_name = tail.split(".", maxsplit=1)[0]
    try:
        module = SourceFileLoader(file_name, file_path).load_module()
    except Exception as e:
        logger.error(f"Encountered an exception while loading the script located at {file_path}")
        tb = traceback.format_exception(None, e, e.__traceback__)
        tb.insert(0, "------->You can ignore the importlib part if the source file is valid<-------\n")
        tb = "".join(tb)
        logger.error(tb)
        return None, tb
    return module, None


def parse_response(response, line_num=0):
    """Parses the given GDB/MI output. Wraps gdbmiparser.parse_response
    debugcore.send_command returns an additional "^done" output because of the "source" command
    This function is used to get rid of that output before parsing

    Args:
        response (str): GDB/MI response
        line_num (int): Which line of the response will be parsed

    Returns:
        dict: Contents of the dict depends on the response
    """
    return gdbmiparser.parse_response(response.splitlines()[line_num])


def search_files(directory, regex):
    """Searches the files in given directory for given regex recursively

    Args:
        directory (str): Directory to search for
        regex (str): Regex to search for

    Returns:
        list: Sorted list of the relative paths(to the given directory) of the files found
    """
    file_list = []
    for file in pathlib.Path(directory).rglob("*.*"):
        result = re.search(regex, file.name, re.IGNORECASE)
        if result:
            file_list.append(str(file.relative_to(directory)))
    return sorted(file_list)


def ignore_exceptions(func):
    """A decorator to ignore exceptions"""

    def wrapper(*args, **kwargs):
        try:
            func(*args, **kwargs)
        except:
            traceback.print_exc()

    return wrapper


def upper_hex(hex_str: str):
    """Converts the given hex string to uppercase while keeping the 'x' character lowercase"""
    # check if the given string is a hex string, if not return the string as is
    if not regexes.hex_number_gui.match(hex_str):
        return hex_str
    return hex_str.upper().replace("X", "x")


def return_optional_int(val: int) -> int | None:
    return None if val == 0 else val


# This is the main int() cast for strings that should be used until you're certain that the cast can never fail or has explicit handling.
# The reason for this is that you can catch stray errors or edge cases by safely returning a value and outputting useful log info
# instead of failing with an exception that will propagate upwards.
def safe_str_to_int(input, base: int) -> int:
    try:
        return int(input, base)
    except ValueError:
        logger.error(f"ValueError: Tried to convert input '{input}' to base {base} for caller '{sys._getframe().f_back.f_code.co_qualname}'")
        return 0
    except TypeError:
        logger.error(f"TypeError: Tried to convert input '{input}' to base {base} for caller '{sys._getframe().f_back.f_code.co_qualname}'")
        return 0


# This is the non-base version of the above.
def safe_int_cast(input) -> int:
    try:
        return int(input)
    except ValueError:
        logger.error(f"ValueError: Tried to convert input '{input}' for caller '{sys._getframe().f_back.f_code.co_qualname}'")
        return 0
    except TypeError:
        logger.error(f"TypeError: Tried to convert input '{input}' for caller '{sys._getframe().f_back.f_code.co_qualname}'")
        return 0

```

`pyproject.toml`:

```toml
[tool.black]
line-length = 120
[tool.isort]
skip_glob = ["*"]

```

`requirements.txt`:

```txt
PyQt6==6.10.2
PyQt6-Qt6==6.10.2
pexpect==4.9.0
capstone==5.0.6
keystone-engine==0.9.2
pygdbmi==0.11.0.0
keyboard==0.13.5

```

`run_tests.py`:

```py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import unittest, argparse
from libpince import debugcore, utils

desc = "Runs all unit tests by creating or attaching to a process"
ex = (
    "Example of Usage:"
    + "\n\tsudo python3 run_tests.py -a kmines"
    + '\n\tsudo python3 run_tests.py -c /usr/games/kmines -o="-v"'
)

parser = argparse.ArgumentParser(description=desc, epilog=ex, formatter_class=argparse.RawDescriptionHelpFormatter)
parser.add_argument("-a", metavar="name_or_pid", type=str, help="Attaches to the process with given name or pid")
parser.add_argument("-c", metavar="file_path", type=str, help="Creates a new process with given path")
parser.add_argument(
    "-o",
    metavar="options",
    type=str,
    default="",
    help="Arguments that'll be passed to the inferior, only can be used with -c, optional",
)
parser.add_argument(
    "-l",
    metavar="ld_preload_path",
    type=str,
    default="",
    help="Path of the preloaded .so file, only can be used with -c, optional",
)

args = parser.parse_args()
if args.a:
    process_list = utils.search_processes(args.a)
    if not process_list:
        parser.error("There's no process with the name or pid " + args.a)
    if len(process_list) > 1:
        for pid, user, name in process_list:
            print(name)
        print("There are more than one process with the name or pid " + args.a)
        exit()
    pid = process_list[0][0]
    if not debugcore.can_attach(pid):
        parser.error("Failed to attach to the process with pid " + pid)
    debugcore.attach(pid)
elif args.c:
    if not debugcore.create_process(args.c, args.o, args.l):
        parser.error("Couldn't create the process with current args")
else:
    parser.error("Provide at least one of these arguments: -a or -c")
unittest.main(module="tests.debugcore_tests", exit=False, argv=[""])
unittest.main(module="tests.utils_tests", exit=False, argv=[""])
unittest.main(module="tests.guiutils_tests", exit=False, argv=[""])
debugcore.detach()

```

`tests/debugcore_tests.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import unittest
from libpince import debugcore, typedefs, regexes


class debugcore_tests(unittest.TestCase):
    def test_read_registers(self):
        register_dict = debugcore.read_registers()
        if debugcore.inferior_arch == typedefs.INFERIOR_ARCH.ARCH_64:
            test_register = "rax"
        else:
            test_register = "eax"
        self.assertRegex(register_dict[test_register], regexes.hex_number.pattern)

```

`tests/guiutils_tests.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import unittest


# from GUI.Utils import guiutils


class guiutils_tests(unittest.TestCase):
    def test_change_text_length(self):
        self.assertEqual(True, True)
        # The function below was removed during refactorization, thus making this test just a placeholder for now
        # self.assertEqual(guiutils.change_text_length("AoB[42]", 30), "AoB[30]")

```

`tests/utils_tests.py`:

```py
"""
Copyright (C) 2016-2017 Korcan Karaokçu <korcankaraokcu@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
import unittest
from libpince import utils


class utils_tests(unittest.TestCase):
    def test_split_symbol(self):
        self.assertListEqual(utils.split_symbol("func(param)@plt"), ["func", "func(param)", "func(param)@plt"])

```

`tr/tr.py`:

```py
from PyQt6.QtCore import QObject, QLocale, QT_TR_NOOP, QT_TRANSLATE_NOOP
from collections import OrderedDict

language_list = OrderedDict([("en_US", "English"), ("it_IT", "Italiano"), ("zh_CN", "简体中文")])


def get_locale():
    system_locale = QLocale.system().name()
    return system_locale if system_locale in language_list else "en_US"


# This handles the default translations for QDialogButtonBox.StandardButton
# Some of the standard button labels have an ampersand (&). It's used to denote an access key or keyboard shortcut
# Translate the text as you wish, then put the ampersand (&) where the shortcut should be
QT_TRANSLATE_NOOP("QPlatformTheme", "OK")
QT_TRANSLATE_NOOP("QPlatformTheme", "&Open")
QT_TRANSLATE_NOOP("QPlatformTheme", "&Save")
QT_TRANSLATE_NOOP("QPlatformTheme", "Cancel")
QT_TRANSLATE_NOOP("QPlatformTheme", "Close")
QT_TRANSLATE_NOOP("QPlatformTheme", "Discard")
QT_TRANSLATE_NOOP("QPlatformTheme", "Apply")
QT_TRANSLATE_NOOP("QPlatformTheme", "Reset")
QT_TRANSLATE_NOOP("QPlatformTheme", "Restore Defaults")
QT_TRANSLATE_NOOP("QPlatformTheme", "Help")
QT_TRANSLATE_NOOP("QPlatformTheme", "Save All")
QT_TRANSLATE_NOOP("QPlatformTheme", "&Yes")
QT_TRANSLATE_NOOP("QPlatformTheme", "&No")
QT_TRANSLATE_NOOP("QPlatformTheme", "Abort")
QT_TRANSLATE_NOOP("QPlatformTheme", "Retry")
QT_TRANSLATE_NOOP("QPlatformTheme", "Ignore")
QT_TRANSLATE_NOOP("QPlatformTheme", "N&o to All")
QT_TRANSLATE_NOOP("QPlatformTheme", "Yes to &All")


class TranslationConstants(QObject):
    @staticmethod
    def translate():
        for key, value in vars(TranslationConstants).items():
            if not key.startswith("__") and isinstance(value, str):
                setattr(TranslationConstants, key, TranslationConstants.tr(value))

    PAUSE_HOTKEY = QT_TR_NOOP("Pause the process")
    BREAK_HOTKEY = QT_TR_NOOP("Break the process")
    CONTINUE_HOTKEY = QT_TR_NOOP("Continue the process")
    CANCEL_HOTKEY = QT_TR_NOOP("Cancel ongoing GDB command")
    TOGGLE_ATTACH_HOTKEY = QT_TR_NOOP("Toggle attach/detach")
    EXACT_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - Exact")
    NOT_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - Not")
    INC_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - Increased")
    INC_BY_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - Increased By")
    DEC_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - Decreased")
    DEC_BY_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - Decreased By")
    LESS_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - Less Than")
    MORE_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - More Than")
    BETWEEN_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - Between")
    CHANGED_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - Changed")
    UNCHANGED_SCAN_HOTKEY = QT_TR_NOOP("Next Scan - Unchanged")
    ERROR = QT_TR_NOOP("Error")
    SUCCESS = QT_TR_NOOP("Success")
    INFO = QT_TR_NOOP("Information")
    GDB_INIT = QT_TR_NOOP("GDB isn't initialized yet")
    GDB_INIT_ERROR = QT_TR_NOOP(
        "Unable to initialize GDB\n"
        "You might want to reinstall GDB or use the system GDB\n"
        "To change the current GDB path, check Settings->Debug"
    )
    EDIT = QT_TR_NOOP("Edit")
    SHOW_HEX = QT_TR_NOOP("Show as hexadecimal")
    SHOW_DEC = QT_TR_NOOP("Show as decimal")
    SHOW_UNSIGNED = QT_TR_NOOP("Show as unsigned")
    SHOW_SIGNED = QT_TR_NOOP("Show as signed")
    TOGGLE = QT_TR_NOOP("Toggle")
    TOGGLE_CHILDREN = QT_TR_NOOP("Toggle including children")
    FREEZE = QT_TR_NOOP("Freeze")
    DEFAULT = QT_TR_NOOP("Default")
    BROWSE_MEMORY_REGION = QT_TR_NOOP("Browse this memory region")
    DISASSEMBLE_ADDRESS = QT_TR_NOOP("Disassemble this address")
    DELETE = QT_TR_NOOP("Delete")
    DELETE_SELECTION = QT_TR_NOOP("Delete selection")
    CUT = QT_TR_NOOP("Cut")
    COPY = QT_TR_NOOP("Copy")
    PASTE = QT_TR_NOOP("Paste")
    PASTE_INSIDE = QT_TR_NOOP("Paste inside")
    POINTER_SCAN = QT_TR_NOOP("Pointer scan for this address")
    POINTER_SCANNER = QT_TR_NOOP("Open pointer scanner")
    POINTER_SCAN_SUCCESS = QT_TR_NOOP("Pointer scan finished.\n\nDon't forget to open the scandata file (File->Open)!")
    WHAT_WRITES = QT_TR_NOOP("Find out what writes to this address")
    WHAT_READS = QT_TR_NOOP("Find out what reads this address")
    WHAT_ACCESSES = QT_TR_NOOP("Find out what accesses this address")
    ADD_GROUP = QT_TR_NOOP("Add to a new group")
    CREATE_GROUP = QT_TR_NOOP("Create a new group")
    GROUP = QT_TR_NOOP("Group")
    INVALID_CLIPBOARD = QT_TR_NOOP("Invalid clipboard content")
    NEW_SCAN = QT_TR_NOOP("New Scan")
    MATCH_COUNT_LIMITED = QT_TR_NOOP("Match count: {} ({} shown)")
    MATCH_COUNT = QT_TR_NOOP("Match count: {}")
    NO_DESCRIPTION = QT_TR_NOOP("No Description")
    OPEN_PCT_FILE = QT_TR_NOOP("Open PCT file(s)")
    OPEN_SCRIPT_FILE = QT_TR_NOOP("Open script file")
    SAVE_SCRIPT_FILE = QT_TR_NOOP("Save script file")
    UNTITLED = QT_TR_NOOP("(untitled)")
    SCRIPT_FAILED = QT_TR_NOOP("Script execution failed:")

    # Keep file extensions such as (*.pct) while translating, it doesn't matter where it stays within the sentence
    # For instance, you can keep (*.pct) in the beginning of the sentence for right-to-left languages like arabic
    # Apply the same to similar entries below
    FILE_TYPES_PCT = QT_TR_NOOP("PINCE Cheat Table (*.pct)")
    FILE_TYPES_SCRIPT = QT_TR_NOOP("Python Scripts (*.py)")
    SHARED_OBJECT_TYPE = QT_TR_NOOP("Shared object library (*.so)")
    FILE_TYPES_TRACE = QT_TR_NOOP("Trace File (*.trace)")
    FILE_TYPES_SCANDATA = QT_TR_NOOP("Pointer Scan Data (*.scandata)")
    CLEAR_TABLE = QT_TR_NOOP("Clear address table?")
    FILE_LOAD_ERROR = QT_TR_NOOP("File {} is inaccessible or contains invalid content")
    SAVE_PCT_FILE = QT_TR_NOOP("Save PCT file")
    FILE_SAVE_ERROR = QT_TR_NOOP("Cannot save to file")
    SMARTASS = QT_TR_NOOP("Nice try, smartass")
    PROCESS_NOT_VALID = QT_TR_NOOP("Selected process is not valid")
    ALREADY_DEBUGGING = QT_TR_NOOP("You're debugging this process already")
    ALREADY_TRACED = QT_TR_NOOP("That process is already being traced by {}, could not attach to the process")
    PERM_DENIED = QT_TR_NOOP("Permission denied, could not attach to the process")
    CREATE_PROCESS_ERROR = QT_TR_NOOP("An error occurred while trying to create process")
    SCAN_FOR = QT_TR_NOOP("Scan for")
    FIRST_SCAN = QT_TR_NOOP("First Scan")
    NO_PROCESS_SELECTED = QT_TR_NOOP("No Process Selected")
    STATUS_DETACHED = QT_TR_NOOP("[detached]")
    STATUS_STOPPED = QT_TR_NOOP("[stopped]")
    REQUIRE_PROCESS_STOP = QT_TR_NOOP("This requires the process to be stopped")
    ENTER_VALUE = QT_TR_NOOP("Enter the new value")
    ENTER_DESCRIPTION = QT_TR_NOOP("Enter the new description")
    EDIT_ADDRESS = QT_TR_NOOP("Edit Address")
    SELECT_PROCESS = QT_TR_NOOP("Please select a process first")
    SELECT_BINARY = QT_TR_NOOP("Select the target binary")
    ENTER_OPTIONAL_ARGS = QT_TR_NOOP("Enter the optional arguments")
    LD_PRELOAD_OPTIONAL = QT_TR_NOOP("LD_PRELOAD .so path (optional)")
    REFRESH = QT_TR_NOOP("Refresh")
    LENGTH_NOT_VALID = QT_TR_NOOP("Length is not valid")
    LENGTH_GT = QT_TR_NOOP("Length must be greater than 0")
    PARSE_ERROR = QT_TR_NOOP("Can't parse the input")
    IS_INVALID_REGEX = QT_TR_NOOP("{} isn't a valid regex")
    LANG_RESET = QT_TR_NOOP("Language settings will take effect upon the next restart")
    GDB_RESET = QT_TR_NOOP("You have changed the GDB path, reset GDB now?")
    RESET_DEFAULT_SETTINGS = QT_TR_NOOP("This will reset to the default settings\n" "Proceed?")
    MOUSE_OVER_EXAMPLES = QT_TR_NOOP("Mouse over on this text for examples")
    AUTO_ATTACH_TOOLTIP = QT_TR_NOOP(
        "asdf|qwer --> search for asdf or qwer\n"
        "[as]df --> search for both adf and sdf\n"
        "Use the char \\ to escape special chars such as [\n"
        r"\[asdf\] --> search for opcodes that contain [asdf]"
    )
    SEPARATE_PROCESSES_WITH = QT_TR_NOOP("Separate processes with {}")
    UNUSED_APPIMAGE_SETTING = QT_TR_NOOP("This setting is unused in AppImage builds")
    SELECT_GDB_BINARY = QT_TR_NOOP("Select the gdb binary")
    QUIT_SESSION_CRASH = QT_TR_NOOP("Quitting current session will crash PINCE")
    CONT_SESSION_CRASH = QT_TR_NOOP("Use global hotkeys or the commands 'interrupt' and 'c&' to stop/run the inferior")

    # For some languages, it might be hard to keep the pipe characters balanced
    # You are free to modify pipes and dashes as you like when translating
    # Check Chinese translation for an example
    GDB_CONSOLE_INIT = QT_TR_NOOP(
        "Hotkeys:\n"
        "-----------------------------\n"
        "Send: Enter                 |\n"
        "Multi-line mode: Ctrl+Enter |\n"
        "Complete command: Tab       |\n"
        "-----------------------------\n"
        "Commands:\n"
        "----------------------------------------------------------\n"
        "/clear: Clear the console                                |\n"
        "phase-out: Detach from the current process               |\n"
        "phase-in: Attach back to the previously detached process |\n"
        "---------------------------------------------------------------------------------------------------\n"
        "You can change the output mode from bottom right\n"
        "Changing output mode only affects commands sent. Any other output coming from external sources"
        "(e.g async output) will be shown in MI format"
    )
    BREAK = QT_TR_NOOP("Break[{}]")
    RUN = QT_TR_NOOP("Run[{}]")
    TOGGLE_ATTACH = QT_TR_NOOP("Toggle Attach[{}]")
    BREAKPOINT_FAILED = QT_TR_NOOP("Failed to set breakpoint at address {}")
    WATCHPOINT_FAILED = QT_TR_NOOP("Failed to set watchpoint at address {}")
    COPY_CLIPBOARD = QT_TR_NOOP("Copy to Clipboard")
    GO_TO_EXPRESSION = QT_TR_NOOP("Go to expression")
    ADD_TO_ADDRESS_LIST = QT_TR_NOOP("Add this address to address list")
    SET_WATCHPOINT = QT_TR_NOOP("Set Watchpoint")
    WRITE_ONLY = QT_TR_NOOP("Write Only")
    READ_ONLY = QT_TR_NOOP("Read Only")
    BOTH = QT_TR_NOOP("Both")
    CHANGE_BREAKPOINT_CONDITION = QT_TR_NOOP("Add/Change condition for breakpoint")
    DELETE_BREAKPOINT = QT_TR_NOOP("Delete Breakpoint")
    ENTER_EXPRESSION = QT_TR_NOOP("Enter the expression")
    INVALID = QT_TR_NOOP("{} is invalid")
    REGION_INFO = QT_TR_NOOP("Protection:{} | Base:{}-{} | Module:{}")
    INVALID_REGION = QT_TR_NOOP("Invalid Region")
    EXPRESSION_ACCESS_ERROR = QT_TR_NOOP("Cannot access memory at expression {}")
    REFERENCED_BY = QT_TR_NOOP("Referenced by:")
    SEE_REFERRERS = QT_TR_NOOP("Press 'Ctrl+E' to see a detailed list of referrers")
    MV_PAUSED = QT_TR_NOOP("Memory Viewer - Paused")
    MV_DEBUGGING = QT_TR_NOOP("Memory Viewer - Currently debugging {}")
    MV_RUNNING = QT_TR_NOOP("Memory Viewer - Running")
    ENTER_BP_CONDITION = QT_TR_NOOP(
        "Enter the expression for condition, for instance:\n\n"
        "$eax==0x523\n"
        "$rax>0 && ($rbp<0 || $rsp==0)\n"
        "printf($r10)==3"
    )
    BP_CONDITION_FAILED = QT_TR_NOOP("Failed to set condition for address {}\n" "Check terminal for details")
    FULL_STACK = QT_TR_NOOP("Full Stack")
    COPY_RETURN_ADDRESS = QT_TR_NOOP("Copy Return Address")
    COPY_FRAME_ADDRESS = QT_TR_NOOP("Copy Frame Address")
    STACKTRACE = QT_TR_NOOP("Stacktrace")
    TOGGLE_STACK_FROM_SP_BP = QT_TR_NOOP("Toggle stack from BP/SP register")
    COPY_ADDRESS = QT_TR_NOOP("Copy Address")
    COPY_VALUE = QT_TR_NOOP("Copy Value")
    COPY_POINTS_TO = QT_TR_NOOP("Copy Points to")
    DISASSEMBLE_VALUE_POINTER = QT_TR_NOOP("Disassemble 'value' pointer address")
    HEXVIEW_VALUE_POINTER = QT_TR_NOOP("Show 'value' pointer in HexView")
    BACK = QT_TR_NOOP("Back")
    HEXVIEW_ADDRESS = QT_TR_NOOP("Show this address in HexView")
    FOLLOW = QT_TR_NOOP("Follow")
    EXAMINE_REFERRERS = QT_TR_NOOP("Examine Referrers")
    BOOKMARK_ADDRESS = QT_TR_NOOP("Bookmark this address")
    DELETE_BOOKMARK = QT_TR_NOOP("Delete this bookmark")
    CHANGE_COMMENT = QT_TR_NOOP("Change comment")
    GO_TO_BOOKMARK_ADDRESS = QT_TR_NOOP("Go to bookmarked address")
    TOGGLE_BREAKPOINT = QT_TR_NOOP("Toggle Breakpoint")
    EDIT_INSTRUCTION = QT_TR_NOOP("Edit instruction")
    REPLACE_WITH_NOPS = QT_TR_NOOP("Replace instruction with NOPs")
    WHAT_ACCESSES_INSTRUCTION = QT_TR_NOOP("Find out which addresses this instruction accesses")
    TRACE_INSTRUCTION = QT_TR_NOOP("Break and trace instructions")
    DISSECT_REGION = QT_TR_NOOP("Dissect this region")
    COPY_BYTES = QT_TR_NOOP("Copy Bytes")
    COPY_OPCODE = QT_TR_NOOP("Copy Opcode")
    COPY_COMMENT = QT_TR_NOOP("Copy Comment")
    COPY_ALL = QT_TR_NOOP("Copy All")
    ENTER_TRACK_BP_EXPRESSION = QT_TR_NOOP(
        "Enter the register expression(s) you want to track\n"
        "Register names must start with $\n"
        "Each expression must be separated with a comma\n\n"
        "For instance:\n"
        "Let's say the instruction is mov [rax+rbx],30\n"
        "Then you should enter $rax+$rbx\n"
        "So PINCE can track address [rax+rbx]\n\n"
        "Another example:\n"
        "If you enter $rax,$rbx*$rcx+4,$rbp\n"
        "PINCE will track down addresses [rax],[rbx*rcx+4] and [rbp]"
    )
    ALREADY_BOOKMARKED = QT_TR_NOOP("This address has already been bookmarked")
    ENTER_BOOKMARK_COMMENT = QT_TR_NOOP("Enter the comment for bookmarked address")
    SELECT_SO_FILE = QT_TR_NOOP("Select the .so file")
    FILE_INJECTED = QT_TR_NOOP("The file has been injected")
    FILE_INJECT_FAILED = QT_TR_NOOP("Failed to inject the .so file")
    ENTER_CALL_EXPRESSION = QT_TR_NOOP(
        "Enter the expression for the function that'll be called from the inferior\n"
        "You can view functions list from View->Functions\n\n"
        "For instance:\n"
        'Calling printf("1234") will yield something like this\n'
        "↓\n"
        "$28 = 4\n\n"
        "$28 is the assigned convenience variable\n"
        "4 is the result\n"
        "You can use the assigned variable from the GDB Console"
    )
    CALL_EXPRESSION_FAILED = QT_TR_NOOP("Failed to call the expression {}")
    INVALID_EXPRESSION = QT_TR_NOOP("Invalid expression or address")
    INVALID_ENTRY = QT_TR_NOOP("Invalid entries detected, refreshing the page")
    ADD_ENTRY = QT_TR_NOOP("Add new entry")
    ENTER_REGISTER_VALUE = QT_TR_NOOP("Enter the new value of register {}")
    ENTER_FLAG_VALUE = QT_TR_NOOP("Enter the new value of flag {}")
    RESTORE_INSTRUCTION = QT_TR_NOOP("Restore this instruction")
    ENTER_HIT_COUNT = QT_TR_NOOP("Enter the hit count({} or higher)")
    HIT_COUNT_ASSERT_INT = QT_TR_NOOP("Hit count must be an integer")
    HIT_COUNT_ASSERT_LT = QT_TR_NOOP("Hit count can't be lower than {}")
    CHANGE_CONDITION = QT_TR_NOOP("Change condition")
    ENABLE = QT_TR_NOOP("Enable")
    DISABLE = QT_TR_NOOP("Disable")
    DISABLE_AFTER_HIT = QT_TR_NOOP("Disable after hit")
    DISABLE_AFTER_COUNT = QT_TR_NOOP("Disable after X hits")
    DELETE_AFTER_HIT = QT_TR_NOOP("Delete after hit")
    OPCODE_WRITING_TO = QT_TR_NOOP("Opcodes writing to the address {}")
    OPCODE_READING_FROM = QT_TR_NOOP("Opcodes reading from the address {}")
    OPCODE_ACCESSING_TO = QT_TR_NOOP("Opcodes accessing to the address {}")
    TRACK_WATCHPOINT_FAILED = QT_TR_NOOP("Unable to track watchpoint at expression {}")
    DELETE_WATCHPOINT_FAILED = QT_TR_NOOP("Unable to delete watchpoint at expression {}")
    CLOSE = QT_TR_NOOP("Close")
    ACCESSED_BY_INSTRUCTION = QT_TR_NOOP("Addresses accessed by instruction {}")
    TRACK_BREAKPOINT_FAILED = QT_TR_NOOP("Unable to track breakpoint at expression {}")
    ACCESSED_BY = QT_TR_NOOP("Accessed by {}")
    DELETE_BREAKPOINT_FAILED = QT_TR_NOOP("Unable to delete breakpoint at expression {}")
    MAX_TRACE_COUNT_ASSERT_GT = QT_TR_NOOP("Max trace count must be greater than or equal to {}")
    SAVE_TRACE_FILE = QT_TR_NOOP("Save trace file")
    OPEN_TRACE_FILE = QT_TR_NOOP("Open trace file")
    EXPAND_ALL = QT_TR_NOOP("Expand All")
    COLLAPSE_ALL = QT_TR_NOOP("Collapse All")
    SELECT_POINTER_MAP = QT_TR_NOOP("Select a pointer map file")
    SCAN = QT_TR_NOOP("Scan")
    SCANNING = QT_TR_NOOP("Scanning")
    FILTER = QT_TR_NOOP("Filter")
    FILTERING = QT_TR_NOOP("Filtering")
    DEFINED = QT_TR_NOOP("DEFINED")
    DEFINED_SYMBOL = QT_TR_NOOP(
        "This symbol is defined. You can use its body as a gdb expression. For instance:\n\n"
        "void func(param) can be used as 'func' as a gdb expression"
    )
    COPY_SYMBOL = QT_TR_NOOP("Copy Symbol")
    FUNCTIONS_INFO_HELPER = QT_TR_NOOP(
        "\tHere's some useful regex tips:\n"
        "^quaso --> search for everything that starts with quaso\n"
        "[ab]cd --> search for both acd and bcd\n\n"
        "\tHow to interpret symbols:\n"
        "A symbol that looks like 'func(param)@plt' consists of 3 pieces\n"
        "func, func(param), func(param)@plt\n"
        "These 3 functions will have different addresses\n"
        "@plt means this function is a subroutine for the original one\n"
        "There can be more than one of the same function\n"
        "It means that the function is overloaded"
    )
    NEW_OPCODE = QT_TR_NOOP(
        "New opcode is {} bytes long but old opcode is only {} bytes long\n" "This will cause an overflow, proceed?"
    )
    IS_INVALID_EXPRESSION = QT_TR_NOOP("{} isn't a valid expression")
    LOG_FILE = QT_TR_NOOP("Log File of PID {}")
    LOG_CONTENTS = QT_TR_NOOP("Contents of {} (only last {} bytes are shown)")
    ON = QT_TR_NOOP("ON")
    OFF = QT_TR_NOOP("OFF")
    LOG_STATUS = QT_TR_NOOP("LOGGING: {}")
    LOG_READ_ERROR = QT_TR_NOOP("Unable to read log file at {}")
    SETTINGS_ENABLE_LOG = QT_TR_NOOP("Go to Settings->Debug to enable logging")
    INVALID_REGEX = QT_TR_NOOP("Invalid Regex")
    SEARCH_OPCODE_HELPER = QT_TR_NOOP(
        "\tHere's some useful regex examples:\n"
        "call|rax --> search for opcodes that contain call or rax\n"
        "[re]cx --> search for both rcx and ecx\n"
        "Use the char \\ to escape special chars such as [\n"
        r"\[rsp\] --> search for opcodes that contain [rsp]"
    )
    COPY_ADDRESSES = QT_TR_NOOP("Copy Addresses")
    COPY_OFFSET = QT_TR_NOOP("Copy Offset")
    COPY_PATH = QT_TR_NOOP("Copy Path")
    START = QT_TR_NOOP("Start")
    CURRENT_SCAN_REGION = QT_TR_NOOP("Currently scanning region:")
    CANCEL = QT_TR_NOOP("Cancel")
    SCAN_FINISHED = QT_TR_NOOP("Scan finished")
    SCAN_CANCELED = QT_TR_NOOP("Scan was canceled")
    SELECT_ONE_REGION = QT_TR_NOOP("Select at least one region")
    DISSECT_CODE = QT_TR_NOOP("You need to dissect code first\n" "Proceed?")
    WAITING_FOR_BREAKPOINT = QT_TR_NOOP("Waiting for breakpoint to trigger")
    TRACING_COMPLETED = QT_TR_NOOP("Tracing has been completed")
    NOT = QT_TR_NOOP("Not")
    EXACT = QT_TR_NOOP("Exact")
    INCREASED = QT_TR_NOOP("Increased")
    INCREASED_BY = QT_TR_NOOP("Increased by")
    DECREASED = QT_TR_NOOP("Decreased")
    DECREASED_BY = QT_TR_NOOP("Decreased by")
    LESS_THAN = QT_TR_NOOP("Less Than")
    MORE_THAN = QT_TR_NOOP("More Than")
    BETWEEN = QT_TR_NOOP("Between")
    CHANGED = QT_TR_NOOP("Changed")
    UNCHANGED = QT_TR_NOOP("Unchanged")
    UNKNOWN_VALUE = QT_TR_NOOP("Unknown Value")
    BASIC = QT_TR_NOOP("Basic")
    NORMAL = QT_TR_NOOP("Normal")
    RW = QT_TR_NOOP("Read+Write")
    FULL = QT_TR_NOOP("Full")
    HOST = QT_TR_NOOP("Host")
    LITTLE = QT_TR_NOOP("Little")
    BIG = QT_TR_NOOP("Big")
    SHOW_HEXVIEW = QT_TR_NOOP("Show in HexView")
    SHOW_DISASSEMBLER = QT_TR_NOOP("Show in Disassembler")
    DARK = QT_TR_NOOP("Dark")
    LIGHT = QT_TR_NOOP("Light")
    SYSTEM_DEFAULT = QT_TR_NOOP("System Default")
    WONG = QT_TR_NOOP("Wong (Colorblind Friendly)")
    SAVE_SESSION_QUESTION_TITLE = QT_TR_NOOP("Session - Unsaved changes")
    SAVE_SESSION_QUESTION_PROMPT = QT_TR_NOOP("You have unsaved changes.\nDo you want to save the current session?")
    SESSION_PROCESS_CHANGED_TITLE = QT_TR_NOOP("Session - Process changed")
    SESSION_PROCESS_CHANGED_PROMPT = QT_TR_NOOP(
        "The process name has changed.\n" "Do you want to keep the current session with the new process?"
    )

```