Project Path: arc_c3rb3ru5d3d53c_binlex_5b8b9ttf

Source Tree:

```txt
arc_c3rb3ru5d3d53c_binlex_5b8b9ttf
â”œâ”€â”€ CLA.md
â”œâ”€â”€ CODE_OF_CONDUCT.md
â”œâ”€â”€ CONTRIBUTING.md
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ LICENSE
â”œâ”€â”€ Makefile
â”œâ”€â”€ PKGBUILD
â”œâ”€â”€ README.md
â”œâ”€â”€ SECURITY.md
â”œâ”€â”€ assets
â”‚   â”œâ”€â”€ binlex.png
â”‚   â””â”€â”€ ida.png
â”œâ”€â”€ examples
â”‚   â””â”€â”€ python
â”‚       â”œâ”€â”€ chromosomes.py
â”‚       â”œâ”€â”€ elf.py
â”‚       â”œâ”€â”€ macho.py
â”‚       â”œâ”€â”€ pe_dotnet.py
â”‚       â”œâ”€â”€ pe_native.py
â”‚       â”œâ”€â”€ pe_native_compare.py
â”‚       â”œâ”€â”€ standalone_search.py
â”‚       â”œâ”€â”€ training.py
â”‚       â””â”€â”€ vector_database.py
â”œâ”€â”€ scripts
â”‚   â”œâ”€â”€ blghidra
â”‚   â”‚   â””â”€â”€ blghidra.py
â”‚   â”œâ”€â”€ blserver
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â”œâ”€â”€ README.md
â”‚   â”‚   â”œâ”€â”€ blserver.py
â”‚   â”‚   â”œâ”€â”€ configs
â”‚   â”‚   â”‚   â”œâ”€â”€ Makefile
â”‚   â”‚   â”‚   â”œâ”€â”€ attu-proxy.conf.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ attu-proxy.crt.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ attu-proxy.key.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ blserver-proxy.conf.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ blserver-proxy.crt.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ blserver-proxy.key.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ blserver.toml.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ jupyterhub-proxy.conf.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ jupyterhub-proxy.crt.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ jupyterhub-proxy.key.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ jupyterhub.py.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ milvus.yaml.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ minio-proxy.conf.bak
â”‚   â”‚   â”‚   â”œâ”€â”€ minio-proxy.crt.bak
â”‚   â”‚   â”‚   â””â”€â”€ minio-proxy.key.bak
â”‚   â”‚   â”œâ”€â”€ docker-compose.yml
â”‚   â”‚   â”œâ”€â”€ libblserver
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ gnn.py
â”‚   â”‚   â”‚   â”œâ”€â”€ milvus.py
â”‚   â”‚   â”‚   â””â”€â”€ minio.py
â”‚   â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”‚   â””â”€â”€ setup.py
â”‚   â”œâ”€â”€ libblclient
â”‚   â”‚   â”œâ”€â”€ libblclient
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ client.py
â”‚   â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”‚   â””â”€â”€ setup.py
â”‚   â””â”€â”€ plugins
â”‚       â””â”€â”€ ida
â”‚           â””â”€â”€ binlex
â”‚               â”œâ”€â”€ __init__.py
â”‚               â”œâ”€â”€ actions
â”‚               â”‚   â”œâ”€â”€ __init__.py
â”‚               â”‚   â”œâ”€â”€ copy_block_json.py
â”‚               â”‚   â”œâ”€â”€ copy_block_vector.py
â”‚               â”‚   â”œâ”€â”€ copy_function_json.py
â”‚               â”‚   â”œâ”€â”€ copy_function_vector.py
â”‚               â”‚   â”œâ”€â”€ copy_hex.py
â”‚               â”‚   â”œâ”€â”€ copy_minhash.py
â”‚               â”‚   â”œâ”€â”€ copy_pattern.py
â”‚               â”‚   â”œâ”€â”€ copy_tlsh.py
â”‚               â”‚   â”œâ”€â”€ export.py
â”‚               â”‚   â”œâ”€â”€ export_byte_colormap.py
â”‚               â”‚   â”œâ”€â”€ function_table.py
â”‚               â”‚   â”œâ”€â”€ index_block.py
â”‚               â”‚   â”œâ”€â”€ index_database.py
â”‚               â”‚   â”œâ”€â”€ index_function.py
â”‚               â”‚   â”œâ”€â”€ scan_minhash.py
â”‚               â”‚   â”œâ”€â”€ scan_tlsh.py
â”‚               â”‚   â””â”€â”€ search_database.py
â”‚               â”œâ”€â”€ gui
â”‚               â”‚   â”œâ”€â”€ __init__.py
â”‚               â”‚   â”œâ”€â”€ about.py
â”‚               â”‚   â”œâ”€â”€ action_handlers.py
â”‚               â”‚   â”œâ”€â”€ binlex_server_authentication.py
â”‚               â”‚   â”œâ”€â”€ binlex_server_settings.py
â”‚               â”‚   â”œâ”€â”€ database_export_options.py
â”‚               â”‚   â”œâ”€â”€ gradient_table.py
â”‚               â”‚   â”œâ”€â”€ hooks.py
â”‚               â”‚   â”œâ”€â”€ json_search.py
â”‚               â”‚   â”œâ”€â”€ main.py
â”‚               â”‚   â”œâ”€â”€ okaycancel.py
â”‚               â”‚   â”œâ”€â”€ progress.py
â”‚               â”‚   â”œâ”€â”€ scan_minhash.py
â”‚               â”‚   â”œâ”€â”€ scan_tlsh.py
â”‚               â”‚   â”œâ”€â”€ search_database.py
â”‚               â”‚   â””â”€â”€ svg.py
â”‚               â”œâ”€â”€ ida-plugin.json
â”‚               â”œâ”€â”€ lib
â”‚               â”‚   â”œâ”€â”€ __init__.py
â”‚               â”‚   â”œâ”€â”€ assets.py
â”‚               â”‚   â”œâ”€â”€ blclient.py
â”‚               â”‚   â”œâ”€â”€ ida.py
â”‚               â”‚   â”œâ”€â”€ styles.py
â”‚               â”‚   â”œâ”€â”€ text.py
â”‚               â”‚   â””â”€â”€ worker.py
â”‚               â”œâ”€â”€ main.py
â”‚               â””â”€â”€ requirements.txt
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ bin
â”‚   â”‚   â”œâ”€â”€ binlex.rs
â”‚   â”‚   â”œâ”€â”€ blelfsym.rs
â”‚   â”‚   â”œâ”€â”€ blhash.rs
â”‚   â”‚   â”œâ”€â”€ blimage.rs
â”‚   â”‚   â”œâ”€â”€ blmachosym.rs
â”‚   â”‚   â”œâ”€â”€ blpdb.rs
â”‚   â”‚   â”œâ”€â”€ blrizin.rs
â”‚   â”‚   â””â”€â”€ blyara.rs
â”‚   â”œâ”€â”€ binary.rs
â”‚   â”œâ”€â”€ bindings
â”‚   â”‚   â””â”€â”€ python
â”‚   â”‚       â”œâ”€â”€ Cargo.toml
â”‚   â”‚       â”œâ”€â”€ project
â”‚   â”‚       â”‚   â”œâ”€â”€ binlex
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ _global
â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ binary
â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ controlflow
â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ disassemblers
â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ capstone
â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ custom
â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â””â”€â”€ cil
â”‚   â”‚       â”‚   â”‚   â”‚   â”‚       â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ ida
â”‚   â”‚       â”‚   â”‚   â”‚       â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ formats
â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ genetics
â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ hashing
â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ imaging
â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â”‚   â””â”€â”€ types
â”‚   â”‚       â”‚   â”‚       â””â”€â”€ __init__.py
â”‚   â”‚       â”‚   â””â”€â”€ binlex_bindings
â”‚   â”‚       â”‚       â””â”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ pyproject.toml
â”‚   â”‚       â””â”€â”€ src
â”‚   â”‚           â”œâ”€â”€ binary.rs
â”‚   â”‚           â”œâ”€â”€ controlflow
â”‚   â”‚           â”‚   â”œâ”€â”€ block.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ function.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ graph.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ instruction.rs
â”‚   â”‚           â”‚   â””â”€â”€ mod.rs
â”‚   â”‚           â”œâ”€â”€ disassemblers
â”‚   â”‚           â”‚   â”œâ”€â”€ capstone
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ disassembler.rs
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ custom
â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ cil
â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ disassembler.rs
â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚           â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚           â”‚   â””â”€â”€ mod.rs
â”‚   â”‚           â”œâ”€â”€ formats
â”‚   â”‚           â”‚   â”œâ”€â”€ elf.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ file.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ macho.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚           â”‚   â””â”€â”€ pe.rs
â”‚   â”‚           â”œâ”€â”€ genetics
â”‚   â”‚           â”‚   â”œâ”€â”€ allelepair.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ chromosome.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ gene.rs
â”‚   â”‚           â”‚   â””â”€â”€ mod.rs
â”‚   â”‚           â”œâ”€â”€ global
â”‚   â”‚           â”‚   â”œâ”€â”€ architecture.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ config.rs
â”‚   â”‚           â”‚   â””â”€â”€ mod.rs
â”‚   â”‚           â”œâ”€â”€ hashing
â”‚   â”‚           â”‚   â”œâ”€â”€ minhash.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚           â”‚   â”œâ”€â”€ sha256.rs
â”‚   â”‚           â”‚   â””â”€â”€ tlsh.rs
â”‚   â”‚           â”œâ”€â”€ imaging
â”‚   â”‚           â”‚   â”œâ”€â”€ colormap.rs
â”‚   â”‚           â”‚   â””â”€â”€ mod.rs
â”‚   â”‚           â”œâ”€â”€ lib.rs
â”‚   â”‚           â””â”€â”€ types
â”‚   â”‚               â”œâ”€â”€ lz4string.rs
â”‚   â”‚               â”œâ”€â”€ memorymappedfile.rs
â”‚   â”‚               â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ controlflow
â”‚   â”‚   â”œâ”€â”€ attribute.rs
â”‚   â”‚   â”œâ”€â”€ block.rs
â”‚   â”‚   â”œâ”€â”€ function.rs
â”‚   â”‚   â”œâ”€â”€ graph.rs
â”‚   â”‚   â”œâ”€â”€ instruction.rs
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ symbol.rs
â”‚   â”‚   â””â”€â”€ tag.rs
â”‚   â”œâ”€â”€ disassemblers
â”‚   â”‚   â”œâ”€â”€ capstone
â”‚   â”‚   â”‚   â”œâ”€â”€ disassembler.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”‚   â””â”€â”€ x86
â”‚   â”‚   â”‚       â”œâ”€â”€ disassembler.rs
â”‚   â”‚   â”‚       â””â”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ custom
â”‚   â”‚   â”‚   â”œâ”€â”€ cil
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ disassembler.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ instruction.rs
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ mnemonic.rs
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ formats
â”‚   â”‚   â”œâ”€â”€ cli.rs
â”‚   â”‚   â”œâ”€â”€ elf.rs
â”‚   â”‚   â”œâ”€â”€ file.rs
â”‚   â”‚   â”œâ”€â”€ macho.rs
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ pe.rs
â”‚   â”œâ”€â”€ genetics
â”‚   â”‚   â”œâ”€â”€ allelepair.rs
â”‚   â”‚   â”œâ”€â”€ chromosome.rs
â”‚   â”‚   â”œâ”€â”€ gene.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ global
â”‚   â”‚   â”œâ”€â”€ architecture.rs
â”‚   â”‚   â”œâ”€â”€ config.rs
â”‚   â”‚   â”œâ”€â”€ format.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ hashing
â”‚   â”‚   â”œâ”€â”€ minhash.rs
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ sha256.rs
â”‚   â”‚   â””â”€â”€ tlsh.rs
â”‚   â”œâ”€â”€ imaging
â”‚   â”‚   â”œâ”€â”€ colormap.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ io
â”‚   â”‚   â”œâ”€â”€ json.rs
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ stderr.rs
â”‚   â”‚   â”œâ”€â”€ stdin.rs
â”‚   â”‚   â””â”€â”€ stdout.rs
â”‚   â”œâ”€â”€ lcs
â”‚   â”‚   â”œâ”€â”€ lcs.rs
â”‚   â”‚   â””â”€â”€ mod.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â””â”€â”€ types
â”‚       â”œâ”€â”€ lz4string.rs
â”‚       â”œâ”€â”€ memorymappedfile.rs
â”‚       â””â”€â”€ mod.rs
â””â”€â”€ tests
    â”œâ”€â”€ test_block_split.rs
    â”œâ”€â”€ test_models_binary.rs
    â”œâ”€â”€ test_models_hashing.rs
    â”œâ”€â”€ test_pe_disassembler.rs
    â””â”€â”€ test_types.rs

```

`CLA.md`:

```md
## Individual Contributor License Agreement (CLA)

**Thank you for submitting your contributions to this project.**

By signing this CLA, you agree that the following terms apply to all of your past, present and future contributions
to the project.

### License.

You hereby represent that all present, past and future contributions are governed by the [MIT License](https://opensource.org/licenses/MIT) copyright statement.

This entails that to the extent possible under law, you transfer all copyright and related or neighboring rights
of the code or documents you contribute to the project itself or its maintainers.
Furthermore you also represent that you have the authority to perform the above waiver
with respect to the entirety of you contributions.

### Moral Rights.

To the fullest extent permitted under applicable law, you hereby waive, and agree not to
assert, all of your â€œmoral rightsâ€ in or relating to your contributions for the benefit of the project.

### Third Party Content.

If your Contribution includes or is based on any source code, object code, bug fixes, configuration changes, tools,
specifications, documentation, data, materials, feedback, information or other works of authorship that were not
authored by you (â€œThird Party Contentâ€) or if you are aware of any third party intellectual property or proprietary
rights associated with your Contribution (â€œThird Party Rightsâ€),
then you agree to include with the submission of your Contribution full details respecting such Third Party
Content and Third Party Rights, including, without limitation, identification of which aspects of your
Contribution contain Third Party Content or are associated with Third Party Rights, the owner/author of the
Third Party Content and Third Party Rights, where you obtained the Third Party Content, and any applicable
third party license terms or restrictions respecting the Third Party Content and Third Party Rights. For greater
certainty, the foregoing obligations respecting the identification of Third Party Content and Third Party Rights
do not apply to any portion of a Project that is incorporated into your Contribution to that same Project.

### Representations.

You represent that, other than the Third Party Content and Third Party Rights identified by
you in accordance with this Agreement, you are the sole author of your Contributions and are legally entitled
to grant the foregoing licenses and waivers in respect of your Contributions. If your Contributions were
created in the course of your employment with your past or present employer(s), you represent that such
employer(s) has authorized you to make your Contributions on behalf of such employer(s) or such employer
(s) has waived all of their right, title or interest in or to your Contributions.

### Disclaimer.

To the fullest extent permitted under applicable law, your Contributions are provided on an "as is"
basis, without any warranties or conditions, express or implied, including, without limitation, any implied
warranties or conditions of non-infringement, merchantability or fitness for a particular purpose. You are not
required to provide support for your Contributions, except to the extent you desire to provide support.

### No Obligation.

You acknowledge that the maintainers of this project are under no obligation to use or incorporate your contributions
into the project. The decision to use or incorporate your contributions into the project will be made at the
sole discretion of the maintainers or their authorized delegates.

```

`CODE_OF_CONDUCT.md`:

```md
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
`c3rb3ru5d3d53c@gmail.com`.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.

```

`CONTRIBUTING.md`:

```md
# Contributing

When contributing to this repository, please first discuss the change you wish to make via issue,
email, or any other method with the owners of this repository before making a change.

Please note we have a code of conduct, please follow it in all your interactions with the project.

## Pull Request Process

1. Sign the [CLA](CLA.md) agreement.
2. Ensure any install or build dependencies are removed before the end of the layer when doing a
   build.
3. Update the [README](README.md) with details of changes to the interface, this includes new environment
   variables, exposed ports, useful file locations and container parameters.
4. Increase the version numbers in any examples files and the [README](README.md) to the new version that this
   Pull Request would represent. The versioning scheme we use is [SemVer](http://semver.org/).
5. You may merge the Pull Request in once you have the sign-off of two other developers, or if you
   do not have permission to do that, you may request the second reviewer to merge it for you.

## Code of Conduct

### Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, gender identity and expression, level of experience,
nationality, personal appearance, race, religion, or sexual identity and
orientation.

### Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
  address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

### Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

### Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

### Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at `c3rb3ru5d3d53c@gmail.com`. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

### Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at [http://contributor-covenant.org/version/1/4][version]

[homepage]: http://contributor-covenant.org
[version]: http://contributor-covenant.org/version/1/4/

```

`Cargo.toml`:

```toml
[package]
name = "binlex"
version = "2.0.0"
edition = "2024"
license = "MIT"
description = "A Binary Genetic Trait Lexer Framework"
authors = ["c3rb3ru5d3d53c"]

[target.'cfg(target_os = "windows")'.dependencies]
winapi = { version = "0.3.9", features = ["winnt", "fileapi", "ioapiset", "winioctl"] }

[dependencies]
clap = { version = "4.5.27", features = ["derive"] }
lief = "0.15.1"
capstone = "0.12.0"
fast-tlsh = "0.1.6"
ring = "0.17.8"
serde = { version = "1.0.217", features = ["derive"] }
serde_json = "1.0.137"
twox-hash = "2.0.0"
rand = { version = "0.8.5", features = ["small_rng"] }
once_cell = "1.20.2"
rayon = "1.10.0"
crossbeam = "0.8.4"
crossbeam-skiplist = "0.1.3"
lz4 = "1.28.1"
pdb = "0.8.0"
memmap2 = "0.9.5"
dirs = "6.0.0"
toml = "0.8.19"
glob = "0.3.2"
indexmap = "2.7.1"
cxx = "=1.0.138"

[workspace]
members = [
    "src/bindings/python/",
]

[profile.release]
opt-level = 3
lto = true
codegen-units = 1

[[bin]]
name = "binlex"
path = "src/bin/binlex.rs"

[[bin]]
name = "blyara"
path = "src/bin/blyara.rs"

[[bin]]
name = "blpdb"
path = "src/bin/blpdb.rs"

[[bin]]
name = "blrizin"
path = "src/bin/blrizin.rs"

[[bin]]
name = "blimage"
path = "src/bin/blimage.rs"

[[bin]]
name = "blhash"
path = "src/bin/blhash.rs"

[[bin]]
name = "blelfsym"
path = "src/bin/blelfsym.rs"


[[bin]]
name = "blmachosym"
path = "src/bin/blmachosym.rs"

```

`LICENSE`:

```
MIT License

Copyright (c) [2025] [c3rb3ru5d3d53c]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Makefile`:

```
OUTPUT_DIRECTORY = target

all:
	@cargo build --release

zst:
	@cargo build --release
	@makepkg
	@mkdir -p $(OUTPUT_DIRECTORY)/zst/
	@for file in *.pkg.tar.zst; do \
		echo "Moving $$file to $(OUTPUT_DIRECTORY)/zst/..."; \
		mv "$$file" $(OUTPUT_DIRECTORY)/zst/; \
	done

deb:
	@cargo install cargo-deb
	@cargo deb

wheel:
	virtualenv -p python3 venv/
	. venv/bin/activate && \
		cd src/bindings/python/ && \
		pip install maturin[patchelf] && \
		maturin build --release

clean:
	@rm -rf pkg/
	@cargo clean

```

`PKGBUILD`:

```
pkgname=binlex
pkgver=$(grep '^version =' Cargo.toml | awk -F\" '{print $2}')
pkgrel=1
pkgdesc="A Binary Genetic Trait Lexer Framework"
arch=('x86_64')
license=('LGPL')

build() {
  local builddir="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
}

package() {
    local builddir="$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
    install -Dm755 "$builddir/target/release/binlex" "$pkgdir/usr/bin/binlex"
    install -Dm755 "$builddir/target/release/blhash" "$pkgdir/usr/bin/blhash"
    install -Dm755 "$builddir/target/release/blimage" "$pkgdir/usr/bin/blimage"
    install -Dm755 "$builddir/target/release/blmachosym" "$pkgdir/usr/bin/blmachosym"
    install -Dm755 "$builddir/target/release/blpdb" "$pkgdir/usr/bin/blpdb"
    install -Dm755 "$builddir/target/release/blrizin" "$pkgdir/usr/bin/blrizin"
    install -Dm755 "$builddir/target/release/blyara" "$pkgdir/usr/bin/blyara"
}

```

`README.md`:

```md
![build](https://github.com/c3rb3ru5d3d53c/binlex/actions/workflows/cicd.yml/badge.svg?branch=master)
![OS Linux](https://img.shields.io/badge/os-linux-brightgreen)
![OS Windows](https://img.shields.io/badge/os-windows-brightgreen)
![OS MacOS](https://img.shields.io/badge/os-macos-brightgreen)
[![GitHub stars](https://img.shields.io/github/stars/c3rb3ru5d3d53c/binlex)](https://github.com/c3rb3ru5d3d53c/binlex/stargazers)
[![Discord Status](https://img.shields.io/discord/915569998469144636?logo=discord)](https://discord.gg/UDBfRpxV3B)
[![GitHub license](https://img.shields.io/github/license/c3rb3ru5d3d53c/binlex)](https://github.com/c3rb3ru5d3d53c/binlex/blob/master/LICENSE)
![GitHub all releases](https://img.shields.io/github/downloads/c3rb3ru5d3d53c/binlex/total)

<table>
  <tr>
    <td style="border: none; text-align: center; vertical-align: middle;">
      <img src="./assets/binlex.png" alt="Binlex logo" width="100" style="display: inline-block;">
    </td>
    <td style="border: none; text-align: center; vertical-align: middle; padding-left: 10px;">
      <h1 style="font-weight: bold; margin: 0;">Binlex - A Binary Genetic Trait Lexer Framework</h1>
      <div style="font-size: smaller; font-weight: bold; margin-top: 5px;">
        If maldevs think their binary is FUD, they're about to have an existential crisis.
      </div>
    </td>
  </tr>
</table>

**Binlex** is a tool for malware analysts and researchers that extracts **instructions**, **basic blocks**, and **functions** from binary files and organizes them into a structured hierarchy of **genomes**, **chromosomes**, **allele pairs**, and **genes**. ğŸ¦ ğŸ”

- A **genome** represents an **instruction**, **block**, or **function** in the binary. ğŸ§¬
- Each genome contains one or more **chromosomes**, which are **patterns** or **sequences** of data within the instruction, function, or block.
- A **chromosome** is made up of **allele pairs**, each representing **two genes**, encoded as a **single byte** (split into two **nibbles**).
- A **gene** is the smallest unit, represented by a **single nibble**.

This hierarchical breakdown allows **binlex** to analyze and compare malware binaries by treating their code structure like a "DNA fingerprint," making it easier to detect patterns, similarities, and variations across samples.

Unlike tools relying on **pure Python**, which can be slow ğŸ¢, **binlex** is designed for speed, simplicity, and flexibility. Its **command-line interface** helps analysts search for patterns across **hundreds or thousands of malware samples**, saving **time** â³ and **resources** ğŸ’°.

For malware analysts and reverse engineers, **binlex** includes a IDA plugin and a vector database (**binlex** server) designed to identify similar functions.

While tools like **BinDiff** and **Diaphora** excel in single-file comparisons, **binlex** server operates more like **Lumina** but with a modern approach. Instead of relying on FLIRT signatures, **binlex** server leverages the power of a **Graph Neural Network (GNN)** and similarity hashing with architecture specific normalization for enhanced precision and flexibility.

With **binlex** sever, you gain access to usernames, timestamps, and the sample hashes from which function signatures are derived, critical insights for collaborative analysis.

A set of command-line tools are also provided to malware analysts and reverse engineers to help speed up the hunting of common patterns for threat hunting and detection.

For developers, **binlex** offers a **Rust API** and **Python bindings** to build custom tooling with minimal licensing restrictions. ğŸ”“

As part of the fight against malware, **binlex** is free to useâ€”just **download the binaries** from the release page. ğŸ“¥

## ğŸš€ Features

The latest version of **binlex** provides the following amazing features!

| Feature                         | Description                                                                                     |
|---------------------------------|-------------------------------------------------------------------------------------------------|
| ğŸŒ **Platforms**   | - Windows ğŸªŸ<br>- MacOS ğŸ<br>- Linux ğŸ§                                                    |
| ğŸŒ **Formats**   | - PE <br>- MachO <br>- ELF                                                  |
| ğŸŒ **Architectures**   | - AMD64 <br>- I386<br> - CIL                                               |
| ğŸ§µ **Multi-Threading**          | - ğŸ”’ Thread-Safe Disassembler Queuing<br>- ğŸš„ Multi-Threaded Tooling for Maximum Efficiency      |
| âš™ï¸ **Customizable Performance** | Toggle features on/off to optimize for your use case                                           |
| ğŸ“‰ **JSON String Compression**  | Save memory with JSON compression                                                    |
| ğŸ§© **Similarity Hashing**       | - ğŸ” Minhash<br>- ğŸ”’ TLSH<br>- ğŸ” SHA256                                                        |
| ğŸ§© **Function Symbols**         | - Pass function symbols to **binlex** as standard input using **blpdb**, **blelfsym** or **blmachosym** or your own tooling                        |
| ğŸ·ï¸ **Tagging**                  | Tagging for easy organization                                                                  |
| ğŸ¯ **Wildcarding** | Perfect for generating YARA rules and now at a resolution of nibbles!                                                     |
| **API** | - ğŸ¦€ Rust API<br>-Python API                                                         |
| ğŸ¤– **Machine Learning Features** | - ğŸ“Š Normalized Features<br>- ğŸ” Vector Database<br>- ğŸ“š Jupyter Notebook<br>- ğŸ§  Function Identification |
| ğŸ“‚ **Virtual Imaging** | - Efficient mapping cache for virtual images<br>- ğŸ—„ï¸ Compatible with ZFS / BTRFS<br>- Speeds up repetitive tasks and filtering<br>- Lightening speed âš¡ |

By caching virtual images, **binlex** is able to perform at better speeds, making repeat runs faster and more efficient.

## Building

To build **binlex** you need Rust.

### Linux, MacOS and Windows

Installation is straight foward on Linux and MacOS.

```bash
cargo build --release
```

### Python Bindings
```bash
cd src/bindings/python/
virtualenv -p python3 venv/
source venv/bin/activate
pip install maturin[patchelf]
maturin develop
python
>> import binlex
```

### Packaging

To build packages for various platforms use the `Makefile`.

```bash
make zst   # Make Arch Linux Package
make deb   # Make Debian Package
make wheel # Make Python Wheel
```

The resulting packages will be in the `target/` directory.

### IDA Plugin

Installing the IDA plugin is easy to install, just make sure you installed the Python bindings in the Python environment for IDA.

Now copy the directory for the **binlex** plugin to your plugin directory.

```bash
mkdir -p ~/.idapro/plugins/
cp -r scripts/plugins/ida/binlex/ ~/.idapro/plugins/
cd ~/.idaapro/plugins/binlex/
pip install -r requirements.txt
```

You will also need to ensure the server is running, GPU hardware is recommended for faster GNN inference but not required.

```bash
cd scripts/blserver/
make -C configs/
docker-compose up -d
```

Once completed the following services will be available.


| **Service Name**             | **Description**                             | **URL**                                 |
|------------------------------|---------------------------------------------|-----------------------------------------|
| Binlex Server                | API Documentation                           | `https://127.0.0.1/swagger`             |
| Attu Milvus Vector Database  | Attu Milvus Vector Database UI              | `https://127.0.0.1:8443`                |
| MinIO                        | MinIO Object Store                          | `https://127.0.0.1:7443`                |
| JupyterHub                   | JupyterHub Web GUI                          | `https://127.0.0.1:6443`                |


The default API key is `39248239c8ed937d6333a41874f1c8e310c5070703af30c06e67b0d308cb82c5`, which you can use with your IDA plugin.

Once you open IDA, you should be greeted with the **binlex** welcome message.

<p align="center">
  <img src="assets/ida.png" alt="Binlex IDA Plugin" width="500"/>
</p>

Using the IDA plugin you have various features that are provided to help you with YARA rule writing and similarity analysis.

**Main Menu:**
- Export Database (Export to JSON)
- Index Database
- Search Database (Search and Apply Function Names)
- Functions (Functions Table)
- Export Byte Color Map (Save Byte ColorMap to SVG)
- JSON Query (jq queries inside IDA)

**Disassembler Context Menu:**
- Copy YARA Pattern
- Copy Hex
- Copy MinHash from Selection
- Copy TLSH from Selection
- Scan for MinHash
- Scan for TLSH

Once you set your API key and URL, it is saved in the IDA registry and auto-completed for you in the future.

The copy pattern and copy hex feature is intended to help with YARA rules and the copying of similarity hashes and scanning is for hunting for similar data.

To ensure your database can be accessed by others using the same server click `Index Database`, which pushes the function data to the server.

To find function names, click `Search Database`, which will populate a table once completed of best matches from the vector databaase you can then apply to your project.

### Documentation

```bash
cargo doc
```

You can also open the docs.

```bash
cargo doc --open
```

## Binary Genomes, Chromosomes, Allele Pairs and Genes

In **binlex**, a hierarchy of genetic-inspired terms is used to describe and symbolize the structure and traits of binary code. This terminology reflects the relationships between different abstractions and their genetic analogies:

- **Genome**: Represents the each object being analyzed, such as a function or block. It encapsulates all the information, including metadata, chromosomes, and other attributes.

- **Chromosome**: Represents the core patterns or sequences extracted from a block or function. A chromosome acts as the blueprint for identifying key characteristics of the binary without memory addressing as indicated by wildcards like `?`, where a single wildcard represents a single gene.

- **AllelePair**: A unit within the chromosome consisting of **two genes**. Allele pairs are the building blocks of the chromosome, combining genes into meaningful pairs.

- **Gene**: The smallest unit of genetic information, representing a single nibble of data (half a byte).

The relationship between these abstractions can be visualized as follows:

```text
Genome (function / block)
 â””â”€â”€ Chromosome (pattern / sequence)
      â””â”€â”€ AllelePair (two genes / single byte / two nibbles)
           â””â”€â”€ Gene (single nibble)
```

### Genome Example

```JSON
{
  "type": "block",
  "architecture": "amd64",
  "address": 6442934577,
  "next": null,
  "to": [],
  "edges": 0,
  "prologue": false,
  "conditional": false,
  "chromosome": {
    "pattern": "4c8b47??498bc0",
    "feature": [4,12,8,11,4,7,4,9,8,11,12,0],
    "entropy": 2.2516291673878226,
    "sha256": "1f227bf409b0d9fbc576e747de70139a48e42edec60a18fe1e6efdacb598f551",
    "minhash": "09b8b1ad1142924519f601854444c6c904a3063942cda4da445721dd0703f290208f3e32451bf5d52741e381a13f12f9142b5de21828a00b2cf90cf77948aac4138443c60bf77ec31199247042694ebb2e4e14a41369eddc7d9f84351be34bcf61458425383a03a55f80cbad420bb6e638550c15876fd0c6208da7b50816847e62d72b2c13a896f4849aa6a36188be1d4a5333865eab570e3939fab1359cbd16758f36fa290164d0259f83c07333df535b2e38f148298db255ac05612cae04d60bb0dd810a91b80a7df9615381e9dc242969dd052691d044287ac2992f9092fa0a75d970100d48362f62b58f7f1d9ec594babdf52f58180c30f4cfca142e76bf",
    "tlsh": null
  },
  "size": 7,
  "bytes": "4c8b4708498bc0",
  "functions": {},
  "number_of_instructions": 3,
  "entropy": 2.5216406363433186,
  "sha256": "84d4485bfd833565fdf41be46c1a499c859f0a5f04c8c99ea9c34404729fd999",
  "minhash": "20c995de6a15c8a524fa7e325a6e42b217b636ab03b00812732f877f4739eeee41d7dde92ceac73525e541f9091d8dc928f6425b84a6f44b3f01d17912ec6e8c6f913a760229f685088d2528447e40c768c06d680afe63cb219a1b77a097f679122804dd5a1b9d990aa2579e75f8ef201eeb20d5650da5660efa3a281983a37f28004f9f2a57af8f81728c7d1b02949609c7ad5a30125ff836d8cc3106f2531f306e679a11cabf992556802a3cb2a75a7fe3773e37e3d5ab107a23bf22754aee15a5f41056859b06120f86cb5d39071425855ec90628687741aa0402030d73e04bc60adb0bd2430560442c4309ae258517fc1605438c95485ac4c8621026a1bb",
  "tlsh": null,
  "contiguous": true,
  "attributes": [
    {
      "type": "tag",
      "value": "corpus:malware"
    },
    {
      "type": "tag",
      "value": "malware:lummastealer"
    },
    {
      "entropy": 6.55061550644311,
      "sha256": "ec1426109420445df8e9799ac21a4c13364dc12229fb16197e428803bece1140",
      "size": 725696,
      "tlsh": "T17AF48C12AF990595E9BBC23DD1974637FAB2B445232047CF426489BD0E1BBE4B73E381",
      "type": "file"
    }
  ]
}
```

Given this JSON genome example.
- **Genome**: The JSON object describing the block, including its metadata, chromosome, and attributes.
- **Chromosome**: as described by the pattern `"4c8b47??498bc0"`
- **AllelePair**: `"4c"` or `"8b"`
- **Gene**: `"4"` or `"c"`

Using the **binlex** API it is possible to mutate these chromosomes, their allele pairs and genes to facilitate genetic programming.

Genetic programming in this context can have several benifits including but not limited to:
- Hunting for novel samples given a dataset
- YARA rule generation

## Command-Line

The simplest way to get started is with the command-line, leveraging a JSON filtering tool like `jq`.

The following command disassembles `sample.dll` with `16` threads, the relevant traits are JSON objects, one per line and are piped into `jq` for filtering and beautifying.

To see what options are available when using the **binlex** command-line use `-h` or `--help`.

```bash
A Binary Pattern Lexer

Version: 2.0.0

Usage: binlex [OPTIONS] --input <INPUT>

Options:
  -i, --input <INPUT>
  -o, --output <OUTPUT>
  -a, --architecture <ARCHITECTURE>      [amd64, i386, cil]
  -c, --config <CONFIG>
  -t, --threads <THREADS>
      --tags <TAGS>
      --minimal
  -d, --debug
      --enable-instructions
      --enable-block-instructions
      --disable-hashing
      --disable-disassembler-sweep
      --disable-heuristics
      --enable-mmap-cache
      --mmap-directory <MMAP_DIRECTORY>
  -h, --help                             Print help
  -V, --version                          Print version

Author: @c3rb3ru5d3d53c
```

A simple example of using the command-line is provided below.

```bash
binlex -i sample.dll --threads 16 | jq
```

Please note that **binlex** will detect the file format fort you and currently supports `PE`, `ELF` and `MACHO` binary formats.

### Configuration

Upon your first execution of **binlex** it will store the configuration file in your configuration directory in `binlex/binlex.toml`.

This **binlex** finds the default configuration directory based on your operating system as indicated in the table below for its configuration.

| OS       | Environment Variable                  | Example Binlex Configuration Path                              |
|----------|---------------------------------------|----------------------------------------------------------------|
| Linux    | `$XDG_CONFIG_HOME` or `$HOME/.config` | `/home/alice/.config/binlex/binlex.toml`                       |
| macOS    | `$HOME/Library/Application Support`   | `/Users/Alice/Library/Application Support/binlex/binlex.toml`  |
| Windows  | `{FOLDERID_RoamingAppData}`           | `C:\Users\Alice\AppData\Roaming\binlex\binlex.toml`            |

The default configuration name `binlex.toml` for **binlex** is provided below.

```toml
[general]
threads = 16
minimal = false
debug = false

[formats.file.hashing.sha256]
enabled = true

[formats.file.hashing.tlsh]
enabled = true
minimum_byte_size = 50
threshold = 200

[formats.file.hashing.minhash]
enabled = true
number_of_hashes = 64
shingle_size = 4
maximum_byte_size_enabled = false
maximum_byte_size = 50
seed = 0
threshold = 0.75

[formats.file.heuristics.features]
enabled = true

[formats.file.heuristics.entropy]
enabled = true

[instructions]
enabled = false

[instructions.hashing.sha256]
enabled = true

[instructions.hashing.tlsh]
enabled = true
minimum_byte_size = 50
threshold = 200

[instructions.hashing.minhash]
enabled = true
number_of_hashes = 64
shingle_size = 4
maximum_byte_size_enabled = false
maximum_byte_size = 50
seed = 0
threshold = 0.75

[instructions.heuristics.features]
enabled = true

[instructions.heuristics.entropy]
enabled = true

[blocks]
enabled = true

[blocks.instructions]
enabled = false

[blocks.hashing.sha256]
enabled = true

[blocks.hashing.tlsh]
enabled = true
minimum_byte_size = 50
threshold = 200

[blocks.hashing.minhash]
enabled = true
number_of_hashes = 64
shingle_size = 4
maximum_byte_size_enabled = false
maximum_byte_size = 50
seed = 0
threshold = 0.75

[blocks.heuristics.features]
enabled = true

[blocks.heuristics.entropy]
enabled = true

[functions]
enabled = true

[functions.blocks]
enabled = true

[functions.hashing.sha256]
enabled = true

[functions.hashing.tlsh]
enabled = true
minimum_byte_size = 50
threshold = 200

[functions.hashing.minhash]
enabled = true
number_of_hashes = 64
shingle_size = 4
maximum_byte_size_enabled = false
maximum_byte_size = 50
seed = 0
threshold = 0.75

[functions.heuristics.features]
enabled = true

[functions.heuristics.entropy]
enabled = true

[chromosomes.hashing.sha256]
enabled = true

[chromosomes.hashing.tlsh]
enabled = true
minimum_byte_size = 50
threshold = 200

[chromosomes.hashing.minhash]
enabled = true
number_of_hashes = 64
shingle_size = 4
maximum_byte_size_enabled = false
maximum_byte_size = 50
seed = 0
threshold = 0.75

[chromosomes.heuristics.features]
enabled = true

[chromosomes.heuristics.entropy]
enabled = true

[chromosomes.homologues]
enabled = true
maximum = 4

[mmap]
directory = "/tmp/binlex"

[mmap.cache]
enabled = false

[disassembler.sweep]
enabled = true
```

If the command-line options are not enough the configuration file provides the most granular control of all options.

If you wish to override the default configuration file and specify another configuration file use the command-line parameter.

```bash
binlex -c config.toml -i sample.dll
```

When you run **binlex**, it uses the configuration file and overrides any settings when the respective command-line parameter is used.

### Making a YARA Rule

Here is a general workflow getting started with making YARA rules, where we get 10 unique wildcarded YARA hex strings from a given sample.

```bash
binlex -i sample.dll --threads 16 | jq -r 'select(.size >= 16 and .size <= 32 and .chromosome.pattern != null) | .chromosome.pattern' | sort | uniq | head -10
016b??8b4b??8bc74c6bd858433b4c0b2c0f83c5??????
01835404????c6836a0400????837e04??
03c04c8d05????????4863c8420fb60401460fb64401018942??85c074??
03c38bf0488d140033c9ff15????????488bd84885c075??
03c6488d55??41ffc58945a?41b804000000418bcce8b8fd01??eb??
03c6488d55??41ffc58945a?41b804000000418bcce8e3fb01??eb??
03f7488d05????????4883c310483bd87c??
03fb4c8bc6498bd7498bcc448d0c7d04000000e89409????8bd84885f6
03fe448bc6488bd3418bcee8d8e501??85ed
03fe897c24??397c24??0f867301????
```

After sending the patterns to `uniq`, you can also send them through this `awk` command to collapse blocks and functions into single patterns.

```bash
awk 'NR==1{n=length($0);first=$0;delete v;split(tolower($0),v,"");cnt=1;next}{L=length($0);if(L==n){split(tolower($0),b,"");for(i=1;i<=n;i++){c=b[i];if(c=="?"){v[i]="?";next}if(!(i in v)||v[i]==""){v[i]=c}else if(v[i]!="?"&&v[i]!=c){v[i]="?"}};cnt++}else{if(cnt==1)print first;else{out="";for(i=1;i<=n;i++)out=out (i in v?v[i]:"?");print out};n=L;first=$0;delete v;split(tolower($0),v,"");cnt=1}}END{if(NR){if(cnt==1)print first;else{out="";for(i=1;i<=n;i++)out=out (i in v?v[i]:"?");print out}}}'
```

This takes output like the following:
```text
4883ec??ff15????????85c079??8bc84883c4??48ff25????????33c04883c4??c3
4883ec??ff15????????85c079??8bc8e80b2cfd??33c0eb??b8010000004883c4??c3
4883ec??ff15????????85c079??8bc8e82bbafb??33c0eb??b8010000004883c4??c3
4883ec??ff15????????85c079??8bc8e83b29fd??33c0eb??b8010000004883c4??c3
4883ec??ff15????????85c079??8bc8e87b93fd??33c0eb??b8010000004883c4??c3
4883ec??ff15????????85c079??8bc8e8ab93fd??33c0eb??b8010000004883c4??c3
4883ec??ff15????????85c079??8bc8ff15????????33c0eb??b8010000004883c4??c3
```

And merges patterns of the same length:

```text
4883ec??ff15????????85c079??8bc84883c4??48ff25????????33c04883c4??c3
4883ec??ff15????????85c079??8bc8e80b2cfd??33c0eb??b8010000004883c4??c3
4883ec??ff15????????85c079??8bc8ff15????????33c0eb??b8010000004883c4??c3
```

To take this a step further you can run it through the `blyara` tool to make a quick YARA signature.

```bash
binlex -i sample.dll --threads 16 | jq -r 'select(.size >= 16 and .size <= 32 and .chromosome.pattern != null) | .chromosome.pattern' | sort | uniq | head -10 | blyara -n example
rule example {
    strings:
        $trait_0 = {016b??8b4b??8bc74c6bd858433b4c0b2c0f83c5??????}
        $trait_1 = {01835404????c6836a0400????837e04??}
        $trait_2 = {03c04c8d05????????4863c8420fb60401460fb64401018942??85c074??}
        $trait_3 = {03c38bf0488d140033c9ff15????????488bd84885c075??}
        $trait_4 = {03c6488d55??41ffc58945a?41b804000000418bcce8b8fd01??eb??}
        $trait_5 = {03c6488d55??41ffc58945a?41b804000000418bcce8e3fb01??eb??}
        $trait_6 = {03f7488d05????????4883c310483bd87c??}
        $trait_7 = {03fb4c8bc6498bd7498bcc448d0c7d04000000e89409????8bd84885f6}
        $trait_8 = {03fe448bc6488bd3418bcee8d8e501??85ed}
        $trait_9 = {03fe897c24??397c24??0f867301????}
    condition:
        1 of them
```

For even better results if you exported the **genomes** using the **binlex** IDA plugin or by other means you can filter for function starting prefixes like `mw::`, for `malware`, which is pretty common.

```bash
cat dump.json | jq -r 'select(.type == "function" and .size > 32 and (.attributes[] | .type == "symbol" and (.name | startswith("mw::")))) | .blocks[] | select(.size > 32) | .chromosome.pattern' | blyara -n example
```

### Using Ghidra with Binlex

To use **binlex** with ghidra use the `blghidra/blghidra.py` script in the scripts directory.

To leverage function names and virtual addresses from your `Ghidra` projects and provide them to **binlex** use the `analyzeHeadless` script in your `Ghidra` install directory.

```bash
./analyzeHeadless \
  <project-directory> \
  <project-name> \
  -process sample.dll \
  -noanalysis \
  -postscript blghidra.py 2>/dev/null |  grep -P "^{\"type" | binlex -i sample.dll
```

Please note that `analyzeHeadless` prints log messages to `stdout` and other log output to `stderr` that is of no use interoperability with other command-line utilities.

As such, to collect the output of the script it must be filtered with `2>/dev/null |  grep -P "^{\"type"`.

### Using Rizin with Binlex

To leverage the power of Rizin function detection and function naming in **binlex**, run `rizin` on your project using `aflj` to list the functions in JSON format.

Then pipe this output to `blrizin`, which parses `rizin` JSON to a format **binlex** undestands.

Additionally, you can combine this with other tools like `blpdb` to parse PDB symbols to get function addresses and names.

You can then do any parsing as you generally would using `jq`, in this example we count the functions processed by **binlex** to see if we are detecting more of them.

```bash
rizin -c 'aaa;aflj;' -q sample.dll | \
  blrizin | \
  blpdb -i sample.pdb | \
  binlex -i sample.dll | \
  jq 'select(.type == "function") | .address' | wc -l
```

**NOTE**: At this time `blrizin` is also compatiable with the output from `radare2` using `blrizin`.

### Collecting Machine Learning Features

If you are would like to do some machine learning, you can get features representing the nibbles without memory addressing from binlex like this.

```bash
binlex -i sample.dll --threads 16 | jq -r -c 'select(.size >= 16 and .size <= 32 and .signature.feature != null)| .signature.feature' | head -10
[4,9,8,11,12,0,4,1,11,9,0,3,0,0,1,15,0,0,4,5,3,3,12,0,8,5,13,2,4,8,8,11,13,0,4,1,0,15,9,5,12,0,4,8,15,15,2,5]
[4,4,8,11,5,1,4,5,3,3,12,0,3,3,12,0,4,8,8,3,12,1,3,0,4,1,0,15,10,3,12,2]
[4,8,8,3,14,12,4,12,8,11,12,10,4,4,8,9,4,4,2,4,11,2,0,1,4,4,0,15,11,7,12,1,8,10,12,10,14,8,5,11,4,8,8,3,12,4,12,3]
[4,8,8,3,14,12,4,4,8,9,4,4,2,4,4,12,8,11,12,10,4,4,0,15,11,7,12,1,11,2,0,1,3,3,12,9,14,8,0,11,4,8,8,3,12,4,12,3]
[4,0,5,3,4,8,8,3,14,12,15,15,1,5,8,11,12,8,8,11,13,8,15,15,1,5,8,11,12,3,4,8,8,3,12,4,5,11,12,3]
[11,9,2,0,0,3,15,14,7,15,4,8,8,11,8,11,0,4,2,5,4,8,0,15,10,15,12,1,4,8,12,1,14,8,1,8,12,3]
[8,11,0,12,2,5,11,8,2,0,0,3,15,14,7,15,4,8,12,1,14,1,2,0,4,8,8,11,4,8,12,1,14,0,0,8,4,8,15,7,14,1,4,8,8,11,12,2,12,3]
[4,8,8,11,0,5,4,8,8,5,12,0,7,5,12,3,4,8,15,15,2,5]
[4,8,8,11,0,13,3,3,12,0,3,8,8,1,11,0,0,8,0,15,9,5,12,0,12,3]
[4,8,8,11,0,5,4,8,8,5,12,0,7,5,12,3,4,8,15,15,2,5]
```

If you would like to refine this for your machine learning model by normalizing them between 0 and 1 float values binlex has you covered with the `blscaler` tool.

```bash
binlex -i sample.dll --threads 16 | jq -r -c 'select(.size >= 16 and .size <= 32 and .signature.feature != null)' | blscaler --threads 16 | jq -c -r '.signature.feature' | head -1
[0.26666666666666666,0.6,0.5333333333333333,0.7333333333333333,0.8,0.0,0.26666666666666666,0.06666666666666667,0.7333333333333333,0.6,0.0,0.2,0.0,0.0,0.06666666666666667,1.0,0.0,0.0,0.26666666666666666,0.3333333333333333,0.2,0.2,0.8,0.0,0.5333333333333333,0.3333333333333333,0.8666666666666667,0.13333333333333333,0.26666666666666666,0.5333333333333333,0.5333333333333333,0.7333333333333333,0.8666666666666667,0.0,0.26666666666666666,0.06666666666666667,0.0,1.0,0.6,0.3333333333333333,0.8,0.0,0.26666666666666666,0.5333333333333333,1.0,1.0,0.13333333333333333,0.3333333333333333]
```

### Virtual Image File Mapping Cache with Compression
To leverage the powerful feature of filemapping to reduce memory usage but still benifit from virtual images.

```bash
# Install BTRFS
sudo pacman -S btrfs-progs compsize
# Enable the Kernel Module on Boot
echo "btrfs" | sudo tee /etc/modules-load.d/btrfs.conf
# Reboot
reboot
# Create Virtual Image Cache Storage Pool
dd if=/dev/zero of=btrfs.img bs=1M count=2048
# Make it BTRFS
mkfs.btrfs btrfs.img
# Make a Cache Directory in /tmp/
mkdir -p /tmp/binlex/
# Mount the Cache (Multiple Compression Options Available)
sudo mount -o compress=lzo btrfs.img /tmp/binlex/
# Run Binlex
binlex -i sample.dll --threads 16 --enable-file-mapping --file-mapping-directory /tmp/binlex/ --enable-file-mapping-cache
sudo compsize ec1426109420445df8e9799ac21a4c13364dc12229fb16197e428803bece1140
# Virtual Image 6GB vs Stored Size of 192MB
# Processed 1 file, 49156 regular extents (49156 refs), 0 inline.
# Type       Perc     Disk Usage   Uncompressed Referenced
# TOTAL        3%      192M         6.0G         6.0G
# none       100%      384K         384K         384K
# lzo          3%      192M         6.0G         6.0G
```

This can set this up to be on disk or if `/tmp/` directory is mapped to RAM.

When mapped to RAM, we are taking advantage of virtual image disassembling but without the additional RAM penalty where repetitive tasks almost double in processing speed.

Since `btrfs` abstracts the access to the mapped file in kernel we are able to access it as we would any mapped file but with the benefit of compression.

To save yourself time if you choose this option, make the mounting of the `btrfs` pool happen on boot and have your **binlex** configuration file set to prefer virtual image caching in the mounted pool directory. This approach ensures that you need not rely on the command-line parameters each time.

## Binlex API

The philophsy of the **binlex** project is focused on security, simplicity, speed and extendability.

Part of this is providing an API for developers to write their own detection and hunting logic.

At this time, **binlex** provides both Rust and Python bindings.

### Rust API

The Rust, API makes is easy to get started

#### Native PE

```rs
use std::process;
use binlex::Config;
use binlex::formats::PE;
use binlex::disassemblers::capstone::Disassembler;
use binlex::controlflow::Graph;

// Get Default Configuration
let mut config = Config();

// Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16;

// Read PE File
let pe = PE.new("./sample.dll", config)
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1);
  });

// To check if DotNet PE use pe.is_dotnet()

// Get Memory Mapped File
let mapped_file = pe.image()
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1)
  });

// Get Mapped File Virtual Image
let image = mapped_file
  .mmap()
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1);
  });

// Create Disassembler
let disassembler = Disassembler(pe.architecture(), &image, pe.executable_virtual_address_ranges(), config)
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1);
  });

// Create Control Flow Graph
let cfg = Graph(pe.architecture(), config);

// Disassemble Control Flow
disassembler.disassemble_controlflow(pe.entrypoint_virtual_addresses(), &mut cfg);
```

#### .NET (MSIL/CIL) PE

```rs
use std::process;
use binlex::Config;
use binlex::formats::PE;
use binlex::disassemblers::custom::cil::Disassembler;
use binlex::controlflow::Graph;

// Get Default Configuration
let mut config = Config();

// Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16;

// Read PE File
let pe = PE.new("./sample.exe", config)
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1);
  });

// To check if DotNet PE use pe.is_dotnet()

// Get Memory Mapped File
let mapped_file = pe.image()
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1)
  });

// Get Mapped File Virtual Image
let image = mapped_file
  .mmap()
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1);
  });

// Create Disassembler
let disassembler = Disassembler(pe.architecture(), &image, pe.dotnet_metadata_token_virtual_addresses(), pe.dotnet_executable_virtual_address_ranges(), config)
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1);
  });

// Create Control Flow Graph
let cfg = Graph(pe.architecture(), config);

// Disassemble Control Flow
disassembler.disassemble_controlflow(pe.dotnet_entrypoint_virtual_addresses(), &mut cfg);
```

#### ELF

```rs
use std::process;
use binlex::Config;
use binlex::formats::ELF;
use binlex::disassemblers::custom::cil::Disassembler;
use binlex::controlflow::Graph;

// Get Default Configuration
let mut config = Config();

// Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16;

// Read PE File
let elf = ELF.new("./sample.exe", config)
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1);
  });

// Get Memory Mapped File
let mapped_file = elf.image()
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1)
  });

// Get Mapped File Virtual Image
let image = mapped_file
  .mmap()
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1);
  });

// Create Disassembler
let disassembler = Disassembler(elf.architecture(), &image, elf.executable_virtual_address_ranges(), config)
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1);
  });

// Create Control Flow Graph
let cfg = Graph(elf.architecture(), config);

// Disassemble Control Flow
disassembler.disassemble_controlflow(elf.entrypoint_virtual_addresses(), &mut cfg);
```

#### MACHO

```rs
use std::process;
use binlex::Config;
use binlex::formats::MACHO;
use binlex::disassemblers::custom::cil::Disassembler;
use binlex::controlflow::Graph;

// Get Default Configuration
let mut config = Config();

// Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16;

// Read PE File
let macho = MACHO.new("./sample.app", config)
  .unwrap_or_else(|error| {
    eprintln!("{}", error);
    process::exit(1);
  });

// Iterate the MACHO Fat Binary Slices
for index in macho.number_of_slices() {
  // Get Memory Mapped File
  let mapped_file = macho.image(index)
    .unwrap_or_else(|error| {
      eprintln!("{}", error);
      process::exit(1)
    });

  // Get Mapped File Virtual Image
  let image = mapped_file
    .mmap()
    .unwrap_or_else(|error| {
      eprintln!("{}", error);
      process::exit(1);
    });

  // Create Disassembler
  let disassembler = Disassembler(macho.architecture(index), &image, macho.executable_virtual_address_ranges(index), config)
    .unwrap_or_else(|error| {
      eprintln!("{}", error);
      process::exit(1);
    });

  // Create Control Flow Graph
  let cfg = Graph(macho.architecture(index), config);

  // Disassemble Control Flow
  disassembler.disassemble_controlflow(macho.entrypoints(index), &mut cfg);
}

```

#### Accessing Genetic Traits

```rs
use binlex::controlflow::Instruction;
use binlex::controlflow::Block;
use binlex::controlflow::Function;

for address in cfg.instructions.valid_addresses() {
  // Read Instruction from Control Flow
  instruction = Instruction(address, &cfg);

  // Print Instruction from Control Flow
  instruction.print();
}

for address in cfg.blocks.valid_addresses() {
  // Read Block from Control Flow
  block = Block(address, &cfg);

  // Print Block from Control Flow
  block.print();
}

for address in cfg.functions.valid_addresses() {
  // Read Function from Control Flow
  function = Function(address, &cfg);

  // Print Function from Control Flow
  function.print();
}
```

### Python API

The binlex Python API is now designed to abstract the disassembler and the controlflow graph.

To disassemble a PE memory mapped image use the following examples.

There are more examples in the `examples/python/` directory.


### IDA Pro Headless Python

It is now possible to leverage IDA's disassembler in headless mode as well.

```python
import json
from binlex import Config
from binlex.controlflow import Graph, Function
from binlex.disassemblers.ida import IDA, Disassembler

config = Config()

ida = IDA()

ida.open_database('sample.i64', run_auto_analysis=False)

image = ida.image()

cfg = Graph(ida.architecture(), config)

disassembler = Disassembler(
    ida.architecture(),
    image.mmap(), {0: image.size()},
    config
)

disassembler.disassemble_controlflow(cfg)

for address in cfg.queue_functions.valid_addresses():
    function = Function(address, cfg)
    function = function.to_dict()
    function['attributes'] = ida.attributes(address)
    print(json.dumps(function))

ida.close_database()
```

#### Native PE

```python
from binlex.formats import PE
from binlex.disassemblers.capstone.x86 import Disassembler
from binlex.controlflow import Graph
from binlex import Config

# Get Default Configuration
config = Config()

# Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16

# Open the PE File
pe = PE('./sample.exe', config)

# To check if a DotNet PE use ps.is_dotnet()

# Get the Memory Mapped File
mapped_file = pe.image()

# Get the Memory Map
image = mapped_file.mmap()

# Create Disassembler on Mapped PE Image and PE Architecture
disassembler = Disassembler(pe.architecture(), image, pe.executable_virtual_address_ranges(), config)

# Create the Controlflow Graph
cfg = Graph(pe.architecture(), config)

# Disassemble the PE Image Entrypoints Recursively
disassembler.disassemble_controlflow(pe.entrypoint_virtual_addresses(), cfg)
```

#### .NET (MSIL/CIL) PE
```python
from binlex.formats import PE
from binlex.disassemblers.custom.cil import Disassembler
from binlex.controlflow import Graph
from binlex import Config


# Get Default Configuration
config = Config()

# Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16

# Open the PE File
pe = PE('./sample.exe', config)

# To check if a DotNet PE use ps.is_dotnet()

# Get the Memory Mapped File
mapped_file = pe.image()

# Get the Memory Map
image = mapped_file.mmap()

# Create Disassembler on Mapped PE Image and PE Architecture
disassembler = Disassembler(pe.architecture(), image, pe.dotnet_metadata_token_virtual_addresses(), pe.dotnet_executable_virtual_address_ranges(), config)

# Create the Controlflow Graph
cfg = Graph(pe.architecture(), config)

# Disassemble the PE Image Entrypoints Recursively
disassembler.disassemble_controlflow(pe.dotnet_entrypoint_virtual_addresses(), cfg)
```

#### ELF

```python
from binlex.formats import ELF
from binlex.disassemblers.capstone.x86 import Disassembler
from binlex.controlflow import Graph
from binlex import Config

# Get Default Configuration
config = Config()

# Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16

# Open the ELF File
elf = ELF('./sample.so', config)

# Get the Memory Mapped File
mapped_file = pe.image()

# Get the Memory Map
image = mapped_file.mmap()

# Create Disassembler on Mapped ELF Image and ELF Architecture
disassembler = Disassembler(elf.architecture(), image, elf.executable_virtual_address_ranges(), config)

# Create the Controlflow Graph
cfg = Graph(elf.architecture(), config)

# Disassemble the PE Image Entrypoints Recursively
disassembler.disassemble_controlflow(elf.entrypoint_virtual_addresses(), cfg)
```

#### MACHO

```python
from binlex.formats import MACHO
from binlex.disassemblers.capstone.x86 import Disassembler
from binlex.controlflow import Graph
from binlex import Config

# Get Default Configuration
config = Config()

# Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16

# Open the ELF File
macho = MACHO('./sample.app', config)

# MachO Fat Binary Can Support Multiple Architectures
for index in macho.number_of_slices():

  # Get the Memory Mapped File
  mapped_file = macho.image(index)

  # Get the Memory Map
  image = mapped_file.mmap()

  # Create Disassembler on Mapped MACHO Image and MACHO Architecture
  disassembler = Disassembler(macho.architecture(index), image, macho.executable_virtual_address_ranges(index), config)

  # Create the Controlflow Graph
  cfg = Graph(macho.architecture(index), config)

  # Disassemble the MACHO Image Entrypoints Recursively
  disassembler.disassemble_controlflow(macho.entrypoints(index), cfg)
```

#### Parsing the Controlflow Graph

Sometimes it maybe nessassary to parse the controlflow graph generated.

In this case, you can use the following technique.

```python
from binlex.controlflow import Instruction
from binlex.controlflow import Block
from binlex.controlflow import Function

# Iterate Valid Instructions
for address in cfg.queue_instructions.valid_addresses():
  # Read Instruction from Control Flow
  instruction = Instruction(address, cfg)
  # Print Instruction from Control Flow
  instruction.print()

# Iterate Valid Blocks
for address in cfg.queue_blocks.valid_addresses():
  # Read Block from Control Flow
  block = Block(address, cfg)
  # Print Block from Control Flow
  block.print()

# Iterate Valid Functions
for address in cfg.queue_functions.valid_addresses():
  # Read Function from Control Flow
  function = Function(address, cfg)
  # Print Function from Control Flow
  function.print()
```

#### Iterating Controlflow Instructions, Blocks, and Functions

Instead of parsing you can access the instructions, blocks, and functions more directly.

```python
for instruction in cfg.instructions():
  instruction.print()

for block in cfg.blocks():
  block.print()

for function in cfg.functions():
  function.print()
```

#### Iterating from Functions to Instructions

It is also possible to iterate from functions to blocks, to instructions, to allele pairs, to genes.

This represents going from the highest level abstraction to the lowest abstraction.

```python
for function in cfg.functions():
    for block in function.blocks():
        for instruction in block.instructions():
            for allelepair in instruction.chromosome().allelepairs():
                for gene in allelepair.genes():
                    print(gene)
```

#### Comparing Function Similarity

One of the most powerful tools you can use in **binlex** is to compare functions, blocks, and instructions using similarity hashing.

To perform these comparisons is as simple as calling the `compare` method.

```python
for lhs in lhs_cfg.functions():
  for rhs in rhs_cfg.functions():
    similarity = lhs.compare(rhs)
    similarity.print()

for lhs in lhs_cfg.blocks():
  for rhs in rhs_cfg.blocks():
    similarity = lhs.compare(rhs)
    similarity.print()

for lhs in lhs_cfg.instructions():
  for rhs in rhs_cfg.instructions():
    similarity = lhs.compare(rhs)
    similarity.print()
```

Any supported similarity hashing algorithms will be calcualted if they are enabled with your configuration.

Although it can be challenging, **binlex** supports performing similarity analysis on non-contiguous functions using its own algorithm to find the best similarity matches.

At least 75% or more of a non-contiguous function's data must be hashable to yield a similarity hash.

#### Accessing Genetic Properties

Each instruction, block and function or **genome** has an associated chromosome which can be accessed via the API.

You can follow these abstractions down to allele pairs, and their respective genes.

```python
# Iterate Block Chromosome
chromosome = block.chromosome()
for allelepair in chromosome.allelepairs():
  for gene in allelepair.genes()
    gene.print()

# Iterate Block Chromosome
chromosome = function.chromosome()
for allelepair in chromosome.allelepairs():
  for gene in allelepair.genes()
    gene.print()

# Iterate Block Chromosome
chromosome = function.chromosome()
for allelepair in chromosome.allelepairs():
  for gene in allelepair.genes()
    gene.print()
```

#### Performing Genetic Mutations

If you are looking to perform genetic programming tasks you can also mutate chromosomes, allelepairs, and genes and they keep track of their own number of mutations.

```python
chromosome = block.chromosome()
chromosome.mutate('deadbe?f')
chromosome.number_of_mutations()
chromosome.print()

for allelepair in chromosome.allelepairs():
  allelepair.mutate('dead')
  allelepair.number_of_mutations()
  allelepair.print()
  for gene in allelepair.genes():
    gene.mutate('d')
    gene.number_of_mutations()
    gene.print()
```

This facilitates mutations with genetic algorithms you may with to employ for your usecases.

## Citation

If you are using **binlex** in a journal publication, or an open-source AI model use the following citation.

```bibtex
@misc{binlex,
  author = {c3rb3ru5d3d53c},
  title = {binlex: A Binary Genetic Trait Lexer Framework},
  year = {2025},
  note = {Available at \url{https://github.com/c3rb3ru5d3d53c/binlex}}
}
```

If the use of **binlex** is for corporate, personal purposes, or for generating outputs that are not open-source AI models, no citation is needed.

For example, if you use **binlex** to create YARA rules, no citation is needed.

This ensures that **binlex** stays relevant but also ensures permissive corporate and personal use.

```

`SECURITY.md`:

```md
# Security Policy

## Reporting a Vulnerability

If you discover a security vulnerability in `binlex`, please help us maintain the project's integrity by reporting it responsibly.

### How to Report

**Email**: Send a detailed report to `c3rb3ru5d3d53c@gmail.com`.

### What to Include

- A clear description of the vulnerability.
- Steps to reproduce the issue.
- Any relevant proof of concept or exploit code.
- Your contact information for follow-up.

We will acknowledge receipt of your report within **48 hours** and aim to provide a status update within **5 business days**, including the expected timeline for a fix.

## Thank You

We appreciate your efforts to keep `binlex` secure and value your contributions to the community.

```

`examples/python/chromosomes.py`:

```py
#!/usr/bin/env python
#                    GNU LESSER GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.
#
#
#   This version of the GNU Lesser General Public License incorporates
# the terms and conditions of version 3 of the GNU General Public
# License, supplemented by the additional permissions listed below.
#
#   0. Additional Definitions.
#
#   As used herein, "this License" refers to version 3 of the GNU Lesser
# General Public License, and the "GNU GPL" refers to version 3 of the GNU
# General Public License.
#
#   "The Library" refers to a covered work governed by this License,
# other than an Application or a Combined Work as defined below.
#
#   An "Application" is any work that makes use of an interface provided
# by the Library, but which is not otherwise based on the Library.
# Defining a subclass of a class defined by the Library is deemed a mode
# of using an interface provided by the Library.
#
#   A "Combined Work" is a work produced by combining or linking an
# Application with the Library.  The particular version of the Library
# with which the Combined Work was made is also called the "Linked
# Version".
#
#   The "Minimal Corresponding Source" for a Combined Work means the
# Corresponding Source for the Combined Work, excluding any source code
# for portions of the Combined Work that, considered in isolation, are
# based on the Application, and not on the Linked Version.
#
#   The "Corresponding Application Code" for a Combined Work means the
# object code and/or source code for the Application, including any data
# and utility programs needed for reproducing the Combined Work from the
# Application, but excluding the System Libraries of the Combined Work.
#
#   1. Exception to Section 3 of the GNU GPL.
#
#   You may convey a covered work under sections 3 and 4 of this License
# without being bound by section 3 of the GNU GPL.
#
#   2. Conveying Modified Versions.
#
#   If you modify a copy of the Library, and, in your modifications, a
# facility refers to a function or data to be supplied by an Application
# that uses the facility (other than as an argument passed when the
# facility is invoked), then you may convey a copy of the modified
# version:
#
#    a) under this License, provided that you make a good faith effort to
#    ensure that, in the event an Application does not supply the
#    function or data, the facility still operates, and performs
#    whatever part of its purpose remains meaningful, or
#
#    b) under the GNU GPL, with none of the additional permissions of
#    this License applicable to that copy.
#
#   3. Object Code Incorporating Material from Library Header Files.
#
#   The object code form of an Application may incorporate material from
# a header file that is part of the Library.  You may convey such object
# code under terms of your choice, provided that, if the incorporated
# material is not limited to numerical parameters, data structure
# layouts and accessors, or small macros, inline functions and templates
# (ten or fewer lines in length), you do both of the following:
#
#    a) Give prominent notice with each copy of the object code that the
#    Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the object code with a copy of the GNU GPL and this license
#    document.
#
#   4. Combined Works.
#
#   You may convey a Combined Work under terms of your choice that,
# taken together, effectively do not restrict modification of the
# portions of the Library contained in the Combined Work and reverse
# engineering for debugging such modifications, if you also do each of
# the following:
#
#    a) Give prominent notice with each copy of the Combined Work that
#    the Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the Combined Work with a copy of the GNU GPL and this license
#    document.
#
#    c) For a Combined Work that displays copyright notices during
#    execution, include the copyright notice for the Library among
#    these notices, as well as a reference directing the user to the
#    copies of the GNU GPL and this license document.
#
#    d) Do one of the following:
#
#        0) Convey the Minimal Corresponding Source under the terms of this
#        License, and the Corresponding Application Code in a form
#        suitable for, and under terms that permit, the user to
#        recombine or relink the Application with a modified version of
#        the Linked Version to produce a modified Combined Work, in the
#        manner specified by section 6 of the GNU GPL for conveying
#        Corresponding Source.
#
#        1) Use a suitable shared library mechanism for linking with the
#        Library.  A suitable mechanism is one that (a) uses at run time
#        a copy of the Library already present on the user's computer
#        system, and (b) will operate properly with a modified version
#        of the Library that is interface-compatible with the Linked
#        Version.
#
#    e) Provide Installation Information, but only if you would otherwise
#    be required to provide such information under section 6 of the
#    GNU GPL, and only to the extent that such information is
#    necessary to install and execute a modified version of the
#    Combined Work produced by recombining or relinking the
#    Application with a modified version of the Linked Version. (If
#    you use option 4d0, the Installation Information must accompany
#    the Minimal Corresponding Source and Corresponding Application
#    Code. If you use option 4d1, you must provide the Installation
#    Information in the manner specified by section 6 of the GNU GPL
#    for conveying Corresponding Source.)
#
#   5. Combined Libraries.
#
#   You may place library facilities that are a work based on the
# Library side by side in a single library together with other library
# facilities that are not Applications and are not covered by this
# License, and convey such a combined library under terms of your
# choice, if you do both of the following:
#
#    a) Accompany the combined library with a copy of the same work based
#    on the Library, uncombined with any other library facilities,
#    conveyed under the terms of this License.
#
#    b) Give prominent notice with the combined library that part of it
#    is a work based on the Library, and explaining where to find the
#    accompanying uncombined form of the same work.
#
#   6. Revised Versions of the GNU Lesser General Public License.
#
#   The Free Software Foundation may publish revised and/or new versions
# of the GNU Lesser General Public License from time to time. Such new
# versions will be similar in spirit to the present version, but may
# differ in detail to address new problems or concerns.
#
#   Each version is given a distinguishing version number. If the
# Library as you received it specifies that a certain numbered version
# of the GNU Lesser General Public License "or any later version"
# applies to it, you have the option of following the terms and
# conditions either of that published version or of any later version
# published by the Free Software Foundation. If the Library as you
# received it does not specify a version number of the GNU Lesser
# General Public License, you may choose any version of the GNU Lesser
# General Public License ever published by the Free Software Foundation.
#
#   If the Library as you received it specifies that a proxy can decide
# whether future versions of the GNU Lesser General Public License shall
# apply, that proxy's public statement of acceptance of any version is
# permanent authorization for you to choose that version for the
# Library.


# Example on Finding common sub sequences

import sys
import json
from binlex.genetics import Chromosome
from binlex import Config

config = Config()

config.chromosomes.homologues.maximum = 2

lhs = Chromosome('deadbeef', config)
rhs = Chromosome('fedeadbeeffe', config)

delta = lhs.compare(rhs)

print(json.dumps(json.loads(delta.json())))

```

`examples/python/elf.py`:

```py
#!/usr/bin/env python
#                    GNU LESSER GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.
#
#
#   This version of the GNU Lesser General Public License incorporates
# the terms and conditions of version 3 of the GNU General Public
# License, supplemented by the additional permissions listed below.
#
#   0. Additional Definitions.
#
#   As used herein, "this License" refers to version 3 of the GNU Lesser
# General Public License, and the "GNU GPL" refers to version 3 of the GNU
# General Public License.
#
#   "The Library" refers to a covered work governed by this License,
# other than an Application or a Combined Work as defined below.
#
#   An "Application" is any work that makes use of an interface provided
# by the Library, but which is not otherwise based on the Library.
# Defining a subclass of a class defined by the Library is deemed a mode
# of using an interface provided by the Library.
#
#   A "Combined Work" is a work produced by combining or linking an
# Application with the Library.  The particular version of the Library
# with which the Combined Work was made is also called the "Linked
# Version".
#
#   The "Minimal Corresponding Source" for a Combined Work means the
# Corresponding Source for the Combined Work, excluding any source code
# for portions of the Combined Work that, considered in isolation, are
# based on the Application, and not on the Linked Version.
#
#   The "Corresponding Application Code" for a Combined Work means the
# object code and/or source code for the Application, including any data
# and utility programs needed for reproducing the Combined Work from the
# Application, but excluding the System Libraries of the Combined Work.
#
#   1. Exception to Section 3 of the GNU GPL.
#
#   You may convey a covered work under sections 3 and 4 of this License
# without being bound by section 3 of the GNU GPL.
#
#   2. Conveying Modified Versions.
#
#   If you modify a copy of the Library, and, in your modifications, a
# facility refers to a function or data to be supplied by an Application
# that uses the facility (other than as an argument passed when the
# facility is invoked), then you may convey a copy of the modified
# version:
#
#    a) under this License, provided that you make a good faith effort to
#    ensure that, in the event an Application does not supply the
#    function or data, the facility still operates, and performs
#    whatever part of its purpose remains meaningful, or
#
#    b) under the GNU GPL, with none of the additional permissions of
#    this License applicable to that copy.
#
#   3. Object Code Incorporating Material from Library Header Files.
#
#   The object code form of an Application may incorporate material from
# a header file that is part of the Library.  You may convey such object
# code under terms of your choice, provided that, if the incorporated
# material is not limited to numerical parameters, data structure
# layouts and accessors, or small macros, inline functions and templates
# (ten or fewer lines in length), you do both of the following:
#
#    a) Give prominent notice with each copy of the object code that the
#    Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the object code with a copy of the GNU GPL and this license
#    document.
#
#   4. Combined Works.
#
#   You may convey a Combined Work under terms of your choice that,
# taken together, effectively do not restrict modification of the
# portions of the Library contained in the Combined Work and reverse
# engineering for debugging such modifications, if you also do each of
# the following:
#
#    a) Give prominent notice with each copy of the Combined Work that
#    the Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the Combined Work with a copy of the GNU GPL and this license
#    document.
#
#    c) For a Combined Work that displays copyright notices during
#    execution, include the copyright notice for the Library among
#    these notices, as well as a reference directing the user to the
#    copies of the GNU GPL and this license document.
#
#    d) Do one of the following:
#
#        0) Convey the Minimal Corresponding Source under the terms of this
#        License, and the Corresponding Application Code in a form
#        suitable for, and under terms that permit, the user to
#        recombine or relink the Application with a modified version of
#        the Linked Version to produce a modified Combined Work, in the
#        manner specified by section 6 of the GNU GPL for conveying
#        Corresponding Source.
#
#        1) Use a suitable shared library mechanism for linking with the
#        Library.  A suitable mechanism is one that (a) uses at run time
#        a copy of the Library already present on the user's computer
#        system, and (b) will operate properly with a modified version
#        of the Library that is interface-compatible with the Linked
#        Version.
#
#    e) Provide Installation Information, but only if you would otherwise
#    be required to provide such information under section 6 of the
#    GNU GPL, and only to the extent that such information is
#    necessary to install and execute a modified version of the
#    Combined Work produced by recombining or relinking the
#    Application with a modified version of the Linked Version. (If
#    you use option 4d0, the Installation Information must accompany
#    the Minimal Corresponding Source and Corresponding Application
#    Code. If you use option 4d1, you must provide the Installation
#    Information in the manner specified by section 6 of the GNU GPL
#    for conveying Corresponding Source.)
#
#   5. Combined Libraries.
#
#   You may place library facilities that are a work based on the
# Library side by side in a single library together with other library
# facilities that are not Applications and are not covered by this
# License, and convey such a combined library under terms of your
# choice, if you do both of the following:
#
#    a) Accompany the combined library with a copy of the same work based
#    on the Library, uncombined with any other library facilities,
#    conveyed under the terms of this License.
#
#    b) Give prominent notice with the combined library that part of it
#    is a work based on the Library, and explaining where to find the
#    accompanying uncombined form of the same work.
#
#   6. Revised Versions of the GNU Lesser General Public License.
#
#   The Free Software Foundation may publish revised and/or new versions
# of the GNU Lesser General Public License from time to time. Such new
# versions will be similar in spirit to the present version, but may
# differ in detail to address new problems or concerns.
#
#   Each version is given a distinguishing version number. If the
# Library as you received it specifies that a certain numbered version
# of the GNU Lesser General Public License "or any later version"
# applies to it, you have the option of following the terms and
# conditions either of that published version or of any later version
# published by the Free Software Foundation. If the Library as you
# received it does not specify a version number of the GNU Lesser
# General Public License, you may choose any version of the GNU Lesser
# General Public License ever published by the Free Software Foundation.
#
#   If the Library as you received it specifies that a proxy can decide
# whether future versions of the GNU Lesser General Public License shall
# apply, that proxy's public statement of acceptance of any version is
# permanent authorization for you to choose that version for the
# Library.


from binlex.formats import ELF
from binlex.disassemblers.capstone import Disassembler
from binlex.controlflow import Graph
from binlex import Config
import argparse

__version__ = '1.0.0'
__author__ = 'c3rb3ru5d3d53c'

parser = argparse.ArgumentParser(
    prog=f'elf v{__version__}',
    description='Read ELF Functions',
    epilog=f'Author: {__author__}'
)
parser.add_argument(
    '--input',
    type=str,
    default=None,
    help='Input ELF File Path',
    required=True
)

args = parser.parse_args()

# Get Default Configuration
config = Config()

# Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16

# Open the ELF File
elf = ELF(args.input, config)

# Get the Memory Mapped File
mapped_file = pe.image()

# Get the Memory Map
image = mapped_file.mmap()

# Create Disassembler on Mapped ELF Image and ELF Architecture
disassembler = Disassembler(elf.architecture(), image, elf.executable_virtual_address_ranges(), config)

# Create the Controlflow Graph
cfg = Graph(elf.architecture(), config)

# Disassemble the PE Image Entrypoints Recursively
disassembler.disassemble_controlflow(elf.entrypoint_virtual_addresses(), cfg)

for function in cfg.functions():
    function.print()

```

`examples/python/macho.py`:

```py
#!/usr/bin/env python
#                    GNU LESSER GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.
#
#
#   This version of the GNU Lesser General Public License incorporates
# the terms and conditions of version 3 of the GNU General Public
# License, supplemented by the additional permissions listed below.
#
#   0. Additional Definitions.
#
#   As used herein, "this License" refers to version 3 of the GNU Lesser
# General Public License, and the "GNU GPL" refers to version 3 of the GNU
# General Public License.
#
#   "The Library" refers to a covered work governed by this License,
# other than an Application or a Combined Work as defined below.
#
#   An "Application" is any work that makes use of an interface provided
# by the Library, but which is not otherwise based on the Library.
# Defining a subclass of a class defined by the Library is deemed a mode
# of using an interface provided by the Library.
#
#   A "Combined Work" is a work produced by combining or linking an
# Application with the Library.  The particular version of the Library
# with which the Combined Work was made is also called the "Linked
# Version".
#
#   The "Minimal Corresponding Source" for a Combined Work means the
# Corresponding Source for the Combined Work, excluding any source code
# for portions of the Combined Work that, considered in isolation, are
# based on the Application, and not on the Linked Version.
#
#   The "Corresponding Application Code" for a Combined Work means the
# object code and/or source code for the Application, including any data
# and utility programs needed for reproducing the Combined Work from the
# Application, but excluding the System Libraries of the Combined Work.
#
#   1. Exception to Section 3 of the GNU GPL.
#
#   You may convey a covered work under sections 3 and 4 of this License
# without being bound by section 3 of the GNU GPL.
#
#   2. Conveying Modified Versions.
#
#   If you modify a copy of the Library, and, in your modifications, a
# facility refers to a function or data to be supplied by an Application
# that uses the facility (other than as an argument passed when the
# facility is invoked), then you may convey a copy of the modified
# version:
#
#    a) under this License, provided that you make a good faith effort to
#    ensure that, in the event an Application does not supply the
#    function or data, the facility still operates, and performs
#    whatever part of its purpose remains meaningful, or
#
#    b) under the GNU GPL, with none of the additional permissions of
#    this License applicable to that copy.
#
#   3. Object Code Incorporating Material from Library Header Files.
#
#   The object code form of an Application may incorporate material from
# a header file that is part of the Library.  You may convey such object
# code under terms of your choice, provided that, if the incorporated
# material is not limited to numerical parameters, data structure
# layouts and accessors, or small macros, inline functions and templates
# (ten or fewer lines in length), you do both of the following:
#
#    a) Give prominent notice with each copy of the object code that the
#    Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the object code with a copy of the GNU GPL and this license
#    document.
#
#   4. Combined Works.
#
#   You may convey a Combined Work under terms of your choice that,
# taken together, effectively do not restrict modification of the
# portions of the Library contained in the Combined Work and reverse
# engineering for debugging such modifications, if you also do each of
# the following:
#
#    a) Give prominent notice with each copy of the Combined Work that
#    the Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the Combined Work with a copy of the GNU GPL and this license
#    document.
#
#    c) For a Combined Work that displays copyright notices during
#    execution, include the copyright notice for the Library among
#    these notices, as well as a reference directing the user to the
#    copies of the GNU GPL and this license document.
#
#    d) Do one of the following:
#
#        0) Convey the Minimal Corresponding Source under the terms of this
#        License, and the Corresponding Application Code in a form
#        suitable for, and under terms that permit, the user to
#        recombine or relink the Application with a modified version of
#        the Linked Version to produce a modified Combined Work, in the
#        manner specified by section 6 of the GNU GPL for conveying
#        Corresponding Source.
#
#        1) Use a suitable shared library mechanism for linking with the
#        Library.  A suitable mechanism is one that (a) uses at run time
#        a copy of the Library already present on the user's computer
#        system, and (b) will operate properly with a modified version
#        of the Library that is interface-compatible with the Linked
#        Version.
#
#    e) Provide Installation Information, but only if you would otherwise
#    be required to provide such information under section 6 of the
#    GNU GPL, and only to the extent that such information is
#    necessary to install and execute a modified version of the
#    Combined Work produced by recombining or relinking the
#    Application with a modified version of the Linked Version. (If
#    you use option 4d0, the Installation Information must accompany
#    the Minimal Corresponding Source and Corresponding Application
#    Code. If you use option 4d1, you must provide the Installation
#    Information in the manner specified by section 6 of the GNU GPL
#    for conveying Corresponding Source.)
#
#   5. Combined Libraries.
#
#   You may place library facilities that are a work based on the
# Library side by side in a single library together with other library
# facilities that are not Applications and are not covered by this
# License, and convey such a combined library under terms of your
# choice, if you do both of the following:
#
#    a) Accompany the combined library with a copy of the same work based
#    on the Library, uncombined with any other library facilities,
#    conveyed under the terms of this License.
#
#    b) Give prominent notice with the combined library that part of it
#    is a work based on the Library, and explaining where to find the
#    accompanying uncombined form of the same work.
#
#   6. Revised Versions of the GNU Lesser General Public License.
#
#   The Free Software Foundation may publish revised and/or new versions
# of the GNU Lesser General Public License from time to time. Such new
# versions will be similar in spirit to the present version, but may
# differ in detail to address new problems or concerns.
#
#   Each version is given a distinguishing version number. If the
# Library as you received it specifies that a certain numbered version
# of the GNU Lesser General Public License "or any later version"
# applies to it, you have the option of following the terms and
# conditions either of that published version or of any later version
# published by the Free Software Foundation. If the Library as you
# received it does not specify a version number of the GNU Lesser
# General Public License, you may choose any version of the GNU Lesser
# General Public License ever published by the Free Software Foundation.
#
#   If the Library as you received it specifies that a proxy can decide
# whether future versions of the GNU Lesser General Public License shall
# apply, that proxy's public statement of acceptance of any version is
# permanent authorization for you to choose that version for the
# Library.

from binlex.formats import MACHO
from binlex.disassemblers.capstone import Disassembler
from binlex.controlflow import Graph
from binlex import Config
import argparse

__version__ = '1.0.0'
__author__ = 'c3rb3ru5d3d53c'

parser = argparse.ArgumentParser(
    prog=f'macho v{__version__}',
    description='Read MACHO Functions',
    epilog=f'Author: {__author__}'
)
parser.add_argument(
    '--input',
    type=str,
    default=None,
    help='Input MACHO File Path',
    required=True
)

args = parser.parse_args()

# Get Default Configuration
config = Config()

# Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16

# Open the ELF File
macho = MACHO(args.input, config)

# MachO Fat Binary Can Support Multiple Architectures
for index in macho.number_of_slices():

  # Get the Memory Mapped File
  mapped_file = macho.image(index)

  # Get the Memory Map
  image = mapped_file.mmap()

  # Create Disassembler on Mapped MACHO Image and MACHO Architecture
  disassembler = Disassembler(macho.architecture(index), image, macho.executable_virtual_address_ranges(index), config)

  # Create the Controlflow Graph
  cfg = Graph(macho.architecture(index), config)

  # Disassemble the MACHO Image Entrypoints Recursively
  disassembler.disassemble_controlflow(macho.entrypoints(index), cfg)

  for function in cfg.functions():
    function.print()

```

`examples/python/pe_dotnet.py`:

```py
#!/usr/bin/env python
#                    GNU LESSER GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.
#
#
#   This version of the GNU Lesser General Public License incorporates
# the terms and conditions of version 3 of the GNU General Public
# License, supplemented by the additional permissions listed below.
#
#   0. Additional Definitions.
#
#   As used herein, "this License" refers to version 3 of the GNU Lesser
# General Public License, and the "GNU GPL" refers to version 3 of the GNU
# General Public License.
#
#   "The Library" refers to a covered work governed by this License,
# other than an Application or a Combined Work as defined below.
#
#   An "Application" is any work that makes use of an interface provided
# by the Library, but which is not otherwise based on the Library.
# Defining a subclass of a class defined by the Library is deemed a mode
# of using an interface provided by the Library.
#
#   A "Combined Work" is a work produced by combining or linking an
# Application with the Library.  The particular version of the Library
# with which the Combined Work was made is also called the "Linked
# Version".
#
#   The "Minimal Corresponding Source" for a Combined Work means the
# Corresponding Source for the Combined Work, excluding any source code
# for portions of the Combined Work that, considered in isolation, are
# based on the Application, and not on the Linked Version.
#
#   The "Corresponding Application Code" for a Combined Work means the
# object code and/or source code for the Application, including any data
# and utility programs needed for reproducing the Combined Work from the
# Application, but excluding the System Libraries of the Combined Work.
#
#   1. Exception to Section 3 of the GNU GPL.
#
#   You may convey a covered work under sections 3 and 4 of this License
# without being bound by section 3 of the GNU GPL.
#
#   2. Conveying Modified Versions.
#
#   If you modify a copy of the Library, and, in your modifications, a
# facility refers to a function or data to be supplied by an Application
# that uses the facility (other than as an argument passed when the
# facility is invoked), then you may convey a copy of the modified
# version:
#
#    a) under this License, provided that you make a good faith effort to
#    ensure that, in the event an Application does not supply the
#    function or data, the facility still operates, and performs
#    whatever part of its purpose remains meaningful, or
#
#    b) under the GNU GPL, with none of the additional permissions of
#    this License applicable to that copy.
#
#   3. Object Code Incorporating Material from Library Header Files.
#
#   The object code form of an Application may incorporate material from
# a header file that is part of the Library.  You may convey such object
# code under terms of your choice, provided that, if the incorporated
# material is not limited to numerical parameters, data structure
# layouts and accessors, or small macros, inline functions and templates
# (ten or fewer lines in length), you do both of the following:
#
#    a) Give prominent notice with each copy of the object code that the
#    Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the object code with a copy of the GNU GPL and this license
#    document.
#
#   4. Combined Works.
#
#   You may convey a Combined Work under terms of your choice that,
# taken together, effectively do not restrict modification of the
# portions of the Library contained in the Combined Work and reverse
# engineering for debugging such modifications, if you also do each of
# the following:
#
#    a) Give prominent notice with each copy of the Combined Work that
#    the Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the Combined Work with a copy of the GNU GPL and this license
#    document.
#
#    c) For a Combined Work that displays copyright notices during
#    execution, include the copyright notice for the Library among
#    these notices, as well as a reference directing the user to the
#    copies of the GNU GPL and this license document.
#
#    d) Do one of the following:
#
#        0) Convey the Minimal Corresponding Source under the terms of this
#        License, and the Corresponding Application Code in a form
#        suitable for, and under terms that permit, the user to
#        recombine or relink the Application with a modified version of
#        the Linked Version to produce a modified Combined Work, in the
#        manner specified by section 6 of the GNU GPL for conveying
#        Corresponding Source.
#
#        1) Use a suitable shared library mechanism for linking with the
#        Library.  A suitable mechanism is one that (a) uses at run time
#        a copy of the Library already present on the user's computer
#        system, and (b) will operate properly with a modified version
#        of the Library that is interface-compatible with the Linked
#        Version.
#
#    e) Provide Installation Information, but only if you would otherwise
#    be required to provide such information under section 6 of the
#    GNU GPL, and only to the extent that such information is
#    necessary to install and execute a modified version of the
#    Combined Work produced by recombining or relinking the
#    Application with a modified version of the Linked Version. (If
#    you use option 4d0, the Installation Information must accompany
#    the Minimal Corresponding Source and Corresponding Application
#    Code. If you use option 4d1, you must provide the Installation
#    Information in the manner specified by section 6 of the GNU GPL
#    for conveying Corresponding Source.)
#
#   5. Combined Libraries.
#
#   You may place library facilities that are a work based on the
# Library side by side in a single library together with other library
# facilities that are not Applications and are not covered by this
# License, and convey such a combined library under terms of your
# choice, if you do both of the following:
#
#    a) Accompany the combined library with a copy of the same work based
#    on the Library, uncombined with any other library facilities,
#    conveyed under the terms of this License.
#
#    b) Give prominent notice with the combined library that part of it
#    is a work based on the Library, and explaining where to find the
#    accompanying uncombined form of the same work.
#
#   6. Revised Versions of the GNU Lesser General Public License.
#
#   The Free Software Foundation may publish revised and/or new versions
# of the GNU Lesser General Public License from time to time. Such new
# versions will be similar in spirit to the present version, but may
# differ in detail to address new problems or concerns.
#
#   Each version is given a distinguishing version number. If the
# Library as you received it specifies that a certain numbered version
# of the GNU Lesser General Public License "or any later version"
# applies to it, you have the option of following the terms and
# conditions either of that published version or of any later version
# published by the Free Software Foundation. If the Library as you
# received it does not specify a version number of the GNU Lesser
# General Public License, you may choose any version of the GNU Lesser
# General Public License ever published by the Free Software Foundation.
#
#   If the Library as you received it specifies that a proxy can decide
# whether future versions of the GNU Lesser General Public License shall
# apply, that proxy's public statement of acceptance of any version is
# permanent authorization for you to choose that version for the
# Library.


from binlex.formats import PE
from binlex.disassemblers.custom.cil import Disassembler
from binlex.controlflow import Graph
from binlex import Config
import argparse

__version__ = '1.0.0'
__author__ = 'c3rb3ru5d3d53c'

parser = argparse.ArgumentParser(
    prog=f'pe_dotnet v{__version__}',
    description='Compare to Native PE Files',
    epilog=f'Author: {__author__}'
)
parser.add_argument(
    '--input',
    type=str,
    default=None,
    help='Input DotNet PE File Path',
    required=True
)

args = parser.parse_args()

# Get Default Configuration
config = Config()

# Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16

# Open the PE File
pe = PE(args.input, config)

# To check if a DotNet PE use ps.is_dotnet()

# Get the Memory Mapped File
mapped_file = pe.image()

# Get the Memory Map
image = mapped_file.mmap()

# Create Disassembler on Mapped PE Image and PE Architecture
disassembler = Disassembler(pe.architecture(), image, pe.dotnet_metadata_token_virtual_addresses(), pe.dotnet_executable_virtual_address_ranges(), config)

# Create the Controlflow Graph
cfg = Graph(pe.architecture(), config)

# Disassemble the PE Image Entrypoints Recursively
disassembler.disassemble_controlflow(pe.dotnet_entrypoint_virtual_addresses(), cfg)

for function in cfg.functions():
    function.print()

```

`examples/python/pe_native.py`:

```py
#!/usr/bin/env python
#                    GNU LESSER GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.
#
#
#   This version of the GNU Lesser General Public License incorporates
# the terms and conditions of version 3 of the GNU General Public
# License, supplemented by the additional permissions listed below.
#
#   0. Additional Definitions.
#
#   As used herein, "this License" refers to version 3 of the GNU Lesser
# General Public License, and the "GNU GPL" refers to version 3 of the GNU
# General Public License.
#
#   "The Library" refers to a covered work governed by this License,
# other than an Application or a Combined Work as defined below.
#
#   An "Application" is any work that makes use of an interface provided
# by the Library, but which is not otherwise based on the Library.
# Defining a subclass of a class defined by the Library is deemed a mode
# of using an interface provided by the Library.
#
#   A "Combined Work" is a work produced by combining or linking an
# Application with the Library.  The particular version of the Library
# with which the Combined Work was made is also called the "Linked
# Version".
#
#   The "Minimal Corresponding Source" for a Combined Work means the
# Corresponding Source for the Combined Work, excluding any source code
# for portions of the Combined Work that, considered in isolation, are
# based on the Application, and not on the Linked Version.
#
#   The "Corresponding Application Code" for a Combined Work means the
# object code and/or source code for the Application, including any data
# and utility programs needed for reproducing the Combined Work from the
# Application, but excluding the System Libraries of the Combined Work.
#
#   1. Exception to Section 3 of the GNU GPL.
#
#   You may convey a covered work under sections 3 and 4 of this License
# without being bound by section 3 of the GNU GPL.
#
#   2. Conveying Modified Versions.
#
#   If you modify a copy of the Library, and, in your modifications, a
# facility refers to a function or data to be supplied by an Application
# that uses the facility (other than as an argument passed when the
# facility is invoked), then you may convey a copy of the modified
# version:
#
#    a) under this License, provided that you make a good faith effort to
#    ensure that, in the event an Application does not supply the
#    function or data, the facility still operates, and performs
#    whatever part of its purpose remains meaningful, or
#
#    b) under the GNU GPL, with none of the additional permissions of
#    this License applicable to that copy.
#
#   3. Object Code Incorporating Material from Library Header Files.
#
#   The object code form of an Application may incorporate material from
# a header file that is part of the Library.  You may convey such object
# code under terms of your choice, provided that, if the incorporated
# material is not limited to numerical parameters, data structure
# layouts and accessors, or small macros, inline functions and templates
# (ten or fewer lines in length), you do both of the following:
#
#    a) Give prominent notice with each copy of the object code that the
#    Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the object code with a copy of the GNU GPL and this license
#    document.
#
#   4. Combined Works.
#
#   You may convey a Combined Work under terms of your choice that,
# taken together, effectively do not restrict modification of the
# portions of the Library contained in the Combined Work and reverse
# engineering for debugging such modifications, if you also do each of
# the following:
#
#    a) Give prominent notice with each copy of the Combined Work that
#    the Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the Combined Work with a copy of the GNU GPL and this license
#    document.
#
#    c) For a Combined Work that displays copyright notices during
#    execution, include the copyright notice for the Library among
#    these notices, as well as a reference directing the user to the
#    copies of the GNU GPL and this license document.
#
#    d) Do one of the following:
#
#        0) Convey the Minimal Corresponding Source under the terms of this
#        License, and the Corresponding Application Code in a form
#        suitable for, and under terms that permit, the user to
#        recombine or relink the Application with a modified version of
#        the Linked Version to produce a modified Combined Work, in the
#        manner specified by section 6 of the GNU GPL for conveying
#        Corresponding Source.
#
#        1) Use a suitable shared library mechanism for linking with the
#        Library.  A suitable mechanism is one that (a) uses at run time
#        a copy of the Library already present on the user's computer
#        system, and (b) will operate properly with a modified version
#        of the Library that is interface-compatible with the Linked
#        Version.
#
#    e) Provide Installation Information, but only if you would otherwise
#    be required to provide such information under section 6 of the
#    GNU GPL, and only to the extent that such information is
#    necessary to install and execute a modified version of the
#    Combined Work produced by recombining or relinking the
#    Application with a modified version of the Linked Version. (If
#    you use option 4d0, the Installation Information must accompany
#    the Minimal Corresponding Source and Corresponding Application
#    Code. If you use option 4d1, you must provide the Installation
#    Information in the manner specified by section 6 of the GNU GPL
#    for conveying Corresponding Source.)
#
#   5. Combined Libraries.
#
#   You may place library facilities that are a work based on the
# Library side by side in a single library together with other library
# facilities that are not Applications and are not covered by this
# License, and convey such a combined library under terms of your
# choice, if you do both of the following:
#
#    a) Accompany the combined library with a copy of the same work based
#    on the Library, uncombined with any other library facilities,
#    conveyed under the terms of this License.
#
#    b) Give prominent notice with the combined library that part of it
#    is a work based on the Library, and explaining where to find the
#    accompanying uncombined form of the same work.
#
#   6. Revised Versions of the GNU Lesser General Public License.
#
#   The Free Software Foundation may publish revised and/or new versions
# of the GNU Lesser General Public License from time to time. Such new
# versions will be similar in spirit to the present version, but may
# differ in detail to address new problems or concerns.
#
#   Each version is given a distinguishing version number. If the
# Library as you received it specifies that a certain numbered version
# of the GNU Lesser General Public License "or any later version"
# applies to it, you have the option of following the terms and
# conditions either of that published version or of any later version
# published by the Free Software Foundation. If the Library as you
# received it does not specify a version number of the GNU Lesser
# General Public License, you may choose any version of the GNU Lesser
# General Public License ever published by the Free Software Foundation.
#
#   If the Library as you received it specifies that a proxy can decide
# whether future versions of the GNU Lesser General Public License shall
# apply, that proxy's public statement of acceptance of any version is
# permanent authorization for you to choose that version for the
# Library.


from binlex.formats import PE
from binlex.disassemblers.capstone import Disassembler
from binlex.controlflow import Graph, Function
from binlex import Config
import argparse

__version__ = '1.0.0'
__author__ = 'c3rb3ru5d3d53c'

parser = argparse.ArgumentParser(
    prog=f'pe_native v{__version__}',
    description='Read Native PE Functions',
    epilog=f'Author: {__author__}'
)
parser.add_argument(
    '--input',
    type=str,
    default=None,
    help='Input Native PE File Path',
    required=True
)

args = parser.parse_args()

# Get Default Configuration
config = Config()

# Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16

# Open the PE File
pe = PE(args.input, config)

# To check if a DotNet PE use ps.is_dotnet()

# Get the Memory Mapped File
mapped_file = pe.image()

# Get the Memory Map
image = mapped_file.mmap()

# Create Disassembler on Mapped PE Image and PE Architecture
disassembler = Disassembler(pe.architecture(), image, pe.executable_virtual_address_ranges(), config)

# Create the Controlflow Graph
cfg = Graph(pe.architecture(), config)

# Disassemble the PE Image Entrypoints Recursively
disassembler.disassemble_controlflow(pe.entrypoint_virtual_addresses(), cfg)

for address in cfg.queue_functions.valid_addresses():
    function = Function(address, cfg)
    function.print()
# for function in cfg.functions():
#     function.print()

```

`examples/python/pe_native_compare.py`:

```py
#!/usr/bin/env python
#                    GNU LESSER GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.
#
#
#   This version of the GNU Lesser General Public License incorporates
# the terms and conditions of version 3 of the GNU General Public
# License, supplemented by the additional permissions listed below.
#
#   0. Additional Definitions.
#
#   As used herein, "this License" refers to version 3 of the GNU Lesser
# General Public License, and the "GNU GPL" refers to version 3 of the GNU
# General Public License.
#
#   "The Library" refers to a covered work governed by this License,
# other than an Application or a Combined Work as defined below.
#
#   An "Application" is any work that makes use of an interface provided
# by the Library, but which is not otherwise based on the Library.
# Defining a subclass of a class defined by the Library is deemed a mode
# of using an interface provided by the Library.
#
#   A "Combined Work" is a work produced by combining or linking an
# Application with the Library.  The particular version of the Library
# with which the Combined Work was made is also called the "Linked
# Version".
#
#   The "Minimal Corresponding Source" for a Combined Work means the
# Corresponding Source for the Combined Work, excluding any source code
# for portions of the Combined Work that, considered in isolation, are
# based on the Application, and not on the Linked Version.
#
#   The "Corresponding Application Code" for a Combined Work means the
# object code and/or source code for the Application, including any data
# and utility programs needed for reproducing the Combined Work from the
# Application, but excluding the System Libraries of the Combined Work.
#
#   1. Exception to Section 3 of the GNU GPL.
#
#   You may convey a covered work under sections 3 and 4 of this License
# without being bound by section 3 of the GNU GPL.
#
#   2. Conveying Modified Versions.
#
#   If you modify a copy of the Library, and, in your modifications, a
# facility refers to a function or data to be supplied by an Application
# that uses the facility (other than as an argument passed when the
# facility is invoked), then you may convey a copy of the modified
# version:
#
#    a) under this License, provided that you make a good faith effort to
#    ensure that, in the event an Application does not supply the
#    function or data, the facility still operates, and performs
#    whatever part of its purpose remains meaningful, or
#
#    b) under the GNU GPL, with none of the additional permissions of
#    this License applicable to that copy.
#
#   3. Object Code Incorporating Material from Library Header Files.
#
#   The object code form of an Application may incorporate material from
# a header file that is part of the Library.  You may convey such object
# code under terms of your choice, provided that, if the incorporated
# material is not limited to numerical parameters, data structure
# layouts and accessors, or small macros, inline functions and templates
# (ten or fewer lines in length), you do both of the following:
#
#    a) Give prominent notice with each copy of the object code that the
#    Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the object code with a copy of the GNU GPL and this license
#    document.
#
#   4. Combined Works.
#
#   You may convey a Combined Work under terms of your choice that,
# taken together, effectively do not restrict modification of the
# portions of the Library contained in the Combined Work and reverse
# engineering for debugging such modifications, if you also do each of
# the following:
#
#    a) Give prominent notice with each copy of the Combined Work that
#    the Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the Combined Work with a copy of the GNU GPL and this license
#    document.
#
#    c) For a Combined Work that displays copyright notices during
#    execution, include the copyright notice for the Library among
#    these notices, as well as a reference directing the user to the
#    copies of the GNU GPL and this license document.
#
#    d) Do one of the following:
#
#        0) Convey the Minimal Corresponding Source under the terms of this
#        License, and the Corresponding Application Code in a form
#        suitable for, and under terms that permit, the user to
#        recombine or relink the Application with a modified version of
#        the Linked Version to produce a modified Combined Work, in the
#        manner specified by section 6 of the GNU GPL for conveying
#        Corresponding Source.
#
#        1) Use a suitable shared library mechanism for linking with the
#        Library.  A suitable mechanism is one that (a) uses at run time
#        a copy of the Library already present on the user's computer
#        system, and (b) will operate properly with a modified version
#        of the Library that is interface-compatible with the Linked
#        Version.
#
#    e) Provide Installation Information, but only if you would otherwise
#    be required to provide such information under section 6 of the
#    GNU GPL, and only to the extent that such information is
#    necessary to install and execute a modified version of the
#    Combined Work produced by recombining or relinking the
#    Application with a modified version of the Linked Version. (If
#    you use option 4d0, the Installation Information must accompany
#    the Minimal Corresponding Source and Corresponding Application
#    Code. If you use option 4d1, you must provide the Installation
#    Information in the manner specified by section 6 of the GNU GPL
#    for conveying Corresponding Source.)
#
#   5. Combined Libraries.
#
#   You may place library facilities that are a work based on the
# Library side by side in a single library together with other library
# facilities that are not Applications and are not covered by this
# License, and convey such a combined library under terms of your
# choice, if you do both of the following:
#
#    a) Accompany the combined library with a copy of the same work based
#    on the Library, uncombined with any other library facilities,
#    conveyed under the terms of this License.
#
#    b) Give prominent notice with the combined library that part of it
#    is a work based on the Library, and explaining where to find the
#    accompanying uncombined form of the same work.
#
#   6. Revised Versions of the GNU Lesser General Public License.
#
#   The Free Software Foundation may publish revised and/or new versions
# of the GNU Lesser General Public License from time to time. Such new
# versions will be similar in spirit to the present version, but may
# differ in detail to address new problems or concerns.
#
#   Each version is given a distinguishing version number. If the
# Library as you received it specifies that a certain numbered version
# of the GNU Lesser General Public License "or any later version"
# applies to it, you have the option of following the terms and
# conditions either of that published version or of any later version
# published by the Free Software Foundation. If the Library as you
# received it does not specify a version number of the GNU Lesser
# General Public License, you may choose any version of the GNU Lesser
# General Public License ever published by the Free Software Foundation.
#
#   If the Library as you received it specifies that a proxy can decide
# whether future versions of the GNU Lesser General Public License shall
# apply, that proxy's public statement of acceptance of any version is
# permanent authorization for you to choose that version for the
# Library.

import json
from binlex.formats import PE
from binlex.disassemblers.capstone import Disassembler
from binlex.controlflow import Graph
from binlex.controlflow import Function
from binlex.controlflow import FunctionJsonDeserializer
from binlex import Config
import argparse

__version__ = '1.0.0'
__author__ = 'c3rb3ru5d3d53c'

parser = argparse.ArgumentParser(
    prog=f'pe_native_compare v{__version__}',
    description='Compare to Native PE Files',
    epilog=f'Author: {__author__}'
)
parser.add_argument(
    '--lhs',
    type=str,
    default=None,
    help='Input LHS PE File path',
    required=True
)
parser.add_argument(
    '--rhs',
    type=str,
    default=None,
    help='Input RHS PE File path',
    required=True
)

args = parser.parse_args()

# Get Default Configuration
config = Config()

# Use 16 Threads for Multi-Threaded Operations
config.general.threads = 16

# Open the LHS PE File
lhs_pe = PE(args.lhs, config)

# To check if a DotNet PE use ps.is_dotnet()

# Get the Memory Mapped File
lhs_mapped_file = lhs_pe.image()

# Get the Memory Map
lhs_image = lhs_mapped_file.as_memoryview()

# Create Disassembler on Mapped PE Image and PE Architecture
lhs_disassembler = Disassembler(lhs_pe.architecture(), lhs_image, lhs_pe.executable_virtual_address_ranges(), config)

# Create the Controlflow Graph
lhs_cfg = Graph(lhs_pe.architecture(), config)

# Disassemble the PE Image Entrypoints Recursively
lhs_disassembler.disassemble_controlflow(lhs_pe.entrypoint_virtual_addresses(), lhs_cfg)

# Open the RHS PE File
rhs_pe = PE(args.rhs, config)

# Get the Memory Mapped File
rhs_mapped_file = rhs_pe.image()

# Get the Memory Map
rhs_image = rhs_mapped_file.mmap()

# Create Disassembler on Mapped PE Image and PE Architecture
rhs_disassembler = Disassembler(rhs_pe.architecture(), rhs_image, rhs_pe.executable_virtual_address_ranges(), config)

# Create the Controlflow Graph
rhs_cfg = Graph(rhs_pe.architecture(), config)

# Disassemble the PE Image Entrypoints Recursively
rhs_disassembler.disassemble_controlflow(rhs_pe.entrypoint_virtual_addresses(), rhs_cfg)

# lhs_blocks = lhs_cfg.blocks()
# rhs_blocks = rhs_cfg.blocks()
# lhs_block = lhs_blocks[0]

# results = lhs_block.compare_many(rhs_blocks)

# for k, v in results.items():
#     v = json.loads(v.json())
#     if v['score']['minhash'] == None: continue
#     if v['score']['minhash'] <= 0.5: continue
#     print(json.dumps(v))

lhs_functions = lhs_cfg.functions()

rhs_functions = rhs_cfg.functions()

print(f'rhs_functions: {len(rhs_functions)}')

for lhs_function in lhs_functions:
    print(f'lhs_function: {lhs_function.address()}')
    lhs_function.compare_many(rhs_functions)

# lhs_filtered = []
# rhs_filtered = []

# # Filter by Size and Hashed Ratio
# for lhs in lhs_cfg.functions():
#     if lhs.size() < 128: continue
#     if lhs.minhash_ratio() < 0.75: continue
#     lhs_filtered.append(lhs)

# for rhs in rhs_cfg.functions():
#     if rhs.size() < 128: continue
#     if rhs.minhash_ratio() < 0.75: continue
#     rhs_filtered.append(rhs)

# # Hunt Similar Functions with Size Tolerance
# for lhs in lhs_filtered:
#   for rhs in rhs_filtered:
#     if abs(lhs.size() - rhs.size()) > 32: continue
#     similarity = lhs.compare(rhs)
#     if similarity is None: continue
#     if similarity.minhash() is None: continue
#     if similarity.minhash() < 0.25: continue
#     print(f'lhs[{hex(lhs.address)}] vs. rhs[{hex(rhs.address)}] -> similarity: {similarity.minhash()}')



```

`examples/python/standalone_search.py`:

```py
#!/usr/bin/env python
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import json, argparse, sys

from binlex.formats import PE
from binlex.disassemblers.capstone import Disassembler
from binlex.controlflow import Graph, Function, FunctionJsonDeserializer
from blclient import BLClient
from binlex import Config


def calculate_size_ratio(len1: int, len2: int) -> float:
    if max(len1, len2) == 0:
        return 1.0
    return 1 - (abs(len1 - len2) / max(len1, len2))

def main(args):

    config = Config()
    config.general.threads = 16
    
    pe = PE(args.file, config)
    img = pe.image()
    mmap = img.mmap()
    disasm = Disassembler(pe.architecture(), mmap, pe.executable_virtual_address_ranges(), config)
    cfg = Graph(pe.architecture(), config)
    disasm.disassemble_controlflow(pe.entrypoint_virtual_addresses(), cfg)
    
    bl_func = Function(int(args.address),cfg)
    
    client = BLClient(url=args.url, api_key=args.api)
    status, databases = client.databases()
    
    if status != 200:
        print(f"Connection to {args.url} with the api key {args.api} resulted in HTTP status {status}")
        sys.exit(1)
    
    if args.database not in databases:
        print(f"Database {args.database} not found. Available databases: {databases}")
        sys.exit(1)
    
    # Search using just an address and SHA256 of the sample as a query usage example
    query = f"file_attributes['sha256'] == '{pe.sha256()}' and address == {args.address}"
    status, search_addr_results = client.query(
                database=args.database,
                collection="function",
                partition=pe.architecture(),
                query=query,
                offset=0,
                limit=15
            )
    # Print raw results
    print(search_addr_results)
    
    # Search using GNN vector and verify similarity with minhash and size check
    status, vector = client.inference(bl_func.to_dict())
    gnn_similarity_threshold: float = 0.75
    size_ratio_threshold: float = 0.75
    combined_ratio_threshold: float = 0.75
    minhash_score_threshold: float = 0.75
    limit: int = 3
    status, search_vector_results = client.search(
                database=args.database,
                collection='function',
                partition=pe.architecture(),
                offset=0,
                limit=limit, # Maximum number of results to return
                query=f"file_attributes['sha256'] != '{pe.sha256()}'", # An example query to go with vector search
                threshold=gnn_similarity_threshold,
                vector=vector
            )


    vector_results = []
    for search_result in search_vector_results:
        # Ignore functions without manually set names
        if len(search_result['name']) == 0:
            continue

        rhs_function = FunctionJsonDeserializer(json.dumps(search_result['data']), config)

        size_ratio = calculate_size_ratio(bl_func.size(), rhs_function.size())
        if size_ratio < size_ratio_threshold:
            continue
        
        comparison = FunctionJsonDeserializer(bl_func.json(),config).compare(rhs_function) 

        if comparison is None:
            continue

        minhash_score = comparison.score.minhash()

        if minhash_score is None or minhash_score < minhash_score_threshold:
            continue
        
        combined_score = (search_result['score'] + minhash_score) / 2.0
        if combined_score < combined_ratio_threshold:
            continue

        data = search_result['data']
        vector_results.append( 
            {
                "id": search_result['id'],
                "name": search_result['name'],
                "timestamp": search_result['timestamp'],
                "username": search_result['username'],
                "sha256": search_result['file_attributes']['sha256'],
                "address": str(data['address']),
                "cyclomatic_complexity": str(data['cyclomatic_complexity']),
                "number_of_instructions": str(data['number_of_instructions']),
                "entropy": str(data['entropy']),
                "average_instructions_per_block": str(data['average_instructions_per_block']),
                "size": str(data['size']),
                "gnn_similarity": str(search_result['score']),
                "minhash_score": str(minhash_score),
                "combined_score": str(combined_score),
                "size_ratio":  str(size_ratio)
            }
        )
    print(vector_results)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Search for function using GNN vector AND address and SHA256 of the sample", formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('-f', '--file', required=True, help='Path to the file', default=argparse.SUPPRESS)
    parser.add_argument('-a', '--address', required=True, help='Address of the function', default=argparse.SUPPRESS)
    parser.add_argument('--url', required=True, help='URL of Binlex server', default=argparse.SUPPRESS)
    parser.add_argument('--api', help='API key to access Binlex server', default='39248239c8ed937d6333a41874f1c8e310c5070703af30c06e67b0d308cb82c5')
    parser.add_argument('-db', "--database", help='Database in which the function shall be searched', default='malware')
    
    main(parser.parse_args())

```

`examples/python/training.py`:

```py
#!/usr/bin/env python
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import os
import random
import json
import numpy as np
import tensorflow as tf
from tensorflow.keras.layers import Input, LSTM, Dense, Dropout, BatchNormalization, Masking, RepeatVector
from tensorflow.keras.models import Model
from tensorflow.keras.initializers import GlorotUniform, Zeros
from tensorflow.keras.preprocessing.sequence import pad_sequences
from sklearn.preprocessing import MinMaxScaler
from collections import defaultdict

##############################################################################
#                       1. FORCE CPU + SINGLE-THREADED                       #
##############################################################################
os.environ["CUDA_VISIBLE_DEVICES"] = "-1"         # Force CPU execution
os.environ["TF_DETERMINISTIC_OPS"] = "1"          # Use deterministic ops if possible
tf.config.threading.set_intra_op_parallelism_threads(1)
tf.config.threading.set_inter_op_parallelism_threads(1)

##############################################################################
#                          2. FIX ALL RANDOM SEEDS                           #
##############################################################################
SEED = 42
random.seed(SEED)
np.random.seed(SEED)
tf.random.set_seed(SEED)
os.environ["PYTHONHASHSEED"] = str(SEED)

##############################################################################
#                       3. HELPER FUNCTIONS                                  #
##############################################################################

def preprocess_nibbles(nibble_sequences, max_len=None):
    """
    Convert variable-length nibble sequences into a padded 2D array.
    Handles nested or malformed input gracefully.
    """
    validated_sequences = []
    for seq in nibble_sequences:
        if isinstance(seq, (list, np.ndarray)):
            # Flatten nested sequences
            if any(isinstance(i, (list, np.ndarray)) for i in seq):
                seq = [item for sublist in seq for item in sublist]
            # Validate sequence content
            if all(isinstance(i, (int, float)) for i in seq):
                validated_sequences.append(seq)
            else:
                print(f"Warning: Invalid sequence skipped: {seq}")
        else:
            print(f"Warning: Non-sequence input skipped: {seq}")

    if not validated_sequences:
        raise ValueError("All input nibble sequences are invalid or empty.")

    # Determine max length if not provided
    if max_len is None:
        max_len = max(len(seq) for seq in validated_sequences)

    # Pad sequences
    return pad_sequences(validated_sequences, maxlen=max_len, padding='post', value=0)

def normalize_and_scale(vectors):
    """
    Normalize vectors to unit length, then scale from [-1,1] to [0,1].
    """
    eps = 1e-12
    norm = np.linalg.norm(vectors, axis=1, keepdims=True) + eps
    normalized_vectors = vectors / norm
    scaled_vectors = (normalized_vectors + 1) / 2
    return scaled_vectors

def compute_function_entropy(nibble_sequence):
    """
    Compute entropy of the nibble sequence for added features.
    Handles nested or malformed sequences gracefully.
    """
    try:
        # Flatten if nested
        if any(isinstance(i, (list, np.ndarray)) for i in nibble_sequence):
            nibble_sequence = [item for sublist in nibble_sequence for item in sublist]

        # Ensure the sequence is numeric
        if not all(isinstance(i, (int, float)) for i in nibble_sequence):
            print(f"Warning: Non-numeric or invalid sequence skipped: {nibble_sequence}")
            return 0  # Return a default entropy value for invalid sequences

        values, counts = np.unique(nibble_sequence, return_counts=True)
        probabilities = counts / counts.sum()
        entropy = -np.sum(probabilities * np.log2(probabilities))
        return entropy
    except Exception as e:
        print(f"Error computing entropy for sequence {nibble_sequence}: {e}")
        return 0  # Return a default value in case of errors

def encode_function_contiguity(is_contiguous):
    """
    One-hot encode the contiguity status of the function (binary).
    """
    return [1, 0] if is_contiguous else [0, 1]

def preprocess_features(nibble_sequences, contiguity_flags):
    """
    Combine nibbles, entropy, and contiguity features into a unified array.
    Handles input validation and error resilience.
    """
    try:
        max_len = max(len(seq) for seq in nibble_sequences if isinstance(seq, (list, np.ndarray)))
    except ValueError:
        raise ValueError("No valid nibble sequences provided.")

    padded_nibbles = preprocess_nibbles(nibble_sequences, max_len=max_len) / 15.0

    # Calculate entropy for each sequence
    entropies = np.array([
        compute_function_entropy(seq) if isinstance(seq, (list, np.ndarray)) else 0
        for seq in nibble_sequences
    ]).reshape(-1, 1)

    # Add contiguity information
    contiguity_vectors = np.array([
        encode_function_contiguity(flag) if isinstance(flag, bool) else [0, 0]
        for flag in contiguity_flags
    ])

    # Concatenate all features
    combined_features = np.hstack([padded_nibbles, entropies, contiguity_vectors])
    return combined_features

def construct_cfg(function_blocks):
    """
    Construct a Control Flow Graph (CFG) from basic blocks of a function.
    """
    cfg = defaultdict(list)
    for block in function_blocks:
        block_address = block['address']
        successors = block.get('successors', [])
        for succ in successors:
            cfg[block_address].append(succ)
    return cfg

def extract_cfg_features(cfg):
    """
    Extract features from a control flow graph for model input.
    """
    node_count = len(cfg)
    edge_count = sum(len(succs) for succs in cfg.values())
    max_degree = max(len(succs) for succs in cfg.values()) if cfg else 0
    return [node_count, edge_count, max_degree]

##############################################################################
#                       4. AUTOENCODER TRAINING                              #
##############################################################################

def train_autoencoder(data, input_dim, time_steps, epochs=50):
    """
    Build & train an LSTM-based autoencoder.
    """
    input_layer = Input(shape=(time_steps, input_dim))

    # Encoder
    x = Masking(mask_value=0.0)(input_layer)
    x = LSTM(128, activation='relu', kernel_initializer=GlorotUniform(seed=SEED), return_sequences=True)(x)
    x = Dropout(0.2)(x)
    x = LSTM(64, activation='relu', kernel_initializer=GlorotUniform(seed=SEED), return_sequences=False)(x)
    bottleneck = Dense(3, activation='tanh', name='bottleneck')(x)

    # Decoder
    x = RepeatVector(time_steps)(bottleneck)
    x = LSTM(64, activation='relu', kernel_initializer=GlorotUniform(seed=SEED), return_sequences=True)(x)
    x = Dropout(0.2)(x)
    x = LSTM(128, activation='relu', kernel_initializer=GlorotUniform(seed=SEED), return_sequences=True)(x)
    output_layer = Dense(input_dim, activation='sigmoid')(x)

    autoencoder = Model(inputs=input_layer, outputs=output_layer)

    # Use Adam optimizer
    optimizer = tf.keras.optimizers.Adam(learning_rate=0.001)

    autoencoder.compile(optimizer=optimizer, loss='mse')

    autoencoder.fit(
        data, data,
        epochs=epochs,
        batch_size=32,
        shuffle=True,
        verbose=0
    )

    # Return encoder and the full autoencoder
    encoder = Model(inputs=input_layer, outputs=bottleneck)
    return autoencoder, encoder

##############################################################################
#                              5. MAIN                                       #
##############################################################################

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Process JSON file with functions.")
    parser.add_argument("input_file", type=str, help="Path to the JSON file containing functions.")
    args = parser.parse_args()

    # Load and parse the JSON file
    with open(args.input_file, 'r') as f:
        functions = [json.loads(line.strip()) for line in f]

    # Initialize autoencoder variables
    autoencoder, encoder = None, None
    current_input_dim = None
    current_time_steps = None

    for function in functions:
        if function.get("type") == "function":
            nibble_sequence = function["chromosome"]["feature"] if function.get("contiguous", True) else \
                             [block["chromosome"]["feature"] for block in function.get("blocks", [])]

            contiguity_flag = function.get("contiguous", True)

            # Preprocess single function features
            input_features = preprocess_features([nibble_sequence], [contiguity_flag])
            input_features = np.expand_dims(input_features, axis=-1)  # Reshape for LSTM

            input_dim = input_features.shape[2]
            time_steps = input_features.shape[1]

            # Check input dimensions and reinitialize autoencoder if necessary
            if autoencoder is None or encoder is None or input_dim != current_input_dim or time_steps != current_time_steps:
                print(f"Reinitializing autoencoder for input_dim: {input_dim}, time_steps: {time_steps}")
                autoencoder, encoder = train_autoencoder(input_features, input_dim, time_steps, epochs=50)
                current_input_dim = input_dim
                current_time_steps = time_steps

            # Encode the function to get the 3D vector
            try:
                raw_vector = encoder.predict(input_features)

                # Compute reconstruction error as confidence score
                reconstruction = autoencoder.predict(input_features)
                mse = np.mean(np.square(input_features - reconstruction))
                confidence_score = 1 - mse  # Confidence is inversely related to error

                # Use the encoded vector directly
                print("Function Address:", function.get("address", "unknown"))
                print(f'Function Size: {function["size"]}')
                print("3D Vector [a, b, c]:", raw_vector[0].tolist())
                print("Confidence Score:", confidence_score)
            except Exception as e:
                print(f"Error processing function {function.get('address', 'unknown')}: {e}")

```

`examples/python/vector_database.py`:

```py
#!/usr/bin/env python
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""
Library: Binlex Vector Database Interface
----------------------------------------
This module provides functionality for:
1) Deserializing functions from a JSON file using Binlex.
2) Converting those functions into embeddings using a simple GCN-based PyTorch model.
3) Storing and querying these embeddings in a LanceDB database.

It has been refactored to allow user-specified dimensions for:
 - PCA-based block feature reduction (block_pca_dim).
 - GNN hidden layer and output layer dimensions (gnn_hidden_dim, gnn_output_dim).

Usage Example:
--------------
    from binlex_vector_db import BinlexVectorDB, Config

    config = Config()
    # Suppose we want to reduce each block feature to 4D with PCA,
    # then produce a 5D vector from the GNN:
    bl = BinlexVectorDB(
        db='./vecdb',
        config=config,
        block_pca_dim=4,
        gnn_hidden_dim=8,
        gnn_output_dim=5
    )

    functions = bl.deserialize_json_file_functions('./lhs.json')
    fn = functions[0]
    fn_vector = bl.create_function_vector(fn)
    print("Function embedding:", fn_vector.vector)

    # Insert into LanceDB
    table_obj = bl.insert_function_vector(fn_vector, table_name='my_functions')
    print("DB Table Info:", table_obj)

    # Query the top-3 nearest neighbors
    similarities = bl.query_vector(fn_vector.vector, table_name='my_functions', top_k=3)
    for sim, fn_json in similarities:
        print(f"Similarity: {sim:.4f}, Function: {fn_json}")
"""

# torch, torch_geometric, pandas, torch-pca, numpy, lancedb

import json
import torch
import numpy as np
import lancedb
import pandas as pd
import pyarrow as pa
from torch_geometric.data import Data
from torch_geometric.nn import GCNConv, global_mean_pool
from dataclasses import dataclass
from pyarrow import schema, field
from torch.nn import CosineSimilarity
from torch_pca import PCA
from binlex import Config
from binlex.controlflow import FunctionJsonDeserializer

@dataclass
class FunctionVector:
    """
    Lightweight container for storing an N-dimensional vector embedding
    of a function along with the original function metadata.
    """
    vector: list[float]
    function: dict

    def to_pandas(self) -> pd.DataFrame:
        """
        Converts this FunctionVector to a single-row DataFrame.
        """
        return pd.DataFrame(
            {
                'vector': [self.vector],
                'function': [self.function],
            }
        )


class BinlexGNN(torch.nn.Module):
    """
    A simple GCN-based model for generating graph embeddings of functions.
    """

    def __init__(self, node_features_dim: int, hidden_dim: int, output_dim: int):
        """
        Args:
            node_features_dim (int): The dimension of the node features.
            hidden_dim (int): The dimension of the hidden GCN layer.
            output_dim (int): The dimension of the final GCN output.
        """
        super().__init__()
        self.conv1 = GCNConv(node_features_dim, hidden_dim)
        self.conv2 = GCNConv(hidden_dim, output_dim)

    def forward(self, x: torch.Tensor, edge_index: torch.Tensor) -> torch.Tensor:
        """
        Forward pass through the GNN.

        Args:
            x (torch.Tensor): Node feature tensor of shape [num_nodes, node_features_dim].
            edge_index (torch.Tensor): Graph edges of shape [2, num_edges].

        Returns:
            torch.Tensor: Output features for each node, shape [num_nodes, output_dim].
        """
        x = self.conv1(x, edge_index).relu()
        x = self.conv2(x, edge_index)
        return x


class BinlexVectorDB:
    """
    Provides a high-level interface for:
      - Extracting function embeddings from JSON via Binlex.
      - Storing the embeddings in a LanceDB database.
      - Performing vector similarity queries.
    """

    def __init__(
        self,
        db: str,
        config: Config,
        seed: int = 0,
        block_pca_dim: int = 3,
        gnn_hidden_dim: int = 6,
        gnn_output_dim: int = 3,
    ):
        """
        Initialize the BinlexVectorDB with user-defined dimensions.

        Args:
            db (str): Path or URI to the LanceDB instance.
            config (Config): Binlex Config object.
            seed (int, optional): Random seed for reproducibility. Defaults to 0.
            block_pca_dim (int, optional): Dimension to reduce each block's feature set via PCA. Defaults to 3.
            gnn_hidden_dim (int, optional): Dimension for the hidden layer of the GNN. Defaults to 4.
            gnn_output_dim (int, optional): Dimension for the GNN output layer. Defaults to 3.
        """
        torch.manual_seed(seed)
        self.config = config
        self.db = lancedb.connect(db)

        # User-defined dimensions
        self.block_pca_dim = block_pca_dim
        self.gnn_hidden_dim = gnn_hidden_dim
        self.gnn_output_dim = gnn_output_dim

    # -------------------------------------------------------------------------
    # Feature Extraction + Graph Construction
    # -------------------------------------------------------------------------

    @staticmethod
    def nibbles_to_histogram_vector(nibbles: list[int]) -> list[int]:
        """
        Convert a list of nibble values (0-15) into a histogram
        of length 16, then flatten into an array of (value, count) pairs.

        Args:
            nibbles (list[int]): List of nibble values from 0 to 15.

        Returns:
            list[int]: Flattened histogram of size 32 (16 pairs of (value, count)).
        """
        histogram = [0] * 16
        for nibble in nibbles:
            if 0 <= nibble <= 15:
                histogram[nibble] += 1

        encoded_histogram = []
        for value, count in enumerate(histogram):
            encoded_histogram.extend([value, count])
        return encoded_histogram

    @staticmethod
    def to_nx3_array(values: list[float]) -> np.ndarray:
        """
        Reshape a flat list of values into Nx3 shape, padding if necessary.

        Args:
            values (list[float]): A list of numeric values.

        Returns:
            np.ndarray: Reshaped array of shape (N, 3).
        """
        arr = np.array(values, dtype=float)
        if arr.size == 0:
            # In case we have no features, return an empty 0x3 array
            return arr.reshape(-1, 3)

        padding = (3 - (len(arr) % 3)) % 3
        if padding > 0:
            arr = np.pad(arr, (0, padding), constant_values=0.0)
        return arr.reshape(-1, 3)

    @staticmethod
    def pca_reduce(values: np.ndarray, output_dim: int) -> np.ndarray:
        """
        Perform a PCA transform to reduce the Nx3 array down to 'output_dim',
        then take the mean across rows to get a single vector of length 'output_dim'.

        If the number of rows is fewer than 'output_dim', we pad them to have
        at least 'output_dim' rows. If PCA fails for any reason, returns zeros.

        Args:
            values (np.ndarray): A NumPy array of shape (N, 3).
            output_dim (int): Number of PCA components to reduce to.

        Returns:
            np.ndarray: A 1D vector of length 'output_dim'.
        """
        if values.size == 0:
            return np.zeros(output_dim)

        values_torch = torch.tensor(values, dtype=torch.float32)
        # Ensure at least `output_dim` rows for PCA
        n_rows, _ = values_torch.shape
        if n_rows < output_dim:
            pad_rows = output_dim - n_rows
            values_torch = torch.nn.functional.pad(values_torch, (0, 0, 0, pad_rows), value=0.0)

        try:
            pca = PCA(n_components=output_dim)
            # shape => [N, output_dim]
            principal_components = pca.fit_transform(values_torch)
            # Average across rows => [output_dim]
            values = principal_components.mean(dim=0).detach().numpy()
        except Exception:
            # If PCA fails, fallback to zeros
            values = np.zeros(output_dim)

        return values

    def _extract_block_features(self, function: FunctionJsonDeserializer) -> tuple[list[int], list[int], list[list[float]]]:
        """
        Extract adjacency lists (a, b) and reduced PCA features for each block in a function.

        Returns:
            tuple of:
              - a (list[int]): list of "from" node indices
              - b (list[int]): list of "to" node indices
              - features (list[list[float]]): list of PCA-reduced block features
        """
        a, b = [], []
        features = []

        for block in function.blocks():
            # Basic stats about the block
            feature = [
                block.size(),
                block.entropy(),
                block.number_of_instructions(),
                block.conditional(),
                block.edges(),
                len(block.functions()),
            ]
            # Chromosome nibble histogram
            chromosome_feature_histogram = self.nibbles_to_histogram_vector(
                block.chromosome().feature()
            )
            feature.extend(chromosome_feature_histogram)

            # Convert to Nx3 array
            feature_nx3 = self.to_nx3_array(feature)
            # Then reduce to user-specified block_pca_dim
            feature_reduced = self.pca_reduce(feature_nx3, output_dim=self.block_pca_dim)
            features.append(feature_reduced.tolist())

            # Adjacency for each sub-block
            for address in block.blocks():
                a.append(block.address())
                b.append(address)

        return a, b, features

    def _build_graph(self, a: list[int], b: list[int], features: list[list[float]]) -> Data:
        """
        Build torch_geometric Data from adjacency lists and node features.

        Args:
            a (list[int]): "from" node indices
            b (list[int]): "to" node indices
            features (list[list[float]]): Node feature vectors

        Returns:
            Data: torch_geometric graph data object.
        """
        # Ensure edges do not exceed the number of nodes
        max_node_index = len(features) - 1
        a_clamped = [min(max_node_index, idx) for idx in a]
        b_clamped = [min(max_node_index, idx) for idx in b]

        node_features = torch.tensor(features, dtype=torch.float)
        edge_index = torch.tensor([a_clamped, b_clamped], dtype=torch.long)

        return Data(x=node_features, edge_index=edge_index)

    def _gnn_embedding(self, data: Data) -> list[float]:
        """
        Run the GNN on the input graph data and global-mean-pool for a single embedding.

        Args:
            data (Data): torch_geometric graph data with x and edge_index.

        Returns:
            list[float]: GNN output embedding of length gnn_output_dim.
        """
        # Build and run the GNN
        gnn = BinlexGNN(
            node_features_dim=data.x.shape[1],
            hidden_dim=self.gnn_hidden_dim,
            output_dim=self.gnn_output_dim,
        )
        node_embeddings = gnn(data.x, data.edge_index)

        # Mean pool => single vector
        graph_embedding = global_mean_pool(
            node_embeddings,
            batch=torch.zeros(node_embeddings.size(0), dtype=torch.long),
        )
        return graph_embedding.squeeze().tolist()

    # -------------------------------------------------------------------------
    # Public API
    # -------------------------------------------------------------------------

    def create_function_vector(self, function: FunctionJsonDeserializer) -> FunctionVector:
        """
        Convert a FunctionJsonDeserializer object into a FunctionVector embedding.

        Steps:
            1) Extract block-level features and reduce them to 'block_pca_dim' via PCA.
            2) Build a graph (edges and nodes) for the function in torch_geometric Data.
            3) Generate node embeddings from a GCN, then take mean pool for the graph.

        Args:
            function (FunctionJsonDeserializer): The function-deserialization object.

        Returns:
            FunctionVector: The resulting embedding with function metadata.
        """
        a, b, features = self._extract_block_features(function)
        data = self._build_graph(a, b, features)
        vector = self._gnn_embedding(data)

        return FunctionVector(
            vector=vector,
            function=function.to_dict(),
        )

    def deserialize_json_file_functions(self, file_path: str) -> list[FunctionJsonDeserializer]:
        """
        Read a JSON file line-by-line, deserializing functions where 'type' = 'function'.

        Args:
            file_path (str): Path to the JSON file.

        Returns:
            list[FunctionJsonDeserializer]: List of deserialized function objects.
        """
        deserialized = []
        with open(file_path, "r") as f:
            for line in f:
                data = json.loads(line)
                if data.get("type") == "function":
                    deserialized.append(FunctionJsonDeserializer(line, self.config))
        return deserialized

    def insert_function_vector(
        self, function_vector: FunctionVector, table_name: str = 'functions'
    ) -> lancedb.table.Table:
        """
        Insert a FunctionVector into LanceDB, avoiding near-duplicate entries
        by comparing cosine similarity of the newly generated vector with
        the top-1 nearest neighbor in the table.

        Steps:
            1) Create the table if it doesn't exist.
            2) Search for the top-1 nearest neighbor (vector search).
            3) If there's a near-identical vector (same sha256 + similarity > threshold), skip.
            4) Otherwise, insert.

        Args:
            function_vector (FunctionVector): The vector + function metadata to insert.
            table_name (str, optional): Name of the target table. Defaults to 'functions'.

        Returns:
            lancedb.table.Table: The LanceDB table object that was created or updated.
        """
        # Convert the FunctionVector to a DataFrame, then to a dict
        record = function_vector.to_pandas().to_dict(orient="records")[0]
        # JSON-serialize the 'function' dict
        record["function"] = json.dumps(record["function"])

        # Extract sha256 from the function's attributes
        func_dict = json.loads(record["function"])
        sha256_hash = None
        attributes = func_dict.get('attributes', [])
        for attr in attributes:
            if attr.get('type') == 'file':
                sha256_hash = attr.get('sha256')
                break

        if not sha256_hash:
            raise ValueError("Missing 'sha256' in function attributes. Cannot insert.")

        record['sha256'] = sha256_hash

        # If the table doesn't exist, create it (with user-defined dimension for vectors)
        if table_name not in self.db.table_names():
            vec_dim = len(record['vector'])  # e.g. self.gnn_output_dim
            table_schema = schema([
                field("vector", lancedb.vector(vec_dim, pa.float32())),
                field("function", pa.string()),
                field("sha256", pa.utf8()),
            ])
            table = self.db.create_table(table_name, data=[record], schema=table_schema)
            print(f"Created table '{table_name}' and inserted record for sha256 '{sha256_hash}'.")
            return table

        # Otherwise, open the existing table
        table = self.db.open_table(table_name)

        # Top-1 nearest neighbor search
        top_match_df = table.search(record['vector']).limit(1).to_pandas()

        if not top_match_df.empty:
            new_vector = torch.tensor(record['vector'], dtype=torch.float32)
            cos = CosineSimilarity(dim=0)
            # Check only the top match
            existing_row = top_match_df.iloc[0]
            existing_vector = torch.tensor(existing_row['vector'], dtype=torch.float32)
            similarity = cos(new_vector, existing_vector).item()

            SIM_THRESHOLD = 0.9999
            # If near-identical vector is found for the same sha256
            if existing_row['sha256'] == sha256_hash and similarity >= SIM_THRESHOLD:
                print(
                    f"Skipping insertion. Found a near-identical vector (cos sim={similarity:.4f}) "
                    f"with the same sha256={sha256_hash}."
                )
                return table

        # If we didn't skip, insert the new record
        table.add([record])
        print(f"Inserted new record for sha256 '{sha256_hash}'.")
        return table

    def query_vector(
    self,
    query_vector: list[float],
    table_name: str = 'functions',
    top_k: int = 3
    ) -> list[tuple[float, str]]:
        """
        Perform a vector search against a LanceDB table (using LanceDB's built-in
        similarity search), then calculate and return the cosine similarity in PyTorch.

        Args:
            query_vector (list[float]): The query embedding vector.
            table_name (str, optional): Name of the table to query. Defaults to 'functions'.
            top_k (int, optional): Number of nearest neighbors to return. Defaults to 3.

        Returns:
            list[tuple[float, str]]: List of (cosine_similarity, function_json_string).
        """
        if table_name not in self.db.table_names():
            raise ValueError(f"Table '{table_name}' does not exist in the database.")

        # 1) Use LanceDBâ€™s vector search (table.search(...)) instead of reading all rows:
        table = self.db.open_table(table_name)
        top_match_df = (
            table.search(query_vector)
                .limit(top_k)
                .to_pandas()
        )

        # 2) Still compute PyTorch cosine similarity for each match:
        cos = CosineSimilarity(dim=0)
        query_tensor = torch.tensor(query_vector, dtype=torch.float32)

        results = []
        for _, row in top_match_df.iterrows():
            candidate_vec = torch.tensor(row['vector'], dtype=torch.float32)
            sim = cos(query_tensor, candidate_vec).item()
            # row['function'] is a JSON-serialized function
            results.append((sim, row['function']))

        return results



# ------------------------------------------------------------------------------
# Optional Example CLI usage. Uncomment if needed:
# ------------------------------------------------------------------------------
#
if __name__ == "__main__":
    config = Config()
    bl = BinlexVectorDB(
        db='./vecdb',
        config=config,
        block_pca_dim=16,
        gnn_hidden_dim=32,
        gnn_output_dim=16
    )

    functions = bl.deserialize_json_file_functions('./lhs.json')

    # for function in functions:
    #     function_vector = bl.create_function_vector(function)
    #     print(f'{hex(function.address())}: {function_vector.vector}')
    #     bl.insert_function_vector(function_vector)

    lhs_fn = functions[0]

    lhs_fv = bl.create_function_vector(lhs_fn)

    for similarity, function in bl.query_vector(query_vector=lhs_fv.vector, table_name='functions', top_k=3):
        if similarity < 0.75: continue
        rhs_fn = FunctionJsonDeserializer(function, config)
        delta = lhs_fn.compare(rhs_fn)
        minhash_score = delta.score.minhash()
        if minhash_score is None: continue
        combined = (similarity + minhash_score) / 2
        print('---')
        print(f'lhs: {hex(lhs_fn.address())}\nrhs: {hex(rhs_fn.address())}\ncosine: {similarity:.4f}\nminhash: {minhash_score}\ncombined: {combined}')

```

`scripts/blghidra/blghidra.py`:

```py
#                    GNU LESSER GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.
#
#
#   This version of the GNU Lesser General Public License incorporates
# the terms and conditions of version 3 of the GNU General Public
# License, supplemented by the additional permissions listed below.
#
#   0. Additional Definitions.
#
#   As used herein, "this License" refers to version 3 of the GNU Lesser
# General Public License, and the "GNU GPL" refers to version 3 of the GNU
# General Public License.
#
#   "The Library" refers to a covered work governed by this License,
# other than an Application or a Combined Work as defined below.
#
#   An "Application" is any work that makes use of an interface provided
# by the Library, but which is not otherwise based on the Library.
# Defining a subclass of a class defined by the Library is deemed a mode
# of using an interface provided by the Library.
#
#   A "Combined Work" is a work produced by combining or linking an
# Application with the Library.  The particular version of the Library
# with which the Combined Work was made is also called the "Linked
# Version".
#
#   The "Minimal Corresponding Source" for a Combined Work means the
# Corresponding Source for the Combined Work, excluding any source code
# for portions of the Combined Work that, considered in isolation, are
# based on the Application, and not on the Linked Version.
#
#   The "Corresponding Application Code" for a Combined Work means the
# object code and/or source code for the Application, including any data
# and utility programs needed for reproducing the Combined Work from the
# Application, but excluding the System Libraries of the Combined Work.
#
#   1. Exception to Section 3 of the GNU GPL.
#
#   You may convey a covered work under sections 3 and 4 of this License
# without being bound by section 3 of the GNU GPL.
#
#   2. Conveying Modified Versions.
#
#   If you modify a copy of the Library, and, in your modifications, a
# facility refers to a function or data to be supplied by an Application
# that uses the facility (other than as an argument passed when the
# facility is invoked), then you may convey a copy of the modified
# version:
#
#    a) under this License, provided that you make a good faith effort to
#    ensure that, in the event an Application does not supply the
#    function or data, the facility still operates, and performs
#    whatever part of its purpose remains meaningful, or
#
#    b) under the GNU GPL, with none of the additional permissions of
#    this License applicable to that copy.
#
#   3. Object Code Incorporating Material from Library Header Files.
#
#   The object code form of an Application may incorporate material from
# a header file that is part of the Library.  You may convey such object
# code under terms of your choice, provided that, if the incorporated
# material is not limited to numerical parameters, data structure
# layouts and accessors, or small macros, inline functions and templates
# (ten or fewer lines in length), you do both of the following:
#
#    a) Give prominent notice with each copy of the object code that the
#    Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the object code with a copy of the GNU GPL and this license
#    document.
#
#   4. Combined Works.
#
#   You may convey a Combined Work under terms of your choice that,
# taken together, effectively do not restrict modification of the
# portions of the Library contained in the Combined Work and reverse
# engineering for debugging such modifications, if you also do each of
# the following:
#
#    a) Give prominent notice with each copy of the Combined Work that
#    the Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the Combined Work with a copy of the GNU GPL and this license
#    document.
#
#    c) For a Combined Work that displays copyright notices during
#    execution, include the copyright notice for the Library among
#    these notices, as well as a reference directing the user to the
#    copies of the GNU GPL and this license document.
#
#    d) Do one of the following:
#
#        0) Convey the Minimal Corresponding Source under the terms of this
#        License, and the Corresponding Application Code in a form
#        suitable for, and under terms that permit, the user to
#        recombine or relink the Application with a modified version of
#        the Linked Version to produce a modified Combined Work, in the
#        manner specified by section 6 of the GNU GPL for conveying
#        Corresponding Source.
#
#        1) Use a suitable shared library mechanism for linking with the
#        Library.  A suitable mechanism is one that (a) uses at run time
#        a copy of the Library already present on the user's computer
#        system, and (b) will operate properly with a modified version
#        of the Library that is interface-compatible with the Linked
#        Version.
#
#    e) Provide Installation Information, but only if you would otherwise
#    be required to provide such information under section 6 of the
#    GNU GPL, and only to the extent that such information is
#    necessary to install and execute a modified version of the
#    Combined Work produced by recombining or relinking the
#    Application with a modified version of the Linked Version. (If
#    you use option 4d0, the Installation Information must accompany
#    the Minimal Corresponding Source and Corresponding Application
#    Code. If you use option 4d1, you must provide the Installation
#    Information in the manner specified by section 6 of the GNU GPL
#    for conveying Corresponding Source.)
#
#   5. Combined Libraries.
#
#   You may place library facilities that are a work based on the
# Library side by side in a single library together with other library
# facilities that are not Applications and are not covered by this
# License, and convey such a combined library under terms of your
# choice, if you do both of the following:
#
#    a) Accompany the combined library with a copy of the same work based
#    on the Library, uncombined with any other library facilities,
#    conveyed under the terms of this License.
#
#    b) Give prominent notice with the combined library that part of it
#    is a work based on the Library, and explaining where to find the
#    accompanying uncombined form of the same work.
#
#   6. Revised Versions of the GNU Lesser General Public License.
#
#   The Free Software Foundation may publish revised and/or new versions
# of the GNU Lesser General Public License from time to time. Such new
# versions will be similar in spirit to the present version, but may
# differ in detail to address new problems or concerns.
#
#   Each version is given a distinguishing version number. If the
# Library as you received it specifies that a certain numbered version
# of the GNU Lesser General Public License "or any later version"
# applies to it, you have the option of following the terms and
# conditions either of that published version or of any later version
# published by the Free Software Foundation. If the Library as you
# received it does not specify a version number of the GNU Lesser
# General Public License, you may choose any version of the GNU Lesser
# General Public License ever published by the Free Software Foundation.
#
#   If the Library as you received it specifies that a proxy can decide
# whether future versions of the GNU Lesser General Public License shall
# apply, that proxy's public statement of acceptance of any version is
# permanent authorization for you to choose that version for the
# Library.

#A Ghidra to Binlex Tool
#@author @c3rb3ru5d3d53c
#@category
#@keybinding
#@menupath
#@toolbar

import json

for function in currentProgram().getFunctionManager().getFunctions(True):
    print(json.dumps({
        'type': 'symbol',
        'symbol_type': 'function',
        'name': function.getName(),
        'file_offset': None,
        'relative_virtual_address': None,
        'virtual_address': function.getEntryPoint().getOffset()
    }))

```

`scripts/blserver/Dockerfile`:

```
FROM pytorch/pytorch:2.5.1-cuda12.4-cudnn9-runtime

WORKDIR /app

COPY . /app

RUN apt-get update && apt-get install -y curl git build-essential pkg-config libssl-dev

RUN pip install --no-cache-dir -r requirements.txt

RUN curl https://sh.rustup.rs -sSf | bash -s -- -y

RUN echo 'source $HOME/.cargo/env' >> $HOME/.bashrc

RUN git clone https://github.com/c3rb3ru5d3d53c/binlex.git && \
    cd binlex/src/bindings/python/ && \
    bash -c 'source /root/.cargo/env; pip install --no-cache-dir maturin[patchelf]; maturin build; pip install --no-cache-dir /app/binlex/target/wheels/*.whl; cargo clean'

RUN cp configs/blserver.toml.bak config.toml

ENV CONFIG=/app/config.toml

ENV PORT=5000

CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:$PORT", "blserver:create_app('$CONFIG')"]

```

`scripts/blserver/README.md`:

```md
# Binlex Server

The **binlex** server provides HTTP endpoints enabling the storage of vector embeddings for functions.

This is accomplished by receiving **binlex** formatted JSON, converting it into Graph Neural Network (GNN)

## Installing

Getting the **binlex** server up and running is as simple as using two commands.

```bash
make -C configs/       # Create Default Configurations
docker-compose up -d   # Build and Start
```

If you need to edit the configurations simply edit them in the `configs/` directory.

That being said, **binlex** server will startup without any additional configuratin.

**NOTE:** With no configuration **binlex** server is insecure, you should really modify the `docker-compose.yml` and configs in `configs/`.

## Services

| **Service Name**             | **Description**                             | **URL**                                 |
|------------------------------|---------------------------------------------|-----------------------------------------|
| Binlex Server                | API Documentation                           | `https://127.0.0.1/swagger`             |
| Attu Milvus Vector Database  | Attu Milvus Vector Database UI              | `https://127.0.0.1:8443`                |
| MinIO                        | MinIO Object Store                          | `https://127.0.0.1:7443`                |
| JupyterHub                   | JupyterHub Web GUI                          | `https://127.0.0.1:6443`                |

```

`scripts/blserver/blserver.py`:

```py
#!/usr/bin/env python
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import json
import argparse
import tomllib
from flask import Flask, request, Response
from flask_restx import Resource, Api, fields
from libblserver import BinlexGNN, BinlexVectorEmbedding, BinlexMinio, BinlexMilvus

__author__ = 'c3rb3ru5d3d53c'
__version__ = '2.0.0'

def read_config(file_path: str) -> dict:
    try:
        with open(file_path, "rb") as file:
            return tomllib.load(file)
    except FileNotFoundError:
        raise FileNotFoundError(f"The file at {file_path} does not exist.")
    except tomllib.TOMLDecodeError as e:
        raise ValueError(f"Error decoding TOML: {e}")

def is_valid_data(data: dict) -> bool:
    if 'type' not in data: return False
    if 'architecture' not in data: return False
    if data['type'] not in ['function', 'block']: return False
    return True

def get_username_by_api_key(config: dict, api_key: str) -> str | None:
    for username, api_key in config['blserver']['authentication']['api_keys'].items():
        if api_key != api_key: continue
        return username

def create_app(config: str) -> Flask:
    server_config = read_config(config)

    app = Flask(__name__)

    minio_client = BinlexMinio(server_config)
    milvus_client = BinlexMilvus(server_config)

    def require_user_api_key(func):
        """Decorator to require an API key for endpoint access."""
        def wrapper(*args, **kwargs):
            api_key = request.headers.get('API-Key')
            if get_username_by_api_key(server_config, api_key) is None or api_key is None:
                return Response(
                    response=json.dumps({'error': 'Unauthorized'}),
                    status=401,
                    mimetype='application/json'
                )
            return func(*args, **kwargs)
        return wrapper

    api = Api(
        app,
        title='Binlex Server',
        version=f'v{__version__}',
        description='A Binlex Server',
        doc='/swagger'
    )

    embedding_input_model = api.model(
        'EmbeddingInput',
        {
            'type': fields.String(
                required=True,
                description='The type of data to process, must be "function"',
                example='function'
            )
        }
    )

    embedding_search_model = api.model(
        'EmbeddingSearchInput',
        {
            'vector': fields.List(
                fields.Float,
                required=True,
                description='A list of float values representing the embedding vector to search',
                example=[0.1, 0.2, 0.3, 0.4]
            ),
            'query': fields.String(
                description='Query to send to Milvus database to filter results',
                example="file_sha256 != '2d66d000874a77e4c81f5ab34674fbc0bf5e28aac86ce07e5fd99aee1b84d244'"
            )
        }
    )
    
    embedding_query_database = api.model(
        'EmbeddingQueryDatabase',
        {
            'query': fields.String(
                description='Query to send to Milvus database',
                example="file_sha256 == '2d66d000874a77e4c81f5ab34674fbc0bf5e28aac86ce07e5fd99aee1b84d244' and address == 4411523"
            )
        }
    )

    embedding_response_model = api.model(
        'EmbeddingResponse',
        {
            'vector': fields.List(
                fields.Float,
                description='The resulting embedding vector',
                example=[0.1, 0.2, 0.3]
            ),
            'data': fields.Raw(
                description='Original data associated with the embedding',
                example={"key": "value"}
            )
        }
    )

    error_response_model = api.model(
        'ErrorResponse',
        {
            'error': fields.String(
                description='Error message explaining the issue',
                example='Invalid input: Missing "type" field'
            )
        }
    )

    @api.route('/embeddings/<string:database>/<string:collection>/<string:partition>/index')
    class BinlexServerEmbeddingsInsert(Resource):
        @require_user_api_key
        @api.expect(embedding_input_model, validate=True)
        @api.response(200, 'Success', embedding_response_model)
        @api.response(400, 'Invalid Input', error_response_model)
        @api.response(415, 'Unsupported Media Type', error_response_model)
        @api.response(500, 'Internal Server Error', error_response_model)
        @api.doc(description='Insert Embeddings')
        def post(self, database, collection, partition):
            try:
                data = json.loads(request.data)

                if not is_valid_data(data):
                    return {'error': 'Invalid JSON data'}, 400

                if database not in milvus_client.list_databases():
                    return {'error': 'database does not exist'}, 404

                if collection not in milvus_client.get_collection_names(database=database):
                    return {'error': 'unsupported collection'}, 404

                if partition not in milvus_client.get_partition_names(database=database, collection_name=collection):
                    return {'error': 'invalid or unsupported architecture for partition'}, 404

                if partition != data['architecture']:
                    return {'error': 'the architecture does not match the partition'}, 400

                if data['type'] not in ['block', 'function']:
                    return {'error': 'currently unsupported type'}, 400

                username = get_username_by_api_key(server_config, request.headers.get('API-Key'))

                if username is None:
                    return {'error': 'missing username, unauthorized'}, 401

                gnn = BinlexGNN(
                    data,
                    block_pca_dim=server_config['blserver']['gnn']['input'],
                    gnn_hidden_dim=server_config['blserver']['gnn']['hidden'],
                    gnn_output_dim=server_config['blserver']['gnn']['output'],
                )

                gnn.train(epochs=server_config['blserver']['gnn']['epochs'])

                embedding = gnn.to_embedding()
                
                result = milvus_client.index_vector(
                    minio_client=minio_client,
                    database=database,
                    collection_name=collection,
                    partition_name=partition,
                    vector=embedding.vector,
                    data=embedding.data,
                    username=username
                )

                if result is None:
                    return {'error': 'failed to index data'}, 400

                return json.dumps(result), 200
            except Exception as e:
                return {'error': str(e)}, 500

    @api.route('/embeddings/<string:database>/<string:collection>/<string:partitions>/query/<int:offset>/<int:limit>')
    class BinlexServerEmbeddingsQuery(Resource):
        @require_user_api_key
        @api.expect(embedding_query_database, validate=True)
        @api.response(200, 'Success', fields.List(
            fields.Raw(
                description='List of search results from the query sent'
            )
        ))
        @api.response(400, 'Invalid Input', error_response_model)
        @api.response(500, 'Internal Server Error', error_response_model)
        @api.doc(description='Search Embeddings')
        def post(self, database, collection, partitions, offset, limit):
            try:

                partitions = partitions.split('||')

                request_data = json.loads(request.data)

                if not isinstance(request_data, str):
                    return json.dumps({'error': 'expected a string'}), 400
                
                if database not in milvus_client.list_databases():
                    return json.dumps({'error': 'database does not exist'}), 404

                if collection not in milvus_client.get_collection_names(database=database):
                    return json.dumps({'error': 'unsupported collection'}), 404
                
                for partition in partitions:
                    if partition not in milvus_client.get_partition_names(database=database, collection_name='function'):
                        return json.dumps({'error': f'{partition} is an unsupported partition or architecture'}), 404

                results = milvus_client.query(
                    minio_client=minio_client,
                    database=database,
                    collection_name=collection,
                    partition_names=partitions,
                    query=request_data,
                    offset=offset,
                    limit=limit
                )
                return json.dumps(results), 200
            except json.JSONDecodeError:
                return json.dumps({'error': 'Invalid JSON input'}), 400
            except Exception as e:
                return json.dumps({'error': str(e)}), 500

    @api.route('/embeddings/<string:database>/<string:collection>/<string:partitions>/search/<int:offset>/<int:limit>/<float:threshold>')
    class BinlexServerEmbeddingsSearch(Resource):
        @require_user_api_key
        @api.expect(embedding_search_model, validate=True)
        @api.response(200, 'Success', fields.List(
            fields.Raw(
                description='List of search results with similarity scores'
            )
        ))
        @api.response(400, 'Invalid Input', error_response_model)
        @api.response(500, 'Internal Server Error', error_response_model)
        @api.doc(description='Search Embeddings')
        def post(self, database, collection, partitions, offset, limit, threshold):
            try:

                partitions = partitions.split('||')

                request_data = json.loads(request.data)

                if not isinstance(request_data["vector"], list) or not all(isinstance(x, (int, float)) for x in request_data["vector"]):
                    return json.dumps({'error': 'expected a list of float values'}), 400

                if database not in milvus_client.list_databases():
                    return json.dumps({'error': 'database does not exist'}), 404

                if collection not in milvus_client.get_collection_names(database=database):
                    return json.dumps({'error': 'unsupported collection'}), 404

                for partition in partitions:
                    if partition not in milvus_client.get_partition_names(database=database, collection_name=collection):
                        return json.dumps({'error': f'{partition} is an unsupported partition or architecture'}), 404

                results = milvus_client.search_vector(
                    minio_client=minio_client,
                    database=database,
                    collection_name=collection,
                    partition_names=partitions,
                    threshold=threshold,
                    float_vector=request_data["vector"],
                    query=request_data["query"],
                    offset=offset,
                    limit=limit
                )

                return json.dumps(results), 200
            except json.JSONDecodeError:
                return json.dumps({'error': 'Invalid JSON input'}), 400
            except Exception as e:
                return json.dumps({'error': str(e)}), 500

    @api.route('/embeddings/inference')
    class BinlexServerEmbeddingsInference(Resource):
        @require_user_api_key
        @api.expect(embedding_input_model, validate=True)
        @api.response(200, 'Success', embedding_response_model)
        @api.response(400, 'Invalid Input', error_response_model)
        @api.response(415, 'Unsupported Media Type', error_response_model)
        @api.response(500, 'Internal Server Error', error_response_model)
        @api.doc(description='Embedding Inference')
        def post(self):
            try:
                request_data = json.loads(request.data)

                if not is_valid_data(request_data):
                    return {'error': 'invalid or unsupported input data'}, 400

                gnn = BinlexGNN(
                    request_data,
                    block_pca_dim=server_config['blserver']['gnn']['input'],
                    gnn_hidden_dim=server_config['blserver']['gnn']['hidden'],
                    gnn_output_dim=server_config['blserver']['gnn']['output'],
                )

                gnn.train(epochs=server_config['blserver']['gnn']['epochs'])

                embedding = gnn.to_embedding()

                return embedding.vector, 200
            except Exception as e:
                return {'error': str(e)}, 500

    @api.route('/embeddings/databases')
    class BinlexEmbeddingsDatabases(Resource):
        @require_user_api_key
        @api.doc(description='List Databases')
        def get(self):
            try:
                databases = milvus_client.list_databases()
                return databases, 200
            except Exception as e:
                return {'error': str(e)}, 500

    @api.route('/embeddings/dimensions')
    class BinlexEmbeddingsDimensions(Resource):
        @require_user_api_key
        @api.doc(description='Get Embedding Dimensions')
        def get(self):
            try:
                return {
                    'input': server_config['blserver']['gnn']['input'],
                    'hidden': server_config['blserver']['gnn']['hidden'],
                    'output': server_config['blserver']['gnn']['output']
                }, 200
            except Exception as e:
                return {'error': str(e)}, 500

    @api.route('/authentication/whoami')
    class BinlexAuthenticationWhoami(Resource):
        @require_user_api_key
        @api.doc(description='Get Username')
        def get(self):
            try:
                api_key = request.headers.get('API-Key')
                username = get_username_by_api_key(server_config, api_key)
                if username is None:
                    return {'error': 'username not found'}, 404
                return {'username': username}, 200
            except Exception as e:
                return {'error': str(e)}, 500


    @api.route('/embeddings/<string:database>/collections')
    class BinlexEmbeddingsDatabaseCollections(Resource):
        @require_user_api_key
        @api.doc(description='List Database Collections')
        def get(self, database):
            try:
                if database not in milvus_client.list_databases():
                    return {'error': 'database does not exist'}, 404
                collections = milvus_client.get_collection_names(database=database)
                return collections, 200
            except Exception as e:
                return {'error': str(e)}, 500

    @api.route('/embeddings/<string:database>/<string:collection>/partitions')
    class BinlexEmbeddingsDatabaseCollectionPartitions(Resource):
        @require_user_api_key
        @api.doc(description='List Database Collection Partitions')
        def get(self, database, collection):
            try:
                if database not in milvus_client.list_databases():
                    return {'error': 'database does not exist'}, 404

                if collection not in milvus_client.get_collection_names(database=database):
                    return {'error': 'unsupported collection'}, 404

                partitions = milvus_client.get_partition_names(database=database, collection_name=collection)

                return partitions, 200
            except Exception as e:
                return {'error': str(e)}, 500

    print('server started')

    return app

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Binlex Server')
    parser.add_argument('--config', required=True, help='Configuration File Path')

    args = parser.parse_args()

    app = create_app(args.config)

    config = read_config(args.config)

    app.run(
        host=config['blserver']['host'],
        port=config['blserver']['port'],
        debug=config['blserver']['debug']
    )

```

`scripts/blserver/configs/Makefile`:

```
all:
	cp blserver.toml.bak blserver.toml
	cp milvus.yaml.bak milvus.yaml
	cp blserver-proxy.conf.bak blserver-proxy.conf
	cp blserver-proxy.key.bak blserver-proxy.key
	cp blserver-proxy.crt.bak blserver-proxy.crt
	cp attu-proxy.conf.bak attu-proxy.conf
	cp attu-proxy.key.bak attu-proxy.key
	cp attu-proxy.crt.bak attu-proxy.crt
	cp minio-proxy.conf.bak minio-proxy.conf
	cp minio-proxy.key.bak minio-proxy.key
	cp minio-proxy.crt.bak minio-proxy.crt
	cp jupyterhub.py.bak jupyterhub.py
	cp jupyterhub-proxy.conf.bak jupyterhub-proxy.conf
	cp jupyterhub-proxy.key.bak jupyterhub-proxy.key
	cp jupyterhub-proxy.crt.bak jupyterhub-proxy.crt

clean:
	rm -f blserver.toml
	rm -f milvus.yaml
	rm -f blserver-proxy.conf
	rm -f blserver-proxy.crt
	rm -f blserver-proxy.key
	rm -f attu-proxy.conf
	rm -f attu-proxy.crt
	rm -f attu-proxy.key
	rm -f minio-proxy.conf
	rm -f minio-proxy.crt
	rm -f minio-proxy.key
	rm -f jupyterhub.py
	rm -f jupyterhub-proxy.conf
	rm -f jupyterhub-proxy.crt
	rm -f jupyterhub-proxy.key

```

`scripts/blserver/configs/attu-proxy.conf.bak`:

```bak
events {
    worker_connections 1024;
}

http {
    # ---------------------------------------------------------
    # Proxy Cache Path
    # ---------------------------------------------------------
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size=100m inactive=60m use_temp_path=off;

    # ---------------------------------------------------------
    # SERVER BLOCK FOR HTTPS (Port 8443)
    # ---------------------------------------------------------
    server {
        listen 8443 ssl;
        server_name _;  # or your domain, e.g. example.com

        # Point to the cert/key files
        ssl_certificate     /etc/nginx/certs/server.crt;
        ssl_certificate_key /etc/nginx/certs/server.key;

        # Basic SSL config; you may want to adjust ciphers, etc.
        ssl_protocols       TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;

        # Your reverse proxy config
        location / {
            proxy_pass         http://attu:3000;
            proxy_cache        my_cache;
            proxy_cache_valid  200 1m;
            proxy_cache_valid  any 1m;
            add_header X-Proxy-Cache $upstream_cache_status;
        }
    }

    # ---------------------------------------------------------
    # SERVER BLOCK FOR REDIRECT (Port 8080 -> 8443)
    # ---------------------------------------------------------
    server {
        listen 8080;
        server_name _;  # or your domain

        # Simple redirect to HTTPS on port 8443
        return 301 https://$host:8443$request_uri;
    }
}

```

`scripts/blserver/configs/attu-proxy.crt.bak`:

```bak
-----BEGIN CERTIFICATE-----
MIIFCTCCAvGgAwIBAgIUSJ5l6dCl7/S/yAolwsRA/7UmUGowDQYJKoZIhvcNAQEL
BQAwFDESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTI0MTIzMTE2NDEzNloXDTI1MTIz
MTE2NDEzNlowFDESMBAGA1UEAwwJbG9jYWxob3N0MIICIjANBgkqhkiG9w0BAQEF
AAOCAg8AMIICCgKCAgEA2Hj9PxDNZM2Fjcge0+QCj5GXhBH0HGo4njiqQbQV0k7o
pTx8mqcErEymuNdCWuZDiDrwLiXcgi/OVyGKJPGHjbbHPXhD1N1Eo1+dZx+W4qt8
wd9wrcGP9T6BQi4C7xxROmkzD9lrH4E/F9xi91NzMcSNQbAi/MhRCO/UT/IPKSUe
5Ri7Yye554knyQ3zXJVzX5ZDwZ45Y//hjM8szYztCjhXRkuWEri5tu0CeEkw8T/I
sZ9iUHHliVPmCyRlOMyCwBrHgHHGPOZcPEdSdSF+CctisPpezc/4jQFswyLZgak4
LztoaV2NMjp4CM1YR5RsGx/fg6+q/8YAy/5T1G0ULbKguIlXywUI5Yo3+7uf+Fnv
oUZw6GuPDP9wswsg3TNDdfQS8ipWRTr5CErKc8vajpLuj3UkOUyx5pIicvnuilM0
wjAHPIpxVuXAt4lnSysh4MLXiVm6Dils/i/yF/Daed14p/h21MnvXGGEIQgH8ZcM
TyMIZpdyCkJACaktXKP9qpe4jBjhPEiPHECXfbt2c8gwDWiQ/oDJ7Hq0FMSgQQ2L
r1RTgvr4FRBWqaZ0gewFKTomnRI2yStqy6zXCAM326ojTLsfqT0RokpqXVMkj80G
jNI8OBjguR1UAj4NMpK1KZG5IQy960dz4TkWHOXMX0d+kmnqenk4si3RixnUJAkC
AwEAAaNTMFEwHQYDVR0OBBYEFOgDgnCGu431UvzdY5SP3VtmbuLIMB8GA1UdIwQY
MBaAFOgDgnCGu431UvzdY5SP3VtmbuLIMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZI
hvcNAQELBQADggIBAKSl9j8uVK2Lgwhv3mVqVQitKc/qp7b8QfjGYchv6vkM7Abm
/djx52Oul9rWnhC5C4jnI4S3WU8Hhc4WBB7kUSSY1DPVo36tcvuJ6EAHegWaES2j
XKbdSHNqYu5xS9RE2eg9zwlzdf4uSh/KYCcTfcF0QmNJccnQtlvKcJsnu6k9s4vQ
FtS2eQBdRgh519T6VSPqGtCtEnR8YUHFeWYV1Os17Z9RBOMSDfhqRD8bv9YGrUoO
340tCDYsi1t+TYmrbFX0DIZPkXCV5P+U0xC/Fl5aztiKw6x/URLqVsPMPbEZf+A0
dtSnExu2UJORxl8eQnR2G9v7E3kvyDeFS5eWCvmyOzOTI15qjwX2FfPoVwbL3RvY
HPBs2Fco4e6gw8DE5GOwCZCPHutYuR67ai0jQFHA4ESflI/0YJZ6r2ZRdMmWLfl9
MkZ2JqZO++bFb+IfoqyOznZNsxvzJmWnENR+aL6mb6a9i6hlcDwUFT7pVPWWaeCu
xTLi3N9i80gcxywVS1uZPJoDoh7b7Q8qSLT4jyf82Y+H2l4XtDglzWGHvB8pIumO
GAl3pcql9e2dpi0a/X3sZLnwj07r9I4qF6677IhQahguPnWwVyTlowRzIMu9kOoc
cbPcAWhHbJE4SXbavqoWL6Mw2T/It6nbeO3cbiCeB2Cv7ZObR31Ln4BvUIno
-----END CERTIFICATE-----

```

`scripts/blserver/configs/attu-proxy.key.bak`:

```bak
-----BEGIN PRIVATE KEY-----
MIIJQgIBADANBgkqhkiG9w0BAQEFAASCCSwwggkoAgEAAoICAQDYeP0/EM1kzYWN
yB7T5AKPkZeEEfQcajieOKpBtBXSTuilPHyapwSsTKa410Ja5kOIOvAuJdyCL85X
IYok8YeNtsc9eEPU3USjX51nH5biq3zB33CtwY/1PoFCLgLvHFE6aTMP2WsfgT8X
3GL3U3MxxI1BsCL8yFEI79RP8g8pJR7lGLtjJ7nniSfJDfNclXNflkPBnjlj/+GM
zyzNjO0KOFdGS5YSuLm27QJ4STDxP8ixn2JQceWJU+YLJGU4zILAGseAccY85lw8
R1J1IX4Jy2Kw+l7Nz/iNAWzDItmBqTgvO2hpXY0yOngIzVhHlGwbH9+Dr6r/xgDL
/lPUbRQtsqC4iVfLBQjlijf7u5/4We+hRnDoa48M/3CzCyDdM0N19BLyKlZFOvkI
Sspzy9qOku6PdSQ5TLHmkiJy+e6KUzTCMAc8inFW5cC3iWdLKyHgwteJWboOKWz+
L/IX8Np53Xin+HbUye9cYYQhCAfxlwxPIwhml3IKQkAJqS1co/2ql7iMGOE8SI8c
QJd9u3ZzyDANaJD+gMnserQUxKBBDYuvVFOC+vgVEFappnSB7AUpOiadEjbJK2rL
rNcIAzfbqiNMux+pPRGiSmpdUySPzQaM0jw4GOC5HVQCPg0ykrUpkbkhDL3rR3Ph
ORYc5cxfR36Saep6eTiyLdGLGdQkCQIDAQABAoICAAmFE50MBf5cf/a24e0vWjH6
ZQOKvxWnUbdallk2nF2P+RD4NqId/Xl+0veuxsUk2nwxnFmpMlf61nwUNmUuxodz
zfIM+Y2xT+kP5cYQ2HO+Nym3A/duO2Cdh7VzfM9La2KSWQulw/1iE5Ze667FCZw7
ELu+bWF4xUCLfIaqBmLotiG821POXdF6AYkI3yaXj3f5DaCEjvFQAdktjMK643tH
NEZcAVzwKQGrjWfhDyES7SZrlBkl0yJ9kTC1AGsVqlvcqaCjUESiHFUNzWlniEmR
u1S9ZAEw19VKpl/0BsT6HkWMeyhkE/ctJVV8w1i9hR4RwiSCS5a9PFB8Ti85v1D4
9KZ6Omxdehe+j/gIsc0Q2toLINYrowiRU7qcUZbgHpIxBo4e5fepGBzHl3i3czVz
KUN+RKaUfoinvJCN+ShrFNYyUHwiyvCxLjYxoMLKgVVgrmHAKbXBofbz4rLzhkZg
VcL9mtGimTXf+n+A3M9DO0cYsDgCW06Y6NcTA+Pfx7DCvK13dYGpxNjFNIxJM9rM
HzUf2nWsH4rQVD8ZTaxGmpn5ARvyyNDKyaUNzIkpgZzCc7Rdxa5XT59J5T5aTpAG
/fFA79BOvKaNhwcH386cRksWiN9prPxycBPpl4ppQ4SB/oIy1QeKqBsvdPaVPH/0
7TR3i3t+raxCgj6dNjzBAoIBAQDuhNUHDLRARezFjKhRi7T+2Gt4689lL0hAltJF
BA8nB8ed0QZfbs2Seq8VaKZ/to+kiwWmYzCyeUoQ3ZDooNNcX4xitwzjrhmUSnWa
7kLan5vORyTfJZgaI/764kbpcNAHYGL+qLIJRzyCMOIqtgLMcAtSlenicXCotWX+
lgt+emjK104HMp2EElv6yXYCsfaCNIRhArZlmgtJhXo1jp4Z+sABPQEKDB6NNbuw
+0Al5fNwcea0GyjGxK1FGwzBOETqjyYexEdWWdmscLTUJVng+BgJJGBcKmSe95cz
P04M4wqF7HKA16h1P1GesyQuqILUWWocQ+mYwsHOzXS0jlLBAoIBAQDoVoSfg4+q
gccoYHBvGenf6T30Qe6O/+YcbvZjFDR/giVUVkVUpnc4PbI/NUB5l2toPElw8Zx6
/Vd/ng7dT9spIO35k1dMJ/SYL1q3ZS0ya4TOkaoOjVFsRlBCwqptLFFH4Fkx6gFG
BDm/YdvOOcAn0No9Vr7frROrEUkt6JEeFxmR3LpJmUqu0EOEAiXmQTsL6fLVvZma
+UJGv+n+7coNs8TeY5O/n5+iQXbL10H4U79p+s9lSYybxF2I6wZSq+BgyOEEbgN9
FqS6TYCUJrovFQ1r6OpUiuJwqGXJW1JFL5hHHvh73mlPO7bS9wlaH6LPWgRL7E+Z
fK8UuderAEtJAoIBAG5Gg6dKvFuq+JktOvTYvsnEjYvOmoiRn7odAQJfqhHFiwjw
Bx5AQFMk3aXsSG5rnWXZ0LbozS723MOHbOPg11ex5VoOf6sUZ0ckVdNXrRkfCg4I
3oc8/mG3mr+rtlVfjw6aBarvm8CmatdWenp8xDZ45wM7xHKpOAkINSvLe2zyc1i0
yqKRSDozssr0Mdd1KB9y4HFpq6K14doQGDyCv54LTJJF/iEDEW0AFtLwluvusOqf
/qXumJ+tdt6obvE2bsZzgJBg9wp5aCZNxYz/59oXWiV/5/00rGjC1+kdr5xNrCPW
+emPy5bJu5bABE5+Il7DKEgBLhMumCRg4UBJPQECggEBANpOaQEk8fnpRUO4Eg0i
kTFWDGOVC92LryDqVlJUatugYwjyouReIclTl0dy9ukJEN/5PZyFOV4K64s67Yaf
gTMNAO4vtqgVJutUG24VADnO8xPRpLNVr7sH+mQwW0iHirv5nnWbBaVPVR9xiMIm
W1pOELHv7xtmmgN0E4mya6CVXe5DMzrycUz+3WGNTyUiB6QzJ3wUUd9e9BpcOzbR
IbhsQMAhWnOEPc+MqV3xHciCkGm5Q+RNDnRSNvzusJs/am4mcd/iqx5/BzsSlY0f
MnQI2Pqa+IuFkC0A3dssFopxpSi2fg6Nte/AERH7Eut+rFEeqMjZ+xUiJbRYxr+j
YBkCggEALZoM8AZe75oKQ/sgIRfpbEFOVS/dbMU9e5DfPfRaWgyRNqfOhcJsdiEc
CA0ifTnarsEDb/0VgUQh9lc8gkyR/xBHA4P+1vHTmYUD4gnvcZ/yxUPA2nm/Rl2S
P09R9Yv9+CSP3A8+UKRGI0ms2/t/bIWsQ7QLT5AuHc9zrVQariW3tog6XEHb/VLs
vJETlOVb5/dCAFcF/eMGiexlUbc4AYi24Hl00H8proZ9ngKbSbj8J42yM6+orja2
NVCtlvjtEg5XA/IICAkw/0abYRmCiVkjudMPU3fyI0r0xGRr1UUo7h6Oz4kLiCna
/CFsqi3O9p4OjusXe3lpJEJyQpJQgA==
-----END PRIVATE KEY-----

```

`scripts/blserver/configs/blserver-proxy.conf.bak`:

```bak
events {
    worker_connections 1024;
}

http {
    # ---------------------------------------------------------
    # Proxy Cache Path
    # ---------------------------------------------------------
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size=100m inactive=60m use_temp_path=off;

    # ---------------------------------------------------------
    # SERVER BLOCK FOR HTTPS (Port 8443)
    # ---------------------------------------------------------
    server {
        listen 443 ssl;
        server_name _;  # or your domain, e.g. example.com

        # Point to the cert/key files
        ssl_certificate     /etc/nginx/certs/server.crt;
        ssl_certificate_key /etc/nginx/certs/server.key;

        # Basic SSL config; you may want to adjust ciphers, etc.
        ssl_protocols       TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;

        # Your reverse proxy config
        location / {
            proxy_pass         http://blserver:5000;
            proxy_cache        my_cache;
            proxy_cache_valid  200 1m;
            proxy_cache_valid  any 1m;
            add_header X-Proxy-Cache $upstream_cache_status;
        }
    }

    # ---------------------------------------------------------
    # SERVER BLOCK FOR REDIRECT (Port 8080 -> 8443)
    # ---------------------------------------------------------
    server {
        listen 80;
        server_name _;  # or your domain

        # Simple redirect to HTTPS on port 8443
        return 301 https://$host$request_uri;
    }
}

```

`scripts/blserver/configs/blserver-proxy.crt.bak`:

```bak
-----BEGIN CERTIFICATE-----
MIIFCTCCAvGgAwIBAgIUSJ5l6dCl7/S/yAolwsRA/7UmUGowDQYJKoZIhvcNAQEL
BQAwFDESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTI0MTIzMTE2NDEzNloXDTI1MTIz
MTE2NDEzNlowFDESMBAGA1UEAwwJbG9jYWxob3N0MIICIjANBgkqhkiG9w0BAQEF
AAOCAg8AMIICCgKCAgEA2Hj9PxDNZM2Fjcge0+QCj5GXhBH0HGo4njiqQbQV0k7o
pTx8mqcErEymuNdCWuZDiDrwLiXcgi/OVyGKJPGHjbbHPXhD1N1Eo1+dZx+W4qt8
wd9wrcGP9T6BQi4C7xxROmkzD9lrH4E/F9xi91NzMcSNQbAi/MhRCO/UT/IPKSUe
5Ri7Yye554knyQ3zXJVzX5ZDwZ45Y//hjM8szYztCjhXRkuWEri5tu0CeEkw8T/I
sZ9iUHHliVPmCyRlOMyCwBrHgHHGPOZcPEdSdSF+CctisPpezc/4jQFswyLZgak4
LztoaV2NMjp4CM1YR5RsGx/fg6+q/8YAy/5T1G0ULbKguIlXywUI5Yo3+7uf+Fnv
oUZw6GuPDP9wswsg3TNDdfQS8ipWRTr5CErKc8vajpLuj3UkOUyx5pIicvnuilM0
wjAHPIpxVuXAt4lnSysh4MLXiVm6Dils/i/yF/Daed14p/h21MnvXGGEIQgH8ZcM
TyMIZpdyCkJACaktXKP9qpe4jBjhPEiPHECXfbt2c8gwDWiQ/oDJ7Hq0FMSgQQ2L
r1RTgvr4FRBWqaZ0gewFKTomnRI2yStqy6zXCAM326ojTLsfqT0RokpqXVMkj80G
jNI8OBjguR1UAj4NMpK1KZG5IQy960dz4TkWHOXMX0d+kmnqenk4si3RixnUJAkC
AwEAAaNTMFEwHQYDVR0OBBYEFOgDgnCGu431UvzdY5SP3VtmbuLIMB8GA1UdIwQY
MBaAFOgDgnCGu431UvzdY5SP3VtmbuLIMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZI
hvcNAQELBQADggIBAKSl9j8uVK2Lgwhv3mVqVQitKc/qp7b8QfjGYchv6vkM7Abm
/djx52Oul9rWnhC5C4jnI4S3WU8Hhc4WBB7kUSSY1DPVo36tcvuJ6EAHegWaES2j
XKbdSHNqYu5xS9RE2eg9zwlzdf4uSh/KYCcTfcF0QmNJccnQtlvKcJsnu6k9s4vQ
FtS2eQBdRgh519T6VSPqGtCtEnR8YUHFeWYV1Os17Z9RBOMSDfhqRD8bv9YGrUoO
340tCDYsi1t+TYmrbFX0DIZPkXCV5P+U0xC/Fl5aztiKw6x/URLqVsPMPbEZf+A0
dtSnExu2UJORxl8eQnR2G9v7E3kvyDeFS5eWCvmyOzOTI15qjwX2FfPoVwbL3RvY
HPBs2Fco4e6gw8DE5GOwCZCPHutYuR67ai0jQFHA4ESflI/0YJZ6r2ZRdMmWLfl9
MkZ2JqZO++bFb+IfoqyOznZNsxvzJmWnENR+aL6mb6a9i6hlcDwUFT7pVPWWaeCu
xTLi3N9i80gcxywVS1uZPJoDoh7b7Q8qSLT4jyf82Y+H2l4XtDglzWGHvB8pIumO
GAl3pcql9e2dpi0a/X3sZLnwj07r9I4qF6677IhQahguPnWwVyTlowRzIMu9kOoc
cbPcAWhHbJE4SXbavqoWL6Mw2T/It6nbeO3cbiCeB2Cv7ZObR31Ln4BvUIno
-----END CERTIFICATE-----

```

`scripts/blserver/configs/blserver-proxy.key.bak`:

```bak
-----BEGIN PRIVATE KEY-----
MIIJQgIBADANBgkqhkiG9w0BAQEFAASCCSwwggkoAgEAAoICAQDYeP0/EM1kzYWN
yB7T5AKPkZeEEfQcajieOKpBtBXSTuilPHyapwSsTKa410Ja5kOIOvAuJdyCL85X
IYok8YeNtsc9eEPU3USjX51nH5biq3zB33CtwY/1PoFCLgLvHFE6aTMP2WsfgT8X
3GL3U3MxxI1BsCL8yFEI79RP8g8pJR7lGLtjJ7nniSfJDfNclXNflkPBnjlj/+GM
zyzNjO0KOFdGS5YSuLm27QJ4STDxP8ixn2JQceWJU+YLJGU4zILAGseAccY85lw8
R1J1IX4Jy2Kw+l7Nz/iNAWzDItmBqTgvO2hpXY0yOngIzVhHlGwbH9+Dr6r/xgDL
/lPUbRQtsqC4iVfLBQjlijf7u5/4We+hRnDoa48M/3CzCyDdM0N19BLyKlZFOvkI
Sspzy9qOku6PdSQ5TLHmkiJy+e6KUzTCMAc8inFW5cC3iWdLKyHgwteJWboOKWz+
L/IX8Np53Xin+HbUye9cYYQhCAfxlwxPIwhml3IKQkAJqS1co/2ql7iMGOE8SI8c
QJd9u3ZzyDANaJD+gMnserQUxKBBDYuvVFOC+vgVEFappnSB7AUpOiadEjbJK2rL
rNcIAzfbqiNMux+pPRGiSmpdUySPzQaM0jw4GOC5HVQCPg0ykrUpkbkhDL3rR3Ph
ORYc5cxfR36Saep6eTiyLdGLGdQkCQIDAQABAoICAAmFE50MBf5cf/a24e0vWjH6
ZQOKvxWnUbdallk2nF2P+RD4NqId/Xl+0veuxsUk2nwxnFmpMlf61nwUNmUuxodz
zfIM+Y2xT+kP5cYQ2HO+Nym3A/duO2Cdh7VzfM9La2KSWQulw/1iE5Ze667FCZw7
ELu+bWF4xUCLfIaqBmLotiG821POXdF6AYkI3yaXj3f5DaCEjvFQAdktjMK643tH
NEZcAVzwKQGrjWfhDyES7SZrlBkl0yJ9kTC1AGsVqlvcqaCjUESiHFUNzWlniEmR
u1S9ZAEw19VKpl/0BsT6HkWMeyhkE/ctJVV8w1i9hR4RwiSCS5a9PFB8Ti85v1D4
9KZ6Omxdehe+j/gIsc0Q2toLINYrowiRU7qcUZbgHpIxBo4e5fepGBzHl3i3czVz
KUN+RKaUfoinvJCN+ShrFNYyUHwiyvCxLjYxoMLKgVVgrmHAKbXBofbz4rLzhkZg
VcL9mtGimTXf+n+A3M9DO0cYsDgCW06Y6NcTA+Pfx7DCvK13dYGpxNjFNIxJM9rM
HzUf2nWsH4rQVD8ZTaxGmpn5ARvyyNDKyaUNzIkpgZzCc7Rdxa5XT59J5T5aTpAG
/fFA79BOvKaNhwcH386cRksWiN9prPxycBPpl4ppQ4SB/oIy1QeKqBsvdPaVPH/0
7TR3i3t+raxCgj6dNjzBAoIBAQDuhNUHDLRARezFjKhRi7T+2Gt4689lL0hAltJF
BA8nB8ed0QZfbs2Seq8VaKZ/to+kiwWmYzCyeUoQ3ZDooNNcX4xitwzjrhmUSnWa
7kLan5vORyTfJZgaI/764kbpcNAHYGL+qLIJRzyCMOIqtgLMcAtSlenicXCotWX+
lgt+emjK104HMp2EElv6yXYCsfaCNIRhArZlmgtJhXo1jp4Z+sABPQEKDB6NNbuw
+0Al5fNwcea0GyjGxK1FGwzBOETqjyYexEdWWdmscLTUJVng+BgJJGBcKmSe95cz
P04M4wqF7HKA16h1P1GesyQuqILUWWocQ+mYwsHOzXS0jlLBAoIBAQDoVoSfg4+q
gccoYHBvGenf6T30Qe6O/+YcbvZjFDR/giVUVkVUpnc4PbI/NUB5l2toPElw8Zx6
/Vd/ng7dT9spIO35k1dMJ/SYL1q3ZS0ya4TOkaoOjVFsRlBCwqptLFFH4Fkx6gFG
BDm/YdvOOcAn0No9Vr7frROrEUkt6JEeFxmR3LpJmUqu0EOEAiXmQTsL6fLVvZma
+UJGv+n+7coNs8TeY5O/n5+iQXbL10H4U79p+s9lSYybxF2I6wZSq+BgyOEEbgN9
FqS6TYCUJrovFQ1r6OpUiuJwqGXJW1JFL5hHHvh73mlPO7bS9wlaH6LPWgRL7E+Z
fK8UuderAEtJAoIBAG5Gg6dKvFuq+JktOvTYvsnEjYvOmoiRn7odAQJfqhHFiwjw
Bx5AQFMk3aXsSG5rnWXZ0LbozS723MOHbOPg11ex5VoOf6sUZ0ckVdNXrRkfCg4I
3oc8/mG3mr+rtlVfjw6aBarvm8CmatdWenp8xDZ45wM7xHKpOAkINSvLe2zyc1i0
yqKRSDozssr0Mdd1KB9y4HFpq6K14doQGDyCv54LTJJF/iEDEW0AFtLwluvusOqf
/qXumJ+tdt6obvE2bsZzgJBg9wp5aCZNxYz/59oXWiV/5/00rGjC1+kdr5xNrCPW
+emPy5bJu5bABE5+Il7DKEgBLhMumCRg4UBJPQECggEBANpOaQEk8fnpRUO4Eg0i
kTFWDGOVC92LryDqVlJUatugYwjyouReIclTl0dy9ukJEN/5PZyFOV4K64s67Yaf
gTMNAO4vtqgVJutUG24VADnO8xPRpLNVr7sH+mQwW0iHirv5nnWbBaVPVR9xiMIm
W1pOELHv7xtmmgN0E4mya6CVXe5DMzrycUz+3WGNTyUiB6QzJ3wUUd9e9BpcOzbR
IbhsQMAhWnOEPc+MqV3xHciCkGm5Q+RNDnRSNvzusJs/am4mcd/iqx5/BzsSlY0f
MnQI2Pqa+IuFkC0A3dssFopxpSi2fg6Nte/AERH7Eut+rFEeqMjZ+xUiJbRYxr+j
YBkCggEALZoM8AZe75oKQ/sgIRfpbEFOVS/dbMU9e5DfPfRaWgyRNqfOhcJsdiEc
CA0ifTnarsEDb/0VgUQh9lc8gkyR/xBHA4P+1vHTmYUD4gnvcZ/yxUPA2nm/Rl2S
P09R9Yv9+CSP3A8+UKRGI0ms2/t/bIWsQ7QLT5AuHc9zrVQariW3tog6XEHb/VLs
vJETlOVb5/dCAFcF/eMGiexlUbc4AYi24Hl00H8proZ9ngKbSbj8J42yM6+orja2
NVCtlvjtEg5XA/IICAkw/0abYRmCiVkjudMPU3fyI0r0xGRr1UUo7h6Oz4kLiCna
/CFsqi3O9p4OjusXe3lpJEJyQpJQgA==
-----END PRIVATE KEY-----

```

`scripts/blserver/configs/blserver.toml.bak`:

```bak
[blserver]
threads = 1
host = '0.0.0.0'
port = 5000
debug = true

[blserver.authentication.api_keys]
admin = '39248239c8ed937d6333a41874f1c8e310c5070703af30c06e67b0d308cb82c5'

[blserver.gnn]
input = 16
hidden = 32
output = 16
epochs = 10

[blserver.cache]
enabled = true

[minio]
host = 'minio'
port = 9000
object_bucket = 'binlex-objects'
attributes_bucket = 'binlex-attributes'
secure = false

[minio.keys]
access = 'minioadmin'
secret = 'minioadmin'

[milvus]
host = 'milvus'
port = 19530
database = 'default'
databases = [
    'default',
    'goodware',
    'malware',
]
collections = [
    'block',
    'function',
]
partitions = [
    'amd64',
    'i386',
    'cil',
]

[milvus.collection.names]
functions = 'functions'
blocks = 'blocks'

[milvus.authentication]
username = 'root'
password = 'Milvus'

```

`scripts/blserver/configs/jupyterhub-proxy.conf.bak`:

```bak
events {
    worker_connections 1024;
}

http {
    # ---------------------------------------------------------
    # Proxy Cache Path
    # ---------------------------------------------------------
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=my_cache:10m max_size=100m inactive=60m use_temp_path=off;

    # ---------------------------------------------------------
    # SERVER BLOCK FOR HTTPS (Port 6443)
    # ---------------------------------------------------------
    server {
        listen 6443 ssl;
        server_name _;  # or your domain, e.g. example.com

        # Point to the cert/key files
        ssl_certificate     /etc/nginx/certs/server.crt;
        ssl_certificate_key /etc/nginx/certs/server.key;

        # Basic SSL config; you may want to adjust ciphers, etc.
        ssl_protocols       TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;

        # Reverse proxy for JupyterHub
        location / {
            proxy_pass         http://jupyterhub:8000;

            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            real_ip_header X-Real-IP;
            proxy_connect_timeout 300;

            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            chunked_transfer_encoding off;
        }

        # Allow requests for Let's Encrypt verification
        location ~ /.well-known {
            allow all;
        }
    }

    # ---------------------------------------------------------
    # SERVER BLOCK FOR REDIRECT (Port 6080 -> 6443)
    # ---------------------------------------------------------
    server {
        listen 6080;
        server_name _;  # Replace with your domain if needed

        # Redirect HTTP traffic on port 6080 to HTTPS on port 6443
        return 301 https://$host:6443$request_uri;
    }
}

```

`scripts/blserver/configs/jupyterhub-proxy.crt.bak`:

```bak
-----BEGIN CERTIFICATE-----
MIIFCTCCAvGgAwIBAgIUSJ5l6dCl7/S/yAolwsRA/7UmUGowDQYJKoZIhvcNAQEL
BQAwFDESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTI0MTIzMTE2NDEzNloXDTI1MTIz
MTE2NDEzNlowFDESMBAGA1UEAwwJbG9jYWxob3N0MIICIjANBgkqhkiG9w0BAQEF
AAOCAg8AMIICCgKCAgEA2Hj9PxDNZM2Fjcge0+QCj5GXhBH0HGo4njiqQbQV0k7o
pTx8mqcErEymuNdCWuZDiDrwLiXcgi/OVyGKJPGHjbbHPXhD1N1Eo1+dZx+W4qt8
wd9wrcGP9T6BQi4C7xxROmkzD9lrH4E/F9xi91NzMcSNQbAi/MhRCO/UT/IPKSUe
5Ri7Yye554knyQ3zXJVzX5ZDwZ45Y//hjM8szYztCjhXRkuWEri5tu0CeEkw8T/I
sZ9iUHHliVPmCyRlOMyCwBrHgHHGPOZcPEdSdSF+CctisPpezc/4jQFswyLZgak4
LztoaV2NMjp4CM1YR5RsGx/fg6+q/8YAy/5T1G0ULbKguIlXywUI5Yo3+7uf+Fnv
oUZw6GuPDP9wswsg3TNDdfQS8ipWRTr5CErKc8vajpLuj3UkOUyx5pIicvnuilM0
wjAHPIpxVuXAt4lnSysh4MLXiVm6Dils/i/yF/Daed14p/h21MnvXGGEIQgH8ZcM
TyMIZpdyCkJACaktXKP9qpe4jBjhPEiPHECXfbt2c8gwDWiQ/oDJ7Hq0FMSgQQ2L
r1RTgvr4FRBWqaZ0gewFKTomnRI2yStqy6zXCAM326ojTLsfqT0RokpqXVMkj80G
jNI8OBjguR1UAj4NMpK1KZG5IQy960dz4TkWHOXMX0d+kmnqenk4si3RixnUJAkC
AwEAAaNTMFEwHQYDVR0OBBYEFOgDgnCGu431UvzdY5SP3VtmbuLIMB8GA1UdIwQY
MBaAFOgDgnCGu431UvzdY5SP3VtmbuLIMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZI
hvcNAQELBQADggIBAKSl9j8uVK2Lgwhv3mVqVQitKc/qp7b8QfjGYchv6vkM7Abm
/djx52Oul9rWnhC5C4jnI4S3WU8Hhc4WBB7kUSSY1DPVo36tcvuJ6EAHegWaES2j
XKbdSHNqYu5xS9RE2eg9zwlzdf4uSh/KYCcTfcF0QmNJccnQtlvKcJsnu6k9s4vQ
FtS2eQBdRgh519T6VSPqGtCtEnR8YUHFeWYV1Os17Z9RBOMSDfhqRD8bv9YGrUoO
340tCDYsi1t+TYmrbFX0DIZPkXCV5P+U0xC/Fl5aztiKw6x/URLqVsPMPbEZf+A0
dtSnExu2UJORxl8eQnR2G9v7E3kvyDeFS5eWCvmyOzOTI15qjwX2FfPoVwbL3RvY
HPBs2Fco4e6gw8DE5GOwCZCPHutYuR67ai0jQFHA4ESflI/0YJZ6r2ZRdMmWLfl9
MkZ2JqZO++bFb+IfoqyOznZNsxvzJmWnENR+aL6mb6a9i6hlcDwUFT7pVPWWaeCu
xTLi3N9i80gcxywVS1uZPJoDoh7b7Q8qSLT4jyf82Y+H2l4XtDglzWGHvB8pIumO
GAl3pcql9e2dpi0a/X3sZLnwj07r9I4qF6677IhQahguPnWwVyTlowRzIMu9kOoc
cbPcAWhHbJE4SXbavqoWL6Mw2T/It6nbeO3cbiCeB2Cv7ZObR31Ln4BvUIno
-----END CERTIFICATE-----

```

`scripts/blserver/configs/jupyterhub-proxy.key.bak`:

```bak
-----BEGIN PRIVATE KEY-----
MIIJQgIBADANBgkqhkiG9w0BAQEFAASCCSwwggkoAgEAAoICAQDYeP0/EM1kzYWN
yB7T5AKPkZeEEfQcajieOKpBtBXSTuilPHyapwSsTKa410Ja5kOIOvAuJdyCL85X
IYok8YeNtsc9eEPU3USjX51nH5biq3zB33CtwY/1PoFCLgLvHFE6aTMP2WsfgT8X
3GL3U3MxxI1BsCL8yFEI79RP8g8pJR7lGLtjJ7nniSfJDfNclXNflkPBnjlj/+GM
zyzNjO0KOFdGS5YSuLm27QJ4STDxP8ixn2JQceWJU+YLJGU4zILAGseAccY85lw8
R1J1IX4Jy2Kw+l7Nz/iNAWzDItmBqTgvO2hpXY0yOngIzVhHlGwbH9+Dr6r/xgDL
/lPUbRQtsqC4iVfLBQjlijf7u5/4We+hRnDoa48M/3CzCyDdM0N19BLyKlZFOvkI
Sspzy9qOku6PdSQ5TLHmkiJy+e6KUzTCMAc8inFW5cC3iWdLKyHgwteJWboOKWz+
L/IX8Np53Xin+HbUye9cYYQhCAfxlwxPIwhml3IKQkAJqS1co/2ql7iMGOE8SI8c
QJd9u3ZzyDANaJD+gMnserQUxKBBDYuvVFOC+vgVEFappnSB7AUpOiadEjbJK2rL
rNcIAzfbqiNMux+pPRGiSmpdUySPzQaM0jw4GOC5HVQCPg0ykrUpkbkhDL3rR3Ph
ORYc5cxfR36Saep6eTiyLdGLGdQkCQIDAQABAoICAAmFE50MBf5cf/a24e0vWjH6
ZQOKvxWnUbdallk2nF2P+RD4NqId/Xl+0veuxsUk2nwxnFmpMlf61nwUNmUuxodz
zfIM+Y2xT+kP5cYQ2HO+Nym3A/duO2Cdh7VzfM9La2KSWQulw/1iE5Ze667FCZw7
ELu+bWF4xUCLfIaqBmLotiG821POXdF6AYkI3yaXj3f5DaCEjvFQAdktjMK643tH
NEZcAVzwKQGrjWfhDyES7SZrlBkl0yJ9kTC1AGsVqlvcqaCjUESiHFUNzWlniEmR
u1S9ZAEw19VKpl/0BsT6HkWMeyhkE/ctJVV8w1i9hR4RwiSCS5a9PFB8Ti85v1D4
9KZ6Omxdehe+j/gIsc0Q2toLINYrowiRU7qcUZbgHpIxBo4e5fepGBzHl3i3czVz
KUN+RKaUfoinvJCN+ShrFNYyUHwiyvCxLjYxoMLKgVVgrmHAKbXBofbz4rLzhkZg
VcL9mtGimTXf+n+A3M9DO0cYsDgCW06Y6NcTA+Pfx7DCvK13dYGpxNjFNIxJM9rM
HzUf2nWsH4rQVD8ZTaxGmpn5ARvyyNDKyaUNzIkpgZzCc7Rdxa5XT59J5T5aTpAG
/fFA79BOvKaNhwcH386cRksWiN9prPxycBPpl4ppQ4SB/oIy1QeKqBsvdPaVPH/0
7TR3i3t+raxCgj6dNjzBAoIBAQDuhNUHDLRARezFjKhRi7T+2Gt4689lL0hAltJF
BA8nB8ed0QZfbs2Seq8VaKZ/to+kiwWmYzCyeUoQ3ZDooNNcX4xitwzjrhmUSnWa
7kLan5vORyTfJZgaI/764kbpcNAHYGL+qLIJRzyCMOIqtgLMcAtSlenicXCotWX+
lgt+emjK104HMp2EElv6yXYCsfaCNIRhArZlmgtJhXo1jp4Z+sABPQEKDB6NNbuw
+0Al5fNwcea0GyjGxK1FGwzBOETqjyYexEdWWdmscLTUJVng+BgJJGBcKmSe95cz
P04M4wqF7HKA16h1P1GesyQuqILUWWocQ+mYwsHOzXS0jlLBAoIBAQDoVoSfg4+q
gccoYHBvGenf6T30Qe6O/+YcbvZjFDR/giVUVkVUpnc4PbI/NUB5l2toPElw8Zx6
/Vd/ng7dT9spIO35k1dMJ/SYL1q3ZS0ya4TOkaoOjVFsRlBCwqptLFFH4Fkx6gFG
BDm/YdvOOcAn0No9Vr7frROrEUkt6JEeFxmR3LpJmUqu0EOEAiXmQTsL6fLVvZma
+UJGv+n+7coNs8TeY5O/n5+iQXbL10H4U79p+s9lSYybxF2I6wZSq+BgyOEEbgN9
FqS6TYCUJrovFQ1r6OpUiuJwqGXJW1JFL5hHHvh73mlPO7bS9wlaH6LPWgRL7E+Z
fK8UuderAEtJAoIBAG5Gg6dKvFuq+JktOvTYvsnEjYvOmoiRn7odAQJfqhHFiwjw
Bx5AQFMk3aXsSG5rnWXZ0LbozS723MOHbOPg11ex5VoOf6sUZ0ckVdNXrRkfCg4I
3oc8/mG3mr+rtlVfjw6aBarvm8CmatdWenp8xDZ45wM7xHKpOAkINSvLe2zyc1i0
yqKRSDozssr0Mdd1KB9y4HFpq6K14doQGDyCv54LTJJF/iEDEW0AFtLwluvusOqf
/qXumJ+tdt6obvE2bsZzgJBg9wp5aCZNxYz/59oXWiV/5/00rGjC1+kdr5xNrCPW
+emPy5bJu5bABE5+Il7DKEgBLhMumCRg4UBJPQECggEBANpOaQEk8fnpRUO4Eg0i
kTFWDGOVC92LryDqVlJUatugYwjyouReIclTl0dy9ukJEN/5PZyFOV4K64s67Yaf
gTMNAO4vtqgVJutUG24VADnO8xPRpLNVr7sH+mQwW0iHirv5nnWbBaVPVR9xiMIm
W1pOELHv7xtmmgN0E4mya6CVXe5DMzrycUz+3WGNTyUiB6QzJ3wUUd9e9BpcOzbR
IbhsQMAhWnOEPc+MqV3xHciCkGm5Q+RNDnRSNvzusJs/am4mcd/iqx5/BzsSlY0f
MnQI2Pqa+IuFkC0A3dssFopxpSi2fg6Nte/AERH7Eut+rFEeqMjZ+xUiJbRYxr+j
YBkCggEALZoM8AZe75oKQ/sgIRfpbEFOVS/dbMU9e5DfPfRaWgyRNqfOhcJsdiEc
CA0ifTnarsEDb/0VgUQh9lc8gkyR/xBHA4P+1vHTmYUD4gnvcZ/yxUPA2nm/Rl2S
P09R9Yv9+CSP3A8+UKRGI0ms2/t/bIWsQ7QLT5AuHc9zrVQariW3tog6XEHb/VLs
vJETlOVb5/dCAFcF/eMGiexlUbc4AYi24Hl00H8proZ9ngKbSbj8J42yM6+orja2
NVCtlvjtEg5XA/IICAkw/0abYRmCiVkjudMPU3fyI0r0xGRr1UUo7h6Oz4kLiCna
/CFsqi3O9p4OjusXe3lpJEJyQpJQgA==
-----END PRIVATE KEY-----

```

`scripts/blserver/configs/jupyterhub.py.bak`:

```bak
# Configuration file for jupyterhub.

c = get_config()  #noqa

c.Authenticator.allow_all = True

#------------------------------------------------------------------------------
# Application(SingletonConfigurable) configuration
#------------------------------------------------------------------------------
## This is an application.

## The date format used by logging formatters for %(asctime)s
#  Default: '%Y-%m-%d %H:%M:%S'
# c.Application.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#  Default: '[%(name)s]%(highlevel)s %(message)s'
# c.Application.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#  Choices: any of [0, 10, 20, 30, 40, 50, 'DEBUG', 'INFO', 'WARN', 'ERROR', 'CRITICAL']
#  Default: 30
# c.Application.log_level = 30

## Configure additional log handlers.
#
#  The default stderr logs handler is configured by the log_level, log_datefmt
#  and log_format settings.
#
#  This configuration can be used to configure additional handlers (e.g. to
#  output the log to a file) or for finer control over the default handlers.
#
#  If provided this should be a logging configuration dictionary, for more
#  information see:
#  https://docs.python.org/3/library/logging.config.html#logging-config-
#  dictschema
#
#  This dictionary is merged with the base logging configuration which defines
#  the following:
#
#  * A logging formatter intended for interactive use called
#    ``console``.
#  * A logging handler that writes to stderr called
#    ``console`` which uses the formatter ``console``.
#  * A logger with the name of this application set to ``DEBUG``
#    level.
#
#  This example adds a new handler that writes to a file:
#
#  .. code-block:: python
#
#     c.Application.logging_config = {
#         "handlers": {
#             "file": {
#                 "class": "logging.FileHandler",
#                 "level": "DEBUG",
#                 "filename": "<path/to/file>",
#             }
#         },
#         "loggers": {
#             "<application-name>": {
#                 "level": "DEBUG",
#                 # NOTE: if you don't list the default "console"
#                 # handler here then it will be disabled
#                 "handlers": ["console", "file"],
#             },
#         },
#     }
#  Default: {}
# c.Application.logging_config = {}

## Instead of starting the Application, dump configuration to stdout
#  Default: False
# c.Application.show_config = False

## Instead of starting the Application, dump configuration to stdout (as JSON)
#  Default: False
# c.Application.show_config_json = False

#------------------------------------------------------------------------------
# JupyterHub(Application) configuration
#------------------------------------------------------------------------------
## An Application for starting a Multi-User Jupyter Notebook server.

## Maximum number of concurrent servers that can be active at a time.
#
#  Setting this can limit the total resources your users can consume.
#
#  An active server is any server that's not fully stopped. It is considered
#  active from the time it has been requested until the time that it has
#  completely stopped.
#
#  If this many user servers are active, users will not be able to launch new
#  servers until a server is shutdown. Spawn requests will be rejected with a 429
#  error asking them to try again.
#
#  If set to 0, no limit is enforced.
#  Default: 0
# c.JupyterHub.active_server_limit = 0

## Duration (in seconds) to determine the number of active users.
#  Default: 1800
# c.JupyterHub.active_user_window = 1800

## Resolution (in seconds) for updating activity
#
#  If activity is registered that is less than activity_resolution seconds more
#  recent than the current value, the new value will be ignored.
#
#  This avoids too many writes to the Hub database.
#  Default: 30
# c.JupyterHub.activity_resolution = 30

## DEPRECATED since version 2.0.0.
#
#          The default admin role has full permissions, use custom RBAC scopes instead to
#          create restricted administrator roles.
#          https://jupyterhub.readthedocs.io/en/stable/rbac/index.html
#  Default: False
# c.JupyterHub.admin_access = False

## DEPRECATED since version 0.7.2, use Authenticator.admin_users instead.
#  Default: set()
# c.JupyterHub.admin_users = set()

## Allow named single-user servers per user
#  Default: False
# c.JupyterHub.allow_named_servers = False

## Answer yes to any questions (e.g. confirm overwrite)
#  Default: False
# c.JupyterHub.answer_yes = False

## The default amount of records returned by a paginated endpoint
#  Default: 50
# c.JupyterHub.api_page_default_limit = 50

## The maximum amount of records that can be returned at once
#  Default: 200
# c.JupyterHub.api_page_max_limit = 200

## PENDING DEPRECATION: consider using services
#
#          Dict of token:username to be loaded into the database.
#
#          Allows ahead-of-time generation of API tokens for use by externally managed services,
#          which authenticate as JupyterHub users.
#
#          Consider using services for general services that talk to the
#  JupyterHub API.
#  Default: {}
# c.JupyterHub.api_tokens = {}

## Authentication for prometheus metrics
#  Default: True
# c.JupyterHub.authenticate_prometheus = True

## Class for authenticating users.
#
#          This should be a subclass of :class:`jupyterhub.auth.Authenticator`
#
#          with an :meth:`authenticate` method that:
#
#          - is a coroutine (asyncio or tornado)
#          - returns username on success, None on failure
#          - takes two arguments: (handler, data),
#            where `handler` is the calling web.RequestHandler,
#            and `data` is the POST form data from the login page.
#
#          .. versionchanged:: 1.0
#              authenticators may be registered via entry points,
#              e.g. `c.JupyterHub.authenticator_class = 'pam'`
#
#  Currently installed:
#    - default: jupyterhub.auth.PAMAuthenticator
#    - dummy: jupyterhub.auth.DummyAuthenticator
#    - null: jupyterhub.auth.NullAuthenticator
#    - pam: jupyterhub.auth.PAMAuthenticator
#  Default: 'jupyterhub.auth.PAMAuthenticator'
# c.JupyterHub.authenticator_class = 'jupyterhub.auth.PAMAuthenticator'

## The base URL of the entire application.
#
#          Add this to the beginning of all JupyterHub URLs.
#          Use base_url to run JupyterHub within an existing website.
#  Default: '/'
# c.JupyterHub.base_url = '/'

## The public facing URL of the whole JupyterHub application.
#
#          This is the address on which the proxy will bind.
#          Sets protocol, ip, base_url
#  Default: 'http://:8000'
# c.JupyterHub.bind_url = 'http://:8000'

## Whether to shutdown the proxy when the Hub shuts down.
#
#          Disable if you want to be able to teardown the Hub while leaving the
#  proxy running.
#
#          Only valid if the proxy was starting by the Hub process.
#
#          If both this and cleanup_servers are False, sending SIGINT to the Hub will
#          only shutdown the Hub, leaving everything else running.
#
#          The Hub should be able to resume from database state.
#  Default: True
# c.JupyterHub.cleanup_proxy = True

## Whether to shutdown single-user servers when the Hub shuts down.
#
#          Disable if you want to be able to teardown the Hub while leaving the
#  single-user servers running.
#
#          If both this and cleanup_proxy are False, sending SIGINT to the Hub will
#          only shutdown the Hub, leaving everything else running.
#
#          The Hub should be able to resume from database state.
#  Default: True
# c.JupyterHub.cleanup_servers = True

## Maximum number of concurrent users that can be spawning at a time.
#
#  Spawning lots of servers at the same time can cause performance problems for
#  the Hub or the underlying spawning system. Set this limit to prevent bursts of
#  logins from attempting to spawn too many servers at the same time.
#
#  This does not limit the number of total running servers. See
#  active_server_limit for that.
#
#  If more than this many users attempt to spawn at a time, their requests will
#  be rejected with a 429 error asking them to try again. Users will have to wait
#  for some of the spawning services to finish starting before they can start
#  their own.
#
#  If set to 0, no limit is enforced.
#  Default: 100
# c.JupyterHub.concurrent_spawn_limit = 100

## The config file to load
#  Default: 'jupyterhub_config.py'
# c.JupyterHub.config_file = 'jupyterhub_config.py'

## DEPRECATED: does nothing
#  Default: False
# c.JupyterHub.confirm_no_ssl = False

## Enable `__Host-` prefix on authentication cookies.
#
#          The `__Host-` prefix on JupyterHub cookies provides further
#          protection against cookie tossing when untrusted servers
#          may control subdomains of your jupyterhub deployment.
#
#          _However_, it also requires that cookies be set on the path `/`,
#          which means they are shared by all JupyterHub components,
#          so a compromised server component will have access to _all_ JupyterHub-related
#          cookies of the visiting browser.
#          It is recommended to only combine `__Host-` cookies with per-user domains.
#
#          .. versionadded:: 4.1
#  Default: False
# c.JupyterHub.cookie_host_prefix_enabled = False

## Number of days for a login cookie to be valid.
#          Default is two weeks.
#  Default: 14
# c.JupyterHub.cookie_max_age_days = 14

## The cookie secret to use to encrypt cookies.
#
#          Loaded from the JPY_COOKIE_SECRET env variable by default.
#
#          Should be exactly 256 bits (32 bytes).
#  Default: traitlets.Undefined
# c.JupyterHub.cookie_secret = traitlets.Undefined

## File in which to store the cookie secret.
#  Default: 'jupyterhub_cookie_secret'
# c.JupyterHub.cookie_secret_file = 'jupyterhub_cookie_secret'

## Custom scopes to define.
#
#          For use when defining custom roles,
#          to grant users granular permissions
#
#          All custom scopes must have a description,
#          and must start with the prefix `custom:`.
#
#          For example::
#
#              custom_scopes = {
#                  "custom:jupyter_server:read": {
#                      "description": "read-only access to a single-user server",
#                  },
#              }
#  Default: {}
# c.JupyterHub.custom_scopes = {}

## The location of jupyterhub data files (e.g. /usr/local/share/jupyterhub)
#  Default: '/home/c3rb3ru5/Tools/binlex/scripts/blserver/venv/share/jupyterhub'
# c.JupyterHub.data_files_path = '/home/c3rb3ru5/Tools/binlex/scripts/blserver/venv/share/jupyterhub'

## Include any kwargs to pass to the database connection.
#          See sqlalchemy.create_engine for details.
#  Default: {}
# c.JupyterHub.db_kwargs = {}

## url for the database. e.g. `sqlite:///jupyterhub.sqlite`
#  Default: 'sqlite:///jupyterhub.sqlite'
# c.JupyterHub.db_url = 'sqlite:///jupyterhub.sqlite'

## log all database transactions. This has A LOT of output
#  Default: False
# c.JupyterHub.debug_db = False

## DEPRECATED since version 0.8: Use ConfigurableHTTPProxy.debug
#  Default: False
# c.JupyterHub.debug_proxy = False

## If named servers are enabled, default name of server to spawn or open when no
#  server is specified, e.g. by user-redirect.
#
#  Note: This has no effect if named servers are not enabled, and does _not_
#  change the existence or behavior of the default server named `''` (the empty
#  string). This only affects which named server is launched when no server is
#  specified, e.g. by links to `/hub/user-redirect/lab/tree/mynotebook.ipynb`.
#  Default: ''
# c.JupyterHub.default_server_name = ''

## The default URL for users when they arrive (e.g. when user directs to "/")
#
#  By default, redirects users to their own server.
#
#  Can be a Unicode string (e.g. '/hub/home') or a callable based on the handler
#  object:
#
#  ::
#
#      def default_url_fn(handler):
#          user = handler.current_user
#          if user and user.admin:
#              return '/hub/admin'
#          return '/hub/home'
#
#      c.JupyterHub.default_url = default_url_fn
#  Default: traitlets.Undefined
# c.JupyterHub.default_url = traitlets.Undefined

## Dict authority:dict(files). Specify the key, cert, and/or
#          ca file for an authority. This is useful for externally managed
#          proxies that wish to use internal_ssl.
#
#          The files dict has this format (you must specify at least a cert)::
#
#              {
#                  'key': '/path/to/key.key',
#                  'cert': '/path/to/cert.crt',
#                  'ca': '/path/to/ca.crt'
#              }
#
#          The authorities you can override: 'hub-ca', 'notebooks-ca',
#          'proxy-api-ca', 'proxy-client-ca', and 'services-ca'.
#
#          Use with internal_ssl
#  Default: {}
# c.JupyterHub.external_ssl_authorities = {}

## DEPRECATED.
#
#  If you need to register additional HTTP endpoints please use services instead.
#  Default: []
# c.JupyterHub.extra_handlers = []

## DEPRECATED: use output redirection instead, e.g.
#
#  jupyterhub &>> /var/log/jupyterhub.log
#  Default: ''
# c.JupyterHub.extra_log_file = ''

## Extra log handlers to set on JupyterHub logger
#  Default: []
# c.JupyterHub.extra_log_handlers = []

## Alternate header to use as the Host (e.g., X-Forwarded-Host)
#          when determining whether a request is cross-origin
#
#          This may be useful when JupyterHub is running behind a proxy that rewrites
#          the Host header.
#  Default: ''
# c.JupyterHub.forwarded_host_header = ''

## Generate certs used for internal ssl
#  Default: False
# c.JupyterHub.generate_certs = False

## Generate default config file
#  Default: False
# c.JupyterHub.generate_config = False

## The URL on which the Hub will listen. This is a private URL for internal
#  communication. Typically set in combination with hub_connect_url. If a unix
#  socket, hub_connect_url **must** also be set.
#
#  For example:
#
#      "http://127.0.0.1:8081"
#      "unix+http://%2Fsrv%2Fjupyterhub%2Fjupyterhub.sock"
#
#  .. versionadded:: 0.9
#  Default: ''
# c.JupyterHub.hub_bind_url = ''

## The ip or hostname for proxies and spawners to use
#          for connecting to the Hub.
#
#          Use when the bind address (`hub_ip`) is 0.0.0.0, :: or otherwise different
#          from the connect address.
#
#          Default: when `hub_ip` is 0.0.0.0 or ::, use `socket.gethostname()`,
#  otherwise use `hub_ip`.
#
#          Note: Some spawners or proxy implementations might not support hostnames. Check your
#          spawner or proxy documentation to see if they have extra requirements.
#
#          .. versionadded:: 0.8
#  Default: ''
c.JupyterHub.hub_connect_ip = '0.0.0.0'

## DEPRECATED
#
#  Use hub_connect_url
#
#  .. versionadded:: 0.8
#
#  .. deprecated:: 0.9
#      Use hub_connect_url
#  Default: 0
#c.JupyterHub.hub_connect_port = 8000

## The URL for connecting to the Hub. Spawners, services, and the proxy will use
#  this URL to talk to the Hub.
#
#  Only needs to be specified if the default hub URL is not connectable (e.g.
#  using a unix+http:// bind url).
#
#  .. seealso::
#      JupyterHub.hub_connect_ip
#      JupyterHub.hub_bind_url
#
#  .. versionadded:: 0.9
#  Default: ''
# c.JupyterHub.hub_connect_url = ''

## The ip address for the Hub process to *bind* to.
#
#          By default, the hub listens on localhost only. This address must be accessible from
#          the proxy and user servers. You may need to set this to a public ip or '' for all
#          interfaces if the proxy or user servers are in containers or on a different host.
#
#          See `hub_connect_ip` for cases where the bind and connect address should differ,
#          or `hub_bind_url` for setting the full bind URL.
#  Default: '127.0.0.1'
c.JupyterHub.hub_ip = '0.0.0.0'

## The internal port for the Hub process.
#
#          This is the internal port of the hub itself. It should never be accessed directly.
#          See JupyterHub.port for the public port to use when accessing jupyterhub.
#          It is rare that this port should be set except in cases of port conflict.
#
#          See also `hub_ip` for the ip and `hub_bind_url` for setting the full
#  bind URL.
#  Default: 8081
# c.JupyterHub.hub_port = 8081

## The routing prefix for the Hub itself.
#
#  Override to send only a subset of traffic to the Hub. Default is to use the
#  Hub as the default route for all requests.
#
#  This is necessary for normal jupyterhub operation, as the Hub must receive
#  requests for e.g. `/user/:name` when the user's server is not running.
#
#  However, some deployments using only the JupyterHub API may want to handle
#  these events themselves, in which case they can register their own default
#  target with the proxy and set e.g. `hub_routespec = /hub/` to serve only the
#  hub's own pages, or even `/hub/api/` for api-only operation.
#
#  Note: hub_routespec must include the base_url, if any.
#
#  .. versionadded:: 1.4
#  Default: '/'
# c.JupyterHub.hub_routespec = '/'

## Trigger implicit spawns after this many seconds.
#
#          When a user visits a URL for a server that's not running,
#          they are shown a page indicating that the requested server
#          is not running with a button to spawn the server.
#
#          Setting this to a positive value will redirect the user
#          after this many seconds, effectively clicking this button
#          automatically for the users,
#          automatically beginning the spawn process.
#
#          Warning: this can result in errors and surprising behavior
#          when sharing access URLs to actual servers,
#          since the wrong server is likely to be started.
#  Default: 0
# c.JupyterHub.implicit_spawn_seconds = 0

## Timeout (in seconds) to wait for spawners to initialize
#
#  Checking if spawners are healthy can take a long time if many spawners are
#  active at hub start time.
#
#  If it takes longer than this timeout to check, init_spawner will be left to
#  complete in the background and the http server is allowed to start.
#
#  A timeout of -1 means wait forever, which can mean a slow startup of the Hub
#  but ensures that the Hub is fully consistent by the time it starts responding
#  to requests. This matches the behavior of jupyterhub 1.0.
#
#  .. versionadded: 1.1.0
#  Default: 10
# c.JupyterHub.init_spawners_timeout = 10

## The location to store certificates automatically created by
#          JupyterHub.
#
#          Use with internal_ssl
#  Default: 'internal-ssl'
# c.JupyterHub.internal_certs_location = 'internal-ssl'

## Enable SSL for all internal communication
#
#          This enables end-to-end encryption between all JupyterHub components.
#          JupyterHub will automatically create the necessary certificate
#          authority and sign notebook certificates as they're created.
#  Default: False
# c.JupyterHub.internal_ssl = False

## The public facing ip of the whole JupyterHub application
#          (specifically referred to as the proxy).
#
#          This is the address on which the proxy will listen. The default is to
#          listen on all interfaces. This is the only address through which JupyterHub
#          should be accessed by users.
#  Default: ''
# c.JupyterHub.ip = ''

## Supply extra arguments that will be passed to Jinja environment.
#  Default: {}
# c.JupyterHub.jinja_environment_options = {}

## Interval (in seconds) at which to update last-activity timestamps.
#  Default: 300
# c.JupyterHub.last_activity_interval = 300

## Dict of `{'group': {'users':['usernames'], 'properties': {}}`  to load at
#  startup.
#
#  Example::
#
#      c.JupyterHub.load_groups = {
#          'groupname': {
#              'users': ['usernames'],
#              'properties': {'key': 'value'},
#          },
#      }
#
#  This strictly *adds* groups and users to groups. Properties, if defined,
#  replace all existing properties.
#
#  Loading one set of groups, then starting JupyterHub again with a different set
#  will not remove users or groups from previous launches. That must be done
#  through the API.
#
#  .. versionchanged:: 3.2
#    Changed format of group from list of usernames to dict
#  Default: {}
# c.JupyterHub.load_groups = {}

## List of predefined role dictionaries to load at startup.
#
#          For instance::
#
#              load_roles = [
#                              {
#                                  'name': 'teacher',
#                                  'description': 'Access to users' information and group membership',
#                                  'scopes': ['users', 'groups'],
#                                  'users': ['cyclops', 'gandalf'],
#                                  'services': [],
#                                  'groups': []
#                              }
#                          ]
#
#          All keys apart from 'name' are optional.
#          See all the available scopes in the JupyterHub REST API documentation.
#
#          Default roles are defined in roles.py.
#  Default: []
# c.JupyterHub.load_roles = []

## The date format used by logging formatters for %(asctime)s
#  See also: Application.log_datefmt
# c.JupyterHub.log_datefmt = '%Y-%m-%d %H:%M:%S'

## The Logging format template
#  See also: Application.log_format
# c.JupyterHub.log_format = '[%(name)s]%(highlevel)s %(message)s'

## Set the log level by value or name.
#  See also: Application.log_level
# c.JupyterHub.log_level = 30

##
#  See also: Application.logging_config
# c.JupyterHub.logging_config = {}

## Specify path to a logo image to override the Jupyter logo in the banner.
#  Default: ''
# c.JupyterHub.logo_file = ''

## Maximum number of concurrent named servers that can be created by a user at a
#  time.
#
#  Setting this can limit the total resources a user can consume.
#
#  If set to 0, no limit is enforced.
#
#  Can be an integer or a callable/awaitable based on the handler object:
#
#  ::
#
#      def named_server_limit_per_user_fn(handler):
#          user = handler.current_user
#          if user and user.admin:
#              return 0
#          return 5
#
#      c.JupyterHub.named_server_limit_per_user = named_server_limit_per_user_fn
#  Default: 0
# c.JupyterHub.named_server_limit_per_user = 0

## Expiry (in seconds) of OAuth access tokens.
#
#          The default is to expire when the cookie storing them expires,
#          according to `cookie_max_age_days` config.
#
#          These are the tokens stored in cookies when you visit
#          a single-user server or service.
#          When they expire, you must re-authenticate with the Hub,
#          even if your Hub authentication is still valid.
#          If your Hub authentication is valid,
#          logging in may be a transparent redirect as you refresh the page.
#
#          This does not affect JupyterHub API tokens in general,
#          which do not expire by default.
#          Only tokens issued during the oauth flow
#          accessing services and single-user servers are affected.
#
#          .. versionadded:: 1.4
#              OAuth token expires_in was not previously configurable.
#          .. versionchanged:: 1.4
#              Default now uses cookie_max_age_days so that oauth tokens
#              which are generally stored in cookies,
#              expire when the cookies storing them expire.
#              Previously, it was one hour.
#  Default: 0
# c.JupyterHub.oauth_token_expires_in = 0

## File to write PID
#          Useful for daemonizing JupyterHub.
#  Default: ''
# c.JupyterHub.pid_file = ''

## The public facing port of the proxy.
#
#          This is the port on which the proxy will listen.
#          This is the only port through which JupyterHub
#          should be accessed by users.
#  Default: 8000
# c.JupyterHub.port = 8000

## DEPRECATED since version 0.8 : Use ConfigurableHTTPProxy.api_url
#  Default: ''
# c.JupyterHub.proxy_api_ip = ''

## DEPRECATED since version 0.8 : Use ConfigurableHTTPProxy.api_url
#  Default: 0
# c.JupyterHub.proxy_api_port = 0

## DEPRECATED since version 0.8: Use ConfigurableHTTPProxy.auth_token
#  Default: ''
# c.JupyterHub.proxy_auth_token = ''

## DEPRECATED since version 0.8: Use ConfigurableHTTPProxy.check_running_interval
#  Default: 5
# c.JupyterHub.proxy_check_interval = 5

## The class to use for configuring the JupyterHub proxy.
#
#          Should be a subclass of :class:`jupyterhub.proxy.Proxy`.
#
#          .. versionchanged:: 1.0
#              proxies may be registered via entry points,
#              e.g. `c.JupyterHub.proxy_class = 'traefik'`
#
#  Currently installed:
#    - configurable-http-proxy: jupyterhub.proxy.ConfigurableHTTPProxy
#    - default: jupyterhub.proxy.ConfigurableHTTPProxy
#  Default: 'jupyterhub.proxy.ConfigurableHTTPProxy'
# c.JupyterHub.proxy_class = 'jupyterhub.proxy.ConfigurableHTTPProxy'

## DEPRECATED since version 0.8. Use ConfigurableHTTPProxy.command
#  Default: []
# c.JupyterHub.proxy_cmd = []

## Set the public URL of JupyterHub
#
#          This will skip any detection of URL and protocol from requests,
#          which isn't always correct when JupyterHub is behind
#          multiple layers of proxies, etc.
#          Usually the failure is detecting http when it's really https.
#
#          Should include the full, public URL of JupyterHub,
#          including the public-facing base_url prefix
#          (i.e. it should include a trailing slash), e.g.
#          https://jupyterhub.example.org/prefix/
#  Default: ''
# c.JupyterHub.public_url = ''

## Recreate all certificates used within JupyterHub on restart.
#
#          Note: enabling this feature requires restarting all notebook servers.
#
#          Use with internal_ssl
#  Default: False
# c.JupyterHub.recreate_internal_certs = False

## Redirect user to server (if running), instead of control panel.
#  Default: True
# c.JupyterHub.redirect_to_server = True

## Purge and reset the database.
#  Default: False
# c.JupyterHub.reset_db = False

## Interval (in seconds) at which to check connectivity of services with web
#  endpoints.
#  Default: 60
# c.JupyterHub.service_check_interval = 60

## Dict of token:servicename to be loaded into the database.
#
#          Allows ahead-of-time generation of API tokens for use by externally
#  managed services.
#  Default: {}
# c.JupyterHub.service_tokens = {}

## List of service specification dictionaries.
#
#          A service
#
#          For instance::
#
#              services = [
#                  {
#                      'name': 'cull_idle',
#                      'command': ['/path/to/cull_idle_servers.py'],
#                  },
#                  {
#                      'name': 'formgrader',
#                      'url': 'http://127.0.0.1:1234',
#                      'api_token': 'super-secret',
#                      'environment':
#                  }
#              ]
#  Default: []
# c.JupyterHub.services = []

## Instead of starting the Application, dump configuration to stdout
#  See also: Application.show_config
# c.JupyterHub.show_config = False

## Instead of starting the Application, dump configuration to stdout (as JSON)
#  See also: Application.show_config_json
# c.JupyterHub.show_config_json = False

## Shuts down all user servers on logout
#  Default: False
# c.JupyterHub.shutdown_on_logout = False

## The class to use for spawning single-user servers.
#
#          Should be a subclass of :class:`jupyterhub.spawner.Spawner`.
#
#          .. versionchanged:: 1.0
#              spawners may be registered via entry points,
#              e.g. `c.JupyterHub.spawner_class = 'localprocess'`
#
#  Currently installed:
#    - default: jupyterhub.spawner.LocalProcessSpawner
#    - localprocess: jupyterhub.spawner.LocalProcessSpawner
#    - simple: jupyterhub.spawner.SimpleLocalProcessSpawner
#  Default: 'jupyterhub.spawner.LocalProcessSpawner'
# c.JupyterHub.spawner_class = 'jupyterhub.spawner.LocalProcessSpawner'

## Path to SSL certificate file for the public facing interface of the proxy
#
#          When setting this, you should also set ssl_key
#  Default: ''
# c.JupyterHub.ssl_cert = ''

## Path to SSL key file for the public facing interface of the proxy
#
#          When setting this, you should also set ssl_cert
#  Default: ''
# c.JupyterHub.ssl_key = ''

## Host to send statsd metrics to. An empty string (the default) disables sending
#  metrics.
#  Default: ''
# c.JupyterHub.statsd_host = ''

## Port on which to send statsd metrics about the hub
#  Default: 8125
# c.JupyterHub.statsd_port = 8125

## Prefix to use for all metrics sent by jupyterhub to statsd
#  Default: 'jupyterhub'
# c.JupyterHub.statsd_prefix = 'jupyterhub'

## Hook for constructing subdomains for users and services. Only used when
#  `JupyterHub.subdomain_host` is set.
#
#  There are two predefined hooks, which can be selected by name:
#
#  - 'legacy' (deprecated) - 'idna' (default, more robust. No change for _most_
#  usernames)
#
#  Otherwise, should be a function which must not be async. A custom
#  subdomain_hook should have the signature:
#
#  def subdomain_hook(name, domain, kind) -> str:
#      ...
#
#  and should return a unique, valid domain name for all usernames.
#
#  - `name` is the original name, which may need escaping to be safe as a domain
#  name label - `domain` is the domain of the Hub itself - `kind` will be one of
#  'user' or 'service'
#
#  JupyterHub itself puts very little limit on usernames to accommodate a wide
#  variety of Authenticators, but your identity provider is likely much more
#  strict, allowing you to make assumptions about the name.
#
#  The 'idna' hook should produce a valid domain name for any user, using IDNA
#  encoding for unicode usernames, and a truncate-and-hash approach for any
#  usernames that can't be easily encoded into a domain component.
#
#  .. versionadded:: 5.0
#  Default: 'idna'
# c.JupyterHub.subdomain_hook = 'idna'

## Run single-user servers on subdomains of this host.
#
#          This should be the full `https://hub.domain.tld[:port]`.
#
#          Provides additional cross-site protections for javascript served by
#  single-user servers.
#
#          Requires `<username>.hub.domain.tld` to resolve to the same host as
#  `hub.domain.tld`.
#
#          In general, this is most easily achieved with wildcard DNS.
#
#          When using SSL (i.e. always) this also requires a wildcard SSL
#  certificate.
#  Default: ''
# c.JupyterHub.subdomain_host = ''

## Paths to search for jinja templates, before using the default templates.
#  Default: []
# c.JupyterHub.template_paths = []

## Extra variables to be passed into jinja templates.
#
#          Values in dict may contain callable objects.
#          If value is callable, the current user is passed as argument.
#
#          Example::
#
#              def callable_value(user):
#                  # user is generated by handlers.base.get_current_user
#                  with open("/tmp/file.txt", "r") as f:
#                      ret = f.read()
#                  ret = ret.replace("<username>", user.name)
#                  return ret
#
#              c.JupyterHub.template_vars = {
#                  "key1": "value1",
#                  "key2": callable_value,
#              }
#  Default: {}
# c.JupyterHub.template_vars = {}

## Set the maximum expiration (in seconds) of tokens created via the API.
#
#  Set to any positive value to disallow creation of tokens with no expiration.
#
#  0 (default) = no limit.
#
#  Does not affect:
#
#  - Server API tokens ($JUPYTERHUB_API_TOKEN is tied to lifetime of the server)
#  - Tokens issued during oauth (use `oauth_token_expires_in`) - Tokens created
#  via the API before configuring this limit
#
#  .. versionadded:: 5.1
#  Default: 0
# c.JupyterHub.token_expires_in_max_seconds = 0

## Extra settings overrides to pass to the tornado application.
#  Default: {}
# c.JupyterHub.tornado_settings = {}

## Trust user-provided tokens (via JupyterHub.service_tokens)
#          to have good entropy.
#
#          If you are not inserting additional tokens via configuration file,
#          this flag has no effect.
#
#          In JupyterHub 0.8, internally generated tokens do not
#          pass through additional hashing because the hashing is costly
#          and does not increase the entropy of already-good UUIDs.
#
#          User-provided tokens, on the other hand, are not trusted to have good entropy by default,
#          and are passed through many rounds of hashing to stretch the entropy of the key
#          (i.e. user-provided tokens are treated as passwords instead of random keys).
#          These keys are more costly to check.
#
#          If your inserted tokens are generated by a good-quality mechanism,
#          e.g. `openssl rand -hex 32`, then you can set this flag to True
#          to reduce the cost of checking authentication tokens.
#  Default: False
# c.JupyterHub.trust_user_provided_tokens = False

## Names to include in the subject alternative name.
#
#          These names will be used for server name verification. This is useful
#          if JupyterHub is being run behind a reverse proxy or services using ssl
#          are on different hosts.
#
#          Use with internal_ssl
#  Default: []
# c.JupyterHub.trusted_alt_names = []

## Downstream proxy IP addresses to trust.
#
#          This sets the list of IP addresses that are trusted and skipped when processing
#          the `X-Forwarded-For` header. For example, if an external proxy is used for TLS
#          termination, its IP address should be added to this list to ensure the correct
#          client IP addresses are recorded in the logs instead of the proxy server's IP
#          address.
#  Default: []
# c.JupyterHub.trusted_downstream_ips = []

## Upgrade the database automatically on start.
#
#          Only safe if database is regularly backed up.
#          Only SQLite databases will be backed up to a local file automatically.
#  Default: False
# c.JupyterHub.upgrade_db = False

## Return 503 rather than 424 when request comes in for a non-running server.
#
#  Prior to JupyterHub 2.0, we returned a 503 when any request came in for a user
#  server that was currently not running. By default, JupyterHub 2.0 will return
#  a 424 - this makes operational metric dashboards more useful.
#
#  JupyterLab < 3.2 expected the 503 to know if the user server is no longer
#  running, and prompted the user to start their server. Set this config to true
#  to retain the old behavior, so JupyterLab < 3.2 can continue to show the
#  appropriate UI when the user server is stopped.
#
#  This option will be removed in a future release.
#  Default: False
# c.JupyterHub.use_legacy_stopped_server_status_code = False

## Callable to affect behavior of /user-redirect/
#
#  Receives 4 parameters: 1. path - URL path that was provided after /user-
#  redirect/ 2. request - A Tornado HTTPServerRequest representing the current
#  request. 3. user - The currently authenticated user. 4. base_url - The
#  base_url of the current hub, for relative redirects
#
#  It should return the new URL to redirect to, or None to preserve current
#  behavior.
#  Default: None
# c.JupyterHub.user_redirect_hook = None

#------------------------------------------------------------------------------
# Authenticator(LoggingConfigurable) configuration
#------------------------------------------------------------------------------
## Base class for implementing an authentication provider for JupyterHub

## Set of users that will be granted admin rights on this JupyterHub.
#
#  Note:
#
#      As of JupyterHub 2.0,
#      full admin rights should not be required,
#      and more precise permissions can be managed via roles.
#
#  Caution:
#
#      Adding users to `admin_users` can only *grant* admin rights,
#      removing a username from the admin_users set **DOES NOT** remove admin rights previously granted.
#
#      For an authoritative, restricted set of admins,
#      assign explicit membership of the `admin` *role*::
#
#          c.JupyterHub.load_roles = [
#              {
#                  "name": "admin",
#                  "users": ["admin1", "..."],
#              }
#          ]
#
#  Admin users can take every possible action on behalf of all users, for
#  example:
#
#  - Use the admin panel to see list of users logged in - Add / remove users in
#  some authenticators - Restart / halt the hub - Start / stop users' single-user
#  servers - Can access each individual users' single-user server
#
#  Admin access should be treated the same way root access is.
#
#  Defaults to an empty set, in which case no user has admin access.
#  Default: set()
# c.Authenticator.admin_users = set()

## Allow every user who can successfully authenticate to access JupyterHub.
#
#  False by default, which means for most Authenticators, _some_ allow-related
#  configuration is required to allow users to log in.
#
#  Authenticator subclasses may override the default with e.g.::
#
#      @default("allow_all")
#      def _default_allow_all(self):
#          # if _any_ auth config (depends on the Authenticator)
#          if self.allowed_users or self.allowed_groups or self.allow_existing_users:
#              return False
#          else:
#              return True
#
#  .. versionadded:: 5.0
#
#  .. versionchanged:: 5.0
#      Prior to 5.0, `allow_all` wasn't defined on its own,
#      and was instead implicitly True when no allow config was provided,
#      i.e. `allowed_users` unspecified or empty on the base Authenticator class.
#
#      To preserve pre-5.0 behavior,
#      set `allow_all = True` if you have no other allow configuration.
#  Default: False
# c.Authenticator.allow_all = False

## Allow existing users to login.
#
#  Defaults to True if `allowed_users` is set for historical reasons, and False
#  otherwise.
#
#  With this enabled, all users present in the JupyterHub database are allowed to
#  login. This has the effect of any user who has _previously_ been allowed to
#  login via any means will continue to be allowed until the user is deleted via
#  the /hub/admin page or REST API.
#
#  .. warning::
#
#     Before enabling this you should review the existing users in the
#     JupyterHub admin panel at `/hub/admin`. You may find users existing
#     there because they have previously been declared in config such as
#     `allowed_users` or allowed to sign in.
#
#  .. warning::
#
#     When this is enabled and you wish to remove access for one or more
#     users previously allowed, you must make sure that they
#     are removed from the jupyterhub database. This can be tricky to do
#     if you stop allowing an externally managed group of users for example.
#
#  With this enabled, JupyterHub admin users can visit `/hub/admin` or use
#  JupyterHub's REST API to add and remove users to manage who can login.
#
#  .. versionadded:: 5.0
#  Default: False
# c.Authenticator.allow_existing_users = False

## Set of usernames that are allowed to log in.
#
#  Use this to limit which authenticated users may login. Default behavior: only
#  users in this set are allowed.
#
#  If empty, does not perform any restriction, in which case any authenticated
#  user is allowed.
#
#  Authenticators may extend :meth:`.Authenticator.check_allowed` to combine
#  `allowed_users` with other configuration to either expand or restrict access.
#
#  .. versionchanged:: 1.2
#      `Authenticator.whitelist` renamed to `allowed_users`
#  Default: set()
# c.Authenticator.allowed_users = set()

## Is there any allow config?
#
#          Used to show a warning if it looks like nobody can access the Hub,
#          which can happen when upgrading to JupyterHub 5,
#          now that `allow_all` defaults to False.
#
#          Deployments can set this explicitly to True to suppress
#          the "No allow config found" warning.
#
#          Will be True if any config tagged with `.tag(allow_config=True)`
#          or starts with `allow` is truthy.
#
#          .. versionadded:: 5.0
#  Default: False
# c.Authenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#          before forcing a refresh of user auth info.
#
#          Refreshing auth info allows, e.g. requesting/re-validating auth
#  tokens.
#
#          See :meth:`.refresh_user` for what happens when user auth info is refreshed
#          (nothing by default).
#  Default: 300
# c.Authenticator.auth_refresh_age = 300

## Automatically begin the login process
#
#          rather than starting with a "Login with..." link at `/hub/login`
#
#          To work, `.login_url()` must give a URL other than the default `/hub/login`,
#          such as an oauth handler or another automatic login handler,
#          registered with `.get_handlers()`.
#
#          .. versionadded:: 0.8
#  Default: False
# c.Authenticator.auto_login = False

## Automatically begin login process for OAuth2 authorization requests
#
#  When another application is using JupyterHub as OAuth2 provider, it sends
#  users to `/hub/api/oauth2/authorize`. If the user isn't logged in already, and
#  auto_login is not set, the user will be dumped on the hub's home page, without
#  any context on what to do next.
#
#  Setting this to true will automatically redirect users to login if they aren't
#  logged in *only* on the `/hub/api/oauth2/authorize` endpoint.
#
#  .. versionadded:: 1.5
#  Default: False
# c.Authenticator.auto_login_oauth2_authorize = False

## Set of usernames that are not allowed to log in.
#
#  Use this with supported authenticators to restrict which users can not log in.
#  This is an additional block list that further restricts users, beyond whatever
#  restrictions the authenticator has in place.
#
#  If empty, does not perform any additional restriction.
#
#  .. versionadded: 0.9
#
#  .. versionchanged:: 5.2
#      Users blocked via `blocked_users` that may have logged in in the past
#      have all permissions and group membership revoked
#      and all servers stopped at JupyterHub startup.
#      Previously, User permissions (e.g. API tokens)
#      and servers were unaffected and required additional
#      administrator operations to block after a user is added to `blocked_users`.
#
#  .. versionchanged:: 1.2
#      `Authenticator.blacklist` renamed to `blocked_users`
#  Default: set()
# c.Authenticator.blocked_users = set()

## Delete any users from the database that do not pass validation
#
#          When JupyterHub starts, `.add_user` will be called
#          on each user in the database to verify that all users are still valid.
#
#          If `delete_invalid_users` is True,
#          any users that do not pass validation will be deleted from the database.
#          Use this if users might be deleted from an external system,
#          such as local user accounts.
#
#          If False (default), invalid users remain in the Hub's database
#          and a warning will be issued.
#          This is the default to avoid data loss due to config changes.
#  Default: False
# c.Authenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#
#          auth_state will be encrypted and stored in the Hub's database.
#          This can include things like authentication tokens, etc.
#          to be passed to Spawners as environment variables.
#
#          Encrypting auth_state requires the cryptography package.
#
#          Additionally, the JUPYTERHUB_CRYPT_KEY environment variable must
#          contain one (or more, separated by ;) 32B encryption keys.
#          These can be either base64 or hex-encoded.
#
#          If encryption is unavailable, auth_state cannot be persisted.
#
#          New in JupyterHub 0.8
#  Default: False
# c.Authenticator.enable_auth_state = False

## Let authenticator manage user groups
#
#          If True, Authenticator.authenticate and/or .refresh_user
#          may return a list of group names in the 'groups' field,
#          which will be assigned to the user.
#
#          All group-assignment APIs are disabled if this is True.
#  Default: False
# c.Authenticator.manage_groups = False

## Let authenticator manage roles
#
#          If True, Authenticator.authenticate and/or .refresh_user
#          may return a list of roles in the 'roles' field,
#          which will be added to the database.
#
#          When enabled, all role management will be handled by the
#          authenticator; in particular, assignment of roles via
#          `JupyterHub.load_roles` traitlet will not be possible.
#
#          .. versionadded:: 5.0
#  Default: False
# c.Authenticator.manage_roles = False

## The prompt string for the extra OTP (One Time Password) field.
#
#  .. versionadded:: 5.0
#  Default: 'OTP:'
# c.Authenticator.otp_prompt = 'OTP:'

## An optional hook function that you can implement to do some bootstrapping work
#  during authentication. For example, loading user account details from an
#  external system.
#
#  This function is called after the user has passed all authentication checks
#  and is ready to successfully authenticate. This function must return the
#  auth_model dict reguardless of changes to it. The hook is called with 3
#  positional arguments: `(authenticator, handler, auth_model)`.
#
#  This may be a coroutine.
#
#  .. versionadded: 1.0
#
#  Example::
#
#      import os
#      import pwd
#      def my_hook(authenticator, handler, auth_model):
#          user_data = pwd.getpwnam(auth_model['name'])
#          spawn_data = {
#              'pw_data': user_data
#              'gid_list': os.getgrouplist(auth_model['name'], user_data.pw_gid)
#          }
#
#          if auth_model['auth_state'] is None:
#              auth_model['auth_state'] = {}
#          auth_model['auth_state']['spawn_data'] = spawn_data
#
#          return auth_model
#
#      c.Authenticator.post_auth_hook = my_hook
#  Default: None
# c.Authenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#
#          This forces :meth:`.refresh_user` to be called prior to launching
#          a server, to ensure that auth state is up-to-date.
#
#          This can be important when e.g. auth tokens that may have expired
#          are passed to the spawner via environment variables from auth_state.
#
#          If refresh_user cannot refresh the user auth data,
#          launch will fail until the user logs in again.
#  Default: False
# c.Authenticator.refresh_pre_spawn = False

## Prompt for OTP (One Time Password) in the login form.
#
#  .. versionadded:: 5.0
#  Default: False
# c.Authenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#
#          If True:
#            - stale managed roles will be removed,
#            - stale assignments to managed roles will be removed.
#
#          Any role not present in `load_managed_roles()` will be considered
#  'stale'.
#
#          The 'stale' status for role assignments is also determined from
#  `load_managed_roles()` result:
#
#          - user role assignments status will depend on whether the `users` key
#  is defined or not:
#
#            * if a list is defined under the `users` key and the user is not listed, then the user role assignment will be considered 'stale',
#            * if the `users` key is not provided, the user role assignment will be preserved;
#          - service and group role assignments will be considered 'stale':
#
#            * if not included in the `services` and `groups` list,
#            * if the `services` and `groups` keys are not provided.
#
#          .. versionadded:: 5.0
#  Default: False
# c.Authenticator.reset_managed_roles_on_startup = False

## Dictionary mapping authenticator usernames to JupyterHub users.
#
#          Primarily used to normalize OAuth user names to local users.
#  Default: {}
# c.Authenticator.username_map = {}

## Regular expression pattern that all valid usernames must match.
#
#  If a username does not match the pattern specified here, authentication will
#  not be attempted.
#
#  If not set, allow any username.
#  Default: ''
# c.Authenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  Default: set()
# c.Authenticator.whitelist = set()

#------------------------------------------------------------------------------
# LocalAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## Base class for Authenticators that work with local Linux/UNIX users
#
#  Checks for local users, and can attempt to create them if they exist.

## The command to use for creating users as a list of strings
#
#  For each element in the list, the string USERNAME will be replaced with the
#  user's username. The username will also be appended as the final argument.
#
#  For Linux, the default value is:
#
#      ['adduser', '-q', '--gecos', '""', '--disabled-password']
#
#  To specify a custom home directory, set this to:
#
#      ['adduser', '-q', '--gecos', '""', '--home', '/customhome/USERNAME', '--
#  disabled-password']
#
#  This will run the command:
#
#      adduser -q --gecos "" --home /customhome/river --disabled-password river
#
#  when the user 'river' is created.
#  Default: []
# c.LocalAuthenticator.add_user_cmd = []

##
#  See also: Authenticator.admin_users
# c.LocalAuthenticator.admin_users = set()

##
#  See also: Authenticator.allow_all
# c.LocalAuthenticator.allow_all = False

##
#  See also: Authenticator.allow_existing_users
# c.LocalAuthenticator.allow_existing_users = False

## Allow login from all users in these UNIX groups.
#
#  .. versionchanged:: 5.0
#      `allowed_groups` may be specified together with allowed_users,
#      to grant access by group OR name.
#  Default: set()
# c.LocalAuthenticator.allowed_groups = set()

##
#  See also: Authenticator.allowed_users
# c.LocalAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.LocalAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.LocalAuthenticator.auth_refresh_age = 300

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.LocalAuthenticator.auto_login = False

##
#  See also: Authenticator.auto_login_oauth2_authorize
# c.LocalAuthenticator.auto_login_oauth2_authorize = False

##
#  See also: Authenticator.blocked_users
# c.LocalAuthenticator.blocked_users = set()

## If set to True, will attempt to create local system users if they do not exist
#  already.
#
#  Supports Linux and BSD variants only.
#  Default: False
c.LocalAuthenticator.create_system_users = False

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.LocalAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.LocalAuthenticator.enable_auth_state = False

## DEPRECATED: use allowed_groups
#  Default: set()
# c.LocalAuthenticator.group_whitelist = set()

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.LocalAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.LocalAuthenticator.manage_roles = False

##
#  See also: Authenticator.otp_prompt
# c.LocalAuthenticator.otp_prompt = 'OTP:'

##
#  See also: Authenticator.post_auth_hook
# c.LocalAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.LocalAuthenticator.refresh_pre_spawn = False

##
#  See also: Authenticator.request_otp
# c.LocalAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.LocalAuthenticator.reset_managed_roles_on_startup = False

## Dictionary of uids to use at user creation time. This helps ensure that users
#  created from the database get the same uid each time they are created in
#  temporary deployments or containers.
#  Default: {}
# c.LocalAuthenticator.uids = {}

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.LocalAuthenticator.username_map = {}

##
#  See also: Authenticator.username_pattern
# c.LocalAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.LocalAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# PAMAuthenticator(LocalAuthenticator) configuration
#------------------------------------------------------------------------------
## Authenticate local UNIX users with PAM

##
#  See also: LocalAuthenticator.add_user_cmd
# c.PAMAuthenticator.add_user_cmd = []

## Authoritative list of user groups that determine admin access. Users not in
#  these groups can still be granted admin status through admin_users.
#
#  allowed/blocked rules still apply.
#
#  Note: As of JupyterHub 2.0, full admin rights should not be required, and more
#  precise permissions can be managed via roles.
#  Default: set()
# c.PAMAuthenticator.admin_groups = set()

##
#  See also: Authenticator.admin_users
# c.PAMAuthenticator.admin_users = set()

##
#  See also: Authenticator.allow_all
# c.PAMAuthenticator.allow_all = False

##
#  See also: Authenticator.allow_existing_users
# c.PAMAuthenticator.allow_existing_users = False

##
#  See also: LocalAuthenticator.allowed_groups
# c.PAMAuthenticator.allowed_groups = set()

##
#  See also: Authenticator.allowed_users
# c.PAMAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.PAMAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.PAMAuthenticator.auth_refresh_age = 300

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.PAMAuthenticator.auto_login = False

##
#  See also: Authenticator.auto_login_oauth2_authorize
# c.PAMAuthenticator.auto_login_oauth2_authorize = False

##
#  See also: Authenticator.blocked_users
# c.PAMAuthenticator.blocked_users = set()

## Whether to check the user's account status via PAM during authentication.
#
#  The PAM account stack performs non-authentication based account management. It
#  is typically used to restrict/permit access to a service and this step is
#  needed to access the host's user access control.
#
#  Disabling this can be dangerous as authenticated but unauthorized users may be
#  granted access and, therefore, arbitrary execution on the system.
#  Default: True
# c.PAMAuthenticator.check_account = True

##
#  See also: LocalAuthenticator.create_system_users
# c.PAMAuthenticator.create_system_users = False

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.PAMAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.PAMAuthenticator.enable_auth_state = False

## The text encoding to use when communicating with PAM
#  Default: 'utf8'
# c.PAMAuthenticator.encoding = 'utf8'

## Number of executor threads.
#
#  PAM auth requests happen in this thread, so it is mostly waiting for the pam
#  stack. One thread is usually enough, unless your pam stack is doing something
#  slow like network requests
#  Default: 4
# c.PAMAuthenticator.executor_threads = 4

## DEPRECATED: use allowed_groups
#  See also: LocalAuthenticator.group_whitelist
# c.PAMAuthenticator.group_whitelist = set()

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.PAMAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.PAMAuthenticator.manage_roles = False

## Whether to open a new PAM session when spawners are started.
#
#  This may trigger things like mounting shared filesystems, loading credentials,
#  etc. depending on system configuration.
#
#  The lifecycle of PAM sessions is not correct, so many PAM session
#  configurations will not work.
#
#  If any errors are encountered when opening/closing PAM sessions, this is
#  automatically set to False.
#
#  .. versionchanged:: 2.2
#
#      Due to longstanding problems in the session lifecycle,
#      this is now disabled by default.
#      You may opt-in to opening sessions by setting this to True.
#  Default: False
# c.PAMAuthenticator.open_sessions = False

##
#  See also: Authenticator.otp_prompt
# c.PAMAuthenticator.otp_prompt = 'OTP:'

## Round-trip the username via PAM lookups to make sure it is unique
#
#  PAM can accept multiple usernames that map to the same user, for example
#  DOMAIN\username in some cases.  To prevent this, convert username into uid,
#  then back to uid to normalize.
#  Default: False
# c.PAMAuthenticator.pam_normalize_username = False

##
#  See also: Authenticator.post_auth_hook
# c.PAMAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.PAMAuthenticator.refresh_pre_spawn = False

##
#  See also: Authenticator.request_otp
# c.PAMAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.PAMAuthenticator.reset_managed_roles_on_startup = False

## The name of the PAM service to use for authentication
#  Default: 'login'
# c.PAMAuthenticator.service = 'login'

##
#  See also: LocalAuthenticator.uids
# c.PAMAuthenticator.uids = {}

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.PAMAuthenticator.username_map = {}

##
#  See also: Authenticator.username_pattern
# c.PAMAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.PAMAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# DummyAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## Dummy Authenticator for testing
#
#  By default, any username + password is allowed If a non-empty password is set,
#  any username will be allowed if it logs in with that password.
#
#  .. versionadded:: 1.0
#
#  .. versionadded:: 5.0
#      `allow_all` defaults to True,
#      preserving default behavior.

##
#  See also: Authenticator.admin_users
# c.DummyAuthenticator.admin_users = set()

##
#  See also: Authenticator.allow_all
# c.DummyAuthenticator.allow_all = False

##
#  See also: Authenticator.allow_existing_users
# c.DummyAuthenticator.allow_existing_users = False

##
#  See also: Authenticator.allowed_users
# c.DummyAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.DummyAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.DummyAuthenticator.auth_refresh_age = 300

## Automatically begin the login process
#  See also: Authenticator.auto_login
# c.DummyAuthenticator.auto_login = False

##
#  See also: Authenticator.auto_login_oauth2_authorize
# c.DummyAuthenticator.auto_login_oauth2_authorize = False

##
#  See also: Authenticator.blocked_users
# c.DummyAuthenticator.blocked_users = set()

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.DummyAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.DummyAuthenticator.enable_auth_state = False

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.DummyAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.DummyAuthenticator.manage_roles = False

##
#  See also: Authenticator.otp_prompt
# c.DummyAuthenticator.otp_prompt = 'OTP:'

## Set a global password for all users wanting to log in.
#
#  This allows users with any username to log in with the same static password.
#  Default: ''
# c.DummyAuthenticator.password = ''

##
#  See also: Authenticator.post_auth_hook
# c.DummyAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.DummyAuthenticator.refresh_pre_spawn = False

##
#  See also: Authenticator.request_otp
# c.DummyAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.DummyAuthenticator.reset_managed_roles_on_startup = False

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.DummyAuthenticator.username_map = {}

##
#  See also: Authenticator.username_pattern
# c.DummyAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.DummyAuthenticator.whitelist = set()

#------------------------------------------------------------------------------
# Proxy(LoggingConfigurable) configuration
#------------------------------------------------------------------------------
## Base class for configurable proxies that JupyterHub can use.
#
#  A proxy implementation should subclass this and must define the following
#  methods:
#
#  - :meth:`.get_all_routes` return a dictionary of all JupyterHub-related routes
#  - :meth:`.add_route` adds a route - :meth:`.delete_route` deletes a route
#
#  In addition to these, the following method(s) may need to be implemented:
#
#  - :meth:`.start` start the proxy, if it should be launched by the Hub
#    instead of externally managed.
#    If the proxy is externally managed, it should set :attr:`should_start` to False.
#  - :meth:`.stop` stop the proxy. Only used if :meth:`.start` is also used.
#
#  And the following method(s) are optional, but can be provided:
#
#  - :meth:`.get_route` gets a single route.
#    There is a default implementation that extracts data from :meth:`.get_all_routes`,
#    but implementations may choose to provide a more efficient implementation
#    of fetching a single route.

## Additional routes to be maintained in the proxy.
#
#  A dictionary with a route specification as key, and a URL as target. The hub
#  will ensure this route is present in the proxy.
#
#  If the hub is running in host based mode (with JupyterHub.subdomain_host set),
#  the routespec *must* have a domain component (example.com/my-url/). If the hub
#  is not running in host based mode, the routespec *must not* have a domain
#  component (/my-url/).
#
#  Helpful when the hub is running in API-only mode.
#  Default: {}
# c.Proxy.extra_routes = {}

## Should the Hub start the proxy
#
#          If True, the Hub will start the proxy and stop it.
#          Set to False if the proxy is managed externally,
#          such as by systemd, docker, or another service manager.
#  Default: True
# c.Proxy.should_start = True

#------------------------------------------------------------------------------
# ConfigurableHTTPProxy(Proxy) configuration
#------------------------------------------------------------------------------
## Proxy implementation for the default configurable-http-proxy.
#
#  This is the default proxy implementation for running the nodejs proxy
#  `configurable-http-proxy`.
#
#  If the proxy should not be run as a subprocess of the Hub, (e.g. in a separate
#  container), set::
#
#      c.ConfigurableHTTPProxy.should_start = False

## The ip (or hostname) of the proxy's API endpoint
#  Default: ''
# c.ConfigurableHTTPProxy.api_url = ''

## The Proxy auth token
#
#          Loaded from the CONFIGPROXY_AUTH_TOKEN env variable by default.
#  Default: ''
# c.ConfigurableHTTPProxy.auth_token = ''

## Interval (in seconds) at which to check if the proxy is running.
#  Default: 5
# c.ConfigurableHTTPProxy.check_running_interval = 5

## The command to start the proxy
#  Default: ['configurable-http-proxy']
# c.ConfigurableHTTPProxy.command = ['configurable-http-proxy']

## The number of requests allowed to be concurrently outstanding to the proxy
#
#  Limiting this number avoids potential timeout errors by sending too many
#  requests to update the proxy at once
#  Default: 10
# c.ConfigurableHTTPProxy.concurrency = 10

## Add debug-level logging to the Proxy.
#  Default: False
# c.ConfigurableHTTPProxy.debug = False

##
#  See also: Proxy.extra_routes
# c.ConfigurableHTTPProxy.extra_routes = {}

## Proxy log level
#  Choices: any of ['debug', 'info', 'warn', 'error'] (case-insensitive)
#  Default: 'info'
# c.ConfigurableHTTPProxy.log_level = 'info'

## File in which to write the PID of the proxy process.
#  Default: 'jupyterhub-proxy.pid'
# c.ConfigurableHTTPProxy.pid_file = 'jupyterhub-proxy.pid'

## Should the Hub start the proxy
#  See also: Proxy.should_start
# c.ConfigurableHTTPProxy.should_start = True

#------------------------------------------------------------------------------
# CryptKeeper(SingletonConfigurable) configuration
#------------------------------------------------------------------------------
## Encapsulate encryption configuration
#
#  Use via the encryption_config singleton below.

#  Default: []
# c.CryptKeeper.keys = []

## The number of threads to allocate for encryption
#  Default: 16
# c.CryptKeeper.n_threads = 16

#------------------------------------------------------------------------------
# Spawner(LoggingConfigurable) configuration
#------------------------------------------------------------------------------
## Base class for spawning single-user notebook servers.
#
#  Subclass this, and override the following methods:
#
#  - load_state - get_state - start - stop - poll
#
#  As JupyterHub supports multiple users, an instance of the Spawner subclass is
#  created for each user. If there are 20 JupyterHub users, there will be 20
#  instances of the subclass.

## Extra arguments to be passed to the single-user server.
#
#  Some spawners allow shell-style expansion here, allowing you to use
#  environment variables here. Most, including the default, do not. Consult the
#  documentation for your spawner to verify!
#  Default: []
# c.Spawner.args = []

## An optional hook function that you can implement to pass `auth_state` to the
#  spawner after it has been initialized but before it starts. The `auth_state`
#  dictionary may be set by the `.authenticate()` method of the authenticator.
#  This hook enables you to pass some or all of that information to your spawner.
#
#  Example::
#
#      def userdata_hook(spawner, auth_state):
#          spawner.userdata = auth_state["userdata"]
#
#      c.Spawner.auth_state_hook = userdata_hook
#  Default: None
# c.Spawner.auth_state_hook = None

## The command used for starting the single-user server.
#
#  Provide either a string or a list containing the path to the startup script
#  command. Extra arguments, other than this path, should be provided via `args`.
#
#  This is usually set if you want to start the single-user server in a different
#  python environment (with virtualenv/conda) than JupyterHub itself.
#
#  Some spawners allow shell-style expansion here, allowing you to use
#  environment variables. Most, including the default, do not. Consult the
#  documentation for your spawner to verify!
#  Default: ['jupyterhub-singleuser']
# c.Spawner.cmd = ['jupyterhub-singleuser']

## Maximum number of consecutive failures to allow before shutting down
#  JupyterHub.
#
#  This helps JupyterHub recover from a certain class of problem preventing
#  launch in contexts where the Hub is automatically restarted (e.g. systemd,
#  docker, kubernetes).
#
#  A limit of 0 means no limit and consecutive failures will not be tracked.
#  Default: 0
# c.Spawner.consecutive_failure_limit = 0

## Minimum number of cpu-cores a single-user notebook server is guaranteed to
#  have available.
#
#  If this value is set to 0.5, allows use of 50% of one CPU. If this value is
#  set to 2, allows use of up to 2 CPUs.
#
#  **This is a configuration setting. Your spawner must implement support for the
#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**
#  implement this support. A custom spawner **must** add support for this setting
#  for it to be enforced.
#  Default: None
# c.Spawner.cpu_guarantee = None

## Maximum number of cpu-cores a single-user notebook server is allowed to use.
#
#  If this value is set to 0.5, allows use of 50% of one CPU. If this value is
#  set to 2, allows use of up to 2 CPUs.
#
#  The single-user notebook server will never be scheduled by the kernel to use
#  more cpu-cores than this. There is no guarantee that it can access this many
#  cpu-cores.
#
#  **This is a configuration setting. Your spawner must implement support for the
#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**
#  implement this support. A custom spawner **must** add support for this setting
#  for it to be enforced.
#  Default: None
# c.Spawner.cpu_limit = None

## Enable debug-logging of the single-user server
#  Default: False
# c.Spawner.debug = False

## The URL the single-user server should start in.
#
#  `{username}` will be expanded to the user's username
#
#  Example uses:
#
#  - You can set `notebook_dir` to `/` and `default_url` to `/tree/home/{username}` to allow people to
#    navigate the whole filesystem from their notebook server, but still start in their home directory.
#  - Start with `/notebooks` instead of `/tree` if `default_url` points to a notebook instead of a directory.
#  - You can set this to `/lab` to have JupyterLab start by default, rather than Jupyter Notebook.
#  Default: ''
# c.Spawner.default_url = ''

## Disable per-user configuration of single-user servers.
#
#  When starting the user's single-user server, any config file found in the
#  user's $HOME directory will be ignored.
#
#  Note: a user could circumvent this if the user modifies their Python
#  environment, such as when they have their own conda environments / virtualenvs
#  / containers.
#  Default: False
# c.Spawner.disable_user_config = False

## List of environment variables for the single-user server to inherit from the
#  JupyterHub process.
#
#  This list is used to ensure that sensitive information in the JupyterHub
#  process's environment (such as `CONFIGPROXY_AUTH_TOKEN`) is not passed to the
#  single-user server's process.
#  Default: ['JUPYTERHUB_SINGLEUSER_APP']
# c.Spawner.env_keep = ['JUPYTERHUB_SINGLEUSER_APP']

## Extra environment variables to set for the single-user server's process.
#
#  Environment variables that end up in the single-user server's process come from 3 sources:
#    - This `environment` configurable
#    - The JupyterHub process' environment variables that are listed in `env_keep`
#    - Variables to establish contact between the single-user notebook and the hub (such as JUPYTERHUB_API_TOKEN)
#
#  The `environment` configurable should be set by JupyterHub administrators to
#  add installation specific environment variables. It is a dict where the key is
#  the name of the environment variable, and the value can be a string or a
#  callable. If it is a callable, it will be called with one parameter (the
#  spawner instance), and should return a string fairly quickly (no blocking
#  operations please!).
#
#  Note that the spawner class' interface is not guaranteed to be exactly same
#  across upgrades, so if you are using the callable take care to verify it
#  continues to work after upgrades!
#
#  .. versionchanged:: 1.2
#      environment from this configuration has highest priority,
#      allowing override of 'default' env variables,
#      such as JUPYTERHUB_API_URL.
#  Default: {}
# c.Spawner.environment = {}

## Override specific traitlets based on group membership of the user.
#
#  This can be a dict, or a callable that returns a dict. The keys of the dict
#  are *only* used for lexicographical sorting, to guarantee consistent ordering
#  of the overrides. If it is a callable, it may be async, and will be passed one
#  parameter - the spawner instance. It should return a dictionary.
#
#  The values of the dict are dicts with the following keys:
#
#  - `"groups"` - If the user belongs to *any* of these groups, these overrides are
#    applied to their server before spawning.
#  - `"spawner_override"` - a dictionary with overrides to apply to the Spawner
#    settings. Each value can be either the final value to change or a callable that
#    take the `Spawner` instance as parameter and returns the final value.
#    If the traitlet being overriden is a *dictionary*, the dictionary
#    will be *recursively updated*, rather than overriden. If you want to
#    remove a key, set its value to `None`.
#
#  Example:
#
#      The following example config will:
#
#      1. Add the environment variable "AM_I_GROUP_ALPHA" to everyone in the "group-alpha" group
#      2. Add the environment variable "AM_I_GROUP_BETA" to everyone in the "group-beta" group.
#         If a user is part of both "group-beta" and "group-alpha", they will get *both* these env
#         vars, due to the dictionary merging functionality.
#      3. Add a higher memory limit for everyone in the "group-beta" group.
#
#      ::
#
#          c.Spawner.group_overrides = {
#              "01-group-alpha-env-add": {
#                  "groups": ["group-alpha"],
#                  "spawner_override": {"environment": {"AM_I_GROUP_ALPHA": "yes"}},
#              },
#              "02-group-beta-env-add": {
#                  "groups": ["group-beta"],
#                  "spawner_override": {"environment": {"AM_I_GROUP_BETA": "yes"}},
#              },
#              "03-group-beta-mem-limit": {
#                  "groups": ["group-beta"],
#                  "spawner_override": {"mem_limit": "2G"}
#              }
#          }
#  Default: traitlets.Undefined
# c.Spawner.group_overrides = traitlets.Undefined

## Timeout (in seconds) before giving up on a spawned HTTP server
#
#  Once a server has successfully been spawned, this is the amount of time we
#  wait before assuming that the server is unable to accept connections.
#  Default: 30
# c.Spawner.http_timeout = 30

## The URL the single-user server should connect to the Hub.
#
#  If the Hub URL set in your JupyterHub config is not reachable from spawned
#  notebooks, you can set differnt URL by this config.
#
#  Is None if you don't need to change the URL.
#  Default: None
# c.Spawner.hub_connect_url = None

## The IP address (or hostname) the single-user server should listen on.
#
#  Usually either '127.0.0.1' (default) or '0.0.0.0'.
#
#  The JupyterHub proxy implementation should be able to send packets to this
#  interface.
#
#  Subclasses which launch remotely or in containers should override the default
#  to '0.0.0.0'.
#
#  .. versionchanged:: 2.0
#      Default changed to '127.0.0.1', from ''.
#      In most cases, this does not result in a change in behavior,
#      as '' was interpreted as 'unspecified',
#      which used the subprocesses' own default, itself usually '127.0.0.1'.
#  Default: '127.0.0.1'
# c.Spawner.ip = '127.0.0.1'

## Minimum number of bytes a single-user notebook server is guaranteed to have
#  available.
#
#  Allows the following suffixes:
#    - K -> Kilobytes
#    - M -> Megabytes
#    - G -> Gigabytes
#    - T -> Terabytes
#
#  **This is a configuration setting. Your spawner must implement support for the
#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**
#  implement this support. A custom spawner **must** add support for this setting
#  for it to be enforced.
#  Default: None
# c.Spawner.mem_guarantee = None

## Maximum number of bytes a single-user notebook server is allowed to use.
#
#  Allows the following suffixes:
#    - K -> Kilobytes
#    - M -> Megabytes
#    - G -> Gigabytes
#    - T -> Terabytes
#
#  If the single user server tries to allocate more memory than this, it will
#  fail. There is no guarantee that the single-user notebook server will be able
#  to allocate this much memory - only that it can not allocate more than this.
#
#  **This is a configuration setting. Your spawner must implement support for the
#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**
#  implement this support. A custom spawner **must** add support for this setting
#  for it to be enforced.
#  Default: None
# c.Spawner.mem_limit = None

## Path to the notebook directory for the single-user server.
#
#  The user sees a file listing of this directory when the notebook interface is
#  started. The current interface does not easily allow browsing beyond the
#  subdirectories in this directory's tree.
#
#  `~` will be expanded to the home directory of the user, and {username} will be
#  replaced with the name of the user.
#
#  Note that this does *not* prevent users from accessing files outside of this
#  path! They can do so with many other means.
#  Default: ''
c.Spawner.notebook_dir = '/srv/jupyterhub/notebooks/'

## Allowed scopes for oauth tokens issued by this server's oauth client.
#
#          This sets the maximum and default scopes
#          assigned to oauth tokens issued by a single-user server's
#          oauth client (i.e. tokens stored in browsers after authenticating with the server),
#          defining what actions the server can take on behalf of logged-in users.
#
#          Default is an empty list, meaning minimal permissions to identify users,
#          no actions can be taken on their behalf.
#
#          If callable, will be called with the Spawner as a single argument.
#          Callables may be async.
#  Default: traitlets.Undefined
# c.Spawner.oauth_client_allowed_scopes = traitlets.Undefined

## Allowed roles for oauth tokens.
#
#          Deprecated in 3.0: use oauth_client_allowed_scopes
#
#          This sets the maximum and default roles
#          assigned to oauth tokens issued by a single-user server's
#          oauth client (i.e. tokens stored in browsers after authenticating with the server),
#          defining what actions the server can take on behalf of logged-in users.
#
#          Default is an empty list, meaning minimal permissions to identify users,
#          no actions can be taken on their behalf.
#  Default: traitlets.Undefined
# c.Spawner.oauth_roles = traitlets.Undefined

## An HTML form for options a user can specify on launching their server.
#
#  The surrounding `<form>` element and the submit button are already provided.
#
#  For example:
#
#  .. code:: html
#
#      Set your key:
#      <input name="key" val="default_key"></input>
#      <br>
#      Choose a letter:
#      <select name="letter" multiple="true">
#        <option value="A">The letter A</option>
#        <option value="B">The letter B</option>
#      </select>
#
#  The data from this form submission will be passed on to your spawner in
#  `self.user_options`
#
#  Instead of a form snippet string, this could also be a callable that takes as
#  one parameter the current spawner instance and returns a string. The callable
#  will be called asynchronously if it returns a future, rather than a str. Note
#  that the interface of the spawner class is not deemed stable across versions,
#  so using this functionality might cause your JupyterHub upgrades to break.
#  Default: traitlets.Undefined
# c.Spawner.options_form = traitlets.Undefined

## Interpret HTTP form data
#
#  Form data will always arrive as a dict of lists of strings. Override this
#  function to understand single-values, numbers, etc.
#
#  This should coerce form data into the structure expected by self.user_options,
#  which must be a dict, and should be JSON-serializeable, though it can contain
#  bytes in addition to standard JSON data types.
#
#  This method should not have any side effects. Any handling of `user_options`
#  should be done in `.start()` to ensure consistent behavior across servers
#  spawned via the API and form submission page.
#
#  Instances will receive this data on self.user_options, after passing through
#  this function, prior to `Spawner.start`.
#
#  .. versionchanged:: 1.0
#      user_options are persisted in the JupyterHub database to be reused
#      on subsequent spawns if no options are given.
#      user_options is serialized to JSON as part of this persistence
#      (with additional support for bytes in case of uploaded file data),
#      and any non-bytes non-jsonable values will be replaced with None
#      if the user_options are re-used.
#  Default: traitlets.Undefined
# c.Spawner.options_from_form = traitlets.Undefined

## Interval (in seconds) on which to poll the spawner for single-user server's
#  status.
#
#  At every poll interval, each spawner's `.poll` method is called, which checks
#  if the single-user server is still running. If it isn't running, then
#  JupyterHub modifies its own state accordingly and removes appropriate routes
#  from the configurable proxy.
#  Default: 30
# c.Spawner.poll_interval = 30

## Jitter fraction for poll_interval.
#
#  Avoids alignment of poll calls for many Spawners, e.g. when restarting
#  JupyterHub, which restarts all polls for running Spawners.
#
#  `poll_jitter=0` means no jitter, 0.1 means 10%, etc.
#  Default: 0.1
# c.Spawner.poll_jitter = 0.1

## The port for single-user servers to listen on.
#
#  Defaults to `0`, which uses a randomly allocated port number each time.
#
#  If set to a non-zero value, all Spawners will use the same port, which only
#  makes sense if each server is on a different address, e.g. in containers.
#
#  New in version 0.7.
#  Default: 0
# c.Spawner.port = 0

## An optional hook function that you can implement to do work after the spawner
#  stops.
#
#  This can be set independent of any concrete spawner implementation.
#  Default: None
# c.Spawner.post_stop_hook = None

## An optional hook function that you can implement to do some bootstrapping work
#  before the spawner starts. For example, create a directory for your user or
#  load initial content.
#
#  This can be set independent of any concrete spawner implementation.
#
#  This maybe a coroutine.
#
#  Example::
#
#      def my_hook(spawner):
#          username = spawner.user.name
#          spawner.environment["GREETING"] = f"Hello {username}"
#
#      c.Spawner.pre_spawn_hook = my_hook
#  Default: None
# c.Spawner.pre_spawn_hook = None

## An optional hook function that you can implement to modify the ready event,
#  which will be shown to the user on the spawn progress page when their server
#  is ready.
#
#  This can be set independent of any concrete spawner implementation.
#
#  This maybe a coroutine.
#
#  Example::
#
#      async def my_ready_hook(spawner, ready_event):
#          ready_event["html_message"] = f"Server {spawner.name} is ready for {spawner.user.name}"
#          return ready_event
#
#      c.Spawner.progress_ready_hook = my_ready_hook
#  Default: None
# c.Spawner.progress_ready_hook = None

## The list of scopes to request for $JUPYTERHUB_API_TOKEN
#
#          If not specified, the scopes in the `server` role will be used
#          (unchanged from pre-4.0).
#
#          If callable, will be called with the Spawner instance as its sole argument
#          (JupyterHub user available as spawner.user).
#
#          JUPYTERHUB_API_TOKEN will be assigned the _subset_ of these scopes
#          that are held by the user (as in oauth_client_allowed_scopes).
#
#          .. versionadded:: 4.0
#  Default: traitlets.Undefined
# c.Spawner.server_token_scopes = traitlets.Undefined

## List of SSL alt names
#
#          May be set in config if all spawners should have the same value(s),
#          or set at runtime by Spawner that know their names.
#  Default: []
# c.Spawner.ssl_alt_names = []

## Whether to include `DNS:localhost`, `IP:127.0.0.1` in alt names
#  Default: True
# c.Spawner.ssl_alt_names_include_local = True

## Timeout (in seconds) before giving up on starting of single-user server.
#
#  This is the timeout for start to return, not the timeout for the server to
#  respond. Callers of spawner.start will assume that startup has failed if it
#  takes longer than this. start should return when the server process is started
#  and its location is known.
#  Default: 60
# c.Spawner.start_timeout = 60

#------------------------------------------------------------------------------
# LocalProcessSpawner(Spawner) configuration
#------------------------------------------------------------------------------
## A Spawner that uses `subprocess.Popen` to start single-user servers as local
#  processes.
#
#  Requires local UNIX users matching the authenticated users to exist. Does not
#  work on Windows.
#
#  This is the default spawner for JupyterHub.
#
#  Note: This spawner does not implement CPU / memory guarantees and limits.

##
#  See also: Spawner.args
# c.LocalProcessSpawner.args = []

##
#  See also: Spawner.auth_state_hook
# c.LocalProcessSpawner.auth_state_hook = None

##
#  See also: Spawner.cmd
# c.LocalProcessSpawner.cmd = ['jupyterhub-singleuser']

##
#  See also: Spawner.consecutive_failure_limit
# c.LocalProcessSpawner.consecutive_failure_limit = 0

##
#  See also: Spawner.cpu_guarantee
# c.LocalProcessSpawner.cpu_guarantee = None

##
#  See also: Spawner.cpu_limit
# c.LocalProcessSpawner.cpu_limit = None

## Enable debug-logging of the single-user server
#  See also: Spawner.debug
# c.LocalProcessSpawner.debug = False

##
#  See also: Spawner.default_url
# c.LocalProcessSpawner.default_url = ''

##
#  See also: Spawner.disable_user_config
# c.LocalProcessSpawner.disable_user_config = False

##
#  See also: Spawner.env_keep
# c.LocalProcessSpawner.env_keep = ['JUPYTERHUB_SINGLEUSER_APP']

##
#  See also: Spawner.environment
# c.LocalProcessSpawner.environment = {}

##
#  See also: Spawner.group_overrides
# c.LocalProcessSpawner.group_overrides = traitlets.Undefined

##
#  See also: Spawner.http_timeout
# c.LocalProcessSpawner.http_timeout = 30

##
#  See also: Spawner.hub_connect_url
# c.LocalProcessSpawner.hub_connect_url = None

## Seconds to wait for single-user server process to halt after SIGINT.
#
#  If the process has not exited cleanly after this many seconds, a SIGTERM is
#  sent.
#  Default: 10
# c.LocalProcessSpawner.interrupt_timeout = 10

##
#  See also: Spawner.ip
# c.LocalProcessSpawner.ip = '127.0.0.1'

## Seconds to wait for process to halt after SIGKILL before giving up.
#
#  If the process does not exit cleanly after this many seconds of SIGKILL, it
#  becomes a zombie process. The hub process will log a warning and then give up.
#  Default: 5
# c.LocalProcessSpawner.kill_timeout = 5

##
#  See also: Spawner.mem_guarantee
# c.LocalProcessSpawner.mem_guarantee = None

##
#  See also: Spawner.mem_limit
# c.LocalProcessSpawner.mem_limit = None

##
#  See also: Spawner.notebook_dir
c.LocalProcessSpawner.notebook_dir = '/srv/jupyterhub/notebooks/'

## Allowed scopes for oauth tokens issued by this server's oauth client.
#  See also: Spawner.oauth_client_allowed_scopes
# c.LocalProcessSpawner.oauth_client_allowed_scopes = traitlets.Undefined

## Allowed roles for oauth tokens.
#  See also: Spawner.oauth_roles
# c.LocalProcessSpawner.oauth_roles = traitlets.Undefined

##
#  See also: Spawner.options_form
# c.LocalProcessSpawner.options_form = traitlets.Undefined

##
#  See also: Spawner.options_from_form
# c.LocalProcessSpawner.options_from_form = traitlets.Undefined

##
#  See also: Spawner.poll_interval
# c.LocalProcessSpawner.poll_interval = 30

##
#  See also: Spawner.poll_jitter
# c.LocalProcessSpawner.poll_jitter = 0.1

## Extra keyword arguments to pass to Popen
#
#          when spawning single-user servers.
#
#          For example::
#
#              popen_kwargs = dict(shell=True)
#  Default: {}
# c.LocalProcessSpawner.popen_kwargs = {}

##
#  See also: Spawner.port
# c.LocalProcessSpawner.port = 0

##
#  See also: Spawner.post_stop_hook
# c.LocalProcessSpawner.post_stop_hook = None

##
#  See also: Spawner.pre_spawn_hook
# c.LocalProcessSpawner.pre_spawn_hook = None

##
#  See also: Spawner.progress_ready_hook
# c.LocalProcessSpawner.progress_ready_hook = None

## The list of scopes to request for $JUPYTERHUB_API_TOKEN
#  See also: Spawner.server_token_scopes
# c.LocalProcessSpawner.server_token_scopes = traitlets.Undefined

## Specify a shell command to launch.
#
#          The single-user command will be appended to this list,
#          so it sould end with `-c` (for bash) or equivalent.
#
#          For example::
#
#              c.LocalProcessSpawner.shell_cmd = ['bash', '-l', '-c']
#
#          to launch with a bash login shell, which would set up the user's own
#  complete environment.
#
#          .. warning::
#
#              Using shell_cmd gives users control over PATH, etc.,
#              which could change what the jupyterhub-singleuser launch command does.
#              Only use this for trusted users.
#  Default: []
# c.LocalProcessSpawner.shell_cmd = []

## List of SSL alt names
#  See also: Spawner.ssl_alt_names
# c.LocalProcessSpawner.ssl_alt_names = []

## Whether to include `DNS:localhost`, `IP:127.0.0.1` in alt names
#  See also: Spawner.ssl_alt_names_include_local
# c.LocalProcessSpawner.ssl_alt_names_include_local = True

##
#  See also: Spawner.start_timeout
# c.LocalProcessSpawner.start_timeout = 60

## Seconds to wait for single-user server process to halt after SIGTERM.
#
#  If the process does not exit cleanly after this many seconds of SIGTERM, a
#  SIGKILL is sent.
#  Default: 5
# c.LocalProcessSpawner.term_timeout = 5

#------------------------------------------------------------------------------
# SimpleLocalProcessSpawner(LocalProcessSpawner) configuration
#------------------------------------------------------------------------------
## A version of LocalProcessSpawner that doesn't require users to exist on the
#  system beforehand.
#
#  Only use this for testing.
#
#  Note: DO NOT USE THIS FOR PRODUCTION USE CASES! It is very insecure, and
#  provides absolutely no isolation between different users!

##
#  See also: Spawner.args
# c.SimpleLocalProcessSpawner.args = []

##
#  See also: Spawner.auth_state_hook
# c.SimpleLocalProcessSpawner.auth_state_hook = None

##
#  See also: Spawner.cmd
# c.SimpleLocalProcessSpawner.cmd = ['jupyterhub-singleuser']

##
#  See also: Spawner.consecutive_failure_limit
# c.SimpleLocalProcessSpawner.consecutive_failure_limit = 0

##
#  See also: Spawner.cpu_guarantee
# c.SimpleLocalProcessSpawner.cpu_guarantee = None

##
#  See also: Spawner.cpu_limit
# c.SimpleLocalProcessSpawner.cpu_limit = None

## Enable debug-logging of the single-user server
#  See also: Spawner.debug
# c.SimpleLocalProcessSpawner.debug = False

##
#  See also: Spawner.default_url
# c.SimpleLocalProcessSpawner.default_url = ''

##
#  See also: Spawner.disable_user_config
# c.SimpleLocalProcessSpawner.disable_user_config = False

##
#  See also: Spawner.env_keep
# c.SimpleLocalProcessSpawner.env_keep = ['JUPYTERHUB_SINGLEUSER_APP']

##
#  See also: Spawner.environment
# c.SimpleLocalProcessSpawner.environment = {}

##
#  See also: Spawner.group_overrides
# c.SimpleLocalProcessSpawner.group_overrides = traitlets.Undefined

## Template to expand to set the user home. {username} is expanded to the
#  jupyterhub username.
#  Default: '/tmp/{username}'
# c.SimpleLocalProcessSpawner.home_dir_template = '/tmp/{username}'

##
#  See also: Spawner.http_timeout
# c.SimpleLocalProcessSpawner.http_timeout = 30

##
#  See also: Spawner.hub_connect_url
# c.SimpleLocalProcessSpawner.hub_connect_url = None

##
#  See also: LocalProcessSpawner.interrupt_timeout
# c.SimpleLocalProcessSpawner.interrupt_timeout = 10

##
#  See also: Spawner.ip
# c.SimpleLocalProcessSpawner.ip = '127.0.0.1'

##
#  See also: LocalProcessSpawner.kill_timeout
# c.SimpleLocalProcessSpawner.kill_timeout = 5

##
#  See also: Spawner.mem_guarantee
# c.SimpleLocalProcessSpawner.mem_guarantee = None

##
#  See also: Spawner.mem_limit
# c.SimpleLocalProcessSpawner.mem_limit = None

##
#  See also: Spawner.notebook_dir
# c.SimpleLocalProcessSpawner.notebook_dir = ''

## Allowed scopes for oauth tokens issued by this server's oauth client.
#  See also: Spawner.oauth_client_allowed_scopes
# c.SimpleLocalProcessSpawner.oauth_client_allowed_scopes = traitlets.Undefined

## Allowed roles for oauth tokens.
#  See also: Spawner.oauth_roles
# c.SimpleLocalProcessSpawner.oauth_roles = traitlets.Undefined

##
#  See also: Spawner.options_form
# c.SimpleLocalProcessSpawner.options_form = traitlets.Undefined

##
#  See also: Spawner.options_from_form
# c.SimpleLocalProcessSpawner.options_from_form = traitlets.Undefined

##
#  See also: Spawner.poll_interval
# c.SimpleLocalProcessSpawner.poll_interval = 30

##
#  See also: Spawner.poll_jitter
# c.SimpleLocalProcessSpawner.poll_jitter = 0.1

## Extra keyword arguments to pass to Popen
#  See also: LocalProcessSpawner.popen_kwargs
# c.SimpleLocalProcessSpawner.popen_kwargs = {}

##
#  See also: Spawner.port
# c.SimpleLocalProcessSpawner.port = 0

##
#  See also: Spawner.post_stop_hook
# c.SimpleLocalProcessSpawner.post_stop_hook = None

##
#  See also: Spawner.pre_spawn_hook
# c.SimpleLocalProcessSpawner.pre_spawn_hook = None

##
#  See also: Spawner.progress_ready_hook
# c.SimpleLocalProcessSpawner.progress_ready_hook = None

## The list of scopes to request for $JUPYTERHUB_API_TOKEN
#  See also: Spawner.server_token_scopes
# c.SimpleLocalProcessSpawner.server_token_scopes = traitlets.Undefined

## Specify a shell command to launch.
#  See also: LocalProcessSpawner.shell_cmd
# c.SimpleLocalProcessSpawner.shell_cmd = []

## List of SSL alt names
#  See also: Spawner.ssl_alt_names
# c.SimpleLocalProcessSpawner.ssl_alt_names = []

## Whether to include `DNS:localhost`, `IP:127.0.0.1` in alt names
#  See also: Spawner.ssl_alt_names_include_local
# c.SimpleLocalProcessSpawner.ssl_alt_names_include_local = True

##
#  See also: Spawner.start_timeout
# c.SimpleLocalProcessSpawner.start_timeout = 60

##
#  See also: LocalProcessSpawner.term_timeout
# c.SimpleLocalProcessSpawner.term_timeout = 5

#------------------------------------------------------------------------------
# NullAuthenticator(Authenticator) configuration
#------------------------------------------------------------------------------
## Null Authenticator for JupyterHub
#
#  For cases where authentication should be disabled, e.g. only allowing access
#  via API tokens.
#
#  .. versionadded:: 2.0

##
#  See also: Authenticator.admin_users
# c.NullAuthenticator.admin_users = set()

##
#  See also: Authenticator.allow_all
# c.NullAuthenticator.allow_all = False

##
#  See also: Authenticator.allow_existing_users
# c.NullAuthenticator.allow_existing_users = False

##
#  See also: Authenticator.allowed_users
# c.NullAuthenticator.allowed_users = set()

## Is there any allow config?
#  See also: Authenticator.any_allow_config
# c.NullAuthenticator.any_allow_config = False

## The max age (in seconds) of authentication info
#  See also: Authenticator.auth_refresh_age
# c.NullAuthenticator.auth_refresh_age = 300

##
#  See also: Authenticator.auto_login_oauth2_authorize
# c.NullAuthenticator.auto_login_oauth2_authorize = False

##
#  See also: Authenticator.blocked_users
# c.NullAuthenticator.blocked_users = set()

## Delete any users from the database that do not pass validation
#  See also: Authenticator.delete_invalid_users
# c.NullAuthenticator.delete_invalid_users = False

## Enable persisting auth_state (if available).
#  See also: Authenticator.enable_auth_state
# c.NullAuthenticator.enable_auth_state = False

## Let authenticator manage user groups
#  See also: Authenticator.manage_groups
# c.NullAuthenticator.manage_groups = False

## Let authenticator manage roles
#  See also: Authenticator.manage_roles
# c.NullAuthenticator.manage_roles = False

##
#  See also: Authenticator.otp_prompt
# c.NullAuthenticator.otp_prompt = 'OTP:'

##
#  See also: Authenticator.post_auth_hook
# c.NullAuthenticator.post_auth_hook = None

## Force refresh of auth prior to spawn.
#  See also: Authenticator.refresh_pre_spawn
# c.NullAuthenticator.refresh_pre_spawn = False

##
#  See also: Authenticator.request_otp
# c.NullAuthenticator.request_otp = False

## Reset managed roles to result of `load_managed_roles()` on startup.
#  See also: Authenticator.reset_managed_roles_on_startup
# c.NullAuthenticator.reset_managed_roles_on_startup = False

## Dictionary mapping authenticator usernames to JupyterHub users.
#  See also: Authenticator.username_map
# c.NullAuthenticator.username_map = {}

##
#  See also: Authenticator.username_pattern
# c.NullAuthenticator.username_pattern = ''

## Deprecated, use `Authenticator.allowed_users`
#  See also: Authenticator.whitelist
# c.NullAuthenticator.whitelist = set()

```

`scripts/blserver/configs/milvus.yaml.bak`:

```bak
# Licensed to the LF AI & Data foundation under one
# or more contributor license agreements. See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership. The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Related configuration of etcd, used to store Milvus metadata & service discovery.
etcd:
  # Endpoints used to access etcd service. You can change this parameter as the endpoints of your own etcd cluster.
  # Environment variable: ETCD_ENDPOINTS
  # etcd preferentially acquires valid address from environment variable ETCD_ENDPOINTS when Milvus is started.
  endpoints: localhost:2379
  # Root prefix of the key to where Milvus stores data in etcd.
  # It is recommended to change this parameter before starting Milvus for the first time.
  # To share an etcd instance among multiple Milvus instances, consider changing this to a different value for each Milvus instance before you start them.
  # Set an easy-to-identify root path for Milvus if etcd service already exists.
  # Changing this for an already running Milvus instance may result in failures to read legacy data.
  rootPath: by-dev
  # Sub-prefix of the key to where Milvus stores metadata-related information in etcd.
  # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
  # It is recommended to change this parameter before starting Milvus for the first time.
  metaSubPath: meta
  # Sub-prefix of the key to where Milvus stores timestamps in etcd.
  # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
  # It is recommended not to change this parameter if there is no specific reason.
  kvSubPath: kv
  log:
    level: info # Only supports debug, info, warn, error, panic, or fatal. Default 'info'.
    # path is one of:
    #  - "default" as os.Stderr,
    #  - "stderr" as os.Stderr,
    #  - "stdout" as os.Stdout,
    #  - file path to append server logs to.
    # please adjust in embedded Milvus: /tmp/milvus/logs/etcd.log
    path: stdout
  ssl:
    enabled: false # Whether to support ETCD secure connection mode
    tlsCert: /path/to/etcd-client.pem # path to your cert file
    tlsKey: /path/to/etcd-client-key.pem # path to your key file
    tlsCACert: /path/to/ca.pem # path to your CACert file
    # TLS min version
    # Optional values: 1.0, 1.1, 1.2, 1.3ã€‚
    # We recommend using version 1.2 and above.
    tlsMinVersion: 1.3
  requestTimeout: 10000 # Etcd operation timeout in milliseconds
  use:
    embed: false # Whether to enable embedded Etcd (an in-process EtcdServer).
  data:
    dir: default.etcd # Embedded Etcd only. please adjust in embedded Milvus: /tmp/milvus/etcdData/
  auth:
    enabled: false # Whether to enable authentication
    userName:  # username for etcd authentication
    password:  # password for etcd authentication

metastore:
  type: etcd # Default value: etcd, Valid values: [etcd, tikv]
  snapshot:
    ttl: 86400 # snapshot ttl in seconds
    reserveTime: 3600 # snapshot reserve time in seconds

# Related configuration of tikv, used to store Milvus metadata.
# Notice that when TiKV is enabled for metastore, you still need to have etcd for service discovery.
# TiKV is a good option when the metadata size requires better horizontal scalability.
tikv:
  endpoints: 127.0.0.1:2389 # Note that the default pd port of tikv is 2379, which conflicts with etcd.
  rootPath: by-dev # The root path where data is stored in tikv
  metaSubPath: meta # metaRootPath = rootPath + '/' + metaSubPath
  kvSubPath: kv # kvRootPath = rootPath + '/' + kvSubPath
  requestTimeout: 10000 # ms, tikv request timeout
  snapshotScanSize: 256 # batch size of tikv snapshot scan
  ssl:
    enabled: false # Whether to support TiKV secure connection mode
    tlsCert:  # path to your cert file
    tlsKey:  # path to your key file
    tlsCACert:  # path to your CACert file

localStorage:
  # Local path to where vector data are stored during a search or a query to avoid repetitve access to MinIO or S3 service.
  # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
  # It is recommended to change this parameter before starting Milvus for the first time.
  path: /var/lib/milvus/data/

# Related configuration of MinIO/S3/GCS or any other service supports S3 API, which is responsible for data persistence for Milvus.
# We refer to the storage service as MinIO/S3 in the following description for simplicity.
minio:
  # IP address of MinIO or S3 service.
  # Environment variable: MINIO_ADDRESS
  # minio.address and minio.port together generate the valid access to MinIO or S3 service.
  # MinIO preferentially acquires the valid IP address from the environment variable MINIO_ADDRESS when Milvus is started.
  # Default value applies when MinIO or S3 is running on the same network with Milvus.
  address: localhost
  port: 9000 # Port of MinIO or S3 service.
  # Access key ID that MinIO or S3 issues to user for authorized access.
  # Environment variable: MINIO_ACCESS_KEY_ID or minio.accessKeyID
  # minio.accessKeyID and minio.secretAccessKey together are used for identity authentication to access the MinIO or S3 service.
  # This configuration must be set identical to the environment variable MINIO_ACCESS_KEY_ID, which is necessary for starting MinIO or S3.
  # The default value applies to MinIO or S3 service that started with the default docker-compose.yml file.
  accessKeyID: minioadmin
  # Secret key used to encrypt the signature string and verify the signature string on server. It must be kept strictly confidential and accessible only to the MinIO or S3 server and users.
  # Environment variable: MINIO_SECRET_ACCESS_KEY or minio.secretAccessKey
  # minio.accessKeyID and minio.secretAccessKey together are used for identity authentication to access the MinIO or S3 service.
  # This configuration must be set identical to the environment variable MINIO_SECRET_ACCESS_KEY, which is necessary for starting MinIO or S3.
  # The default value applies to MinIO or S3 service that started with the default docker-compose.yml file.
  secretAccessKey: minioadmin
  useSSL: false # Switch value to control if to access the MinIO or S3 service through SSL.
  ssl:
    tlsCACert: /path/to/public.crt # path to your CACert file
  # Name of the bucket where Milvus stores data in MinIO or S3.
  # Milvus 2.0.0 does not support storing data in multiple buckets.
  # Bucket with this name will be created if it does not exist. If the bucket already exists and is accessible, it will be used directly. Otherwise, there will be an error.
  # To share an MinIO instance among multiple Milvus instances, consider changing this to a different value for each Milvus instance before you start them. For details, see Operation FAQs.
  # The data will be stored in the local Docker if Docker is used to start the MinIO service locally. Ensure that there is sufficient storage space.
  # A bucket name is globally unique in one MinIO or S3 instance.
  bucketName: a-bucket
  # Root prefix of the key to where Milvus stores data in MinIO or S3.
  # It is recommended to change this parameter before starting Milvus for the first time.
  # To share an MinIO instance among multiple Milvus instances, consider changing this to a different value for each Milvus instance before you start them. For details, see Operation FAQs.
  # Set an easy-to-identify root key prefix for Milvus if etcd service already exists.
  # Changing this for an already running Milvus instance may result in failures to read legacy data.
  rootPath: files
  # Whether to useIAM role to access S3/GCS instead of access/secret keys
  # For more information, refer to
  # aws: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html
  # gcp: https://cloud.google.com/storage/docs/access-control/iam
  # aliyun (ack): https://www.alibabacloud.com/help/en/container-service-for-kubernetes/latest/use-rrsa-to-enforce-access-control
  # aliyun (ecs): https://www.alibabacloud.com/help/en/elastic-compute-service/latest/attach-an-instance-ram-role
  useIAM: false
  # Cloud Provider of S3. Supports: "aws", "gcp", "aliyun".
  # Cloud Provider of Google Cloud Storage. Supports: "gcpnative".
  # You can use "aws" for other cloud provider supports S3 API with signature v4, e.g.: minio
  # You can use "gcp" for other cloud provider supports S3 API with signature v2
  # You can use "aliyun" for other cloud provider uses virtual host style bucket
  # You can use "gcpnative" for the Google Cloud Platform provider. Uses service account credentials
  # for authentication.
  # When useIAM enabled, only "aws", "gcp", "aliyun" is supported for now
  cloudProvider: aws
  # The JSON content contains the gcs service account credentials.
  # Used only for the "gcpnative" cloud provider.
  gcpCredentialJSON:
  # Custom endpoint for fetch IAM role credentials. when useIAM is true & cloudProvider is "aws".
  # Leave it empty if you want to use AWS default endpoint
  iamEndpoint:
  logLevel: fatal # Log level for aws sdk log. Supported level:  off, fatal, error, warn, info, debug, trace
  region:  # Specify minio storage system location region
  useVirtualHost: false # Whether use virtual host mode for bucket
  requestTimeoutMs: 10000 # minio timeout for request time in milliseconds
  # The maximum number of objects requested per batch in minio ListObjects rpc,
  # 0 means using oss client by default, decrease these configration if ListObjects timeout
  listObjectsMaxKeys: 0

# Milvus supports four MQ: rocksmq(based on RockDB), natsmq(embedded nats-server), Pulsar and Kafka.
# You can change your mq by setting mq.type field.
# If you don't set mq.type field as default, there is a note about enabling priority if we config multiple mq in this file.
# 1. standalone(local) mode: rocksmq(default) > natsmq > Pulsar > Kafka
# 2. cluster mode:  Pulsar(default) > Kafka (rocksmq and natsmq is unsupported in cluster mode)
mq:
  # Default value: "default"
  # Valid values: [default, pulsar, kafka, rocksmq, natsmq]
  type: default
  enablePursuitMode: true # Default value: "true"
  pursuitLag: 10 # time tick lag threshold to enter pursuit mode, in seconds
  pursuitBufferSize: 8388608 # pursuit mode buffer size in bytes
  pursuitBufferTime: 60 # pursuit mode buffer time in seconds
  mqBufSize: 16 # MQ client consumer buffer length
  dispatcher:
    mergeCheckInterval: 1 # the interval time(in seconds) for dispatcher to check whether to merge
    targetBufSize: 16 # the lenth of channel buffer for targe
    maxTolerantLag: 3 # Default value: "3", the timeout(in seconds) that target sends msgPack

# Related configuration of pulsar, used to manage Milvus logs of recent mutation operations, output streaming log, and provide log publish-subscribe services.
pulsar:
  # IP address of Pulsar service.
  # Environment variable: PULSAR_ADDRESS
  # pulsar.address and pulsar.port together generate the valid access to Pulsar.
  # Pulsar preferentially acquires the valid IP address from the environment variable PULSAR_ADDRESS when Milvus is started.
  # Default value applies when Pulsar is running on the same network with Milvus.
  address: localhost
  port: 6650 # Port of Pulsar service.
  webport: 80 # Web port of of Pulsar service. If you connect direcly without proxy, should use 8080.
  # The maximum size of each message in Pulsar. Unit: Byte.
  # By default, Pulsar can transmit at most 2MB of data in a single message. When the size of inserted data is greater than this value, proxy fragments the data into multiple messages to ensure that they can be transmitted correctly.
  # If the corresponding parameter in Pulsar remains unchanged, increasing this configuration will cause Milvus to fail, and reducing it produces no advantage.
  maxMessageSize: 2097152
  # Pulsar can be provisioned for specific tenants with appropriate capacity allocated to the tenant.
  # To share a Pulsar instance among multiple Milvus instances, you can change this to an Pulsar tenant rather than the default one for each Milvus instance before you start them. However, if you do not want Pulsar multi-tenancy, you are advised to change msgChannel.chanNamePrefix.cluster to the different value.
  tenant: public
  namespace: default # A Pulsar namespace is the administrative unit nomenclature within a tenant.
  requestTimeout: 60 # pulsar client global request timeout in seconds
  enableClientMetrics: false # Whether to register pulsar client metrics into milvus metrics path.

# If you want to enable kafka, needs to comment the pulsar configs
# kafka:
#   brokerList: localhost:9092
#   saslUsername:
#   saslPassword:
#   saslMechanisms:
#   securityProtocol:
#   ssl:
#     enabled: false # whether to enable ssl mode
#     tlsCert:  # path to client's public key (PEM) used for authentication
#     tlsKey:  # path to client's private key (PEM) used for authentication
#     tlsCaCert:  # file or directory path to CA certificate(s) for verifying the broker's key
#     tlsKeyPassword:  # private key passphrase for use with ssl.key.location and set_ssl_cert(), if any
#   readTimeout: 10

rocksmq:
  # Prefix of the key to where Milvus stores data in RocksMQ.
  # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
  # It is recommended to change this parameter before starting Milvus for the first time.
  # Set an easy-to-identify root key prefix for Milvus if etcd service already exists.
  path: /var/lib/milvus/rdb_data
  lrucacheratio: 0.06 # rocksdb cache memory ratio
  rocksmqPageSize: 67108864 # The maximum size of messages in each page in RocksMQ. Messages in RocksMQ are checked and cleared (when expired) in batch based on this parameters. Unit: Byte.
  retentionTimeInMinutes: 4320 # The maximum retention time of acked messages in RocksMQ. Acked messages in RocksMQ are retained for the specified period of time and then cleared. Unit: Minute.
  retentionSizeInMB: 8192 # The maximum retention size of acked messages of each topic in RocksMQ. Acked messages in each topic are cleared if their size exceed this parameter. Unit: MB.
  compactionInterval: 86400 # Time interval to trigger rocksdb compaction to remove deleted data. Unit: Second
  compressionTypes: 0,0,7,7,7 # compaction compression type, only support use 0,7. 0 means not compress, 7 will use zstd. Length of types means num of rocksdb level.

# natsmq configuration.
# more detail: https://docs.nats.io/running-a-nats-service/configuration
natsmq:
  server:
    port: 4222 # Listening port of the NATS server.
    storeDir: /var/lib/milvus/nats # Directory to use for JetStream storage of nats
    maxFileStore: 17179869184 # Maximum size of the 'file' storage
    maxPayload: 8388608 # Maximum number of bytes in a message payload
    maxPending: 67108864 # Maximum number of bytes buffered for a connection Applies to client connections
    initializeTimeout: 4000 # waiting for initialization of natsmq finished
    monitor:
      trace: false # If true enable protocol trace log messages
      debug: false # If true enable debug log messages
      logTime: true # If set to false, log without timestamps.
      logFile: /tmp/milvus/logs/nats.log # Log file path relative to .. of milvus binary if use relative path
      logSizeLimit: 536870912 # Size in bytes after the log file rolls over to a new one
    retention:
      maxAge: 4320 # Maximum age of any message in the P-channel
      maxBytes:  # How many bytes the single P-channel may contain. Removing oldest messages if the P-channel exceeds this size
      maxMsgs:  # How many message the single P-channel may contain. Removing oldest messages if the P-channel exceeds this limit

# Related configuration of rootCoord, used to handle data definition language (DDL) and data control language (DCL) requests
rootCoord:
  dmlChannelNum: 16 # The number of DML-Channels to create at the root coord startup.
  # The maximum number of partitions in each collection.
  # New partitions cannot be created if this parameter is set as 0 or 1.
  # Range: [0, INT64MAX]
  maxPartitionNum: 1024
  # The minimum row count of a segment required for creating index.
  # Segments with smaller size than this parameter will not be indexed, and will be searched with brute force.
  minSegmentSizeToEnableIndex: 1024
  enableActiveStandby: false
  maxDatabaseNum: 64 # Maximum number of database
  maxGeneralCapacity: 65536 # upper limit for the sum of of product of partitionNumber and shardNumber
  gracefulStopTimeout: 5 # seconds. force stop node without graceful stop
  ip:  # TCP/IP address of rootCoord. If not specified, use the first unicastable address
  port: 53100 # TCP port of rootCoord
  grpc:
    serverMaxSendSize: 536870912 # The maximum size of each RPC request that the rootCoord can send, unit: byte
    serverMaxRecvSize: 268435456 # The maximum size of each RPC request that the rootCoord can receive, unit: byte
    clientMaxSendSize: 268435456 # The maximum size of each RPC request that the clients on rootCoord can send, unit: byte
    clientMaxRecvSize: 536870912 # The maximum size of each RPC request that the clients on rootCoord can receive, unit: byte

# Related configuration of proxy, used to validate client requests and reduce the returned results.
proxy:
  timeTickInterval: 200 # The interval at which proxy synchronizes the time tick, unit: ms.
  healthCheckTimeout: 3000 # ms, the interval that to do component healthy check
  msgStream:
    timeTick:
      bufSize: 512 # The maximum number of messages can be buffered in the timeTick message stream of the proxy when producing messages.
  maxNameLength: 255 # The maximum length of the name or alias that can be created in Milvus, including the collection name, collection alias, partition name, and field name.
  maxFieldNum: 64 # The maximum number of field can be created when creating in a collection. It is strongly DISCOURAGED to set maxFieldNum >= 64.
  maxVectorFieldNum: 4 # The maximum number of vector fields that can be specified in a collection. Value range: [1, 10].
  maxShardNum: 16 # The maximum number of shards can be created when creating in a collection.
  maxDimension: 32768 # The maximum number of dimensions of a vector can have when creating in a collection.
  # Whether to produce gin logs.\n
  # please adjust in embedded Milvus: false
  ginLogging: true
  ginLogSkipPaths: / # skip url path for gin log
  maxTaskNum: 1024 # The maximum number of tasks in the task queue of the proxy.
  ddlConcurrency: 16 # The concurrent execution number of DDL at proxy.
  dclConcurrency: 16 # The concurrent execution number of DCL at proxy.
  mustUsePartitionKey: false # switch for whether proxy must use partition key for the collection
  accessLog:
    enable: false # Whether to enable the access log feature.
    minioEnable: false # Whether to upload local access log files to MinIO. This parameter can be specified when proxy.accessLog.filename is not empty.
    localPath: /tmp/milvus_access # The local folder path where the access log file is stored. This parameter can be specified when proxy.accessLog.filename is not empty.
    filename:  # The name of the access log file. If you leave this parameter empty, access logs will be printed to stdout.
    maxSize: 64 # The maximum size allowed for a single access log file. If the log file size reaches this limit, a rotation process will be triggered. This process seals the current access log file, creates a new log file, and clears the contents of the original log file. Unit: MB.
    rotatedTime: 0 # The maximum time interval allowed for rotating a single access log file. Upon reaching the specified time interval, a rotation process is triggered, resulting in the creation of a new access log file and sealing of the previous one. Unit: seconds
    remotePath: access_log/ # The path of the object storage for uploading access log files.
    remoteMaxTime: 0 # The time interval allowed for uploading access log files. If the upload time of a log file exceeds this interval, the file will be deleted. Setting the value to 0 disables this feature.
    formatters:
      base:
        format: "[$time_now] [ACCESS] <$user_name: $user_addr> $method_name [status: $method_status] [code: $error_code] [sdk: $sdk_version] [msg: $error_msg] [traceID: $trace_id] [timeCost: $time_cost]"
      query:
        format: "[$time_now] [ACCESS] <$user_name: $user_addr> $method_name [status: $method_status] [code: $error_code] [sdk: $sdk_version] [msg: $error_msg] [traceID: $trace_id] [timeCost: $time_cost] [database: $database_name] [collection: $collection_name] [partitions: $partition_name] [expr: $method_expr]"
        methods: "Query,Search,Delete"
    cacheSize: 0 # Size of log of write cache, in byte. (Close write cache if size was 0)
    cacheFlushInterval: 3 # time interval of auto flush write cache, in seconds. (Close auto flush if interval was 0)
  connectionCheckIntervalSeconds: 120 # the interval time(in seconds) for connection manager to scan inactive client info
  connectionClientInfoTTLSeconds: 86400 # inactive client info TTL duration, in seconds
  maxConnectionNum: 10000 # the max client info numbers that proxy should manage, avoid too many client infos
  gracefulStopTimeout: 30 # seconds. force stop node without graceful stop
  slowQuerySpanInSeconds: 5 # query whose executed time exceeds the `slowQuerySpanInSeconds` can be considered slow, in seconds.
  queryNodePooling:
    size: 10 # the size for shardleader(querynode) client pool
  http:
    enabled: true # Whether to enable the http server
    debug_mode: false # Whether to enable http server debug mode
    port:  # high-level restful api
    acceptTypeAllowInt64: true # high-level restful api, whether http client can deal with int64
    enablePprof: true # Whether to enable pprof middleware on the metrics port
  ip:  # TCP/IP address of proxy. If not specified, use the first unicastable address
  port: 19530 # TCP port of proxy
  internalPort: 19529
  grpc:
    serverMaxSendSize: 268435456 # The maximum size of each RPC request that the proxy can send, unit: byte
    serverMaxRecvSize: 67108864 # The maximum size of each RPC request that the proxy can receive, unit: byte
    clientMaxSendSize: 268435456 # The maximum size of each RPC request that the clients on proxy can send, unit: byte
    clientMaxRecvSize: 67108864 # The maximum size of each RPC request that the clients on proxy can receive, unit: byte

# Related configuration of queryCoord, used to manage topology and load balancing for the query nodes, and handoff from growing segments to sealed segments.
queryCoord:
  taskMergeCap: 1
  taskExecutionCap: 256
  # Switch value to control if to automatically replace a growing segment with the corresponding indexed sealed segment when the growing segment reaches the sealing threshold.
  # If this parameter is set false, Milvus simply searches the growing segments with brute force.
  autoHandoff: true
  autoBalance: true # Switch value to control if to automatically balance the memory usage among query nodes by distributing segment loading and releasing operations evenly.
  autoBalanceChannel: true # Enable auto balance channel
  balancer: ScoreBasedBalancer # auto balancer used for segments on queryNodes
  globalRowCountFactor: 0.1 # the weight used when balancing segments among queryNodes
  scoreUnbalanceTolerationFactor: 0.05 # the least value for unbalanced extent between from and to nodes when doing balance
  reverseUnBalanceTolerationFactor: 1.3 # the largest value for unbalanced extent between from and to nodes after doing balance
  overloadedMemoryThresholdPercentage: 90 # The threshold of memory usage (in percentage) in a query node to trigger the sealed segment balancing.
  balanceIntervalSeconds: 60 # The interval at which query coord balances the memory usage among query nodes.
  memoryUsageMaxDifferencePercentage: 30 # The threshold of memory usage difference (in percentage) between any two query nodes to trigger the sealed segment balancing.
  rowCountFactor: 0.4 # the row count weight used when balancing segments among queryNodes
  segmentCountFactor: 0.4 # the segment count weight used when balancing segments among queryNodes
  globalSegmentCountFactor: 0.1 # the segment count weight used when balancing segments among queryNodes
  # the channel count weight used when balancing channels among queryNodes,
  # 		A higher value reduces the likelihood of assigning channels from the same collection to the same QueryNode. Set to 1 to disable this feature.
  collectionChannelCountFactor: 10
  segmentCountMaxSteps: 50 # segment count based plan generator max steps
  rowCountMaxSteps: 50 # segment count based plan generator max steps
  randomMaxSteps: 10 # segment count based plan generator max steps
  growingRowCountWeight: 4 # the memory weight of growing segment row count
  delegatorMemoryOverloadFactor: 0.1 # the factor of delegator overloaded memory
  balanceCostThreshold: 0.001 # the threshold of balance cost, if the difference of cluster's cost after executing the balance plan is less than this value, the plan will not be executed
  checkSegmentInterval: 1000
  checkChannelInterval: 1000
  checkBalanceInterval: 3000
  checkIndexInterval: 10000
  channelTaskTimeout: 60000 # 1 minute
  segmentTaskTimeout: 120000 # 2 minute
  distPullInterval: 500
  heartbeatAvailableInterval: 10000 # 10s, Only QueryNodes which fetched heartbeats within the duration are available
  loadTimeoutSeconds: 600
  distRequestTimeout: 5000 # the request timeout for querycoord fetching data distribution from querynodes, in milliseconds
  heatbeatWarningLag: 5000 # the lag value for querycoord report warning when last heatbeat is too old, in milliseconds
  checkHandoffInterval: 5000
  enableActiveStandby: false
  checkInterval: 1000
  checkHealthInterval: 3000 # 3s, the interval when query coord try to check health of query node
  checkHealthRPCTimeout: 2000 # 100ms, the timeout of check health rpc to query node
  brokerTimeout: 5000 # 5000ms, querycoord broker rpc timeout
  collectionRecoverTimes: 3 # if collection recover times reach the limit during loading state, release it
  observerTaskParallel: 16 # the parallel observer dispatcher task number
  checkAutoBalanceConfigInterval: 10 # the interval of check auto balance config
  checkNodeSessionInterval: 60 # the interval(in seconds) of check querynode cluster session
  gracefulStopTimeout: 5 # seconds. force stop node without graceful stop
  enableStoppingBalance: true # whether enable stopping balance
  channelExclusiveNodeFactor: 4 # the least node number for enable channel's exclusive mode
  collectionObserverInterval: 200 # the interval of collection observer
  checkExecutedFlagInterval: 100 # the interval of check executed flag to force to pull dist
  updateCollectionLoadStatusInterval: 5 # 5m, max interval of updating collection loaded status for check health
  cleanExcludeSegmentInterval: 60 # the time duration of clean pipeline exclude segment which used for filter invalid data, in seconds
  ip:  # TCP/IP address of queryCoord. If not specified, use the first unicastable address
  port: 19531 # TCP port of queryCoord
  grpc:
    serverMaxSendSize: 536870912 # The maximum size of each RPC request that the queryCoord can send, unit: byte
    serverMaxRecvSize: 268435456 # The maximum size of each RPC request that the queryCoord can receive, unit: byte
    clientMaxSendSize: 268435456 # The maximum size of each RPC request that the clients on queryCoord can send, unit: byte
    clientMaxRecvSize: 536870912 # The maximum size of each RPC request that the clients on queryCoord can receive, unit: byte

# Related configuration of queryNode, used to run hybrid search between vector and scalar data.
queryNode:
  stats:
    publishInterval: 1000 # The interval that query node publishes the node statistics information, including segment status, cpu usage, memory usage, health status, etc. Unit: ms.
  segcore:
    knowhereThreadPoolNumRatio: 4 # The number of threads in knowhere's thread pool. If disk is enabled, the pool size will multiply with knowhereThreadPoolNumRatio([1, 32]).
    chunkRows: 128 # Row count by which Segcore divides a segment into chunks.
    interimIndex:
      # Whether to create a temporary index for growing segments and sealed segments not yet indexed, improving search performance.
      # Milvus will eventually seals and indexes all segments, but enabling this optimizes search performance for immediate queries following data insertion.
      # This defaults to true, indicating that Milvus creates temporary index for growing segments and the sealed segments that are not indexed upon searches.
      enableIndex: true
      nlist: 128 # temp index nlist, recommend to set sqrt(chunkRows), must smaller than chunkRows/8
      nprobe: 16 # nprobe to search small index, based on your accuracy requirement, must smaller than nlist
      memExpansionRate: 1.15 # extra memory needed by building interim index
      buildParallelRate: 0.5 # the ratio of building interim index parallel matched with cpu num
    multipleChunkedEnable: true # Enable multiple chunked search
    knowhereScoreConsistency: false # Enable knowhere strong consistency score computation logic
  loadMemoryUsageFactor: 1 # The multiply factor of calculating the memory usage while loading segments
  enableDisk: false # enable querynode load disk index, and search on disk index
  maxDiskUsagePercentage: 95
  cache:
    memoryLimit: 2147483648 # 2 GB, 2 * 1024 *1024 *1024
    readAheadPolicy: willneed # The read ahead policy of chunk cache, options: `normal, random, sequential, willneed, dontneed`
    # options: async, sync, disable.
    # Specifies the necessity for warming up the chunk cache.
    # 1. If set to "sync" or "async" the original vector data will be synchronously/asynchronously loaded into the
    # chunk cache during the load process. This approach has the potential to substantially reduce query/search latency
    # for a specific duration post-load, albeit accompanied by a concurrent increase in disk usage;
    # 2. If set to "disable" original vector data will only be loaded into the chunk cache during search/query.
    warmup: disable
  mmap:
    vectorField: false # Enable mmap for loading vector data
    vectorIndex: false # Enable mmap for loading vector index
    scalarField: false # Enable mmap for loading scalar data
    scalarIndex: false # Enable mmap for loading scalar index
    chunkCache: true # Enable mmap for chunk cache (raw vector retrieving).
    # Enable memory mapping (mmap) to optimize the handling of growing raw data.
    # By activating this feature, the memory overhead associated with newly added or modified data will be significantly minimized.
    # However, this optimization may come at the cost of a slight decrease in query latency for the affected data segments.
    growingMmapEnabled: false
    fixedFileSizeForMmapAlloc: 1 # tmp file size for mmap chunk manager
    maxDiskUsagePercentageForMmapAlloc: 50 # disk percentage used in mmap chunk manager
  lazyload:
    enabled: false # Enable lazyload for loading data
    waitTimeout: 30000 # max wait timeout duration in milliseconds before start to do lazyload search and retrieve
    requestResourceTimeout: 5000 # max timeout in milliseconds for waiting request resource for lazy load, 5s by default
    requestResourceRetryInterval: 2000 # retry interval in milliseconds for waiting request resource for lazy load, 2s by default
    maxRetryTimes: 1 # max retry times for lazy load, 1 by default
    maxEvictPerRetry: 1 # max evict count for lazy load, 1 by default
  indexOffsetCacheEnabled: false # enable index offset cache for some scalar indexes, now is just for bitmap index, enable this param can improve performance for retrieving raw data from index
  grouping:
    enabled: true
    maxNQ: 1000
    topKMergeRatio: 20
  scheduler:
    receiveChanSize: 10240
    unsolvedQueueSize: 10240
    # maxReadConcurrentRatio is the concurrency ratio of read task (search task and query task).
    # Max read concurrency would be the value of hardware.GetCPUNum * maxReadConcurrentRatio.
    # It defaults to 2.0, which means max read concurrency would be the value of hardware.GetCPUNum * 2.
    # Max read concurrency must greater than or equal to 1, and less than or equal to hardware.GetCPUNum * 100.
    # (0, 100]
    maxReadConcurrentRatio: 1
    cpuRatio: 10 # ratio used to estimate read task cpu usage.
    maxTimestampLag: 86400
    scheduleReadPolicy:
      # fifo: A FIFO queue support the schedule.
      # user-task-polling:
      # 	The user's tasks will be polled one by one and scheduled.
      # 	Scheduling is fair on task granularity.
      # 	The policy is based on the username for authentication.
      # 	And an empty username is considered the same user.
      # 	When there are no multi-users, the policy decay into FIFO"
      name: fifo
      taskQueueExpire: 60 # Control how long (many seconds) that queue retains since queue is empty
      enableCrossUserGrouping: false # Enable Cross user grouping when using user-task-polling policy. (Disable it if user's task can not merge each other)
      maxPendingTaskPerUser: 1024 # Max pending task per user in scheduler
  levelZeroForwardPolicy: FilterByBF # delegator level zero deletion forward policy, possible option["FilterByBF", "RemoteLoad"]
  streamingDeltaForwardPolicy: FilterByBF # delegator streaming deletion forward policy, possible option["FilterByBF", "Direct"]
  dataSync:
    flowGraph:
      maxQueueLength: 16 # The maximum size of task queue cache in flow graph in query node.
      maxParallelism: 1024 # Maximum number of tasks executed in parallel in the flowgraph
  enableSegmentPrune: false # use partition stats to prune data in search/query on shard delegator
  queryStreamBatchSize: 4194304 # return min batch size of stream query
  queryStreamMaxBatchSize: 134217728 # return max batch size of stream query
  bloomFilterApplyParallelFactor: 4 # parallel factor when to apply pk to bloom filter, default to 4*CPU_CORE_NUM
  workerPooling:
    size: 10 # the size for worker querynode client pool
  ip:  # TCP/IP address of queryNode. If not specified, use the first unicastable address
  port: 21123 # TCP port of queryNode
  grpc:
    serverMaxSendSize: 536870912 # The maximum size of each RPC request that the queryNode can send, unit: byte
    serverMaxRecvSize: 268435456 # The maximum size of each RPC request that the queryNode can receive, unit: byte
    clientMaxSendSize: 268435456 # The maximum size of each RPC request that the clients on queryNode can send, unit: byte
    clientMaxRecvSize: 536870912 # The maximum size of each RPC request that the clients on queryNode can receive, unit: byte

indexCoord:
  bindIndexNodeMode:
    enable: false
    address: localhost:22930
    withCred: false
    nodeID: 0
  segment:
    minSegmentNumRowsToEnableIndex: 1024 # It's a threshold. When the segment num rows is less than this value, the segment will not be indexed

indexNode:
  scheduler:
    buildParallel: 1
  enableDisk: true # enable index node build disk vector index
  maxDiskUsagePercentage: 95
  ip:  # TCP/IP address of indexNode. If not specified, use the first unicastable address
  port: 21121 # TCP port of indexNode
  grpc:
    serverMaxSendSize: 536870912 # The maximum size of each RPC request that the indexNode can send, unit: byte
    serverMaxRecvSize: 268435456 # The maximum size of each RPC request that the indexNode can receive, unit: byte
    clientMaxSendSize: 268435456 # The maximum size of each RPC request that the clients on indexNode can send, unit: byte
    clientMaxRecvSize: 536870912 # The maximum size of each RPC request that the clients on indexNode can receive, unit: byte

dataCoord:
  channel:
    watchTimeoutInterval: 300 # Timeout on watching channels (in seconds). Datanode tickler update watch progress will reset timeout timer.
    legacyVersionWithoutRPCWatch: 2.4.1 # Datanodes <= this version are considered as legacy nodes, which doesn't have rpc based watch(). This is only used during rolling upgrade where legacy nodes won't get new channels
    balanceSilentDuration: 300 # The duration after which the channel manager start background channel balancing
    balanceInterval: 360 # The interval with which the channel manager check dml channel balance status
    checkInterval: 1 # The interval in seconds with which the channel manager advances channel states
    notifyChannelOperationTimeout: 5 # Timeout notifing channel operations (in seconds).
    maxConcurrentChannelTaskNumPerDN: 32 # The maximum concurrency for each DataNode executing channel tasks (watch, release).
  segment:
    maxSize: 1024 # The maximum size of a segment, unit: MB. datacoord.segment.maxSize and datacoord.segment.sealProportion together determine if a segment can be sealed.
    diskSegmentMaxSize: 2048 # Maximun size of a segment in MB for collection which has Disk index
    sealProportion: 0.12 # The minimum proportion to datacoord.segment.maxSize to seal a segment. datacoord.segment.maxSize and datacoord.segment.sealProportion together determine if a segment can be sealed.
    sealProportionJitter: 0.1 # segment seal proportion jitter ratio, default value 0.1(10%), if seal proportion is 12%, with jitter=0.1, the actuall applied ratio will be 10.8~12%
    assignmentExpiration: 2000 # Expiration time of the segment assignment, unit: ms
    allocLatestExpireAttempt: 200 # The time attempting to alloc latest lastExpire from rootCoord after restart
    maxLife: 86400 # The max lifetime of segment in seconds, 24*60*60
    # If a segment didn't accept dml records in maxIdleTime and the size of segment is greater than
    # minSizeFromIdleToSealed, Milvus will automatically seal it.
    # The max idle time of segment in seconds, 10*60.
    maxIdleTime: 600
    minSizeFromIdleToSealed: 16 # The min size in MB of segment which can be idle from sealed.
    # The max number of binlog (which is equal to the binlog file num of primary key) for one segment,
    # the segment will be sealed if the number of binlog file reaches to max value.
    maxBinlogFileNumber: 32
    smallProportion: 0.5 # The segment is considered as "small segment" when its # of rows is smaller than
    # (smallProportion * segment max # of rows).
    # A compaction will happen on small segments if the segment after compaction will have
    compactableProportion: 0.85
    # over (compactableProportion * segment max # of rows) rows.
    # MUST BE GREATER THAN OR EQUAL TO <smallProportion>!!!
    # During compaction, the size of segment # of rows is able to exceed segment max # of rows by (expansionRate-1) * 100%.
    expansionRate: 1.25
  sealPolicy:
    channel:
      # The size threshold in MB, if the total size of growing segments of each shard
      # exceeds this threshold, the largest growing segment will be sealed.
      growingSegmentsMemSize: 4096
  autoUpgradeSegmentIndex: false # whether auto upgrade segment index to index engine's version
  segmentFlushInterval: 2 # the minimal interval duration(unit: Seconds) between flusing operation on same segment
  # Switch value to control if to enable segment compaction.
  # Compaction merges small-size segments into a large segment, and clears the entities deleted beyond the rentention duration of Time Travel.
  enableCompaction: true
  compaction:
    # Switch value to control if to enable automatic segment compaction during which data coord locates and merges compactable segments in the background.
    # This configuration takes effect only when dataCoord.enableCompaction is set as true.
    enableAutoCompaction: true
    indexBasedCompaction: true
    # compaction task prioritizer, options: [default, level, mix].
    # default is FIFO.
    # level is prioritized by level: L0 compactions first, then mix compactions, then clustering compactions.
    # mix is prioritized by level: mix compactions first, then L0 compactions, then clustering compactions.
    taskPrioritizer: default
    taskQueueCapacity: 100000 # compaction task queue size
    rpcTimeout: 10
    maxParallelTaskNum: 10
    dropTolerance: 86400 # Compaction task will be cleaned after finish longer than this time(in seconds)
    gcInterval: 1800 # The time interval in seconds for compaction gc
    mix:
      triggerInterval: 60 # The time interval in seconds to trigger mix compaction
    levelzero:
      triggerInterval: 10 # The time interval in seconds for trigger L0 compaction
      forceTrigger:
        minSize: 8388608 # The minmum size in bytes to force trigger a LevelZero Compaction, default as 8MB
        maxSize: 67108864 # The maxmum size in bytes to force trigger a LevelZero Compaction, default as 64MB
        deltalogMinNum: 10 # The minimum number of deltalog files to force trigger a LevelZero Compaction
        deltalogMaxNum: 30 # The maxmum number of deltalog files to force trigger a LevelZero Compaction, default as 30
    single:
      ratio:
        threshold: 0.2 # The ratio threshold of a segment to trigger a single compaction, default as 0.2
      deltalog:
        maxsize: 16777216 # The deltalog size of a segment to trigger a single compaction, default as 16MB
        maxnum: 200 # The deltalog count of a segment to trigger a compaction, default as 200
      expiredlog:
        maxsize: 10485760 # The expired log size of a segment to trigger a compaction, default as 10MB
    clustering:
      enable: true # Enable clustering compaction
      autoEnable: false # Enable auto clustering compaction
      triggerInterval: 600 # clustering compaction trigger interval in seconds
      minInterval: 3600 # The minimum interval between clustering compaction executions of one collection, to avoid redundant compaction
      maxInterval: 259200 # If a collection haven't been clustering compacted for longer than maxInterval, force compact
      newDataSizeThreshold: 512m # If new data size is large than newDataSizeThreshold, execute clustering compaction
      preferSegmentSizeRatio: 0.8
      maxSegmentSizeRatio: 1
      maxTrainSizeRatio: 0.8 # max data size ratio in Kmeans train, if larger than it, will down sampling to meet this limit
      maxCentroidsNum: 10240 # maximum centroids number in Kmeans train
      minCentroidsNum: 16 # minimum centroids number in Kmeans train
      minClusterSizeRatio: 0.01 # minimum cluster size / avg size in Kmeans train
      maxClusterSizeRatio: 10 # maximum cluster size / avg size in Kmeans train
      maxClusterSize: 5g # maximum cluster size in Kmeans train
  syncSegmentsInterval: 300 # The time interval for regularly syncing segments
  index:
    memSizeEstimateMultiplier: 2 # When the memory size is not setup by index procedure, multiplier to estimate the memory size of index data
  enableGarbageCollection: true # Switch value to control if to enable garbage collection to clear the discarded data in MinIO or S3 service.
  gc:
    interval: 3600 # The interval at which data coord performs garbage collection, unit: second.
    missingTolerance: 86400 # The retention duration of the unrecorded binary log (binlog) files. Setting a reasonably large value for this parameter avoids erroneously deleting the newly created binlog files that lack metadata. Unit: second.
    dropTolerance: 10800 # The retention duration of the binlog files of the deleted segments before they are cleared, unit: second.
    removeConcurrent: 32 # number of concurrent goroutines to remove dropped s3 objects
    scanInterval: 168 # orphan file (file on oss but has not been registered on meta) on object storage garbage collection scanning interval in hours
  enableActiveStandby: false
  brokerTimeout: 5000 # 5000ms, dataCoord broker rpc timeout
  autoBalance: true # Enable auto balance
  checkAutoBalanceConfigInterval: 10 # the interval of check auto balance config
  import:
    filesPerPreImportTask: 2 # The maximum number of files allowed per pre-import task.
    taskRetention: 10800 # The retention period in seconds for tasks in the Completed or Failed state.
    maxSizeInMBPerImportTask: 6144 # To prevent generating of small segments, we will re-group imported files. This parameter represents the sum of file sizes in each group (each ImportTask).
    scheduleInterval: 2 # The interval for scheduling import, measured in seconds.
    checkIntervalHigh: 2 # The interval for checking import, measured in seconds, is set to a high frequency for the import checker.
    checkIntervalLow: 120 # The interval for checking import, measured in seconds, is set to a low frequency for the import checker.
    maxImportFileNumPerReq: 1024 # The maximum number of files allowed per single import request.
    maxImportJobNum: 1024 # Maximum number of import jobs that are executing or pending.
    waitForIndex: true # Indicates whether the import operation waits for the completion of index building.
  gracefulStopTimeout: 5 # seconds. force stop node without graceful stop
  slot:
    clusteringCompactionUsage: 16 # slot usage of clustering compaction job.
    mixCompactionUsage: 8 # slot usage of mix compaction job.
    l0DeleteCompactionUsage: 8 # slot usage of l0 compaction job.
  ip:  # TCP/IP address of dataCoord. If not specified, use the first unicastable address
  port: 13333 # TCP port of dataCoord
  grpc:
    serverMaxSendSize: 536870912 # The maximum size of each RPC request that the dataCoord can send, unit: byte
    serverMaxRecvSize: 268435456 # The maximum size of each RPC request that the dataCoord can receive, unit: byte
    clientMaxSendSize: 268435456 # The maximum size of each RPC request that the clients on dataCoord can send, unit: byte
    clientMaxRecvSize: 536870912 # The maximum size of each RPC request that the clients on dataCoord can receive, unit: byte

dataNode:
  dataSync:
    flowGraph:
      maxQueueLength: 16 # Maximum length of task queue in flowgraph
      maxParallelism: 1024 # Maximum number of tasks executed in parallel in the flowgraph
    maxParallelSyncMgrTasks: 256 # The max concurrent sync task number of datanode sync mgr globally
    skipMode:
      enable: true # Support skip some timetick message to reduce CPU usage
      skipNum: 4 # Consume one for every n records skipped
      coldTime: 60 # Turn on skip mode after there are only timetick msg for x seconds
  segment:
    # The maximum size of each binlog file in a segment buffered in memory. Binlog files whose size exceeds this value are then flushed to MinIO or S3 service.
    # Unit: Byte
    # Setting this parameter too small causes the system to store a small amount of data too frequently. Setting it too large increases the system's demand for memory.
    insertBufSize: 16777216
    deleteBufBytes: 16777216 # Max buffer size in bytes to flush del for a single channel, default as 16MB
    syncPeriod: 600 # The period to sync segments if buffer is not empty.
  memory:
    forceSyncEnable: true # Set true to force sync if memory usage is too high
    forceSyncSegmentNum: 1 # number of segments to sync, segments with top largest buffer will be synced.
    checkInterval: 3000 # the interal to check datanode memory usage, in milliseconds
    forceSyncWatermark: 0.5 # memory watermark for standalone, upon reaching this watermark, segments will be synced.
  timetick:
    interval: 500
  channel:
    # specify the size of global work pool of all channels
    # if this parameter <= 0, will set it as the maximum number of CPUs that can be executing
    # suggest to set it bigger on large collection numbers to avoid blocking
    workPoolSize: -1
    # specify the size of global work pool for channel checkpoint updating
    # if this parameter <= 0, will set it as 10
    updateChannelCheckpointMaxParallel: 10
    updateChannelCheckpointInterval: 60 # the interval duration(in seconds) for datanode to update channel checkpoint of each channel
    updateChannelCheckpointRPCTimeout: 20 # timeout in seconds for UpdateChannelCheckpoint RPC call
    maxChannelCheckpointsPerPRC: 128 # The maximum number of channel checkpoints per UpdateChannelCheckpoint RPC.
    channelCheckpointUpdateTickInSeconds: 10 # The frequency, in seconds, at which the channel checkpoint updater executes updates.
  import:
    maxConcurrentTaskNum: 16 # The maximum number of import/pre-import tasks allowed to run concurrently on a datanode.
    maxImportFileSizeInGB: 16 # The maximum file size (in GB) for an import file, where an import file refers to either a Row-Based file or a set of Column-Based files.
    readBufferSizeInMB: 16 # The data block size (in MB) read from chunk manager by the datanode during import.
    maxTaskSlotNum: 16 # The maximum number of slots occupied by each import/pre-import task.
  compaction:
    levelZeroBatchMemoryRatio: 0.5 # The minimal memory ratio of free memory for level zero compaction executing in batch mode
    levelZeroMaxBatchSize: -1 # Max batch size refers to the max number of L1/L2 segments in a batch when executing L0 compaction. Default to -1, any value that is less than 1 means no limit. Valid range: >= 1.
    useMergeSort: false # Whether to enable mergeSort mode when performing mixCompaction.
    maxSegmentMergeSort: 30 # The maximum number of segments to be merged in mergeSort mode.
  gracefulStopTimeout: 1800 # seconds. force stop node without graceful stop
  slot:
    slotCap: 16 # The maximum number of tasks(e.g. compaction, importing) allowed to run concurrently on a datanode
  clusteringCompaction:
    memoryBufferRatio: 0.3 # The ratio of memory buffer of clustering compaction. Data larger than threshold will be flushed to storage.
    workPoolSize: 8 # worker pool size for one clustering compaction job.
  bloomFilterApplyParallelFactor: 4 # parallel factor when to apply pk to bloom filter, default to 4*CPU_CORE_NUM
  storage:
    deltalog: json # deltalog format, options: [json, parquet]
  ip:  # TCP/IP address of dataNode. If not specified, use the first unicastable address
  port: 21124 # TCP port of dataNode
  grpc:
    serverMaxSendSize: 536870912 # The maximum size of each RPC request that the dataNode can send, unit: byte
    serverMaxRecvSize: 268435456 # The maximum size of each RPC request that the dataNode can receive, unit: byte
    clientMaxSendSize: 268435456 # The maximum size of each RPC request that the clients on dataNode can send, unit: byte
    clientMaxRecvSize: 536870912 # The maximum size of each RPC request that the clients on dataNode can receive, unit: byte

# This topic introduces the message channel-related configurations of Milvus.
msgChannel:
  chanNamePrefix:
    # Root name prefix of the channel when a message channel is created.
    # It is recommended to change this parameter before starting Milvus for the first time.
    # To share a Pulsar instance among multiple Milvus instances, consider changing this to a name rather than the default one for each Milvus instance before you start them.
    cluster: by-dev
    # Sub-name prefix of the message channel where the root coord publishes time tick messages.
    # The complete channel name prefix is ${msgChannel.chanNamePrefix.cluster}-${msgChannel.chanNamePrefix.rootCoordTimeTick}
    # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
    # It is recommended to change this parameter before starting Milvus for the first time.
    rootCoordTimeTick: rootcoord-timetick
    # Sub-name prefix of the message channel where the root coord publishes its own statistics messages.
    # The complete channel name prefix is ${msgChannel.chanNamePrefix.cluster}-${msgChannel.chanNamePrefix.rootCoordStatistics}
    # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
    # It is recommended to change this parameter before starting Milvus for the first time.
    rootCoordStatistics: rootcoord-statistics
    # Sub-name prefix of the message channel where the root coord publishes Data Manipulation Language (DML) messages.
    # The complete channel name prefix is ${msgChannel.chanNamePrefix.cluster}-${msgChannel.chanNamePrefix.rootCoordDml}
    # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
    # It is recommended to change this parameter before starting Milvus for the first time.
    rootCoordDml: rootcoord-dml
    replicateMsg: replicate-msg
    # Sub-name prefix of the message channel where the query node publishes time tick messages.
    # The complete channel name prefix is ${msgChannel.chanNamePrefix.cluster}-${msgChannel.chanNamePrefix.queryTimeTick}
    # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
    # It is recommended to change this parameter before starting Milvus for the first time.
    queryTimeTick: queryTimeTick
    # Sub-name prefix of the message channel where the data coord publishes time tick messages.
    # The complete channel name prefix is ${msgChannel.chanNamePrefix.cluster}-${msgChannel.chanNamePrefix.dataCoordTimeTick}
    # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
    # It is recommended to change this parameter before starting Milvus for the first time.
    dataCoordTimeTick: datacoord-timetick-channel
    # Sub-name prefix of the message channel where the data coord publishes segment information messages.
    # The complete channel name prefix is ${msgChannel.chanNamePrefix.cluster}-${msgChannel.chanNamePrefix.dataCoordSegmentInfo}
    # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
    # It is recommended to change this parameter before starting Milvus for the first time.
    dataCoordSegmentInfo: segment-info-channel
  subNamePrefix:
    # Subscription name prefix of the data coord.
    # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
    # It is recommended to change this parameter before starting Milvus for the first time.
    dataCoordSubNamePrefix: dataCoord
    # Subscription name prefix of the data node.
    # Caution: Changing this parameter after using Milvus for a period of time will affect your access to old data.
    # It is recommended to change this parameter before starting Milvus for the first time.
    dataNodeSubNamePrefix: dataNode

# Configures the system log output.
log:
  # Milvus log level. Option: debug, info, warn, error, panic, and fatal.
  # It is recommended to use debug level under test and development environments, and info level in production environment.
  level: info
  file:
    # Root path to the log files.
    # The default value is set empty, indicating to output log files to standard output (stdout) and standard error (stderr).
    # If this parameter is set to a valid local path, Milvus writes and stores log files in this path.
    # Set this parameter as the path that you have permission to write.
    rootPath:
    maxSize: 300 # The maximum size of a log file, unit: MB.
    maxAge: 10 # The maximum retention time before a log file is automatically cleared, unit: day. The minimum value is 1.
    maxBackups: 20 # The maximum number of log files to back up, unit: day. The minimum value is 1.
  format: text # Milvus log format. Option: text and JSON
  stdout: true # Stdout enable or not

grpc:
  log:
    level: WARNING
  gracefulStopTimeout: 10 # second, time to wait graceful stop finish
  client:
    compressionEnabled: false
    dialTimeout: 200
    keepAliveTime: 10000
    keepAliveTimeout: 20000
    maxMaxAttempts: 10
    initialBackoff: 0.2
    maxBackoff: 10
    backoffMultiplier: 2
    minResetInterval: 1000
    maxCancelError: 32
    minSessionCheckInterval: 200

# Configure external tls.
tls:
  serverPemPath: configs/cert/server.pem
  serverKeyPath: configs/cert/server.key
  caPemPath: configs/cert/ca.pem

# Configure internal tls.
internaltls:
  serverPemPath: configs/cert/server.pem
  serverKeyPath: configs/cert/server.key
  caPemPath: configs/cert/ca.pem
  sni: localhost # The server name indication (SNI) for internal TLS, should be the same as the name provided by the certificates ref: https://en.wikipedia.org/wiki/Server_Name_Indication

common:
  defaultPartitionName: _default # Name of the default partition when a collection is created
  defaultIndexName: _default_idx # Name of the index when it is created with name unspecified
  entityExpiration: -1 # Entity expiration in seconds, CAUTION -1 means never expire
  indexSliceSize: 16 # Index slice size in MB
  threadCoreCoefficient:
    highPriority: 10 # This parameter specify how many times the number of threads is the number of cores in high priority pool
    middlePriority: 5 # This parameter specify how many times the number of threads is the number of cores in middle priority pool
    lowPriority: 1 # This parameter specify how many times the number of threads is the number of cores in low priority pool
  buildIndexThreadPoolRatio: 0.75
  DiskIndex:
    MaxDegree: 56
    SearchListSize: 100
    PQCodeBudgetGBRatio: 0.125
    BuildNumThreadsRatio: 1
    SearchCacheBudgetGBRatio: 0.1
    LoadNumThreadRatio: 8
    BeamWidthRatio: 4
  gracefulTime: 5000 # milliseconds. it represents the interval (in ms) by which the request arrival time needs to be subtracted in the case of Bounded Consistency.
  gracefulStopTimeout: 1800 # seconds. it will force quit the server if the graceful stop process is not completed during this time.
  storageType: remote # please adjust in embedded Milvus: local, available values are [local, remote, opendal], value minio is deprecated, use remote instead
  # Default value: auto
  # Valid values: [auto, avx512, avx2, avx, sse4_2]
  # This configuration is only used by querynode and indexnode, it selects CPU instruction set for Searching and Index-building.
  simdType: auto
  security:
    authorizationEnabled: true
    # The superusers will ignore some system check processes,
    # like the old password verification when updating the credential
    superUsers:
    defaultRootPassword: "Milvus" # default password for root user. The maximum length is 72 characters, and double quotes are required.
    rbac:
      overrideBuiltInPrivilegeGroups:
        enabled: false # Whether to override build-in privilege groups
      cluster:
        readonly:
          privileges: ListDatabases,SelectOwnership,SelectUser,DescribeResourceGroup,ListResourceGroups,ListPrivilegeGroups # Cluster level readonly privileges
        readwrite:
          privileges: ListDatabases,SelectOwnership,SelectUser,DescribeResourceGroup,ListResourceGroups,ListPrivilegeGroups,FlushAll,TransferNode,TransferReplica,UpdateResourceGroups # Cluster level readwrite privileges
        admin:
          privileges: ListDatabases,SelectOwnership,SelectUser,DescribeResourceGroup,ListResourceGroups,ListPrivilegeGroups,FlushAll,TransferNode,TransferReplica,UpdateResourceGroups,BackupRBAC,RestoreRBAC,CreateDatabase,DropDatabase,CreateOwnership,DropOwnership,ManageOwnership,CreateResourceGroup,DropResourceGroup,UpdateUser,RenameCollection,CreatePrivilegeGroup,DropPrivilegeGroup,OperatePrivilegeGroup # Cluster level admin privileges
      database:
        readonly:
          privileges: ShowCollections,DescribeDatabase # Database level readonly privileges
        readwrite:
          privileges: ShowCollections,DescribeDatabase,AlterDatabase # Database level readwrite privileges
        admin:
          privileges: ShowCollections,DescribeDatabase,AlterDatabase,CreateCollection,DropCollection # Database level admin privileges
      collection:
        readonly:
          privileges: Query,Search,IndexDetail,GetFlushState,GetLoadState,GetLoadingProgress,HasPartition,ShowPartitions,DescribeCollection,DescribeAlias,GetStatistics,ListAliases # Collection level readonly privileges
        readwrite:
          privileges: Query,Search,IndexDetail,GetFlushState,GetLoadState,GetLoadingProgress,HasPartition,ShowPartitions,DescribeCollection,DescribeAlias,GetStatistics,ListAliases,Load,Release,Insert,Delete,Upsert,Import,Flush,Compaction,LoadBalance,CreateIndex,DropIndex,CreatePartition,DropPartition # Collection level readwrite privileges
        admin:
          privileges: Query,Search,IndexDetail,GetFlushState,GetLoadState,GetLoadingProgress,HasPartition,ShowPartitions,DescribeCollection,DescribeAlias,GetStatistics,ListAliases,Load,Release,Insert,Delete,Upsert,Import,Flush,Compaction,LoadBalance,CreateIndex,DropIndex,CreatePartition,DropPartition,CreateAlias,DropAlias # Collection level admin privileges
    internaltlsEnabled: false
    tlsMode: 0
  session:
    ttl: 30 # ttl value when session granting a lease to register service
    retryTimes: 30 # retry times when session sending etcd requests
  locks:
    metrics:
      enable: false # whether gather statistics for metrics locks
    threshold:
      info: 500 # minimum milliseconds for printing durations in info level
      warn: 1000 # minimum milliseconds for printing durations in warn level
  storage:
    scheme: s3
    enablev2: false
  # Whether to disable the internal time messaging mechanism for the system.
  # If disabled (set to false), the system will not allow DML operations, including insertion, deletion, queries, and searches.
  # This helps Milvus-CDC synchronize incremental data
  ttMsgEnabled: true
  traceLogMode: 0 # trace request info
  bloomFilterSize: 100000 # bloom filter initial size
  bloomFilterType: BlockedBloomFilter # bloom filter type, support BasicBloomFilter and BlockedBloomFilter
  maxBloomFalsePositive: 0.001 # max false positive rate for bloom filter
  bloomFilterApplyBatchSize: 1000 # batch size when to apply pk to bloom filter
  collectionReplicateEnable: false # Whether to enable collection replication.
  usePartitionKeyAsClusteringKey: false # if true, do clustering compaction and segment prune on partition key field
  useVectorAsClusteringKey: false # if true, do clustering compaction and segment prune on vector field
  enableVectorClusteringKey: false # if true, enable vector clustering key and vector clustering compaction
  localRPCEnabled: false # enable local rpc for internal communication when mix or standalone mode.
  sync:
    taskPoolReleaseTimeoutSeconds: 60 # The maximum time to wait for the task to finish and release resources in the pool

# QuotaConfig, configurations of Milvus quota and limits.
# By default, we enable:
#   1. TT protection;
#   2. Memory protection.
#   3. Disk quota protection.
# You can enable:
#   1. DML throughput limitation;
#   2. DDL, DQL qps/rps limitation;
#   3. DQL Queue length/latency protection;
#   4. DQL result rate protection;
# If necessary, you can also manually force to deny RW requests.
quotaAndLimits:
  enabled: true # `true` to enable quota and limits, `false` to disable.
  # quotaCenterCollectInterval is the time interval that quotaCenter
  # collects metrics from Proxies, Query cluster and Data cluster.
  # seconds, (0 ~ 65536)
  quotaCenterCollectInterval: 3
  limits:
    allocRetryTimes: 15 # retry times when delete alloc forward data from rate limit failed
    allocWaitInterval: 1000 # retry wait duration when delete alloc forward data rate failed, in millisecond
    complexDeleteLimitEnable: false # whether complex delete check forward data by limiter
    maxCollectionNum: 65536
    maxCollectionNumPerDB: 65536 # Maximum number of collections per database.
    maxInsertSize: -1 # maximum size of a single insert request, in bytes, -1 means no limit
    maxResourceGroupNumOfQueryNode: 1024 # maximum number of resource groups of query nodes
    maxGroupSize: 10 # maximum size for one single group when doing search group by
  ddl:
    enabled: false # Whether DDL request throttling is enabled.
    # Maximum number of collection-related DDL requests per second.
    # Setting this item to 10 indicates that Milvus processes no more than 10 collection-related DDL requests per second, including collection creation requests, collection drop requests, collection load requests, and collection release requests.
    # To use this setting, set quotaAndLimits.ddl.enabled to true at the same time.
    collectionRate: -1
    # Maximum number of partition-related DDL requests per second.
    # Setting this item to 10 indicates that Milvus processes no more than 10 partition-related requests per second, including partition creation requests, partition drop requests, partition load requests, and partition release requests.
    # To use this setting, set quotaAndLimits.ddl.enabled to true at the same time.
    partitionRate: -1
    db:
      collectionRate: -1 # qps of db level , default no limit, rate for CreateCollection, DropCollection, LoadCollection, ReleaseCollection
      partitionRate: -1 # qps of db level, default no limit, rate for CreatePartition, DropPartition, LoadPartition, ReleasePartition
  indexRate:
    enabled: false # Whether index-related request throttling is enabled.
    # Maximum number of index-related requests per second.
    # Setting this item to 10 indicates that Milvus processes no more than 10 partition-related requests per second, including index creation requests and index drop requests.
    # To use this setting, set quotaAndLimits.indexRate.enabled to true at the same time.
    max: -1
    db:
      max: -1 # qps of db level, default no limit, rate for CreateIndex, DropIndex
  flushRate:
    enabled: true # Whether flush request throttling is enabled.
    # Maximum number of flush requests per second.
    # Setting this item to 10 indicates that Milvus processes no more than 10 flush requests per second.
    # To use this setting, set quotaAndLimits.flushRate.enabled to true at the same time.
    max: -1
    collection:
      max: 0.1 # qps, default no limit, rate for flush at collection level.
    db:
      max: -1 # qps of db level, default no limit, rate for flush
  compactionRate:
    enabled: false # Whether manual compaction request throttling is enabled.
    # Maximum number of manual-compaction requests per second.
    # Setting this item to 10 indicates that Milvus processes no more than 10 manual-compaction requests per second.
    # To use this setting, set quotaAndLimits.compaction.enabled to true at the same time.
    max: -1
    db:
      max: -1 # qps of db level, default no limit, rate for manualCompaction
  dml:
    enabled: false # Whether DML request throttling is enabled.
    insertRate:
      # Highest data insertion rate per second.
      # Setting this item to 5 indicates that Milvus only allows data insertion at the rate of 5 MB/s.
      # To use this setting, set quotaAndLimits.dml.enabled to true at the same time.
      max: -1
      db:
        max: -1 # MB/s, default no limit
      collection:
        # Highest data insertion rate per collection per second.
        # Setting this item to 5 indicates that Milvus only allows data insertion to any collection at the rate of 5 MB/s.
        # To use this setting, set quotaAndLimits.dml.enabled to true at the same time.
        max: -1
      partition:
        max: -1 # MB/s, default no limit
    upsertRate:
      max: -1 # MB/s, default no limit
      db:
        max: -1 # MB/s, default no limit
      collection:
        max: -1 # MB/s, default no limit
      partition:
        max: -1 # MB/s, default no limit
    deleteRate:
      # Highest data deletion rate per second.
      # Setting this item to 0.1 indicates that Milvus only allows data deletion at the rate of 0.1 MB/s.
      # To use this setting, set quotaAndLimits.dml.enabled to true at the same time.
      max: -1
      db:
        max: -1 # MB/s, default no limit
      collection:
        # Highest data deletion rate per second.
        # Setting this item to 0.1 indicates that Milvus only allows data deletion from any collection at the rate of 0.1 MB/s.
        # To use this setting, set quotaAndLimits.dml.enabled to true at the same time.
        max: -1
      partition:
        max: -1 # MB/s, default no limit
    bulkLoadRate:
      max: -1 # MB/s, default no limit, not support yet. TODO: limit bulkLoad rate
      db:
        max: -1 # MB/s, default no limit, not support yet. TODO: limit db bulkLoad rate
      collection:
        max: -1 # MB/s, default no limit, not support yet. TODO: limit collection bulkLoad rate
      partition:
        max: -1 # MB/s, default no limit, not support yet. TODO: limit partition bulkLoad rate
  dql:
    enabled: false # Whether DQL request throttling is enabled.
    searchRate:
      # Maximum number of vectors to search per second.
      # Setting this item to 100 indicates that Milvus only allows searching 100 vectors per second no matter whether these 100 vectors are all in one search or scattered across multiple searches.
      # To use this setting, set quotaAndLimits.dql.enabled to true at the same time.
      max: -1
      db:
        max: -1 # vps (vectors per second), default no limit
      collection:
        # Maximum number of vectors to search per collection per second.
        # Setting this item to 100 indicates that Milvus only allows searching 100 vectors per second per collection no matter whether these 100 vectors are all in one search or scattered across multiple searches.
        # To use this setting, set quotaAndLimits.dql.enabled to true at the same time.
        max: -1
      partition:
        max: -1 # vps (vectors per second), default no limit
    queryRate:
      # Maximum number of queries per second.
      # Setting this item to 100 indicates that Milvus only allows 100 queries per second.
      # To use this setting, set quotaAndLimits.dql.enabled to true at the same time.
      max: -1
      db:
        max: -1 # qps, default no limit
      collection:
        # Maximum number of queries per collection per second.
        # Setting this item to 100 indicates that Milvus only allows 100 queries per collection per second.
        # To use this setting, set quotaAndLimits.dql.enabled to true at the same time.
        max: -1
      partition:
        max: -1 # qps, default no limit
  limitWriting:
    # forceDeny false means dml requests are allowed (except for some
    # specific conditions, such as memory of nodes to water marker), true means always reject all dml requests.
    forceDeny: false
    ttProtection:
      enabled: false
      # maxTimeTickDelay indicates the backpressure for DML Operations.
      # DML rates would be reduced according to the ratio of time tick delay to maxTimeTickDelay,
      # if time tick delay is greater than maxTimeTickDelay, all DML requests would be rejected.
      # seconds
      maxTimeTickDelay: 300
    memProtection:
      # When memory usage > memoryHighWaterLevel, all dml requests would be rejected;
      # When memoryLowWaterLevel < memory usage < memoryHighWaterLevel, reduce the dml rate;
      # When memory usage < memoryLowWaterLevel, no action.
      enabled: true
      dataNodeMemoryLowWaterLevel: 0.85 # (0, 1], memoryLowWaterLevel in DataNodes
      dataNodeMemoryHighWaterLevel: 0.95 # (0, 1], memoryHighWaterLevel in DataNodes
      queryNodeMemoryLowWaterLevel: 0.85 # (0, 1], memoryLowWaterLevel in QueryNodes
      queryNodeMemoryHighWaterLevel: 0.95 # (0, 1], memoryHighWaterLevel in QueryNodes
    growingSegmentsSizeProtection:
      # No action will be taken if the growing segments size is less than the low watermark.
      # When the growing segments size exceeds the low watermark, the dml rate will be reduced,
      # but the rate will not be lower than minRateRatio * dmlRate.
      enabled: false
      minRateRatio: 0.5
      lowWaterLevel: 0.2
      highWaterLevel: 0.4
    diskProtection:
      enabled: true # When the total file size of object storage is greater than `diskQuota`, all dml requests would be rejected;
      diskQuota: -1 # MB, (0, +inf), default no limit
      diskQuotaPerDB: -1 # MB, (0, +inf), default no limit
      diskQuotaPerCollection: -1 # MB, (0, +inf), default no limit
      diskQuotaPerPartition: -1 # MB, (0, +inf), default no limit
    l0SegmentsRowCountProtection:
      enabled: false # switch to enable l0 segment row count quota
      lowWaterLevel: 30000000 # l0 segment row count quota, low water level
      highWaterLevel: 50000000 # l0 segment row count quota, high water level
    deleteBufferRowCountProtection:
      enabled: false # switch to enable delete buffer row count quota
      lowWaterLevel: 32768 # delete buffer row count quota, low water level
      highWaterLevel: 65536 # delete buffer row count quota, high water level
    deleteBufferSizeProtection:
      enabled: false # switch to enable delete buffer size quota
      lowWaterLevel: 134217728 # delete buffer size quota, low water level
      highWaterLevel: 268435456 # delete buffer size quota, high water level
  limitReading:
    # forceDeny false means dql requests are allowed (except for some
    # specific conditions, such as collection has been dropped), true means always reject all dql requests.
    forceDeny: false

trace:
  # trace exporter type, default is stdout,
  # optional values: ['noop','stdout', 'jaeger', 'otlp']
  exporter: noop
  # fraction of traceID based sampler,
  # optional values: [0, 1]
  # Fractions >= 1 will always sample. Fractions < 0 are treated as zero.
  sampleFraction: 0
  jaeger:
    url:  # when exporter is jaeger should set the jaeger's URL
  otlp:
    endpoint:  # example: "127.0.0.1:4317" for grpc, "127.0.0.1:4318" for http
    method:  # otlp export method, acceptable values: ["grpc", "http"],  using "grpc" by default
    secure: true
  initTimeoutSeconds: 10 # segcore initialization timeout in seconds, preventing otlp grpc hangs forever

#when using GPU indexing, Milvus will utilize a memory pool to avoid frequent memory allocation and deallocation.
#here, you can set the size of the memory occupied by the memory pool, with the unit being MB.
#note that there is a possibility of Milvus crashing when the actual memory demand exceeds the value set by maxMemSize.
#if initMemSize and MaxMemSize both set zero,
#milvus will automatically initialize half of the available GPU memory,
#maxMemSize will the whole available GPU memory.
gpu:
  initMemSize: 2048 # Gpu Memory Pool init size
  maxMemSize: 4096 # Gpu Memory Pool Max size

# Any configuration related to the streaming node server.
streamingNode:
  ip:  # TCP/IP address of streamingNode. If not specified, use the first unicastable address
  port: 22222 # TCP port of streamingNode
  grpc:
    serverMaxSendSize: 268435456 # The maximum size of each RPC request that the streamingNode can send, unit: byte
    serverMaxRecvSize: 268435456 # The maximum size of each RPC request that the streamingNode can receive, unit: byte
    clientMaxSendSize: 268435456 # The maximum size of each RPC request that the clients on streamingNode can send, unit: byte
    clientMaxRecvSize: 268435456 # The maximum size of each RPC request that the clients on streamingNode can receive, unit: byte

# Any configuration related to the streaming service.
streaming:
  walBalancer:
    # The interval of balance task trigger at background, 1 min by default.
    # It's ok to set it into duration string, such as 30s or 1m30s, see time.ParseDuration
    triggerInterval: 1m
    # The initial interval of balance task trigger backoff, 50 ms by default.
    # It's ok to set it into duration string, such as 30s or 1m30s, see time.ParseDuration
    backoffInitialInterval: 50ms
    backoffMultiplier: 2 # The multiplier of balance task trigger backoff, 2 by default
  txn:
    defaultKeepaliveTimeout: 10s # The default keepalive timeout for wal txn, 10s by default

# Any configuration related to the knowhere vector search engine
knowhere:
  enable: true # When enable this configuration, the index parameters defined following will be automatically populated as index parameters, without requiring user input.
  DISKANN:
    build:
      max_degree: 56 # Maximum degree of the Vamana graph
      pq_code_budget_gb_ratio: 0.125 # Size limit on the PQ code (compared with raw data)
      search_cache_budget_gb_ratio: 0.1 # Ratio of cached node numbers to raw data
      search_list_size: 100 # Size of the candidate list during building graph
    search:
      beam_width_ratio: 4 # Ratio between the maximum number of IO requests per search iteration and CPU number

```

`scripts/blserver/configs/minio-proxy.conf.bak`:

```bak
events {
    worker_connections 1024;
}

http {
    # Upstream configuration for MinIO S3 and Console
    upstream minio_s3 {
        least_conn;
        server minio:9001;
    }

    upstream minio_console {
        least_conn;
        server minio:9000;
    }

    # Main server block for HTTPS
    server {
        listen 7443 ssl;
        server_name minio.example.net;

        # SSL configuration
        ssl_certificate     /etc/nginx/certs/server.crt;
        ssl_certificate_key /etc/nginx/certs/server.key;
        ssl_protocols       TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;

        # General settings
        ignore_invalid_headers off;
        client_max_body_size 0;
        proxy_buffering off;
        proxy_request_buffering off;

        # Proxy requests to MinIO S3
        location / {
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            real_ip_header X-Real-IP;
            proxy_connect_timeout 300;

            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            chunked_transfer_encoding off;

            proxy_pass http://minio_s3;
        }

        # Proxy requests to MinIO Console
        location /minio/ {
            rewrite ^/minio/(.*) /$1 break;
            proxy_set_header Host $http_host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-NginX-Proxy true;

            real_ip_header X-Real-IP;
            proxy_connect_timeout 300;

            # WebSocket support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            chunked_transfer_encoding off;

            proxy_pass http://minio_console;
        }
    }

    # Redirect HTTP traffic to HTTPS
    server {
        listen 7080;
        server_name minio.example.net;

        return 301 https://$host:7443$request_uri;
    }
}

```

`scripts/blserver/configs/minio-proxy.crt.bak`:

```bak
-----BEGIN CERTIFICATE-----
MIIFCTCCAvGgAwIBAgIUSJ5l6dCl7/S/yAolwsRA/7UmUGowDQYJKoZIhvcNAQEL
BQAwFDESMBAGA1UEAwwJbG9jYWxob3N0MB4XDTI0MTIzMTE2NDEzNloXDTI1MTIz
MTE2NDEzNlowFDESMBAGA1UEAwwJbG9jYWxob3N0MIICIjANBgkqhkiG9w0BAQEF
AAOCAg8AMIICCgKCAgEA2Hj9PxDNZM2Fjcge0+QCj5GXhBH0HGo4njiqQbQV0k7o
pTx8mqcErEymuNdCWuZDiDrwLiXcgi/OVyGKJPGHjbbHPXhD1N1Eo1+dZx+W4qt8
wd9wrcGP9T6BQi4C7xxROmkzD9lrH4E/F9xi91NzMcSNQbAi/MhRCO/UT/IPKSUe
5Ri7Yye554knyQ3zXJVzX5ZDwZ45Y//hjM8szYztCjhXRkuWEri5tu0CeEkw8T/I
sZ9iUHHliVPmCyRlOMyCwBrHgHHGPOZcPEdSdSF+CctisPpezc/4jQFswyLZgak4
LztoaV2NMjp4CM1YR5RsGx/fg6+q/8YAy/5T1G0ULbKguIlXywUI5Yo3+7uf+Fnv
oUZw6GuPDP9wswsg3TNDdfQS8ipWRTr5CErKc8vajpLuj3UkOUyx5pIicvnuilM0
wjAHPIpxVuXAt4lnSysh4MLXiVm6Dils/i/yF/Daed14p/h21MnvXGGEIQgH8ZcM
TyMIZpdyCkJACaktXKP9qpe4jBjhPEiPHECXfbt2c8gwDWiQ/oDJ7Hq0FMSgQQ2L
r1RTgvr4FRBWqaZ0gewFKTomnRI2yStqy6zXCAM326ojTLsfqT0RokpqXVMkj80G
jNI8OBjguR1UAj4NMpK1KZG5IQy960dz4TkWHOXMX0d+kmnqenk4si3RixnUJAkC
AwEAAaNTMFEwHQYDVR0OBBYEFOgDgnCGu431UvzdY5SP3VtmbuLIMB8GA1UdIwQY
MBaAFOgDgnCGu431UvzdY5SP3VtmbuLIMA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZI
hvcNAQELBQADggIBAKSl9j8uVK2Lgwhv3mVqVQitKc/qp7b8QfjGYchv6vkM7Abm
/djx52Oul9rWnhC5C4jnI4S3WU8Hhc4WBB7kUSSY1DPVo36tcvuJ6EAHegWaES2j
XKbdSHNqYu5xS9RE2eg9zwlzdf4uSh/KYCcTfcF0QmNJccnQtlvKcJsnu6k9s4vQ
FtS2eQBdRgh519T6VSPqGtCtEnR8YUHFeWYV1Os17Z9RBOMSDfhqRD8bv9YGrUoO
340tCDYsi1t+TYmrbFX0DIZPkXCV5P+U0xC/Fl5aztiKw6x/URLqVsPMPbEZf+A0
dtSnExu2UJORxl8eQnR2G9v7E3kvyDeFS5eWCvmyOzOTI15qjwX2FfPoVwbL3RvY
HPBs2Fco4e6gw8DE5GOwCZCPHutYuR67ai0jQFHA4ESflI/0YJZ6r2ZRdMmWLfl9
MkZ2JqZO++bFb+IfoqyOznZNsxvzJmWnENR+aL6mb6a9i6hlcDwUFT7pVPWWaeCu
xTLi3N9i80gcxywVS1uZPJoDoh7b7Q8qSLT4jyf82Y+H2l4XtDglzWGHvB8pIumO
GAl3pcql9e2dpi0a/X3sZLnwj07r9I4qF6677IhQahguPnWwVyTlowRzIMu9kOoc
cbPcAWhHbJE4SXbavqoWL6Mw2T/It6nbeO3cbiCeB2Cv7ZObR31Ln4BvUIno
-----END CERTIFICATE-----

```

`scripts/blserver/configs/minio-proxy.key.bak`:

```bak
-----BEGIN PRIVATE KEY-----
MIIJQgIBADANBgkqhkiG9w0BAQEFAASCCSwwggkoAgEAAoICAQDYeP0/EM1kzYWN
yB7T5AKPkZeEEfQcajieOKpBtBXSTuilPHyapwSsTKa410Ja5kOIOvAuJdyCL85X
IYok8YeNtsc9eEPU3USjX51nH5biq3zB33CtwY/1PoFCLgLvHFE6aTMP2WsfgT8X
3GL3U3MxxI1BsCL8yFEI79RP8g8pJR7lGLtjJ7nniSfJDfNclXNflkPBnjlj/+GM
zyzNjO0KOFdGS5YSuLm27QJ4STDxP8ixn2JQceWJU+YLJGU4zILAGseAccY85lw8
R1J1IX4Jy2Kw+l7Nz/iNAWzDItmBqTgvO2hpXY0yOngIzVhHlGwbH9+Dr6r/xgDL
/lPUbRQtsqC4iVfLBQjlijf7u5/4We+hRnDoa48M/3CzCyDdM0N19BLyKlZFOvkI
Sspzy9qOku6PdSQ5TLHmkiJy+e6KUzTCMAc8inFW5cC3iWdLKyHgwteJWboOKWz+
L/IX8Np53Xin+HbUye9cYYQhCAfxlwxPIwhml3IKQkAJqS1co/2ql7iMGOE8SI8c
QJd9u3ZzyDANaJD+gMnserQUxKBBDYuvVFOC+vgVEFappnSB7AUpOiadEjbJK2rL
rNcIAzfbqiNMux+pPRGiSmpdUySPzQaM0jw4GOC5HVQCPg0ykrUpkbkhDL3rR3Ph
ORYc5cxfR36Saep6eTiyLdGLGdQkCQIDAQABAoICAAmFE50MBf5cf/a24e0vWjH6
ZQOKvxWnUbdallk2nF2P+RD4NqId/Xl+0veuxsUk2nwxnFmpMlf61nwUNmUuxodz
zfIM+Y2xT+kP5cYQ2HO+Nym3A/duO2Cdh7VzfM9La2KSWQulw/1iE5Ze667FCZw7
ELu+bWF4xUCLfIaqBmLotiG821POXdF6AYkI3yaXj3f5DaCEjvFQAdktjMK643tH
NEZcAVzwKQGrjWfhDyES7SZrlBkl0yJ9kTC1AGsVqlvcqaCjUESiHFUNzWlniEmR
u1S9ZAEw19VKpl/0BsT6HkWMeyhkE/ctJVV8w1i9hR4RwiSCS5a9PFB8Ti85v1D4
9KZ6Omxdehe+j/gIsc0Q2toLINYrowiRU7qcUZbgHpIxBo4e5fepGBzHl3i3czVz
KUN+RKaUfoinvJCN+ShrFNYyUHwiyvCxLjYxoMLKgVVgrmHAKbXBofbz4rLzhkZg
VcL9mtGimTXf+n+A3M9DO0cYsDgCW06Y6NcTA+Pfx7DCvK13dYGpxNjFNIxJM9rM
HzUf2nWsH4rQVD8ZTaxGmpn5ARvyyNDKyaUNzIkpgZzCc7Rdxa5XT59J5T5aTpAG
/fFA79BOvKaNhwcH386cRksWiN9prPxycBPpl4ppQ4SB/oIy1QeKqBsvdPaVPH/0
7TR3i3t+raxCgj6dNjzBAoIBAQDuhNUHDLRARezFjKhRi7T+2Gt4689lL0hAltJF
BA8nB8ed0QZfbs2Seq8VaKZ/to+kiwWmYzCyeUoQ3ZDooNNcX4xitwzjrhmUSnWa
7kLan5vORyTfJZgaI/764kbpcNAHYGL+qLIJRzyCMOIqtgLMcAtSlenicXCotWX+
lgt+emjK104HMp2EElv6yXYCsfaCNIRhArZlmgtJhXo1jp4Z+sABPQEKDB6NNbuw
+0Al5fNwcea0GyjGxK1FGwzBOETqjyYexEdWWdmscLTUJVng+BgJJGBcKmSe95cz
P04M4wqF7HKA16h1P1GesyQuqILUWWocQ+mYwsHOzXS0jlLBAoIBAQDoVoSfg4+q
gccoYHBvGenf6T30Qe6O/+YcbvZjFDR/giVUVkVUpnc4PbI/NUB5l2toPElw8Zx6
/Vd/ng7dT9spIO35k1dMJ/SYL1q3ZS0ya4TOkaoOjVFsRlBCwqptLFFH4Fkx6gFG
BDm/YdvOOcAn0No9Vr7frROrEUkt6JEeFxmR3LpJmUqu0EOEAiXmQTsL6fLVvZma
+UJGv+n+7coNs8TeY5O/n5+iQXbL10H4U79p+s9lSYybxF2I6wZSq+BgyOEEbgN9
FqS6TYCUJrovFQ1r6OpUiuJwqGXJW1JFL5hHHvh73mlPO7bS9wlaH6LPWgRL7E+Z
fK8UuderAEtJAoIBAG5Gg6dKvFuq+JktOvTYvsnEjYvOmoiRn7odAQJfqhHFiwjw
Bx5AQFMk3aXsSG5rnWXZ0LbozS723MOHbOPg11ex5VoOf6sUZ0ckVdNXrRkfCg4I
3oc8/mG3mr+rtlVfjw6aBarvm8CmatdWenp8xDZ45wM7xHKpOAkINSvLe2zyc1i0
yqKRSDozssr0Mdd1KB9y4HFpq6K14doQGDyCv54LTJJF/iEDEW0AFtLwluvusOqf
/qXumJ+tdt6obvE2bsZzgJBg9wp5aCZNxYz/59oXWiV/5/00rGjC1+kdr5xNrCPW
+emPy5bJu5bABE5+Il7DKEgBLhMumCRg4UBJPQECggEBANpOaQEk8fnpRUO4Eg0i
kTFWDGOVC92LryDqVlJUatugYwjyouReIclTl0dy9ukJEN/5PZyFOV4K64s67Yaf
gTMNAO4vtqgVJutUG24VADnO8xPRpLNVr7sH+mQwW0iHirv5nnWbBaVPVR9xiMIm
W1pOELHv7xtmmgN0E4mya6CVXe5DMzrycUz+3WGNTyUiB6QzJ3wUUd9e9BpcOzbR
IbhsQMAhWnOEPc+MqV3xHciCkGm5Q+RNDnRSNvzusJs/am4mcd/iqx5/BzsSlY0f
MnQI2Pqa+IuFkC0A3dssFopxpSi2fg6Nte/AERH7Eut+rFEeqMjZ+xUiJbRYxr+j
YBkCggEALZoM8AZe75oKQ/sgIRfpbEFOVS/dbMU9e5DfPfRaWgyRNqfOhcJsdiEc
CA0ifTnarsEDb/0VgUQh9lc8gkyR/xBHA4P+1vHTmYUD4gnvcZ/yxUPA2nm/Rl2S
P09R9Yv9+CSP3A8+UKRGI0ms2/t/bIWsQ7QLT5AuHc9zrVQariW3tog6XEHb/VLs
vJETlOVb5/dCAFcF/eMGiexlUbc4AYi24Hl00H8proZ9ngKbSbj8J42yM6+orja2
NVCtlvjtEg5XA/IICAkw/0abYRmCiVkjudMPU3fyI0r0xGRr1UUo7h6Oz4kLiCna
/CFsqi3O9p4OjusXe3lpJEJyQpJQgA==
-----END PRIVATE KEY-----

```

`scripts/blserver/docker-compose.yml`:

```yml
version: '3.5'

services:
  etcd:
    container_name: milvus-etcd
    image: quay.io/coreos/etcd:v3.5.14
    environment:
      - ETCD_AUTO_COMPACTION_MODE=revision
      - ETCD_AUTO_COMPACTION_RETENTION=1000
      - ETCD_QUOTA_BACKEND_BYTES=4294967296
      - ETCD_SNAPSHOT_COUNT=50000
    volumes:
      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/etcd:/etcd
    command: etcd -advertise-client-urls=http://127.0.0.1:2379 -listen-client-urls http://0.0.0.0:2379 --data-dir /etcd
    healthcheck:
      test: ["CMD", "etcdctl", "endpoint", "health"]
      interval: 30s
      timeout: 20s
      retries: 3
    networks:
      - default

  minio:
    container_name: milvus-minio
    image: minio/minio:RELEASE.2023-03-20T20-16-18Z
    environment:
      MINIO_ACCESS_KEY: minioadmin
      MINIO_SECRET_KEY: minioadmin
    volumes:
      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/minio:/minio_data
    command: minio server /minio_data --console-address ":9001"
    # In production Comment this Out!
    ports:
      - "9001:9001"
      - "9000:9000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
    networks:
      - default

  minio-proxy:
    container_name: minio-proxy
    image: nginx:latest
    depends_on:
      - minio
    ports:
      - "7080:7080"
      - "7443:7443"
    volumes:
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/minio-proxy.conf:/etc/nginx/nginx.conf:ro
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/minio-proxy.crt:/etc/nginx/certs/server.crt:ro
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/minio-proxy.key:/etc/nginx/certs/server.key:ro
    networks:
      - default

  milvus:
    container_name: milvus-standalone
    image: milvusdb/milvus:v2.5.1
    command: ["milvus", "run", "standalone"]
    security_opt:
    - seccomp:unconfined
    environment:
      ETCD_ENDPOINTS: etcd:2379
      MINIO_ADDRESS: minio:9000
    volumes:
      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/milvus:/var/lib/milvus
      - ${DOCKER_VOLUME_DIRECTORY:-.}/configs/milvus.yaml:/milvus/configs/milvus.yaml
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9091/healthz"]
      interval: 30s
      start_period: 90s
      timeout: 20s
      retries: 3
    # In production Comment this Out!
    ports:
      - "19530:19530"
      - "9091:9091"
    depends_on:
      - "etcd"
      - "minio"
    networks:
      - default

  attu:
    container_name: milvus-attu
    image: zilliz/attu:latest
    environment:
      MILVUS_URL: milvus:19530
    # In production Comment this Out!
    ports:
      - "3000:3000"
    depends_on:
      - "milvus"
    networks:
      - default

  attu-proxy:
    container_name: attu-proxy
    image: nginx:latest
    depends_on:
      - attu
    ports:
      - "8080:8080"
      - "8443:8443"
    volumes:
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/attu-proxy.conf:/etc/nginx/nginx.conf:ro
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/attu-proxy.crt:/etc/nginx/certs/server.crt:ro
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/attu-proxy.key:/etc/nginx/certs/server.key:ro
    networks:
      - default

  blserver:
    container_name: blserver
    build:
      context: .
      dockerfile: Dockerfile
    environment:
      CONFIG: /app/config.toml
    volumes:
      - ${DOCKER_VOLUME_DIRECTORY:-.}/configs/blserver.toml:/app/config.toml
    command: >
          bash -c "while true; do sleep 5; gunicorn -w 4 -b 0.0.0.0:5000 'blserver:create_app(config=\"/app/config.toml\")'; done"
    # In production Comment this Out!
    ports:
      - "5000:5000"
    depends_on:
      - "milvus"
      - "minio"
    networks:
      - default

  blserver-proxy:
    container_name: blserver-proxy
    image: nginx:latest
    depends_on:
      - blserver
    ports:
      - "80:80"
      - "443:443"
    volumes:
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/blserver-proxy.conf:/etc/nginx/nginx.conf:ro
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/blserver-proxy.crt:/etc/nginx/certs/server.crt:ro
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/blserver-proxy.key:/etc/nginx/certs/server.key:ro
    networks:
      - default

  jupyterhub:
    image: jupyterhub/jupyterhub:latest
    container_name: jupyterhub
    volumes:
      - ${DOCKER_VOLUME_DIRECTORY:-.}/volumes/jupyterhub/:/srv/jupyterhub/
      - ${DOCKER_VOLUME_DIRECTORY:-.}/configs/jupyterhub.py:/srv/jupyterhub/jupyterhub.py:ro
    # In production Comment this Out!
    ports:
      - "8000:8000"
    entrypoint: >
      /bin/bash -c "
      if [ ! -f /srv/jupyterhub/setup_done ]; then
        pip install jupyterlab &&
        if ! id admin >/dev/null 2>&1; then
          useradd -m -s /bin/bash admin &&
          echo 'admin:admin' | chpasswd;
        fi &&
        mkdir -p /srv/jupyterhub/notebooks/ &&
        chown root:root /srv/jupyterhub/notebooks/ &&
        chmod 777 -R /srv/jupyterhub/notebooks/ &&
        touch /srv/jupyterhub/setup_done;
      fi &&
      jupyterhub --config /srv/jupyterhub/jupyterhub.py"
    restart: always
    networks:
      - default

  jupyterhub-proxy:
    container_name: jupyterhub-proxy
    image: nginx:latest
    depends_on:
      - jupyterhub
    ports:
      - "6080:6080"
      - "6443:6443"
    volumes:
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/jupyterhub-proxy.conf:/etc/nginx/nginx.conf:ro
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/jupyterhub-proxy.crt:/etc/nginx/certs/server.crt:ro
      -  ${DOCKER_VOLUME_DIRECTORY:-.}/configs/jupyterhub-proxy.key:/etc/nginx/certs/server.key:ro
    networks:
      - default

networks:
  default:
    name: binlex

```

`scripts/blserver/libblserver/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from libblserver.gnn import BinlexGNN
from libblserver.gnn import BinlexVectorEmbedding
from libblserver.minio import BinlexMinio
from libblserver.milvus import BinlexMilvus

```

`scripts/blserver/libblserver/gnn.py`:

```py
#!/usr/bin/env python
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import torch
import random
import numpy as np
import pandas as pd
from torch import Tensor
from torch import float32
from torch import float as torch_float
from torch import long as torch_long
from torch import tensor
from torch import manual_seed
from torch import zeros
from torch import cat
from torch import stack
from torch.nn import functional
from torch.nn import Module, BatchNorm1d, Dropout
from torch_geometric.data import Data
from torch_geometric.nn import GCNConv, global_mean_pool
from dataclasses import dataclass
from torch_pca import PCA


@dataclass
class BinlexVectorEmbedding:
    vector: list[float]
    data: dict

    def to_pandas(self) -> pd.DataFrame:
        return pd.DataFrame(
            {
                'vector': [self.vector],
                'data': [self.data],
            }
        )

    def to_dict(self) -> dict:
        return {
            'vector': self.vector,
            'data': self.data,
        }


class BinlexInnerGNN(Module):
    def __init__(self, node_features_dim: int, hidden_dim: int, output_dim: int):
        super().__init__()
        self.conv1 = GCNConv(
            in_channels=node_features_dim,
            out_channels=hidden_dim
        )
        self.bn1 = BatchNorm1d(hidden_dim)
        self.dropout = Dropout(p=0.3)
        self.conv2 = GCNConv(hidden_dim, output_dim)
        self.bn2 = BatchNorm1d(output_dim)

    def forward(self, x: Tensor, edge_index: Tensor) -> Tensor:
        x = self.conv1(x, edge_index)
        if x.size(0) > 1:
            x = self.bn1(x)
        x = x.relu()
        x = self.dropout(x)
        x = self.conv2(x, edge_index)
        if x.size(0) > 1:
            x = self.bn2(x)
        return x


class BinlexGNN:
    def __init__(
        self,
        data: dict,
        seed: int = 0,
        block_pca_dim: int = 16,
        gnn_hidden_dim: int = 32,
        gnn_output_dim: int = 16,
    ):

        random.seed(seed)
        np.random.seed(seed)
        manual_seed(seed)

        self.data = data
        self.block_pca_dim = block_pca_dim
        self.gnn_hidden_dim = gnn_hidden_dim
        self.gnn_output_dim = gnn_output_dim

        self.model = None
        self.criterion = torch.nn.MSELoss()
        self.optimizer = None

        self._last_graph_data = None
        self._last_data_dict = None

    @staticmethod
    def nibbles_to_histogram_vector(nibbles: list[int]) -> list[float]:
        """
        Convert a list of nibbles (0-15) into a histogram vector.
        Each nibble count is appended as [nibble_value, ratio_of_total].
        """
        histogram = [0] * 16
        for nibble in nibbles:
            if 0 <= nibble <= 15:
                histogram[nibble] += 1
        total_count = sum(histogram)
        encoded_histogram = []
        for nibble, count in enumerate(histogram):
            ratio = count / total_count if total_count > 0 else 0.0
            encoded_histogram.extend([float(nibble), ratio])
        return encoded_histogram

    @staticmethod
    def to_nx3_array(values: list[float]) -> np.ndarray:
        """
        Reshape the list of floats into an Nx3 array (padding if necessary).
        """
        arr = np.array(values, dtype=float)
        if arr.size == 0:
            return arr.reshape(-1, 3)
        padding = (3 - (len(arr) % 3)) % 3
        if padding > 0:
            arr = np.pad(arr, (0, padding), constant_values=0.0)
        return arr.reshape(-1, 3)

    @staticmethod
    def pca_reduce(values: np.ndarray, output_dim: int) -> np.ndarray:
        """
        Apply PCA to reduce Nx3 values to a single vector of size output_dim,
        then average across principal components to get a 1D vector.
        """
        if values.size == 0:
            return np.zeros(output_dim)
        values_torch = tensor(values, dtype=float32)
        n_rows, n_features = values_torch.shape
        n_components = min(output_dim, n_features)
        try:
            pca = PCA(n_components=n_components)
            principal_components = pca.fit_transform(values_torch)
            # Average across principal components to get a 1D vector
            values = principal_components.mean(dim=0).detach().numpy()
            # If n_components < output_dim, pad with zeros
            if n_components < output_dim:
                padding = np.zeros(output_dim - n_components)
                values = np.concatenate([values, padding])
        except Exception as e:
            print(f"PCA Reduction Error: {e}")
            values = np.zeros(output_dim)
        return values

    def _extract_block_features(self, block: dict) -> list:
        """
        Extract and assemble features from a single block.
        """
        features = [
            len(block['functions']) / block['number_of_instructions'],
            block['entropy'],
            block['number_of_instructions'],
            block['conditional'],
            block['edges'],
            len(block['functions']),
        ]
        chromosome_feature_histogram = self.nibbles_to_histogram_vector(
            block['chromosome']['feature']
        )
        features.extend(chromosome_feature_histogram)
        return features

    def _extract_function_features(
        self,
        function: dict
    ) -> tuple[list[int], list[int], list[list[float]]]:
        """
        Build zero-based adjacency (a, b) and the node feature list for a function graph.
        Rather than storing addresses directly, we re-index each block by its order
        so the GNN does not see actual addresses.

        Returns:
        - a: list of source indices for edges
        - b: list of target indices for edges
        - features: list of feature vectors, indexed consistently with (a, b)
        """

        # First, map each block's address to a zero-based index
        address_to_index = {}
        for i, block in enumerate(function['blocks']):
            address_to_index[block['address']] = i

        # Build up features and adjacency (in zero-based indices)
        features = []
        a, b = [], []

        for block in function['blocks']:
            # Extract the block-level features
            block_features = self._extract_block_features(block)

            # Append some function-level info
            block_features.append(function['average_instructions_per_block'])
            block_features.append(function['cyclomatic_complexity'])

            # PCA reduce
            feature_nx3 = self.to_nx3_array(block_features)
            feature_reduced = self.pca_reduce(feature_nx3, output_dim=self.block_pca_dim)
            features.append(feature_reduced.tolist())

            # Build adjacency using the re-mapped indices
            src_idx = address_to_index[block['address']]
            for child_address in block['blocks']:
                dst_idx = address_to_index[child_address]
                a.append(src_idx)
                b.append(dst_idx)

        return a, b, features

    def _build_graph(
        self,
        a: list[int],
        b: list[int],
        features: list[list[float]]
    ) -> Data:
        """
        Given zero-based adjacency (a, b) and features, build a torch_geometric Data object.

        We no longer make edges bidirectional by default, and we do not clamp
        (since 'a' and 'b' are already guaranteed to be within valid range by design).

        We still remove duplicate edges if any exist.
        """
        node_features = tensor(features, dtype=torch_float)
        edge_index = tensor([a, b], dtype=torch_long)

        # Remove duplicates (optional, but often helpful)
        edge_index = edge_index.unique(dim=1)

        return Data(x=node_features, edge_index=edge_index)

    def _initialize_model(self, input_dim: int):
        """
        Initialize the GNN model and optimizer based on input dimensions.
        """
        self.model = BinlexInnerGNN(
            node_features_dim=input_dim,
            hidden_dim=self.gnn_hidden_dim,
            output_dim=self.gnn_output_dim,
        )
        self.optimizer = torch.optim.Adam(self.model.parameters(), lr=1e-3)

    def _gnn_embedding(self, data: Data) -> Tensor:
        """
        Forward pass through the stored model to get node embeddings.
        Returns a Tensor for further processing (e.g., loss computation).
        """
        if self.model is None:
            input_dim = data.x.shape[1]
            self._initialize_model(input_dim)

        return self.model(data.x, data.edge_index)

    def train(
        self,
        epochs: int = 10
    ):
        """
        Train the GNN on the data passed into the constructor (either a single function or a block)
        using node-level MSE loss. The target is to reconstruct the original node features.

        Parameters:
        - epochs: Number of training epochs
        """
        if 'type' not in self.data:
            raise ValueError("Data must include a 'type' field, either 'function' or 'block'.")

        if self.data['type'] == 'function':
            # Extract graph data for function
            a, b, features = self._extract_function_features(self.data)
            graph_data = self._build_graph(a, b, features)
        elif self.data['type'] == 'block':
            # Extract block features
            block_features = self._extract_block_features(self.data)
            block_features_nx3 = self.to_nx3_array(block_features)
            block_features_reduced = self.pca_reduce(
                block_features_nx3,
                output_dim=self.block_pca_dim
            )

            # Only one node => trivial graph
            features = [block_features_reduced.tolist()]
            a, b = [], []
            graph_data = self._build_graph(a, b, features)
        else:
            raise ValueError(f"Unsupported data type: {self.data['type']}")

        # Store for inference/embedding
        self._last_graph_data = graph_data
        self._last_data_dict = self.data

        # Initialize the model if not already
        if self.model is None:
            input_dim = graph_data.x.shape[1]
            self._initialize_model(input_dim)
        else:
            # If model exists, ensure input dimensions match
            if self.model.conv1.in_channels != graph_data.x.shape[1]:
                raise ValueError(
                    f"Model expects input dimension {self.model.conv1.in_channels}, "
                    f"but got {graph_data.x.shape[1]}."
                )

        self.model.train()

        for epoch in range(epochs):
            self.optimizer.zero_grad()
            node_embeddings = self.model(graph_data.x, graph_data.edge_index)
            loss = self.criterion(node_embeddings, graph_data.x)
            loss.backward()
            self.optimizer.step()

        self.model.eval()

    def to_embedding(self) -> BinlexVectorEmbedding | None:
        """
        After training on the data in the constructor, produce a graph-level embedding
        for that data. Returns a BinlexVectorEmbedding with the normalized embedding vector,
        or None if no training has occurred yet.
        """
        if self._last_graph_data is None or self._last_data_dict is None:
            return None

        node_embeddings = self._gnn_embedding(self._last_graph_data)

        # Global mean pool over all nodes to get a single embedding
        graph_embedding = global_mean_pool(
            node_embeddings,
            batch=zeros(node_embeddings.size(0), dtype=torch_long),
        )
        # L2 normalize
        norm_embedding = functional.normalize(graph_embedding, p=2, dim=1)

        return BinlexVectorEmbedding(
            vector=norm_embedding.squeeze().tolist(),
            data=self._last_data_dict,
        )

```

`scripts/blserver/libblserver/milvus.py`:

```py
#!/usr/bin/env python
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import re
import time
import json
import hashlib
import uuid
import struct
from typing import List, Optional, Dict, Any, Union
import sys
from copy import deepcopy

from pymilvus import (
    connections,
    FieldSchema,
    CollectionSchema,
    DataType,
    Collection,
    has_collection,
    utility,
    db,
)
from pymilvus.exceptions import MilvusException


class BinlexMilvus:
    """
    A class to manage vector embeddings in Milvus,
    integrated with MinIO for data storage.
    """

    def __init__(self, config: Dict[str, Any], database: Optional[str] = None):
        """
        Initialize the BinlexMilvus instance.

        Parameters:
            config (Dict[str, Any]): Configuration dictionary containing Milvus and MinIO settings.
            database (Optional[str]): Name of the Milvus database to connect to.
                Defaults to config['milvus']['database'].
        """
        self.config = config
        self.database = database or self.config['milvus']['database']
        self.connect(database=self.database)
        self._validate_config()
        self._init_collections()

    def list_databases(self) -> list:
        return db.list_database()

    def get_collection_names(self, database: str) -> list[str]:
        self.connect(database=database)
        collection_names = utility.list_collections()
        return collection_names

    def get_partition_names(self, database: str, collection_name: str) -> list:
        self.connect(database=database)
        collection = Collection(name=collection_name)
        partitions = collection.partitions
        return [partition.name for partition in partitions]

    def _validate_config(self):
        required_milvus_keys = [
            'database',
            'host',
            'port',
            'authentication',
            'databases',
            'partitions'
        ]
        missing_keys = [
            key for key in required_milvus_keys
            if key not in self.config.get('milvus', {})
        ]
        if missing_keys:
            raise KeyError(f"Missing Milvus configuration keys: {', '.join(missing_keys)}")

        required_auth_keys = ['username', 'password']
        missing_auth_keys = [
            key for key in required_auth_keys
            if key not in self.config['milvus']['authentication']
        ]
        if missing_auth_keys:
            raise KeyError(f"Missing Milvus authentication keys: {', '.join(missing_auth_keys)}")

        for bucket_key in {'object_bucket', 'attributes_bucket'}:
            if bucket_key not in self.config.get('minio', {}):
                raise KeyError(f"Missing MinIO configuration key: {bucket_key}")

    def connect(self, database: Optional[str] = None):
        """
        Establish a connection to the Milvus server.

        Parameters:
            database (Optional[str]): Name of the database to connect to.
                Defaults to the instance's database.
        """
        database = database or self.database

        try:
            connections.connect(
                alias='default',
                db_name=database,
                host=self.config['milvus']['host'],
                port=str(self.config['milvus']['port']),
                token=(
                    f"{self.config['milvus']['authentication']['username']}:"
                    f"{self.config['milvus']['authentication']['password']}"
                ),
            )

            for db_name in self.config['milvus']['databases']:
                if db_name not in db.list_database():
                    db.create_database(db_name)
        except MilvusException as e:
            raise RuntimeError(f"Failed to connect to Milvus: {e}")

    def _init_collections(self):
        """
        Ensure that all databases have the required collections initialized.
        """
        primary_schema = self._create_primary_schema()

        for db_name in self.config['milvus']['databases']:
            self.connect(database=db_name)
            existing_collections = set(self.get_collection_names(db_name))

            for collection_name in self.config['milvus']['collections']:
                if collection_name not in existing_collections:
                    self._create_or_load_collection(collection_name, primary_schema)

    def _create_primary_schema(self) -> CollectionSchema:
        """
        Create the schema for the primary collections.

        Returns:
            CollectionSchema: The schema for the primary collections.
        """
        fields = [
            FieldSchema(name='id', dtype=DataType.VARCHAR, max_length=36, is_primary=True),
            FieldSchema(name='name', dtype=DataType.VARCHAR, max_length=65535),
            FieldSchema(name='timestamp', dtype=DataType.INT64),
            FieldSchema(name='username', dtype=DataType.VARCHAR, max_length=512),
            FieldSchema(name='object', dtype=DataType.VARCHAR, max_length=64),
            FieldSchema(name='object_stat', dtype=DataType.JSON),
            FieldSchema(name='address', dtype=DataType.INT64),
            FieldSchema(name='functions_called', dtype=DataType.JSON),
            FieldSchema(name='file_attributes', dtype=DataType.JSON),
            FieldSchema(name='extra_attributes', dtype=DataType.JSON),
            FieldSchema(
                name='vector',
                dtype=DataType.FLOAT_VECTOR,
                dim=self.config['blserver']['gnn']['output']
            ),
        ]
        return CollectionSchema(
            fields=fields,
            description='Primary collection schema'
        )

    def _create_or_load_collection(self, collection_name: str, schema: CollectionSchema) -> Collection:
        """
        Create a new collection with the given schema or load it if it already exists.

        Parameters:
            collection_name (str): Name of the collection.
            schema (CollectionSchema): Schema of the collection.

        Returns:
            Collection: The created or loaded collection.
        """
        if not has_collection(collection_name):
            collection = Collection(name=collection_name, schema=schema)
            self._create_indexes(collection)
            self._create_partitions(collection)
        else:
            collection = self.load_collection(collection_name)
        return collection

    def _create_indexes(self, collection: Collection):
        """
        Create indexes for the given collection.

        Parameters:
            collection (Collection): The Milvus collection.
        """
        index_params = {
            'index_type': 'IVF_PQ',
            'metric_type': 'COSINE',
            'params': {'nlist': 2048, 'm': 8, 'nbits': 8}
        }
        collection.create_index(field_name='vector', index_params=index_params)

    def _create_partitions(self, collection: Collection):
        """
        Create partitions within the given collection based on configuration.

        Parameters:
            collection (Collection): The Milvus collection.
        """
        for partition_name in self.config['milvus']['partitions']:
            if not collection.has_partition(partition_name):
                collection.create_partition(partition_name)

    def load_collection(self, collection_name: str) -> Collection:
        """
        Load an existing Milvus collection.

        Parameters:
            collection_name (str): Name of the collection to load.

        Returns:
            Collection: The loaded Milvus collection.
        """
        if not has_collection(collection_name):
            raise ValueError(f"Collection '{collection_name}' does not exist.")
        collection = Collection(name=collection_name)
        collection.load()
        return collection

    def _sha256_of_vector(self, float_list: List[float]) -> str:
        binary_data = b''.join(struct.pack('f', num) for num in float_list)
        hash_object = hashlib.sha256(binary_data)
        return hash_object.hexdigest()

    def _derive_uuid(self, strings: list) -> str:
        NAMESPACE_UUID = uuid.UUID('deadbeef-feed-face-feed-feedfacefeed')
        return str(uuid.uuid5(NAMESPACE_UUID, ''.join(strings)))

    def index_vector(
        self,
        minio_client,
        database: str,
        collection_name: str,
        partition_name: str,
        vector: List[float],
        data: Union[dict, bytes],
        username: str
    ) -> Optional[Dict[str, Any]]:
        """
        Insert a vector and its associated data into Milvus and MinIO.

        Parameters:
            minio_client: MinIO client instance.
            database (str): Name of the Milvus database.
            collection_name (str): Name of the Milvus collection.
            partition_name (str): Name of the partition in the collection.
            vector (List[float]): The vector to be inserted.
            data (Union[dict, bytes]): Related data to be stored in MinIO.
            username (str): Username responsible for the insert.

        Returns:
            Optional[Dict[str, Any]]: Inserted record(s) or None if failed.
        """

        if data['type'] not in ['function', 'block']:
            return None

        self.connect(database=database)

        _object = self._sha256_of_vector(vector)
        if not _object:
            return None

        sha256 = self._get_file_sha256(data)
        if sha256 is None:
            return None
        
        virtual_address = data["address"]
        
        names = self._get_symbol_names(data)

        primary_collection = self.load_collection(collection_name)

        existing_object = primary_collection.query(
            expr=f"object == '{_object}'",
            output_fields=["object"]
        )

        if not existing_object:
            minio_data = deepcopy(data)
            if minio_data["type"] == "block":
                if minio_data["next"]:
                    minio_data["next"] = minio_data["next"] - minio_data["address"]
                for set_adr in {"to", "blocks"}:
                    minio_data[set_adr] = [adr - minio_data["address"] for adr in minio_data[set_adr]]
            if minio_data['type'] == "function":
                for block in minio_data["blocks"]:
                    if block["next"]:
                        block["next"] = block["next"] - minio_data["address"]
                    for set_adr in {"to", "blocks"}:
                        block[set_adr] = [adr - minio_data["address"] for adr in block[set_adr]]
                    block["address"] = block["address"] - minio_data["address"]
                    for key in {"functions", "entropy", "sha256", "minhash", "tlsh"}:
                        block.pop(key, None)
                    if block["attributes"]:
                        for i, attribute in enumerate(block["attributes"]):
                            if attribute["type"] == "file":
                                del block["attributes"][i]
            
            minio_data["address"] = 0
            if minio_data["attributes"]:
                indexes_to_remove = [
                    i for i, attribute in enumerate(minio_data["attributes"]) 
                    if attribute["type"] in {"file", "symbol"}
                ]
                for i in reversed(indexes_to_remove):
                    del minio_data["attributes"][i]

            for key in ["functions", "entropy", "sha256", "minhash", "tlsh"]:
                minio_data.pop(key, None)
            
            self._upload_to_minio(
                minio_client=minio_client,
                bucket='object_bucket',
                data=minio_data,
                object_name=_object,
                content_type='application/json'
            )

        results = []
        
        if len(names) == 0:
            names.append('')

        for name in names:
            _uuid = self._derive_uuid([str(virtual_address), sha256, _object, name])

            existing_uuid = primary_collection.query(
                expr=f"id == '{_uuid}'",
                output_fields=["object"]
            )
            if existing_uuid:
                continue

            try:
                object_stat = {
                    "size": data['size'], 
                    "number_of_instructions": data['number_of_instructions'], 
                    "edges": data['edges'], 
                    "entropy": data['entropy']
                }
                if data['type'] == 'block':
                    extra_attributes = {attr: data[attr] for attr in {"entropy", "sha256", "minhash", "tlsh"} if attr in data}
                if data['type'] == 'function':
                    object_stat.update(
                        {
                            "number_of_blocks": len(data['blocks']),
                            "cyclomatic_complexity": data['cyclomatic_complexity'],
                            "average_instructions_per_block": data['average_instructions_per_block']
                        }
                    )
                    extra_attributes = {
                        "function": {attr: data[attr] for attr in {"entropy", "sha256", "minhash", "tlsh"} if attr in data},
                        "blocks": [
                            {
                                attr: block[attr] for attr in {"address", "functions", "entropy", "sha256", "minhash", "tlsh"} if attr in block
                            } for block in data['blocks']
                        ]
                    }
                
                extra_attributes_sha256 = hashlib.sha256(json.dumps(extra_attributes).encode('utf-8')).hexdigest()
                
                existing_attr_object = primary_collection.query(
                    expr=f"extra_attributes['minio'] == '{extra_attributes_sha256}'",
                    output_fields=["extra_attributes"]
                )
                
                if not existing_attr_object:
                    self._upload_to_minio(
                        minio_client=minio_client,
                        bucket='attributes_bucket',
                        data=extra_attributes,
                        object_name=extra_attributes_sha256,
                        content_type='application/json'
                )
                
                user_attributes = self._get_user_attributes(data)
                
                insert_data = {
                    "id": _uuid,
                    "name": name,
                    "timestamp": int(time.time()),
                    "username": username,
                    "object": _object,
                    "object_stat": object_stat,
                    "address": virtual_address,
                    "functions_called": data['functions'],
                    "file_attributes": self._get_file_attributes(data),
                    "extra_attributes": ({"minio": extra_attributes_sha256, **user_attributes}),
                    "vector": vector,
                }
                primary_collection.insert(insert_data, partition_name=partition_name)
                results.append(insert_data)
            except MilvusException as e:
                print(f"Failed to insert vector into collection '{collection_name}': {e}")
                return None

        return results

    def search_vector(
        self,
        minio_client,
        database: str,
        collection_name: str,
        partition_names: List[str],
        float_vector: List[float],
        query: str = None,
        threshold: float = 0.75,
        offset: int = 0,
        limit: int = 10
    ) -> List[dict]:
        """
        Search vectors in a specified collection by COSINE similarity.

        Parameters:
            minio_client: MinIO client instance.
            database (str): Database name.
            collection_name (str): Collection to search in.
            partition_names (List[str]): List of partition names to search within.
            float_vector (List[float]): Query vector for similarity search.
            query (str): Search query to filter restults further.
            similarity_threshold (float): Minimum COSINE similarity in [-1, 1].
            offset (int): Offset for pagination.
            limit (int): Maximum number of results to return.

        Returns:
            List[dict]: Search results with raw COSINE scores from Milvus.
                        Each dictionary contains:
                            - uuid: Unique identifier of the hit (the "id" field).
                            - similarity: The COSINE similarity score [-1, 1].
                            - vector: The retrieved vector.
                            - data: The associated data from MinIO.
        """
        # Validate input
        self._validate_search_vector_params(partition_names, offset, limit)

        # Connect and load the collection
        self.connect(database=database)
        collection = self.load_collection(collection_name)

        # Use COSINE in the search parameters
        search_params = {
            "metric_type": "COSINE",
            "params": {"nprobe": 10}
        }

        top_k = offset + limit

        # Perform the search directly
        search_results = collection.search(
            data=[float_vector],
            anns_field="vector",
            param=search_params,
            limit=top_k,
            expr=query,
            output_fields=[
                "id",
                "name",
                "timestamp",
                "username",
                "object",
                "object_stat",
                "address",
                "functions_called",
                "file_attributes",
                "extra_attributes",
                "vector"
            ],
            partition_names=partition_names
        )

        # Handle empty or invalid results
        if not search_results or not search_results[0]:
            return []

        raw_hits = list(search_results[0])  # or .hits, depending on the PyMilvus version

        hits_above_threshold = [hit for hit in raw_hits if hit.score >= threshold]
        hits_slice = hits_above_threshold[offset:offset + limit]

        results = []
        for hit in hits_slice:
            entity = hit.entity
            id_val = entity.get('id')
            object_name = entity.get('object')

            score = hit.score

            if score > 1.0: score = 1.0

            if not id_val or not object_name:
                continue
            
            data = self._retrieve_data_from_minio(minio_client, 'object_bucket', object_name)
            if data is None:
                continue
            
            self._restore_extra_attributes(minio_client, data, entity)

            results.append({
                "id": id_val,
                "score": score,
                "vector": entity.get('vector'),
                "name": entity.get('name'),
                "username": entity.get('username'),
                "timestamp": entity.get('timestamp'),
                "file_attributes": entity.get('file_attributes'),
                "data": data
            })

        return results

    def query(
        self,
        minio_client,
        database: str,
        collection_name: str,
        partition_names: List[str],
        query: str,
        offset: int = 0,
        limit: int = 10,
    ) -> List[dict]:
        """
        Search database using the specified query.

        Parameters:
            minio_client: MinIO client instance.
            database (str): Database name.
            collection_name (str): Collection to search in.
            partition_names (List[str]): List of partition names to search within.
            query (str): Search query.
            offset (int): Offset for pagination.
            limit (int): Maximum number of results to return.

        Returns:
            List[dict]: Search results for the query.
                        Each dictionary contains:
                            - uuid: Unique identifier of the hit (the "id" field).
                            - vector: The retrieved vector.
                            - data: The associated data from MinIO.
        """
        self.connect(database=database)
        collection = self.load_collection(collection_name)
        

        search_results = collection.query(
            expr=query,
            offset=offset,
            limit=limit,
            output_fields=[
                "id",
                "name",
                "timestamp",
                "username",
                "object",
                "object_stat",
                "address",
                "functions_called",
                "file_attributes",
                "extra_attributes",
                "vector"
            ],
            partition_names=partition_names
        )
        
        if not search_results or not search_results[0]:
            return []
        
        results = []
        for search_result in search_results:
            id_val = search_result.get('id')
            object_name = search_result.get('object')
            
            if not id_val or not object_name:
                continue
            
            data = self._retrieve_data_from_minio(minio_client, 'object_bucket', object_name)
            if data is None:
                continue
            
            self._restore_extra_attributes(minio_client, data, search_result)
            
            results.append({
                "id": id_val,
                "vector": list(map(float, search_result.get('vector'))),
                "name": search_result.get('name'),
                "username": search_result.get('username'),
                "timestamp": search_result.get('timestamp'),
                "file_attributes": search_result.get('file_attributes'),
                "data": data
            })
        
        return results


    def _validate_search_vector_params(self, partition_names: List[str], offset: int, limit: int):
        """
        Validate parameters for the search_vector method.

        Raises:
            ValueError: If parameters do not meet the required criteria.
        """
        if not isinstance(partition_names, list):
            raise ValueError("'partition_names' must be a list of strings.")
        if not all(isinstance(p, str) for p in partition_names):
            raise ValueError("All elements in 'partition_names' must be strings.")

        if offset + limit > 128:
            raise ValueError(
                f"In a single search, offset + limit must be <= 128. "
                f"Got offset={offset}, limit={limit}, sum={offset + limit}."
            )

    def _retrieve_data_from_minio(self, minio_client, bucket: str, object_name: str) -> Optional[Dict[str, Any]]:
        """
        Retrieve and parse data from MinIO.

        Parameters:
            minio_client: MinIO client instance.
            bucket (str): Bucket from MinIO which contains the requested object.
            object_name (str): Name of the object to retrieve.

        Returns:
            Optional[Dict[str, Any]]: Parsed JSON data or None if retrieval failed.
        """
        try:
            object_bytes = minio_client.download(
                bucket_name=self.config["minio"][bucket],
                object_name=object_name
            )
            return json.loads(object_bytes.decode("utf-8"))
        except Exception as e:
            print(f"Failed to retrieve or decode object '{object_name}': {e}")
            return None

    def _get_data_sha256(self, data: Union[dict, bytes]) -> Optional[str]:
        """
        Compute the SHA-256 hash of data (bytes or dict).

        Parameters:
            data (Union[dict, bytes]): Data to hash.

        Returns:
            Optional[str]: The SHA-256 hex digest or None if data is invalid.
        """
        if isinstance(data, bytes):
            return hashlib.sha256(data).hexdigest()
        elif isinstance(data, dict):
            return hashlib.sha256(json.dumps(data).encode()).hexdigest()
        return None

    def _upload_to_minio(self, minio_client, bucket: str, data: Union[dict, bytes], object_name: str, content_type: str) -> Optional[str]:
        """
        Upload data to MinIO and return the object name.

        Parameters:
            minio_client: MinIO client instance.
            bucket (str): MinIO bucket to which the object is uploaded.
            data (Union[dict, bytes]): Data to be uploaded.

        Returns:
            Optional[str]: The name of the uploaded object or None if upload failed.
        """
        try:
            object_name = minio_client.upload(
                bucket_name=self.config['minio'][bucket], 
                data=data, 
                object_name=object_name, 
                content_type=content_type
            )
            return object_name
        except Exception as e:
            print(f"Failed to upload data to MinIO: {e}")
            return None

    def _get_symbol_names(self, data: dict) -> list:
        """
        Extract all symbol names from 'attributes' in the provided dict.

        Parameters:
            data (dict): The data containing attributes.

        Returns:
            list: A list of extracted symbol names.
        """
        names = []
        for attribute in data.get('attributes', []):
            if attribute.get('type') == 'symbol' and attribute.get('name'):
                # Skip Default Rizin, Binja, IDA an Ghidra Function Names
                if re.match(r'^(fcn\.|fun_|sub_)[0-9a-f]+$', attribute['name'], re.IGNORECASE): continue
                names.append(attribute['name'])
        return names

    def _get_file_sha256(self, data: dict) -> Optional[str]:
        """
        Extract the file SHA256 from 'attributes' in the provided dict.

        Parameters:
            data (dict): The data containing attributes.

        Returns:
            Optional[str]: The SHA256 string if found, else None.
        """
        if 'attributes' not in data:
            return None
        for attribute in data['attributes']:
            if attribute.get('type') == 'file':
                if 'sha256' in attribute:
                    return attribute['sha256']
        return None
    
    def _restore_extra_attributes(self, minio_client, data: dict, entity: dict) -> None:
        """
        Restore extra attributes, functions called and addresses for returned Binlex JSON from MinIO.

        Parameters:
            data (dict): The dictionary from MinIO without extra attributes.
            entity (dict): The dictionary with data stored in Milvus database. 

        Returns:
            None: The function modifies data dictionary.
        """
        attributes = self._retrieve_data_from_minio(minio_client, 'attributes_bucket', entity.get('extra_attributes').get('minio'))
        if data['type'] == "function":
            # restoring function attributes
            extra_attributes = attributes.get('function', {})
            if extra_attributes:
                fcn_adr = entity.get('address')
                data.update(
                    {
                        "functions": entity.get('functions_called'),
                        "address": fcn_adr,
                        "entropy": extra_attributes.get('entropy', None),
                        "sha256": extra_attributes.get('sha256', None),
                        "minhash": extra_attributes.get('minhash', None),
                        "tlsh": extra_attributes.get('tlsh', None)
                    }
                )
            # restoring each block's attributes in the function
            extra_attributes = attributes.get('blocks', {})
            if extra_attributes:
                for i, block in enumerate(data['blocks']):
                    block.update(extra_attributes[i])
                    if block["next"]:
                        block["next"] = block["next"] + fcn_adr
                    for list_addr in ["to", "blocks"]:
                        block[list_addr] = [adr + fcn_adr for adr in block[list_addr]]
        elif data['type'] == "block":
            if attributes:
                bb_adr = entity.get('address')
                data.update(
                    {
                        "functions": entity.get('functions_called'),
                        "address": bb_adr,
                        "entropy": attributes.get('entropy', None),
                        "sha256": attributes.get('sha256', None),
                        "minhash": attributes.get('minhash', None),
                        "tlsh": attributes.get('tlsh', None)
                    }
                )
            if data["next"]:
                data["next"] = data["next"] + bb_adr
            for list_addr in ["to", "blocks"]:
                data[list_addr] = [adr + bb_adr for adr in data[list_addr]]
    
    @staticmethod
    def _get_file_attributes(data: dict) -> dict:
        """
        Extract the file entropy, sha256, size, tlsh from 'attributes' item in the provided dict.

        Parameters:
            data (dict): The data containing attributes.

        Returns:
            dict: The dictionary containing found file attributes that are not None, else {}.
        """
        if 'attributes' not in data:
            return {}
        file_attributes = {}
        file_attrs = {'entropy', 'sha256', 'size', 'tlsh', 'minhash'}
        for attribute in data['attributes']:
            if attribute.get('type') == 'file':
                file_attributes.update(
                    {
                        attr: attribute[attr] for attr in file_attrs if attr in attribute and attribute[attr]
                    }
                )
        return file_attributes
        
    @staticmethod
    def _get_user_attributes(data: dict) -> dict:
        """
        Extract all the user attributes from 'attributes' item in the provided dict. By default, user attributes are identified by the same type of the object (function/block).

        Parameters:
            data (dict): The data containing attributes.

        Returns:
            dict: The dictionary containing found user attributes, else {}.
        """
        if 'attributes' not in data:
            return {}
        for sub_attribute in data['attributes']:
            if sub_attribute.get('type') == data['type']:
                user_attributes = sub_attribute.copy()
                user_attributes.pop('type')
                return user_attributes
        return {}
```

`scripts/blserver/libblserver/minio.py`:

```py
#!/usr/bin/env python
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import json
import hashlib
from minio import Minio
from io import BytesIO

class BinlexMinio():
    def __init__(self, config: dict):
        self.client = Minio(
            f'{config["minio"]["host"]}:{config["minio"]["port"]}',
            config['minio']['keys']['access'],
            config['minio']['keys']['secret'],
            secure=config['minio']['secure'],
        )

    def create_bucket(self, bucket_name: str):
        if self.client.bucket_exists(bucket_name):
            return
        self.client.make_bucket(bucket_name)

    def upload(self, bucket_name: str, data: bytes | dict, object_name: str, content_type='application/octet-stream') -> str:
        if not isinstance(data, bytes) and not isinstance(data, dict):
            raise ValueError('data must be of type bytes or dict')

        if isinstance(data, dict):
            data = json.dumps(data).encode()

        self.create_bucket(bucket_name)

        self.client.put_object(
            bucket_name,
            object_name,
            BytesIO(data),
            length=len(data),
            content_type=content_type,
        )

        return object_name

    def download(self, bucket_name: str, object_name: str) -> bytes:
        response = self.client.get_object(bucket_name, object_name)
        try:
            return response.read()
        finally:
            response.close()
            response.release_conn()

    def delete(self, bucket_name: str, object_name: str):
        self.client.remove_object(bucket_name, object_name)

```

`scripts/blserver/requirements.txt`:

```txt
flask-restx==1.3.0
pymilvus==2.5.2
torch-geometric==2.6.1
torch==2.5.1
torch-pca==1.0.0
minio==7.2.13
gunicorn==23.0.0

```

`scripts/blserver/setup.py`:

```py
#!/usr/bin/env python
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import os
from glob import glob
try:
    from setuptools import setup, find_packages
except ImportError:
    from distutils.core import setup, find_packages

__author__  = '@c3rb3ru5d3d53c'
__version__ = '2.0.0'

setup(
    name='blserver',
    version=__version__,
    maintainer=__author__,
    description='A Binlex HTTP Server',
    install_requires=open('requirements.txt', 'r').read().splitlines(),
    scripts=['blserver.py'],
    packages=find_packages(),
    include_package_data=True,
    classifiers=[
        "Programming Language :: Python",
        "Operating System :: OS Independent",
    ],
)

```

`scripts/libblclient/libblclient/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from libblclient.client import BLClient


```

`scripts/libblclient/libblclient/client.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import json
import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class BLClient():
    def __init__(self, url: str, api_key: str, verify=False):
        self.url = url
        self.api_key = api_key
        self.verify = verify

    def databases(self):
        r = requests.get(
            url=f'{self.url}/embeddings/databases',
            headers={
                'API-Key': self.api_key
            },
            verify=self.verify,
        )
        return r.status_code, json.loads(r.content)

    def inference(self, data: dict):
        r = requests.post(
            url=f'{self.url}/embeddings/inference',
            headers={
                'API-Key': self.api_key
            },
            json=data,
            verify=self.verify,
        )
        return r.status_code, json.loads(r.content)

    def collections(self, database: str):
        r = requests.get(
            url=f'{self.url}/embeddings/{database}/collections',
            headers={
                'API-Key', self.api_key
            },
            verify=self.verify,
        )
        return r.status_code, json.loads(r.content)

    def partitions(self, database: str, collection: str):
        r = requests.get(
            url=f'{self.url}/embeddings/{database}/{collection}/partitions',
            headers={
                'API-Key': self.api_key
            },
            verify=self.verify,
        )
        return r.status_code, json.loads(r.content)

    def index(self, database: str, collection: str, partition: str, data: dict):
        r = requests.post(
            url=f'{self.url}/embeddings/{database}/{collection}/{partition}/index',
            headers={
                'API-Key': self.api_key
            },
            json=data,
            verify=self.verify,
        )
        return r.status_code, json.loads(r.content)

    def search(
        self,
        database: str,
        collection: str,
        partition: str,
        offset: int,
        limit: int,
        threshold: float,
        vector: list,
        query: str = None):
        r = requests.post(
            url=f'{self.url}/embeddings/{database}/{collection}/{partition}/search/{offset}/{limit}/{threshold}',
            headers={
                'API-Key': self.api_key
            },
            json={"vector": vector, "query": query},
            verify=self.verify,
        )
        return r.status_code, json.loads(r.json())
    
    def query(
            self,
            database: str,
            collection: str,
            partition: str,
            offset: int,
            limit: int,
            query: str):
            r = requests.post(
                url=f'{self.url}/embeddings/{database}/{collection}/{partition}/query/{offset}/{limit}',
                headers={
                    'API-Key': self.api_key
                },
                json=query,
                verify=self.verify,
            )
            return r.status_code, json.loads(r.json())

```

`scripts/libblclient/requirements.txt`:

```txt
requests==2.32.3

```

`scripts/libblclient/setup.py`:

```py
#!/usr/bin/env python
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import os
from glob import glob
try:
    from setuptools import setup, find_packages
except ImportError:
    from distutils.core import setup, find_packages

__author__  = '@c3rb3ru5d3d53c'
__version__ = '2.0.0'

setup(
    name='libblclient',
    version=__version__,
    maintainer=__author__,
    description='A Binlex HTTP Server Client Library',
    install_requires=open('requirements.txt', 'r').read().splitlines(),
    packages=find_packages(),
    include_package_data=True,
    classifiers=[
        "Programming Language :: Python",
        "Operating System :: OS Independent",
    ],
)

```

`scripts/plugins/ida/binlex/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


```

`scripts/plugins/ida/binlex/actions/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from .copy_hex import execute as copy_hex
from .copy_pattern import execute as copy_pattern
from .scan_minhash import execute as scan_minhash
from .scan_tlsh import execute as scan_tlsh
from .copy_minhash import execute as copy_minhash
from .copy_tlsh import execute as copy_tlsh
from .function_table import execute as function_table
from .search_database import execute as search_database
from .index_database import execute as index_database
from .export import execute as export
from .export_byte_colormap import execute as export_byte_colormap
from .copy_block_vector import execute as copy_block_vector
from .copy_block_json import execute as copy_block_json
from .copy_function_vector import execute as copy_function_vector
from .copy_function_json import execute as copy_function_json
from .index_function import execute as index_function
from .index_block import execute as index_block

```

`scripts/plugins/ida/binlex/actions/copy_block_json.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from lib import Worker
from lib import BLClient
from lib import IDA
from PyQt5.QtWidgets import QDialog
from binlex.controlflow import Function, Block
from gui import BinlexServerAuthenticationDialog
from PyQt5.QtWidgets import QApplication
import ida_kernwin
import json

def execute(parent):
    ea = IDA().get_screen_ea()
    bb = IDA().get_basic_block(ea)
    parent.disassemble_block(bb)
    block = Block(bb.start_ea, parent.cfg)
    data = block.to_dict()
    data['attributes'] = [IDA().file_attribute()]
    QApplication.clipboard().setText(json.dumps(data))
    ida_kernwin.msg(f'[*] block json at {hex(bb.start_ea)} copied to clipboard\n')

```

`scripts/plugins/ida/binlex/actions/copy_block_vector.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from lib import Worker
from lib import BLClient
from lib import IDA
from PyQt5.QtWidgets import QDialog
from binlex.controlflow import Function, Block
from gui import BinlexServerAuthenticationDialog
from PyQt5.QtWidgets import QApplication
import ida_kernwin

def execute(parent):
    dialog = BinlexServerAuthenticationDialog()
    if dialog.exec_() != QDialog.Accepted: return
    (
        url,
        api_key,
    ) = dialog.get_inputs()
    ea = IDA().get_screen_ea()
    bb = IDA().get_basic_block(ea)
    parent.disassemble_block(bb)
    block = Block(bb.start_ea, parent.cfg)
    client = BLClient(url=url, api_key=api_key)
    status, vector = client.inference(block.to_dict())
    if status != 200: return
    QApplication.clipboard().setText(str(vector))
    ida_kernwin.msg(f'[*] block vector at {hex(bb.start_ea)} copied to clipboard\n')

```

`scripts/plugins/ida/binlex/actions/copy_function_json.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from lib import IDA
from binlex.controlflow import Function
from PyQt5.QtWidgets import QApplication
import ida_kernwin
import json

def execute(parent):
    ea = IDA().get_screen_ea()
    bb = IDA().get_basic_block(ea)
    f = IDA().get_function(ea)
    parent.disassemble_function(f)
    function = Function(f.start_ea, parent.cfg)
    data = function.to_dict()
    data['attributes'] = IDA().get_function_attributes(f)
    QApplication.clipboard().setText(json.dumps(data))
    ida_kernwin.msg(f'[*] function json at {hex(f.start_ea)} copied to clipboard\n')

```

`scripts/plugins/ida/binlex/actions/copy_function_vector.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from lib import Worker
from lib import BLClient
from lib import IDA
from PyQt5.QtWidgets import QDialog
from binlex.controlflow import Function
from gui import BinlexServerAuthenticationDialog
from PyQt5.QtWidgets import QApplication
import ida_kernwin

def execute(parent):
    dialog = BinlexServerAuthenticationDialog()
    if dialog.exec_() != QDialog.Accepted: return
    (
        url,
        api_key,
    ) = dialog.get_inputs()
    ea = IDA().get_screen_ea()
    f = IDA().get_function(ea)
    parent.disassemble_function(f)
    function = Function(f.start_ea, parent.cfg)
    client = BLClient(url=url, api_key=api_key)
    status, vector = client.inference(function.to_dict())
    if status != 200: return
    QApplication.clipboard().setText(str(vector))
    ida_kernwin.msg(f'[*] function vector at {hex(f.start_ea)} copied to clipboard\n')

```

`scripts/plugins/ida/binlex/actions/copy_hex.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import ida_kernwin
import ida_bytes
from lib import IDA
from PyQt5.QtWidgets import QApplication

def execute(parent):
    start_ea, end_ea = IDA.get_disassembly_selection_range()
    pattern = ida_bytes.get_bytes(start_ea, end_ea - start_ea).hex()
    QApplication.clipboard().setText(pattern)
    ida_kernwin.msg('[*] hex copied to clipboard\n')

```

`scripts/plugins/ida/binlex/actions/copy_minhash.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import ida_bytes
from lib import IDA
from PyQt5.QtWidgets import QApplication
import ida_kernwin
from binlex.controlflow import Instruction
from binlex.hashing import MinHash32

def execute(parent):
    start_ea, end_ea = IDA.get_disassembly_selection_range()
    data = ida_bytes.get_bytes(start_ea, end_ea - start_ea)
    minhash = MinHash32(
        data,
        parent.config.instructions.hashing.minhash.number_of_hashes,
        parent.config.instructions.hashing.minhash.shingle_size,
        parent.config.instructions.hashing.minhash.seed).hexdigest()
    if minhash is None:
        ida_kernwin.msg('[x] not enough data or minhash failed\n')
        return
    QApplication.clipboard().setText(minhash)
    ida_kernwin.msg(f'[*] copied minhash to clipboard based on {len(data)} bytes\n')

```

`scripts/plugins/ida/binlex/actions/copy_pattern.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import ida_ua
from lib import IDA
from PyQt5.QtWidgets import QApplication
import ida_kernwin
from binlex.controlflow import Instruction

def execute(parent):
    start_ea, end_ea = IDA.get_disassembly_selection_range()
    pattern = ''
    pc = start_ea
    while pc < end_ea:
        insn = ida_ua.insn_t()
        ida_ua.decode_insn(insn, pc)
        parent.disassemble_instruction(insn)
        blinsn = Instruction(pc, parent.cfg)
        pattern += blinsn.chromosome().pattern()
        pc += insn.size
    QApplication.clipboard().setText(pattern)
    ida_kernwin.msg('[*] pattern copied to clipboard\n')

```

`scripts/plugins/ida/binlex/actions/copy_tlsh.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import ida_bytes
from lib import IDA
from PyQt5.QtWidgets import QApplication
import ida_kernwin
from binlex.hashing import TLSH

def execute(parent):
    start_ea, end_ea = IDA.get_disassembly_selection_range()
    data = ida_bytes.get_bytes(start_ea, end_ea - start_ea)
    tlsh = TLSH(data).hexdigest(50)
    if tlsh is None:
        ida_kernwin.msg('[x] not enough data or minhash failed\n')
        return
    QApplication.clipboard().setText(tlsh)
    ida_kernwin.msg(f'[*] copied tlsh to clipboard based on {len(data)} bytes\n')

```

`scripts/plugins/ida/binlex/actions/export.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import json
from lib import Worker
import ida_kernwin
from lib import IDA
from binlex.controlflow import Function

def process(file_path: str, cfg, function_addresses: list, function_attributes: dict, function_names: dict) -> str:
    print(f'[-] database exporting to {file_path}...')
    with open(file_path, 'w') as file:
        for address in function_addresses:
            function = Function(address, cfg)
            data = function.to_dict()
            data['attributes'] = function_attributes[address]
            file.write(json.dumps(data) + '\n')
    return file_path

def completed(file_path: str):
    print(f'[*] database exported to {file_path}')

def execute(parent):
    parent.disassemble_controlflow()
    file_path = ida_kernwin.ask_file(1, "*.json", 'Export Binlex Functions to JSON File')
    if not file_path: return
    function_names = IDA().get_function_names()
    function_attributes = parent.get_function_attributes()
    function_addresses = parent.cfg.queue_functions.valid_addresses()
    worker = Worker(
        target=process,
        args=(
            file_path,
            parent.cfg,
            function_addresses,
            function_attributes,
            function_names,
        ),
        done_callback=completed
    )
    worker.start()

```

`scripts/plugins/ida/binlex/actions/export_byte_colormap.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import ida_kernwin
import idc
import idautils
from lib import IDA
from binlex.imaging import ColorMap

def execute(parent):
    file_path = ida_kernwin.ask_file(1, "*.svg", 'Export Binlex Byte ColorMap')
    if not file_path: return
    print(f'[-] creating byte colormap...')
    colormap = ColorMap()
    segments = []
    for seg_ea in idautils.Segments():
        start = idc.get_segm_start(seg_ea)
        end = idc.get_segm_end(seg_ea)
        segments.append((start, end))
    segments.sort(key=lambda x: x[0], reverse=True)
    for start, end in segments:
        data = IDA.get_bytes(start, end - start)
        colormap.append(data, offset=start)
    colormap.write(file_path)
    print(f'[*] wrote byte colormap to {file_path}')

```

`scripts/plugins/ida/binlex/actions/function_table.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from lib import IDA
from gui import GradientTable
from lib import Worker

def process(function_names, functions: list):
    print(f'[-] collecting function data...')
    data = []
    for function in functions:
        chromosome = function.chromosome()
        row = [
            str(hex(function.address())),
            function_names[function.address()],
            'function',
            function.contiguous(),
            function.size(),
            function.number_of_blocks(),
            function.cyclomatic_complexity(),
            function.average_instructions_per_block(),
            function.chromosome_minhash_ratio() or '',
            chromosome.minhash() if chromosome else '',
            function.chromosome_tlsh_ratio() or '',
            chromosome.tlsh() if chromosome else '',
            chromosome.pattern() if chromosome else '',
        ]
        data.append(row)
    return data

def complete(data: list):
    print(f'[*] completed processing functions')
    form = GradientTable(
        data,
        [
            'Address',
            'Name',
            'Type',
            'Contiguous',
            'Size',
            'Number of Blocks',
            'Cyclomatic Complexity',
            'Average Instructions Per Block',
            'Minhash Chromosome Ratio',
            'Chromosome Minhash',
            'TLSH Chromosome Ratio',
            'Chromosome TLSH',
            'Chromosome Pattern'
        ],
        color_column=7,
        min_value=0,
        max_value=1,
        low_to_high=True,
        default_filter_column=1,
        default_sort_column=5,
        default_sort_ascending=False
    )
    form.Show('Binlex Function Table')

def execute(parent):
    if parent.function_table_window:
        return None

    parent.disassemble_controlflow()

    functions = parent.cfg.functions()

    function_names = IDA().get_function_names()

    worker = Worker(
        target=process,
        args=(function_names, functions),
        done_callback=complete
    )
    worker.start()

```

`scripts/plugins/ida/binlex/actions/index_block.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from lib import Worker
from gui import BinlexServerSettingsDialog
from lib import BLClient
from PyQt5.QtWidgets import QDialog
from binlex.controlflow import Block
from lib import IDA

def process(client, data: dict, database: str):
    status, vector = client.index(
        database=database,
        collection='block',
        partition=data['architecture'],
        data=data
    )

    if status != 200:
        print(f'[-] warning: {vector}')

def complete():
    print('[*] indexed block')

def execute(parent):
    dialog = BinlexServerSettingsDialog(show_include_blocks=False)
    if dialog.exec_() != QDialog.Accepted: return
    (
        url,
        api_key,
        database,
        _,
    ) = dialog.get_inputs()
    ea = IDA().get_screen_ea()
    bb = IDA().get_basic_block(ea)
    parent.disassemble_block(bb)
    block = Block(bb.start_ea, parent.cfg)
    data = block.to_dict()
    data['attributes'] = [IDA().file_attribute()]
    client = BLClient(url=url, api_key=api_key)
    worker = Worker(
        target=process,
        args=(
            client,
            data,
            database,
        ),
        done_callback=complete,
    )
    worker.start()
    print(f'[-] indexing block at {hex(bb.start_ea)}...')

```

`scripts/plugins/ida/binlex/actions/index_database.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from lib import Worker
from gui import BinlexServerSettingsDialog
from lib import BLClient
from PyQt5.QtWidgets import QDialog
from binlex.controlflow import Function, Block

def process(client, cfg, function_addresses: list, function_attributes: dict, block_addresses: list, block_attributes: dict, database: str):
    for address in function_addresses:
        function = Function(address, cfg)
        data = function.to_dict()
        data['attributes'] = function_attributes[address]
        status, vector = client.index(
            database=database,
            collection='function',
            partition=data['architecture'],
            data=data
        )
        if status != 200:
            print(f'[-] warning: {vector}')

    for address in block_addresses:
        block = Block(address, cfg)
        data = block.to_dict()
        data['attributes'] = block_attributes[address]
        status, vector = client.index(
            database=database,
            collection='block',
            partition=data['architecture'],
            data=data
        )
        if status != 200:
            print(f'[-] warning: {vector}')

def complete():
    print('[*] indexed database')

def execute(parent):
    dialog = BinlexServerSettingsDialog()
    if dialog.exec_() != QDialog.Accepted: return
    (
        url,
        api_key,
        database,
        include_blocks,
    ) = dialog.get_inputs()
    client = BLClient(url=url, api_key=api_key)
    parent.disassemble_controlflow()
    function_attributes = parent.get_function_attributes()
    function_addresses = parent.cfg.queue_functions.valid_addresses()
    if include_blocks:
        block_attributes = parent.get_block_attributes()
        block_addresses = parent.cfg.queue_blocks.valid_addresses()
    else:
        block_attributes = []
        block_addresses = []
    worker = Worker(
        target=process,
        args=(
            client,
            parent.cfg,
            function_addresses,
            function_attributes,
            block_addresses,
            block_attributes,
            database,
        ),
        done_callback=complete,
    )
    worker.start()
    print('[-] started database indexing...')

```

`scripts/plugins/ida/binlex/actions/index_function.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from lib import Worker
from gui import BinlexServerSettingsDialog
from lib import BLClient
from PyQt5.QtWidgets import QDialog
from binlex.controlflow import Function
from lib import IDA

def process(client, data: dict, include_blocks: bool, database: str):
    status, vector = client.index(
        database=database,
        collection='function',
        partition=data['architecture'],
        data=data
    )

    if status != 200:
        print(f'[-] warning: {vector}')

    if not include_blocks: return

    for block in data['blocks']:
        status, vector = client.index(
            database=database,
            collection='block',
            partition=block['architecture'],
            data=block
        )

        if status != 200:
            print(f'[-] warning: {vector}')

def complete():
    print('[*] indexed function')

def execute(parent):
    dialog = BinlexServerSettingsDialog()
    if dialog.exec_() != QDialog.Accepted: return
    (
        url,
        api_key,
        database,
        include_blocks,
    ) = dialog.get_inputs()
    ea = IDA().get_screen_ea()
    f = IDA().get_function(ea)
    parent.disassemble_function(f)
    function = Function(f.start_ea, parent.cfg)
    data = function.to_dict()
    data['attributes'] = IDA().get_function_attributes(f)
    file_attribute = IDA().file_attribute()
    for i in range(0, len(data['blocks'])):
        data['blocks'][i]['attributes'] = [file_attribute]
    client = BLClient(url=url, api_key=api_key)
    worker = Worker(
        target=process,
        args=(
            client,
            data,
            include_blocks,
            database,
        ),
        done_callback=complete,
    )
    worker.start()
    print(f'[-] indexing function at {hex(f.start_ea)}...')

```

`scripts/plugins/ida/binlex/actions/scan_minhash.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import idaapi
from PyQt5.QtWidgets import QDialog
from lib import IDA
from binlex.hashing import MinHash32
from gui import Progress
from gui import GradientTable
from gui import ScanMinHashInputDialog
from lib import Worker

def process(rhs_minhash, num_bytes, threshold, addresses, config):
    print(f'[-] processing minhash scan...')
    table = []
    for addr in addresses:
        data = IDA().get_bytes(addr, num_bytes)
        lhs_minhash = MinHash32(
            data,
            config.instructions.hashing.minhash.number_of_hashes,
            config.instructions.hashing.minhash.shingle_size,
            config.instructions.hashing.minhash.seed
        ).hexdigest()
        similarity = MinHash32.compare(lhs_minhash, rhs_minhash)
        if similarity is not None and similarity > threshold:
            row = [
                str(hex(addr)),
                similarity or '',
                lhs_minhash,
                rhs_minhash
            ]
            table.append(row)
    return table

def complete(table: list):
    print(f'[*] completed minhash scan')
    headers = [
        'Address',
        'Score',
        'MinHash LHS',
        'MinHash RHS',
    ]
    form = GradientTable(
        table,
        headers,
        color_column=1,
        min_value=0,
        max_value=1,
        low_to_high=True,
        default_filter_column=0,
        default_sort_column=1,
        default_sort_ascending=False
    )
    form.Show('Binlex MinHash Scan Table')

def execute(parent):
    dialog = ScanMinHashInputDialog()
    if dialog.exec_() != QDialog.Accepted: return
    rhs_minhash, num_bytes, threshold = dialog.get_inputs()
    addresses = IDA.get_instruction_addresses()
    worker = Worker(
        target=process,
        args=(
            rhs_minhash,
            num_bytes,
            threshold,
            addresses,
            parent.config
        ),
        done_callback=complete
    )
    worker.start()

```

`scripts/plugins/ida/binlex/actions/scan_tlsh.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import idaapi
from PyQt5.QtWidgets import QDialog
from lib import IDA
from binlex.hashing import TLSH
from gui import Progress, GradientTable, ScanTLSHInputDialog
from lib import Worker

def process(rhs_tlsh, num_bytes, threshold, addresses, config) -> list:
    print(f'[-] processing tlsh scan...')
    table = []
    for addr in addresses:
        data = IDA().get_bytes(addr, num_bytes)
        if not data: continue

        lhs_tlsh = TLSH(data).hexdigest(50)
        if lhs_tlsh is None: continue

        similarity = TLSH.compare(lhs_tlsh, rhs_tlsh)
        if similarity is not None and similarity < threshold:
            table.append([
                str(hex(addr)),
                str(similarity) if similarity is not None else '',
                rhs_tlsh,
                lhs_tlsh
            ])
    return table

def complete(table: list):
    print(f'[*] completed tlsh scan')
    headers = ['Address', 'Score', 'TLSH LHS', 'TLSH RHS']
    form = GradientTable(
        table,
        headers,
        color_column=1,
        min_value=512,
        max_value=0,
        low_to_high=True,
        default_filter_column=0,
        default_sort_column=1,
        default_sort_ascending=True
    )
    form.Show('Binlex TLSH Scan Table')

def execute(parent):
    dialog = ScanTLSHInputDialog()
    if dialog.exec_() != QDialog.Accepted:
        return

    rhs_tlsh, num_bytes, threshold = dialog.get_inputs()
    addresses = IDA.get_instruction_addresses()
    worker = Worker(
        target=process,
        args=(
            rhs_tlsh,
            num_bytes,
            threshold,
            addresses,
            parent.config
        ),
        done_callback=complete
    )
    worker.start()

```

`scripts/plugins/ida/binlex/actions/search_database.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import json
from gui import GradientTable
from lib import Worker
from lib import BLClient
from binlex.controlflow import FunctionJsonDeserializer, Function
from gui import SearchDatabaseDialog
from PyQt5.QtWidgets import QDialog
from lib import IDA
from datetime import datetime
from gui import OkayCancelDialog

def process(
    cfg,
    function_addresses,
    client: BLClient,
    config,
    function_names: dict,
    database: str = 'default',
    minhash_score_threshold: float = 0.75,
    gnn_similarity_threshold: float = 0.75,
    size_ratio_threshold: float = 0.75,
    combined_ratio_threshold: float = 0.75,
    mininum_size: int = 32,
    chromosome_minhash_ratio_threshold: float = 0.75,
    limit: int = 3,
    exclude_named_functions: bool = False,
):
    print('[-] database search started...')
    def calculate_size_ratio(len1: int, len2: int) -> float:
        if max(len1, len2) == 0:
            return 1.0
        return 1 - (abs(len1 - len2) / max(len1, len2))

    results_table = []

    for address in function_addresses:
        lhs_function = Function(address, cfg)
        lhs_function = FunctionJsonDeserializer(lhs_function.json(), config)
        if exclude_named_functions and not function_names[lhs_function.address()].startswith('sub_'):
            continue

        if lhs_function.size() < mininum_size:
            continue

        if lhs_function.chromosome_minhash_ratio() < chromosome_minhash_ratio_threshold:
            continue

        status, lhs_vector = client.inference(lhs_function.to_dict())
        if status != 200:
            return

        status, search_results = client.search(
            database=database,
            collection='function',
            partition=lhs_function.architecture().to_string(),
            offset=0,
            limit=limit,
            threshold=gnn_similarity_threshold,
            vector=lhs_vector
        )
        if status != 200:
            print(f"[x] status: {status}, response: {search_results}")
            return

        for search_result in search_results:
            if len(search_result['name']) == 0:
                continue

            result_data = search_result['data']
            rhs_function = FunctionJsonDeserializer(json.dumps(result_data), config)

            size_ratio = calculate_size_ratio(lhs_function.size(), rhs_function.size())
            if size_ratio < size_ratio_threshold:
                continue

            comparison = lhs_function.compare(rhs_function)
            if comparison is None:
                continue

            minhash_score = comparison.score.minhash()
            if minhash_score is None or minhash_score < minhash_score_threshold:
                continue

            combined_score = (search_result['score'] + minhash_score) / 2.0
            if combined_score < combined_ratio_threshold:
                continue

            row = [
                str(hex(lhs_function.address())),
                str(search_result['score']),
                str(minhash_score),
                str(combined_score),
                str(result_data['size']),
                str(size_ratio),
                str(result_data['number_of_instructions']),
                str(result_data['entropy']),
                str(result_data['average_instructions_per_block']),
                str(result_data['cyclomatic_complexity']),
                function_names[lhs_function.address()],
                search_result['name'],
                search_result['file_attributes']['sha256'],
                datetime.fromtimestamp(search_result['timestamp']).isoformat(),
                search_result['username'],
                str(lhs_vector),
                search_result['vector']
            ]
            results_table.append(row)

    return results_table

def complete(table: list):
    print('[-] database search completed')
    gradient_table = GradientTable(
        table,
        [
            'LHS Address',
            'GNN Score',
            'Minhash Score',
            'Combined Score',
            'Size',
            'Size Ratio',
            'Number of Instructions',
            'Entropy',
            'Average Instructions Per Block',
            'Cyclomatic Complexity',
            'LHS Name',
            'RHS Name',
            'RHS SHA256',
            'Timestamp',
            'Username',
            'LHS Vector',
            'RHS Vector',
        ],
        color_column=3,
        min_value=0,
        max_value=1,
        low_to_high=True,
        default_filter_column=11,
        default_sort_column=3,
        default_sort_ascending=False
    )
    def apply_rhs_name(row: list):
        address = int(row[0], 16)
        gnn_score = float(row[1])
        minhash_score = float(row[2])
        score = float(row[3])
        size = int(row[4])
        size_ratio = float(row[5])
        number_of_instructions = int(row[6])
        entropy = float(row[7])
        average_instructions_per_block = float(row[8])
        cyclomatic_complexity = int(row[9])
        rhs_name = row[11]
        sample_sha256 = row[12]
        timestamp = row[13]
        username = row[14]
        IDA().set_name(address, rhs_name)
        comment = (
            "Binlex Function Details:\n"
            f"SHA256: {sample_sha256}\n"
            f"Score: {score}\n"
            f"GNN Score: {gnn_score}\n"
            f"Minhash Score: {minhash_score}\n"
            f"Size: {size}\n"
            f"Size Ratio: {size_ratio}\n"
            f"Number of Instructions: {number_of_instructions}\n"
            f"Entropy: {entropy}\n"
            f"Average Instructions per Block: {average_instructions_per_block}\n"
            f"Cyclomatic Complexity: {cyclomatic_complexity}\n"
            f"Username: {username}\n"
        )
        IDA().set_function_comment(address, comment)

    def apply_lhs_name(row: list):
        address = int(row[0], 16)
        IDA().set_name(address, row[10])
        IDA().delete_function_comment(address)

    def apply_all_names(table: list):
        dialog = OkayCancelDialog(title='Are you sure?', okay_text='Okay', cancel_text='Cancel')
        if dialog.exec_() == QDialog.Rejected: return

        function_names = {}

        for row in table:
            address = int(row[0], 16)
            gnn_score = float(row[1])
            minhash_score = float(row[2])
            score = float(row[3])
            size = int(row[4])
            size_ratio = float(row[5])
            number_of_instructions = int(row[6])
            entropy = float(row[7])
            average_instructions_per_block = float(row[8])
            cyclomatic_complexity = int(row[9])
            rhs_name = row[11]
            sample_sha256 = row[12]
            timestamp = row[13]
            username = row[14]

            if address not in function_names or function_names[address]['score'] < score:
                function_names[address] = {
                    'rhs_name': rhs_name,
                    'sample_sha256': sample_sha256,
                    'score': score,
                    'gnn_score': gnn_score,
                    'minhash_score': minhash_score,
                    'size': size,
                    'size_ratio': size_ratio,
                    'number_of_instructions': number_of_instructions,
                    'entropy': entropy,
                    'average_instructions_per_block': average_instructions_per_block,
                    'cyclomatic_complexity': cyclomatic_complexity,
                    'timestamp': timestamp,
                    'username': username,
                }

        for address, info in function_names.items():
            IDA().set_name(address, info['rhs_name'])
            comment = (
                "Binlex Function Details:\n"
                f"SHA256: {info['sample_sha256']}\n"
                f"Score: {info['score']}\n"
                f"GNN Score: {info['gnn_score']}\n"
                f"Minhash Score: {info['minhash_score']}\n"
                f"Size: {info['size']}\n"
                f"Size Ratio: {info['size_ratio']}\n"
                f"Number of Instructions: {info['number_of_instructions']}\n"
                f"Entropy: {info['entropy']}\n"
                f"Average Instructions per Block: {info['average_instructions_per_block']}\n"
                f"Cyclomatic Complexity: {info['cyclomatic_complexity']}\n"
                f"Username: {info['username']}\n"
            )
            IDA().set_function_comment(address, comment)

    gradient_table.register_row_callback('Apply RHS Name', apply_rhs_name)
    gradient_table.register_row_callback('Apply LHS Name', apply_lhs_name)
    gradient_table.register_table_callback('Apply All RHS Names', apply_all_names)
    gradient_table.Show('Binlex Function Compare Results')

def execute(parent):
    dialog = SearchDatabaseDialog()
    if dialog.exec_() != QDialog.Accepted: return
    (
        minhash_score_threshold,
        mininum_size,
        size_ratio_threshold,
        chromosome_minhash_ratio_threshold,
        combined_ratio_threshold,
        gnn_similarity_threshold,
        url,
        api_key,
        database,
        limit,
        exclude_named_functions,
    ) = dialog.get_inputs()
    client = BLClient(url=url, api_key=api_key)
    IDA().set_registry_value('url', url)
    IDA().set_registry_value('api_key', api_key)
    parent.disassemble_controlflow()
    #functions = parent.get_function_json_deserializers()
    function_addresses = parent.cfg.queue_functions.valid_addresses()
    function_names = parent.ida.get_function_names()
    worker = Worker(
        target=process,
        args=(
            parent.cfg,
            function_addresses,
            client,
            parent.config,
            function_names,
            database,
            minhash_score_threshold,
            gnn_similarity_threshold,
            size_ratio_threshold,
            combined_ratio_threshold,
            mininum_size,
            chromosome_minhash_ratio_threshold,
            limit,
            exclude_named_functions,
        ),
        done_callback=complete,
    )
    worker.start()

```

`scripts/plugins/ida/binlex/gui/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from .about import About
from .gradient_table import GradientTable
from .main import Main
from .progress import Progress
from .database_export_options import DatabaseExportOptionsDialog
from .scan_minhash import ScanMinHashInputDialog
from .scan_tlsh import ScanTLSHInputDialog
from .search_database import SearchDatabaseDialog
from .svg import SVGWidget
from .okaycancel import OkayCancelDialog
from .json_search import JSONSearchWindow
from .binlex_server_authentication import BinlexServerAuthenticationDialog
from .binlex_server_settings import BinlexServerSettingsDialog
from .action_handlers import BinlexExportActionHandler
from .action_handlers import CopyHexActionHandler
from .action_handlers import CopyPatternActionHandler
from .action_handlers import register_action_handlers
from .action_handlers import unregister_action_handlers

```

`scripts/plugins/ida/binlex/gui/about.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from lib.assets import LOGO
from lib.assets import MOVIE
from lib.text import CREDITS

import zlib
import base64
from PyQt5.QtCore import Qt, QBuffer, QTimer, QByteArray
from PyQt5.QtGui import QMovie
from PyQt5.QtWidgets import QLabel, QDialog

class About(QDialog):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin
        self.gif_data = zlib.decompress(base64.b64decode(MOVIE))
        self.gif_buffer = None
        self.init_ui()

    def init_ui(self):
        self.setWindowTitle('About')
        self.setFixedSize(300, 200)
        self.setWindowFlags(Qt.WindowFlags(Qt.Dialog | Qt.ApplicationModal))

        self.gif_label = QLabel(self)
        self.gif_label.setGeometry(0, 0, 300, 200)
        self.gif_buffer = QBuffer()
        self.gif_buffer.setData(QByteArray(self.gif_data))
        self.gif_buffer.open(QBuffer.ReadOnly)

        movie = QMovie(self.gif_buffer, b'gif')
        self.gif_label.setMovie(movie)
        movie.start()

        self.overlay_label = QLabel(self)
        self.overlay_label.setGeometry(0, 0, 300, 200)
        self.overlay_label.setStyleSheet("background-color: rgba(0, 0, 0, 150);")
        self.overlay_label.setAttribute(Qt.WA_TransparentForMouseEvents)

        self.text_label = QLabel(self)
        self.text_label.setGeometry(0, 200, 300, 200)
        self.text_label.setText(CREDITS)
        self.text_label.setAlignment(Qt.AlignCenter)
        self.text_label.setStyleSheet(
            "color: white; font-size: 14px; background: transparent; font-weight: bold;"
        )

        self.timer = QTimer(self)
        self.timer.timeout.connect(self.scroll_text)
        self.timer.start(40)

        self.text_y_pos = 200

    def scroll_text(self):
        self.text_y_pos -= 1
        if self.text_y_pos + self.text_label.height() < 0:
            self.text_y_pos = self.height()

        self.text_label.move(0, self.text_y_pos)

```

`scripts/plugins/ida/binlex/gui/action_handlers.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import ida_kernwin
import idaapi

class BinlexExportActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.export()
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

class CopyBlockVectorActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_copy_block_vector()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class CopyMinHashActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_copy_minhash()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class CopyPatternActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_copy_pattern()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class CopyBlockJsonActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_copy_block_json()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class CopyHexActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_copy_hex()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class ScanMinHashActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_scan_minhash()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class ScanTLSHActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_scan_tlsh()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class CopyTLSHActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_copy_tlsh()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class CopyFunctionVectorActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_copy_function_vector()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class CopyFunctionJsonActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_copy_function_json()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class IndexFunctionActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_index_function()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

class IndexBlockActionHandler(idaapi.action_handler_t):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def activate(self, ctx):
        self.plugin.action_index_block()
        return 1

    def update(self, ctx):
        if ctx.widget and ida_kernwin.get_widget_type(ctx.widget) in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            return idaapi.AST_ENABLE_ALWAYS
        return idaapi.AST_DISABLE

def unregister_action_handlers():
    ida_kernwin.unregister_action('binlex:copy_pattern')
    ida_kernwin.unregister_action('binlex:copy_minhash')
    ida_kernwin.unregister_action('binlex:scan_minhash')
    ida_kernwin.unregister_action('binlex:copy_tlsh')
    ida_kernwin.unregister_action('binlex:copy_hex')
    ida_kernwin.unregister_action('binlex::copy_block_vector')
    ida_kernwin.unregister_action('binlex::copy_block_json')
    ida_kernwin.unregister_action('binlex::copy_function_vector')
    ida_kernwin.unregister_action('binlex::copy_function_json')
    ida_kernwin.unregister_action('binlex::index_function')
    ida_kernwin.unregister_action('binlex::index_block')

def register_action_handlers(parent):
    action_desc = idaapi.action_desc_t(
        "binlex:index_block",
        "Index Block",
        IndexBlockActionHandler(parent),
        None,
        "Index current block",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register index_block action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:index_function",
        "Index Function",
        IndexFunctionActionHandler(parent),
        None,
        "Index current function",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register index_function action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:copy_function_json",
        "Copy Function JSON",
        CopyFunctionJsonActionHandler(parent),
        None,
        "Copy current function JSON",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register copy_function_json action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:copy_function_vector",
        "Copy Function Vector",
        CopyFunctionVectorActionHandler(parent),
        None,
        "Copy current function vector",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register copy_function_vector action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:copy_block_json",
        "Copy Block JSON",
        CopyBlockJsonActionHandler(parent),
        None,
        "Copy current block JSON",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register copy_block_json action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:copy_block_vector",
        "Copy Block Vector",
        CopyBlockVectorActionHandler(parent),
        None,
        "Copy current block vector",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register copy_block_vector action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:copy_pattern",
        "Copy Pattern",
        CopyPatternActionHandler(parent),
        None,
        "Copy selected range as pattern",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register copy_pattern action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:copy_hex",
        "Copy Hex",
        CopyHexActionHandler(parent),
        None,
        "Copy selected range as hex",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register copy_minhash action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:copy_minhash",
        "Copy MinHash",
        CopyMinHashActionHandler(parent),
        None,
        "Copy selected range as a MinHash",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register copy_minhash action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:scan_minhash",
        "Scan MinHash",
        ScanMinHashActionHandler(parent),
        None,
        "Scan project for MinHash similarity matches",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register scan_minhash action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:copy_tlsh",
        "Copy TLSH",
        CopyTLSHActionHandler(parent),
        None,
        "Copy selected range as TLSH",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register copy_tlsh action.\n')
    action_desc = idaapi.action_desc_t(
        "binlex:scan_tlsh",
        "Scan TLSH",
        ScanTLSHActionHandler(parent),
        None,
        "Scan project for TLSH similarity matches",
        -1
    )
    if not ida_kernwin.register_action(action_desc): ida_kernwin.msg('[x] failed to register scan_tlsh action.\n')

```

`scripts/plugins/ida/binlex/gui/binlex_server_authentication.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QLabel,
    QDialog,
    QVBoxLayout,
    QDialogButtonBox,
    QLineEdit,
    QPushButton,
    QHBoxLayout,
    QComboBox,
    QCheckBox,
)
from lib import IDA
from lib import BLClient

class BinlexServerAuthenticationDialog(QDialog):
    def __init__(self, parent=None):
        super(BinlexServerAuthenticationDialog, self).__init__(parent)
        self.setWindowTitle('Binlex Server Settings')
        self.setModal(True)
        self.setFixedWidth(500)

        layout = QVBoxLayout(self)

        url = IDA().get_registry_value('url')
        api_key = IDA().get_registry_value('api_key')

        self.url_label = QLabel('Server URL')
        self.url_input = QLineEdit()
        if url is not None: self.url_input.setText(url)
        layout.addWidget(self.url_label)
        layout.addWidget(self.url_input)

        self.api_key_label = QLabel('API Key')
        self.api_key_input = QLineEdit()
        self.api_key_input.setEchoMode(QLineEdit.Password)
        if api_key is not None: self.api_key_input.setText(api_key)

        self.show_hide_button = QPushButton('Show')
        self.show_hide_button.setCheckable(True)
        self.show_hide_button.clicked.connect(self.toggle_api_key_visibility)

        api_key_layout = QHBoxLayout()
        api_key_layout.addWidget(self.api_key_input)
        api_key_layout.addWidget(self.show_hide_button)

        layout.addWidget(self.api_key_label)
        layout.addLayout(api_key_layout)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def toggle_api_key_visibility(self):
        if self.show_hide_button.isChecked():
            self.api_key_input.setEchoMode(QLineEdit.Normal)
            self.show_hide_button.setText('Hide')
        else:
            self.api_key_input.setEchoMode(QLineEdit.Password)
            self.show_hide_button.setText('Show')

    def get_inputs(self):
        return (
            self.url_input.text(),
            self.api_key_input.text(),
        )

```

`scripts/plugins/ida/binlex/gui/binlex_server_settings.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QLabel,
    QDialog,
    QVBoxLayout,
    QDialogButtonBox,
    QLineEdit,
    QPushButton,
    QHBoxLayout,
    QComboBox,
    QCheckBox,
)
from lib import IDA
from lib import BLClient

class BinlexServerSettingsDialog(QDialog):
    def __init__(self, databases: list = ['default', 'goodware', 'malware'], show_include_blocks: bool = True, parent=None):
        super(BinlexServerSettingsDialog, self).__init__(parent)
        self.setWindowTitle('Binlex Server Settings')
        self.setModal(True)
        self.setFixedWidth(500)

        layout = QVBoxLayout(self)

        url = IDA().get_registry_value('url')
        api_key = IDA().get_registry_value('api_key')

        try:
            if url is not None and api_key is not None:
                client = BLClient(url=url, api_key=api_key)
                status, response = client.databases()
                if status == 200: databases = response
        except:
            pass

        self.url_label = QLabel('Server URL')
        self.url_input = QLineEdit()
        if url is not None: self.url_input.setText(url)
        layout.addWidget(self.url_label)
        layout.addWidget(self.url_input)

        self.api_key_label = QLabel('API Key')
        self.api_key_input = QLineEdit()
        self.api_key_input.setEchoMode(QLineEdit.Password)
        if api_key is not None: self.api_key_input.setText(api_key)

        self.show_hide_button = QPushButton('Show')
        self.show_hide_button.setCheckable(True)
        self.show_hide_button.clicked.connect(self.toggle_api_key_visibility)

        api_key_layout = QHBoxLayout()
        api_key_layout.addWidget(self.api_key_input)
        api_key_layout.addWidget(self.show_hide_button)

        layout.addWidget(self.api_key_label)
        layout.addLayout(api_key_layout)

        self.database_label = QLabel('Database')
        self.database_input = QComboBox()
        self.database_input.addItems(databases)
        self.database_input.setCurrentText('default')
        layout.addWidget(self.database_label)
        layout.addWidget(self.database_input)

        self.include_blocks = QCheckBox('Include Blocks')
        self.include_blocks.setChecked(False)
        if show_include_blocks: layout.addWidget(self.include_blocks)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def toggle_api_key_visibility(self):
        if self.show_hide_button.isChecked():
            self.api_key_input.setEchoMode(QLineEdit.Normal)
            self.show_hide_button.setText('Hide')
        else:
            self.api_key_input.setEchoMode(QLineEdit.Password)
            self.show_hide_button.setText('Show')

    def get_inputs(self):
        return (
            self.url_input.text(),
            self.api_key_input.text(),
            self.database_input.currentText(),
            self.include_blocks.isChecked(),
        )

```

`scripts/plugins/ida/binlex/gui/database_export_options.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


from PyQt5.QtCore import Qt, QBuffer, QTimer, QByteArray
from PyQt5.QtGui import QMovie
from PyQt5.QtWidgets import QLabel, QDialog, QVBoxLayout, QDialogButtonBox, QDoubleSpinBox, QSpinBox, QLineEdit

class DatabaseExportOptionsDialog(QDialog):
    def __init__(self, parent=None):
        super(DatabaseExportOptionsDialog, self).__init__(parent)
        self.setWindowTitle('Database Export Options')
        self.setModal(True)

        layout = QVBoxLayout(self)

        self.gnn_input_dimensions_label = QLabel('GNN Input Dimensions')
        self.gnn_input_dimensions_input = QSpinBox()
        self.gnn_input_dimensions_input.setRange(4, 32)
        self.gnn_input_dimensions_input.setValue(8)
        layout.addWidget(self.gnn_input_dimensions_label)
        layout.addWidget(self.gnn_input_dimensions_input)

        self.gnn_hidden_dimensions_label = QLabel('GNN Hidden Dimensions')
        self.gnn_hidden_dimensions_input = QSpinBox()
        self.gnn_hidden_dimensions_input.setRange(8, 64)
        self.gnn_hidden_dimensions_input.setValue(16)
        layout.addWidget(self.gnn_hidden_dimensions_label)
        layout.addWidget(self.gnn_hidden_dimensions_input)

        self.gnn_output_dimensions_label = QLabel('GNN Output Dimensions')
        self.gnn_output_dimensions_input = QSpinBox()
        self.gnn_output_dimensions_input.setRange(4, 64)
        self.gnn_output_dimensions_input.setValue(8)
        layout.addWidget(self.gnn_output_dimensions_label)
        layout.addWidget(self.gnn_output_dimensions_input)

        self.knn_max_label = QLabel('KNN Max Results')
        self.knn_max_input = QSpinBox()
        self.knn_max_input.setRange(1, 32)
        self.knn_max_input.setValue(4)
        layout.addWidget(self.knn_max_label)
        layout.addWidget(self.knn_max_input)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def get_inputs(self):
        return (
            self.gnn_input_dimensions_input.value(),
            self.gnn_hidden_dimensions_input.value(),
            self.gnn_output_dimensions_input.value(),
            self.knn_max_input.value(),
        )

```

`scripts/plugins/ida/binlex/gui/gradient_table.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from PyQt5.QtCore import Qt, QSortFilterProxyModel
from PyQt5.QtGui import QBrush, QColor, QPainter, QStandardItemModel, QStandardItem
from PyQt5.QtWidgets import (
    QStyledItemDelegate,
    QStyleOptionViewItem,
    QTableView,
    QHeaderView,
    QVBoxLayout,
    QComboBox,
    QLineEdit,
    QMenu,
    QApplication,
    QWidget,
    QStyle,
    QAbstractItemView,
)
import idaapi
import idc
import ida_kernwin

class BoldSelectedRowDelegate(QStyledItemDelegate):
    def paint(self, painter, option, index):
        painter.save()
        custom_option = QStyleOptionViewItem(option)

        if custom_option.state & QStyle.State_Selected:
            custom_option.state &= ~QStyle.State_Selected
            background_brush = index.data(Qt.BackgroundRole)
            if isinstance(background_brush, QBrush):
                painter.fillRect(custom_option.rect, background_brush)
            custom_option.font.setBold(True)
            painter.setFont(custom_option.font)

        super().paint(painter, custom_option, index)
        painter.restore()

class TableFilterProxyModel(QSortFilterProxyModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.filter_string = ""
        self.filter_column = 0
        self.setFilterCaseSensitivity(Qt.CaseInsensitive)

    def setFilterString(self, text):
        self.filter_string = text.lower()
        self.invalidateFilter()

    def setFilterColumnIndex(self, col_index):
        self.filter_column = col_index
        self.invalidateFilter()

    def filterAcceptsRow(self, source_row, source_parent):
        if not self.filter_string:
            return True
        index = self.sourceModel().index(source_row, self.filter_column, source_parent)
        cell_text = index.data(Qt.DisplayRole)
        if cell_text is None:
            return False
        return self.filter_string in cell_text.lower()

class GradientTable(ida_kernwin.PluginForm):
    # def __init__(
    #     self,
    #     data,
    #     headers,
    #     color_column=None,
    #     min_value=0,
    #     max_value=1,
    #     low_to_high=True,
    #     default_filter_column=0,
    #     default_sort_column=0,
    #     default_sort_ascending=True
    # ):
    #     super().__init__()
    #     self.data = data
    #     self.headers = headers
    #     self.color_column = color_column
    #     self.min_value = min_value
    #     self.max_value = max_value
    #     self.low_to_high = low_to_high
    #     self.default_filter_column = default_filter_column
    #     self.default_sort_column = default_sort_column
    #     self.default_sort_ascending = default_sort_ascending

    #     self.model = None
    #     self.proxy_model = None
    #     self.table_view = None
    #     self.column_combo_box = None
    #     self.filter_line_edit = None

    #     self.row_callbacks = []
    #     self.table_callbacks = []

    def __init__(
        self,
        data,
        headers,
        color_column=None,
        min_value=0,
        max_value=1,
        low_to_high=True,
        default_filter_column=0,
        default_sort_column=0,
        default_sort_ascending=True
    ):
        super().__init__()
        self.data = data
        self.headers = headers
        self.color_column = color_column
        self.min_value = min_value
        self.max_value = max_value
        self.low_to_high = low_to_high
        self.default_filter_column = default_filter_column
        self.default_sort_column = default_sort_column
        self.default_sort_ascending = default_sort_ascending

        self.model = None
        self.proxy_model = None
        self.table_view = None
        self.column_combo_box = None
        self.filter_line_edit = None

        self.row_callbacks = []
        self.table_callbacks = []

    def register_table_callback(self, menu_text, callback):
        """Register a full-table callback to be added to the context menu."""
        self.table_callbacks.append((menu_text, callback))

    def register_row_callback(self, menu_text, callback):
        """Register a row callback to be added to the context menu."""
        self.row_callbacks.append((menu_text, callback))

    def OnCreate(self, form):
        self.parent = self.FormToPyQtWidget(form)
        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout()

        self.model = QStandardItemModel(len(self.data), len(self.headers), self.parent)
        self.model.setHorizontalHeaderLabels(self.headers)

        for row_idx, row_data in enumerate(self.data):
            row_color = None
            if self.color_column is not None:
                try:
                    value = float(row_data[self.color_column])
                    row_color = self.get_color(value)
                except ValueError:
                    pass

            for col_idx, col_data in enumerate(row_data):
                item = QStandardItem(str(col_data))
                if row_color:
                    brush = QBrush(row_color)
                    item.setBackground(brush)
                    fg_color = self.get_contrasting_color(row_color)
                    item.setForeground(QBrush(fg_color))
                item.setEditable(False)
                self.model.setItem(row_idx, col_idx, item)

        self.proxy_model = TableFilterProxyModel(self.parent)
        self.proxy_model.setSourceModel(self.model)
        self.proxy_model.setDynamicSortFilter(True)

        self.table_view = QTableView(self.parent)
        self.table_view.setModel(self.proxy_model)
        self.table_view.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table_view.setSelectionMode(QAbstractItemView.SingleSelection)
        self.table_view.setSortingEnabled(True)

        sort_order = Qt.AscendingOrder if self.default_sort_ascending else Qt.DescendingOrder
        self.table_view.sortByColumn(self.default_sort_column, sort_order)

        self.table_view.verticalHeader().setVisible(False)

        self.table_view.horizontalHeader().setStretchLastSection(True)
        self.table_view.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)

        delegate = BoldSelectedRowDelegate(self.table_view)
        self.table_view.setItemDelegate(delegate)

        self.table_view.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table_view.customContextMenuRequested.connect(self.show_context_menu)

        selection_model = self.table_view.selectionModel()
        selection_model.selectionChanged.connect(self.on_row_selected)

        main_layout.addWidget(self.table_view)

        filter_layout = QVBoxLayout()

        self.column_combo_box = QComboBox()
        self.column_combo_box.addItems(self.headers)
        self.column_combo_box.setCurrentIndex(self.default_filter_column)
        self.column_combo_box.currentIndexChanged.connect(self.on_filter_column_changed)

        self.filter_line_edit = QLineEdit()
        self.filter_line_edit.setPlaceholderText("Type to filter...")
        self.filter_line_edit.textChanged.connect(self.on_filter_text_changed)

        filter_layout.addWidget(self.column_combo_box)
        filter_layout.addWidget(self.filter_line_edit)

        main_layout.addLayout(filter_layout)
        self.parent.setLayout(main_layout)

        self.proxy_model.setFilterColumnIndex(self.default_filter_column)

    def on_filter_column_changed(self, index):
        self.proxy_model.setFilterColumnIndex(index)

    def on_filter_text_changed(self, text):
        self.proxy_model.setFilterString(text)

    def on_row_selected(self, selected, deselected):
        indices = self.table_view.selectionModel().selectedRows()
        if not indices:
            return

        proxy_index = indices[0]
        source_index = self.proxy_model.mapToSource(proxy_index)
        item = self.model.item(source_index.row(), 0)
        if not item:
            return

        hex_text = item.text()
        try:
            address = int(hex_text, 16)
            idc.jumpto(address)
        except ValueError:
            ida_kernwin.msg('[x] invalid address format\n')

    def show_context_menu(self, position):
        menu = QMenu(self.table_view)
        column_actions = {}

        # Add "Copy" actions for each column
        for col_idx, header in enumerate(self.headers):
            action = menu.addAction(f"Copy {header}")
            column_actions[action] = col_idx

        # Add row callbacks
        if self.row_callbacks:
            menu.addSeparator()
        for menu_text, callback in self.row_callbacks:
            action = menu.addAction(menu_text)
            column_actions[action] = callback

        # Add full-table callbacks
        if self.table_callbacks:
            menu.addSeparator()
        for menu_text, callback in self.table_callbacks:
            action = menu.addAction(menu_text)
            column_actions[action] = callback

        selected_action = menu.exec_(self.table_view.viewport().mapToGlobal(position))
        if selected_action in column_actions:
            selected_item = column_actions[selected_action]
            if callable(selected_item):
                if selected_item in dict(self.row_callbacks).values():
                    # Execute the row callback
                    self.execute_row_callback(selected_item)
                elif selected_item in dict(self.table_callbacks).values():
                    # Execute the full-table callback
                    self.execute_table_callback(selected_item)
            else:
                self.copy_column_data(selected_item)

    def execute_table_callback(self, callback):
        """Execute a table callback."""
        table_data = []
        for row_idx in range(self.model.rowCount()):
            row_data = [
                self.model.item(row_idx, col_idx).text()
                for col_idx in range(self.model.columnCount())
            ]
            table_data.append(row_data)
        callback(table_data)

    # def show_context_menu(self, position):
    #     menu = QMenu(self.table_view)
    #     column_actions = {}

    #     # Add "Copy" actions for each column
    #     for col_idx, header in enumerate(self.headers):
    #         action = menu.addAction(f"Copy {header}")
    #         column_actions[action] = col_idx

    #     # Add row callbacks
    #     if self.row_callbacks:
    #         menu.addSeparator()
    #     for menu_text, callback in self.row_callbacks:
    #         action = menu.addAction(menu_text)
    #         column_actions[action] = callback

    #     selected_action = menu.exec_(self.table_view.viewport().mapToGlobal(position))
    #     if selected_action in column_actions:
    #         selected_item = column_actions[selected_action]
    #         if callable(selected_item):
    #             # Execute the row callback
    #             self.execute_row_callback(selected_item)
    #         else:
    #             self.copy_column_data(selected_item)

    def execute_row_callback(self, callback):
        """Execute a row callback on the selected row."""
        selection_model = self.table_view.selectionModel()
        if not selection_model.hasSelection():
            return
        proxy_index = selection_model.selectedRows()[0]
        source_index = self.proxy_model.mapToSource(proxy_index)
        row_data = [
            self.model.item(source_index.row(), col_idx).text()
            for col_idx in range(self.model.columnCount())
        ]
        callback(row_data)

    def copy_column_data(self, column_index):
        selection_model = self.table_view.selectionModel()
        if not selection_model.hasSelection():
            return
        proxy_index = selection_model.selectedRows()[0]
        source_index = self.proxy_model.mapToSource(proxy_index)
        item = self.model.item(source_index.row(), column_index)
        if item:
            clipboard = QApplication.clipboard()
            clipboard.setText(item.text())

    def get_color(self, value):
        normalized = (value - self.min_value) / (self.max_value - self.min_value)
        normalized = max(0, min(1, normalized))
        if not self.low_to_high:
            normalized = 1 - normalized
        red = int((1 - normalized) * 255)
        green = int(normalized * 255)
        return QColor(red, green, 0)

    def get_contrasting_color(self, color: QColor) -> QColor:
        r = color.redF()
        g = color.greenF()
        b = color.blueF()
        luminance = 0.299*r + 0.587*g + 0.114*b
        return Qt.black if luminance >= 0.5 else Qt.white

```

`scripts/plugins/ida/binlex/gui/hooks.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import idaapi
import ida_kernwin

class UIHooks(idaapi.UI_Hooks):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin

    def finish_populating_widget_popup(self, widget, popup):
        widget_type = ida_kernwin.get_widget_type(widget)
        if widget_type in [ida_kernwin.BWN_DISASM, ida_kernwin.BWN_DISASM]:
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:copy_pattern",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:copy_hex",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:copy_minhash",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:copy_tlsh",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:scan_minhash",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:scan_tlsh",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:copy_block_vector",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:copy_block_json",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:copy_function_vector",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:copy_function_json",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:index_function",
                "Binlex/"
            )
            ida_kernwin.attach_action_to_popup(
                widget,
                popup,
                "binlex:index_block",
                "Binlex/"
            )

```

`scripts/plugins/ida/binlex/gui/json_search.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import sys
import jq
from PyQt5.QtWidgets import (
    QVBoxLayout, QHBoxLayout, QWidget, QLabel,
    QLineEdit, QPushButton, QTextEdit, QMessageBox,
    QMenu, QAction, QFileDialog
)
import ida_kernwin

class JSONSearchWindow(ida_kernwin.PluginForm):
    def __init__(self, json_objects: list[dict]):
        super().__init__()
        self.json_objects = json_objects

    def OnCreate(self, form):
        # Get a parent widget for the dockable window
        self.parent = self.FormToPyQtWidget(form)

        # Main layout
        main_layout = QVBoxLayout()

        # Query bar layout
        query_layout = QHBoxLayout()
        self.query_input = QLineEdit()
        self.query_input.setPlaceholderText("Enter jq query here...")
        query_button = QPushButton("Query")
        query_button.clicked.connect(self.perform_query)

        query_layout.addWidget(QLabel("JQ Query:"))
        query_layout.addWidget(self.query_input)
        query_layout.addWidget(query_button)

        # Results text box
        self.results_box = ResultsTextEdit()
        self.results_box.setReadOnly(True)

        # Add widgets to the main layout
        main_layout.addLayout(query_layout)
        main_layout.addWidget(self.results_box)

        # Set the layout to the parent widget
        container = QWidget()
        container.setLayout(main_layout)
        layout = QVBoxLayout()
        layout.addWidget(container)
        self.parent.setLayout(layout)

    def OnClose(self, form):
        # Perform any cleanup if necessary
        pass

    def perform_query(self):
        query = self.query_input.text()
        try:
            # Combine all JSON objects into a list

            # Apply jq query
            result = jq.compile(query).input(self.json_objects).all()

            # Display results
            self.results_box.setPlainText(str(result))
        except Exception as e:
            QMessageBox.critical(self.parent, "Query Error", f"An error occurred: {e}")

class ResultsTextEdit(QTextEdit):
    def contextMenuEvent(self, event):
        # Create a custom context menu
        menu = QMenu(self)

        # Add a save action
        save_action = QAction("Save", self)
        save_action.triggered.connect(self.save_to_file)
        menu.addAction(save_action)

        # Add other default actions from the standard context menu
        standard_menu = self.createStandardContextMenu()
        for action in standard_menu.actions():
            menu.addAction(action)

        # Show the context menu
        menu.exec_(event.globalPos())


    def save_to_file(self):
        # Open a file dialog to select a save location
        file_path = ida_kernwin.ask_file(1, "*.json", 'Export Binlex JQ Query Results')
        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as file:
                    file.write(self.toPlainText())
                print("[*] results saved successfully")
            except Exception as e:
                print(f"[x] {e}")

```

`scripts/plugins/ida/binlex/gui/main.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import zlib
import base64
from lib.assets import LOGO
from lib.styles import QPUSHBUTTON_STYLE
from PyQt5.QtWidgets import QDialog, QVBoxLayout, QPushButton, QMainWindow, QWidget
from PyQt5.QtCore import Qt, QRect
from PyQt5.QtGui import QPixmap, QPainter

class Main(QWidget):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin
        self.pixmap = QPixmap()
        self.init_ui()

    def init_ui(self):
        self.setWindowTitle('Binlex')
        self.setFixedSize(300, 300)
        self.setWindowFlags(Qt.Window | Qt.WindowCloseButtonHint | Qt.WindowTitleHint)

        image_data = zlib.decompress(base64.b64decode(LOGO))
        self.pixmap.loadFromData(image_data)

        layout = QVBoxLayout()

        export_database_button = QPushButton('Export Database')
        export_database_button.clicked.connect(self.plugin.action_export)
        export_database_button.setStyleSheet(QPUSHBUTTON_STYLE)
        layout.addWidget(export_database_button)

        index_database_button = QPushButton('Index Database')
        index_database_button.clicked.connect(self.plugin.action_index_database)
        index_database_button.setStyleSheet(QPUSHBUTTON_STYLE)
        layout.addWidget(index_database_button)

        search_database_button = QPushButton('Search Database')
        search_database_button.clicked.connect(self.plugin.action_search_database)
        search_database_button.setStyleSheet(QPUSHBUTTON_STYLE)
        layout.addWidget(search_database_button)

        functions_button = QPushButton('Functions')
        functions_button.clicked.connect(self.plugin.action_function_table)
        functions_button.setStyleSheet(QPUSHBUTTON_STYLE)
        layout.addWidget(functions_button)

        export_byte_colormap_button = QPushButton('Export Byte ColorMap')
        export_byte_colormap_button.clicked.connect(self.plugin.action_export_byte_colormap)
        export_byte_colormap_button.setStyleSheet(QPUSHBUTTON_STYLE)
        layout.addWidget(export_byte_colormap_button)

        json_query_button = QPushButton('JSON Query')
        json_query_button.clicked.connect(self.plugin.action_json_search_window)
        json_query_button.setStyleSheet(QPUSHBUTTON_STYLE)
        layout.addWidget(json_query_button)

        about_button = QPushButton('About')
        about_button.clicked.connect(self.plugin.open_about_window)
        about_button.setStyleSheet(QPUSHBUTTON_STYLE)
        layout.addWidget(about_button)

        self.setLayout(layout)

    def paintEvent(self, event):
        super().paintEvent(event)

        if self.pixmap.isNull():
            return

        painter = QPainter(self)

        widget_width = self.width()
        widget_height = self.height()

        pixmap_width = self.pixmap.width()
        pixmap_height = self.pixmap.height()

        scale_x = widget_width / pixmap_width
        scale_y = widget_height / pixmap_height
        scale = min(scale_x, scale_y)

        new_width = int(pixmap_width * scale)
        new_height = int(pixmap_height * scale)

        x_offset = (widget_width - new_width) // 2
        y_offset = (widget_height - new_height) // 2

        target_rect = QRect(x_offset, y_offset, new_width, new_height)
        painter.drawPixmap(target_rect, self.pixmap, self.pixmap.rect())

```

`scripts/plugins/ida/binlex/gui/okaycancel.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QDialog, QVBoxLayout, QDialogButtonBox, QHBoxLayout, QLabel, QSpacerItem, QSizePolicy
)

class OkayCancelDialog(QDialog):
    def __init__(self, title: str = 'Select an Option', okay_text="OK", cancel_text="Cancel", width=300, height=50, parent=None):
        super().__init__(parent)

        # Set dialog properties
        self.setWindowTitle(title)
        self.setModal(True)
        self.setFixedSize(width, height)

        # Main layout
        main_layout = QVBoxLayout(self)

        # Add vertical spacer for alignment
        main_layout.addSpacerItem(QSpacerItem(0, 20, QSizePolicy.Minimum, QSizePolicy.Expanding))

        # Button box with OK and Cancel buttons
        self.button_box = QDialogButtonBox()
        self.ok_button = self.button_box.addButton(okay_text, QDialogButtonBox.AcceptRole)
        self.cancel_button = self.button_box.addButton(cancel_text, QDialogButtonBox.RejectRole)

        # Connect button signals
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        # Horizontal layout for centering buttons
        button_layout = QHBoxLayout()
        button_layout.addSpacerItem(QSpacerItem(20, 0, QSizePolicy.Expanding, QSizePolicy.Minimum))
        button_layout.addWidget(self.button_box)
        button_layout.addSpacerItem(QSpacerItem(20, 0, QSizePolicy.Expanding, QSizePolicy.Minimum))

        # Add button layout to main layout
        main_layout.addLayout(button_layout)

        # Add another vertical spacer for alignment
        main_layout.addSpacerItem(QSpacerItem(0, 20, QSizePolicy.Minimum, QSizePolicy.Expanding))

        # Set the final layout
        self.setLayout(main_layout)

```

`scripts/plugins/ida/binlex/gui/progress.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QProgressBar, QWidget

class Progress(QMainWindow):
    def __init__(self, title='Progress', max_value=100):
        super().__init__()

        self.is_closed = False

        self.setWindowTitle(title)
        self.setGeometry(100, 100, 300, 100)

        self.central_widget = QWidget()
        self.layout = QVBoxLayout()

        self.progress_bar = QProgressBar()
        self.progress_bar.setMaximum(max_value)
        self.layout.addWidget(self.progress_bar)

        self.central_widget.setLayout(self.layout)
        self.setCentralWidget(self.central_widget)

    def set(self, value: int):
        self.progress_bar.setValue(value)
        QApplication.processEvents()

    def increment(self, value: int = 1):
        """Increment the progress bar by the specified value."""
        current_value = self.progress_bar.value()
        new_value = min(self.progress_bar.maximum(), current_value + value)
        self.progress_bar.setValue(new_value)
        QApplication.processEvents()

    def closeEvent(self, event):
        """Handle the window close event."""
        self.is_closed = True
        event.accept()
```

`scripts/plugins/ida/binlex/gui/scan_minhash.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


from PyQt5.QtCore import Qt, QBuffer, QTimer, QByteArray
from PyQt5.QtGui import QMovie
from PyQt5.QtWidgets import QLabel, QDialog, QVBoxLayout, QDialogButtonBox, QDoubleSpinBox, QSpinBox, QLineEdit

class ScanMinHashInputDialog(QDialog):
    def __init__(self, parent=None):
        super(ScanMinHashInputDialog, self).__init__(parent)
        self.setWindowTitle("Scan MinHash")
        self.setModal(True)

        layout = QVBoxLayout(self)

        self.minhash_label = QLabel("MinHash String:")
        self.minhash_input = QLineEdit()
        layout.addWidget(self.minhash_label)
        layout.addWidget(self.minhash_input)

        self.byte_count_label = QLabel("Number of Bytes to Scan:")
        self.byte_count_input = QSpinBox()
        self.byte_count_input.setRange(4, 1024)
        layout.addWidget(self.byte_count_label)
        layout.addWidget(self.byte_count_input)

        self.threshold_label = QLabel("MinHash Similarity Threshold (default: 0.75):")
        self.threshold_input = QDoubleSpinBox()
        self.threshold_input.setRange(0.0, 1.0)
        self.threshold_input.setSingleStep(0.01)
        self.threshold_input.setValue(0.75)
        layout.addWidget(self.threshold_label)
        layout.addWidget(self.threshold_input)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def get_inputs(self):
        return (
            self.minhash_input.text(),
            self.byte_count_input.value(),
            self.threshold_input.value()
        )
```

`scripts/plugins/ida/binlex/gui/scan_tlsh.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from PyQt5.QtCore import Qt, QBuffer, QTimer, QByteArray
from PyQt5.QtGui import QMovie
from PyQt5.QtWidgets import QLabel, QDialog, QVBoxLayout, QDialogButtonBox, QDoubleSpinBox, QSpinBox, QLineEdit

class ScanTLSHInputDialog(QDialog):
    def __init__(self, parent=None):
        super(ScanTLSHInputDialog, self).__init__(parent)
        self.setWindowTitle("Scan TLSH")
        self.setModal(True)

        layout = QVBoxLayout(self)

        self.tlsh_label = QLabel("TLSH String:")
        self.tlsh_input = QLineEdit()
        layout.addWidget(self.tlsh_label)
        layout.addWidget(self.tlsh_input)

        self.byte_count_label = QLabel("Number of Bytes to Scan:")
        self.byte_count_input = QSpinBox()
        self.byte_count_input.setRange(50, 1024)
        layout.addWidget(self.byte_count_label)
        layout.addWidget(self.byte_count_input)

        self.threshold_label = QLabel("TLSH Similarity Threshold (default: 100):")
        self.threshold_input = QDoubleSpinBox()
        self.threshold_input.setRange(0.0, 512)
        self.threshold_input.setSingleStep(1.00)
        self.threshold_input.setValue(100)
        layout.addWidget(self.threshold_label)
        layout.addWidget(self.threshold_input)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def get_inputs(self):
        return (
            self.tlsh_input.text(),
            self.byte_count_input.value(),
            self.threshold_input.value()
        )
```

`scripts/plugins/ida/binlex/gui/search_database.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (
    QLabel,
    QDialog,
    QVBoxLayout,
    QLineEdit,
    QComboBox,
    QDoubleSpinBox,
    QSpinBox,
    QDialogButtonBox,
    QHBoxLayout,
    QPushButton,
    QCheckBox,
)
from lib import IDA
from lib import BLClient

class SearchDatabaseDialog(QDialog):
    def __init__(self, databases: list = ['default', 'goodware', 'malware'], parent=None):
        super(SearchDatabaseDialog, self).__init__(parent)
        self.setWindowTitle('Binlex Database Search Options')
        self.setModal(True)

        self.setFixedWidth(500)

        layout = QVBoxLayout(self)

        url = IDA().get_registry_value('url')
        api_key = IDA().get_registry_value('api_key')

        try:
            if url is not None and api_key is not None:
                client = BLClient(url=url, api_key=api_key)
                status, response = client.databases()
                if status == 200: databases = response
        except:
            pass

        self.url_label = QLabel('Server URL')
        self.url_input = QLineEdit()
        if url is not None: self.url_input.setText(url)
        layout.addWidget(self.url_label)
        layout.addWidget(self.url_input)

        self.api_key_label = QLabel('API Key')
        api_key_layout = QHBoxLayout()
        self.api_key_input = QLineEdit()
        self.api_key_input.setEchoMode(QLineEdit.Password)
        if api_key is not None: self.api_key_input.setText(api_key)
        api_key_layout.addWidget(self.api_key_input)

        self.api_key_toggle_button = QPushButton('Show')
        self.api_key_toggle_button.setCheckable(True)
        self.api_key_toggle_button.clicked.connect(self.toggle_api_key_visibility)
        api_key_layout.addWidget(self.api_key_toggle_button)

        layout.addWidget(self.api_key_label)
        layout.addLayout(api_key_layout)

        self.database_label = QLabel('Database')
        self.database_input = QComboBox()
        self.database_input.addItems(databases)
        self.database_input.setCurrentText('default')
        layout.addWidget(self.database_label)
        layout.addWidget(self.database_input)

        self.minhash_score_threshold_label = QLabel('MinHash Score Threshold')
        self.minhash_score_threshold = QDoubleSpinBox()
        self.minhash_score_threshold.setRange(0.0, 1.0)
        self.minhash_score_threshold.setSingleStep(0.01)
        self.minhash_score_threshold.setValue(0.75)
        layout.addWidget(self.minhash_score_threshold_label)
        layout.addWidget(self.minhash_score_threshold)

        self.mininum_size_label = QLabel('Mininum Size Threshold')
        self.mininum_size = QSpinBox()
        self.mininum_size.setRange(32, 2048)
        layout.addWidget(self.mininum_size_label)
        layout.addWidget(self.mininum_size)

        self.size_ratio_label = QLabel('Size Ratio Threshold')
        self.size_ratio = QDoubleSpinBox()
        self.size_ratio.setRange(0.0, 1.0)
        self.size_ratio.setSingleStep(0.01)
        self.size_ratio.setValue(0.75)
        layout.addWidget(self.size_ratio_label)
        layout.addWidget(self.size_ratio)

        self.chromosome_minhash_ratio_threshold_label = QLabel('Chromosome MinHash Ratio Threshold')
        self.chromosome_minhash_ratio_threshold = QDoubleSpinBox()
        self.chromosome_minhash_ratio_threshold.setRange(0.0, 1.0)
        self.chromosome_minhash_ratio_threshold.setSingleStep(0.01)
        self.chromosome_minhash_ratio_threshold.setValue(0.75)
        layout.addWidget(self.chromosome_minhash_ratio_threshold_label)
        layout.addWidget(self.chromosome_minhash_ratio_threshold)

        self.combined_ratio_threshold_label = QLabel('Combined Ratio Threshold')
        self.combined_ratio_threshold_input = QDoubleSpinBox()
        self.combined_ratio_threshold_input.setRange(0.0, 1.0)
        self.combined_ratio_threshold_input.setSingleStep(0.01)
        self.combined_ratio_threshold_input.setValue(0.75)
        layout.addWidget(self.combined_ratio_threshold_label)
        layout.addWidget(self.combined_ratio_threshold_input)

        self.gnn_similarity_threshold_label = QLabel('GNN Similarity Threshold')
        self.gnn_similarity_threshold_input = QDoubleSpinBox()
        self.gnn_similarity_threshold_input.setRange(0.0, 1.0)
        self.gnn_similarity_threshold_input.setSingleStep(0.01)
        self.gnn_similarity_threshold_input.setValue(0.75)
        layout.addWidget(self.gnn_similarity_threshold_label)
        layout.addWidget(self.gnn_similarity_threshold_input)

        self.limit_label = QLabel('Limit (Function Top-K)')
        self.limit_input = QSpinBox()
        self.limit_input.setRange(1, 32)
        self.limit_input.setValue(3)
        layout.addWidget(self.limit_label)
        layout.addWidget(self.limit_input)

        self.exclude_named_functions = QCheckBox('Exclude LHS Named Functions')
        self.exclude_named_functions.setChecked(True)
        layout.addWidget(self.exclude_named_functions)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

    def toggle_api_key_visibility(self):
        if self.api_key_toggle_button.isChecked():
            self.api_key_input.setEchoMode(QLineEdit.Normal)
            self.api_key_toggle_button.setText('Hide')
        else:
            self.api_key_input.setEchoMode(QLineEdit.Password)
            self.api_key_toggle_button.setText('Show')

    def get_inputs(self):
        return (
            self.minhash_score_threshold.value(),
            self.mininum_size.value(),
            self.size_ratio.value(),
            self.chromosome_minhash_ratio_threshold.value(),
            self.combined_ratio_threshold_input.value(),
            self.gnn_similarity_threshold_input.value(),
            self.url_input.text(),
            self.api_key_input.text(),
            self.database_input.currentText(),
            self.limit_input.value(),
            self.exclude_named_functions.isChecked(),
        )

```

`scripts/plugins/ida/binlex/gui/svg.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import json
from PyQt5.QtWidgets import QApplication, QWidget
from PyQt5.QtGui import QPainter, QColor, QWheelEvent, QMouseEvent, QTransform
from PyQt5.QtCore import Qt, QPointF, QRectF
import xml.etree.ElementTree as ET
import idc
import ida_kernwin

class SVGWidget(QWidget):
    def __init__(self, svg_string: str, title: str = 'SVG Widget'):
        super().__init__()
        self.svg_string = svg_string
        self.title = title
        self.elements = []
        self.svg_width = 800  # Default width
        self.svg_height = 600  # Default height
        self.init_ui()
        self.parse_svg()

        self.scale_factor = 1.0
        self.min_scale = 0.1
        self.max_scale = 10.0
        self.last_mouse_pos = QPointF()
        self.dragging = False
        self.offset = QPointF(0, 0)

        self.current_hovered_element = None

    def init_ui(self):
        self.setWindowTitle(self.title)
        self.setMinimumSize(400, 400)  # Ensure minimum size
        self.resize(600, 400)  # Set initial modest size
        self.setMouseTracking(True)

    def parse_svg(self):
        try:
            root = ET.fromstring(self.svg_string)
            namespace = ''
            if '}' in root.tag:
                namespace = root.tag.split('}')[0] + '}'

            # Get SVG dimensions and ensure they're integers
            self.svg_width = int(float(root.get('width', '800')))
            self.svg_height = int(float(root.get('height', '600')))

            # Ensure dimensions don't exceed a predefined maximum
            max_width, max_height = 800, 600  # Example maximum sizes
            self.svg_width = min(self.svg_width, max_width)
            self.svg_height = min(self.svg_height, max_height)

            # Optionally, resize only if the dimensions are smaller than the initial size
            if self.svg_width <= 600 and self.svg_height <= 400:
                self.resize(self.svg_width, self.svg_height)

            for rect in root.findall('.//{}rect'.format(namespace)):
                x = float(rect.get('x', '0'))
                y = float(rect.get('y', '0'))
                width = float(rect.get('width', '0'))
                height = float(rect.get('height', '0'))
                fill = rect.get('fill', '#000000')  # Default to black
                address = rect.get('address', None)

                # Handle `rgb(r,g,b)` syntax
                if fill.startswith("rgb("):
                    try:
                        rgb_values = fill[4:-1].split(",")
                        r, g, b = map(int, rgb_values)
                        color = QColor(r, g, b)
                    except ValueError:
                        color = QColor("#000000")  # Default to black if parsing fails
                else:
                    color = QColor(fill)  # Assume hex color if not `rgb`

                self.elements.append({
                    'x': x,
                    'y': y,
                    'width': width,
                    'height': height,
                    'color': color,
                    'address': address
                })
        except ET.ParseError as e:
            print(f"Error parsing SVG: {e}")


    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        transform = QTransform()
        transform.scale(self.scale_factor, self.scale_factor)
        transform.translate(self.offset.x(), self.offset.y())
        painter.setTransform(transform)

        for elem in self.elements:
            painter.setBrush(elem['color'])
            painter.setPen(Qt.NoPen)
            rect = QRectF(elem['x'], elem['y'], elem['width'], elem['height'])
            painter.drawRect(rect)

    def wheelEvent(self, event: QWheelEvent):
        zoom_in_factor = 1.15
        zoom_out_factor = 1 / zoom_in_factor

        # Determine zoom factor based on scroll direction
        if event.angleDelta().y() > 0:
            zoom_factor = zoom_in_factor
        else:
            zoom_factor = zoom_out_factor

        # Compute the new scale factor
        new_scale = self.scale_factor * zoom_factor
        if new_scale < self.min_scale or new_scale > self.max_scale:
            return

        # Calculate the center point of the widget in scene coordinates
        center_widget = QPointF(self.width() / 2, self.height() / 2)
        center_scene = self.map_to_scene(center_widget)

        # Update the offset to maintain the center
        self.offset -= (center_scene * (zoom_factor - 1))

        # Apply the new scale
        self.scale_factor = new_scale

        # Trigger a redraw
        self.update()


    def mousePressEvent(self, event: QMouseEvent):
        if event.button() == Qt.LeftButton:
            self.dragging = True
            self.last_mouse_pos = QPointF(event.pos())
        elif event.button() == Qt.RightButton:
            scene_pos = self.map_to_scene(QPointF(event.pos()))
            rect = self.get_rect_at(scene_pos)
            if rect:
                address = rect.get('address')
                if address:
                    try:
                        ida_kernwin.jumpto(int(address), ida_kernwin.UIJMP_DONTPUSH)
                    except ValueError:
                        print(f"Invalid address: {address}")

    def mouseMoveEvent(self, event: QMouseEvent):
        if self.dragging:
            current_mouse_pos = QPointF(event.pos())
            delta = current_mouse_pos - self.last_mouse_pos
            self.last_mouse_pos = current_mouse_pos
            self.offset += delta / self.scale_factor
            self.update()
        else:
            scene_pos = self.map_to_scene(QPointF(event.pos()))
            rect = self.get_rect_at(scene_pos)
            if rect != self.current_hovered_element:
                if rect and rect['address']:
                    tooltip_text = f"Address: {hex(int(rect['address']))}"
                    self.setToolTip(tooltip_text)
                    self.current_hovered_element = rect
                else:
                    self.setToolTip('')
                    self.current_hovered_element = None

    def mouseReleaseEvent(self, event: QMouseEvent):
        if event.button() == Qt.LeftButton:
            self.dragging = False

    def mouseDoubleClickEvent(self, event: QMouseEvent):
        if event.button() == Qt.LeftButton:
            self.scale_factor = 1.0
            self.offset = QPointF(0, 0)
            self.update()

    def get_rect_at(self, pos: QPointF):
        for elem in reversed(self.elements):
            rect = QRectF(elem['x'], elem['y'], elem['width'], elem['height'])
            if rect.contains(pos):
                return elem
        return None

    def map_to_scene(self, pos: QPointF):
        x = (pos.x() - self.offset.x()) / self.scale_factor
        y = (pos.y() - self.offset.y()) / self.scale_factor
        return QPointF(x, y)

```

`scripts/plugins/ida/binlex/ida-plugin.json`:

```json
{
  "IDAMetadataDescriptorVersion": 1,
  "plugin": {
    "name": "Binlex",
    "entryPoint": "main.py"
  }
}

```

`scripts/plugins/ida/binlex/lib/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from .worker import Worker
from .blclient import BLClient
from .ida import IDA
from .text import BANNER
from .text import CREDITS
from .assets import LOGO
from .assets import MOVIE
from .styles import QPUSHBUTTON_STYLE

```

`scripts/plugins/ida/binlex/lib/assets.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

MOVIE = 'eJxF/XVYFP8b94FuwtJLL710xtIVLt0d0t0lGSLqLt3dJZ0hLSDoktLSJfIFBKRE'
MOVIE += 'UFRElMPveZ5zznXtHxszn7nnM7Ozs/f9vl9vDS11aRnHJuAF4NcFAAACACD4AHwE'
MOVIE += 'GAjDBwDwCaEEJAKkYBoychIqMJRGjIQWCULQI+kZEMz8rGxCaE48Am4eLn4BYgEq'
MOVIE += 'qAgUJmZEISEp/iC5SIlDUelJozIrsQo9u4qqskpkjtaTGu3wRt2oFn00u5GJoVFo'
MOVIE += 'hUlQhimEyDSm1ty/yYKS1wLb5uBk7yxL5qpr4BFd55H5xvsZz6MAv4DcvqA7zdD6'
MOVIE += '16F3CuF+geH5TRHW9hF3KEzUc0zVOOZOK+rONPruQUwQf+ytU+JCdXLdcMq3uFQh'
MOVIE += '1zRblnQFs4y09ozM9Mx/lvmdC/n/PAuUkoqNnhX/e1wmH/6iZ7Zc1re88kX5HX9V'
MOVIE += 'q1ONZEiNZEyN1JMGAcUGCaeGka1GiYCmf1EvxXxf6se3dbR13uV21Xt3v1vv4Y/o'
MOVIE += '9cgfdMh9u3z09q5+6K50ZGx4LKJmYnZn8uvsFKHI1Nre7N2r92md75uVl7yfLVe+'
MOVIE += 'XV5dWplbWrmb2Cx5++HwYiu+++Pp8U7/+5274927mT0GtU9A7k8He/t3mwedy0ey'
MOVIE += 'SkfzH49Pj8/GZM+mPp7nl56/f/X17+3FHeDy6vr71eVVlMHVJOLq+MuPV2I/ti9+'
MOVIE += '3H39aWj/Kzb+16LXr39d1z7x151k1zufr//eXf/bvb4D/D7M/v3n+vet5g0AcQNg'
MOVIE += 'u+FTu1nHv7l9ePNP/Oaf580d85+BiT/LibcAyO3T1Ns3RrfT728/z/8FwP/SSf41'
MOVIE += 'e/S3mu9vA+PfdrG/XWp/1wv+fn779zvD379P/96l/727/ecV+S/zxb96vH8v3/zr'
MOVIE += '6vs37PhvIujfdv2/7Y//vl//+/Hx383Xf38G/92+/3d79++u+k7Z+q6K7q4G/66m'
MOVIE += '/a4ZcDefere8effl193X9bvfrXc3gLs/v+/ugOLh7JJ6zvol6QbalMZtz+2G3J2e'
MOVIE += 'vXJxz/LfsgqxSn/6tDpKzi3OIK2sUbDhSWXTQUf7b1wHjr1348ngjebbO+SHOzq9'
MOVIE += 'VuHhBOkpNuj7LM59KOIzGckpLeSXFdPfFK5BXodpFj0hQk4zOnQIGUkhjHaUgQFw'
MOVIE += 'B2C9I9JXMzVRUTJUExVCgYEAAID1NwQKAVwABO6fA/73NQHA7gBhBIyabTtC6kZs'
MOVIE += 'VABcW4VKHHXHIFF8jEY2IYCUGOCAzRxKR6okMRJkkafEkglmIEX2Rl5RohQmSrQ6'
MOVIE += 'a2eLJWy3tKp5M5PJ6KL2GLWXDxOq2PMEAoxrCHPrDKu0S7W7G1eaLFoCscO5iSWa'
MOVIE += '6XNKj09iknkMXy426iVLmvJY+DsmOqmHGTdbDHxr3fzQtNb5FmdIkMclaLLrPNbK'
MOVIE += 'yzXZ2/7pXYYGRVEV2/DINDG5gOEFiFNFPFMlWShh/JsK3qZFT6Rl14/5csEpD+1v'
MOVIE += 'FTWGa73ebEysflomdZbRRCz68ifmXI/YOIsk3Zopa22+DVm97vnyoTfoWPR1cf7a'
MOVIE += 'ttnTO8W7P9QIM/7heEph5tk3g38y7fievClBDqnH822fus9ojt4CQdXjFIZ91Dw5'
MOVIE += 'BBzz6uVYvPNDIMEg8OFWDJU5TI0+jqdKVyTcp2YsyGB3ScN6xZI232bTN/5hWORv'
MOVIE += 'qMXjz+R5BBKnX9w/pVbqhcZASRx+woEEM9hPGdDHuxvqwKwdrC/xXuiHKD2aBFPD'
MOVIE += 'nQSwU6yFW2Iu49RFFxGzs9LQWLxBAJYs0aMdmmTN7aaxZssfgW9nHw9YSnL4rOeM'
MOVIE += 'EEmvr2PNxODRL5LzWbQtVJD4jmLjymBJzp5A1YgjMFj9eD/bwMqKCsudAtjNNY9p'
MOVIE += 'PKi3fHNZx+pMOpRL4xKXVFvkbXeHn8/jNzy5VzLIuDglkt61qM015pJFILJ8ZVlV'
MOVIE += 'NUE4NcEYhIMDQYmgHbUOFYpK5UrNVlWT2qK5Ud9XLwl+7BMciEP5Go5o1tQ4xnSX'
MOVIE += '1Ew/WwUc8lcY5udZry1onxYHRGhohbfA9t3bhkGn3N0w/ie+bs85UpxJeZimMITa'
MOVIE += 'ogTnY7T/hUY9qqw9FQkIh4iqD5iU5rol+kzVCL/9+PvPI+F6RgF/R7zps4vZP38d'
MOVIE += '6UBGO5FVtAoUgH31Br3Ey4WiHkgU/k4Okc07Fg1b6knT3U/xgz41zYGhPSc/AoXf'
MOVIE += 'Av58nhnWd+587/GK22VT8mQg8ymQEemgo7nGxPmRXJvn/nITdafZHcDuxOT95k9H'
MOVIE += '8xpfzi1RyjqEWiVo1kdDyKoqR+ecmZWRkR4DCPT2/vW5T6FQ6r/q7IMwf/MXxE2r'
MOVIE += '/E3r3+xyYp6eScRR+/Qc9GqYPz7P9q7qA2hFCQ1446ftBB9PkOFDaX4vJ4u+We/z'
MOVIE += 'XGsZ1DSZEXlNrDvz6dX7uT+/dr6GQXqAFv45ulzEL//10Of/kTJ/310UmadfIyR9'
MOVIE += '6tf/bJLzvcuea+roBXVETKzC19ivGFiMLimCjRdg6MV5bP0C8s6MFK7kK/21mAWv'
MOVIE += 'Hd5LMcYXwbtHKlwmQoIVwKcuRGgCnE3bQPQoLMcGE3FAPB6eujaAzHQRwq35qjZx'
MOVIE += 'N4qeuJLyrhxDZiH9KKSDz8b2IjBBA6ZK8e5aTRjElUHdgaJ8N7FH5C5NYYDaS2a+'
MOVIE += 'dEL0hYsJo5uwZFsV9AoOIH//FGkXTRW82AJq+I9dr/fgitAzimQzxCmiHvbeCeTB'
MOVIE += 'TOdolOziM8Ny6A8ht8CByBOqOQRxWMZwR9J0pCpbttkIHinGWPT3Kr1ID3JbYCwK'
MOVIE += 'nUNIJ+6YEDabmWbeMEzdWksoviusFslYIV69nm9D8k0fLF9NJEWQxSgNEFP+Tq6i'
MOVIE += '6h/DPu9Ibs1x6HEIF1cl4ImqorLD2zxiaJXG5+fkUOFzLKQ2UvucwLPELhZYmK+z'
MOVIE += 'Q4iwHKAsc1Gt6tQyQUpysFTSZ93NxKsuFjoP1D05dKBPJOApPhVTemTB+aBJdRj+'
MOVIE += 'kuOz2cVQ3B9Oowi2/Vi5JzJl5gCw+lUKl8iv48lXmTnVpIk48nm4ITZp3LdIJZWU'
MOVIE += 'nE+e8sKtxFRklIGNz6jJBlhq+fqIWazfKC0Lvzq2oU5zMhxTS9gCIEpoNKX1r671'
MOVIE += 'Ui2EJmAIVw8XGV1JjcDSPHreVml+zzr5Qnc8DepWh06qm0Navd2TbcTLHvu9tPg5'
MOVIE += '4A4sp89MjPn0kuq3kvT2ZRohwhwIu05PZ8sA56W1NKVajj4EtmW0zeXU6jRZ4xWF'
MOVIE += 'tjYmZAtI/7V4p85g1ShdkdBYtWaduy4RNqclHyLI4XjRbyp0920HX35niDT0NZj+'
MOVIE += 'Kg8PlztEGqiz9dYN3F40QgxCfED9mrjApFgUkAgaFn8POOk3lKUnsCoHG1nx8YyL'
MOVIE += '0fKteW0uOtU8fs/OuJaQxE/7lMqgBRn3xYtIhf4K0Hs9+/LZj+RoZqQSgXb4uwDa'
MOVIE += 'ysxnbNoQo3kXD9y1mtDwjqhaFUFo55Mumq1d7nLvzaUZuQdvG0K86hU2dtxqRo8n'
MOVIE += 'qR8KR71k/a4987f/eux6DEgaOQ1mZXz4gtQTgI/+hFAPV8rKnMFGUUorxkMecdVA'
MOVIE += 'PoZ+9ccnzM4qruZ8Gf/82tHob0b0jw7O4p3+0vPevKpPvOk+0+r/QYavZ4Y+YolX'
MOVIE += 'BcC3U5g7/N0JdSibm0McKpRUUBCmLF2+jndx3dcnN/yc2SNKWWV+ngN3OObTlo2U'
MOVIE += 'pvPcc1DOqSHe5IsmZOFiJ7/q6XmnNdCaf04tRvQa31K8mP6tQu/XFKzc1pB2+Ryp'
MOVIE += '5Tl50Ws55es6gHukJjAC72jrMfYFcTsgO17hTHUdF0Tb2cZFU3Gk8ZyWZydDPD62'
MOVIE += 'PjYIMpy7hFcZnFG/XfGMfkaj1N1R8+OKydvwV76kfv4butFSj5RwROhDdTgA/I5w'
MOVIE += 'nyxus8mJTloQUcm6RryLZh4YpSzLAW7sZOkZ9DfNlqM1H2XTsNFdwBNtIU6mdWNV'
MOVIE += 'Ieb8CgadR957rOm9kzaHF4V/9oXvytqJc3ZSCUc/xMVTWEEckNUzChAgCcxKhQ3l'
MOVIE += 'AvlnHQROwDGVP47nppKHza6aEkW1ZasKzL6mY6cdbUoR4lmviAERQGjrt0V49lU+'
MOVIE += 'cbEFvPu0vE3Lmrt/oN63+b3Yj34rFBesn/ggVgB+LJSdvKx7qM6GipdktJZMbgN+'
MOVIE += 'FMpTpDgqJyZm2SYoCB3QHhElsfhvjGEuifOPr3yEszt5vcq/bf6OghRvsr/9a/I2'
MOVIE += 'HKMyazy+CVAP27B4KkwTQbD1A4byKKJgHJ6rpuxiWesb8vUum7R4Tkq+VgJXVEUF'
MOVIE += 'lRNhhPDLuZCsQbUSFpl9G76b+a+S42/+YuE7LTOw/ce0cV6wO+KJiYSLD4YMTEfo'
MOVIE += 'ytNVn/oHfanUMz+343A1rmLYb1SBhLR8jceSude/eWjcFn89tjF96h321OcdWBQD'
MOVIE += '1swgmVp+hCeCX7YAUKB9wgbwAZaTrO/74Bl7iLWHn79T3KKI8qk2fKjsunwI0S1n'
MOVIE += 'DfZ/fpxF1j0aWdKj+ooCwyblhhet+csF82fMTx4NbqqFWOPA0kjwrwNrrx7wgx2M'
MOVIE += 'ojKW1TGIOABSHIxFxz9jKrcUvIAI7vAK7j4xrPNY7cbOcVHt4EKYP0HoAgOqRGkO'
MOVIE += 'RYUbqQmfIUNZVUOR+U7RRoj08mi5ieg/uV4/Oe8HxHPDQLwOrYcknB9gyKdcgGzk'
MOVIE += 'UNK7IeB/8WgJQLCWk8iOMsi3jShsHpRb+YRNmjKam1JdhYodQLqPfF55AHlkSCyX'
MOVIE += 'K3TjrtoIJcpGxm9mGgVxYkq52R9L6y6OxtfjxYj1gLUvoCEAmDXGTw3hLI8h/0MV'
MOVIE += '1lbnLrkMaJZS4VJSPKJN0qLEe94BE0FLldUzaLRT7MGS1sMpueaB5lFJRyA22wy8'
MOVIE += 'xTghnAhbBZJwAAOLh8fzicVLJBCOljMvIUkOydkX25IHzTFvPOyHxsDWO3hFSAL7'
MOVIE += 'ebBXbaDfIWYyF/x4Df57wZsoO+h5nqYaDe9PoDZtNmTsFSJsJ9WQNm3zAuAe7LIq'
MOVIE += 'QaVA9Zz3yNH9CKKCNsq/wxBm7RBeS0fHVRk1zRNmIQkgmQQgVUQ6Djaw7oRf6EV4'
MOVIE += 'jDeJhPu1gZtW/cy1wA8wESTzjzx26F7SUrzFA5DgxH5RQd1NWe5vpjnW6WUBevRZ'
MOVIE += 'MCVMlmp7FghtzPbbY29P0KxDyogm4BTxgI8H/x06ZwxFQJv74GyFaBRdwBfDDG7I'
MOVIE += '4Xwnh59o74bKSTTCf7sSrY3OJB4CtLmH0f0mD8rwZkMaunGIZynzChfm95GD9eqQ'
MOVIE += 'nxZj+duziAHB9b+1KrrylB3l3RCR75VIdf2fu68UX4hBbB3wM8vxU3CU8RjheBna'
MOVIE += '7J2AiEx+IdOsIVFYCmVhn1ghrhv6pByBmYeg7vASCHFoCAALEsFvl0wFK8FkaYFQ'
MOVIE += 'ApU6T5VGAqoqCyTXPJ6jYdqKGminLatHK3ET96J3yLL1CPKjDj9rnNoVG3maUJLp'
MOVIE += 'T/q5DXH7yvMmi4nrUBRnyP7FmHgcZPkaV/rGFe91G4G7v33hsZvcDgmvWRZEKZYY'
MOVIE += 'WwYZgkHNANS9Wh7lQTmcgFynxD4jD8lYSo62rD43lleFRfkrHH4xUVfR5YlGkYE7'
MOVIE += 'es7lcU++44XiIPvl+KkU+JY9nmIeyQlLRBu/LVz647MTwdqG+O4ZlTcSNiUEAGPN'
MOVIE += '2tLgMCSwCjCfuQjhXagnWaspZpyg4LgAhNDxEgdU109W5YpSUUdTbt2NVlPvQU5F'
MOVIE += 'JdNxkM8oGI0U5MRC/9kIJFEExvpT6SSnom3pAZKegi0JPFxQ6JtvP+1RFnxBLn4C'
MOVIE += 'P+OFk63CBw6Nr9UVIfSyW6LV0drG7i56sDBK9nmQCBwsiKFkgbPqyULC56X1TSM9'
MOVIE += 'd8qr96RCywnGUHgWhhVW2eni4dI7WEKdhtKdkVKFDD81nszbH+CDjULXzQiSTDDy'
MOVIE += 'MhOAAYjy6RUEVePh6jTFQIiLpkcqAKsfmRCMCtyUir0cLB+AL5JRrAykPC5oYHZr'
MOVIE += 'cCkicGJrvwCzYdtg4TtU06+4/n32lQiHOd+07k9Jst0kn/ZYwx9bK18EAtp4kOR5'
MOVIE += 'oT+fBt1twtn8q4qXWXChLnmV9NgkY5g/JGan7JUnQDAg7T8eyqlaAl940mou0PWg'
MOVIE += 'fmRBxBYOO9vjJpyKQzDomKIC1g8hz+Zr/r0SPuPgfgokHr14UMMH5yWyMdNy7uN0'
MOVIE += 'EIpnYTOqCi8qmwpp6o/G04BDjS5ehdO8UBnulNzv1GNLI8MY88HVs7vJ3+BXtzoG'
MOVIE += 'j/2CnGoglZVA50vdBiKRzmIknzENlcolRTch7QmPdSCYZ6wkPh96HjXZN+QlmMZi'
MOVIE += 'AYZFrLsJe7/IYwD+pJmdmdhHd+02NDvQTnqe7ggevD+dHIbFf6iAz9Xbevs4hAmy'
MOVIE += 'BXfyxnvqXy0A6fECKCujDGTh5Hfa2cbfVVyAUOynmpagnkhWOS5++Ccr+0cfrPXp'
MOVIE += 'SC9ryXMP4CkIiqoNOMmFTUp5lVTYSzYl2GGdLt8ONFOagwgSLFMt6N0AmvlgUHGs'
MOVIE += 'BoUiZWP6WitS6bPwH9ZzJLqBZMvB/yzNt6y79VEVQlaRmRdpJafdVclWdictJ68J'
MOVIE += 'z+Qovnq7PXqNkfa3vqQpJ8EC3lvAoVBApBxcRfc1WwYO6hg2pWrJV9MpI4Z/CRSE'
MOVIE += 'IHlxzgCLlDGjP4JKAbp/TEdD3S1FhrCakiAlw8j1IH9+R7Alyl8kw0OHkPpE8zlD'
MOVIE += 'Jb4RvGWsPM70T35dtGu5bLT7NNFKJ1HLH3LL4JFddueXd03WMwW6vXkWZpE8Czfk'
MOVIE += 'V5uAx6HeT6DgAf48kA38OYbuzyGcRqtX4dBZAxA7laOLRwPcNBTX7aBILrYRpc+L'
MOVIE += 'F5XK5HcM1wKFtRFBqfAMHAZdkUnMaKEn8owWr01UcBAsJiTCP6n6dLgyCsoV/QAh'
MOVIE += 'q7CTqRy79ab4qr95HBw8DgzGCdBaWIIdXrc1VgVrwHunyaed6oghYO3ITvlPUCND'
MOVIE += 'Or0UAB9gLF0En20eULE12uXdJrvf1Br2EjpTBWNL+tzZRfoLAt2tTISDkTyU5Nas'
MOVIE += '4Rdp70XwHtYRByL7J8S4rDB2r0xplyjxF+c5ff+Qy/nH8H4AfzWsh+zEgCtA+3e6'
MOVIE += 'o9F7EbD5zBQ0Dx/aW6ZtMnLNm2LirUI8HsoBeFcyl6EE0/AfBfxdvuJFRk+h1QaI'
MOVIE += '5ovpT8IUX08p9t/Oc27gaRGyPsrxHfOBqqBqxhzwmT8OWw0ZLm1FhgUQvKag4K2e'
MOVIE += 'tameENQD61qMfXrFnHLRi7ah0Ch5y57Z1M/1EikyGiBblUM+ReIP0T6bhN8uT1Nr'
MOVIE += 'pUNc/hHPg3EAE6ZYvEv8+l+Ad24g66NYJe1xkYzhsYdZeTpSWqfAmcY0V4WapUYl'
MOVIE += 'fSTTkTV/exv/V2+YhO5EKJOiMRL6q7sxMtx+w6F6MVAgJsOGUpfejuCF3V9yeBAd'
MOVIE += 'G6qJaAaFVKIDDASV3unCZ6PMYA5APgct7RQ4CsnS5V1/qAt/95qcbH7q22BWSzNH'
MOVIE += 'cwNDgSa8yVc56vPmPFc2l3w/SIjPEIO/Pp7/kI2NplGVvTp+J5lw3xG2xK1XUg47'
MOVIE += 'R299ifNTD7cXUCjzWXWbSOV56QU/nYGbKcBlNuHJswgPQ1zp45fPy6uYFrxj4NCP'
MOVIE += 'epaMgDGu9snCdufo18vP29h/zZSppDr3eJqRAUh3yudbP3Y96tuEfgaRfvsPabxq'
MOVIE += 'vJD/LFG+EjTizwpLgKPj4fgiI8nrS4TC34iiRXZdYkh8zkm/IKF0ZV7Pwr288+xZ'
MOVIE += 'n7EoCcBDkwBjr4lmK0HcihR/KywybOEbXzbY7to/tebTHW3wRDR651JtpA19LAjY'
MOVIE += 'O09xLk+hdzJjcC8ZPucnILLeXHMt9/loYoNM79wjLH82MjZPGO8Pc1d0g1wrlOAO'
MOVIE += 'ff8dfuazCfLzOv4ZHfaPDsn6JFiW4/vvBAXapkO6I8gl/rs/8DWFJcUOs6x/rzmZ'
MOVIE += 'O9umPv3meKT5Da1Z4d9ZpZYIWKWhpDJ+5ZgjyWpzjh/fliOfqTZ6QbxT6yQudtpn'
MOVIE += 'ctozd5iEOfXK9/obm/Gof0/tG/y/pzJQAS2mjdzW/FcsWLzIULqfsvhCdi/ZMj7/'
MOVIE += 'MfpSejZ30wPPHDhC0fIi2igEDSc2BM7H6YePP6nvhZxTLeKrQ2izL968Q5IM3s3b'
MOVIE += '7fGh0ih1syM7lgO/rvsTXp+TnuO+PiRwNuW9avi5+OtyS8yrbhHGIzcY5GwJ4H92'
MOVIE += '5NTwXszrU9fryZ0znnrddTxHbxL0dv6owAzFnLENjyxtEHEwgKx86MM1xGdgmtfG'
MOVIE += 'R94RzOSg/X7LpG7lWwUSNnqxfxdN2HTh6vmE+O5TgWv0xI+5793b11/Kv7rXno4k'
MOVIE += 'QK6pSXlzcSqpFNrP2d1485wn4SiUyzkj8On55L+F0fRUgecoFjAZnYch+H3l1Kvf'
MOVIE += 'gMJ6VkdkmgY5xNVhcOyh/2s4hOOChBmww2ffbQaAVgJoK+bxn5MdZBkSvy03Cvwm'
MOVIE += '+n7+tisoR7zqunfkeuvu6+FoS+DxuNvwNTQyA/Y2FvwA0BkpRHFl9dr8K3NcqfHs'
MOVIE += 'j7V/pjdqUV8YHe72ot9WE8NfQ0g5jrQolZRj5usB8/O7ABA4cCvxPi0aT04jXBve'
MOVIE += 'wWNUKRemyEWosqcaR76XZ+i4sXigUyDiOldt+b2GMvKpw1CSmT+tiHa70yVbv5fZ'
MOVIE += 'S7v3GFuTPIKVJfPFBD2FcdMNsxeW3X4HmxL8km2OY2lmy/pJOcziy4sZQypaparv'
MOVIE += 'JFmHWKPxsghJicKPp3ZZMTA7xGPOATM17FvYPOKWcvdRtExsmMQ/IkCcy4w1k9xM'
MOVIE += 'Jl0Ft3JwJePk7qtvKgkAZheX2Rs2AgqtqS4k+SetuwIkh1CRpufYK72doViy9/g6'
MOVIE += 'yy8bWV5qfeIM9lio0sx38/pBZbbcMNooNHyy8eeXrfNYusJBKxMpo3jEWUa7a3p1'
MOVIE += 'EyZ8uab908eRaRveBwJtCPldHvinrzDszyAY8A3suzI6vvL6feeDf9/IOh8cTrCC'
MOVIE += 'SOlhO11LyChNwEd5uAg7mXj/UTSVQJTgKLH8jm8iZ+O17/iuV1c7F3fbUVW6xk52'
MOVIE += 'dYG7k2NcoVZZtH6/p+FvKMKhdUT/tXfS8bkSXx/9V239Npma5tCIIyU8xpz1TwWN'
MOVIE += 'Jw7eLf5wf56ood4iFZXbxjOvtFnmKUeULL/OvJ7Ej0DDueEBABoN2TxLIlcfwNwp'
MOVIE += 'xZBKBXcZaShRBRhrW3d1qVHKonYXydCAupJcP6qQ5QKXGNALndbMfYST+bGzJlss'
MOVIE += 'WxJtVbWKGi9XaU4Swmuii9DQAX84cN1EX6QJnzHC37lczH+dVYE+x2KnQuGVctX7'
MOVIE += 'uDSUuEUM4q8OJPobYwa/8olPvZVf91QF66j0xUk6u0ACRkmTKam+YxmBdFzS/kMt'
MOVIE += 'Aqa8Hqwfo9S9zlGP8dQOdzT2bHTi5DHU2ue2U8VKrFp6pp5nqJQNma01RLScrAU3'
MOVIE += 'Mf50aZuSbeLT6rEwwCvwnKhlTRBATfAj6NHoWF8dZljclADShVZZoD7FvWXA9ZfB'
MOVIE += 'i+za0CaZPbUvRkX44XemAA0yfySolT18x5vYcv/qv3bBH2tLCLo8AkKuucefSLhK'
MOVIE += 'PHodRV8sTEobCTAbr7Jnfrv+ZN72hCPbiZC77/ir4XjHuuDHAPxCWw7PKMUCVxi+'
MOVIE += 'SBN5Qkrbg39o+SboXWC+Rw1TB+57VOV1Mu79U6dRj3hD7iMyYQHMkhEZ5bUOAIgI'
MOVIE += 'RzP4mse0dK+ivv0K3+eHunP2FT8MJ1ZpIxx93P05jyDddu9IhWrge1zuo9RM7alP'
MOVIE += 'nEplUxcj1u90A36G9OHB+wd0dfA43PRJtob9zO8OvdVYImjj5Gutgq6TCX8+hCtv'
MOVIE += 'tQI/JNH3+OcXkRHshA1VzV5o7gN3CQQeM+ja4UzZ7qpO2mMIlpCsBOxKCqck3PBH'
MOVIE += 'E/i/QrOkBkXAkd3fGH4X7VeflX/FlDn+19YRQ2LM4UznoZRu5dIW7a87zdr8gTXW'
MOVIE += '4XPGwpc9WC4vgHjTtB92+zLxuUPGLGE1CD8UBtoE4Eurt/HukadHe7t8SkBzxsGN'
MOVIE += 'h0gf8m6Jsy3EUm3D0q89dvX7paq1qDzNxRn/y/K7rtY4akuMPa4IT/qhol+yR1lj'
MOVIE += 'GCO3/46GjodVuGFhi43XRQiA9KW16/1YNI/kGdStT4QEw3oFVIU1OXFRnHwLUO6a'
MOVIE += 'TO3UltSJkQN8fcM0PpwRkRcRxJxQSsFozEha5pKdGMg78Ya6I3Jtw4yN5LPW8J14'
MOVIE += 'R2buWZZVeEZto2W5+/rWFIs2AeBW7zARxIcBy1W9ZWpszUXBqgbZ/CGyOd+AHEfo'
MOVIE += 'hNDfBphzdcahnA+Pdq4ZuFWHC6aQ0To5vJRUqxMEY7/Zm8vp9BiYjekXkTYikRKc'
MOVIE += 'gTSqxR/E06kWqyCPHFpZGeedNCvwtI3OQXhtXQ/BVpujvIEJD9jWKfnIq16S9k74'
MOVIE += 'ADlP8B6DdeNkHGELJuq7+xnv4nZVuecG1omrxN6kG2VXjV4cTaBPFi/KdbOqEZ5T'
MOVIE += 'WwE0ev84QY2QJoND+PgtLCaHkWKIcbzvbcgxFQCG45Z/adT/9Ny7Xo3Tp0bACVUt'
MOVIE += '5APzTFDlIM7E45HvujM1XAGpNRBqviEXrTLc8ODqvVl42W8a0FefJKRIPqmZF/XU'
MOVIE += '2ktDbvGkwud3dwv4+MWg0w3+UgkeEJUQZRsGEyeV2Cm1VFJRZQNVipH2tE135wwV'
MOVIE += 'xKNOSFgrRwLKgl/724ruLKhLB1T8EvAyu/TNK9oAfvGJDemw8VHWHmuD8GobJdns'
MOVIE += '71GlCpDJ5cCsSdtWBl6HewMJhhMGTqiA5IZAer8TsR0uPLz67BY0hYCStejDYdpj'
MOVIE += 'bmnDo+IobRrplNRRdgq6RCmfh34+O2VhIt4cs3uNWtgPuaFT3nY5Sn60ZhujosHt'
MOVIE += 'xKyN5gEZpqOyHA42Hyp3Wx3UwALORSaDmzoQjTt4YPRBjkNoIjr0ZqgEQAzfJaDt'
MOVIE += '6WPi0diyUq4i9pbm0keocMgHwhUynF+L9g9/1LXhoLL/8agvaapVVInr5Tmta+3E'
MOVIE += 'd3StY1JH1AHlFhINOpIAEKk6TrCWNmVBhxO2FnNUoB7oSilagceSo6CbA+1jC/iy'
MOVIE += 'gHuf2qAMjyvTSYz4gBIpFhaTr7YCjRyYfz2nJMI53OQ0pz9WVEEtOBVcYffiSHq+'
MOVIE += 'JnzoaZMkz/Y/x4XkZkEqgkt8nwAH0mTZOjvBDLAw3GmjwBGCYIA/nHSJACAu3Ou5'
MOVIE += 'SzKxefSNBEHbwbEjUKl38zLzmWKtls3easMI1ws1PI9Mkf/Q0QdUNciru3ZveiB5'
MOVIE += 'uSMpvp3L8y9jWMB4D5omCa0QzYBlFCjRTjkqCUNULAJzPmxRKPLB9AQPdyZgLB9X'
MOVIE += 'PgxU8c5Sv1JeS9RlsXj4h2Cei50WSDvNvWwEzAjyeKVxEdVRetvn9rA2W5F1lNwU'
MOVIE += '9ZLjNPbVG182/5ba1MxiOTC+nIxyMa2bsVJFemdon1Ernx4jBXumsN9pWmdXojwD'
MOVIE += 'eMf1aTUb3r/v9XLVQPI2ALH4mxGpgIlka8dRxoGMioGv1Cp4ikj+kF+AA7fBeu5L'
MOVIE += 'TOzrtMAd6QoiC56A6ekyJ9zkbafPq8dktFa9erDiz468sWQcmAKwRaotulYBII0O'
MOVIE += 'dn1krb93Q9Tff1fJQ0qFXqyz7HBII62XPVaJHsy53cf2+cU5/psOjA75/DZ/g4oh'
MOVIE += 'q6hw/aVBxHWit48ybR+G8cTs7c3yzcB6fFz5ELDtlyq/za+73yOUG2MXYYKQHNma'
MOVIE += 'LmgaytXvMg+QUaMlUnZo3XqQ+aY1mufEmYuyszFi6Q1u9805ewLzVKzLfKxxRrWr'
MOVIE += '4Usni7jvn/oEJrOMUVCTCTwqVUx5kwLfHoZRGlRZJSvDGrNINxB1EcVu2BWG7RgY'
MOVIE += '6a0sfjAz0UAy1E/p+AZMzBPNWg/tKjs8jjLpE5BmT9JBchRU1do39GX045Yoko1x'
MOVIE += '7WTESlfg5KxNIAcc9GgCD2oIcNaRx0sA3L0FUwkFwvyfiD/mAxD1irego407AMly'
MOVIE += 'qYPRwPGmrL1AKrYBGLv8MIaeB2ozfLw0IISRosyu+FwwfFYl5jkh9dSkBM6h5ILC'
MOVIE += '+004IgCUxvAnM2km36BBzBNxhBYYxa78zU8YHgD6K2I0zoE+aqIlrpeyxSEmiC2D'
MOVIE += 'J7x/t4oNccR/M1ICRGFA8qqqt3VkcPww51ETnUaus6j214q84q+ts9FpHVy6M8pX'
MOVIE += 'DL2uFniGoxS5vym617FMO0Dm8HhCQ8DofOnPoLe/nqhcwKX+foP88U7oBpVOWZRr'
MOVIE += 'FIPFdzB/i8WJefu/OgA2Xne4EneTOSVORI2LFLd6bg18edypVa18x7DXrHvR3D2t'
MOVIE += 'evXkZQDHuyxRNXrNvBtDEEc4PtVMHBSlTvZYa+O7HFIgAcIPkI/swkIwjL28Ad6w'
MOVIE += '51cEwoZAUsOh0deDPsVa6wQALZnMWFXcKD1XQoq6Z1fUaaU6jziF9sz4N4KSM4vX'
MOVIE += 'iux1GcTT2bwNbE5EwbcgKeloYWlwcAFYFk7yoYIeqQLwlHvTbEhfHFhaAiE24+t4'
MOVIE += '26a0AdJEYPoHmsSdzpLo64uUfbQPtXHuKVOTRepMiRUWiWItKTINF82tRYLtZ7oC'
MOVIE += 'Mk2/jdKZUNHRhnHOFrmLW7FqbUBypDYye6T4LEnWkfItW4y5DwwxX5nwgV9/iVB5'
MOVIE += 'AkhdL3lXStFqwSjKygjwNVQfJ+Z5F6PbkKKrEdOdzJqVPDxOX1T7xERu8TvH+7M5'
MOVIE += 'cuLkbyhelyGsIIbMLjtGDIYfGqylUTG9fZX4IRGwkaTyVIBp8EM2+06R3FXafEJU'
MOVIE += 'r4AuiGgUm1HX5Dx1ICBAaZj4OXBOaKL1WLm+sUs7uXFOO4bwbCJGA9fZ812fNJZj'
MOVIE += 'fhTIAYh56ZSkVw/+raUVFkmFp9XrO0Lz+4rgBgIoTgTtzuj5JYIQbRgH+SIeD1HT'
MOVIE += 'ftkD1dEJ76pt/zlhohhPBPgoWJXLoo9AIuuiT1/2CQXtH+3zM0MBKFFnRpTsRJJq'
MOVIE += 'fTQLJq/bMEoiHPCwuejJ8FtbtObd05kkmEgpqN3gxdUg3660OBy4K58KwmWMpiSA'
MOVIE += '5uOopA07RAxTcKL7MkC14In65QFNGCREB8GDa428FoINzFzKsgjYVAt8NNX3x1fU'
MOVIE += 'nNUQA7tYJovYRhtNtTwZSq8SgElCU35HSkdNvF8yBFpCaMQx2Ioto+g/S2jqZRpH'
MOVIE += 'bR2CRRBjQVykpodpo2hnYqMLSKBA/yJxkU81NpWQjn/QWP/LvPF6TBQgRrggXYx1'
MOVIE += 'hZnnve0O+BGgf7dLfLkhG6/AAC+xUuOD3mDnWFZDBpHnWD4EM2ajb0vfbQvCkgNy'
MOVIE += '39m8OmwHy9cnujKBWfsUp5srmve0u1Vyak+6vQ/mbdB6d64ZEMX1KCaUjrGCBkdG'
MOVIE += 'jJ4HSNR0Mm+5CQQHMnisKAc0CU0l8SA0rcxY7mu/kZmDkb5TxJqZ5JpRHLAohAcW'
MOVIE += 'Q77qqNbchZ14yW8R/QXEhQBHaq4PWlrwdpOeleMl5FI8KrH42ozn3AEJRSe7ky91'
MOVIE += '+xNpXUeJXWb5T8StL/FvfDexLInOmyVU3hmK22kCn7y/G8gHjVnqALFUnkA9BEHG'
MOVIE += 'BKiCcxlio3riRIDvioNxRms9tapXe21Ttan7kbX5h77x/KrzxWgbQM+FzuwnjLLj'
MOVIE += 'AJtWg2WxeB8m0NX9lApUDkY8tW65iMI2N2nIIRnHaLR+r7iKY9cBiaQXH6ItYu5E'
MOVIE += 'E4CVUxhKiygN2+F4K5uYQQShLdQ62ib+C08TVMew5PUUNNk1I8sFIN5ez3FpQyS8'
MOVIE += 'C+S4pnh9ZBF8i/X3x/zRtv30TcFj6fUnZ0jfx6bdzQrZPltlX0XKiajMNuBbvZgd'
MOVIE += 'Xyw5vM9WFhsla8f+V/TA12amUuqyYZg70y7xoI8iRRi1tWyCjnNCxwlSkeXystFp'
MOVIE += 'Et0gPhoLsHEagnJVR7JSBxMcKrFts+AFBfGJd7lJeqPY3Tjcf7ezspT3hc3eaIrJ'
MOVIE += 'KAQSO3SAzEXvQPwSjwZapf2tPCpjVOpHC4qTUjkqCJglbVFxtY14p4PmJpp4QoqF'
MOVIE += 'gRBKdtCHIJvkVLPkuwsS/EeaCwkoZJYjJKjBbI0A9a/evtoZjodYdvUBZvaCGeYT'
MOVIE += 'MOSNGOXENcNETMgcp9+8jqaFklWseXiMXf28Tq7DCUmv0FWj89FO4izU9sgpUD5v'
MOVIE += 'geljgWP61GOaS4mHoPCFqLa3v64S6RRTb41ZApbwSGTLWDkbUxKwAoBNsuu4w35X'
MOVIE += 'DgHjNjEb8qo3jRzR0gUxeM/wRAv3Ycs8TvV7nr17mYuxiuxNU1DXnN8O/pz/GeH9'
MOVIE += '178O/JMIsxRgeqyQw17ewNcxzZfYCz7ifnZQftvy+ake88GUq+TNWnwFiMNuOdHH'
MOVIE += 'UDScyyEj2Rw4yDs7k9a/iW7Ce/5659SsJGu4+q6b5z//n1k3velPAhzxOwXfF4Bt'
MOVIE += 'xGvwHSG+H8ZkZQDKq58dWz7v9VHl+im26ux9HhUSRYLd3PA0/WL1wvE6k9NkRnSd'
MOVIE += 'duo961f/7vbdz25tuch56tH9r+DvxEJ/RQ2TW2AuaMYWLmU+x7KSEhXBhynYk5T/'
MOVIE += '+Dp4O1ZJXBxq4RkhqbrnCexx8+547Pk31bNQHVFk7sZ6DLXjOTIrH/XAi8NlylRs'
MOVIE += '6/8QOXGtJxQFKtWqP3jENWkkZA//WA1om4wqH1Oq+BRG4Pm02iSQwPM/sJDKdzxk'
MOVIE += 'L0B5rsZeD4uYB5YdbHy42F3kSHxip/8x19v5DTms5li6F4JWjjHvVae/8bzjbuiU'
MOVIE += 'WzLUO+gzQJ/oTcSS6J7VkhI9SjsRPcf+8adKc4PgL54N73jxGQMlYl0ttLmxuF2g'
MOVIE += 'Bcb/CMu1Hhcp9EVUWkzY11dvHrvmNrMe2r3Rk7lJ4+HqdmhR4LL98zhluTFVHG/X'
MOVIE += 'j+3qDwRkULjC0Psr4qXW3iGpBNm431lWtZdGu5dNiQos02Q7+HNTa0rz9sUEM4YQ'
MOVIE += 'DQo2jfIDSNj2wyQcfA1tLwX8Pe0//icQHhWU8XWDRuw/w+0Ptd2f2/RheH7y7F6j'
MOVIE += 'Rn7tyFgvTTyX9Rg9VJzBm+3EHo8kvP/0kmA9wyd8l6BkSuwXGtiUXUMUHAcKj+/G'
MOVIE += 'AZnhoO//VoY2ae/+2V5GeYBrBfYyVQgeKCZw6O3vlpML9gbVuyQmJBn+0be4WNS2'
MOVIE += '3eXRofFnpRWPj3vtjMZLmDP2o1/ROVk/8oN9LUs5aTUhL2/Am1cantaw5kDugjGE'
MOVIE += 'cNtuzTxmWLwf/AvTOJLB4dFPu1nJeO9JBixiJ80JBZFYChrpDuJZ//F5+bsLM9jh'
MOVIE += 'na8WY3XntCYNZTB/mc0L3uALU3/jeTdBR6/cRC9OQ8Bgr5bN2cUdOnq92yekyPrx'
MOVIE += 'j29hDmTvzYg4LuLKRS+1WbFiJmnyvdECF/ZsXORSa7JLfljU9QcnaXxZg77/dkDy'
MOVIE += '74PGajwdaCnyo81h581KD5Buj675Ay6M/mHvAklrljPh6GPJUElF70uFtz4w6DXQ'
MOVIE += 'hGbWmDTeF+6mcvsJBQMzIMqsvTyV9LCiHl/kEPjuJW9cisi5LDaD/IuleNaJVNz+'
MOVIE += 'MEerh/Y1d5nu2F1XhobXfLVL4F4RCQM8cfxIK8QZ1vINu2UwgxvzATy+kHAt2MBy'
MOVIE += 'HeHluXlLKJ+aPpqi0QSdz0MYUFj668cM79t6CCAqHs2amuDElLkivJ9ciuHMXx95'
MOVIE += 'qoW62v+sEY6ESMV2y0eLoaJl18EIjAbdRxqObGkHGWK+xeCX10YAQ8CCmsbnWuCj'
MOVIE += 'dTy27VStvoOnk7DsXys0C1h5zaiUi7XA8qj4nOLnabo7DlKNxDdFNBR3hE8dLrNk'
MOVIE += 'vGjOsnhvh98d0n6KFvMAeT/KuBPNrwHnyZQ70nU7QgLLA8LyxO+/FOKPDl8flOsJ'
MOVIE += '2asxP1N6Ot35+/d45tZ/fwYfkb7hval/SijHzrprQLsXFq6VZNGEjruktDzCgwFA'
MOVIE += '+KjrztOdVh4w1Moh5oJ1NIGCVTQK67CLYyflPjcWweDeQeU9dtbbo/Gmcvg8r9CL'
MOVIE += '1R+gZFy64RMXFVz6hZLB8zPH37nny5Xjbxgdg0fjC/fyLCoWlydN6ozrjFu8fvCZ'
MOVIE += '8tv2ZB1vSug3tw2Mf7NaOfV56f4eA1Q56KFu1y2s1ZMLTWHfHnjcfvnl9JfwDi4K'
MOVIE += 'n1LI5xrlNPQi6Y739RPiDe4359WaRsYVOFxcmeRXCqyRmPtgJdlcO8bIASJOmS5g'
MOVIE += 's6OHp03H/bA1Z6HqHRkr0ufbPzr2hVIa1Xvd6L/vXIFFex1OvudbMsstNoNpfVSS'
MOVIE += 'NBtmbu8bXT/QmPF7BhxvMvnaPdq7OlnrfMRiYdTgMkXKxX7wMFMudBf1nBHwiZWV'
MOVIE += 'xIEjSulzYf6IWp0n1aaQB0bcUFJz3iGLuG0h1DFW2QdM9UhyP3OCUnHDhTGR89tq'
MOVIE += 'MT47amjLVE/tB2OKidJBTPByKjDPwtkz3jzMZ5CzzCbkoysyE94XxpGlxfY4iXeN'
MOVIE += 'yuSFQ8lA2zxAQ35/zJOk3pxDo2R2aMgTkOB/N++WApM2hD7Y8Wct7vqCi5Zicpk3'
MOVIE += '0VMo9Ndg+y/SISfx6U0iJcGeKet4stB4uEey3sqRGf2qXhSTcP7ZxEcrxShuZpFR'
MOVIE += 'G7H9SBv6eo76iiS+dd7qAu0CuS2Hn+W0ZGrtJ8qomaHyOnyRqHFyh7I4ACs+udMm'
MOVIE += 'miimc6TIl16HgkQzptNRj2nehZKAoytzjODJv8e+iUwYE1KTuIhkj5Q4oc2V1DXX'
MOVIE += 'V7ZWCv8KGmpLQq2aPKqm5IQHMbzKU6C/QENcHj5vFz/+X5rf7xhlVOHAZku/6lP0'
MOVIE += '17P5EZ93HX1cpAoDHHW6ioWGcUSajn9EEg+klY5e7cSd7vU61/swVbtWNN2Z15y6'
MOVIE += 'WaW8vkgzF56TibYilDxB+uM0/hCmjBfWqWWoUD1HdZBH6wj/jafVwOH8CxCWk7AV'
MOVIE += 'gCqPyJr4RM8IGYoztkRX/BgguqlqJgeS/pjn8y1ou7ZEnVHgVNqzX8ReNujx182B'
MOVIE += '/DksUdk2b2Th93I0VBXosIqQ8G+DMiag+gjZLByGhtS+WofskauKnL5EqK2DdcZC'
MOVIE += 'Z91iHYStP+uK1fy9MVyJaDOt9H8n+CvYtkYpLE3oe/359peff6UiohmeyzvWFYzY'
MOVIE += 'z6NQpRmHJToPngJh/gAVLIn6SxxN9QOfm2PeUlMfLZqw7Et/nuFnvt1T7R5/vggt'
MOVIE += 'Fryeev2r9WMoypr+zq42HRWa+l+CFPn+5CnVC6TaLiy84ICVFEBTQF34LyP6SO9l'
MOVIE += '1J8kDOF8hsJzWw5g09S45nCY7HqOKsFuL+ZsIo6SKdznaRvDUGCJMfR6zIAv2bhw'
MOVIE += 'ag9Nk1/Bb/sHvGgjyYnG8fq7TxSoCyV5IA5sOQAJycPfQzObYixRAdB6ZnxT/xg7'
MOVIE += 'tX0y5uN0yqUrFHloi3JP32xHiUQP1WM0vpbHboINrIM8xzlOHLJ2248WYlwlMW4q'
MOVIE += 'H2XFXBJr/0UJKTVvwFOrVQ0P9ugnLDgcqYYIQnQxAIJkHB7ZN3zxeiSIYM8GyOyO'
MOVIE += 'ZZ9xJNUuhrGn+dcCpdsBG9dDiEkenYTHI3cQJsNPME3DOCk27rTAWwTxf2EaR9XN'
MOVIE += 'z2QZpzkjlFKcu5wycK9zxEkJcKrakKwUXXWXZroaUwlDpAymXPXQP4ZxH4B3GAOU'
MOVIE += 'GczQStuaEgMH7IG2sRBGjEHe7msSioEALNGEJ4RLE0L05Pf02ph/watpdtLTNR6X'
MOVIE += 'n8oJ9Re7ZFV0o57GJpmb8ou8eZmjyf9q/EuuR3OaeeCQeofSUZVoKMX4FFR3N+Wq'
MOVIE += 'q27ULikr6wLHobxTp9eRAaPEBZR7fjD/si2pG8MVHBZQoFptDiSO1wRX/keQrnqs'
MOVIE += 'vAAgzRSOdTYW0q0wM7lIoWRk0uXVZW004TC0O8lAgyjgXVgcgMTo7mqZpRJ+3xxA'
MOVIE += 'kgKbwOtwaFzL2dnB315XJ6JoT3D/vRwrFhNFY8Fh+kGtrkD9IysqbXeGubuG2lCB'
MOVIE += 'g60hMdGIqpWqeD3HNg1Y8zKrkcqV84u99i64uzU3t2Jmx1qD8iFRc0cryAgtHe5Q'
MOVIE += 'MfgtD08eFu9FoxRVPN/Q5lFViqL17qDzVEt/In7CmfEY5sUYZZwLinOtIdf75iKZ'
MOVIE += 'OaKpLsFoBHP2UKZL2YgR6k/a/MGGp3hiaCaFbwyonsXCdapyufPUE2RUhxzKTdGS'
MOVIE += 'OfPRSZmtrwbUlNkwYjZ7N4u9a4Q5H4i9cum03vUR2npU5yTS1CmLaY40HamkDRFa'
MOVIE += 'bdUgXlnE3VlsNDmNaC42ZUcqvUH/7oVp+gWy7QAO78UGfGVcZQ8Qk79OPB1Ez9EE'
MOVIE += '+BvgzqRTBx/eOmv946iYGuVdBj4qsvyEcz7Sy45Tp18dQb/91eiCiKxmKilzEe3s'
MOVIE += '0q/3IkqVB6WzXXg1d6O1ZduTQt1qQDmA/fiPbhMoQQKKE2SirEe9z8lr8+i1z+1R'
MOVIE += 'aUOkk65nOXXRIx8lTqbyy0fzXhZ/rI/qq5yoHxVQViCyz6CnL1gXENI/3ZPofNc0'
MOVIE += 'jTu89L+06xaCcEAMm1oYEPYApA8rUKjN93bGmpkHSKCm+KIkp0SSmnDZQAP4LnAc'
MOVIE += 'nigiT/9sr/I/RKj7QbtDxPQ2MD3/9Z2cquNyFM08LKRB6yOxsTPbbG8bXlPmsqZz'
MOVIE += '72N/32dAKb7CU+wWfUpLt511GBCMxahadG60tD15HR05HqOf+Iam88kJd1HKDuMS'
MOVIE += 'TLWbRFZKm4Xy+ds/aqoHxnsNXKIfq/RfiRVVBObKgenP06Se6DqmOPk4ZSZdx8jO'
MOVIE += 'XIIINJHj31yZAaYOU/O3FR5hZlH3CvyL7VYCp2lRbFmOHhvlKBJPsk1pJTsjVqA6'
MOVIE += 'wYDsRT++UxvMdYD108hWb0/VqdxpnDwlx8v6foO0b32vSpaF4387inoRaAmoJDb1'
MOVIE += '8FkGYJMNIqOYzsLxv7Nh7AUm1xju76hf8MeAOYKdpYyFSQmCrbbv4jmcaC2lCTt1'
MOVIE += 'gnNodjzplyXlSJimA7o/6T3PPbB/va2o6nGtfB784s+UwRe/jr3Brn7puKe3/36Z'
MOVIE += 'vZZ+oEeVgJvYn8v9hozJ+I+fQAvGXfKP93vp1+V1icwEGs2tDdneESU2JdJA1T6+'
MOVIE += 'RoMRhuaUA90/HkvDIy8Bj+y98tY+7l+F9e08uSvzQqisTDD8e8oDsswdzrnQINGE'
MOVIE += 'fJJI8Xs8+/0vnfYWns/t6m+b6dJgO7YubLzHfwwhLxJnIAQQJTqBKPIMe0PPklg9'
MOVIE += '+puF2dxdEtXJlLtgq9vJF8SrLA01JcJdH3hwxfbXL5Iyh9VbLHZ7wd9R6J9Kozjy'
MOVIE += 'EjCi+LsE8tHkHXosRk/XHxagOc0GwRpBlNhygKUxzIn1BkQIYGDuC5IK2xtLK7Lj'
MOVIE += 'dOszvYxbsq3ZcoY9O7Edh0Y6+MNc5cFjFs8+Fah8pmpB4stj81EU66OWSdISwxcp'
MOVIE += 'mkQCBUYcWMZJ0g9UOQhjpViFhz2DSnR5UM7bOatq1rvmirO/qfUVHxje7DbksrkL'
MOVIE += 'jnAxjnBVI5izVnl5hnchqdC2XZW2uMgDcyQh21Ls7IHW7toKBJ95r2JonriCmXlW'
MOVIE += 'j/ONEv0O9t3TLZOhMfoka1o1LMwi0S5mrz+1kmGxrF8GzEU1LAgwFN1y5Cdk4d7a'
MOVIE += 'gkiT83OyFM5QFyGVsMeVCpYJdO0Qqr27GMG/ewYZaIoZtDDbZsk+xGAlUySKSLTy'
MOVIE += 'Baeos1gPspcuy/QAyq5K0gaLgWGWVB2qJFeRJF77f2eVBduU+XSXyPI+qWllkfXS'
MOVIE += 'AG/jVcuBbl37cqNV8lNZ+y0EPhlpio66hMfOeg67xPXkG7fOAS4YorOsdzOqH1Qr'
MOVIE += 'ORbJaozomYOLXymwi/jQCiqPsjACfS8RACRuzx8iGFwjMAGSjONU9/okUA2q41Bh'
MOVIE += 'TRnmGSjW0KLQ4jOEM/8HHDXXqP8EEED/aoO0IxnXBkz1SAvk9zDEuki9rveGkQ6P'
MOVIE += 'Y7GnuDSh2XjaYMw7DyIlGpfbEpabFb1TT3qb3ih+w5ELFIhV9S5VznwerKf6sIyr'
MOVIE += 'MLHGwm1fYCIK1TtcCxup7y5mhzGTvXHdoZrjFgCv+LiqzihRthtLEhf4ICwCpqrs'
MOVIE += 'bQEGAY76F58Ou4ecalN/MI1CCfeNjGuDyol7RA4YHA5NQulE/GvdvRbJj9ZLU01J'
MOVIE += 'd2i9Wt0fNtbWZ9ZMtStLbEUJdJVMFVq9HmTwYzbgPVIWpRp5W5+71zL+nqBgccgU'
MOVIE += 'S8BlL8pKAVOSKkGjNmNIbV5wobkNiyYeAQyjPg75oSw+rC+gPD8TuBX3WO7xaSaJ'
MOVIE += 'RTHUjpo9Njf8kQCQNYLjW+wLtdWlZll6NbpJbpdN5ToJzvyXtvnR6rxubpROFJMn'
MOVIE += 'xGgP7LqbUgUQ8ZvhRhg9rieWScWVhCQdFKJmJTms9QldyHuABDb1iTFKjzktiAFq'
MOVIE += 'HzJmmGyLUzOOzoM/K48Ti3QNI5cxj83heCSlXIIvImu4lcu5OLbqn6Rxprda81Zu'
MOVIE += 'Td2LTkHITL5E3shVdyV1zfYsQv/RtxhV4IAL2QVAV5uYwmeI5hZDfAtAimMzCNh8'
MOVIE += 'UDb69WQE62jEzBDbllJBK5lTVMLoxqhxfUO3p3uxcdH9OS9czmPVNkayBYDuW3kL'
MOVIE += 'QkA4ntR+QmhuLfdyVJf+aar5qefJ0dQkk1Sa07M86qpvY68kvbwm30n4gCyfDkPm'
MOVIE += '6UHzB0KoGQAPpn6cYu0KQwG4i+I4wzL0YjkAw2TBfJTDcbG3OMlgj2BJd7qJE+Ex'
MOVIE += 'wFrFRGIBppzn4RbqHYfiWrGos7D4MKvLGUn16Zuxh0BVTHOBqSo8SsMBArrVQFWf'
MOVIE += 'dbX69FmeRpB6Wbi5TAt65cQ09f4bG0jM5QgAtwAxj/65+ZNiRsRfaF+faiOBLDPx'
MOVIE += 'HD7Kn58q6Y7HHcOLpdZVhSMmov4uVhxAmLA8o8r4VPPp59UvOJmHGa7RsCsBHsFT'
MOVIE += 'KWotqgmPKTzw9HhLV39z+XDzl0mH9NDT2R6r50kr/MNse8RHqoy72qxAiiPztoBU'
MOVIE += 'Bp/tOx/QYsUJWHRHdwFn/xRHcDSp6MW6WpZg6NOSI3iXbxr5JSELyMzzSaYNAFmn'
MOVIE += 'MbcznBhOpi0d/zB+/qED9GXqy9Riy8NnBw+TrHoatz56cZAInfieCyZXfLISaVCF'
MOVIE += 'D6sBSAADaDlNoMPPAzrNYRHN4de9Q0vKgvbUTgdPS0lLjg//sRmX4JKkoaFFLzne'
MOVIE += 'YBnXhxA+aowDjxipgHjIJtt/DClJzXXh2MMJobvF+5bRrxrjgucnQsBozopxpvSi'
MOVIE += 'zQyKrxH+w7wlHENmfLdfQHk7VqB68DNNoAJdyzUS+4ZtNGMZK3+Oo4nExlBN23PV'
MOVIE += 'Ld+3CkyRf2aunUBb0apGPT4GUm6h8OrPW23npXZfzsJBu4TRcCKROxqRreGWL3N3'
MOVIE += 'gh9Pzr1AnpW1W5TFVr4n3OBXa9zBhoAL7XxMorcZxpN3+Htg2xrPEF0120/eaI4C'
MOVIE += 'rLwkEMkYzYBzXjBPaAxM0AftjwS09vCYr01pIhlH2BmBeGgAYiPvrQQGtg+gxSJU'
MOVIE += 'J6gBxJfwty0oxOXZP2H+Zh/O/4TON798nWOaXfWhdh7h9QfvWXxSNW3zLlSxVny5'
MOVIE += 'HzFbJD5Eb/r18EvUjzftQmxA5IwGG2CY4E8TRTDYsRseJGSJh8GM0LCfeAJFg4C0'
MOVIE += 'DtjbQIEhMxIQY2oZnyhfA4bdXoxc5xuHyTfOD63TXoH1UE+p1Y8foTvcDPo7+hdK'
MOVIE += 'bZhILfRDrSy5LhVs5h0p6XITl6EwMnJVyPQrTYnXcHtA4RmIRXxo1JB5nCMeRQnt'
MOVIE += 'KmRy4v0uWoVRRH2l5vTeE8cQ7mPITIKeqZHgO3RqPO+SxAdL4bdRfPJL8wr8onDZ'
MOVIE += 'IHgh89Vhnu2lqrzy/BuM5+NlfsVHY22XGT7KBPYvhP50tk1iKDi+iKDiOHqHSAXq'
MOVIE += 'fZr1T9uMlFniH/i2tCYpibKL0RAPKTJiSP9Yf84wVjcRe75AM6QGtsz+ofEiZMot'
MOVIE += 'SJO9HVAs7nUuVJHk9DEkMCsyiteF0st1RFkTpbGPe98QrfFbTV5HiWkikM1nmHYC'
MOVIE += 'I8gCQV4ADP/QKUhgy/+mc8CvYuez7SU+m6h06wLuVj6ziZlXATYDQ56jcKydTeqP'
MOVIE += 'uszitCxfhVq+kNB8+UNyTYirWJzyV6vNI37StChr5kQhm2ihtjUa1Pv+PSh7ihvI'
MOVIE += 'X8XhrlRO9yWHZtTSTR6deJxQcvuLVDIyASFn9qGoLDISwJCktM3qaoBh1it8zEhS'
MOVIE += 'BrH5h1WPV3ni3B3qOqpmdpyfeyUt66KeFkv42Hf6vA+VMmmy/twKTD54qi/y9WO8'
MOVIE += 'Y+Rwpr6Kf1Ue24UPwGH8PRsyF/DTN6odr2p0OMSOSTr0Z4Qe/R3aPk4Pr3reUJxh'
MOVIE += '80yLKBNTglEhz8HhGV55RjbTVPSox7slG5OB1kHp36+ffn719KvUc28xzlchGPu7'
MOVIE += '0/K8zQaj9kFiPF7TaFFxaU+g3zxMSOOiARKp/OiDjjxlAXEJkKVgCKTY4nNkSbeA'
MOVIE += 'XmcMRtX16jKK612YdHmMgFE4j3gtsAXuMy4s8gGEPSHb4mEGaxWQ/kq64pf0M/Bj'
MOVIE += 'cVgfe7y41FIohfWpb3QnSOy3o/yJOslL0Ecb8JWAnPIo43KRjI9M7/mOy5a6TsKJ'
MOVIE += '84MXuiGz+3q+woWvjtQYk7Mxksv9gAlpdVW0xGYvW3Qt7fVDqKUB3mMQ6+0QCzG4'
MOVIE += '48MwiqpfcOdV54M/Fa96Kh+IZkr1V3X6YGhRFkUfni5KWCjFmek9FjButIOf2+51'
MOVIE += 'yxBJukZKDz8loZPxoMK7gyYRfdIb/Q3eurGSMCxVE+M9/l32QXto6/jKoqv8Tqmd'
MOVIE += '4XU7++th4dsOWtmuu+uRuuFn0z3dtI99i4N5amuBnR+sjCO8jkG1HxjlIF/Y0fs2'
MOVIE += '5IB5f3Ay1rvBOszwq/lor3yALCupLgvtpirR2zbhG2OhhZvB7J9icuRgj0zZd2E2'
MOVIE += 'ehnJhK+9GOWHpf4KyiuMaDztkIvkuw4f5b7pMnnNYf1ny0nuY9ymVjwnKfN1Y7fl'
MOVIE += 'xJ+P0ekddjYnbxz8e2nxnnWBsXQt08971/bHcYejvz4OseUoxYxn6m0Z46sSEbTh'
MOVIE += 'wHBR/rG10idKT/8+Ub3qGzKcT4n2GRJ7umT/b8n9zbLw3UCH2OsKe4VV96dWGh1n'
MOVIE += 'N49QsOhR9svnrwTGuftAnVcfXq7xp8m9NDJTLRiP9ldJToyYzbvZ3/yb0zOqg0ET'
MOVIE += 'Xqky5Kyxwd4FqNq8n/79nvtf64I0r9w/Fca/3DWCKUJ/Dx49OHT/J+jzZpgyYkRM'
MOVIE += 'blTjtbf730oNUX6Iinjk25uXb8fsI7mauBqHGLl7oyHlHLoGECYABIgFwwr4axIo'
MOVIE += 'JWOJ6CRNj/QJSenFQycKeAKc1FMZZEKvrheq1BjZH4efXnyJIaCwDPUk3AO6zRCL'
MOVIE += 'OacZNnzBAoBA2E8qGIAHAKGpnGFdpmioq9YplAw5yVlgRJDTQ7ojutFghMf8LesV'
MOVIE += '/l3zWpvzZNRgCI2vVdfIek/I6aq5TV9gVU2HNe1XW8cnv3/+mJay6tDLtYCKRV6j'
MOVIE += '+MeSqdcCiQkCXayyeR/2yBOJ1Rr1Nstc3dIFe7yv0cbqTxyrGQAkyrjMlDDcWIJq'
MOVIE += 'eNI/4vZ41Uzk418/vxTHZxChtDJg2fWzCWQs6jxSlwO9kiUPn5vHMymp5ax+6Av6'
MOVIE += 'dcVNmAJabnCnBjqTVr103Xh1V0XzZvPV95V+WTkfoY+v/5z++8Ewm+fcqqWOuFeM'
MOVIE += 'ZrSPMz6Z6cATzIYq66ICXDpN9NtJRohp2aB0xromCVQQvJ0GoHrvH5XRcjtpTRUf'
MOVIE += 'IVNN8i2hm9Rx+ifZQ5XMz47U7+L3zK04Yg+LTBIhJaFJs7JN9G245Kv+JxRTebBC'
MOVIE += 'lViYMYcwD4RtAkhStRpEptthQxc0c70YeJrX40d+ViCZnlmt9/Bi+j3Nv2/9nW/f'
MOVIE += 'VPap0bnGbUyj0GSM4ghzGvlgJXzqWMM8S66t5k4aTtd6KtuswvEcMhneWIaVtKPz'
MOVIE += 'hPJ7kUgPjYG1ZmZo9cTsuLl1rmN8Il+WIwfn4mPlGvIOf6UJtqBvnuXkLcP6r3lS'
MOVIE += 'Pwo1XrSOUgC+O1yrDKJqXNOLvFqYOq3+dEl8b/b6M1DLCWwozBaU/TS8NCcXL+JG'
MOVIE += '6VV5mS6sTMkvrgQlM8vpsOQLCu40titZ7jEJVDr8sOgjxn1ngZejLAlq4vPH34lz'
MOVIE += '8olfSfEvga0yRRSImD9UWIXFS8iiHPsQXSJIzGUBNAnIVSpP41b7D1015dou4DAt'
MOVIE += 'RLDxeLNssoPGo3xSYEn3Yf1x56xXukitYFCpupSw4xm9un448IuO3QhN05ih6mUI'
MOVIE += 'XHmKL0W6yzjpdyhltFqQO2hl3qK3mydKGwAImlA0YzWTmquPH/Rsm3DCPWDeSpV3'
MOVIE += 'O9qJJg1tbJUn6kim+1ad9dTXtbzDeHfD4+l2iYBUtiTe1XwsM72gT7bkxwLxz0+S'
MOVIE += '9esvm8Wom3ZnZdshZF/6adQ4RyGiVsxjY8O0l2VdVFF/VA//m9e/ZOUBOoRnRTvw'
MOVIE += 'a/678/NxyoliG3qMrvzEHN4bfjH0VlOVAilryOq67uTdAyQtEhcJnHBv7QusYJNW'
MOVIE += '/iws8x+LwPt8GiZMpdjmfJtaqqjjqe4vS9ulOTPutRqd0OcVpVifeB48vdqwnMlS'
MOVIE += 'txvqgVhDYYdaQL5oXkUFvOElUEMmcyrcKeNEYpSpsRFGkuMQJ+xDbP5gR+l6uC5G'
MOVIE += 'QdOJ8vEEMO++RfZaKY3cA2bwtyi2lBGuHHSb7WRxS4v2try0quYvfbrXicZTnBW6'
MOVIE += 'GdKB/BVVGqU6RBF1PKwUL1CauhUKp8nKiQ1lRdp6TDBRt2mTlnEwl8EcJIUZmblN'
MOVIE += 'a2JkGT8RSx8N0by5AON+p8ZL3G0OsVK2EwlToV1T+AH4KfcXXnIQCVub8d+umAfC'
MOVIE += 'sWrPTbZYOm4/95WnpmG2Tippd6NY6pUyUi5Fnb/0uClJmtfCmVKqGKmVZ+JKlGnH'
MOVIE += 'pNVrRathIZBpUPK1ubchVQ54AMfUTV79A7Jap+ezi+8HgFCwHRczYx6xJ3P8J3RY'
MOVIE += 'Ti/QUJ5d5qJtmobum9rVhRqkVPL9pqMx7/kW9JKqCNjHMy22EIh4hVgqYQzntjns'
MOVIE += 'QL+ufij8tFAOXylKmebbGkqpF27CyE73Yt4whQYuICyv5Vdp/I636/ewgYAzJQgU'
MOVIE += 'w3DSFi+4g/Y/2NfT514Es5S1lA53oM3qowHko0vZYp/QdxDRyeYKVdbnf3P4LHvA'
MOVIE += 'hk2EVHkuojyCjxxTJD+6C5GNUqr+VXktEdEiSlM6E+OPTU6lCCogajAVkr2h0y9h'
MOVIE += 'k0ATYAjLqQbdgEiIwLcZbk1HQtsjNlqvPym8Kdzl2nafahU+ItSDp16lRKazy/uD'
MOVIE += 'e1dRZeQHGHJUm6VhGfSVM+cljM2BTfG+21S9jTvXJHcvG+dqJuVI3tSec2A9cCOz'
MOVIE += 'kjvt2faJ7PmE1Xiz2YWd3ygyVvFytXdqIZpedoy71ZRtSXGMyFwGI2N1M2QDq0fs'
MOVIE += 'knhqQPG2PWnYaRuSYOo81pYpC20EjFgzyq0dvOBwGkDk1hhLIMqqon6HbPwmmjbv'
MOVIE += 'btNUQJCgsS7nS1TDSenm5s/n5pCP/Ny6JNGNNbk/LR1O44pbwzJXmn8Ml0ZxjJQr'
MOVIE += 'R1b2jVzlO1Qks+adXHLffElTICgHZpJK0ml6T3LpKg0amH7ymYJnZKQHaNA2hMUx'
MOVIE += 'H1u/s4mtYiph7aDfGMp5jIv+M64+/tohhvC2+D/AK7zuxhYWb1u5vHXR8MYupopo'
MOVIE += 'a4L+D0655VAzIgl57s//gdZo7OUf8o0e7YrQSFV+04ZzWAAJ3gW3zMcioZ7mZzZH'
MOVIE += 'qyus71P0wKsDTMpwM6Rwb7uKLvnS5moAXU1fhhBHuxtwaHKC2EiYNLxcxOKpI2Ux'
MOVIE += 'YJTGo22E67sDEWZH6YkMG+TuPemOic7uSyw2CoCoR/GCewAmp684hINj3T3yQi33'
MOVIE += 'J6lgwiRzAauNytTan2uG8CvC8Zzjq/D2Pq1Ozw/hiipYK44ORYuqJqODeVEkmGxF'
MOVIE += 'XtMVS94URJQu6xo57wS6vab5KbELz89okTMGtbJbC3QkdlJyWInyxBC/LJCD8S1p'
MOVIE += 'z4wq2qecEZhkJx1l//W4lyfn8WZJsuRd42CO90ORD+3iRcBX2tO3CT/0x3LrV6ko'
MOVIE += 'SZw5wMELMDyXXhpdqhG58LS0U/zvhFRvFBPJH/LhkvASU41H6XdU9PFEcyxPvhPa'
MOVIE += 'mER8wtLx0W07q9pk+WWM0v7Dy0r5zgFgeDTF4tFcjRd+d8v35UnPwzfBhznZ0CSx'
MOVIE += 'Jbpp6385+W/7hkUeOMyOKPiRgem9YYTjqLhm4oeqVfDcNqhoDLBQ2XCiJcU8YoD6'
MOVIE += 'W2Lt8Eu5DTPPMIX+xO/m/d9e84wPNSkOmBg2EzwpOGz1jmGni1SiyNoZ/CDGG1YX'
MOVIE += 'Q/F1f4gDvyP629sgUhKNCaURzB70bXTDRRzLt93/BOaBJz+HCbf8/WN1bCby29HN'
MOVIE += '5fLGxq9qa9Silb6EvjrKZP5qklMJup4VDbuVZSNIyKHs1yF/o/OOz5c3ZUilcU7M'
MOVIE += 'aZRpDvfDStk5gkzjBEkOcJwK//RF8VzrED1jrv61/MtN2fsZO51E6XKg+jQIJvyn'
MOVIE += '9vjHXSv2D+AkFwa7nYFU7IH05vcOZ77e8rFWVg5Rb1anSQL10xwRhFUiNFUf1XeP'
MOVIE += 'jsiONT/9q0W/BCBBhulyRw5PKXagQi4Z2o50xPMDcT70xi1VXgbkurvE5Sn4yGN1'
MOVIE += '/1FiACtTKG5VkQ0MxF33ROPoNaD6XgeqbQqVgje1L581pweZZ0BTx/SiXs5y6GII'
MOVIE += 'PT70cm5FJHsGwj8z8oU2j9Os7yOYTxExfiLh57AH6VRp5x8L2qh0K6oj9nzLIXiH'
MOVIE += 'bqCOYzFt1nc9znRIEhUn2BOO0z02T9LTDDkBtOlPIcjveX5NFGFc4/TECCgqcxMm'
MOVIE += 'EtgrfOlkiMeQife56pWkUsgd7ghbXUvREve+f+r0ZIJm31WJUO2fJitV4cU/xYpj'
MOVIE += 'wM5xeVr9UdyJYjQVsT9vhntxNZLNA00S4kWbHrsPRyP++Av8y7gZPztvBu1LxtMd'
MOVIE += 'HEPbBT9g1CuqjRQpGpv0P9PPQtH0hF4udRTiL18NH9AYD6XQVMG1Fxk1MhcCWdVg'
MOVIE += 'ACAzq/a3VD9CNBNyXEyT9edwTc+idzHI0Mz/viqQFn/of9f/ieUzEqnh75Z0CSmE'
MOVIE += 'Aa7meL6R8LA5wGmzWFmac5s7/lClHyZwKSp+Q+y7hHAEUNxFvVcUtbHB4ocQKCFU'
MOVIE += '/jHucmiNMOlWmERE0VqP0D7Zc1Rnp3nBVq3I45TCG3eHMab98Z6lc5QnNkDhEH1z'
MOVIE += 'vogUwW+wqkQCkYQ5Cy/qF7N1Z6Fv5898TlndUYLouh7jukuOzK1KLvrVMb2MSsSi'
MOVIE += 'sSB+jZ2uMRW5ugUcQ9g030mKBO7gWLWBE0eXAPJzvy5Ds2+ZLARLFknffoPISGA+'
MOVIE += 'vCSLT1NAr3NiRIeGRZvEbDYh5I765J3aTQMnshs1tlspnveC49Pq2/M9mjw8Op+K'
MOVIE += 'JvWjbynen6OGqHRZabkwfo3vLczJzwl3KOHD9oqOwgZfgPbCdBT+xYacLNTHj0LB'
MOVIE += 'keqVj+a0ODii8LdZGVqdeH6/Ry34KNSq3rBlW6ImE5m/8yJYRV/Uuzd3yjJ0iN3h'
MOVIE += 'JxwOmLyLM6RYd5WfFOuN439v/E6eUltdJSvFo44jaAifFMmzGQB+TgKoP/+XscvV'
MOVIE += 'eT4AiflJSmWGVGYTd8PPwJjJ4rFHvtR+gmPgK6+u/6T8aqQMvoMy81TRysCpe86w'
MOVIE += 'oSFFkI1yCF/NvLvhsij2QrbUiD//SvaDK5tnzu36nv5e1FyBOsKiU4OX5/vOjqLl'
MOVIE += 't+lylwS3bKpaHVrCBX1+4Z95jkvlyxE+mXjP0AQWanhcyR3PMMqPvgNigtPTxsoI'
MOVIE += 'y3V/c29SieEjvpfR78irLstl8RCe6IvyZus/WTnQJRmOGvewyTG+c3/lI/RgyvUB'
MOVIE += 'Y4IgZo6m6/KWuIpdxeHp3UmgKns2g64j3Zt2gJQjXeCu9YDfRDBQumKZaR0IL0Ka'
MOVIE += '+7twhKIJNFd0HnGZpbqaWYcEzS9D0kW+ln3Xq4Dcl8G/6ppaRXY/PCYXeykYfLWc'
MOVIE += '23MyN2FiOcInTHEiH9KK5sM+jokFVvNqmwrz4NAUzN68WUNUmuyrUV+XYnxoJHJZ'
MOVIE += 'FbEO66xSDlCCnHLTz3EB9BidQwntk9zn1cMqD3LMX7G52fHLZwnzUAQ6EPQ4iCw5'
MOVIE += 'nPLIZXNJkKSXzw3P3XThDXm8n2jpba6yaJ0WqsoAOwmST7z74faVMuucMnAIMccl'
MOVIE += 'kc66TOVvrH9A1SNB7pTANLzLRLWjk129XpZQ6k+jfRdsfhCcK1/SYV/BwVerbP9S'
MOVIE += 'GZ5O48nwqtHHW66Vk42zI5ne/D0qa+sshl2lXDahS7MKRagt6JM+ZM3+4594I1VQ'
MOVIE += 'Bb0k64C6Jq1QDI1EzWtdLBlHBXqWlQHl6Uq48zijsjSKTdca7C8VD49YDfTI1WGL'
MOVIE += 'h1eWvx2fAWnObesvB9TRWsoPPW9MkqvLuzyMvp0zCXJ2Z6hRR/hh/RzAQMJ8OXMj'
MOVIE += 'pL8Yte9DWhq9q72JE7zxpZv9EOdXahZ55ANoEP2OaSEMF7n26IVL+NM4uAs1jw3e'
MOVIE += 'U89TsjQMn2YiTz+IjwhAEp4bIbyebUPwqjITb0xYQESKXeLbZRw26PibRSNB7J3o'
MOVIE += '0M52PoHR2cf9emMI2MbuV/TFQ6dzr/5a9IMq1FNRXtD8iPZ5R7c8aw2GLfxFJeZJ'
MOVIE += 'bXhDNNhryV9tLry9Emha3i15ZVRcw18LjX61fpG3eqDILc9LHPzmvdjXkUDLOnWW'
MOVIE += 'ekpceSQ+rj8l1lljFJSx+zQfPqZZQZ+l5GJfsKCoROvUEnMmHEo+zLSMZeAAWORw'
MOVIE += 'EF438cEBuF4fHH0tsIAk3MzM9CzESoiErrSgaMChPmH1ma4n2SsBnY6CgD5ELtGC'
MOVIE += '3LYLjOkba2csf0Oo+B9iWz5W6s1D7vNUuxYQKAFHZVMg3rXyIwtGbIekVQ4g0Lls'
MOVIE += 'O3l0bKpXNbMLVY0B3B25GWnEAC3YeQNxL8/Pp2X9Me5nWb80sierEjM5bwY2GubA'
MOVIE += 'Vrdp5LJtQFSfgrFlmSPX6gndq4H0FO+56Ae98vwVlOZIC3naE5eQk0PKwqAhCngF'
MOVIE += 'A6MDJz+OSnOISdOZ6r3Is3w/k3Ulpr2Qp1PRj2SEsAqOpNKA7M2r4j72RDGZJCCy'
MOVIE += '6JCUhLA5sMuFn2pGAYbd37aM+ExX95r9OrR/lkqYvvtXeWOevmwFZVxFqielm2aw'
MOVIE += 'H8CBED5NtbwL1V7H0eAYeYqoSg2rDH9Rlhe55b4PTCs3snYiZV4BEeJAV9ng7cOw'
MOVIE += '1PUsQfyyEZcSM/oIM6tYrvjEFEKPuiV+RGfCnZ9s3d0mr2mwXCfP7SrI8rsPQpb1'
MOVIE += 'vXZBi6Nbi6MzsBZAzIG2p0QCa3fyX8o+0wGOzQzppJpaNFcCAnfIpvod4YAueSDJ'
MOVIE += 'VD8gjTA2nfAZ85+E0r3qugNt1fLSl2wgD3U9BUNIr7KAaSvSZP4l8ENvtpOvvSH5'
MOVIE += 'O4tkRpGKYZIH6yDixk+p6Zxpd1OlbU6qFADgKrDQ9vrj8AeqcstH0WPrXY/lN6me'
MOVIE += 'woawxYsvd7S0VSHAAcAPl9ctxQctI/s9Cljyw83H3/1fXH/WlnbQT/+Ae43gpwzo'
MOVIE += 'A9a3ve/No2jc7vlpoexa9URZ4pw7QrmYYeaS431mW1kRwxmlmUKyn3pM2N1bAb5e'
MOVIE += 'XR7Aji9sqFiJlPdcX5VtZ3u+vHpMvOSX+1trUGk7BLiFD6mZ4lMtx5FtTWycwcNk'
MOVIE += 'r50Eg0OLJnl9rOkH6BuVKvzKZVUBiYi6etnEnJbKhs9BiiGOTLUOTA+o3rjG1Tsg'
MOVIE += 'CenddBww9VkPITx6XYAdeYEri9aCMag8Txsjb8RWYFtVN2hL1zdSs+77BJmCdk7k'
MOVIE += '5IeDRrykwAZJvfpbGjgr8FkqaaM/qSjTxgWjjjTAb8AS9EaCNtCRUNkBiC6shyOp'
MOVIE += 's/WgjZWZxd/2q126iw8eA5G4f+inriE9xaD3eo+DRCeDXH80VCYNwVjT0lt6yW03'
MOVIE += 'iitZO0WfKGQL3lXnQTEgybY+3ryH60Fokeno9Qja6nxXwgn5R9PRrqY7vs2qqotW'
MOVIE += 'vOOyWDNkhM8qr3QeOGMWZHwxbl219sudFPOU95o+6WrTLFn6LfHTDSLmSf6QGIfz'
MOVIE += 'pPPHeLasNcvvOAvZCE9m+dS9Mz/jiHzcvC8jLaNiuQ0/ZHuWvslPOi+KBU/RA6QT'
MOVIE += 'yY2nQKpdNWrVfOYfKU8+vknl/E/G/b/4YF7CLJxaxqBS/g6J3ZFZ4VHxVSPiTd/r'
MOVIE += '2HqY8rB11BK/xvlh+Tagg7PynK/jz9uMVDe3Le15h/hj+TKf21mwz3Ozpu7chLHd'
MOVIE += 'OLD08faLvUMp7s+lfrx+xWQEwPe0v3Li7b7ePe8++hq8MEJJcVmoK4kd1hgNgv5y'
MOVIE += 'K9rOao16rwC8TCZRKIoCP76Wd3jT9TOZ1H3wqb71B2s2U5d//Hvha4V7X57GzWOH'
MOVIE += 'P1gP8wFmPr99E5X99KvzCzmrwuAXA3XthEetLoRVBtDgkCQzALZYLb/Tssvksn+D'
MOVIE += 'G7tQLsnQ21BQfeK8ctz8PtPaabbG/06ZYOxzOeLL1mHL8NqTw6vvOoHmb88HZd7m'
MOVIE += 'G/1ceiF3q7HwyD5FqgIcgPdV6Plj3mdv+mgiBNG8MEfLeTAJvBygOgoyzgTXzIFy'
MOVIE += '7N1irgOs2F7H2a+vbr1Vf86rzXL792d7pi2kYo3Hwf7viv2for9BZW/kqZ7T3s3L'
MOVIE += 'gAhpSUQTo3KHi4EDT21sVB0AT63k8MdV+D7z7r/7dPNFzy2wO/D/jSJ5q1VM5vqj'
MOVIE += '+/+MMmvnT5n2Qtb4Oa/04GX2cPGTX9f5gqD1SaIZRQyBUpj1n2n6gu8fPO82tQ6t'
MOVIE += 'ZWs+bPNqP8geeTC9t+7x4v1/yTZ/V97S7Y4T5R+2P5bm8aHmfbO9XbDXzr7DYxie'
MOVIE += 'XkDGI+1wk7n37msbIA0z/Kr6ZOw57zZeN0/ZFn/fn+i9PzVj6+SivJBnomr+pHHW'
MOVIE += 'L1fs/5qYUiCGcIv9nwwZLE9mlwqVzeUakM+lD5ZePybamcnX453H3BRANhBDv2N9'
MOVIE += 'bxJWmwfRV1+3/tyZCaUdnJ8D7ZKqn73/YfV35T9ZKIfo4FNcuZfcfHlDnD3vhfz6'
MOVIE += 'v4WXW/i86n7y3/z3d7hP6O9489beq/1plms4rKq+EpNJO2i9MvEjbVWFXt2P8EK/'
MOVIE += 'ImwlHf2G+jmvR8pJNlva75LxGavfruMv988X6V/wpjyt53vnZq/Od+J7lV/5v9U5'
MOVIE += 'S8bn7Hv+vej6v6sPPl4h6gBQPdjIGwu6Q2bz+NK+seN76X3wNEC+I4W8NrxsAIlv'
MOVIE += '+DfACiR/a337+gHPG3urvDW+uP9uf8NJrgz+NxfHV+c1MXvx9ntqDA0I4BIhTvXN'
MOVIE += 'G0tVdOyZXVa37W12pU5WlDbPxrulm+m7+2gKXK/y2fQH0QeQZ9ef7BHCDR7/m4gX'
MOVIE += '+pe3sIGd02g2EE0vZ3m+Jl3F9gBoiRBJeMuHzxOp02h3+1lLJJqFXxo9/vPXaeH/'
MOVIE += 'GeRSMRv67JouW/KpYtogmvU+FCNx/R/dl8Vst0BkWY4szz9ccR0qsf49iE+at4TF'
MOVIE += 'D1f1KrGex0lurtD4NpXz/6xul0839N9Tu53/u3qLWFcBxYMXoIjBUvITwX8mzxwr'
MOVIE += 'Wy9LnR6/tftd2/uUWqxGMP735jbvHtVXMRl912e99wfy2Xbgmwe6y/Z/BcUS9wYC'
MOVIE += '2ZCiTcW888js7WuyBPPxa/ty148Qe/oy03rsk+KEu6Q9uf/f+g8VWovXP+s8+Hq/'
MOVIE += 'YWu/50GYvcm+pNOWy2JQhInIbXtUWObeIkT2hueNvKrDp7xfl3eMHpl7ZP//1Uvv'
MOVIE += 'ft12l72cjt27Xbj/grzdrOW43zFRWi79pftlTO88N9+pcP54DeK9Ts56NO7a+KaG'
MOVIE += 't0y2FiEb2/KlVHnnfuc/Ba8YIQAZf3/fyPH49E/ch5EO677f3DP5CGnkx9y7/odW'
MOVIE += '34pPYP3NB0bVpPn/5xw0kr+Pp14VfZn9/x3kycewl6oOd2nkiE5grfHflQeBlWxz'
MOVIE += 'xSRl5ZyvaTbS9V83RKV6P830YEeuvgX/+N/x/9/ZGOee+PPd6yjv/18obxXLDne0'
MOVIE += 'IT+/5sjy1f1vlIbB8sf87knF2+M/mro2MsmlFZuz2fTbQR6fJ4kCASvf4by4kbft'
MOVIE += 'UWAHTHbp/5kUCPNXsd+nI4rZXGIyn2TpqP/PIH+L/7fDxZX8NFymKTytQOSP7L12'
MOVIE += 'OvtvTfs192djm0LA18+uiN7/fwx7iK93fjig3f26bmkvEmnXeePqs/cKdO9PqOKx'
MOVIE += 'dQd0/jHv9f1GXXyev/2H+wYP9FLU/r/b/cSbdql4sFc293/X3VtuYNuJrxD0q+54'
MOVIE += 'H3/Ao3t6uiTbzND76i7RIzOXjW/vtub5E2xF9WGV6s4g0l8NupFUEPX0X7sZYOf+'
MOVIE += 'IDjfi/AXj9PKeXRjvJ+++j0SQZqnlp/69/Jua6vJTsRkM1DV4Uqq7X9B/991ua7/'
MOVIE += '1PFtDqCLW0Ab/7vO/Wexl8NbIw2SLucZpuc9IQWm4XgGy7cJcd0FnYH30/FrGksp'
MOVIE += 'BUqK8mav+18A93v+MGRJzLTnn22iIp3u/9sBqqAtpvtfe0sBJH4a7mbn3dv2UVAa'
MOVIE += 'MsD6yaeU+0jkvz1s+9+63Nnhn1g2Qgt0/yS6d7HcPMT72m3xd4XFbS/40z/kkrNE'
MOVIE += 'wCO3rPebRDx2dg/jtAwHath439TPO2MP7q9k/2flO/IfZ5O1vydPWXqfmQJ27pDI'
MOVIE += '/y82+/r/YrOTgaf/P2y2/xojBECBh7jYy640WZdWK9HMrJRT64MxGsKqyt+lIxfE'
MOVIE += '0bByAIBaOnSivD0rbjofFdCrOqxRyKX3bga3Ndn5eS5XOqNXK9iksJpLMZvPdqrr'
MOVIE += 'Myk9rW7JhQNbdHyTRadX91Q3/1qLw0jSLLpSgIDBkcbTiurTPU/b1Y/CzFz3vYyQ'
MOVIE += 'VRfaMTAtTa947B9f5/faCwa5QIrThWjtdFaVTDyFyu/137qnpy48t2f6Oj+/L1dJ'
MOVIE += '/nk2Vj0MJJ1Ryuntrxwz2IIRW6zvkE186F3IENBCMlDkCeYqfgxwy+YodnORdCUM'
MOVIE += '1qCUyud8+rh/oD+kVm7Y9svFbsuvrztD+XcrAZ/ntgTYt6LSK0JbZ3WdC1Csv9zo'
MOVIE += '3YaCfyCEUixEnN9lbDwsdC1IddvBwugLoj3rAqr0vVtLnZKEaiOd5jwBjNgPcays'
MOVIE += 'LsZA6HXtorGcYd0ojfvyflzgWmaCKlNWQbsKmeCqRVWgfHjQEIHJ04fmFJbyC+bh'
MOVIE += 'qmnUqjZK212aRMfUMsOW59QSszJSR0q0z6T0quzp//zg1kBixX9aOGDIwy2jPGoL'
MOVIE += 'y2khKGlr4FYkaFe1RuAevlyKpMJosfkf1Wl4DHgWPZKHfM6pkPZpf5ckyRcLJn0A'
MOVIE += 'u2QISTXvt0ncDp7/ZM2VkTFmE5aTW0ZgZmbGEU7Xm6FJJ5nhYMcmknI3v9/ALm9k'
MOVIE += 'qpTu8Ds/z9N/w9XJPu7YggNLbb3hVtjQcNZRbelvBepgddDnbXV01nZgnMiDA5/9'
MOVIE += 'PW5BY8vMMVLyptwm2iEFSlU1QpPzWa+n2ifOB7R+XKhI7W7IPmRrKcpQZRbJqdlu'
MOVIE += 'cHSFowiU4CvjzWrmEspEXh9fOdo6pyycvsT9kzprBWdNnr1jEQ5UBX/wIsJAloxH'
MOVIE += 'J7mL2zwDqf4bH9Dp7eyWUSOT3tEF1yhOzkdT2DfrfJ1P/YkJ6ludBPC+oTPtbjAX'
MOVIE += 'UX2sYVUUM4Ua2i784dVs4SwBghmd8NUwUVtHiown1/gmPB3TpdTicpsS+LX1irwy'
MOVIE += 'qviD7AQ9d43FndM3reAnp1AtMCMGLZ1D+FGMVF68QnohQ4pTVdZNertyMcMO1WZe'
MOVIE += 'FvfUhIHD5mOIRfUm2pSiI20u940TpYvmhtsfL4vnnsI/Ee2PRkqbRrG/FKXoN/Ju'
MOVIE += 'D4lqS4yTeNs9rYu53wSFqyqDEP4YkDbxuyAD7e8XI58yw75m02VpGsdTfCtKjoZ/'
MOVIE += 'wKBzLThGQ071lGK2S08ePY7QgHck2VWbcRWs3QiNJUDOplabOh8T6PYwjCLZvvf0'
MOVIE += 'SnzFiiYrQ3o4hYIEwOQSYgQzBfhDH/YBKtToYVLCFaqwx19jtD1BLGmsBFK3SE/U'
MOVIE += 'MfAGDQCZYGvMfcPtbzXRb5uPkc8bquyJ7jThIhmwDAJbZDRFrgXa/vGxDoHpDijk'
MOVIE += 'HWw75CKpl3U0CpWTAZP2BnTs3s9Pglp6PUBl4xpbYTgxTnPpwKO+oJVqnsU0u+HP'
MOVIE += '76KFcJMfEmb+OS93PGlPxmIukHGkpKhlw0ZXlIAvz8jlbGTqAGYxGhO1ClTxgAO3'
MOVIE += 'cfUtoHKgi+d91u1Nr+Bo7svUehftyrTOZIWcetsv/WU6/gBhq8Nmhi1ehOWwP+UM'
MOVIE += 'vMbs+a0+PDY8nv9xjG4gupKtcL1JXXHxASDL6XyHBuFi+60IogTm5S2Aizh9Z39e'
MOVIE += 'sKMMa8P4w/TwOnRrZO2Ho2Vnxkj2pzcSZ/zxmEsouPiPgRTBy3dA5sZ4gTEbHSMK'
MOVIE += 'cj7mG5EC2NiUVL1T8Z0tL6EaD4MY0cSLf0hU0atpVa7aTH7vZ9+LZZB0UkAUvuiz'
MOVIE += 'nGgPf8ofEQCq8xaT0qNbEP9L4HtK3z36xII0nbCsTpajozQL1mSrMjSIvTe9HKRT'
MOVIE += 'b/wAFfXvsarQ19czDAXIBa65uUqvJzNfqisWbJhGkrg5YezjUzDllIXq7ZsRmlcr'
MOVIE += '3F1x3eJ1RgAK/9D3+bWL7nq9x4hfyMQ+gJO0diaQzK3aoHZWuF6yN5oEo8lcmaOU'
MOVIE += 'ofPXuW7LXVdU7YfCZDOfGj+hXgp9VNOy/PjDkJBFGHKnC+aABkvDY3lyurJEnJd6'
MOVIE += 'JBHm6XfNEqysOZP0XxrnmMV3pZ8+fcExt0NR/SMFX7NzTRLjRc1UAOhgrs99PF/1'
MOVIE += 'doIiBSLD4SsSGv/iXgLd6f6Ei4qyfoU3IqSrmxNGy5uAgdU7kLb9pWQdTcQ8GJUa'
MOVIE += 'nGkCSnVWdH38RpMryjH1UE0uw8UHixcy5q7jRkV6Lp7I38lH1KCIY7eu+Ny2qpYb'
MOVIE += 'wcOw4jSxyxhLpQtYKh9dnzzHWAo+ekgH1Da8B6gi9/bAXoaLUb0hyCAMkHgeY5+R'
MOVIE += 'gA5njZxMEHLvgtz94hbNaFiPaxLbQRaoTkGBYbLz2Ng9EX7kRBSpKHHZ78wpU46j'
MOVIE += 'VaH5Yk72nBGCUGSeQwIFLsjU567T43W9eQ3QSj2j7938DUPcuCUFaXjFu1l21Yuu'
MOVIE += '3HENuj73qNiDzPzO2EIaVQqMPyPT0u/sodWAYQRN8s3yu4NX1UJQQVhIvS9nj2QX'
MOVIE += 'gHHPP4qy4CJOk9hFiD3t47PrKoTM+76msHFhEAfOm0Bgp6uTHD3bO2nVuY2Yf0bI'
MOVIE += 'TZ8c6VGG0ifQhu9WmmmBxcL9aLOu+VgEXjGG8friy/ZPHcqmdnMdl+eH7aCUKDJj'
MOVIE += 'aa4oGfXnp+FHlLCH/03BH0njl3gq2H171tO0DPC2eGCUFJW/R/kCFSvDhwRuwJHA'
MOVIE += 'x6G90PCUsz7eJ+sbhsrZTZ3RwvADotmyn8mtgpsvV3elhO8uhbOCaPziM4uf6YE+'
MOVIE += '3OnT9utnYhgNMcPwckxs2bSj75hoTPEvkuZnzlQ7v/ReyuU9I08o2TuuQb0jorq4'
MOVIE += 'KCKxhlC9DJ/5hxZdipkoW8tUqso1wtc2sJ5w/s+QbeYCvM+2G4v1JSDNmScpfzMQ'
MOVIE += 'T8L5hakgB1Rb5IAXoTnD0D8fJLAvTxKBNBchdlzZUBIdO6xRX/Tmz5zSSHh0Eg5U'
MOVIE += 'JgW0LNVjXr9bjVBSZWvN/TdqJG8IYuEIcAh+05Gq/oH3U9kWJGybEB5SH22H35Eo'
MOVIE += '2ztEErIzwrx8IEZxCch/X2of8vW89Pz2MZI8SKBukMawv1pJ+HGA8v0kx0WIvblU'
MOVIE += '+/rqLikEP+LWvMlqfPoWRCjlA0Du/K68ozzWy7POk5c5l1sHsWzhwFUkfalTjsp1'
MOVIE += 'r8SsAbAiOCLLgcAaA+Hew8O7VlTbxxMYY5RDhzHN885IyX6sYD2tpXH0N7QM8FPD'
MOVIE += '4pvCH3H2PrVFsoTDYaGAZ2oP5Q4k1BionY5DnpF30NMs+n/BB7A5+Fy+Y/VA6hOy'
MOVIE += 'Pjz9xqONhQRxgpUNZdSrAj9WMb7MD+yvgYTglDA7eIvjFNThePdk6iFOTgwmUIfV'
MOVIE += 'YioEW5CHVbvnWeF0jDpgLZUP2DNs4xyiNuKjTH+4CV2HZ0KkxHj8/3OJxlj4F3ED'
MOVIE += 'hvOU7FCPH1jAY9r0AOWAw7ur54qXYDe04sSBdBfERC7aZl0FnNoDE1yGbB8KxXSL'
MOVIE += 'aTvg9eY/CXEg/hT0fNhRfLdchsUhzGM9UlSKNtn/wci+hK4r/z1yOFwpfvPVU3BO'
MOVIE += 'fKnEM36aiDVIworx46Ry2AmcQa4eNFGQ8No/YLMD8LUcwpFDJXrx5KDS4N/nmDyK'
MOVIE += 'J5zDmAcYSNE6pTLQ075cXV0TLP2dKn0RLIeJ+eGRfrhIsd1G8kky+RFrVBA5nm5H'
MOVIE += 'ZPewcEMtFJcQNa2aUkqt16eipab6eCrh3s8HZvTq2ZYLUEI9FcnqESnJ8PUiNK0D'
MOVIE += 'WjwPeWnKdrWuIHfxBJcvZD8POSrQly5X9vN3sJpg+3anzB7HJaytwtZPTbUbKnG3'
MOVIE += 'n/5RBPSCjZZlgqMQj1ZuFNKY93SIJ4VzVdWG4tlYPTrdP+VZuBblRm51hvzIz2eM'
MOVIE += 'jxlS/NVR5kCuRIdfXWAMDt8dySuQK5aRTfFWjfbhOuSDhaLorrV1mwmPqk7hMHvG'
MOVIE += 'D47axfT9Q9PX/viyOE84DU3yY+q9Noh5RgahpVMHl536L0SW0rOxcjrrRDXbjdw6'
MOVIE += 'B9LXItZLiOczYPDwp2e7Dga8C5RuF2YjakzPHssYxEHc2vAuRo2Puqi+XhtvjIi/'
MOVIE += 'X+HQG1N5+jndIAui2h52vBA2H+JqCiQ9MITm8OaaTHKmcdh1f8oo/wFb2imkoCui'
MOVIE += 'vCNgWAgveoCAlnIwrK8/rxPPzpqXLC6H/JQSF8sKnFhxMWDFCCuxF7CnbUfL/NpD'
MOVIE += 'mWSCXA2ZH8+DVAuZAy4hFTS2aoXJj8gLly2jGs0LIcu6aTFOqF70x+PSFwRFexu5'
MOVIE += 'NTiS8CpQgnSeHdKYyhS4uU4pvxPrHIrHt/tijTX/c2BVe5e6erS4OL1Md7DwVgCI'
MOVIE += 'F25Yl10ukoFvgNQ0B6rqNFCryZRyalbwFGiGF+DNxSAscs2yqo18lpw8KCqpjfyp'
MOVIE += 'd4Nph90BOKCidB40IGA4FLD0nVSuvWqcFc6d73Elmi6XIfY1K5A9OFQ+REgcCTES'
MOVIE += 'AZ3Q4BE0gnHiD3RkH+jdFVGDCUkp+Wpo6OXC/Z0S2kuLPO22tRwcobXkAYR9KJJ+'
MOVIE += 'h+gTNAWXCIDGwZ68oRbkmLdlCtxFa8SygR+7siQiIYLfip8lGfA0UPjGp/WfFD9o'
MOVIE += 'I6mNtkvMgKh6FtRVKnIj8cx2mqm9SiljRQp/I+hDWkoTyUr5ysY7iccdiCcvCDAW'
MOVIE += 'jQgKIMNkozs1NFxFf59CxX4+NgSQNN7dJCmafkNFutEGICoHvFmoUj4ksXSn9FHK'
MOVIE += '0QkBZckUmpZDsyMKS8xaROuNmH/ET/XSh2QR+5oQ96G4Wy8JZKX1SeBtR4RCKTB1'
MOVIE += 'zyvtbzExMLfQ9aoXS7XWBVWQr4ZARAfgrLyj7u4d2M2f5awnEvL6gUUAaA/eQMjf'
MOVIE += 'QsxvR3uQsVZEEPqzAk5VVOvQPnFhVlzevqJchm+YAAN0sE7DWHLgpVKA9YR8GJc4'
MOVIE += 'pQVTlMRLwddimhekRP6NkT0ASw8h7QuMHH8y/SH1Xm0zwQENh7+bAV1u3mSbQUwD'
MOVIE += 'WTGB3U0NZTHRf/3EtRdmVfRF7EmsUMBzVjm4HVp7BK9phR1aYNIzHZDm8cRFprPH'
MOVIE += '9JUd1BBYcVqc3gH1huOpo/iuol9FvH5luQBUkis0BPTmETyj95KzOZGMe9ILE82s'
MOVIE += 'wxBPoAUn/EkmkK1bNyA7KYYusz7QULfbDdcGINugh0K+3/rJBtga2TN0V6TdL8Gu'
MOVIE += 'h4ISXmQWG1HALki7+6h+LdbXOYEsM6DQTbyDdtdOhtd+C0D2nVdG/W3EfaVPjyTz'
MOVIE += 'HC3Xl3Nh8SQvkFZ9gFqa4wG3KeyiHHxT3Dj1iORxEUUHVVJhQYQ3BoK+tP9mgRV9'
MOVIE += 'Ql90KfXGkXekX5Fes/5PB5/8tGt1YMYdf0syh1wBL452uhCvJGWvgShMWZC0GSZ8'
MOVIE += 'IQVFDlEOEKX4Q/w6yMHlgK848FE9RK884Mue74Vmk4goo8Wtcd5P0prX0aWm+prw'
MOVIE += 'wB8dwxf8uuxo5pdZMO3Ct9o/bA6QeBK6NTOqLYV9RoVtaKiuFZKvcs2fuMrrMasV'
MOVIE += 'oZpNAoEROPdOFWY3b/VZNu95hqD5Q7ENOCmKTbEckXS+N1hkiO/wSkygWFvuAvw7'
MOVIE += 'gv4R2+Sq3MMv01QKcNIPF+IWzkEcqAyRLU8u/9fcHiP+brndKvjGo++eCrTbehIW'
MOVIE += 'G8qXaZMbSU1C/CHPkSC+JADjxQSjFr6yhygUCfo4jG+PatrGU3wCSBI1YvtHKKOX'
MOVIE += 'QeL3WpCyrkjiU4KD1JxQow3Uetpm9W2IzzvTyUelB9OLyyIKPlp7WoTVFw2mH3JL'
MOVIE += '/AlN/Oc+RElZWvfJYODka49RaPx3Dg6aJthEXMS1Z+f2CFj0tAc6D6DvgPnJATZ6'
MOVIE += '6yQ7hFp8XnnN1E9xv89cYe8dePoNG09zB+WKuYyy6q8R0+RaQw6UBcyg/zYkXRAo'
MOVIE += 'XnDREDsvzmQ+B4Br+gRhF49fY2Ll/fGe5pIG1SwYwNI1DYepqjNBFUXwtQQDGERu'
MOVIE += 'kd1/q/M/I9KsSUjGApoRilhygMUstGk0mS2Jk/gsLSnO0ik9nRl3nthkG2c/0KN+'
MOVIE += 'qFU+JB+EA54WwWVQ+G/yYe/gnhfD1tIqU+wr5PceBlzt5KwdYpnRkI+45raUVXqe'
MOVIE += 'Cuy8LZAq/LM/6bLVGt2P19COteKFtXcz7RHqSuQA8Afxvomf+HxwIK6FLrU0bEO8'
MOVIE += 'gwALWI/EKAUlplZOKvQx8maSAObpZADWbjIMy58UdLKBVXqbVXdLb80cmny4gjl6'
MOVIE += 'HqkTcYkUdP1k/VCq9MEhglB4Z/TUzB506XxE7OGfO08FARuht0CsShqz0R7zEGNc'
MOVIE += '8UB3TxbDIH7mPOtjZZ2qxW2mtzs4iHmU72skukjCe9A7RWxiO/LL9p5lIx5y3X1K'
MOVIE += 'Kaa8EoDu465hAJ4vf3U1TjEcuhmE1/0hPcrp12JVbv0F3p3/pPAP7JsfoUNOSoT8'
MOVIE += 'zylRoH4rwemDguAC5IN/CXmrLJfD688OlFk4mJ+kkXTk9r/abe7NLiRpggE3udrW'
MOVIE += 'Y6Tvf52sqc7L3QQL5o4S2oKK63YZta/9IexPUnMFlK8SbCIVlc0YSb9ekArgAG6E'
MOVIE += 'gBie/4jv7ln1zKSbsGaZJTC7vpIMKoLPCsA6+cKWkfJJ4opwJoV29Lhe7riREI2p'
MOVIE += 'OSksmFQzR5WO2f3JdQbt6bs3KhOOdoJkRvsls84dEgzEO9HPccgrJvMYw6K67vXe'
MOVIE += 'p5BL6k/jCgxEhpOfpZVzr0MJywG+OmevWuAw3MsEsYfyF6Rf4jcgAR+h5QCUVhrn'
MOVIE += 'YpPz66k0kF8bbLeKmaaKorARr5e2cdcyyejREjp5XrJtW65D8ZSBCCBMA8w1nQWe'
MOVIE += 'NvLaWRcNCpI7mN+zx1Fw4PI2wMjf3q5cq263Fn++Z53U9zriDS3L562YSwkT4Nf5'
MOVIE += 'T47EAHKM+XO0NBQARu+QfN0hEb37SrKB/K7A7HsFS5Qg9DNxc/2iz6HHWbosUzOi'
MOVIE += '+ZWksKG19Wue+Py5LSGghdTQvtZXEX5kKbatKJZlZ81dNj86Cwvyh6zM6JHDBwtb'
MOVIE += 'QDx2IQTtLxf1vyDtv5xYFpW5qD+hAfjJMsxnKcHaXuYy+r6kC/3vkOTh0PmDr9Ud'
MOVIE += 'ga9DpVOkU2oeNiwN2aj34q6USBod/H9+ED0GkZ+Jl32b+URg/QJOk2EXPR6NJIcm'
MOVIE += 'PV22+EyebgimcaAnMPzlx8bAXmrFVg6SNf8jaw7mwwFt3adIH/5K+UJO8MAYTrtK'
MOVIE += '+vBWxWJSi3L4P5rNPvFreknQIl1uo+LXhyENMfzROcuSzKQkBXc7sHSDiST48rnh'
MOVIE += '6NSA4MWrBK7OzBT4jX2a2lHhPB/p0yCHS/aQWcUJOpzKEcezLUYAXOPolnXfc00p'
MOVIE += 'hiCXvEiM+150AGCjKJduV1KKRXH4NU8E7L1LAwKoDDMEt8joxSMmMipE77HZvAE7'
MOVIE += '1wuzo4nk3PIFF/NLnw3KlbBuCJFKboMKrVyu2YsK7l5O/cbgY9G4GTNRzy6vp9/H'
MOVIE += '5x7KRYwmSZiGGlbrpi/T8NfOf7Hu9Sv+HRU3Sd56n6Y9/ti09tUeh9ESvJggx9BG'
MOVIE += 'Jl427CDuu+1S7fb0a+ULyUdTaXfpS9grcROpLxiknzGMoTQgbGmIZsY11vj3cQ9f'
MOVIE += 'H/jfBN+9GyZ/IBS+to9PxiwacZVA13nfn6LcL+P6ZllmnsMyi/Gp3d/fCYEmLaZj'
MOVIE += 'ESHeRa0OI2krzj99uK7Sa7t9PyruNlvOHSm/Ln5o9B/uN7CY/6Jw73iD9FsUOzmF'
MOVIE += 'qC87YsvEX1TYKTsBrG4R7Z226UPJqryKuJzpgVVeOw/NhjrGKI8o5lyUM+p7I0FE'
MOVIE += 'pgl7Y+xp9UoxMPoJvVcgmgt1Ao5QRKt0gYV2YjxLzyQOUt0cRBojSgF05OasotJm'
MOVIE += '/NJ7ev76Asf2Ur5zfsqF/sc6uL3DbafY4I3RxeKj2bd2yJ1OkGlbZhWEnG10CA+1'
MOVIE += 'BSVJk0Z8N4hRRTXPUX78Ngz6QIi8IyGZYRTAgRYBH5uVE00xyXBqeAI6ll23+owM'
MOVIE += 'IUrtacrYaTSssYeBdMRzCaEqojlqGPmiERSFQuaWVRysctz1J3N8AoOLgTqd8yqP'
MOVIE += 'FMayzEIt3QprTjeujzqS9bz4r8mAyvNoDLsOZSUVVgZ+MzIEY8uhGn2A+sATv4qQ'
MOVIE += 'cfqwpDoxZJTIhlZ5H/SxaGTBX4q9ftAnqFykcpSQH8nAYibYykkfDnMvpvKf7eat'
MOVIE += 'DOZR2UtsOgWU8DWvz2k7vJr61iTYJ/913c3E/PGG+zFf54F4QIXkA29Op/JyKpXv'
MOVIE += 'wbQTFN/Zhkd3oIAPkUqqI0qJHN5fyJR8xZqBocnbZwmKnLZ3+2TCaeVdbIyclUcA'
MOVIE += 'AB+azSzWhEK0hnlgcmeyFtXT2lDZ4S/3qUYW6UggUg96nOIwxt6j47yic0bfQJ71'
MOVIE += '9SKP/B3HbOFdIxKYCA9XVVXVIPHPB0r1D3zLvBEcGASrsLfMvxooWPIkD/0nzzq+'
MOVIE += 'ypRdQe9VciSZmcUEOPMJv273QYZdjJvVyR5h9lKUCtL8LCuKptaalPFe8jseZLBn'
MOVIE += 'oPFEvu5r0Djq0J0TGdz+yT8eVjscZ0mP/Kawy4gE6fX/F1YFIvd6yiFuHibsnpZj'
MOVIE += '1+85Au/d+hdTco46d4SwDlxkLM3MeduckoHgbRifWwd8aSTDVzs2xv84j81Gs81M'
MOVIE += '1uPu5G2NtB7NBjFfVUopnGSORXA7JxcM/BrMy/UU+mbJaH9BWVCkFkN6z5H7jDeh'
MOVIE += 'EiKBZDXN1gRe4aOn0HHsd50zq3HmDzj4XEg5vd6zmMKBEU8PAda3Bmk05QDoADuj'
MOVIE += 'M+OnR6FtYGaLNumRXSUpofLsvsHUaCTHNuNzJ5B/jsqjLd4Kgpr44fYCboUxQ4Nf'
MOVIE += 'djAVxNyF0HJg9lpoOJxNfRT0RU5zSfFTwzwvX1LL7otTq+gHieK4oGIquEbMNW+L'
MOVIE += 'zKyR/Yy65HZFDBePEoFYRc2GC4BRgj4eT9pjOPBIs732lqJg6HZyMxyUppBl6PLs'
MOVIE += '1pnQTBrmxNiUESdAz0Ze15t3t7unePMYuL8NUTOAO+mDHXDsYcApwOVkdvUWMfvh'
MOVIE += 'q0w/Pa7gH8ZMvOwEAOXBA3IJB5w6aEfvOSEaQH2hLj1urkM/AcAfV2IfCSzMIqjU'
MOVIE += 'gz3y0R8/03wleuRQoLSbeFGPUm66SOWfySkT6+NI9XjmWfTitZtOy3Fyn4C+XoTR'
MOVIE += 'KG8tpkrzUjcYZlSnupeveN3eKfr1ylOBXBS/AogEqX90SXLKfh8zswtLOrZSZbbA'
MOVIE += 'hu18q7A+YBrpueSokuZMQ9poGw1nJAiIxxd0GjN/L1p75ZblHutuOS1OozQb2Wf6'
MOVIE += 'cic7j109k3awxInpRaLmMuk3xUzde8zFjmYfabI4F6HEHWsZwHUQVwgPKMpqKI50'
MOVIE += '1yfjB0GoiDXIebWkw0ejmfzNul2rHKSFAFHtWSFa7JrKbD41qx15zgR+Idvf/1ks'
MOVIE += 'oltRgunXWURNfWv5w8u6wZdNEleVpOHkO3VlvSkPFOqEIAWwhjiZSpePgTHrMWud'
MOVIE += 'ZeHuQKHTj4RP3XJSCh4+l68sJhQHEsgXTAqZvLa6fVONT6X7AbrD9YE0C40fNqHC'
MOVIE += 'ZoOxri1AM77+yGDznGGLuvFAJ0mGI5CcV4VOdkQonHUMElxlEbOMsYYBOT1Fp22/'
MOVIE += 'jo8RabXklNEvF1B9n6dUHK3u91MFQHkq8N3lP218+/Mp9qYVzD0/aQW8LUG4DEET'
MOVIE += '7zxU1FJtdClT0IyTZy2PWIh3s2sOWqnvMfMVC2sGHjgAlRKmj7RyLkGapp6iHRDn'
MOVIE += 'w1iIeOtK+sjc66++TYN053g8lJU8fr8LR4vcfRdNSkEaY5q9zvyYRwShROj3B0uF'
MOVIE += 'tOBhqOrQzKdTyFIQm47+9K3wzZmrqpMTVJq+hgv+g+s7KJPdt7XVt7/YnWRDHaoN'
MOVIE += 'QYMlp/VZZGPGMpOVlUQfZoYgh97FmK88Y+83JMR750N7NZ6hlcGhxX/DLdQLNpY8'
MOVIE += 'KYF+l7TghlQjFzpoXJt1tyZB/xFnF2+5wXf1yC/PFEh0Tk3/wMeqky8H0J+6Htat'
MOVIE += 'x39LYyRGBWaEuamsk3L23DWGYmKEJ8LyJ4RI9SInh7h1/nA7phqbfKv/ovOcs5Wr'
MOVIE += 'kzkgWc4v41PVVkd9LIov4Jt+8DD557i8fm4Kg3O9ywdn1mfHhPDW+fZeQGZqOzfi'
MOVIE += 'QByAk38fzGzaEIa1ABwlcEKEpXVpkmJkASC437oyPVZ1iMsHzJuYFzpaCpYKQAFd'
MOVIE += 'PqxK+0voxTtTs1uuwR53wrWSHdve9bxD/epzZyXDNBbGKy6z0NPPsyirOa6eQeGD'
MOVIE += 'zroJ+q03MDsezQ9M7wViLp6w/0zSmWMzBtJtvTp+qFHFkJMJQ9/n2Yvelqd7gTiX'
MOVIE += 'dSLNx0aq1t+VXaYGlZAKREZOCTGmOBJ/oklBxaHQd3+brcILZhpHWOrIvsXHId50'
MOVIE += 'QDUzdgdPW23dx0EyBdGFGzKfVA9wN36TPqqEqJtZMO93yi1l0ZyAFLGzV9L1THNk'
MOVIE += 'Qih57qZtbruXpD56OxGusutnRcz7HTwElflFRJqYeKtr8bxoXqt5jNBJ64MCJoi0'
MOVIE += '8BRAeMQQ+2W6UwEoaxIFJGtA/2HlA7QBYJFEqfOpzY3lFyrFzOsgMQDkXAT8Y4nz'
MOVIE += 'JxiUdFJeBcCSNZLe/OkvRWGD4K9vrWs7wBz/ljqcpPE+B6WDbwfdM6GWGPw0lMBv'
MOVIE += 'Vjj0MuaxU6d1dvPUMK5iI0emV1mrQgIwgX1elaLhn+O/LlJL9IBDGqy1w3yn6AGS'
MOVIE += '0Ga4bnrApBklyhMtPzEiJ436zUC4HpW0xtBAKdrQkQDpnyrTkI5z9hi5A+M4IlWv'
MOVIE += 'M+LTyvvqlYsuCclnHEWMOnBF1t0Z92zKHbTWb4k7y4zfvJgw9AilajETPE0wo5/L'
MOVIE += 'g4ASksVygdf6hwCegD0qSGM0FV+nx1fYY+/gl3PnG01jEFITH1a3ydCIGXXTxN3d'
MOVIE += '1+XPqiWLlZd45YnkM95fZMugo7ELwxOO5MIXyr8SQERwYFVTCt4WrH1ywCy4nzmj'
MOVIE += 'ZtmYh2gYeE+RZLBJkmHDKroQMkDiRWCq/Eu9Tlc9Gsg4No4SV9MMN59xSyTImLy/'
MOVIE += 'ipL+gVHGqGb+3ZIhViRH4NsUC28UcF6ZnrgLM8YOMYJkssckE9IBoPAupifvCh0S'
MOVIE += 'YzdLI1RJ7U80NqYwVOuTvH+GsByFVP1lV2jNWBtNDp8JDh88rZl7jn/JezQmsinF'
MOVIE += 'X1seVD5AxR6DFJXffwLLhPRTE4yVTdO1PcbPRQ7OWtdbfyOPVSbd3ngZe4P1WHpn'
MOVIE += 'd9ZPfB1XOtD7CjSsRKytJKt5JUNb7dJ3YYT+OCHVrDU5NaEMkI5Sqx8M4GeS9Uxn'
MOVIE += '7600mMHy1CuOCtCP0gMIEAydke9u+bK4E3VKIoupMC1lzR0v9qf7tNNRIkJuxLrB'
MOVIE += 'ybz5yQlJqpXUT4SJNDUAwyzsxvA4lMYdcBhHbQQcd+ZmuFR8D9FzOgWusc0udqUt'
MOVIE += 'iQMdiHl1KFWdIms7/GdphvnjcmYBJayP4YqZsKFhpWgTotQx+clhrfdnlVLqbYqE'
MOVIE += 'KrB7ijhRguKyTNSTSV24ZymQByN2q3to2kJAGM+a/PaoK+1Rmw6lBzCgbe40puyM'
MOVIE += 'UbnbouEB8P3GFdQK0Z0KEOFgg6TiUq2StRtYIRWXhjEOENL7khpygapbyp+YhKZv'
MOVIE += 'RnnXoPdaAqQ5Zslo2OpEIKM6D2lJO66eC2qb+3rR0jHSodLMjx6av6gm4iYm+X5b'
MOVIE += '4m1aXv5pNvK4oZxSSdZz6h2KmByOfZu8QHZv3N1l1GvxLmEC765o3+jWi4D1dT0y'
MOVIE += 'd6nMopjGY55tVqcVF51ZWLazOUf4FPLOlJjbVcaIHdBGh/mQwqaVAUFcE7sqAb50'
MOVIE += 'vng8JZWAy66/BdN05rSkAG5NM2Hlij+biWcQPEpBJk7ZWDeisr4SkxcFczQTJl/n'
MOVIE += 'CRVns/6K0XWhiVzolpVD6Dy0GHUz8GE48jL+EtV1MDoBVOmNYb8wRgM5q+j1Ey9e'
MOVIE += 'KS8sRhjBwip0M0bqphlXXtWnAuGYPNWVKLlBsnXkQ8GmSoyZZXeX1cfpBxKjV4jl'
MOVIE += '0aMVRGCD5c482/DiCtCoLhHj9OX9fL2ROu493pGQ91+cTiFYeAfgGUKvRw4U9199'
MOVIE += '5ZByl2CBaWd96MRPEVy6VMmTVH1vguCNDZxfCrtvuJBPVsrAy3WSe9f1kCQVz7Fe'
MOVIE += 'zj2BzBKxOlm1HqkFiUVH5y6TaG2+D9pl0dZNCIHIUl/kmFtz4xkBSdGY1hmDihZ5'
MOVIE += '49/Y2MV1lukBtkmMjO48eQKweuddItiSQRyLQOCzxw5aU091+W9sdq651UO9yuMc'
MOVIE += 'emsLovAxN+hHfynLzNSZb2QmCks1AowaqqmoFBT9GUlugjOIWJH70UCBpAVQgdH2'
MOVIE += 'QJ3YqJXyB2BQ6RJVL7iPFdj+IzH9B4BhZsyChPev2OtTx430J5acqlLW6zH6bR8s'
MOVIE += 'cTEkqeqDUGTZQdlHtQT2I+67DzsY3paUK5vlKi8B19zuZ7+jGf3JtRztRFKtSC0H'
MOVIE += 'Stu3mMa2bCK06OBRrVBjtSXghyLgvG3TgsIsFeDDyRm7Xzb/o+I4552VNT0hK03o'
MOVIE += 'w/qNi4qK+/M5bV2PjpJPWTpKFUoAasO8AGbuPSUSpGZ7bpaJ+UsZJx31h2OJGotN'
MOVIE += 'ZIJTUBmezXIWBiPunEhlZyeBnywZYB8rCua+h2Dx1T5mEg6/lRk/C7B+l/wfIAZP'
MOVIE += 'E4FnZdHq3m77eB6Di2WE9Kqq+y4zwhyqsTmDqQOpqG0xb4HVC1CligbH1CoM/mpe'
MOVIE += '0wAQjk88t2Oj3eMmB9xtWHqWglWziKFB7pYhrdcDsXcI9G7XX60HYx27ovmvcnf3'
MOVIE += 'G6HmGbEewFWmuQ9kHDbOvsuqSIj3peKIh1GpXsKV/BZRiTwB68ASzxgPfWbcU4vN'
MOVIE += 'CpjA6t6ttiDjBdOzM7vfDFi5yJ7y8t5SzU8B0vHyY3P/RTin6ZCpIxjXq4lle2rz'
MOVIE += '+3bpKi11MfjMafk80nvDiTEZo7ZNFAnERlrqoUSCglbR6Pc7B2vfIVr10H6i8f0V'
MOVIE += '7Wlb5Si/tqEjyAESYFmOdOWwdKZtA1qaHax7H+giY2jTDiYLDlQbLT0KiK498Cwz'
MOVIE += '0v/kxsPv0UmxwMBbyrcfoVLScXroeJ8LMkd1AFx+8sr4kHMu5aGk4s8Tba0fkLsI'
MOVIE += 'EhmDcJvKYjev8wVbL4T5Qr/vKpYGeSD2D5BE9BkBAAaaOxKkMitTcShjDhBxG3E+'
MOVIE += 'McykW3dwLOinkPION4Zwh4zjcHKxwagBB6EZk8mQh4vDxJ9uH6ZuCRlLrjS+RFqq'
MOVIE += 'sTQI061HWSoX5+1gfecTyQDevz+NnErrwf2xNKgoNgVjglLDClMie31Ykbr2YyQI'
MOVIE += '07GIB9/uzaPSuo7elzja8ASAtkWj2+QBKNlCIs4k1xieeXfE+mmlY8JmOSxFb2Rm'
MOVIE += '1qlVeXrBO0oMHdWUS0CPMiyDnwaX9i4yfaZBW/ecL0m5WTsV1PYUe1cPyLEVAITY'
MOVIE += 'cieXDCbwMtVtY+6C6hlLSH0QDvLjcSK8yqkq+l4fPDC7qXtXpoCG7UamYmRj3GTM'
MOVIE += 'JpbLHyymKahnJ/3fb69FoS9iir4MbcBuc/tLD99HT3xD/dw34lTzG05texbZpk6n'
MOVIE += 'z9yhvz/bAiCPUhI+PCsy5KSu34yVa2+dcvB5Wour7Sna58AQ4nxilap20Owc9f6W'
MOVIE += '387ec0meHUYrrEfNsJN2XRlZXwEM9Ncq25RoUR86zf5Tcvnve0ItbdqXX/rKVhga'
MOVIE += '3YkD6utlRSwWwTv5MY1Iax2sZwFGGAKkM+0+Oniow8sP3U4e+LNNfxMqfD1wKlg8'
MOVIE += 'owLiRIHF/KNld8CK6/enFvj9tjznTvTfe2z0zJ+zms53ZnpZ5rm9lA9OEQVB7Oiv'
MOVIE += 'BAdvRxMuM4oDLkpirTDg8DaMKokfTpIzoCRaxS99OxfyaDmgqZE7ZKH6p0PM1oxm'
MOVIE += 'ZGLlk29xItzzTBmQMl/Tc89ksbazlQ4NsYsr0niT2irkf5fCZXDXy+3JUh+sTBg2'
MOVIE += 'SDO62WJXDr+EUBBvWGiqdydoI1I96wNE1QJIgttgoKPeii0isfF/jsVeUR3exeDC'
MOVIE += 'vBxehX9rlbfweJjxYnDrVvZHD+y7bEaMkz+46fWZAD5ECx0WlkKgcgr0Cf1unSNp'
MOVIE += 'aQCknQizfheC5FBflU/vtpALoPwZN+pohY4DVUPDLYCEOMubZy/veObuEgVL8EMB'
MOVIE += 'mbcGPPIJj7M0G5qDR3YAt3M/edp0Ixjy7ywANzciHLAjPf9oJp7voQa/lHSq9PxA'
MOVIE += 'YtLRBA8R8d6EpTyXRwNhEnO/vp+HRelaCntaEzKER4WNI7I+R/TYsllg4et5d+Wh'
MOVIE += 'jsz0JM1vBtVmnhJOki3lm4GpGhkXoC+4YXQnjxsxfO/tONdBvzveCfuDOaWnC9FV'
MOVIE += 'f+h7YhqFP4tTSEcEeQYRWq6FfX8j7qdjqYLK+2GommR+U/MAzWguFDSC4sqBPu6N'
MOVIE += 'jzX4CdE0bQWaaf6OznhOFHuWAryo/d4vBriOJGgwRukFV5m98GQ6qdUCAFx7b5UF'
MOVIE += 'E/aw98aPK2wMdxLpiaZYE1ZUVtCPJ2rRXbj3v+hQoGENy58SEE9psl8fv4+/M4yQ'
MOVIE += 'RBelums6QMORUXCkwQ3NAmwex3MBkkVCvqcbXHEz/nCHfPgWo3pxpZoQBbngSuxy'
MOVIE += '8nlFTJ3hgRRKXQIkwFJCybfU6u/ZrARUbdmLYPzUBApu42ZNFXVVDm3UFM7jkn0i'
MOVIE += 'QS5C9azXOV4jSdrQ7gyrOhFLxiQ/f+vQyTVXIhv2batwz52QVtl9VDqfa7a4WusL'
MOVIE += 'KpdS872JQlytNkMO72KVs1U6L//RStPLNqd3WYLePwU2u+ZWO8yemOcJhF+Y62pm'
MOVIE += 'OADsQBHfuc6IytHROHI8SiHGoXskHSrtTlXGuFw4+oEt0fCF9y7/4UzBgurFh7Vh'
MOVIE += 'xln79HA8jIOD0uLTpw6flvUJ09LENeOqr/0PaLQeCK2e+5JrULJqekyvk1Pcw3g/'
MOVIE += 'oLd8tr/LBJfSFYGpvdjjyKs0c994Ev74s9xgzi5YZH5W5NHmd4/N/srs23ntyDq7'
MOVIE += '4v/qansg8sf3j6csz5WNIg9i7aExecxR0IaLAneoKrbII0h+HAlgCx+DKT9tqNL0'
MOVIE += 'PseFGmm/mcSokNkDKhkevWmQ3iON1AzEI6Oge1hMLB9OmR20cNz7SW+lDw7OUGcc'
MOVIE += 'sw3TfYpvFh6d4r79mOD8G3OOkbYljc1sm8S0QNcEO5ktJUeXvTI04ffd+vNb4BEd'
MOVIE += 'vr3j0Rq5vqyMhntNgH85d9HBDi0o+JxCzQ7qb0LI3VJaOeHN2zoxQpflwZZIEddo'
MOVIE += 'wUD6oHdhhctP/MRD80G4mAke18U1bzC7C2rYQLkbXh269Zg211TLTkKPS49LmrOl'
MOVIE += 'u0ODSNx9jFtHUBXeHoUH5/AHtI/R6/gAJvme1LrbRYa425MvH3NFpeAwgGca6AJL'
MOVIE += 'KkYLQHRZmT8uXza6J/Tcu6uhd4TmiUclcZU4ou68imXXQZ0tW+sbVIPtHKciJfKY'
MOVIE += 'kG9IJhXJ14CEcC6nb/jWmZroY7m37xsbpZpa6LzPVgUcQ+RXBb5N/GjC4yz2CQRT'
MOVIE += '6mJwU1Si/HcZD4PC88Ddj6ww9hCP6ncTPSHfZDAAgHQ5LP4zXlJqPOtqnCpTIkdg'
MOVIE += 'CsdIpuqjQepJ1PHrKZ9FVS1xNvwtyTk9qdChF8/QJ8PEzu5UYeGqAiJZi6YhuWO0'
MOVIE += 'n4Kkth8/GpD6z/f3318WfYSK0rsF6Mo0WRPGTPAn4WuMoR1Iv3am9+mBZWe2jIO1'
MOVIE += 'FWmM4Z93h+GFzuLHLYM0H1KQk+Wj9Nxv1sHqDQ9tyVWtAca6bPY4RTmSBz7fU/XA'
MOVIE += 'T3CeGy9AuaCMSdpcPOYPg7N8YxaWt37bK/99lPq54U5MwlUloDLPNZ0ROEUFYczw'
MOVIE += 'gaTr6pfb0ziV7TDmPsnrLM7dpcZAznP07254mYefZS1yLEYz36IJ3MJLNcPdM9d9'
MOVIE += 'sWTHCH0NECIrF8bqw4wawgWaDhyZajxGL86N7COVyZkb+OISRptmqohPzQyeCEXu'
MOVIE += 'PmkeJfSyAdPVSkMXewPy39U7BL7OsMdY8IyyHvpapQ0ZfIbH4OGRlAMYNu2P5WPA'
MOVIE += 'zBPjbK+GgBTXDnEfNDPC2NkWyJ5hotdT6u0Qv4G6fso9Zbru0dIyZfhrktU1KXC/'
MOVIE += 'hekYcacQZrY9cNyzW/adUeVkD9Noql6PVLZlJYzj7phlNtAWy/hbEfIXmJCRyeEG'
MOVIE += 'I+ceGMB4GKY4ydWrZ8LU94msYzRpH0upJ2hC2JptyJOHlQZIYS/vuJy9nRk+emS/'
MOVIE += 'KOF7LDsxJ2Nq9i6R9zjmsSkrC7BhxvUGJBTrH8NOOkkQNrCjc98TccMFbnlDhXbP'
MOVIE += 'vr+dFxUXm3RQh66WYGSvfk3+rTnNNR+BUThA2KA3h6wNxFpkhhRtOwsxPs5gJeLb'
MOVIE += 'hmmy21HI1BKWpINd9yumriBT+lDcXFPVzZgqzpze5pf+ZSLUQgwUY2haqjqPnHwq'
MOVIE += 'pvAc7ukp9Jl6MYPfUIOfiVQHWB9EwpfTwpHJ06D5vrQoE09zfTnY6xhopOBInsgD'
MOVIE += 'JlBVy44W6W7QjiVVMsEoHWwgK4Ka2QleZFUn6TmTTzbzWNwlJHoUjQg9OXZUQgSI'
MOVIE += '+YEANpx31HqlM5ZFeOFpyDOdVWAkyoTxWRbV5PyYLnmhUMjH7Lq4L7OkOTskhyh8'
MOVIE += 'bvxkrJHEZUyd7EqDIbWZEknRAJIjx/cj3W6mVcg7jfCQSkeFL0TuIuZsBRKsEhdT'
MOVIE += 'LJKeMoirs+KUApVX9HDZ94wwkte5ODt7K1kTi0rEbrHnQjWMzYi5p28wE6vTz7pc'
MOVIE += 'kYaBhIU/ZLNCR9WY5zXkp56YPqWDsEunpPmz12a1Km++rOwZfHqK4NpxePGdM8bN'
MOVIE += 's9ulIHAHqky870ewt8EyD49lTPiuG/xxjKIlERDSvOTRn3AkkoQlNoatMcUGJgaJ'
MOVIE += '3fKg/Jz7me+FFd9+CFH4vHq9TUJ951bTaIk83slXL69iZqtI8Sx/qPU4MuZG93Sb'
MOVIE += '6ZGAYtz3LIkFbbg3nTQIhR5h/Fe+/wDuNBl0EUVrCsfies90YQWUUWO8sgb9V9kv'
MOVIE += '0HEPJZWScE6fqI75muMk5Mc3eOK5V1dG2XIW4iikzHi4n80NKZa3XYzjoIL/DoxB'
MOVIE += '5InfqdgpjgcJx9IekzB9X1ewuLGoehqwcA36rci3nkfrMt2sF7QpzqZZyX3eTxuE'
MOVIE += 'fDX91BbvYW8Hge3FSs0/HbHmL2rghDNAPR67EmIvhZmBIwQioqlMR0E+X9dx+YJP'
MOVIE += 'fzvdDXB0jmCrzJZJf0xsO+Ns/j7eIKnricdCov4yiLKv36P64A6IBW7FA8jLox/C'
MOVIE += 'gNF8Yf0fAQkYwgz5Ftuthi0ISqOJwafL+IhtmNxO/Q1UDr0/2r9DuYGFu2UpFXeh'
MOVIE += 'R9csRskHLvBt/8OG9wmEGiohc6JPkAWebdEpnZJ9uvNKWjwzkDTXmkQap9cKw+tj'
MOVIE += 'InFGRO3oiHcFOIj8iZMeSN4j8DlGCfsxlQWXgGuxZ42RmXz6lhZi85+6WKxIGjbF'
MOVIE += 'AB1QxJJVOuSox/aoALfHgsSOiFHiGZDLydL9J51s3TwvdTS0aUunOjkW/c3i98N9'
MOVIE += 'iOfviGbVZOszZYqhXo/ZD0+CziejQfc2gfMwOEDgky/t8wsQPj3uXI/WAcV3Mcx4'
MOVIE += 'IvvoLkoVGKgtDHij9yV48Wklvcv2i9iw/JBog8xTbg/9kS9+97LO3ya8/zKFQ1Db'
MOVIE += 'NcTKB1MWEKY9Rer+Bv/vYe9eW+2bELloVtIwgaXSd5MTrZp3FA9W887usdTUCTgQ'
MOVIE += 'DI0rePMfYLTeQWQ/5pTR0GsWmtM0XbkWVq4fEMFTZEnYJCWtHrGTKrGJPAu1V73c'
MOVIE += 'Yn43i9uUUeO6hk9SLxGU2lw+VUOyssxORglLK0voggUdCK4k6MVx+WQco0/L35N7'
MOVIE += '2HH9HWLMcSAQtfRVS4Cd0dhp4uJ4ovoGWG4nd7h/kBV9ZDH4i5YaYB75zeKj9y7U'
MOVIE += 'l7a+GjNO4gCHLLkzlU9QbyIT7mjAklo/RvGvXMtb5YuqRZa+T0ahqofBTsW5EyoE'
MOVIE += 'KdYdqjpUCTvWsx/u/QEKrzWAwcaFqcyMw4481O80ZibuESHBuw6DVzgoSgM/A+3i'
MOVIE += 'Oe7CuzJ2rIn/O4v8qIy8N5WRiqUCaC8SYJbtP+YyD1ZYjxaAlN3TUXYsHMUcd61m'
MOVIE += 'QPf8QNoeRq4JMPnRGP4eFFwP6C+t+KSG9fk4BoQD/iw4MB46HcOTVHD6CWgIhQ+W'
MOVIE += 'rgSLOHYc7NrA51D6aatJlFOaVm1h6F/C9sy8yzK2WXVvMpMmYvmjUAyIZ1lFYX1E'
MOVIE += 'YUuFKzB9J7gy1yWRyyoH+ZgB8gYqD5n+e6YBYQTSV9/tzMEKbJ5qeethyApAQieV'
MOVIE += 'aPrUO1NyrdFxWh9ltrPpZrqqJE2lYlva0MmypRggQTgCP1dbeAz3AjpELjsmjgAR'
MOVIE += 'SHxI0So22zf6aPqev5mDp8tFOqvKq5TdUjxaAB11D2GUe1P1ZGVrdqxqcDY909Hu'
MOVIE += 'cCWRG2BBUAkktkBDzlafI3FEkcrEpNWmzygqtsZ9xKspOKaEloFkvdkqUapkF2io'
MOVIE += 'p/ob6dQlyJAaDbGhD4fGyXa41gyqFJ5dsBUuryyCAj3cIdHp4bBfHeHMqoIUQfm3'
MOVIE += 'QKJoZYuASv2IlGps8e4oO+WlmidA3eGIpu5jukmP/YJujds5mXBlFuAHhs7nbpjL'
MOVIE += 'Zurh6jjpDuB0nYk1XAnRNaTqNcyUAbhcpzBt4Xz32AWeYJipmmJKbKW5ud5ko2K3'
MOVIE += 'TaJDUxfwRlkhxdnBj40fOSLizzo7qeG0mbTbpsy5o90yEyXgn5g/T9spoFPXzSpX'
MOVIE += 'AnrsduhWVrcAT+J3XPA7w9EBos7DOZtrIBqmmSs7aL8cVzZ5JTE7F2KXoRAZPQqY'
MOVIE += 'o8F+gjEWAGu2sO539Stae0zyX8UGJ7v4tgRjXeybKM4kZzG0MieHyj0VdgZLTK1f'
MOVIE += 'V0Wnz2mqIipQ13Ix9VJg2jlq8jlVwmcCDKQtulycKaKsLmIOj0IcG4Acoo0cItsq'
MOVIE += 'd2xf1CpXpW0Zrea502Y+wg1Vo/XgZm0flYioPNJKZjeQPC/+Flq/Wfdzy/Wgzo4Q'
MOVIE += 'pFe0mYk957Tvd5E2Hgb6Df/30UY/6yhnWZmv/IiLMTopj+2dj5MYDkjuAYAmVEgM'
MOVIE += '8bgkAA7/Ds0KMLFBXdK0Xf+mLtzDo1Ku6vVn657qQ3j/jtPsJ9Pcg9N2R9V60HQu'
MOVIE += 'wDI6jzyuo6SABg16LEyBLKKiWtIuRbSkIbaWl+cayAkfEcypKtnUFk+o5WAESwCY'
MOVIE += 'WxyQ1luMHMtR8tc4QnFvmCagSxut8WXt4S1xnwx5vkRjTyjMZz2NgthwzaOUGAmk'
MOVIE += 'uMBQiCtlFAGpQ8jJlrEcy1gKiDNON984887CYN07KPJk44Iu47qQpLmRMZL3Src4'
MOVIE += 'Qs9je55PpxFU1Fo9nDTMKg5y0HZ/qazF56Pc5jcsGLOXsEioTpcmKwvi3Qdl/I2l'
MOVIE += 'O4+yeowE3hJUZX3uOWEj7gFTcETTIYcyvgFWZWjJIoEsgKj7VAQNEpj1LIaid+g9'
MOVIE += 's6d08IjP4iG0z5IiBkuEbtA7OoXyerxgNYXLK0U/O85MiBeHg6d2a8zhkOGIqmGu'
MOVIE += '5uHFEf76YfkZsMJotPS3xrJxwW9QFVGeKZH1qPGbhWqZYUIeu6eucY8qBNyUjXgj'
MOVIE += 'h2+7m9+s5HDyRHOWYNPHNxG82GTNKDqfIbISt1pz1fSOiYx/VGkOd7y+EeswSPFS'
MOVIE += 'DpYISex66W3975RYHuvXqp361FckxjeWrflLLW/gGw4bSJacts9L5SjBM+U3VFFb'
MOVIE += 'NE3/ze9b4VT6RDCtT2P/cqjCIqMeL5ryCoxwGTJJ3qOMGYX2lMl5DdmQE6S9kmva'
MOVIE += 'PEoZU9wCBybFlw4PCEz/jKPXjTyXKRiiKm2tI/Yp7/1oSE1MDWeQO+vsR+QRW0JA'
MOVIE += 'Bm7pNy2WsLnxk30B2IgIB0jCgfvndWvCTZS8B/pZ+NJDdBZ+0chVTxwvckScQ6W8'
MOVIE += 'QJk1RJgxb5hrZt1jU91zEZYeN/I5IunPnuoZdYzL7Ne6VeHzj8L/zoU9NjK3yFkq'
MOVIE += 'dv2A/51wzNyNaFe2xPI1S2+DqYXa9JWj+DWHUZoBoa3sL25AgtVOdjDL7ptYiOaj'
MOVIE += '/FLlt6X4ojkgUQ4wuhLF+MzgnhBOU/6y6Ivpv9iD2kgVfH9t1igvup02rhwsKYvH'
MOVIE += '30NmPy7sP9JsOFk7c2k8OeWFPOOwEGMUi3zHRuu+jrJI3rxyiX6zIEc0at8zPSB9'
MOVIE += '95Ykz6dSwIGI/2Y7o4WaO2Ajv6ZoVZobvVfP8DWdN+YLnbTqEJNnUCznImm63pWI'
MOVIE += 'Xjhhq54LvETPZAESRVMRvivM5rzCxmLF/r6xpaf6izEoQnNYGBclZSd23giSXowO'
MOVIE += 'dBKBWCWiMED+hI7xeY5SwmjeFx3C/nfREo5ZDxPoZQOGea/NLj3VRPaHBdOZSUuV'
MOVIE += 'RZdbONdZ/pEfgyT2mx0XJEtww18geJk4aQQ2y7Ia7zFa7BdKgzmQAjLkfvnVnPzy'
MOVIE += 'MS5Kq7hLqvZK6rvrhj5IYr2Fowu0QYMKVBTZ4muTebvG+5yhNyRFl+bREwRpqKQK'
MOVIE += 'J7GKSC9I7lUsLT8zuE1UqZ4FYIrjtnipzKf9kHFEVJpp+vCI1+XHv4ll7pgf5ev2'
MOVIE += 'qTs5PHQaGhkTRAYLkjMQLE0leuXC2LNLrM42WamTFnce1hWVNT/EHi6YXXKl1STu'
MOVIE += '+FJc2EJgGaFCsSSuswrm6RXUBf0Qral6ty/eMqGMQkaLzLSiPO7akb99lT0uFnb1'
MOVIE += 'KLFKH7WjOJrbRB26BUdyeNEHjw+jhHCswoq01CL5zOcA0WcA1VNj1s/btp8e2YVp'
MOVIE += 'eBxjCX53r1mlOAhLadOG3l+ohE0vuRijOCn9eSyc4ry+We0nuXzQxrsR3zK+2EYr'
MOVIE += 'ixOrSMzPC9m0Wzso/8fMDMRhPOpxH9sqRQSqP4oK/crT/0HYROJ5yO0DQr9zrIDN'
MOVIE += '87ScHry5SLhC07sGD4l3RoVyiOM3M2mqiRwD7UdsAVUltIzAoLDw+HiQcBcoJD6K'
MOVIE += 'Quxn7OKIzo0yN78Jysea26YufTIorDMehRjhgqnEeymLxtRbjY7ZbqmBdz4xxswB'
MOVIE += '51NGOO/A5V095Q4qvAjwgAdJLInLD3rwz/FdXs2heAFD8yKgp2y1Bo90Wi+5iWcD'
MOVIE += 'PjQsZnqo/N7fCh1rBmHxxMfwjPbFv+/TSo6SeviL3DlIJ6kzTl+S9ntpYztI/EJb'
MOVIE += 'sG34+2yvdfUwCg3iCga5P/lpsQXmcGj7ryex1IISzwUagVARFGssT0ApOYQ8k7J4'
MOVIE += 'axYt+Km+qXsEAc3Y95slqpugmkRFf58oqANY3/j/OxQueh7LejREvgwAlwvYocDt'
MOVIE += '7/raWV6XLv0upZWUlnpdZn0E1Phptc/LnfTryXxU9n8NohM29xYYQaQRP3OcUYYq'
MOVIE += 'bAI3XP/Ecx2U+UQTuhLioDO/APV3OOYzLOfWPENaGe8WqII1OuuXmajuiA9ZNZum'
MOVIE += 'UYqqKtl+HIe4Et1ghNYO7t+B96ULZnj9xu3xPrFNJFU4ll4gyhwOpt9HQ2bClE3J'
MOVIE += '2vPlxRKGJ9nlOpb6gl52dS418o3eckoqo5q/f9dixWM7zCE2jql4dw/sJ2SJLreW'
MOVIE += 'zLm+QnmM/Vf6uqyscveLWu9Wpz0HgL536OfJHm/BsChyhIBo/xezCkM68z3SXAgS'
MOVIE += 'frdOlVigydY71C8aOXLqwFDjuqF5K6XKHopQggcfU4YDWZqBiH0M+GLhY8HAZJP8'
MOVIE += 'Lv+T6aaraYb75LyyAPz+IgoedasM3pNfOJ3aDokd4Yzin7i7hrwHSXCoiCNqF5ug'
MOVIE += '4vPKT+5aPABGsH3lty+z1VMjokuVhfZBZ9lpvPCiwWL9V37KIoAoihLVoc6/Ptdz'
MOVIE += 'OIfqjcm/W3cJRAgsyQzubVa+pDSm9jJz5+HzySr5Xe7Xuyxvph+8DogDCWBMhWei'
MOVIE += 'FQZ8ZfcGLm+UX635rnIMC/orVtbFCrRF8d+Wgl7ic0+r9HW/dgOMloAg907p7wis'
MOVIE += 'lf+HzQ6+hjupJk7XMr3uaTZV1j9/c7bA4UlEQqcQOo96TOGqnctv2aOr1TEpCWeR'
MOVIE += 'X+56TOk+Ryz3tkaTnD2OhF09sH6eywEHqNbKBuF+UXmZRmbXG7uGUnubt8yohvwg'
MOVIE += 'JLrzsWh3VMmVeNIjwNPtZd/t2/RzXkhvKXzhidn77cEnndeS3odE/g5D0QR/vp0m'
MOVIE += 'm7c4jIdaLqum5u4OZ/Oa+HE1rQq45xItDZtqjmBrjfbzJL8Q4GEgBtxU9K56Tj4b'
MOVIE += 'ne75yubNBaIuL+BZ2rVnBQzM3K694s8Y+6buNaaz4hWUsnOlgrpdbY5VePh4IFXw'
MOVIE += 'xbmCUhTQePJBasgbrxst686IkK/PfCK7vq81mv2QzKnXKKLoo4Dy5/ScLEwLz0p/'
MOVIE += 'IB4aus2C0rsTblSL7IjTudFY/ss6wxFDl846IMLNPjS6KNZKXoCA4aH4ErOSAwZC'
MOVIE += 'qonD12AcguabeLwmf7eh24d3N+aUwRqb8yFNKa6UKQIHjN/Lss7SynbhIZ28NxjZ'
MOVIE += 'lSkO7fg2xR/EhoX4MsN2MKgRqq9yK7BwwrgHU9FJ+ZIf5Mn0pTeKvzf+2k4mM7hZ'
MOVIE += 'NCYif/fs0vn96z3WefQbcQEBhCvHMfmYtUdA7UsIWenVPOgvWz0GgFfOrrZUCSiX'
MOVIE += 'g9wr5ul1GZV43pmamR3l2MgfB1C6CGyOUoVV44Y4bIq3urUYQ2HuDGT1yxTcRR6V'
MOVIE += '946//ZGYMbHLAK9Zj7XgbCu7vZTsOZ8vZ4QG7VfiyfmwdBmIwIPbBFdqVVIC6MtB'
MOVIE += 'IblmUy0ZnZpKaz9H3Wznyl14GxnvX9pR0NPdQ96vgUfLd+JEExAHqIYmdQCVjXkp'
MOVIE += '4p1J1mTqO0s9JU1y3vC/vQ+zBgonLQQ16j1jsvtsQnmjYFk0h98aS3/Pei9Mm/PL'
MOVIE += 'vf4SqmhUq7VPr5WU+InCIaHwkN5pHaaWW/uhG25H4t5wmKftUVGTYR1BFTc0SwxB'
MOVIE += 'nA0LlELTYtnDqR0NBvz71MI1fduW13jK5CRNkPvkai4+y/VM6Ur/PtQwR5Rj8R/J'
MOVIE += '8vyOpkxpSZvG7+EnH/jqVHbLWyRYR6Pww58mtsk3bJuugCo9E+JhZ+dp1QI4reAW'
MOVIE += 'JjronslzkL7SQbQ0kMfl1Y9sK7S1M2WWqwov5unEfCWdL4cbU45yOPVTysbmDB4r'
MOVIE += 'ut7RuaLMuQpTaDrMLoaAd9scWS44bLyfbP1iDKWxWyFv/dRtK3CK2z722Y1wnQzN'
MOVIE += 'D/EXQR/kHsSrUS0C6JMM9xGmAB7DX0Y6ChffutdIuMLyNokFKy9hzpAR74ElZLXA'
MOVIE += 'AYyFGGkC2MFdiCsl4IV/VlOFL8TuxBEkGs2o181DH3FxKahFOhmFy42P00dBhrBk'
MOVIE += 'CeIX1Ls9C9iyYABjGhGrSR6spY5R6VnOqZrwyUO1G9s9il8jJbP7MZ0lIef8DuRq'
MOVIE += 'AsEFlTo5rsxXDe/5LcLI3ie0qDy9pK2uDCCSRld6M0AQXG/GaUMwFXLIEjCByUjO'
MOVIE += 'qjRbetzv5Aa7+kZjjir6xbsgO16BKAYWLWPWraqhTP29QWTZqKbyKJC7lCOaqcSY'
MOVIE += '4GgCiMeMofqqSp4nUrwn0GKhY+dilCzRWUj7YemBmwubb/3RyKuTKlm8E6hXPwOD'
MOVIE += 'oxuQoEnGMN14Sff8BpSqzxEN5pRdv/g3L4D6XQ5HGLtEI+Mm10cz2PrRud/bApK8'
MOVIE += 'dsbZJnccVbYWSG2fLnJq9nNn6SdCmJGsDKTzywBSuE70sE8egZ6HYFOBjneACM3A'
MOVIE += 'TOHDG1xDF9C5wOV3nrW5e/rATEBhzG7VaaVMw1tDFP0CXB0V45jiHLOrBpFhIHgQ'
MOVIE += 'O0wQPGwYZ2QX5bY8EaI+SkVTWPfd5yrxxFKU9oFtwh3b1q5W5BsIpxGFjfR2Zio0'
MOVIE += 'vE5NSO7IfPo78Us+qmYTF4+/jDeG0mZqlSFWsc5CNyyPyLMFfXzW7IjZNaB/1Rw4'
MOVIE += 'a3IEbFjznW9/vExuQyNjNdAxrpSxrAg8Dvpqut6DFfLA7Fn2O23CmuGLx30W476N'
MOVIE += 'FYPxV7MNBtROvJ4XTYQ8O408xPv8fZubdeHUPW0k/Ba+luadhwbPN4pU+fESXlFR'
MOVIE += 'gxHOvEQYuKZuxA6n8N/Fj3GH9Q/ndiToyRdjRM/zolGeSWDUh7HNgWgq8fU9o6c5'
MOVIE += 'SAeb8LkTJmfKPNfPxuTGSV4cKoMkSmYKTy44FqYw+A/mH5mZvN6spmoGXAb5ej+/'
MOVIE += 'M9oBvfvZ1Gl7ZPEyYVpQOSfZsm9UPLAggVGy9tW7IzWWgoAy6ebhluG/eSdWdTPP'
MOVIE += 'ZPKNnzdArak5CbTKd/uLbkaC4x/K5wfgEOZLGQ0cH+C2pqJPTp9O8M4cZ5hckTzU'
MOVIE += 'pEgMUPbOYkp5lKOJjqJYDdhcfpPebWS0hCHw2bFHImYIafij2xPGrM2Jhm1U1eb/'
MOVIE += '8XW5X1VSX0DORAxZSaqZohFPYQFlb9TSH8OiWhlthJLIgheJKOGDrA5TgDT0sC2c'
MOVIE += 'jVcIHC3El6k5hyKTJJaBiu7vsb8ntDTTHaRu1XRi5KT8rMWhBDLjb1MVehsRiMv4'
MOVIE += '0exJ4raR9HiGeJUt5jErwR1Ou5I6H2OyUB2Q+ray/tV4AvTVP3waBSYTGg7OrmVZ'
MOVIE += 'CIH69WrEzTdgIZ4DtuBLJZ6PNwARHMlD/juHsri2XSiJ+GSdx6m0Z3iF1/YbBycT'
MOVIE += '71s9WHxucb2ZxV2xfD28F+dp62/54WaVsMdVhcmnz+IChBDKG2UvAxpJm0QbKWWP'
MOVIE += '8uEmWhQ+NxQAvdiXa22PCGWiqWvbJ754sJIRCmxWjoixfujNHMDHc6uTb8lUjvJS'
MOVIE += 'COl/4pcE+BJwXWjf6FYFME60+QPYvqojjtzBoWOHPP+6xjz/MevUU1l85t5nZjgy'
MOVIE += 'NqT/feQJNsnMxon6PerJu5HrgN8xw9blDg6n2n50HqZ3PNRxCuMol8/J5LmakLRt'
MOVIE += 'NaqtfIzRR8a05BIjN6mAlGpQqd+PAXdtbbZee1cVIGwi58/6IROeNNPVtcfYkQZZ'
MOVIE += 'SL3J352HX9VWRyJgL1dv4KYlG3zINwROAGdqsrWa2eao3AQ7NfhfZ0nAd1Ua9yXn'
MOVIE += 'fRk1w6Cq37Qey8re0OAcLAoYr0aGuffdElCijwsfzugqzMxd59UVUZkw8XnzJXyS'
MOVIE += '9560HtZFH5v57L9DFfvnnlt3/6q5B4+r7EKE2SPzyoAIUWAb/aefTukV8620CfcZ'
MOVIE += 'mK+BiwIt63Nfwt2YDytSt9TScr62so1VA1QQjCMI412jPA1wmxdAc2ShNxlJLPzy'
MOVIE += 'Tlf7MuLstgS/q1IVpt/0zw+VdGGAX6N0d5V+Vz83TUo8Y7X7MkmJ3pD1p0dDHs/Q'
MOVIE += 'j4mTmQv8yoj0/JiXG4AYZmVg4TheUU4TVGwf5VFBiYlDxLB+nkhW9dO9CB0aN2WH'
MOVIE += 'iM//oVJF0RiwC/HjPdqn2ifBz0EDC0jx/6CsRIFwYCYCLxN++ZI6vO3q+tHJ7Xsc'
MOVIE += 'TneHgnitNoHCiz+/lfPVgOZ1P+jV1hwo+6WwIjnVx4u+f1HUAns0Ftjf5UMHDvoX'
MOVIE += 'yC9yFDjf8WMS/ujMk/nHMfqEGTuNw6NkT9rlQZkIUSw8PgDxxP9On+yH15eTLP+e'
MOVIE += 'LMM1PpGgeW3rG3eK1bOXd6QVZNczIJ2UdMX2VtX2+UpHepompWqSz+YOUHw0dLEt'
MOVIE += 'w8oFtIOJlkx4HDpHwx3XsF6RGGnE8mI4q9aRPoEcGTaPoA4gx15MN5MCKJPo6GaA'
MOVIE += '09rPf8bTQZRAhUByTQ2hascN+TmyPWfmvd0qZREfN0cEHIiq9BVtFA4kdBhn9FXT'
MOVIE += 'zYBtQ32k51Fs/EtHbcycINZAoMm4M8sTChY717l/SfT1wLZqVriYIz75JeJ5GzL6'
MOVIE += 'AjkiQBHU8myqeebc/WxOhd/JcZbCEZOgBIp/JCDfSI6qEq6cFXiVUXgdZUpcQ8QK'
MOVIE += 'pXe55xuz8Wp++uDFxwvHHboZeUk6q/uMcj2iYLtbZpW/nud+Qs4TLcqTTgHPNsZ/'
MOVIE += 'koGku+SlNN5FUHxh9DqTTaFN2J232uUPUa/6J7DpMaTMx0GlsyT+TgelGgPr9Y3h'
MOVIE += 'ekcJb1IzLyfWm/M2NlLd9ycFmrAtYwET1ahf5L7E/J9ah1jqlEToxHifXuBnk7P6'
MOVIE += 'kqwhOlhbKIaFdhHyoEfSfpWimRsWdeTnSjStbuIGJkTv3Obpq2ns/MrNRaGp+DTu'
MOVIE += 'Yg4DbpDCSWEvEamQ76zrShLmn6SeGEuTNLH8MRKhzkZUV8C/vxexHroqoES0klK4'
MOVIE += 'J7NO8+kLKYk99aW12v21riL3dthmr4KcvoLmDSWFooj8WKcgEEzv4QilqcW7WzQk'
MOVIE += 'sdQBI3SEpfYPaUZ/H2ZOnFGyXWQCCL0eYDsf/P3+INlEE0uOJLqE41PQUZuKvvhO'
MOVIE += 'x3KRpxwv/VxpvTpTX5Qco6oEh1SoqHz36qeS1xAHk6kYM+Mx28Qhl7NjdI94jScU'
MOVIE += 'eD95GZL7kVYreUA0vgYhI3IePO96MK0Zf9gsDQ4WYTCRIejgzTX6wUUpW7Wk13aU'
MOVIE += '5EdkvZgUVLbM0wBE/KtS8R4Su67UKU4s0u8smhIReg2GQl8y2XOUIA9IWP8Hbabj'
MOVIE += 'q9AbqzW9ocj+R3Gk6Ij8R2QQRO0W1SHNUoEAUcmQUCkRdBuWGsMo55QaEu713LuM'
MOVIE += 'ucmrYPcIoGdwvfGdoxL8FsfcT0nRT2UyuKxT1SL+VZ+GHmg6wH6xmAEvqpFKRCrK'
MOVIE += 'VNFksZLTAAecqJT8spll4syVvlDqGj780y3fqsQXZaqZ+p0nMwgZHyLzN13J8r3S'
MOVIE += 'ZApf6TJFjT8/TwUi7QtCOptfVshaYdlabUlgiJqDX5VmwBPwk53kSxaAC80sCrt0'
MOVIE += 'GaKRdKS8ObdfNib9vvLx58p/t2buYPODBBOHRFMEfo5Iqgg5Zc8OjSRfMRX9J9Ug'
MOVIE += 'LixtBBBhBSQPB/JL4yseslordTm/6jGpSmXoSlSzz0ZmOUGvD/qUxbnkRr8Wxdf7'
MOVIE += 'iUv6/HANNfd7nGcA7UEktDtE96BzF0WyqX7cIXK0cnMparJpxbmf+zf5B3Hp/KcC'
MOVIE += '7+imYc73fn0lJxhDs4P9AN/ZXISTbOMzG2f2hXN7TRHE1dfR61Z8pAH5PQ70exgW'
MOVIE += 'HsyjGaACxydH/AiF/+7x+GvuCJSiqAha82vS49ptLgBaNdGoMKypsOZ7v++Ajzrz'
MOVIE += 'EvKTvHoJMN8x6r/EdmXYjamLISbrPKqoxE8la1kHt3+aP8wPGclrSbkXFUvAs4MM'
MOVIE += 'qclFGciHsiSNmigIWQVAUjSPX/0MIHKUeOvMZHlFVgQj1gXSKlMJEnxBeQSWSgO3'
MOVIE += '4wRopVs0/Nkj2ZU1OlMihaWTbq4MgBIWvr9ECoO0qPX5mniSi6hnkf5Bd23BFGlr'
MOVIE += 'Yj0rOqysCCSgCSXlQzQph0QiGJXUT4UkWN2esLDRMrJLZbDSpTnSZ+wu0VdGlcKi'
MOVIE += 'iwsCSZfcBY/Jl19FZ+bwBknFUPtQ4Id5vozN7zDVYaENfEVNYaEEJsQD0JNgtEKh'
MOVIE += '+j9Gw3vDDrMf60uxNmoYtQITX4dpeoQklq6n21LyiI1Tnpk/TVyAJ0oqKVmEBaRS'
MOVIE += '0D8+9TltXgS7d3SpRO8GWAIpCIfw53uBNKw+fTomxC/Ddq5b/Unx6KKo1pM+SivR'
MOVIE += 'XhSkL1ynOxfK/xSXtn2YxOKYlC6KABtbkBfuJP3woO1zfOe1Fk7W0rynjH0f/rWC'
MOVIE += 'xqICzod10ZAguUt2L5/K22+lHXsWzppXcZnDGqE/RJHmSHfdC4g0yXtfmLc0T8kx'
MOVIE += 'NyYpjSaxtEjM3UnplqELDaO8cGQ65/tcrRK7SzwIxvOSgcq89+0n5yjU4frhlelf'
MOVIE += 'QXXbgdXBUgVi49oq6FN2Ly9WmBSxVPek7rmNKluiJCC/JjQYsRHGS/l49Ujm2UF+'
MOVIE += 'gSBlbDso5TEQ1F+VPdKjVlgJ8XKMlf9RXtqkTh0+IUnCvpmI1RlimsE6lB1U5d+U'
MOVIE += '3yMKvuQ5xJLzNvU+DQhbzfhZ1tdb8MIsfI2dxrBcdblA7TOumAJjSxldp0SO3Y19'
MOVIE += 'N8Mbd2/qor9LKV0kb5rf8LW/AUuFXpEKvfv1U7NJ9gRjWdDtl8ygbfRDxsl5l7AE'
MOVIE += 'yqI/eu//qssFYLaosB5cNlm7QZGOxG7JsmorMfXuTrWSvdSQe/mHsvFv+8tkUw+F'
MOVIE += '9afUvw3dmzKJ/mS+urHqve+0x9W6tyIpHKBRu9YPfgoMZuacrtRp71Les77tjLq0'
MOVIE += 'ivteeUm3f+lT60cEPn4aT9PWQv/M2ftHpbH/5UZMmDCNNvoBEFnuS+9KjtlCsj7P'
MOVIE += 'fmWi19l+o9Y7m2qK4OhI+8DIgfke2NP368Mx5ltDVUES9Fv/31Xeig46jd68o7VA'
MOVIE += 'HkdHBC7bdxOki4Ko+g+y0/YuWbVwQylba28id7w/5b1VYcT/WzxKt7t59/MecNL9'
MOVIE += 'yJohuTQo75kjnC7UkjYSHPWu9tUp9WzRfXtK4HMG3Q1RG2cqSgtCZvGdGFUVcVWb'
MOVIE += 'yb8Xr0QP3WV6Qx8WPzroG4uHvy8gN/Il+JJUrqp+NL7WJrU7lEWpkjJWkPJkQEcq'
MOVIE += '0vqr0MiLU7l7WooPQ1NeyZxGybjm1mS0eH6YZfeTvsZcqqGEXQRm6IdFfx5phYM4'
MOVIE += '9FVQMVD5CMAFII5yfDddsihCNxvriPCvq5OrOthxhHLhLJF1aicly48u5tpn8/4s'
MOVIE += 'PAz4TW5aDE+kcfy8gXSc9rAaGuss+UlaASl2Kp55Uq6qAo4BZo8VUEcNrccCme9J'
MOVIE += 'jjsVhe+3dKIrXt6lKCEwAyjtGuUEB6gLIjDCRJzeQU2HaauYdAVKxqNXQi5ZkE8i'
MOVIE += 'UkaQe3Ii8IO4JPMTUn505IOTJy3yta5yOQUh9j+mCngMliIQCcrT7BAsffdw5aUs'
MOVIE += 'kGJ5S0x1X5IISKrsAAIht/jLQi4jM4wG+klCxx4U7EDgTSNJFBhHMN73nkc2Qqbl'
MOVIE += 'uhQYBuMKCj4gaSRS7Qll4IwsgtDx3Usu6iyscsMQjYCt6hSCdKcE2Tq9l/4m0eRp'
MOVIE += '/9Pc6qXBT5YDJx3XcNJdvCtKlrkf43SsIPNt/EgHkM+fG5wz1BhLPfUvS2Tw0mb3'
MOVIE += '86tu+D4WJg4A0XDFZJSdCyuu4Et2J5vi7gysVm0/rNZunwAdMu510z12fXrwaQsi'
MOVIE += '9RTbxek36/G7iJgKCouhF+528jBkDEfdudR/9rn/QvLfrNj+Xfl7G+3+cRXDCqms'
MOVIE += 'XPMtIk8r/+7xRpUQBwxEQ/CcUBKYy9SPXiUE5Fl/l0a2e6Ap3+Mf5G30ZfkX0qct'
MOVIE += '9f/e9hi870fZhf/A+VikbAVhXCj/k1OXIBR9AUgAhPV0U8SwUssz/vkv/vr9f1V6'
MOVIE += 'jCJG1r+zl0KdmcJqeqjT7nPXy4+X3Ei/PSedRw5P3z1lQ/7ZB/03xE5vx0yKQ4OF'
MOVIE += 'WP4uPO8yYPp0l/3S+VdGy/qV5nsW2/9cGV+bIIaIcAO6PNwXdrHk+hPP74bQC/MF'
MOVIE += 'iQssf7U+vET9exCwIV3V//6/tx4aXz1qsaR+ucijcvl53MXfOzkH5N0C7uJt1ZrS'
MOVIE += '4+M24r8LD0aX+vwColfU/nv54+u/hKGHDY5/YA4/Dpz+/H2LfFM1cLBHdnMnN7/D'
MOVIE += 'Gzp0Qfm/gCYNBt2tpXiWSj8BF6h7T3kHBsQDMX/+3td9kEE6KsipURBil/eCaXr+'
MOVIE += 'fuEXLPaxpbF4Uv50FnSUvORD1D3/eOE7ZIc79ww/aC8LAI6G7H82G8D8MYKTZJH+'
MOVIE += 'vY9/jaNao44lMfvlj5//bIaoTd84sJVbtulC8F6QD/wvbMD5W3EfBMBrkzLmfnyW'
MOVIE += 'vy/Wv1fJfr1LHKK2eeBmfv/Z+vd5U6H+Bl0YGcvFIFIV8L+F3uq9/HH78M8m9Sqe'
MOVIE += '28CAic1b3YFb8YuPNvaupP+LkiXPYyNL/o7cBkt/CBidVikygfz3VqVZh912l/sP'
MOVIE += 'Qun6foSFuw8dZeTq7kb69apsABIHpMm/sPCe96p2any4gbYbFsD/jQaf+FMYUBK4'
MOVIE += '85yFhGQAbWVXUzyl2qwDdp22hvxvQ29ph7YeV+3EEKKbyfH+G6wC4L0VPyzXZZTD'
MOVIE += '/7+f+iIA6t13JOrlelUX05DTAzZb92uzctj/Rn5inEpXcXcflRyUpBpEUu06Hvh/'
MOVIE += 'du1J5gWP+3QAlwakOhaOUOL7v++epl/wcL+ujv2zgLbqIft/wV3mXPBoQPfrtv+3'
MOVIE += 'P//vsSoP/D9P7Pn+70z9fq37f49D8RNaQrz/PVFjxPtfcM8nF/7PAoWyx/PPG8Cg'
MOVIE += '/0fh3fy/FN4m4MX/ofASiHzbT8xMAgEo2CBIpzm0XlGa1qZae+VYMgpGvH5UlfEy'
MOVIE += 'HamSRCzTtNFsXepfOjyelT2dh3KeKrH0Opgplg46uafwckuaTKTQiZkRuqczi2fx'
MOVIE += '2fZ34afVibtw5CZFN6z8j8L7MelHfZYfi2i4dEClWhYHr37kH7zh2GSEkA+kUO7X'
MOVIE += '2YZA+Pe8DevDudIHzyFCVtVnlbsjCZT8djO9ImM8tINIgKEDKwAiw3xedLQ+PZ7K'
MOVIE += 'uiPNoFVUPWnaaiFD/2Px85xBn810md6Tnw3GEkE92YsqJ+bMuMyL60oI79qnieyg'
MOVIE += 'jwvO8a9IHR+k8IAv5xKoeDffpOq8av04EPH75g4qUND26fvRUtPL+qjyMRkaiimD'
MOVIE += 'a1yyyFzaHWoeAcAeubEALTY1uxjFdLUK2swZ9CYyOnai4eq92WxfkAfW5pGAjkku'
MOVIE += 'zFnAOOlULE9loNwEZuShUyEaFFIkoBxFgPT4lWfzcSOENjzyB9TCIboQfyECjUdQ'
MOVIE += 'DS2yDB51+U5iiCFMYYxmxicIMM3SApFKE4nPTexpiwxfg5BcTe3VmrqSuz2UvMWj'
MOVIE += 'XLtFPtqaFQFWeqa6IlPVS5AE9sOGOjPOvTYVadqCHSCB0la7Jlx42CPKOmBBMz/V'
MOVIE += 'YKfgkz2WQL1OssCt8bi2JPTkuK48jq+xluT20tmR+i/QNQusugONMFK9o8NBOgwt'
MOVIE += 'a3Itt5VJOCx+FpXrieZWJov0R4J8dKttOmfafSVPBQyEuoNYza0LjDSY/G4Be11P'
MOVIE += 'Qhkqibn25kckmSI/YQl4U/xbCZJEvaKrtkupPcMjv2gmOMSmNn59c/vzAy/QARFE'
MOVIE += 'Uhr3eAEAwCfOADxHXfci2PEfqQLILdikyzU7542tolz6q3VE3vl8S9Rx7nFJEimm'
MOVIE += '+nE2JfBZtcJ4x657ZCY8wvu78ZtcmFiviDWUB8ZSAv84L9JPPbIge3RxFPY4NtOZ'
MOVIE += '4dnvlaoRZXPfECfAf6IoJzy9i8JIxoKkRieNGSms/KBd80/N3tH9Re4Jqjhdobqc'
MOVIE += 'FD2hcUaVsOnIX3ezi7znFzQrszFBIVRmBmZqKmZyyIoYCk1Ut4pUFKFCsIXa29jg'
MOVIE += 'RaUjgOeSgYbgD4c6O9+bY8g1AI+92CaoAHsRzoQZBVtcTKwnklO0q/NfyG5u4v6A'
MOVIE += 'uDof+AbOXPZThRBujwmc/vrOH9RhvKM1ZHn9Q0eBU4XSWvxyjMa+YBevxy9yQXV/'
MOVIE += '484fi5+vkf97QcR/+/fncJlZ2uXKXxY3x7dEWmjYpKbqqV18iik6Ckb0pwi21VnA'
MOVIE += 'OBMPuODRusCEcWp0kXDVWeANhWKJHXmrEJNI5it1GOvrL4c86zq7xuEOeHM+/rRP'
MOVIE += '/EdKI2qpHgCxT7842y/s0D6oGfO2s4RF/72bmse7/V0j/+f0BcWCGID0jI08UXNG'
MOVIE += 'pB5LoDkqhGWQiXLeY3/ROekURbmPaNMmf+Xtw0P3DlBYpDmhLtXtIhVtwvrTpQ2q'
MOVIE += 'Ne+pXwSIoetBMlLZ1eDrrauThqzTME8Jw76BKuFf3UflkAGJGbrvgWz+KTxshxoL'
MOVIE += '9VCu/QrgJqsDaeolSBmuDCBZ3jN34EjViolPJupQpdXvYG/MyyyW3FzUG9jNY3xk'
MOVIE += '/s67OoA2ZH2YtBxU0nwFEGA3XDtIWgVdBwh5JvpswpN5+jX6ScMyZw7V3MLkkqS1'
MOVIE += '6PRv3BxrRYgtfSiSu/mNnUyR/AD/KvO3RIZiKGxieC2FblXbJG8j8E4fL+0sD5A6'
MOVIE += 'XxzOFV30JdBAu34kHdAOrfOH4nPdYJG5dHkubtxQ+TNWcV/TtygXR2G16lr2zAJe'
MOVIE += 'Hy+TYoYKFTUOVv1Pid8RPfVQQXgveYxHu8glK07ZHNOzoDtJm+EQq2BCkGrfvk85'
MOVIE += 'ibAWWUXM1y5y+Y9nYn+QyrIFPFVSKV4HkWVE1zGHs4MPKZKDW8GgFHpRz7JPHnBa'
MOVIE += 'rdEM5szqAtFjLfY+8onbesTI/KZEenyjxzyIgl/TQRldyNduq/qAPjMdb9+I38Om'
MOVIE += 'gWYlYdyQmweJskXRgm+RoqpHy3MnHP5mhXxmaldUzPKt0maZJ+YX9wJ4mCg4V+cQ'
MOVIE += '5nQvxb2Tpmzx/JsGp6UzvjVLCl7LObXJ782kD/+OSIA1SoctGDuilZntsg0gzHto'
MOVIE += 'QFedQ2KuBSjhYiyFZIR6qEDAyDKRxLF7mapM76VBeX/vAk1aQKVr0p7ufip617BH'
MOVIE += 'xGnNUqrxw8ces+q3NUX+8dNvU+GetMX1o7kerCkuiPds8D41w6cZ6zEeC2LfHuc6'
MOVIE += 'zmMyYkh2AAQWWAEX8hRvQ6MB1Rpub+1LPe5j5UHUGy3vTSOFXycE+k+/VZkjN+04'
MOVIE += 'MrwFmHGPCNdXdFO//RJ6HWL16F2Q8A5pAe6vtQX4yD+ZP3d0qhM+jvqmXpdhVEWB'
MOVIE += '3+wP3BF7wYiMmyHLQeMojFL5U8Pu0DS3EB2C2g7EB0subPGGUUSbWQtV1/sknZLU'
MOVIE += 'JnrScjWNZqQhlY3kO5nuvRpiL4vAf1f5qjy/XopCEkD8HsD3/0lUmd/LkYlSyYmP'
MOVIE += '5tzDomeZ5FgKAOwee+imyO+aF48JyzXZyGt3zkoV/mR9tJkot9jdKPddjWbB1FSe'
MOVIE += 'TJG+9vlDs/UPrpEZeloN9TnmdLICZ5THFitVfgGssFG7mo7nJxru4g9jRDSccgmJ'
MOVIE += 'E7Qt4/cf1qBihRqNPtu+u+YUNrGJ7OQGMweTPR1mlky88QVVcJoIJK5+9WX4ciSg'
MOVIE += 'al1tVBVc0+Qry8kEAH2bR+RZkKfoIz/l2DOSRMdjibU4qij478KRroobBTKqGDNK'
MOVIE += 'JIhja8C30nhyiSaypvXLx40sLSDfn1ZWEouJeOFl3XzQmnYiV5j9rzGPt9pV9n+Z'
MOVIE += 'tyfU5KOC/031r3a2LoFiLJw760cF7/tVTLZv2f/HrPATIQ7X9FFc8yVmV8U1wqer'
MOVIE += 'PjbIy2lKmz8q+1qkDIf+NGuMipFtdmzSV4pY7AQJ/YhdOUZibjqL1X/c2pairN8P'
MOVIE += 'HCqthKRufaQd6e3m4jgjNiXk+eKon6AORydcaaqb0yf+5v3UEGbpPPxVdkOGwGCB'
MOVIE += '9IuIu8wTD2Xj8o7rT1fqjfa2bimEkyPK3bsE8/FvxOlkvqj5/LtZX8PLCbUi8oCM'
MOVIE += 'IBJRcXeoZ9oUmTiVNkCvZ8RhWyO+Fw6fRuUyPCjtSWmX+q8FsK8p1fscMcQgX5JJ'
MOVIE += 'pHVApDRcU6ZLZW6ULQyO9030KdIshEIjQHvUkVBEZL6cM3HnoV1U2NtoAt53LCTz'
MOVIE += 'EadDMA0HOgoTAD+AjN4kov3Qb7gK+UODqxYVXXtBIJnwnF9FYbIdbI8Dy3Nh4sBC'
MOVIE += 'kXmR0qqaRUHiWgA1wxx84npNAzBWnwv7dwT25ZfjNwxB6zwB+zjWDmT6DeNJX+Go'
MOVIE += 'NPxMU1SuUQNCly/5TUMJsAdbhUev+zMcrMgGKXM/cda5CWOEmrHd4sfoslIrlEM+'
MOVIE += 'OHhIj+oS1McYUT1l+hFjBH64cfcr4V8H0XOHKEoA/jOzJ+wLxN0ZgdVdaGIIRwoc'
MOVIE += '+gcYJPow6LxHOw0Trc8pMJlBrKYUP4Z+1IhQeM0qFEDlY7IQ/0w6UmQE/CMEROWa'
MOVIE += 'MJcDhWfC3nM/9R5L0Kh+kLGecvsNQZCJZp1/ChqO7USbGC3i1X2H4QOfdJqAPBCB'
MOVIE += 'QglJrV3e/iYIUif5aTSVPjScpoN614ntda/zHw2woptM7BFILU5cHY6X7I+/ICX8'
MOVIE += '7wcmFYE1rldtkgSA0IBBMMV3DrtaLpbPqw881JM68Sm8CsI6HZQ619XpIcpqmURn'
MOVIE += 'iPgv6090K5x596WfqptJw0nPsoHKPenFYN4J6YxFGgfKu7AM82wTBnKnPR47ZgtH'
MOVIE += 'VpiW0UVgszJAJD+O4spNPN8gNJRwJIv4KMQ9CSmtjc36GgtxA8CGpaykMZCfsfZI'
MOVIE += 'ZLZ6nmZmlgvZkfVqdfbf7/jCa9kfagL2Qp4RRMOdelUrEryIRACwciCfhUgBQt3v'
MOVIE += 'OufFfNivcQYlDel7puOr1VyBYzNaANN1jT8RbchCfN4dVGIfaPNiIu+hCr59FUo0'
MOVIE += 'PqwkB8Ac6lAqE4sqz8dvM1H1d8XKKFUZpomsZvqO2uH/gD4pJ8ZgFAW0wA8uGJ0l'
MOVIE += 'rHMmPfIInjIf2Ov0FB5mFpVZSthhnlF+z67CEojnAoii8YLU4M8zwNmXodXBAPo7'
MOVIE += 'nMkygTqF6nP/9bSFb09e7+NFZsD8kOH4nBAlcyMVN+ss2gytWhe/sRKZ3yXKFPwb'
MOVIE += 'UCV+HiTdfU7f0c2gR1VmHlBt6sfQDlD0DzMzNqB25myXLPYLJGTcrGCOYOBfoD/m'
MOVIE += 'dcaqS8t3ghWvoVlt0H5NaYAm2H4FiEsQWncUV4/TXOh6kSUpawQrPxbJpDWS3JAA'
MOVIE += 'XmAIUl29YPTAj13l2lf4ag2B9mJAenhaYF/cvoYBnxHDKyPCFw6E023EE/NJyiK1'
MOVIE += '4zvyi2KVouasa+zU8tH3+Gp8zflKKUrMSbSKeBFI8sQnIyrPsa0qzilDMYIZOo+K'
MOVIE += 'MwLDb/IxseWO1y+C7g6gbBgOsFdcjSrkoi32hXmqWSA/15BID5DqXbZloBmxMFfl'
MOVIE += 'K5dimaEnibxsxkNWmvOQhhs7IyPqd+OK69i6oqo6mSKXZ7ISKfT18ZlwxnL9KYf6'
MOVIE += 'LG3gw/BnSYTVPjL4GhgvQ1mAcVKcJ49BRFjo0TFltznJbpcN7YJ8dYROTQZRvwNh'
MOVIE += 'tUOjX1WtFKWYb0TyObXQiTMoy7LqcZK5NJ+w7Eld/lrTm349mCMwxpW8Ka5cdVNL'
MOVIE += 'iy9K8aQ+g7DCbYRk16MB6GTwMIqga4NyOEtqS1Zy4sLgvyn1mjZilmpik99I4exW'
MOVIE += 'SEiupLqK3ZiQEtfLV3wPnjQ2yW26LPe8TDLCmty5IfAb62Wf5GNv8D0MY983RlCi'
MOVIE += 'gKw74HsD4asurCeYBHVEwdrfLhjAoDUmwfrB8kUbsT6b6KKJVM0Oae1NEDQkEjIm'
MOVIE += 'ZiGTPh6sS4cG0bg25RZaTyBUB1c00zNezlm8KnWKAuM61+BtsjqAKe3O12iYzEW9'
MOVIE += 'oVUv5F5ZltF74R/WiTbgk2yXr1D6FEw82UbMVuh9rEb4TbK7H014eAGizoBTlJMa'
MOVIE += 'PqFc/u4uj7MCevRMLDAO9/VIern4NWk+5fN9JvLKwv1VfzIvxYWjbTwgorgzaSpw'
MOVIE += 'SK0TMgRTJAKre/ZmNpKTlAM/EZBp8JPp8zKgjUjsraINmuzugbrjKvioOyQQ/5Mj'
MOVIE += 'PhKwhWKo+/CopR+6E4Tn7s/d3BTfCk1ZG+oZl3mtR/mqMvp1wavX/dYweow+oPxV'
MOVIE += 'ZHH5E2hvwiU+qhxE6hWlxFBEIALc2gEflpP2GumgLluu3R5Ng/HkCYYIcCRxfZTl'
MOVIE += 'rlb2KMXINjyMYbA2/K2NI5vyPLDDrEk00fqq0/rmCX5Q8mtdwl6znMAjl4fO7AOQ'
MOVIE += 'C3yw0QAsEvEchZ9GD5y7CW3Mt81qNCFqA1DgSEwchhhvpMRYlQ9vBOouCLZQQGa8'
MOVIE += 'MaNbELvPc24XRvHoypcnw8kj4AnTtzewECkBVZHXI2LFo9S7Fl1wCy220VYV2PSp'
MOVIE += 'Kv7Mu7iFwoq7Xhw5BlDg1uvGOCnsQEqtS9jX3l19MzYXSHiCdpQlGmJgBXrKsw4+'
MOVIE += '7OEhfBfHDslVGQll1PM2ey3V8M7509tZHmQ3GhLe9IyKvK0/ZTThFqUz00wDB5Lv'
MOVIE += '4AwbO7UWAeY2QGqbaLdA03GKbkb+cWPiqYV1wMIAMiFx6nEUeOIK+F8GU/IhqPeg'
MOVIE += 'hyl2pEdOdk11OuPab52HZbAZxDY//eZ2OuUykaMXx2g4M97cplF4TzAlyW4mrb7n'
MOVIE += 'LOPSGLZEDawJDwENFZMAtA7gEDWlcMm1VcK920YidhP8wWjOK3bu2U3d6czcBjeF'
MOVIE += 'GBR4wDXxc+aB3D1qWhQ/CIOHcgDS3O00f8O+giABRI+9RmdIqG0IQ79LWdv0d7Eq'
MOVIE += '3APEmcxNCByBduUsbr3kwuWTdD5ZgREL2ruMvMNCGuFVjN3WcRSL0UqLszwG9uIm'
MOVIE += 'iw2LCgOLibtQs14OjR2oho1xGQZPphzE5wBMF+BnCAAwrw58awcIo6C5Ait1jaSD'
MOVIE += 'xSipWSC9ejMLDWCrvB3ECT3zWgHzGLG0+RQtdeQlunihEWGA1VXu1XQP+nmHVafa'
MOVIE += 'V54tqzSZ4L8lcBIccDMREdM26uEP+eMz45ayTja1BtkBPLSZlAgYovJ9ftIG6P+y'
MOVIE += '2d5C7AEvItpBxpBQns8z5KQy7oFopnpW6M1eugfgw9thuXdSnuyCm0X4Oeu9a5Ol'
MOVIE += 'm4225CCv3m+OQA0Hi6JARDAJmG1+4vHsdqw1ULjtvxybIbvkIRt5SgcAQE4ws0gE'
MOVIE += 'nyAZcHKx5WeSK+5PVSf/8SE2/MMFCVMGU0qgdToF3tZHNuRH2qXal1jtJx/cSo/C'
MOVIE += 'Oo9Kt1/jYNP8LOWLAD7/7ZQhGEpvbYS44fpLKlkMwPxsSU1JVGWQ4h4+X8AlQo78'
MOVIE += '9CUf5aG73IF9tDDYT+FHjTkiEYnabX+i6doGy1vGQ37UfN7/DlYiKcgjf0ACIC43'
MOVIE += '5m3dfF7OC4UDpbY3Ccg/zW3QheiFZd6+p1d6w9KDAuBmNrboTwAVcT7kp6Uotpl9'
MOVIE += 'vTs7UQztQUo+VV4p02bFbtACnnYvDEUUIM+3p9io3eSymRhyyJfGnM1jm2J4Mum9'
MOVIE += 'JCUIEk1jTveHPEr8z21r4MXC/aEbE6oghc6v3RO6aO/pyb0Adsplvyv1irGj5xYK'
MOVIE += 'PySsM9/IBJPj5VXjMVOr/scUoJA08dOf7EI1yC+v/lH8XoXip2lrQFNaWxwROI4z'
MOVIE += 'LAi3HtYKzzXaP51jIWIFUv4lGCy2DXAnD/WLO8yYf2+cG+l2Ji1GrTlPMvXsQDFG'
MOVIE += 'c+tv5AIz3tK/e0FGZ/kF4Q9/Mr+8zMT+JZaek//KJkLfLKfM8z6fb/7uSEfib1LS'
MOVIE += 'YUyFxaO5/75TAAqM/UjgwO93KXgo2+8SBvg9H/e0/679EGIhiuk0TBkPqYKpfu1S'
MOVIE += 'Sj3iEIBmKWw8dmKT38HTxDk/OhPEiLqouGlKZEEfTZv7mulhikbJ7cl++H8hs4xA'
MOVIE += 'tica2gDqBy9p2re+K71vsp3JuUTTlF9Si+AzPV/i5wah2n4mKkXxIX+9K7GgySii'
MOVIE += 'kpaDOgCr0YSxBMuqD5Z9QdLUgZGSI9FZ/niZJivbbO9cJVz+hGu2lqRALDNWSH++'
MOVIE += '9L95CSe8Ql96XXtuAb7mYFd90r+yG1iUDcPwTHoH0jqlFVlo4NC7zZZk8ocxKPym'
MOVIE += 'hkCYrFs8sAuGBM7d3Wbffs58TtinqvLx9qoISeCGu+K7u+Kmhc858x7/0H69rHFD'
MOVIE += '9rWJPP2m/vmXKmDB1r+fw7J/XmN2vpMDL77woub/EOzy8UPhHvQApAUcACL3CBV0'
MOVIE += 'WZ/fVUkgSrfgQWdgxnjggwhx6XL2IdDWzFO+MS1yyRxes1YXT2NXOV7xewMzo6VD'
MOVIE += 'vRIZz/nRiuq0Dlnp0CMOq2UefeaPxpFiC5VqxPWyUbokWfuTK9yWwz6CJrWza3KO'
MOVIE += 'd3ArU8k9yy7PldaP0KkvTQ8bd940ur/MbLZ8/HSBLQtTlRRbtk7KZVPgT5rGuPrP'
MOVIE += '6JIcDUQQBSGvE5DvWHwLJR4dbm0EuQ29RvgOaJYDduZJBKmu1m8+YcDtBLo7ta0u'
MOVIE += 'dzpbfUZ8UYmfjr4WSUd4iXZSXl/+Jz0c4nBC5UXMZFxnNVikxv/wpcNYloT3+p9f'
MOVIE += '8Y9UYotOJZfln/y6kPzOmax5HMWGwNbZP/D1IH2+EWH5dyEK9s7UQbVz+YxohlId'
MOVIE += 'zl8PkGWbSi9flecTHIbcJs0KE/gs+Y7kUmWC4pkz2KekCn96sEmTmwwkcnH0aFU0'
MOVIE += '1FVm6eOfNH7gS2l948XeLDfO553pnUNgrAlOjqmX55huOi2zjByCZL3ZAeOiHpCK'
MOVIE += 'f5u6r39gqiZWnfYTkhjFEqJl2lISMrCEU7vNMosCAKA0UYbJTDoH6rNkvs1e20ho'
MOVIE += 'BCwT74HZwCQJRwqlqSGdv8cdOYRSN5y0/6h6mK+JIWA5QIP565GfJtusgKiW4acI'
MOVIE += 'TgVuEVZQVPJwSvkMSCGEWlB8WKB+euwmqBkjYR/CQxhNX/BVQDktwYlU/ZA/j1y8'
MOVIE += '8l6zSgrP6C4Hyzd+ocrXHwp6n6PvqYHnB1ToquWKwGFrH5lUe+I/QoRc9Wly1pzL'
MOVIE += 'tgrNmpogZb6YPrxQJgmhiNCsgTK/BfHAgMLNo78c4jTFEsy7EYlRomlshrDdWCQX'
MOVIE += 'z8M//wrAceKWlA4Y6ExFXrZB41APZ8B0t2c8fNLst7Qf9cfaBQ3W3HO+Jr6P2tu6'
MOVIE += 'Ut35e8NXggZCSkmFHK1XbpnuoDXm6Xqzcvt7BiAC7/aOuCsW9rgNSQRLpE+FEhVc'
MOVIE += 'TyUOU/V202qLQAtd9d0mS8nCAn/P+9mrCxnRxyAcbUOrilvVSx8fLnx+UWWnc/SN'
MOVIE += '67ELpd32yUMaTfEMCkBc+8BN4IzYfykP01Qx9JUtBHu40/e2pf3lMG1378wHVi8+'
MOVIE += 'hQhXGppPpZNkADL1Wj+aGPhskbf6qbruOPK8xjKE1bEU7H04POYisXn3mEBK3mPU'
MOVIE += 'njymQK8e6yp/uWhdUZl0a4wN1n9u/jSiB6fbrD2k+GgGuUxM9vd4haBwJJk9zbDC'
MOVIE += 'WXa32J/Qq0+Pk1tGTbd3peUBtQFW7feQ5BtydrqPZ7arfWk74mNM9+1bT6OVGBVu'
MOVIE += 'AXcpKggw+QfKdJsbNUgnuaoT0cL6KX3XENvjXUuAB26dmSLWfdI9woMe8XteFF+8'
MOVIE += 'HgkiaVv3ZuNgvfvNeX/HFwOwBmUXdflgTTimyPqBUVTyfMbPOwmh/LDBob+a0Sh5'
MOVIE += 'xj2u3XgtxmiKfSzRY9Mh9YgrsBkeL44c4AInVx2Kd7lKo03SzIhScCF9b0x8gzPP'
MOVIE += 'UC4jINGAfdzw46zlsFMF9QexSXZxMlLMpiaZnmHhPUAQ7ZVeFOUtG2Ikakjk26XA'
MOVIE += 'Cvt7vrTd+Ff3uZitT++cGcX68Oa/RjbGaBYrVo6AY4VATyBFUTDlpmV41ANrUbYu'
MOVIE += 'YgfMeuRZwlJMqoZDebL2naKRNIZtm0tqI5olvApckYI081IdaqkfitpqoBV+ODml'
MOVIE += 'xegk1JhxYL0lSkYIcABmf2e5TTjW754ZMrdxXhHSx8+K0n/0jISOhBitXMf+hgBI'
MOVIE += 'kQGQEogwSnFbxq9FqUl2HzPoRZhgRyiHoWikdlCWaOkpFTua3Vihon1BsG3nHeOf'
MOVIE += 'zyw/+4JDvorBQGm4BCX6fRjKJWZslKsgVeR7Lb4DWm1WidBGtZuqrtzLrCXCrDGC'
MOVIE += 'SmrgUk9qkNP49e8G/G2UEqGTC7hR/KXsxVRa6PkF7JxKRROyyKv7w/X9Qxzbi2Av'
MOVIE += 'DIwnyqSU+TD9vrqL7zKGta/4SqbwF0zPGGESrct6R2tCUm4u+Jqi9wfOFQvythjq'
MOVIE += 'I6GVd+Xz0OM1X980Z1ZQ7l5sarJVOUh/dhXNcnsxrQZHGd537tfLq9nqg5+wYK9e'
MOVIE += 'At6UbrMSRGHcfrwEMvZWaXA9tjzqgfhxnDSD/o4KPpLmhIWFR5FUm+Rqla7mND6F'
MOVIE += 'eNueWBn+HqllbMcJMau/S4SuIWk0zx6tZL2gY+58ar5o81ysDrX7M6T+NRIyWsnZ'
MOVIE += 'MUXYRtVX4ENZVUzR+7i7n4+IijTGIRrFwUYuhmyR0bNu6HFKGjjIbXr6IWr720w0'
MOVIE += 'y2+z3UgXjwzY7QlZ748tIb1bThp25D1EQsXJ16c6OqkBQIMGB2ixC273faHqv5Me'
MOVIE += 'F8lT0jrqj3al7PmQ86QtVt7Ff4TJnL/Gj2qvLaW39BeIJykzx4BQCwZs3rOJfDYG'
MOVIE += '2yJdH/XaTfc3QzXf7E0XMPKiIaYZhvyWSCtaI40oA/UkPTgBHdkhk3uDjRDdNQGB'
MOVIE += 'OzwlTmZL6GLzaJpGgGg1Z9feMH5TzE2IDGocrmr1hQ6AYIf4hch87kS8ei57iKFN'
MOVIE += 'OG2Yq5+/7w/SzFBxOFIodaIrkcXLEW5qgSgW+T3ziorjzMRnUJ23/brZxTvyrWo5'
MOVIE += 'wepDOdcPm598bf961edmoRwqkZYZeFv0q6S7gi4EbFHsV9fv4jaCXuAPTIM61Zn0'
MOVIE += '5cc2Y7oSbVBFBu9Meu6Sejk90ZpOtPN5kuHZgJfhlsV239XtX+0ag2AiDqQmQS5A'
MOVIE += 'UENNGQ0VDnBRMrRa2k1FeLms7IeBXkTWyKCbgXYTQVY/b0EOQUdU1Wh1UXqBC6Bf'
MOVIE += '0w7e50nSmYwjuXVkTkEPYfejYF5d2w8DA13SPCjSiqiASCWfZ+ZrCAoXwMDNPoXl'
MOVIE += '/e912wMauVqgTMIwi9d5qYzAtHfFnJRSr6MPaeYwVfhz1Facn1C+BBA+5RG9OH18'
MOVIE += '0WSqXeqXG9F+Zv3DSrkezyVe5A8ubT0WFbUF3cGQvO30nX8StYXp+U8Vj5+LacSB'
MOVIE += 'dECIeIxh0QbS6+yCTm9l27oMI/fNtpavVxEhvHt7Jchm557sfpu+rR+SHM/mAHZA'
MOVIE += 'D3rhtjUEIGh3BgwmpguGh4Z91LhQvmLI0sb8G3L6oqZDZXrxMMxEiPCbEPzoD0Ps'
MOVIE += 'jM0ofl61QtXftJic2IT+9FYGroCOaK56sBiSP7QQuzhFeIpLY5zMWaHvFO2UjuyH'
MOVIE += 'pcOq1cIFWoEULRWKAGR27DrMix7woAqMv9wgCQbIqBCVfwOR7rzQkE0Y/gZCP8kd'
MOVIE += '64ARTPTdfOdRm4+VrY/mgjVofAAiSxLBwwS7RiAOwyjf8LQuZfng4czWiyRdR+4L'
MOVIE += 'lTd+RNDNLNy1Z3dawYBteMyZdxE7Mvn2Gh3lgGFs6yY35SSiYnjvkHA36wF7RwF0'
MOVIE += '9xwS2VVc5adw64e9ea3EvRjruX7PL8xszWo7AZEjVTOpM7EVaNCjcNKvsjiuSGWe'
MOVIE += 'fXJlnpfipjWNYOjzekF6NhZ1Qz7srrLstbJG0cADpBpJcDXAAUAkHUUbWJfmiXm+'
MOVIE += 'iAiRg6dOAokuXuIlYBgtFAweK4Iukp8GoRS7BEwyIFrrEKkdYAa97IPLtyXS5Uw7'
MOVIE += 'WC7NYUS4qqYuWiuYX2dAVbGx/yEs9hERBm2VIAMYA07kGsXA03mqM9lHOkVGer6r'
MOVIE += 'x/yOHjnhTPjNa9BbIowtkAFiZpQAiAINdplqiDSGVrPDaabWGB2npwlBG0blbTzI'
MOVIE += '/EbCbBh1J3wN4kAk+fYTsO4DORxG6fyBPmeiwZvj9WJEETGs/pDYZxiyb2JSpoyA'
MOVIE += 'l3+iRa5gQssx9PdIs5JonjbMkolaWbME+e0bXnFKwEjBWnQ7wka7IimKWvcBkwlQ'
MOVIE += 'vFelBwnp1NJ0stFMZ4vVbopWrgAy7gALCwjabqJctmJk16NSBzq4yic8t4AcJVi6'
MOVIE += 'a6FRFTQUUpUnqy0KevfwIvpHhIR4wciqA4YnQVGuA0OPLK2KjGHMGEkrf1NLgKFv'
MOVIE += 'U3k3ko/kfxcHGEt+/Lp8mD0O9SBJ87V90qtpH4UaJ7bWgWZjTXHXjBixdSA8M1Hw'
MOVIE += 'HkR4MZR/DORcB7t6iBrsRDM1g+/QqGi35kQk1WTWwDRk9N6DCNKxM/0IosEf0y7/'
MOVIE += 'HcduRa0nPZuAYE8lBwbHaJR1YeyuFA3a0YDw1+8tWOPD3y071o9/01+sroK1ARDi'
MOVIE += 'KYcRrStdzY6UFFrrIE6PKEH/aNUm8FY1ilkTP1YnxvZi1ikjRvi6NLdwPFlX+XUz'
MOVIE += '+YCL/hEd0bhAyRsfrR8UjfEXUYUcMjcXUfSarZ79vOQTQLl9CaNPDXiYhP6gFFSM'
MOVIE += 'yh2GGpExcl0iLEecOufwCroxcrsPN3FIUNUcH/r0XvCCa3YPO6QD+c80TnUHzMEz'
MOVIE += '18FYxqQZT9Q7zkksDM+mZSlUJpVg9M9JNgzXig5XYysUuQu9Ehd9YiItiCdbEE3f'
MOVIE += 'BjANfqXo3ceIjpbBpfh6t8ImGN9ZsM4mdI4lvIbBptLXx+w4St+vdxogjFv4jAXZ'
MOVIE += 'xRQNQY9OaMTQ41/BENbqVmTJOAsAJKTHL9wi2XaRmUe/dHypEzGvqs8BmHmdrxb+'
MOVIE += 'ZrWcRXp2pdMC8tcz77ZI9909zB+e1yivqOf/IDEwhRHJhM3IXvJXWJh/AVtfwNJp'
MOVIE += 'vgoamZUudsxZ1q40/Wc6z66AJ4YchVKU3SMlFQylWYEQZkNVQ6hyxlk1nQMz1+0i'
MOVIE += 'sWtdBHb14eV0H3pptZ6RrSKapx4oIUF5X2a+Z2TQ6L4Fratd7i9Zbb0zTMY8QErd'
MOVIE += 'LVfg1hLXu9tYqG0slr93shHNwjbM/ajLbXjaeeWjXayRexUE26dU+ExlubFrTOgo'
MOVIE += 'Pxgn+3Vr7RNpQsL2+ipa5xbpZ3+nm/gTKJfN7u2cOq2VhnXf/naSQwQP+Ban81xY'
MOVIE += 'UM9bXNy33iBm743D1hcUg3g2/FbM2pqF+oL12DaihQtE01N0ODyidBhqhBbViUBW'
MOVIE += 'Tz+uVZBAf0TQYNQ2ox1jaAKbYQXmdV8abPcxjkZ8pACJcUO5dn6KcmXw1+BNtn7K'
MOVIE += 'dmqk7bwZ/heBimvQkOGaN8/91ZqWLWe+CBr1eGUjqBJZ/8eyA5X3eiyr4imRZMIK'
MOVIE += 'L6/F29Ky3mjsd+9NN2O1uzuYxK893aheq+zoPkZfgJcgDDUPZR20yfGYcEYTGXA+'
MOVIE += 'zGUlr0BF/7cVJbwOgn6MlcUtU2PXdn+DCM0+dnekraYqv0u23Zj94H+1tgg335r9'
MOVIE += 'yLRYgKSvfABaTZ8v+SkPV0YZBD+xmVhJsdY1TZhq0UNCjz5SmvDEHQ/mH6fu7Faw'
MOVIE += 'nR0APwhQ7RIYxrLPX34BMl8D7xHsyAzCq6dRKAfbemf79bHRjdLk8Awc4dCwrXdu'
MOVIE += 'Vcmwdqx+tAII4UBz8FdDJHFB6iwF/YNYGGmX5a398DdFLmV21HE93hyJmsesvmeH'
MOVIE += '3noMV7Fdn5UxP5T/P0OQ1EXMBQl5O5u911bcvo3tXQta6+cPurxIx96CeLJu2/vT'
MOVIE += 'I6oG/E1eRsujgudC/+BADIDkEt9JKaJMAZCuVj3Nndccqlet9FqHuLQN8RxCTBIW'
MOVIE += 'vdFxBm00xhZ4gop4yseanS2Jr6AxYvWLnmfAb3+xXBdxmTnWEJtP3C7yoYEmFbHO'
MOVIE += 'vRfxlT9e1P5On5p5cZvJtHEJQiwXyAi6OY+/4LlwdaWhcfRj+izw0jnRjckORuKd'
MOVIE += '8JGECX2agucxEqPkRG7oJOaZewymG9TBwytzyZOGumQ0OV30efNCjSdiQ/RjBDMq'
MOVIE += 'Dcc5ONejmCFUpnnz7M3qb0UmD1Jc12xXSJ86vgpfEZs9cNBdgDBjkjCUiXlHd3Kx'
MOVIE += 'PIfOgBRmm9TtoztDIM0sMIPUM5P5+B3EKL5g6NPwJgSoOXfREOf/1pDo1edFKI+6'
MOVIE += 'e279vqd/R5G+u21bDJpjmkAHGZCJZZHOf3YIrCbVYkXhwAOGUWmyn20g/RHOMfoe'
MOVIE += 'sW9AVBiAfoyGw4FXqK5aG+kpO9/WP96+uAIjPMtk9lBiIoC7wS4rR/K2k25b4yal'
MOVIE += 'szTeC5OJPAd8zvqdk5tsTZ0eTbFPLNLDFH4n2DnyV0leDYcpVj2uHDLpz3iAH/QW'
MOVIE += 'NPvPZj08/g36PNs7I7j0Sk5oj99hef/B7McubFrazoBu/zoaaJLhom4d5+I/oVeA'
MOVIE += '5+y/TbLb9yL6C9ce353fMdd/uAfP8hI3ZpY/EWtxwvD7r4pLbfW5xTmV26x/ScAn'
MOVIE += '3vDLpLVsNDbQha7mUiLO8VhOklOV/vh9o/EmyKTmuLcEu0xZdMiYs6gfgtff7qGt'
MOVIE += 'ximglwk8bfenxrITY4/nxLENMlZBPtYA7g/89rpvFygF0FduMG7v2s6vIFCrBnKg'
MOVIE += 'T+5UbQ/9ZD+bn+2ZTB63pp/oUwx0cOtd4VO+O+ef8KP+HE/hEUD7KIDmLfZWJoaf'
MOVIE += 'B0v9/pz2eQBs/ZKw0DHKQvElKcbiR2+8hUrNFQVjY8qbsSx5RoyMNJ7m4VcGG9Ge'
MOVIE += '+x/6yUbtIqHiIywX2lLqGtRePRH4MbFQ84Rd3P4OXE1OQis8nn1OVpcO12C0jCKK'
MOVIE += 'qKzjGy3VK495XBDP0R5kWIGP/u97OCKYjSdY5UGw6oMragvg24mUay3EvHiKDKo5'
MOVIE += '3dDgqwVHj8krmXlFgvnYTaG4nvZjnj/w/46A723nvTMgaE26zKyLj+DJDI5d8Yff'
MOVIE += '+9RWXuT6NaYFDThxUnwNsceH2knjOXswKv4XQn4XUm2U7mYR6vaeaBCD5xEfagXD'
MOVIE += 'm7yE2QckvK+usJ3veUacUZ6aoMBQGy9d6vEYWCYXF3roO20cVr4UCNifBS/smOcz'
MOVIE += '7BJo7f+s1vT0e+Ib5CPnYavxUzKJU6yY1/EFpDBQkOLl92eWoe6PKAYniNx+Qe88'
MOVIE += 'ymOpkZh0IGCWiuRfwGlX26SS4BeWmwQN2hQ52TbjerzYaSZFl7AjtnGdrERmabAA'
MOVIE += 'qa3W0RCotNKz6xdRGJb4ee/Ttz+evQ+xZYnQBuBZyIb721B4vIhVrodo4iCJ97nE'
MOVIE += 'eHxAb3gnacq85behC/ZH7skUAiMg8rfJmgCScqiHZixO2t3oQY8iOS3HNUgRELN7'
MOVIE += 'iy3q/V21IxDFTvhNQTllKw5Z0NOnh+sv7fUc/1DxINLQ0AObr/+qDd8KjvewPs4S'
MOVIE += 'E9EQhjdtX9SpdQoWMVioTU8iWU1JT3i59jMOVQtBRnERxFlPQLwM/3Tb/wpFZib7'
MOVIE += 'gNhtLJVkVNvFqUrXn9yx+0QFH/3GrSUNfU0b/pUz8vmh84N/900QDwvsHOtvpz4T'
MOVIE += 'ZccFR8P+Kn6zIG+b8hHejkN7AjQB4RnhA+Wxyg6/1z7Dty9qQ13pAi5JRIR1CCSG'
MOVIE += 'X7XoCEUcGN9sDEb6HPx31wiGmZVDjLxCBI0qVX6eTxYdnLKOxn+jANQjhpZaU+jY'
MOVIE += 'TSGGgLjxDDaNrK0xTVVsGhND+NBR4H5mDrMgirBQ5YDQai5SpiR2klzIRzmeQtCq'
MOVIE += 'a5m3Sjtf1PdkmafOxDhivnxBBW+10epV4Jd+6qYUJrkM5C7rSNM6k3x4hlolZCIF'
MOVIE += 'qZQ1//QbB9E2ynHz4uDJ56+lalES5EKe16i9jJc0d2J+Z9ci+xNZ3A9+fnr3Aj3Z'
MOVIE += 'KGpyPhBexqLdimHiO+TNZjG8OpNIRpAbw3I1VLfPLDCGe1t0g/6mx5lgv5Eg04QL'
MOVIE += 'Cht2DRD1gePmBmX2eyODxLIbVb7jq7PNOv69mC85rxvkIlLeYUf4I64+u15c747P'
MOVIE += '0nEq1PvpTfe0ZAkHfF4dLA57ZO8LoFlnEz4OdfAr4+1FRpcnOCWo42KG1+XbxI8s'
MOVIE += '3Xzgn6Y4npWDJriyMcMWCkQSQZUqczOB6YHUrBfvJKY8YjDabMgCBDvfxL41Fd4h'
MOVIE += 'nooahKNtWL9VLYYoVOsxvhnviq7K1D3D99g0XLzEbCXyquYVJ6mzZWWK59TZwt3I'
MOVIE += '4x81NTSW2jwLo8SyvZa0dpZHZnilz4Dq910JNKHsL9hspZ2cMXb1O3xZ8LwE/qcx'
MOVIE += 'ICLhVwnS9e4VqKojjmUf0Ix8VJqFkzf8dzU2EAzIiNZEN8aov4ivWMA8orZEvcN6'
MOVIE += 'VFenSkJwJtWZZH+pqEK1M7NSRPquZDnbx3qqaswm/BK3LfUQfM4imDPDWnP3yuPV'
MOVIE += 'IvQAwefnwXmOn+3DSXvcG5/+I9DmOU6r563O0gvUZROqoMDne7e1Z/A6M07UQDir'
MOVIE += 'd1i39uzN8LFA5xHEAISfkIRjZ53dZdDr0pYXGaO2btZTR515WKf3JSKr6/nF8/lV'
MOVIE += 'm2EmmoY6f2X1JLRIrO8EZraerqVRTW/erpC68QQRd0XqTud2/2poiKHz3QwJfhUS'
MOVIE += 'xd9adpA37eB2/3+ASIzy8APdW9gYw1eRLIDK+5WcVB6YRNZV5Xl/Sov1noKiY0dU'
MOVIE += 'fes4zyeh2lCXqnR9d3GNR28CAKeORhDeRvn5naJTVCIj+wyP8IuOb1w1o/KPc3SY'
MOVIE += 'm85m7XYvwMj5CLZJWlFDa7N5z8Y+6L2tali+nSOPoEOv7ueWsCiSuMAEjqwutiSc'
MOVIE += 'I/6Jo4g8f9mfqjcG6gQSg7ion/2gl1xE4t+qxdHanVozmv9Rz6o/0RQaQjs3aSyr'
MOVIE += 'LjLumKiOTnA8oEoRgZKKaU8pF3ZoiQwZP3ub8931zZ0AqWbwGx0RDiCMY94hWJyH'
MOVIE += 'qWfVVPwfsiVk26rorDeMvV5QnQqoOyp8sVIwi3gkUo6Bip2EpJBrs7F839HFZxpJ'
MOVIE += 'OfjhJ/ozA0oO8AcAEwjNhC6VmzQ5lTJnhkAtIDTExwNJyqMhQz8/uatpTuDBWQVf'
MOVIE += 'HBp/mSZCYjtA/NzcJYktzZUafP4SoyAdXcGxG8dleKBtuwEkWY2KYSFuIdhcHFo4'
MOVIE += 'W+wHbByThSXskHrXlc/EgKgvN9UYm/OG32H2KF4jWN8TL+CPl/tnZDRqJKKpAUac'
MOVIE += 'AHX6hlRtB9QbeTcO/J3vejrKlVFIAgJmXmMWVWRA8jCHCiINqSbBEUDsonl+l9RT'
MOVIE += 'nUXz+iiXGelI5L4eRdGYlXtVH5CqQqlcfOhEK3MJRT/9ncxEsCyuz+xmWLEztpXQ'
MOVIE += 'rkkm+jL6VbbRuUtM0rL/fOab7xogF2UAUQwve9WVHkS5UEN9ZteZ4XsCZ5gRgxEU'
MOVIE += 'A5vXcWq1MiEoI1+mmUDOcCkGTMdKqpFLiFUJdTuVJeYRVNrycjHcW18vQ7H6zxey'
MOVIE += 'uUoIWuWEosyDq2odkZyEnoyj3g1KtAK3SEI7KmGfZ6gELVhEasCbysxDH7j7zQKb'
MOVIE += 'VfuO9OtriyZVTJzeHKlGUIIyqcWPkSSAvv8tBxqmDzH8MVtJ+W49hmPzcaqNQGKF'
MOVIE += 'm2CSCntR2XeHOX7vO0cd9bWrWN8YJW+r1yOML2TK5UupathlHvJEKL1yZoxiflYw'
MOVIE += 'ylrtmGKesRT2zH9MqGw33qJNXD0+/NiAdazQMAdpmr0PYNc9IXg9ZAINmqgzWQCA'
MOVIE += 'iVR3sk2gAHyU0wqSacG/foZaMItcH0XtjEhrU6d+3z9vMq/bYjU5RdpW+dZ1cKVA'
MOVIE += '5UMUXdl8nNpWdwgbU4b4n5OHYwKaGRUTGlyH6hZOKSjy8QQ1InzOe8jzvV+9Raz4'
MOVIE += 'jA6BkluPbeMRPlSe6N6i+ifMuLQRFgiHCt9TD+wShsnTMsDkvT+7qXkxUPG+5A1j'
MOVIE += 'CmZ2uQPfx6BUzvMGxLA/nmEU/31fFFuy7+zWneVMUE2TBZUH4i+Q4VUbVJhxNmR1'
MOVIE += '8NzunVrrl/NK26fwJk2OnG2iRJDY2yrI44cVPaxrD0WfHUHJX9IDZWP2yTRDUHmd'
MOVIE += 'tw5EjI6knz7U1XMByDj8JEZewcsq/IAE7g57iew05+3Di06fhHQEEGYmlEWYGbpR'
MOVIE += 'Ef2Iik8Y5gpnZu9q2xyULhvV2P75T3HRNgCeCBewhyvZV/Wq5h1f61ACT1O1M/1l'
MOVIE += 'FPS84UCA9l5EJh1lRHCp/4zLYaZA0z4ulSPFjGYckatJbrgdab7XGj9n2/X96XrC'
MOVIE += '575vjwuf0fCeKcp6KP9CGBdut6tT+Q7QSJLRxMNHK4t9PLuNnGLu08t1X+9oGFNQ'
MOVIE += 'IBJG+I96M2Mv0nBHUvVZGP2NugrEYr3Hde5CoHKos48ETAH9rlas1uw9dbm5Zks8'
MOVIE += '3e2Q8lmw2hlv7Gd6SYYCUhm2KU77Wnpc7PyTJ1qOfRTX87VIgy7iQujDA2gsy80O'
MOVIE += 'WYgtWzj9pBG59SgFy18gHpsHoP+pCaaU9t6fGaNECtCgUHYw1iTQxMiv3mboj8k+'
MOVIE += '7Eaoiw7okTx/sTgLflWj0ufh77ZRKEBob0L5BkBb/Rd/PmzPe3ypNdSqm58maOlc'
MOVIE += 'Qoia8EWZjtKRaB/70DiRU1cldf212sjNSSIjo+3b5ww3jPM7UPK2VVCauyC+AzxW'
MOVIE += 'xvDfR47E4ef8WYA7EqpKGavBsGZXcmJrxIjhu3qIeMG/7CZnJobz+ZvV11EXDq/a'
MOVIE += 'CYjTk9vZ/X76E0QUxbz5kyXB+W0MF1XDlHcg1BMHmzHu/53bs/NGIwtm+TOKhIpg'
MOVIE += '5UfupummCGgZ0PvvRyJH8nNJptxSLz2UTUCKy3LU8ZynjaXl87cHZdI/q19/H37n'
MOVIE += '54PP57sX+VRuSwuuuK/C0mb4ldieJYYWkKQ6cKvsNaNS25bxXa98c8v0KjGGwxAs'
MOVIE += 'XJ3McqGiPcoIQOKafOxf3A6Rc7yL5n0HxCihqIjjcu3jJpUFISrcbaDmY+3WSZZ/'
MOVIE += 'VPl/a/DN6qFfsB9pjvA3Lv97xcGglToNMs6m9LgD0tw7c1SrS5HY89yCPur+J3Iv'
MOVIE += 'WIG8FxGfZbVRZhxVEkYMcxqW00UNy49iHSNL8AeVea7AkC7YaDCdyaXWr43UQEPV'
MOVIE += 'YQsce3DU2yEkUhZfcH6YhEaLdPwFKYWO0A9kBKBibdeyrEKffG7ytKSUAm+HVAlL'
MOVIE += 'YwHkdhqihpfzoOy/95am8KSJ2yhP2Srxw8E0WfBvX0Co+Y90RZT9NkpamuYXQ1Gs'
MOVIE += 'y+g5VjQEUnogQa3AhIWKY0ZHGdUcAEwc0aLVyidQNuJnZX+Y9BM42Q7mdf9u2K/J'
MOVIE += 'PCzbsAtesRjtmyPfJGBN0HknwkpdXSXrtQfAm8lSUHGkGhHOsemfieZhvAOJ5Mzy'
MOVIE += 'M1OI7HwUOJxOQCxqMkateGjT04wwbuF+DOYR7uPIVYH0hmX3FpBRIhZjo1sAATSM'
MOVIE += 'Y4TrYia+e5xImf0N0xyvmsatBXv7/S1Ypdqw0p66rxKCxwQR8+kUpy9jx3YPAZb1'
MOVIE += 'AlJJYw0kWQ2cgMAOQxZ4tIDWCIeF5kVNMhIQLaI5wtrMJgKP5gFVPzAuEtrMfbuc'
MOVIE += 'c6FQxAEHM1yoPMvMcrc1AyIBVpUHCrYuagmFQ9VRIpjJoh8xmquuFDIQrhIObe1E'
MOVIE += 'bcKlEt9Sdlna9UIgXDwDDNVM+11m7znEJQukDAbSAVxllYcoKZAMjMMiLsOsbUMJ'
MOVIE += 'Pnm189FI3TsQ5Cb6AceBmf645+pa+uMozyPSCS11apoRznkVnmuVBzlo2S8lh7Zm'
MOVIE += 'ahdcMP1cqOnwxLwyZzBIJGNDfLMmsKdQ4sxVWx96fFsz1P7uKYchR2W049ykGCeD'
MOVIE += '/QqrhBooXD2KdQdrIOrmfONCjQJSUo0gVR3d85YumBy8zDcj9T9UfIkSUFCZrHDj'
MOVIE += 'v1KuDZ+Xv462MMYpf1vi6J56BALMZWaRSQ//PrDW4quL2ZtqknE/gKmF52hJLtKF'
MOVIE += '7OFzKD905FKS7p8LBamHUVhhVYcZpIfgOdzOXk7Uo/WUA1gmYiwN3MEsyeb7aJ3Z'
MOVIE += 'KrdgnDI/cpGvnMTLOEouiVFg3Y0Afuexi0XCbiphOECj/yZQExMdoa2C2Y7BY0uS'
MOVIE += 'jlqx9FAhiVXxrX8ZUn+MsV2XsLFlrC0ViEo0ZyRY1EemYF36j7i8sAj/SsrgIf1A'
MOVIE += 'JdfFT2leHxLQ5V7X9WaEyhoUKisFWwQS9FItJBC7ON+f9wpdFYLRXQ69DRbUCgsV'
MOVIE += 'ehiGBsGH3l7GJHF8ztPnCYryLKBQi2vdD6DODtnchscdUVqsifnOagzxphd+Nug/'
MOVIE += '0tfnoq12Tpniod0BM7RhqfAaO/Q/ODKBUIag76W7rD4gkf2RctznnlxKwiEQw86a'
MOVIE += 'GUGm3pUbCI1edCxoKOND9tt7nyU1Ts2wtbpYUJl8mVynrb/jPc04aqFQd7jaltHO'
MOVIE += 'KPvHj8MT4P7XWOY1BPiJZYEQp387enE9JIxcFElIqFCecmaKkiPk47kA8zbg5l3t'
MOVIE += '9Mv5JwJz7XqawnIEjDyMzHFlVkAGm+573jKTbUr9qxwlbO+x3h4HN4HA0LnA+5+8'
MOVIE += 'ildYHp4DY/oT+WCGIsuzB+PDkaUVD0ZtwOGfhXYyeleL8+KaY4bJ2KyOeJFjvMEt'
MOVIE += 'WfX7KE92eM/Z8CTCcZufc1ULG0Nk/6Np+8jn/fgXLtKm5H/NEDz7NxmzncEknLef'
MOVIE += '+HkORjf13akXfqaM5pLgIDM1K0JCDU5ROE423mCXe6yj6P4wdzC+JKYlWJ3qsfjD'
MOVIE += '5sU7/tC56hCF+dFdI7+ZoR+jvFtTX+aGPVIOeSOMldrZzqh6dCrOfEfxhKoH6ugI'
MOVIE += 'zchtIVoTSb0UQMEYjk+V3nayn7mPQJa5yiK6I9+Zo3kjlV/2qsjVNweEtA4oVzYX'
MOVIE += 'AenbSOmrv2gWnk+3lHpkjp50+OHK6pJlge3/BCpuPHialTXmZoW3Wv4rq2ChqidJ'
MOVIE += 'HW1kAkAzLFeYX2o+4z3NjRLRBUv4fJGgUhE1BecUNIcNlJldlf8knI2fWqeLfFkS'
MOVIE += '81I6jV18Mu231YyjP9sLUp+tn3zva7++pfdh8a/t32khfmKoWP/fvQ/z2Lnf994q'
MOVIE += 'gcNHzvMqS6SAlmW0FhxECAIQQe6ikwQ+AihRxFyPDk+KppHgKy4w+DRK2ZE8OCn2'
MOVIE += '6JqeviY2npB1MI5HL439TF75q20KNOXit5cq7YAI44gIdUmbbOMF4SvUeyGlx8pD'
MOVIE += 'hosPyR54sVzbCuxfnNcm8yBXOefzyUbc5A1j6lGA5fNh8gzjJsGPfbKXgcP/reQO'
MOVIE += 'K2m9NESOmXR5rdOv0SarITTYBp85052uMJW3lxE7i9AAGOxtGNc6BL83MFWhiNZE'
MOVIE += 'uEn55Q5VFFW9a8hPiMPW5C9AgwVxVBVrbCO1+CR+akdwLRcD2MDmZ8dvDa38t/Kt'
MOVIE += 'gqVRvKhHORj8YPO2IexlYeW36UDUXbso/dKQQDqKbjRI/r+7QEZrJYXP34RMsFyN'
MOVIE += '7DQX1X+YBf7V0vacXMgj7ynsQJrKqHnJ7y5XI8rqaI4qbP08IRD+VSCDRTJeIOsI'
MOVIE += 'KcXONttmVsg8H17S0UzKOpLY2nI+xtSlhNgHtOhmbVYAU+pLdSY69d6LKXzoIHz5'
MOVIE += 'cq5HWNgaO0SBZNXAY7ElEUZbiehy9vwVUXkb9SDFVW0i+84cQmKEkXc55nQPptQY'
MOVIE += 'TYSU3IaIW3neO2IQDaeOyeRf0Vb/oE85J2cGEg90YXuSBJa077xUx9Uwo1tddulA'
MOVIE += '++8SLllAhaavBmSSzO/90LRB6cNRTlIhLmc6tdXJ4zTk7+4JYJj3AGItFRdeySrN'
MOVIE += 'zJk7EH9X+WXaPqtbC+TJu9Vnw1LFw8XUW+EupGTlmaiAWHqCD8fzp7QlQFlVDp0n'
MOVIE += 'WMKuPN/rcbk6JvarEPuvIQEfgvXftjs0fToBHQCs1JUIKUzEetgl0n9sqKPcYsx4'
MOVIE += '30EmRojsxD7R6wrCwMvdFOr5//VHeAY5CRnlgHiPooQsQKITUhrfdEXrfyb8qCHT'
MOVIE += 'z8n1SeTtzGxTc7J6gWUoVyGpB4AHxNQhr0Yt0PTy0gEa1wHsYYFroo6nonFiUoTP'
MOVIE += '94iIxEKk6CBRca4W6iw2Q3gTFeLZMWSxSXhbYC23blsvai6IisRWlCdyVEQVfAVD'
MOVIE += 'IZ8d32PD70HSYlFaAK7otoy7n9SuTHkOpKqOXyVbF8jWt31fqkgKYMCjIZu/NUtC'
MOVIE += 'yVgtZqKf/87XuY45DYk9FVd070VU9wmDOecjruPr5m9BYLZmp6vJRZJwVTX5Fscd'
MOVIE += '+M/L6ETcdUxZwhus2Xl4Mbeqisd/NO4sTryA31CKx/YKL5VZ+6h5H3sHxRK3kVNw'
MOVIE += 'rOXhLKyDnSnDVSTFC7DmKTpi15vYvkaV64KvEoX5v/VfnuOmPCiTlNrxOtnePp5g'
MOVIE += 'Ta9AqqrDh5G6UchrcK36D0f/TYAh5sGMinzXrBqLsKBh9P2NCVewMgo2wnU2jAJE'
MOVIE += 'xD3uNry9rkpek9A02lcdSzAjoKeDkxUAkbB5Wgjlsf9drIgvkKJ5hIgHd9/w2/BW'
MOVIE += 'vHEpeKy5v5EyjL5XdsgkPPbFb5yyksG5SxkpkEo+TOo44g0uyuhbisCPuqnHhi4P'
MOVIE += 'R13yR1ksJIFXI9/aZh8/CmlWe713NhN/sCqEjKh8VyT5qCsMZ9yT/LoiO7fvP+NE'
MOVIE += 'EmiAbeyhuNJnRjBL5FBXTKy5Yaz64IicKW6HETPM6PFIFK3CrMHxNYN2forBZXD1'
MOVIE += '0V8GwC0u+fHQ25uhJtTGOz+iu+au3S8d2gPO8ptvmKIlCZLQ5SYaSHSoO3ET75/N'
MOVIE += 'ZZUPFzHmG8WBc1GoGT3RI8g0EfiV1MdH5FBegZ2HrGDRfWVBkhIazny6EC3K5SFm'
MOVIE += '3bsRgK+aZcz99AMapkPeVvVzaxKv1b1Z64xoehd0mvw0kF0edy7CQ1/ecXIOEdWW'
MOVIE += 'PhAq95+XDzbXqL7WhINq9SkeWKTyLY/w3/5WQZCG152qoIdRhtH866CrZeWe5/sN'
MOVIE += 'EX/uKekPfYe5kNFCGcP7nWXPvMfUn2IZOIbZLpQoHablXKJBDhs2+c/exueNrmP/'
MOVIE += '1f1bBavSY8EENLpieBXoGKJJ8eCjNh3VREre0IpA8irqVPpul+VhqP2byGfKuZEh'
MOVIE += 'FKZTOTyWPcG/Kdx0C8VUEtkOtemFswVVfoAvKNFg9dcJNBInnGhjAMFNX/PDr3Zi'
MOVIE += '9ialZjUR9xTe5nmPkFwJibsCDq/uyNmORmrfTbcCdcdPwVM5DcZBBqV7wbTWtq+e'
MOVIE += '/P754w8tyl4t/MOPDNZoPFJGzZ7ezC7+TIZHG1QCCH+ZY+DMpnTQ3AJdsMdClVb8'
MOVIE += 'T5cucXe5poOJx9/pQ8+k8DzX1K/hUudJrwXdtmBjWv7cTiXEWJCoPUsWX+H74H+M'
MOVIE += 'EcEP/uW9hRzgHxkIq/fxZ3Mo82Iovpt3NLt/LWu2LCgv1ftT5iX2+0vsR0KuFYHI'
MOVIE += 'vyaf/wTGTAsPXCzyt4FIiHXRvKRVWCVGDw+nVB6HNmIAkLQX3knMYDjUdS5/Cx+F'
MOVIE += '02npFa/qRjpLbJhGtkh+CHxCziYaXuVRRd80zyP9Xwm69Y7MrPIP+QTycZRr3aF2'
MOVIE += 'IFKOWjknhhRUMpDyIstURCuX731y4+DfLq9Dfo/VjsZCq4k90QeCs6MQ9Ot/sgfZ'
MOVIE += 'xqSRlHNvtoYq8Dky1lkZp3gGzibPAGiHriVlxpz5c3UOIwlKa+dUIzlDG5EeGk/n'
MOVIE += 'I0lEUHF7JaPClMe7SFXsWP9hJb/BhLEzIScW8kx5J13JbEII+NyuIr7uYaOqwZt/'
MOVIE += 'M1u5a7Z3f7yFXi2nLOEcwYwZehzbk7WAB6WC5Rg8VZPaeS8iBSqjeaqPoQvqdLFU'
MOVIE += 'kloklTk2Oq6jy+N6QZDEaj6tkLXl8AO1hpizQMQVOZ6Qt6R2fmjRStlLt8xGAdsn'
MOVIE += 'Ctd3Dg3/xH5mewWz0jgNZQgeUAZFZuBEKcjbdhJ8FP6Fd8E6Us3v4dQwiKuf2Xae'
MOVIE += 'hL8l1S9kIK/EQyld9sWucTZlpypZ66fVWsuPYxUnX5zF0F/BFPNPuKmeFz45KauH'
MOVIE += 'CU0rxLRsGyh4rNPnUTmn/ebYSzgtSqYKstsRGJmGU1Pt93wUmiWag/1WSe//ov/4'
MOVIE += 'YMA6VMamAJ9vzbiYNyrKPyWGqIHMqDoyjU7yG/Dgc8WBmSszYccHv3kYhq8c8sAl'
MOVIE += 'gn6tSe2z2ZoRYIaf1jmPoNgiaeWxEgiCJ40G1JRx7HzZ0vmu+mvu8B84fOcr8z+/'
MOVIE += 'HPCC9QHVw6snW9qefpoXCbC3mXcR3OUwLar3pZ8OEFq3179tJ59fLXDPqCK7Jl/g'
MOVIE += 'OZx8/2YqQ/a28YCl9F8DytH75bKW4+B6kj1PudguMCmbAodB/yDFVgDLPVQB4IVb'
MOVIE += 'ofB7vuZlWrx83pfUR7sRlt9dVocKS3X8h2RIabJUOKy79923qka1/nEqss6CQbM3'
MOVIE += 'Wk02UP5v9RxUUUhqg9acmgaZT/E/ql7ci6toTQRG9EbpzW2pjPJNelWYthJKAbk0'
MOVIE += 'mPn5XfLVxb3y4HcV6XSglAhUDGSyHp8oYtqI7syaXnJCiewZnHVhxFJT3bg65zqB'
MOVIE += 'IqHX8dpGujGCV00r6mae0eU6+9ngMFk8apyvK344W57T4fauQbs1hkeVzWnvoQ9b'
MOVIE += 'bDupOMKAb4/yBKUBENkX2ea8cC7D5XWhe5J7sOR5bQLOlxeh6uKKJxKtMpk+tz/V'
MOVIE += 'cUoQW/1eur3b+c5sRqdYuTP2jKlXfMqwbypaYEKICzWhtqYyxdg1lOHaowwT0uCg'
MOVIE += '1MwxXFvb3ePAngiXU+NdNsLyNgqrNKhyTrj8yoZmJcB/E28r/t54r3RLWd5OdYRw'
MOVIE += '11IS28ySaFlQEUHIpnqqDkt4B2cKv8Af/rhVTyQfFUugJEKm3eVfiG60Ca0EzJJ5'
MOVIE += 'kvJwwmJZEgJSnG2caVs8OHQjVckaPj4qkWkh/LcTnB+S9A3adkJpiA6KMZmjdFkH'
MOVIE += 'Ae6M3yIM60hNy6ESHt8sTF6tIqKsLM3iWHGcQkmKBv5MQC0WtBpzRhyVLK8nF2BO'
MOVIE += 'o57HJR70DxPL8wxoosXoTIEmgnIMNSyxUuh69+5w2JdM6PsJYIC0JzOGciPAWsVQ'
MOVIE += 'caKSe/OuDAPYT8rOwtlRtxc3y1ia4CjqszxGkFGKLXoZXltjzoW3UNQq+jWfuhRG'
MOVIE += '6adOnmGDLXZX4w++reArnzdUpcFwQ3sn4+wYnSnjkWSEu7FZtUp6NE9LX9jvZvN3'
MOVIE += 'wi9LIIFEchpa2pu8ap5LFBwumTd037ycO4+ZIO4KRGZRUT15hHotoknYzZu0zEav'
MOVIE += 'EpIZnhP5I8eTiMnjDdJ7xyEHq8R0FkAGKzGhRHyEshZnDmBct8qELGJ9pD+nRCik'
MOVIE += '26XfZn9PqNrfnbUUmoMn3aNibXppRFlgSfu298Vx7mUKO3DluTL1m9BssDldhFTM'
MOVIE += 't9THhMePZt1UexU55shUO5yxxSoEbgJhdmrWSFCHJg+CeI0llIqC5yiA+YdF/sjD'
MOVIE += 'EVXWDEdC/V4V0Ct+EmLUKyepqkNfmYKRxxrfYXIfCscz5zvLPnz4jJpbhEf2nFyq'
MOVIE += 'PhmyrjVSU/pn7eM4ytC+F93MaSma/diR2EHTr9qDn7fi3zwG+JPfw9OXwJS4ZxdV'
MOVIE += 'B6VskB7/p4vFmMokznmLHQvBdiVl3kWEEQ9+F2dm/XSncGo5/iz065Npj/nrtJ95'
MOVIE += 'dDGCjAzDPmxiWAL5m5zqhtkSQ/+viEEPq4GpJV2Qf7nVoxBjIAWcjDH0u4xiY5ae'
MOVIE += 'zlMvMaVh6neYGPblBQEb9+Sxvj8jgybZK2oClYjQ1RAOZkIfevwPnU/ffHhiJKnk'
MOVIE += 'UkUeHTkCZnZIZlCXkkujyCRPb/zI6AYH16Z/+qltuksG4/ElXdvDZD+rXEw76Xkq'
MOVIE += '3KAh3+biVXxqiniNGn+4PLQ+X479b7C4U5KPIXgRR3WsFc/LXjAXPK0YBRc/b25z'
MOVIE += 'pdOZt1rJ+7j4qJpDwiU5Hbi5IOTYDQWmWGhGwxldAzOuK/i4oVmGmo4yoKK94Rez'
MOVIE += 'd+wK0E/vcVul1EJ6nxAj5VDxnZ0g2fRXYUxi/by529fVD6KOwxV7I+r0fzT9uU4h'
MOVIE += '++/m2eDm0EsxjqprXDyPJhmRG66SbEw6Jou7ZeYndSqg0cmsG1elSIgwiZyfXZxt'
MOVIE += '+ECsaXhKc8Y7YEzzkkQ4AR2WH3v5rfD9bbW3clMa/rUE23P3SYPt91L/zg54C34v'
MOVIE += 'NBot0L6TVmlG3uxnPKN4lwA9bfoYUa6E+wJYF6+A7R7nDG+ZmkZAGzaWfglSR/FE'
MOVIE += 'vaeNE+alEpYwbr3uqlhVr/pNPw8U4b9hm7/M0l9rfg/6qntSr5+3M71OmNpFqu0q'
MOVIE += '+fK7osct855kfzlrGyZNaNfkbv3l3xSOwxvWfwI4q2oCnkCdQOM9+21uvuu5O5wq'
MOVIE += 'TeUujTGQ0g1IajqW1LVLb3gsTjFPoKQCqvIH5e7+V/sVdC8qjJ89kZ5fP8FzvSZO'
MOVIE += 'IdaD/D79PipMCq8jU3askmz8q8u2bAeKk+Q+aIXWOD2SD0QtR0IUOg7xsZoKXtj7'
MOVIE += 'hjZYdqWYRUpuihAhDEtOc0Hwnzphpxche+Ybvra1iC871Ur0Fk3fusjetfq9YSSE'
MOVIE += 'DL7vzmk5lX9vPPeIZAVFzTkLjebipNDltcBZzQPKYBiWE8dX6oJfMbC2yIxfmhpZ'
MOVIE += 'eIZmhO3i5wTiP0kIQ9yP6DPpcv1BDHw7bf7f4H6UMpfv7wC+FATaVK9qmji8jEsE'
MOVIE += 'pTLYWVYzNM3bqeWEOCO8MZhkQ6+v3HuN8j2C1UhehakY2r+P4ORjyarOWAS5UYpR'
MOVIE += 'bs5XIP63sW/HBC/I6Sm/kYf7dgoE0G/cR5xRDvKF12LfsGHz5C9STDmImThvR1+y'
MOVIE += 'qrIFTBhNml9CTYbJTg60UhqtiqotVz9n2Ckxh51qzzj9ughAgNUy8sgb+PjDCwL8'
MOVIE += '4kjpyL6R0yWBkituUBesTUZs7I4UydhdUWP2Br7UM8wOoxe9cW1qxCQVA4hEJ51j'
MOVIE += 'sp3E8asozndVkQM/T5sBgCnabktvHNVWriP7LrIqABCHZCG/B764XcAWtcNZLgXu'
MOVIE += 'qL8R1iysec3Q+zaz5e6SVy8S1RE+HlCrYEv7rkjhb4qiKcDSWaEERgJr4GixZyCS'
MOVIE += '+0LByTxNhQBtqRPZWGL/UZbqty/O4YvCzp0SLJcqZWS1ICF6Yf9xlBG9ODzlnye9'
MOVIE += 'X/O67MU687k1nGQiyoc45kxyb4fCAi4glc0osSOGX95CWIMYTcU0EnyMizM9YqU6'
MOVIE += 'rOBq4JqxWMrRHEHIsIc/e8dS2ibsGuRrfnaZ9e2mLZ0X/+RFrzCVL4EahVd+VhCE'
MOVIE += 'FsThxEpDwS2rlUWif84NcyD17OQxF6p5wx2o7FpovKeNJ6xoahKc5l8GGBP+kC1m'
MOVIE += 'SKw4qUNBScHPkvUtUqzxrnc+vJ5CtJv0diLD+IKVhotVTMtA7B5NewL1tVhUSozK'
MOVIE += 'wKs/d3Jivk9VLXzi8/tGuzsir0HlktQaJr+sZXKsoddUgSc2eGJC2fmeXvhReM+l'
MOVIE += '9T1/l+s7gzMXaUk2WoRSQG2X0G3+Unl/CsNmru9KkXUsbgbU+usFfz4MqOsS3zRR'
MOVIE += 'VcD7fbvsCzDp5sggz6DQMVpGPTdZP+HiU2lSe058O3HFkE9pQg7Se2RK9W0o0EJI'
MOVIE += '3JdS9R9OBb8ccA00DWfLTFKKD/X+KCAuIUHl+JMKcJNjeFArhhHC2nQCKh14Hv0Q'
MOVIE += 'JlnhYc9UpDXWkTpd+6kLtlxeJ24xWoaRbWP2rpORd/A9Cq9gClUsnaSD0oZX8ugX'
MOVIE += '0cMuTlUgueRulU13nzEbM0jdnCzO3HfFgBZFON85urzo2wa1KL2cTaO4/xMxJ3B6'
MOVIE += '3CxMVGgsPVlPFEKsq5FJNTYmc8n6D4Ah7dHs1fWRUcaS7AFEDR0/bGU5x0LsfsLr'
MOVIE += 'Nj9N/xRSbGV7iMTCzHEGO92+z36020haV1/Jf89V/S3Bmtl6jFDagUi+z/mh+HJB'
MOVIE += 'h1viu7+no/W+bl8Ip5qE6oBDvaFEvBWwNk1pf5UUL37cdvtz8d67r26705HpNC6s'
MOVIE += 'rtyAMOURjRZXwyffhMJCkmf4fT3Nw7SpjChXQO3G3559cX8o7hEbyp5sbuyH9rzz'
MOVIE += 'uNBIrfxZEgO62fnUr0FRVkHd0CNX5Vyz1UZ7uzN8juWLhPGf19EYS/6rrzcvDOBZ'
MOVIE += 'QBIGol0C3Vc1XUgtVn3JeUDpQseNF9q0FPxEQpYNRmrsuUS2VHvIGkkufaQipfir'
MOVIE += '+n8WQsBr7JPQXUQCK8mHjACNOS5DLO0tkqbVMbYtL/CxyAM3LM0+kFkc7bN0yB3x'
MOVIE += 'TsJTMtIMCTqZtDSUCrnUawrUA+mJh/6Xb8Tww+i7+aNSM9GQMN1LALhjRKCbRzD2'
MOVIE += 'F6Eh8CZCKWC9jeRjm/OSHtefHURJFgKtT08VP33RytwnGfQQQGA55+GF9HNaEjL7'
MOVIE += 'JdDH/jS1VfuFwYDP96d3TIRq7MZsUhffFOGnZw+NbNyIxaWBbObJCCV7Yz5SGyAi'
MOVIE += 'MIeDDMG00OIVAveq4A0sjmMON3zC7RCU6+azkG+osUaeCFLtdLXT6CX3zauQ/aRK'
MOVIE += 'l6vzV8DjR/n4T5NHCeaSvd2WsB27Hs3z4dxwqJLsxgVjfPjjMB4qUmBR2i754gXH'
MOVIE += 'ejmLNu6LJsS+uD0DnCD2M1NMGaFKuuHbapH8m4T145oFU2CsZfgfNH93+WJKAG30'
MOVIE += 'bagSu8PYFjmAB2fif4X+vI75cp1mAnJOZSNPcyy+wbLsvDfVEpA7J8j6u1ztTyK5'
MOVIE += 'IpZVivJvUEPhL2Vlmj2z7i2XfNzkwXtKoa1UWj1718ypKecMRlEWG9HlfrZI+Ph+'
MOVIE += 'c26OB8FKxlFt3QQzoljILO0yjOAGqe7AkJZu0Y8vOeCENW2Ef3PdiUwsrddjE92z'
MOVIE += 'fV+JKGyQWqCj/6w9926H+IgXdxdeoUxyT9fTXqbSJ+2RDWDAZ2QD1/uAyp387l24'
MOVIE += 'Rk5SrFCy/VLY6vekfRlgfB9P5rf/YEGhX/JefOHKY/aCx3U+E/aopzdNhsn+NI1l'
MOVIE += 'ETLRC6ASg+4StmJYIEANFisBezgNz1ANbIjIoTxD1EqQrrlelh1ECJBcWiJQKZqr'
MOVIE += 'PDAwspKsaUvKTPNLteT1/IUC80mD+TxeQcn2MeXYqCHTM7KTjK3WHVEo9uUdtyNF'
MOVIE += 'ShEoAw66ZrWmo0+QCSI55qMcwEBRVqsJle0Y6qoviXREdG5jVpF9CHraEPpLyvL9'
MOVIE += 'V7Ws1OWTCRI5hx5n/WWyVbDWew+OHZN3NL7IHUJps2KWfpNP5Xj+MvlKYOC65EPy'
MOVIE += 'gw4RawZCABBkBvyPqzf2j3nuqjjPpcWT0MHz0C7OI3Bft9jh+1T7b6LIcpghADRf'
MOVIE += 'S7PLC3T70EYXUaVaQdZaDtHXj9YataOlI0kpFuu16lOrij5leLsSVvNo9emT0FAR'
MOVIE += 'mWwiwpznw6A4p7HtpCD8o9AdXoALQ3F0UcVSMYvdk/qzFQC1JYOiRS9huQumEHjM'
MOVIE += 'UKMwhPxePPpHj/DOffapiUWsfdFYNt0jdwLqfXQ0EGn68GzKgtTXjREggCT8GZY6'
MOVIE += 'plLBWnL1DdhWMWbXlPDm6/EbcpnV4Ye+S78JwvpG60xrGB7xNMIdqvzGBQz7/6TU'
MOVIE += '/Ud6Y55CfrIyWqaVqykD3HOguO4nvy2iTeofdbs96hhr+kgzosVBbh869es25sXX'
MOVIE += '/1qxNYXnyWKsL0y6Qt/x/KPfKVR16eCaxoWx6k8yAnbmKEHdEPOhl9wVMG0MaOe9'
MOVIE += 'c558h/GnMnTJlManqkT9qd82K//R+GX6+dkWhf7egFuU16v/gHHJgSJ/KGiN1kuz'
MOVIE += 'az5nA/o5LPECBhomgj+oG1YiFUq3CBx7CO6owu/UI1fqnpZ5dCJA0J15+n7rXryU'
MOVIE += '8cwqh45OldDaTaJ/DqTb62Vet2bDH54ouK0F5Y5lWTPsFW6efty21qp5RLNqXcIG'
MOVIE += 'PXGs+y3+7+GiFP7rzMoMqo9JLClDI8kItU/LX4/rTyLDkpz6vn7c0yooA3Pe2IXN'
MOVIE += '0+V2SzZ9sExbDHP8eM9caivmgTPy7LTuT1sOoA/n9Jjw4CgLBSCd1t+9buDIgcJn'
MOVIE += 'na3LOAlxh7VPYqxPn7GBEEoP1xYN2NDQiTVLePl4KtviXUxcgWQHAK1aWNp08Pq/'
MOVIE += 'iO3Tt2XB7Jlvg4KmX6aTIk2HOvpHCXdKW6QJZ8LMKu0MuX5ybybBd+ygXE3Au/Ka'
MOVIE += '3DJbhv0/4ll2vY/L/oOxnOU+Cdl4dbzzipX/8rmW6nkYlny+DMcyyLNPynPYdjA4'
MOVIE += 'oeL8TPBp6Z5S9Gkd56iaStL75G2y51PPr8R/So+938SbHGglqTkAOvxMjfr2AfE9'
MOVIE += 'capKo6rqKX6u/7awwQNghc2P0ycFv9Ypx9+ACml6fhvVvY7O8RyQC32L8yQ5/x08'
MOVIE += 'l9y+Sz72Kv2tbwrL7Vj/VDvl8aH6OxkAiSoASF+eqsQRjh3uTYw6J8LEoVX2DJjE'
MOVIE += 'CelIRu0Znj2/VXC7end3DW24dIk/2P6PEv3rV9CKgeEzWsibINr3F++e3757scJK'
MOVIE += 'XnsCd7K+g40z7byuOnB/z3PnQc6zefIxu93w+5Pq+4WWpAi1+saNGu8tUuWe/eVW'
MOVIE += '/7cWHcXz5oU4+qlvxj+7/43y4Izh0YlI3dIt5KBvxPz58+2/LGtzeXOLxtdLD/+3'
MOVIE += 'Gcs1FacHhPPonVS3zM6xcgWlPXZ+/PWfsFv7MPWbbeIH1rd37cZPb9+99f2pGNb8'
MOVIE += 'D7NJ02TbGW0AtrZpCMvY/k4N81XCCyFZuLsf6lXBRthnX45/37uB9hrMHan6EFP0'
MOVIE += 'tXVP2GYKuWKB2O19MCyfvutd/3ggsf0hrOO/siLXtQf0RbcvxK6eu8jbvM+V+3E/'
MOVIE += 'SBA3foGQuHqZnOJ1tc6nQa2ROxn2H0Gff4W8+1+0dxq9PxL3DDuKtBWUDrqjNzQ+'
MOVIE += '+XBvSzy/235mH0bMIv7mLbnS8v+WU/k0+L7nVCJOO33qQuvTn98i1v9b4K34/cS/'
MOVIE += 'e55ceNu+/VYuo5T77wsxjn9Lpxsq//v0f/G9jX2x8VnuwE1v58W/9lt7uh/yBSTP'
MOVIE += 'bwX/ide+HVXPZ0reMyQuEVPOJt/5J9v36Zf9KpEA+k5t5BVdodz/G+HtXibfVTer'
MOVIE += 'OC0RjzL1xss3o/Adn7/P/yj8GrjqAP4vNvsfP15cdUJ3re/EE55XK6lfYJ/cBrn7'
MOVIE += 'kW78L2yNqruxu8G7tzyqt8uFpQO3L0ZNBsNoLnzuPyou4dm2ZbCZISI5+veE/Kgq'
MOVIE += '9s78aTdQSbzvMhD5PP5YWmWvG3t9v9wTd57aFzPsO6v4ZdsaRary/xkwtSmYsFyT'
MOVIE += 'H3H/71ONixBuUCCO6MRw0cRe/NmLP1rPVZU+Ak1sk/9/wN2N/wvcTfl/wF1y4vsX'
MOVIE += 'Qyx6WaRYq+vG3abHf5EATVQGG4A0ONRza8Lo0wsYBN/4om6KVSWbR6Whi7vJUsxS'
MOVIE += 'sOJ3kVZnrZ59Rhxddo4mxXtVWPqXk0LibJ18qWw+26mr2maPpfqPJ6Ne5ktN2u6e'
MOVIE += 'IYdES7w+DiNJTDo9zRudHkuNtsmzpVT0/p8WM0QejpMyh1/ybXyonswTtAe9EFEp'
MOVIE += 'aGOQCqH4DoR4vGd+oZiudaLZ13EwXSCThLi3JiiyfcdTqnr8EoJdqidAXpfIECol'
MOVIE += 'cxpOMX8xzB18ItLn1KLFv44ymIoi+hU8Y9FhOtfF9nE2MkyssNOH87WbLqLlcN1b'
MOVIE += 'dnis5/WvrztLeXde8SpCNv2iZ4cr02vCDkOxJOzmM+siLlpZYqf/vX2A/xmgJr+U'
MOVIE += 'zNIlYZrF8tcwA6NWKoGKf1ZsZAoA/IVbOKjwNZgW813tjK8ErUtQpoiM5SBsAsaJ'
MOVIE += 'TbQE3/DgO4WiNqmWBJpvaycFBcYnSszTYj5/SkeXhSTJfSmQemgb1vIqn+LpX+p1'
MOVIE += '2uixMAunEIHVdedfeuP/5dn47Y89/+sSXqHlc8FupAlQRU+4poQr37sbU6EcY2m9'
MOVIE += 'pMkYsi1ghApXW3nFQYKrbKYBr7acdMSHl5WTk6ePa51DUUrGiagRxiDitHTRH1kC'
MOVIE += '3cFThGElEN6T+m1ep8bMo4Y6lyf6inQv6EwW78Jc86xCPZueBd8+jCrr8kyoYPHJ'
MOVIE += 'wSEBNF2JG4yUlXjABzS14u854hGdRKjvDjBthVeDR0dmBhtsuijBWVC2wDwiJKen'
MOVIE += 'cFhaB5XnE6grOmyR26pXgB7WRjVUOxGJFgdHJbNV4wmgrIInc+0itA67XbK/Kv32'
MOVIE += 'ajZbjT94+so80gcciIdW6nSuFCd7MAnyR5P4gOLj0NTUhsryxIIQItSoJtck87su'
MOVIE += 'NphvFCN1ZaDNrMV5z3fFTWKOHkYxYg5RqG12YJc4SWJlQco3M4sKUp8f9V94WMGk'
MOVIE += '8lTED4fDWbGQJhIVugPH72pb61zFaLycMf+wK6NxhvdcDNqXBeM75Iwid04CGhqj'
MOVIE += 'j62ABDm49AdEv3cJPbK0nBs4lqdCP+genfuYLWq/t9apRLv7USYUhEv8WKlObtSU'
MOVIE += 'O7502CZt/swZ+oT4wWPJTVPRntAP8mMtr9UfLab2fsS9pSCD1pNgMLTMAfMYwufg'
MOVIE += 'z5uepeSqSg98AJ1aInkUlNPUOEYVYmzWf+yPavWyT3//PhKOnQytecVSLaewY1hm'
MOVIE += '08x9K5v9tI/7dST8w5zk+aMPtluq8A4UlCz8L8IcSOqEzajHiL63hrvrZ0c/yKl3'
MOVIE += 'a8OM8XnhKW4Ee0SiGtcq0AWKTL41MdpYvD9b75S/luxRfVlXIptxpv2TSvK8PZqs'
MOVIE += '2SMf8eEL1leRoBxwJ3j4IuOiyrnTESZwrUR+FLDzGJKI/o5RiZ8tUY8CawLAXhfl'
MOVIE += 'ZvXVtIwDH5Tbcnkdz/ZoNFUcQ1ELbPkZhqk5Jo5EnyfyTAr2iOTKHU+HQ0dujw3i'
MOVIE += 'PXSKybAFr1mHv+iUGlnyoDjUReKGyWrpGK8YNel2ztjwSWEE7qQoOMJQmGoQY4M/'
MOVIE += 'llA8ZXvA2Y0Y54rLZJSOOzJorSboQwH5ZDezBJImoKK6Ig9uVh7h/xrZtd+mrGEa'
MOVIE += 'n9LGIKvh8c6a/wQqgZQuI2w6ixMcz3T9aVgnQGEL8mm3u7B5XfMOmhwM/4Qjbf5F'
MOVIE += 'rpbVzyTS2Caj0qrJIDvjBquCr6ntM9zmThR33QsfO2Ir9lR58yqIbXn2BP0zWUie'
MOVIE += 'FXJw3O7gt3mv0CURiLj8m+ee8TnM23QZW0JkFK2U6HkaU1IgXNgZCh0hxDtUFIFu'
MOVIE += 'mdBgr0JduqiWJ6Ni/N+b1d60gg2e3nTxahKULv8jMNRfX0C8Q6vztimVfZtJr3B8'
MOVIE += '4qGaqLXQZUkVRrdylGdjkkmBA1EhSRo65yAKEPmEBzEXymB7Ff0ktIMl9c0J28Zx'
MOVIE += 'RkSCQVkRiIkjyijX/N/Vy8eliYQBuwaVdl+oXrRBEiUzk18yij8LwPKRMRIaORp3'
MOVIE += 'o+BN0V+yEheyy0ybrItGIKyY3rYkM2pOSw7CDgIAYouPkA0+wbGQAyC8u/iUza3U'
MOVIE += 'onIT/P7QYbgMQ3Lut/pQZ8TOt5xLe9xYZYx04tmXfKMWn38cVmZ8nqvPFS/P3JVe'
MOVIE += 'v3BuDmH7Gx7rqUK/ys+BtCSxMMkXkIlnbKOKoCue6Lg1aiERrDaYl6mZ+/bEZPcm'
MOVIE += '7GmshB9Ovz3FiacKUQuYJtrAGtJfoTtyOD+4Hpi8nt2b67Q8aHUVJ+91yTQv/ZRL'
MOVIE += 'IvEXwwVQdQzTSPCdcGOgoLIZIkP9jLYxc1wTB+nJWNOxJHgAKct+r73V3JjjBXA5'
MOVIE += 'YAsrVVeQRLdne92f9X/G5eXamn12rrHyLNApWofqEOHSb+h5qgU/aWgSItV0TvxI'
MOVIE += 'Na79EqEamFebNHcB9MN5DLlgEvgURFbYaaxS//qTooZv33+8aphk4jwDZBU9ppZe'
MOVIE += 'uXhg/jUkqJ+kmMctfRLBb1/4wDJNWZLSX5WjNYjV5x7mnOHulpxLT8JvK6J1sHxI'
MOVIE += '0dvP8u8o+3q9vnO/5JQTWaTGFxjzXvHOrF74Ko03T8RD+UUUVWJtkVzE8TS3sEC8'
MOVIE += 'W7F4Lv/TY2sR5VmChIa6v/BkxQIuDrZ5FOumN9DspQwHHMX4YIc1ndHRz1qudUzQ'
MOVIE += '4pLV/sPrFx9ZoYnBSh4XJWkb+jTWLHX8rp7TU4src7p5Etg4riTIXNmbUREH1AcZ'
MOVIE += 'j197tGtMjTIO52u37lEkFkDyBNx5wI8C/rd31OMiRx/ZnhD9+piG4MtcUCZ0salC'
MOVIE += '/BUys3brldX47316ZllgLHnZxV/0pTglykFCbQjmpIvxhwT4LigYj/3KutpifoFZ'
MOVIE += 'VSmPYmyzZvZH4IlaDI1L/pS16S8MevnUyrtmV65ceVhdwr/su3G3CqGoQDpxxIWD'
MOVIE += 'orZUfFYtyv256A+hBkw153Upu7MRcRJ4p/pYMFLjEACmtgAA+cf7DzPnohhi0Psc'
MOVIE += '+fiCyg9/UvUPxJiTi1rnZab0P38naL0k9x/DTVAcuYl20V8CwzzexzOMiqc+113d'
MOVIE += 't4Yx0Jiz0cE6YvZDzAnMwed7ES1mR7oqhEQTw3CvoK5cnfv8r4zZcNQ1+U7o+svN'
MOVIE += '+a11Ben5n+wKnydM56hfltr/niGGsCKv6PZOIPflO9o6kD+OEkGLASUYb6nBZAwf'
MOVIE += 'k2MeX9Y8BsNFS7BqVJkAfmQg5y/9vsOnv7tCCylkVw19nBwJqw2fbe/SDIo/iRT3'
MOVIE += 'Pw94UrCCyLh88O0VSwzGl52VixhIDkfqu/+I+v7rnv3nxugAJOh1owYqUKrGkPUi'
MOVIE += 'KcuB/IaBes6PSvb8PosRMvEwM/NErRta7GcacvU+M5FwbBvGT7984FMVfUMe3SUR'
MOVIE += 'LV6AdM8CTGjEUY/A7hF8KMPHjDuRPJ8wahPm3pJA9nd+X8dD31eYDBkqizyMfegR'
MOVIE += '62FkgX/gII16onj37hlv74O4ANtiKExBKdxvndztKGCD62HFDplUAv1YVqLKFew5'
MOVIE += 'LlrhCJpHCyTPeDz/EMD6zk8+TibMPLln9akcu0GHIc/TWMX3rEEJHrJfcGHyGilp'
MOVIE += 'XGbXYrqZ4w9Mh/EjLx74jTyR1YT9CFODKHFXAERZs6Orw109/DFsF5Hz8Vz0OJLK'
MOVIE += 'z+JHForScVismdBbcpLnBTLvySWGNPk4Cp6NS1tOeNwXw3Rnr1OmxKk+IhhTLp68'
MOVIE += 'VAK8HsZrXokDF/p/inNDHyVxSsLhGTEJGNhyRuZ4W+YQzkQ526TBn7gYlVAfHzhm'
MOVIE += 'lv6gw+faI8rpe9gUT6K8Kef7axU0R2pheDj/3ThZhBjcNZSEpDAypw7UgqDoHHNC'
MOVIE += '7UBj2mD0AeKC79IsL1nVgkjewUlQuzkb7YxdMVlKgYapmilP17IoVtNFjlOKdxAS'
MOVIE += 'ntku4SRYsEKzBLz6MPtBYWQKys8OCVKRyexcATDuQJ+3EWg6a2co80rGw5KdcuM2'
MOVIE += '1KM4Y60IOEZ6sxao81CWRmIEqR6TtiY5dPbKxvWXzwNkMpR404ofgh2QZDUaMvGP'
MOVIE += 'KXPYiJ8fOetk8/K7JNxdKcdCi50qYOdt4GPyBy3s/rY8COyvZwpdlgsWwTS4jBss'
MOVIE += 'HrF/RvQIfelGhjwMPA95StkWU9FZpBCiffBd5hubULh5kfc+zF6pOPnOsvhiCRyK'
MOVIE += 'Bb8+Nhz0lFyhLukRKyGgDcE38mKQxPeOpVfYKAEfS9FjvfJfuRH1xlT+8ltLpN7a'
MOVIE += 'KDowFlYtB1K1gfzbsDGcZeNuYWIcKse/wzInyrLNHb/SqaJFMPeN90hCAMlFnus6'
MOVIE += 'ej4bfNNXuRXj9tXMqUS81B9A4IFfUFRJVcFOpooCrvIAj7+FDlkQsoYneJEb+onQ'
MOVIE += '/hiJzVMz+6KVmEujasVWaSxbs4HklpnXy3V0KM4U+D5ZKXCDj7p4UVQHVEWSebxj'
MOVIE += 'bMYZfKgs11uuJb7ItK0oYLtWrrmHcpY7qGm71CGh0oYq6b1llCvVubAXKz0YMBw4'
MOVIE += 'U+j4l9ea606tJu2mHnhU47NoJ6xtHQkj87zRZzH2FsokzELf414bw/AI+HFV6jyi'
MOVIE += '9OXi3IVBcT0EU/51/mtMGl4VYZdgQy7H1uEURm1+Anf6mBEtqGMJXZwXF1/DeD9R'
MOVIE += 'I6I0nADIj4ywcsROsxINZxAntmkzETBdlAOLrgIIdsB1fVT8+xH9SKqpDJf2TaaR'
MOVIE += '3rATKclcaldMjiWTtsjKIRm5CHk2R0hSv39G/8vbJMd3EXSeZqnhiQB6JNm8YUFO'
MOVIE += 'kMyQIXG3KLGPamPdTQC9g/N3UNmBVBj++KPPUzQa/bFnNz7P91H/epsuH/oS7ZLd'
MOVIE += 'xnOxZZD/3uy42yzxT2zm44qh4CGbvmtnHPInTnQg9lkiKACQydMDyP/Qq+6UKn8i'
MOVIE += '2t18VO0fNJZBxGCt4bfbPnHUysaQ7TXSxPUB/g/pFqUCJ8Z1CP3pGKfvpBfBNypv'
MOVIE += '/pnvd+HP9IyzZbKNYHKewB8NoRSFk8uxUiYrKhiH1aGYYD+71CIIP7F2fyH0zCyU'
MOVIE += 'fGjdkb8qmiEuMJ5d78TQJ3KajXN004ADcbJK+Iad3PsUww7Erwxh95mWwunst9xd'
MOVIE += 'BGhIRjn2hE1DRsoQnyYKk0yTdKF84KkC/wH+8vkZrrD3W3/vqelLlndSLgw9WXI9'
MOVIE += 'HrgAD7anvqvNHwhIijtB5ETgGBxooxroftNSpGwho0E4JlKNvhuuO5yUBf2S5V3n'
MOVIE += 'Y5PrSAGmInK7T8WNF1Tgo9YD76zfMmLxIF0t1Ea1Mj2gNAagnT9xsAMARwi8MHSX'
MOVIE += '7McGWrnUGJJox9YpKkdJmL7RBHge8QevxXbfe649w6l2/kBfeb9lOyMIQrZd6gAo'
MOVIE += 'AWQ++287XYHegcQ/wowBGa+g/VTCbERd87zmWKFZtA7FpmIN0qMSpPJ0SjY0QMXP'
MOVIE += 'Ac8a4It9p2Jw8/rhoSYTMbC5ppJVfvjnKXSqSY8yCxCkYw2E+1nm8XsYdz3rZs8x'
MOVIE += 'ISrNINZwpirN7vpUSNM5JfugDeq+g/dkB0+HsUOPkT81M1IrR5pZXuk6aSz3Ej+g'
MOVIE += 'ACxzB4d6lNvZJeGR5ABKxFlhSHJ85FMwTp7BCHznCBDIwl3meP/yJ5ryJ841hFFN'
MOVIE += 'Ux90vAqwqVZzotX2xwtB0T0pH9UNHMKrs3yCI3/YbOZ0QEbu8cpc94XFGbTDzInN'
MOVIE += 'H5Jq0zcorzqo28rgyNvaSG4H4BZQhzudZafMA0TlAdteyTeuiuLkxJNIgvF5As8c'
MOVIE += '+/l5CsvHEuqcvQ+vR3bJy4wvwB1neNntBF8ippdzpy06/AmkTDoXyAq5QWk+E6/9'
MOVIE += 'gz/jJVPn+GdPw+oQC2O7lL7g2cnoEMZ5ee/EYLwnBb5SlOzKjBPlRSxZDMmL7N8G'
MOVIE += 'aEh8GPWnlQHZFpjyd35tRFl393MzTEubMlRiFu70g7AiA/0hqR42SMQiksZ5ALU4'
MOVIE += 'mXl+j871h+SFzbBeAgQywPck3WCHhTLDZU4aYI06zNB33ON24U2GtrLjPf6b5z2Q'
MOVIE += 'oF43HbyE43RyqL2HabcRTwNG+/3xyMzwp3D41v5Lt2ex+luS8h+XHjzlwlkBRuSH'
MOVIE += 'vT2XWcmBRhnLNCr4IceRa80l6gkA8rZ8mQQBznH6XCK1cTB+N5KsWm9zI2zTrYih'
MOVIE += 'eZLhRbErb5R4AY5wuE24AaWjQo3SSVbIG+5aKifm9X2muwK23qG09296/qW4bwAR'
MOVIE += '5TvwWozse8ZzLXH5EH5pGlzqj9NwyBDQlATc3v047Y5kw/obzMghI8/WqS4iBFAO'
MOVIE += '0kz9CMlcxzkOw+AgJf4YamCEW39oBoYYzZrVYEjQgCaJpiCeAlZXGtdxsVFZgZrM'
MOVIE += 'xYJUK9e8yyEKO2t0N8Xypq4WLY6GGOjveXxIpTUvOWFjhpQPJ+u5YJ9G/nrCDNBw'
MOVIE += 'cGU4iQ5ROzb5OwDgta32myWjTm/jo95zHEb02fBD1VqxE9jzAkoid975gc4XxGxV'
MOVIE += 'bY0PvhFwOO0rWhKHkAw9/E7wBADTw4EVLgz7ilP+Mmp2mywQfIbQpZH9RiODoMZv'
MOVIE += 'AvUCF1VHQX1OyXgeUQD8FvKUDLCXuRMj4LOPcf7LhMeFgqCoOWBMGSZu8xPrHWvz'
MOVIE += '/uy697gWQTnQe7qHx52dVZ54PyqXSICvdl4IDy+fYFy5LoPIGkOLW86Cu/Z+5dO8'
MOVIE += 's/E1BEBNHaDmDodPDQW9tkVjW95CyyezpmFfc2fL5uUn+TOhDvM35NCDuBASDGBM'
MOVIE += 'Br/uerhoIvo/zY0bBgoa9Au72SP5MrV0fUg3UrgAfZyrmmXBK1vNZgjFO9j/vBhe'
MOVIE += 'd9BD71hv1/0XDLvO9G8hPTUzhJpiyBhJP7qITnT+WJ/xoZumheq1zIQIPU/Wgwu+'
MOVIE += 'Ib/mPyMyGH6s6EYOAK/Ocn5SyOEm/vwceTYlBOIzBPPBv7H5PyZC2IcSHfvEEEi6'
MOVIE += '040jzzcrI2qjSWrvkFkjmUSTh3PGOLCo6lBv0RvqNLPm8xNTJF7bHPTa4fDZxdYe'
MOVIE += 'JwPcCOQiwXoPxy3To4vx7+N/I08t/HhA8bOtFx1nSsiKHh2fv3Gh1FkQYNsmakJE'
MOVIE += 'H75ip4WXuHEye6ZFsiBfDwov6CMoH/6PdD7H8fi2m/rVYO56OZHisRB3JdHbvxFk'
MOVIE += '5icDxwd8sEMz0FV+LfTHOcTG//dLUqgPDm9HhYyowprTiL6Sa8b2vxcecm6GZGAP'
MOVIE += 'e9/ANC4v5ZnQc3lhPm4Y4IJjBghEAGUMP7e950xGKUFRbxl2LXNf/Vkg/gP/ApUp'
MOVIE += 'H0gQ6qIkIqie4QK9abAeWrW2JJxEkRSXE+XdwQ8mAW++sEMV2p51S+nGf1DJEDn8'
MOVIE += '+ebfS7urm238wUX4d0P6jRg7G5fPb+O3rWc/m+DD+QDEjDxOa0oxBOQUSVGYHRXS'
MOVIE += 'oECqcGlUFK06oYTffv38tAokSDbNJoFLIwYPbNrqshEIbTGdcmHOMTVZavee8msf'
MOVIE += '3vc2F7Ofd/k9LH5CJVmtlSvkWpRj2uFV21a6GEv8mctYr9vvIGn5Pj8qF3qBjlKd'
MOVIE += '3ODS62n+u7iaQifld3IB7CL4rJv1+Ifx7oc1YWoeq5uf5FCi5aaRRKXYEw0sDvcO'
MOVIE += '4jg/ebkeqDYDHTg62JJhrYJRm4Uv/okHjyVRGZGpZoyYSK63u76vtX0SeucaRS7v'
MOVIE += 'enWWmEG7RfbQitRw4PoT5CKKbqlr+lzEuTiF6fXrBkqOF7Nd4DHTrtMwn+rgXKt+'
MOVIE += 'YksR5/2hl/ZTBJ6vmZ0mi9Sa8nw/iPkfrOYuf3g7/hZE1UwI6sNxszxQNjpDmR1d'
MOVIE += 'xrPAKHp9hqfp23aUiRi1fTvvZJc90nKYA/WE1Sth5GJRqvBJlUFpeLuU+gB8d3QG'
MOVIE += 'GS0AhIlbYGGPvdrValVbld7naftUHAppZTXsc39xARIWnfvLEPLeOzqf5PDmy3Lm'
MOVIE += 'O2ewcurwb/zRftMxZ8wm+GfzZi/l9rAjcewOcsWP4od1DRMIXByrKI2ZKs2QPZfM'
MOVIE += 'mB8nYJBmq4t1KL8jx4DmMZT6wuYMMLxFTSqgGsDqibiwgTL7hNG25s0nmIEI0w4G'
MOVIE += 'wlXgoMGWQxRHY+UWUEvj5SY7Tu2IXDArMI1r18ly9HI0lnOPihon520g7mwyUZwc'
MOVIE += 'o/qRZ2tAHjZR/XWm63zk0VvVqK1lMZm7QCcbkZu9qNTHN6oCVEagCmcJwoeqVBUP'
MOVIE += 'hKAEy4/+JisbA3i+CCwmsfmL/5cmv5BhpHylrBIT/ZuJB2O2i9Uos+h2FuVxd8ry'
MOVIE += 'zDb1wh5+KkPxcuS6ZBG78bj3jKyTa9Q2L2oL9O3F5BhUuxpkmoQXfLUS7/64RyR2'
MOVIE += 'vV714fCCraDK/09jkGftO4W2NsPbo09wrUP/uwDlKMIEJw4sOuuXx1waTjfWUIYt'
MOVIE += 'NbM16A/9Wcy/8AlQllPwZS+W1PC4nUDcY2XSQqSixiLlQVksdVNa35gzjlK4h07X'
MOVIE += '4vh6r9yFk5DeJmdw0W1G7J16JnNorbBg+RqgOs0la6P6wUBCngsZGtBwHBKVnTeI'
MOVIE += 'jiSN4WTxvFcOcCa1MR/NZ47G1Rv3/Nh8xUY6tZogjsi4q7o+WAifKE87TMBUvjbT'
MOVIE += 'dvgDUc7AJzWP2l3JO1U0Z6y3rBS5XXkrYs54YelxzPtt9FP8KPns9/dvqXgnNit0'
MOVIE += 'fXx3iVs/qAKN4nlWWlpDXj5ZeuWSLy4nAyQ0xOFT1V7C8JaPWF3414WixO7g1IxK'
MOVIE += 'MWwpygQLqPgH8Chy/hnY5RuJTEyLHuviEwZ2J/BgjCrWKHtvYhjm9Arr88hMFY4n'
MOVIE += 'msKaCOJyRgyXF/xBSVJZbg3TJLCv/mm+Vj1Hs1Gr8sUYXf0acy2tZPpbbPB0GZTg'
MOVIE += 'pzVsrfbkI5fVL3U8Zn8TshjkEhcikR6yI0qeAMIx7wm3Fp6wQtEAED0cqMq2CGKr'
MOVIE += 'x9IeXkxQ9bdJPePQBEtXk4szEgNoNAs4AhAlIECH8XNDrBefKADWDCD9iI1BJWHL'
MOVIE += 'TAdOks6z1VAuB9V8c4EBo17jhh6sxPeSYMpX9ZB/uPAZz25nAYCqCeUJWtyDq5Kr'
MOVIE += '5ZOKxO4Ebv1uQQRtPj8MebeSH4QsDwPAgY8G2upbUiGqpJTV/kc/M2AJSHx2+V1C'
MOVIE += 'hUQtPVIO/Cnn0S28RcznXX/2WfaJBFLlBPY2MVF+Hkhor0miA6zJ4ntQ5Z9nHTo3'
MOVIE += 'xx35Bt8SxVAByZ9toguEntCJ6jVShV2VC7yYzmO4odTz9IsiCykgsqVJmI30DCqO'
MOVIE += 'uqylbCyPZaMqD5skWmEUT8RgQ1Tjzxnn/As2KZTojTP5/F24H5g2blmE0A4/sTCG'
MOVIE += 'NsKj/pGyruqQVJiC8DzgRJQPMm3UPt6Y21pdanVdLwilsRI4E4MpcuU87T+AWUpt'
MOVIE += 'vQUj0UwMnlbxvROuQi3JXD4ph6ylft/viv/bBxF25OvvqTlKkmdUKJ/9WI4fXJI2'
MOVIE += 'pG7x4F8EIBiBJD9tEh7wy6DoKSDh9iuaFkB/HnV/CQfUBTeQfoejF+9h70j3kWo0'
MOVIE += 'Fp25CLJ85tr6cGJiRhBOw7oIUXWi1DEpVg+yS/9h4DJ2ABkKpiSymdf4KdtkDfDv'
MOVIE += 'cXjuUUA7j4njYazAY+yFs9H5/zffs9RVmIiBpqHuScLDPWSUWE9lb+DBwk9kz9+X'
MOVIE += 'UEOX+s9/HUsgyOH/Nukf7rkhnPmK1SSyAuDONviU075+9tQLabnP7kvR69ATDqzF'
MOVIE += 'X5uw9tYR3rBP+7Zv/bF1KohHj5OXAC1c+53gdjRaZtis9ziW9OKuRSn7Xt1EhMKx'
MOVIE += '6q98RZqc8lB6Zkiom/srK0rvkwT+Zs+rwMgvNjqKU9I+VeJV5ZQ1Sr03/mvhEBIR'
MOVIE += 'bcjdY7lFE/hd5HGov+PqHUW8loq11Q+4zX969AmAb3jVAADsPxEFzdxjIzm8Vfio'
MOVIE += '/TfG2S1H2f9dTMgA4t/wGPEkEU9iySo9emz1YREizloGdoQywlpBLSslTJpXLnId'
MOVIE += 'w6pap7djJju/8fV2VOjJn8RJQK3GJQUdOjvphPz4WvSfsr5TNO/wMNWqB7D1cbMy'
MOVIE += 'pvBGM6emqplMsFRmgKld6pfN3JafUzbv1FTWA5aTy1z9XdysP/9p4ROzn9qcWrNn'
MOVIE += 'yWZynfx+R9aD21PlGCF2v7Z8tt1xtirxGvN++1jq61U+W8yRiOGg7xAMu3Jrl7Vy'
MOVIE += 'UDZCXjlwHsp2T4lAq2S8lcXXlXDoZmflUTP3d3z6uaR3m6DqiaISobEq/845Oqrs'
MOVIE += '11aLrIe3HoamS+K/3ngH43hZgayPLqUXeM1vsQQMOOZ3ZpUSBt/GP5wR/5qQoYBu'
MOVIE += 'H2Z/tKTEvvY87VECYcBCazBWRuVMgh3rz09ohT4B5sqqCpxkx+59xmqNP5v0RjPJ'
MOVIE += 'o6SRPx3ium919XwCr0NKSTUaDJg6ggcilK8A2FZ8QKbbF9qw9z/xxSMZnhCHv9rI'
MOVIE += '/+WJUEVn8xjogaXhsXOHyeS/Y5ROve/+wNl2Sr6O/Icy+vemzIDjU+4Sj7oQSDF3'
MOVIE += 'VAdIYO0/QntWJTj1QF4o+lnVqejz/Hs1JxHWcPwby9CP+IAJorUmza9yBWCeIMxB'
MOVIE += '66/39aZI/WcE1Grd7WjSgXLltt89ukMCsY8TCDxY9nTQ3MP3CIIkY4s474J+Z/83'
MOVIE += 'mBEKNYR0N4qIVZPy1kE24fRNfbZsY3ZpIF2UVIGQ8jpmC0Z9n/SB7XS0WbMGVr29'
MOVIE += 'KY4WyBZMzBhk4mtqbs/QrpK7m4CdGsm83CNuXpSDmqK/HEn8RMbqrcc+3Ixxmo/9'
MOVIE += 'XJwktySm4A3izBggbR74UiwyMz1AHtPjURWFLsArxJWnMpCkTyDvGOgAma+56bdy'
MOVIE += 'jD0xPTIg6l7mzWkqBG4QkK3CSN/5rh7DITCa64lumYde8OO5ALIx/FAqsWyxxIE/'
MOVIE += '/tJfqhrOm4jAxlUi1exc82Bx05F38ySRUy+B9UBEiUpUYstikxzDPkZNhDqXEiiu'
MOVIE += 'qbYJIonKAKiIj5Jbp9tkKDtq4zXUD/MbyVcVq2rb9L/qHZWdGHXzLr9Y4uVCxgcl'
MOVIE += 'QPTaAGdKGI1whWZZUtLyOj0TtbvrcmlV2N4liHoH0C1GTZ4QVXjaId/PsDNVY7sv'
MOVIE += 'JxyIVtuC2F5TZCfRuRnJH2mPu1iPCweP69lUMSzVErDhq/Dg0Rz1B8rDtIgA6+Wi'
MOVIE += 'cJDqXcBZiixEOdUBskwJ/NnU8W948IBcqr2vmFCHP63xXcmTLCNAuglAtmKkpEAc'
MOVIE += 'Wtw1aYMaeM7YK1CtKmSj/hc3ev5EXX9L3ndRhCchxkk6hqkZG0XOnCwAwGsbq5qE'
MOVIE += 'pRN3U0xNUdCztp6xC19ra4C6qe6BtqrRKzsY0kIwwqFAYaua/frBf9GUsm3kz9ra'
MOVIE += 'cl0m82Lintx2m9TjHf6Zdsog1Bhg/CUda4yQ7uxV9AVORTFORZ+pytJHiRhqyyDT'
MOVIE += 'YBYxmZqDf4u0g1zIDW666NuEecGCi08QFYEwiCbmj5WeFFVTv1zU5ESyAX9Nt1w1'
MOVIE += 'Y7hGFC81zKImZ2gaEqk1qkJ4Z2vx5mEjHk5OV8yzVrtLla6pQUqWSWazdTBBgLIk'
MOVIE += 'Do2IhgAqgRODMRdRSxlUdSVKNJas2Zi3f9lmFyEtf0+a38tG9V5BEBapKosP/ipj'
MOVIE += 'FCGolLOULi3SpGHUfzMoPMaZZ6pJxr1axSVaragZbPaoz5DiF5PmkYi5ogyS4xmi'
MOVIE += 'r/QguXBwIC6KBI6Jt+w+4C3iTBYOG5255SBQhnXL+2AiN5n/86yjTV1QwnbRERaw'
MOVIE += 'nc0tRXAIJ4iGmsiQ1qtJLwiyHb2/25fD41D3HKLA6M6dFg/gKwhU7JNplc9vX7QK'
MOVIE += 'Fahz4+LZ2hgIEjG+xO9Sy0ku5Rn2HGM6BFjJPXR0Fx7cVdBTmbACfIvbJtA6WvSd'
MOVIE += 'SRPA/iDBNXmYsObrHp/Xd3ILZEBFNsHFwSoxDlsyAZkZKAkSn1qcJ3eet5tEO5eE'
MOVIE += 'kSEqYAgkcCGSCzNAcSaK2CZkdQKMreWmj4TJNQXbINPSR/HS89Hs61OMGCDCEEjN'
MOVIE += 'A7QRBBKWA2xCUrYdVWITXmF4NTJOe+dcYmTQYGoPjIIA5p8sqHEfRtBUTM1jqrLS'
MOVIE += 'Z6SZpxqrxem7jHegLBwzzxM7511vGvSjdbIS6S0mPAczO7aJ+S8h6k+T6B6MzW4w'
MOVIE += 'iq1NZCAiDnIcbecRGyYWEwmHGh2BJZHrzwAKTzdhD/+wC+lIABI094ym6Tyn7/Am'
MOVIE += 'sDzX0b9sICQyGK9Bc2hwTNHG6lccBdSVl5Rx4nBf8Qjy9vxba80CSAgD0p+lkpVO'
MOVIE += 'eHhjylAFFnYA5kgb6GoB7NSAMhnRbBPxkbj4uJKh14GxWjvZYxfR/NIxuhajquhY'
MOVIE += 'BSM49BJfCroA/TSkvQf/D9e4v5tCJdEXEtkGw2DzxIqNFwBngA1IDMSe3bKlDR2G'
MOVIE += 'y3tUOuCvIFD3AXxkyh7UkqoiRiuExP8S2cVw0KX/HfTba/a1iFrnZhlsHcMmnRGJ'
MOVIE += 'i3aCLczOEjhhYoMt4VBsrB0SL983tvmjlRQnOqZeJjBJDTDRFV0AzrD58Mu0Mdhb'
MOVIE += '58+VSuwFVUKi9V0fp6Jql7WgyMzAyoeJTx+4x4SKQVvKTYvDUGEm67XchLriLwka'
MOVIE += '5WDZhCjVpK2Jp41ny/FPkfjfOOMJCImFcFHihnFILJe1TJy7pm09FBohnVJ/HO1e'
MOVIE += 'T30CiIMY2UY5fIzWZAAkgJQBnc+1ucUGPw5caH6NsX3sDSD3r44uKP7vy6udj6/Z'
MOVIE += 'ObdbLEz3g039SR6O3VjXR4/PJWxf7EWxzuNLzaYyFnC3zgAVVtjrh4sAaOxThH1g'
MOVIE += '230eJiroevFdFsTJIvafGXHoLlRbEz5qQSx5BDWVpjA9sm/9+18q3IF0146Kt23v'
MOVIE += '2CTER+eO4p4EuwOZcSBxIyR1ww+9cDhIbb+D99QqIHaP9okpz7mqBYCdSUZ83o0E'
MOVIE += 'FQAqNJaNJ+r7j9paXtpALIgLATnXhjzciYXQOVnAY+yRcQooPCUA9IEl8X2uS3IC'
MOVIE += 'v/EL9I4JBtiG8unn4PPLRV1qiicMdknkEjhAc4DOpdnUzvTOgrxQq3+QUEQP1xcc'
MOVIE += 'vu2nVc9Pn6H5R91VrDhA7oXhQhF8UTZXjfK/pzhTuSzJDTqQwnqCEsJprCDmcwbk'
MOVIE += 'IRw6euT26CeldrjVg6PNA3KHVdsHJtqZHrP5D9BSbi0dBBeIiOADK7CQau4Bv4iu'
MOVIE += 'tfq2RrfQ26dzuNht6XMiHh7QUzggVm9rwYtAnfK/byu7w64gb92EO08cOBJj9agM'
MOVIE += 'X9ui1Dl889G/o3mmz1F8n+MBDsqYdY3vm3u/u3h2jOaTPp9dGEQ849+hFwGu7Ige'
MOVIE += 'uvt/PHieJn2kOnHMePQGhy+AA1CVYyBwAHB+Dogjh83j1zPbczmAEu4xhtJKSc+i'
MOVIE += '5S/BHOaxwUrEkgVpZpop6T8PR+GezDcKvHZlP1QyExAyXSYaJjEf0rKOC1t5ugkN'
MOVIE += 'p+mcswWhY6eFz/z0ixdVKUi9KvIsq2Oivo3tfouNYpX+r/EweWKVN7DgsDIxRsRC'
MOVIE += 'U2AiXvEC3EkDdZKGjITHagudPoR5wgqWsBHkadKe8QtUiaYolx8Vr3+vv2ZW1FjX'
MOVIE += 'sTw/fYp3dif+83PAX89SvYSRn0QXfLRXfz8RyO4CycGf886weUeF82AutD23Bchv'
MOVIE += 'z6dj/L9WoS8dh5QPNH2TLXwnj5CzM8J91lv5DIJ+basf5qTKdExHBKCoRLoRDuiz'
MOVIE += 'UGMJUkeMkA+RoF+ApZ9sxCH2WfTbLnACV8abHZ8RDHRkh3Lpn4fhTrxPsMzHyldp'
MOVIE += 'Ey1roQ+U/uaJmCTugFt/bbfZvtbZ/VbZL9huXB/nbRGXqSBP+i/mRtPO1WWcJ9cY'
MOVIE += 'y3wU4BglgogWQtDKAv19jac8NaORZPlgJdqQRP/O8/gVHg1HvY4BdDRCX/iHEHOU'
MOVIE += 'MYFY8ecPte/O/b/u0W/LUg441+P9kE66e6Ouj/OTJqNaG+J66EBz0vQsxjMhBg34'
MOVIE += 'xk77LekU5IrzAZLl82WUg5WcFn/6cX2Nn4ZzKj5NwDPcseUhj+cFOPxtfLQUSMR8'
MOVIE += '+ZRScYBZRERYZKgYj3Dm82/JT49cg4RjFqV+fc2U9uFuAw8kQBrPuRSeI+V7g4b8'
MOVIE += '3dB3XIT0FjD3b34/8S+5ALws/BkW7qkoFO1AIFlmtQyCm6QXv/xIT9eAX++rXCU6'
MOVIE += 'r1hIREhkrlrz+7b++BnRlGaqtNnXhBEu8GFxoicCfFF0ZvmVSNThfKNPWnclqo7O'
MOVIE += '1/459EH5p3ugu96HwWajnwe85N3ZwRqftzSSvjjU6ES04XM3hD5kZrxzdIi1ms/V'
MOVIE += 'eX/l/TX4UBZqggpCfHaQwP8lGb/oxvFLiougYtyQ52zLMyEk7KW0h5BKaZYdU3Iz'
MOVIE += 'H+4cPGnVIen7YAdfinM1PsPCqI/qmRKgQupr3y7Aesvgebl9fHx4n2vTlRaeMwqv'
MOVIE += 'vh4CieHPTXzkVE34DR2U8epgsGbAJH3erodg9s/X4afnrB6aeWQQm/zHXyn2PeW6'
MOVIE += '+l+y99WBFC59VKS8DXuJiR8kkBkHv/dImIED0wS0MEqp0/LmCsQAGC4sAvMzWdh4'
MOVIE += 'kq7EsR7P0T+OpYLUOZzxNVeez+zPz2KWT7mgoUd0b75Yfw6WlxIKi4Edvslw24uM'
MOVIE += 'YXn+uOBX8ufaP3dhBkXyx+BIbt+3dQCkEwbpPOZIpgx+1lW1BgMrfn7GDSDcoTQz'
MOVIE += 'jI3ojTcn3basj7Wehzi3xboh8FzL8awdoM9UOivRhhwST63Un658VWZ4IWLfKhKU'
MOVIE += '/1eucOabWEyQR9EAPowPhE8a7HSBVIy0oLFiPbpgHU2gwDdvB7myMhhV2AVADhbY'
MOVIE += '34KBAMhE+/TSpG0MPINDhptzpkDUudJz/lttwgMx14gO/2yOlAJGgMs0XsWLxmqm'
MOVIE += '043XUt55L+uN64xbvH6crFjmSnLK0rRY1uh3u0h4HxLzW+kWMJYOH/4U3OoN/LzY'
MOVIE += '8ucn1bZJjfZT0bFWrWxBe7wXvD7jKcWyGMDdSsOI+2WZQhaXwTZBENthNKg05bFY'
MOVIE += 'HKOMCImGe2h4xiSDjFftIKvtTchhUvXlj0vw6SeN5wQAOACONdJ9IRhtJUSanZEE'
MOVIE += 'eqAVAUxb7Eg4MHKo9NTCRL2tbpQNbA4zoNm82FtQJDE/K1p3K0CWCsox84vb+H5Z'
MOVIE += 'fPnowUu7Ny/WeQkErnUc3RlrCzhS+obeOWca3Tc1tSlUW6oQKYlUICr7zK1i73sX'
MOVIE += 'tDjeCyrPxJImaRrGgcxi1BSf+owyKVBdqFPQvy+FjOiRwJ0Y07gfOy4ZQP3LTQKM'
MOVIE += 'bq8YdPkGCgAPfkRWL/MziEBnn7ir0TGHv1GlJOEokBYjsnRV4jzIsUtju3vx1LWI'
MOVIE += 'gPbZk8uxOfs7oEcBXeRZ5gRzpMU3BJJQKOFTAlXmT/cENtkhSDyTkOiszFO+G/ok'
MOVIE += '+thvHg+mUjmUdYO2THHBMocFW4Ew1d2SFBQTFg2EWlwYa8dcWAAgz5onmJp/TigT'
MOVIE += '5bupQV3FXNQOap4YP23gFDfA4nMWmNBb+5gWZCQeFs6uxuYXRfoC12nuCI7GubIl'
MOVIE += 'xjWck4Ed5RyRQrJ+btGhbgmsj4jJefr2A7FkDK1xe+nJ7OTwTxK/z9kYHzHGNDa4'
MOVIE += 'Bqm2MQIYy09sdJ/PiOAPi90XYh+8HJ6yVdh+qpWbvwsk0sozIX8iMGHW0t3cyfk+'
MOVIE += '92HXC91TFscELa67yXvmA15r75dN+Uwlq7YnQS/072l1ir9xIKIHry/dlEZWPubw'
MOVIE += '4vIqRmHEWf+CVUekzaXQjwiu2S9HqT6AuV4OfjvREexuM9bi8/xPNAXVhf4dMBEg'
MOVIE += 'V7VqtVoQGWbD07TxsNvP7s8XrlSCc8FZkm+RQeVWR5G9sxb+jqwMv23aGVYBqFLh'
MOVIE += 'twBxgMvSeEXmYx3ynT9fdVXM5t773quDtcc6gj1PW7tgYk+4SxHOMyI3h2+mRRKW'
MOVIE += '9yQ7AuNtpLbHTgcf2vs+Yy3AuC0blTMkThJLu6pZPh/8kcJOursn5y2c6W0brIRH'
MOVIE += '5zlAjs8sBUdmPUrnqXqZIdUw31cr09ZlQ2r2nuruzg/W1r4QarrWXUt86tzpEMvl'
MOVIE += 'FJjy8ZKUq6de7WUMvqi1kqfimNjG5dVImpcgGRoMgrBUvhIc/nL8NO83cx8gdjiU'
MOVIE += 'ZJcks0BdxKEApjcKB5+xA4h0w7OOtkY5qqvsayLZJLJUcURjFSN/NQMhbv56mC0C'
MOVIE += 'qELRXpNQ+x6NSMok8Y8fbxzRcD8KYpOzvAoi45y9qNlhsq6fPUNvBglEEsgrdi6u'
MOVIE += 'RLVcArj5B9iZ7VXiaItQcUvzI6woACDz7DDwOc/Kon7lA+Tw6DPI9FCq9loxEIID'
MOVIE += 'phsuZJVcjz5EjfG+jsLjKjIickSOUBLrIvlo1yUFbc+SjW6MW+PaE1042O9o3YLN'
MOVIE += '8R4oJb35/QW1kL0No80WnCpBpY/LcylNoFJ/LfjTex5FIcpxMdSGFN4E6BWttLYS'
MOVIE += 'dhSFRhCAiTwVQUn/Q50jYSKmSbxBq5YKZWGEHRVsK8A5zxg/fFOfxW9PJ6e7vseR'
MOVIE += 'hRoTPHBSwtYapfr4bDBgjxGPSLKVxJS4VL8WiHEHHz1tpgNRUeHHsnGgvSQXWckO'
MOVIE += 'aCdZQAKmPDIgtueBfdeZHEApFJ6sWIP+ymSShX2lGl/B5GtnQ2ffYVjck7IsA9RN'
MOVIE += 'lE6XQ6wIRW8KZhVfeH0Caa8bMC/JJZ5GDH3Y60Jx3yz4qDJCelJ8H00K2wVDIYb6'
MOVIE += 'j25zKdRjujhJ7nptpNI/QUmJ2zm9PsbS8j2kImQcvsdO1mm4ybbjIvDllRWQBo8c'
MOVIE += 'k7Xbopy7Gs3442WZLRaHqScnGgULtQ2NC4apXoR7KT0Yop0LzEDN/qkxi+0rhyrm'
MOVIE += 'NPGY7hLKsMdviDoqF2lpkkdEmxOl5LQogDDQSpzMjcgemREGmA5Tp9D+AiIxdjZ7'
MOVIE += 'cBORuAw1b4s+qFbA4GuX4FUlm2C18zl0lr/17sm/4olx+y9K3jjDiW7F4l4vXvxi'
MOVIE += 'UGvlUZ3al6sr1UKTstHulz/KZtfHWp+aZnMwAqjZA8ttIBBakpFSAtZ/DjbkFkiQ'
MOVIE += 'lun5QrBxdjHawTtnIi1E4jd5BG4Yg/Amu3tZRmF5+aaO5lWvmiBKJOlqSq2rxr8x'
MOVIE += '8tdPgjcE48RAWV0zJnaNZq+Vt7ZQlGiQJAREe22KShzGRXBIEOF2YDLSoLwWYjA5'
MOVIE += 'B+3IAyUMoWJN4oA+BUDjcY6uSuRHXMe53NCH3FMvI1PqzmuLTh4GUxdd5xvGR+/k'
MOVIE += 'JX2/R6UgJ+AyXOr/vlYwVEoLEgOh6gxa4NHHWQ8ylqbz3nQdmu7s5KR4ZeFroh/M'
MOVIE += 'Nx8ava3kxSmbC1YClahf9s7tYm0tr2YSFV4IdMmdC+A/P9ORJpU1iH2jW/kqfj/B'
MOVIE += 'a3nBRIceXyjFU4cWAGTEDB3JG1GxBxSwfNcUa1C7JTTTJPdxOx4V4btr55R9faNg'
MOVIE += 'QPBhS13E0Op1zXu5wzP6EMEjVlrS9WdRX9qiSx8l3EvN4BZp2Qri8ezBj2VCJML/'
MOVIE += 'l0KU8Sd1fOGt1UCYwXGO4v1A5W4cUmxKvRaiTDkBo+m7z0db/FG2PJsrbgk5zrfB'
MOVIE += 'p387WMYu4mycWRh0D20InUBclcepfmFYqD4eViS9OBZlcax+rwQmloZjE6T+GNco'
MOVIE += 'o8EC5VF86cFcwfXBd3M+ly3OYRZtzaqicbs95slbFrO4sUkjRfu/GatWgvFVToD2'
MOVIE += 'xL73Ck0oIL70lFEapweXu5TwmkytI4zr1nZB8UO8IqHupOZdBpxIJZp2Hvl7UviM'
MOVIE += 'LMbCRRd2L3Jhzu2DWIPVAH36J0kfwQ9dZfhSps+1NcoVvnyxk/tw6m2F/CR1Hpwu'
MOVIE += 'oyuLjiLHqDBGhoFmve3Co7pQFPJ3crSSKmnPiZ4evSEPsgn7Fs9O3DwD0EQTAPgj'
MOVIE += 'kp+MOo0VMYVfNNxktI/9KE/Ne5b1OXRzxLYg+H2erjoaRFlQDg6njd/Od6jY1Rkl'
MOVIE += 'eASD3FFDaFAbVZmq4Hr0iBoLk//GiC4FNMZqXG3nZ4Ol3pepUiVQ/sDGtZrW7xpb'
MOVIE += 'pS9Q3oFiXuLxM6jl1pehPxu22ik4WDiGKBRzDsWSI5ToU7AkoBeEP0pUmWKYMrBt'
MOVIE += 'x+We16U0PBDCrfnAegytDTP8cRQt4x0W6mAg6ULyINLuSA+5pmR0TJ0rNg9q8Sm/'
MOVIE += 'mFjvX1jHz1OGbdMTnFh9UVInnBrFj8TBugAEo6wE5VlqetHSHP+h0VjK5unK1Dh4'
MOVIE += 'fx7Z5sy/v7uzxEN+hnMG4mhIG4b2FnhYM8pYPkTO89GASg1k40QwM9LtWEwdyCKX'
MOVIE += 'qsdDkIwXwRoprWzDM1yWWiHUXYrf/uKK2Mpl2RZco8qQhiGPUaIbBRAIKDPxjrAh'
MOVIE += 'gP8uS33gqmowe8CbcSTI0TNjRBGNBiEcseTk+DaWeZaWpIaIIWIjUDmOel+F+1nV'
MOVIE += 'msvufbHiNIWN1wk6OVOEeLbDt1eE/3GNnwtG6DYtoql8vn+Xhj/AKswVRTqzS/xR'
MOVIE += 'iW4dTVSAVvy5vW2plJgyjmL+dO+19R49BM+IVry11mHa4zAj1UJXqK9S0ySApJ+5'
MOVIE += 'hMVEmdjo8h0RnpV8Cm8rw+9gf7K7SVPO+lJpXH6T3fsgjSADTTdjyNaFg+Uo0XEo'
MOVIE += 'MS6+IOpxZEhSQZmrxnKwqwzHkcm6EBI4Vv39AIABrHjLAl1nOSQ+xFZgWExZNUOd'
MOVIE += 'uJVik4HpMpUuZvUcrw+MdYqUhVBk8rJxLj7KLqNs3hKGjIcubC5KilFoPBc0PtzF'
MOVIE += 'nsLV4VuZUV70rCCnW7USRzDWBM8iRkCVvByjaLNnYME5hCmkncFGmc0BdbceRrmY'
MOVIE += 'iN+p8HGA8cqqLZPeTVRz6vS4WBtTez1N5pg4sPFTtj3UZ9xEI+SHzlPRhF2sDs9w'
MOVIE += 'BBcHhhEAGJzD8YZ5lqn2Hl35PmACIX5oIjmq5qCk7D9EfQEm9MGI2e2xWrk8SsCR'
MOVIE += 'zw9ZiYA+MwFCI924+aCnyyrs88aeZW45mCzeRueIhgOrDhvlPuzLL9hXEx9dBOCK'
MOVIE += 'HeUOPQ5EeIeG9B4OeFz2ZWhH5v0Zs5g9Hvc2GSXaAUMOeBmzKPcbLF58VrQ0AqBO'
MOVIE += 'EU/zZZix2hTUjIFUfl4VIeAMH0bl2EFyObVPtL0Wi14H5On0uzlduT9fZWL6AiLC'
MOVIE += 'O8aQcmfSNGSebxsJVcdw3RVRQpSRt5lKLvVvLIdel6OBNu+jSyHd3ab1DUcQvlgW'
MOVIE += '5LDIQL3n1JFMf7zVTEHq5qaVNrWuEFX61EfUrGEG4VEGPW8ZfT3+LefXg48UAtgs'
MOVIE += 'oTqRXSBl9ZCaDDZnm1ERjR28wrPRKxq0YYFO6CRFHNdfDnPZgDmpzAuH3c2uCHka'
MOVIE += 'rPk6jq0OowYS4WVXRyWghlKKhrLDhqZVJyJCzujD/7K4rC5XaCoJT8j46Gk57A62'
MOVIE += 'zHQ9KN2Vy2uSyljgKr0XoFNN8o3HXkZYp9OhsVTbjNfd7NZTDE64hkb9cWIsoDeK'
MOVIE += 'P7Nnt2n4pJTCVfHncRbIkbTjlHlTCXmrW7lto+54h513JZEcGwU77Febn7Rb5bMw'
MOVIE += 'Kp9fDPcEFOeM8nSpe1seaeO/UYNZeU99tOoZnuz251dxTdavxYz7NY9/cyslPH63'
MOVIE += '6tlHWpPRjyG1ARDXAyjlPcr3dt4owYJlYS9/8lFfVCjCAEAqaNBkDC2xEcFt01ED'
MOVIE += 'SAAZhfQf7V6I5lZrotWjaSplKB1MhTRonJYOi1ooI7ZJGvY8hLr2Wgk2ZgA83gHN'
MOVIE += '614CfzNbiDaP37lhMig8S2txTBzKzPBhyivmf6yuxlwcL+fOjAOBhJj6wYTPuj7H'
MOVIE += 'AI/Ut6AWB1+nEBHoWUkRv2f+1n6SZQHbil+UEMpsNXR1FW+TIeD0+eYnIdRdFFFM'
MOVIE += '61Hc+Xgcf69fM6a2haHnZGO1gcjFiPloOwDEN31YrJQDY2WrLed4gaDC/vczjmxy'
MOVIE += 'VDt4u5uulTr0RViBp/n8Pd08+jveiIHMy0/jJEWyINEZJl6L88hB6+JhrbXaRgXt'
MOVIE += 'YRYLA+Kcr0dlL4livAlLzm+S+E+zTh06yscjMCQoE/iM198FwS/bfJ7EhJQpuf8d'
MOVIE += '++7axlD6DwHYnCAZOVHU0NWL6MvAF28p4Pesa26OERGUsu82yLDPuNV0+I/PsDt0'
MOVIE += '+aCjRij8kW7rEL2FgU7BS6JRwE2c3+9xAKz65XHj15ufXLc/XTNq0XRbSoitoT9H'
MOVIE += 'uJM3DvjwWseTHQTPnQrHBNYdVXt+3vrJA0iVoULgwPEGJgzuGgWgceA6bg1/68U4'
MOVIE += 'LRTHiG547LVCqwAEfG4TLWQjiOf7la/VleBtqTNAiZQHMFTyiPjrJfMrDEt6y/1U'
MOVIE += 'BsSdkZ5i9E8OT2g8TulFyq1gyqRspLJK9BBQf7kOch3ILH/ZS+V4YAHQYjLWQU76'
MOVIE += 'JljR2jsWHyQpiAiZp7RzU4ElYCqc+2n8ExudcVpi9Zd/XPLoPiJuAh65F95jWoex'
MOVIE += 'F0P0+xiwNCY/UYhFWIwl3Y/Ip5mgQOiEIhC+f/+TwcpKdBy1evKCzZX0fBce0ynt'
MOVIE += '/a03Azz3ZoJ6OibTZdYoJXA375sucJ676A46XFYgjFbmQ4wIwkaakdEPg3cNzchF'
MOVIE += 'XV7CXjL9OlR2P1bm1gUSa2LUvapJVbtUDbpIUZ1Eby9+gwIJIbwE1yKSTUKbpJwE'
MOVIE += 'iGpHN82LMQGZkXH4EZgViEmYGmVpU32EBECvlAaaJ0J5COTdrS38tOpukkzFv64n'
MOVIE += 'GvO14Sf/netS9plKKBc6GqbSRIOJjQDyXT8Mu8w0utTeodS9r8ZvLjdrT/soXP+G'
MOVIE += 'oBX3XkRXBmsn33vttx7KV0oe0wDK0fMJoJAvXdw05pZ2xJOTyjwrdOE8yQwvyJ/t'
MOVIE += '1MsWjBD5b98jH6nwgM5iP83sQ8yLv6pVvVRfu/Dn++a/yPJ3qFzp3x3zXW2I2w5Y'
MOVIE += 'A4rWAAKkLOMM/N3UoXq+4pm2TXRyk/UtaCiHqTLtXM+3tHi9iprub2q8VLEQARyH'
MOVIE += 'bbUZX6ikPDBQ6qezcJiaWKeoQc9Rki/JS18i0mOCEhxs+QXBVUM0n6cq7OI/3lG8'
MOVIE += 'HEuQNV5h96jiEfH8FdD2rWSDLz5V7KFB1boA6hEnUgW1tWS5brLcofxhHmT/vadw'
MOVIE += '/nPzZazsAAYijnR14gCKY2A4TABLGIVuOIV4T6z1tbNGKPE6hmS0jeV5OKF8pxsZ'
MOVIE += 'h/ijMMnss94yzLaE6nS/QPh/jDQZ0eTaVjvqXiAq7BzSS9njBe9bMU22ljVeAYWl'
MOVIE += 'IEFisMLBXZhfMn6mdRu/aZRhIp8tXJqbB5T7IkqI6VqExUZHVdrMRDqWXarAvtdM'
MOVIE += 'TlItX9g8qNe88yL+XRvBKFr8rQws4cvDz574VIf/JGOS34a3aYlQAfi1ZtJd6wnN'
MOVIE += '781N2fhoqZQUq7MfehU/4W+lkW1ZmlLmczkRgUTzPTdCjZr0IsBZ00U2ujLcV4WO'
MOVIE += 'RL80qRD5L/pjnsgURPc1cmNV+aWC5HrU/gSIxbeS5Av1vvkKK8EwvNnR/PC79FRm'
MOVIE += '8Kd1NRs6L4kQiJiVVPeYM+RmSOkIdSlOf+72rfJDHlqZ26VRlDEaJdByMaP8jhPE'
MOVIE += '9HhsDP34dQXbVO8IVgcHsUnfIwE0Bt09pnFRanrZP2hwHTvSr/oeEOccEuQdTpQu'
MOVIE += '1LrW5h8VwjC8E7rk+4+gqs2g3sOkmoIan/1adc4tWjEjmsYiwSMDnHSlxLLcTWnG'
MOVIE += 'ynPv9Tw/0vW8ZixlVu4g6NxH+RX373DTheekYH6blDqTx68zo2SuMYRkTNEMDgMa'
MOVIE += 'vY3v5Qb/kwt8FRGb/fvNe8BbfKU4DUn1F8JDYWebXj/PF3w9I0NHfs2oUQ2Fv15h'
MOVIE += 'z6r/4QjYNYv5lxhHSQX0zegAzIIFLpQv9UGogoHLiJhQHI8pjFqcqu9B0OtX8bov'
MOVIE += 'J5Rr6VVYeQRzCkqs6+Wi2HHzWtrV/WZG8srzDGEI0zcHD98sMAw2fr6T+3yKWeIf'
MOVIE += 'jPt+GR8t/c5L8m/p9UZgp3LEq1lWL/UNmuzDe7jBiXTujeaZyppGDKL5achunMaM'
MOVIE += 'ivA+KfPOyEPbKI0yecifpl9jRxGqykYjt08YzfKCU6zQYI5IZccg8Kj9gcrX4X3+'
MOVIE += 'nwfxDxZonx7+Jxcb9GbpyZvF/MdH3j9+F70hSPE9qT0Nabq2/GCToKupPvZPCQBJ'
MOVIE += 'AoAJ/NdD4I7Dts/hAGQvUFuV35RHv/oohvBNZKUytugXIQdPZgUXU7apz2a7bf1N'
MOVIE += 'DBXd/wHueoZGynSWKdyTamW+b1Autph2RlJLRFB5Gtc8KF3YO/am4dLN2B+ybi9X'
MOVIE += '6vEh6Ar9cUN952PR7vw2TuQJjW+BgPdG69NvNH42vUpHXO1PpBJI+2Wv74G7DzWI'
MOVIE += 'h6Khr1GRFm0EY7wIKTdiUAc+WYZeBoC71aaPU78xuNV4gc1D0KokJQCkFuy10mT5'
MOVIE += 'qjWBXJIGBAGWG4XLJY1gCSa0dEn+iCtKPlOMM+VcJGt3HuPQMqaLZ9Y7Xqr7MEDQ'
MOVIE += '6Txn+aGY+guzgNn7mk/vHknxhfAJPlY15yhQACgCOr4fr/2ywnvwr8v39/d8hl+t'
MOVIE += 'gMvKZNzgtSgcNeyEnoFCnTWHYseRxf7K4+q95WAy9V6BTk5ZsGBXUrkmO4XcBMFC'
MOVIE += 'N5WZKYk0dysGV7Gh2vtFknSPAQAKbIOR30kK8WwSJ0feYMZqP6EvP+V7t8rETR7c'
MOVIE += 'hh/LnlSnTPYXyRrXlD1xyawpFCod4kBcTjCYNHwhbPCKJUBq7gCuBwIn3kgfDAi/'
MOVIE += 'lV3RJmrpWQ4kQgN3v4klgn7woYTfUsnPoPDJbZfb3vGY6LaT6u74d64ZOw/Dc7YB'
MOVIE += '5GPUCq4kvfwQNswy6F+5CKs4jB4Wy6QUHEXE8mA0gYj1BfFkujlpoF++U+juWA1v'
MOVIE += 'bOoxuyHXJbvsMXryuOz8WWASr2iVYDYfSy8rtfVHv5igOb8v3uAt/6GxJQGJGU6p'
MOVIE += 'lLtlszC08kfBLmH8g5A2KK0Vhuq/SD2Eo8qMfEkIW8pcomqhpvRfqrtd6kusMkaS'
MOVIE += 'SRZkdg/zheIBYP5koIfCJ5cOSeL0oi/MKYyOCtwrGWkODB0q9gvMv/V9k+ZTMhpj'
MOVIE += 'FhzkyH79wkWkke4KFQAhDer1dAC0eCSLvGk9RI5+qJ2koPUKeC+a7yX/51PQR8UP'
MOVIE += 'T2nbWj8zNce2US7l+zwTpnyXyPnvr09CUGjmyKI+ZZm1uIB69zrI4CqtIBO2xY/B'
MOVIE += 'UKju90oIXQxxm2hRgcZZcpjetVYfiD7e0BboPMvicU/fS6sv69/v4PGojoIws4kj'
MOVIE += 'ccfLZr/4TlYrhMAfm/44084DCL7Q/3rJcFvk83RsqHnkfUECRCJlv5bhMb8T07Bj'
MOVIE += 'su+H2OYtN/Dtneqn9Fc5JVI0SjyU9rl9XGn8LM9vC/V0A/1yneqczb/PinxlbGiY'
MOVIE += 'X0YCf5m/ffBD7mrtvx9r3xnWBDooHWi6zOVeI4+E1VGgc9B3ie3dU7vfXkBpnFHa'
MOVIE += 'HIoVvgLW/yZtkblwFC2Jl4hQFtiB446rIqq1Mimv2hJUU2bgah6s2kKsby5riBHj'
MOVIE += '/ml7pEqMroOVzPmU2WGBNLIeMyAK/wslWH9lC2iHLClo8z+qr/MP+A+5iVx33luu'
MOVIE += 'ZtX1IOAp+FTL5fB1NP4Uv8/ghzVX3aVK0tALsVAVK+Ahajh6xlGShhKn6BEymFQ9'
MOVIE += '9GQJBaEsv4iz+1IZJ8X4gsV8oZoT+Ml8/C6xMCCwQ+xXCGmiRxFubK9K8Lcqec6P'
MOVIE += 'ij2eFkS37AaBrR2VA8JXY1xE9CLlm5Upoe58VMAtqSSLVaZa+G91vkg8wmt/MqVA'
MOVIE += 'h3fRpj6SJAzDHrc8eNzEj+ijGMEyE0MxX1kX45Ko8jTDlYi1Bi7gG6ZqM1yJnBYO'
MOVIE += 'cwldhmRPHK6YrwHnHoywA/l3ygkaW9/J/4xwMx2hJeqNUr1uiY8YYbLxKIApibUp'
MOVIE += 'p/Vibjd3/S5p0OM1VSIXcLLVVYrjUv2bm5pCO30ONov5dY2/CagU6SAWUh0MWN1N'
MOVIE += 'Q1mcQ52On9m75PdMUHAFEW5hRGk0I/2xi0mxCQVERDIA9oMgmXm2Uu3OdH+IhIQR'
MOVIE += 'U2akx8Rar71idCJMYVnj1IsnOx8V+MPGpLOobKayNdpLmeQ5hXM5j7aR2PiiUoaT'
MOVIE += 'rtvUEJ1tUk41x0H5jwngMLiXm3B8K5bWSbz46UxwrCBfKiuzSJwVybGLkhkNe3q/'
MOVIE += '3pf5SjhV/X8+1ZuWvIeO5DEWox60AWZLZT/JGkpHWHQLWSRSciv2I5Rpzg03QYT1'
MOVIE += 'LZAoTpt3eLxaHxer+me8tbKl+FosMORR1EBAnAwms0edWMLMR18hL5170KXkIKd5'
MOVIE += 'hs269OH8GfOFx2duBWu7mwH4YLXZI08DOe1FfV0nM+I13i8QudisU1LhgRFLj7D8'
MOVIE += 'V20rLX1PmgRO71yFNWN9GXHU5/5PCYr4xWkBdusfYGYHzL8u2qMXoA3qquRaX/zy'
MOVIE += 'tdE/WjVPWO18C2nHnJW+JlFebtPkh3Z9+bgtscv/3+9F2nf1ujp0V9Nj/6Zc8cTC'
MOVIE += 'p4n93qFVLntQIm1DkOfvdJMMH75scfRPiLCK0m9Et702HGKs2xLR2ZBwQEzGh6gR'
MOVIE += '7331+s55WQ7wNd46fDlvQfezgk/x+BaWE/6o67UF5MHvLTyGaB0SQ7mjZfiNlUSO'
MOVIE += 'I/nLg5erjDcxW4c/KxGpNQRODqCdCM0RcixI36hKeSy0MB/hOAyHoOGQEu028gRy'
MOVIE += 'ANIwxkJmY9roH4m6OCi5MHhtZiQJP+bjlvfdDQq0PoT3s+Q0xeCHsRnl2cHnFzp0'
MOVIE += 'QsoPBYldDa+evVn32FKMqIxU6hB8B0zjzIkmiNkS12/442koZ6JqCHBMSeK1OLYU'
MOVIE += 'APIcBUeDa2ORiVGa7EMhrbHUZDDc0hpwjbDEc0DKEfyHvKKlUeGr1sqDhLzBL76S'
MOVIE += '5cBGFo+g9k1S14PV3kMJfD6uoU/S+JTl8uQlRQzLbIvDils5qSCOtYKn/D5p8GLH'
MOVIE += 'JNVqmFK/UM7P2UfH1wxlRvDr+ddZ8OgnbOunCpKeLZt2S/2t89d94QD83qPUR7O5'
MOVIE += 'rikPBQSnfHf+Jm9xa8holQJc79PLw1jqM0ZCwHtIeYb/m5SEwQeH38vP72TV4ew3'
MOVIE += '86nPgg3apAeFXGRZr2gDEv/05VwH2D5DbbN4URq2YAiVyyEuLhak63gOYCG64e3f'
MOVIE += 'QmK7JHjRJIqrvu10ro+n/Qwqmj9L/lpQdWF+8KXvo3tU2DWj49fI998WXmpZqVPJ'
MOVIE += 'jd/ofLmI/+ru9r2Q9M8pyyeTQu1X6H89jLTL/Om3EpClbiKdo8h1zkB6LuJmBBYH'
MOVIE += 'o1LVTgMjkOrBE6IqBUQvSPbBLFdpH8aDSZe15p697mEJP/8tzM1p+2knRW+X5nw3'
MOVIE += '4SvZN4ckUv8kJ5/L6trfzKibdeiHnZobRo79Z/Hfe15+H3eoe/OO9JCUqAv9UZtE'
MOVIE += '0cvhF6ypzxD5bz9d7a4EQOTVojnOyzGV8l8oif8NGf4XFboovUekpOtpvrswYbK4'
MOVIE += 'r11uupTX7nslgs14goJlmJP14U3iBJDgo1NYFTQFvT/nSCyeQTyBJjVUdtoGQCYf'
MOVIE += 'mW7GAA312nw4FEW5zi1QMyVo9nVA/YVBhw88JBBONglitZvYeeY/+OxlIxwFfzkF'
MOVIE += '+5GyUdSiT+z7jv79g2e630A+r/BGKtsMid4hwa9xFCTHRYsOS6pwwl4AIai8D8k1'
MOVIE += 'PY/Rw9sDGDpEJ/A/lnWGRXlKN8aQfhUC+qHIHpELAMgudnS0Ih+t109d/OR+z8GF'
MOVIE += '4J7rJtV7MOGKKUd9A6gJJaUQdut9cMLlzSkR3b2ep6jbfVLrSCRDUtcLgI7zPwp9'
MOVIE += 'ibcTrRc4GmEh8jgOED2Orm7WoXJJ/+k0TBqwwPw6auxnBu3jdtq//hcxKDIKP6da'
MOVIE += 'GJAoMKmZZ34UGlryiK7iPR3RhC0g+ibYAU9UmEgwE/yWm6Jgh0KOnJAHmQ4rT7uK'
MOVIE += 'U2RWWlnfB/x0hG36Sxj7SUwAb4e/MG6XU0fUax6Sc1x9ZQ77Nks1rBiZQd6Y1JUw'
MOVIE += 'fzw6ZlMZ9wJ3AmSdFyq6ZOU2NKTiIHrPWoTXwDBJQtTvAPJwZvzy6eOOM0ukKpOz'
MOVIE += '4EdxQbYCHGnXJTne4ZOrcthFBZnVHpcLag3NyhxOIfxVYx1wQXvXflxyDr8bii3X'
MOVIE += 'nhSg+SZAHFRR9h7ThfcB4IyNwuFtounwKijEMr5PlMP8VDmeG9Npa0qR7lCOibab'
MOVIE += 'uoh3Abjwd4vYHOGRarfKhETrGHY3EVe7XSFbIeFHnda3rfh/RcaJKVC/3ZPwvic5'
MOVIE += 'xF9OObx1OPViFr3pEMTyLOINIxea20VfZxC1ORRo1nzc0yULA6Zv8Qo8NJyaIqUU'
MOVIE += 'ySLYV499k8Ey8lK+ZUfMBo73WF/ykR6HF6XUaZDAztndzXlsTiuSRBQBpAS2aD7X'
MOVIE += '13qe087KZPxJmjQMSSnqi8amoGVFKIgkAYpu7CAu3baMSVZSB1hZstoEkqLrsugK'
MOVIE += 'd+aXxgRWYnnpmXEnOyumrM0uq0yzMEN2tKTovcx/0fn1Ko5sV8fJPOXBh6YHWgQ2'
MOVIE += 'Vxpvk8TetdWz0qbS3fGn/IsSihKYgI0qvWclWcQQlzsUdO099s9R/wfw3waDDaum'
MOVIE += '43ZIVIOdRt8bxzkQix4gIznJl7/hBeqzyX5aKcEw3mKkndLxjOIousr1fKgMR6J0'
MOVIE += 'uk3kRtjWVfl5ojMAJP7XhFNG5Htkh+U5hCSCtYK5zXqg9lm8KBwsbQco2wDEozaD'
MOVIE += 'ea/cDP2Y+r6EAqnlOmqw7zJGgAldjooG3J3MqVZlDxkHANRCSlQcBBx+WdrLdcx7'
MOVIE += 'WJYCHsP0kLLrb4bHAmSwlwC6biNuN3ILb+m7wpfGQMJPF6q2F1Vv2/SwmhiIFpTk'
MOVIE += '0KVvLxqkOUdpskIQV040E+xUq0Q64UisnGO+O21mf2ku7EpvdUIbev4PvWev4cR8'
MOVIE += 'XQGRJLIko0nKyZVa0zGqoH7D5nepT4AhJbQufbQwjHyb1VLBZtDCdaJEguN32KEP'
MOVIE += 'nqfs71T+pQQ2oVb4ZUTGjN3ZziXQ57D/kTt+gaSpgdD8j8JaXrp5TkpO42FSR0Yb'
MOVIE += '2oVp96A2Q5Irw142khydvuAL5Z11emLVSFKCIt50IL9N1nqZik4BMKKpDycCVkjL'
MOVIE += 'i/oxROJtWyhN019GdLW7jBdmEMsstglHs6ecFFH7bj/0OByGyEJDB+5kj92jzf2D'
MOVIE += 'OvW4dY9JH8KxmRok6Qjw0nMcNBdOaUAYQH4rMF4U+KlyGVaED9AM+NW6y8GkzKJJ'
MOVIE += '6jsitLW1kpa0y5iEFP8UOhXnrjr5FXoQwBy4+kiGn0E60ZQe8AtvLeyTahsXMWfS'
MOVIE += 'lzKaCrvHOQgTokoKUS9CkopNnPECyLtuFUbLaitJY8JtwEDoDV7NU38jCrTYub+6'
MOVIE += 'MYh0fB9u0R389UQ6wM2STFBnVCMJ/ew7luR2iMVOlV85y/TNHvmztedy3l0pLXae'
MOVIE += 'MXBjfop6zW7Y1GPgFM8LKecfAeTz5QTkXRgf3BeYg43WKqX8kpPVFwoURYywyH0J'
MOVIE += 'DEPgRz86L3UnW1uNXvBvAxAaYtwd95+7r68BDAezJJ0ILYCUGddW8ViG9RcCryLY'
MOVIE += 'ewlEVoTkgyTbzoL6vusIuoEnpGLajZIEMx3Uj0hgkyFmvX4nOYSjGKKJCkZizJpH'
MOVIE += 'QcoH4seDUl3/lgCFq/EvpGxofpExG4R29TC2Q4Ewx0TecadgMBSNYK9BMKzQmOVw'
MOVIE += 'bInrJctBpeMwjIbIwuARmmlElgI/y8K6h2Pzg6dLXd/Kn785SSH/jv6oTKr8Kuj7'
MOVIE += 'dc3Ol5cTQ9pV4UkPQzN+YIJ10gQa0AJ/koKKYQAEMivIspGr0Jdyz1/nNOsXfnas'
MOVIE += 'DLqitly/Bn5vNFb4CFOGJvPC8dMjfe4M5oFXR4DAUQoTy6RPSDfvHdh829ccVVK7'
MOVIE += '3/t8laqO0YzGXoDhlczXUeTBdGUqvA9WXvlXafHXKhk18XWfpOT4NJdfWMDi2wOh'
MOVIE += 'vrwLO/xA9Je8a/67RtgeroJJlqQAAw2XTEcA8BgJNGxltmbMifynYtUaiQruwbIO'
MOVIE += 'YCSyzICeLMj00fnMw2fke41JLz54X6snWwlKvQGJbc5DSebRJK4QlbFQn0doUsYb'
MOVIE += 'PJ5gM79R0D80p10PYh9NNCm4JWRSKeKQYrTZ+Ps996Nl/LXkuX/Z8YmL46I/4cdE'
MOVIE += '1mE3/Mc86T98plO4AAgMlG3nkW8hf8cQyCa07D8zMqFOopFUxjskzrHnoBFcfITX'
MOVIE += 'RxuW7fFcBhFyDQgrSMqafR6oSxJaRKpqmfi9gDwjfIVwWqGjpk8ATTZ/0Woi49Zw'
MOVIE += 'o65t3WYgt+NXxU30KyWbpF2Lv6BQ8m3OS0/O0DeEjWk60JIHv8hMfdNlGKzpMeCT'
MOVIE += '8HQwBtqTs0O8y4jaAWhe1D+CdFdZ/zpLEIiE157O7Bp7N6V8hdNakCAwA/JS6VoS'
MOVIE += 'nclyIDw/0o5h/rldOGaIOoWVLmWIuhJQNBllXc3w9it5xKhTVwzJ6+gLqaHG+fNy'
MOVIE += 'xtdOjBo8xne/kTBg53SxdZY3qUNSH2qHZG8Hvo8jUsV4JHG9ldtS3yUW6NkUvvsm'
MOVIE += 'dZfidXeOJoHj+DOsWeeR+KKvgYEOpD4cncefYBOnAL8dPIsdWeu5kecD6r9r8e1f'
MOVIE += 'j8aK25w7TH/TjLkhxeMYGHhbCZzHlPPFvTWz4f/XrwymnXglb0jNxmLP0JM8kATz'
MOVIE += 'HqOOgntsDU0zAH2q+LPkBfxu+Tsin/eVzH0RaUoWmn7D3ZfQs77a+4BFqayfTe6H'
MOVIE += 'wPyXEaJtgclfFi4/Zl59GphjKY37m+ZI2zqH+DH/OgqMGCIKREMEHO6Jimuo10B1'
MOVIE += 'Cjzkx2V2hQck1uVPM+Yyfg6M7SUO75FF5CvClAbfRs0Y2K7hP6QcBT1WiySnOPf4'
MOVIE += 'ogU5AgMPAQKHOyufo1cHo8j9nq7dVX18nhn2IOwq/0vDm0k2/NE9MvmnimWDvbSD'
MOVIE += 'yzWlW09fdT8kfgMiW3+T9eHdXofvAHdQ1dbnv8/7xEdZlMyGozwIkRVGnMPJr9ff'
MOVIE += 'Rv1dfMSKLt0me7Odqq9FWDDQ4bjV6Ugq9FQxxk8RtL2Rz7Qr9i/syd/Zol7Jn1z4'
MOVIE += 'TqV774b3xpz2Byv3JewO3HsXBitzNr7UmdTsjjgdMj07ePTsE1nUfTM1SQkjoOep'
MOVIE += 'ALOigN0264UF1J/5+OmvsV/XsMpym+knHEZjry7H8xPd0lnO+dMUj18xG+Zvxyxu'
MOVIE += 'ObE5FFHvlXOeIXEKfwc+lvaVffkitjD0phd/8Cvq9X4L8yPcMOWm3dcesh5gye0y'
MOVIE += 'nuVed5Tn2evDX9sXAUugQEzjG7YlqMTXQbYLMvtv2J6Nt5UFe/ulY3ufuV98z/yx'
MOVIE += '/mn0XEwOJNr7XecBPstbReJhTzgSX3/syv4/RfKIt5+qAar3ZxPLzyAWqbFn+oS2'
MOVIE += 'v57fSfLbfydHn3Y63vt4/v7SDtB8/vatKGgAsJFtf3MpOmVkf1jw7G3A85tXD8iI'
MOVIE += '0Kefd44F3UgRQBLjsj/vnx/tEJwDMT9EmP/+d8fsbHvz/0OZ3rvf/l+U6df/gzIN'
MOVIE += 'I2DUbNsRUtcQoAJkIDEqACKgJuRekJjEhkj2QV7Mg9ijkSpJjFodDpXOU7CDBGly'
MOVIE += 'NMGDttsZ8A/t3MaH0kEnW4liVLOFbZHfGLW76heqZJ9KmPQv5y/VGVZpl2qvHAto'
MOVIE += '+scRdFp1Nz1snHVzDIwhKr5Hmc6WWVk3+jYYVO9liapJPRSyDc8/7o5pFu5wKQax'
MOVIE += 'MMj3Vu+OJJBQFoGdlVXSBLgpkBnIoTgSuLS2anZvp3t0Yivv0j6BXkwilC/f4dO7'
MOVIE += 'z7MRmiE3ELVjQ8OiXufTbd/l7cGXuGj+MQhvbpOedeksxVykl4luVXNN6ZufOR9e'
MOVIE += 'BX5eHSwOe/nfW6wU+Z3Qbd/A44yyUKbkyj1xKT9BThoLi8cdKtSfvzMoysh2cZMT'
MOVIE += 'qZkCoP+68j74Keopp3K8vRL5gB1QQ1Qo6Ch90g1C8I1p8xXDcrYCad0KWLnm9fLN'
MOVIE += 'Q9aGOGlta9dj84UiBEfy7TEEkmXPpMviF50IJJD/uaBBMhiVkgMPF00eAiooSEVI'
MOVIE += 'HAC5RUhTPopCRFMgR3VBFTE2527pAjRJE1sCw4zsieFDFrDKAnYnJzYrnv4aJ5sP'
MOVIE += 'AfhVdiuRD6vCpZiP6xzdtLM4lPl4qOx1GKt/1WWOpYTqikJmAzZViC8/pRsOANkT'
MOVIE += 'RcfOHIk5TUJ5+YylBp0MCnzw3k0JVvtm1QY2uN0h8tgeNY7llWys/HZKebyI2A7X'
MOVIE += 'EuJr1hwiHJ1g9MA5ALMFH4s0v9gnudIkoSDhJYf6JFSaNKjFihKIjGsO43OSpXkJ'
MOVIE += 'GdWsssO45ieMHRPalVeIBRvO2I6KLhWpV9/c9DPkstcVjCUmrliurXLD3rs+TO4T'
MOVIE += 'yJ4RyRPIrhMRP+f1aH/vZkPByqYbg2Ond49UdYHk+ENrtyiop+SfwjsnUXh+j8/7'
MOVIE += 'jocXU15/PeR/JDbk08E7IPsnKshU6vMZMZcrye1hCz73jFNyP3LJ0R7DZHLJ9TUg'
MOVIE += 'OmDChjKnjDvdArdAbktUzEw/o5+DxoqSQbV5/jEuWhmIremZKvwSoDafN5q8y5p5'
MOVIE += 'H2kNdSr4Q09Cgut2GrmyDuroTVl+52PcvU/t3hKyURCvqnH4/h9raAb8ijLIp3ye'
MOVIE += 'vfhj/dcYqbdY65VJrleAj7Linct2K7tAg4faIesTiSgbQzCXlWPmKYHFqnVQ6+03'
MOVIE += '9Wej7apoZZlfRpIBydYfPi+qvv8ZnF2WrRdeRX8d2E1MmXqm9J4tWSDj2pp60b30'
MOVIE += 'WyJvv2kVEW/N1Xbw8A8Vq7OqiXDGlbRfzDkW5xiYbjmIdgLth/qKlT5ZT6eA11TN'
MOVIE += 'V0Ws6TAZ9EgR2Omy8dh2EMSu17yMJNeQucjA/69MJdkKVkXf7G9vpk7eZlwAonvH'
MOVIE += 'oy4i2X4vHJ0L+249znUXHE6SI+5FSZ69Dmg3x+0rXSQaqs6Q74GBVFvq0ZX9BCgK'
MOVIE += '1kTzNtZoh5xCb9Pd4ipH5ae4htKFazW2q752mSevtTllHVNskWB7Y09CSyp3Qs3M'
MOVIE += 'OJPJidihTWVC2+v3yEkLPLuscIkh1cvMjK11oUAAR5yhf7DFvvG99vzV6WOKFBk6'
MOVIE += '9nsnPVbU0ELo1MYHhg2X15ZtlZSTKHWRLCPYSwxMFigXKyTJyaPvy0aLzz72CY+T'
MOVIE += '3hVgmBlWtGAv8HPiJetkYWYkGxMfb2a+A182+bfo2lbWRDNd3ujVDwS1JyJTA0ON'
MOVIE += 'fF8roRx8RokOBca84bovBGLuj0IbyHgsAU/Qh+6OTaqwhiqPp9aDvjulTz4Fua/F'
MOVIE += 'IZq9oflCbaGw7DpBjJN+ViMCy0nEO1TTFq9XtsVB1b6uJsKxmyT8LKuKbvTD/Lwn'
MOVIE += 'tfk6m/gyDC/AgpXYPEH46QJSnQ9pRHS5vuSPHnm42KZE6OLPZ5U1gtBmezV/Xx2u'
MOVIE += 'KI7aY5n3h5D740DkE43mgjgsoyqQ5DlSVa0wHybOUZ4F7jfVcHamfJEwnPDOQ63e'
MOVIE += 'jpzQ6EoZ7juSanBilB72TI1mhEfdI2c3SX9rmHoZoS64Rye8txwlncAzLiK7m1B8'
MOVIE += 'eFlShWjkDbRQdQ5NSEjjO+QC1ROdj2oWTiLLwawF0Vpm01Ztsb7dphnR7HflWPL7'
MOVIE += 'irJFfGzP9b3xwbMLMN5aBJVdBpf4o4RJTlKlVNVeNp5dUzoBeiCBRMM3Xo4cNReJ'
MOVIE += 'obEH9EF1nfw1woTtDdYT/rnflEv2AtuX1VPxFCbnY3mp3LjtJCgspqrcfH7xVwM9'
MOVIE += 'au/ZTDjyfxkfPirqGF9WoB/4U9runVQzP7s4F7dSShm6N5iLR5X+QpMrnvZnuqt/'
MOVIE += 'OUBLGhFQzAkJNGj6ojBeOtd/l+qtKdtFvtQ1nfMEJEay6T7jHfuP+XsBJ3mb7/2f'
MOVIE += 'm7oH1/WchMxV0Y+jih+7KItTDKIcu2Ky8f6btT2z+mTiYZQwLD6lO4mJTnzH3WVt'
MOVIE += 'WkWxouDuXySSt8W7dxdXonaUIJiZ3J/T8ya8/9EL0XgjbwU3gPuKcDoZ1IF6RumV'
MOVIE += 'qiQFq/R8VqwAooapZpIDfWqLhTtHmP/b/vUm56D8sJmiBzkuHveKQMRa0u5JVSyK'
MOVIE += '+cnJzo6xYH9Cp5Ik6391G9D3Una1qcEzfVMWbmDaSU11gaioaQeueQ6VVFW2jOgP'
MOVIE += 'bLILnx1jIC3UshYCG74vC0affPxj53oLclVv1zJQNko3KV1YagxWZfUTOVlAsFM7'
MOVIE += 'q3/ljeX6+jJmjDyJwaK5TxDOTv/pmYHzeuu3FOfbQD8YLCxquAF3EScXuauPAMn8'
MOVIE += 'bCd7esQuBpbGAW+ttSCQ32S5+sSqL5j01Ot3unPuKnA+J5meAjccVMn+j9jwphuU'
MOVIE += '2naTGMYn8/dDtqvah6lF/4sVkTWarmwPD8XJVFlkuSWxrhrNVSqx8WJeldJydj5s'
MOVIE += '+PshVrhZnj/87ykZ2Z8R6rQLVlObTwy04gBTOBSUHcnRm/rnQ7HW5LXpBXVbn6Rt'
MOVIE += '4e7HoQhaMqTP7488y8IjuVode5nNItqRrONsH1e6GYiEFI1IRm4Xqb43iS3jlZ0u'
MOVIE += '+5WeloBfH40phiZkP927mddNZ8ABxRN+oFLugb9d9EDEwDYupV7Oy+4bIYmwDNUz'
MOVIE += 'D6hWbSYZ5/e4l4/5t+irWK9MIez0r9CJInYH9yh41xcNzTFGKjoCLlsGcsWvAu5e'
MOVIE += '5v3+Xe/md1XNPXgcX+4vmODIgph/Bzz5/jkR9YRUhQvGXrmzmaeKsyR3ddBho+OM'
MOVIE += '9iQ9FDzEdxWTgideELWwhstlCj2lprk8pOpwILJSIjoxIVox1HhnSODl8hQBYuuA'
MOVIE += 'E7fO+xIgKCbKH4eOP/70+fGLtZCj/GekUhFnGlAbHJQoPuKNOYvgbgAYj+J9tg8F'
MOVIE += 'FmCECjPsek6eGUpfE/YdQMykDI++cPlKTW8Fwn7IojwYV6Sup8q4iF1XIxqCW0w6'
MOVIE += 'mDzjjPIMZu3G8Y0v+7IbEY+j3QWcuPV/RFm9ChGVjhavj3f6DNmHP4fvRN9CwXNc'
MOVIE += '8BikJJCCBWTMobpqrXeXBeAEeIayE76r4Cn0h/lkkOU7wKrcuFoAftXKUlUcRLa9'
MOVIE += 'jI7KRFxcRPNrBAX+cR4TBgUXsrGsPOcSVkb1zOAa4kTx+BoJ//pubixr9JOCZ1Xv'
MOVIE += '4u2lIDzI54rmT+K5JKcOA/7iA0gyni/sJzDWGY2vCb6oZmhEkcXvECS2EYwDiLlW'
MOVIE += 'KH38YS1oknE4/jOci1MXZRsqqeWnuhQlce5F0hA5VzOG+F8A8bOHxCsXBKor2C+r'
MOVIE += 'lq+RMtU4pl13e2kuZpKrDHghekQ6k4ogtD4/tIOafO7+7+gFORctCxvA9zUKXwOP'
MOVIE += 'gwr1cLM3tZod1orkacURCeOrP0MTtMwTPt1J47ubdDngovlRK+wV8/RamvrkKtZJ'
MOVIE += 'mniMgj4Lrum1IBfX5f6uXFPIKYS4wTuKPNOcLpO6MNcJP1QfADVEk+5jQNhQnktH'
MOVIE += 'IFIDjpr3SNF0gdEAMoBAhhCqMlWyCgBRG5JwbdQlHsk8CBcTaXj4fQf/KY5Y+jhN'
MOVIE += '1lPf+5DKiyLHVOT+cJGkX8BaM+Qn0YR9lA8e7aLUg1Xz5pONtfyng3MrE3OtLIvG'
MOVIE += 'jnLrLSFj5s8vyYEq4zAGAgAKmfV6RwahhiznYfiOIsgxZDiyyB4EED1+5/IMTdyC'
MOVIE += 'Irj3E+L5IclvInReT7ibXRAzUnAPHS9uw/hJGyY4EP7G4/ZZYFPmsNq+o80NCZeo'
MOVIE += 'elxG5FJE4p4i4RFRf5x7XzRDoPKmDgVUJPEFFgCvNFzKLuQZfjFTwck0RMgG2ggi'
MOVIE += 'AbDiHcKHmHx1csImXNraaEnWOiUkCZYAII7CZEkDbaXIyTTCLG2USo1YiZ9xWLCt'
MOVIE += '8twrkhcyH9SUowrcUUmGmhSfeBRivC3yrY4Kq2DVZfb4AWcN8Yh2cn0Ka+K2F3Zi'
MOVIE += 'vgC0ZNdvlkQe8tuMVFkRshx/ogQUwRvufEqvAmkRMp823i80+PxBVE1Vbgq8lYZY'
MOVIE += 'guYOiUmM2zxG5xEXgRyH5QuUZspSTmKwd4m7vG511dFk1Vh9GX1FxB9X4KPPUEFW'
MOVIE += '0LK0eUpGnuAduWwfnbYosGCdw09hKKyKy3IUV64+9LDVotbthDgjo/b1fPorJPH5'
MOVIE += 'J4MXDgTR7SpBSfybQHasaplIZV1kUdWzm6rRXn8GQxaydvtiysDjIZhgxQsdeqOU'
MOVIE += 'Rsm/5RWW6wqFwch/82QP/T2qA7hQvPnWRw0vCKm7d7BVjQTmI4TIDmHXAMKnHJb9'
MOVIE += '/kzrmRnfx1AdjbRdVk2fHzfZfa6iPo7/g6ZrW/H5G8+C44NTiLN4E/j21jzRCwyz'
MOVIE += 'KqqxNc5/bwWiygDAdwAemJxitFC7kd9bbMsGPbGWKKLYgagbqfiLi+ke6DrWRixw'
MOVIE += 'QzCUwxSArZP82XrBV/TNC2qLxquZhOjeZUSsLgLUovBU6AFvCSniCMm1+qsh5FBF'
MOVIE += 'NgAYx8E574Af1UaxSMZ5gchqBy4ZdreUNxzdy3WzWmaNhJOR8HEHIk8aGntN5YUA'
MOVIE += 'QqBLYXAjm36Qd+9hh7B3bs3jiH1/0jg4gS2miVgDLxNOsLwnssgH53YXZG2Q8czm'
MOVIE += 'UZWDe+AAHbGpjzpr9HUUcghLnwG6qdB6CEtQpUP+YzoG9mqqx12KU2G26a+4Hhpp'
MOVIE += 'cAcQ0YebxESLv0Bq9ohqEqhwB2nGd25mKH5SfV6ZS6hBqnuBF1GuEoomjTgNwV7A'
MOVIE += 'iJFIQH3vyzGAuydcnYacPKN3vIOog5alyUioVI4vhzDyoSEIcRfGw/jLw7ZDNi9W'
MOVIE += '2GtUlg3ROrTD8+qCT+AA5r9b2tHE1uP2GpIfIsHmTDfyWiUDDwsnkHWBSTbl6jpA'
MOVIE += 'RpI8UtwENWAUKXAgyKla9XXv+pOgiq5B20pHf/AbNFv3ujeGQrRWtUr9uOnNarx6'
MOVIE += 'F4p4+6R9hbay178waUS888nbF4+dbxgQt38ELI8hAB/YI8PuJRSeg+WAOZp0V64L'
MOVIE += 'D4vX+LAXia0GFvf6ypCvZ2VvfMK/xRWtZjkEFKqxEferJcJKHeJYr5MchgmX/YkX'
MOVIE += '5hvEgtlEfd52W49IFVlJN79+Zpxp6/9qhB+/mhwmOQ2x0iL1fAXHWg+SEVvfOyG8'
MOVIE += 'u8cM3+kOgi/xFxDlmclUbfNk+TqYbKMsit36kKWxTkOCScNuKhU555S471mEy3AV'
MOVIE += 'wQExIZrXb1Rem32OAnO865uWsJTBU9YlzY8gdflVFwGbkEn2OBbppaioxhNRo1wA'
MOVIE += 'TE/f00YTSIzooA68M3x8vUNk+QzkP8iBAii13NEnmQL3ZW2yW2WiFbiZe6A6l0BU'
MOVIE += 'N5wkYZ6qfplaSozmqpjN73bqgG46SHfa8nfuIxT9o513J/gB9ZOQfQz587heHH3X'
MOVIE += 'v4OiDUv6JB5QvO7g4qrHCk14HXuimONYFB85yXxoCg5gTDT5UZfqTTsj30B7MSrd'
MOVIE += 'I2HRTsRUZGu8daZVcvXxk6j31HcEUH1cIhY1OnoUYrWTexEWgPgM1yVunpPmeMDA'
MOVIE += 'y2ECUE+IYRuCecChGvAVI8xz3Y/y+KwzaDbZTX5WhEKeSiXo5Stc4cBYqJj29+H0'
MOVIE += 'inZY5j3zo2Tqd4dG89bUDv6SPucSlvwVmWWRLZwgUvelI3enOQA6kZA5SA9QsZ15'
MOVIE += 'aQZWTpiM5zNPJKTg0BJlfge0u5jHFxFgmYRTBGg9t1xQ3yXjzFggxyUYoVjQ36op'
MOVIE += 'vKTmPcn2zsLGAXiIJ3J8s1IvVxe/3S4KMLCHDtaFt6CtCKDhaDyp3qXv2qTfNNbb'
MOVIE += 'JAb/NhIHZWzZn0ow6eWpFcwwUBYvCoJiLVZ+G4U5e/IO3cVqae7iVyhUQ8tBXr4C'
MOVIE += 'f6XGylXFGEPJelCIccNGluluH9CaSOSHoNIPJrzTvNICEV9yR3r9zctTnvXYR9vA'
MOVIE += 'k5GSq8ofj4fWp8wBbMghVuzKou9zjYv1m0v8oB0oH6qaJJOeCg3kLDf6Z7j3z5+q'
MOVIE += 'IvUl6S70awVP9B/EQziVGPmiyqXRj3nYyA6hVcV4RyDZLyRRN+o/7oGpZLGRECer'
MOVIE += 'P4NvbdjxnNCjp7/3JTygVjhIyh/4dyxAgYicQgg+LkBOgxxiokR69tnfScE5fuFT'
MOVIE += 'lx3K+O/8Jn9iFsKjVGkvuAv4Byd7fky5V5qZXMIM+5JXrzcmzqxdFyj2Zj72N4zk'
MOVIE += '+K7kE5EmiT/8A91irbAuf0BWx+/Ut1MQZhkawdfWAzVapM8l7+tD+JVCqxRDL0lL'
MOVIE += 'JAEZYDImKOUueRDKt60GdOsGn02lt/M//aIUowYD532hC5pn9nCdDBD6nAfhZDig'
MOVIE += '/AtfVhnead+IiU2U5ftRMRxg8FeJfsHhqFNFpc90n//bOFjqWYGff/Lemjz9gVUb'
MOVIE += '2fPDgeddsOrWCbaFA7XePD5WEB8g0F5HMNoN6LM9kRo6MenEkypJ7v2PLiYDPvzs'
MOVIE += 'wpOUnGWWrHIErxBL/6SV4/LSg1elocG53XHo05ASUSmK+BUcMQLI4U0V//Cm56P+'
MOVIE += '+zDQuQTb+fPKpRL9TJ7yiKS7lucMlgCS+dNpn48xVhTBhsvMKpIJ5hOUSjOL307r'
MOVIE += 'FZtlyj+yN4AKdM8AeWY08B9GLEAS/6sXdnq5zXSqwvd3lXQbHzawbxrYBb+cE1Nn'
MOVIE += 'IIlrk9KfmLD1fGnM/VfI99a76Jwb6gPVm5sWfu8vcgcn/gfLdDzBCzD693AlGfMV'
MOVIE += 'uXF6od88b1uMwq0vTu90lU3MU3LQlINQcChijrmvNeEBHiBeEJ4oD2CfI6s2uPk7'
MOVIE += 'T8apSDblJfRhxDNtjuqPMlvt/uqlqDhnh/Txzc//WrkDDd79FgHtIEkP2iBOGdFh'
MOVIE += 'b/11z/et2n6pk1A0z1GQG8DX+MkXHlB4wItJhwBPyYYo74aAiVYXpKTk9swUXLT3'
MOVIE += 'lp+A9S+hpUOw5xnwSTdBKO5Qnujz39wAenwgFe4CpP2wHABvtMMSQr127lGmlHFR'
MOVIE += 'rgY04roF5RJBh9N7ail0/JLFK+SfmpPo1dI4CjOdNHV7tUuH41qWpw1e6M5WF+rk'
MOVIE += 't7rK5Fs2rlJuvHeZlCTJDfZZM/o/KNPG5ZF4yr1RwQBjsxQEn+U9ynSzO4lakOf+'
MOVIE += 'V0zn3h6aFLAM8rioO26V4TNVvbz62ZIAAq42zrZreqYNAtLWP47B1KNxXgzhDR/W'
MOVIE += 'KYtgXt9bBR0qhB1nNI+XHXCz390BKQzs1JnrwXsAAuSV84g6ldI6lHpOHcZPdTf4'
MOVIE += 'pJNN+YnF4q9HO0MatTYb3w6mbdDRpK5vtOo4yx5kQqn7GzzcznQ0fFgugSXLnGZt'
MOVIE += 'Xi2bK5GrLx3f5a2MXpFFDfJ1vBc+c+3YBzAy83bDCy4/9P/DDHWBTP2bUNTnrw1i'
MOVIE += 'ZRBaXuI3zLfshB2rFLsCo/pyX95ACMsxLJK3WBLJTW0BzdyI8+MvHLtWwZdqyYy8'
MOVIE += 'czUm2qwHed45C0aFzpIEJ9ylgY3qsicJonzKZ2URhDGkmtetjI1T/F/lX+I23RWG'
MOVIE += 'tjsevbzLmGl+ILCirPKufx6T3iHC6kJIQkRlSgQUPwQEvQR9vqCQI1xTLp/G1/lA'
MOVIE += '9GYANEiG+TMOQmLJPmfetaiqkxhD1aifOpKra/NTE2QbJfHr5ztJygRSuvhNcdKa'
MOVIE += 'RG1NUhw0vj7XH86JnIKQ9YDxGbkK2ggF+Pq0v04RHnwIuC/vJe2gzf9z2k8gvGRo'
MOVIE += 'FsH99NKZ7axEXM2K/drDzTkROI++H5AOT4aT0l8IzMlMSdCSCDu0IVW6h1VzWNRI'
MOVIE += 'vHKMNLm7r7afMA0d5ND/lhgzYUptUM83Inpz7HBkLCH64ZXNXwe5ew7oUPRXH6aX'
MOVIE += '2vz+B0kPOwQumhp+/ezPcBSkmyd6gEggCW2GtY0Rb3mCvR0sPbQUkzK8VFQ6DlFe'
MOVIE += 'CffUMHxNTDOIgmeI5QFNaVjFw5P2OrpE5eEwL9qK7bv8/z5liJwgXDRLPZejyRRD'
MOVIE += '+g8SOh43EC+GWkySqsPxp1rGs40/pZTOKxM9nWADAJ0Kp4IESWEyTxoeLGrTYBzT'
MOVIE += 'rUYvCCnfz1AKwxPoAKQ3zDa8LmtJ5W5njKZJmQ/mDZVaRoAYwGiNTuSVJ41C5c2P'
MOVIE += '/4z38muMg7XwCl0HuA68owMWtWQ74vsZG7qZzgGrlJV88QSXJ6HPmni/MydjxIut'
MOVIE += 'bNz64zS8gguXqqseVJK/2rqx/VcQ1MLY9YhPdHLxVxa5OkyJPYl9efDlcPaaqCzz'
MOVIE += '4z/2VpJ1kyCOrA7aM+KCTN2VI87ahMlztz3cvQKLG8dffJMUpkQmfexrxPf++0no'
MOVIE += 'nVQaOQAvhoCutLFuUP5YLXb6xu7fuijXeyCMxG+q7IajupwSxMNbEa0EWc3tdNk1'
MOVIE += 'eBSnjUnQzOnHCpww9xVqAsmuVTeY3DmFA5CQodBspFGbLM2oQzPyEGgxq80Y9H0n'
MOVIE += 'R3kCMFOOvWc+s37WlIyfqM8QkLggYtJV51aUcCX13somKdyDuo8Zxqdo5u/CalgF'
MOVIE += 'oAERcFTlXUZ4JYDiIjH7DKaGYmVv5m3DVrdV6rVdy7H5Gj2xvcJd6gL4H2Jx5ohi'
MOVIE += 'CkpSlEIpuVv6k4pCEoJ20Y6UFNIzkzxbGLnGZLlSxjN57cPlPf7XjPyggWpdBy6V'
MOVIE += 'vPLJS0Wqgnf8jYmj2DuYixFv1j4HmYWWTl4UZUmGEy+9RTa/tj+dFdU2z+t6yfDG'
MOVIE += 'FjBSGphTn0UtmlaB96Qdwx03mcOIBACDObiMA1GCRLA0+OdpIuI4y3zfhYY4qFkJ'
MOVIE += 'q3Mh1ftwJ1KNtvp/FKguZfKdKvZYtBY3AEth6ABioSCXZDBLV0eT0M95xAlERL+0'
MOVIE += 'nHfC6JfQcyka6Qc9i8om3S9dj6GacolUb9Bx9TIp1dauj/jsa1y0eI9Wj2/frwEK'
MOVIE += 'se9eJ/Rxessc5SW241hyTsrfXkKr9F29rT+eJMpQY5pCCsHFq5rcstSAmtujeJbb'
MOVIE += 'm4c4GtW2tOBjn15P8rStK7shfzVxQizB2DDpnQn6I4eRXqZ+KbGWTLG/t/sHerN6'
MOVIE += 'P/doe9738FojYhocReHm4ug7Hqv8CSiXf8gus+tNQs4DiFv3SwXC1/SAigeMu7rZ'
MOVIE += 'YAAoZXztWRseTU/AcpW2KlkE1c+anxMkmjbxwuaMVYiJ+3+/L44SXmi3d4j3NXNz'
MOVIE += '1m/sPDYf1IUKmurN95DkcZPUDQ7Nb0oYbbu9i8SSA29DF5px0lc8/Mk41NoTh7rD'
MOVIE += 'nxl/5bVtMOGaMMpyln8Ja+T2lzzE7hYjMbnnPvVNxfU/uijGeMZRSFYJsL75gPIB'
MOVIE += 'x2ORJ8uzbNe4L5wHMAcJkH9JuXxE+KiMHwBoIQmI+136nqWAAEAdPkcUdqfG2K+r'
MOVIE += '6TKboFs1rOZSUWlt4cuVOcKk7zQY+r3fLWUdkYtud/nBuV1h9XNsGv010GXAjj6s'
MOVIE += 'Xa6Vgp35XIvUAoRzTooOdPvn/9D+sdPbOUY/4Nba57fUmhAZBlNImgOXRR5aElSY'
MOVIE += 'r3RIbnvoVziNTxCr4EFOnhbTPyPohScYg01xTLkJKSAULlrx2f5OoUXRWfZDYvt2'
MOVIE += 'WTq6B8xsuP2wAAP801gTGHneKdC0Mo/g4hnGBrOLpCZqQhLKI56zAyBZobt3nEZU'
MOVIE += '9YBxVp7dL1o2T5ZK8GL5zi+PDYNUV4YL1QSNHZNDTEgGcnxFZGcZOK4k4ztf+Xm1'
MOVIE += 'hjwdqNMdI9Cd17hr+1HyzumtKyna5kuWAXuUDKz1PUBxvxzuD5FTqhdf+hS/qHtv'
MOVIE += 'szfqRFFxpCLCAYRVIPcIe+iklImHZ4O/d6l1YSD8ex+XdHOzx4TsxIprqr7aXhQP'
MOVIE += '/qsNQPynTvpUl5/wTvfaGMnE8t6zq+p51BD5v51yNzI/dJ0nrqL0DS2heIeRj8eY'
MOVIE += 'oYPRN2fGKursev9pW1LeIvNvh0OFE1tfqclzuyI+/5T00jf8Qfn0vmP+ixmDR182'
MOVIE += 'NnEXwUh2iCYtfpNjOc7N+64xEMxWDhLXLCmwJiMGGasj5mjLPzE/hAlEsCYq+IBo'
MOVIE += 'KpF4KEg7D1H6H9XGAnxp1/NZbceo7ZdvfgVl3NFTDQl3D7LPK11WJU1ZPEWCv/ou'
MOVIE += 'OsbU03iK/b18jVZxytoqcP8kIcIW3nWlNf5bypZfjCifWEJCAf5A05ly/BqqNDwr'
MOVIE += '/sr793Cp/quPGsbP/9y50TQ7xIZIiBLmSqfp7fW9+ZD4n04cuyPC+ASDmIiSS4gZ'
MOVIE += 'n4iSecJNfM9oQAHAiMqBNoDwevqxCaEYXU6mEtEXFQ5lTwBRQlQfoeL78ozJNkzf'
MOVIE += 'IusIK2ChmPaBBdSpHGKR8CDfGBpf3nA7oqCjDf1CiGcfnrCKxaNb6KvYe23wTYaN'
MOVIE += 'LsnZQek9kpNiIkq1YABxzfZcjpliPo5YgKm7Hih80ejEzoE8efmgN90bC7wjdxAl'
MOVIE += 'acew86h8Tc6AJGIkp/qrNZsoerkoE0mYg3nr+hS2pmHAYYg5Co+5AapFJ7HnL1GZ'
MOVIE += 'VD5TieStVvarb6fhiZbrBetpxnAXoCvlOM/DMZ9HWKYpgcIJve+xHXWd8IsmVuX1'
MOVIE += 'elg4qjX5XqQ05vMbPFtMpl5PQ3gRjSYeF9IhVxZQHfV65egfa4uIo15I0PGSCPJS'
MOVIE += '3j5W4IEkaVcrG3thLVmBFOFR3EjgAZHG8+ICfx+gL1JNhmJkr7HftFnlBy+lVQ5x'
MOVIE += 'fmKFsxEWhhRaru/HC3i3S5cxwFOpXiHuQzm+rET+BKb8KAvqmBDnKB1niiifOIG9'
MOVIE += 'WJTzFBD2Un15d9yrTmOD9uPAcrECDTlkA2OSaHbUff0xwcvJ8kuULFHYmU+C/VEq'
MOVIE += 'U5ZJC5gXMhdR/gvw5GSAp5jKl0IwPWPyMwt6LMcEJjgnAqW+kxFrVR6r7z9RuEeS'
MOVIE += 'PZ/6ODox6YwpskrVoH20Pom7sgrdzYrF70WDw2uCYzi7XLAyA7IKLgWWfBj5EeFh'
MOVIE += 'NBixA5gUUSI6fhPvNf3bIR968eK72JQAf0KEv1AscrxeVbOxocHqCCL6AZZq+EqH'
MOVIE += 'DVpKyUdLVKy1JcCrixb+rf3+rDLtdrhDfNrBWsv9kpW6Gky2XDZ8LP9CPG++XWMg'
MOVIE += 'h5jKdMiWkZH8OgXk8RonPoWFx66hZu5G9mtHTaeSNaU0y2OzMnQ1ynULEsY1YyTe'
MOVIE += 'endW3xDPqWa9n5nb2037cq1MvB7/FNGQLssYuY9hlI5iN1R6tj+2GD7UeQG62tIh'
MOVIE += 'AD5wHyabnQTKMpawG/K1n+o5BrdaFOA5lEO04XL60XJjJfRrvPqZiPKEiZwXSfMR'
MOVIE += '/MIzWwQnpo2nKfAvW4acu/pkvQCKdWQgYuHpPD4hgn6Jg0nEBWDtovOqOU9yuKS7'
MOVIE += 'DfAOrBTaQKy+BJ+exs5UKUsAMO8xtIvf9WL9Wx9LxzhrxqiWQ/T+oD7dJgCdDDML'
MOVIE += 'GhIyMmGx+sGN80eGpMSCNKR/jQPE+0WyKLh4okjWMXjlYzk5LXc84XpnBRV/Kie7'
MOVIE += 'etPZMxSVe5uuEkFPBqY3Sogc93Rqw2OAFymAoxFWzsWNC/BzNPQtD55SeWpgVSv3'
MOVIE += 'IEzXUH/nuuujxXABrPFoeZGoW18YamL0xfAVQfoVBsRVHi2DAhFLA8rpAA9DzFjp'
MOVIE += 'MX8cAHiWY2eaXfQKLN3lC/gyhOgsuveOMYG7GPYlrTKBEfvZFDULdkn0cs1lPHAQ'
MOVIE += 'ApOPM5N+G606wZNLb9m2rG46r105pXew/PD0taAgxfuJ+d8Is9DUXO5dJHdCzBIh'
MOVIE += 'hAuJfyFgdD99lqkrBVjs4xIyQHZTjUOM80HyB90mqb7ZKnip2ojGRpHK3TBp8rf4'
MOVIE += 'ypjVuw0YVAkNUdONMb9Q2USoJmcs4rWYWvNYWiPiHDVjJ4Yb/FdS7wvRwOBhiyXd'
MOVIE += 'U4fcUCYz/3BhsvBis8YoIYcooTYGQURUIyKKFbkAnlijUgNcgpdtYTQQQwt1h47J'
MOVIE += 'BIAicErpksbmR13/CWt8DTHVqLQCsUJSt4VmLskDAJ6Wf6zikd4e1cYEJNGjwLq/'
MOVIE += 'JTZ3MD9vtuEwJbGgdPxNlf5hBqR40BKlwDky1v6KVbDiIOq1pw0PMt6q/SEMwEvr'
MOVIE += 'VJXiPS2zUVKDo/ujS4yYH9jka0VEJj+YAD653fzjs5QQm+Huzds5uB5dEG+HkPEu'
MOVIE += 'oh3VnU/xqBzz2TDw1jc+sr5Lvv1gSLg1xGlDqlB2Ll1TF04hukfIE779WRAkVmqz'
MOVIE += 'lNCz4Er4X1SeRA5xmXjqGKae3YILcW+9khIFy5gcbZOf6SxxMEvueGq7iRzkf9Lw'
MOVIE += 'pL7In8TyI3TNv0ZGc4djJ1cVQcTc2Uf56a/xfmc7KdrO34K5sShrfJBBABfFhsSn'
MOVIE += 'Qrw3HpUPGyCbHayg+xjLU65GbWiBbqFT8KUEKaX2ecBPPhCt/XjvkJJPyj5zA1WO'
MOVIE += 'oSr/NPqx9+N/fh+taZL1vWy4i/TW5qjMupUUSQXlX25Z8vxO4kOZkSmnp9AZPaXG'
MOVIE += 'WAoCNF5v29bngdhL/ji0PYB97L62q5tNsVCN9leyVd6dvIu2Sq6IsY+igmq1OzKW'
MOVIE += 'fTpo5tDlgbzR6/SsVg91Ig0ZI2YTeoPgcXi4QXpgCeJ+5nREJ10tpiMSg+UxtBD8'
MOVIE += 'V/fly4qCS+0kCs5QqfNa9dOgh7MUjXr8xQNZyfJ7Z3cD/pj/9Dr19z7t/nA+ozKD'
MOVIE += 'a8bIz2MzOGxKFbBwPRe1VQS3tNVTM6N7fP2yPKGdF0D73KkGCbkxJe4bKHlwvWd5'
MOVIE += 'trUEODAkHQU0NhhLHqRdi2sioOZ+B29OnXlTXI1WgFZc+w+VasgBC9A3dXZ+W83o'
MOVIE += 'FQomA9U9xf+M17VXOx/wWZD7mxSzQpYGNVQ7Dr0Ph3y23dYJ1rR/fDSj+czN4Y75'
MOVIE += 'nXvHQWdGgf6MQO0V+xZTAuLJLya4gPGkEU74hyABtFkgDjOqaaSw4O4amu7mluxa'
MOVIE += 'Uf/NlnYJdRSd9mALJhLrZpkYA9EI3zDrkXpYu2FWkR46i+HQjBpm36r9ORWh7EK6'
MOVIE += 'mcSd5hQ5i3OlxDwEUb374I7nTSi8Y6aMlXaqqufBYJ2/Rx9RvCrxk6FK5C1cPNQi'
MOVIE += 'IQgpTvCPhZj9+zjIz7dbs9Gl4hWqVyyA0Ap5U26sR9aX6B5JH/W03O4y0qxXABDz'
MOVIE += 'ycbRU3IkgQ5yIbsNqv2Y87Yn9DQCravb28qd2mfYxFH0aZegZv4NjYPB709xdCuZ'
MOVIE += 'wdjhceTB04dc5j6t9WtPPgLuCMNXugs8q3uXUDSODBIk9geCU6QAWAG+r+zye/1S'
MOVIE += 're9KXGy+n5pPl9R9B54dBfp+6Xj85edE2ibzI2NXRUZrp7EyhsaiHQq9vMxC+bnx'
MOVIE += 'vUlrZ3cKVFLjm+4M8SvnuKO8QaKgopPN1dOfscKfbIuebAy6feHWRaz9Ow3h/LoZ'
MOVIE += 'h4A8e2kb55RFs3lZXwxjXnBQOayJahqsN1Kg8FagvJx+3POsN/VhQYzd0aO7N21G'
MOVIE += '55602Bh9OB4H8Zof9OQuV//tn9df/53SRfvTfxpHOpwIf0kLRH/tby8e7fG3eWyT'
MOVIE += 'W1aGsKHbHU9xphOaSlgQqdUS+g/qKkdFyJAADAlgDjbuzwu4yyqPdcyAOKOG/9TI'
MOVIE += 'FPHHFLbpFv5QiPXkvqQJHGEHMljEyCHPSKjZVRVXbDYIBTFRT8Nr2u9PAsDbj/Rv'
MOVIE += 'G/gvBVnOrzMN1AsovZvwDR3wnHagoixSvtrkMv9WlYOnBM5i/L5BpQ3mZF4175hx'
MOVIE += '48a+J61+p2fA0ljEqPKA0Wv6iRUFHGFRTchgPpngQLQR6Nrr/u6L5FAtJpeYHOU3'
MOVIE += '3FuDV/DTHW+qex3To7DofHFlEOYd9LrBqYTe0iHWhSfOQzNEOv170pW1xfMDPYCP'
MOVIE += 'Vb4Y5c6o6kSU0RdSjNzXrdqsMbX+0MymHj4Axo+wQIu4qYbM4OgeiSgPQgMjL+IV'
MOVIE += 'UXF3zgUxfmFymp7qzgISjig89cjvwQ9dZcOGm6stw9N/EWljBWAg/eovoQqc+6nC'
MOVIE += 'z8Js7OiSGR0aJZR7z9AqA8oY+Bypd37H+4sYOaaiCl4QDy7e/iKnpyX8mEKTTl2g'
MOVIE += 'ppnXvD6G4VdCcPr3DPdfmWG+1c+8sh9S0KKw5L3Rog5rttEFI3/TGh2cIk+SKvRo'
MOVIE += 'XFjaBucDOTxnr8YevxUJrwFwVMZj2BAg0QSIc3jMjsuNxgnLkDI5sIgKiC9WK9+e'
MOVIE += '2nbT9N77W0QIwY3cWo/+OlcZx78IzkJXdu69OqGBr4jgSPrj/sni7ElW1xdXg3Vj'
MOVIE += '7sKnL9lNHU8pu+EAMBJfoB50Jy+Np4WCSBYMJkncRoefR2FidS5YtqQTR4tOk9p4'
MOVIE += 'pR9py0jFNlWrz7zXPC2QwH9FxHkZ8R4fyzHvoUzzJ+xNLjdpxa83hSVDf0qEiQd6'
MOVIE += 'n0yf1zeVErcIgQTgYB5UlAYqJhKQoNiGHuTzuEAOxxAqxXodXewOJ1CQSF4FJVAM'
MOVIE += 'Rv84+xgdR7DU7DYXmSng+Y1jKofPaCpL7dRVUDOWMLNRa4pqzqYv+NLmcImio3wi'
MOVIE += 'y3eT4/io3fl1nqhvv7gmMQWdou4Phx98q81WrwK/nPzgX2+z0ytAsOrb9PF5tRh6'
MOVIE += 'fghNUPTbglEVsD9s5SYHAKgADkOU7Ab6+JTMKbVK/w0mqd3d8g4Ep8UOkqRJr7yW'
MOVIE += 'AhAKGI4mBBj7aZEL/FaVKPG4ET9ZhqpYbnHAKhpT3ygqM/R9kzzf6lAeTtFa4tI3'
MOVIE += 'kX188q2PuN6wUj2TL2RGPJO0yWzM+KXfX9mf5BZaGMpXLi3WfIY/oYbNlbxVPPm/'
MOVIE += 'IwLOn6FYqRPXaBPY1kWKfuovzLBgYpMpDT12aSgNE7im0I1a1YTRJI3fCKMJhSwy'
MOVIE += 'HuB8ohJYIEoehgq/xFWKffsSpSvFXs8uFutKfsxZ0lf4y7FsqMbEqWX8lbdzmmnR'
MOVIE += '8deKqYL+K/YMdChqmGAnBZ1n6Rn7y/wx5EICP+IqwIE9N+rxAi4iKWC+wPmXxNiQ'
MOVIE += '3VNXybtRuA2aFenuhJDejKbg4iDkzAGIufOH9CgnFhOJHMXHFhuKGvDAFdcNfZhW'
MOVIE += '1Nkq+y/VdQTfpIIYk0fp4m0Mp5hGtp4kepwMpytFIHNJtY4cogmYCvjM6soaT8zq'
MOVIE += 'HkS8oqGxcEDiAN3/VnIivm885MxFITM47Y0gh5yO2MftZYr70uTM1jMdElYqmLxa'
MOVIE += 'Vq82zc53QUXnorDux8xU2gLpmh3TYtV63nCBq3AE2+vEfgaKAeEhiJb/D9LPewEr'
MOVIE += 'pkUpgeJujVo0mzX0+0xFhwFt9YIY1EUjicm7j+5mHupzwG5ZrY3U1yiKoQgYerLp'
MOVIE += 'SZQSng+QJtKmwOa5Qx8t8A+q/e4MMxfHbcWCpQgOekU5uxQvrs1pTMxX6DGVcq/o'
MOVIE += 'yiET0WDKqpiFhYR7vD7nIvxaKayk/Ggwc8878Y3KJb9z0HkuK7UZaXqGKo1nVWko'
MOVIE += 'DZHc7c8QzbKQw3CaNW38VksrOGKCVWyPf1IDrrxuy9dWgga5DG81z5iaVqgpSnwq'
MOVIE += '6fQsHzWeESm0GVZnzB837lp4drWbxFGsq/xYqX2STeKUy+hp5cpD2qxuf0GaXyZr'
MOVIE += 'tz8ZepzDujB8I2VpqNsL15GnkRbcJf5mWfo411/bUQR4h5E0xNu/nrCDGYYm9ZkC'
MOVIE += 'wkEM4tvh7lY70QYqdBWKRjwDgGyy8qfwIM2lcg0ED0O8ze6dRjGhL4fxshV3pRu8'
MOVIE += 'zcu82Hb1POT1JwsQTz/4wxNNpBIT6/twmmYk3qtK+UYeMkGEBRkwcJ5KuVlXZ23E'
MOVIE += 'Lj80M9oeeAqLdCakX6V8w+bP6ibJaG+9vEf2AMBncFVgzoPXoUjwMZ31gS6TMuxH'
MOVIE += 'eRrEENPLWw60F82GbPoZk1xtnm9nDzXb+CfbVTts1IoO4M9PaUHKie0G5lkAqugH'
MOVIE += 'R0oVJv/urcoTHXgT5xHvpoIAT4mV0NKM9tSrqkUkLbWBpI7RfXFHLfEAPmXyingF'
MOVIE += 'cw0cl+ylZLJXjm6w00s+fT6ZqQ1VY2WtAuGsjhwn1iHwmTlA6pyN0BsCIC5XFZCO'
MOVIE += 'iLqD2yUMM3aaAoTI2UTzZQAyt9cajLJAlqeIai8QlMhidJfiM4iJwp48SRGVmkHx'
MOVIE += 'm4WT31NrXSKJWmyBI1n6mBLxlCSnojnTRLdhLsRtDMLBU5UNx8TVwNQV+lUB+IcE'
MOVIE += 'GsrlrPg0CWh7OwIM3oVgPlgTpxj1eMRRiMDtegKfoTGRfrV5D3EFVrsr36hd+KtM'
MOVIE += 'RZGqebOaq+fbk0yz1QzlHyCY20wMotvvWpZ5/IoqdDG4lKLZLNt8g0p4P+CJTMIw'
MOVIE += 'C0JE4JhAvT4FOco44A9BIKgsIvuIXBG7OtysXWgi1/rOuZjYeOPOZ0iSMb4UVgIH'
MOVIE += 'HvIiKnIo37haitaVIZvk3SmcUkPbOMumw4hHUFUoqir7HqLJI5J7LOTFt26chWaQ'
MOVIE += 'PiACoXpyHliMNwDQaAibA5A0obyDbQf3gH0eQCNrnk8uDcqp1gaMyniCoRRc5p39'
MOVIE += 'Aq8S4kjsUmGcKY5Upjkrzc0yoxIZ3xIsBiTZDLJPbZ4arfnRVFJEmJUH2JxovR0P'
MOVIE += 'RkU/PafhLNDmliDAS173NNBa3fiynQ1uj2EFAzDSo77Igno9X5WH0zTcXZJKFOQQ'
MOVIE += 'o1FtazVtHqpKTfrUNCDx2uKrjB8F1WIAhE1uSVfxtvz5YJZOQ+AhbelxjFAMPwzE'
MOVIE += '0JbSz8Vwj3Cb/kgSzwtCoVWcB6hi7Tl3AF2L7+4e08Vvjw+liNmV2vAcBiRUclRS'
MOVIE += '003xHNGzva10qM9oSOSwxfeZ3C7Poe6Gz3FxHmS3Pm7hUQee6bILuPYKDuda0mPa'
MOVIE += '7l2aSf3zRn51YQghv8Ztb4f8n2rhAD/r56k7H6MziZbL/WmcH+g6USwix1NntclX'
MOVIE += 'ASOIl46azyVALqwvIfRQ/QbtzIGHnMLRkweR3yREV3N48Sc1hqo8ERRYvLm9q2H6'
MOVIE += '7G2WASRoNvDVvY7Oh3QeFQ9P36DUOBKFkLaRAZWUBn3HHX8zTsU9Hv3thh6I4c9o'
MOVIE += 'cC+ZBdP4koirmd6b5tftqwq1e1e9odNXl7vJ/pclbsJj68miJYNX1AsmIL4zbB8Z'
MOVIE += '7niiXzhCHpgBRrQVf5S5ADUdE7yoKa9oqAoppPEK975qDdVTzglactglVJI3qYLJ'
MOVIE += 'hHrBOjJ7RT+EdGVAu6pS1zw/NW3qv+kJej7apqNC67uV5k9oDEjLZMAoPrnHu+rz'
MOVIE += 'PLISiiX3aMOgLdFST7++Dpi1opl7Pxr7/Wky63ceDk79NetHEvUZUKl9/mcf/ONV'
MOVIE += '5PdElXYq+d/YwJye8NL2ovEV/aNIHQY1pqfRDdJ2S8S9O/0G0lnr0CaSgA+zKaiL'
MOVIE += '4RDLN+s8uispTxqUkD4te0VipJ91kfg73qlB3AmsLBX+1enR0mdj3PvMXEVQbZhF'
MOVIE += 'sjWHE2UujICDzR59B1z6EfItQkub34jA1oPEfnJjlJtphoojZoThw8XNN1lDvo4C'
MOVIE += '5Bdxwde1wYZPtCm/ghepMTZFpmUA1XK84IQn/2XdvCf8oAD6TqxKe60440oyRJp5'
MOVIE += '/Wca722tPEPq5bawZrz01363iWGa1+uqEhbA7kvaC46X0aUDyvaJA6tp0kRXLifA'
MOVIE += '5Gim2x383aNxqIVaQyTYLKa0R28s5qCshzwdl4Eh8FDhI2HpI6EiVgXSI6iNqM2q'
MOVIE += 'RYYZVbEPZHLpqO0djpR+arGIyAwhVJVFdEdkeKZ3qLGYffBSMFHH0xcxPKV/yA1R'
MOVIE += 'PspsjCrc88qdvnakxrOfF0CViXZ2vPN/M7OzG+62jecBVItoMnEsHKYk5TMC9ckA'
MOVIE += 'MpfjB6MR+xOgn9ummnCCejSEmaav0MrFKM81AO2iloc2s3CyNRDJKSfYLKEMVuLg'
MOVIE += 'GSGkiWbsiv0JnVAhKCah2RuWKPZfUZbw0BY1HT4hZsXkjv6hZq1sjwpYYamS2QCL'
MOVIE += 'rDmoOpJdAcgi2e63e+rouNo+5VCIg8YowanSe2IXEFmsfLmZoSF5H2VWbP2jv7vO'
MOVIE += '/Dj+yCRpSguJ4iL+lLqjdCU4bXVN3hVsz1pkVrwefQ1cF6iOEmUcE6y3X+5i+TM2'
MOVIE += '/Rmqwpm3Dfo4IUKl9i/EiUqdlXQeQ3wGuPv7nyTP+28eH9ceo79kkmzU31ESHGE+'
MOVIE += 'rNvxWtKPUNHQkQAEQ82zU1b5gcsRqumiqspJfyuTBJN/6I2kUoEJ2D5tK+TAF1TU'
MOVIE += 'dyzElLN5UkY5Wv4TQKhUf4kSKVgW6FVF9Q4Lopm5DCluB1VR5TlSeyt2JPGB1Crj'
MOVIE += 'ozkc+3u293nBsk88hFgpm13erNgGFyZLXbhcHwltXKwc0GVSC9nWZVuAxMAi14Vw'
MOVIE += '6LwjfBXZfRTJEINmNVfzDsP1XgTd0ltLE43NvE+J9lrroEOPYbbqKFvSEUGOESEk'
MOVIE += 'CDi4rz3KIRjOzg+Jlpr7T49Gw1DTaj3lE9c1hxTE1XAP47KHJjsD8IJ2oMtl32bQ'
MOVIE += 'dMtlOHlO2qm7SognGKIIoCMAeC0SFmmVEzbTG2XOR5S8U5bksIjDp8oAUyKGCfGG'
MOVIE += 'p22ordFDKr+HrHoO2hxNMKWqnFTRHAJRgbLrIqrRmuhte5oKB4pazu19fQHLoERn'
MOVIE += 'I2kulzJnWWVW0gnA49YqalA5/hGabQZjOsPu8aYOH7XzdcIpLHL+Qg0n8EWZuEXj'
MOVIE += 'SeTB9kqtdQmBH54yMmMEDkmYEZgurD+YJ697VU80gKwLJK2y//gOVZDjb2msM5Fs'
MOVIE += 'a1mnrVZqEEnyNcXZ4GY/rLKK+AJANg8gmwCQaHIlSw7RNiux5Qzx9nNHvuHG/7EN'
MOVIE += 'S2GUTrEGHlG1749FiKNJJoaw/7gx43e6tCWTImweUYclxKvl0UV4CqPgkbEDmzIW'
MOVIE += 'nlwXPs29jD5I5uN6R74KcGq9UfjnxDceSVPo8EUc6QXG5R+GDhDF0Twk6RNNsMOD'
MOVIE += 'CDFK+/npne08fgqAIGUEzIgDXkGJ4ePP+OKgzRtZkjkkJAk/JfSpeTy8F5C55p6s'
MOVIE += 'CyoK8k5xN8Mo3Whj6d38NEi95Ic4CkttgkN/ZD4nx0iCnbbx/l7RNl+JpBLTvCZl'
MOVIE += '19FdxWd8n4oX/3hrUiuAOYxAVQD79b6xP+c0GkB8c5glStrNx5tMoEoOZFQP4Ki7'
MOVIE += 'KeCbUWEf4AAqqXA37ySoW4kuDycMpNl28zkmlf3VmuIyta2WuKNtLeN5nFZJtzxE'
MOVIE += 'N8FLilQi69qmxiv/lgJYC/nYRnG6nrhQUbTQKg1ldXn4WM2rOmkcPbrBPxONtAFx'
MOVIE += '+tu/UqQQVy6rYI3Wl3wn82VYZF25kQLxmh7hiAceGPcOmDix/7sitMX/ppbnXn1A'
MOVIE += 'yzNEWu/s+vM/MpsKAgHdLzWAB3wC5eN1kinF9vNNTZPziuWcYx2FWXsjxHhJSKSy'
MOVIE += 'cclc7WY5u9LiicMwad6ZUMEXfbxosWvOaWO90cHmo1S7gf6c87O0wT0fl8aq5J8A'
MOVIE += 'ijM0WT27XBI3xfWL0y+e8udli8oFiEzMEgVGUcmHWUarw9B35ZutiBap0nw0j8sw'
MOVIE += 'V4ZZtPkd754STFx5WHD5VGSL3HErqn/YZTr06PV481/ehxJIfCNxi9QdX8ObL/9l'
MOVIE += 'cVOZuyXncX/V5qKAYc/HPkM9bfaijMplZ0xv5+hAaBIqvOdXai26vqSW3geVa8/r'
MOVIE += 'oTS9q/yMRorzmrOR9+hh78WPYH7GaNXVCa5mpRM1+mA/ykczwx/enN+SawilZHMi'
MOVIE += 'NFIKsnlYgQBwWxIpiqyNXY6mDXh67nL+hfvfl0RtLrLeT1AMjgBe7vYsmo9LwMPN'
MOVIE += 'NjMDQ8Kh9GKYxGuVEFRvY4IgtU94SB6DP+sqHCGh0x2opNibz9MLQt2WkIDI5xAf'
MOVIE += 'SWkhCvXKPF3KfoIuXMHKvhkvUMR3KkGI6E2/Ks17h2HDvek3TTPbc29wOVeQNgAl'
MOVIE += 'CsTtD3pVT/WzJXy7yWWcl+wWIwUpbwjHSfW6LypbWEaiiVysKLacoQpfR8oYYInp'
MOVIE += 'RMLHKvc1dU8BkduNXwrZ0ROWv3z9DpiiT0AV/t0xOsTRIogRVNv0oZbzis2sg377'
MOVIE += '1lxLoK9T6kQsDTuQNqydtrMqmW3o/kykvfWR7T8qOgcIPN8jg7vSf2XfXNhmIDMn'
MOVIE += 'WseFKMUzsac7WqZ0HH4Winxvh0xrMfJjeYuidVBinMl/+lSfdJqu9BLEqUpV7unF'
MOVIE += 'czWMYotGudgto8GCsGhbq2+cT7Y/+4puhXZk2bbbH+zx5N+J0j4RKfEDkmkP090C'
MOVIE += 'ztUrivXdqPuZofnaxueBet1oOo9krt4lGs8RtOK5gz9xERCnyMErJiVWnBnNujMp'
MOVIE += '+flC/joa2Qzi01QR8ZgSvFAmY1FlUbUSHo3mqBglj1d9XS3G8dLrVk9kZrg1GRkN'
MOVIE += 'vkx+MNlJsyQGfHKvYQcixTXYCoaSZP3nQDUuP9FvKgOk4Ff0pxPB11VKIyTSVDPG'
MOVIE += 'GGsUCxnfRqoPxXi7blezkRKJrTjxSwl1+68Rg0qisI+flbNZkFEpmiARzRHWGRUy'
MOVIE += 'I30FQ2X+UdDdjsNnLfd67T0ORxBH2/DIhvjRbrD+k0DDez85TVwuEEPh0uP2SNKd'
MOVIE += '/26I57sAkvgT2xmW7hbH+6JH4VRQQIVVjm/oTu+CoBq3slDlRsgfnImuJXGmy8hS'
MOVIE += 'ySdXksErMFwD5mi5C4hZ+8dFlREwrxsSSX2fZQKzdw0TB522DdG+BYCHFh7yoKJn'
MOVIE += 'IYQxzEmSeIWnKTEouJohsYr0y0Yn4VBt6ih2aWXWCSjYqAeck2EiAXz2Kcw9qGf+'
MOVIE += 'JwuFuFIpobqsjxKQTMKL+6LFuJZCHCsXBQC2irxQfoh/nwl0AfLOVo61Lfa1GwKR'
MOVIE += 'y/BgvHAUaSC+Jj1CGXllRJsyxJChZC2WzOqiy1h9tTc7wsEYhewyE+Vk0sCEcbBV'
MOVIE += 'CquOSFztGK2DONCiXEp3ID3zYV2qez5ulI00xlldRmr/1bOvr9x+/SKDXNAuA5E+'
MOVIE += 'QNw5+r/GIyz7ddFPnMkvXBStq9szNIPG9bC24RCHMjxjEbzI9oy+k5AzqKhvx+q0'
MOVIE += '1OKclQAvilU1itnhJdEnpUmKKMlp6d/0ej7oKg3VI0qgTFBeDT9ERWd9ZaXtFQoG'
MOVIE += 'ZrwG5OCz6Gv9tjXsa5DC5npLNoJRz7wvyWASXv95Pe74yZ0VaOSngu9RsddvAr+H'
MOVIE += 'OKtqQJ/Wmg1kjwEAqioCRCtT4AQw5TrrHBMPJWSYkCuKth6plqSSLDaN2JpgGlPa'
MOVIE += 'J3avOtVSqE/W0eznXIni130timofiFRtIgTLX98BINL3Db94Dfk3DVWyjXWy7t7t'
MOVIE += '7tmiCu9kt+PqXGo9BJ0diTEXrcU4Ng5lYof54SOc3/Op4C9jlXu/223iAB7gMNRr'
MOVIE += '6n16wkbkq7sZ8X0mX8kgP7cUViqgooDsJ5H+mHAvjkI5PxhYwiaJw+aoVgXEhRki'
MOVIE += '1MVBygudQ2cGg0ZoGP8ufJbL/RqW+0gSR/QDQHQrM9fv9eo4+RwXlT9EPMG8F3fR'
MOVIE += 's8FMUK63JpVi2oUZVXnXlo1uv5P0N/kKQKHx0TNhXVBKi/8muIfZBKJYBfR/ktqZ'
MOVIE += 'p9bo29mT22CnhbfX6Gd3G6LiEaGUiTFOdcoSRzqcDsqsOKA8XIlg/SPE7g4PTPXX'
MOVIE += 'NhJ4FK+4mK54zD64+Fnq7d0fHvy2c8kL3u8tdBdDtMgh/l+4BUpOQGAbQkvD3D4W'
MOVIE += 'z/qHmVwKZAONgEfV5mDbDFwf89BEMibf30dJG0IraIZkBq4/fncU/lf3H5lmS6m8'
MOVIE += 'OZCZ+ZrNT1KOktHZegcchRRle7f+jnl7iafH/0ev8Jm6b2SM0zRY/mIEdJuUA4YA'
MOVIE += '/cAENOLhFzrKsdZvfAKu4Xt5XJS85j6V+5UUqQwybJfX5Pukmexa5ztDVZP0rk/m'
MOVIE += 'ru5RfZyk9OIuMd97ZlXxKdjVIy+OgR6GFSqJ/8StcjzwqnUKQZyOn+aE9BIpjo/o'
MOVIE += 'TK0BLQCB8Kx7lOmZEDWgRxS5mxOTr1aE4zI2n4FTBuo3GzZ4/xKy5bYdnwgBcQrb'
MOVIE += 'DUUTZD+Jxvd3GIyAqgytcS/zT5bzPEwj9tp2mS2WCft5+zuXz+yni1LxQZPlyfIb'
MOVIE += 'C+dAEoIseTZ+JIe0PzzM7yOE+qcdQqRSbZcx0fs24FZak4O7UOrBhjM+hdijXz7Y'
MOVIE += 'RNW4FCYxhX8wWj/re2OzuSiPzSsVQsp9rRKzm3+Rt5WHnYa+n3qI31dAu75pUEo2'
MOVIE += 'P4Cv82HwR093FBvX+dQLX7HRRYsMQ9jZswjBjmzKBBJdREnibFjlZBKJ4KjkSIf2'
MOVIE += 'ZtEInu/OFFPoJ+TjcyeZPuKWpq8vxT0YM/Hv0qjFMZhmYAzE4RVb8hWJ1g6SYq5y'
MOVIE += 'L0FFSOYgJ4i0n6lnPWZINoeHgIvZaVOJoLi/Dwf5XaD9MkW1o61i8NeMGOUcsU0v'
MOVIE += 'e6aoDyyaj0Hdw7EeFgUB4AFGZPcMID4Ybb5X9C5tBZqLmgKogVF4lZBckqN4Rp/q'
MOVIE += '1jJcDk2c2aZ5aXXvsv/t2Fl0+pAcQq7tFEltTmv2eKzM0nQ6k+bxzr32AwC7/mGA'
MOVIE += 'TWGkkeKgNKaQ5uIPzKriqVEFTR2EI7SsOE35uDKFw8t55Q47pknxGUM9lBP89K8b'
MOVIE += 'Zip2rPlixRv6q/RkQiyk5mqdetmT6458nOuaoiiwAh30DqrzL2kuTe40QV2WF4tx'
MOVIE += 'wmaHjAK98ADj14uGcY2ezFviy69BhXGJBtTWzZ/elheEdDxWrhgtUBFNpnZ7z0ZJ'
MOVIE += '0vkkcNRljYAChcawErS1PATAkXlHUVvSNx5iOXZFnmJz4fQndal6otKu3E7m7Bw5'
MOVIE += 'Fx5EaHrdUWJOlx2lU65rVBUB3SgTgSzds4tDUE2ksddg8PHTl4pQCQKnEvbz5Ipt'
MOVIE += '6Q9Pohrpxq3DYvAjuE4Tot5+Y9uxv3utTjFYZ+mCR4HjjW/lOyqiuoI9sCNySsOv'
MOVIE += '8obJsxHEJCWxD562wicXcggFuZ4JUJndhH8qML81FDlEqDE869x1J+EsexIJU3ox'
MOVIE += 'UUrWe3RE5FV0d1Nbpeh88l9G7oRXc+e2VWIrpcLrROEtXGC6cNtSK0fAY2m/Yt+J'
MOVIE += 'SJO31TlJSo/0zj2cW+TOSG0UOdbXdlfVopohOw/BQSWmALxmGDwq0FErSh8HJA0Q'
MOVIE += 'qCA0Q5rZspnmC0USCyFEPx6DduvJV9MIw1ExzBMikH6PCkIrHD7D7UWyNyM7TQeh'
MOVIE += 'XbMpV5Ph9RDZvx18CKaa+phpQXPFpHKpNX8wzif9yceRolXxxRhZTWW+rPVoDo6A'
MOVIE += 'FO/magIFaS0t1XtPFAdV2PaROn7kIuUvmBovB0z537pxnRToQp5rHmgWdfGgIhjN'
MOVIE += 'QAxDzw+04WzLKwA4NvQnvofvOFIw8ux3Hu8PRXkKSO95Xs6aKrRoCeWsDWw2IwU1'
MOVIE += 'AUMwq55ZMyzQX0fYrmcEUcFD1U6s9uDaCETIgfRQVd4TConuqhZc8NQdKFvuiBdo'
MOVIE += 'EkyWNlVVpgTsjsk+S+U7NlQmSxMTzMK5cOxSfCJblK6lLNGxZfYwQKxmPZDcXdB1'
MOVIE += 'bTMhmgvMKU9BMySDMYTEfUSIaz4s3DSDPmUx+0fKTlREgK3DvXPUUmZKaP7yPIIt'
MOVIE += 'oAG/L8NUBaYaXQ0snO6lEO+o1mVZR09TwDFo3IkZKNzSuOo3RcEwI9fPEg9d18cG'
MOVIE += 'hXrrKtEUBzTQpxUELO1c3epsYPoUF+tPxs5baRTvfnYBDCJ0hu8YjmPnKo7KFf4F'
MOVIE += '1hl3BWBYWXfI4q5iXmDUDF7WV+BdZFob6jsoERudxPIIHPHcl9Fp+UxVHlnoVCEh'
MOVIE += '0MAJbG2AQ7SASNECy80IC1WvaxsFgQCrGq46sWXEie6Dhb3iz3wdG89lK6tuLsEl'
MOVIE += 'b3Foxk14Rrf701Arl2hz+pHv2KDEd+AsYhULCvIYOVkJRT0SQgIqqepxOlHC69tc'
MOVIE += 'WoRqfBtNSDMXYuhwCrs6N5TWwqDcypndZJ7YcSAYgRlm8LjBg++OqMoSM7sm0BI+'
MOVIE += 'v4blxz5lvsL7Fj/K19N+7CrgsnGK50D6nSjnCwkVU2C34MxygKOJW6fiKfnnkn18'
MOVIE += 'x/5JqOwdIOpHhgOpnalpmQPRhyC6DDQ5soBVEC5DKk9MsuMyJTVmlBbogIr28D0n'
MOVIE += '0PLJF0El1MYVjFvjLcS+9QeGbaZanh8NxfGXY0DDe+qAuQ/O7A20E19iz54U18Pz'
MOVIE += 'vMiSKH+DaJje4Zf4QbQfHL3s+pcMKYBV2FwuaZnSLMRpnu0h3iFjTBlsXi4xwy2y'
MOVIE += 'rXcYKejaeMQ9yC3rX/wVzYiiCnYIQjJ7JP7eEhlotegcQ4CpYE9t6e3Eq/ISXeF/'
MOVIE += 'jKIoqNqR8j8vq4PALjprShNaKryZFYej3KDPRCGGpkMcRvHCKP4p48C057lVMcUz'
MOVIE += 'SPKw+SGC8UzTv4939FxJSwhw2MM7SPhKhjMBAsx8mdAg78h9rEQIIxbYIoogbX16'
MOVIE += 'LkZJ3J7sWR5OuyrYRVmAg5gkghZEkw/kDxcWKPaNNXurr/pDgo6R7pvExXnNkcl0'
MOVIE += 'mTElrJ1EOTEMot+qPfQaZNYZ2YO3uSFi1VUMu4kfpL6Zx9mcburSp7kDSDMAkP2K'
MOVIE += 'siCEIc4L4ySRKcPj/JQsXu62jzJLaZMialgG8YNahgqrWh44TMHYuZYyPEyW2prK'
MOVIE += 'RiKHAVGpkp3RyCIT9IMVGT9+PI2VqkvcKK79E8d66Cxa0NdLICRpTBmSkfCrR/KA'
MOVIE += 'V+kUX+4Iq1HkEOeXcszADVMumspobRi+VOgI4fMl8gc0Hd6Vl72eaHkJwmGU0GKw'
MOVIE += 'f1580u+hIMJn0nF1T5iYLzICh9fNyIrM1G2cFEX4TR1har1Rs/zshYYZH1h6dNFA'
MOVIE += 'vOXDTIpREPR35fyaYKLewDPKJxmDZ8l2fza/sx6nPfXRxtLZi/nsCY5lQFi2MINi'
MOVIE += 'y9gjwtUIyrxljtYwVRkOSzfK5fVUshkkmat08gcJgZxXIz8V8LsawRz2KHXTgq8C'
MOVIE += 'BXFitAH6fewHkD04vnMKw+vcRzOX6S8l9ZIz47JWYkl+8uV5NedFxHrQYH9QZDA4'
MOVIE += 'fP3h9v4n8/xRoMGx4VR+a3yEAGp7QJ0CgL2ew7FGvie5Lj+Sb3tTsP+7nIyjRIVj'
MOVIE += 'Ox7/DoN8NuWAtzoCXmz9Y+w9hxTi8XL4xMH9dQC5SHjMTzGEpzxXKjkTdUXcV47Z'
MOVIE += 'RHPd4bGrLgLm153gi9oHF8AtO9arKHXgqwwLRAaQCQ5KPT/KmPso6jthzAexJ1sq'
MOVIE += 'OVxKEdhOO1zSzvhdeeSlf9GZg9OprErCS9lQx80lKfttk6WL4mB+OHcvB4vQCiya'
MOVIE += 'EPymPu0ciWd3Kl/gyy3rE/0tipGLj8KjjkDJFXaGnFfWUnGCESHZ29jiiUyMpBxe'
MOVIE += 'ntCjfg63HY1nEAt/aV8kgtMkH215J24Bfksb0r6Ym5hDe+6hLEvST/vZp4T22HvU'
MOVIE += 'CfMainuAkDfYjajhOWMHvzuIiL/oDgGxEgCvEkAPiBJtbeva66HaJ41rs3NB/evX'
MOVIE += 'E47DHFA4wpE1lCousHua49XOZlLFpSSkRbeGJYLT0dQISTJM5Jj+0yETzOnfjvRu'
MOVIE += 'V80go8Am1yvTNn0mVvYnS0j3TGo+PrpvpD3/3X9v5otHUHTJXn2GPzEGfTs0V5DK'
MOVIE += '+Zbs1gpJgcI1Iri/niUi4TC8+fISJz2K9/uQ9QluNK75qJJICJ/5HpLY7QDrRRMc'
MOVIE += 'OISoZqJQCSrXuw8jDj7jUfCTHJ/0BPITif4kpWB99IhmaTofRVJTFvfLlNBrBkNW'
MOVIE += '4EM5F+dVlM6m789eXV0shNmwKfczRnM+AGTNj3DexYIYlwGB12AAG47/RAvN9hnY'
MOVIE += 'pZR2Hc/9hOKcK8hvz4ARryJzH4CqbBnNOxW6APDlNsH8AgFtovxMnxG9WfxEFPCf'
MOVIE += 'SIERf2LBWeIlY8+dZEH+zwhJIHwGKcQyjPhiKDNOyo5TeaaLViB1UbD6thvFhooG'
MOVIE += 'MabskEMILDBtZT/TBEjRDOvHvB07pDtQhqeBkA4k7D+AqXwQs1wnLHBS3KDTwdhE'
MOVIE += '4mUrcuibxBjFr+1Z4sy449UOUszLk61yqYOLmgHuqQk8mTfI6X33ZzZIqEUgfSxo'
MOVIE += 'P88JkoKm80IGgmq4ZHAo6A5wM1pFC0mUtSNXXAl20DNCuryfM9lcNMm/Ww1CkvDO'
MOVIE += 'GC8pvF7kt3+k6GxEk+0n+d0EcepQW0AMl2/r2F+EGKBk5jVhNnBuNBJqg9Eq7OJU'
MOVIE += 'wNEvfSL7RJqmiSSmjwXScAOH28sIgwAQgNyHUd4pDtV8ZfnzaME5bJA0pZqeu7jl'
MOVIE += 'srjtlZozlaK7qZR3DvhRF7F3e7uxV8GMw4OhM2NJoOZpKnvhS+lnlJGSTmxTnLt5'
MOVIE += 'y9Bvi1qFLfR14ud7Qng0u8YWGLQf/1d6TQAEBxjNgU1T8V650p5jSve/Nm92vd+m'
MOVIE += '0rfu4oJyzrzZU3jUrf+WgtixnTSjVdGTfDtjvN0rqCNtZonCiTT9uEbeiX0ZpuSM'
MOVIE += 'VvptzPkWa3X3dgiC6PKTx0EuXMhpHL82JwE1NUQYHAAACrAfGu9Rm90RJ8EUgEcW'
MOVIE += 'UD5VQajsjlI/k0924HI2s6/CR/uv2LfMSXhfPQz6qnjg6xlz6XDs6yVQicin5kAM'
MOVIE += 'GxWbKv1YhBR0Qe/7tk/cFLbUKA/Rsk9iZU958QEAJD4G6oLqDiZRJBbunkr6Z4O/'
MOVIE += 'adNtd7mS8HPFLbXa/u8Pcwa4AT6NBpFkBwWNYLLAE8RqR1wO+03LGcU5CJnrdBrH'
MOVIE += 'KUHz/GwEjxmdqepgToC1cV8E+vuLHtT6CcAulbndXM1zPHrEH5n7hqj8F2x+3/9o'
MOVIE += '8CjAgGjVIHHVoujIIzf3t+ge29Q74jsbFB7fKrSZ2tkZ569XvpvmBQr2Ng8bInIz'
MOVIE += '1uxSytJc8Y514h4NJZhv9JldFZoP9X3wCzk8XNgx4RuU6w796X5srlE68XMG+ehH'
MOVIE += 'qBCdROQbHFR4B2SD8yd5BQ18JddZDn32Cjqx0uO2QimN/IiHAyx3B8Y79c5ox5x1'
MOVIE += 'E7TggpTyI/ocsciOYOsF5Ntv+o5GNE/NB01f+R1/8SzTorylnAQse8l3JHXEscL9'
MOVIE += '8Mqpw4KkCFxmyZoyTaZzAfQOP/zNP6G1TZlMuHWp9VvZuK+qyESkLv8JR9S9imBZ'
MOVIE += 'j2CQmh+IirpbIXI3UGS9eGLyajDnKGnmFenZqqH9GhspqVaxOMFdSjmUKsdqqAKP'
MOVIE += 'uHwvcgw/UU0gah+AQEMdADwsVLf7QnYy74Rs4vXkOlm+UUelXyfwrfMLXBN5CjsM'
MOVIE += 'PjTAmk3Ih5/Us8VQr1oghmvSGpJikM9IOcOKgxnHK3omQOtJqnw0SrItUyAHpF9O'
MOVIE += '2GMsm+0DHMXnFfniNhYIMjOjID2Zyz0kVP1TaPQkhQf3t+i64R9JLy0UBCeFmnxu'
MOVIE += 'V6HuyGf4vxisHBib+TLhuHVGoyZYjYvaTurLKIzKnOnpZxwqLOGPQPqfglxPi+CP'
MOVIE += 'qycWne5V4YMz3xTzDzNsX4JpZTRzY7R60LCbUDaOYQY2OitOulkAzsSb4u/EHtAB'
MOVIE += 'J6zWp3vHkIN5PGwf0xR1KJyrc0Z41Zv7ttDXnu6h8wb/SGBGTfhxAVd+9q7P2apF'
MOVIE += 'p4Vm4X4iIpT0LpTBDY3PZgTQTGKAA6IoLjM2zwAQNBRzavyfMBiNg6pbOsdO2+t+'
MOVIE += 'TpvtFMrDASKhJcIRUhy9glSQJ+9+E11eua/paIj4eyr7gxfCYp4GFWAxNUzoAWXJ'
MOVIE += 'r+e892Kh1JDKir8TeC19UB803zkm/jhFGxvlJ7oDGQ8t18RTJUxl1tonLKKHogBV'
MOVIE += 'VfSJXd/sXwWSIVB+1IGsYY+2K7m2IxZOKIBwwwivnnX0LJJhlGjdK2sWpgrxKQeX'
MOVIE += 'h8r8N1lkkuy/5VQRkjqyKh5957T6TzmGCGTd9nz0fNG8kexDLhP3k+5fwZ9Nmnz7'
MOVIE += 'ohfg8MZwKbqN/PhC1lVHIGj8BWeBYdyogFU52Arp9XmzqGUDb5tT+8k6D9V170kU'
MOVIE += 'o6Ka05kXyxXrIpzhVcDPCBn6jEHRaAlEJCdKozCOFjh0om8lmL1vkcHJOlMOoiL4'
MOVIE += 'Sv/rFg9UzQwIZyhS6vxAb7LDu3dDH9Ky8WxdiK163hDNop4uQIx6tSZXFWatFPE6'
MOVIE += '8bNYL8sTEPsfkmw8xF1233scAxu3DSci8NlYY0d2V+cH3J/5F4anr2MjcrB7Sm89'
MOVIE += 'UUkAoiQHMIS3eiJ5UMzmh3jRMs0Tiecf2j//zBPJyK9TB97BogDbulGpUppsO7Ce'
MOVIE += 'XUPSAyeGIqualbnVKuNjet6IvfKHocJvebl1y/H8MBO/HKvL3iFhSiP5A++m0qsa'
MOVIE += 'QG8Y4NGzj9+MhCVp9UuKLZbao1sk+lviY6BXOKLhHYIO3Ew28gXJL4bKbuMPJZwG'
MOVIE += 'cnWfz7p2bUqOZP9tRoNvRxsLSt6/mp98IT8VQj06ZswaX8yW/KNU0BFfzjrKVdbh'
MOVIE += 'CFM1DZgNevhsY2C2Tnzuc8lMUmOrBpqbaxKg/fK9xsf3H3qCXfvUA0x/1fY2PTwh'
MOVIE += 'ymCFjHoXegeK/CZl/Iok9kHjL5Ys8to6PS/Vqugxvpfk3bW9CGeDcmgxzJMFPo9b'
MOVIE += 'fvH04109fYbte6LOfuKHH9+QDVp8LGdg0xgWj/haLwdyGlgjkRong64/Z3JOHqSf'
MOVIE += 'jf6YzrbBPwHgs3pH3AQsZ/qveGuZ/90IybdEFcbSxyKDey0r8ZMk846ddWIiDA/X'
MOVIE += '4/aBPkhYFGbNGY1POobpGgIHhoWRvNJi2JwNmMX7OIc5fLpdbKsJU6b4ZnvwOHHE'
MOVIE += 'W3S+yfZNU2QTtoetDhm4GmFOhx2brLynghI++2cYtWOo7ACqZwCOM+1ND65hf/WT'
MOVIE += 'NUMD0VBVJCg047O/Cp058+kvMzoQU/QdU6+zyeijQlrKMoEO7SoCoKP0+ef0cjxT'
MOVIE += 'DLD+g3vXHm9O2WLhszrfnTCtcvAd34x7x/bX9PBTx76SJ+ZN7tm0DMyASusqcl5k'
MOVIE += 'nxIU5KmJR5DP9uD+653G82yNWxFv7uPeJ15T3ruvKnfYP3+roKEC4DeDgCFZIIDR'
MOVIE += 'WhHHzn3+PO5FmIAmpPxeCPxr6XaLNeVbvOrVc5Zge+Ym8m9PXMsyxEh+/0RnwJTH'
MOVIE += 'ONf5Ff8YRI2j+vZgoXaazMhfvMzfd60C/CikOEiuR1ii3Lur/ut88invSIAEbleO'
MOVIE += 'lC4/UMCSh/oPwNGzjB8faiIJ7wG9bg5fgMqxMD8IUSDYAVUxHEvMIBsJE6kcTaTi'
MOVIE += 'txpIEKkaTyUKe3xVwOOiqcWhU7QF4amZyhWwXn1MQMn1Agq9I5r5nUDJXSUj/xl1'
MOVIE += 'AwNj5itUYwMvrpYo4yugjIyXewcwYiIYCLKTING02mLzOuLvjcRnoUx2vaKPMZJf'
MOVIE += 'yrq9rfvN6CjncVF8o89ug6qHhtnVyIVilOYpi0DKBE2G7aZHmCYHBrlnxDId+22h'
MOVIE += 'D4oGU36Lbr7i+x3+82zMAahMGKbmOf+QBwTBAzL+FnunY1Zpp9jIo4kMOx8Dc/35'
MOVIE += 'RyLf6/8yV9BdqPCod1KhBPj05wA3aIHHKahaSNvCg7TEw5BM7eIde8VZPz6jJubZ'
MOVIE += '5cWPsw+vH9nL/3uX6Zor7P5ag+K/Crbg7dqjSSE8NSPT58yzsQyPwCjDkSekijDH'
MOVIE += 'mOzE3Ik7ix8bGllWv//uMgHIUVHj5KAfKzhHcgFT6xBVakychpEmzDlFdK6eOtbF'
MOVIE += 'MZzC6okPGwEr27Ua3JsQCEAoxYSzfkyqoN7P5H5AGrIsFAPTcs41t3tcEymz60HB'
MOVIE += 'vqqU46TPR0UNZHUiUTdNfo1McC32e9NXFvluZ5TTKstGZSdEZciwJESVjocryZ9U'
MOVIE += '26Mi1TPRJNBmO7HWkHh2YV5IaSGUy8j1/JsGMM5vyrMOwEbYKFqZZkXMChEYBSp9'
MOVIE += 'GHunGQ+o9jLE0OSEVtb1bCd5p1anWZkpyVBd4St50UhZVL++LZoXajuc8umck+VA'
MOVIE += 'Zq+diXp7asyol6rcSXS5KH9QJPK76+1LUoMX63IRoIHCkuL4ucSeRfCOvTmdlxW5'
MOVIE += 'ekXw+P2G0/l+4m6veQO1VR3/IXP1DxmGRuW73IVu5uMJ0OeyqlbKGoiUgHGxcw0L'
MOVIE += '8P4Ps4cBdlSx6iqKXE0BU3xv6WptEwl++CobKPcFzkpqHJ3Ej80qlc0VDD8JmldW'
MOVIE += 'mUhQjhSt9ilirqioe63ygOTHo5Gkg0eqMBvGkFWrBzQ1toWiBxlQeV+90A0bJqOt'
MOVIE += '6Qh1OJRVrZgkbAvB6p9t+6cmDkP4cWo27D+KWN3Mvmdk+uHKAuqQ4Hs2pZ0hZGhc'
MOVIE += 'hwrfQ34u/CDWGm7n8KXW0nAs7/lcGPjlX+x+kt+TdoGjRvfSfgIV8v3ytROLey6w'
MOVIE += '3P8HxxkTpw=='

LOGO = 'eJzt/WN4nuHbLQ4+sdGYaNzYNps2bGxbja2mcWPbaBo0bozGZmM0RtOYaObK793v'
LOGO += 'f+89M8fMfJg5jvmwHxv3feG81rnWOiOUFWXRkImQIRAImtxbqQ8QCJQLOLshwoNH'
LOGO += 'iLaQY8HVpLmWnIWcHAMEEdwBr4SChUCBWy7gAup/3HYDF9BQMBAYcDsUnLHA7ZfH'
LOGO += 'X85EUHD/uf4CzsT/43YSONP/j9e8vIcdChqCBq6zwJkD3MYB1+XgbB32X5/fAc4v'
LOGO += 'B8T/HHmhIf95xX9fy8opKFNwsLCzsXDygfezcXAJsHMIsPFTsLELsLEJgAehIFB5'
LOGO += '//MXvRwakeoYwL3P1pKSynKSkhQfnR0trO3MIRDPLL94wbc/xUj6O0WKGHARBN86'
LOGO += 'DSpn/9mAcapQp5cIUWasPzRyPkDJ4KJ+wxLzyba7e8BkrrtPWxNBUxzTN5BPkO9N'
LOGO += 'y9uI5/fIzCZCfH8HPG78VvwQbjPVSzK6YfNsUuLlaEL0/NUR2ym/iMCyB5X1yvsp'
LOGO += '4syckhjenJ5dsYzXtU088cMnfRqC5IplGbUYv3LEnLDTEdjz20RkfI98xn/2Qxyf'
LOGO += '2n+75c858V7CT/8cQvbadK9NxBrlQ5PmKO1F5YjSCNPIcpUO0b3aHq+oOp3Kumvh'
LOGO += 'O5SfcPbm6UdcsnE9lCkUEoFfBBjKeiSyNKJxsAmXlLxvC2MMqVPlq5AJ+PGUg5GH'
LOGO += 'zoKfu08cxjZnizJxFKGFWRuf2JE/uwdp/GzsjLVvdYOGzQlirNyq5g5aVJomJmV2'
LOGO += 'h0V1gMGfJ1VYg2HxCPxNp89BLYs8eYkf1fVA6KdKRtACdz+/srb0wOcHqZ1Vv4fn'
LOGO += '44Ptf5fU/vfs79rftX/CM39PEFLDnBvOC3ocIBB0XWs1LVctBXkBU0d7FmMzRxNz'
LOGO += 'Fk/7j//ZY0Kinh+NTW3NXSlMzC2tHYQpT1o7KSmszYQpNbkV2BQ+SppbWb/1djZX'
LOGO += '9VZUM/W2NeU3oxQVQRbyFAAfYG/uakzhaW/n4CLgKUz5n88VALdfHmalpPjPS1xt'
LOGO += 'hSm1QDuSdHQ2p+Bi4WJhY5b2tHbnoBRBphByNrMQ+CAl8z8+AtwTprRydf0owMrq'
LOGO += '4eHB4sHJ4uhsycrOz8/PysbBysHBDF7B7OLl4GrsyezgQvXyEf/1GVLmLqbO1h9d'
LOGO += 'rR0dKF7uG5s4urkKU1KC5yn++/fZf1RQ+L8+3sHlf2wFsD1YPY0/srKzsLHa27P+'
LOGO += 'r+9wcZV2Bx/y/+odLmpeH81ZP5i7OLo5m5pLu5s7uFL9rx9hZvp/vf+jm7Pdf/6O'
LOGO += 'mSmruZ25PXipC/gM9v/tK1963P+2CSyt7T/+513g5/9vr3S1tvifG+t/+20vz/zn'
LOGO += 'x/3f/fv/1//kPy/+zzYSkHI0dXv5eXJSwpQv3y9g5mhqbSbwn5smvOZsfNzcZsw8'
LOGO += 'XGxszFx87PzMxjxmPMxsPBbGfPwmXNzmPCb/y0fJObi4GjuYmr98FHiExRp8Dge7'
LOGO += 'hRknBy8PswU3JwczlwUXB7OxuSkvMyebmZmZKbcpLxen6f/yEUrO1qBVGtv9r7/q'
LOGO += '5aPMwEexs5vy8pry8zJzmFmwg1/DYcxszMXNwczOy2nCb8Jnwm/KZ/6fjzIzFZBx'
LOGO += 'dLY3BrvT2t7Y0pz1o4Plf5542eAC4spywpQcLGz/8xFlO2NXC/AGYUp5awc3z//5'
LOGO += 'hJq1vbmqq/HL1gRfwsnLwcbFycfLwc/Pwfk/X6Rh7uwCWuLLZ/5n7PzPMy+75eXP'
LOGO += 'gL9g/NJOwQf8978UkHQ2N3Z1dFZzdLQTpvy/Rt3/62kF0J3MjF2NpYxdzcGH/l/j'
LOGO += 'sNp/j8PMbFzgxv98vaOZtYXX/7tXv3QeCqH/2shvrV3A93v956H/6lGq5k7/de+/'
LOGO += '7tpZ/9cdiv90CgFj0//6Cy7G7uZm/9XO/vspUytjB0tzMHr8j/b3349b/z9pCjwc'
LOGO += 'xsb85hZczGa8bGD/gT/JbMLPxcfMxW3KZcxpZmJuys71v3+Ki6OFq4exs7m4JdiO'
LOGO += 'YFuBNvmfbUVB/58d9eZ/f7WHlfnLXgCbgJmdnZmdW42dV4CbTYD7vzcB6//v/yIv'
LOGO += 'n4mFCWjazOZ85magtVvwMBubGhszm5qacLGzmZtzm1n8V4f5/8Jf5GD+f9zL/+Mv'
LOGO += 'CrH+rztV6GU4+d93+3+94H8ZR1+G5/88BsZnMNyz/l/j/f/YZv8/PvyfL/k/X/J/'
LOGO += 'vuT/fMn/+ZL/8yX/50v+/+pLkP/nitHcAURBHmA9yJjWugPWkvAm72Wl/gsIuJNs'
LOGO += 'DQBXSB/fagPkAwX75QwFycgiAA8iuMopSCPsoyLBQWh1nn5NQyAUEDkpcTXPpT/Z'
LOGO += 'Xp7qc3PPoqleyHnhkbC4ahVlX6dLZN68OysOT/oQqTPMmLyJos74T82g4T5yU20v'
LOGO += '/218eXgkVTh9Gc4rKQo48Tj2ILaJuM+fR3+SXp/Etiv+HRri30NvDoId9855Wtle'
LOGO += '48xt7/Q5buiwZT7txVYSOvv/5CLxnlLk5JWn86e3VHAKfhuqcw9ubwVaoCXeBZjc'
LOGO += 'o8MNW96vgZex3fQmLhS/mYS1gudSnYS2QstCz4KuT0yBrU+yJx6yNF3sfDNJYkWz'
LOGO += 'fidfGY80K0nU+k0HEXG41PBfVRIe9LtAyrsKyHlQYddrcpxhd38KilxcZ1Tw3V0r'
LOGO += 'iYkSwQ4I9VCKcC3Qe9D4w8+lSOFNr5QdzSHtSGWxybAKYscIw0EfoG6hKTR1yD5C'
LOGO += 'BqGvkTbwby8bc/pPIhB2c7j2/eewrKoptLvuSfJQPqbUz8B+Xy5sOAv9xVpJQYoV'
LOGO += 'x1t/Y0eBwMcE6cRd2JlZT45sPIFqpyNL8/kQwGVvXYnjChFA8jSE1qPNuHkjpgt1'
LOGO += 'nFg5AQf34yJIsqDdEe7X0DO/SOUqsU7budgaNsaoMD/eNI497UHZhu+GCdRfl0n3'
LOGO += 'vzNSyw7bwgyaSHkK3PzQhz5BpF3w5HbQMeGhJzdkyS9flIBY2RpRH/MO5tpcTIkC'
LOGO += 'jg/mOI2LJDanlxXZPpFVLNOKI5CmC4/cDnuSN6syx3MzqJlOJf8d54b8xoc8jFPs'
LOGO += 'DaGe8SHaKzS45APHViXbMN6A+8MTMcS87G+tk4EdWG9vukXytfDu80aPanI8jf5G'
LOGO += 'EGIqSQsysr6CkAe6H2bHlDzdxXRzqzkhVOZCcZ1UT8++m3qrIZ+GTUA5io+anlEz'
LOGO += 'yrbPNrZzsvuZP5q5iHCdO3GipLY6/chqwK/CFGmo8i9UIwQfKioQrQuZYqSU2+el'
LOGO += 'HWxTw566W83IGW5oimUE3rCr8I9t/5GoTz0tq/9pZfM2P7Bxaq38p+0hXFHr4z+h'
LOGO += 'jIIZ5KcN1OqqxVZb2m5yydJuPCPa75CF7Zlr9/98GizCKY8Jzx1rnujHZiPVnoY/'
LOGO += 'eXK66HlzMsF1TdgKv/kYKLLp7N1hfHKeJoVGVOH2l1F+0I3clA7eMJvRTC7USrz9'
LOGO += 'jgOzDmU40lY/Vbr37r8+EeoU7xNzKkwnNva7MKncgfDvb16NeVdDbl5D/c0S+FVx'
LOGO += 'lFkElQ23gWbyRAh9mr3z3GilqkhqdaYLN4umOuqPZHLeC+OiREQRnhtkkfOI/INM'
LOGO += 'gUo+bZdUbLn0/STOl6cu7/omFpTbaR+4KmfiSYUUuT0YUqQ9RquUhe5m3Fu8W97v'
LOGO += 'PQgI7aUnYD9ekXf5fcLoRAgN58lh62OltoiXtPLus+Div1efktL0rKZgIYQdhcuB'
LOGO += 'YYlL+bLrR6tsiwE9EqjdJWH0bWKrxsfor1w7zFmK1d8biBH1Uo227UYVDlobjr3A'
LOGO += 'IqqdlGzD6DmZT/ZQtBgGl/nOh3rNpbcfEikM9sWNRE7hMv56Dvocgqbn7CveRnrq'
LOGO += 'YsR3WioVfWWinen4ivmR7ESFnJcQ1VUW+4k1rjMR2+MWa4Nxg9MoXUmVXPilR5oi'
LOGO += 'bu7lMRNTBR1hOY1SQa8xBqrvY/ZerRVWper4yG6820CuXxUW/91EHMjflSqi9VfY'
LOGO += 'GvSMr7qYJ/B6aI+irlZ+ldTEgziQZ41fqzlcJHLwDpAqqA9TTOmwgzxGlKcdSpwy'
LOGO += '//ka2E+elhu8VlhSlWJtmPYXBqgV0i4dml6xP7qDvek2UruqpwxOOG0CFvi7XI1y'
LOGO += 'lDJNX0YqnUBPBDhJHCbVvE37nbxaMQW4uWrvcvXq7MBK0bI98UqIuk6Uf2GeRLca'
LOGO += '3Dy90t0Fl4vSJvTZTNC3wGco+H6frKeuD67bgzpKMKIHRbynKHdt0NnCzIpvYETg'
LOGO += 'RLAUVhlj9yLoXom1RX86whn9Fk3bgTubmQfvqVMOPeuvjJv3Ke8x71dwywm1D7xH'
LOGO += 'YAaSje4x1xU0HCs96chGRGm6jwnM5vGkSEXrZOPZjzUFlgxLnuBQ3KA7kuuhr6Pa'
LOGO += 'yNHlBKX5i8QyJo5UMAUSdJRIg42VZssx+yYF/U44GcUX0RV6BiJD90uVVkRqrFyx'
LOGO += 'wop3UJ5otz2lT/v/6dbTFP7EbAw5T5JWdLseVrFze1eP/nuFXsmleYn9XBxQ9lyk'
LOGO += 'v6x2Zxs7TusqGvWp/lDRxxaQdiOTEqh/vj5NLsD+dDeF04W9CutCJTD/k+aM3IJ2'
LOGO += 'Se6+IXV2BOYikbC3FfKMthKm2IZfV4Gr8Mi4MtNEpuSF3U57wpDhXOf9z+AT7fLn'
LOGO += 'eKFRq9c9/SYuKl/eucZPfOBS3W+En8V4KJxBeny3pkpyAPPYRdfl0+U7kQPmJNhN'
LOGO += 'ZlxU5VPptsYRtLycCtnrhVLxMaiGD1qcPmKk8OrU8hliX27wObjnxDKc2s3zHOwD'
LOGO += 'ea4M8mgjRF+PWyqXGyV8yin/N7GYY/FXrjLokWODdsOgvpmX1iUyPvrU9BCDc8d0'
LOGO += 'Q8e1fL7/742B+t3A4A8rNQwGKr2N6Vv9CDxHtXtrCT7yH9natFJj09fuFvhU1Z6q'
LOGO += '/Baq7DfUFmyoMCKbuq59saH0flM45UcRglNP4lxH5uU4pde9MBfYyL0BQTwqa5E8'
LOGO += '+LLMdyaKd7xLKlrr1JLy9NFftc8rsbL3+r6rgDlKZm6TtGvW1Lc9uLdkTnGJsKuZ'
LOGO += 'g7Ah+dcH2gSZEqReIaPR3F25YbFaFMVAEUGtkhIuLxEn92iPqetLcmGc0662/GBP'
LOGO += 'JULswvAail6HelUXqCUC7dwdVS7T3u/sD3D1F5MRLTmVe/OOCus+qRB/XahHDVpl'
LOGO += '3vknO+obu21XUVgha5fHws+cecn5hDxo0veFLm8MQxTDycMUhLGPqZ9SU8m6EkMR'
LOGO += 'N7NxVkqM9CsaB/SU64jLVq+0Gris0Xa8LYN1kG2wy47Rbps74Rlg1Mx9ea6GGKC+'
LOGO += 'pgufcV2YIm13wv5jIPKa/RBuEMUiwyl2nW02YY94zS1Wmp+NInNFSm58kmHsyEo1'
LOGO += 'KsGuAS8ehdSrl8oV3jifOsI+3JflBsmuax886q86sabIKCWT3Z6k6yIW0Z8eBzPn'
LOGO += 'EXN4bkxj1Hp0FSwed3i11HKvoV0XjBCxh/e2lSvzqLvVgysx+1g9pouMrat59q/P'
LOGO += 'KOy3Jj7/5v5c9dMtCMoEf87+3v/ZCNLW/BiTPOHAZbpJL1mKMS4+Lyz8BX1JYIpG'
LOGO += 'Ye0gAMpyoPGILL1w/ewAEwlMBNWaYv84XXWWXtX8adKG/zdg5ajiF282M7yBWx98'
LOGO += 'gVpf2RQNyYTyhKr3E0Kwx2SmJIlYxBL+mW0BfYj3mXGXADWZ9mqLdIlHHhIDNxqN'
LOGO += '9NNRhwYH2/2SLKERI1vz+gL7+0ls0tCj5nmMaZxXF7bBX1fwH1HCm2QF/53Qhs7W'
LOGO += '03Rh1X97LvR2FYUJyi1YJEjFrGJZ5xh+GoPiEYH622/Am/+WtuVpusOx6xsbnRfZ'
LOGO += 'Pt0TnYzfrvmGfq4Bjtdm0J0T1Pnfruyu4xr6VG2r64FL74LoGzHiO5/h9WzpTIff'
LOGO += 'zqqhpEtsKrc7AblWlpXhIlKGCCmsDXMJNXeoaeM7LvuDv1weSAQ6ZniGXXP7hVMy'
LOGO += 'NEhEev6k7Dp3ViLupZ41Wz0nW7mPQBkJ0mksBYqYeDfHpElkSHbhbPDn0jq9fD07'
LOGO += '3Pm3oGfpmZTCBKp9GxFyFdHI1xh4zIelXSFWPtdvXtX//aCtTkCLK5lsE9ro45EQ'
LOGO += 'kWeNWriAvCAO1UIF7esPpXJhOVnvqDy+vgB7OqZAm9VPW6eomqhdmj60PSNxbf0u'
LOGO += 'jdyQsiRBr57ZF2VpoZU0+wNBPfb3urT8lrwjV/ckS8LjyBKcMYV15r0FRHmHja0t'
LOGO += 'lfQilhj7psUuFJHb2DA2sjRyRopnYTYRnbp3EH29M0ntSDLHZhXI454Vj0Rt8Jve'
LOGO += '7yGWKJ74BcedYTutHK5orbmIeW4S2AeZi1aFoYVsmrRBEnedIVZfo+WJPtKMNytU'
LOGO += '+J6+1TFxwf7Y9OqjvTgfTOFvT+5a9sZkW3YEQXOUBYvBdcGIUa4WyZz3HukrqAOO'
LOGO += 'qvhjwhQTeeEfxebi4IUU4Ydd9hknhN7diXNdppNNexoZpFKsYR1vPzKq4L2dkHb5'
LOGO += 'bvD7Nmw9NmlxzwTqtwuJWBv0Ag3RPpER4Zxt8DVeXAskW+JKyIvAnpmUwQy6xL7A'
LOGO += 'a83/y19u7ZS7/uHfaol4jkXXtg4cmVkRJeTZzA9ESN1f1MUmi75aDrXqEf28Wnlj'
LOGO += 'UfEX+k92AeQHhQCmNbOAvoRkcupUkCx70fKYOIKg0uWB1xzogdjI2/aTQUFK0q0T'
LOGO += 'MhswGwdbvsftU18Jq6XCzJvcCMV9zHBrSDxXC14ZUuymOUB7kkpjO7IuVXef0ksK'
LOGO += '3rmjnD5xQ92wiY0S2MPC6ubZzyoo7OKYt4TKqFlmEGRUG5ez8+3Da/GmmnokDH2t'
LOGO += 's3bmWO6GqS0fTFZ/1yGv4XX+Zy3m3J92xMy7pH5m2+APvFk65F5CG51HihBZKLzE'
LOGO += 't4+CNXxx53uYGFkaHfLghFTYlizcdt9+V64cybPNTXuvGTumj48nxB5jzRj6jBAP'
LOGO += '7UZz//MR/pDZpLg89phdjJty/a8AGMdep/Yn2HolqizeHVcojeClNDNoJxer9mZV'
LOGO += 'xnIENG3VRSK1HufEkrW3tEicGB2Ef38fQfHLfIW0Gn9aotnoICQd+WuRQshImz9i'
LOGO += 'hmXtsI4wlIg7TlsjbRe/ZcEd55QEL/Rlt3ggztgBnW2otE4HhOlelYGPvhtk9Xes'
LOGO += 'BX/EXCJKZxPFrwMDpS1nPOCgUcPgSK7D8dqJj70YsD4esGao0UHNuc9WwJtZbSLA'
LOGO += 'muFBYZu29WdOrW2bJcrYWW0oKJRQuMzl67RNlCsJ5vyAOpX51d9fC82mAaPwsUQn'
LOGO += 'o1CBsZcpkdU+M62SzKW50ficxJ9hl8C0L7jP1byC5TpdQ9VQ9fnihuAcawn/o8Nl'
LOGO += 'q12qw1WLrOFll9BaUADcR9Gl3wcMUFwet1RTg0fBrrKcGv7MYtpMEFOrTUGFjK/x'
LOGO += 'pN/b0wj9P3XcofPNYMOY2GiFVbngfxOKde/JYcaWcdl8t7mNuHDm+he5udSOHRd3'
LOGO += '0MWabqKgsuLjl/05q7uyHSvLQ3dtKOlzUrAnb/Tlt//YvU4Px4euLni/OSeTw6Xw'
LOGO += 'TnymvM+B0g/WU4+2my5iTdyP8xSfi4bnHVK+vtLEwyUjCLcvyqDyqy8nGKnsdT9V'
LOGO += 'XXKSpukqVYlK11sHD6kwiJmZHXHa9YXuLqpwFV8obCwNwlMzTiZ1V0JTUBX+SJmy'
LOGO += '8vGhg+qaQXRZ1G2G/DBmYBcr1st45W1IfWP++Xdmw1+ZgjleTr/GVxQOllO1lcF5'
LOGO += '8l2+rfLerTuCklsOMY2tbmKCGonyu3nur+Q54Y/PvssT6U7eeRo4LfiTCHicK03y'
LOGO += 'XBchDhjACkldjl8fO5P3I5fFjx32jQ7x8l3vrpz22+TL/y3VRB3uNy34WP+lwzYg'
LOGO += 'vLGw+kx5GObCKvCxqYCkWHrpOi5NPWf7lrafSDItZEqqviv780wtTwqUpVXi63r7'
LOGO += 'e9+e0aQ62NM/vZC86C6bApdehQS5HaYe/h40I7dDT4tfbyPqOWY8zE0oh+ORdoLp'
LOGO += 'cyfE0r+Px8vt2PVUJDTOmqUQzDu9zTGNGVKrXdjVx4Bh4RYecIGl1pXREiew/sRb'
LOGO += 'oC15wFdnRhtBu4y29/0Os8VzyLHQl0Vwu5kr2kgiUgaVrZOmf677Wxcah7jMm6jA'
LOGO += 'AV+B8CUwWpAiLJBPxoxfUNq34mYz73vWqjtIcQqz4FI4UlHUE2W32XZaTVciEhNP'
LOGO += 'iMl6G7CI+cNfi4uIQ2VUWnHvI2xk01dZN+pNaPNpnrK7TERNua/b9XRLLHK8IuXW'
LOGO += '9wiBWFPuOHjBC0s92Dum2+EYI5Qae9+9GmPRxjKGDlCmHZnZ8XLF+XjDL3Qkwf/v'
LOGO += 'nSscdpMtGfW8/UDsGEKHuA9qJ1XtyS5/DU2G+roo2Za/r2iG8Ufjy9YKmJzz232y'
LOGO += 'NEGoO4L6n+3vuYQPFGKq/drwl9JyaYN1kDD/JphfC0xRsyYU32vXrmqb7H5kRNL4'
LOGO += 'YmFSBJMrDVVQONWH4k+bYcqYOW7OtIzS52rMd3KNdMskHDNRi7H0BvxqH+LMIwzk'
LOGO += 'spNkJAekJSUs+9fH1udV4+yVsH9yVF5l4Nbj3ZAMewy6GTLQclwc9oQzcGu92yLq'
LOGO += 'uiWmxlZH3bluhGp6cL0Byx4fWPXgffepQaoU1weysW7/Iz7Di49c5qc4U2Sx4Xgp'
LOGO += 'jDpmtY//XKDof4b+pYX/aY6WoXYCv9bJRjpP3/RrpVsqkXm+MYTtwtz9sy0h0407'
LOGO += '8hxpbGVvllHVoymbCqqMXLzVtaxJ1seHQv6p1AiN7O3TUYbt2xDojIedjkbl7FzH'
LOGO += 'ZK567F2TKQIWzLF2Gm773+La6X9SRDzC3ovu05y0fKuYHLVI/WmVMo2GZkRCW0i6'
LOGO += 'FdxLTRBSAem/vczaCbqTQ9+sNFN/wFExO80Ki7H6hlE0z87x8SaKNuf1hncEJD7/'
LOGO += 'jWyt9G5G/ZiC1fIxZZi9Y6LpP2h7D4ctiHvoBYdm/c85q/GnVJW1ZcZabzaSlGP5'
LOGO += 'RGnsTEW7bVbe4DRxDCa8GckcyAmLTYn623g5kxCr1q/TLDiBru9JLEq4ieBYUB+8'
LOGO += 'af96eTpIy4b+k6g/cler5rdZiYo38Qy2+sO47XfMZj+vP0o1Hz60rzaz3ZL548iT'
LOGO += 'DD+dmrZ3pnD5UXdDZf1Mf8XLyD8LrCdUPGVkl3ggvuJPw8nxDBnyQZBhfuhtUeyx'
LOGO += 'c65Uv5tCUp9MOM+U5jQUGaQFfRbaJFW4lawiKYg96VLH4w393x33qVM0C0m6Hm1E'
LOGO += 'bBqLvUOVKa0mZAjxbnT7Z5cBLry6kRCOrwSvMo9hqVezQuBbqWRH3zIGdkobl3NM'
LOGO += 'YxjS7tlJgClL2vk4s0+oISHDtYsd+u/eoBOyWd9UnBnqUrq3umumZeEQe/Vd+cQR'
LOGO += 'WVourNja+6Q/s2+XU/KiZFd0ME5Mi5hqWpExs/CMJYaTuju1xCqUA/PVxOiQxt6L'
LOGO += 'gk285vxnnIU2LE8OW4R+act7BcYMlZAOeySqIITb/SBtl4L8wsOddMnS2n3ejhqL'
LOGO += 'Eec7p3P03qtdzQephzGsmbce7LGu8ckR/MniVH+sg6EOJEOrjQrlsxTFRd5Y8bzL'
LOGO += 'SBtEVW4SvHbQvmpTeMrvo9UxkH1AL2DyZUf6cWKGyiLwplvPOneKs+sqvlH4s7ue'
LOGO += 'sBr4uQQCpwX4f99YXvTB1kkEto3Coi/uG6wTHRMcv87ww5iKQ1urJyUgIvz35btb'
LOGO += 'cKrwqsWD2VSjEja2sujU5URvzpE9fI9zfV3NW9p0oXTfT3gXkd3Mjm9o06+dDZml'
LOGO += 'E3kOwwXMw7mmH8jilYJT74sCT4TCbH2D2VbZF82nOWlzObQJCa6vmT9nz6GQxDyj'
LOGO += 'aOM2uHtq6Eq9N6QfYNdQZMRa2ZPBUiSumKyXkH+va1rALS+tuv0sKJ+oEvdRxDNX'
LOGO += 'viz+UYm1wNoiu7B1NAD62acW6l4OYffD2vGZVZAvQ8bah9yi0gqs+63x3BXphY4W'
LOGO += 'hfpzZ6hsLEJ5fbNAPcoBYU1IWzxM4APcZS1s101edvE3p5KDaJwNnncTbiAmpJL2'
LOGO += '+YsXeI+lUMNptzE1bAR1NYNEV89x/iUzqOMNNxUJWmW76ZfEo5BzIVY6veKv8Qck'
LOGO += 'ionJ8R7mwfIkGh2ryl7rmiNOy3wktqkVkb+wx19xsoo/OWRac7BnsKffy+/SXByW'
LOGO += 'xSPVE2f+G6i/P4tKYGfruTsRE9wpLGLtgPlylS3V0KzEwIZPkSuGM7X3EBSgLHoe'
LOGO += 'S2yy/a4Z3V7W7g/0pyhp4nU6WljT72Fmiw5STAaUxyT4x6BFHSrWF7oxxl9UrzBl'
LOGO += 'bE/0PboI/I2P9wl8YtZ1ZsOEdOba79vIr5MH791nBf7TPtdTxMZ0kD5WRRViHOAU'
LOGO += '/LJKyfd+W/uRWP+ul4F3WGpKU6yy/WfNsFntKvUE2yucJUgEK5RVRVXtZJBVPIFi'
LOGO += 'E/TN8DA7cjqi0P7MfRjCLh1mnCEl4253fOPqJ0X4S2/h5uu/ViJ3YvVB62+29OKt'
LOGO += 'Btcj8dQpYDChTutglb+oNZZuOYRxlY87ygi+1cTkR9keM8n58U4DrVIfkidVxa1b'
LOGO += 'f3IFbQZVvtwXG/YFISeukxPuj+D8eZpSnnUEfl72oAIp13VcW+sVx5vncL/X+/NT'
LOGO += 'o5njPwSLosxMDKMVB9UzC6ZRkPbskdK4XLZmKBDbWDs1kQcJDqA/fUaJS8KOOYyW'
LOGO += 'tm5BG5ON/SAZgOvZVaq0FXSHBNneg35GeFQqsucNx1M1DHyk5dpr7BxJ6JRI+TrS'
LOGO += 'SxKEREEU8csvWR52D5P/ad94ap9jqnEFTaqxveP1hh9U/M8FtLDzJhNoNtmyUD4v'
LOGO += 'M4YMZpdGee9oO67fvtr6lSly3CjH+/JYcR3S9f++mYfgyrkXEgrKbv9YNz3ZKkOR'
LOGO += 'o3V6w+ogaQkTDX7RL/x0+e0gLxjI+XgBzhP/dKNowQHzzFG32w0+JjnFLjIv5nOT'
LOGO += 'nk+61Tb+q6qsC9X6pibbz6mkmJzDGLTMvozj8AOyO7f4g1fZn1qpZiBn1VLqOu/4'
LOGO += 'vibGBzwWbSfmq+x6nDMl2o3qv07fRx+GbUXK9vCHMc65w9R2JoqZtroIIU/x+JcJ'
LOGO += 'f7vikOhPYK6YSueH1tQIdu8701HYlWBCca7JZ6r7vJSWhA6O7/6vl+qxpR0bUPdD'
LOGO += 'OLqUpInhE6WWj2J3GWSRWwaTnzQR+ex6+ElX+dLp/RkSg+PXhRLsUpGc87PoAunc'
LOGO += 'nckz0l3hfn+2dsf2zLfat0UUlOfcvunez8tnlFJ1JN5pTs23LkNToM3foigYbfGs'
LOGO += 'VjqyJUvjFWMLeHXM6pTMbSU794UgJju0EaxogtSWzXS/1pqREYnPLIQ1FvpHuU+n'
LOGO += 'FHw1Ea9n/trE1NwqXbNiQIfd416PVpf00a9KaCbBs0Bv/W4BX/479s+z60qh+RaW'
LOGO += 'bT7XfWUB132xbxqVVr8qCKOJeUuctvq5bIqi8d+9+dRN4d+Zm5CAhYyC4nXSfq89'
LOGO += '/hs9/QtrKq4Syp8oNZwIiw4DDUvyIUfhyevtXOzx1YRtEUWt0OshLqnDAZ/9wXl6'
LOGO += 'krnXG9UdbKbTMBfw0NsBlJHUAZlSVLF9b5IiDar1aYP/UJzKMUPaMTJYRXrNvbLo'
LOGO += 'KP6hCbScf2caQDHbMIhgGZiDsQwzZf/9uHhgtaSD9PuDHb/zqIv0xV+q98+NP2RN'
LOGO += 'UyBcDqNLRnHNBcdKlYU3S9WGolXt1zosPzagx4Uu5JfqrSVHUpitl+rfKGTyVEJ/'
LOGO += 'LLzz/c3iAPFmI6DGRMREhD19eEpKTlb58KEnnkp2oc4SIz09nUm79vPV0Tz5jf8j'
LOGO += 'w+8VAXedxt/KK19ilNdYsBtezedQPh1qcvAvkJqWXj77EJ16PmNm+9AiSxci/hjB'
LOGO += '92vWUIrhjDOs2pCFG660h+du8YarKVsayasVT5YThLbRIBlgXxrLQ+fXKySf/aC8'
LOGO += 'Jb9cOmxpqIwRfA+v1jHi9xfu6k2ZoNgV1ByMGkfZzE4dXdk/Z9JE8Up4Nxy1wZ00'
LOGO += 'qOZGEmWlQKIPUQ9Ntj/DMDQDEjtFbzdgGmzmGNxuT43VVVTyD3U+decxMDKqIqCT'
LOGO += 'KDNqVqmddD77N9gSsxmJSZxwZ7iTl1WLHcOoH546oAdloBy+9pr4ZdoGa1M41iEr'
LOGO += 'PibYf6OKb09UZvSZndW+utwwnV9obAVqcEIWAa65xEwk8Dqyv24t4ws6prU4X/4s'
LOGO += 'R0G4hHMc+/7K/J5Oxzrt0i+bu+VBEc8WK+35iGvfjBFhItf6CXmLRJwepOyMyGs/'
LOGO += 'ZgGrMs5rXxeaPVGG+fP32goVMoKTWK8LZWMtNrqCsjzWvLKch9/U28yVvztyWPlx'
LOGO += '5nSkGspjqKIiLi0NR0NDg4OD893/yXt6ZiadY2ehaql0yEcU5WF/pdJKY2Z5drSJ'
LOGO += 'E95e80T6CmfwoU/+ovPKjMQjdeJDohe7Dpof/d9XU5S6gVN0H5yrsJFHk2Pu0gLd'
LOGO += 'XQXfxaRBkVWEKFw4QHXITP+2GBKLkP0wWZFsmEf6BdfK8rcvV1R+dJr6rzxClmBY'
LOGO += '32wChmKOcHzs3cwTHApFvFYPTX5DpZ6dwdG+RDS3AfqRRuJjO13JTZcfEznCmSMs'
LOGO += 'rV9iSAWnW9yO4Of2hkdG+D1PKXQb7Yy7AqEG/rR5vCd/SzOqzRv1Sp2f+LiJTbDB'
LOGO += 'pxDFz1Cab92Ff+n6H2EEa+N5pN5Jq9VyaSYTVl2uyujyRh2CmZ4Ug9w8afY/rmHX'
LOGO += 'zveBD34DtDxjMBcE3b4kp5+WecKkTb+iHXDB2VvyJuxXxz3b2hofMxstEZECPtzB'
LOGO += 'crR7vcHnmMCHiCh7tvf1d9XFF00pUK26Yk9EUKdcUJe7aqUIRN3k0iaqhkEuZMda'
LOGO += 'NMxoVa0O0JqGftz6re7F9suN6ujvf6osKtPgIKsvrkdFRS22+/AeHBwInXbBuHmv'
LOGO += 'OX0OHvoj8eiRrz4RUHh8CF92g7uzlfo5OP+LK+T95OfACh2D5RsrmWj+L6LUW9uW'
LOGO += 'KclS+JSplSgZ9/WZ1DDVr7hXz9+7kqWOkaXNk1OQfyohzd4qk84P1v37bpKfHBtt'
LOGO += 'fwiWdAIRVg5PNVKl6xZaWwDdif3rn1RxPll4Y9me5J1oxO7cQlLjvchd05AJCW2f'
LOGO += 'f7Ia8BGjPTfXy44udzupLr9D8KfbvC5aTjDe5SdZVGVm57k/zxd77XYFwVTot6aA'
LOGO += 'Qa8W9CGLiZzs04tL7OgbeJtfHNzLOKiJmem4p4QC70vSl/Ax0bw+MN93URU8NTmz'
LOGO += 'wbjxPnUq3hfxXxTx30TF/55mNVqjiby4EaM7aaFsGXlCPMYZO+t6vIXxcpwaDPhd'
LOGO += 'H20o/zrAjuImiVLnYmISZ/DZ2VNb2uTDHfLY6CK9RRLevpSxDFmsrVSdoz0RVyjO'
LOGO += 'SOC9Tv39JqyVubW1tV7A0xUqmVAai37LZIubbQaPfQYmBXfgklGRmobGB21tORWV'
LOGO += 'V8XFxTi4uCp6enrmWxrvpn44mfqKkIvkxlqMZUzVmr/XabSTexngV1u4wZ4slo7C'
LOGO += '47Ke/lyikKnBbozl1P4+ty3lv7kA+cplhy2gkzWf9RObLj2XpbVy9NVvzhr+ozy5'
LOGO += 'p2PJqBQ35aoNRJeQ/WAgrlAyYsH1/kg3Kyr5xxCJCgOOyh41gkrjF+gZXJOSCNnQ'
LOGO += 'guYHFej79/tCLMlouAjEQmmMwkiicrAnl/gFb8xmf/qwcTlLeg+db85b0e0Roj/Y'
LOGO += 'xz1w8O3t7OcsIJHq5DIMOL8bNFNTzVX6MezHyG/IufktyWcr+uNxg+r+Yh2dsPdl'
LOGO += 'nvo3jQboXmV6KXNzMD7QvGyADx8kDAzI4ODgSPg5wuOpjG8/3m4EL3WGgeHd+d/d'
LOGO += 'nsvf5r3pDj+flwnv4frYer6KtFK3qcTt6FeDey98sLizi4t2hy//0a9K057PSK9u'
LOGO += '7iTWTG3rT0yjoz9My/qfhMbQKvSl6xrQI3ct7xME/rYy8FGashrD9vtqNU0eflCQ'
LOGO += 'fzYZlo/91S3C4cJJBA0kOskRKE6YxESm7VtDOJbn8SnIKQOXP6R0RCl0FhcE+4dG'
LOGO += 'aPcqnk95Vc9Ij7SIpRS2Trmf5uYdl3V2rXXsp0Ld07QweGOkI7pjsoRjxiZeFMaK'
LOGO += 'bGp23uMeLzUUatdZOAV50uMUFBR8AgOo8+mG+Ms+O6pqPezz8bmckm3+Uzvy43Yz'
LOGO += 'iv+4fsZqpgQNzH/RR1pBYoG1tRzXfxZ/eqz7DRg+32vOH5eiGHlgKtzktT0omeO6'
LOGO += 'xcslHjOU4NcJryhqRFy3oR5rNr/l2me0G/Xqq3X2SewtnhXWOI/78sxJ6egN+dHH'
LOGO += 'iOn3J6gt+xM+pdO7ANg5QfRxG5usB/4G6t/1nSiHKMqcYsKWv2Ew4K46PjZl/7Xk'
LOGO += 'L3sIIV+TjFkmVRP9HaEE3SDNt/HLjzHE8hGnzAF9npDzpIP1kPz5Nmzph1Ph+cOT'
LOGO += '01nLk3/n8NiYOpiYD0dYO+3Y2nYPZkq/XV66Nvg9uLtd7qvgIsJutjyDv3X1E0O0'
LOGO += 'bCiR7luH34NAzskbZZQQ2yqx5MBh6CuoMvZphA9my2Q9vIa4xr5mSKIPPIushLMw'
LOGO += 'eRwkjUoI3LVQzpOGLgTYPPbFkQKvC+kioC/YkaEdWC0Yy347td12nJ9rBuugHqbo'
LOGO += 'uBcZ5K2lHL1JbiSaLSwJ4jXocGlJtVOuDn5Xx+8vyq8hUGYS9tQU5C1NW6Y28m/I'
LOGO += 'OTp2SAr72E/4ZsXFZr5Kv7ytTS9EIj8NwoSJWPb46Psyc1/9qZvguQ3EFRN+upyx'
LOGO += '6YvEZeDl5d2NYMZB/hoZiey20QXF7XVuNn+xgnL4PVD1rYhmsLfUWqFXARncIbay'
LOGO += 'j979L7JFi8/WnVzK5J+GGxb9iyWVP/g5qoqpSyHsYydr/vmXBnWXi0Pi7vM6bHOW'
LOGO += 'wiEpSIVFJWZn2mvrWCw2aMm6ufE4LydezrRIaj1ZYEX2VVm1NPGJtcDfgzz4wHuE'
LOGO += 'shNx3IU/usgMqgUCCINiSthsJ29gzg0I60dMfpTKknlJFZeWfvv06VNawyQIEpOT'
LOGO += 'k4tF7rYTsaG7spcQyH3zNKoNKs8vLkxz9iOjouami9/PgTZc3uLhER6XrL5go+30'
LOGO += 'RtkrDy8wwyjje+KOcCwemn+dpOg32AakWd08+PTxROhDNOUj6g+zCx35Hal7lFLv'
LOGO += 'M5cIMKyPyAYDGH//iGEtkDDQEWL1+WHVHfoLG6dOtm3pTmfGLUSsEsKttbQF/Ufx'
LOGO += 'pgZrVp9nQD6F7V8yuvGqdN4/KuNrDQVmbfgjUw6kW/NpHfvpQb0Ty+OlNG6nzvVq'
LOGO += '95O1SjBiuknA/FDN5HMqWGqw1ZT/iiiRH8fAzKz+PoXJSdjdI72ijtmaYQ3aLbHt'
LOGO += 'KL/2XvJ+1ZUY7qdNpE//rl6T3FIkWoO8oVPbsmf6LWWgV+On52uSPDeE7dQCFwz9'
LOGO += 'rcZVLNcuMaGcm3/7XVnrWIre6rCPybfnWQHMMWXvjF8LUQc8S48bp75mV8rSVS0j'
LOGO += 'tF3Bzk574p1FfQ77OJfzdRZ1RxGPbkmMq6+ykE8yU9qJfKZUaa/8W9Vmlst4RMaU'
LOGO += 'ioHB+Hi2oHaTA2nAo+mxXL5kGHqxbpNDltsvbXX5RDxmHbWGX5W6miHP5PzOn0GI'
LOGO += 'UmFwtc675hls0O7tNM6/N1mu/m3/vu3Dn5XmRCXRpyTrm9W9/d4AEv2dAxIu4j76'
LOGO += 'zew39owZm56wCrrtMvdx8elTDA8hfGyxH3n6seX+vdkSkuj9ibHPIB11Sp0v5p/x'
LOGO += 'SZOSObYxsKU9hfPGSLlVLGQ/X2KT+pB8r8Y7cpdLrn4zPwH1a9fv+/mR8p5xcS/e'
LOGO += 'MlbS+khnbTihLaMJEnqkHh4drh8Bg9z8+s/YSnnuf1cIE2kNNDRKNCq04jGZ/zNK'
LOGO += '6DQ7Fw8PDans7OwMn9x8M2IrA8EvcogEAwFquRhF3qN/Z3lZmTKYDWxmShQOwfBQ'
LOGO += 'Mb/0e7MvSt3f319eJBRE+ZrvrVIoGVl/7rG/S3DCzVhzirn1y8HP9AxY5JG732XM'
LOGO += '+8XHhxBlRnP3pa/Xo6Cefypdd01VAC2GDgn2Ygr53QqZb9UCCvZZwUPwvbg8IS9t'
LOGO += '+CIH7KwHekk8tJMEWuMiqwLEvzVNquKBLKn4opInUZG1pokV7zo4PsIpAvVfUO0E'
LOGO += 'BKHVUVFRcVbM4MOHgl9V+t8M/K7mdES/sXY+fgATtUJyUpKaYAA9zgf/TkNcfPxv'
LOGO += 'wQgY5aOj8g2eZybcpv2o3NbT1NzGPZ/h4ehBJKayPAcGS51O/3bvx7MBdR2dDCIK'
LOGO += 'imXVrI1Qv0fSTKasB3HmWmNlQv+Cg4L6hehvJMq5Q+4N7evMV/uLN3jTYjiBImuS'
LOGO += 'G71Qd3PxH5bu+xTT9vFzsvK2Vl5zsQtSGCIcSoe5oOHSjhpnPr2TcvF+SxuEM+O/'
LOGO += 'Krb6pnHsGE9j1MdZ+GdfydII7ZOdu7v7rI6pl1ezTp2FwjGJ6oRwKYisKv1vfyMk'
LOGO += 'Jyaq/vQHUUoFByfn3OPdxdztWdns7Cz2u/d6342CQC+Lvvc6WWlWXQ14fmLg59cu'
LOGO += '/kREi+2CkZ6WiyPdK3B3gtk/DcMzz/ahfu4J3ZQJe3agoYjWocoycE22ig46jfzD'
LOGO += 'UuSOHHPQIzQcuWyGMP68acssXyp6nTy8YcLPDZ19MV4haor1CfHEAG14w+Khuxbc'
LOGO += 'WZQeOTLTTbzM5TByf4LkwvGPkyAgYGFReKxsWvuAgs+iRkhIeAjCxPKiIik4aChc'
LOGO += '5BA1ObkIAd/b78Ojo2ovL3DsfLqW22JaBTMWWHdFLV2ejwuelCUl4XC7luVkIUT2'
LOGO += 'LypB/DuspS3GpTvfa6l5LOv9fCow4otu0M8TSfgRiv07Xem7lwyPfcj0lZVQBPZg'
LOGO += 'JqOnAJHg3aD3gpx3eLtv5893m7rsbhtG5Ov7Ba+fVmUKZeDPMk28kTIIkL9JB3e+'
LOGO += 'rz9/VWILqxZLVvYSpMPYNm2igYWGihDR8oUniHtBjJhSXlHhmkWBTi5CEm/pV9BU'
LOGO += 'muvf0n/Yq/CyDwbjqebyxINnEdnDUJP/sUvd/yTLVM83vF/gUjYNYYh64/nnCLEi'
LOGO += 'NroW+u12O532qKik/LFMupgDXomi4aLIwcLixPNXSjr7ywUmdCMREn2UguwZHpr9'
LOGO += 'rFc3c3W25J9oy6/zLWgFqbjuTV1NKtppdxUMXR0+PUuEPWYWf0gTqJt8vaKB/yBm'
LOGO += 'zKWnxGf94Y2Aedfevh5T9GT+Rt3k4lAK9ITIA5PpQEyx+ftsQVYc5MWSIrQQCTNL'
LOGO += 'yzrvKxv/i8x9rC8xRNyR/k/3TiDIn2l2sdRpctDH3a1OKqitTdjcNGm0X5bR0MAL'
LOGO += 'uJ/JFWKGJxB0Z6KS+bKR8J7lqzerQ23As39/DOl7epzNpAnR0g9rV69cwwOIWuil'
LOGO += 'I7+KEn2NjQoUnsZ/DmZh/IGTvXgaMPn6n3ANa4YvQbbXWSPs6s07Y01uuqwU7UVI'
LOGO += 'Cv9Es1dmXj3mb66p6J1WRqov87JTfcP6RQTZLDeGBhjRaIOqOL741o1ZVHrL90Xa'
LOGO += 'q5a/U3VJVaojogXnCrRXaB4/CtLtiSBdkdM+aC+yeERylk7XK70umwBBobqITwZJ'
LOGO += 'm7BPwe5ErqHkkbtzR6VBuwCPveU4yUBXwadP0A0WY0TcTptSc6VKuYk62B621QD+'
LOGO += 'mNXxdnCoatnL8ZmNey05Sz81jlbZmGpVx/nZ9C9v+vqoSFp0nsV7cp5EqJIWvrcj'
LOGO += 'IfnJGlEPK2T58saUS3QqX5aF42PrNELeE3pmeOGIrUEdi/8LcFg2z8OW9tOOrXpy'
LOGO += 'cy2RbGWyz5yMiN+NLPk+VxQvCvfl+yJrIG3ruORFSJNqu408RwarYNYhf8HFlLpF'
LOGO += 'SmToL9RsP0fyyUIEME9BSuTTexYtc4+9RQG0BFCMGXOH1LJytRWnAdKXlY6e/92O'
LOGO += '65+FGoZX6iC8zcsLzBb0SACRBeba3RD1SCrrHth9+SCarVpW19A470Fh/Q42ARF3'
LOGO += 'Rt8rOT9tcb6/Gw7a7cV5CBkNkxGG9Zd304aaQzdUZlceaNdnr0amztDOcC4MvsRk'
LOGO += 'Ig4j10tUSb4ad3ToRiTCHvdySHJUK1mHoY1T3f+jjU2pN0DtyhsL+XICc8N1+bg3'
LOGO += 'gDz6TEdEtOl39TaYiGq2miMsfBZuU+vQuAbtGtP+a1f30F281Zaw3QLLE43TvDix'
LOGO += '/+l7E1MSewb47ISEghaPkyrQ0ohxB/hB2Od1sduX5MnAyjqRUvvDqBtaaUZRjNra'
LOGO += '2NhYTef+qLqzKhSdtBwejajI+7reI0GUEfXbuzD2Rv0PENSGsz3frbhPJpm9LLO7'
LOGO += 'IpWjTBfcN4m/NBEx2uVzrUu44N/UmsRaznUI1Lr/1YyoY8qeFFtT7d58y9WreTRF'
LOGO += '8dCKorvznS8NfgHWYIXJDoaObk+1R/G74F52Dy7GkjwJJ9ygIwe/QLSL6MUop0oN'
LOGO += 'DYAs5orkEgtangEuI2u/3tFOhEILQtK2tjZvqE1GGguj30iQfQyh00Cddm83tcB/'
LOGO += 'v3QdvwbBIJSvta82/zpBNJ+qIscLvm+ip9QIfAp7E1xYm3YjYtc1cRuxz8H0T7a7'
LOGO += 'j8xE8D0VXKxUrd9Y1NnOitde9mEIvoEyhsitUc8igyNfUQXaO7NVVdpogSGJ51oU'
LOGO += 'LUTE/ZXfXYJKMFf1VmLuwVaNQxo2ygMvmxbC7bI7WiZm9PzvyWZ/Mv/VyXOOz1+V'
LOGO += '5SbHamNLDFhom9UWtwE/ZX/bKTKYzbqyKBdSgf6b67MBcllcKy7QkebrW2RapW/3'
LOGO += 'wkjvz+GNLdBq8lf/WdUpva2/CX1nqIeZTfrvhMxM0HanU+X7e+m38162XGLLhWHe'
LOGO += 'Z334c79/hqmbmxcjw0IzgB3b1iZ0BYb+2XtzDLw92yDJ3hXXqX5VJqi37TRCS+Pp'
LOGO += 'rmopDT9JAttyYaF2BCsgBoku6FzSCUTaN7vj2cROGwjB4g1gJCv7G3B3vgPCljKi'
LOGO += 'vNsn/5dFDrf5cJI3O8F7UjFawe49HVacDlO/2FjRfz8EnLff9t4I+Fz/KYv1aqWH'
LOGO += 'vUMf7sGa0quR4pmAcut9rb0yCY+4S1XgEvpXvaWiig6PQlT1nOKHheSXX2Q3k5IY'
LOGO += '6swPIF4Ac27ldUAb4WOCGYf2MQTnSJqY3Kw2NnOMoY7kR+sD9fo5s8nN+8Ya1SpX'
LOGO += 'TxZBGmy9DFSmYNYsEJj0MURQg46pUlq8WmephFY5eXIzz9h6O4UI46QNPWFeRCRC'
LOGO += 'dsNvNogJljBB4Sceu6Pp7KQ3b4gNvzRXj38fCrqsr5A5JrBEUxHMPdxUYmsYGhbR'
LOGO += 'XJRD221ioHf2+cho8tGqQq+5FtmstrZ2tjcCe65Cu07N378DrArLv39XRiPmYSpJ'
LOGO += 'XdaX2JgXmKxLibgrqn5zZZcgt6W9axQ1gslGRpvRijtoCN2wHFpLkCS3Y7xY3Xlw'
LOGO += 'R01HxygGQixNlZ0J/80IOsq155VmF3UnJ6foIh0AkJRrBp/O0Edi/nk32fxryIcv'
LOGO += '5yYzI6P8+mSd/ExYKVdEeHdwJ/pVOU67cT61O77PHdn78x+hiLuSBSOrCSch95oI'
LOGO += '5y5U/MJ1cPUFfq9CGz+AOOf4QUnkTio5NfXb+fl5mqBHJB9ZZXPeTWSJcynEK7JP'
LOGO += 'RETc+cPCmZUmylZRU/1M8eupfBSpkfq/PmLOFajfPc/GiO4+waFQop/++WPHbTNL'
LOGO += 'f/OI66cMIhJuu62+vr7DrVjRqlQYdt4eipWMQJfH92mSfVcb/rLRROqmBQ2J1jMl'
LOGO += 'fVlfbGJGtrVeL92+T3nqf7e++ubLt607uwQz8wc1kgcRs8T60ZIxzQyaPxFq6M5+'
LOGO += 'Rpym8t7JmZnfkj7YAAyEW2KYkYFBDbTwewCkbZWj3dculKGY7f7LHN2Exx2GbItw'
LOGO += 'bGDw40BpvbFIpp5pd0vszHUtQzb9c2P2mSJ6sc5SlmTB5+avW/u8w2rL1wnR5zb4'
LOGO += '1e8FBRLM2rVS0WTCLWs26s+ubJYhvaVnH6DHaww13mceogi7jxKoq6nhnLV3AvSi'
LOGO += 'ppQg7sGVKFe295fIQn+TmqbaRqcstivNASoPkjVFwtM/R575RznX8UknsrifhMgd'
LOGO += 'H32UM0mxoJsbwPbS1eib/aqqzkagBhrpYaZjR4RtilK8eg9KCv66gpiQepVHR/BY'
LOGO += 'pV59imBv1VriR+Nd4+m7WvtrQQoYCzVYlxnTWGE8JzHH5UbmzfaO538Pc+dlnyVe'
LOGO += 'gzmnBPTXZTZklpEiYkzVt2I5R5ewJGCWnjGcsOsB01nsoHQ1WHRgCF8qjw6QUdPi'
LOGO += '0Ol6K6cxK9GxLZeRZh7JNoe213IMOi+4p/PZXyhwvW/Ve8uLEmwXLD/5/qv2thAV'
LOGO += 'R9pznuuv4ESiUYRyRE5/IZqNRofVcuigQAHvSyu33e77q3dvit+9fz/X+e+q+jMt'
LOGO += 'vMQoU2yE3/ob3kufksd9OVrdLZgePPrGzzqpbxE6RCPjDsiEwwkw60EYVfZ3TM9+'
LOGO += 'bbB4FdM+d6b37FEROrZ5cVb0pNLyBgBrvOUAR2q5DioooOS2GCUYIAg9K6i/rGer'
LOGO += 'TSgiZ8HBTlR9Wj1oQD3xsIkShzuoxHn6VtP1hz5u/a3yrE26VYyJYahTqIIf5Fvt'
LOGO += 'JeV437TCMZI6Z951EdR5buuO4ZtkX+qajlMQEl8t2VZ/BUjBS6YCYG3qMjIy3HRT'
LOGO += '18fL6mDwxt77jPWwJIRPvAxfs7xoLuirXf8pT3pmKHEc79jtz1LDCHeBy2KtuQp/'
LOGO += '7JhdMoBGGj7+lmBFVl2Sxz52chFu7//39PANIHnSrr6x5KIG4FblUgfGe0yVRjPF'
LOGO += 'tvn8CZEvVXbbOJY1GvKvhbF8HRmlmu9+4aCRDVGrUk8txvLbcS4mXc+/sdgwDWuT'
LOGO += 'K0kpdR2vSkQfzKT3HLAv0dWK2tEBsP6cJIZw0cvuePQPaBjsB1+hXiNss+wtZ5ke'
LOGO += 'o2IzniP6LwRG9J+G9i/Shgjn1S8s9yRjbitOCIeT+ZJV6jZgAMSei+xH3X64OdFU'
LOGO += 'LVW8EluZPZcPvHIT7vzVF4UvK7/4cUL4Rg3mcs3kkPPBWuOt4R97bD5eZSx7XH4p'
LOGO += 'W1b3yXDb48tk9aMgxOVoLoWORP1GnymcuqnV7t4LBbNj34hPUYo8bJ0GDEaCztoD'
LOGO += 'dPvFGKQCau3XS7aHuc+PpUT8zmaV9Sc+0lH+SpBHhfweexfIeXbtKHmMH27+FY88'
LOGO += 'VOdpiqnxie/NqkcMIYZkfhxY3nzx/AIODBQY8MGH+1OFh/GyZGeQldkOtvbSNnjn'
LOGO += 'Mdv5Kje4SzDrcZsNxjHgqSdM6uHr3pvnyBvcvGIpS7BDtvKRwSGiu56EcYPdFSTp'
LOGO += 'T51y4FTgym2xu8mKSodTtZgJjod6egOnoAQmJulu2eG++ITBFfRVkFhp97nRAMC3'
LOGO += 'E/mWhpOIxTDHn8CFTTzldqbMZNF/Wa5crW1MBzzYYvl8iqbNjTTvU/jwfNm0GG/W'
LOGO += 'fBylLr5oU00MDip7rLqlImzgMZjkDOXWlEPpP/xdbdWH8nuZWgEgUq5ZbVAeZrVC'
LOGO += 'ZUfA9Fp1cjIbetOadn2CPqzrdXDPww3s2sxPk+sF+l6o0mOZzC7f/CjmZ6/ERYuP'
LOGO += 'x8jadoLWlJK4j4ocsfwaZdWsr7vkSgZ5Oq0Xm+VSUkQRBfu8MUbMtQV6++W88bkZ'
LOGO += 'C4iNd2vuEXMC/nlp+juBEE9KeQ2sUtCiH1N0HcCmnL5Op13nUK7mzbMlBwk6qYHb'
LOGO += 'l4kuEApGrdP/SS1AO2KNFvkLNl8nq9Hiao93+g5mSCZjutjDr2lRboPx/F6egFzq'
LOGO += 'lJ+0hAuMJewt2vthvItFw7dSa44h9IkYzRWI17Lwlxi4WX4FMF4ocJyrEtfrFZaX'
LOGO += 'jUJRSNSks9TKhi3bhZ49tZfvOeBU7RK2PssPrNBks/w6EvQ8zTPtKd7c3Az3suKx'
LOGO += 'W1C2zwW7hLHfq8veHoX5Wxkp2ikZCGaPdNYbysrerrov29uAnJbNZJ54uWGnP4O0'
LOGO += 'yWuN1oqCul484YX+s9v0MYKvmAVdeTorUepBDAlOLYOHMLVDnHXE+rD9basYPLvj'
LOGO += 'fnypblm4hKOS7/BtBPK7fcs+5c1IalFdt2ytnvlEla55++WOnJ/nmmA0Zcj5xxUX'
LOGO += 'Zad8rLaCF5/xx63F8qKMsR0dHXXdweoEI/Sri1hi3N+g6TIwMHwA+FU9wloKzxA0'
LOGO += 'ongNHW+vj9efmgE9BedW9+MPT/dXqn4P1+pPDzfVHBjoOBefVG0WKJ0S1k6Mdr+/'
LOGO += 'v2orw8O2/fqzwa7eTndTwovMERmZIQnX4+sfVQaiZ0iY7Q852hDEwH/p5dpPZ5+h'
LOGO += 'zl1wRp1b7iScWFrgUNOOzS0ypgpNfnl+6Lo803G99Tchb3JPgSuwX2chbZq2WLxL'
LOGO += 'GN1dJZFntLBRTbe6aep1inZsv0oBiwEPM3qpSAf9Zmdz7pSJ7mCEuboJkaOgJn0b'
LOGO += 'xJEiPzXaC3hBfoWMbRuHdNGAjncKCpXvsu0sHNqZnlaYFXqkbHZFlJI7qrA2xBQ5'
LOGO += 'zXna9JeE+fC/pTNbJBJuQp56LDJlP19xIOuj5AXgyLcQxncL5RldRiDvNs3SKt1J'
LOGO += 'FvThoWDCk8Zgx62jRAhPuNZmla5IjOnQs3p9d4W39Z6DPmArtE+wW2Ul0eg0/9rM'
LOGO += '9Ql/LZnMUnVq4LuX7GaCpbm5umkHSM2WDZAHrMA4tG6b8KxsjtF1+fmBkaTKtY/d'
LOGO += 'tF9t5/areHAff9/3/KLRRPp9BzyiLaFE/sK2INGfxgvzuN/rvcq9pQewoQdb6W81'
LOGO += 'moucomnNRCUDL8rqhX6HkGG2XuBNBabyjXa9ujsweeaUrWtnRF/Mqd1m+ZgW3r8A'
LOGO += '+3aFDgr9ddSq36vfDGI1YMXfyI/eK+xz/eNvq/fVoQ3PNZhuAIC+XTYOVgSGyRkZ'
LOGO += 'RPPcdHR085OXRBKCJpLET/S/tqhVGGnVs/ldb45d/shOwaYW58/0OngQzpwspZGc'
LOGO += 'JMo5/0Vie9NBTDjKOBuhYaLYTb5qt5Pbd8d2glO6qb/p1Sldv7r03VgmMtoxOc0u'
LOGO += 'NLxfBP3h89U3EomWkyYnEvXIC/MilNjFY+22p+vlmN1kMMHO92Cu+93oc89EfnhX'
LOGO += 'qdfMYQL1ufh9ajlICLzEF2ByVzcwyPEGczKl6EA8lbqFRQkI9cMZmJjUQkJCbMBE'
LOGO += 'pELj7Q3SWXPbQ4lzL0PGe1bS3KCWudekP+3ZSUwPZ78yCArqJqeklL+g8rm51SD4'
LOGO += 'VHuB5UKE1l6+N+Cf78vkCeJgw2bnZwBguV+t+Zx8JeS0KGs96Vj2+7PiVVooyYWJ'
LOGO += 'KDVaYg1/lb6AX88m5ifwm0F69XPG8hEs5CJTb0GkpFFM/AgbbnDC9X2JOkWgXmZY'
LOGO += 'RsZGahID9k/lA1dJ6eUm7/NUfuXsUKTBMLtR7iaBhS28SNr9ortVRAY6ugH2nhnm'
LOGO += '4pOHk05DmEHQZ73Bj8nO/SlZBkAN3UZ56jF7MNXbrHf4cY8TIsIWMPgb42B/BXEV'
LOGO += 'gHoBmiVvbmZGUid+T3Ztbcjb70lCJRuJvUUvKmr4dOwY8C29/cQxQFVbW7s8Ly+v'
LOGO += 'n1Ov1b3yuPlXhbbqmK+GtjYhu+XzsmPncVm2pZlZGYC+pXMlxDSyHODEHfo7tFwk'
LOGO += 'Y0XD40TXqzcisSO6Pxy41on+mkmd1ayP0ZWqo6/Tu2ky0SE0chqPwcppTj6o7aH5'
LOGO += 'YVxFEuADG+gaeTo6POy8ctKNQK4WhkHeONexssDosEtCJwY1W289Q1KoAlZbR5yG'
LOGO += 'DTbJW/yrf9njj5EizlEWt5HvKUK37FZ+1Bw+qamplU1Pf3hpBMPDw+UQAbDgvrvY'
LOGO += '05x3nZkux+pZjNDnOqGKFfrAzJ7xekotgKNqRnHNcwtNdrlZ1WeRBsu1/fOYh2hQ'
LOGO += 'V1vniibs8eO/lv5FmQEJRgSHXpq2qzBvASRm6CUomKB1CLN8ZyWsCII7NHEg7vnT'
LOGO += '2w2NDcvAifonog00o/QdEmGzddsg5c+WTmd9131d79+9A+uWqmNHydCuH05bfCCf'
LOGO += 'CBkcGsr//h0Tkjux5/18vNyE0SlbXHCiBtYdy6yg0bQ7prLolx8TI4dsCijam9F/'
LOGO += 'bNl5giKBDx34mKVRqaMuvAeinZlydcaXrDSg5wwNDpbdVwKWwdz10exXbIC/uvvu'
LOGO += '7u7ZvgXP2TcJ7yQN4o71x5IrAdwV7N3bn+S3qyf+lg/Lpl2Js6NMbhhsyLeo9HWP'
LOGO += '7m8+opxiTh7Dsr+eQOhAGF7lba2qUmCOjuluN0B6/HUwILQR5X2fcP924BFtcu3S'
LOGO += 'T+AU/RT3O+kC3fo66qMoBa6V3ZI/9int99n6ytcTUKlDUjXEt8E/Gyq0aj6BUeXX'
LOGO += 'rQgBaq3rwYf+6G/pxM9g/jZe+WHuuj8JlTsxsNbu43UxxvuGnr6ssTMRBx8/MTt7'
LOGO += 'LIVZV6vRjnBxcVG9sxnKtlAmWvmdippa7/nOyB1I+YEVPqQM2pJuaGys+MePNPD3'
LOGO += 'a0AyEITCmnCH/eyHH2hh9O3hQ6F5BgR+yOf5nG50E90cwPYGiUE615UAIQZ4s/1Z'
LOGO += 'a888P3eej3AD2Q2wNoEOgoBHq7ock8HaixOkB5bXExISfoBR5+BXpcBlCSQV4oHC'
LOGO += 'JirjNtxPCXU3YJeji7DRGWRdsJONeE70fckv0RDqeS4uKy373X9zAcYYLd94Ltvf'
LOGO += '1VDH4KR/TZD93Swg/ykgSjImQqnPy3pMdu293ZqGw71NTfyNu1bMvYKadKltuqCH'
LOGO += 'A1qrNfX1u2qDFtecVxQJqamlDh13FnBlL2HdFEGu7/lQWe5QgXRU+XhmTg5Z/L3F'
LOGO += 'v86KigqGWN/6vdaHv63f4LifTn9iuHWYjTu/TUshN93kZDoIF308lRywtN5D+bEV'
LOGO += 'Iyg/ke8tMwowgAXLJ+yBc0DtKG/UrzGRltD68MsE7+u+c3iIWnXQw5cxTzKwxB35'
LOGO += 'E+x5C8veJP8xHJG34Qan3rrMyL/9E0lpJmMMFefmqokpK47O5h8ByKUsyb7GerrQ'
LOGO += '+S6PBG2xMzEFeSQLuWXDK8Ui7+zhYJb5raSlxtraD2Np7D/dc9+olqgtVoKh6x7A'
LOGO += 'dt/4CaJPTCNus0QD/OVnuQXZWBkYIr1zz7YGNF1I/J+fbtwECPY29KKFGWO2jhdq'
LOGO += 'Cg+XLMezDhB3p26hv2Q0vnvTABDteXvQbXQajkGCqlCJ1uOoMubdT5DOUwfj/U9u'
LOGO += 'mN4DRzRb1vjRSFO7DzvjzuFoQzL4oSKvIH4dgmn4b360dKdrm8HfC3/MmOHJDGQ1'
LOGO += 'Ffr7UXuTBqp0sGXnAFbfhdeogIm08roNrUu2y27kxnQyJ5oxaDfl2BCuNqhPLOWg'
LOGO += 'aT7oVe0KLD1ma2b2aCZvLDqpwKxvx7sa6xlah5aDEqLO4pKShIwMnYbetc4A0Zel'
LOGO += '5zd/3uXhQu3QZeYT01rDTjwRS2rOKO3REjjQQA0tIwckxVgRBhRpvlPFmGYoaAGG'
LOGO += 'TcwwyRa1xbp40d5kgfRCK3aUtQ2YqJh06gevm1wmhFPXn//dUNMdtfQdBQlPN42V'
LOGO += '/NQQE90w2KA544UyCxe1rh2r+4MIVLJfLlZp5sQD9t885ZOzacnL8ELzDi24JTgG'
LOGO += 'Uo2LNoknih9SCzvop/C9g/LfuzQNcf3MzU5yirYhMYI6K5PFENz3WjszlVcxxvTq'
LOGO += 'AxOcCKZgnvZffDbRgXMKzh0d3gjSFe8Y8RT0tDekqwyAIMHb7n1VIJeYUf21qOgz'
LOGO += 'v8vuwtrIRncw/0nbRbnYDYjPvl37gJ73LfB1AjbXayN/wbL44ak1YjSCft9xgp15'
LOGO += 'Md2wdWSqZUl9qAWBIB0ooRQPzDEXtjXHikS6ruOm9fGb9QDDHbbqkrdo5OOgAS80'
LOGO += 'Kf28QT4YMCwkzbFoxhzz3UfNgmqDw4mQqNeAnBGN8JExbTER0V0wLZYWD5Uay+uK'
LOGO += 'ECvM0WE3KDVeDf3bpVtfuMzkIC2M8L2fpA4p6cqF3a88b/tysjae+g9hQ3WjFR5q'
LOGO += 'l+NCz/GDiO0gy5SBaXaQ7oLvenmK2BrMDyULwzp3UqzoO/2DzxZeBLfArKJ45hEi'
LOGO += 'n+yja37fkcsn+6Dz17iVZF1R5guBeCaPvZ04N8hzyZL71e+2X+53g0SsLEiUy4I8'
LOGO += 'CpjNLQF0r9657nsxNkfiUAMd4fRPS5zyFWApadMN+MHchowYLSA9GpIMcNtOaowJ'
LOGO += '5eyRHSP3GU31Ugm6/9kAfBT855sA7pMfYGmpB2A6MMK1Ik/ivw0Qwf4xzoG3lJ+O'
LOGO += 'kW1W4AunQPY2lZ1DgUt/y0YXGTEmfu5bYgX0OEKGSrZVINyoH953B7MLn9FvzDO9'
LOGO += '7Dr3Meq/wjd3xfT5YQgqNkRF3u5/qKviuuB0khuvCnyGnPR5ThrXFh3Z3fkbMisw'
LOGO += 'BiTuGLmMDP9+z/5NK+iRpp73H5cqAtLQuy3cOyYO+3UET0x7Jk4PEdHTmkaJhXeg'
LOGO += 'v9oh+Dk51VDhnoUSO2xU1I1Db4BAeDu189G8YT2T19FAwSUKXy0GTmHSN9s9w5vS'
LOGO += '7It8PXM2LaaRftYAjyjVkQtPsE/FCcX0YT/qbk3aVDlOchj5LphcvnJ81Wq4ACwf'
LOGO += '9QeHqssbJsJCywwFEehJy/DNi+QvGIGiMLLSVCcM6w10HObs6iJ7I2fESCVcHNYL'
LOGO += 'IlAPMui3hfKm7GbTvck7rXlf4Yq4oZxJAklUmqsT5yKCUVP6hvu90XbfiRYeBX7L'
LOGO += 'alyEfxQc35rAQ2vhzJhv1gOh7MI7x1rIncVBnktfr8kgZGpQVSqTTeBdhOu0dZfQ'
LOGO += 'yNlAoVfDnk6gkO61k052G1h1Z3kffm0sCavuuI9EwqZd+Mtr1AXJ4HUcr9Jvvb2b'
LOGO += 'CHB4ns7svVkyZY/nOyZm/JGmIO5WQ3TbHvglcRvmPdbHnCWrzd09vLHyQdTds46j'
LOGO += 'l08Ba4bZ238gz2O88N247fF8BAc3RD2lb7oEyqPAT1tf4cFt/hdPFUelzjo0mbhL'
LOGO += 'vaPUgAVJYxrtapFoHG1ANYU8Eo9GRyjD965aQ/IZ7htO6xX3D0G7w9XxTuvjn5AU'
LOGO += 'Ca50CS/Gst0GXyNz+I2XVuFneGn+UejS0YXCg+bcFLrVYjdvC3bXWFOPQsmmzpBy'
LOGO += 'ScRrFNNAJV+0E4XbN9HOMYfkhq+yrdY+jZxTLOn+DcBeWqx7ZYlw2jBvYHvExUhP'
LOGO += 'bwR+9DX4Vix8fddX5ubmMTEVS5D3lFxbWuOrZSqFNst03txs4pCiryPIHPhpBiNI'
LOGO += 'owIRbidrwrseRmsi0z5Wa0Kor+XkzpoRBmLJJ8JfUdkFx4OO190TgiKnpFR9tuyt'
LOGO += 'fRxIC0HlCvImrletKbU60kTGMwufntEQc1NHnW/uMfGPkMHL/GeA+bP518D3Y4Qu'
LOGO += 'paCRbN5m7cvmuYjDCbdui7tm656K1602NXbc26R3FWhxolRLgcbzDBI+NCLFJarX'
LOGO += 'btoa2WNwc4G+MAIEg8jbq9sPuma0vEXKKaGskIkWyB2Yufm2vnD+yV2v0m9cjyVg'
LOGO += '/wTyIIlJSb2g5Y+CtDnRKwrTBr/M7jcazPxklR0Ahj4T1C/kWs7ePffR/tKFVWlm'
LOGO += 'bt43Rh95+Uf1w4dy662zT17u7jxR+MCZ9/jxYmIvw7Yq4t3ZfdSX2A8zN8xBUX2/'
LOGO += '2HTqF/CgR93O2mLDmDB9P6a7txYyVyOplmEj777DFvTfcl9xs/K5O0tqNdMRWoWt'
LOGO += 'rYPTu4He1WrHmPp95z3pWHnvT7gk0jFZyyREqpD8WGhF1B8nTIHdp0b5gNzifmzz'
LOGO += 'rRlk9lNYKpsHQbC7CfouDYhBaXl5U1UKZZptPC3YYvu+aqXOitGxxUpTRUuvFZWc'
LOGO += '9DF47dejRWAePXA9n8joflFXFL6atUmUrLMY2xT5BXBnUrrJlwmNu0AiW6xS9FRp'
LOGO += 'hE/F6t3mHIfGP8oNf8ohLMr7C/9vWIMV8vUWa0jZFr0azmYfK0RjMDwD9fLY455q'
LOGO += 'f2l/btyxxHI3AODn6mPcpwLrNgaezqsSfPfECiL/4MavxJKuoqci10JugjUuQlBm'
LOGO += 'FhbOYME9f+sPgJjLo/nY/mjiOt+78/ASlDqt5hWHDxoaGowKgr+eKq7XpILu+Kbg'
LOGO += 'VyXOPtX+82MWh/yF343gqqt3WBUwxu4DWZbB0dH6p+NS0ac3fveXEfdaNyM2ntxL'
LOGO += '8+Z6xthcmX88CopjhYK6fG3MKo6Cx3dVTrra4tO6x131DLA6tzhVsDiY/T45CxsW'
LOGO += 'kCYwyncJkRKMes1lpUDVB++52Sw9IuRf/LgsFuA0ybS6QXFCR+UYAdGwfbYGLi4u'
LOGO += 'k26KSesEGu+KGBhVARU/1vQDtaA9Lw5yX5F9ZkP9Ep/k1twotrlFMxL+eIV1g8Yy'
LOGO += '7EeLyoVjr76ffE5YttMspbB6NZCWGSmfn2i8k+0+Y5QChdLYAYFsF7D1EwdvuKI9'
LOGO += 'BY13w2sKjmOrNtkOYaEvXVVM9Lfnr9BHcakLm3cUOy+enH4NvxJ70oG4t1iNPOcL'
LOGO += 'fNu25bqaHLj+HgGlQPVYkFFDY9fohXy8YC3D98OINKPj0jxJbNzzx+X0e/sAsDxH'
LOGO += '9FhRuXgAPcFljHteWUOjP1FJhPAMZ3e/y4htP415QkOX2/pzJ1ifHj3qayvA1lRQ'
LOGO += 'Zm0zu34qk/nrlw6z/yWwgUiPNq5RMaPBvGlB7sOHDw3yqcqC4/xdIA+hwcyeqV3V'
LOGO += 'dj5cvsFVl/Vma8+xK6prXSFPRLfrn5tK0ajYPGz25UPAFFKLIqxXSnhJSxDy+DfH'
LOGO += 'jDu4H3wiHv1I209TSXlSwziuSYu5UwZ7pLTRvoIZVWZkNn37rjl1vSR1M5fLq9Pe'
LOGO += 'ytlNLTop2usfVn3+0hrqnUlzf+eOStzi5OZO3h3LrDMfwVvzPqoM32PDcCjGSaRV'
LOGO += 'iDwiFDhbKWTHlmL8ZRkfnpcvwucy/E1D3CpUWkLzM22pOTBcoU17u2kmcABWdaSC'
LOGO += '7hXGnE0zOabx6t/+rCaAVSNgrtlwxLmYc9jFWlR+keAM+zLZQOnaOIkv9fVeRaM9'
LOGO += 'VI86sfunG6RqiN1hPXVp+Rz/wyqUXfz7Kerce6jdhLAdG5LROP/6nx+NkwY4f+Ta'
LOGO += 'Tin2z8d2owooCxjxvl/4JTK1to5fWZDt2o9Tj3YqsmGHfZua71U2Acjp35iwZ/i4'
LOGO += 'onoUQbZWaDmICBE2jd+l5FjkhVNcUfHlYKaQajKd6h0I7b/VzTLs0vhUNGrBfDeB'
LOGO += 'YvkWkdeIvlBs9dexiHEwXu7Hr60eM52v9634rodc35cuovrMdi7uSLIzABs7y+dv'
LOGO += 'M7fd7q+uGi3ztTavmM7FGp3G/Oyn0KzXjZ878w66Cie/VEvvl+0rTY5L1P0LIFuK'
LOGO += 'WaMT33oQ0abp/BJDHrHd+i7eSQBHITAcvu5fBM9P9PrHa44M0RPK+blMu0hkFpXv'
LOGO += 'K5VMKzA1Kcu1JKaqpBYCrSrIvN/G5ya8xMoLLhvMLP7AHLoNeRMkHB5DDW3fNisg'
LOGO += '8YtFp3A46xYnRK+6AQ6NYMqJc8s1GOgELBTrbcGiTG7OCbD6X9Kss5a5fiX3lwdb'
LOGO += 'WtxWLyjMVn/03LtfpEKeysw69fSbdyJAc5IcH6+S3M0O0t4g1fYfkqrtr4qyOi6i'
LOGO += '9AcODo7Z/akzdYzhaD00Gbiic1/K+7mAfxe55RWxd3d3Njd/V18yIoenv3+qf/VL'
LOGO += '/mBzstY+bq1OJ69cZzlRxSBamvQBYPQNlSfpKSklLwh0IfIcGFFt/Vh3L3RH1haT'
LOGO += 'U4hhbYIlQ3txPxD4Fc3CSB9eK8I0LKpNfaOIqShfMOPKZkkOPKeZcxX7oITfjONn'
LOGO += 'SLt1FWg0NcJy8GNArn/MZGj7PmnMHWXlYfX1zjs50UYj//RPCorBpk4kbs8VNEvo'
LOGO += 'v17FYbDvmPEYXsR+kF5p8UMuG0o4nGlTai765yowoXgg9l6vsea9qI629lfAoN/9'
LOGO += 'MQG6h2mLYWvWXBg6qXM2UxZ1hmtjc3NzTPFfwIbFvlnZ1NZufFBIY3u9e9PW//qp'
LOGO += 'vIHUjeDLWT1djmcPe3GFNkCmtjJk5nVE68Ha0n7huzhYa2nAgIExdTkFPkvYx73y'
LOGO += 'pO+rWf6Hd8JAanHdV7zTrOvy+CB+nDwdSY5sVJqB8+3Nh/eXI7BtwbFwgllrNyxR'
LOGO += '58nwNk1j7s/f+a/5msNIulELx6v1BdYtqW7ana66R6cl5Jksl1meevWwvrW3Fadx'
LOGO += 'PtY+HqohJE7CWNGVpe9rh1qwy2OrRsz5X1cwdeqkZ5l71drVjcydUma0+jeuxKqm'
LOGO += 'DAL69cCf8Jd9an/TfFCSCUj2GAUd60At0sDgGLX4tRnQFiwfnKTh8pXDjdi05iTy'
LOGO += 'McGt6enp8D0mVtZSgHf09EggIwNPjQk6UdFcANo6gWH7x9/lIjlsgN7TMzIWlpWF'
LOGO += 'AzzU2dl5cCwbc8bnH+atXFK2sNK9LaXZ4+0Zk2FHFsg8PfqL5isjFqupo8AHkwh5'
LOGO += 'xuUI+wiQFYI+DNKD0EFi6hd3vi+aojl5btAlueyXksCPcfP9qdgJ0qE661H6vpJz'
LOGO += 'P/aX51MUH4gyoO/RM85tCYaIRjwVpTlpZfKoxAYgnFNfUmSn7r7YMAZg1umwC2CM'
LOGO += '+m/EwVmOPubGnAfEfcSTcfmLV5fFynPrfIb9eVJlW7n9EMtqs1fl5n27QTMbVGxy'
LOGO += 'veZpzae81S91SgzHyhNLkjwlWchTiA41ix0YZYQ8fSjowd7Lxd+PX71nXyY+biQ9'
LOGO += 'tDNZrDGV7fl7F4RAphyFx/yBUaNCeT3guf2dkhLYvFfJRyIgRLaRcnnr51AohaKm'
LOGO += 'wtXZ9izQXjKx7cITGWuycPJ0+Nx5t5s5N0osJydXLhtLVh7w/O+w4+GvqmqJvApI'
LOGO += 'O6q/UGwkqgRpaIrLbZJXh1loaPrcngX72hIYd7GPhhs/yH+tjoignZp4cnsj4JKb'
LOGO += '5jKsYJHbWlkizj42mqTeajgq8cv0GvtCmagsIDKdxlC+zn0+7u/as8QwjcyeVroW'
LOGO += 'i/r38b/QkgDY7kA71bQTmFFRfobnHu3+29hTqySWYhXLn7UF9z7kJtAVs9V+3fuI'
LOGO += 'GeSCjW0/pHFajiOp9j161t+xzAX/+dOM4TMxWmO/VD80ZeY+o8ArvRLAUVbd+6fl'
LOGO += 'Xb9S1zm6czHlVLSbK4a1Sf+b5Iud8ObecTyR7m1Lr+WdtKG8HDxi35w/qWZ1qy48'
LOGO += 'N7bWAdXRDUWNFni5fP6J2VpMosqd207a/Q21aRp4BarCSzQL9ygCv7945TLXUvvO'
LOGO += 'WjykTnppj7Ox06H/1ssvep/K0ogaAppTx797W6EIJVR/Fy5zfQmryMPENdOoxdnN'
LOGO += 'iztKmeDruDPVcEW2JjUtmvUCmGvUA4qtj0wZpTlWi9RPrykQiRMsktX3015Jrpj8'
LOGO += 'RUEcSLndXpDmWa6sWfkWjaqc8dFNr6utMC1BqWZqYVH2qsLiSvxf6qH1m4spkvN8'
LOGO += 'nmVFMTr491Sjr1nFEQiFmV3p6lDxlhfeurLg5y5M+vdmr7+Q1JdPmhzXyXgxVrCf'
LOGO += 'FJdlm+1fcdcZeH/QzyoQhwKdTu+mHTXb6RKLkNind+KSTMDfNHuoZA2Z9N0/fFf0'
LOGO += '7FnY9bBmq5DI79lQl8eUl6Scq3NvFO/Cb9EphUpySfDZNL0pn97wzOp36t3+8Z4l'
LOGO += 'dAlMKfmkuFNAuJD8tcWw48QE2ln0N8Mb96FaB5k9J5G+ojNWWdnQlgjVtXMwuXgj'
LOGO += 'YpW2fRrvxGb+9kSPlIedtVFr1P2pHFlS4wVGeQsgXUTPbLgsn3zVLQfx0v60GMXh'
LOGO += 'ZCrIMmxlwdpn2lcr8YFHSjKlQhocKWjKjr+/P0H1KCo3uZrLwNXvOq8EL+AvaAXG'
LOGO += 'NEVQtG/17SwVGdp9sqjRM7oxfYMkP5sJGaqenk7RgHEWjPZFbrESlx35YEMoEJGi'
LOGO += 'HjpSe8rhlf9unDd1MCL4L5BHLjVWavsBmlHCa8lQT0SssBW6k2q3pGXNX3UdOrnm'
LOGO += 'YPZrHE0GELDzccN8rX+7sCOzkhgL3NgfG2bT4uw0rpS84OjGApiQD7BWibCrAuEp'
LOGO += 'QjT9RwriCEduspbs9nbs6Vx1X1zMlvGmR3XcA1zNlKjY580GYZ24M0ILzB5y81R9'
LOGO += 'fYcnPIen6zqk8U/45uBGcV3PpA0LqV5P63RnIj+69z8G5/XPYg+MySgf0s0J742I'
LOGO += 'oTWYOr6FqAy6sppvJtUIXis77ac1199tssfuLnXcbqLoln4A6aM916g65u+/eVob'
LOGO += 'SIx1PSdYnH0Ov5aS3O0CyUDsIIUucwX7VnMA2qG4kzzR8lWKh5aNl5IosuCblCNS'
LOGO += 'ut5QEifllMxxx3o32qo7Zadxh7rTMZSQ6FrkWTVlYZpdM6KyYzznz399gBuP8s2C'
LOGO += '3gzDzT+tsvrljbQM7YRJfzTdY3+Ev8a3R9LLzEkTlDWyyw0mqoy4lUv0ezhytITX'
LOGO += 'h2P3z8g1Xp30jQJ1bcwlWHVbHLry0pKkMc9fmAgzMRUnuUizb2iIDqYKw45vpj7+'
LOGO += 'EP76Rikve26KhV+y4NW/DeGWMrNFDkvJbkAX3F/IjeY+83a1asVavkuujSQyWawi'
LOGO += 'F6hZfXWhJY6/FiP9qZbSkVXHzYU4cUi6QJ+48Sxq6gB2vDFwVX26aRwb7bmU47pV'
LOGO += 'JZsk/2GtpPydusYdO0fV9Ze91V57i1fV3+zvpETjsXEJix6RtXeJ4LTRSiWVu1rg'
LOGO += '5mwtecSxn3SlrTHaZVI0+938MNpsTUcCoLKP2vRv/9FDdvPq2hYXBxxlEdAJlvfy'
LOGO += 'XH6skP90qbdo5qROsQvNsSJkoJhkCfUbLqquOiUzVONwXBMCaGtvumWOtS0v4L5z'
LOGO += 'An5XjNGadP8lq/SQDdWgW2jgvq+rIpXU6xZCUnnXkC/rmwTVvKTZBjdlSB/RZuRM'
LOGO += 'e7QV0TL7dTm6s0x6iko+CcKj9LNlbUOv5/kF953rhmTtMTQbtpKIfpscbcQbT/Vr'
LOGO += '+GTdcejmfIg6mhkecStP96BVNP1xgOFVt/Z5LWpGkX7NN94pOT+BtPoG4f3ZBo8l'
LOGO += 'O1HFDiUeqDsD15zdB9M2kdJaAxDnnMdRyTTjIji2RZEkI60l7j/YysiEMqc12c7H'
LOGO += 'AGR02e0ZA5YCxoT4hOnZQ1w2JIe5619Fxa/1xOvPvuS20PXq0wmT6POKHB0jcNg6'
LOGO += 'Q6XprtalbW68i81j2J38cNocQ/UFuMVJzrgPC1/8ivP99t+qpbY1aQ6/iUVKa6L5'
LOGO += 'c/It34k8zztjYYtZvDknlmSULViBlYGa6BrV9UenOplU6Z7QPOx2WJ8UJ2v/UYaw'
LOGO += 'T6P9tXgxDkAgyZx7KUwnx6vw2P9gJ/iftdzcFqQAUeV3AHLfXx/rbjWBRfMMSMSG'
LOGO += 'D3jGflzwIU/8MAubjXGNc+dQQq8mZzVjjr2ppKBHTZvjefRGipPoJj1vudLoSci1'
LOGO += '/Phi5exKYqNVAMGlWJMldeEJLw7q3Fz4wDfK/FdTXcMTyo9u6G3BPlhThO2Jwenq'
LOGO += 'QusHJtcWpdaN/L1Aw9+jiS8JAft3C8PD72SqyY5fyyZxIN5i19A10svgU55Re4P8'
LOGO += '2MdRR4c0nYJ4QpNNhlR2ZwNuNM1UWyFVrr30BYTfXGaL8r1YkvikUUenb7JxLJqy'
LOGO += 'eRvfSix+3Tv2ev+j/bd+wJDxg6yYeXojxrtxDDq8Xr/NV6wezS/ql+VaaBBgCe1K'
LOGO += 'oR4LD0Xlm1iJD+3vCXcu6Do719rfIxUn6bS4ft3yv3mf5stRZtCjcwBzSKicjn5i'
LOGO += 'LU2CmhI6GbpsZttQ3zdcRmUYluGFPTVsLwz8oByrJjheZd9NjrKOics6rtnWPc3Q'
LOGO += 'Rq/QOf5EDM/YNmohfLdwtkmtSNP+8s24bO+a5bhaf7H/1YxE3z+ndl8E89iz5Unr'
LOGO += 'zyKG6av1HFgYVHFMcRXYZPW/kVWiKnoarJsxFZSpV7W14XkVVQZiH5FQwoMoIsuk'
LOGO += 'It59EFPBiaPgw4KlHqLvoXCi/LlN0uojkHVyM/B1RtWv5fCSXzjou++Eauy0Kt3c'
LOGO += '14tfmoaeotu7u8gKDN4aigoyklecq4MdnHDlM2cknCN4tfq1/gh+omph7lRDTe7N'
LOGO += 'w3hlyUmosyfLi7tFeSzdQiQ2SXGnD2/Mjby+DmOVGStXlivI0H8+bNNjYa9ENeuy'
LOGO += 'C7YJmDCizbj79I8zf2mjgfoTR5SRotTgyMi3CycCXkUaqpeA+YtgB9SoFQcMOzt7'
LOGO += '+Jcvn5ePZYCOtT+Wd+8wW8CNgZKKauq7saRnu8HCsbt8jlDzrxwqnItIHqVY/c93'
LOGO += 'vG6HalLS0t07ztpEYXKJtN3H7lurHutXT3jY2MHnzkfw4SBWxA143CKfqrdWlZKR'
LOGO += '6fn9kUJUlBzQMfsSaHannWvr6kKM/MGEVuCyN+7/ilk4T4DV8fNw1CxuOdWFZhlZ'
LOGO += 'h4vyQYlLWsIczL98/ybJ4sF2UoZsh0dcyO6OMr8NatejQJn/0PrhuUgG5nfV/oQf'
LOGO += 'A714heDDcYiJdU90M2MJvxEGdGpjeb9nk+klIVXdVAlcS6khr/38mjXVDlDwvKPm'
LOGO += 'j9CGk/hcduWBMLAQm05R+d07ZKAlVNXRIXrJ/U2bijxdqgq47KKaW1qqOjmxA0qo'
LOGO += 'Msh6giyxRo5vnSlCsx7LB5w+TQpxFZxzTyHAbkT/6bPS5Ei+eOzu3Lq6feY5eHSV'
LOGO += 'MLD1OnVEGuTiq5Jv7gg5j+L7NNbtcgDzghQQchOXj2mr599HFsTNH9GAl4HxAVgP'
LOGO += 'MPx24rQYzQMbRUVODomfBL12+TgpM/M9SEVTQWZbPRxffi+Q1U0Bbd0+4JTmA2qr'
LOGO += '3EkhYALikJOzKtyDvsp2JQQkCyVjmbwoE7+vvA++luYglwVyiXcp37WPyy9G40al'
LOGO += '/5TPoMT+y6E/x1pXCVYiroD2N6mqJCxt2v8lPwKbbjqKteMtyD0lkGFjY0vqt7jm'
LOGO += 'LyxoHS43sQKYOBtIXOwPvQElqxTA5Ijf2Kzt350230PdyVrMV2FOBgViF0QJQt2z'
LOGO += 'DRaJBPwTwsXD+2Bs/Lq4qGgyFI14Wz0wx3dak+cIyAxKgCI69FGc2Qj7rVJTs9Z0'
LOGO += 'AAfj2e5OrUwA5/d41t8MGfSog7Gw30q2P8L6ojo0Zf6qiCevs1/mAZujg8POQqQf'
LOGO += 'cEWUra2/nm5xbnKCXGeC/y0wnGDz5Sk0jWY4SrOvgRR/hmwT0bdpK4l12C3W5s2F'
LOGO += 'ArURzN7RJ7ieO7BVrPfGs2er9AW9ASuLnooqWIgM402kBNgHXB83xA7aK3Sbxk9F'
LOGO += 'AEP0K1iwlNjtouAxxeVYjqaxQ+XNk+apfvKI70miEA67gwQ2ouxHrdq9buzxWgNx'
LOGO += 'MBjtecCfvcVTix2QBD8bpNNla2pq/G+WK3V5iYS9ubJF/DKASstv+K26Oi4gkUzq'
LOGO += 'OrZLA2wqiSXtRWi0sqKXO/0iJDJehxpVsmTTvPng1uuaHejFCh0phc+aFKhPrvFv'
LOGO += 'eOsMcaQgArID6DPF6/4P0aBN+AXn5uQoAo6z71vyZBHpznAFSpX1CKbk+RHcSj4K'
LOGO += 'ihoEWQvD/uzOuDloNHclytqA0pk31ZZ8nmyAzoIUtFKWsg1WrtDvYq3PQS+OwC+l'
LOGO += 'eY8qDqQMkqET/YKDl/MinqdG0eLO7X1Jfv4eVygubXMIaeRCnpM3K+6t2QmJiW/Y'
LOGO += '2eOBbAYfyAYwBdpesBzrZhFplUebaptWusov6wBpKaZIjI//3URvFRVIC6iVJbm2'
LOGO += 's2Uq083sHn/1IiMiXn0wpEZci4hKVvVV1zSoFWT87aHz4XKX9RkaVD/8Ly6ALfbN'
LOGO += '4ldVuqUa0zDycNsNeSk1dXXprYHYm+SNo4UaKjCbTFTLfPP/h4eLC/dHpAvZk0nr'
LOGO += 'eyBQkQAi2N9VxvYmhPQeSzbDKDm02GrsTC9Ti3MbFojXtoS5+MxI+A++FZAwPPUU'
LOGO += 'equgIG1hQUtJSTkJdkK91RQ0yJJ2Gj4DVfdWH76hFMg+bjg3b5x5YuLihoCQfDNG'
LOGO += 'sEL2TxEbTBItzSjU6/L3ojlPa+g2HMGJ/IKt78ef0GaligjULKP/GjWKUhGyGUF6'
LOGO += 'eqAXceo/GFJqt3tzk3ltv+Ky/YWKRsQlBijnGdy2oYInbdjgLibZDGicXFaTEMVS'
LOGO += 'bAj4Pl8eu8KjN5GfADvnx6pDUkrKJhAv/gCkw6mK9AzDA/fW4ptm3ztnPhJ04CeT'
LOGO += 'n5cH6Xw8R/G++RsNsKHg8I2PfDZFym1oyb5vcMJisW0SJnO8a6NthK6kPoO2l+e4'
LOGO += '3uEf0wuCj58WdfngzkK9daINU/tfgXWnyIK88nJkQHS4DKnxFpq7VAKt+e3bt13Z'
LOGO += 'HmsR4eGI6z5z70Gsf5Ll3kr6MrYDde8ZADVva+P0WVIP9jhMLtsAATik8fGqwg+a'
LOGO += 'O8TwfWqU2UkdNidWQN89qdGx2/WJSNluSWe+vuAjNxV07mu0ibd/C8HgRyDiy0fm'
LOGO += 'f2tMH/kJrBeohIVJyWIRXjZTLJkw5qtXQUD63avpXwNwG8/9/DBMUlI0CB+AwBVz'
LOGO += 'hCKAdGkjRhB4BINfCBTHG0Dq1Qcmo53WX1n8LqejnBN55iMp3xftOmr9HlunR2KV'
LOGO += 'JXHQ6P0zYawwEq0FNTrDZEYxXmGSHIdkzNVLfpxU4F2FzRwLBZrXFXdd7qFNsI/Y'
LOGO += 'QHoRQDk4AG/sBspFtbCB4yaAFiGCoFQCtJ2Xn+16MA0H2LYibOyMlgtWpzHVlcpR'
LOGO += 'svvmfLPbieiog/pMm/ml2yu5kuYfZkRyKcvO6iz2BaTrmwLf+UW9Uc4UC0Ul3AQM'
LOGO += 'bQOoEgVG6WB4tM+QzPh4AMd4dgU4vZc7cyqzpSBnw/sZZnr78ZlO7v37i+jOP3yQ'
LOGO += 'F63lKZCjqT2fCilfesaf5Kqrq3NDD4pSXbZbigRSXe3vb+LbPX0iJiQ8gLlXuFbo'
LOGO += 'WHdxcXH63QOHg4e3CfDNF3MO7+s/EaenHzFVIPs2U0qvXr2a/mICCY+KCp456KXL'
LOGO += '9f30+TPsCmDcikwiN4od0YiIkElRjyb+ALsYLZYUukGxS+xWtcpg4BP2Us2zYe9T'
LOGO += 'JbmaSLE4EwEUISEiwkefo1+B1EYb4JvCo6PhICSC7qhA303OqKqn9yUtjQB0hFHZ'
LOGO += '46OPfL5Rul5eXoEF6Wlp4WBhkmc6YJOwDHK5mycBz4Ik6AjAPSIYdL37j+Nv+WHU'
LOGO += 'UgYpphcr/hojjcpFj2OX9ztcf5IqUGDzi7wHg+GXF6KIFaC2Gb6dmVESPZ53BFBv'
LOGO += 'RwTVjJi0M4TBI/KafzFfAwdL/dErxmtpue6fQZm2DgeFIRr3viGMM4IaNGtd2wiY'
LOGO += 'R/H9ESML3gbpUZPzwK8ZB4pL7a5RzU8MI1RYE0qZHfBVQOzq7F7rc1IQwe5GcSJ8'
LOGO += 'YY7KQqyWZZvn8LXnycRouxKrpkduSfb4aZxC3+G0JWO3ojVG9jLVr+up4MCZm/9j'
LOGO += '/yAtLd1xQRh0B+iUT5GCR19TK612wTb42Lrag6xtgVP15o9uVm+BJhdFpEnrhjvq'
LOGO += 'Pn6hwIMzk5pBUgTqZ2QIk828IvLuUvuCHU/++W/31ld4eLv46impqXs+SgVeGamp'
LOGO += 'oGUK5IEozR+FONYQTGVipYrZRnWLnxhYIpSHYNEkbE84Kvm00lJ5rkkbcG2STqu9'
LOGO += 'mafFLnVjml327sl+WWGdL0XTP+lTC+ZzZIW4LB8Fx9WRd4zSvoV92J/gGNOlfr/I'
LOGO += 'c0bkEH+LbkPjXNdjK2UxxtRQ2zQdbVzWZeP+W/nYblO6u/zScmuNS8qogZ17j7vE'
LOGO += 'Myts+KtLzrHphCSa4JgxrWTljhha/ogJcyL38XozBMzUL1y0gxWagkCMTIT9n2E7'
LOGO += 'aoag959y1qCS8LGJ/bz0FAI9OFRsGIYfUm+3OH0CFhK7Gc0y8HkWUqayj7BB1NTH'
LOGO += '6Xj/HLMjOF8xvF47gpRsijOJes/O/n1r5g+sxILHLC4e8Dg5OHyRC98uImNgyHp6'
LOGO += '8hHxOtj9mAwJC3sYd6QutmuyovCICyiyqAy6CxCXeLcXSoRiQ21QrflDAPoclsh/'
LOGO += 'sgFP3uDz8BlmHzMX3ULvK6heJbu7GSu7mfxa8shDcf/uxk9EtoXZ9svP8+Xt5SpU'
LOGO += 'v+u0oOUa9cuHfq0jfz8feKMkZPzvE8qjeCUgrb8OOlvPx9JYsIHsHud9SGkMe3c4'
LOGO += 'G/N0Y3G9TryA18k9XxVMNLKW0nCkPfNvlUgsmNhBDGRTN7ibPf4g7E7cBeBnCxCe'
LOGO += 'bN52AIYfMlsdfSQ0GLBa/3JUDr4WEBDYboYMpgtLL7XQCtOsH2UiMi3PR/rlquaV'
LOGO += '3MDYfPGCV6Os6rtl3xe2aSWID3jns5aA9TzbASaZ3MV3rEuf6C4UIKec3fv4yu1Z'
LOGO += '5niBFBYpjW5Qu6QUvzlqMyc3pYILFdypojOfMwnZyKGfi/LULPBeDXXmffgoU9Nh'
LOGO += 'rfzGuRTlvurT4WfroXQNHskxMZyhB/ibMv6Ozxl3FIy5s8Tc06PSKBVv7H3rQlAU'
LOGO += 'K/wdpcxGJcy+i3kEN2+OXjEbxCKENTn0fasmSqW4hrlQ+l1qT3xWDgxLhqtPwHT8'
LOGO += '9O8foL1lQhO+Sjs7mS23YLnIHMSp21E2fPoA+6tXf1zeyjbvPsdXR0St6uw5WHSv'
LOGO += 'WX0m723irxz9UOGC9bsQm97wV6Hzs+7qMgk97l7wzmgzxja4oz8XkF8LlYz2BhoA'
LOGO += '/YZ/JyC+LVsasDuXaafnGUoWz6NJuqkcTFCM/1rpubd5/0UjXCIptemz/QmRk0Um'
LOGO += 'NiQnZWXAuiym5TV8RjMO27yWOFa1sgtP/ejHqHLcupjnTVOosfU50uX1e1l+2H+v'
LOGO += '5FIj6SEfVFXPss1Ke0Sb1kkCiu/9vNoNJDmpHBtBx18AcY6aaf2mamR4+Gmr6Dda'
LOGO += '3nRhrct2d7NKmsAA6LSwLoF0wbz7OpEwUTc7HDX/07PX8qTMzsBAQ0PiIpmsHiSw'
LOGO += 'jonft8fClPEgLB+7W18zd4pFjuenXm68u1y1+L6EnDYgJvEoEbc80mBPAQH0YHig'
LOGO += 'PuwBMUWN14WF0MOfuvCYGBkQosZE2hn+DAISXASQML0htqO6o5rdxCXacPi8kEsw'
LOGO += '0KVxpNt7Hxl5Px5MZFNmvU1WdjB48/7vbwK1PQVsGMa3lYujuH2O57BvEhyQLqO7'
LOGO += 'hbhq7GRMWstF8/xJUy2KMbtKm1Zpd9B+H2/68+yG/iuhK6z3XVN5M5PDbcTN4RQe'
LOGO += 'GBNAruFuLWPEMm2lunCTJ2dYlvxZqhuRKn8a6+Ih1qqR86GpBT0jBYToYBn2Eqw5'
LOGO += 'durb8+l3+DY76t2BsDhSAqw9Vhx4QTj3HaSP19dLlHJjgCvaJ2D/khxSVET9m/vO'
LOGO += 'w6w/4CPeXEghzbmhxfHurohEHifUm4INd16xb8GwJ3s7O3cfuu+K8KvnGeUln0GT'
LOGO += 'GzpwhacmAkH+22r2T8UzthGICNRPGgcEI38g9smXfth5aiyvB9EmkYL3VobmWIQs'
LOGO += 'Jh3B2q3nc1RWFslIxBsdd0uwxHQ7wmsLMDbOP/EGgnJev+z6ei5DLGm2YahOHtwO'
LOGO += 'KeSmZfuDxRzLLaVUI5ea+wSZm4DrP9rrLqA5tt47OgYCanZ4+D7QjYbubViTY2Fj'
LOGO += 'h/iN54oqSUmB5UvJQCPY9f5D+i8ZzEsHYLnAlPUT6A+nTxRFQ5srSixYxZ+nEj7n'
LOGO += 'z0DQeL1igUyhaHZWjZISLEkKL/YmVEEsR151mgZs42wjo6OLQYbLsGAe+B0dXB7M'
LOGO += 'qOnp/Xn/RxfYZKy74bEayAM5QynwCUkAk8u2oAdYI78samcOioC5F9LJGTuLj960'
LOGO += 'orIbUogO1EUYIj2ufgVq3o086h8wqQzuON/dvikvL6cXETFYCUDeB9yipPR0OeAh'
LOGO += '4no4++ZlifsGfu+kz8ktCZpLa9KykkV3hmw7WH6PQ1yYSVXhlwdGavI+lJVLuNFa'
LOGO += 'dS4cG7nICsLu169fS2J+qx5rVmi9wkpzXKztexRW/ArvkjpijsSG/jntQHt+DGVS'
LOGO += 'ifav6Js3Q6nWZc+ZPLRgGuRo0CJWeZ0l6BETHg7ygftjvOtc3I2ARXMO0wCUXVre'
LOGO += 'vJ3/7r8lbUn3557z6Gbpt0izI+XdmOPgfSELJn+ogyjUfawGeKlIzOtK0HnBZkyM'
LOGO += 'sQbAkth1aQG9xCjwQhEGSMELIuDeChPj0qwHhRJIJth2fnfN+bUEz7QuHc7nDq0l'
LOGO += 'O0GJ4VOaNtcLTwEQ1HfeMwyOj/dfTIiy/hWC++E0HJ2Cl0WrTKV52rqev/lHO1/1'
LOGO += '+rWaZY7XgoaiWlAZq0uMjSJ0ZdKKZoKto4zba2NWl6J/SuG0KO/F4dTVO45rtDkR'
LOGO += '1yciDz7zTmhxpMp/bTTU5ncQmS0rQtTz/hDe9WlDhhYhHim4KT3Tz7C2I8NwmB5F'
LOGO += 'zWwaxY0FmCBMfQ8I3b7hTbu7kLt2oNI+Gnyk5OV8nnX4m3aTXl3O+OBIwGmKLnOK'
LOGO += 'KKCw5LeCnnmy+oVWIaPLog7gQvltbSQBD8vrRQMrziPMwOQTs6r1r4CUlFTXjvNr'
LOGO += 'EM8Li6J9GTqYryYH4ubYsjJ6EOl//85mSFBowaukmDJQuS0ZjZgEkJVI7878ls/W'
LOGO += 'g0ZkUM+PxKIIymSz8u85zwGB/dciwjW2zxnMRE6f8+oAD2oXn9rALf1o46o69DY2'
LOGO += '30daMMVLbLw97h9/IJi/QaU2TzuUSGEN8+hHfS82dFNnV4ghvYZ6/F3UBeWkmBpX'
LOGO += '+QJ5rWnDDh3yu3lug3D0bJCcEWayvJyBnC9zrG9yIlX5kTB/cLnCPmTYsGoO6Qee'
LOGO += 'DXCwGc0RSb1ah+Gu2acqCzLQ0fro80UCa9eEffaPsqQXyi35+3SK8v260uhtpYB7'
LOGO += '1UHTBDjuLT3oXYV8GSwZgqBmbSUtrnKUKZRu3wea03hzMTTyLFQj9BsfptlNLN5a'
LOGO += 'uTy2jynWi8FpD3wJwA9xpk06jeuL9YNOrUqoHAXvMOpy/RvX0gJCBHpyAdxa1YsA'
LOGO += 'Jl+CmQqYPouSSD0bCeWjtxnqclxGaJA/KpjOlYNcVmugqPAerh3Z6UnfsOA7Obl4'
LOGO += 'gemx/m+iUA0xYixhymhQj6Jlxrf3QrHmkBgONA3dV4LQ+9EjhpFflHVCCtwRsWCM'
LOGO += '8EYze3I3i3RsA/uwpq8g+/fHJ563YRQWdZVZb+umEf0KVEgLO5A36VMx8mg5rV6L'
LOGO += 'fFWOUk175feu0SCxjpJIGezdn7T3F6+dNbpWbOqD7bq1W2Z/nMhDYvN4Vm8a6BYh'
LOGO += 'eDr71UFeYjjIskJYTB2Z5B4/4zSi8h6BXPfuqmE4nQrGhfF1DKvE2ODqRJA29Sx1'
LOGO += 'xyvlrekGnDrPss96R0+QVZ1XJ+/VI90mqCEX6IgJFsbIo3JwFykcY223WGRFrHmh'
LOGO += 'mDIfg68rzXR5gu336isV38x+6izIEDBNk8Ecu1pFuVBPiYyM/EyevfO9m0xANQKJ'
LOGO += 'a09yu0Ivds+ipt6YtPQhMHi2vOMEC+6coWzOSQTD+NUMzIrJssm6BBGqVPRgy2VU'
LOGO += '7cBWDexwG559g038aJapm4oWFPfZXzo1fIdGcQWCe061cWqR2L/W8P/6lA8IrvWh'
LOGO += 'jAyQf572soV2ciO4lCTzJgZ5DdEIiJ3UVmZZeFQG2kQ9iIqvT9kd+aLNezByFu7v'
LOGO += '8JfVVHl89NOE8uzuaQdUgjnkNNHFTTkAzubOSOceMsNcGC06Uk5xvR0hajFRaO08'
LOGO += 'weKuJjG+eEM99u0HAaAVnT5lTrxNcsqCMMDQ5CZSvJeYoncmRUfgYE4q3DoIZ2Rk'
LOGO += 'ZLdbYJsZGHaPB0y4nnUMcW7tv/FZJ0p/BIdl3fxlUOAvWX92ijgqXVfGQE4PAQqb'
LOGO += 'W1vDHtff3bXyJ6ejUl7bWfzqj6ENB24X54qCpri5HrbCnDhqnq7LBA6Gk8RPsTJC'
LOGO += 'Ox2B2kS/7Wqtts6srKy4Ll8gRt6fLkYpKCx8QZmBGyQsyNaGjln8dJvXD3shdgDR'
LOGO += 'j8NG0GqQkuE9DojG8B2ad/ByaeeHwnFgGXb+tt+sRQGzwfHUbmIyshiwPOfLVnwZ'
LOGO += 'aEIHgGIeLZqI+3zRm4qKKj4r6wuYxPJd3sQqvOPl/O21EBABo56uUYC73Jif0Sn9'
LOGO += '4MG3HBMWwpcbmW+BqotrfwYUX8IpTNrQlBJgRfACyAwOvsWMj0WRogZ46DnMBVio'
LOGO += 'Mun9wATzXu1Jk1ziRiYM2GC3fIPCVwczA6moP08ODfzvzMmfpwBJVQL6wmhi5hPz'
LOGO += 'r06xhugjc9jZLxNrqK71Hh74y3Ctv8k/f4fTjNnmaJflkCXGnPzRb+0DK0+d9wEH'
LOGO += 'xitIHbOb5hey65z5ZvSheq2ILzCiWi/UM2wSr30FycDZJpNO9gUslU+0NoPl8K9e'
LOGO += 'AZ0dcqwPYF/6nVUbVM/jHxkCMKnev/iPd8GCdYcf8OLaBqvq+S2QVXGe9KD/1nBf'
LOGO += '0M3OCsX15emZERJtiWuHt3/YrKOAvoS3KSTkd19v/JVHWsUK7KCUGFYQF4DpX7XJ'
LOGO += 'IQ9ISWaqO/+9A6hCET3y0+1WbP/NLJzr7igh0AUmpTBnCbiVf7UcGR1F5VvbOpsE'
LOGO += 'FC7aP51EeVgOepxQOtanx0XIJtUB5ic4mka6Q+8c3+3+5k+gy9adHtUtyPjM1hXj'
LOGO += '+XVx9IIPRlR8RzhF/UILKaBcD87miiK+IuSdMd74PQ2xXasH2/KDLvzN12JU3alR'
LOGO += 'Tk7OF+xCFF5OxFxIqefYrmlZRUNjN8qvYdFOGQcO0J/6TdNTwwA5TFTw6y+zCq82'
LOGO += '4V+/P97y3+JIBxXQ87nQerJ9+yIxOhgwbFuc8UwZeidcIKFqFodopBvucgYkjVbA'
LOGO += 'ccZx1AstJXzDVeAMQA+63r4gAfCC3Z6MODRRcXJiA+yUz5dgf+XOj5qmPZZWAQvg'
LOGO += 'JUEgpCJYV/7Uwmg3VQAH0AohstjcrwoqOECYszZbF0FpG04fGKKcmD1q8ACByeGB'
LOGO += '/INOhvYIrzrRlWckh+WG139g+GvUiYuQjmBhLtxUh7L354rHoQnhr0fIMumS60Vv'
LOGO += '1AbXwjrk9tu2o45UFLUQO9EnZMd8+f0djkoa8dphO+iyT5Vc6NfP9xpDGdm26Pou'
LOGO += 'NQXVJdyvA/eXbP1uNFEnKROJhKBc9aYdX8vi5uEWJOPCGYz9faoPkZfvgAfd0e0b'
LOGO += 'lNAtRdn7VEbV1lcNip9WUxc1kCdndX6ENa15R7GhcAWIIF6Ik/ueQkWTCv76LtD2'
LOGO += 'K8f7nX145be7U4qrw+JfadnAtPBgyzMDSoEEPey+Qty9CZ00u/9VYD/SfQzCfpGi'
LOGO += 'pOYC/+jaHqzG6OqI+4wDD359QCuBIj9/G4eNkIE1gUZ37cRVZQKpat99Kkz9el64'
LOGO += '71dfFryErPmJegsy9OAVNLpAlsNPJ3R++f3IPgvZAsrH8QY/66mJm4bfZAH52B28'
LOGO += 'lpYrXrCTNIcJK2tg7uuqf5zh/GoZR3+eC6ySfo+Glk6RJrPrrnKJr5+VexGhKVh9'
LOGO += 'oqzutFHSD4srg1MYjhXdFH3nLVnJap1cNgLTMDy2Df43QE2glOWKIEZZIr0DYh33'
LOGO += '5Q4De7Lrn7XsD/jiLf66t/pNMCRO5J0/e5iTtVtZYDtCcXeaYpdrJ6xbEnB+Po4k'
LOGO += 'zmv53uOUxvgzcegeFPP0oCv/CRH+8yyMuD2kCUvE54pot935OxbN8uknVBZH14dg'
LOGO += 'rQt4u3A7xK+RUD6WsL50Osw4JWeuLbD11VDQY0dt4s+rLXNrPxk6ou7/7owfQ1uF'
LOGO += 'dXsl8q+lUrqDyO3NmzdQGdHzR8UA0X0csBq7mupAUWGcgN+P/rZFt+P26s4XOGEq'
LOGO += '5G7xltScmxqM33oavLpcZ9qwWvQIibat8hVpedsg9I5KZ5TvppDijUqpWHRsvSH0'
LOGO += '0vxRS9gbzlNXVuOcS7aqkxvM1CRdhAZPab6Zy1gxvRpEZWsnwdv+XSVxP6SCuHoQ'
LOGO += 'wb0sJTWLr4tcEHWasxc91zsEfCXugF6S7vLkND+me/tGuVDH074eaWbhGYk7PTz1'
LOGO += '2XhdixDBICBQNHZkh4mVwHb3FURHhTnQiyrdpewT1H1fEtKf4AanqNFYRHphJAhB'
LOGO += 'X1ZKxlDvWFZyLMp9TDDRxNJnlwp/6uYwdeXmWe49OZ7rLbdwuTaueBpr2C27ToZd'
LOGO += 'czLqRYd+EcoiSZIMb3W1ZiDe+2zkgMPJmiAK/XY6SIv6ISdX1oj500C+QOE3vtMT'
LOGO += 'dG6+386pDAS06IsQrpo52FHta0vsxSKPPAHbIyBGue75yUehFCY0vK1dZuCKNhj7'
LOGO += 'likkOL8/iXev/kY/oeN9WohuHcWuZLTkM+VgOz4eHrIpwA8dY0BSzUD6i04cWdn4'
LOGO += 'NDejtDxjJ4NJRHT0FXvu/W/xOAKXdCbT9fxETviwOv2/M4hFg54Z7bkfchsXoZTy'
LOGO += 'UyfD3PgjgqODguoprL9H8Y+1Rchzan4ybBvfIb114UwSN5i043kkNQ5R/oZinxB4'
LOGO += 'd9Lc8RVLwR4y+5nK/jPj6yo76gQgaTaWMTMzo3Zov/r1rUwFRcdLVosRchwyXMJ/'
LOGO += 'fnhK+Kk53CI1XFlNjVqYRf38galEn9xiHQNDsUmMO+Awe5JIDr+GM4wKnYrlwqmB'
LOGO += 'yqovnyBTXC9Emy02RcF3QNr3Fkp5tfVR8TebGplz/JvdN2rEzyN502njCYH+vGph'
LOGO += '95iBF/Aonx11muyjYG+d6AmHgSXc55olnky0JmDeoD5bli8EHVE30NXmLF77wzDZ'
LOGO += '5sVD+DMXJkDahhfbo4812pUJ30ufs6mJatYoSjpO4Lx5aronUROhziPExA42Tb37'
LOGO += '4WAZlQ71xo1q9tOYkF5Jug/rOeSU3BZODYs53uqgO9AmVxA5GU+T9Sm/lvbcnQaj'
LOGO += '1/fY9Leh2UJmNto3lQCO1mYrYh/10ZHMMkUEXkainZ+P335a0o9lcGPX2nsLkWUJ'
LOGO += '0KC32UYeSmVdK6vOS3NgdolnhzoE69QXkEP//EIO/x2neEHVICZM0jMFAAsGH0x1'
LOGO += 'jVF3jbn5m6IDtaAZpH5z0EAUmjDdL4C8HWTCZ6xALiopK0seUCOB9VdW3E/Pjtm5'
LOGO += 'XT26g6ZARjpZSLHTm3VMai56vf1ETaxtUQqKL2XsT3g9nH+Wm5TSdu2LU7bm8Bb8'
LOGO += 'GwlC9y2KW6ti9E9TsrKYmL2skr6kFKK8YkbYlw2evUYVF3h20iCup715npIln5oq'
LOGO += 'lH0DKK4gE/ZyhYWFtQ9cm0oUswXkYpdb3Bhp6OhmQOYHbaLT48RAwOMvyUvKFqSe'
LOGO += 'gXBo6mW6fyF7TvroOmZNB4Rro0smfIS+x9rAy24LN2dOhzsHHocMLCzXc6QAka0H'
LOGO += '2RiioOb7Wl3V9KIJFwiN880f2H1OuXUP15AcTjS8cEe+yXmTv7whp6iA1IjrT9DN'
LOGO += 'p1rF45UJrZwvzTYBY7U5V8M5B8aoEJfrecMANP8Kh5VjeC9ilwWf16s3Pj/gb/yB'
LOGO += 'ybSzQLZIDEXswNYWGfjiEnxDX/aNNFxGDWV390bWKpHXr8UNOPmEVz0MXl4i+QEn'
LOGO += 'BCgZ9gFRi62tk7tFy1v/AY6JlQMngtoIE8pgauiC5s2PgkYANQNJfxHgFEfGxpaC'
LOGO += 'v3Tu3V4PsllEChWshIupf05kXXu1atWWSiECA1CuSDP70n4D+5GojEw7fEWWnlDb'
LOGO += 'rgIh1lOaQVT114l91PnI16/0SQVdxnackZBaRvEQWCetVxxKPka430Wlfyjevw8g'
LOGO += '7vFj1fsRB+CPwWN3VRMTSuCkNQWSKxJgoKBtXSVTrvAChmVqwEZcjMvjfFvuDVKO'
LOGO += 'htoDkDaWvnjiAsLQO5Dzraz2vAERGdqJ06tCSNzoHLZacGSSCmwbPcyFnVwJXhGT'
LOGO += '98lXVqszH7OmvYQC+hKNC+VlW4GURhOYnGg3EjEfyJK5WrFBHBLjzAZGaNmBpxAZ'
LOGO += 'gCqe1E8R8811IM6sYp16pJwzx9+qO7BqrZaO3Wf2br9AtRSMdClindK7wexTWcAp'
LOGO += 'u66fw0fddABcDWxlgKk/VU9VEuPi4NzKSy+dAHeT4ooKpuHBwTywWXOnaWBcon+f'
LOGO += 'pxr6I90ug5R6eHjZ9+9xZD5/2JvhJC2xfjVQl7UFviactWfbcDwjIj6C2S5OpS2L'
LOGO += 'SeCgGP0qYH5UnndKXbayM8a39wsD88KuDamhIOI6j1D5jkqqFiXo6mJcYrQoAZ07'
LOGO += '0940zgeXHT80LGzrL/CROLSvo/+mom/U+2U701NUs1iHzHMDKv9CVSNOgnpCjLkh'
LOGO += 'DTYZQy5KpxmOwRJlwteLwIY9/Uo5isx2moRhqwCXJx14WeLxZDJT7G+A/HXHrWeH'
LOGO += '1SDg2398upovBGr5H4B2HpeQsOlyiWw/zdQji5Ovoay8cVQ4B4cZ8ZNAlbgg1Gk3'
LOGO += 'FAoqX4xd6YNps3yG3AHMhvdfMlUKFoHVCAVkZqpZpAbfOeQhL/Jp4YHYsiq+3hFe'
LOGO += 'puk+C5MvL9yYIUnelY8wwOfGR0V0bWFhQUfUkpdTvVQyqdWog7aImOHV8lySnwuH'
LOGO += 'SS8iSEWq3fJ+o9mDJM+yQP1bzJ2XiH5tiJzcpZSIn59yNLLznSrjjfGFvIHSt1yG'
LOGO += '+1/1o+raNHQUnpUaaCNSaSXM7iBPeUstsISphLsViPOGU1pKwYBl4tj2ik+dYQrI'
LOGO += 'gnVyXQ3rIvLQrJFgNF89n/GVCTETyYKSPQGpWTdfHLoU97v0Me7jleuQgvs6+/v7'
LOGO += 'exyaHtSToGa9Y2OFrwmAl7V64RnwUWP9CFgvdyFJbyKhU0dCQNZ+q2aADJs13O/e'
LOGO += '6O9KMxB50PT8/CkuBXDvsvJyQMMgBGnrMODSgBK7WmOK4AAMQqQWCDFw/psLAFAk'
LOGO += 'ADIdXfWA07F7IbCCuFnVfOj7naLz8cpn8aFeB94BOHf8+B1KDNJcvr7HYMX8kidG'
LOGO += 'jX0vL3/plNCqxwKWiyBRbvwzFE0LAJqXP6hkYzZKMh0+eHgfHCw0u9AZ+Bw3BPqf'
LOGO += 'tCO47n9HByxwcTB7ZinSAe8tGz4PYCseDUb7AvB28Ivfysv3bnQ7YwWDpDS1Ucw5'
LOGO += 'coTr3hDX+NNp9U5zYIOw8iJWZo1jI7Pa+MnRxgSGCJlN3pUh1EqXvy0M9/q2Ie1a'
LOGO += 'dvxmmTYi+P81zjvvAGPq+burUAD61KcuOgT0psWiZnr1/jQbSYrfFTRsqTa7ZLBj'
LOGO += 'WglrH9XkUe0aP+rND8YAASwGNq18WTKGN/+s2StmheG+RptquXtR1Oc/CtpOCzeu'
LOGO += 'YsZhOqZq1AiLPJMoDd+D0rm2gPih3naeZeMGMIiaZbbYgY/jJTB+SKvBl18m4DAL'
LOGO += '50JvAoP5/lLDN5xRctBpOpkZWYH0pgx77IwsjRVWv9tdXWO7ad0f2zkBB48IX3F0'
LOGO += 'cLALKOcwf3B+bJ3iLCw9TdM08IIDbKLuaN61/VYDkFuYrNDmFGXLFfETeGEl6Do0'
LOGO += 'w6moqHSY0LGkokRERPS4KGUL4MaK3NP/bTliMTxWpuy5mjd0vCXhXXVN/K6WNX/U'
LOGO += 'B/hCRQN9bNEPAXklx0epZ2SQTYjQoLs6T5mvQEBohh1X7rJ6dVCG7jmOzzyPhcYD'
LOGO += 'ng1LxOu4RTvxZxmpDzOs1YhIuLDwCwXsm1D+8eLdRxTDTjjEGWyIH3xHM7TtalF0'
LOGO += '2euEACkOgCVcOYRsEONXryB24TZLOJW2B1v+IemaGS6CgVLBqY+vLCNfW0S+mvO9'
LOGO += 'I2AQ16Te8+GDY78ZHlBuTrGXZ+TVzd8FrJmeY0OA+dty0S4hMGaTqqiEDhBFTFW9'
LOGO += '05Amg2SNL9EFEYzWc3PKSSAvr3Xa9VGf/g57Hf8ebO8xTGrNZY333W1g9PSfRwFZ'
LOGO += 'SaC/mGywdVutAGJ3nM7np5OXwhqATXfPoAzylCjrx0Ckc3Y+wroF5BWSrq71hg3l'
LOGO += 'RtTalOYwyt9Uogk5ZbyzZIpwf3KdFn4SaScwSv2Yh42WHH5kWGbBJTzascx37Qc1'
LOGO += 'd31tVJD+SSqvKj0WcKAMAIsgrktP9YvUYg2RV04BvWd5xeipCBpEOEv3J1Omdr13'
LOGO += 'OXcKcNbH/Cb6j8DesQVJfeXnZ1678O7nW4QqmNPb96xz+0TPgYdaZ0Hw28ldUMnD'
LOGO += 'PBkzw03I96hGywJXdbeLTXVx9gbPnw/fkZEl6vBD/izWISgJnUl18TQCratWC47n'
LOGO += 'Wd9kPzUvLz56GAzIgIO+BWiGcKDkSCTgP0CmpqZCdWWr56OA7QigwQD463NISD5I'
LOGO += 'OHSYFuW1EYgkyoMXv3v3brLRXne9wCSEdq7ikffxK+kXkSR5LaXFE8ATajNgBf0Y'
LOGO += 'TL4vI0OUdnr3wCJwggGp8xcWBMh/vSDvAcAEoFAOm3vA87us3S9Ma4+lk0qdvod0'
LOGO += 'R8/oZlCbKhTlErCkjm/QvYaGhthJgsEop/1ruFs+50B55o4KamVIXq/p6P7KNHAt'
LOGO += 'cVmbN2R4ueCYfJ5T7AQh+U0N60NoZppnGPBJUcah2SDO5LSMUbLmyMjMcK8MuhpN'
LOGO += '55zKE4f5QvKV484qZgJCY9kDu/7JQF09BAjTQsvTbZE937plE2OdskLjqJTJc7wf'
LOGO += 'DopoBC7SP3sau5EJEWzD3GrWuyP5An4iK1j5BXDRB5QqoS+Zx1kfTkfHLj6czCC4'
LOGO += '/nv0Mu421KZPWrzeSTWcBjZE+vqRto+ehkPVgHo2s5cOQBxWoZGjq2mQ8Al5AlbA'
LOGO += '74AxQl4yoyZW6FfzIUCI85vAYfrFk+Q+bUZvwi/GKMH3DF5pPVeuDhv4Ys/wohA6'
LOGO += 'eSLh+yjmvQIoio/IPG1ADNRRU11eXgCYzfAkM980WYFjLBPIloBYzhUktgx7ACCN'
LOGO += 'hEYmpOXdDuAaw5Wb4WRGmH8dgO3X8vE39AtjLoaEX2IghpSqaVnBoDpVBDixeMkc'
LOGO += 'T4iiSGIBwbR89Doy3sRE2GdaaC7Jz7ifetNNhjw8PvvdNFugtOPjAHplMWguAC8r'
LOGO += 'AKGd4Rf+V3e4vWR8HylACk8ZRF8vxiKrDnSUBYD+PDw+Thv28/d8AKiCsX3lPbTj'
LOGO += 'DDAlPBAigzCt4CQjsmAS0ORQTxyznHp02b+qncTnf7p7HtocTYQiMnkNM3vgCmKt'
LOGO += '7TO1uAJA/2xIXM6WZEmNGs/ixz4PE9JNbf7a19Vp/1E+lCXxilSuU23VC+UTE73v'
LOGO += '+hNerilwn+zB6D9wnX4R6KPd0irl/Hlv8h1696TjoerkH/jtnxedazW0tPZ9coAF'
LOGO += '/y+GuAAzksyjpq55DXkvPb0sVnIjYAQy7Q8mVoy3elNi3eCTEmjeF5m2gymFCHCp'
LOGO += 'oOYiQEBvzgWMNc+uBDTnd17i9Rda5AQ7sPAHpEqzpuWdxYhEMfAiCRomoMi6TOs7'
LOGO += 'SiIN6UtBoIepQI6XnZ9Hn9SEXG3cdwzbHOewe2EAXVgeEMgZ7pb+Ah0KbMX7q+P1'
LOGO += 'TlEvIbLOL4rMLmqCf0HIelNt1OjDC8izYC+glVGkpKTgXf7rn4eMjvGJJWMeC7Zk'
LOGO += 'h3YGXwBz14F0TktlA4MYYNHj7IZYOfSgbNpm6hqzKByn6bEeafOJyeT6ZJ5GceL6'
LOGO += '+HehvNqnha7nPJdzsu+3TGdnZz+A0fhnFWYdMzn7QcAuYge1u/IUX8ePKR+dnHl+'
LOGO += 'd/06dL+vlO7REkqJQcEnWADNHbBxodNSsruujNM3CXX/7+HkwVYWjfg+XTl0Wvm3'
LOGO += 'k7eIz7E3CIo+kL+9wVt9IrGnJP8y+BXk+CKAlxmgkMks7IWFBWAK1EUgDsSk7zH8'
LOGO += 'Gf6z4+ES8yMz/Sxh4rN2z2jxhASaAOKe3T4GR2KZhUh2d4a2F/BKg4IY+t/RVDXv'
LOGO += 'Er2MWT9+ELxkx6Dvq3Sb0J/v5zvj0tMj/j1945QDVRiiQD7sBRFvj7n3gXhfq5Eu'
LOGO += 'Gfqewb0ohV4eBbuIz++eK8dzE2m2OA3KhYNjTUr7h5a9dMXpOdte76zIEtfgiFas'
LOGO += 'BXnn9UZfHF20EEJXv9M6Xi0SbQKXA1O4gvI3JUFg5Sr073ZrH2yurnWpzjkpz5N2'
LOGO += '7d/HFbW9SPm+fR2TApCLILaBGC34hoLZCp2cAEADLCrqdX0GP6wTzpUdz5QgVNsb'
LOGO += 'gWPPGXBOfE/Cw+WjXcCM58fzBIPQezgAPBgY6mtSk5N/1038m5/29Otb07QNJf+t'
LOGO += 'fDFzA502TpIZSPRADtewNHm18mA/9PhB8qk0yfzuYf3ZodwQLJBh/H3uD0qDyYCP'
LOGO += 'R2Dc3yibU3lj2vFj7vOYpY9Oxe1/yZDzLbyHt9fLYtzPxKJxc2mcfM+Dtz7pvJKm'
LOGO += 'HoFaKXoqdDJNEovORZMGJDFa2GGQUDX+96hDaZltq0C1l63/OqjZAcHoSovqzhA7'
LOGO += 'RgljNu4Hvq3TmrUiG6WE111aHJ4UhEDmJ2jiRNw22/hOrxl8KXX0whFB+Z+eTqV0'
LOGO += 'Dum0mjJ+kflq/FzNxgn/VCh3qM4Ls4y7t7eyOQqfMpz0C2ZEHD9dPQaOSNtx75vQ'
LOGO += 'ck0pc8b+CMf4R/tY9yQEiYGJ6+t9hN6457H3xdCH4qbVo9b/USkoruAZ11cu2h/7'
LOGO += '0ZxmGrPNLCvevar432HTXsDdiKGN+QqeDAsq0qh5l8OckEomDvpND9/KOxSlY/Vl'
LOGO += 'ctKmuldmjpk6s3Y8xCLIz/RFq4GoaZU2uyC2+shHwue0+VktGJemG9Rg2ARYQHLO'
LOGO += 'DQ8M80fEmd47rTIZ5QtJme5Oo3sXZc7aO4LEt2V9phq/y7XmRtE6206jPC9mfqhn'
LOGO += '5llkENLkNkFDWB4ZfkLynvHnjKN04L++/fWduZBWsWyIkTseuOrm323tZjr2l6tz'
LOGO += '5/Y8ygbwj1hkRyhQ72DO8M3ipTFGfoqM/J0SswUlzPTnmYk11KFJ95a3/a6PXio+'
LOGO += 'FXSpL0TcDBsezJJq1ECbHbr3xWiDMkrvZMJ9UqjwvWQZkvTEwb0/KndS/PoEdxhR'
LOGO += 'j2exnH6mthCHWJO+2RgJxHlhLFky2jR5yGx1/VvekrI0B0JXdNmuOj+K01X6mrKX'
LOGO += '/iwcc3/p07ya+/ESDfURoKx2AbugAUBJULbb5UCbOS/6Vhyy7U4wYKVek62p/335'
LOGO += '1ALvG+7B00DPvaIY/O6jzxwrEccbFpZ+wDjqa83xOcFlQXRoIgZzIptQdVSQLJfa'
LOGO += 'TOlbMstdgn/WJnn33SUunfafiTzjeqFU+GbV/q0+eyHzzRGmGdrJhR32PnK/7Yxf'
LOGO += '+WmzmEP53hKjcdNWx4t9tuUzZQTUwOT8543QK0S8ePkMLiQgmcX9dwyYJgMg0FK+'
LOGO += 'IBRXK9yyhd7l5j6DlB/PvWW8kYj+cF9b1VifxV9oIRK4k7Ke+se77a6PKe3mZN1w'
LOGO += 'cOwCOOG/VN7peeDzf+QLReNsvLrIcHUpg4LmEFufSFexU6Yau2dz+ULrKKaANTyv'
LOGO += 'Dfc3NOOta3E40pZ5dNfKV10hBXI98nPexulLtv0LssdsMxbIWUKHkrj5h9n683VX'
LOGO += 'nU/rn/fw6yMjdSrDiPDx6WbHCwvBGm8rdr48nSIJTiwlnz7B/+kxFrcYOECSse0a'
LOGO += 'vzFdvlU60lGglJDqJZp5AsRgR6ZR6KrFvtQb0wW7RqLjQEDZpf6S4SSQvdAZEDC5'
LOGO += '5cMRnUWguILoRCQKYfr8rrrLdrVJvNhqMsDxzA5/PFP3b/unLl/3j6rvB42qxNCO'
LOGO += 'KhJISdyQUMXk4zpFv/pMQpf1XV5OI5SP6buUp0h++0dKTx4UZaTyChmfAl12FLkb'
LOGO += 'z32zFwk4wCA9/wJ0crslHG80r+r5I3w6ew0c6TNSS7jR+WrZtxDaxK/KzXxmljWS'
LOGO += 'NPLfMM6NcLlyeVc7y8uHeXelcBKotHn8HZqWT/xCkXcFPf5esnNHjnIA/2oet5xG'
LOGO += 'yDmf2Akqe/C+d2OwwID1hQrIVGse3vv3c3nxlg41Sbu93QoIfDtkM2a1i3vqIfRA'
LOGO += 'ukLxufXrZ9FSLwUahnCNcUe8VeXjpQKCOZ+Nk1GmwP5+LHqMg5z23qMQeqxHztuL'
LOGO += 'vrRkZt3GDVBEBWtJloqSEpg257dqw3S1tXpRIM/Jq6rWobPeSJDF7MN9xGLIVdSP'
LOGO += 'vDbAka7p3Xmafs96B1mJjAhFsF7UAvTQ+WH0fUDKwCI7uvJ+RU7ueKDnw3dq1eXe'
LOGO += 'TolexK9sOjnDHxcTdIi5M5ZvyBao9Fse6xXmPM4PvT6LLwOvbXeJrgXM8RsOIWOy'
LOGO += 'DcJEiJU/4Fi7RUIQ3G7SkIyCixw91MKoWhZ+KZmx5o42BnVY/pjrFEBmDZDaV9wE'
LOGO += '5rJbYN7piW0CVTRe2+5Jzb2aJ4sdqM/PnUesTDCfs+AzkQ1mZ+bw7Gx4s3ThI0Tm'
LOGO += 'C6w5U/BnDs/ILawfwxEV90iMc0FSd72Ze1fq20sVldeqdK9e09DABTx9azB3hizD'
LOGO += '2dbREDG8WWIRX5dTpoqNbF53COk8JkG9BIlY0rX+pO+VrztGOJWDSbC030PHjY7n'
LOGO += 'wlMkP/FmN6Dozfi/37rXCyR6kwpHQWwTJ4O+XIwjFt2SSMMQg1alJygxN8qth700'
LOGO += '+lMSUm61Omy6pWH6LeHn3276jGuH7F/u6CaChxRlNTtLF9vQt2sbWY+WCcnUPNUV'
LOGO += '0tzMtmX8sYAwhS/zHlBgNvLDyHqIHduM77KE+Ivn7OTRJiuTkGZsE/P7y2DKqf54'
LOGO += 'w1RuUVQUe4QxZIhS4eyVdlqIDGCBgRS69YnfOPf21pM82JR+twIU8vgNcC48sj33'
LOGO += '1hpA24/rP3xVNuS1pOvYI09vC+cHNHfSrh9b/y6/elvIHpKu8Y6/cj3S3aBXbGws'
LOGO += 'KTgzX6Z1FcL9blen8cF2XAe13LZR+kCH2vZV2Xjt5XfHjsgnzYcAQbWLylVqEWTX'
LOGO += 'eax0dDv4KMbf5HUnTVhctbcmdQs2tjPpIhKvouNUS6hyYDGjZTryGU2veeJRt0df'
LOGO += 's8AjU6qOfrzVxD+XGL+ZgpvLd0l/LbIF8qpnC6axSM19mSC1DgUDv3HcVIkrovvj'
LOGO += 'Yz6GXuXHKMFsxf/iAeW7NJZYQHOe0/e6liKr7WnpZ2r6XqTdcUp44fmzX3jL6grI'
LOGO += 'fFugTgREVQCq9++t/9gj29hXcbmZAxa71uLxIOHxeJH7jOrVhsdeeYEOL8CuLOkj'
LOGO += 'LU1DFpZB78r6M+1tGQ6J7W+lmTMOmPUB7VxiY5GxZyJILtsfAlot+pLvDzSKpO75'
LOGO += 'S0ak48YE7KgXzi4qQQHR2/B/nlf/pJu94ov+wm3Hq4tSRmtkQCO4wJB2YvzNwAU9'
LOGO += '3BHJ2Nluo970FUk7AnNVmzeafHCW4SP6X19z5ZlOc6MPYxoryBH0mDY7nMr6S8N9'
LOGO += '7rD5w0ATBeCCsMD7KJAOAQTLASD/CAbg9+opyYQwQhZfvv9CG5jlgEcU0SzeUruP'
LOGO += 'R29v7+0LjQy4ob/w4KlEy1wshRbOcTJ4T7b2vtiClDPAhyMBHUI+naNvWmuFIf3P'
LOGO += 'HZshIrXaAeBaYAkhdb2h4OcnBGtrEOCmAZGfw4/f8DNGpdYXgEB7Ml8oiwG+YAMj'
LOGO += '4DbYceXnz59nL2oJrwtuTPXMGUrlnp4e4P+BAcQV6K9BhcAyLzOwtJmmJAIKFTAE'
LOGO += 'onYsSBoEXKlaZHyRabgQkGly2d0RLIsZI154cEDm/ufLoYbwgzbAXPCBmBxiF1bR'
LOGO += 'PvE6Yb2BkB/lilW8a8UcxUGbh2uai9YoNzxhCn1yGPONlAeUaxk8TtERVLnJbFqn'
LOGO += '3H3WzJnWRNJlZp9KGYO45yTKoxW/4NRAgj/Sl7p0yLtquOE5wH2NH9nBmo6zMDe/'
LOGO += 'K/sgbd+PqqyoiP6ygHzRYSEhIfk/LoDZtZguF4ccOJqKg3UVZdhPccBo6LBtWXUA'
LOGO += 'LtilIHmKGEsMVofAA/dlWQhWg7JIh0DOB0BwUNaRKbpbkbSp7dc5YarQ4Q/wyUuy'
LOGO += '+LZNy35qZWCll6VYevnjBfUeHS0CLRDkFC6jQ2TaGQpk/A6KU+lZWWOBs/IQICGU'
LOGO += 'hakjW2O81PnaSBMPFgP0TH+928gCZaAeWXWJfWzGY4EFyr/fKy/KQmBkosrVS4TW'
LOGO += 'oNLpQcDLP2HrryOTSXra/nX9HlF8nROeG4mltBE67x0/3F/C2/nmRtTdaMRbcVdn'
LOGO += 'OjFbls3gvZqI17BsMfha7GlskH3IQLYdLySUn0QMW8waHjtlbz7mW/He2PAwlv9H'
LOGO += 'QByJpRY1qsngHjmhmn+vrZ1+uQBoqQdAAfS2uQ3UKmWEQ1S4/rtqe3A3gbSbBz3Z'
LOGO += 'dMW13ghMH7pUKyNGdhLI9s48UQeA8ihwcuI5DeQ738Wq4oSksBqyaImJA/wVKusW'
LOGO += 'lIjiIZt32fssdN9RwF6dQZyrRsozeO9Xyqim0odno7Iu3FLAiV6C2NgKHag724GJ'
LOGO += 's7uxVA3x18Rmi6U2ytzfdghsNCgIPscu7eOH0mE44NVBaEOCuCVbW+h1cgTSEsiL'
LOGO += 'oVk5Q7yLU3KsQcMUidZR6zIBBbjPQ1hZlZBpvT/4d4AarXflpUAjBRa8L+oxINAD'
LOGO += 'NIXfT2BRnwLAL8BfBQRYshfFJ2g2IJUR9/N3HpA+pflfJ/8ppBN3Coa64ip9MbAG'
LOGO += 'NWuAQb3J8MREKdjRL9ACGIleaDBkpcd2INP2tb4+Cezrr8AIBhBGAGP4A0hPeaI/'
LOGO += 'X2JnC3klKOaKKFhO5BS/iDwBAPHSPgHQz7gYMpb34wffCzgClngqDg4sQG366/un'
LOGO += 'OLugl4bgdqTx3lSty88DF/6J5win8EMEFnccLs7vBw3oy7+4yLu6rnBCrseYj1SV'
LOGO += 'zMHN0YHR1FOR15DZYyySJNe/InWo9/ZbtO+SuxW3uEnTsjj4LJGPtky2VDMn3EA/'
LOGO += '+NqfkpHxDoQveGRNQES2BHSspCK+aTFkwu+AB2ApQBVmakwHrAAoMn0EYOC39x6F'
LOGO += 'W10MRBHDBVBgeNjVLldLomCrwfl+7Nc+9o1MeB+gY8nQ7X9+AKOXro/zXKA+UNR5'
LOGO += 'NHDMWdHsflv0lCvs8+ucn9clo9hEedxeaHmxxc1826z1jy/p3z8IZRO48NvHkKXK'
LOGO += 'b9+LbH3ya/0LaQM73mlEHu29/6h8q5PFEviL6HJsO6evLGYDTv+u5obm6ZdzXi7c'
LOGO += '5EILGyuh1WK+b2Cqt+6ou2ZRXYO/e4iN5dVLSrH4YhAgIklvVCUEThxbPGguCNvH'
LOGO += '3ojoCMJPmn7qyD1wn8SVj2pPWJPFt1Bho/e7Jf2EHQIPdxFrJp2tBH25TcNDP+CK'
LOGO += 'bf25aF1o3LoQ4rpiFKXErHvP7x/ibqKBrz5DgTE/dWG/8mNqgnDoPeDM+4HVq+Ys'
LOGO += '9bMKBLA8uvm2f5UqkQuA8tvNqw75lSs7zlPApE1S5HmgRSCFLDj7j8618NnuyFxt'
LOGO += 'y7eshBLrp61DpxUAkStIhqIiLTmC0gZcxj2wGYIeLMxAzwiAIbvDR2FCeMLAO3g1'
LOGO += 'zTZUwtH113nvNGa9Jmm4VFKd14w84uYePo9X/QsqyjVgXLHc8PNwwva0JhXZA428'
LOGO += 'qFERDHdAt9bszPV29XbPAG6bqAEMQ+/2YgroL4EoF140LMKKsxV9Uhpu3OcAWZhx'
LOGO += '1Pe6CqkzGT+P/NB6FNivMQOETIO0R8YCyIu/FhT0TOCU0/9HNw0ALLTY4xF5BXij'
LOGO += 'DmgSlW8GoxxnOG97ml+RSlR46Q+vlpWgnIpF78T3Jaz1buoj2XyIDY/yRXjk13r3'
LOGO += 'O5erd+TZdAilF/5PUrdfizKnQ8ZYpg8iIxaUjXqB6PPdBIGAKz2Lx11oH8FDgiWF'
LOGO += '5XorA60Z0ctU9Fbuxx93wY67XQxxpRmofyE0l9Oxfj46EkZ8UV9nSlcGoBYiDosE'
LOGO += 'iGdHR0SUv6Ef7EDK60R+LvCnzv3+2H5/+C1NNEAEHp0kHIgWibFG/R6Om4AwTRpw'
LOGO += '58BYAD4XdGsgvARQ8nJeg2ShkVZaVp5FwK+KXUqoACoK1XodHE7LUFzsQaTGHptj'
LOGO += 'M+bKHEkohk2NW67gjjD+ypVuiU9ST5fGEjLoY1wOst+XpUQdFfxgUMTcW/VtbkbH'
LOGO += 'x1NkhPXQ7RHFCAUU/qyojwlc8iCrffhAmc2KHhb8q9rQ8VAvLL3Rnnef81NfwEU8'
LOGO += 'vRek/fVw4aT1uYOFDznDfqvSjUJOdeHZUmdA5wTODkAqj66IdrG3d3biAdoJhA06'
LOGO += 'tWZI7efDjJfbiUrToPSInAoOUA28JKzkYgNU8IOrbdVhv0harYT6G60lB3IWRKnV'
LOGO += '/rCRTIS4cFnUKNdKNSYzGPPUIl9TNuwaKfbiRAV3ZmbyucMM7FnxfK23HISySspb'
LOGO += 'pw0sE4cRZW0Zzbnh3Etn5WZbDKybSZ3r+bzc5lXHlf5WBeedomIJmDMNUjbq5PcW'
LOGO += 'J5qRB7ltwHjC+8Vjvd2nyfwitaejQR++G5FGwOV9G4Vek+h7yu1kulTqf74kmSht'
LOGO += 'HI2TPX74Tmmq4/+Yaw+qDdozeBzX5I/mq0u3t81AyhlA+L3Xf3OEXwZZHOl8YPB8'
LOGO += 'mFCLl/DzNwUQ03/TrE5ZmyfuZ9/tK/rwdk7LgXYjb59SA6G2akkIvmDJr7g2WXHW'
LOGO += 'I5jllXHuEDWu9sofmUCcle2jVLOPucQ/Qn7Lk9JhWyfExYnBIKC3/emy7FRUbUUe'
LOGO += 'dMOeJmJykv/VsWe36h7YSNwmm8riomcmGhDiJ/jIq9nz56RgP4XDYQBPc2CrCeTF'
LOGO += 'JdkCQLnvQYemxAL6nh/+9rJmSSu8y3xM7FHQ1nYStemaEj24uPDJtjsm7zHU8L+e'
LOGO += 'Sigk6zDsz6cuNnKPaLJvz6Z7j6c5lyXleN+RQogHnqx6ob3wLSGCqu8nOsyGsACf'
LOGO += '561cLmBsfAEpCX2NklVj5fQ/XOsDEd9+/Y0zBzXnXtJ3SVi8rKwYQGTS5LsmC0Vi'
LOGO += '+S/Xqsx1piAji3hBbz68jEiCWS0/FSN9PZJu3BY5mUNTSfICtfwbdsjvCbdxS7Iv'
LOGO += 'PfyUlD0Dam9qv9kO8NpQ37AZWKIOKt7ia5e/SisdVJzcpFT69TuLE3v0AMsRcj/v'
LOGO += 'HJiBuuEXscUpr3ldAGGIrTW47Ru1h0yP5CcgWD/ZRP0+AchgD++6L1VxHRoGxgCQ'
LOGO += '6BLWIwL6PUZ+Rh8Hhs3vuIxBuGtuHMnRYr/iYcCgPQVeqNKHP6gogRHzsusVRbur'
LOGO += '+Tpc2kUVsRqtlIEFp6wl4d62HQsS5gJysujKyJU9UgNqds7kX5/dz+rfseHwCUe9'
LOGO += 'aEdAapJjy2I/vJr9X10iv5gt029Y1Ndd7z+lrRuyBB3/SOU0pIb9bXzmfO2vDW9c'
LOGO += 'K4eN4np9IxQI//6edPOP71c3NnRAyygBCYQDjRciBIjWWVDqxLB8lJK5hSZs8C4q'
LOGO += '9v80dv5DSNMQud+nsg4t3T1dAcXoKvW+yd9U2iWahaUc3epKnRhnxOxJc+5FdhzJ'
LOGO += 'jTapz5s2A8OGPB4XZgLj5Ub7fxOc9kQgCHz1irD/hJwH/f1jSDnvN24sYqh2xDLM'
LOGO += '4svc1vCa3Rk3JORrirPVr7RbyVc1OxwDe293v0zhNbbT0sPrJQwZENuDBMk0gQna'
LOGO += '5NbmJos1pndqdCdCXiF3BNruWnQ4tcMDLuo2EEoVg3hF0nAYkIJsJ5rLLyRx5XBo'
LOGO += 'hJklkcRyUe79CqMcpiBPR1FcOaAgnUjKe8PLlcl8fz8u6Xcnbw2aHLJZ33aHH+0m'
LOGO += 'saedFGbQojq9Yr4Z7MGugyJyiYe/C3RwfoSfVE3ocGH+Tijgqm39E5UkQz1LhmOg'
LOGO += 'qzmfGTPdjY8MSMcvQQn1t1R6XNDF77UlnxtTJMb9f5O8w7U7cz+A7L2DPYdDwSPg'
LOGO += '0ACx+D1wKC8LeF5q/+ulT2ASI4Y0jaflT+cn/rGKLj1YPTxRUPC/uQAY+15XfDFA'
LOGO += '7CsEpJQ5L/5ToDzNlQpyaUnJB29vARpa2vsw+b/LssBoY9WhFKCVAm6HONn8LqFg'
LOGO += 'fAc8FGDz1/+F0DSSQ2oeB5pnLkM6M1AXkY+xResN1c8aAa2dPwsZihT+qUb1OwI9'
LOGO += 'UJ2keREJ/j9dhYZryxIdmCz0fovpNEouDlwJqmFgn4FF2QcdVWZzH+AtkUqCiWZC'
LOGO += 'FBkljTS3rXcgoBP2s4WNn3crtiMh8BH8NfTy+JcaMEMNmkeUwzg8f6sRayXfu74O'
LOGO += 'j5Bf3HxAw5dKsj7bu2JPATmWU6dfUdSA2/lxb0Isdy9x3qo8ANQxPmiQORxtaNml'
LOGO += 'bNBS/ZKP/as+W3pu+CKwi/JSwTgLjTbBfnToFbwRd2D3ayY2Tn669F2m+NUBIUjA'
LOGO += 'RlZROsQMF81xhp8KGaqXo5SeNVhZfwtbmXMmEm6PeHTceotEWmZTxq25WXkHBAT9'
LOGO += 'pB4rQaFofQ2GL3YwoGHbrbbggoRtL83Wd92fu5LIgXS2H3MMRp1KhqIrDugCjhgH'
LOGO += 'F5vtFjleFIQSCFm7vYBw0ftSY4Vunhy1QdmJKXOLZ/eUfJBSnesAYcO2bGetYFGv'
LOGO += 'M+JJEL4LJeMCz8ZvvNMJCv0VaqC7eCWzTuo5sGMuBJnxjwLZwJwBEWTEAQ3jRTIA'
LOGO += 'sqRg/IMlAf0RwRdUwvxx1k/8khsHqZVuQM7m5p5jg7m0GPzGJV556Y6cn4qFZ7P3'
LOGO += '3pwnm5W5yjuX/cFNBm1z1gNpYfEe6d5t2kmAPk7z7SGlkZ+P0iRrqPWCb+fVH537'
LOGO += 'jovm4w6VzVdpFltfacZMej4jhRIWLKW0NmYZNUzVk6rYZzH2LcBr28434ywBAdvX'
LOGO += 'Hz8WTvVBSRdggBx8+GigeCCfW5xAesGeTdjXbXdyLwCVu8/lPybVeIbsHZCLLP+u'
LOGO += 'heCis6szxje6+5F7UbZGVOpDxdxrkUexoAGfRPH+Ut2BYGZGq0nZAV0DCm0K+IMs'
LOGO += '253ROnQkWfZ1x/BuF6/g76Pa9i/FdpXFbrzbSwaTDwvnaLtYZI3EUTqyOyQCjcAM'
LOGO += 'EKrCqBN5B4qmHA7cDUtTWSPL89SljuB9DIliW2Zms/SvvvCwjup9ZNx4ckMeNyVT'
LOGO += '6jpuaDmm2HizGBbPMPXuqNyvwKUxyxgnoaBD9EDiTSfH9Ed5pg/ZCxK9hqJB1lf3'
LOGO += 'HUoHt9IMaFlfv4rTu0vag7myCHQvZFpQcYQLODdHCdSMHFFw7FJD2877B4RA7kAk'
LOGO += 'hYpvK60C/FYKxzkC9RPWNbs7ubIy76INkiY/qvV0CsxLBD09xqGftrFVzfvwN6x/'
LOGO += 'Ul7/pUONgrB7M8yyb7Hk7CcrZBWPXNszPHFUz1kK1W6BLwPdL5pahnhp+iUqJFbX'
LOGO += 'wL5LIX+/5zUCgVWxGkJgSQPAVBDgXEHa+GXZDxxxS9foXOVIc3ygqVQfbpHvbpdB'
LOGO += '3QCQ2hH30KNTyknSyC2vzMZhD9mRXF33nwy5BbbRPykYoqsFXJE3naMs3d6pwX2J'
LOGO += 'mtBjGaNI6FPo+qLzsRAu8K4BFmcY4qciLPL4jsWXDWpz2i07jVQ395EKZuYfYoXF'
LOGO += 'tK7J5tAvdtmYZL31iar1H+z6cXoBtsIho6C+UMjoWyBQbQdtV9NLgaWbBxTYBItI'
LOGO += 'Lt8AAId+b/y2uGs2rPzdF3WMi09xoOE8c9wwiZl/gkvfyhTMmEZw0O8Hn9zTOyem'
LOGO += 'WvQIobp/idqutr4Xw4aOGery9RBG73IZ9U1AaahIK1NyvPZYF15zzzSG2iBs2eM3'
LOGO += 'jfuyOZmeJvXUUudyupdkjzJB4ZleuWRjGPDU8EbMQyC75I1KdeO9NUhXFhujBzW2'
LOGO += 'AoNH/PZTibGqK0LeCfPXvZ3ONQ+KJcZH4gJRy9neqB1BySRwFT0QRXdDxezjR2f/'
LOGO += '0hOkBJzmFJlzLGRu6IuP0B1xQXfp7+3iRKZXcweMMldDFKQ6nvcSOjJdnzZRTWRH'
LOGO += '5JWhXee9am/mfy4wadf2sqkmrZcbsuBANJ2PQEIZDODwfoboYYUyNOu311D40ia9'
LOGO += 'NBN7ZjiU30X+apLoV12T2uFllZJHfVThExM1ohQfckrvXOZugaDpvy9z26ND2Hcc'
LOGO += '6mpTNkn5oXVc5CDoTv3WVT4e/XZALvAmieW3cZU4FpyoiCXan+bHO41fM7dfSAV5'
LOGO += 'rPiIc62mqw07v3V5v1oC/z5Yhtr6Py5COu3X1qsrj3KTewjZzTQGWM39lv67RGbW'
LOGO += 'F1PMfUwjOrMnTKqfplkublqV9hAmG4Jh678xsj1noo7iwuyZ+DVFtMxVMQ1KcKre'
LOGO += 'MOFDIpMD/WtihvOaxPvfBIxHM4noO2rGzoRIxFQOnLaTCXsre3u3vBEDlTx/FNhE'
LOGO += 'GRweF6caFIDe9VPegNmkGExaL77EdDe/Z52+ikl82f09SvaehshKEXOHIeVYPpv2'
LOGO += 'J9F6WalH/ESSOqfivUnjoFqa0I22fhzsfFvRrnFDOSObo2XSZ6evsOeOs6vzTlBx'
LOGO += '59j7PvrP5NpfflgdDWE8sge7lBz2/N59x/XEdYs/+Bf7M6fM1+Czl1y5AlTL8nEJ'
LOGO += 'gC7gmBV9GuYqXibdFYem14G2FLkJCRLYdL9W27cRJVCl3f8gj1NTMcI1x0Sx1L1/'
LOGO += 'tHPcx+rAGUQZnNU0CF6WWNdLYy07h754Q1B01hlLYf3IDXUhw9HDbLIto88SFPta'
LOGO += '3ZIj3X7SI5wCyrq522z7wY/q4KaEZZwnUXpk/wFtMvskbkjO7Qd6v910kVzJGAuw'
LOGO += 'IQKrA19cT1vBWuNLKwDBcO6MAG5eUkLCh70bnOqok3HOyfG706UJ6vUlOQeyPaTB'
LOGO += 'AwH2zBZ9/N9Xi9L+vAZRG460vZ4MqEf+GpinXEyTVVrJbNA8w11CGHkG+F6TYS5y'
LOGO += 'iL2Nb2VuuLCCGhDCKD3fcBZKb5pmwwdg5VVhTc6rQndROIsdeeRV1U4JuBUAxARh'
LOGO += 'dcl2yRjASX63v8M0g36kDE6NhgN2iHPzYfTwraT+fpYuFs+PFFWj+tpwbNin3Y9O'
LOGO += 'cwYWFpOqFm2Du61hD7/GDbdvtjiQdlu116Gx/TQJZWvNJIqTygVfG32J/2p+Lk12'
LOGO += 'idvysGhr4ja7POLztu3Y0u21ChXskzd0vbTHOLnUtc3un238MF60v4kg+Tl3hfD4'
LOGO += 'O0zkUJGzJPXLF1TgUnWtroyefwwKOAF8Khj6B7AgA4ZVwIbkKiVjQvBAqMVRquTj'
LOGO += 'j2YtJ+2SY4uq3Kh08dz5q/QCTvEfrLXuVX4BcuL31txKY0wiYV84RW/Ed86/qbIF'
LOGO += '7H9oyBxgO92d2SvNfCu2efL8XfyDSgzLUWUYdYihIfc2NhLGqOLqL7XGYE9pjw77'
LOGO += 'K7aUmxUXpcnIv946q6BpZwh5navHoU+3uB5IgCqJHNuk+MwZgN7hltJnbfVpJoRC'
LOGO += 'g6Pyw7pjh6KgUtiPX91W10+nSbPryPd93bnBHTw/c2cW3MbSlDb52VgDdcTIEsqy'
LOGO += '1cadHuK7+RG64lDHpbtMIAqHRKO62HFMMBeqV6MzBeR5KC2wWQ7dWQEtD8+jEOVs'
LOGO += 'AZEURazWDW192K634p0df0geNyf1nY/7WnwqJnB2wQIzI1JuPvge5K6qoZs+K/WV'
LOGO += 'teW+ZZwApchA1ZG0jn7ADZZnLSfK0yDku2zYZ+Jtikq6UtgeP+Aa/LkxMviGrepR'
LOGO += 'fZlZN1DXYKgunI1F2jLSL6rvN0gMNhNIh9OXGSN/qvXuiPSOQ4TuSFqVGpKuzzxq'
LOGO += '+EMlfu9hqqj7j0A7P/oGbkjimJrngSn7oi42InmRntkr7O8SypGXXqlCpgxInptJ'
LOGO += 'A68DAMbMgDoYj+QYG8DFrwAQiMbrg9NjSV+sC8b0SzGA5D4HMOQGt85esHE0chGh'
LOGO += 'fSchCP+nNKoZtw56lcGNVIG9Z68UpPITXpnUut9ff5bh+j2kW9/tERiVvuWoDjCO'
LOGO += 'ysqEcsG1JcRyOZdzr0ItUbOQNHB0d/nI1tkp0kUC+4WjJT4dD8EDZCeSwAIa8GaS'
LOGO += 'kpKkgLcAxh2NNvvd5XQIPB7MZUKvb524ZWfiHJGfbOqd1zus3xdtMQ4bPhEl6whB'
LOGO += 'owEnetTKwGcu+yssnnBZalLSC+3KCpQge1ahEHFY4QM0fQwbbHzpb9TU1Mpg2aNg'
LOGO += 'eDQYT+UfYwv89IC3GBeYR2fiDZG/oNQ7ztIg2vOEZ+9ycnmkwdbPevuLti/eXCWJ'
LOGO += '52qm4wlHwQmNmlmUumNlhUOVcdoeU+/9+apLAMccHGhxBbeLQRB0hwGPQQmNCEAz'
LOGO += 'MCM3VdYvH6dE0X4RM4JaLxaPOfh2MUv3LiGE7LNosgNU7+NOxuqoPeXKR67HiPYv'
LOGO += 'f9XJowR+U0KrAeDiRfTxAjdr9AEgGLg/jGXxX0TCnQJoZPqF9g9cD0oKPl0CGzVJ'
LOGO += 'YETI5dcOKj0pi4sHnTxMsSJb/PnDok/Liyof3QZN+f7s+VMUpmpaDxesiYZKKwv5'
LOGO += 'lqhJPK/ibzroDlk/JKjKL392vWjt5jISKysqRjXp3V7EJsBWAVDmQGqiuKLR7dND'
LOGO += 'WtSGNItn5MpqwnbBGlN+GF9sY8XaHk9ia7B2y2nf1wT/WCQ7J0nWICR+YPkGKj6X'
LOGO += '0fgIYHCAgaEeuHgzfsquAcA1cNqgFHDahH2pvU4P9BUm/KMuwMxNfMwQPFLvebaZ'
LOGO += 'RxjTuzgeXVDsv7VrHx/0IbF0+Ww8hd5or/nC61myy1fhI/ZI7z3sBT30L6LVSXps'
LOGO += 'jJcq8/+lIvDrRCMVSAJibF+dyEX6lMKWI02ktwFfPFXCmRHj0qQiXRtvyRK+jHuu'
LOGO += 'Co/Gr5yUnu5pk79pvmaDsu/ZoEBn5kWJrYiN4Ad0ZgH3P2nKnFxUZLFhoLXv355t'
LOGO += 'vfxq4GnRvi3aDwC/mfes7VLEPHaA1kQNXOsQD+7aDViBoHMKRPKSLRh1KLLW1m8A'
LOGO += '4irmTda+PliGPFOaRevIe2vRsVXv0iQO+4tF36g7GX171S2LN+FadrYUk210P5Qn'
LOGO += '3ZMtGv/zOjKw3U9MAnZ3LhC4ujuovDOB73ObXZbw2hCNQ4hbirgMnSH8kW7iYpF2'
LOGO += 'wujEONPZp3k9+LQvmU3vx79icAsqTyS+bGxX0N7jRlm9PwJ3wwLgDThVaz5S5nGy'
LOGO += 'lipF/xvkjsVBeelCMM+oqqjEG7e0pyMmg8yT90n7je+81XxV9s6DgOt+3IE0WDrK'
LOGO += 'lcP6jkI5JkfIb5NgqzBjpy1OE/d2i+qW9hkeGIlo7VHg1auqafoywRv9Q4AeNudN'
LOGO += 'hp0U7p4Gdu0R4Y9WGmHoIRNHJ87N8skc2F6hKNQ67I6szwYI/2oTHFBcyZ5xE/xV'
LOGO += 'XaMimXxrUMQQ3IwjOHqqyDG1jApjkdhE3eNpbQHhG/wcfUBAwqttrJo3eP/+/YtZ'
LOGO += 'oPvJmgK53+UrkF35Ajq6Pt3NOkg+EgGg9wXlBmOHJPAyUdPWlnNoEqQm/vFP+0XG'
LOGO += 'k6xp8IqFIH/lxf5HYTXV3V7788irknBfy80MUWc5qTv4J5G90bQQeKd5BKZPXqPm'
LOGO += 'qLsncPPDoqhver+HeuYgcr8/cJoiX4ZYYWyUdSOByoQfQcnEQsC1JhDyZAPmT1+A'
LOGO += '3wdQI1gZ5oJqpXm8zonbN6HwA73ffS71EcQS8tZdIEvOz1WQOBr+vQYIkcszC+xH'
LOGO += 'xclqqECrv+vSEAa4JwPYSbmbTJguPGzWUsJZsTnCMkNQvAKl0W7xExALbAImfFdh'
LOGO += 'rEgkWFWTAVUJ17/w72wvNnKABNEHYLHIMHJ/AoNq/IvdseBVB1lgpwLyFvE5OTG9'
LOGO += 'vVLAJrYAWPqB5gkWwodCVguY4E3S/4NUz+W4RjKv54L2wix88VC70QVU0BdNPSAa'
LOGO += 'UAi1XUfmAwYWiNd+Az+RAZAt/+wHNGCTwF0QLKC1BG5AXwBeoghSsrIIpANADkAI'
LOGO += 'ihP/BNAb9D//3BDbf6h5KIEldjmVUGxvJ0+YMudVmB6K67Z9hyB/zZ9G3/KzGLIb'
LOGO += 'i0a00vPKdKHIfBu1wdaJ04Bm5OdPB/94d29yaHy8Ub6ib6CbqPgZ3Zx9wxfxdzAl'
LOGO += 'w4dsd9+cvoQoCcT5TPm/B0OUUPX+D9StaXeY+BOhUPMw5CediKmKnweA+uSl7QC9'
LOGO += 'HEm9jqLCZyU/j/8YqQCw+5fWt0Znv9IZObDWdL09Nc4AUP7V/tTPy6pd4KF2ebeX'
LOGO += 'q0u0/mJOAwY+64c78LdtHhUnDn+EmT1huQ7xFIiwOv/+4qT5PWLnjf5CbR4p3UZ/'
LOGO += 'FNxuJeLbpNUVOOySFJDuAiK4iMlWx8byHyIWMz//eMtYA5tVYxUEasI01gMSKcu8'
LOGO += 'lMqZG58Ye1Gv5esHWvyEY7xR2YFgvlJP2YP51P0iIGvhBKV1E0AqUtWU+KGYEoSo'
LOGO += 'YMNbDSXQvF7s5FZ97+8vAqxhdGpMQopNMciErGy6gU3MJfCfmb0lrdolyZeG/1di'
LOGO += 'nxU8M0h9wXykie7Evhc19QXvN/CLngScgTc8PCn3V0eyquzJgERg4dkh3a3A9NyR'
LOGO += '1hrKBp1CsLrBl0g0BPYB/Zs3ES/eQMAbNQ9Y6GWQXZpmzbclWRc3x80Tz5oI45J6'
LOGO += 'qWvK3eKc+P1T3wwk6Q9M8bCJ4fmIfqaYyw3PM0Bp4VFf92xo+4GzmhU9dQnxCDA1'
LOGO += 'Xr+kBsFIbbutVcF65t0OmMMHYNB80ZN4gxSKrb0QwNMkFUsT9Vjw2y/GBX/9GHBx'
LOGO += '/gTdAnKpgACesamWy22b8oZmmOZ14oxd7yLi+JlwAspz5ae23sI5HlA09CX7CFq6'
LOGO += 'CmDygxz8Bxub8tkaEctxkpfHQR45/ufvuN1WYB74hb9WHKj8xT3oaxCZtKjoZaaO'
LOGO += 'C5YCET1/IY7e/MKmt7McQmZczNutHYKCAdUVu3j1Su9OUs2+RE+nKzqjmUzRucR8'
LOGO += 'gOv3PdJYsmyxXPIidJCWBfR1UPevGHgcjqQnulV62W48gVq6swcELwUpQWgFeAJT'
LOGO += 'oIdY3//QrjMi8KiiRwYladissAxBfWRWs9l9bYxa/e89o0lsG25n8Ivah0eneLNs'
LOGO += 'My9iPiA1oiGNAgAJogevxX00Cf8Hz/EG22gFJvECLf+iFtpfHFC7nXR5yu6JfeIS'
LOGO += 'B4cFpCaJr7F33/dVphatYsy8uhi0EpY9+KHBAeU9DRlF4WcL6EzJeUiMqo/7ZQ5A'
LOGO += 'jT2r7k9wQH3JI+B1Tg3km4C38Px8rO/liSN97+9jgYUl8QMHJ9wZkX6wH05aRVFF'
LOGO += 'Tco1XlIKB9Z8Dg7vd+kr3HhJPCcnFWVlFWVMTClp/m14SRyp7Y4etN/osIjNliX+'
LOGO += 'AWoK01+/llflyIfC7vnkeFFwzoGDuqPf1S8PnCj4k/f3Hw+maZwfb51qjX/Cc4B9'
LOGO += 'yHyxYBQAJFyyYKs1ux4kMF+MApmS0n8qHseB8IYeXwUMJEAZ+JX2uWYo6u5LgQJ5'
LOGO += 'eoXO9IJ2XMzWej/l5TqoO3qRawzcGosAaD2bHkHz/BYYXbbugvqX1HR0pXFYNaB+'
LOGO += 'dKczUKgK8ANvIW2Q71r84UT1+nMcGC3ykxNOLoyRSrV8jcikA5vLQ8fRz6RuEys/'
LOGO += 'lUPOcp3ss4o3miasFyYwNrluqUZ9VC16PMe3r64N4nIeOMc+dnRMAPPVkvogX+A1'
LOGO += 'Oghs2IaAe6g0HoveWzBlDII+NQgCt0EAoA+BaWgImGPI2dgwyCko0ADUlwpQHGhf'
LOGO += 'hAqgv1EABy4aIG0yO9vsMwMldrafbtbpACz2RmVifwYHeHnZCk6FONZc7CCqk5bH'
LOGO += 'gPKkJAKub23eeQNDDQ6zQczi0j3zssT40jR6wnSMXi0WPbFy6RWcOUuga7ubcPzn'
LOGO += 'Dwg9d5YIj9y7WnwiQGHhmLTTAQoVPirjgvEbu5EGPSRxBFHEC9bqA+WoPeLke7jd'
LOGO += 'B2qyxL6rxQmuIK6hEwU4na49ZJYTyiY27kSpIMFuYRdduexClTgWhtQgH7acB+xM'
LOGO += 'FSrVhSePzWE6XKSA3lygj8ME0TU6CZ/RkYAhxz5YQQ62v8rkpQOOuLWXCKdgHAAB'
LOGO += 'ybQZqki1aXLhhhLtQNEWMsMnDAZe7i7/5Q6/VsxRsG1ynvXKj/yifoPxeBYZVHna'
LOGO += 'eehtA56lH3LxqolGA2jFFilJDeBfTcxDv01+0kIQy8RkYZkateCWOH9oOMWQS6F7'
LOGO += 'QwzVZemUNfLHYt7FfFOLH1/TMKZo/K2qNkZglLi3Q2zfugXh4BJm9yMU0WsmGhWb'
LOGO += 'XxURQFECFmwIYLKc7vgLdJxaHb78L1Yyv0/I/W9fizw/uvQODOguzRKHBr04x75o'
LOGO += 'Fh4q4QI5/zzHvjlcQNrAegiQhjzjJqUjUCQ+VIkHPu1esG88Efuu68oZkEl/Bq3N'
LOGO += 'PgARmMM9VnJDUFijHFGfZTtNjPxRu7DmonU+E4yqY6E8J8LzPpK6dgWuoO5qf+J4'
LOGO += 'Q7KvC/XVcQgewtraNBy8QZCJSJiXo9Pt2b370A8pK1ZZL2FrNHh1dzmjBAWp1Gno'
LOGO += 'AU5vDVXWy43MZL6n4r8dgSGuLGgFTiB6+bkzfUH6JTxcDGz7kE59jI2kvqvqIIEd'
LOGO += 'L3F15fTEabm/JzaQDIRJSxBMvYtrShiVj6zkCORhdRVhY9X9ZdjsALPhflXJAnnL'
LOGO += 'dEiARJRGjNPaoZpsbVXjjKDqK8bsY28Oa6SI48Yvv3Qt7UWOo+MXAT0Z8bVC1unE'
LOGO += 'Q8w+eXMBWg3P2VGTXOzCPlI9ibupGivQHS/qHVPZiKOWBCPwre359/TwG5inAMbf'
LOGO += 'bxD5IPuitLszt7gd0cICsErut3n51kHtBNcvxxSrvdZmfg00sSZIzgX4sz0nbtz2'
LOGO += 'uRZ/P5YZc9DS0pLPmpo+WerCHa32UUr+8fXv43KBaKEZFf4ZsIHohBptBFgXaLLI'
LOGO += '4WFCs4snM02dZ9Me6++++7PdJaQkNpBmjRcGWfAawpwUZYgWlZ0ssYmsNXAIUg0R'
LOGO += 'LYPPE9CV7/98xr39odpAuKi4+DUHBxZQWHOBdbzF0f0LSxV0fiBNLS4+6tQPnE1e'
LOGO += 's/M4UiUjer+bpz0SW6tsZOYMxNm/b1JZDcefA8Baezvy1cygOVGH0mhUAeLtMzzR'
LOGO += 'ruTrdQRTX1jcUbSWPIafoSuVkzjBNDsKz6IYRkGwniMfIemlk5uktGwTCZM86FWS'
LOGO += 'Fzj22916/Vo58B81ID2OcsOWKDmqKVW9Y8yoLNKL95AqY9dRN4jNsie55i+UzcME'
LOGO += '8BOpQHYX2Pe/0AHxmLTy3FaB7U4oqCJDwcLCkkfAD1bfWjUmcJubm5GPqCL+wp+O'
LOGO += '+aQ7ybGtmtzN1zugJWp1ecuXeYGkBKgsVf/dAEFnK83bddcZhTQ+J8oXm90QFPzd'
LOGO += '57UOPx/XvyuE6uU4Ym7HSw1ToEYWF7CLyo3+TvC8DAWkFQjEUESYFO/NXf75suf+'
LOGO += 'ezZpWScKoYpbhOEMDmnGTc7uCaHbr37LE99tTlBe/b11jOtqyEhap/XqE8k3jpFE'
LOGO += 'Fb1F+wRPTqMIfncXJOn7YWctDtX3ufptw3X1VD4IIhgrHcZRSXn+tPJpcY7Wrzmq'
LOGO += 't0RBpabRWAXst74Z4BamleeXpfRcrxI2SDXKpp/StoQ9LBHULP7JEwhKqJmZowHV'
LOGO += 'G9ebR0Rm7BMcysvQ/RZIub6zuv9ZUCkzvPM8B8UeKYHMkhIIj8YxxvxU7Ps4KLUW'
LOGO += 'iO0y4ODRkhrfXvv0YZ7u8upYDTjZFcdu1K/OII+tVHS30mR41edJJu48JSlVEiCP'
LOGO += 'CQ3UM+9Uz7/C38YT9l1l6at6s3i5Aj/rYBMPYagjnY6GlIfiHuZd7AEJZ0A88J4E'
LOGO += 'jgX0I7Q0NPlgdgMwpRbwCQTrBOim5Uo38tiBYPBjCmzmyrsuJh6egHQo1xT095da'
LOGO += '7kAHWb76r52ebZke45n+k1we/0yMS4ZXNuTeBuCgIEV2p8JeWICMHREfH7LFpfFN'
LOGO += 'Aw3kmYE88tcuERh9Q+eP4F7DAlXl4PCwhIwMPKC5xJCLxpTkyZDv4OqjGjl97w/5'
LOGO += 'RtCfgd8VCxEYQV6BymMsI/zgFH5HIWPG6BUPlUC47fy6CSWS52yJrAxDPVsv2ykv'
LOGO += 'hUWjgAPVBSXw0V5hfKWPWca33QD9c7XKSQtyY16k8xTqHypCVm99goBgFiBJ6JvM'
LOGO += 'Pxw1AeSMfuGbFZim5Wiw+n4xjIF8BCy02apK2mHE1wsg27C5tRXSGQAGuH2g2AT5'
LOGO += 'PpU6CwVUAjbIhNDFF43l2KDQeJaJJPJXb8khHwnE9Gcey5A38sb8vYEyH9gfT5Uo'
LOGO += 'EKsBF8jPmJgSL6oq8L2vX7/OV74DAz4UyKQODg2Jg3qvIDRB/Rk4siOxM5zs9OjZ'
LOGO += 'jcUJZl27he9QwB5cGjwPAvfgn2Gavylst5VlGBnNoGZf9byHnfsQBilVU5Raxykk'
LOGO += '7uQ3X6YPQSjhv9kzDildxKANfm6PnIQ1TIe+xo5SzklUWB5EgRCW07fqxWVt4kqf'
LOGO += 'sonoOchKO8eINhcRP9d97OWQdfiS2rzuYuDrwn3RHSraffdSa3j7JcQBtV+BYVTO'
LOGO += 'KHD8nDyhkvkyqDRCnwBcM+LBarBGdYkuN+5nGEbiysqKRLOhqqrq1c/XLl9xJ+RW'
LOGO += 'Huhqmn8zFxs7WWq1nohiy6+44WDnkAf1ie8fQwTwfkaPpRATQkLlhvucM7x4ZvCk'
LOGO += 'EAJYEuGPQhde0ce40f6u39YKSXnPlVNKWBgZvnvhA0cUULQ7wotzqeBXhRYKN4Y1'
LOGO += 'pGLLUb4X8qGC1NBCkDs7e97hmmwGqs1w9JgIUGZBiw0B6LJalR6hksidWf46qHwR'
LOGO += 'A1o64kEKoOuP5oqSA9bccjZYFWGBBi4DPFaAYZbKoHPhh+J3txdKwjQuULL5vW/r'
LOGO += 'LwwhowgKvuxfk6KjQ/OGBHHO6QJ3aMhG08fumAZJKZywZ3nGgobdVswS5bzQ4+L0'
LOGO += '3jz8NxfAzChnFBKf1iWkmchQY0Ibsf1soY0R8A07+U2h5umnEatGcW6KBBWj1L/G'
LOGO += 'z5pTCq/0DEes0oklIQ59SLvoEG5IxffN3PQPyuhdT32zOaDABAUw+XqxYeCxX/oM'
LOGO += 'DLDe67x4qy4AGvZrnZ1Y0X9dINF7Cowo8RgE7Ze4QPiGCLh0KQIEgLsLYgpT8P90'
LOGO += '7IX7olOJPnG4QKEijCVdqb4hJgaWvKUsHAOnN7EMTlnNSr9qPCali90OnYeDhCa1'
LOGO += 'QzTGRT3xeq2XN8WP9SJCZDKgn4Plm0LgFeSjAt/NjG2ILX2HoHEu6KbTnov9rbWq'
LOGO += 'c0zdCFq6WVjB2MG54jEieTCDsKbUIvmsFAlxQSYRuvCRN3hPnNUSSheGBs1AxGgF'
LOGO += 'COIgke+0PfiqEmaowXZ+1yeQTNRfz3MMTLtToO4fEFsHhXKotLmUYoPZQBDQUqPm'
LOGO += 'DXzGak+cFQR/IPa1MURPQ79jvYxS9hxJ5QJDJGnihbr5P/g8w7gTny9B8rTIf7S9'
LOGO += 'vlJAUvVQlgKtXAmq2X3yx9XfyqPEIeexOhHV/5TgvPmYp2OgkmJIbaYo6VRBXrBA'
LOGO += 'wVyYZlUgqTXVc41lJZRmAfkLx9aapLCAXXLzgbTLL7LWkk9BrfHj0+B91ILVwAtc'
LOGO += 'AcTdP/RYmHQbK+JIG97tjmdHAZQbHSiPcR3aptaZ98C0DbzM3ovE+Qjl+BJfAfbT'
LOGO += 'z60zD0NGzSqSf6AeuAmo+j/sEwstPHopbIlTRUYIeX/zVC0uOZeEzmZZi2mSm/2I'
LOGO += 'f/s2zlELocuiJLkpNekrLYQvHa89GkapOnA4zq0EwXlcKGzmOgIuLXMZPx9iFb8T'
LOGO += 'lW/g2oAXgRNTJacupEv2+JMo/J4plLkCV0y/VVe3bTn7dU7SHhTJh8d/xIxbibuQ'
LOGO += 'lvfDtPnfzZOZyhYL6dlKhe2nOgDCvQnCU6vZsldgDOzwE3ypI3C898KfAIV83xSp'
LOGO += 'gzp656RfwKgFliChoDbn3gC3U7OeBBtCYCQuYwEY5DwByTzpZt3R+9e5JlLcvKXp'
LOGO += 'ho5XfB2kg+1P5bwmGYhBWh/VQtTP7GhQrvEGTFVo30E+OaB1UcWVju82mCRb5PQl'
LOGO += 'q9t/Y3WxdxEfF49Cf48WvRqEfsoK9R1+9ubWVrrZDr3NBSo8q4v1o2CBLdOatv6v'
LOGO += 'tShkAVMsq94CfWkSyW9iYwy2bw7vI2FWMuIQEn3wQ4TDnpGcrKJKaCebaifIgQj5'
LOGO += 'JRwH8bIvQAl+ABuuyMtR4KnYA8TeZ7OqSvkmfZGuWRbmv8EKWxx0nTNQhcf06nAO'
LOGO += 'rCxAcaKkT/wQvYCnK8+dZM0k1/dYyGWTkXaaH5Z2cG+Xx1zOg1Tkzw5JXnt2XEH8'
LOGO += 'U87tkNFa6AugZdeSyfPaLnmGTLCNoZv1wql+9HU/i6k25BVl1mMhbOPRiYwJKUH1'
LOGO += 'PDp02RbmCn3qUGkflJSP8n/FNR76Fj3vY16RasLe+72/JxA2lQ97AfLBDUKF+1Ln'
LOGO += 'mDCz8JBG+hxzwUCuvh7fnsvnTIh83B8Nz/Kv+Zs5+M2WuPGviRcp9xJrEloAyhnd'
LOGO += '4vYV1/3DByzvy32VbX5OUF0GFLomAgMfxWcKZmY04DQsAdaCFyNCj6c/X2S9JOiy'
LOGO += 'Hb9YEoH1JMMyNx6c+5YiLNkhj5YJegINcpo5zWpF0CM006dXKVZsvPuKagfkahib'
LOGO += 'BGjS8bXKrAHoKMqctt0Mx8tCNWNhGQYoh73y8wR4y6N2xEYs92Nf7+xCTcTaoI24'
LOGO += 'YE5D86ASZOSGHaSM3+Onw8WF/2LHESTklZ2q/z3sKmv8Ldw2vYRxCTnVcslIKLD7'
LOGO += 'E4fFxOpbHL7qU+c4W03uwZm+Cmlj1qVQrOKu0eooyniASZPuDKuQr4A1Yp5+a8Fi'
LOGO += 'CCg1CwVWwGKgSDMwT4zPzo4GBURJgYlAv8uEcJhj5xNenSV+ltUoUMYD8gW9askX'
LOGO += '7791BPu7nrRtduamfYELBTTKXqA2VFwSbFERZG8iVxZkTYDN9Gd8Q5xcDS64SQZh'
LOGO += '0nbI454oYEcffAh7k15vGRkj0cFTlmxzAOtCi7KohVe9AbmHvwvdeb3nOu8CkaXA'
LOGO += 'iOzzkdNpnvLhFpzXq4Y5FJOgZJv1c+qm3G0J6q/gUZ6s2cHtMne/qYYTVpz9vmCd'
LOGO += 'nkujIyapt41X5owZdirPc7V+hUmuYS9hjJJETMFTrD+h8ladool1bSK5Xb+gPXNr'
LOGO += 'bv7VLC9AqUAA8drwwe/5qStaMAyV8BPo1gXAawu04h++dxwgRg+0GEPukQRAVj6Q'
LOGO += 'q9wCfhMUBFhsMQAPiRAA4I9o7QNDFICVOP5raEM1EuTn/eSBuAQCGpDp2sjxQbSZ'
LOGO += 'pShT+4rFoFERrtNggzSBk8FTTDb3EwqswM+V83xu7Mv0mmsr76ZWTCxRjBSdPtm9'
LOGO += '7VrJm13Qm5OyJ5bIKEa7acVHDvbEpsdCYV77PtVs4bAcKJAuw3L5c+N8/G1oiEXV'
LOGO += 'N8L5jbtXg4BznX8KpUzSW1PlNabXt3jx6s1I1/NKYKwFITPUBp+DE046co6kMdXG'
LOGO += 'EY3OfOqXqrMh7jjZoeX+IC+/W8Hx4mDny45r9dRJdlA7qnut3QcKAqZLTzGXlzmI'
LOGO += 'gN0Etqo5NEfDbq2NsGZrAJTt6hn48cLf253IjQ0j80Z02R0denYADqrv1oQCUvUa'
LOGO += 'mcj8LlUOTqLEKydRkeasNcs1KjPIzyaP3fGRvWxjPu4nvqLC2/qXRbLy92wyW9md'
LOGO += 'B+QK6u13u9cKQ/TvOCABSd5slucwOE6I//o1+o0GT5SDFWiCfvlrsENFwNKro4Rj'
LOGO += 'HxqpNdOK8eS5/xl6BUn+gr8HEyRNXw8cC0nRHrmOtLzJ4+8s9Z8Lephdi4oU4pKi'
LOGO += 't3OiOv3RmgikJP6YpPZcWdrfZiJXWeKIiYiJ+f8Y0s1+1K8V09voetSRuTqtJYQ7'
LOGO += 'mKsKWhm2BGMa8BaR0dMj4XFYCfd/ukTzA2uPSBBb5AFmyQ/gdAGc3A+gDpcdUUYw'
LOGO += 'SPgwAe1UBmjqL7LjwZI5FGSfbeD+tuxm2H4HubLfjtWfyEJLtEdh9NOBMgD4t4UB'
LOGO += 'avdrSkpowLEcBAdDrcey2mCEM5BsMLl3pfN/zMjQzzD9riWHgZQ9UK0dujJR5RrU'
LOGO += 'LD6R1PEJ2ih45xWRab55CyxX1PwnAfZgwAExIIcL+uG7o559VFOT+HEh7z1qeLuY'
LOGO += '21c0bVFqmK4G+fWYaLjpg4L0ApXSbi75bw+Cdn8phbCil5hqldXwm88oD59XoQWU'
LOGO += 'qX3Zmo5oJgBjNJQeCTfNHtolt4AqAd/A8/V6CCiE0g/qCImtd9j0nAPQuxdgBU7P'
LOGO += 'Tzc/d5yNgZbgpZGDBm7O3/hSI4mahub3QWnu+PNfIHfs7w7+9bva97F5dOfZevJt'
LOGO += 'Ji8CEgyAwEMBIoc/6rR7ivPq93PJw81JrM9JO77fA/TeuB9I4OaTamNNbg5PiBnD'
LOGO += 'fiDidgkk+/yO89UTqck3KMHpxfqncfXAutdpVi1Gb3RCCpX5hmOS08n5AjWsqR2i'
LOGO += 'bNW7qmuNb97ey1ArQKiLSzaxAk0PDtKgvD45SNZiv1rNRbxXoWZ1cdP7xEe5a/DX'
LOGO += 'kfBoyLL2lfWgzw+RBHM7AfjnSx8FmtY2vxWfJ61awebBYxKz6TYvF7vVdzeYIALr'
LOGO += 'B2D+GcjNo4woAu03OJSplqKDlZn/wzHvbLXh+q/Hw1+VxMC597vLnqLQNQGahd9F'
LOGO += 'WabT/aU1M8YUKB6GC6ptIVUlaZEuycjKFgLZX3jk9IXsX/iRwXAI2/wpeUYx8Wi6'
LOGO += 'u4hksUqT1BSTLkNGWTAqMcbfqQB4dtbwTwu/FVGMcFZFJWrUqXiWXm8ek0by8HHh'
LOGO += 'I7Fl5ENbCeGq/2iKov945cEJ0a1A2mVY2qPYhyzBG9H0rllVQnzH/z5jl+HGvL3N'
LOGO += 'I+B9W//oGsOCNSSC7mv6WimmPaXBUcTqk2n8LT0CJymn1hTrSzj5YvWOgs/yQk0k'
LOGO += '4OwX/boOUpqTwA8miVETHcAo/aDWVjVunS41sG+WADKMNc8tNJsz9sR+HiUlpaY2'
LOGO += 'nhd8Rujs83GShzS8AB7OaGq1Ku3LYg1wQkkyBheQNjnREv98WmEuULPdhQgjPilc'
LOGO += 'mwpF9mefcFnrMxzPbYhJy1j0sefxMB1eanPrWbgdw51ioBz2b3Tp8YxK6dgXWQTw'
LOGO += '4c6GWIVhoR6lvsmz+MQK7ZmmovwNdmcabqIkwwZNazVXkhR+k19jojCSw1eH41Vp'
LOGO += '7s8pHvaEPmNGhN1QiUyDnqV5uC5P6YeYjKQgraHxbqamFWcU76vDEDACPrBS2M5v'
LOGO += 'vtg0gZxgfEpK6Mss+OJ8FL92BlbAyiAH+oVcKfc/WUIAamfkwmrT4DKoiQEweQos'
LOGO += '3eOCYhznNzgP6qdXkNKripPXzf2OtOGF4Zvvwfi+J/3heKWv/gId6lcnWRfXpJiI'
LOGO += 'JS5FP0zaPDTmmLn5xq3Q8i+MUDcrzVcYfxF7ouq2nr62oiBK+Zt0fYs8O8D6E16B'
LOGO += 'brYKEUGVePCMlDETSB+wHjQXu/sYT+sX9PBXJ5qnbUSkto9WyVRTuWwiYNMEpeOB'
LOGO += 'RTGLLwgY7BGHGhsBZALMOc7KYq6X+1NaoKhZBpf1J2AwaaYCNIM1DqsCxzAq37aJ'
LOGO += 'unEMnS1KVe2FCLCxYYAF3ODgWoqbCNyI3o/WvO+brUQA07uFj0xj5g1uEURgIOeM'
LOGO += 'vidH/sgSKWMjPSQP31DxvcDWNdvHmRuvSBni+p1GdzK1HOpOuGyni2FQmMptBxUh'
LOGO += 'ZeqUN1YBP9AfTdovpF4pfPUKqrykmNvmsyYJOio0Guvwew5k8k8Gthd3LwzxrOMZ'
LOGO += 'BCCzFX7pVqDeyYtxuLhfAKia2A/yDme92EpG24PxoLYfKPDWFQSjM/+CiS20Nd8m'
LOGO += '/QIuZCag/HvPKnKg73huaRAkz0T6HWrG8fHYOUc9VnKABY4IbbNACIQUMY5xpMcJ'
LOGO += 'nqIaVxU+7i+E36pFk0cs9O1wP5QZ/si7bahB+EAuNAni++9MYrvbE8fU5st1vaO7'
LOGO += '/9Ip3jxwvU+wHW+8jC+y401hD0/D4lZSrfeieRid9O2PibQ893P/OFHMkGnC4AFN'
LOGO += '0U6zswttxj2idlFbJC/IcudeSxGslkWh+4Vpa2xPr3kLcsBE79FcbtRGDL9I77n3'
LOGO += 'IE9Y5f+dvVGjSk8OuAxGgAKVIE6jv/4i8JKsAG2N8XIVuEo2JEjvbW/HnXQ+d2gt'
LOGO += 'JQMGCfB9unjooQPgyTaQcJudbw/5zz8CMuBnTIkYUpjF71BmIOtQZKv53BLQOE5Z'
LOGO += 'H7NgGPy+2AI9OLQvbppZXQymbQB/3eTD/vMBnk598x+ZqJYHKAIrFdrsGVS0Mknk'
LOGO += 'fYGb2zLEiwaOFDYs7ym0Cy/tkvZrM71aBtVZ2y91HfjnBCxnJNHGzeo8T88Ct8vO'
LOGO += 'vDBXw/vINtYXrJO9+OTv6HHqCrWkb3Vxij/q8RFE0wrkiUb0kBWy02dpkeRZ8rNb'
LOGO += 'fv7M8o+MMEJJwZDUcqljwNWQtDXxBXiyW8T6jAnmXmlBEgeV7cZlB0lA1wPiK8Pv'
LOGO += 'wV9VYEBkmjIvIyOz+SLW/0LI+WmtClhkgaR6HhhkQ2op58pUYIDtFWM940tEwwIc'
LOGO += 'PclnhFliNsYFkWzmq9CaWlXzvREOrXdmUGu61WsiUDQVVyAlMJ5iHKIfGbfyg0nV'
LOGO += 'VXo1fbiC1o0oqC/UHl7N9nJkPi3Lnp0aEB/PFWtLfd0gIYpK+rXN9iSK7GxZ5P6n'
LOGO += '+ajG9roWf2zEq2xrMLP4DbLgvefvAK0lWBH8uwHkGs/5t/dvUGa/YNp1fyvqrnzo'
LOGO += 'QTy9vhpYFGS13Jz/5vLoiTsn2PHPu4hUWCf80zBbdPu7PA3soUgBi9G0oNa/LShA'
LOGO += 'Eg5MTRC/Im0AO68zYNhI+eYN0ljmjLJrFD6rDCiUwuR1CMx/XPcnX+/bA6Yeh0Pr'
LOGO += 'MQ/wXwMQW2IizE82EOe/QP0HpXAjlkDGDDZHIMB8gMsiUNsCBNZ4rc1Lq6bgI9lX'
LOGO += 'dOWwdQj3WkZYZwbmhvqcuzmCmACs18Nc9HvFrK8LtfMIg2QyfT+gzgUfFNWuAyBy'
LOGO += 'nHOtfZRfj8lUF68gXsrimqeuvWEZQ0nCkLsP4kN2W8OK6vVerIySBNJn9UUrwZBF'
LOGO += '+/KbT9RI7lkU2leskQ8nHMkjplyRdzfdCeyX6UUdfit1sXjUX/2XkjwzvzvNfFDW'
LOGO += 'JI7hoYKkj6v4pOJurag2MHjNq3W8FtvN/OtHQiHM3X+9WGcZAdiRgGfw0sZfKxgJ'
LOGO += '2f5icgYWIhzgGoucXAnkpZVeJuuE1FRLuSawSZzBSu/88BuNoNyF7oonpm9tuFDF'
LOGO += '05xcXZoZLfKex9XMeC5qt/vnfWYhCuRj+tBvy5VyIZDL07qK3b9iV5ttPDlRiFZ4'
LOGO += '9PSv6jS/vZ8KvfiSc5qRM1a8aJA+G3bVXReOB9VrfJjh0gqNUKgzjFz2qm7RhjCc'
LOGO += 'NPNX13rbXEX7mAqaM+TAcpwiiJi8ueTfV/pF/tupRPXyDWAtB5bRUr6+QinMuni1'
LOGO += 'ESuAblMBgDiA5/8Mf0X1ESRvv5DwY4FKcbUl+mgwQP+zP2OpFKEulBlokRipgZ+J'
LOGO += 'FuI0oI62Oxr/NvkIYo/rKp33GBMMw74ow4Yckm1LgkyWq0QZj9YsR0hOSdFvEofZ'
LOGO += '7W5IDYTmWH0Fm6HtwMlsw6hcZJk+T8rV8yPuVeIbyPvgI1DpTcPFvBbKLk5ZJhV2'
LOGO += 'g5jmx9pYdNgRjj0XitJJBdxnBIIcggDBc3ocEcY3KBuKY2ftIOcLNjDgqrwUvE3j'
LOGO += 'ZXUV/AdsUIgAuV8a8Gb+M3CDWSeNyxoLaJdtDl7bEMA7tBzQUtPSprxlO7EbSy4N'
LOGO += 'DG0eu/9ms5uy5MU9idl8FezK+S1Qm4M5x2p2xMOqJRr/N2pP1FY7g3pYhgv0Pu9P'
LOGO += '2KLQT+vXGUtpdFNpqhvklQn0FhH0RNTrnUIfLeXwyqITQnpfa3WtrKC/a4yzQHS3'
LOGO += 'sThAMOozb4yTxWXCq0K9M7H9u1WecXLQvJfzE0BsL9A/KChRD2TzqiXySItmHU/X'
LOGO += 'yzXAeBm4b+Kztl9ivVjbyQMnTG3tXwR7zs2TBdIoABJmpUEeXA7O6ZXS2VooZ5zr'
LOGO += 'x4LahVd4LHD1aifuyuxzDRAUr3AtpNWxLiogYKhNPcP+s9hHnIGiqSSebdBXsPud'
LOGO += '3RM1xH0k2D7QVObHLek21y1JuOkc71ybEssjtlnqFJDH9ohGaQhCnuG+c2SyCNWG'
LOGO += 'GBPrkoxOaPXR7tRYjBFhSmCCos6APWICSH6vM2eY9ybCBra6gYt0zIsTJHAA6zmc'
LOGO += '+9bApAd5qawJynawvIu8hC72xa191YW6hdzixqfsvO1H31aMOrk94YjwW8bd07wO'
LOGO += 'rxybb+SV0cC3hDdN+JOvpRI7ziQc2DfrIcZ1pxZfNJ7iB6Dccz5lTMfzoTEveVRH'
LOGO += 'Zblnqn+W1ksi1riOmYHLaN6voAgKakn2Wparij0mYhYF6MnCd2MYEDgzaFYxueW8'
LOGO += 'wUtngwKsOWlXVy6wPEIIlNHXqzWL0EB1hbyYnkVALp2+X77thN3wK9z/almNzsZb'
LOGO += 'JnvpSf+BVwMaLfnOl31l/RuEPQx+I9KKUGwCbRmhoja1RgoqVMCI5X3bWTEkjzTy'
LOGO += '+oAsxWG7Xi22AK0tokRVdXkPP1GrSvGiPTuDK+rPP4NoDsoMGmTpuqfVCebeILPv'
LOGO += 'nQ9/gUsLuZvE5aIGCgl5lDStYlY4IOq+4rb91Xu+w/U9mPVrKHoe8KZ1PV7CBT+9'
LOGO += '3eQHF+xlmyLpFJyquGmpvsobuQx+VCJKXS8CnTB7r0hKh33dMD57mz3pfO0/yuIt'
LOGO += 'YPUmo/2zX+xNZLRAdXcrblR+djcxSgACI8y95Sv0J6fyp5xISrofHUhcTpIgO/sR'
LOGO += 'WC++FE0B5Tw9r+aK4sYOgB8LBTv7K491P16gM0eF/Lj6pfufCE4AEJeq3i6s0Oa9'
LOGO += 'Fq9SwV+GNirPr3Z84u7KGtr7zvbDEV46JaoLH8scIV2QQbcOnZFtnnl9nPbtPrQ9'
LOGO += '6/7FkS+51urPIeFUVVVOjzf7CCpMmZ7YffHoTm8Np9q3aK4u7jd5xNfLC5S97b8E'
LOGO += 'xYoH17qlPOa82c8Uh4p5IfoBLRduqPEGmJ1Rvoa8ByFKDTBCePGuu2t7AoFzXEaG'
LOGO += 'jfXvzUT/p3tjQJh8DVdgMHl+maWdJZfxnjuNePanjwBO1XdF5aapf1BrwfNr53m7'
LOGO += 'yWNE/DX5Z9hRPFJW0AfOUGMJhWBtMyOVo/EaOe7aWczSjWCUrjuF1Kf457oO9TuX'
LOGO += 'eAaEGvuO4G+sEi57SYxQhtnXfT3PEG23UGekJJY/GHfdFrC8LPqIQgdnAL9lN3+H'
LOGO += 'a2ZpSQVEKwDy4LMYzyKs9VoF6z3AtnspRQsH8b3bSS37UIwMYuh8/QGQuQUL19i4'
LOGO += '+hv1xkGdPzipVJ9VXr0vtPgbtXzeXD7qZsdRj3RKpog+WodLuj0La/WKYL/f94yh'
LOGO += '/gcPNJsHAtSodM24m2kHZlRtavO/5BDRwU08cfUvRB0nI8GhQjww5brf98O7fDO3'
LOGO += '78658Erohwqo3zW+Pnxgp30HzKkoIipsTWCP3yD7CNkRnALPhteMjC9xACgkQ77m'
LOGO += 'tZcdN3YkkOsfCRBbahrcSaH3KUxTilN4pKTRwNzjRUnetzR+D8kJFJIosebzN70N'
LOGO += '68cI5qcj43FIDkM+gxhg5DlXG/VxM3G5XDQMRTZ980nb2623ZRyJK5hkUlT4WO/9'
LOGO += '2r3qeCjwHmu2ezp8w7DawgctIiW3L8iqxcSjl7W/mcjvSO2xBPsHUyaxEqzJg3k8'
LOGO += 'zQcVqkDRq1lVrTZPdsTXP0D5x7NhxmqjwbjX+elzpgObYECSAfMbj0PR78OcgH9e'
LOGO += 'TAZtWoxf4SAgH9W88KYgIOh8B++csGzuY0R8AvKuyFFKTR7P/gdr0+IeW6vl8hhM'
LOGO += 'P/JSiFCPPnEpUlyoiUdc1Ca7QQM29uqQ9Z1Av7mf2Na0R5iQVgipfa6ViCoewkJ6'
LOGO += 'RlSOYg9Gep9SxbZAWL+Wq9afa2j9QHOQecC3W6pHAgWLAcobgsWF3/SFXJQMJO/6'
LOGO += 'gEVyYHVHAZ3hizc2AH6KxnJ57RYwRZ/1fO/il3Xx72C6ZEMDCB7Y0hghTxiQk68L'
LOGO += 'kYiTs2buXJeIOI2oG1CBJxQ9QRPScoskt4Jpg9TRMLVqg0p+rMhdqrjcU8VyQ552'
LOGO += 'l9pYjLlR0Cg4hI7rpFzJS56TsKvkwTJof1gW3X4oiLFwTsm/Eqor06NuuhDIz/M0'
LOGO += 'gRU7wAms15RcTmFmEpXDk/lHCNZYgt88LPZwqqxnSoAfm+jq7/4B0/mqyfS3HqCq'
LOGO += 'MUiiSAHY6twlCPigrPJ93AjkyRMFvsl9Jr/PoazqlULMOCjWNaZPa6WC+WEutb8P'
LOGO += '4rgLL//yYIQeS6j0ss8xMR/Csdp9k1Brq4w58iDUu2jhm4DqUxKB7nDeClPEbMaV'
LOGO += 'EHb10wspLmC8LPkwz5I4WczURyk4IKMeFXtuY8ZMmsTDb9/cYhi+YUKkK1CtUb8K'
LOGO += '4+mnFMY8gpTqTFOdlgA3DtJcjxDKv7OZSjPAX+DzSihp7NhJ0WUDFiSgOZfmeCOD'
LOGO += 'KFcMkIFOgRkaFOQwuiIM+KnazJ+tuEy8VL4Wt52ZyYuJwONA4lLViUjEwti1U/SF'
LOGO += 'EN2IMaARzBdTfSXBlJbMYUvlfV3PwbutMHSoW78FHfhT2dIQ49c18MdelFP8/V6A'
LOGO += 'tA+viuoTh+nr2H8EfTkX+lAhZjF3m3N6k1JGXoizvtUss0jZxyxxAuaupttRo+LZ'
LOGO += 'RDhRoZumjEI9IBBj8739COLlbjZUUH7vVa7ftfYg7fVLKWtAdXhp6lysB6gLtd+d'
LOGO += '+Eg8t6J5P/3KoRN/0npJkLJWq1FUfoMaNZ5cGd1a/KvPMFaJmTvEgOPOyfxt0sa1'
LOGO += 'TeQ1VMFblOOJPlonfq2B7KlibcgDunDLFZl4kPCNN5TfGYuVMlfyD0oq43EpL8J/'
LOGO += 'YXkF4l8znRi0a4hroQ3js70EHscU0KQ7j5ge3YObFqeuqew6TiZEHlBflgeA3G1i'
LOGO += 'YjIJsp9dFcjQSQC/IAIGlMDKGf+FWvwIQO7b/cLYj8B8uPIIMCyjAWkOv5nUEcaq'
LOGO += 'mGUT/nQo2X2R9cponHYYryS/VV13DkFczn1E/DP0+DxcXsru5w9B+jy86epObd1W'
LOGO += '4VruJ/083UKaZxKkGUtF9DLRw2/tiJbHn1E3eAnT1BrCj1Mzo2wZ8UhQW5UXWnmw'
LOGO += 'NjdUl2Enum/sSQKVxLFtWJP/kKj57X/OaSqrcs/5VrPgTRMVfpK9vBrPb0xuD1y2'
LOGO += 'IgEFPBDzE3DVNtWcmPw9VySXyOayK7/y8SfaS9FzQLidAg6FFfqtGq0xBu3exren'
LOGO += 'v6Ga8mnK3ph8aVmAVdBnR93NOEfrJRw839FRNn1uxMMdgxnb8Ui3HxNVtlJpMcqx'
LOGO += 'LXQRLOzSpk6wzhG2h4SDOhHqlChr3zgHChwZg0tYjyhv25EgW1+uoALSUUJODtie'
LOGO += 'OlF7U15f0RitjV/euCpXt/tDyOh18XhrLYVG3e0tIkI60TzMXnUJ6U/eOFT5MWRI'
LOGO += 'mzkl0hH4SBUqvIKSrwBghimIhyk+54HpcaFd0FUxGgCMt4BQMlWmQvUIPBshgUAr'
LOGO += 'RALGprmqLYDCFrUiZ2Kh2Pz1imoBxYjJiZx/lrGlIeRlWwK0+V/5irc4q97f0j/m'
LOGO += 'Ojsas3MxUrSfOT7+yIYqVHIIXHJbIDTKrBAb+q5iST4JU0Cb0Phrpu1EYf4rfgEi'
LOGO += 'kt9mHCQndtMaStWIC89mDqLMydOoXGsWSFvw0eqPTZ543+D9zLcaKsqSbFkV+joj'
LOGO += '+W1QImITrFgA271Ms9rgLRUeMJ4iDng8Q3hxh5cH2SXI6aQkhjUrA0iWgEBaHODk'
LOGO += 'x8eoRtYHX5U2/5sLEJkGvdFJM8QPCpmP+tVMDHwKrdJwyF5DdQrThmvgGBmj993X'
LOGO += '6YdGhYm2rGKwpUsZNbWL5yJ3+FdGX73E76nX1dnsvs/EQKkziLDbpGU1h6uywFVb'
LOGO += 'EVjiZG21C3se/k5x7F99HabP8Vg05dCLqx1AcLdAgA9+8T4AdN9CPYF67V0A4wsF'
LOGO += 'zWSHTtcBpIWAiXWBm1/xu2S7dEZQRe9Hy1uywDN4hUm9zeLZIH7ielEoT4RIVXP8'
LOGO += 'QEumMhR9++VCfuM/1I5llGWMPf1SDabXuyr1mvNe5USPhdfpi2d/ja5v2JO8uExM'
LOGO += '++TebG5+Z8Xz7IMtt2DVZZ39jXDrkWWmY1ek2iEh8E/q9+i7oNDSK7HxkIunLBii'
LOGO += 'Nkm4SZHW+1sKq10ZTLGnKNYOMWBCBWzRh1OYo14Cehh4VMTFlX8Dov+CgO14ARBI'
LOGO += '3FmEuUts8FhNQr5paNM9WGNktI9S1h8LQkrykt5+BRm3GcijrHoeWdkbvWXKlc+l'
LOGO += 'iiQ8ZZi4ceeKkvjMS4T0YybmDmWZKG7IyPKsfjc85ARjZ0HNmTJX7iWlhfKLtf+u'
LOGO += 'iosoXJSM0Ra7obLLJg5R7teGgoz0w/0g48XKqvRTnxy5CTdhN9Jsp9ZFhj6Lak4E'
LOGO += 'N59AtOq/S3WJssSNs3wrI/IG+ARIF4t2bZ1R8PDggeAW+aDXH4yPcaBuPkDsKF+/'
LOGO += 'hgLNpMacwwsIZHYFqYa25bT6DbzIu/gk1+FoUHelJ8eRjj7u6DqM7qfcQk62avj5'
LOGO += 'XU2TROEz+n24y74WrcZ1eEE1ysFB90KXcfCjnTqunHRCfcxUVI4eldfhSSG1rg1A'
LOGO += 'QkbnJyV5+5XLRQXVO8fWoZvL1XCyol0eRvdn8kiov7wPBkIvg6NCdsj6txrJ82QX'
LOGO += 'HGNZDZwDoBEA2Xz4n2zKQPAY5x0+nsn74qstBvLeZ/uFs7p5oDj4LSiE0HC0v9ra'
LOGO += 'xKGw9uZKax12IzjBRsmf22aXrQzmNx+EMZmRO7I/lxhvqcnrfPG3ZK7x0q1fXgp3'
LOGO += 'C6gBlVX/V6P9i9hFa1mZJU3ZyC0Uz5KXnNEyzYdY0+eZmTdxmt92S19d5Ieoo0RK'
LOGO += 'FtRkmhOXfbWE3TfeZ4bgWV1H7a+WdK3DzFZq5xoXBEFDmYUZ7eEMwyZu9Uf/BEOL'
LOGO += 'MQE8WPeFAcfAuNVWIFhKA6gQIKOTPV4Tc3+2B4BPx0B5DMhbvt0ab0Pe0Mz4GJmK'
LOGO += 'Cjkh6pqaDg0rJhpd/LyIYTOaJ4R5jBj1ZQrrd1NLfFzppwsc071zMVWNCwHW7Ws1'
LOGO += 'w09kU5aB3r0ONVqX3tBWg/tfBKnN76G0mh3JlUNNF0jRfyQmxkMB7F82TKrw+3IL'
LOGO += 'k3P+6BI9f9c/+dDb0R7jGirloDcTP7GJT95aahbXFtUk8klpgqXNF5loot8vvbVZ'
LOGO += 'z+pXBSHIymLWNgsDb3QwsuOBPN1PMO5DlFFSR1KvOAZkpKSMgPeDp3wWneOi9oY5'
LOGO += 'ZKAZ7QS2bOL6p5HBaGAHSReKMmxnBHSD+L812p3NTVqrz329VH2zzfHQlTrXEl4X'
LOGO += 'fMnHnpyTknm2FLseMPHuEP/RoW7rScwf1pBG/bZwboiICVGbnUccypO8Iuw9vwaM'
LOGO += '9g+/jE5N01LskZy+SeJq/6Umxb8qc3eyToHNgFW1jQ3qLCKDYQ8ANyOx7lorgJT+'
LOGO += '6aUECJhX+1BY2wLB3GoKPGVeiHNgH5WqywJ6GzugJxGx5In9g7DVEq/yCU/wZJVC'
LOGO += 'vsBzS46Ka1VVYObBQf2jgKj4JUCm6yE+ybnoAHXTb0WjqEmobYdynla7hohlWK2V'
LOGO += 'Zm82lVSM7Vp66n5oJBarld9RhNqGG+PBGShtPaC69+MTY4HpHVtqhaMYg93ZhJwj'
LOGO += 'zCPo4p5I7NVFfXN8LbaEPGzPliwH9zZAPF0rcHT38AGOwh7WfJ0jeQjmLbRYBspw'
LOGO += 'A+ygouoiSeBlvNDIDWTIYgcdd6YVFBah+IzpDOQFHICxGRdTCAwdsCUQCUX9hbKx'
LOGO += 'FTITQPSBpT80OkoNCGW0gBSjBI+vFAWZxzp0+FDe58QNUpzBGOhw31XV/5IpcxJE'
LOGO += 'P/rfqTyNusq2fEL+3WCC2/TEUYY7aDx5Cs2IcyVg16YsKZmIqiawzCQ6cBl/7Jsn'
LOGO += 'R7MQcU5gOVXFt58t2Ptz/YPUJcu0/TRdd8Ey9KvYOdj49hF+lzhAb1hY0LoEzlRv'
LOGO += 'WS7dzcEqlC/gn9CLsRioTvWKmNehF+QQGqpjY2L6Abv8xH87XvYfjNFr3pgPaN44'
LOGO += 'OClYZfketdPjSGIa1jb7htDUIBj3z5kZvaE/fBQN1IMgetV/zExBHuZBGJSpOqay'
LOGO += 's9p9+lRE+jRc36kXaMYxpqX+j2uGNhbGLK5o9KFCEcP2hLZPcLH3qptHrhntT12k'
LOGO += '9Ug2dcY/vKoOcrgMV2wH2Y9kFKzv/wqmfnOMLlr5DuG+0OtrfYyZGc2UGy6G9I70'
LOGO += 'W1OYGgE1CTUwq/wfUOY02LRx1ntPDzd0gDpKLSycDZbdoRAKME5R8JgbELx+vxgT'
LOGO += 'DCHfh9xLjFXep1b4RpoxskBfrEKs6d+0klMUvcPtvNZLClykJTbKsWfwIKLww51o'
LOGO += '6IYtGmC+p5CdDJiWw8DEwpcdmSsTZ3k3rGBy5a3tR4xr1KELMxoAhyguKLHg0gx1'
LOGO += 'nlzUMQbNht+uSzaK8B4vzEvP7xt396M60m3jq8DmLxyZ1Ui7stqGuazQZQ7LjdHg'
LOGO += 'l0sgvgbFOV4X6/bHkishvn5JW/hfxqJ5XZTDtoOiNu15tFFHFcjukMdN93AzISvq'
LOGO += 'DpS4MK0rCVYeWT8IHdTGH+3O9YKNk1/rZEE+geVMDCLwH79ZY+oVOomVMd7MYDPd'
LOGO += 'D5xt0RsWR7JFe1Ejt174vG7EP4LN6NKWnoJ0JH7buQteHrovt8ZE6JyRWeed/7FG'
LOGO += '5ZUbQzlprrH1U/3zEO6zvxDwgESTQASJguhcf2R9hlHA2Tb63RNSBtzq/cmmHFZb'
LOGO += 'XtMN/ErfoZcYTDRmYxV+vHNS/hkRrWH+DHXoV5RgDyEz+exbGz2Oo5BhhtMYxjFC'
LOGO += 'NslW171tQIq8xhcJkysX6e1JfIkNuHNQFOO9epoV4SNEe1Dwvb9kGjbIiTQv9QqV'
LOGO += 'F2xTv7tHwgfpYpe5BZfCJfyRUB9nJJuvPasSZC3qHq03FzjtRpgD8AoyyNa9sDLA'
LOGO += '+h9pceUvGFdemOGCf3/AVLedI+Mx6yTlVg6GjlJ+rkcM9jqAujSEajMOEgyHPsWC'
LOGO += 'ZGMKM5BSL8OfVl1A5chdw/xQUObBvifLbbvLAOnzL3rwViLMfzkC/0W2BMCfj6Fh'
LOGO += 'SByjP70KHE3CwftWzFR7c/xTW7xZC52kHTOTVgNHaOCNeLPaNUnoQXZWcv3ZJyMO'
LOGO += 'PiaxuTdQPTi3Yf6TUAouDCKMcRo079gzpYkS4CzpkeV1qKL4mvpj4ADiHQoscQFn'
LOGO += 'EKzyhF9nL4OxUxKIdkCNJ24IV8kovuHCNbUc9edZ9P/8gR3UQvRvw8lQpzhMCdFL'
LOGO += 'OMkWPEiznOwh1gd1r5twhgI7BkoHebRL5NyhhH89k3KFJM5Z3MlBMAJDYxtqt7wx'
LOGO += 'ZgM9DGXgseIjMFQWOlYcctF4mal9xLammuL/5AmtQGe+1pZagd5wtbr8Ojq+MpLs'
LOGO += '1iX6JdBu+unrVydBZi4H9WZkWjYPyG1V+FYrUFq/QB0gR6nc4etlv3xi9PbdO+SX'
LOGO += '8sIAAN8bED5ZbqpmTg2gzUR8jdtjZOANefKB/KwY7oN4xlgnB71NGrO/dsdJEymR'
LOGO += '+Hu2HepP8upV2rfNSlco7rlHQas2Z8aaxARfvMAmsRknGqtPuCqTWg1QX6DGbhje'
LOGO += 'S2Ky7seiymnrx+r/I5HymN7fxeGmmMC1pXsToU1JjaJYJE2Yu5+RBxz1cYeGLqPV'
LOGO += 'Ad1XNjZ0HMUfVAzWarDBfamy5gtY65CykU6HQT3aZIjd689SeUkjhtBg0s+y7qaE'
LOGO += '5LX9UVV2GUCcNuuA47rZR8v7e6aACzlEO+2Avd78Aau7Cwt1Onpe1XfC0n1xtBQi'
LOGO += 'GHmqOAPHFQ7lVPI6LBpuVNlqnSHaLxp2IzvD7zkr2gOkYWK3Bg7eKL/ETWCMDbPz'
LOGO += 'ffF3fKukJAv0x+eSV7/K1VEGYhaHaVRQiCxtQYfS5gg5Xkj+AMXVP+iamSyLIuCa'
LOGO += '2afYVTqmCTWGhBwh4zYkAcP7Pgc+LeRdBUldFt6SM0WPLD8OqcQA0r2y6wntpNLm'
LOGO += 'qzf7RzsJcAORja8aBmw0jXAnhMK+qTYMPpMmjU+7oURGRUkC9zFQGQUoi0k4UFJB'
LOGO += 'xbgdWVkSMHER8dghQjzPh+h+uy9/MHWg+vyIBX8xXZjtg5pRvM+dbX+oCtmVEP0n'
LOGO += '61Zl9xlt401UT3qYZ+WE6md8GzfPJVQuzPSYR4SkUG9DIICB/IOzMTaBExNY2jSB'
LOGO += 'WEKygjtac74gKE396RTVJqXuypbyifYps8ITkarRrFs95nLHrbW8i3tDxP0ao4w2'
LOGO += 'Idf//gWkArEEs87nceVtUFL7JfDBBEWMcRnLyN0AafGlsbWqN1B/9iUBP5Gq+Ys0'
LOGO += 'obH6JFweoxWeNenX8J5dl1fKCNUcMPWsC8mK2snug2G/uZkMzoWU/x2YTkoqJxd9'
LOGO += 'Vz+luV6som9F5DrXVgLtOKfEomrJadZIMG04Tneaz14Z22DMB5/m8g9WlJxlk4G+'
LOGO += 'fh29+/bcwgIzKJZHPC8M4D7Q6D8tH8sA89n/eJwrHL7YhoOsj0SDzdw5hhSdQsbn'
LOGO += 'F59ZB3VWLIm/GKAHT01yohK9PibVP7YRrihELslnwydG8nKVJLMq/H2C87NaTEDX'
LOGO += 'RTD+usOI6E4BlfpIgiSA2G6HE8aKsOznaSN3Azu0yQi2IMx3kUdOuC8pgc1UYhCc'
LOGO += 'K0M/9NFjSOt4UPmh/hKU/6rnjYB9deAn1Lc7duOVgJO8N0BSDaQcHaZK9Nug0EYf'
LOGO += '8Js+Awal25a0RFxWyhTGPpYh3W2uEcsQGehJnZYTk8BfyioW9GWLo9IzsKrmVKNb'
LOGO += 'ECVuJxbbD3QODpQ+FLF72vP1C7ccDOowV5E75twEjoZVkMtx+qVMKIjbAnnAQybX'
LOGO += 'gTT/2N670OduiyJa7tflnIoSgqfYlIlX0Ri9wpNNdx5vrfDW3FeKF8x/cNMxYdyn'
LOGO += 'S6cRvIrMTozxvT+I5gMOw6AyNShwYsa4o6sCVLksP1wPsHJ8/vK3gXwUxMpgCsj7'
LOGO += 'Fr6WIL82k7OGqe/kSHvAWZvPs472JA981kk6QDu874T6FYH9xxPVwrqDj7dUH6sM'
LOGO += 'o3cUe2EPk2r6x3zgEk1uq7z4E5uVJ0w6E+zHMwr9zzGO6zHsWGJzV3pfZpj2cCCl'
LOGO += 'uhKEB8jV6XuLVrnLEg+aU2LmdlanLQfPqGMil8mtBF1FRMJEacI+PBycnK9wcUOA'
LOGO += 'UQYWp8Uo4tBnRUVFGQkJaKDRP+0ndszz82nJAitTMcGvcIlhiK8dX7azCssixCCs'
LOGO += 'hNvEZ/LSmoExWuXPzcOfJmni0QiJ5Xm/IUYoEpONTZju9riL5YlP8J/IEA8xLxv7'
LOGO += 'CtxhCks2MbVS6L51UBJN2NDfDxdOPb+h5wtjs92T1s5a1fNB69ueHQN2tTJR0nKy'
LOGO += 'LJIOLLY0z/9uOmsAhwSUI3vxTgfLfsTFrBwOc+QXn2gw5Yxm62K+KhMPhnf/RiSO'
LOGO += 'eKCl8/0PK0AVsQw5rDzPNPOua6DE7jYi8uTSoyhZulN0G0IosI7H331Lsk8e4Di0'
LOGO += 'gisjXGL4DtFG1sbIcHBI7m+fMZ4YegsX+AaPqOodZ6qX3SFENytv/Zg6y/0gWtSa'
LOGO += 'f5XgrwwmXQAjpFX5kkkReDV3Afuq31feKsXvcEmEPOMs5tGDUIl5UF80hM3OOx83'
LOGO += 'YaN348EKwjLHq99BXRRLgui/2mke07Bq3F7uYKogQfZ0JyLvNozsVz6X2H4N8jxa'
LOGO += '81BaNxj4UYxPLYdNGE5hpXlW3V/biLosxHwRs1l+pL4vjDaIsvw9A6+zg8ONc4M3'
LOGO += 'xaXYJ8Xzie9uK/gyBlCZYoDVD0FoEGD3GT9dHEnydOQAkPPPSjM2IFP8/FU5q2EL'
LOGO += '9ONAgFawWv4PzMmooEfPTHea2/VYfKvlDZI5IyLfaPdsPaeX1q6mndyxmUZo24ct'
LOGO += 'tep3pzrOmzBenvvbdn8ihxiIDktWqTyrdJW/94F15hIf15iXEsbf6s9bV4/QPmaA'
LOGO += 'pUqBZV4NKB0BfgmtQgYsFiaj0RlNUUxs7ETnCQjXzwCasPCVFrrrOgF935gNH6aP'
LOGO += 'FUIGfxWtMp00D0OAeqh3bvIqCIhq8RV2zJdoxTC46+zlL2PFC7nH4Xcm1c/hAicg'
LOGO += 'vuhHBKcngWQZtJ9kdP9UyWEMBlZ27G5EN0LtGkD9OHOjzbyPpXeXPvh0jR3OHCzF'
LOGO += 'FafrAkWHzMbLNHy61Mr42cUGhOEvhFEpKdgXk1eQCgv7s+ax5kWnmCMUAWR+eOu+'
LOGO += 'ku0ywMzy80lHHa4NE16Xv8TbZba0VBExUXOIpNhTKFM7OVGw86SL/YopCnImSblV'
LOGO += 'CudkXapIbI+FtYaiJJq48BODxN+Q/WV3Tdjod2rR+nSChETD+6W/8l77kcOixeZJ'
LOGO += 'Ui0gXR3NEkwqolA0LOGGQ3t42c1a9h1hR4es0JH1jfd9rYFx0Rdne+58fhB9yVq/'
LOGO += 'kLkNO4RaPE7Ian3IhTwx575pDgBi5xRAhh8lp8B6dKsw1i5kzgXqNh3T2Z5g9D1d'
LOGO += 'WcBE0smxhvkI57YhSnuZi6oYBrlfoEa/BOc81Ff7LIsqDr+jQesAho1leKJnwaiG'
LOGO += 'eagaDyM/5b2CcyLX90zIuTytr2M/DmJo5Ar7+aHZ9FibnvrQrB/8uLxwPyQbgmZy'
LOGO += 'ho38lactFOkja2W1y1LF+gVzovh/pDmB1wbQJvW+CEpeCHarnQCp43P/Q/ACAyuJ'
LOGO += '5C+i3AMO6d3Fnu28E+A7/Qw19nxHqRHSrYcxiQ99KzqZhZoyHTmFqvHq3wexmXw/'
LOGO += 'FKIZPfPhfTx5g/hTqCI1sNQpZwz16/gwmxkDreua7mHLAWNGpnwtV4bkIhGrBxHm'
LOGO += '4rbWxkLB/xPCOZmN2msiSwEtKwmTV/l3JLha82Ktds/F6q9O5Hsy7/3XJMBu4a/3'
LOGO += '5ha71WRe3NozGPN6QVuYAvZ0jxD9F341AGGgIEDhO20LBOuR4N68MfFEGmgIBmKG'
LOGO += '8EQW1O9LH8e+6NwS/QoLUZJ4FpuyoSxZgHCuFRRWmBxl94gtla5+DTTCn9l0Yp6j'
LOGO += '9dv9Uis9PAlLHf8r0449L5rSJo+lCh03DSFjbQLdrZBfo/hd6Bayza5IOpuxhP/o'
LOGO += 'GaAmmwwnven4TYDltRlBB5YLkYBXR2q//AG5Dfh28gFpPpDvxafuKV0DhSwySHVf'
LOGO += 'KrTzQh6ZUXeLiSc7zQkqd4j14q0zRAPhSxjK04I0G5ljdwK7lSF93opbdHiM6vC8'
LOGO += 'H802rmis2Cqiv84SHzkMtktzQsPiktNg00Fk/mF+4B0osfs9o21nws1lvCh4FZjj'
LOGO += 'Fr6Enz+5r075AZ3BJcCwQ+LCarM3okz9Gx6YMTBB9hJA4V7APO8U+xM21OIHwLl+'
LOGO += 'yf2A1Oc3zL4PpYqkei2uSCBtd9MOnKplQYgxapgMdSX3lQjEP2j7nOJomilHBi6C'
LOGO += 'VqOBBVnrmhsGGp9paQqhLzyrFNU1yMjT+OSvdIJGsiH91soKoGpJqTgGHUW+o+dY'
LOGO += 'Vtd6+mCMewU264r9fQy9mL5ZU5Vk3W2FqeI78HOb2SLu5yJL7reQJ4oBhSIbKELx'
LOGO += 'UX9+fEnCNgHZg2tA2d92o25oQEKDB5xQepzVGtnYHilDsITZ3HxM7QcIZ6NL66oc'
LOGO += 'zZswK4JRGJhL7rxXBqWHBi4wVjqN6nlhRe7FDMgIKZHoPS5JQaJ0R79OginfYyjP'
LOGO += 'tA9XdDDkff29ZIWqUTAZ7pUhl2rprjsppjFRibJL1u12kGF/iZffGcDRcEZJT+oO'
LOGO += 't/MNVLjd9k8d2RHUiQwAKp7CUFRCrNqffeym/RuADioJeL01XpxujNr1Vq/wmAvW'
LOGO += 'oMASHKS6I9fdnkFxNzagjdAqndHGn30tBHY/ySQGNAHshrpVv30k7EdWq09hrEax'
LOGO += 'dNXD7UwgJSJ5QeP4ubOJvsb/r4SYJk7qiT+EiNcuzdBSfq7cE50rP+StZ6II66f3'
LOGO += '9d40RlVH+l8Tbwl5fsDSXeIrZMNZIgVSVWR39ggUG7LLIQdCQbyhFuwJ+vHtEsWA'
LOGO += '9s0RTIOnufl28iCL+REIuB+BIncANGMIJFboHPEFtQECpMXqR2DHM0i+1IgafDcH'
LOGO += 'tU8IryAlivirmfR8h7YkeTy0QTVCCf2Wa0ALOdeDHg9GRLJNMjGhJpLGpFG18R0O'
LOGO += 'Kcohcwv0ZlzSmdHvz6qqKB1CLvAqNTX71HmWhyhcLtkEbzhiJ7Vul+ujKkw5uN8U'
LOGO += 'g5vJI2Jzioj6pbsmR5t/GYmIXcT8ILvBLXz4YVp8OWMw3BscCA2CpgT9nBB3GLZy'
LOGO += 'zep/TaLAuUCXfu8MFIwUQxQH7KcaW/zV6nC9f4BInZNrmUQ8bMzWGSnmJ2Kq0lEr'
LOGO += '6VRvpHN/QbTTCct58l5pYk9blatbbycu4WeyutOZuUqaqEbQ9FFeitDNazLWrnV5'
LOGO += 'F+Lq/P7+aSWwgGFn9/fRFMlpJt78qZMKGTVPYL7NNKRgsbEZ7Jj1l5JcpvtkGQT/'
LOGO += '1geX6z3szWhtDTuCWJNJGsyMeFM58+/c6hTuvfU/vyjL/XkD2f/gSnED8zZ/0B2H'
LOGO += '8jM6E+mU+sF2f4HoAWaJ0i1CRQVzs86KKqlZU7QRh2KMhJf3jLSR+/mvUZh4zmJF'
LOGO += '3GM01PrPLyCS6bYfbBxIJWgqZGTglCC7NcG9idkMlIbfXYU8YouhEkEvwCM8sAQx'
LOGO += 'eqDSDhS6YhtLcJRZF0ITmGc0V7lTFhS2JThbRM+zWDqYO+8rJ51JiJaXOMEN/KOF'
LOGO += 'oCl/jNmCjvYwjPrHj80VmO28Z0PQ7yvxFqVk+ce/q+oAdS2A0bOC0uv235SFJL9p'
LOGO += 'bC4z6f3AJBWgv5mg6Q+ir0hH0KxF28BW3hsmd2Mth9sgl/fJtlC5JoNgiJPq/BrP'
LOGO += 'JwzQon8P14TyLwXXIZz/yOLu8F33q0wrjzg4iOJzcX+23Fa+blDxgITklX4hMc+v'
LOGO += 'fKTp8o7Z31XHbeTZFXLfVQy/m0HK+OeRJuPQpv5xxd4wnRJb0VZnE6nvEoSeEame'
LOGO += 'GxP0u637XigwzbgNJqeNgoR3DbQz5C0aaL+VxY7wwhte2LPNqu+JAmnF1qCHORHe'
LOGO += '9Ut/xGYcCeX5KkgRXvDnhm2ZTVW/MyvQJh2K4nhbbqOfOMgZLt46BtHqk9a+ebnH'
LOGO += 'ki+81TSBABHwM1XUEazua1zMR5olpC3fF2OPPYkVw06qh4+e2cLpRBhoEDOVILVz'
LOGO += 'mFsR0uNA3SJdPwXJ6mik1+ZGokz+8TTc3OqeEIY4GBo4DwBa+Ab6d+cZPClBbmVu'
LOGO += 'BPBnXH3XCrcibz9Q5fGYXlrZ5J9laViJjVfvBQkgZUPiIlyLPslYblunfAXhMi+J'
LOGO += 'cOTsSOpFpeoazqw2lHdEhvSiFzRaBHE4vBIfm8e7+yyrSfXH39xBQrlH9nnWTwXG'
LOGO += 'oj+TSTHXh+uTMvNEDNntB3UwD3lLbBV8YJO8byqVfoLx4N6Hfu9vs8vexzHu+QXj'
LOGO += '9B6jf/hQV9STP6f+5Wkv1ou3vyrb22fNkzluORdETmDWhDSs/4JjMymskP9VJ72P'
LOGO += 'NhnIg4ESuCLkwikP40S1TevSZvktW0y7m+DRXRJmcHjXeWK7RryuDP29IP4MgX+Q'
LOGO += 'CoNScM5Z7/5NMEKXQfA0E3+Lbbkxge7CsRDkpbbFJaiha2ThNDEHiHebwMrgRdiV'
LOGO += 'PcKThFOBRB4YCj/JCeUrVTYxCVlA9CP7OZskIL817cRHhGjzNEU8K/LETZzRLF/7'
LOGO += 'e6L6W9UqohPZO4NDDuYJ/Ia33FteExqpIb9spREIMyBK0LCuYVJH/pAQSdiyHjQ+'
LOGO += '7rLizQSVPEuuJugfeI3QLuaQBSijHPFKVY+eXfF8Y4J1bIn+QCJsqVhy0X+XQKFY'
LOGO += 'AKqEazBZtoOkGhk8Bhlq2M9G/1bQe+UJRiVRDluhLum4LH+i5NXE1hfBB7LkiRs3'
LOGO += 'BudUlZ9nK32yCLXBIVnxwhFLJglMWYpjprXFMWeoO245YbvSlV5kqhpjQdrw4ao3'
LOGO += 'RewayoeoSzpl/zHgiGM5OsrSP5SO73SkZ9bogBEerLLB6EWycg1Nh+wSJB2NI3t2'
LOGO += 'EPTrfo4LhQi06lUdgdpD/uctR1Xf8P5Y6jc7m/t3MWeeRxkTeNHAGfZwvd/vs1UO'
LOGO += 'yP8rby1ivbeZSVgWC/udgAvFTYV6GBarOe6iSaSU1IVeK7l8LqHBiSsQCQ9m0mMy'
LOGO += 'NX+ShQVZ+bXOJ9oWBqPPcD+irIi+xbUIBGYibBObfsuqPv/BE2JSWwX7EW/297cM'
LOGO += 'kThs5W8x1hBvgi624GkMbWn7WGMC/a7RAqBg0wH1i59RiQLWQMWyLMCZVKZAqIie'
LOGO += 'eGlyU9NKRLNdW9qTXZGNRXhW0Lu86buCFF3uRYUfi8Sb4G4JsZZ+MjmhogrAWKEP'
LOGO += 'p/MmJkWbobzjmtGiwj0enYE1IB0gXdxI5b+71buv7FIYMD6woFjXo/uQ373+qUe8'
LOGO += '7kJZKB7dEG5HYnpB40zHz+h06vYB8oUzMB5eH+PT6mij/JYsSO+dyL97dw8tzaWZ'
LOGO += 'xetIVqKYHQlEusGY0BJ2mh6EPKOxP43+zUOuivPwIp7yUp/nY0us0LwXfghAFJ7e'
LOGO += 'TKaR0hFomTFapViNdSdC57UcnCDH+Si/SgwlQXM7FMoRiQjsTEyc72fyQPznTm9F'
LOGO += '/xN68m7dTMebyUNpseCHxGR1hDiJz5YYxjdDmGhCtVeNnvNCJeyxIKP5rIx5T/PD'
LOGO += 'pZdNMViGAognXsy8Jzb7omQlSFUk6IW9L7sAaWAScK8gsyltwO7ultwD/wQCQfJ5'
LOGO += '4QIcfqv+o3EVYkyw9xMRD4/wu/SrDWNoX4nAEVgKd9FmyCJaHCvUdH6XjuLRRU7f'
LOGO += 'CYLCDT9G3AD1TgaMWf7XP0iBrglJTxhizlrNqIGo6isBEV/H6yCELPQXBGLX6cPm'
LOGO += 'UEVhRR3NeutjCG99xJvdSjhKIee1efJMYh0bh8sYcTyfADfPmZwxhz/makKJZ734'
LOGO += '8IJHTAOKGpeC7MGUKRVCh3SKm//PtuZ1JvnnesrPRdi0cnJyMPJHTeecVpMU5wDO'
LOGO += 'xAbWvIDYugiMMeTevqVXs/gZiiZFDWxDHzUB9htv3IscxfJ9nrorAOkjJaYyHWQI'
LOGO += 'dvAEQkhMjan18/ASsk0g1sLQ5fv1K6klZFrlgzuXbiAiTDNs31Nq5qG8KQqUYQkV'
LOGO += 'wi4/5KAKaXcdqUsIj0JupQ41PvCOq6oDBott3ZFhC2owWBzWZm7PNvCPkR9+l+cw'
LOGO += 'lRgHlAgF17uzhh/QKrCIr6MRXzeLqAE34QeHOU4wJqTYrXcIk4dMZPFLwqMSUDB3'
LOGO += 'AiqZRFm75QQZ2eAEpgRlDyIu3jIXAVQGh3InDn0ZNvxHF6jp5vDASSyKE13AMnhL'
LOGO += 'Wdo3wnWhAhky3Zmm0ak+qRtW25MObGOknwmFuRAKvEya5c09KjyBa03nC6zgTebH'
LOGO += 'h2VDsA3I2Sb8dEfYg/f1p93r6yViXgNoM+wNPqhdTKLtCyK9RWU2is9CvyV/jWXy'
LOGO += 'suIKewBizFC5+rdwQO7/jJmQmfkeSCHy5yyBUy0d4IhRnLRdoPP7XFcQDgp/jtMw'
LOGO += '1kJ+r8J91Q9LYKimLDpUv9sN+Wr4haI2tND/nr4s2w57H+PD7F3U13HXwC/YSV5x'
LOGO += 'hcGIYjkpgSc3es1wWMx3vKrpaoFtlNbrrlUdZo3v44WVbkwOH6C+pCyO4eWudPVH'
LOGO += 'ZkJ0EU9FJd5cMdDYiGCeo7/+DGr5ZEsFEcOCTYf2Ek8PjRUPt4Lfqttoh1RG/mI6'
LOGO += 'ZLvjGBZPz9QNfYnY/zVALHBGGurKLtAOftASYq2JGsiRABWRqoJd60xe0+gJ5YxE'
LOGO += '8RPHnNcFZ1oqwiJnWNhWCSmtenOYGetSmkmMp2a9veLv74RrP1otEswCJfJG0/vo'
LOGO += 'bJXtpfkevwxPWqjrV0Yc+enPJtX1tACHvPuMefJSlklBIYPrNYiHmIeA4FR2DXjX'
LOGO += 'xgFHIoTZ3Jdi1RjbLj8RcVI2MfELDWUwN4xUxLIh1CFQi8qBXCiUXb3sH9VUBLfk'
LOGO += 'uVCgBt+F4I24tNfB7ohsHF68BTqwbc2qjh2INSN90xjs7h7hBGt5NZ2YBsSMqlAv'
LOGO += 'ErvtCKaIVUwEalDnGp0V14mETeFRGHoFLu/DV+WPiIstoONXc3JyXqiAsjex8rki'
LOGO += 'whsdpJwWqBjbjEivjUc6v+MIlvrTQYVibyC+uTejlU2fG9SFWBNBR9cSF/ojVo01'
LOGO += 'Wb1K9olXYYS9ulgW0ITetUBBq97Mu0a8+fMerv6tX1XHe4gX52eipruZuKv5sNGe'
LOGO += 'XRLbRMHTm2Pj+lVFiZ8KKyGYOqWwSKPkRno8wIkOAMLxIJMHN9sJVLnbwAFrM+gx'
LOGO += 'kW30M80sjjyaRKJpBTJ8mWVNcC/NaBJzB4H4oSo2RXb8xyFmqNqQ5BHoQafARyUJ'
LOGO += '3m3I597+WsvmEPn4Fd7EmQ3RFCajPYUUdhea3ai+K+ufeLXWf+4m4H6v1irhQf3C'
LOGO += 'MqKHcmBlzvgBGa2m+6xH+TkOuC8nBl1fADGsLHCQGKXwT8Cc5v/CZNyckGeQDGlH'
LOGO += 'inv7ifdsyD/wcTCw3Ysd6l48SrI7JUPnrJTWXmC1YBxFftnBtgabn6wg+x1TYbEM'
LOGO += '57hf2BC6KGKuPDQJVdcNrGfo5K198ZpBRjpjjjlCTg6oTLsNtBdLxMTE3/4cgWo5'
LOGO += 'CSArnwhM2AyIDVWIHroRf66roxyy5zkVCQZ5z84ja6zSiV8I/4VB2xX6Civy3JrH'
LOGO += 'Elz4sa920nYoOM8Y1QF+EkfMHsL7aekZTkUIgg51S9iFAR897050uI9WrChpWd3S'
LOGO += 'cNIKhEZKwCby4c9inQzIuQAqE2AjfgF9GyDcsx8JQ8kfSSFxRgT9j2xpYcVF0D5u'
LOGO += 'yo7tdGJU3+HVWQJ3L4QQib774T8EmPw4eioSCcywS7ZHLSeah0XzwjQbgkZrcibh'
LOGO += 'Muv1De7IqfjmXaEqeGqcV7M2bKWXAEVU4QIdVWhgA/hDAczKsfBjrJNIXYV5QVrB'
LOGO += 'AH5WZBcTRc2AdxwxxFlZDqwqUpDXuYnOyzcPfvYWJ+A7ttS5hQ+WkRdBcWr59Y1w'
LOGO += 'tjAtZQ2W65Uq2uRZABlXx703JBPt59sOnRx+8Nn6RtVIGT4bBo3LnTU//u4Yv01A'
LOGO += 'zoA6oLDiKaKGBBiY69yM5ZVGoKX166PNLtO2eDr6fbbeyBSj+viXx0rTp4fqqZrK'
LOGO += 'mA0j2JsQftuDQ2HXv0QK79s2u9sZycym6uIepiqjUj5s8Ud2OaZAb0gVDNoV8YRa'
LOGO += 'R/mfVlvxQozQt9fQWvAbusEOn1g+ybyj+x1PCn/x/bEhSBj6Mq8eyQr14EGsriVE'
LOGO += '3pcwbFq8+Zbr+sSrZK40HS/IbjLOK72ENPDEcF0CE4FIgAf9Mo+dMEn3PMSbeURk'
LOGO += 'Ku/352rjgFTjPD2kS+pmpsDzPyfDeSQes8leCgNi2J9ZEb5P5UH+osWuff/cLcTE'
LOGO += '4YQZadj0yfnPsYo8SesYHEIzfbhPxogIP31WGyU2HHWt13dBcU2m9U7zhYE+EfN3'
LOGO += 'az6DcOZFCWKJ749NIGQp//kMqKD9hrxfLh5s0U9VjKVZBlfOWFx3N8jKRDsF4hg8'
LOGO += 'P7FSQNOgKSPyoZl0aafN0/NRLenWRPRQEnNG5rLcZYX8CvrwZg+t5Tfie60eI7KU'
LOGO += 'OOtj9ryMB/u8A5ETCzFDkRVBCX7Iu0w7mOKbRKiikG5BJrDF38vB3CBOuuZwix0v'
LOGO += 'ZQbqHK4i27jrn7FO42rn8Yy1Ehg5GgcYcpTNRQgK6fSABOD3JB4nNrQOorKQLxjb'
LOGO += 'tkECEhpvdiY8YGcVRAhnk/wRyg42pIMtnDF0sz6D9mbcbMPtSYfMBFMo9pUot/m6'
LOGO += 'AZTdevT10uBJeRLN8DMRO0JK2Q4i+ukp1rDHpcx2fSdc/EnnfY45JAfamy8dhSIR'
LOGO += 'ysPh9jj05YOQokT3HyqQ9em/038x2zBAh9vdYGmk59PiR2gnMcApwnMp7HqT/JEi'
LOGO += 'Z6xjwty8Vszrjx6kWWaBkI7JGAlsCyywdWn+n94sBjX9YNakU0qW9xqQIOAgJ60o'
LOGO += 'VSVh9On/Bi6Jbjo='

```

`scripts/plugins/ida/binlex/lib/blclient.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import json
import requests
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class BLClient():
    def __init__(self, url: str, api_key: str, verify=False):
        self.url = url
        self.api_key = api_key
        self.verify = verify

    def databases(self):
        r = requests.get(
            url=f'{self.url}/embeddings/databases',
            headers={
                'API-Key': self.api_key
            },
            verify=self.verify,
        )
        return r.status_code, json.loads(r.content)

    def inference(self, data: dict):
        r = requests.post(
            url=f'{self.url}/embeddings/inference',
            headers={
                'API-Key': self.api_key
            },
            json=data,
            verify=self.verify,
        )
        return r.status_code, json.loads(r.content)

    def collections(self, database: str):
        r = requests.get(
            url=f'{self.url}/embeddings/{database}/collections',
            headers={
                'API-Key', self.api_key
            },
            verify=self.verify,
        )
        return r.status_code, json.loads(r.content)

    def partitions(self, database: str, collection: str):
        r = requests.get(
            url=f'{self.url}/embeddings/{database}/{collection}/partitions',
            headers={
                'API-Key': self.api_key
            },
            verify=self.verify,
        )
        return r.status_code, json.loads(r.content)

    def index(self, database: str, collection: str, partition: str, data: dict):
        r = requests.post(
            url=f'{self.url}/embeddings/{database}/{collection}/{partition}/index',
            headers={
                'API-Key': self.api_key
            },
            json=data,
            verify=self.verify,
        )
        return r.status_code, json.loads(r.content)

    def search(
        self,
        database: str,
        collection: str,
        partition: str,
        offset: int,
        limit: int,
        threshold: float,
        vector: list,
        query: str = None):
        r = requests.post(
            url=f'{self.url}/embeddings/{database}/{collection}/{partition}/search/{offset}/{limit}/{threshold}',
            headers={
                'API-Key': self.api_key
            },
            json={"vector": vector, "query": query},
            verify=self.verify,
        )
        return r.status_code, json.loads(r.json())

```

`scripts/plugins/ida/binlex/lib/ida.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import re
import pickle
import idc
import idaapi
import ida_bytes
import idautils
import ida_ua
import ida_kernwin
import ida_nalt
import ida_registry
import ida_funcs

class IDA():

    def __init__(self):
        pass

    @staticmethod
    def get_database_sha256():
        return ida_nalt.retrieve_input_file_sha256().hex()

    @staticmethod
    def get_bytes(ea: int, size: int) -> bytes | None:
        result = None
        def thunk_get_bytes():
            nonlocal result
            result = idaapi.get_bytes(ea, size)
        ida_kernwin.execute_sync(thunk_get_bytes, ida_kernwin.MFF_READ)
        return result

    @staticmethod
    def file_attribute():
        return {
            'type': 'file',
            'sha256': ida_nalt.retrieve_input_file_sha256().hex(),
            'tlsh': None,
            'size': None,
            'entropy': None,
        }

    @staticmethod
    def get_function_symbol_attribute(ea: int):
        attribute = {}
        attribute['type'] = 'symbol'
        attribute['symbol_type'] = 'function'
        attribute['file_offset'] = None
        attribute['relative_virtual_address'] = None
        attribute['virtual_address'] = ea
        attribute['name'] = IDA.get_function_name(ea)
        attribute['slice'] = None
        return attribute

    def get_function_attributes(self, function) -> list:
        attributes = []
        attributes.append(self.file_attribute())
        attributes.append(self.get_function_symbol_attribute(function.start_ea))
        return attributes

    def set_name(self, ea: int, name: str):
        name = self.normalize_function_name(name)
        idaapi.set_name(ea, name, idaapi.SN_FORCE)

    @staticmethod
    def normalize_function_name(name: str) -> str:
        normalized = re.sub(r'[^0-9A-Za-z_]', '_', name)
        normalized = re.sub(r'_+', '_', normalized)
        if re.match(r'^\d', normalized):
            normalized = f'_{normalized}'
        return normalized

    def get_function_names(self):
        function_names = {}
        for function in self.get_functions():
            function_names[function.start_ea] = self.get_function_name(function.start_ea)
        return function_names

    @staticmethod
    def set_function_comment(ea: int, comment: str, repeatable: bool = True):
        f = idaapi.get_func(ea)
        idaapi.set_func_cmt(f, comment, repeatable)

    def delete_function_comment(self, ea: int, repeatable: bool = True):
        self.set_function_comment(ea, '', repeatable=repeatable)

    @staticmethod
    def get_functions() -> list:
        return [idaapi.get_func(ea) for ea in idautils.Functions()]

    @staticmethod
    def get_function(ea: int):
        return idaapi.get_func(ea)

    def is_function_ea(self, ea: int) -> bool:
        function = self.get_function(ea)
        if function is None: return False
        return function.start_ea == ea

    @staticmethod
    def get_function_name(ea: int) -> str:
        name =  idc.get_func_name(ea)
        if name is None: return ''
        return name

    @staticmethod
    def get_basic_block(ea: int):
        function = idaapi.get_func(ea)
        if function is None: return None
        for block in idaapi.FlowChart(function):
            if block.start_ea <= ea < block.end_ea:
                return block

    @staticmethod
    def get_function_blocks(function) -> list:
        return [block for block in idaapi.FlowChart(function)]

    @staticmethod
    def get_block_instructions(block) -> list:
        instructions = []
        ea = block.start_ea
        while ea < block.end_ea:
            insn = ida_ua.insn_t()
            ida_ua.decode_insn(insn, ea)
            instructions.append(insn)
            ea += insn.size
        return instructions

    @staticmethod
    def get_function_addresses(functions):
        return [function.start_ea for function in functions]

    @staticmethod
    def get_disassembly_selection_range():
        status, start_addr, end_addr = ida_kernwin.read_range_selection(ida_kernwin.get_current_viewer())
        if status is True:
            return (start_addr, end_addr)
        current_screen_ea = ida_kernwin.get_screen_ea()
        insn = ida_ua.insn_t()
        if ida_ua.decode_insn(insn, current_screen_ea):
            next_instr_ea = current_screen_ea + insn.size
        else:
            next_instr_ea = current_screen_ea
        return (current_screen_ea, next_instr_ea)

    @staticmethod
    def get_screen_ea() -> int:
        return ida_kernwin.get_screen_ea()

    @staticmethod
    def get_instruction_addresses():
        instruction_addresses = []
        for seg_ea in idautils.Segments():
            start = idc.get_segm_start(seg_ea)
            end = idc.get_segm_end(seg_ea)
            ea = start
            while ea < end:
                if idc.is_code(idc.get_full_flags(ea)):
                    instruction_addresses.append(ea)
                ea = idc.next_head(ea, end)
        return instruction_addresses

    @staticmethod
    def set_registry_value(key: str, value, subkey: str = 'binlex'):
        serialized_value = pickle.dumps(value)
        ida_registry.reg_write_binary(key, serialized_value, subkey=subkey)

    @staticmethod
    def get_registry_value(key: str, subkey: str = 'binlex'):
        value = ida_registry.reg_read_binary(key, subkey=subkey)
        if value is None:
            return None

        try:
            return pickle.loads(value)
        except (pickle.UnpicklingError, TypeError):
            return None

    @staticmethod
    def delete_registry_value(key: str, subkey: str = 'binlex'):
        ida_registry.reg_delete(key, subkey=subkey)

```

`scripts/plugins/ida/binlex/lib/styles.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

QPUSHBUTTON_STYLE = """
QPushButton {
    background-color: rgba(0, 0, 0, 200);
    color: white;
    border: 1px solid rgba(255, 255, 255, 255);
    border-radius: 10px; /* Rounded corners */
    padding: 6px;
    font: 14px "Segoe UI";   /* or any font you prefer */
}
QPushButton:hover {
    background-color: rgba(0, 0, 0, 255);
}
"""

```

`scripts/plugins/ida/binlex/lib/text.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

CREDITS = """
Project: Binlex
License: LGPL
Author: c3rb3ru5d3d53c
URL: github.com/c3rb3ru5d3d53c/binlex
Thank you for using Binlex!
"""

BANNER = """
    â €â €â €â €â €â €â €â €â¢€â£€â£€â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €
   â €â €â €â €â €â €â£ â¡¶â Ÿâ ›â ›â ›â ›â »â¢¶â£¤â¡€â €â €â €â €â €â €â €â €â €â €
  â €â €â €â €â €â¢€â£¾â ‹â£ â¡¶â Ÿâ ›â ›â ·â£¦â£„â ˆâ »â£¦â¡€â €â €â €â €â €â €â €â €
 â €â €â €â €â €â¢€â£¾â ƒâ °â Ÿâ¢ â¡¶â ¶â ¶â£¦â£„â ‰â ³â£¤â¡ˆâ¢»â£¦â €â €â €â €â €â €â €
 â €â €â €â €â €â£¼â ‡â£°â¡†â¢ â¡„â €â£€â£€â£€â ™â »â£¦â¡™â¢¿â£†â ‰â â €â €â €â €â €â €
 â €â €â €â €â °â ¿â¢ â¡¿â €â£¿â €â£¾â ‹â£‰â ™â¢·â£„â ˆâ »â£¦â¡™â¢³â£„â €â €â €â €â €â €
â €â €â €â €â €â£¤â €â šâ ƒâ €â£¿â €â£¿â¡€â ¹â£·â¡€â ™â¢·â£„â ˆâ »â¡¦â â €â €â €â €â €â €
     â£¿ â£´â °â£¦â ˜â£†  BINLEX â£„â ™â » â£¤â „â£°â¡„
 â €â €â €â €â¢¿â¡†â¢»â¡†â ¹â£§â ™â£¦â¡€â ‰â »â£¦â£„â ™â ³â †â¢ â¡¿â¢€â£¿â €â €â €â €â €
 â €â €â €â €â¢¸â£‡â ˆâ£¿â €â ˜â¢·â£Œâ ›â ¶â¡¤â €â£‰â ›â †â¢ â¡¿â¢â£¾â ƒâ €â €â €â €â €
  â €â €â €â €â Ÿâ¢€â£ â£´â ¦â €â ™â¢ƒâ£€â£€â ˆâ ™â ›â €â ›â¢â£¾â ƒâ €â €â €â €â €â €
  â €â €â €â €â €â ›â ‰â£ â£´â ¾â ›â¢›â£‰â£™â£›â¡›â —â °â£¦â €â â €â €â €â €â €â €â €
  â €â €â €â €â €â €â €â ‰â¢ â¡¶â Ÿâ¢›â£‰â£‰â£‰â¡›â ›â ¶â €â €â €â €â €â €â €â €â €â €
   â €â €â €â €â €â €â €â €â €â â¢‹â£â£ â£ˆâ ™â ›â €â €â €â €â €â €â €â €â €â €â €
â €â €â €â €â €â €â €â €â €â €â €â €â €â ˆâ ‰â ‰â ‰â â €â €â €
   If maldevs think their binary is FUD,
they're about to have an existential crisis.
"""

```

`scripts/plugins/ida/binlex/lib/worker.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import inspect
from typing import Callable
from dataclasses import field, dataclass
from threading import Thread
import ida_kernwin

@dataclass(unsafe_hash=True)
class Worker(Thread):
    target: Callable
    args: tuple = field(default_factory=tuple, compare=False)
    done_callback: Callable = None
    error_callback: Callable = None

    def __post_init__(self):
        super().__init__(target=self.__wrapped_target, args=self.args, daemon=True)

    def __wrapped_target(self, *args, **kwargs):
        try:
            results = self.target(*args, **kwargs)

            if self.done_callback is not None:
                def call_done_callback():
                    argument_spec = inspect.getfullargspec(self.done_callback)
                    argument_count = len(argument_spec.args)
                    if argument_count > 1:
                        self.done_callback(*results)
                    elif argument_count == 1 and results is not None:
                        self.done_callback(results)
                    else:
                        self.done_callback()

                ida_kernwin.execute_sync(call_done_callback, ida_kernwin.MFF_FAST)
        except Exception as exception:
            if self.error_callback is not None:
                def call_error_callback():
                    argument_spec = inspect.getfullargspec(self.error_callback)
                    argument_count = len(argument_spec.args)
                    if argument_count == 1:
                        self.error_callback(exception)
                    else:
                        self.error_callback()

                ida_kernwin.execute_sync(call_error_callback, ida_kernwin.MFF_FAST)
            else:
                raise exception
        finally:
            if self.done_callback is not None:
                del self.done_callback
            if self.error_callback is not None:
                del self.error_callback

```

`scripts/plugins/ida/binlex/main.py`:

```py
#!/usr/bin/env python

#                    GNU LESSER GENERAL PUBLIC LICENSE
#                        Version 3, 29 June 2007
#
#  Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.
#
#
#   This version of the GNU Lesser General Public License incorporates
# the terms and conditions of version 3 of the GNU General Public
# License, supplemented by the additional permissions listed below.
#
#   0. Additional Definitions.
#
#   As used herein, "this License" refers to version 3 of the GNU Lesser
# General Public License, and the "GNU GPL" refers to version 3 of the GNU
# General Public License.
#
#   "The Library" refers to a covered work governed by this License,
# other than an Application or a Combined Work as defined below.
#
#   An "Application" is any work that makes use of an interface provided
# by the Library, but which is not otherwise based on the Library.
# Defining a subclass of a class defined by the Library is deemed a mode
# of using an interface provided by the Library.
#
#   A "Combined Work" is a work produced by combining or linking an
# Application with the Library.  The particular version of the Library
# with which the Combined Work was made is also called the "Linked
# Version".
#
#   The "Minimal Corresponding Source" for a Combined Work means the
# Corresponding Source for the Combined Work, excluding any source code
# for portions of the Combined Work that, considered in isolation, are
# based on the Application, and not on the Linked Version.
#
#   The "Corresponding Application Code" for a Combined Work means the
# object code and/or source code for the Application, including any data
# and utility programs needed for reproducing the Combined Work from the
# Application, but excluding the System Libraries of the Combined Work.
#
#   1. Exception to Section 3 of the GNU GPL.
#
#   You may convey a covered work under sections 3 and 4 of this License
# without being bound by section 3 of the GNU GPL.
#
#   2. Conveying Modified Versions.
#
#   If you modify a copy of the Library, and, in your modifications, a
# facility refers to a function or data to be supplied by an Application
# that uses the facility (other than as an argument passed when the
# facility is invoked), then you may convey a copy of the modified
# version:
#
#    a) under this License, provided that you make a good faith effort to
#    ensure that, in the event an Application does not supply the
#    function or data, the facility still operates, and performs
#    whatever part of its purpose remains meaningful, or
#
#    b) under the GNU GPL, with none of the additional permissions of
#    this License applicable to that copy.
#
#   3. Object Code Incorporating Material from Library Header Files.
#
#   The object code form of an Application may incorporate material from
# a header file that is part of the Library.  You may convey such object
# code under terms of your choice, provided that, if the incorporated
# material is not limited to numerical parameters, data structure
# layouts and accessors, or small macros, inline functions and templates
# (ten or fewer lines in length), you do both of the following:
#
#    a) Give prominent notice with each copy of the object code that the
#    Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the object code with a copy of the GNU GPL and this license
#    document.
#
#   4. Combined Works.
#
#   You may convey a Combined Work under terms of your choice that,
# taken together, effectively do not restrict modification of the
# portions of the Library contained in the Combined Work and reverse
# engineering for debugging such modifications, if you also do each of
# the following:
#
#    a) Give prominent notice with each copy of the Combined Work that
#    the Library is used in it and that the Library and its use are
#    covered by this License.
#
#    b) Accompany the Combined Work with a copy of the GNU GPL and this license
#    document.
#
#    c) For a Combined Work that displays copyright notices during
#    execution, include the copyright notice for the Library among
#    these notices, as well as a reference directing the user to the
#    copies of the GNU GPL and this license document.
#
#    d) Do one of the following:
#
#        0) Convey the Minimal Corresponding Source under the terms of this
#        License, and the Corresponding Application Code in a form
#        suitable for, and under terms that permit, the user to
#        recombine or relink the Application with a modified version of
#        the Linked Version to produce a modified Combined Work, in the
#        manner specified by section 6 of the GNU GPL for conveying
#        Corresponding Source.
#
#        1) Use a suitable shared library mechanism for linking with the
#        Library.  A suitable mechanism is one that (a) uses at run time
#        a copy of the Library already present on the user's computer
#        system, and (b) will operate properly with a modified version
#        of the Library that is interface-compatible with the Linked
#        Version.
#
#    e) Provide Installation Information, but only if you would otherwise
#    be required to provide such information under section 6 of the
#    GNU GPL, and only to the extent that such information is
#    necessary to install and execute a modified version of the
#    Combined Work produced by recombining or relinking the
#    Application with a modified version of the Linked Version. (If
#    you use option 4d0, the Installation Information must accompany
#    the Minimal Corresponding Source and Corresponding Application
#    Code. If you use option 4d1, you must provide the Installation
#    Information in the manner specified by section 6 of the GNU GPL
#    for conveying Corresponding Source.)
#
#   5. Combined Libraries.
#
#   You may place library facilities that are a work based on the
# Library side by side in a single library together with other library
# facilities that are not Applications and are not covered by this
# License, and convey such a combined library under terms of your
# choice, if you do both of the following:
#
#    a) Accompany the combined library with a copy of the same work based
#    on the Library, uncombined with any other library facilities,
#    conveyed under the terms of this License.
#
#    b) Give prominent notice with the combined library that part of it
#    is a work based on the Library, and explaining where to find the
#    accompanying uncombined form of the same work.
#
#   6. Revised Versions of the GNU Lesser General Public License.
#
#   The Free Software Foundation may publish revised and/or new versions
# of the GNU Lesser General Public License from time to time. Such new
# versions will be similar in spirit to the present version, but may
# differ in detail to address new problems or concerns.
#
#   Each version is given a distinguishing version number. If the
# Library as you received it specifies that a certain numbered version
# of the GNU Lesser General Public License "or any later version"
# applies to it, you have the option of following the terms and
# conditions either of that published version or of any later version
# published by the Free Software Foundation. If the Library as you
# received it does not specify a version number of the GNU Lesser
# General Public License, you may choose any version of the GNU Lesser
# General Public License ever published by the Free Software Foundation.
#
#   If the Library as you received it specifies that a proxy can decide
# whether future versions of the GNU Lesser General Public License shall
# apply, that proxy's public statement of acceptance of any version is
# permanent authorization for you to choose that version for the
# Library.

import idc
import idaapi
import ida_bytes
import idautils
import ida_kernwin
import ida_ida
import json
import os
from binlex.formats import (
    File,
    PE,
    ELF
)
from binlex.hashing import (
    MinHash32,
    TLSH
)
from binlex import (
    Config,
    Architecture
)
from binlex.controlflow import (
    Graph,
    Instruction,
    FunctionJsonDeserializer,
    BlockJsonDeserializer,
)
from binlex.genetics import Chromosome
from binlex.disassemblers.capstone import Disassembler as CapstoneDisassembler
from binlex.types import MemoryMappedFile
from PyQt5.QtWidgets import QApplication, QDialog
import tempfile
from lib import IDA
from gui.hooks import UIHooks
from gui import (
    register_action_handlers,
    unregister_action_handlers,
    Main,
    SVGWidget,
    Progress,
    JSONSearchWindow,
    OkayCancelDialog,
    About,
)
from lib.text import BANNER
from actions import (
    copy_pattern,
    copy_hex,
    scan_minhash,
    copy_minhash,
    copy_tlsh,
    scan_tlsh,
    function_table,
    search_database,
    index_database,
    export,
    export_byte_colormap,
    copy_block_json,
    copy_block_vector,
    copy_function_vector,
    copy_function_json,
    index_function,
    index_block,
)
from binlex.imaging import ColorMap

class BinlexPlugin(idaapi.plugin_t):
    flags = idaapi.PLUGIN_DRAW
    comment = 'Binlex IDA Plugin'
    help = 'A Binary Genetic Trait Lexer Framework'
    wanted_name = 'Binlex'

    def init(self):
        self.config = Config()
        try:
            self.config.write_default()
        except:
            pass
        self.config.from_default()
        self.main_window = None
        self.about_window = None
        self.function_table_window = None
        self.json_search_window = None
        self.is_disassembled = False
        self.ui_hooks = UIHooks(self)
        self.ui_hooks.hook()
        self.ida = IDA()
        register_action_handlers(self)
        self.load_binary()
        ida_kernwin.msg(BANNER + '\n')
        return idaapi.PLUGIN_KEEP

    def action_copy_pattern(self):
        copy_pattern(self)

    def action_copy_hex(self):
        copy_hex(self)

    def action_copy_tlsh(self):
        copy_tlsh(self)

    def action_copy_minhash(self):
        copy_minhash(self)

    def action_index_function(self):
        index_function(self)

    def action_index_block(self):
        index_block(self)

    def _disassemble_controlflow(self):
        number_of_functions = len(IDA.get_functions())
        progress = Progress(title='Disassembling CFG', max_value=number_of_functions)
        progress.show()
        for function in IDA.get_functions():
            progress.increment()
            self.disassemble_function(function)
        progress.close()

    def disassemble_function(self, function):
        for block in IDA.get_function_blocks(function):
            self.disassemble_block(block)

    def disassemble_block(self, block):
        to = set([bb.start_ea for bb in block.succs()])
        for instruction in IDA.get_block_instructions(block):
            self.disassemble_instruction(instruction)
            if IDA().is_function_ea(instruction.ea):
                self.cfg.set_function(instruction.ea)
            if block.start_ea == instruction.ea:
                self.cfg.set_block(instruction.ea)
            if idc.prev_head(block.end_ea) == instruction.ea:
                self.cfg.extend_instruction_edges(instruction.ea, to)

    def disassemble_instruction(self, instruction):
        self.disassembler.disassemble_instruction(instruction.ea, self.cfg)

    def load_disassembler(self):
        self.disassembler = CapstoneDisassembler(self.architecture, self.image, self.executable_address_ranges, self.config)

    def action_copy_block_vector(self):
        copy_block_vector(self)

    def action_copy_block_json(self):
        copy_block_json(self)

    def action_copy_function_vector(self):
        copy_function_vector(self)

    def action_copy_function_json(self):
        copy_function_json(self)

    def update(self, ctx):
        if ctx.widget:
            widget_type = ida_kernwin.get_widget_type(ctx.widget)
            ida_kernwin.msg(f"[*] Widget type: {widget_type}\n")
            if widget_type == ida_kernwin.BWN_DISASM:
                return ida_kernwin.AST_ENABLE_ALWAYS
        return ida_kernwin.AST_DISABLE

    @staticmethod
    def get_function_symbol_attribute(ea: int):
        attribute = {}
        attribute['type'] = 'symbol'
        attribute['symbol_type'] = 'function'
        attribute['file_offset'] = None
        attribute['relative_virtual_address'] = None
        attribute['virtual_address'] = ea
        attribute['name'] = IDA.get_function_name(ea)
        attribute['slice'] = None
        return attribute

    def disassemble_controlflow(self):
        if not self.is_disassembled:
            self._disassemble_controlflow()
            self.is_disassembled = True
            return

        dialog = OkayCancelDialog(title='Disassemble Again?', okay_text='Disassemble', cancel_text='Continue')
        if dialog.exec_() == QDialog.Accepted:
            self._disassemble_controlflow()

    def action_export(self):
        export(self)

    def load_image(self):
        directory = os.path.join(tempfile.gettempdir(), 'binlex')
        if not os.path.exists(directory): os.makedirs(directory)
        file_path = os.path.join(directory, IDA().get_database_sha256())
        self.mapped_file = MemoryMappedFile(file_path, False)
        for segment in idautils.Segments():
            start = idc.get_segm_start(segment)
            end = idc.get_segm_end(segment)
            data = ida_bytes.get_bytes(start, end - start)
            if data is None: continue
            if self.mapped_file.size() < start:
                self.mapped_file.seek_to_end()
                self.mapped_file.write_padding(start - self.mapped_file.size())
            self.mapped_file.seek_to_end()
            self.mapped_file.write(data)
        self.executable_address_ranges = {0: self.mapped_file.size()}
        self.image = self.mapped_file.mmap()

    def load_binary(self) -> bool:
        if ida_ida.inf_get_procname() == 'metapc':
            if ida_ida.inf_is_32bit_exactly() is True:
                self.architecture = Architecture.from_str('i386')
                self.cfg = Graph(self.architecture, self.config)
                self.load_image()
                self.load_disassembler()
                return True
            else:
                self.architecture = Architecture.from_str('amd64')
                self.cfg = Graph(self.architecture, self.config)
                self.load_image()
                self.load_disassembler()
                return True
        return False

    def open_main_window(self):
        if not self.main_window:
            self.main_window = Main(self)
        self.main_window.show()

    def open_about_window(self):
        if not self.about_window:
            self.about_window = About(self)
        self.about_window.exec_()

    def action_scan_tlsh(self):
        scan_tlsh(self)

    def action_scan_minhash(self):
        scan_minhash(self)

    def action_search_database(self):
        search_database(self)

    def action_json_search_window(self):
        if not self.json_search_window:
            self.disassemble_controlflow()
            data = [json.loads(function.json()) for function in self.cfg.functions()]
            data.extend([json.loads(block.json()) for block in self.cfg.blocks()])
            self.json_search_window = JSONSearchWindow(json_objects=data)
        self.json_search_window.Show('Binlex JSON Search')

    def action_export_byte_colormap(self):
        export_byte_colormap(self)

    def get_function_attributes(self) -> dict:
        results = {}
        for address in self.cfg.queue_functions.valid_addresses():
            attributes = []
            attributes.append(IDA.file_attribute())
            attributes.append(self.get_function_symbol_attribute(address))
            results[address] = attributes
        return results

    def get_block_attributes(self) -> dict:
        results = {}
        for address in self.cfg.queue_blocks.valid_addresses():
            attributes = []
            attributes.append(IDA.file_attribute())
            results[address] = attributes
        return results

    def action_index_database(self):
        index_database(self)

    def action_function_table(self):
        function_table(self)

    def run(self, arg):
        self.open_main_window()

    def term(self):
        self.ui_hooks.unhook()
        unregister_action_handlers()

def PLUGIN_ENTRY():
    return BinlexPlugin()

```

`scripts/plugins/ida/binlex/requirements.txt`:

```txt
requests==2.32.3

```

`src/bin/binlex.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use binlex::controlflow::Attributes;
use binlex::controlflow::Block;
use binlex::controlflow::Function;
use binlex::controlflow::Graph;
use binlex::controlflow::Instruction;
use binlex::controlflow::Symbol;
use binlex::controlflow::Tag;
//use binlex::disassemblers::capstone::x86::Disassembler;
use binlex::disassemblers::capstone::Disassembler;
use binlex::disassemblers::custom::cil::Disassembler as CILDisassembler;
use binlex::formats::pe::PE;
use binlex::formats::File as BLFile;
use binlex::formats::ELF;
use binlex::formats::MACHO;
use binlex::io::Stderr;
use binlex::io::Stdin;
use binlex::io::Stdout;
use binlex::io::JSON;
use binlex::types::LZ4String;
use binlex::Architecture;
use binlex::Config;
use binlex::Format;
use binlex::AUTHOR;
use binlex::VERSION;
use clap::Parser;
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};
use rayon::ThreadPoolBuilder;
use serde_json::json;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::collections::HashSet;
use std::fs::File;
use std::io::Write;
use std::process;

#[derive(Parser, Debug)]
#[command(
    name = "binlex",
    version = VERSION,
    about = format!("A Binary Pattern Lexer\n\nVersion: {}", VERSION),
    after_help = format!("Author: {}", AUTHOR),
)]
pub struct Args {
    #[arg(short, long)]
    pub input: String,
    #[arg(short, long)]
    pub output: Option<String>,
    #[arg(short, long, help = format!("[{}]", Architecture::to_list()))]
    pub architecture: Option<Architecture>,
    #[arg(short, long)]
    pub config: Option<String>,
    #[arg(short, long)]
    pub threads: Option<usize>,
    #[arg(long, value_delimiter = ',', default_value = None)]
    pub tags: Option<Vec<String>>,
    #[arg(long, default_value_t = false)]
    pub minimal: bool,
    #[arg(short, long, default_value_t = false)]
    pub debug: bool,
    #[arg(long, default_value_t = false)]
    pub enable_instructions: bool,
    #[arg(long, default_value_t = false)]
    pub enable_block_instructions: bool,
    #[arg(long, default_value_t = false)]
    pub disable_hashing: bool,
    #[arg(long, default_value_t = false)]
    pub disable_disassembler_sweep: bool,
    #[arg(long, default_value_t = false)]
    pub disable_function_blocks: bool,
    #[arg(long, default_value_t = false)]
    pub disable_heuristics: bool,
    #[arg(long, default_value_t = false)]
    pub enable_mmap_cache: bool,
    #[arg(long)]
    pub mmap_directory: Option<String>,
}

fn validate_args(args: &Args) {
    if let Some(tags) = &args.tags {
        let mut unique_tags = HashSet::new();
        for tag in tags {
            if !unique_tags.insert(tag) {
                eprintln!("tags must be unique");
                process::exit(1);
            }
        }
    }
}

fn get_elf_function_symbols(elf: &ELF) -> BTreeMap<u64, Symbol> {
    let mut symbols = BTreeMap::<u64, Symbol>::new();

    if Stdin::is_terminal() {
        return symbols;
    }

    let json = JSON::from_stdin_with_filter(|value| {
        let obj = match value.as_object_mut() {
            Some(obj) => obj,
            None => return false,
        };

        let obj_type = obj.get("type").and_then(|v| v.as_str()).map(String::from);
        let symbol_type = obj
            .get("symbol_type")
            .and_then(|v| v.as_str())
            .map(String::from);
        let file_offset = obj.get("file_offset").and_then(|v| v.as_u64());
        let relative_virtual_address = obj.get("relative_virtual_address").and_then(|v| v.as_u64());
        let mut virtual_address = obj.get("virtual_address").and_then(|v| v.as_u64());

        if obj_type.as_deref() != Some("symbol") {
            return false;
        }

        if symbol_type.is_none() {
            return false;
        }

        if file_offset.is_none() && relative_virtual_address.is_none() && virtual_address.is_none()
        {
            return false;
        }

        if virtual_address.is_some() {
            return true;
        }

        if virtual_address.is_none() {
            if let Some(rva) = relative_virtual_address {
                virtual_address = Some(elf.relative_virtual_address_to_virtual_address(rva));
            }
            if let Some(offset) = file_offset {
                if let Some(va) = elf.file_offset_to_virtual_address(offset) {
                    virtual_address = Some(va);
                }
            }

            if let Some(va) = virtual_address {
                obj.insert("virtual_address".to_string(), json!(va));
                return true;
            }
        }

        false
    });

    if json.is_ok() {
        for value in json.unwrap().values() {
            let address = value.get("virtual_address").and_then(|v| v.as_u64());
            let name = value.get("name").and_then(|v| v.as_str());
            let symbol_type = value.get("symbol_type").and_then(|v| v.as_str());
            if address.is_none() {
                continue;
            }
            if name.is_none() {
                continue;
            }
            if symbol_type.is_none() {
                continue;
            }
            let symbol = Symbol::new(
                address.unwrap(),
                symbol_type.unwrap().to_string(),
                name.unwrap().to_string(),
            );
            symbols.insert(address.unwrap(), symbol);
        }
    }

    symbols
}

fn get_macho_function_symbols(macho: &MACHO) -> BTreeMap<u64, Symbol> {
    let mut symbols = BTreeMap::<u64, Symbol>::new();

    if Stdin::is_terminal() {
        return symbols;
    }

    let json = JSON::from_stdin_with_filter(|value| {
        let obj = match value.as_object_mut() {
            Some(obj) => obj,
            None => return false,
        };

        let obj_type = obj.get("type").and_then(|v| v.as_str()).map(String::from);
        let symbol_type = obj
            .get("symbol_type")
            .and_then(|v| v.as_str())
            .map(String::from);
        let file_offset = obj.get("file_offset").and_then(|v| v.as_u64());
        let relative_virtual_address = obj.get("relative_virtual_address").and_then(|v| v.as_u64());
        let mut virtual_address = obj.get("virtual_address").and_then(|v| v.as_u64());
        let slice = obj.get("slice").and_then(|v| v.as_u64());

        if slice.is_none() {
            return false;
        }

        let slice = slice.unwrap() as usize;

        if obj_type.as_deref() != Some("symbol") {
            return false;
        }

        if symbol_type.is_none() {
            return false;
        }

        if file_offset.is_none() && relative_virtual_address.is_none() && virtual_address.is_none()
        {
            return false;
        }

        if virtual_address.is_some() {
            return true;
        }

        if virtual_address.is_none() {
            if let Some(rva) = relative_virtual_address {
                let va = macho.relative_virtual_address_to_virtual_address(rva, slice);
                if va.is_none() {
                    return false;
                }
                virtual_address = Some(va.unwrap());
            }
            if let Some(offset) = file_offset {
                if let Some(va) = macho.file_offset_to_virtual_address(offset, slice) {
                    virtual_address = Some(va);
                }
            }

            if let Some(va) = virtual_address {
                obj.insert("virtual_address".to_string(), json!(va));
                return true;
            }
        }

        false
    });

    if json.is_ok() {
        for value in json.unwrap().values() {
            let address = value.get("virtual_address").and_then(|v| v.as_u64());
            let name = value.get("name").and_then(|v| v.as_str());
            let symbol_type = value.get("symbol_type").and_then(|v| v.as_str());
            if address.is_none() {
                continue;
            }
            if name.is_none() {
                continue;
            }
            if symbol_type.is_none() {
                continue;
            }
            let symbol = Symbol::new(
                address.unwrap(),
                symbol_type.unwrap().to_string(),
                name.unwrap().to_string(),
            );
            symbols.insert(address.unwrap(), symbol);
        }
    }

    symbols
}

fn get_pe_function_symbols(pe: &PE) -> BTreeMap<u64, Symbol> {
    let mut symbols = BTreeMap::<u64, Symbol>::new();

    if Stdin::is_terminal() {
        return symbols;
    }

    let json = JSON::from_stdin_with_filter(|value| {
        let obj = match value.as_object_mut() {
            Some(obj) => obj,
            None => return false,
        };

        let obj_type = obj.get("type").and_then(|v| v.as_str()).map(String::from);
        let symbol_type = obj
            .get("symbol_type")
            .and_then(|v| v.as_str())
            .map(String::from);
        let file_offset = obj.get("file_offset").and_then(|v| v.as_u64());
        let relative_virtual_address = obj.get("relative_virtual_address").and_then(|v| v.as_u64());
        let mut virtual_address = obj.get("virtual_address").and_then(|v| v.as_u64());

        if obj_type.as_deref() != Some("symbol") {
            return false;
        }

        if symbol_type.is_none() {
            return false;
        }

        if file_offset.is_none() && relative_virtual_address.is_none() && virtual_address.is_none()
        {
            return false;
        }

        if virtual_address.is_some() {
            return true;
        }

        if virtual_address.is_none() {
            if let Some(rva) = relative_virtual_address {
                virtual_address = Some(pe.relative_virtual_address_to_virtual_address(rva));
            }
            if let Some(offset) = file_offset {
                if let Some(va) = pe.file_offset_to_virtual_address(offset) {
                    virtual_address = Some(va);
                }
            }

            if let Some(va) = virtual_address {
                obj.insert("virtual_address".to_string(), json!(va));
                return true;
            }
        }

        false
    });

    if json.is_ok() {
        for value in json.unwrap().values() {
            let address = value.get("virtual_address").and_then(|v| v.as_u64());
            let name = value.get("name").and_then(|v| v.as_str());
            let symbol_type = value.get("symbol_type").and_then(|v| v.as_str());
            if address.is_none() {
                continue;
            }
            if name.is_none() {
                continue;
            }
            if symbol_type.is_none() {
                continue;
            }
            let symbol = Symbol::new(
                address.unwrap(),
                symbol_type.unwrap().to_string(),
                name.unwrap().to_string(),
            );
            symbols.insert(address.unwrap(), symbol);
        }
    }

    symbols
}

fn process_output(
    output: Option<String>,
    cfg: &Graph,
    attributes: &Attributes,
    function_symbols: &BTreeMap<u64, Symbol>,
) {
    let mut instructions = Vec::<LZ4String>::new();

    if cfg.config.instructions.enabled {
        instructions = cfg
            .instructions
            .valid()
            .iter()
            .map(|entry| *entry)
            .collect::<Vec<u64>>()
            .par_iter()
            .filter_map(|address| Instruction::new(*address, cfg).ok())
            .filter_map(|instruction| {
                let mut instruction_attributes = Attributes::new();
                let symbol = function_symbols.get(&instruction.address);
                if let Some(symbol) = symbol {
                    instruction_attributes.push(symbol.attribute());
                }
                for attribute in &attributes.values {
                    instruction_attributes.push(attribute.clone());
                }
                instruction
                    .json_with_attributes(instruction_attributes.clone())
                    .ok()
            })
            .map(|js| LZ4String::new(&js))
            .collect();
    }

    let mut blocks = Vec::<LZ4String>::new();

    if cfg.config.blocks.enabled {
        blocks = cfg
            .blocks
            .valid()
            .iter()
            .map(|entry| *entry)
            .collect::<Vec<u64>>()
            .par_iter()
            .filter_map(|address| Block::new(*address, cfg).ok())
            .filter_map(|block| {
                let mut block_attributes = Attributes::new();
                let symbol = function_symbols.get(&block.address);
                if let Some(symbol) = symbol {
                    block_attributes.push(symbol.attribute());
                }
                for attribute in &attributes.values {
                    block_attributes.push(attribute.clone());
                }
                block.json_with_attributes(block_attributes.clone()).ok()
            })
            .map(|js| LZ4String::new(&js))
            .collect();
    }

    let mut functions = Vec::<LZ4String>::new();

    if cfg.config.functions.enabled {
        functions = cfg
            .functions
            .valid()
            .iter()
            .map(|entry| *entry)
            .collect::<Vec<u64>>()
            .par_iter()
            .filter_map(|address| Function::new(*address, cfg).ok())
            .filter_map(|function| {
                let mut function_attributes = Attributes::new();
                let symbol = function_symbols.get(&function.address);
                if let Some(symbol) = symbol {
                    function_attributes.push(symbol.attribute());
                }
                for attribute in &attributes.values {
                    function_attributes.push(attribute.clone());
                }
                function.json_with_attributes(function_attributes).ok()
            })
            .map(|js| LZ4String::new(&js))
            .collect();
    }

    if output.is_none() {
        instructions.iter().for_each(|result| {
            Stdout::print(result);
        });

        blocks.iter().for_each(|result| {
            Stdout::print(result);
        });

        functions.iter().for_each(|result| {
            Stdout::print(result);
        });
    }

    if let Some(output_file) = output {
        let mut file = match File::create(output_file) {
            Ok(file) => file,
            Err(error) => {
                eprintln!("{}", error);
                std::process::exit(1);
            }
        };

        if cfg.config.instructions.enabled {
            for instruction in instructions {
                if let Err(error) = writeln!(file, "{}", instruction) {
                    eprintln!("{}", error);
                    std::process::exit(1);
                }
            }
        }

        for block in blocks {
            if let Err(error) = writeln!(file, "{}", block) {
                eprintln!("{}", error);
                std::process::exit(1);
            }
        }

        for function in functions {
            if let Err(error) = writeln!(file, "{}", function) {
                eprintln!("{}", error);
                std::process::exit(1);
            }
        }
    }
}

fn process_pe(input: String, config: Config, tags: Option<Vec<String>>, output: Option<String>) {
    let mut attributes = Attributes::new();

    let pe = match PE::new(input, config.clone()) {
        Ok(pe) => pe,
        Err(error) => {
            eprintln!("failed to read pe file: {}", error);
            process::exit(1);
        }
    };

    if pe.architecture() == Architecture::UNKNOWN {
        eprintln!("unsupported pe architecture");
        process::exit(1);
    }

    if !config.general.minimal {
        let file_attribute = pe.file.attribute();
        if tags.is_some() {
            for tag in tags.unwrap() {
                attributes.push(Tag::new(tag).attribute());
            }
        }
        attributes.push(file_attribute);
    }

    let function_symbols = get_pe_function_symbols(&pe);

    // for (_, symbol) in &function_symbols {
    //     attributes.push(Attribute::Symbol(symbol.process().clone()));
    // }

    let mut mapped_file = pe.image().unwrap_or_else(|error| {
        eprintln!("failed to map pe image: {}", error);
        process::exit(1)
    });

    Stderr::print_debug(config.clone(), "mapped pe image");

    let image = mapped_file.mmap().unwrap_or_else(|error| {
        eprintln!("failed to get pe virtual image: {}", error);
        process::exit(1);
    });

    Stderr::print_debug(config.clone(), "obtained mapped image pointer");

    let executable_address_ranges = match pe.is_dotnet() {
        true => pe.dotnet_executable_virtual_address_ranges(),
        _ => pe.executable_virtual_address_ranges(),
    };

    let mut entrypoints = BTreeSet::<u64>::new();

    match pe.is_dotnet() {
        true => entrypoints.extend(pe.dotnet_entrypoint_virtual_addresses()),
        _ => entrypoints.extend(pe.entrypoint_virtual_addresses()),
    }

    entrypoints.extend(function_symbols.keys());

    let mut cfg = Graph::new(pe.architecture(), config.clone());

    if !pe.is_dotnet() {
        Stderr::print_debug(config.clone(), "starting pe disassembler");

        let disassembler = match Disassembler::new(
            pe.architecture(),
            image,
            executable_address_ranges.clone(),
            config.clone(),
        ) {
            Ok(disassembler) => disassembler,
            Err(error) => {
                eprintln!("{}", error);
                process::exit(1);
            }
        };

        disassembler
            .disassemble_controlflow(entrypoints.clone(), &mut cfg)
            .unwrap_or_else(|error| {
                eprintln!("{}", error);
                process::exit(1);
            });
    } else if pe.is_dotnet() {
        Stderr::print_debug(config.clone(), "starting pe dotnet disassembler");

        let disassembler = match CILDisassembler::new(
            pe.architecture(),
            image,
            pe.dotnet_metadata_token_virtual_addresses().clone(),
            executable_address_ranges.clone(),
            config.clone(),
        ) {
            Ok(disassembler) => disassembler,
            Err(error) => {
                eprintln!("{}", error);
                process::exit(1);
            }
        };

        disassembler
            .disassemble_controlflow(entrypoints.clone(), &mut cfg)
            .unwrap_or_else(|error| {
                eprintln!("{}", error);
                process::exit(1);
            });
    } else {
        eprintln!("invalid or unsupported pe file");
        process::exit(1);
    }

    process_output(output, &cfg, &attributes, &function_symbols);
}

fn process_elf(input: String, config: Config, tags: Option<Vec<String>>, output: Option<String>) {
    let mut attributes = Attributes::new();

    let elf = ELF::new(input, config.clone()).unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1);
    });

    if elf.architecture() == Architecture::UNKNOWN {
        eprintln!("unsupported elf architecture");
        process::exit(1);
    }

    if !config.general.minimal {
        let file_attribute = elf.file.attribute();
        if tags.is_some() {
            for tag in tags.unwrap() {
                attributes.push(Tag::new(tag).attribute());
            }
        }
        attributes.push(file_attribute);
    }

    let function_symbols = get_elf_function_symbols(&elf);

    // for (_, symbol) in &function_symbols {
    //     attributes.push(Attribute::Symbol(symbol.process().clone()));
    // }

    let mut mapped_file = elf.image().unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1)
    });

    let image = mapped_file.mmap().unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1);
    });

    let executable_address_ranges = elf.executable_virtual_address_ranges();

    let mut entrypoints = BTreeSet::<u64>::new();

    entrypoints.extend(elf.entrypoint_virtual_addresses());

    let mut cfg = Graph::new(elf.architecture(), config.clone());

    let disassembler = match Disassembler::new(
        elf.architecture(),
        image,
        executable_address_ranges.clone(),
        config.clone(),
    ) {
        Ok(disassembler) => disassembler,
        Err(error) => {
            eprintln!("{}", error);
            process::exit(1);
        }
    };

    disassembler
        .disassemble_controlflow(entrypoints, &mut cfg)
        .unwrap_or_else(|error| {
            eprintln!("{}", error);
            process::exit(1);
        });

    process_output(output, &cfg, &attributes, &function_symbols);
}

fn process_code(input: String, config: Config, architecture: Architecture, output: Option<String>) {
    let mut attributes = Attributes::new();

    let mut file = BLFile::new(input, config.clone()).unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1);
    });
    file.read().unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1);
    });

    let mut cfg = Graph::new(architecture, config.clone());

    let mut executable_address_ranges = BTreeMap::<u64, u64>::new();
    executable_address_ranges.insert(0, file.size());

    let mut entrypoints = BTreeSet::<u64>::new();

    entrypoints.insert(0x00);

    match architecture {
        Architecture::AMD64 | Architecture::I386 => {
            let disassembler = match Disassembler::new(
                architecture,
                &file.data,
                executable_address_ranges.clone(),
                config.clone(),
            ) {
                Ok(disassembler) => disassembler,
                Err(error) => {
                    eprintln!("{}", error);
                    process::exit(1);
                }
            };

            disassembler
                .disassemble_controlflow(entrypoints, &mut cfg)
                .unwrap_or_else(|error| {
                    eprintln!("{}", error);
                    process::exit(1);
                });
        }
        Architecture::CIL => {
            let disassembler = match CILDisassembler::new(
                architecture,
                &file.data,
                BTreeMap::<u64, u64>::new(),
                executable_address_ranges.clone(),
                config.clone(),
            ) {
                Ok(disassembler) => disassembler,
                Err(error) => {
                    eprintln!("{}", error);
                    process::exit(1);
                }
            };

            disassembler
                .disassemble_controlflow(entrypoints, &mut cfg)
                .unwrap_or_else(|error| {
                    eprintln!("{}", error);
                    process::exit(1);
                });
        }
        _ => {}
    }

    attributes.push(file.attribute());

    let function_symbols = BTreeMap::<u64, Symbol>::new();

    process_output(output, &cfg, &attributes, &function_symbols);
}

fn process_macho(input: String, config: Config, tags: Option<Vec<String>>, output: Option<String>) {
    let mut attributes = Attributes::new();

    let macho = MACHO::new(input, config.clone()).unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1);
    });

    for slice in 0..macho.number_of_slices() {
        let architecture = macho.architecture(slice);
        if architecture.is_none() {
            continue;
        }
        let architecture = architecture.unwrap();
        if architecture == Architecture::UNKNOWN {
            continue;
        }

        let tags = tags.clone();

        if !config.general.minimal {
            let file_attribute = macho.file.attribute();
            if tags.is_some() {
                for tag in tags.unwrap() {
                    attributes.push(Tag::new(tag).attribute());
                }
            }
            attributes.push(file_attribute);
        }

        let function_symbols = get_macho_function_symbols(&macho);

        // for (_, symbol) in &function_symbols {
        //     attributes.push(Attribute::Symbol(symbol.process().clone()));
        // }

        let mut mapped_file = macho.image(slice).unwrap_or_else(|error| {
            eprintln!("{}", error);
            process::exit(1)
        });

        let image = mapped_file.mmap().unwrap_or_else(|error| {
            eprintln!("{}", error);
            process::exit(1);
        });

        let executable_address_ranges = macho.executable_virtual_address_ranges(slice);

        let mut entrypoints = BTreeSet::<u64>::new();

        entrypoints.extend(macho.entrypoint_virtual_addresses(slice));

        let mut cfg = Graph::new(architecture, config.clone());

        let disassembler = match Disassembler::new(
            architecture,
            image,
            executable_address_ranges.clone(),
            config.clone(),
        ) {
            Ok(disassembler) => disassembler,
            Err(error) => {
                eprintln!("{}", error);
                process::exit(1);
            }
        };

        disassembler
            .disassemble_controlflow(entrypoints, &mut cfg)
            .unwrap_or_else(|error| {
                eprintln!("{}", error);
                process::exit(1);
            });

        process_output(output.clone(), &cfg, &attributes, &function_symbols);
    }
}

fn main() {
    let args = Args::parse();

    validate_args(&args);

    let mut config = Config::new();

    let _ = config.write_default();

    if args.config.is_some() {
        match Config::from_file(&args.config.unwrap().to_string()) {
            Ok(result) => {
                config = result;
            }
            Err(error) => {
                eprintln!("{}", error);
                process::exit(1);
            }
        }
    } else if let Err(error) = config.from_default() {
        eprintln!("failed to read default config: {}", error);
        process::exit(1);
    }

    if args.debug {
        config.general.debug = args.debug;
    }

    if args.threads.is_some() {
        config.general.threads = args.threads.unwrap();
    }

    if args.disable_heuristics {
        config.disable_heuristics();
    }

    if args.disable_hashing {
        config.disable_hashing();
    }

    if args.mmap_directory.is_some() {
        config.mmap.directory = args.mmap_directory.unwrap();
    }

    if args.enable_mmap_cache {
        config.mmap.cache.enabled = args.enable_mmap_cache;
    }

    if args.disable_disassembler_sweep {
        config.disassembler.sweep.enabled = false;
    }

    if args.minimal || config.general.minimal {
        config.enable_minimal();
    }

    if args.enable_instructions {
        config.instructions.enabled = args.enable_instructions;
    }

    if args.enable_block_instructions {
        config.blocks.instructions.enabled = args.enable_block_instructions;
    }

    if args.disable_function_blocks {
        config.functions.blocks.enabled = !args.disable_function_blocks;
    }

    Stderr::print_debug(
        config.clone(),
        "finished reading arguments and configuration",
    );

    ThreadPoolBuilder::new()
        .num_threads(config.general.threads)
        .build_global()
        .unwrap_or_else(|error| {
            eprintln!("{}", error);
            process::exit(1);
        });

    if args.architecture.is_none() {
        let format = Format::from_file(args.input.clone()).unwrap_or_else(|error| {
            eprintln!("{}", error);
            process::exit(1);
        });
        match format {
            Format::PE => {
                Stderr::print_debug(config.clone(), "processing pe");
                process_pe(args.input, config, args.tags, args.output);
            }
            Format::ELF => {
                Stderr::print_debug(config.clone(), "processing elf");
                process_elf(args.input, config, args.tags, args.output);
            }
            Format::MACHO => {
                Stderr::print_debug(config.clone(), "processing macho");
                process_macho(args.input, config, args.tags, args.output);
            }
            _ => {
                eprintln!("unable to identify file format");
                process::exit(1);
            }
        }
    } else {
        let architecture = args.architecture.unwrap();
        match architecture {
            Architecture::AMD64 | Architecture::I386 | Architecture::CIL => {
                Stderr::print_debug(config.clone(), "processing code");
                process_code(args.input, config, architecture, args.output);
            }
            _ => {
                eprintln!("unsupported architecture");
                process::exit(1);
            }
        }
    }

    process::exit(0);
}

```

`src/bin/blelfsym.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::process;
use std::fs::File;
use std::io::Write;
use binlex::io::Stdout;
use clap::Parser;
use binlex::AUTHOR;
use binlex::VERSION;
use binlex::formats::ELF;
use binlex::Config;
use binlex::controlflow::SymbolIoJson;
use binlex::io::Stdin;
use binlex::types::LZ4String;

#[derive(Parser, Debug)]
#[command(
    name = "blelfsym",
    version = VERSION,
    about =  format!("A Binlex ELF Symbol Parsing Tool\n\nVersion: {}", VERSION),
    after_help = format!("Author: {}", AUTHOR),
)]
struct Args {
    #[arg(short, long, required = true)]
    input: String,
    #[arg(short, long)]
    output: Option<String>,
}

fn main() -> pdb::Result<()> {
    let args = Args::parse();

    let config = Config::new();

    let elf = ELF::new(args.input, config).unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1);
    });

    let mut symbols = Vec::<LZ4String>::new();
    for (_, symbol) in elf.symbols() {
        let symbol = SymbolIoJson{
            type_: "symbol".to_string(),
            symbol_type: "function".to_string(),
            name: symbol.name,
            file_offset: None,
            relative_virtual_address: None,
            virtual_address: Some(symbol.address),
            slice: None,
        };
        if let Ok(string) = serde_json::to_string(&symbol) {
            symbols.push(LZ4String::new(&string));
        }
    }

    Stdin::passthrough();

    if args.output.is_none() {
        for symbol in symbols {
            Stdout::print(symbol);
        }
    } else {
        let mut file = match File::create(args.output.unwrap()) {
            Ok(file) => file,
            Err(error) => {
                eprintln!("{}", error);
                std::process::exit(1);
            }
        };
        for symbol in symbols {
            if let Err(error) = writeln!(file, "{}", symbol) {
                eprintln!("{}", error);
                std::process::exit(1);
            }
        }
    }

    process::exit(0);
}

```

`src/bin/blhash.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::process;
use clap::Parser;
use binlex::AUTHOR;
use binlex::VERSION;
use clap::ValueEnum;
use std::fmt;
use binlex::Config;
use binlex::formats::File;

#[derive(Parser, Debug)]
#[command(
    name = "blhash",
    version = VERSION,
    about =  format!("A Binlex File Hashing Tool\n\nVersion: {}", VERSION),
    after_help = format!("Author: {}", AUTHOR),
)]
struct Args {
    #[arg(short, long)]
    input: String,
    #[arg(long, value_enum, default_value = "tlsh")]
    hashtype: HashType,
}


#[derive(Debug, Clone, ValueEnum)]
pub enum HashType {
    Sha256,
    Tlsh,
}

impl fmt::Display for HashType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                HashType::Sha256 => "sha256",
                HashType::Tlsh => "tlsh",
            }
        )
    }
}

fn main () {

    let mut config = Config::new();

    config.formats.file.hashing.tlsh.enabled = true;
    config.formats.file.hashing.sha256.enabled = true;
    config.formats.file.hashing.minhash.enabled = true;

    let args = Args::parse();

    let mut file = File::new(args.input, config).unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1);
    });

    file.read().unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1);
    });

    let hash = match args.hashtype.to_string().as_str() {
        "sha256" => {
            file.sha256()
        },
        "tlsh" => {
            file.tlsh()
        },
        _ => { None }
    };

    if hash.is_some() {
        println!("{}", hash.unwrap());
    } else {
        eprintln!("unable to calculate hash");
        process::exit(1);
    }

    process::exit(0);
}

```

`src/bin/blimage.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use binlex::hashing::SHA256;
use binlex::io::Stdout;
use binlex::AUTHOR;
use binlex::VERSION;
use clap::Parser;
use clap::ValueEnum;
use std::collections::BTreeMap;
use std::fmt;
use std::fs::File;
use std::io::Read;
use std::process;

#[derive(Parser, Debug)]
#[command(
    name = "blimage",
    version = VERSION,
    about =  format!("A Binlex Binary Visualization Tool\n\nVersion: {}", VERSION),
    after_help = format!("Author: {}", AUTHOR),
)]
struct Args {
    #[arg(short, long)]
    input: String,
    #[arg(short, long)]
    output: Option<String>,
    #[arg(short, long, value_enum, default_value = "grayscale")]
    color: ColorMap,
    #[arg(short, long, default_value_t = 10)]
    shape_size: usize,
}

#[derive(Debug, Clone, ValueEnum)]
pub enum ColorMap {
    Grayscale,
    Heatmap,
    Bluegreen,
    Redblack,
}

impl fmt::Display for ColorMap {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                ColorMap::Grayscale => "grayscale",
                ColorMap::Heatmap => "heatmap",
                ColorMap::Bluegreen => "bluegreen",
                ColorMap::Redblack => "redblack",
            }
        )
    }
}

impl ColorMap {
    pub fn map_byte(&self, byte: u8) -> String {
        match self {
            ColorMap::Grayscale => format!("rgb({},{},{})", byte, byte, byte),
            ColorMap::Heatmap => {
                let r = (byte as f32 * 1.2).min(255.0) as u8;
                let g = 255 - byte;
                let b = (byte as f32 * 0.5).min(255.0) as u8;
                format!("rgb({},{},{})", r, g, b)
            }
            ColorMap::Bluegreen => {
                let r = (byte as f32 * 0.2).min(255.0) as u8;
                let g = (byte as f32 * 0.8).min(255.0) as u8;
                let b = 255 - byte;
                format!("rgb({},{},{})", r, g, b)
            }
            ColorMap::Redblack => {
                let r = byte;
                let g = 0;
                let b = 0;
                format!("rgb({},{},{})", r, g, b)
            }
        }
    }
}

fn main() {
    let args = Args::parse();

    let colormap = ColorMap::from_str(&args.color.to_string(), false).unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1);
    });

    if args.output.is_some() {
        let mut file = File::open(args.input).unwrap_or_else(|error| {
            eprintln!("{}", error);
            process::exit(1);
        });

        let mut byte_data = Vec::new();

        file.read_to_end(&mut byte_data).unwrap_or_else(|error| {
            eprintln!("{}", error);
            process::exit(1);
        });

        let mut metadata = BTreeMap::<String, String>::new();
        metadata.insert(
            "Hash".to_string(),
            "sha256:".to_string() + &SHA256::new(&byte_data).hexdigest().unwrap(),
        );

        let svg_content = bytes_to_svg(&byte_data, args.shape_size, &colormap, metadata);

        std::fs::write(args.output.unwrap(), svg_content).unwrap_or_else(|error| {
            eprintln!("{}", error);
            process::exit(1);
        });
    } else {
        let mut file = File::open(args.input).unwrap_or_else(|error| {
            eprintln!("{}", error);
            process::exit(1);
        });

        let mut byte_data = Vec::new();

        file.read_to_end(&mut byte_data).unwrap_or_else(|error| {
            eprintln!("{}", error);
            process::exit(1);
        });

        let mut metadata = BTreeMap::<String, String>::new();
        metadata.insert(
            "Hash".to_string(),
            "sha256:".to_string() + &SHA256::new(&byte_data).hexdigest().unwrap(),
        );

        let svg_content = bytes_to_svg(&byte_data, args.shape_size, &colormap, metadata);
        Stdout::print(svg_content);
    }

    process::exit(0);
}

fn map_to_svg_metadata(metadata: BTreeMap<String, String>) -> String {
    let mut svg = String::new();
    for (key, value) in metadata {
        svg.push_str(r#"<metadata>\n"#);
        svg.push_str(&format!(r#"<{}>{}</{}>\n"#, key, value, key));
        svg.push_str(r#"</metadata>\n"#);
    }
    svg
}

/// Converts byte data into an SVG representation with a given colormap
///
/// # Arguments
///
/// * `byte_data` - A slice of bytes to visualize.
/// * `shape_size` - The size of each rectangle in the grid (in pixels).
/// * `colormap` - The colormap to use for color mapping.
fn bytes_to_svg(
    byte_data: &[u8],
    shape_size: usize,
    colormap: &ColorMap,
    metadata: BTreeMap<String, String>,
) -> String {
    let num_bytes = byte_data.len();
    let grid_size = (num_bytes as f64).sqrt().ceil() as usize;

    let mut svg = String::new();

    // SVG Header
    svg.push_str(&format!(
        r#"<svg xmlns="http://www.w3.org/2000/svg" width="{}" height="{}" viewBox="0 0 {} {}">\n"#,
        grid_size * shape_size,
        grid_size * shape_size,
        grid_size * shape_size,
        grid_size * shape_size
    ));

    svg.push_str(&map_to_svg_metadata(metadata));

    // Add rectangles for each byte
    for (i, &byte) in byte_data.iter().enumerate() {
        let row = i / grid_size;
        let col = i % grid_size;

        let x = col * shape_size;
        let y = row * shape_size;

        let color = colormap.map_byte(byte);

        svg.push_str(&format!(
            r#"<rect x="{}" y="{}" width="{}" height="{}" fill="{}" />\n"#,
            x, y, shape_size, shape_size, color
        ));
    }

    // SVG Footer
    svg.push_str("</svg>\n");

    svg
}

```

`src/bin/blmachosym.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::process;
use binlex::formats::MACHO;
use binlex::io::Stdout;
use clap::Parser;
use std::fs::File;
use std::io::Write;
use binlex::AUTHOR;
use binlex::VERSION;
use binlex::Config;
use binlex::controlflow::SymbolIoJson;
use binlex::io::Stdin;
use binlex::types::LZ4String;

#[derive(Parser, Debug)]
#[command(
    name = "blmachosym",
    version = VERSION,
    about =  format!("A Binlex MachO Symbol Parsing Tool\n\nVersion: {}", VERSION),
    after_help = format!("Author: {}", AUTHOR),
)]
struct Args {
    #[arg(short, long, required = true)]
    input: String,
    #[arg(short, long)]
    output: Option<String>,
}

fn main() -> pdb::Result<()> {
    let args = Args::parse();

    let config = Config::new();

    let macho = MACHO::new(args.input, config).unwrap_or_else(|error| {
        eprintln!("{}", error);
        process::exit(1);
    });

    let mut symbols = Vec::<LZ4String>::new();
    for slice in 0..macho.number_of_slices() {
        for (_, symbol) in macho.symbols(slice) {
            let symbol = SymbolIoJson{
                type_: "symbol".to_string(),
                symbol_type: "function".to_string(),
                name: symbol.name,
                file_offset: None,
                relative_virtual_address: None,
                virtual_address: Some(symbol.address),
                slice: Some(slice),
            };
            if let Ok(string) = serde_json::to_string(&symbol) {
                symbols.push(LZ4String::new(&string));
            }
        }
    }

    Stdin::passthrough();

    if args.output.is_none() {
        for symbol in symbols {
            Stdout::print(symbol);
        }
    } else {
        let mut file = match File::create(args.output.unwrap()) {
            Ok(file) => file,
            Err(error) => {
                eprintln!("{}", error);
                std::process::exit(1);
            }
        };
        for symbol in symbols {
            if let Err(error) = writeln!(file, "{}", symbol) {
                eprintln!("{}", error);
                std::process::exit(1);
            }
        }
    }

    process::exit(0);
}

```

`src/bin/blpdb.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use binlex::controlflow::Symbol;
use binlex::controlflow::SymbolIoJson;
use binlex::io::Stdin;
use binlex::io::Stdout;
use binlex::AUTHOR;
use binlex::VERSION;
use clap::Parser;
use pdb::FallibleIterator;
use std::fs::File;
use std::process;

#[derive(Parser, Debug)]
#[command(
    name = "blpdb",
    version = VERSION,
    about =  format!("A Binlex PDB Parsing Tool\n\nVersion: {}", VERSION),
    after_help = format!("Author: {}", AUTHOR),
)]
struct Cli {
    #[arg(short, long, required = true)]
    input: String,
    #[arg(short, long)]
    output: Option<String>,
    #[arg(long, default_value_t = false)]
    demangle_msvc_names: bool,
}

fn main() -> pdb::Result<()> {
    let cli = Cli::parse();

    let file = File::open(cli.input)?;
    let mut pdb = pdb::PDB::open(file)?;

    let symbol_table = pdb.global_symbols()?;
    let address_map = pdb.address_map()?;

    let mut results = Vec::<SymbolIoJson>::new();
    let mut symbols = symbol_table.iter();
    while let Some(symbol) = symbols.next()? {
        match symbol.parse() {
            Ok(pdb::SymbolData::Public(data)) if data.function => {
                let rva = data.offset.to_rva(&address_map).unwrap_or_default();
                let mut name = data.name.to_string().into_owned();
                if cli.demangle_msvc_names {
                    name = Symbol::demangle_msvc_name(&name);
                }
                results.push(SymbolIoJson {
                    type_: "symbol".to_string(),
                    symbol_type: "function".to_string(),
                    name,
                    file_offset: None,
                    relative_virtual_address: Some(rva.0 as u64),
                    virtual_address: None,
                    slice: None,
                });
            }
            _ => {}
        }
    }

    Stdin::passthrough();

    for result in results {
        if let Ok(json_string) = serde_json::to_string(&result) {
            Stdout::print(json_string);
        }
    }

    process::exit(0);
}

```

`src/bin/blrizin.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use clap::Parser;
use serde_json::Value;
use std::fs::File;
use std::io::Error;
use std::io::Write;
use std::process;
use binlex::types::LZ4String;
use binlex::AUTHOR;
use binlex::VERSION;
use binlex::io::Stdout;
use binlex::io::JSON;
use binlex::controlflow::SymbolIoJson;

#[derive(Parser, Debug)]
#[command(
    name = "blrizin",
    version = VERSION,
    about =  format!("A Binlex Rizin Tool\n\nVersion: {}", VERSION),
    after_help = format!("Author: {}", AUTHOR),
)]
struct Args {
    #[arg(short, long)]
    input: Option<String>,
    #[arg(short, long)]
    output: Option<String>,
}

fn process_value(parsed: &Value) -> Result<LZ4String, Error> {
    let virtual_address = parsed.get("offset").unwrap().as_u64().unwrap();
    let function_name = parsed.get("name").unwrap().as_str().unwrap().to_string();
    let symbol = SymbolIoJson {
        type_: "symbol".to_string(),
        symbol_type: "function".to_string(),
        name: function_name,
        file_offset: None,
        relative_virtual_address: None,
        virtual_address: Some(virtual_address),
        slice: None,
    };
    let result = serde_json::to_string(&symbol)?;
    Ok(LZ4String::new(&result))
}

fn main() {
    let args = Args::parse();
    let json = JSON::from_file_or_stdin_as_array(args.input, |value| {
        let object = match value.as_object() {
            Some(object) => object,
            None => return false,
        };
        let virtual_address = object.get("offset").and_then(|v| v.as_u64());
        let function_name = object.get("name").and_then(|v| v.as_str()).map(String::from);

        if virtual_address.is_none() || function_name.is_none() {
            return false;
        }
        true
    });

    if args.output.is_none() && json.is_ok(){
        for value in json.unwrap().values() {
            if let Ok(string) = process_value(value) {
                Stdout::print(string);
            }
        }
    } else if args.output.is_some() && json.is_ok() {
        let mut file = match File::create(args.output.unwrap()) {
            Ok(file) => file,
            Err(error) => {
                eprintln!("{}", error);
                std::process::exit(1);
            }
        };
        for value in json.unwrap().values() {
            if let Ok(string) = process_value(value) {
                if let Err(error) = writeln!(file, "{}", string) {
                    eprintln!("{}", error);
                    std::process::exit(1);
                }
            }
        }
    }

    process::exit(0);

}

```

`src/bin/blyara.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use clap::Parser;
use serde_json::{Map, Value};
use std::fs::File;
use std::io::{self, BufRead, Write};
use std::process;
use binlex::AUTHOR;
use binlex::VERSION;
use binlex::io::Stdout;

#[derive(Parser, Debug)]
#[command(
    name = "blyara",
    version = VERSION,
    about = format!("A Binlex YARA Generation Tool\n\nVersion: {}", VERSION),
    after_help = format!("Author: {}", AUTHOR),
)]
struct Cli {
    #[arg(short, long)]
    input: Option<String>,
    #[arg(
        short,
        long,
        num_args(2),
        value_names = ["KEY", "VALUE"],
        action = clap::ArgAction::Append
    )]
    metadata: Vec<String>,
    #[arg(short, long, required = true)]
    name: String,
    #[arg(short, long, default_value_t = 1)]
    count: usize,
    #[arg(short, long)]
    output: Option<String>,
}

fn main() {
    let cli = Cli::parse();

    let metadata_map = collect_metadata(&cli.metadata);
    let pattern_map = collect_patterns(&cli.input);

    if pattern_map.is_empty() {
        eprintln!("no signature patterns collected.");
        process::exit(1);
    }

    let signature = generate_signature(&cli.name, &metadata_map, &pattern_map, cli.count);

    if let Some(output_file) = &cli.output {
        if let Err(e) = write_to_file(output_file, &signature) {
            eprintln!("failed to write yara rule to output file: {}", e);
            process::exit(1);
        }
    } else {
        Stdout::print(signature);
    }
}

fn collect_metadata(metadata_vec: &[String]) -> Map<String, Value> {
    let mut metadata_map = Map::new();
    for chunk in metadata_vec.chunks(2) {
        if let [key, value] = chunk {
            metadata_map.insert(key.clone(), Value::String(value.clone()));
        }
    }
    metadata_map
}

fn collect_patterns(input_file: &Option<String>) -> Map<String, Value> {
    let reader: Box<dyn BufRead> = match input_file {
        Some(file_name) => {
            let file = File::open(file_name).unwrap_or_else(|_| {
                eprintln!("failed to open input file: {}", file_name);
                process::exit(1);
            });
            Box::new(io::BufReader::new(file))
        }
        None => Box::new(io::BufReader::new(io::stdin())),
    };

    let mut pattern_map = Map::new();
    for (count, line) in reader.lines().enumerate() {
        match line {
            Ok(l) => {
                pattern_map.insert(
                    format!("trait_{}", count),
                    Value::String(format!("{{{}}}", l)),
                );
            }
            Err(e) => {
                eprintln!("failed to read line: {}", e);
                process::exit(1);
            }
        }
    }
    pattern_map
}

fn generate_signature(
    name: &str,
    metadata_map: &Map<String, Value>,
    pattern_map: &Map<String, Value>,
    count: usize,
) -> String {
    let mut signature = format!("rule {} {{\n", name);

    if !metadata_map.is_empty() {
        signature.push_str("    meta:\n");
        for (key, value) in metadata_map {
            signature.push_str(&format!("        {} = {}\n", key, value));
        }
    }

    signature.push_str("    strings:\n");
    for (key, value) in pattern_map {
        signature.push_str(&format!(
            "        ${} = {}\n",
            key,
            value.as_str().unwrap_or("")
        ));
    }

    signature.push_str("    condition:\n");
    signature.push_str(&format!("        {} of them\n", count));
    signature.push_str("}\n");

    signature
}

fn write_to_file(output_file: &str, content: &str) -> io::Result<()> {
    let mut file = File::create(output_file)?;
    file.write_all(content.as_bytes())
}

```

`src/binary.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::collections::HashMap;
use std::fmt::Write;

/// A struct representing a binary, used for various binary-related utilities.
pub struct Binary;

impl Binary {
    /// Calculates the entropy of the given byte slice.
    ///
    /// This method computes the Shannon entropy, which is a measure of the randomness
    /// or unpredictability of the data. The entropy value is returned as an `Option<f64>`.
    ///
    /// # Arguments
    ///
    /// * `bytes` - A reference to a `Vec<u8>` containing the binary data.
    ///
    /// # Returns
    ///
    /// An `Option<f64>`, where `Some(f64)` is the calculated entropy, or `None` if the data
    /// is empty.
    pub fn entropy(bytes: &Vec<u8>) -> Option<f64> {
        let mut frequency: HashMap<u8, usize> = HashMap::new();
        for &byte in bytes {
            *frequency.entry(byte).or_insert(0) += 1;
        }

        let data_len = bytes.len() as f64;
        if data_len == 0.0 {
            return None;
        }

        let entropy = frequency.values().fold(0.0, |entropy, &count| {
            let probability = count as f64 / data_len;
            entropy - probability * probability.log2()
        });

        Some(entropy)
    }

    /// Converts a byte slice to a hexadecimal string representation.
    ///
    /// This method takes a slice of bytes and returns a `String` where each byte is
    /// represented as a 2-character hexadecimal string.
    ///
    /// # Arguments
    ///
    /// * `data` - A reference to a byte slice (`&[u8]`).
    ///
    /// # Returns
    ///
    /// A `String` containing the hexadecimal representation of the byte data.
    pub fn to_hex(data: &[u8]) -> String {
        let mut result = String::with_capacity(data.len() * 2);
        for byte in data {
            write!(result, "{:02x}", byte).unwrap();
        }
        result
    }

    pub fn from_hex(hex: &str) -> Result<Vec<u8>, String> {
        if hex.len() % 2 != 0 {
            return Err("hex string has an odd length".to_string());
        }

        hex.as_bytes()
            .chunks(2)
            .map(|chunk| {
                let hex_str =
                    std::str::from_utf8(chunk).map_err(|_| "invalid UTF-8 in hex string")?;
                u8::from_str_radix(hex_str, 16).map_err(|_| format!("invalid hex: {}", hex_str))
            })
            .collect()
    }

    /// Creates a human-readable hex dump of the provided byte data.
    ///
    /// This method formats the binary data into a string representation with both
    /// hexadecimal values and ASCII characters, often used for debugging or inspecting
    /// binary content.
    ///
    /// # Arguments
    ///
    /// * `data` - A reference to a byte slice (`&[u8]`).
    /// * `address` - The starting memory address (in hexadecimal) to be used in the dump.
    ///
    /// # Returns
    ///
    /// A `String` formatted as a hex dump with both hexadecimal and ASCII views of the data.
    #[allow(dead_code)]
    pub fn hexdump(data: &[u8], address: u64) -> String {
        const BYTES_PER_LINE: usize = 16;
        let mut result = String::new();
        for (i, chunk) in data.chunks(BYTES_PER_LINE).enumerate() {
            let current_address = address as usize + i * BYTES_PER_LINE;
            let hex_repr = format!("{:08x}: ", current_address);
            result.push_str(&hex_repr);
            let hex_values = {
                let mut s = String::new();
                for byte in chunk {
                    let _ = write!(s, "{:02x} ", byte);
                }
                s
            };
            //let hex_values: String = chunk.iter().map(|byte| format!("{:02x} ", byte)).collect();
            result.push_str(&hex_values);
            let padding = "   ".repeat(BYTES_PER_LINE - chunk.len());
            result.push_str(&padding);
            let ascii_values: String = chunk
                .iter()
                .map(|&byte| {
                    if byte.is_ascii_graphic() || byte == b' ' {
                        byte as char
                    } else {
                        '.'
                    }
                })
                .collect();
            result.push('|');
            result.push_str(&ascii_values);
            result.push_str("|\n");
        }
        result
    }
}

```

`src/bindings/python/Cargo.toml`:

```toml
[package]
name = "binlex-python"
version = "2.0.0"
edition = "2021"

[dependencies]
pyo3 = { version = "0.22.6", features = ["extension-module"] }
memmap2 = "0.9.5"
rayon = "1.10.0"

[lib]
name = "binlex"
crate-type = ["cdylib"]

[dependencies.binlex]
path = "../../../"

```

`src/bindings/python/project/binlex/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex import Config
from binlex_bindings.binlex import Architecture
from binlex_bindings.binlex.binary import Binary

```

`src/bindings/python/project/binlex/_global/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex._global import *

```

`src/bindings/python/project/binlex/binary/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex.binary import *

```

`src/bindings/python/project/binlex/controlflow/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex.controlflow import *

```

`src/bindings/python/project/binlex/disassemblers/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


```

`src/bindings/python/project/binlex/disassemblers/capstone/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex.disassemblers.capstone import Disassembler


```

`src/bindings/python/project/binlex/disassemblers/custom/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


```

`src/bindings/python/project/binlex/disassemblers/custom/cil/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex.disassemblers.custom.cil import Disassembler

```

`src/bindings/python/project/binlex/disassemblers/ida/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import os
import re
import tempfile
import idapro
import idc
import ida_ida
import ida_nalt
import idaapi
import idautils
import ida_bytes
import ida_ua

from binlex_bindings.binlex.controlflow import (
	Graph,
)

from binlex_bindings.binlex.disassemblers.capstone import Disassembler as CapstoneDisassembler

from binlex_bindings.binlex.types import MemoryMappedFile

from binlex_bindings.binlex import (
	Architecture,
	Config,
)

from typing import List

class IDACommon():

	@staticmethod
	def architecture() -> Architecture:
		if ida_ida.inf_get_procname() == 'metapc':
			if ida_ida.inf_is_32bit_exactly():
				return Architecture.from_str('i386')
			return Architecture.from_str('amd64')

class IDAInstruction(IDACommon):
	def __init__(self, address: int):
		instruction = ida_ua.insn_t()
		ida_ua.decode_insn(instruction, address)
		self.instruction = instruction

	def address(self) -> int:
		return self.instruction.ea

	def size(self) -> int:
		return self.instruction.size

class IDABlock(IDACommon):
	def __init__(self, block):
		self.block = block

	def address(self) -> int:
		return self.block.start_ea

	def end(self) -> int:
		return self.block.end_ea

	def instructions(self) -> List[IDAInstruction]:
		instructions = []
		address = self.address()
		while address < self.end():
			instruction = IDAInstruction(address)
			instructions.append(instruction)
			address += instruction.size()
		return instructions

	def to(self) -> set:
		return set([self.address() for bb in self.block.succs()])

class IDAFunction(IDACommon):
	def __init__(self, address: int):
		self.function = idaapi.get_func(address)

	def address(self):
		return self.function.start_ea

	def blocks(self):
		return [IDABlock(block) for block in idaapi.FlowChart(self.function)]

	def name(self):
		return idc.get_func_name(self.address)

class IDA():
	def __init__(self):
		pass

	def processor(self) -> str | None:
		return ida_ida.inf_get_procname()

	def is_32bit(self) -> bool:
		return ida_ida.inf_is_32bit_exactly()

	def architecture(self) -> Architecture | None:
		if self.processor() == 'metapc':
			if self.is_32bit():
				return Architecture.from_str('i386')
			return Architecture.from_str('amd64')

	def sha256(self):
		return ida_nalt.retrieve_input_file_sha256().hex()

	@staticmethod
	def attribute_symbol(address: int):
		attribute = {}
		attribute['type'] = 'symbol'
		attribute['symbol_type'] = 'function'
		attribute['file_offset'] = None
		attribute['relative_virtual_address'] = None
		attribute['virtual_address'] = address
		attribute['name'] = idc.get_func_name(address)
		attribute['slice'] = None
		return attribute

	def functions(self) -> list:
		return [IDAFunction(address) for address in idautils.Functions()]

	def is_function_address(self, address: int) -> bool:
		function = idaapi.get_func(address)
		if function is None: return False
		return function.start_ea == address

	def attributes(self, address: int) -> List[dict]:
		attributes = [self.attribute_file()]
		if self.is_function_address(address):
			attributes.append(self.attribute_symbol(address))
		return attributes

	def attribute_file(self):
		return {
            'type': 'file',
            'sha256': self.sha256(),
            'tlsh': None,
            'size': None,
            'entropy': None,
        }

	def open_database(self, path: str, run_auto_analysis: bool = True):
		idapro.open_database(path, run_auto_analysis=run_auto_analysis)

	def close_database(self):
		idapro.close_database()

	def image(self):
		directory = os.path.join(tempfile.gettempdir(), 'binlex')
		if not os.path.exists(directory): os.makedirs(directory)
		file_path = os.path.join(directory, IDA().sha256())
		mapped_file = MemoryMappedFile(file_path, False)
		for segment in idautils.Segments():
			start = idc.get_segm_start(segment)
			end = idc.get_segm_end(segment)
			data = ida_bytes.get_bytes(start, end - start)
			if data is None: continue
			if mapped_file.size() < start:
				mapped_file.seek_to_end()
				mapped_file.write_padding(start - mapped_file.size())
			mapped_file.seek_to_end()
			mapped_file.write(data)
		return mapped_file

class Disassembler():
	def __init__(self, architecture: Architecture, image: bytes, executable_virtual_address_ranges: dict, config: Config):
		self.architecture = architecture
		self.executable_virtual_address_ranges = executable_virtual_address_ranges
		self.config = config
		self.image = image
		self.disassembler = CapstoneDisassembler(
			self.architecture,
			self.image,
			self.executable_virtual_address_ranges,
			self.config
		)

	def disassemble_instruction(self, instruction: IDAInstruction, cfg: Graph):
		self.disassembler.disassemble_instruction(instruction.address(), cfg)

	def disassemble_block(self, block: IDABlock, cfg: Graph):
		for instruction in block.instructions():
			self.disassemble_instruction(instruction, cfg)
			if IDA().is_function_address(instruction.address()):
				cfg.set_function(instruction.address())
			if block.address() == instruction.address():
				cfg.set_block(instruction.address())
			if idc.prev_head(block.end()) == instruction.address():
				cfg.extend_instruction_edges(instruction.address(), block.to())

	def disassemble_function(self, function: IDAFunction, cfg: Graph):
		for block in function.blocks():
			self.disassemble_block(block, cfg)

	def disassemble_controlflow(self, cfg: Graph):
		for function in IDA().functions():
			self.disassemble_function(function, cfg)

```

`src/bindings/python/project/binlex/formats/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex.formats import *

```

`src/bindings/python/project/binlex/genetics/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex.genetics import *

```

`src/bindings/python/project/binlex/hashing/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex.hashing import *

```

`src/bindings/python/project/binlex/imaging/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex.imaging import *

```

`src/bindings/python/project/binlex/types/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from binlex_bindings.binlex.types import *

```

`src/bindings/python/project/binlex_bindings/__init__.py`:

```py
# MIT License
#
# Copyright (c) [2025] [c3rb3ru5d3d53c]
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


```

`src/bindings/python/pyproject.toml`:

```toml
[project]
name = "binlex"
version = "2.0.0"
authors = [{ name = "c3rb3ru5d3d53c", email = "c3rb3ru5d3d53c@gmail.com" }]
description = "A Binary Genetic Traits Lexer Framework"
keywords = ["malware", "genomics", "binary similarity", "cybersecurity", "research"]
classifiers = [
    "Programming Language :: Python",
    "Programming Language :: Rust",
    "Topic :: Security",
    "License :: OSI Approved :: MIT License"
]
requires-python = ">=3.9"

[build-system]
requires = ["maturin>=1.0,<2.0"]
build-backend = "maturin"

[tool.maturin]
python-source = "project"
module-name = "binlex_bindings.binlex"
python-packages = ["binlex", "binlex_bindings"]

```

`src/bindings/python/src/binary.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use pyo3::prelude::*;

use binlex::binary::Binary as InnerBinary;

#[pyclass]
pub struct Binary;

#[pymethods]
impl Binary {
    #[staticmethod]
    pub fn entropy(bytes: Vec<u8>) -> Option<f64> {
        InnerBinary::entropy(&bytes)
    }
    #[staticmethod]
    pub fn to_hex(bytes: Vec<u8>) -> String {
        InnerBinary::to_hex(&bytes)
    }
    #[staticmethod]
    pub fn hexdump(bytes: Vec<u8>, address: u64) -> String {
        InnerBinary::hexdump(&bytes, address)
    }
}

#[pymodule]
#[pyo3(name = "binary")]
pub fn binary_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Binary>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.binary", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.binary")?;
    Ok(())
}

```

`src/bindings/python/src/controlflow/block.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::graph::Graph;
use crate::controlflow::Instruction;
use crate::genetics::Chromosome;
use crate::genetics::ChromosomeSimilarity;
use crate::Architecture;
use crate::Config;
use binlex::controlflow::Block as InnerBlock;
use binlex::controlflow::BlockJsonDeserializer as InnerBlockJsonDeserializer;
use binlex::controlflow::Graph as InnerGraph;
use binlex::Architecture as InnerArchitecture;
use binlex::Binary as InnerBinary;
use pyo3::prelude::*;
use pyo3::types::PyBytes;
use pyo3::types::PyList;
use pyo3::Py;
use rayon::prelude::*;
use rayon::ThreadPoolBuilder;
use std::collections::{BTreeMap, BTreeSet};
use std::sync::Arc;
use std::sync::Mutex;

#[pyclass]
pub struct BlockJsonDeserializer {
    pub inner: Arc<Mutex<InnerBlockJsonDeserializer>>,
}

#[pymethods]
impl BlockJsonDeserializer {
    #[new]
    #[pyo3(text_signature = "(string, config)")]
    pub fn new(py: Python, string: String, config: Py<Config>) -> PyResult<Self> {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerBlockJsonDeserializer::new(string, inner_config)?;
        Ok(Self {
            inner: Arc::new(Mutex::new(inner)),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn functions(&self) -> BTreeMap<u64, u64> {
        self.inner.lock().unwrap().functions()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn architecture(&self) -> PyResult<Architecture> {
        let inner = InnerArchitecture::from_string(&self.inner.lock().unwrap().json.architecture)
            .map_err(pyo3::exceptions::PyRuntimeError::new_err)?;
        Ok(Architecture { inner })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn bytes(&self, py: Python) -> PyResult<Py<PyBytes>> {
        let bytes = InnerBinary::from_hex(&self.inner.lock().unwrap().json.bytes)
            .map_err(pyo3::exceptions::PyRuntimeError::new_err)?;
        let result = PyBytes::new_bound(py, &bytes);
        Ok(result.into())
    }

    #[pyo3(text_signature = "($self, rhs)")]
    pub fn compare(
        &self,
        py: Python,
        rhs: Py<BlockJsonDeserializer>,
    ) -> Option<ChromosomeSimilarity> {
        let binding = rhs.borrow(py);
        let rhs_inner = binding.inner.lock().unwrap();
        let similarity = self.inner.lock().unwrap().compare(&rhs_inner);
        similarity.as_ref()?;
        Some(ChromosomeSimilarity {
            inner: Arc::new(Mutex::new(similarity.unwrap())),
        })
    }

    #[pyo3(text_signature = "($self, rhs_blocks)")]
    pub fn compare_many(
        &self,
        py: Python,
        rhs_blocks: Py<PyList>,
    ) -> PyResult<BTreeMap<u64, ChromosomeSimilarity>> {
        let block = InnerBlockJsonDeserializer::new(
            self.json()?,
            self.inner.lock().unwrap().config.clone(),
        )?;

        let inner_config = self.inner.lock().unwrap().config.clone();

        let mut tasks = Vec::<InnerBlockJsonDeserializer>::new();

        let list = rhs_blocks.bind(py);

        let items: Vec<Py<PyAny>> = list.iter().map(|item| item.into()).collect();

        for item in items {
            let py_item = item.bind(py);
            if !py_item.is_instance_of::<BlockJsonDeserializer>() {
                return Err(pyo3::exceptions::PyTypeError::new_err(
                    "all items in rhs_blocks must be instances of BlockJsonDeserializer",
                ));
            }
            let rhs: Option<Py<BlockJsonDeserializer>> = py_item.extract().ok();
            if rhs.is_none() {
                continue;
            }
            let rhs_binding_0 = rhs.unwrap();
            let rhs_binding_1 = rhs_binding_0.borrow(py);
            let a = rhs_binding_1.inner.lock().unwrap().clone();
            tasks.push(a);
        }

        let pool = ThreadPoolBuilder::new()
            .num_threads(inner_config.general.threads)
            .build()
            .map_err(|err| pyo3::exceptions::PyRuntimeError::new_err(format!("{}", err)))?;

        let results: BTreeMap<u64, ChromosomeSimilarity> = pool.install(|| {
            tasks
                .par_iter()
                .filter_map(|rhs_block| {
                    block.compare(rhs_block).map(|similarity| {
                        (
                            rhs_block.address(),
                            ChromosomeSimilarity {
                                inner: Arc::new(Mutex::new(similarity)),
                            },
                        )
                    })
                })
                .collect()
        });
        Ok(results)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn address(&self) -> u64 {
        self.inner.lock().unwrap().address()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn minhash(&self) -> Option<String> {
        self.inner.lock().unwrap().minhash()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlsh(&self) -> Option<String> {
        self.inner.lock().unwrap().tlsh()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn sha256(&self) -> Option<String> {
        self.inner.lock().unwrap().sha256()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn edges(&self) -> usize {
        self.inner.lock().unwrap().edges()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn blocks(&self) -> BTreeSet<u64> {
        self.inner.lock().unwrap().blocks()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn to(&self) -> BTreeSet<u64> {
        self.inner.lock().unwrap().to()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn conditional(&self) -> bool {
        self.inner.lock().unwrap().conditional()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn entropy(&self) -> Option<f64> {
        self.inner.lock().unwrap().entropy()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn next(&self) -> Option<u64> {
        self.inner.lock().unwrap().next()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn size(&self) -> usize {
        self.inner.lock().unwrap().size()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn number_of_instructions(&self) -> usize {
        self.inner.lock().unwrap().number_of_instructions()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn chromosome(&self) -> Chromosome {
        let inner_chromosome = self.inner.lock().unwrap().chromosome();
        Chromosome {
            inner: Arc::new(Mutex::new(inner_chromosome)),
        }
    }

    #[pyo3(text_signature = "($self)")]
    pub fn to_dict(&self, py: Python) -> PyResult<Py<PyAny>> {
        let json_str = self.json()?;
        let json_module = py.import_bound("json")?;
        let py_dict = json_module.call_method1("loads", (json_str,))?;
        Ok(py_dict.into())
    }

    #[pyo3(text_signature = "($self)")]
    pub fn json(&self) -> PyResult<String> {
        self.inner
            .lock()
            .unwrap()
            .json()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn print(&self) {
        self.inner.lock().unwrap().print()
    }

    pub fn __str__(&self) -> PyResult<String> {
        self.json()
    }
}

/// A class representing a control flow block in the binary analysis.
#[pyclass]
pub struct Block {
    /// The starting address of the block.
    pub address: u64,
    /// A reference to the control flow graph associated with the block.
    pub cfg: Py<Graph>,
    pub inner_block_cache: Arc<Mutex<Option<InnerBlock<'static>>>>,
}

impl Block {
    fn with_inner_block<F, R>(&self, py: Python, f: F) -> PyResult<R>
    where
        F: FnOnce(&InnerBlock<'static>) -> PyResult<R>,
    {
        let mut cache = self.inner_block_cache.lock().unwrap();

        if cache.is_none() {
            let binding = self.cfg.borrow(py);
            let inner = binding.inner.lock().unwrap();

            let inner_ref: &'static _ = unsafe { std::mem::transmute(&*inner) };
            let inner_block = InnerBlock::new(self.address, inner_ref)?;
            *cache = Some(inner_block);
        }

        f(cache.as_ref().unwrap())
    }
}

#[pymethods]
impl Block {
    #[new]
    #[pyo3(text_signature = "(address, cfg)")]
    /// Creates a new `Block` instance.
    ///
    /// # Arguments
    /// - `address`: The starting address of the block.
    /// - `cfg`: The control flow graph associated with the block.
    ///
    /// # Returns
    /// A new `Block` object.
    pub fn new(address: u64, cfg: Py<Graph>) -> PyResult<Self> {
        Ok(Self {
            address,
            cfg,
            inner_block_cache: Arc::new(Mutex::new(None)),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn address(&self) -> u64 {
        self.address
    }

    #[pyo3(text_signature = "($self)")]
    pub fn architecture(&self, py: Python) -> PyResult<Architecture> {
        self.with_inner_block(py, |block| {
            Ok(Architecture {
                inner: block.architecture(),
            })
        })
    }

    #[pyo3(text_signature = "($self, rhs)")]
    /// Compares this block with another returning the similarity.
    ///
    /// # Returns
    ///
    /// Returns an `Option<ChromosomeSimilarity>` reprenting the similarity between this block and another.
    pub fn compare(&self, py: Python, rhs: Py<Block>) -> PyResult<Option<ChromosomeSimilarity>> {
        self.with_inner_block(py, |block| {
            let rhs_address = rhs.borrow(py).address;
            let rhs_binding_0 = rhs.borrow(py);
            let rhs_binding_1 = rhs_binding_0.cfg.borrow(py);
            let rhs_cfg = rhs_binding_1.inner.lock().unwrap();
            let rhs_inner = InnerBlock::new(rhs_address, &rhs_cfg).expect("rhs block is invalid");
            let inner = block.compare(&rhs_inner);
            if inner.is_none() {
                return Ok(None);
            }
            let similarity = ChromosomeSimilarity {
                inner: Arc::new(Mutex::new(inner.unwrap())),
            };
            Ok(Some(similarity))
        })
    }

    #[pyo3(text_signature = "($self, rhs_blocks)")]
    /// Compares this block with many othe rblocks returning the similarity.
    ///
    /// # Returns
    ///
    /// Returns an `PyResult<BTreeMap<u64, ChromosomeSimilarity>>` reprenting the similarity between this block and many others.
    pub fn compare_many(
        &self,
        py: Python,
        rhs_blocks: Py<PyList>,
    ) -> PyResult<BTreeMap<u64, ChromosomeSimilarity>> {
        self.with_inner_block(py, |block| {
            let mut tasks = Vec::<(u64, Arc<Mutex<InnerGraph>>)>::new();

            let list = rhs_blocks.bind(py);

            let items: Vec<Py<PyAny>> = list.iter().map(|item| item.into()).collect();

            for item in items {
                let py_item = item.bind(py);
                if !py_item.is_instance_of::<Block>() {
                    return Err(pyo3::exceptions::PyTypeError::new_err(
                        "all items in rhs_blocks must be instances of Block",
                    ));
                }
                let rhs: Option<Py<Block>> = py_item.extract().ok();
                if rhs.is_none() {
                    continue;
                }
                let rhs_binding_0 = rhs.unwrap();
                let rhs_binding_1 = rhs_binding_0.borrow(py);
                let address = rhs_binding_1.address();
                let rhs_cfg = Arc::clone(&rhs_binding_1.cfg.borrow(py).inner);
                tasks.push((address, rhs_cfg));
            }

            let pool = ThreadPoolBuilder::new()
                .num_threads(block.cfg.config.general.threads)
                .build()
                .map_err(|err| pyo3::exceptions::PyRuntimeError::new_err(format!("{}", err)))?;

            let results: BTreeMap<u64, ChromosomeSimilarity> = pool.install(|| {
                tasks
                    .par_iter()
                    .filter_map(|(address, inner_cfg)| {
                        let c = inner_cfg.lock().unwrap();
                        let rhs_block = InnerBlock::new(*address, &c).ok()?;
                        block.compare(&rhs_block).map(|similarity| {
                            (
                                *address,
                                ChromosomeSimilarity {
                                    inner: Arc::new(Mutex::new(similarity)),
                                },
                            )
                        })
                    })
                    .collect()
            });
            Ok(results)
        })
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the chromosome associated with this block.
    ///
    /// # Returns
    /// - `PyResult<Option<Chromosome>>`: The chromosome associated with this block.
    pub fn chromosome(&self, py: Python) -> PyResult<Option<Chromosome>> {
        self.with_inner_block(py, |block| {
            let inner_config = self.cfg.borrow(py).inner.lock().unwrap().config.clone();
            let config = Py::new(
                py,
                Config {
                    inner: Arc::new(Mutex::new(inner_config)),
                },
            )
            .unwrap();
            let pattern = block.pattern();
            let chromosome = Chromosome::new(py, pattern, config).ok();
            Ok(chromosome)
        })
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the instructions associated with this block.
    ///
    /// # Returns
    /// - `PyResult<Vec<Instruction>>`: The instructions associated with this block
    pub fn instructions(&self, py: Python) -> PyResult<Vec<Instruction>> {
        self.with_inner_block(py, |block| {
            let mut result = Vec::<Instruction>::new();
            for instruction in &block.instructions() {
                let instruction = Instruction::new(instruction.address, self.cfg.clone_ref(py))
                    .expect("failed to get instruction");
                result.push(instruction);
            }
            Ok(result)
        })
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the raw bytes of the block.
    pub fn bytes(&self, py: Python) -> PyResult<Py<PyBytes>> {
        self.with_inner_block(py, |block| {
            let bytes = PyBytes::new_bound(py, &block.bytes());
            Ok(bytes.into())
        })
    }

    #[pyo3(text_signature = "($self)")]
    /// Checks if the block is a prologue block.
    pub fn prologue(&self, py: Python) -> PyResult<bool> {
        self.with_inner_block(py, |block| Ok(block.prologue()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the number of edges from the block.
    pub fn edges(&self, py: Python) -> PyResult<usize> {
        self.with_inner_block(py, |block| Ok(block.edges()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the next address in the block.
    pub fn next(&self, py: Python) -> PyResult<Option<u64>> {
        self.with_inner_block(py, |block| Ok(block.next()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the set of addresses the block points to.
    pub fn to(&self, py: Python) -> PyResult<BTreeSet<u64>> {
        self.with_inner_block(py, |block| Ok(block.to()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Calculates the entropy of the block.
    pub fn entropy(&self, py: Python) -> PyResult<Option<f64>> {
        self.with_inner_block(py, |block| Ok(block.entropy()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the set of addresses of blocks referenced by this block.
    pub fn blocks(&self, py: Python) -> PyResult<BTreeSet<u64>> {
        self.with_inner_block(py, |block| Ok(block.blocks()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the number of instructions in the block.
    pub fn number_of_instructions(&self, py: Python) -> PyResult<usize> {
        self.with_inner_block(py, |block| Ok(block.number_of_instructions()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the functions referenced in the block as a map.
    pub fn functions(&self, py: Python) -> PyResult<BTreeMap<u64, u64>> {
        self.with_inner_block(py, |block| Ok(block.functions()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the TLSH (Trend Micro Locality Sensitive Hash) of the block.
    pub fn tlsh(&self, py: Python) -> PyResult<Option<String>> {
        self.with_inner_block(py, |block| Ok(block.tlsh()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the SHA-256 hash of the block.
    pub fn sha256(&self, py: Python) -> PyResult<Option<String>> {
        self.with_inner_block(py, |block| Ok(block.sha256()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the MinHash of the block.
    pub fn minhash(&self, py: Python) -> PyResult<Option<String>> {
        self.with_inner_block(py, |block| Ok(block.minhash()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the ending address of the block.
    pub fn end(&self, py: Python) -> PyResult<u64> {
        self.with_inner_block(py, |block| Ok(block.end()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Retrieves the size of the block in bytes.
    pub fn size(&self, py: Python) -> PyResult<usize> {
        self.with_inner_block(py, |block| Ok(block.size()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Prints a human-readable representation of the block.
    pub fn print(&self, py: Python) -> PyResult<()> {
        self.with_inner_block(py, |block| {
            block.print();
            Ok(())
        })
    }

    #[pyo3(text_signature = "($self)")]
    /// Converts the block to a Python dictionary.
    pub fn to_dict(&self, py: Python) -> PyResult<Py<PyAny>> {
        let json_str = self.json(py)?;
        let json_module = py.import_bound("json")?;
        let py_dict = json_module.call_method1("loads", (json_str,))?;
        Ok(py_dict.into())
    }

    #[pyo3(text_signature = "($self)")]
    /// Converts the block to a JSON string.
    pub fn json(&self, py: Python) -> PyResult<String> {
        self.with_inner_block(py, |block| {
            block
                .json()
                .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
        })
    }

    /// Converts the block to a JSON string when printed.
    pub fn __str__(&self, py: Python) -> PyResult<String> {
        self.json(py)
    }
}

#[pymodule]
#[pyo3(name = "block")]
pub fn block_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Block>()?;
    m.add_class::<BlockJsonDeserializer>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.controlflow.block", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.controlflow.block")?;
    Ok(())
}

```

`src/bindings/python/src/controlflow/function.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Block;
use crate::controlflow::BlockJsonDeserializer;
use crate::controlflow::Graph;
use crate::genetics::Chromosome;
use crate::genetics::ChromosomeSimilarity;
use crate::Architecture;
use crate::Config;
use binlex::controlflow::BlockJsonDeserializer as InnerBlockJsonDeserializer;
use binlex::controlflow::Function as InnerFunction;
use binlex::controlflow::FunctionJsonDeserializer as InnerFunctionJsonDeserializer;
use binlex::controlflow::Graph as InnerGraph;
use binlex::Binary as InnerBinary;
use pyo3::prelude::*;
use pyo3::types::PyBytes;
use pyo3::types::PyList;
use pyo3::Py;
use std::collections::BTreeMap;
use std::sync::Arc;
use std::sync::Mutex;

#[pyclass]
pub struct FunctionJsonDeserializer {
    pub inner: Arc<Mutex<InnerFunctionJsonDeserializer>>,
}

#[pymethods]
impl FunctionJsonDeserializer {
    #[new]
    #[pyo3(text_signature = "(string, config)")]
    pub fn new(py: Python, string: String, config: Py<Config>) -> PyResult<Self> {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerFunctionJsonDeserializer::new(string, inner_config)?;
        Ok(Self {
            inner: Arc::new(Mutex::new(inner)),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn blocks(&self) -> Vec<BlockJsonDeserializer> {
        let mut result = Vec::<BlockJsonDeserializer>::new();
        let blocks = self.inner.lock().unwrap().json.blocks.clone();
        let inner_config = self.inner.lock().unwrap().config.clone();
        for block_json in blocks {
            let block_json_deserializer = BlockJsonDeserializer {
                inner: Arc::new(Mutex::new(InnerBlockJsonDeserializer {
                    json: block_json,
                    config: inner_config.clone(),
                })),
            };
            result.push(block_json_deserializer)
        }
        result
    }

    #[pyo3(text_signature = "($self)")]
    pub fn functions(&self) -> BTreeMap<u64, u64> {
        self.inner.lock().unwrap().functions()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn size(&self) -> usize {
        self.inner.lock().unwrap().size()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn contiguous(&self) -> bool {
        self.inner.lock().unwrap().contiguous()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn architecture(&self) -> PyResult<Architecture> {
        let inner = self
            .inner
            .lock()
            .unwrap()
            .architecture()
            .map_err(|err| pyo3::exceptions::PyRuntimeError::new_err(format!("{}", err)))?;
        Ok(Architecture { inner })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn bytes(&self, py: Python) -> PyResult<Option<Py<PyBytes>>> {
        let binding = self.inner.lock().unwrap();
        let string = binding.json.bytes.clone();
        if string.is_none() {
            return Ok(None);
        }
        let bytes = InnerBinary::from_hex(&string.unwrap())
            .map_err(pyo3::exceptions::PyRuntimeError::new_err)?;
        let result = PyBytes::new_bound(py, &bytes);
        Ok(Some(result.into()))
    }

    #[pyo3(text_signature = "($self, rhs)")]
    pub fn compare(
        &self,
        py: Python,
        rhs: Py<FunctionJsonDeserializer>,
    ) -> PyResult<Option<ChromosomeSimilarity>> {
        let binding = rhs.borrow(py);
        let rhs_inner = binding.inner.lock().unwrap();
        let similarity = self.inner.lock().unwrap().compare(&rhs_inner)?;
        if similarity.is_none() {
            return Ok(None);
        }
        Ok(Some(ChromosomeSimilarity {
            inner: Arc::new(Mutex::new(similarity.unwrap())),
        }))
    }

    #[pyo3(text_signature = "($self, rhs_functions)")]
    pub fn compare_many(
        &self,
        py: Python,
        rhs_functions: Py<PyList>,
    ) -> PyResult<BTreeMap<u64, ChromosomeSimilarity>> {
        // Initialize the function deserializer
        let function = InnerFunctionJsonDeserializer::new(
            self.json()?,
            self.inner.lock().unwrap().config.clone(),
        )?;

        // Prepare a vector to hold tasks (deserializers)
        let mut tasks = Vec::<InnerFunctionJsonDeserializer>::new();

        // Bind the Python list
        let list = rhs_functions.bind(py);

        // Collect items from the Python list
        let items: Vec<Py<PyAny>> = list.iter().map(|item| item.into()).collect();

        // Iterate over each item to deserialize and collect tasks
        for item in items {
            let py_item = item.bind(py);
            if !py_item.is_instance_of::<FunctionJsonDeserializer>() {
                return Err(pyo3::exceptions::PyTypeError::new_err(
                    "All items in rhs_functions must be instances of FunctionJsonDeserializer",
                ));
            }

            // Attempt to extract the deserializer
            let rhs: Option<Py<FunctionJsonDeserializer>> = py_item.extract().ok();
            if let Some(rhs_binding) = rhs {
                let rhs_borrowed = rhs_binding.borrow(py);
                let task: InnerFunctionJsonDeserializer =
                    rhs_borrowed.inner.lock().unwrap().clone();
                tasks.push(task);
            }
        }

        // Perform the comparisons sequentially
        let mut results = BTreeMap::new();
        for rhs_function in tasks.iter() {
            if let Ok(Some(similarity)) = function.compare(rhs_function) {
                results.insert(
                    rhs_function.address(),
                    ChromosomeSimilarity {
                        inner: Arc::new(Mutex::new(similarity)),
                    },
                );
            }
        }

        Ok(results)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn address(&self) -> u64 {
        self.inner.lock().unwrap().address()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn number_of_instructions(&self) -> usize {
        self.inner.lock().unwrap().number_of_instructions()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn number_of_blocks(&self) -> usize {
        self.inner.lock().unwrap().number_of_blocks()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn average_instructions_per_block(&self) -> f64 {
        self.inner.lock().unwrap().average_instructions_per_block()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn entropy(&self) -> Option<f64> {
        self.inner.lock().unwrap().entropy()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn edges(&self) -> usize {
        self.inner.lock().unwrap().edges()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn sha256(&self) -> Option<String> {
        self.inner.lock().unwrap().sha256()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn minhash(&self) -> Option<String> {
        self.inner.lock().unwrap().minhash()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlsh(&self) -> Option<String> {
        self.inner.lock().unwrap().tlsh()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlsh_ratio(&self) -> f64 {
        self.inner.lock().unwrap().tlsh_ratio()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn minhash_ratio(&self) -> f64 {
        self.inner.lock().unwrap().minhash_ratio()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn chromosome_minhash_ratio(&self) -> f64 {
        self.inner.lock().unwrap().chromosome_minhash_ratio()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn chromosome_tlsh_ratio(&self) -> f64 {
        self.inner.lock().unwrap().chromosome_tlsh_ratio()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn prologue(&self) -> bool {
        self.inner.lock().unwrap().prologue()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn chromosome(&self) -> Chromosome {
        let inner_chromosome = self.inner.lock().unwrap().chromosome();
        Chromosome {
            inner: Arc::new(Mutex::new(inner_chromosome.unwrap())),
        }
    }

    #[pyo3(text_signature = "($self)")]
    pub fn to_dict(&self, py: Python) -> PyResult<Py<PyAny>> {
        let json_str = self.json()?;
        let json_module = py.import_bound("json")?;
        let py_dict = json_module.call_method1("loads", (json_str,))?;
        Ok(py_dict.into())
    }

    #[pyo3(text_signature = "($self)")]
    pub fn json(&self) -> PyResult<String> {
        self.inner
            .lock()
            .unwrap()
            .json()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn print(&self) {
        self.inner.lock().unwrap().print()
    }

    pub fn __str__(&self) -> PyResult<String> {
        self.json()
    }
}

#[pyclass]
/// Represents a function within a control flow graph (CFG).
pub struct Function {
    /// The address of the function.
    pub address: u64,
    /// The control flow graph associated with the function.
    pub cfg: Py<Graph>,
    inner_function_cache: Arc<Mutex<Option<InnerFunction<'static>>>>,
}

impl Function {
    fn with_inner_function<F, R>(&self, py: Python, f: F) -> PyResult<R>
    where
        F: FnOnce(&InnerFunction<'static>) -> PyResult<R>,
    {
        let mut cache = self.inner_function_cache.lock().unwrap();

        if cache.is_none() {
            let binding = self.cfg.borrow(py);
            let inner = binding.inner.lock().unwrap();

            let inner_ref: &'static _ = unsafe { std::mem::transmute(&*inner) };
            let inner_block = InnerFunction::new(self.address, inner_ref)?;
            *cache = Some(inner_block);
        }

        f(cache.as_ref().unwrap())
    }
}

#[pymethods]
impl Function {
    #[new]
    #[pyo3(text_signature = "(address, cfg)")]
    /// Creates a new `Function` instance.
    ///
    /// # Arguments
    /// - `address` (`u64`): The address of the function.
    /// - `cfg` (`Graph`): The control flow graph associated with the function.
    ///
    /// # Returns
    /// - A new instance of `Function`.
    pub fn new(address: u64, cfg: Py<Graph>) -> PyResult<Self> {
        Ok(Self {
            address,
            cfg,
            inner_function_cache: Arc::new(Mutex::new(None)),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn address(&self) -> u64 {
        self.address
    }

    #[pyo3(text_signature = "($self)")]
    pub fn architecture(&self, py: Python) -> PyResult<Architecture> {
        self.with_inner_function(py, |function| {
            Ok(Architecture {
                inner: function.architecture(),
            })
        })
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the chromosome associated with this function.
    ///
    /// # Returns
    /// - `PyResult<Option<Chromosome>>`: The chromosome associated with this function
    pub fn chromosome(&self, py: Python) -> PyResult<Option<Chromosome>> {
        self.with_inner_function(py, |function| {
            let inner_config = self.cfg.borrow(py).inner.lock().unwrap().config.clone();
            let config = Py::new(
                py,
                Config {
                    inner: Arc::new(Mutex::new(inner_config)),
                },
            )
            .unwrap();
            let pattern = function.pattern();
            if pattern.is_none() {
                return Ok(None);
            }
            let chromosome = Chromosome::new(py, pattern.unwrap(), config).ok();
            Ok(chromosome)
        })
    }

    #[pyo3(text_signature = "($self, rhs)")]
    /// Compares this block with another returning the similarity.
    ///
    /// # Returns
    ///
    /// Returns an `Option<ChromosomeSimilarity>` reprenting the similarity between this block and another.
    pub fn compare(&self, py: Python, rhs: Py<Function>) -> PyResult<Option<ChromosomeSimilarity>> {
        self.with_inner_function(py, |function| {
            let rhs_address = rhs.borrow(py).address;
            let rhs_binding_0 = rhs.borrow(py);
            let rhs_binding_1 = rhs_binding_0.cfg.borrow(py);
            let rhs_cfg = rhs_binding_1.inner.lock().unwrap();
            let rhs_inner = InnerFunction::new(rhs_address, &rhs_cfg).ok();
            if rhs_inner.is_none() {
                return Ok(None);
            }
            let inner = function.compare(&rhs_inner.unwrap())?;
            if inner.is_none() {
                return Ok(None);
            }
            let similarity = ChromosomeSimilarity {
                inner: Arc::new(Mutex::new(inner.unwrap())),
            };
            Ok(Some(similarity))
        })
    }

    #[pyo3(text_signature = "($self, rhs_functions)")]
    pub fn compare_many(
        &self,
        py: Python,
        rhs_functions: Py<PyList>,
    ) -> PyResult<BTreeMap<u64, ChromosomeSimilarity>> {
        self.with_inner_function(py, |function| {
            let mut tasks = Vec::<(u64, Arc<Mutex<InnerGraph>>)>::new();

            // Bind the PyList to access its items
            let list = rhs_functions.bind(py);

            // Collect items into a Rust Vec for processing
            let items: Vec<Py<PyAny>> = list.iter().map(|item| item.into()).collect();

            // Iterate over each item to validate and collect necessary data
            for item in items {
                let py_item = item.bind(py);

                // Ensure the item is an instance of `Function`
                if !py_item.is_instance_of::<Function>() {
                    return Err(pyo3::exceptions::PyTypeError::new_err(
                        "all items in rhs_functions must be instances of Function",
                    ));
                }

                // Attempt to extract the `Function` instance
                let rhs: Option<Py<Function>> = py_item.extract().ok();
                if let Some(rhs_binding) = rhs {
                    let rhs_borrowed = rhs_binding.borrow(py);
                    let address = rhs_borrowed.address();
                    let rhs_cfg = Arc::clone(&rhs_borrowed.cfg.borrow(py).inner);
                    tasks.push((address, rhs_cfg));
                }
            }

            // Initialize the results map
            let mut results: BTreeMap<u64, ChromosomeSimilarity> = BTreeMap::new();

            // Sequentially process each task
            for (address, inner_cfg) in tasks.iter() {
                // Lock the inner configuration
                let c = inner_cfg.lock().map_err(|e| {
                    pyo3::exceptions::PyRuntimeError::new_err(format!(
                        "Failed to lock InnerGraph: {}",
                        e
                    ))
                })?;

                // Create a new InnerFunction instance
                if let Ok(rhs_function) = InnerFunction::new(*address, &c) {
                    // Compare the functions to get similarity
                    if let Ok(Some(similarity)) = function.compare(&rhs_function) {
                        // Insert the similarity result into the map
                        results.insert(
                            *address,
                            ChromosomeSimilarity {
                                inner: Arc::new(Mutex::new(similarity)),
                            },
                        );
                    }
                }
            }

            // Return the collected results
            Ok(results)
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn chromosome_minhash_ratio(&self, py: Python) -> PyResult<f64> {
        self.with_inner_function(py, |function| Ok(function.chromosome_minhash_ratio()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn chromosome_tlsh_ratio(&self, py: Python) -> PyResult<f64> {
        self.with_inner_function(py, |function| Ok(function.chromosome_tlsh_ratio()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn minhash_ratio(&self, py: Python) -> PyResult<f64> {
        self.with_inner_function(py, |function| Ok(function.minhash_ratio()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlsh_ratio(&self, py: Python) -> PyResult<f64> {
        self.with_inner_function(py, |function| Ok(function.tlsh_ratio()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn cyclomatic_complexity(&self, py: Python) -> PyResult<usize> {
        self.with_inner_function(py, |function| Ok(function.cyclomatic_complexity()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn average_instructions_per_block(&self, py: Python) -> PyResult<f64> {
        self.with_inner_function(py, |function| Ok(function.average_instructions_per_block()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the blocks associated with this function.
    ///
    /// # Returns
    /// - `PyResult<Vec<Block>>`: The blocks associated with this function
    pub fn blocks(&self, py: Python) -> PyResult<Vec<Block>> {
        self.with_inner_function(py, |function| {
            let mut result = Vec::<Block>::new();
            for block_address in function.blocks.keys() {
                let block = Block::new(*block_address, self.cfg.clone_ref(py))
                    .expect("failed to get block");
                result.push(block);
            }
            Ok(result)
        })
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the raw bytes of the function.
    ///
    /// # Returns
    /// - `bytes | None`: The raw bytes of the function, if available
    pub fn bytes(&self, py: Python) -> PyResult<Option<Py<PyBytes>>> {
        self.with_inner_function(py, |function| {
            if let Some(raw_bytes) = function.bytes() {
                let bytes = PyBytes::new_bound(py, &raw_bytes);
                Ok(Some(bytes.into()))
            } else {
                Ok(None)
            }
        })
    }

    #[pyo3(text_signature = "($self)")]
    /// Determines if the function starts with a prologue.
    ///
    /// # Returns
    /// - `bool`: `true` if the function starts with a prologue; otherwise, `false`.
    pub fn prologue(&self, py: Python) -> PyResult<bool> {
        self.with_inner_function(py, |function| Ok(function.prologue()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the number of edges in the control flow graph.
    ///
    /// # Returns
    /// - `usize`: The number of edges.
    pub fn edges(&self, py: Python) -> PyResult<usize> {
        self.with_inner_function(py, |function| Ok(function.edges()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the entropy of the function.
    ///
    /// # Returns
    /// - `Option<f64>`: The entropy value, if available.
    pub fn entropy(&self, py: Python) -> PyResult<Option<f64>> {
        self.with_inner_function(py, |function| Ok(function.entropy()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the number of instructions in the function.
    ///
    /// # Returns
    /// - `usize`: The number of instructions.
    pub fn number_of_instructions(&self, py: Python) -> PyResult<usize> {
        self.with_inner_function(py, |function| Ok(function.number_of_instructions()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the number of blocks in the function.
    ///
    /// # Returns
    /// - `usize`: The number of blocks.
    pub fn number_of_blocks(&self, py: Python) -> PyResult<usize> {
        self.with_inner_function(py, |function| Ok(function.number_of_blocks()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns a mapping of function calls within the current function.
    ///
    /// # Returns
    /// - `BTreeMap<u64, u64>`: A map of called functions' addresses and counts.
    pub fn functions(&self, py: Python) -> PyResult<BTreeMap<u64, u64>> {
        self.with_inner_function(py, |function| Ok(function.functions()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the TLSH (Trend Micro Locality Sensitive Hash) of the function.
    ///
    /// # Returns
    /// - `Option<String>`: The TLSH hash, if available.
    pub fn tlsh(&self, py: Python) -> PyResult<Option<String>> {
        self.with_inner_function(py, |function| Ok(function.tlsh()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the SHA-256 hash of the function.
    ///
    /// # Returns
    /// - `Option<String>`: The SHA-256 hash, if available.
    pub fn sha256(&self, py: Python) -> PyResult<Option<String>> {
        self.with_inner_function(py, |function| Ok(function.sha256()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the MinHash of the function.
    ///
    /// # Returns
    /// - `Option<String>`: The MinHash, if available.
    pub fn minhash(&self, py: Python) -> PyResult<Option<String>> {
        self.with_inner_function(py, |function| Ok(function.minhash()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the size of the function in bytes.
    ///
    /// # Returns
    /// - `usize`: The size of the function in bytes.
    pub fn size(&self, py: Python) -> PyResult<usize> {
        self.with_inner_function(py, |function| Ok(function.size()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Determines if the function's memory layout is contiguous.
    ///
    /// # Returns
    /// - `bool`: `True` if contiguous; otherwise, `False`.
    pub fn contiguous(&self, py: Python) -> PyResult<bool> {
        self.with_inner_function(py, |function| Ok(function.contiguous()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the ending address of the function.
    ///
    /// # Returns
    /// - `int | None`: The ending address, if available.
    pub fn end(&self, py: Python) -> PyResult<Option<u64>> {
        self.with_inner_function(py, |function| Ok(function.end()))
    }

    #[pyo3(text_signature = "($self)")]
    /// Prints a textual representation of the function in JSON.
    ///
    /// # Returns
    /// - `()` (unit): Output is sent to stdout.
    pub fn print(&self, py: Python) -> PyResult<()> {
        self.with_inner_function(py, |function| {
            function.print();
            Ok(())
        })
    }

    #[pyo3(text_signature = "($self)")]
    /// Converts the function to a JSON dictionary representation.
    ///
    /// # Returns
    /// - `dict`: A Python dictionary representation of the function.
    pub fn to_dict(&self, py: Python) -> PyResult<Py<PyAny>> {
        let json_str = self.json(py)?;
        let json_module = py.import_bound("json")?;
        let py_dict = json_module.call_method1("loads", (json_str,))?;
        Ok(py_dict.into())
    }

    #[pyo3(text_signature = "($self)")]
    /// Converts the function to JSON representation.
    ///
    /// # Returns
    /// - `str`: JSON string representing the function.
    pub fn json(&self, py: Python) -> PyResult<String> {
        self.with_inner_function(py, |function| {
            function
                .json()
                .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
        })
    }

    /// When printed directly print the JSON representation of the function.
    pub fn __str__(&self, py: Python) -> PyResult<String> {
        self.json(py)
    }
}

#[pymodule]
#[pyo3(name = "function")]
pub fn function_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Function>()?;
    m.add_class::<FunctionJsonDeserializer>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.controlflow.function", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.controlflow.function")?;
    Ok(())
}

```

`src/bindings/python/src/controlflow/graph.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Block;
use crate::controlflow::Function;
use crate::controlflow::Instruction;
use crate::Architecture;
use crate::Config;
use binlex::controlflow::Graph as InnerGraph;
use binlex::controlflow::GraphQueue as InnerGraphQueue;
use pyo3::prelude::*;
use std::collections::BTreeSet;
use std::sync::Arc;
use std::sync::Mutex;

#[pyclass]
pub struct GraphQueue {
    inner_graph: Arc<Mutex<InnerGraph>>,
    kind: QueueKind,
}

#[derive(Clone, Copy)]
enum QueueKind {
    Instructions,
    Blocks,
    Functions,
}

impl GraphQueue {
    fn get_queue<'a>(&self, inner: &'a InnerGraph) -> &'a InnerGraphQueue {
        match self.kind {
            QueueKind::Instructions => &inner.instructions,
            QueueKind::Blocks => &inner.blocks,
            QueueKind::Functions => &inner.functions,
        }
    }

    fn get_queue_mut<'a>(&self, inner: &'a mut InnerGraph) -> &'a mut InnerGraphQueue {
        match self.kind {
            QueueKind::Instructions => &mut inner.instructions,
            QueueKind::Blocks => &mut inner.blocks,
            QueueKind::Functions => &mut inner.functions,
        }
    }
}

#[pymethods]
impl GraphQueue {
    #[pyo3(text_signature = "($self, address)")]
    pub fn insert_invalid(&self, address: u64) {
        let mut inner = self.inner_graph.lock().unwrap();
        self.get_queue_mut(&mut inner).insert_invalid(address);
    }

    #[pyo3(text_signature = "($self, address)")]
    pub fn is_invalid(&self, address: u64) -> bool {
        let inner = self.inner_graph.lock().unwrap();
        self.get_queue(&inner).is_invalid(address)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn valid_addresses(&self) -> BTreeSet<u64> {
        let inner = self.inner_graph.lock().unwrap();
        self.get_queue(&inner).valid_addresses()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn invalid_addresses(&self) -> BTreeSet<u64> {
        let inner = self.inner_graph.lock().unwrap();
        self.get_queue(&inner).invalid_addresses()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn processed_addresses(&self) -> BTreeSet<u64> {
        let inner = self.inner_graph.lock().unwrap();
        self.get_queue(&inner).processed_addresses()
    }

    #[pyo3(text_signature = "($self, address)")]
    pub fn is_valid(&self, address: u64) -> bool {
        let inner = self.inner_graph.lock().unwrap();
        self.get_queue(&inner).is_valid(address)
    }

    #[pyo3(text_signature = "($self, address)")]
    pub fn insert_valid(&self, address: u64) {
        let mut inner = self.inner_graph.lock().unwrap();
        self.get_queue_mut(&mut inner).insert_valid(address);
    }

    #[pyo3(text_signature = "($self, addresses)")]
    pub fn insert_processed_extend(&self, addresses: BTreeSet<u64>) {
        let mut inner = self.inner_graph.lock().unwrap();
        self.get_queue_mut(&mut inner)
            .insert_processed_extend(addresses);
    }

    #[pyo3(text_signature = "($self, address)")]
    pub fn insert_processed(&self, address: u64) {
        let mut inner = self.inner_graph.lock().unwrap();
        self.get_queue_mut(&mut inner).insert_processed(address);
    }

    #[pyo3(text_signature = "($self, address)")]
    pub fn is_processed(&self, address: u64) -> bool {
        let inner = self.inner_graph.lock().unwrap();
        self.get_queue(&inner).is_processed(address)
    }

    #[pyo3(text_signature = "($self, addresses)")]
    pub fn enqueue_extend(&self, addresses: BTreeSet<u64>) {
        let mut inner = self.inner_graph.lock().unwrap();
        self.get_queue_mut(&mut inner).enqueue_extend(addresses);
    }

    #[pyo3(text_signature = "($self, address)")]
    pub fn enqueue(&self, address: u64) -> bool {
        let mut inner = self.inner_graph.lock().unwrap();
        self.get_queue_mut(&mut inner).enqueue(address)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn dequeue(&self) -> Option<u64> {
        let mut inner = self.inner_graph.lock().unwrap();
        self.get_queue_mut(&mut inner).dequeue()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn dequeue_all(&self) -> BTreeSet<u64> {
        let mut inner = self.inner_graph.lock().unwrap();
        self.get_queue_mut(&mut inner).dequeue_all()
    }
}

#[pyclass]
pub struct Graph {
    pub inner: Arc<Mutex<InnerGraph>>,
}

#[pymethods]
impl Graph {
    #[new]
    #[pyo3(text_signature = "(architecture, config)")]
    pub fn new(py: Python, architecture: Py<Architecture>, config: Py<Config>) -> Self {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerGraph::new(architecture.borrow(py).inner, inner_config);
        Self {
            inner: Arc::new(Mutex::new(inner)),
        }
    }

    #[pyo3(text_signature = "($self)")]
    pub fn instructions(&self, py: Python) -> Vec<Instruction> {
        let mut result = Vec::<Instruction>::new();
        for inner_instruction in self.inner.lock().unwrap().blocks() {
            let cfg = Graph {
                inner: Arc::clone(&self.inner),
            };
            let pycfg = Py::new(py, cfg).ok();
            if pycfg.is_none() {
                continue;
            }
            let instruction = Instruction::new(inner_instruction.address, pycfg.unwrap()).ok();
            if instruction.is_none() {
                continue;
            }
            result.push(instruction.unwrap());
        }
        result
    }

    #[pyo3(text_signature = "($self)")]
    pub fn blocks(&self, py: Python) -> Vec<Block> {
        let mut result = Vec::<Block>::new();
        for inner_block in self.inner.lock().unwrap().blocks() {
            let cfg = Graph {
                inner: Arc::clone(&self.inner),
            };
            let pycfg = Py::new(py, cfg).ok();
            if pycfg.is_none() {
                continue;
            }
            let block = Block::new(inner_block.address, pycfg.unwrap()).ok();
            if block.is_none() {
                continue;
            }
            result.push(block.unwrap());
        }
        result
    }

    #[pyo3(text_signature = "($self)")]
    pub fn functions(&self, py: Python) -> Vec<Function> {
        let mut result = Vec::<Function>::new();
        for inner_function in self.inner.lock().unwrap().functions() {
            let cfg = Graph {
                inner: Arc::clone(&self.inner),
            };
            let pycfg = Py::new(py, cfg).ok();
            if pycfg.is_none() {
                continue;
            }
            let function = Function::new(inner_function.address, pycfg.unwrap()).ok();
            if function.is_none() {
                continue;
            }
            result.push(function.unwrap());
        }
        result
    }

    #[getter]
    pub fn get_queue_instructions(&self, py: Python) -> Py<GraphQueue> {
        Py::new(
            py,
            GraphQueue {
                inner_graph: Arc::clone(&self.inner),
                kind: QueueKind::Instructions,
            },
        )
        .expect("failed to get instructions graph queue")
    }

    #[getter]
    pub fn get_queue_blocks(&self, py: Python) -> Py<GraphQueue> {
        Py::new(
            py,
            GraphQueue {
                inner_graph: Arc::clone(&self.inner),
                kind: QueueKind::Blocks,
            },
        )
        .expect("failed to get blocks graph queue")
    }

    #[getter]
    pub fn get_queue_functions(&self, py: Python) -> Py<GraphQueue> {
        Py::new(
            py,
            GraphQueue {
                inner_graph: Arc::clone(&self.inner),
                kind: QueueKind::Functions,
            },
        )
        .expect("failed to get functions graph queue")
    }

    #[pyo3(text_signature = "($self, address)")]
    pub fn set_block(&self, address: u64) -> bool {
        self.inner.lock().unwrap().set_block(address)
    }

    #[pyo3(text_signature = "($self, address)")]
    pub fn set_function(&self, address: u64) -> bool {
        self.inner.lock().unwrap().set_function(address)
    }

    #[pyo3(text_signature = "($self, address, addresses)")]
    pub fn extend_instruction_edges(&self, address: u64, addresses: BTreeSet<u64>) -> bool {
        self.inner
            .lock()
            .unwrap()
            .extend_instruction_edges(address, addresses)
    }

    #[pyo3(text_signature = "($self, address)")]
    pub fn get_instruction(&self, py: Python, address: u64) -> Option<Instruction> {
        let cfg = Graph {
            inner: Arc::clone(&self.inner),
        };
        let pycfg = Py::new(py, cfg).ok();
        pycfg.as_ref()?;
        Instruction::new(address, pycfg.unwrap()).ok()
    }

    #[pyo3(text_signature = "($self, cfg)")]
    pub fn absorb(&mut self, py: Python, cfg: Py<Self>) {
        self.inner
            .lock()
            .unwrap()
            .absorb(&mut cfg.borrow_mut(py).inner.lock().unwrap());
    }
}

#[pymodule]
#[pyo3(name = "graph")]
pub fn graph_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<GraphQueue>()?;
    m.add_class::<Graph>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.controlflow.graph", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.controlflow.graph")?;
    Ok(())
}

```

`src/bindings/python/src/controlflow/instruction.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Graph;
use crate::genetics::Chromosome;
use crate::genetics::ChromosomeSimilarity;
use crate::Config;
use binlex::controlflow::Instruction as InnerInstruction;
use pyo3::prelude::*;
use std::collections::BTreeSet;
use std::sync::Arc;
use std::sync::Mutex;

#[pyclass]
pub struct Instruction {
    pub address: u64,
    pub cfg: Py<Graph>,
    pub inner: Arc<Mutex<Option<InnerInstruction>>>,
}

impl Instruction {
    fn with_inner_instruction<F, R>(&self, py: Python, f: F) -> PyResult<R>
    where
        F: FnOnce(&InnerInstruction) -> PyResult<R>,
    {
        let mut cache = self.inner.lock().unwrap();

        if cache.is_none() {
            let binding = self.cfg.borrow(py);
            let inner = binding.inner.lock().unwrap();
            #[allow(mutable_transmutes)]
            #[allow(clippy::all)]
            let inner_ref: _ = unsafe { std::mem::transmute(&*inner) };
            let inner_instruction = InnerInstruction::new(self.address, inner_ref);
            if inner_instruction.is_err() {
                return Err(pyo3::exceptions::PyRuntimeError::new_err(
                    "instruction does not exist",
                ));
            }
            *cache = Some(inner_instruction.unwrap());
        }

        f(cache.as_ref().unwrap())
    }
}

#[pymethods]
impl Instruction {
    #[new]
    #[pyo3(text_signature = "(address, cfg)")]
    pub fn new(address: u64, cfg: Py<Graph>) -> PyResult<Self> {
        Ok(Self {
            address,
            cfg,
            inner: Arc::new(Mutex::new(None)),
        })
    }

    #[getter]
    pub fn get_address(&self) -> u64 {
        self.address
    }

    #[pyo3(text_signature = "($self)")]
    /// Returns the chromosome associated with this instruction.
    ///
    /// # Returns
    /// - `PyResult<Option<Chromosome>>`: The chromosome associated with this instruction.
    pub fn chromosome(&self, py: Python) -> PyResult<Option<Chromosome>> {
        self.with_inner_instruction(py, |instruction| {
            let inner_config = self.cfg.borrow(py).inner.lock().unwrap().config.clone();
            let config = Py::new(
                py,
                Config {
                    inner: Arc::new(Mutex::new(inner_config)),
                },
            )
            .unwrap();
            let pattern = instruction.pattern();
            let chromosome = Chromosome::new(py, pattern, config).ok();
            Ok(chromosome)
        })
    }

    #[pyo3(text_signature = "($self)")]
    /// Compares this instruction with another returning the similarity.
    ///
    /// # Returns
    ///
    /// Returns an `Option<ChromosomeSimilarity>` reprenting the similarity between this instruction and another.
    pub fn compare(
        &self,
        py: Python,
        rhs: Py<Instruction>,
    ) -> PyResult<Option<ChromosomeSimilarity>> {
        self.with_inner_instruction(py, |instruction| {
            let rhs_address = rhs.borrow(py).address;
            let rhs_binding_0 = rhs.borrow(py);
            let rhs_binding_1 = rhs_binding_0.cfg.borrow(py);
            let rhs_cfg = rhs_binding_1.inner.lock().unwrap();
            let rhs_inner =
                InnerInstruction::new(rhs_address, &rhs_cfg).expect("rhs instruction is invalid");
            let inner = instruction.compare(&rhs_inner);
            if inner.is_none() {
                return Ok(None);
            }
            let similarity = ChromosomeSimilarity {
                inner: Arc::new(Mutex::new(inner.unwrap())),
            };
            Ok(Some(similarity))
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn blocks(&self, py: Python) -> PyResult<BTreeSet<u64>> {
        self.with_inner_instruction(py, |instruction| Ok(instruction.blocks()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn next(&self, py: Python) -> PyResult<Option<u64>> {
        self.with_inner_instruction(py, |instruction| Ok(instruction.next()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn to(&self, py: Python) -> PyResult<BTreeSet<u64>> {
        self.with_inner_instruction(py, |instruction| Ok(instruction.to()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn functions(&self, py: Python) -> PyResult<BTreeSet<u64>> {
        self.with_inner_instruction(py, |instruction| Ok(instruction.functions()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn size(&self, py: Python) -> PyResult<usize> {
        self.with_inner_instruction(py, |instruction| Ok(instruction.size()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn to_dict(&self, py: Python) -> PyResult<Py<PyAny>> {
        let json_str = self.json(py)?;
        let json_module = py.import_bound("json")?;
        let py_dict = json_module.call_method1("loads", (json_str,))?;
        Ok(py_dict.into())
    }

    #[pyo3(text_signature = "($self)")]
    pub fn json(&self, py: Python) -> PyResult<String> {
        self.with_inner_instruction(py, |instruction| {
            instruction
                .json()
                .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
        })
    }

    pub fn __str__(&self, py: Python) -> PyResult<String> {
        self.json(py)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn print(&self, py: Python) -> PyResult<()> {
        self.with_inner_instruction(py, |instruction| {
            instruction.print();
            Ok(())
        })
    }
}

#[pymodule]
#[pyo3(name = "instruction")]
pub fn instruction_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Instruction>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.controlflow.instruction", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.controlflow.instruction")?;
    Ok(())
}

```

`src/bindings/python/src/controlflow/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod graph;
pub mod instruction;
pub mod block;
pub mod function;

pub use crate::controlflow::graph::Graph;
pub use crate::controlflow::graph::GraphQueue;
pub use crate::controlflow::block::Block;
pub use crate::controlflow::block::BlockJsonDeserializer;
pub use crate::controlflow::function::Function;
pub use crate::controlflow::function::FunctionJsonDeserializer;
pub use crate::controlflow::instruction::Instruction;

use crate::controlflow::graph::graph_init;
use crate::controlflow::instruction::instruction_init;
use crate::controlflow::block::block_init;
use crate::controlflow::function::function_init;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
#[pyo3(name = "controlflow")]
pub fn controlflow_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(graph_init))?;
    m.add_wrapped(wrap_pymodule!(instruction_init))?;
    m.add_wrapped(wrap_pymodule!(block_init))?;
    m.add_wrapped(wrap_pymodule!(function_init))?;
    m.add_class::<Graph>()?;
    m.add_class::<GraphQueue>()?;
    m.add_class::<Instruction>()?;
    m.add_class::<Block>()?;
    m.add_class::<BlockJsonDeserializer>()?;
    m.add_class::<Function>()?;
    m.add_class::<FunctionJsonDeserializer>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.controlflow", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.controlflow")?;
    Ok(())
}

```

`src/bindings/python/src/disassemblers/capstone/disassembler.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Graph;
use crate::Architecture;
use crate::Config;
use binlex::disassemblers::capstone::Disassembler as InnerDisassembler;
use pyo3::buffer::PyBuffer;
use pyo3::exceptions::PyTypeError;
use pyo3::prelude::*;
use pyo3::types::PyAny;
use pyo3::types::PyBytes;
use pyo3::types::PyMemoryView;
use pyo3::Py;
use std::borrow::Borrow;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::io::Error;

#[pyclass(unsendable)]
pub struct Disassembler {
    image: Py<PyAny>,
    machine: Py<Architecture>,
    executable_address_ranges: BTreeMap<u64, u64>,
    config: Py<Config>,
}

#[pymethods]
impl Disassembler {
    #[new]
    #[pyo3(text_signature = "(machine, image, executable_address_ranges, config)")]
    pub fn new(
        machine: Py<Architecture>,
        image: Py<PyAny>,
        executable_address_ranges: BTreeMap<u64, u64>,
        config: Py<Config>,
    ) -> Self {
        Self {
            machine,
            image,
            executable_address_ranges,
            config,
        }
    }

    fn get_image_data<'py>(&'py self, py: Python<'py>) -> PyResult<&'py [u8]> {
        let image_ref = self.image.borrow();

        if let Ok(bytes) = image_ref.downcast_bound::<PyBytes>(py) {
            return Ok(bytes.as_bytes());
        }

        if let Ok(memory_view) = image_ref.downcast_bound::<PyMemoryView>(py) {
            let buffer = PyBuffer::<u8>::get_bound(memory_view)?;

            if !buffer.is_c_contiguous() {
                return Err(PyTypeError::new_err("the memoryview is not c-contiguous"));
            }

            let slice = buffer.as_slice(py).unwrap();

            let result: &[u8] =
                unsafe { std::slice::from_raw_parts(slice.as_ptr() as *const u8, slice.len()) };

            return Ok(result);
        }

        Err(PyTypeError::new_err(
            "expected a bytes or memoryview object for the 'image' argument",
        ))
    }

    #[pyo3(text_signature = "($self, address, cfg)")]
    pub fn disassemble_instruction(
        &self,
        py: Python,
        address: u64,
        cfg: Py<Graph>,
    ) -> Result<u64, Error> {
        let image = self.get_image_data(py)?;
        let machine_binding = &self.machine.borrow(py);
        let inner_config = self.config.borrow(py).inner.lock().unwrap().clone();
        let disassembler = InnerDisassembler::new(
            machine_binding.inner,
            image,
            self.executable_address_ranges.clone(),
            inner_config,
        )?;
        let cfg_ref = &mut cfg.borrow_mut(py);
        let result =
            disassembler.disassemble_instruction(address, &mut cfg_ref.inner.lock().unwrap())?;
        Ok(result)
    }

    #[pyo3(text_signature = "($self, address, cfg)")]
    pub fn disassemble_function(
        &self,
        py: Python,
        address: u64,
        cfg: Py<Graph>,
    ) -> Result<u64, Error> {
        let image = self.get_image_data(py)?;
        let machine_binding = &self.machine.borrow(py);
        let inner_config = self.config.borrow(py).inner.lock().unwrap().clone();
        let disassembler = InnerDisassembler::new(
            machine_binding.inner,
            image,
            self.executable_address_ranges.clone(),
            inner_config,
        )?;
        let cfg_ref = &mut cfg.borrow_mut(py);
        let result =
            disassembler.disassemble_function(address, &mut cfg_ref.inner.lock().unwrap())?;
        Ok(result)
    }

    #[pyo3(text_signature = "($self, address, cfg)")]
    pub fn disassemble_block(
        &self,
        py: Python,
        address: u64,
        cfg: Py<Graph>,
    ) -> Result<u64, Error> {
        let image = self.get_image_data(py)?;
        let machine_binding = &self.machine.borrow(py);
        let inner_config = self.config.borrow(py).inner.lock().unwrap().clone();
        let disassembler = InnerDisassembler::new(
            machine_binding.inner,
            image,
            self.executable_address_ranges.clone(),
            inner_config,
        )?;
        let cfg_ref = &mut cfg.borrow_mut(py);
        let result = disassembler.disassemble_block(address, &mut cfg_ref.inner.lock().unwrap())?;
        Ok(result)
    }

    #[pyo3(text_signature = "($self, addresses, cfg)")]
    pub fn disassemble_controlflow(
        &self,
        py: Python,
        addresses: BTreeSet<u64>,
        cfg: Py<Graph>,
    ) -> Result<(), Error> {
        let image = self.get_image_data(py)?;
        let machine_binding = &self.machine.borrow(py);
        let inner_config = self.config.borrow(py).inner.lock().unwrap().clone();
        let disassembler = InnerDisassembler::new(
            machine_binding.inner,
            image,
            self.executable_address_ranges.clone(),
            inner_config,
        )?;
        let cfg_ref = &mut cfg.borrow_mut(py);
        disassembler.disassemble_controlflow(addresses, &mut cfg_ref.inner.lock().unwrap())?;
        Ok(())
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disassemble_sweep(&self, py: Python) -> Result<BTreeSet<u64>, Error> {
        let image = self.get_image_data(py)?;
        let machine_binding = &self.machine.borrow(py);
        let inner_config = self.config.borrow(py).inner.lock().unwrap().clone();
        let disassembler = InnerDisassembler::new(
            machine_binding.inner,
            image,
            self.executable_address_ranges.clone(),
            inner_config,
        )?;
        let results = disassembler.disassemble_sweep();
        let mut asdf = BTreeSet::<u64>::new();
        for result in results {
            asdf.insert(result);
        }
        Ok(asdf)
    }
}

#[pymodule]
#[pyo3(name = "disassembler")]
pub fn disassembler_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Disassembler>()?;
    py.import_bound("sys")?.getattr("modules")?.set_item(
        "binlex_bindings.binlex.disassemblers.capstone.disassembler",
        m,
    )?;
    m.setattr(
        "__name__",
        "binlex_bindings.binlex.disassemblers.capstone.disassembler",
    )?;
    Ok(())
}

```

`src/bindings/python/src/disassemblers/capstone/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod disassembler;

use crate::disassemblers::capstone::disassembler::disassembler_init;
use disassembler::Disassembler;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
#[pyo3(name = "capstone")]
pub fn capstone_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(disassembler_init))?;
    m.add_class::<Disassembler>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.disassemblers.capstone", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.disassemblers.capstone")?;
    Ok(())
}

```

`src/bindings/python/src/disassemblers/custom/cil/disassembler.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Graph;
use crate::Architecture;
use crate::Config;
use binlex::disassemblers::custom::cil::Disassembler as InnerDisassembler;
use pyo3::buffer::PyBuffer;
use pyo3::exceptions::PyTypeError;
use pyo3::prelude::*;
use pyo3::types::PyAny;
use pyo3::types::PyBytes;
use pyo3::types::PyMemoryView;
use pyo3::Py;
use std::borrow::Borrow;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::io::Error;

#[pyclass(unsendable)]
pub struct Disassembler {
    image: Py<PyAny>,
    machine: Py<Architecture>,
    metadata_token_addresses: BTreeMap<u64, u64>,
    executable_address_ranges: BTreeMap<u64, u64>,
    config: Py<Config>,
}

#[pymethods]
impl Disassembler {
    #[new]
    #[pyo3(text_signature = "(machine, image, executable_address_ranges, config)")]
    pub fn new(
        machine: Py<Architecture>,
        image: Py<PyAny>,
        metadata_token_addresses: BTreeMap<u64, u64>,
        executable_address_ranges: BTreeMap<u64, u64>,
        config: Py<Config>,
    ) -> Self {
        Self {
            machine,
            image,
            metadata_token_addresses,
            executable_address_ranges,
            config,
        }
    }

    fn get_image_data<'py>(&'py self, py: Python<'py>) -> PyResult<&'py [u8]> {
        let image_ref = self.image.borrow();

        if let Ok(bytes) = image_ref.downcast_bound::<PyBytes>(py) {
            return Ok(bytes.as_bytes());
        }

        if let Ok(memory_view) = image_ref.downcast_bound::<PyMemoryView>(py) {
            let buffer = PyBuffer::<u8>::get_bound(memory_view)?;

            if !buffer.is_c_contiguous() {
                return Err(PyTypeError::new_err("the memoryview is not c-contiguous"));
            }

            let slice = buffer.as_slice(py).unwrap();

            let result: &[u8] =
                unsafe { std::slice::from_raw_parts(slice.as_ptr() as *const u8, slice.len()) };

            return Ok(result);
        }

        Err(PyTypeError::new_err(
            "expected a bytes or memoryview object for the 'image' argument",
        ))
    }

    #[pyo3(text_signature = "($self, address, cfg)")]
    pub fn disassemble_instruction(
        &self,
        py: Python,
        address: u64,
        cfg: Py<Graph>,
    ) -> Result<u64, Error> {
        let image = self.get_image_data(py)?;
        let machine_binding = &self.machine.borrow(py);
        let inner_config = self.config.borrow(py).inner.lock().unwrap().clone();
        let disassembler = InnerDisassembler::new(
            machine_binding.inner,
            image,
            self.metadata_token_addresses.clone(),
            self.executable_address_ranges.clone(),
            inner_config,
        )?;
        let cfg_ref = &mut cfg.borrow_mut(py);
        let result =
            disassembler.disassemble_instruction(address, &mut cfg_ref.inner.lock().unwrap())?;
        Ok(result)
    }

    #[pyo3(text_signature = "($self, address, cfg)")]
    pub fn disassemble_function(
        &self,
        py: Python,
        address: u64,
        cfg: Py<Graph>,
    ) -> Result<u64, Error> {
        let image = self.get_image_data(py)?;
        let machine_binding = &self.machine.borrow(py);
        let inner_config = self.config.borrow(py).inner.lock().unwrap().clone();
        let disassembler = InnerDisassembler::new(
            machine_binding.inner,
            image,
            self.metadata_token_addresses.clone(),
            self.executable_address_ranges.clone(),
            inner_config,
        )?;
        let cfg_ref = &mut cfg.borrow_mut(py);
        let result =
            disassembler.disassemble_function(address, &mut cfg_ref.inner.lock().unwrap())?;
        Ok(result)
    }

    #[pyo3(text_signature = "($self, address, cfg)")]
    pub fn disassemble_block(
        &self,
        py: Python,
        address: u64,
        cfg: Py<Graph>,
    ) -> Result<u64, Error> {
        let image = self.get_image_data(py)?;
        let machine_binding = &self.machine.borrow(py);
        let inner_config = self.config.borrow(py).inner.lock().unwrap().clone();
        let disassembler = InnerDisassembler::new(
            machine_binding.inner,
            image,
            self.metadata_token_addresses.clone(),
            self.executable_address_ranges.clone(),
            inner_config,
        )?;
        let cfg_ref = &mut cfg.borrow_mut(py);
        let result = disassembler.disassemble_block(address, &mut cfg_ref.inner.lock().unwrap())?;
        Ok(result)
    }

    #[pyo3(text_signature = "($self, addresses, cfg)")]
    pub fn disassemble_controlflow(
        &self,
        py: Python,
        addresses: BTreeSet<u64>,
        cfg: Py<Graph>,
    ) -> Result<(), Error> {
        let image = self.get_image_data(py)?;
        let machine_binding = &self.machine.borrow(py);
        let inner_config = self.config.borrow(py).inner.lock().unwrap().clone();
        let disassembler = InnerDisassembler::new(
            machine_binding.inner,
            image,
            self.metadata_token_addresses.clone(),
            self.executable_address_ranges.clone(),
            inner_config,
        )?;
        let cfg_ref = &mut cfg.borrow_mut(py);
        disassembler.disassemble_controlflow(addresses, &mut cfg_ref.inner.lock().unwrap())?;
        Ok(())
    }
}

#[pymodule]
#[pyo3(name = "binlex_cil_disassembler")]
pub fn binlex_cil_disassembler_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Disassembler>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.disassemblers.custom.cil", m)?;
    m.setattr(
        "__name__",
        "binlex_bindings.binlex.disassemblers.custom.cil",
    )?;
    Ok(())
}

```

`src/bindings/python/src/disassemblers/custom/cil/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod disassembler;

use pyo3::{prelude::*, wrap_pymodule};

use disassembler::binlex_cil_disassembler_init;
use disassembler::Disassembler;

#[pymodule]
#[pyo3(name = "cil")]
pub fn cil_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(binlex_cil_disassembler_init))?;
    m.add_class::<Disassembler>()?;
     py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.disassemblers.custom.cil", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.disassemblers.custom.cil")?;
    Ok(())
}

```

`src/bindings/python/src/disassemblers/custom/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod cil;

use cil::cil_init;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
#[pyo3(name = "custom_disassemblers")]
pub fn custom_disassemblers_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(cil_init))?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.disassemblers.custom", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.disassemblers.custom")?;
    Ok(())
}

```

`src/bindings/python/src/disassemblers/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod capstone;
pub mod custom;

use crate::disassemblers::capstone::capstone_init;
use crate::disassemblers::custom::custom_disassemblers_init;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
#[pyo3(name = "disassemblers")]
pub fn disassemblers_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(custom_disassemblers_init))?;
    m.add_wrapped(wrap_pymodule!(capstone_init))?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.disassemblers", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.disassemblers")?;
    Ok(())
}

```

`src/bindings/python/src/formats/elf.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::types::memorymappedfile::MemoryMappedFile;
use crate::Architecture;
use crate::Config;
use binlex::formats::ELF as InnerELF;
use pyo3::prelude::*;
use pyo3::types::PyType;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::io::Error;
use std::sync::Arc;
use std::sync::Mutex;

#[pyclass(unsendable)]
pub struct ELF {
    pub inner: Arc<Mutex<InnerELF>>,
}

#[pymethods]
impl ELF {
    #[new]
    #[pyo3(text_signature = "(path, config)")]
    pub fn new(py: Python, path: String, config: Py<Config>) -> Result<Self, Error> {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerELF::new(path, inner_config)?;
        Ok(Self {
            inner: Arc::new(Mutex::new(inner)),
        })
    }

    #[classmethod]
    #[pyo3(text_signature = "(bytes, config)")]
    pub fn from_bytes(
        _: &Bound<'_, PyType>,
        py: Python,
        bytes: Vec<u8>,
        config: Py<Config>,
    ) -> PyResult<Self> {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerELF::from_bytes(bytes, inner_config)?;
        Ok(Self {
            inner: Arc::new(Mutex::new(inner)),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn architecture(&self) -> Architecture {
        return Architecture::from_value(self.inner.lock().unwrap().architecture() as u16);
    }

    #[pyo3(text_signature = "($self)")]
    pub fn executable_virtual_address_ranges(&self) -> BTreeMap<u64, u64> {
        self.inner
            .lock()
            .unwrap()
            .executable_virtual_address_ranges()
    }

    #[pyo3(text_signature = "($self, relative_virtual_address)")]
    pub fn relative_virtual_address_to_virtual_address(
        &self,
        relative_virtual_address: u64,
    ) -> u64 {
        self.inner
            .lock()
            .unwrap()
            .relative_virtual_address_to_virtual_address(relative_virtual_address)
    }

    #[pyo3(text_signature = "($self, file_offset)")]
    pub fn file_offset_to_virtual_address(&self, file_offset: u64) -> Option<u64> {
        self.inner
            .lock()
            .unwrap()
            .file_offset_to_virtual_address(file_offset)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn entrypoint_virtual_addresses(&self) -> BTreeSet<u64> {
        self.inner.lock().unwrap().entrypoint_virtual_addresses()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn entrypoint_virtual_address(&self) -> u64 {
        self.inner.lock().unwrap().entrypoint_virtual_address()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn image(&self, py: Python<'_>) -> PyResult<Py<MemoryMappedFile>> {
        let result = self
            .inner
            .lock()
            .unwrap()
            .image()
            .map_err(|e| pyo3::exceptions::PyIOError::new_err(e.to_string()))?;
        let py_memory_mapped_file = Py::new(py, MemoryMappedFile { inner: result })?;
        Ok(py_memory_mapped_file)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlsh(&self) -> Option<String> {
        self.inner.lock().unwrap().tlsh()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn sha256(&self) -> Option<String> {
        self.inner.lock().unwrap().sha256()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn size(&self) -> u64 {
        self.inner.lock().unwrap().size()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn export_virtual_addresses(&self) -> BTreeSet<u64> {
        self.inner.lock().unwrap().export_virtual_addresses()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn entropy(&self) -> Option<f64> {
        self.inner.lock().unwrap().entropy()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn file_json(&self) -> PyResult<String> {
        self.inner
            .lock()
            .unwrap()
            .file_json()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }
}

#[pymodule]
#[pyo3(name = "elf")]
pub fn elf_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<ELF>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.formats.elf", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.formats.elf")?;
    Ok(())
}

```

`src/bindings/python/src/formats/file.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::Config;
use binlex::formats::file::File as InnerFile;
use pyo3::prelude::*;
use std::io::Error;

#[pyclass]
pub struct File {
    pub inner: InnerFile,
    pub config: Py<Config>,
}

#[pymethods]
impl File {
    #[new]
    #[pyo3(text_signature = "(path, config)")]
    pub fn new(py: Python, path: String, config: Py<Config>) -> PyResult<Self> {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerFile::new(path, inner_config)?;
        Ok(Self { inner, config })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlsh(&self) -> Option<String> {
        self.inner.tlsh()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn sha256(&self) -> Option<String> {
        self.inner.sha256()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn size(&self) -> u64 {
        self.inner.size()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn read(&mut self) -> Result<(), Error> {
        self.inner.read()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn json(&self) -> PyResult<String> {
        self.inner
            .json()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }
}

#[pymodule]
#[pyo3(name = "file")]
pub fn file_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<File>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.formats.file", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.formats.file")?;
    Ok(())
}

```

`src/bindings/python/src/formats/macho.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::types::memorymappedfile::MemoryMappedFile;
use crate::Architecture;
use crate::Config;
use binlex::formats::MACHO as InnerMACHO;
use pyo3::prelude::*;
use pyo3::types::PyType;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::io::Error;
use std::sync::Arc;
use std::sync::Mutex;

#[pyclass(unsendable)]
pub struct MACHO {
    pub inner: Arc<Mutex<InnerMACHO>>,
}

#[pymethods]
impl MACHO {
    #[new]
    #[pyo3(text_signature = "(path, config)")]
    pub fn new(py: Python, path: String, config: Py<Config>) -> Result<Self, Error> {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerMACHO::new(path, inner_config)?;
        Ok(Self {
            inner: Arc::new(Mutex::new(inner)),
        })
    }

    #[classmethod]
    #[pyo3(text_signature = "(bytes, config)")]
    pub fn from_bytes(
        _: &Bound<'_, PyType>,
        py: Python,
        bytes: Vec<u8>,
        config: Py<Config>,
    ) -> PyResult<Self> {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerMACHO::from_bytes(bytes, inner_config)?;
        Ok(Self {
            inner: Arc::new(Mutex::new(inner)),
        })
    }

    #[pyo3(text_signature = "($self, relative_virtual_address, slice)")]
    pub fn relative_virtual_address_to_virtual_address(
        &self,
        relative_virtual_address: u64,
        slice: usize,
    ) -> Option<u64> {
        self.inner
            .lock()
            .unwrap()
            .relative_virtual_address_to_virtual_address(relative_virtual_address, slice)
    }

    #[pyo3(text_signature = "($self, file_offset, slice)")]
    pub fn file_offset_to_virtual_address(&self, file_offset: u64, slice: usize) -> Option<u64> {
        self.inner
            .lock()
            .unwrap()
            .file_offset_to_virtual_address(file_offset, slice)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn number_of_slices(&self) -> usize {
        self.inner.lock().unwrap().number_of_slices()
    }

    #[pyo3(text_signature = "($self, slice)")]
    pub fn entrypoint_virtual_address(&self, slice: usize) -> Option<u64> {
        self.inner.lock().unwrap().entrypoint_virtual_address(slice)
    }

    #[pyo3(text_signature = "($self, slice)")]
    pub fn imagebase(&self, slice: usize) -> Option<u64> {
        self.inner.lock().unwrap().imagebase(slice)
    }

    #[pyo3(text_signature = "($self, slice)")]
    pub fn sizeofheaders(&self, slice: usize) -> Option<u64> {
        self.inner.lock().unwrap().sizeofheaders(slice)
    }

    #[pyo3(text_signature = "($self, slice)")]
    pub fn architecture(&self, slice: usize) -> Option<Architecture> {
        let architecture = self.inner.lock().unwrap().architecture(slice);
        architecture.as_ref()?;
        Some(Architecture {
            inner: architecture.unwrap(),
        })
    }

    #[pyo3(text_signature = "($self, slice)")]
    pub fn entrypoint_virtual_addresses(&self, slice: usize) -> BTreeSet<u64> {
        self.inner
            .lock()
            .unwrap()
            .entrypoint_virtual_addresses(slice)
    }

    #[pyo3(text_signature = "($self, slice)")]
    pub fn export_virtual_addresses(&self, slice: usize) -> BTreeSet<u64> {
        self.inner.lock().unwrap().export_virtual_addresses(slice)
    }

    #[pyo3(text_signature = "($self, slice)")]
    pub fn executable_virtual_address_ranges(&self, slice: usize) -> BTreeMap<u64, u64> {
        self.inner
            .lock()
            .unwrap()
            .executable_virtual_address_ranges(slice)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn image(&self, py: Python<'_>, slice: usize) -> PyResult<Py<MemoryMappedFile>> {
        let result = self
            .inner
            .lock()
            .unwrap()
            .image(slice)
            .map_err(|e| pyo3::exceptions::PyIOError::new_err(e.to_string()))?;
        let py_memory_mapped_file = Py::new(py, MemoryMappedFile { inner: result })?;
        Ok(py_memory_mapped_file)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn size(&self) -> u64 {
        self.inner.lock().unwrap().size()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlsh(&self) -> Option<String> {
        self.inner.lock().unwrap().tlsh()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn sha256(&self) -> Option<String> {
        self.inner.lock().unwrap().sha256()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn entropy(&self) -> Option<f64> {
        self.inner.lock().unwrap().entropy()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn file_json(&self) -> PyResult<String> {
        self.inner
            .lock()
            .unwrap()
            .file_json()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }
}

#[pymodule]
#[pyo3(name = "macho")]
pub fn macho_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<MACHO>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.formats.macho", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.formats.macho")?;
    Ok(())
}

```

`src/bindings/python/src/formats/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod file;
pub mod pe;
pub mod elf;
pub mod macho;

use crate::formats::file::file_init;
use crate::formats::pe::pe_init;
use crate::formats::macho::macho_init;

pub use crate::formats::pe::PE;
pub use crate::formats::file::File;
pub use crate::formats::elf::ELF;
pub use crate::formats::macho::MACHO;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
#[pyo3(name = "formats")]
pub fn formats_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(file_init))?;
    m.add_wrapped(wrap_pymodule!(pe_init))?;
    m.add_wrapped(wrap_pymodule!(macho_init))?;
    m.add_class::<PE>()?;
    m.add_class::<File>()?;
    m.add_class::<ELF>()?;
    m.add_class::<MACHO>()?;
     py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.formats", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.formats")?;
    Ok(())
}

```

`src/bindings/python/src/formats/pe.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use pyo3::prelude::*;
use std::io::Error;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::collections::HashMap;
use binlex::formats::pe::PE as InnerPe;
use crate::Architecture;
use crate::types::memorymappedfile::MemoryMappedFile;
use pyo3::types::PyType;
use crate::Config;
use std::sync::Arc;
use std::sync::Mutex;

#[pyclass(unsendable)]
pub struct PE {
    pub inner: Arc<Mutex<InnerPe>>,
}

#[pymethods]
impl PE {
    #[new]
    #[pyo3(text_signature = "(path, config)")]
    pub fn new(py: Python, path: String, config: Py<Config>) -> Result<Self, Error> {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerPe::new(path, inner_config)?;
        Ok(Self{
            inner: Arc::new(Mutex::new(inner)),
        })
    }

    #[classmethod]
    #[pyo3(text_signature = "(bytes, config)")]
    pub fn from_bytes(_: &Bound<'_, PyType>, py: Python, bytes: Vec<u8>, config: Py<Config>) -> PyResult<Self> {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerPe::from_bytes(bytes, inner_config)?;
        Ok(Self { inner: Arc::new(Mutex::new(inner)) })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn is_dotnet(&self) -> bool {
        self.inner.lock().unwrap().is_dotnet()
    }

    #[pyo3(text_signature = "($self, virtual_address)")]
    pub fn virtual_address_to_relative_virtual_address(&self, virtual_address: u64) -> u64 {
        self.inner.lock().unwrap().virtual_address_to_relative_virtual_address(virtual_address)
    }

    #[pyo3(text_signature = "($self, virtual_address)")]
    pub fn virtual_address_to_file_offset(&self, virtual_address: u64) -> Option<u64> {
        self.inner.lock().unwrap().virtual_address_to_file_offset(virtual_address)
    }

    #[pyo3(text_signature = "($self, relative_virtual_address)")]
    pub fn relative_virtual_address_to_virtual_address(&self, relative_virtual_address: u64) -> u64 {
        self.inner.lock().unwrap().relative_virtual_address_to_virtual_address(relative_virtual_address)
    }

    #[pyo3(text_signature = "($self, offset)")]
    pub fn file_offset_to_virtual_address(&self, file_offset: u64) -> Option<u64> {
        self.inner.lock().unwrap().file_offset_to_virtual_address(file_offset)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn architecture(&self) -> Architecture {
        return Architecture::from_value(self.inner.lock().unwrap().architecture() as u16);
    }

    #[pyo3(text_signature = "($self)")]
    pub fn dotnet_metadata_token_virtual_addresses(&self) -> BTreeMap<u64, u64> {
        self.inner.lock().unwrap().dotnet_metadata_token_virtual_addresses()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn dotnet_executable_virtual_address_ranges(&self) -> BTreeMap<u64, u64> {
        self.inner.lock().unwrap().dotnet_executable_virtual_address_ranges()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn executable_virtual_address_ranges(&self) -> BTreeMap<u64, u64> {
        self.inner.lock().unwrap().executable_virtual_address_ranges()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn pogo_virtual_addresses(&self) -> HashMap<u64, String> {
        self.inner.lock().unwrap().pogo_virtual_addresses()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlscallbacks(&self) -> BTreeSet<u64> {
        self.inner.lock().unwrap().tlscallback_virtual_addresses()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn dotnet_entrypoint_virtual_addresses(&self) -> BTreeSet<u64> {
        self.inner.lock().unwrap().dotnet_entrypoint_virtual_addresses()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn entrypoint_virtual_addresses(&self) -> BTreeSet<u64> {
        self.inner.lock().unwrap().entrypoint_virtual_addresses()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn entrypoint_virtual_address(&self) -> u64  {
        self.inner.lock().unwrap().entrypoint_virtual_address()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn sizeofheaders(&self) -> u64 {
        self.inner.lock().unwrap().sizeofheaders()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn image(&self, py: Python<'_>) -> PyResult<Py<MemoryMappedFile>> {
        let result = self.inner.lock().unwrap().image().map_err(|e| {
            pyo3::exceptions::PyIOError::new_err(e.to_string())
        })?;
        let py_memory_mapped_file = Py::new(py, MemoryMappedFile { inner: result})?;
        Ok(py_memory_mapped_file)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn size(&self) -> u64 {
        self.inner.lock().unwrap().size()
    }

    #[staticmethod]
    pub fn align_section_virtual_address(value: u64, section_alignment: u64, file_alignment: u64) -> u64 {
        InnerPe::align_section_virtual_address(value, section_alignment, file_alignment)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn export_virtual_addresses(&self) -> BTreeSet<u64> {
        self.inner.lock().unwrap().export_virtual_addresses()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlsh(&self) -> Option<String> {
        self.inner.lock().unwrap().tlsh()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn sha256(&self) -> Option<String> {
        self.inner.lock().unwrap().sha256()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn entropy(&self) -> Option<f64> {
        self.inner.lock().unwrap().entropy()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn file_json(&self) -> PyResult<String> {
        self.inner.lock().unwrap().file_json().map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn imagebase(&self) -> u64 {
        self.inner.lock().unwrap().imagebase()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn section_alignment(&self) -> u64 {
        self.inner.lock().unwrap().section_alignment()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn file_alignment(&self) -> u64 {
        self.inner.lock().unwrap().file_alignment()
    }
}

#[pymodule]
#[pyo3(name = "pe")]
pub fn pe_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<PE>()?;
     py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.formats.pe", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.formats.pe")?;
    Ok(())
}

```

`src/bindings/python/src/genetics/allelepair.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::genetics::Gene;
use binlex::genetics::AllelePair as InnerAllelePair;
use pyo3::prelude::*;
use pyo3::Py;
use std::sync::Arc;
use std::sync::Mutex;

#[pyclass]
pub struct AllelePair {
    pub inner: Arc<Mutex<InnerAllelePair>>,
}

#[pymethods]
impl AllelePair {
    #[new]
    #[pyo3(text_signature = "(low, high)")]
    pub fn new(py: Python, low: Py<Gene>, high: Py<Gene>) -> PyResult<Self> {
        let high_binding = high.borrow(py);
        #[allow(clippy::all)]
        let high_inner = high_binding.inner.lock().unwrap().clone();
        let low_binding = low.borrow(py);
        #[allow(clippy::all)]
        let low_inner = low_binding.inner.lock().unwrap().clone();
        let inner = InnerAllelePair::new(high_inner, low_inner);
        Ok(Self {
            inner: Arc::new(Mutex::new(inner)),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn number_of_mutations(&self) -> usize {
        self.inner.lock().unwrap().number_of_mutations()
    }

    #[pyo3(text_signature = "($self, low, high)")]
    pub fn mutate(&mut self, py: Python, low: Py<Gene>, high: Py<Gene>) {
        let high_binding = high.borrow(py);
        #[allow(clippy::all)]
        let high_inner = high_binding.inner.lock().unwrap().clone();
        let low_binding = low.borrow(py);
        #[allow(clippy::all)]
        let low_inner = low_binding.inner.lock().unwrap().clone();
        self.inner.lock().unwrap().mutate(high_inner, low_inner);
    }

    #[pyo3(text_signature = "($self)")]
    pub fn genes(&self) -> Vec<Gene> {
        vec![self.low(), self.low()]
    }

    #[staticmethod]
    #[pyo3(text_signature = "(pair)")]
    pub fn from_string(pair: String) -> PyResult<Self> {
        let inner = InnerAllelePair::from_string(pair)?;
        Ok(Self {
            inner: Arc::new(Mutex::new(inner)),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn low(&self) -> Gene {
        let low = self.inner.lock().unwrap().low;
        Gene {
            inner: Arc::new(Mutex::new(low)),
        }
    }

    #[pyo3(text_signature = "($self)")]
    pub fn high(&self) -> Gene {
        let high = self.inner.lock().unwrap().high;
        Gene {
            inner: Arc::new(Mutex::new(high)),
        }
    }

    #[pyo3(text_signature = "($self)")]
    pub fn print(&self) {
        println!("{}", self.inner.lock().unwrap());
    }

    pub fn __str__(&self) -> String {
        self.inner.lock().unwrap().to_string()
    }
}

#[pymodule]
#[pyo3(name = "allelepair")]
pub fn allelepair_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<AllelePair>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.genetics.allelepair", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.genetics.allelepair")?;
    Ok(())
}

```

`src/bindings/python/src/genetics/chromosome.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::genetics::AllelePair;
use crate::Config;
use binlex::genetics::chromosome::HomologousChromosome as InnerHomologousChromosome;
use binlex::genetics::Chromosome as InnerChromosome;
use binlex::genetics::ChromosomeSimilarity as InnerChromosomeSimilarity;
use pyo3::exceptions::PyRuntimeError;
use pyo3::prelude::*;
use pyo3::types::PyBytes;
use pyo3::Py;
use std::sync::Arc;
use std::sync::Mutex;

#[pyclass]
pub struct ChromosomeSimilarityScore {
    pub inner: Arc<Mutex<InnerChromosomeSimilarity>>,
}

#[pymethods]
impl ChromosomeSimilarityScore {
    #[pyo3(text_signature = "($self)")]
    pub fn minhash(&self) -> Option<f64> {
        self.inner.lock().unwrap().score().minhash()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlsh(&self) -> Option<f64> {
        self.inner.lock().unwrap().score().tlsh()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn json(&self, _py: Python) -> PyResult<String> {
        self.inner
            .lock()
            .unwrap()
            .json()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn print(&self) {
        self.inner.lock().unwrap().print();
    }
}

#[pyclass]
pub struct HomologousChromosome {
    pub inner: Arc<Mutex<InnerHomologousChromosome>>,
}

#[pymethods]
impl HomologousChromosome {
    #[new]
    #[pyo3(text_signature = "($score, chromosome)")]
    pub fn new(py: Python, score: f64, chromosome: Py<Chromosome>) -> PyResult<Self> {
        let binding = chromosome.borrow(py);
        let inner_chromosome = binding.inner.lock().unwrap().clone();
        let inner_homologous_chromosome = InnerHomologousChromosome {
            score,
            chromosome: inner_chromosome,
        };
        Ok(Self {
            inner: Arc::new(Mutex::new(inner_homologous_chromosome)),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn json(&self, _py: Python) -> PyResult<String> {
        self.inner
            .lock()
            .unwrap()
            .json()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn print(&self) {
        self.inner.lock().unwrap().print();
    }
}

#[pyclass]
pub struct ChromosomeSimilarity {
    pub inner: Arc<Mutex<InnerChromosomeSimilarity>>,
}

#[pymethods]
impl ChromosomeSimilarity {
    // #[new]
    // #[pyo3(signature = (minhash=None, tlsh=None))]
    // pub fn new(minhash: Option<f64>, tlsh: Option<u32>) -> Self {
    //     Self {
    //         inner: Arc::new(Mutex::new(InnerChromosomeSimilarity::new(minhash, tlsh))),
    //     }
    // }

    #[pyo3(text_signature = "($self)")]
    pub fn json(&self, _py: Python) -> PyResult<String> {
        self.inner
            .lock()
            .unwrap()
            .json()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }

    #[getter]
    pub fn score(&self) -> ChromosomeSimilarityScore {
        ChromosomeSimilarityScore {
            inner: Arc::clone(&self.inner),
        }
    }

    #[pyo3(text_signature = "($self)")]
    pub fn print(&self) {
        self.inner.lock().unwrap().print();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn to_dict(&self, py: Python) -> PyResult<Py<PyAny>> {
        let json_str = self.json(py)?;
        let json_module = py.import_bound("json")?;
        let py_dict = json_module.call_method1("loads", (json_str,))?;
        Ok(py_dict.into())
    }

    pub fn __str__(&self, py: Python) -> PyResult<String> {
        self.json(py)
    }
}

#[pyclass]
pub struct Chromosome {
    pub inner: Arc<Mutex<InnerChromosome>>,
}

#[pymethods]
impl Chromosome {
    #[new]
    #[pyo3(text_signature = "(pattern, config)")]
    pub fn new(py: Python, pattern: String, config: Py<Config>) -> PyResult<Self> {
        let inner_config = config.borrow(py).inner.lock().unwrap().clone();
        let inner = InnerChromosome::new(pattern, inner_config.clone())?;
        Ok(Self {
            inner: Arc::new(Mutex::new(inner)),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn allelepairs(&self) -> Vec<AllelePair> {
        let mut result = Vec::<AllelePair>::new();
        for allelepair in self.inner.lock().unwrap().allelepairs() {
            result.push(AllelePair {
                inner: Arc::new(Mutex::new(allelepair)),
            });
        }
        result
    }

    #[pyo3(text_signature = "($self)")]
    pub fn number_of_mutations(&self) -> usize {
        self.inner.lock().unwrap().number_of_mutations()
    }

    #[pyo3(text_signature = "($self, pattern)")]
    pub fn mutate(&mut self, pattern: String) -> PyResult<()> {
        self.inner
            .lock()
            .unwrap()
            .mutate(pattern)
            .map_err(|error| PyRuntimeError::new_err(format!("{}", error)))
    }

    #[pyo3(text_signature = "($self, rhs)")]
    pub fn compare(&self, py: Python, rhs: Py<Chromosome>) -> Option<ChromosomeSimilarity> {
        let rhs_inner = rhs.borrow(py).inner.lock().unwrap().clone();
        let lhs_inner = self.inner.lock().unwrap().clone();
        let similarity = lhs_inner.compare(&rhs_inner)?;
        Some(ChromosomeSimilarity {
            inner: Arc::new(Mutex::new(similarity)),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn pattern(&self) -> String {
        self.inner.lock().unwrap().pattern()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn feature(&self) -> Vec<u8> {
        self.inner.lock().unwrap().feature()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn tlsh(&self) -> Option<String> {
        self.inner.lock().unwrap().tlsh()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn minhash(&self) -> Option<String> {
        self.inner.lock().unwrap().minhash()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn sha256(&self) -> Option<String> {
        self.inner.lock().unwrap().sha256()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn entropy(&self) -> Option<f64> {
        self.inner.lock().unwrap().entropy()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn normalized(&self, py: Python) -> Py<PyBytes> {
        PyBytes::new_bound(py, &self.inner.lock().unwrap().normalized()).into()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn print(&self) {
        self.inner.lock().unwrap().print();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn to_dict(&self, py: Python) -> PyResult<Py<PyAny>> {
        let json_str = self.json(py)?;
        let json_module = py.import_bound("json")?;
        let py_dict = json_module.call_method1("loads", (json_str,))?;
        Ok(py_dict.into())
    }

    #[pyo3(text_signature = "($self)")]
    pub fn json(&self, _py: Python) -> PyResult<String> {
        self.inner
            .lock()
            .unwrap()
            .json()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }

    pub fn __str__(&self, py: Python) -> PyResult<String> {
        self.json(py)
    }
}

#[pymodule]
#[pyo3(name = "chromosome")]
pub fn chromosome_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Chromosome>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.genetics.chromosome", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.genetics.chromosome")?;
    Ok(())
}

```

`src/bindings/python/src/genetics/gene.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use pyo3::prelude::*;
use binlex::genetics::Gene as InnerGene;
use std::sync::Arc;
use std::sync::Mutex;
use pyo3::exceptions::PyRuntimeError;

#[pyclass]
#[derive(Debug, Clone)]
pub struct Gene {
    pub inner: Arc<Mutex<InnerGene>>,
}

#[pymethods]
impl Gene {
    #[staticmethod]
    #[pyo3(text_signature = "(c)")]
    pub fn from_char(c: char) -> PyResult<Self> {
        let inner = InnerGene::from_char(c)?;
        Ok(Self { inner: Arc::new(Mutex::new(inner)) })
    }

    #[staticmethod]
    #[pyo3(text_signature = "(pattern, config)")]
    pub fn from_value(v: u8) -> PyResult<Self> {
        let inner = InnerGene::from_value(v);
        Ok(Self{inner: Arc::new(Mutex::new(inner))})
    }

    #[staticmethod]
    #[pyo3(text_signature = "()")]
    pub fn from_wildcard() -> PyResult<Self> {
        let inner = InnerGene::from_wildcard();
        Ok(Self{inner: Arc::new(Mutex::new(inner))})
    }

    #[pyo3(text_signature = "($self, c)")]
    pub fn mutate(&mut self, c: char) -> PyResult<()> {
        self.inner
            .lock()
            .unwrap()
            .mutate(c)
            .map_err(|error| PyRuntimeError::new_err(format!("{}", error)))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn wildcard(&self) -> Option<String> {
        self.inner.lock().unwrap().wildcard()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn is_wildcard(&self) -> bool {
        self.inner.lock().unwrap().is_wildcard()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn is_value(&self) -> bool {
        self.inner.lock().unwrap().is_value()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn to_char(&self) -> String {
        self.inner.lock().unwrap().to_char()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn print(&self) {
        self.inner.lock().unwrap().print();
    }

    pub fn __str__(&self) -> String {
        self.to_char()
    }
}


#[pymodule]
#[pyo3(name = "gene")]
pub fn gene_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Gene>()?;
     py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.genetics.gene", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.genetics.gene")?;
    Ok(())
}

```

`src/bindings/python/src/genetics/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod chromosome;
pub mod gene;
pub mod allelepair;

pub use crate::genetics::chromosome::chromosome_init;
pub use crate::genetics::chromosome::Chromosome;
pub use crate::genetics::chromosome::ChromosomeSimilarity;

pub use crate::genetics::allelepair::allelepair_init;
pub use crate::genetics::allelepair::AllelePair;

pub use crate::genetics::gene::gene_init;
pub use crate::genetics::gene::Gene;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
#[pyo3(name = "genetics")]
pub fn genitics_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(gene_init))?;
    m.add_class::<Gene>()?;
    m.add_wrapped(wrap_pymodule!(allelepair_init))?;
    m.add_class::<AllelePair>()?;
    m.add_wrapped(wrap_pymodule!(chromosome_init))?;
    m.add_class::<Chromosome>()?;
    m.add_class::<ChromosomeSimilarity>()?;
     py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.genetics", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.genetics")?;
    Ok(())
}

```

`src/bindings/python/src/global/architecture.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use binlex::Architecture as InnerArchitecture;
use pyo3::exceptions::PyValueError;
use pyo3::prelude::*;

#[pyclass(eq)]
#[derive(PartialEq)]
pub struct Architecture {
    pub inner: InnerArchitecture,
}

#[pymethods]
impl Architecture {
    #[staticmethod]
    pub fn from_value(value: u16) -> Self {
        let inner = match value {
            0x00 => InnerArchitecture::AMD64,
            0x01 => InnerArchitecture::I386,
            0x02 => InnerArchitecture::CIL,
            _ => InnerArchitecture::UNKNOWN,
        };
        Architecture { inner }
    }

    #[staticmethod]
    #[pyo3(text_signature = "(s)")]
    pub fn from_string(s: String) -> PyResult<Self> {
        let inner = InnerArchitecture::from_string(&s).map_err(|err| {
            PyValueError::new_err(format!(
                "invalid or unsupported binary architecture: {}",
                err
            ))
        })?;
        Ok(Architecture { inner })
    }

    pub fn __str__(&self) -> String {
        self.inner.to_string()
    }

    #[getter]
    pub fn get_value(&self) -> u16 {
        self.inner as u16
    }
}

#[pymodule]
#[pyo3(name = "architecture")]
pub fn architecture_init(py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Architecture>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex._global.architecture", m)?;
    m.setattr("__name__", "binlex_bindings.binlex._global.architecture")?;
    Ok(())
}

```

`src/bindings/python/src/global/config.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use binlex::Config as InnerConfig;
use pyo3::prelude::*;
use std::sync::{Arc, Mutex};

#[pyclass]
pub struct ConfigHomologues {
    inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigHomologues {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.homologues.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.homologues.enabled = value;
    }

    #[getter]
    pub fn get_maximum(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.homologues.maximum
    }

    #[setter]
    pub fn set_maximum(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.homologues.maximum = value;
    }
}

#[pyclass]
pub struct ConfigBlockInstructions {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigBlockInstructions {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.blocks.instructions.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.instructions.enabled = value;
    }
}

#[pyclass]
pub struct ConfigFunctionBlocks {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFunctionBlocks {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.functions.blocks.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.blocks.enabled = value;
    }
}

#[pyclass]
pub struct ConfigChromosomes {
    inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigChromosomes {
    #[getter]
    pub fn get_hashing(&self) -> ConfigChromosomesHashing {
        ConfigChromosomesHashing {
            inner: Arc::clone(&self.inner),
        }
    }
    #[getter]
    pub fn get_heuristics(&self) -> ConfigChromosomesHeuristics {
        ConfigChromosomesHeuristics {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn homologues(&self) -> ConfigHomologues {
        ConfigHomologues {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigChromosomesHeuristics {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigChromosomesHeuristics {
    #[getter]
    pub fn get_features(&self) -> ConfigChromosomesHeuristicsFeatures {
        ConfigChromosomesHeuristicsFeatures {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_entropy(&self) -> ConfigChromosomesHeuristicsEntropy {
        ConfigChromosomesHeuristicsEntropy {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigChromosomesHashing {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigChromosomesHashing {
    #[getter]
    pub fn get_sha256(&self) -> ConfigChromosomesHashingSHA256 {
        ConfigChromosomesHashingSHA256 {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_tlsh(&self) -> ConfigChromosomesHashingTLSH {
        ConfigChromosomesHashingTLSH {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_minhash(&self) -> ConfigChromosomesHashingMinhash {
        ConfigChromosomesHashingMinhash {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigChromosomesHeuristicsEntropy {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigChromosomesHeuristicsEntropy {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.heuristics.entropy.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.heuristics.entropy.enabled = value;
    }
}

#[pyclass]
pub struct ConfigChromosomesHeuristicsFeatures {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigChromosomesHeuristicsFeatures {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.heuristics.features.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.heuristics.features.enabled = value;
    }
}

#[pyclass]
pub struct ConfigChromosomesHashingSHA256 {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigChromosomesHashingSHA256 {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.sha256.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.sha256.enabled = value;
    }
}

#[pyclass]
pub struct ConfigChromosomesHashingTLSH {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigChromosomesHashingTLSH {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.tlsh.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.tlsh.enabled = value;
    }

    #[getter]
    pub fn get_minimum_byte_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.tlsh.minimum_byte_size
    }

    #[setter]
    pub fn set_minimum_byte_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.tlsh.minimum_byte_size = value;
    }
}

#[pyclass]
pub struct ConfigChromosomesHashingMinhash {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigChromosomesHashingMinhash {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.enabled = value;
    }

    #[getter]
    pub fn get_number_of_hashes(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.number_of_hashes
    }

    #[setter]
    pub fn set_number_of_hashes(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.number_of_hashes = value;
    }

    #[getter]
    pub fn get_shingle_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.shingle_size
    }

    #[setter]
    pub fn set_shingle_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.shingle_size = value;
    }

    #[getter]
    pub fn get_maximum_byte_size_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.maximum_byte_size_enabled
    }

    #[setter]
    pub fn set_maximum_byte_size_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.maximum_byte_size_enabled = value;
    }

    #[getter]
    pub fn get_maximum_byte_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.maximum_byte_size
    }

    #[setter]
    pub fn set_maximum_byte_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.maximum_byte_size = value;
    }
    #[getter]
    pub fn get_seed(&self) -> u64 {
        let inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.seed
    }

    #[setter]
    pub fn set_seed(&mut self, value: u64) {
        let mut inner = self.inner.lock().unwrap();
        inner.chromosomes.hashing.minhash.seed = value;
    }
}

// stop

#[pyclass]
pub struct ConfigFunctions {
    inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFunctions {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.functions.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.enabled = value;
    }

    #[getter]
    pub fn get_blocks(&self) -> ConfigFunctionBlocks {
        ConfigFunctionBlocks {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_hashing(&self) -> ConfigFunctionsHashing {
        ConfigFunctionsHashing {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_heuristics(&self) -> ConfigFunctionsHeuristics {
        ConfigFunctionsHeuristics {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigFunctionsHeuristics {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFunctionsHeuristics {
    #[getter]
    pub fn get_features(&self) -> ConfigFunctionsHeuristicsFeatures {
        ConfigFunctionsHeuristicsFeatures {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_entropy(&self) -> ConfigFunctionsHeuristicsEntropy {
        ConfigFunctionsHeuristicsEntropy {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigFunctionsHashing {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFunctionsHashing {
    #[getter]
    pub fn get_sha256(&self) -> ConfigFunctionsHashingSHA256 {
        ConfigFunctionsHashingSHA256 {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_tlsh(&self) -> ConfigFunctionsHashingTLSH {
        ConfigFunctionsHashingTLSH {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_minhash(&self) -> ConfigFunctionsHashingMinhash {
        ConfigFunctionsHashingMinhash {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigFunctionsHeuristicsEntropy {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFunctionsHeuristicsEntropy {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.functions.heuristics.entropy.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.heuristics.entropy.enabled = value;
    }
}

#[pyclass]
pub struct ConfigFunctionsHeuristicsFeatures {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFunctionsHeuristicsFeatures {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.functions.heuristics.features.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.heuristics.features.enabled = value;
    }
}

#[pyclass]
pub struct ConfigFunctionsHashingSHA256 {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFunctionsHashingSHA256 {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.functions.hashing.sha256.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.hashing.sha256.enabled = value;
    }
}

#[pyclass]
pub struct ConfigFunctionsHashingTLSH {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFunctionsHashingTLSH {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.functions.hashing.tlsh.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.hashing.tlsh.enabled = value;
    }

    #[getter]
    pub fn get_minimum_byte_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.functions.hashing.tlsh.minimum_byte_size
    }

    #[setter]
    pub fn set_minimum_byte_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.hashing.tlsh.minimum_byte_size = value;
    }
}

#[pyclass]
pub struct ConfigFunctionsHashingMinhash {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFunctionsHashingMinhash {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.enabled = value;
    }

    #[getter]
    pub fn get_number_of_hashes(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.number_of_hashes
    }

    #[setter]
    pub fn set_number_of_hashes(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.number_of_hashes = value;
    }

    #[getter]
    pub fn get_shingle_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.shingle_size
    }

    #[setter]
    pub fn set_shingle_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.shingle_size = value;
    }

    #[getter]
    pub fn get_maximum_byte_size_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.maximum_byte_size_enabled
    }

    #[setter]
    pub fn set_maximum_byte_size_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.maximum_byte_size_enabled = value;
    }

    #[getter]
    pub fn get_maximum_byte_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.maximum_byte_size
    }

    #[setter]
    pub fn set_maximum_byte_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.maximum_byte_size = value;
    }
    #[getter]
    pub fn get_seed(&self) -> u64 {
        let inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.seed
    }

    #[setter]
    pub fn set_seed(&mut self, value: u64) {
        let mut inner = self.inner.lock().unwrap();
        inner.functions.hashing.minhash.seed = value;
    }
}

// stop

#[pyclass]
pub struct ConfigBlocks {
    inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigBlocks {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.blocks.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.enabled = value;
    }

    #[getter]
    pub fn get_instructions(&self) -> ConfigBlockInstructions {
        ConfigBlockInstructions {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_hashing(&self) -> ConfigBlocksHashing {
        ConfigBlocksHashing {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_heuristics(&self) -> ConfigBlocksHeuristics {
        ConfigBlocksHeuristics {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigInstructions {
    inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigInstructions {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.instructions.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.enabled = value;
    }

    #[getter]
    pub fn get_hashing(&self) -> ConfigInstructionsHashing {
        ConfigInstructionsHashing {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_heuristics(&self) -> ConfigInstructionsHeuristics {
        ConfigInstructionsHeuristics {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigInstructionsHeuristics {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigInstructionsHeuristics {
    #[getter]
    pub fn get_features(&self) -> ConfigInstructionsHeuristicsFeatures {
        ConfigInstructionsHeuristicsFeatures {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_entropy(&self) -> ConfigInstructionsHeuristicsEntropy {
        ConfigInstructionsHeuristicsEntropy {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigBlocksHeuristics {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigBlocksHeuristics {
    #[getter]
    pub fn get_features(&self) -> ConfigBlocksHeuristicsFeatures {
        ConfigBlocksHeuristicsFeatures {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_entropy(&self) -> ConfigBlocksHeuristicsEntropy {
        ConfigBlocksHeuristicsEntropy {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigInstructionsHashing {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigInstructionsHashing {
    #[getter]
    pub fn get_sha256(&self) -> ConfigInstructionsHashingSHA256 {
        ConfigInstructionsHashingSHA256 {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_tlsh(&self) -> ConfigInstructionsHashingTLSH {
        ConfigInstructionsHashingTLSH {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_minhash(&self) -> ConfigInstructionsHashingMinhash {
        ConfigInstructionsHashingMinhash {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigBlocksHashing {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigBlocksHashing {
    #[getter]
    pub fn get_sha256(&self) -> ConfigBlocksHashingSHA256 {
        ConfigBlocksHashingSHA256 {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_tlsh(&self) -> ConfigBlocksHashingTLSH {
        ConfigBlocksHashingTLSH {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_minhash(&self) -> ConfigBlocksHashingMinhash {
        ConfigBlocksHashingMinhash {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigInstructionHeuristicsEntropy {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigInstructionHeuristicsEntropy {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.instructions.heuristics.entropy.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.heuristics.entropy.enabled = value;
    }
}

#[pyclass]
pub struct ConfigBlocksHeuristicsEntropy {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigBlocksHeuristicsEntropy {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.blocks.heuristics.entropy.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.heuristics.entropy.enabled = value;
    }
}

#[pyclass]
pub struct ConfigBlocksHeuristicsFeatures {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigBlocksHeuristicsFeatures {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.blocks.heuristics.features.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.heuristics.features.enabled = value;
    }
}

#[pyclass]
pub struct ConfigInstructionsHeuristicsFeatures {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigInstructionsHeuristicsFeatures {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.instructions.heuristics.features.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.heuristics.features.enabled = value;
    }
}

#[pyclass]
pub struct ConfigInstructionsHeuristicsEntropy {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigInstructionsHeuristicsEntropy {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.instructions.heuristics.entropy.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.heuristics.entropy.enabled = value;
    }
}

#[pyclass]
pub struct ConfigBlocksHashingSHA256 {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigBlocksHashingSHA256 {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.blocks.hashing.sha256.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.hashing.sha256.enabled = value;
    }
}

#[pyclass]
pub struct ConfigInstructionsHashingSHA256 {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigInstructionsHashingSHA256 {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.instructions.hashing.sha256.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.hashing.sha256.enabled = value;
    }
}

#[pyclass]
pub struct ConfigInstructionsHashingTLSH {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigInstructionsHashingTLSH {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.instructions.hashing.tlsh.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.hashing.tlsh.enabled = value;
    }

    #[getter]
    pub fn get_minimum_byte_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.instructions.hashing.tlsh.minimum_byte_size
    }

    #[setter]
    pub fn set_minimum_byte_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.hashing.tlsh.minimum_byte_size = value;
    }
}

#[pyclass]
pub struct ConfigInstructionsHashingMinhash {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigInstructionsHashingMinhash {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.enabled = value;
    }

    #[getter]
    pub fn get_number_of_hashes(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.number_of_hashes
    }

    #[setter]
    pub fn set_number_of_hashes(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.number_of_hashes = value;
    }

    #[getter]
    pub fn get_shingle_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.shingle_size
    }

    #[setter]
    pub fn set_shingle_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.shingle_size = value;
    }

    #[getter]
    pub fn get_maximum_byte_size_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.maximum_byte_size_enabled
    }

    #[setter]
    pub fn set_maximum_byte_size_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.maximum_byte_size_enabled = value;
    }

    #[getter]
    pub fn get_maximum_byte_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.maximum_byte_size
    }

    #[setter]
    pub fn set_maximum_byte_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.maximum_byte_size = value;
    }

    #[getter]
    pub fn get_seed(&self) -> u64 {
        let inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.seed
    }

    #[setter]
    pub fn set_seed(&mut self, value: u64) {
        let mut inner = self.inner.lock().unwrap();
        inner.instructions.hashing.minhash.seed = value;
    }
}

#[pyclass]
pub struct ConfigBlocksHashingTLSH {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigBlocksHashingTLSH {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.blocks.hashing.tlsh.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.hashing.tlsh.enabled = value;
    }

    #[getter]
    pub fn get_minimum_byte_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.blocks.hashing.tlsh.minimum_byte_size
    }

    #[setter]
    pub fn set_minimum_byte_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.hashing.tlsh.minimum_byte_size = value;
    }
}

#[pyclass]
pub struct ConfigBlocksHashingMinhash {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigBlocksHashingMinhash {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.enabled = value;
    }

    #[getter]
    pub fn get_number_of_hashes(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.number_of_hashes
    }

    #[setter]
    pub fn set_number_of_hashes(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.number_of_hashes = value;
    }

    #[getter]
    pub fn get_shingle_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.shingle_size
    }

    #[setter]
    pub fn set_shingle_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.shingle_size = value;
    }

    #[getter]
    pub fn get_maximum_byte_size_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.maximum_byte_size_enabled
    }

    #[setter]
    pub fn set_maximum_byte_size_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.maximum_byte_size_enabled = value;
    }

    #[getter]
    pub fn get_maximum_byte_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.maximum_byte_size
    }

    #[setter]
    pub fn set_maximum_byte_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.maximum_byte_size = value;
    }

    #[getter]
    pub fn get_seed(&self) -> u64 {
        let inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.seed
    }

    #[setter]
    pub fn set_seed(&mut self, value: u64) {
        let mut inner = self.inner.lock().unwrap();
        inner.blocks.hashing.minhash.seed = value;
    }
}

/// stop

#[pyclass]
pub struct ConfigFormats {
    inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFormats {
    #[getter]
    pub fn get_file(&self) -> ConfigFormatsFile {
        ConfigFormatsFile {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigFormatsFile {
    inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFormatsFile {
    #[getter]
    pub fn get_hashing(&self) -> ConfigFormatsFileHashing {
        ConfigFormatsFileHashing {
            inner: Arc::clone(&self.inner),
        }
    }
    #[getter]
    pub fn get_heuristics(&self) -> ConfigFormatsFileHeuristics {
        ConfigFormatsFileHeuristics {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigFormatsFileHeuristics {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFormatsFileHeuristics {
    #[getter]
    pub fn get_features(&self) -> ConfigFormatsFileHeuristicsFeatures {
        ConfigFormatsFileHeuristicsFeatures {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_entropy(&self) -> ConfigFormatsFileHeuristicsEntropy {
        ConfigFormatsFileHeuristicsEntropy {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigFormatsFileHashing {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFormatsFileHashing {
    #[getter]
    pub fn get_sha256(&self) -> ConfigFormatsFileHashingSHA256 {
        ConfigFormatsFileHashingSHA256 {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_tlsh(&self) -> ConfigFormatsFileHashingTLSH {
        ConfigFormatsFileHashingTLSH {
            inner: Arc::clone(&self.inner),
        }
    }

    #[getter]
    pub fn get_minhash(&self) -> ConfigFormatsFileHashingMinhash {
        ConfigFormatsFileHashingMinhash {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigFormatsFileHeuristicsEntropy {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFormatsFileHeuristicsEntropy {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.heuristics.entropy.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.heuristics.entropy.enabled = value;
    }
}

#[pyclass]
pub struct ConfigFormatsFileHeuristicsFeatures {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFormatsFileHeuristicsFeatures {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.heuristics.features.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.heuristics.features.enabled = value;
    }
}

#[pyclass]
pub struct ConfigFormatsFileHashingSHA256 {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFormatsFileHashingSHA256 {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.sha256.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.sha256.enabled = value;
    }
}

#[pyclass]
pub struct ConfigFormatsFileHashingTLSH {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFormatsFileHashingTLSH {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.tlsh.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.tlsh.enabled = value;
    }

    #[getter]
    pub fn get_minimum_byte_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.tlsh.minimum_byte_size
    }

    #[setter]
    pub fn set_minimum_byte_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.tlsh.minimum_byte_size = value;
    }
}

#[pyclass]
pub struct ConfigFormatsFileHashingMinhash {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigFormatsFileHashingMinhash {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.enabled
    }

    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.enabled = value;
    }

    #[getter]
    pub fn get_number_of_hashes(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.number_of_hashes
    }

    #[setter]
    pub fn set_number_of_hashes(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.number_of_hashes = value;
    }

    #[getter]
    pub fn get_shingle_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.shingle_size
    }

    #[setter]
    pub fn set_shingle_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.shingle_size = value;
    }

    #[getter]
    pub fn get_maximum_byte_size_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.maximum_byte_size_enabled
    }

    #[setter]
    pub fn set_maximum_byte_size_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.maximum_byte_size_enabled = value;
    }

    #[getter]
    pub fn get_maximum_byte_size(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.maximum_byte_size
    }

    #[setter]
    pub fn set_maximum_byte_size(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.maximum_byte_size = value;
    }
    #[getter]
    pub fn get_seed(&self) -> u64 {
        let inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.seed
    }

    #[setter]
    pub fn set_seed(&mut self, value: u64) {
        let mut inner = self.inner.lock().unwrap();
        inner.formats.file.hashing.minhash.seed = value;
    }
}

#[pyclass]
pub struct Config {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl Config {
    #[new]
    pub fn new() -> Self {
        Self {
            inner: Arc::new(Mutex::new(InnerConfig::new())),
        }
    }

    #[getter]
    pub fn get_general(&self) -> PyResult<ConfigGeneral> {
        Ok(ConfigGeneral {
            inner: Arc::clone(&self.inner),
        })
    }
    #[getter]
    pub fn get_formats(&self) -> PyResult<ConfigFormats> {
        Ok(ConfigFormats {
            inner: Arc::clone(&self.inner),
        })
    }

    #[getter]
    pub fn get_blocks(&self) -> PyResult<ConfigBlocks> {
        Ok(ConfigBlocks {
            inner: Arc::clone(&self.inner),
        })
    }

    #[getter]
    pub fn get_instructions(&self) -> PyResult<ConfigInstructions> {
        Ok(ConfigInstructions {
            inner: Arc::clone(&self.inner),
        })
    }

    #[getter]
    pub fn get_functions(&self) -> PyResult<ConfigFunctions> {
        Ok(ConfigFunctions {
            inner: Arc::clone(&self.inner),
        })
    }

    #[getter]
    pub fn get_chromosomes(&self) -> PyResult<ConfigChromosomes> {
        Ok(ConfigChromosomes {
            inner: Arc::clone(&self.inner),
        })
    }

    #[getter]
    pub fn get_mmap(&self) -> PyResult<ConfigMmap> {
        Ok(ConfigMmap {
            inner: Arc::clone(&self.inner),
        })
    }

    #[getter]
    pub fn get_disassembler(&self) -> PyResult<ConfigDisassembler> {
        Ok(ConfigDisassembler {
            inner: Arc::clone(&self.inner),
        })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn enable_minimal(&mut self) {
        self.inner.lock().unwrap().enable_minimal();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disable_hashing(&mut self) {
        self.inner.lock().unwrap().disable_hashing();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disable_heuristics(&mut self) {
        self.inner.lock().unwrap().disable_heuristics();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disable_chromosome_heuristics(&mut self) {
        self.inner.lock().unwrap().disable_chromosome_heuristics();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disable_chromosome_hashing(&mut self) {
        self.inner.lock().unwrap().disable_chromosome_hashing();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disable_block_hashing(&mut self) {
        self.inner.lock().unwrap().disable_block_hashing();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disable_instruction_hashing(&mut self) {
        self.inner.lock().unwrap().disable_instruction_hashing();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disable_function_hashing(&mut self) {
        self.inner.lock().unwrap().disable_function_hashing();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disable_function_heuristics(&mut self) {
        self.inner.lock().unwrap().disable_function_heuristics();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disable_block_heuristics(&mut self) {
        self.inner.lock().unwrap().disable_block_heuristics();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn disable_instruction_heuristics(&mut self) {
        self.inner.lock().unwrap().disable_instruction_heuristics();
    }

    #[pyo3(text_signature = "($self)")]
    pub fn from_default(&mut self) -> PyResult<()> {
        self.inner
            .lock()
            .unwrap()
            .from_default()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn to_string(&self) -> PyResult<String> {
        self.inner
            .lock()
            .unwrap()
            .to_string()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn print(&self) {
        self.inner.lock().unwrap().print()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn write_default(&self) -> PyResult<()> {
        self.inner
            .lock()
            .unwrap()
            .write_default()
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }

    #[pyo3(text_signature = "($self, file_path)")]
    pub fn write_to_file(&self, file_path: String) -> PyResult<()> {
        self.inner
            .lock()
            .unwrap()
            .write_to_file(&file_path)
            .map_err(|e| PyErr::new::<pyo3::exceptions::PyRuntimeError, _>(e.to_string()))
    }
}

impl Default for Config {
    fn default() -> Self {
        Self::new()
    }
}

#[pyclass]
pub struct ConfigDisassembler {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigDisassembler {
    #[getter]
    pub fn get_sweep(&self) -> ConfigDisassemblerSweep {
        ConfigDisassemblerSweep {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigDisassemblerSweep {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigDisassemblerSweep {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.disassembler.sweep.enabled
    }
    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.disassembler.sweep.enabled = value;
    }
}

#[pyclass]
pub struct ConfigMmap {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigMmap {
    #[getter]
    pub fn get_directory(&self) -> String {
        let inner = self.inner.lock().unwrap();
        inner.mmap.directory.clone()
    }

    #[setter]
    pub fn set_directory(&mut self, value: String) {
        let mut inner = self.inner.lock().unwrap();
        inner.mmap.directory = value;
    }

    #[getter]
    pub fn get_cache(&self) -> ConfigMmapCache {
        ConfigMmapCache {
            inner: Arc::clone(&self.inner),
        }
    }
}

#[pyclass]
pub struct ConfigMmapCache {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigMmapCache {
    #[getter]
    pub fn get_enabled(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.mmap.cache.enabled
    }
    #[setter]
    pub fn set_enabled(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.mmap.cache.enabled = value;
    }
}

#[pyclass]
pub struct ConfigGeneral {
    pub inner: Arc<Mutex<InnerConfig>>,
}

#[pymethods]
impl ConfigGeneral {
    #[getter]
    pub fn get_threads(&self) -> usize {
        let inner = self.inner.lock().unwrap();
        inner.general.threads
    }

    #[setter]
    pub fn set_threads(&mut self, value: usize) {
        let mut inner = self.inner.lock().unwrap();
        inner.general.threads = value;
    }

    #[getter]
    pub fn get_minimal(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.general.minimal
    }

    #[setter]
    pub fn set_minimal(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.general.minimal = value;
    }

    #[getter]
    pub fn get_debug(&self) -> bool {
        let inner = self.inner.lock().unwrap();
        inner.general.debug
    }

    #[setter]
    pub fn set_debug(&mut self, value: bool) {
        let mut inner = self.inner.lock().unwrap();
        inner.general.debug = value;
    }
}

#[pymodule]
#[pyo3(name = "config")]
pub fn config_init(py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<Config>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex._global.config", m)?;
    m.setattr("__name__", "binlex_bindings.binlex._global.config")?;
    Ok(())
}

```

`src/bindings/python/src/global/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod config;
pub mod architecture;

use crate::global::config::config_init;
pub use crate::global::config::Config;
use crate::global::architecture::architecture_init;
pub use crate::global::architecture::Architecture;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
#[pyo3(name = "_global")]
pub fn global_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(config_init))?;
    m.add_wrapped(wrap_pymodule!(architecture_init))?;
    m.add_class::<Config>()?;
    m.add_class::<Architecture>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex._global", m)?;
    m.setattr("__name__", "binlex_bindings.binlex._global")?;
    Ok(())
}

```

`src/bindings/python/src/hashing/minhash.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use pyo3::prelude::*;

use binlex::hashing::minhash::MinHash32 as InnerMinHash32;

#[pyclass]
pub struct MinHash32 {
    num_hashes: usize,
    shingle_size: usize,
    seed: u64,
    bytes: Vec<u8>,
}

#[pymethods]
impl MinHash32 {
    #[new]
    #[pyo3(text_signature = "(bytes, num_hashes, shingle_size, seed)")]
    pub fn new(bytes: Vec<u8>, num_hashes: usize, shingle_size: usize, seed: u64) -> Self {
        Self {
            bytes,
            num_hashes,
            shingle_size,
            seed,
        }
    }

    #[pyo3(text_signature = "($self)")]
    pub fn hexdigest(&self) -> Option<String> {
        InnerMinHash32::new(&self.bytes, self.num_hashes, self.shingle_size, self.seed).hexdigest()
    }

    #[staticmethod]
    #[pyo3(text_signature = "(lhs, rhs)")]
    pub fn compare(lhs: String, rhs: String) -> f64 {
        InnerMinHash32::compare(&lhs, &rhs)
    }
}

#[pymodule]
#[pyo3(name = "minhash")]
pub fn minhash_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<MinHash32>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.hashing.minhash", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.hashing.minhash")?;
    Ok(())
}

```

`src/bindings/python/src/hashing/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod sha256;
pub mod tlsh;
pub mod minhash;

use crate::hashing::sha256::sha256_init;
use crate::hashing::tlsh::tlsh_init;
use crate::hashing::minhash::minhash_init;

pub use crate::hashing::minhash::MinHash32;
pub use crate::hashing::tlsh::TLSH;
pub use crate::hashing::sha256::SHA256;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
#[pyo3(name = "hashing")]
pub fn hashing_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(sha256_init))?;
    m.add_wrapped(wrap_pymodule!(tlsh_init))?;
    m.add_wrapped(wrap_pymodule!(minhash_init))?;
    m.add_class::<SHA256>()?;
    m.add_class::<MinHash32>()?;
    m.add_class::<TLSH>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.hashing", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.hashing")?;
    Ok(())
}

```

`src/bindings/python/src/hashing/sha256.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use pyo3::prelude::*;

use binlex::hashing::sha256::SHA256 as InnerSHA256;

#[pyclass]
pub struct SHA256 {
    pub bytes: Vec<u8>,
}

#[pymethods]
impl SHA256 {
    #[new]
    #[pyo3(text_signature = "(bytes)")]
    pub fn new(bytes: Vec<u8>) -> Self {
        Self { bytes }
    }

    #[pyo3(text_signature = "($self)")]
    pub fn hexdigest(&self) -> Option<String> {
        InnerSHA256::new(&self.bytes).hexdigest()
    }
}

#[pymodule]
#[pyo3(name = "sha256")]
pub fn sha256_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<SHA256>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.hashing.sha256", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.hashing.sha256")?;
    Ok(())
}

```

`src/bindings/python/src/hashing/tlsh.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use binlex::hashing::tlsh::TLSH as InnerTLSH;
use pyo3::prelude::*;

#[pyclass]
pub struct TLSH {
    bytes: Vec<u8>,
}

#[pymethods]
impl TLSH {
    #[new]
    #[pyo3(text_signature = "(bytes)")]
    pub fn new(bytes: Vec<u8>) -> Self {
        Self { bytes }
    }

    #[pyo3(text_signature = "($self)")]
    pub fn hexdigest(&self, mininum_byte_size: usize) -> Option<String> {
        InnerTLSH::new(&self.bytes, mininum_byte_size).hexdigest()
    }

    #[staticmethod]
    #[pyo3(text_signature = "(lhs, rhs)")]
    pub fn compare(lhs: String, rhs: String) -> Option<f64> {
        InnerTLSH::compare(lhs, rhs)
    }
}

#[pymodule]
#[pyo3(name = "tlsh")]
pub fn tlsh_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<TLSH>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.hashing.tlsh", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.hashing.tlsh")?;
    Ok(())
}

```

`src/bindings/python/src/imaging/colormap.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use binlex::imaging::colormap::ColorMap as InnerColorMap;
use binlex::imaging::colormap::ColorMapType as InnerColorMapType;
use pyo3::exceptions::PyRuntimeError;
use pyo3::prelude::*;
use pyo3::types::PyBytes;
use std::sync::Arc;
use std::sync::Mutex;

#[pyclass]
pub struct ColorMapType {
    inner: Arc<Mutex<InnerColorMapType>>,
}

#[pymethods]
impl ColorMapType {
    #[staticmethod]
    pub fn from_string(string: String) -> PyResult<Self> {
        let inner = InnerColorMapType::from_string(&string)
            .map_err(|e| PyErr::new::<PyRuntimeError, _>(e.to_string()))?;
        Ok(Self {
            inner: Arc::new(Mutex::new(inner)),
        })
    }
}

#[pyclass]
pub struct ColorMap {
    inner: Arc<Mutex<InnerColorMap>>,
}

#[pymethods]
impl ColorMap {
    #[new]
    #[pyo3(text_signature = "()")]
    pub fn new() -> Self {
        Self {
            inner: Arc::new(Mutex::new(InnerColorMap::new())),
        }
    }

    #[pyo3(text_signature = "($self, color_map_type)")]
    pub fn set_color_map_type(&mut self, py: Python, color_map_type: Py<ColorMapType>) {
        let inner_color_map_type = color_map_type.borrow(py).inner.lock().unwrap().clone();
        self.inner
            .lock()
            .unwrap()
            .set_color_map_type(inner_color_map_type);
    }

    #[pyo3(signature = (data, offset=0))]
    pub fn append(&mut self, py: Python, data: Py<PyBytes>, offset: u64) {
        let inner_data = data.bind(py).as_bytes();
        self.inner.lock().unwrap().append(offset, inner_data);
    }

    #[pyo3(text_signature = "($self, cell_size)")]
    pub fn set_cell_size(&mut self, cell_size: usize) {
        self.inner.lock().unwrap().set_cell_size(cell_size)
    }

    #[pyo3(text_signature = "($self, fixed_width)")]
    pub fn set_fixed_width(&mut self, fixed_width: usize) {
        self.inner.lock().unwrap().set_fixed_width(fixed_width);
    }

    #[pyo3(text_signature = "($self, key, value)")]
    pub fn insert_metadata(&mut self, key: String, value: String) {
        self.inner.lock().unwrap().insert_metadata(key, value)
    }

    #[pyo3(text_signature = "($self)")]
    pub fn to_svg_string(&self) -> String {
        self.inner.lock().unwrap().to_svg_string()
    }

    #[allow(clippy::useless_conversion)]
    #[pyo3(text_signature = "($self, file_path)")]
    pub fn write(&self, file_path: String) -> PyResult<()> {
        self.inner
            .lock()
            .unwrap()
            .write(&file_path)
            .map_err(|e| PyErr::new::<PyRuntimeError, _>(e.to_string()))
    }
}

impl Default for ColorMap {
    fn default() -> Self {
        Self::new()
    }
}

#[pymodule]
#[pyo3(name = "colormap")]
pub fn colormap_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<ColorMap>()?;
    m.add_class::<ColorMapType>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.imaging.colormap", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.imaging.colormap")?;
    Ok(())
}

```

`src/bindings/python/src/imaging/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod colormap;

pub use colormap::ColorMap;
pub use colormap::ColorMapType;
use crate::imaging::colormap::colormap_init;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
#[pyo3(name = "imaging")]
pub fn imaging_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(colormap_init))?;
    m.add_class::<ColorMap>()?;
    m.add_class::<ColorMapType>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.imaging", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.imaging")?;
    Ok(())
}

```

`src/bindings/python/src/lib.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod formats;
pub mod types;
pub mod global;
pub mod hashing;
pub mod binary;
pub mod disassemblers;
pub mod controlflow;
pub mod genetics;
pub mod imaging;

pub use binary::Binary;
pub use global::Config;
pub use global::Architecture;

use crate::formats::formats_init;
use crate::types::types_init;
use crate::binary::binary_init;
use crate::disassemblers::disassemblers_init;
use crate::controlflow::controlflow_init;
use crate::genetics::genitics_init;
use crate::global::global_init;
use crate::hashing::hashing_init;
use crate::imaging::imaging_init;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
fn binlex(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(formats_init))?;
    m.add_wrapped(wrap_pymodule!(controlflow_init))?;
    m.add_wrapped(wrap_pymodule!(types_init))?;
    m.add_wrapped(wrap_pymodule!(global_init))?;
    m.add_wrapped(wrap_pymodule!(binary_init))?;
    m.add_wrapped(wrap_pymodule!(disassemblers_init))?;
    m.add_wrapped(wrap_pymodule!(genitics_init))?;
    m.add_wrapped(wrap_pymodule!(hashing_init))?;
    m.add_wrapped(wrap_pymodule!(imaging_init))?;
    m.add_class::<Binary>()?;
    m.add_class::<Architecture>()?;
    m.add_class::<Config>()?;
    Ok(())
}

```

`src/bindings/python/src/types/lz4string.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use binlex::types::LZ4String as InnerLZ4String;
use pyo3::prelude::*;

#[pyclass]
pub struct LZ4String {
    pub inner: InnerLZ4String,
}

#[pymethods]
impl LZ4String {
    #[new]
    #[pyo3(text_signature = "(string)")]
    pub fn new(string: String) -> Self {
        Self {
            inner: InnerLZ4String::new(&string),
        }
    }

    fn __str__(&self) -> PyResult<String> {
        Ok(format!("{}", self.inner))
    }
}

#[pymodule]
#[pyo3(name = "lz4string")]
pub fn lz4string_init(py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<LZ4String>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.types.lz4string", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.types.lz4string")?;
    Ok(())
}

```

`src/bindings/python/src/types/memorymappedfile.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use pyo3::prelude::*;
use pyo3::exceptions;
use pyo3::types::PyMemoryView;
use binlex::types::MemoryMappedFile as InnerMemoryMappedFile;
use pyo3::ffi;
use std::os::raw::c_char;

#[pyclass]
pub struct MemoryMappedFile {
    pub inner: InnerMemoryMappedFile,
}

#[pymethods]
impl MemoryMappedFile {
    #[new]
    #[pyo3(text_signature = "(path, cache)")]
    pub fn new(path: &str, cache: bool) -> PyResult<Self> {
        let path = std::path::PathBuf::from(path);
        let inner = InnerMemoryMappedFile::new(path, cache)
            .map_err(|e| exceptions::PyIOError::new_err(e.to_string()))?;
        Ok(MemoryMappedFile { inner })
    }

    #[pyo3(text_signature = "($self)")]
    pub fn is_cached(&self) -> bool {
        self.inner.is_cached()
    }

    #[pyo3(text_signature = "($self)")]
    pub fn path(&self) -> String {
        self.inner.path()
    }

    #[pyo3(text_signature = "($self, data)")]
    pub fn write(&mut self, data: &[u8]) -> PyResult<u64> {
        let mut reader = std::io::Cursor::new(data);
        self.inner
            .write(&mut reader)
            .map_err(|e| exceptions::PyIOError::new_err(e.to_string()))
    }

    #[pyo3(text_signature = "($self, length)")]
    pub fn write_padding(&mut self, length: usize) -> PyResult<()> {
        self.inner
            .write_padding(length)
            .map_err(|e| exceptions::PyIOError::new_err(e.to_string()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn seek_to_end(&mut self) -> PyResult<u64> {
        self.inner
            .seek_to_end()
            .map_err(|e| exceptions::PyIOError::new_err(e.to_string()))
    }

    #[pyo3(text_signature = "($self, offset)")]
    pub fn seek(&mut self, offset: u64) -> PyResult<u64> {
        self.inner
            .seek(offset)
            .map_err(|e| exceptions::PyIOError::new_err(e.to_string()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn size(&self) -> PyResult<u64> {
        self.inner
            .size()
            .map_err(|e| exceptions::PyIOError::new_err(e.to_string()))
    }

    #[pyo3(text_signature = "($self)")]
    pub fn mmap<'py>(&'py mut self, py: Python<'py>) -> PyResult<Py<PyMemoryView>> {
        let mmap = self
            .inner
            .mmap()
            .map_err(|e| exceptions::PyIOError::new_err(e.to_string()))?;
        let data = &mmap[..];
        let ptr = data.as_ptr() as *mut c_char;
        let len = data.len() as ffi::Py_ssize_t;
        unsafe {
            let memview_ptr = ffi::PyMemoryView_FromMemory(ptr, len, ffi::PyBUF_READ);
            if memview_ptr.is_null() {
                Err(PyErr::fetch(py))
            } else {
                Ok(Py::from_owned_ptr(py, memview_ptr))
            }
        }
    }

    #[pyo3(text_signature = "($self)")]
    pub fn mmap_mut<'py>(&'py mut self, py: Python<'py>) -> PyResult<Py<PyMemoryView>> {
        let mmap = self
            .inner
            .mmap_mut()
            .map_err(|e| exceptions::PyIOError::new_err(e.to_string()))?;
        let data = &mmap[..];
        let ptr = data.as_ptr() as *mut c_char;
        let len = data.len() as ffi::Py_ssize_t;
        unsafe {
            let memview_ptr = ffi::PyMemoryView_FromMemory(ptr, len, ffi::PyBUF_WRITE);
            if memview_ptr.is_null() {
                Err(PyErr::fetch(py))
            } else {
                Ok(Py::from_owned_ptr(py, memview_ptr))
            }
        }
    }
}

#[pymodule]
#[pyo3(name = "memorymappedfile")]
pub fn memorymappedfile_init(py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<MemoryMappedFile>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.types.memorymappedfile", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.types.memorymappedfile")?;
    Ok(())
}


```

`src/bindings/python/src/types/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod memorymappedfile;
pub mod lz4string;

use crate::types::memorymappedfile::memorymappedfile_init;
use crate::types::lz4string::lz4string_init;

pub use crate::types::memorymappedfile::MemoryMappedFile;
pub use crate::types::lz4string::LZ4String;

use pyo3::{prelude::*, wrap_pymodule};

#[pymodule]
#[pyo3(name = "types")]
pub fn types_init(py: Python, m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(memorymappedfile_init))?;
    m.add_wrapped(wrap_pymodule!(lz4string_init))?;
    m.add_class::<MemoryMappedFile>()?;
    m.add_class::<LZ4String>()?;
    py.import_bound("sys")?
        .getattr("modules")?
        .set_item("binlex_bindings.binlex.types", m)?;
    m.setattr("__name__", "binlex_bindings.binlex.types")?;
    Ok(())
}

```

`src/controlflow/attribute.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::SymbolJson;
use crate::controlflow::TagJson;
use crate::formats::file::FileJson;
use serde_json::json;
use serde_json::Value;
use std::io::Error;

#[derive(Clone)]
pub enum Attribute {
    File(FileJson),
    Symbol(SymbolJson),
    Tag(TagJson),
}

impl Attribute {
    pub fn to_json_value(&self) -> serde_json::Value {
        match self {
            Attribute::File(file_json) => serde_json::to_value(file_json).unwrap_or(json!({})),
            Attribute::Symbol(symbol_json) => {
                serde_json::to_value(symbol_json).unwrap_or(json!({}))
            }
            Attribute::Tag(tag_json) => serde_json::to_value(tag_json).unwrap_or(json!({})),
        }
    }
}

#[derive(Clone)]
pub struct Attributes {
    pub values: Vec<Attribute>,
}

impl Attributes {
    pub fn new() -> Self {
        Self {
            values: Vec::<Attribute>::new(),
        }
    }

    pub fn push(&mut self, attribute: Attribute) {
        self.values.push(attribute);
    }

    pub fn pop(&mut self) -> Option<Attribute> {
        self.values.pop()
    }

    pub fn is_empty(&self) -> bool {
        self.values.is_empty()
    }

    pub fn len(&self) -> usize {
        self.values.len()
    }

    pub fn process(&self) -> Value {
        let json_list: Vec<Value> = self
            .values
            .iter()
            .map(|attribute| attribute.to_json_value())
            .collect();
        json!(json_list)
    }

    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }
}

impl Default for Attributes {
    fn default() -> Self {
        Self::new()
    }
}

```

`src/controlflow/block.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::binary::Binary;
use crate::controlflow::graph::Graph;
use crate::controlflow::Attributes;
use crate::controlflow::Instruction;
use crate::controlflow::InstructionJson;
use crate::genetics::Chromosome;
use crate::genetics::ChromosomeJson;
use crate::genetics::ChromosomeSimilarity;
use crate::hashing::MinHash32;
use crate::hashing::SHA256;
use crate::hashing::TLSH;
use crate::Architecture;
use crate::Config;
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};
use rayon::ThreadPoolBuilder;
use serde::{Deserialize, Serialize};
use serde_json;
use serde_json::Value;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::io::Error;
use std::io::ErrorKind;

/// Represents the JSON-serializable structure of a control flow block.
#[derive(Serialize, Deserialize, Clone)]
pub struct BlockJson {
    /// The type of this entity, always `"block"`.
    #[serde(rename = "type")]
    pub type_: String,
    /// The architecture of the block.
    pub architecture: String,
    /// The starting address of the block.
    pub address: u64,
    /// The address of the next sequential block, if any.
    pub next: Option<u64>,
    /// A set of addresses this block may branch or jump to.
    pub to: BTreeSet<u64>,
    /// The number of edges (connections) this block has.
    pub edges: usize,
    /// Indicates whether this block starts with a function prologue.
    pub prologue: bool,
    /// Indicates whether this block contains a conditional instruction.
    pub conditional: bool,
    /// The chromosome of the block in JSON format.
    pub chromosome: ChromosomeJson,
    /// The size of the block in bytes.
    pub size: usize,
    /// The raw bytes of the block in hexadecimal format.
    pub bytes: String,
    /// A map of function addresses related to this block.
    pub functions: BTreeMap<u64, u64>,
    // Blocks this blocks has as children.
    pub blocks: BTreeSet<u64>,
    /// The number of instructions in this block.
    pub number_of_instructions: usize,
    /// Instructions assocated with this block.
    pub instructions: Vec<InstructionJson>,
    /// The entropy of the block, if enabled.
    pub entropy: Option<f64>,
    /// The SHA-256 hash of the block, if enabled.
    pub sha256: Option<String>,
    /// The MinHash of the block, if enabled.
    pub minhash: Option<String>,
    /// The TLSH of the block, if enabled.
    pub tlsh: Option<String>,
    /// Indicates whether the block is contiguous.
    pub contiguous: bool,
    /// Attributes
    pub attributes: Option<Value>,
}

#[allow(dead_code)]
#[derive(Clone)]
pub struct BlockJsonDeserializer {
    pub json: BlockJson,
    pub config: Config,
}

impl BlockJsonDeserializer {
    #[allow(dead_code)]
    pub fn new(string: String, config: Config) -> Result<Self, Error> {
        let json: BlockJson =
            serde_json::from_str(&string).map_err(|error| Error::other(format!("{}", error)))?;
        if json.type_ != "block" {
            return Err(Error::other("deserialized JSON is not a function type"));
        }
        Ok(Self {
            json,
            config: config.clone(),
        })
    }

    #[allow(dead_code)]
    pub fn chromosome(&self) -> Chromosome {
        Chromosome::new(self.json.chromosome.pattern.clone(), self.config.clone())
            .expect("invalid chromosome")
    }

    #[allow(dead_code)]
    pub fn compare(&self, rhs: &BlockJsonDeserializer) -> Option<ChromosomeSimilarity> {
        self.chromosome().compare(&rhs.chromosome())
    }

    #[allow(dead_code)]
    pub fn compare_many(
        &self,
        rhs_blocks: Vec<BlockJsonDeserializer>,
    ) -> Result<BTreeMap<u64, ChromosomeSimilarity>, Error> {
        let pool = ThreadPoolBuilder::new()
            .num_threads(self.config.general.threads)
            .build()
            .map_err(|error| Error::other(format!("{}", error)))?;
        pool.install(|| {
            let result = rhs_blocks
                .par_iter()
                .filter_map(|block| self.compare(block).map(|sim| (block.address(), sim)))
                .collect();
            Ok(result)
        })
    }

    #[allow(dead_code)]
    pub fn blocks(&self) -> BTreeSet<u64> {
        self.json.blocks.clone()
    }

    #[allow(dead_code)]
    pub fn edges(&self) -> usize {
        self.json.edges
    }

    #[allow(dead_code)]
    pub fn tlsh(&self) -> Option<String> {
        self.json.tlsh.clone()
    }

    #[allow(dead_code)]
    pub fn functions(&self) -> BTreeMap<u64, u64> {
        self.json.functions.clone()
    }

    #[allow(dead_code)]
    pub fn architecture(&self) -> Result<Architecture, Error> {
        match Architecture::from_string(&self.json.architecture) {
            Ok(result) => Ok(result),
            Err(error) => Err(Error::new(ErrorKind::Unsupported, format!("{}", error))),
        }
    }

    #[allow(dead_code)]
    pub fn entropy(&self) -> Option<f64> {
        self.json.entropy
    }

    #[allow(dead_code)]
    pub fn address(&self) -> u64 {
        self.json.address
    }

    #[allow(dead_code)]
    pub fn size(&self) -> usize {
        self.json.size
    }

    #[allow(dead_code)]
    pub fn next(&self) -> Option<u64> {
        self.json.next
    }

    #[allow(dead_code)]
    pub fn to(&self) -> BTreeSet<u64> {
        self.json.to.clone()
    }

    #[allow(dead_code)]
    pub fn number_of_instructions(&self) -> usize {
        self.json.number_of_instructions
    }

    #[allow(dead_code)]
    pub fn minhash(&self) -> Option<String> {
        self.json.minhash.clone()
    }

    #[allow(dead_code)]
    pub fn contiguous(&self) -> bool {
        self.json.contiguous
    }
    #[allow(dead_code)]
    pub fn sha256(&self) -> Option<String> {
        self.json.sha256.clone()
    }

    #[allow(dead_code)]
    pub fn conditional(&self) -> bool {
        self.json.conditional
    }

    #[allow(dead_code)]
    pub fn json(&self) -> Result<String, Error> {
        let result = serde_json::to_string(&self.json)?;
        Ok(result)
    }

    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }
}

/// Represents a control flow block within a graph.
#[derive(Clone)]
pub struct Block<'block> {
    /// The starting address of the block.
    pub address: u64,
    /// The control flow graph this block belongs to.
    pub cfg: &'block Graph,
    /// The terminating instruction of the block.
    pub terminator: Instruction,
}

impl<'block> Block<'block> {
    /// Creates a new `Block` instance for the given address in the control flow graph.
    ///
    /// # Arguments
    ///
    /// * `address` - The starting address of the block.
    /// * `cfg` - A reference to the control flow graph the block belongs to.
    ///
    /// # Returns
    ///
    /// Returns `Ok(Block)` if the block is valid and contiguous; otherwise,
    /// returns an `Err` with an appropriate error message.
    pub fn new(address: u64, cfg: &'block Graph) -> Result<Self, Error> {
        if !cfg.blocks.is_valid(address) {
            return Err(Error::other(format!(
                "Block -> 0x{:x}: is not valid",
                address
            )));
        }

        let mut terminator: Option<Instruction> = None;

        let mut previous_address: Option<u64> = None;
        for entry in cfg.listing.range(address..) {
            let instruction = entry.value();
            if let Some(prev_addr) = previous_address {
                if instruction.address != prev_addr {
                    return Err(Error::other(format!(
                        "Block -> 0x{:x}: is not contiguous",
                        address
                    )));
                }
            }
            previous_address = Some(instruction.address + instruction.size() as u64);
            if instruction.is_jump
                || instruction.is_trap
                || instruction.is_return
                || (address != instruction.address && instruction.is_block_start)
            {
                terminator = Some(instruction.clone());
                break;
            }
        }

        if terminator.is_none() {
            return Err(Error::other(format!(
                "Block -> 0x{:x}: has no end instruction",
                address
            )));
        }

        Ok(Self {
            address,
            cfg,
            terminator: terminator.unwrap(),
        })
    }

    /// Gets the address of the block.
    pub fn address(&self) -> u64 {
        self.address
    }

    #[allow(dead_code)]
    /// Get the architecture of the block.
    pub fn architecture(&self) -> Architecture {
        self.cfg.architecture
    }

    /// Prints the JSON representation of the block to standard output.
    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }

    /// Compares this block to another for similarity.
    ///
    /// # Returns
    ///
    /// Returns `Option<ChromosomeSimilarity>` representing the similarity between this block to another.
    pub fn compare(&self, rhs: &Block) -> Option<ChromosomeSimilarity> {
        self.chromosome().compare(&rhs.chromosome())
    }

    /// Compares this block to many other blocks for similarity.
    ///
    /// # Returns
    ///
    /// Returns `Vec<ChromosomeSimilarity>` representing the similarity between this block to other blocks.
    pub fn compare_many(
        &self,
        rhs_blocks: Vec<Block>,
    ) -> Result<BTreeMap<u64, ChromosomeSimilarity>, Error> {
        let pool = ThreadPoolBuilder::new()
            .num_threads(self.cfg.config.general.threads)
            .build()
            .map_err(|error| Error::other(format!("{}", error)))?;
        pool.install(|| {
            let result = rhs_blocks
                .par_iter()
                .filter_map(|block| self.compare(block).map(|sim| (block.address(), sim)))
                .collect();
            Ok(result)
        })
    }

    /// Converts the block into a JSON string representation.
    ///
    /// # Returns
    ///
    /// Returns `Ok(String)` containing the JSON representation, or an `Err` if serialization fails.
    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    /// Converts the block into a JSON string representation including `Attributes`.
    ///
    /// # Returns
    ///
    /// Returns `Ok(String)` containing the JSON representation, or an `Err` if serialization fails.
    pub fn json_with_attributes(&self, attributes: Attributes) -> Result<String, Error> {
        let raw = self.process_with_attributes(attributes);
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    /// Processes the block into its JSON-serializable representation.
    ///
    /// # Returns
    ///
    /// Returns a `BlockJson` instance containing the block's metadata and related information.
    pub fn process(&self) -> BlockJson {
        BlockJson {
            type_: "block".to_string(),
            address: self.address,
            architecture: self.architecture().to_string(),
            next: self.next(),
            to: self.terminator.to(),
            edges: self.edges(),
            chromosome: self.chromosome_json(),
            prologue: self.prologue(),
            conditional: self.terminator.is_conditional,
            size: self.size(),
            bytes: Binary::to_hex(&self.bytes()),
            number_of_instructions: self.number_of_instructions(),
            instructions: self.instructions_json(),
            functions: self.functions(),
            blocks: self.blocks(),
            entropy: self.entropy(),
            sha256: self.sha256(),
            minhash: self.minhash(),
            tlsh: self.tlsh(),
            contiguous: true,
            attributes: None,
        }
    }

    /// Blocks are contiguous.
    pub fn contiguous(&self) -> bool {
        true
    }

    /// Retrives the instructions associated with the block.
    ///
    /// # Returns
    ///
    /// Returns a `Vec<Instruction>` representing the instructions associated with a block.
    pub fn instructions(&self) -> Vec<Instruction> {
        let mut result = Vec::<Instruction>::new();
        for entry in self.cfg.listing.range(self.address..) {
            let address = *entry.key();
            let instruction =
                Instruction::new(*entry.key(), self.cfg).expect("failed to retrieve instruction");
            result.push(instruction);
            if address >= self.terminator.address {
                break;
            }
        }
        result
    }

    /// Retrives the instructions associated with the block.
    ///
    /// # Returns
    ///
    /// Returns a `Vec<InstructionJson>` representing the instructions associated with a block.
    pub fn instructions_json(&self) -> Vec<InstructionJson> {
        let mut result = Vec::<InstructionJson>::new();
        if !self.cfg.config.blocks.instructions.enabled {
            return result;
        }
        for entry in self.cfg.listing.range(self.address..) {
            let instruction = entry.value();
            result.push(instruction.process());
            if instruction.address >= self.terminator.address {
                break;
            }
        }
        result
    }

    /// Processes the block into its JSON-serializable representation including `Attributes`.
    ///
    /// # Returns
    ///
    /// Returns a `BlockJson` instance containing the block's metadata and `Attributes`.
    pub fn process_with_attributes(&self, attributes: Attributes) -> BlockJson {
        let mut result = self.process();
        result.attributes = Some(attributes.process());
        result
    }

    /// Determines whether the block starts with a function prologue.
    ///
    /// # Returns
    ///
    /// Returns `true` if the block starts with a prologue; otherwise, `false`.
    pub fn prologue(&self) -> bool {
        if let Some(entry) = self.cfg.listing.get(&self.address) {
            return entry.value().is_prologue;
        }
        false
    }

    /// Retrieves the number of edges (connections) this block has.
    ///
    /// # Returns
    ///
    /// Returns the number of edges as a `usize`.
    pub fn edges(&self) -> usize {
        self.terminator.edges
    }

    /// Retrieves the address of the next sequential block, if any.
    ///
    /// # Returns
    ///
    /// Returns `Some(u64)` containing the address of the next block if it is
    /// conditional or has specific ending conditions. Returns `None` otherwise.
    pub fn next(&self) -> Option<u64> {
        if !self.terminator.is_conditional {
            return None;
        }
        if self.terminator.address == self.address {
            return None;
        }
        if self.terminator.is_block_start {
            return Some(self.terminator.address);
        }
        if self.terminator.is_return {
            return None;
        }
        if self.terminator.is_trap {
            return None;
        }
        if self.terminator.is_block_start {
            return Some(self.terminator.address);
        }
        self.terminator.next()
    }

    /// Retrieves the set of addresses this block may jump or branch to.
    ///
    /// # Returns
    ///
    /// Returns a `BTreeSet<u64>` containing the target addresses.
    pub fn to(&self) -> BTreeSet<u64> {
        self.terminator.to()
    }

    pub fn blocks(&self) -> BTreeSet<u64> {
        let mut result = BTreeSet::new();
        for item in self.to().iter().copied().chain(self.next()) {
            result.insert(item);
        }
        result
    }

    /// Retrieves a chromosome representing this block.
    ///
    /// # Returns
    ///
    /// Returns a `Chromosome` representing this block.
    pub fn chromosome(&self) -> Chromosome {
        Chromosome::new(self.pattern(), self.cfg.config.clone())
            .expect("failed to parse block chromosome")
    }

    /// Generates a signature for the block using its address range and control flow graph.
    ///
    /// # Returns
    ///
    /// Returns a `SignatureJson` representing the block's signature.
    pub fn chromosome_json(&self) -> ChromosomeJson {
        Chromosome::new(self.pattern(), self.cfg.config.clone())
            .unwrap()
            .process()
    }

    /// Retrieves the pattern string representation of the chromosome.
    ///
    /// # Returns
    ///
    /// Returns a `Option<String>` containing the pattern representation of the chromosome.
    pub fn pattern(&self) -> String {
        let mut result = String::new();
        for entry in self
            .cfg
            .listing
            .range(self.address..self.address + self.size() as u64)
        {
            let instruction = entry.value();
            result += instruction.pattern.as_str();
        }
        result
    }

    /// Retrieves the function addresses associated with this block.
    ///
    /// # Returns
    ///
    /// Returns a `BTreeMap<u64, u64>` where each key is an instruction address
    /// and each value is the address of the function containing that instruction.
    pub fn functions(&self) -> BTreeMap<u64, u64> {
        let mut result = BTreeMap::<u64, u64>::new();
        for entry in self.cfg.listing.range(self.address..self.end()) {
            let instruction = entry.value();
            for function_address in instruction.functions.clone() {
                result.insert(instruction.address, function_address);
            }
        }
        result
    }

    /// Computes the entropy of the block's bytes, if enabled.
    ///
    /// # Returns
    ///
    /// Returns `Some(f64)` containing the entropy, or `None` if entropy calculation is disabled.
    pub fn entropy(&self) -> Option<f64> {
        if !self.cfg.config.blocks.heuristics.entropy.enabled {
            return None;
        }
        Binary::entropy(&self.bytes())
    }

    /// Computes the TLSH of the block's bytes, if enabled.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the TLSH, or `None` if TLSH is disabled or the block size is too small.
    pub fn tlsh(&self) -> Option<String> {
        if !self.cfg.config.blocks.hashing.tlsh.enabled {
            return None;
        }
        TLSH::new(
            &self.bytes(),
            self.cfg.config.blocks.hashing.tlsh.minimum_byte_size,
        )
        .hexdigest()
    }

    /// Computes the MinHash of the block's bytes, if enabled.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the MinHash, or `None` if MinHash is disabled or the block's size exceeds the configured maximum.
    pub fn minhash(&self) -> Option<String> {
        if !self.cfg.config.blocks.hashing.minhash.enabled {
            return None;
        }
        if self.bytes().len() > self.cfg.config.blocks.hashing.minhash.maximum_byte_size
            && self
                .cfg
                .config
                .blocks
                .hashing
                .minhash
                .maximum_byte_size_enabled
        {
            return None;
        }
        MinHash32::new(
            &self.bytes(),
            self.cfg.config.blocks.hashing.minhash.number_of_hashes,
            self.cfg.config.blocks.hashing.minhash.shingle_size,
            self.cfg.config.blocks.hashing.minhash.seed,
        )
        .hexdigest()
    }

    /// Computes the SHA-256 hash of the block's bytes, if enabled.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the hash, or `None` if SHA-256 is disabled.
    pub fn sha256(&self) -> Option<String> {
        if !self.cfg.config.blocks.hashing.sha256.enabled {
            return None;
        }
        SHA256::new(&self.bytes()).hexdigest()
    }

    /// Retrieves the size of the block in bytes.
    ///
    /// # Returns
    ///
    /// Returns the size as a `usize`.
    pub fn size(&self) -> usize {
        (self.end() - self.address) as usize
    }

    /// Retrieves the raw bytes of the block.
    ///
    /// # Returns
    ///
    /// Returns a `Vec<u8>` containing the bytes of the block.
    pub fn bytes(&self) -> Vec<u8> {
        let mut result = Vec::<u8>::new();
        for entry in self.cfg.listing.range(self.address..self.end()) {
            let instruction = entry.value();
            result.extend(instruction.bytes.clone());
        }
        result
    }

    /// Counts the number of instructions in the block.
    ///
    /// # Returns
    ///
    /// Returns the number of instructions as a `usize`.
    pub fn number_of_instructions(&self) -> usize {
        let mut result: usize = 0;
        for _ in self
            .cfg
            .listing
            .range(self.address..=self.terminator.address)
        {
            result += 1;
        }
        result
    }

    /// Retrieves the address of the block's last instruction.
    ///
    /// # Returns
    ///
    /// Returns the address as a `u64`.
    #[allow(dead_code)]
    pub fn end(&self) -> u64 {
        if self.terminator.is_jump {
            return self.terminator.address + self.terminator.size() as u64;
        }
        if self.address == self.terminator.address {
            return self.terminator.address + self.terminator.size() as u64;
        }
        if self.terminator.is_block_start {
            return self.terminator.address;
        }
        if self.terminator.is_return {
            return self.terminator.address + self.terminator.size() as u64;
        }
        if let Some(next) = self.next() {
            return next;
        }
        self.terminator.address
    }
}

```

`src/controlflow/function.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use super::block::BlockJsonDeserializer;
use crate::binary::Binary;
use crate::controlflow::Attributes;
use crate::controlflow::Block;
use crate::controlflow::BlockJson;
use crate::controlflow::Graph;
use crate::controlflow::GraphQueue;
use crate::genetics::chromosome::ChromosomeSimilarityScore;
use crate::genetics::chromosome::HomologousChromosome;
use crate::genetics::Chromosome;
use crate::genetics::ChromosomeJson;
use crate::genetics::ChromosomeSimilarity;
use crate::hashing::MinHash32;
use crate::hashing::SHA256;
use crate::hashing::TLSH;
use crate::Architecture;
use crate::Config;
use serde::{Deserialize, Serialize};
use serde_json;
use serde_json::Value;
use std::collections::BTreeMap;
use std::io::Error;
use std::io::ErrorKind;

/// Represents a JSON-serializable structure containing metadata about a function.
#[derive(Serialize, Deserialize, Clone)]
pub struct FunctionJson {
    /// The type of this entity, typically `"function"`.
    #[serde(rename = "type")]
    pub type_: String,
    /// The architecture of the function.
    pub architecture: String,
    /// The starting address of the function.
    pub address: u64,
    /// The number of edges (connections) in the function.
    pub edges: usize,
    /// Indicates whether this function starts with a prologue.
    pub prologue: bool,
    /// The chromosome of the function in JSON format.
    pub chromosome: Option<ChromosomeJson>,
    /// Chromosome MinHash Ratio
    pub chromosome_minhash_ratio: f64,
    /// Chromosome TLSH Ratio
    pub chromosome_tlsh_ratio: f64,
    /// Minhash Ratio
    pub minhash_ratio: f64,
    /// TLSH ratio
    pub tlsh_ratio: f64,
    /// The size of the function in bytes, if available.
    pub size: usize,
    /// The raw bytes of the function in hexadecimal format, if available.
    pub bytes: Option<String>,
    /// A map of functions associated with the function.
    pub functions: BTreeMap<u64, u64>,
    /// The set of blocks contained within the function.
    pub blocks: Vec<BlockJson>,
    /// The number of instructions in the function.
    pub number_of_instructions: usize,
    /// Number of blocks
    pub number_of_blocks: usize,
    /// The cyclomatic complexity of the function.
    pub cyclomatic_complexity: usize,
    /// Average Instructions per Block
    pub average_instructions_per_block: f64,
    /// The entropy of the function, if enabled.
    pub entropy: Option<f64>,
    /// The SHA-256 hash of the function, if enabled.
    pub sha256: Option<String>,
    /// The MinHash of the function, if enabled.
    pub minhash: Option<String>,
    /// The TLSH of the function, if enabled.
    pub tlsh: Option<String>,
    /// Indicates whether the function is contiguous.
    pub contiguous: bool,
    /// Attributes
    pub attributes: Option<Value>,
}

#[allow(dead_code)]
#[derive(Clone)]
pub struct FunctionJsonDeserializer {
    pub json: FunctionJson,
    pub config: Config,
}

impl FunctionJsonDeserializer {
    #[allow(dead_code)]
    pub fn new(string: String, config: Config) -> Result<Self, Error> {
        let json: FunctionJson =
            serde_json::from_str(&string).map_err(|error| Error::other(format!("{}", error)))?;
        if json.type_ != "function" {
            return Err(Error::other("feserialized json is not a function type"));
        }
        Ok(Self {
            json,
            config: config.clone(),
        })
    }

    #[allow(dead_code)]
    pub fn address(&self) -> u64 {
        self.json.address
    }

    pub fn blocks(&self) -> Vec<BlockJsonDeserializer> {
        let mut result = Vec::<BlockJsonDeserializer>::new();
        for block in &self.json.blocks {
            let block_json_seserializer = BlockJsonDeserializer {
                json: block.clone(),
                config: self.config.clone(),
            };
            result.push(block_json_seserializer);
        }
        result
    }

    #[allow(dead_code)]
    pub fn bytes(&self) -> Option<Vec<u8>> {
        self.json.bytes.as_ref()?;
        Binary::from_hex(&self.json.bytes.clone().unwrap()).ok()
    }

    #[allow(dead_code)]
    pub fn average_instructions_per_block(&self) -> f64 {
        self.json.average_instructions_per_block
    }

    #[allow(dead_code)]
    pub fn cyclomatic_complexity(&self) -> usize {
        self.json.cyclomatic_complexity
    }

    #[allow(dead_code)]
    pub fn size(&self) -> usize {
        self.json.size
    }

    #[allow(dead_code)]
    pub fn tlsh_ratio(&self) -> f64 {
        self.json.tlsh_ratio
    }

    #[allow(dead_code)]
    pub fn minhash_ratio(&self) -> f64 {
        self.json.minhash_ratio
    }

    #[allow(dead_code)]
    pub fn functions(&self) -> BTreeMap<u64, u64> {
        self.json.functions.clone()
    }

    #[allow(dead_code)]
    pub fn chromosome_tlsh_ratio(&self) -> f64 {
        self.json.chromosome_tlsh_ratio
    }

    #[allow(dead_code)]
    pub fn chromosome_minhash_ratio(&self) -> f64 {
        self.json.chromosome_minhash_ratio
    }

    #[allow(dead_code)]
    pub fn prologue(&self) -> bool {
        self.json.prologue
    }

    #[allow(dead_code)]
    pub fn architecture(&self) -> Result<Architecture, Error> {
        Architecture::from_string(&self.json.architecture)
    }

    #[allow(dead_code)]
    pub fn entropy(&self) -> Option<f64> {
        self.json.entropy
    }

    #[allow(dead_code)]
    pub fn sha256(&self) -> Option<String> {
        self.json.sha256.clone()
    }

    #[allow(dead_code)]
    pub fn tlsh(&self) -> Option<String> {
        self.json.tlsh.clone()
    }

    #[allow(dead_code)]
    pub fn minhash(&self) -> Option<String> {
        self.json.minhash.clone()
    }

    #[allow(dead_code)]
    pub fn contiguous(&self) -> bool {
        self.json.contiguous
    }

    pub fn compare(
        &self,
        rhs: &FunctionJsonDeserializer,
    ) -> Result<Option<ChromosomeSimilarity>, Error> {
        if self.contiguous() && rhs.contiguous() {
            let lhs_chromosome = self.chromosome();
            let rhs_chromosome = rhs.chromosome();
            if lhs_chromosome.is_none() && rhs_chromosome.is_none() {
                return Ok(None);
            }
            return Ok(self
                .chromosome()
                .unwrap()
                .compare(&rhs.chromosome().unwrap()));
        }

        let mut minhashes = Vec::<f64>::new();
        let mut tls_values = Vec::<f64>::new();

        for lhs_block in self.blocks() {
            let mut best_minhash: Option<f64> = None;
            let mut best_tls: Option<f64> = None;

            let results = match lhs_block.compare_many(rhs.blocks()) {
                Ok(results) => results,
                Err(error) => {
                    return Err(Error::new(ErrorKind::InvalidData, format!("{}", error)));
                }
            };

            for (_, similarity) in results {
                let minhash = similarity.score().minhash();
                let tlsh = similarity.score.minhash();
                if minhash.is_none() && tlsh.is_none() {
                    continue;
                }
                if let Some(mh) = minhash {
                    best_minhash = Some(best_minhash.map_or(mh, |prev| prev.max(mh)));
                }

                if let Some(t) = tlsh {
                    best_tls = Some(best_tls.map_or(t, |prev| prev.min(t)));
                }
            }

            if let Some(mh) = best_minhash {
                minhashes.push(mh);
            }

            if let Some(t) = best_tls {
                tls_values.push(t);
            }
        }

        if !minhashes.is_empty() || !tls_values.is_empty() {
            let minhash_average = {
                let avg = minhashes.iter().sum::<f64>() / minhashes.len() as f64;
                if avg > 0.0 {
                    Some(avg)
                } else {
                    None
                }
            };

            let tlsh_average = {
                let avg = tls_values.iter().sum::<f64>() / tls_values.len() as f64;
                if avg > 0.0 {
                    Some(avg)
                } else {
                    None
                }
            };

            if minhash_average.is_none() && tlsh_average.is_none() {
                return Ok(None);
            }

            return Ok(Some(ChromosomeSimilarity {
                score: ChromosomeSimilarityScore {
                    minhash: minhash_average,
                    tlsh: tlsh_average,
                },
                homologues: Vec::<HomologousChromosome>::new(),
            }));
        }

        Ok(None)
    }

    pub fn compare_many(
        &self,
        rhs_functions: Vec<FunctionJsonDeserializer>,
    ) -> Result<BTreeMap<u64, ChromosomeSimilarity>, Error> {
        rhs_functions
            .iter()
            .filter_map(|function| match self.compare(function) {
                Ok(Some(similarity)) => Some(Ok((function.address(), similarity))),
                Ok(None) => None,
                Err(e) => Some(Err(e)),
            })
            .collect()
    }

    #[allow(dead_code)]
    pub fn edges(&self) -> usize {
        self.json.edges
    }

    #[allow(dead_code)]
    pub fn chromosome(&self) -> Option<Chromosome> {
        let chromosome = self.json.chromosome.clone();
        chromosome.as_ref()?;
        Chromosome::new(chromosome.unwrap().pattern.clone(), self.config.clone()).ok()
    }

    #[allow(dead_code)]
    pub fn number_of_blocks(&self) -> usize {
        self.json.number_of_blocks
    }

    #[allow(dead_code)]
    pub fn number_of_instructions(&self) -> usize {
        self.json.number_of_instructions
    }

    #[allow(dead_code)]
    pub fn json(&self) -> Result<String, Error> {
        let result = serde_json::to_string(&self.json)?;
        Ok(result)
    }

    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }
}

/// Represents a control flow function within a graph.
#[derive(Clone)]
pub struct Function<'function> {
    /// The starting address of the function.
    pub address: u64,
    /// The control flow graph this function belongs to.
    pub cfg: &'function Graph,
    /// The blocks that make up the function, mapped by their start addresses.
    pub blocks: BTreeMap<u64, Block<'function>>,
}

impl<'function> Function<'function> {
    /// Creates a new `Function` instance for the given address in the control flow graph.
    ///
    /// # Arguments
    ///
    /// * `address` - The starting address of the function.
    /// * `cfg` - A reference to the control flow graph the function belongs to.
    ///
    /// # Returns
    ///
    /// Returns `Ok(Function)` if the function is valid; otherwise,
    /// returns an `Err` with an appropriate error message.
    pub fn new(address: u64, cfg: &'function Graph) -> Result<Self, Error> {
        if !cfg.functions.is_valid(address) {
            return Err(Error::other(format!(
                "Function -> 0x{:x}: is not valid",
                address
            )));
        }

        let mut blocks = BTreeMap::<u64, Block>::new();

        let mut queue = GraphQueue::new();

        queue.enqueue(address);

        while let Some(block_address) = queue.dequeue() {
            queue.insert_processed(block_address);
            if cfg.blocks.is_invalid(block_address) {
                return Err(Error::other(format!(
                    "Function -> 0x{:x} -> Block -> 0x{:x}: is invalid",
                    address, block_address
                )));
            }
            if let Ok(block) = Block::new(block_address, cfg) {
                queue.enqueue_extend(block.blocks());
                blocks.insert(block_address, block);
            }
        }

        Ok(Self {
            address,
            cfg,
            blocks,
        })
    }

    pub fn address(&self) -> u64 {
        self.address
    }

    #[allow(dead_code)]
    pub fn architecture(&self) -> Architecture {
        self.cfg.architecture
    }

    /// Calculates the average instructions per block in the function.
    ///
    /// # Returns
    ///
    /// Returns a `usize` representing the average instrucitons per block.
    pub fn average_instructions_per_block(&self) -> f64 {
        self.number_of_instructions() as f64 / self.blocks.len() as f64
    }

    /// Calculates the cyclomatic complexity of the function.
    ///
    /// # Returns
    ///
    /// Returns a `usize` representing the cyclomatic complexity.
    pub fn cyclomatic_complexity(&self) -> usize {
        let nodes = self.blocks.len();
        let edges = self.edges();
        let components = 1;
        if edges < nodes {
            return 0;
        }
        edges - nodes + 2 * components
    }

    /// Processes the function into its JSON-serializable representation.
    ///
    /// # Returns
    ///
    /// Returns a `FunctionJson` struct containing metadata about the function.
    pub fn process(&self) -> FunctionJson {
        FunctionJson {
            address: self.address,
            type_: "function".to_string(),
            edges: self.edges(),
            prologue: self.prologue(),
            chromosome: self.chromosome_json(),
            chromosome_minhash_ratio: self.chromosome_minhash_ratio(),
            chromosome_tlsh_ratio: self.chromosome_tlsh_ratio(),
            minhash_ratio: self.minhash_ratio(),
            tlsh_ratio: self.tlsh_ratio(),
            bytes: self.bytes_to_hex(),
            size: self.size(),
            functions: self.functions(),
            blocks: self.blocks_json(),
            number_of_blocks: self.number_of_blocks(),
            number_of_instructions: self.number_of_instructions(),
            cyclomatic_complexity: self.cyclomatic_complexity(),
            average_instructions_per_block: self.average_instructions_per_block(),
            entropy: self.entropy(),
            sha256: self.sha256(),
            minhash: self.minhash(),
            tlsh: self.tlsh(),
            contiguous: self.contiguous(),
            architecture: self.architecture().to_string(),
            attributes: None,
        }
    }

    /// Compares this block to another for similarity.
    ///
    /// # Returns
    ///
    /// Returns `Option<ChromosomeSimilarity>` representing the similarity between this block to another.
    pub fn compare(&self, rhs: &Function) -> Result<Option<ChromosomeSimilarity>, Error> {
        if self.contiguous() && rhs.contiguous() {
            let lhs_chromosome = self.chromosome();
            let rhs_chromosome = rhs.chromosome();
            if lhs_chromosome.is_none() && rhs_chromosome.is_none() {
                return Ok(None);
            }
            return Ok(self
                .chromosome()
                .unwrap()
                .compare(&rhs.chromosome().unwrap()));
        }

        let mut minhashes = Vec::<f64>::new();
        let mut tls_values = Vec::<f64>::new();

        for lhs_block in self.blocks() {
            let mut best_minhash: Option<f64> = None;
            let mut best_tls: Option<f64> = None;

            let results = match lhs_block.compare_many(rhs.blocks()) {
                Ok(results) => results,
                Err(error) => {
                    return Err(Error::new(ErrorKind::InvalidData, format!("{}", error)));
                }
            };

            for (_, similarity) in results {
                let minhash = similarity.score().minhash();
                let tlsh = similarity.score.minhash();
                if minhash.is_none() && tlsh.is_none() {
                    continue;
                }
                if let Some(mh) = minhash {
                    best_minhash = Some(best_minhash.map_or(mh, |prev| prev.max(mh)));
                }

                if let Some(t) = tlsh {
                    best_tls = Some(best_tls.map_or(t, |prev| prev.min(t)));
                }
            }

            if let Some(mh) = best_minhash {
                minhashes.push(mh);
            }

            if let Some(t) = best_tls {
                tls_values.push(t);
            }
        }

        if !minhashes.is_empty() || !tls_values.is_empty() {
            let minhash_average = {
                let avg = minhashes.iter().sum::<f64>() / minhashes.len() as f64;
                if avg > 0.0 {
                    Some(avg)
                } else {
                    None
                }
            };

            let tlsh_average = {
                let avg = tls_values.iter().sum::<f64>() / tls_values.len() as f64;
                if avg > 0.0 {
                    Some(avg)
                } else {
                    None
                }
            };

            if minhash_average.is_none() && tlsh_average.is_none() {
                return Ok(None);
            }

            return Ok(Some(ChromosomeSimilarity {
                score: ChromosomeSimilarityScore {
                    minhash: minhash_average,
                    tlsh: tlsh_average,
                },
                homologues: Vec::<HomologousChromosome>::new(),
            }));
        }

        Ok(None)
    }

    pub fn compare_many(
        &self,
        rhs_functions: Vec<Function>,
    ) -> Result<BTreeMap<u64, ChromosomeSimilarity>, Error> {
        let result: Result<BTreeMap<u64, ChromosomeSimilarity>, Error> = rhs_functions
            .iter()
            .filter_map(|function| match self.compare(function) {
                Ok(Some(similarity)) => Some(Ok((function.address(), similarity))),
                Ok(None) => None,
                Err(e) => Some(Err(e)),
            })
            .collect();

        result
    }

    pub fn chromosome_tlsh_ratio(&self) -> f64 {
        if self.contiguous() {
            return 1.0;
        }
        let mut tlsh_size: usize = 0;
        for block in self.blocks() {
            if block.chromosome().tlsh().is_some() {
                tlsh_size += block.size();
            }
        }
        tlsh_size as f64 / self.size() as f64
    }

    pub fn chromosome_minhash_ratio(&self) -> f64 {
        if self.contiguous() {
            return 1.0;
        }
        let mut minhash_size: usize = 0;
        for block in self.blocks() {
            if block.chromosome().minhash().is_some() {
                minhash_size += block.size();
            }
        }
        minhash_size as f64 / self.size() as f64
    }

    pub fn tlsh_ratio(&self) -> f64 {
        if self.contiguous() {
            return 1.0;
        }
        let mut tlsh_size: usize = 0;
        for block in self.blocks() {
            if block.tlsh().is_some() {
                tlsh_size += block.size();
            }
        }
        tlsh_size as f64 / self.size() as f64
    }

    pub fn minhash_ratio(&self) -> f64 {
        if self.contiguous() {
            return 1.0;
        }
        let mut minhash_size: usize = 0;
        for block in self.blocks() {
            if block.minhash().is_some() {
                minhash_size += block.size();
            }
        }
        minhash_size as f64 / self.size() as f64
    }

    /// Retrives the number of blocks in the function.
    ///
    /// # Returns
    ///
    /// Returns `usize` representing the number of blocks in the function.
    pub fn number_of_blocks(&self) -> usize {
        self.blocks.len()
    }

    /// Processes the function into its JSON-serializable representation including `Attributes`
    ///
    /// # Returns
    ///
    /// Returns a `FunctionJson` instance containing the function's metadata and `Attributes`.
    pub fn process_with_attributes(&self, attributes: Attributes) -> FunctionJson {
        let mut result = self.process();
        result.attributes = Some(attributes.process());
        result
    }

    /// Prints the JSON representation of the function to standard output.
    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }

    /// Converts the function metadata into a JSON string representation.
    ///
    /// # Returns
    ///
    /// Returns `Ok(String)` containing the JSON representation, or an `Err` if serialization fails.
    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    /// Converts the function metadata into a JSON string representation including `Attributes`.
    ///
    /// # Returns
    ///
    /// Returns `Ok(String)` containing the JSON representation, or an `Err` if serialization fails.
    pub fn json_with_attributes(&self, attributes: Attributes) -> Result<String, Error> {
        let raw = self.process_with_attributes(attributes);
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    /// Generates the function's chromosome if the function is contiguous.
    ///
    /// # Returns
    ///
    /// Returns `Some(Chromosome)` if the function is contiguous; otherwise, `None`.
    pub fn chromosome(&self) -> Option<Chromosome> {
        if !self.contiguous() {
            return None;
        }
        let bytes = self.bytes();
        bytes.as_ref()?;
        let pattern = self.pattern()?;
        let chromosome = Chromosome::new(pattern, self.cfg.config.clone()).ok()?;
        Some(chromosome)
    }

    /// Generates the function's chromosome JSON if the function is contiguous.
    ///
    /// # Returns
    ///
    /// Returns `Some(ChromosomeJson)` if the function is contiguous; otherwise, `None`.
    pub fn chromosome_json(&self) -> Option<ChromosomeJson> {
        if !self.contiguous() {
            return None;
        }
        let bytes = self.bytes();
        bytes.as_ref()?;
        let pattern = self.pattern()?;
        let chromosome = Chromosome::new(pattern, self.cfg.config.clone()).ok()?;
        Some(chromosome.process())
    }

    /// Retrieves the pattern string representation of the chromosome.
    ///
    /// # Returns
    ///
    /// Returns a `Option<String>` containing the pattern representation of the chromosome.
    pub fn pattern(&self) -> Option<String> {
        if !self.contiguous() {
            return None;
        }
        let mut result = String::new();
        for entry in self
            .cfg
            .listing
            .range(self.address..self.address + self.size() as u64)
        {
            let instruction = entry.value();
            result += instruction.pattern.as_str();
        }
        Some(result)
    }

    /// Retrieves the total number of instructions in the function.
    ///
    /// # Returns
    ///
    /// Returns the number of instructions as a `usize`.
    pub fn number_of_instructions(&self) -> usize {
        self.blocks
            .values()
            .map(|block| block.number_of_instructions())
            .sum()
    }

    /// Indicates whether this function starts with a prologue.
    ///
    /// # Returns
    ///
    /// Returns `true` if the function starts with a prologue; otherwise, `false`.
    pub fn prologue(&self) -> bool {
        if let Some((_, block)) = self.blocks.iter().next() {
            return block.prologue();
        }
        false
    }

    /// Retrieves the blocks associated with this function.
    ///
    /// # Returns
    ///
    /// Returns a `Vec<Block>` representing the blocks associated with this function.
    pub fn blocks(&self) -> Vec<Block> {
        if !self.cfg.config.functions.blocks.enabled {
            return Vec::new();
        }
        self.blocks
            .keys()
            .filter_map(|&block_address| Block::new(block_address, self.cfg).ok())
            .collect()
    }

    /// Retrieves the blocks associated with this function.
    ///
    /// # Returns
    ///
    /// Returns a `Vec<BlockJson>` representing the blocks associated with this function.
    pub fn blocks_json(&self) -> Vec<BlockJson> {
        let mut result = Vec::<BlockJson>::new();
        if !self.cfg.config.functions.blocks.enabled {
            return result;
        }
        for block_address in self.blocks.keys() {
            let block = Block::new(*block_address, self.cfg)
                .expect("failed to get block associated with function");
            result.push(block.process());
        }
        result
    }

    /// Retrieves the number of edges (connections) in the function.
    ///
    /// # Returns
    ///
    /// Returns the number of edges as a `usize`.
    pub fn edges(&self) -> usize {
        self.blocks.values().map(|block| block.edges()).sum()
    }

    /// Converts the function's bytes to a hexadecimal string, if available.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the hexadecimal representation of the bytes, or `None` if unavailable.
    fn bytes_to_hex(&self) -> Option<String> {
        if let Some(bytes) = self.bytes() {
            return Some(Binary::to_hex(&bytes));
        }
        None
    }

    /// Retrieves the size of the function in bytes, if contiguous.
    ///
    /// # Returns
    ///
    /// Returns `Some(usize)` if the function is contiguous; otherwise, `None`.
    pub fn size(&self) -> usize {
        if self.blocks.is_empty() {
            return 0;
        }
        let end = self
            .blocks
            .values()
            .map(|b| b.address + b.size() as u64)
            .max()
            .unwrap_or(self.address);
        (end - self.address) as usize
    }

    /// Retrieves the address of the function's last instruction, if contiguous.
    ///
    /// # Returns
    ///
    /// Returns `Some(u64)` containing the address, or `None` if the function is not contiguous.
    pub fn end(&self) -> Option<u64> {
        if !self.contiguous() {
            return None;
        }
        if let Some((_, block)) = self.blocks.iter().last() {
            return Some(block.end());
        }
        None
    }

    /// Retrieves the raw bytes of the function, if contiguous.
    ///
    /// # Returns
    ///
    /// Returns `Some(Vec<u8>)` containing the bytes, or `None` if the function is not contiguous.
    pub fn bytes(&self) -> Option<Vec<u8>> {
        if self.blocks.is_empty() {
            return None;
        }
        let end = self
            .blocks
            .values()
            .map(|b| b.address + b.size() as u64)
            .max()
            .unwrap_or(self.address);
        let mut bytes = Vec::<u8>::new();
        let mut pc = self.address;
        while pc < end {
            let instruction = match self.cfg.get_instruction(pc) {
                Some(i) => i,
                None => return None,
            };
            bytes.extend(&instruction.bytes);
            pc += instruction.size() as u64;
        }
        Some(bytes)
    }

    /// Computes the SHA-256 hash of the function's bytes, if enabled and contiguous.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the hash, or `None` if SHA-256 is disabled or the function is not contiguous.
    pub fn sha256(&self) -> Option<String> {
        if !self.cfg.config.functions.hashing.sha256.enabled {
            return None;
        }
        if !self.contiguous() {
            return None;
        }
        if let Some(bytes) = self.bytes() {
            return SHA256::new(&bytes).hexdigest();
        }
        None
    }

    /// Computes the entropy of the function's bytes, if enabled and contiguous.
    ///
    /// # Returns
    ///
    /// Returns `Some(f64)` containing the entropy, or `None` if entropy calculation is disabled or the function is not contiguous.
    pub fn entropy(&self) -> Option<f64> {
        if !self.cfg.config.functions.heuristics.entropy.enabled {
            return None;
        }

        if self.contiguous() {
            return self.bytes().and_then(|bytes| Binary::entropy(&bytes));
        }

        let entropi: Vec<f64> = self
            .blocks
            .values()
            .filter_map(|block| block.entropy())
            .collect();

        if entropi.is_empty() {
            Some(0.0)
        } else {
            Some(entropi.iter().sum::<f64>() / entropi.len() as f64)
        }
    }

    /// Computes the TLSH of the function's bytes, if enabled and contiguous.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the TLSH, or `None` if TLSH is disabled or the function is not contiguous.
    pub fn tlsh(&self) -> Option<String> {
        if !self.cfg.config.functions.hashing.tlsh.enabled {
            return None;
        }
        if !self.contiguous() {
            return None;
        }
        if let Some(bytes) = self.bytes() {
            return TLSH::new(
                &bytes,
                self.cfg.config.functions.hashing.tlsh.minimum_byte_size,
            )
            .hexdigest();
        }
        None
    }

    /// Computes the MinHash of the function's bytes, if enabled and contiguous.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the MinHash, or `None` if MinHash is disabled or the function is not contiguous.
    pub fn minhash(&self) -> Option<String> {
        if !self.cfg.config.functions.hashing.minhash.enabled {
            return None;
        }
        if !self.contiguous() {
            return None;
        }
        if let Some(bytes) = self.bytes() {
            if bytes.len() > self.cfg.config.functions.hashing.minhash.maximum_byte_size
                && self
                    .cfg
                    .config
                    .functions
                    .hashing
                    .minhash
                    .maximum_byte_size_enabled
            {
                return None;
            }
            return MinHash32::new(
                &bytes,
                self.cfg.config.functions.hashing.minhash.number_of_hashes,
                self.cfg.config.functions.hashing.minhash.shingle_size,
                self.cfg.config.functions.hashing.minhash.seed,
            )
            .hexdigest();
        }
        None
    }

    /// Retrieves the functions associated with this function.
    ///
    /// # Returns
    ///
    /// Returns a `BTreeMap<u64, u64>` containing function addresses.
    pub fn functions(&self) -> BTreeMap<u64, u64> {
        self.blocks
            .values()
            .flat_map(|block| block.functions())
            .collect()
    }

    /// Checks whether the function is contiguous in memory.
    ///
    /// # Returns
    ///
    /// Returns `true` if the function is contiguous; otherwise, `false`.
    pub fn contiguous(&self) -> bool {
        if self.blocks.is_empty() {
            return false;
        }
        let end = self
            .blocks
            .values()
            .map(|b| b.address + b.size() as u64)
            .max()
            .unwrap_or(self.address);
        let mut pc = self.address;
        while pc < end {
            match self.cfg.get_instruction(pc) {
                Some(instr) => pc += instr.size() as u64,
                None => return false,
            }
        }
        true
    }
}

```

`src/controlflow/graph.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Block;
use crate::controlflow::Function;
use crate::controlflow::Instruction;
use crate::Architecture;
use crate::Config;
use crossbeam::queue::SegQueue;
use crossbeam_skiplist::SkipMap;
use crossbeam_skiplist::SkipSet;
use std::collections::BTreeSet;

/// Queue structure used within `Graph` for managing addresses in processing stages.
pub struct GraphQueue {
    /// Queue of addresses to be processed.
    pub queue: SegQueue<u64>,
    /// Set of addresses that have been processed.
    pub processed: SkipSet<u64>,
    /// Set of valid addresses in the graph.
    pub valid: SkipSet<u64>,
    /// Set of invalid addresses in the graph.
    pub invalid: SkipSet<u64>,
    /// Pending addresses in the graph.
    pub pending: SkipSet<u64>,
}

impl Clone for GraphQueue {
    /// Creates a clone of the `GraphQueue`, including all processed, valid, and invalid addresses.
    fn clone(&self) -> Self {
        let cloned_queue = SegQueue::new();
        let mut temp_queue = Vec::new();
        while let Some(item) = self.queue.pop() {
            cloned_queue.push(item);
            temp_queue.push(item);
        }
        for item in temp_queue {
            self.queue.push(item);
        }
        let cloned_processed = SkipSet::new();
        for item in self.processed.iter() {
            cloned_processed.insert(*item);
        }
        let cloned_valid = SkipSet::new();
        for item in self.valid.iter() {
            cloned_valid.insert(*item);
        }
        let cloned_invalid = SkipSet::new();
        for item in self.invalid.iter() {
            cloned_invalid.insert(*item);
        }
        let cloned_pending = SkipSet::new();
        for item in self.pending.iter() {
            cloned_pending.insert(*item);
        }
        GraphQueue {
            queue: cloned_queue,
            processed: cloned_processed,
            valid: cloned_valid,
            invalid: cloned_invalid,
            pending: cloned_pending,
        }
    }
}

impl GraphQueue {
    /// Creates a new, empty `GraphQueue` instance.
    ///
    /// # Returns
    ///
    /// Returns a new `GraphQueue` instance with empty sets and queues.
    pub fn new() -> Self {
        Self {
            queue: SegQueue::<u64>::new(),
            processed: SkipSet::<u64>::new(),
            valid: SkipSet::<u64>::new(),
            invalid: SkipSet::<u64>::new(),
            pending: SkipSet::<u64>::new(),
        }
    }

    /// Marks an address as invalid if it has not been marked as valid.
    ///
    /// # Arguments
    ///
    /// * `address` - The address to mark as invalid.
    pub fn insert_invalid(&mut self, address: u64) {
        if !self.is_invalid(address) && !self.is_valid(address) {
            self.invalid.insert(address);
        }
    }

    /// Checks if an address is marked as invalid.
    ///
    /// # Returns
    ///
    /// Returns `true` if the address is invalid, otherwise `false`.
    pub fn is_invalid(&self, address: u64) -> bool {
        self.invalid.contains(&address)
    }

    /// Retrieves a reference to the invalid address set.
    ///
    /// # Returns
    ///
    /// Returns a reference to the `SkipSet` containing invalid addresses.
    #[allow(dead_code)]
    pub fn invalid(&self) -> &SkipSet<u64> {
        &self.invalid
    }

    /// Retrieves a reference to the valid address set.
    ///
    /// # Returns
    ///
    /// Returns a reference to the `SkipSet` containing valid addresses.
    pub fn valid(&self) -> &SkipSet<u64> {
        &self.valid
    }

    /// Collects valid addresses in a set
    ///
    /// # Returns
    ///
    /// Returns a `BTreeSet` containing valid addresses.
    pub fn valid_addresses(&self) -> BTreeSet<u64> {
        let mut result = BTreeSet::<u64>::new();
        for entry in self.valid() {
            result.insert(*entry.value());
        }
        result
    }

    /// Collects invalid addresses in a set
    ///
    /// # Returns
    ///
    /// Returns a `BTreeSet` containing valid addresses.
    pub fn invalid_addresses(&self) -> BTreeSet<u64> {
        let mut result = BTreeSet::<u64>::new();
        for entry in self.invalid() {
            result.insert(*entry.value());
        }
        result
    }

    /// Collects processed addresses in a set
    ///
    /// # Returns
    ///
    /// Returns a `BTreeSet` containing processed addresses.
    pub fn processed_addresses(&self) -> BTreeSet<u64> {
        let mut result = BTreeSet::<u64>::new();
        for entry in self.processed() {
            result.insert(*entry.value());
        }
        result
    }

    /// Retrieves a reference to the processed address set.
    ///
    /// # Returns
    ///
    /// Returns a reference to the `SkipSet` containing processed addresses.
    pub fn processed(&self) -> &SkipSet<u64> {
        &self.processed
    }

    /// Checks if an address is marked as valid.
    ///
    /// # Returns
    ///
    /// Returns `true` if the address is valid, otherwise `false`.
    pub fn is_valid(&self, address: u64) -> bool {
        self.valid.contains(&address)
    }

    /// Marks an address as valid if it has been processed.
    ///
    /// # Arguments
    ///
    /// * `address` - The address to mark as valid.
    pub fn insert_valid(&mut self, address: u64) {
        if self.is_processed(address) {
            self.valid.insert(address);
        }
    }

    /// Marks multiple addresses as processed.
    ///
    /// # Arguments
    ///
    /// * `addresses` - A set of addresses to mark as processed.
    pub fn insert_processed_extend(&mut self, addresses: BTreeSet<u64>) {
        for address in addresses {
            self.insert_processed(address);
        }
    }

    /// Marks a single address as processed.
    ///
    /// # Arguments
    ///
    /// * `address` - The address to mark as processed.
    pub fn insert_processed(&mut self, address: u64) {
        self.processed.insert(address);
    }

    /// Checks if an address has been processed.
    ///
    /// # Returns
    ///
    /// Returns `true` if the address is processed, otherwise `false`.
    pub fn is_processed(&self, address: u64) -> bool {
        self.processed.contains(&address)
    }

    /// Adds multiple addresses to the processing queue.
    ///
    /// # Arguments
    ///
    /// * `addresses` - A set of addresses to enqueue.
    pub fn enqueue_extend(&mut self, addresses: BTreeSet<u64>) {
        for address in addresses {
            self.enqueue(address);
        }
    }

    /// Adds an address to the processing queue if it hasn't been processed.
    ///
    /// # Returns
    ///
    /// Returns `true` if the address was enqueued, otherwise `false`.
    pub fn enqueue(&mut self, address: u64) -> bool {
        if self.is_processed(address) {
            return false;
        }
        if self.pending.contains(&address) {
            return false;
        }
        self.pending.insert(address);
        self.queue.push(address);
        true
    }

    /// Checks if an address is currently pending in the queue.
    ///
    /// # Returns
    ///
    /// Returns `true` if the address is pending processing, otherwise `false`.
    pub fn is_pending(&self, address: u64) -> bool {
        self.pending.contains(&address)
    }

    /// Removes an address from the processing queue.
    ///
    /// # Returns
    ///
    /// Returns `Some(u64)` containing the dequeued address if available, otherwise `None`.
    pub fn dequeue(&mut self) -> Option<u64> {
        if let Some(x) = self.queue.pop() {
            self.pending.remove(&x);
            return Some(x);
        }
        None
    }

    /// Removes all addresses from the processing queue.
    ///
    /// # Returns
    ///
    /// Returns a `BTreeSet<u64>` containing all dequeued addresses.
    pub fn dequeue_all(&mut self) -> BTreeSet<u64> {
        let mut set = BTreeSet::new();
        while let Some(address) = self.queue.pop() {
            self.pending.remove(&address);
            set.insert(address);
        }
        set
    }
}

impl Default for GraphQueue {
    fn default() -> Self {
        Self::new()
    }
}

/// Represents a control flow graph with instructions, blocks, and functions.
pub struct Graph {
    /// The Instruction Architecture
    pub architecture: Architecture,
    /// A map of instruction addresses to `Instruction` instances.
    pub listing: SkipMap<u64, Instruction>,
    /// Queue for managing basic blocks within the graph.
    pub blocks: GraphQueue,
    /// Queue for managing functions within the graph.
    pub functions: GraphQueue,
    /// Queue for managing instructions within the graph.
    pub instructions: GraphQueue,
    /// Configuration
    pub config: Config,
}

impl Graph {
    /// Creates a new, empty `Graph` instance with default options.
    ///
    /// # Returns
    ///
    /// Returns a `Graph` instance with empty instructions, blocks, and functions.
    #[allow(dead_code)]
    pub fn new(architecture: Architecture, config: Config) -> Self {
        Self {
            architecture,
            listing: SkipMap::<u64, Instruction>::new(),
            blocks: GraphQueue::new(),
            functions: GraphQueue::new(),
            instructions: GraphQueue::new(),
            config,
        }
    }

    pub fn instructions(&self) -> Vec<Instruction> {
        let mut result = Vec::<Instruction>::new();
        for address in self.instructions.valid_addresses() {
            let instruction = Instruction::new(address, self).ok();
            if instruction.is_none() {
                continue;
            }
            result.push(instruction.unwrap());
        }
        result
    }

    pub fn blocks(&self) -> Vec<Block> {
        let mut result = Vec::<Block>::new();
        for address in self.blocks.valid_addresses() {
            let block = Block::new(address, self).ok();
            if block.is_none() {
                continue;
            }
            result.push(block.unwrap());
        }
        result
    }

    pub fn functions(&self) -> Vec<Function> {
        let mut result = Vec::<Function>::new();
        for address in self.functions.valid_addresses() {
            let function = Function::new(address, self).ok();
            if function.is_none() {
                continue;
            }
            result.push(function.unwrap());
        }
        result
    }

    pub fn instruction_addresses(&self) -> BTreeSet<u64> {
        let mut result = BTreeSet::<u64>::new();
        for entry in &self.listing {
            result.insert(*entry.key());
        }
        result
    }

    pub fn listing(&self) -> &SkipMap<u64, Instruction> {
        &self.listing
    }

    pub fn set_function(&mut self, address: u64) -> bool {
        let mut instruction = match self.get_instruction(address) {
            Some(instruction) => instruction,
            None => {
                return false;
            }
        };
        self.functions.insert_processed(address);
        self.functions.insert_valid(address);
        instruction.is_function_start = true;
        instruction.is_block_start = true;
        self.update_instruction(instruction);
        true
    }

    pub fn set_block(&mut self, address: u64) -> bool {
        let mut instruction = match self.get_instruction(address) {
            Some(instruction) => instruction,
            None => {
                return false;
            }
        };
        self.blocks.insert_processed(address);
        self.blocks.insert_valid(address);
        instruction.is_block_start = true;
        self.update_instruction(instruction);
        true
    }

    pub fn extend_instruction_edges(&mut self, address: u64, addresses: BTreeSet<u64>) -> bool {
        let mut instruction = match self.get_instruction(address) {
            Some(instruction) => instruction,
            None => {
                return false;
            }
        };
        instruction.to.extend(addresses);
        self.update_instruction(instruction);
        true
    }

    pub fn insert_instruction(&mut self, instruction: Instruction) {
        if !self.is_instruction_address(instruction.address) {
            self.listing.insert(instruction.address, instruction);
        }
    }

    pub fn update_instruction(&mut self, instruction: Instruction) {
        if !self.is_instruction_address(instruction.address) {
            return;
        }
        self.listing.insert(instruction.address, instruction);
    }

    pub fn is_instruction_address(&self, address: u64) -> bool {
        self.listing.contains_key(&address)
    }

    pub fn get_instruction(&self, address: u64) -> Option<Instruction> {
        self.listing
            .get(&address)
            .map(|entry| entry.value().clone())
    }
    pub fn absorb(&mut self, graph: &mut Graph) {
        for entry in graph.listing() {
            self.insert_instruction(entry.value().clone());
        }

        for entry in graph.instructions.processed() {
            self.instructions.insert_processed(*entry.value());
        }

        self.instructions
            .enqueue_extend(graph.instructions.dequeue_all());

        for entry in graph.blocks.processed() {
            self.blocks.insert_processed(*entry.value());
        }

        self.blocks.enqueue_extend(graph.blocks.dequeue_all());

        for entry in graph.functions.processed() {
            self.functions.insert_processed(*entry.value());
        }

        self.functions.enqueue_extend(graph.functions.dequeue_all());

        for entry in graph.instructions.valid() {
            self.instructions.insert_valid(*entry.value());
        }

        for entry in graph.instructions.invalid() {
            self.instructions.insert_invalid(*entry.value());
        }

        for entry in graph.blocks.valid() {
            self.blocks.insert_valid(*entry.value());
        }

        for entry in graph.blocks.invalid() {
            self.blocks.insert_invalid(*entry.value());
        }

        for entry in graph.functions.valid() {
            self.functions.insert_valid(*entry.value());
        }

        for entry in graph.functions.invalid() {
            self.functions.insert_invalid(*entry.value());
        }
    }
}

```

`src/controlflow/instruction.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::binary::Binary;
use crate::controlflow::Attributes;
use crate::controlflow::Graph;
use crate::genetics::Chromosome;
use crate::genetics::ChromosomeJson;
use crate::genetics::ChromosomeSimilarity;
use crate::Architecture;
use crate::Config;
use serde::{Deserialize, Serialize};
use serde_json;
use serde_json::Value;
use std::{collections::BTreeSet, io::Error};

/// Represents a single instruction in disassembled binary code.
///
/// This struct encapsulates metadata and properties of an instruction,
/// such as its address, type, and relationships with other instructions.
#[derive(Clone)]
pub struct Instruction {
    // The instruction architecture
    pub architecture: Architecture,
    /// The configuration
    pub config: Config,
    /// The address of the instruction in memory.
    pub address: u64,
    /// Indicates whether this instruction is part of a function prologue.
    pub is_prologue: bool,
    /// Indicates whether this instruction is the start of a basic block.
    pub is_block_start: bool,
    /// Indicates whether this instruction is the start of a function.
    pub is_function_start: bool,
    /// The raw bytes of the instruction.
    pub bytes: Vec<u8>,
    /// The signature pattern of the instruction.
    pub pattern: String,
    /// Indicates whether this instruction is a return instruction.
    pub is_return: bool,
    /// Indicates whether this instruction is a call instruction.
    pub is_call: bool,
    /// A set of functions that this instruction may belong to.
    pub functions: BTreeSet<u64>,
    /// Indicates whether this instruction is a jump instruction.
    pub is_jump: bool,
    /// Indicates whether this instruction is a conditional instruction.
    pub is_conditional: bool,
    /// Indicates whether this instruction is a trap instruction.
    pub is_trap: bool,
    /// A set of addresses this instruction may jump or branch to.
    pub to: BTreeSet<u64>,
    /// The number of edges (connections) for this instruction.
    pub edges: usize,
}

/// Represents a JSON-serializable view of an `Instruction`.
#[derive(Serialize, Deserialize, Clone)]
pub struct InstructionJson {
    /// The type of this entity, always `"instruction"`.
    #[serde(rename = "type")]
    pub type_: String,
    // The architecture of the instruction.
    pub architecture: String,
    /// The address of the instruction in memory.
    pub address: u64,
    /// Indicates whether this instruction is part of a function prologue.
    pub is_prologue: bool,
    /// Indicates whether this instruction is the start of a basic block.
    pub is_block_start: bool,
    /// Indicates whether this instruction is the start of a function.
    pub is_function_start: bool,
    /// Indicates whether this instruction is a call instruction.
    pub is_call: bool,
    /// Indicates whether this instruction is a return instruction.
    pub is_return: bool,
    /// Indicates whether this instruction is a jump instruction.
    pub is_jump: bool,
    /// Indicates whether this instruction is a trap instruction.
    pub is_trap: bool,
    /// Indicates whether this instruction is conditional.
    pub is_conditional: bool,
    /// The number of edges (connections) for this instruction.
    pub edges: usize,
    /// The raw bytes of the instruction in hexadecimal format.
    pub bytes: String,
    /// The size of the instruction in bytes.
    pub size: usize,
    /// The chromosome
    pub chromosome: ChromosomeJson,
    /// A set of functions that this instruction may belong to.
    pub functions: BTreeSet<u64>,
    /// A set of addresses for the blocks this instruction may branch to.
    pub blocks: BTreeSet<u64>,
    /// A set of addresses this instruction may jump or branch to.
    pub to: BTreeSet<u64>,
    /// The address of the next sequential instruction, if any.
    pub next: Option<u64>,
    /// Attributes
    pub attributes: Option<Value>,
}

impl InstructionJson {
    /// Converts a JSON string into a `InstructionJson` object.
    ///
    /// # Returns
    ///
    /// Returns `Ok(InstructionJson)` if the JSON is valid; otherwise, returns an `Err`.
    pub fn from_json(json_str: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json_str)
    }
}

impl Instruction {
    /// Creates a new `Instruction` with the specified address.
    ///
    /// # Arguments
    ///
    /// * `address` - The memory address of the instruction.
    ///
    /// # Returns
    ///
    /// Returns a new `Instruction` with default values for its properties.
    #[allow(dead_code)]
    pub fn create(address: u64, architecture: Architecture, config: Config) -> Self {
        Self {
            address,
            is_prologue: false,
            is_block_start: false,
            is_function_start: false,
            bytes: Vec::<u8>::new(),
            pattern: String::new(),
            is_call: false,
            is_return: false,
            functions: BTreeSet::<u64>::new(),
            is_conditional: false,
            is_jump: false,
            to: BTreeSet::<u64>::new(),
            edges: 0,
            is_trap: false,
            architecture,
            config,
        }
    }

    /// Retrieves an `Instruction` from the control flow graph if available.
    ///
    /// # Returns
    ///
    /// Returns a `Result<Instruction, Error>` containing the `Instruction`.
    pub fn new(address: u64, cfg: &Graph) -> Result<Instruction, Error> {
        let instruction = cfg.get_instruction(address);
        if instruction.is_none() {
            return Err(Error::other("instruction does not exist"));
        }
        Ok(instruction.unwrap())
    }

    /// Retrieves the set of addresses for the blocks this instruction may branch to.
    ///
    /// # Returns
    ///
    /// Returns a `BTreeSet<u64>` containing the block addresses.
    pub fn blocks(&self) -> BTreeSet<u64> {
        let mut result = BTreeSet::new();
        if !self.is_jump {
            return result;
        }
        for item in self.to.iter().copied().chain(self.next()) {
            result.insert(item);
        }
        result
    }

    /// Compares this instruction to another for similarity.
    ///
    /// # Returns
    ///
    /// Returns `Option<ChromosomeSimilarity>` representing the similarity between this instruction to another.
    pub fn compare(&self, rhs: &Instruction) -> Option<ChromosomeSimilarity> {
        self.chromosome().compare(&rhs.chromosome())
    }

    /// Retrieves the address of the next sequential instruction.
    ///
    /// # Returns
    ///
    /// Returns `Some(u64)` containing the address of the next instruction, or `None`
    /// if the current instruction is a return or trap instruction.
    pub fn next(&self) -> Option<u64> {
        if self.is_jump && !self.is_conditional {
            return None;
        }
        if self.is_return {
            return None;
        }
        if self.is_trap {
            return None;
        }
        Some(self.address + self.size() as u64)
    }

    /// Computes the size of the instruction in bytes.
    ///
    /// # Returns
    ///
    /// Returns the size of the instruction as a `usize`.
    #[allow(dead_code)]
    pub fn size(&self) -> usize {
        self.bytes.len()
    }

    /// Converts the `Instruction` into its JSON-serializable representation.
    ///
    /// # Returns
    ///
    /// Returns an `InstructionJson` struct containing the properties of the instruction.
    #[allow(dead_code)]
    pub fn process(&self) -> InstructionJson {
        InstructionJson {
            type_: "instruction".to_string(),
            architecture: self.architecture.to_string(),
            address: self.address,
            is_block_start: self.is_block_start,
            bytes: Binary::to_hex(&self.bytes),
            size: self.size(),
            chromosome: self.chromosome_json(),
            is_return: self.is_return,
            is_trap: self.is_trap,
            is_call: self.is_call,
            is_jump: self.is_jump,
            is_conditional: self.is_conditional,
            is_function_start: self.is_function_start,
            is_prologue: self.is_prologue,
            edges: self.edges,
            functions: self.functions(),
            blocks: self.blocks(),
            to: self.to(),
            next: self.next(),
            attributes: None,
        }
    }

    pub fn pattern(&self) -> String {
        self.pattern.clone()
    }

    /// Retrieves the chromosome representing the instruction.
    ///
    /// # Returns
    ///
    /// Returns a `Chromosome` represnting the instruction.
    pub fn chromosome(&self) -> Chromosome {
        Chromosome::new(self.pattern.clone(), self.config.clone())
            .expect("failed to parse instruction chromosome")
    }

    /// Retrieves the chromosome representing the instruction.
    ///
    /// # Returns
    ///
    /// Returns a `ChromosomeJson` representing the instruction.
    pub fn chromosome_json(&self) -> ChromosomeJson {
        Chromosome::new(self.pattern.clone(), self.config.clone())
            .expect("failed to parse instruction chromosome")
            .process()
    }

    /// Retrieves the set of addresses this instruction may jump or branch to.
    ///
    /// # Returns
    ///
    /// Returns a `BTreeSet<u64>` containing the target addresses.
    pub fn to(&self) -> BTreeSet<u64> {
        self.to.clone()
    }

    /// Retrieves the set of functions this instruction may belong to.
    ///
    /// # Returns
    ///
    /// Returns a `BTreeSet<u64>` containing the function addresses.
    pub fn functions(&self) -> BTreeSet<u64> {
        self.functions.clone()
    }

    /// Converts the instruction into a JSON string representation including `Attributes`.
    ///
    /// # Returns
    ///
    /// Returns `Ok(String)` containing the JSON representation, or an `Err` if serialization fails.
    pub fn json_with_attributes(&self, attributes: Attributes) -> Result<String, Error> {
        let raw = self.process_with_attributes(attributes);
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    /// Processes the instruction into its JSON-serializable representation including `Attributes`.
    ///
    /// # Returns
    ///
    /// Returns a `BlockJson` instance containing the block's metadata and `Attributes`.
    pub fn process_with_attributes(&self, attributes: Attributes) -> InstructionJson {
        let mut result = self.process();
        result.attributes = Some(attributes.process());
        result
    }

    /// Converts the `Instruction` into a JSON string representation.
    ///
    /// # Returns
    ///
    /// Returns `Ok(String)` containing the JSON representation, or an `Err(Error)` if serialization fails.
    #[allow(dead_code)]
    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    /// Prints the JSON representation of the `Instruction` to standard output.
    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }
}

```

`src/controlflow/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod graph;
pub mod function;
pub mod block;
pub mod instruction;
pub mod attribute;
pub mod tag;
pub mod symbol;

pub use graph::Graph;
pub use graph::GraphQueue;
pub use function::Function;
pub use function::FunctionJson;
pub use function::FunctionJsonDeserializer;
pub use block::Block;
pub use block::BlockJson;
pub use block::BlockJsonDeserializer;
pub use instruction::Instruction;
pub use instruction::InstructionJson;
pub use attribute::Attribute;
pub use attribute::Attributes;
pub use tag::Tag;
pub use tag::TagJson;
pub use symbol::Symbol;
pub use symbol::SymbolJson;
pub use symbol::SymbolIoJson;

```

`src/controlflow/symbol.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Attribute;
use serde::{Deserialize, Serialize};
use serde_json;
use std::io::Error;

/// Represents a JSON-serializable structure containing metadata about a function symbol.
#[derive(Serialize, Deserialize)]
pub struct SymbolIoJson {
    /// The type of this entity.
    #[serde(rename = "type")]
    pub type_: String,
    /// The type of symbol
    pub symbol_type: String,
    /// Names associated with the function symbol.
    pub name: String,
    /// The offset of the function symbol, if available.
    pub file_offset: Option<u64>,
    /// The relative virtual address of the function symbol, if available.
    pub relative_virtual_address: Option<u64>,
    /// The virtual address of the function symbol, if available.
    pub virtual_address: Option<u64>,
    /// The slice associated with the function symbol, MachO format only
    pub slice: Option<usize>,
}

/// Represents a JSON-serializable structure containing metadata about a function symbol.
#[derive(Serialize, Deserialize, Clone)]
pub struct SymbolJson {
    #[serde(rename = "type")]
    /// The type always `symbol`.
    pub type_: String,
    /// The type of symbol.
    pub symbol_type: String,
    /// Names associated with the function symbol.
    pub name: String,
    /// The virtual address of the function symbol.
    #[serde(skip)]
    pub address: u64,
}

/// Represents a structure containing metadata about a function symbol.
#[derive(Clone, Debug)]
pub struct Symbol {
    /// Names associated with the function symbol.
    pub name: String,
    /// The virtual address of the function symbol.
    pub address: u64,
    /// The type of symbol
    pub symbol_type: String,
}

impl Symbol {
    #[allow(dead_code)]
    pub fn new(address: u64, symbol_type: String, name: String) -> Self {
        Self {
            name,
            address,
            symbol_type,
        }
    }

    /// Processes the function signature into its JSON-serializable representation.
    ///
    /// # Returns
    ///
    /// Returns a `FunctionSymbolJson` struct containing metadata about the function symbol.
    pub fn process(&self) -> SymbolJson {
        SymbolJson {
            type_: "symbol".to_string(),
            symbol_type: self.symbol_type.clone(),
            name: self.name.clone(),
            address: self.address,
        }
    }

    /// Processes the tag into an `Attribute`.
    ///
    /// # Returns
    ///
    /// Returns a `Attribute` struct containing the tag.
    pub fn attribute(&self) -> Attribute {
        Attribute::Symbol(self.process())
    }

    /// Prints the JSON representation of the function symbol to standard output.
    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }

    /// Converts the function symbol metadata into a JSON string representation.
    ///
    /// # Returns
    ///
    /// Returns `Ok(String)` containing the JSON representation, or an `Err` if serialization fails.
    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    /// Demangles a Microsoft Visual C++ (MSVC) mangled symbol name.
    ///
    /// # Arguments
    ///
    /// * `mangled_name` - A string slice representing the mangled symbol name to demangle.
    ///
    /// # Returns
    ///
    /// A `String` containing the demangled symbol name in the form `namespace::...::function_name`.
    /// If the input string does not start with the MSVC mangling prefix `?`, the original string
    /// is returned unchanged.
    #[allow(dead_code)]
    pub fn demangle_msvc_name(mangled_name: &str) -> String {
        if !mangled_name.starts_with('?') {
            return mangled_name.to_owned();
        }
        let parts = mangled_name
            .trim_start_matches('?')
            .split('@')
            .collect::<Vec<_>>();
        let function_name = parts.first().copied().unwrap_or(mangled_name);
        let mut namespaces: Vec<_> = parts
            .iter()
            .skip(1)
            .take_while(|s| !s.is_empty())
            .copied()
            .collect();
        namespaces.reverse();
        format!("{}::{}", namespaces.join("::"), function_name)
    }
}

```

`src/controlflow/tag.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Attribute;
use serde::{Deserialize, Serialize};
use std::io::Error;

/// Represents a JSON-serializable structure containing metadata about a tag.
#[derive(Serialize, Deserialize, Clone)]
pub struct TagJson {
    /// The type of this entity, always `"tag"`.
    #[serde(rename = "type")]
    pub type_: String,
    /// The tag value
    pub value: String,
}

#[derive(Clone)]
pub struct Tag {
    tag: String,
}

impl Tag {
    #[allow(dead_code)]
    pub fn new(tag: String) -> Self {
        Self { tag }
    }

    /// Processes the function signature into its JSON-serializable representation.
    ///
    /// # Returns
    ///
    /// Returns a `FunctionSymbolJson` struct containing metadata about the function symbol.
    pub fn process(&self) -> TagJson {
        TagJson {
            type_: "tag".to_string(),
            value: self.tag.clone(),
        }
    }

    /// Processes the tag into an `Attribute`.
    ///
    /// # Returns
    ///
    /// Returns a `Attribute` struct containing the tag.
    pub fn attribute(&self) -> Attribute {
        Attribute::Tag(self.process())
    }

    /// Prints the JSON representation of the function symbol to standard output.
    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }

    /// Converts the function symbol metadata into a JSON string representation.
    ///
    /// # Returns
    ///
    /// Returns `Ok(String)` containing the JSON representation, or an `Err` if serialization fails.
    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }
}

```

`src/disassemblers/capstone/disassembler.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

extern crate capstone;
use crate::controlflow::Graph;
use crate::disassemblers::capstone::x86::Disassembler as X86Disassembler;
use crate::Architecture;
use crate::Config;
use std::collections::{BTreeMap, BTreeSet};
use std::io::{Error, ErrorKind};

pub trait ArchDisassembler {
    fn disassemble_instruction(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error>;
    fn disassemble_block(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error>;
    fn disassemble_function(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error>;
    fn disassemble_controlflow(
        &self,
        addresses: BTreeSet<u64>,
        cfg: &mut Graph,
    ) -> Result<(), Error>;
    fn disassemble_sweep(&self) -> BTreeSet<u64>;
}

pub enum DisassemblerBackend<'a> {
    X86(X86Disassembler<'a>),
}

impl ArchDisassembler for DisassemblerBackend<'_> {
    fn disassemble_sweep(&self) -> BTreeSet<u64> {
        match self {
            DisassemblerBackend::X86(d) => d.disassemble_sweep(),
        }
    }
    fn disassemble_instruction(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error> {
        match self {
            DisassemblerBackend::X86(d) => d.disassemble_instruction(address, cfg),
        }
    }

    fn disassemble_block(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error> {
        match self {
            DisassemblerBackend::X86(d) => d.disassemble_block(address, cfg),
        }
    }

    fn disassemble_function(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error> {
        match self {
            DisassemblerBackend::X86(d) => d.disassemble_function(address, cfg),
        }
    }

    fn disassemble_controlflow(
        &self,
        addresses: BTreeSet<u64>,
        cfg: &mut Graph,
    ) -> Result<(), Error> {
        match self {
            DisassemblerBackend::X86(d) => d.disassemble_controlflow(addresses, cfg),
        }
    }
}

pub struct Disassembler<'a> {
    backend: DisassemblerBackend<'a>,
}

impl<'a> Disassembler<'a> {
    pub fn new(
        machine: Architecture,
        image: &'a [u8],
        executable_address_ranges: BTreeMap<u64, u64>,
        config: Config,
    ) -> Result<Self, Error> {
        let backend = match machine {
            Architecture::AMD64 | Architecture::I386 => {
                let disasm = X86Disassembler::new(
                    machine,
                    image,
                    executable_address_ranges.clone(),
                    config.clone(),
                )
                .map_err(|_| Error::other("failed to create X86 disassembler"))?;
                DisassemblerBackend::X86(disasm)
            }
            _ => {
                return Err(Error::new(
                    ErrorKind::Unsupported,
                    "unsupported architecture",
                ));
            }
        };

        Ok(Self { backend })
    }

    pub fn disassemble_instruction(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error> {
        self.backend.disassemble_instruction(address, cfg)
    }

    pub fn disassemble_block(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error> {
        self.backend.disassemble_block(address, cfg)
    }

    pub fn disassemble_function(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error> {
        self.backend.disassemble_function(address, cfg)
    }

    pub fn disassemble_controlflow(
        &self,
        addresses: BTreeSet<u64>,
        cfg: &mut Graph,
    ) -> Result<(), Error> {
        self.backend.disassemble_controlflow(addresses, cfg)
    }

    pub fn disassemble_sweep(&self) -> BTreeSet<u64> {
        self.backend.disassemble_sweep()
    }
}

```

`src/disassemblers/capstone/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod disassembler;
pub mod x86;

pub use disassembler::Disassembler;

```

`src/disassemblers/capstone/x86/disassembler.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

extern crate capstone;
use crate::binary::Binary;
use crate::controlflow::graph::Graph;
use crate::controlflow::instruction::Instruction;
use crate::io::Stderr;
use crate::Architecture;
use crate::Config;
use arch::x86::X86OpMem;
use arch::x86::X86Reg::{X86_REG_EBP, X86_REG_ESP, X86_REG_RBP, X86_REG_RIP, X86_REG_RSP};
use capstone::arch::x86::X86Insn;
use capstone::arch::x86::X86OperandType;
use capstone::arch::ArchOperand;
use capstone::prelude::*;
use capstone::Insn;
use capstone::InsnId;
use capstone::Instructions;
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};
use rayon::ThreadPoolBuilder;
use std::collections::{BTreeMap, BTreeSet};
use std::io::Error;
use std::io::ErrorKind;

pub struct Disassembler<'disassembler> {
    cs: Capstone,
    image: &'disassembler [u8],
    machine: Architecture,
    executable_address_ranges: BTreeMap<u64, u64>,
    config: Config,
}

impl<'disassembler> Disassembler<'disassembler> {
    pub fn new(
        machine: Architecture,
        image: &'disassembler [u8],
        executable_address_ranges: BTreeMap<u64, u64>,
        config: Config,
    ) -> Result<Self, Error> {
        let cs = Disassembler::cs_new(machine, true)?;
        Ok(Self {
            cs,
            image,
            machine,
            executable_address_ranges,
            config,
        })
    }

    pub fn is_executable_address(&self, address: u64) -> bool {
        self.executable_address_ranges
            .iter()
            .any(|(start, end)| address >= *start && address <= *end)
    }

    #[allow(dead_code)]
    pub fn disassemble_sweep(&self) -> BTreeSet<u64> {
        let valid_jump_threshold: usize = 2;
        let valid_instruction_threshold: usize = 4;

        let mut functions = BTreeSet::<u64>::new();
        for (start, end) in self.executable_address_ranges.clone() {
            let mut pc = start;
            let mut valid_instructions = 0;
            let mut valid_jumps = 0;
            while pc < end {
                let instructions = match self.disassemble_instructions(pc, 1) {
                    Ok(instructions) => instructions,
                    Err(_) => {
                        pc += 1;
                        valid_instructions = 0;
                        valid_jumps = 0;
                        continue;
                    }
                };
                let instruction = instructions.iter().next().unwrap();
                if Disassembler::is_privilege_instruction(instruction)
                    || Disassembler::is_trap_instruction(instruction)
                {
                    pc += instruction.bytes().len() as u64;
                    continue;
                }
                if let Some(imm) = self.get_jump_immutable(instruction) {
                    if self.is_executable_address(imm) {
                        valid_jumps += 1;
                    } else {
                        valid_instructions = 0;
                        valid_jumps = 0;
                        pc += 1;
                        continue;
                    }
                }
                if let Some(imm) = self.get_call_immutable(instruction) {
                    if valid_jumps >= valid_jump_threshold
                        && valid_instructions >= valid_instruction_threshold
                    {
                        if self.is_executable_address(imm) {
                            functions.insert(imm);
                        } else {
                            valid_instructions = 0;
                            valid_jumps = 0;
                            pc += 1;
                            continue;
                        }
                    }
                }
                valid_instructions += 1;
                pc += instruction.bytes().len() as u64;
            }
        }
        functions
    }

    #[allow(dead_code)]
    pub fn disassemble_controlflow<'a>(
        &'a self,
        addresses: BTreeSet<u64>,
        cfg: &'a mut Graph,
    ) -> Result<(), Error> {
        let pool = ThreadPoolBuilder::new()
            .num_threads(cfg.config.general.threads)
            .build()
            .map_err(|error| Error::new(ErrorKind::Other, format!("{}", error)))?;

        if cfg.config.disassembler.sweep.enabled {
            cfg.functions.enqueue_extend(self.disassemble_sweep());
        }

        cfg.functions.enqueue_extend(addresses);

        let external_image = self.image;

        let external_machine = self.machine;

        let external_executable_address_ranges = self.executable_address_ranges.clone();

        let external_config = self.config.clone();

        pool.install(|| {
            while !cfg.functions.queue.is_empty() {
                let function_addresses = cfg.functions.dequeue_all();
                cfg.functions
                    .insert_processed_extend(function_addresses.clone());
                let graphs: Vec<Graph> = function_addresses
                    .par_iter()
                    .map(|address| {
                        let machine = external_machine;
                        let executable_address_ranges = external_executable_address_ranges.clone();
                        let image = external_image;
                        let mut graph = Graph::new(machine, cfg.config.clone());
                        if let Ok(disasm) = Disassembler::new(
                            machine,
                            image,
                            executable_address_ranges,
                            external_config.clone(),
                        ) {
                            let _ = disasm.disassemble_function(*address, &mut graph);
                        }
                        graph
                    })
                    .collect();
                for mut graph in graphs {
                    cfg.absorb(&mut graph);
                }
            }
        });

        Ok(())
    }

    pub fn disassemble_function<'a>(
        &'a self,
        address: u64,
        cfg: &'a mut Graph,
    ) -> Result<u64, Error> {
        cfg.functions.insert_processed(address);

        if !self.is_executable_address(address) {
            cfg.functions.insert_invalid(address);
            let error_message = format!(
                "Function -> 0x{:x}: it is not in executable memory",
                address
            );
            Stderr::print_debug(cfg.config.clone(), &error_message);
            return Err(Error::new(ErrorKind::Other, error_message));
        }

        cfg.blocks.enqueue(address);

        while let Some(block_start_address) = cfg.blocks.dequeue() {
            if cfg.blocks.is_processed(block_start_address) {
                continue;
            }

            let block_end_address = self
                .disassemble_block(block_start_address, cfg)
                .inspect_err(|_| {
                    cfg.functions.insert_invalid(address);
                })?;

            if block_start_address == address {
                if let Some(mut instruction) = cfg.get_instruction(block_start_address) {
                    instruction.is_function_start = true;
                    cfg.update_instruction(instruction);
                }
            }

            if let Some(instruction) = cfg.get_instruction(block_end_address) {
                cfg.blocks.enqueue_extend(instruction.blocks());
            }
        }

        cfg.functions.insert_valid(address);

        Ok(address)
    }

    pub fn disassemble_instruction<'a>(
        &'a self,
        address: u64,
        cfg: &'a mut Graph,
    ) -> Result<u64, Error> {
        cfg.instructions.insert_processed(address);

        if let Some(instruction) = cfg.get_instruction(address) {
            return Ok(instruction.address);
        }

        if !self.is_executable_address(address) {
            cfg.instructions.insert_invalid(address);
            let error = format!(
                "Instruction -> 0x{:x}: it is not in executable memory",
                address
            );
            Stderr::print_debug(cfg.config.clone(), error.clone());
            return Err(Error::new(ErrorKind::Other, error));
        }

        let instruction_container = self.disassemble_instructions(address, 1)?;
        let instruction = instruction_container.iter().next().ok_or_else(|| {
            cfg.instructions.insert_invalid(address);
            let error = format!("0x{:x}: failed to disassemble instruction", address);
            Error::new(ErrorKind::Other, error)
        })?;

        let instruction_signature = self.get_instruction_pattern(instruction)?;

        let mut blinstruction =
            Instruction::create(instruction.address(), cfg.architecture, cfg.config.clone());

        blinstruction.is_jump = Disassembler::is_jump_instruction(instruction);
        blinstruction.is_call = Disassembler::is_call_instruction(instruction);
        blinstruction.is_return = Disassembler::is_return_instruction(instruction);
        blinstruction.is_trap = Disassembler::is_trap_instruction(instruction);

        if blinstruction.is_jump {
            blinstruction.is_conditional =
                Disassembler::is_conditional_jump_instruction(instruction);
        }

        blinstruction.edges = self.get_instruction_edges(instruction);
        blinstruction.bytes = instruction.bytes().to_vec();
        blinstruction.pattern = instruction_signature;

        if let Some(addr) = self.get_conditional_jump_immutable(instruction) {
            blinstruction.to.insert(addr);
        }
        if let Some(addr) = self.get_unconditional_jump_immutable(instruction) {
            blinstruction.to.insert(addr);
        }
        if let Some(addr) = self.get_call_immutable(instruction) {
            cfg.functions.enqueue(addr);
            blinstruction.functions.insert(addr);
        }
        if let Some(addr) = self.get_instruction_executable_addresses(instruction) {
            cfg.functions.enqueue(addr);
            blinstruction.functions.insert(addr);
        }

        Stderr::print_debug(
            cfg.config.clone(),
            format!(
                "0x{:x}: mnemonic: {:?}, next: {:?}, to: {:?}, is_conditional: {:?}, is_jump: {:?}",
                blinstruction.address,
                instruction.mnemonic().unwrap(),
                blinstruction.next(),
                blinstruction.to(),
                blinstruction.is_conditional,
                blinstruction.is_jump,
            ),
        );

        cfg.insert_instruction(blinstruction);

        cfg.instructions.insert_valid(address);

        Ok(address)
    }

    #[allow(dead_code)]
    pub fn disassemble_block<'a>(&'a self, address: u64, cfg: &'a mut Graph) -> Result<u64, Error> {
        cfg.blocks.insert_processed(address);

        if !self.is_executable_address(address) {
            cfg.functions.insert_invalid(address);
            let error_message = format!("Block -> 0x{:x}: it is not in executable memory", address);
            Stderr::print_debug(cfg.config.clone(), error_message.clone());
            return Err(Error::new(ErrorKind::Other, error_message));
        }

        let mut pc = address;
        let mut has_prologue = false;
        let mut terminator = address;

        while self.disassemble_instruction(pc, cfg).is_ok() {
            let mut instruction = match cfg.get_instruction(pc) {
                Some(instr) => instr,
                None => {
                    cfg.blocks.insert_invalid(address);
                    return Err(Error::new(
                        ErrorKind::Other,
                        "failed to disassemble instruction",
                    ));
                }
            };

            if instruction.address == address {
                instruction.is_block_start = true;
                cfg.update_instruction(instruction.clone());
            }

            if instruction.address == address && instruction.is_block_start {
                instruction.is_prologue = self.is_function_prologue(instruction.address);
                has_prologue = instruction.is_prologue;
                cfg.update_instruction(instruction.clone());
            }

            terminator = instruction.address;

            let is_block_start = instruction.address != address && instruction.is_block_start;

            if instruction.is_trap || instruction.is_return || instruction.is_jump || is_block_start
            {
                break;
            }

            pc += instruction.size() as u64;

            if cfg.blocks.is_pending(pc) || cfg.blocks.is_processed(pc) || cfg.blocks.is_valid(pc) {
                break;
            }
        }

        if has_prologue {
            cfg.functions.enqueue(address);
        }
        cfg.blocks.insert_valid(address);

        Ok(terminator)
    }

    pub fn is_function_prologue(&self, address: u64) -> bool {
        // Starting Instructions
        if let Ok(instructions) = self.disassemble_instructions(address, 2) {
            match self.machine {
                Architecture::AMD64 => {
                    if instructions[0].id() == InsnId(X86Insn::X86_INS_PUSH as u32)
                        && self.instruction_has_register_operand(
                            &instructions[0],
                            0,
                            RegId(X86_REG_RBP as u16),
                        )
                        && instructions[1].id() != InsnId(X86Insn::X86_INS_MOV as u32)
                        && self.instruction_has_register_operand(
                            &instructions[1],
                            0,
                            RegId(X86_REG_RBP as u16),
                        )
                        && self.instruction_has_register_operand(
                            &instructions[1],
                            1,
                            RegId(X86_REG_RSP as u16),
                        )
                    {
                        return true;
                    }
                }
                Architecture::I386 => {
                    if instructions[0].id() == InsnId(X86Insn::X86_INS_PUSH as u32)
                        && self.instruction_has_register_operand(
                            &instructions[0],
                            0,
                            RegId(X86_REG_EBP as u16),
                        )
                        && instructions[1].id() != InsnId(X86Insn::X86_INS_MOV as u32)
                        && self.instruction_has_register_operand(
                            &instructions[1],
                            0,
                            RegId(X86_REG_EBP as u16),
                        )
                        && self.instruction_has_register_operand(
                            &instructions[1],
                            1,
                            RegId(X86_REG_ESP as u16),
                        )
                    {
                        return true;
                    }
                }
                _ => {}
            }
        }

        false
    }

    fn instruction_has_register_operand(
        &self,
        instruction: &Insn,
        index: usize,
        register_id: RegId,
    ) -> bool {
        let operands = match self.get_instruction_operands(instruction) {
            Ok(operands) => operands,
            Err(_) => return false,
        };

        if let Some(operand) = operands.get(index) {
            if let ArchOperand::X86Operand(op) = operand {
                if let X86OperandType::Reg(reg_id) = op.op_type {
                    return reg_id == register_id;
                }
            }
        }
        false
    }

    #[allow(dead_code)]
    pub fn get_operand_mem(operand: &ArchOperand) -> Option<X86OpMem> {
        if let ArchOperand::X86Operand(operand) = operand {
            if let X86OperandType::Mem(_operand) = operand.op_type {
                return Some(_operand);
            }
        }
        None
    }

    #[allow(dead_code)]
    pub fn get_instruction_total_operand_size(&self, instruction: &Insn) -> Result<usize, Error> {
        let operands = self.get_instruction_operands(instruction)?;
        let mut result: usize = 0;
        for operand in operands {
            match operand {
                ArchOperand::X86Operand(op) => {
                    result += op.size as usize;
                }
                _ => {
                    return Err(Error::new(
                        ErrorKind::Other,
                        "unsupported operand architecture",
                    ))
                }
            }
        }
        Ok(result)
    }

    pub fn instruction_contains_memory_operand(&self, instruction: &Insn) -> bool {
        let operands = match self.get_instruction_operands(instruction) {
            Ok(operands) => operands,
            Err(_) => return false,
        };
        for operand in operands {
            if let ArchOperand::X86Operand(op) = operand {
                match op.op_type {
                    X86OperandType::Mem(_) => return true,
                    _ => continue,
                };
            }
        }
        false
    }

    pub fn instruction_contains_immutable_operand(&self, instruction: &Insn) -> bool {
        let operands = match self.get_instruction_operands(instruction) {
            Ok(operands) => operands,
            Err(_) => return false,
        };
        for operand in operands {
            if let ArchOperand::X86Operand(op) = operand {
                match op.op_type {
                    X86OperandType::Imm(_) => return true,
                    _ => continue,
                };
            }
        }
        false
    }

    #[allow(dead_code)]
    pub fn get_instruction_pattern(&self, instruction: &Insn) -> Result<String, Error> {
        if Disassembler::is_unsupported_pattern_instruction(instruction) {
            return Ok(Binary::to_hex(instruction.bytes()));
        }

        if Disassembler::is_wildcard_instruction(instruction) {
            return Ok("??".repeat(instruction.bytes().len()));
        }

        if !self.instruction_contains_immutable_operand(instruction)
            && !self.instruction_contains_memory_operand(instruction)
        {
            return Ok(Binary::to_hex(instruction.bytes()));
        }

        let instruction_size = instruction.bytes().len() * 8;

        let mut wildcarded = vec![false; instruction_size];

        let instruction_trailing_null_size = instruction
            .bytes()
            .iter()
            .rev()
            .take_while(|&&b| b == 0)
            .count()
            * 8;

        let operands = self.get_instruction_operands(instruction)?;

        let total_operand_size = self.get_instruction_total_operand_size(instruction)?;

        if total_operand_size > instruction_size {
            return Ok(Binary::to_hex(instruction.bytes()));
        }

        let instruction_trailing_null_offset = instruction_size - instruction_trailing_null_size;

        let is_immutable_signature = self.is_immutable_instruction_to_pattern(instruction);

        if total_operand_size == 0 && !operands.is_empty() {
            return Err(Error::new(
                ErrorKind::Other,
                format!(
                    "Instruction -> 0x{:x}: instruction has operands but missing operand sizes",
                    instruction.address()
                ),
            ));
        }

        for operand in operands {
            if let ArchOperand::X86Operand(op) = operand {
                let should_wildcard = match op.op_type {
                    X86OperandType::Imm(_) => is_immutable_signature,
                    X86OperandType::Mem(mem) => mem.index() == RegId(0),
                    _ => false,
                };

                let displacement_size = match op.op_type {
                    X86OperandType::Mem(op_mem) => {
                        Disassembler::get_displacement_size(op_mem.disp() as u64) * 8
                    }
                    _ => 0,
                };

                let mut op_size = if (op.size as usize) > displacement_size {
                    op.size as usize
                } else {
                    displacement_size
                };

                if op_size > instruction_size {
                    op_size = op.size as usize;
                }

                if op_size > instruction_size {
                    Disassembler::print_instruction(instruction);
                    return Err(Error::new(ErrorKind::Other, format!("Instruction -> 0x{:x}: instruction operand size exceeds instruction size", instruction.address())));
                }

                let operand_offset = instruction_size - op_size;

                if should_wildcard {
                    for i in 0..op_size {
                        if operand_offset + i > wildcarded.len() {
                            Disassembler::print_instruction(instruction);
                            return Err(Error::new(ErrorKind::Other, format!("Instruction -> 0x{:x}: instruction wildcard index is out of bounds", instruction.address())));
                        }
                        wildcarded[operand_offset + i] = true;
                    }
                }
            }
        }

        let instruction_hex = Binary::to_hex(instruction.bytes());

        if instruction_hex.len() % 2 != 0 {
            return Err(Error::new(
                ErrorKind::Other,
                format!(
                    "Instruction -> 0x{:x}: instruction hex string length is not even",
                    instruction.address()
                ),
            ));
        }

        let signature: String = instruction_hex
            .chars()
            .enumerate()
            .map(|(index, ch)| {
                let start = index * 4;
                let end = start + 4;
                if (start >= instruction_trailing_null_offset && is_immutable_signature)
                    || wildcarded[start..end].iter().all(|&x| x)
                {
                    '?'
                } else {
                    ch
                }
            })
            .collect();

        if signature.len() % 2 != 0 {
            return Err(Error::new(
                ErrorKind::Other,
                format!(
                    "Instruction -> 0x{:x}: wildcarded hex string length is not even",
                    instruction.address()
                ),
            ));
        }

        if instruction_hex.len() != signature.len() {
            return Err(Error::new(
                ErrorKind::Other,
                format!(
                    "Instruction -> 0x{:x}: instruction hex length not same as wildcard hex length",
                    instruction.address()
                ),
            ));
        }

        Ok(signature)
    }

    fn get_displacement_size(displacement: u64) -> usize {
        match displacement {
            0x00..=0xFF => 1,
            0x100..=0xFFFF => 2,
            0x10000..=0xFFFFFFFF => 4,
            _ => 8,
        }
    }

    #[allow(dead_code)]
    pub fn get_jump_immutable(&self, instruction: &Insn) -> Option<u64> {
        if Disassembler::is_jump_instruction(instruction) {
            let operand = match self.get_instruction_operand(instruction, 0) {
                Ok(operand) => operand,
                Err(_error) => return None,
            };
            return Disassembler::get_operand_immutable(&operand);
        }
        None
    }

    #[allow(dead_code)]
    pub fn get_conditional_jump_immutable(&self, instruction: &Insn) -> Option<u64> {
        if Disassembler::is_conditional_jump_instruction(instruction) {
            let operand = match self.get_instruction_operand(instruction, 0) {
                Ok(operand) => operand,
                Err(_error) => return None,
            };
            return Disassembler::get_operand_immutable(&operand);
        }
        None
    }

    #[allow(dead_code)]
    pub fn get_unconditional_jump_immutable(&self, instruction: &Insn) -> Option<u64> {
        if Disassembler::is_unconditional_jump_instruction(instruction) {
            let operand = match self.get_instruction_operand(instruction, 0) {
                Ok(operand) => operand,
                Err(_error) => return None,
            };
            return Disassembler::get_operand_immutable(&operand);
        }
        None
    }

    #[allow(dead_code)]
    pub fn get_instruction_executable_addresses(&self, instruction: &Insn) -> Option<u64> {
        if !Disassembler::is_load_address_instruction(instruction) {
            return None;
        }
        let operands = match self.get_instruction_operands(instruction) {
            Ok(operands) => operands,
            Err(_) => return None,
        };
        for operand in operands {
            if let ArchOperand::X86Operand(operand) = operand {
                if let X86OperandType::Mem(mem) = operand.op_type {
                    if mem.base() != RegId(X86_REG_RIP as u16) {
                        continue;
                    }
                    if mem.index() != RegId(0) {
                        continue;
                    }
                    let address: u64 = (instruction.address() as i64
                        + mem.disp()
                        + instruction.bytes().len() as i64)
                        as u64;
                    if !self.is_executable_address(address) {
                        continue;
                    }
                    if self.disassemble_instructions(address, 1).is_err() {
                        continue;
                    }
                    return Some(address);
                }
            }
        }
        None
    }

    #[allow(dead_code)]
    pub fn get_call_immutable(&self, instruction: &Insn) -> Option<u64> {
        if Disassembler::is_call_instruction(instruction) {
            let operand = match self.get_instruction_operand(instruction, 0) {
                Ok(operand) => operand,
                Err(_error) => return None,
            };
            return Disassembler::get_operand_immutable(&operand);
        }
        None
    }

    #[allow(dead_code)]
    pub fn get_operand_immutable(op: &ArchOperand) -> Option<u64> {
        if let ArchOperand::X86Operand(op) = op {
            if let X86OperandType::Imm(imm) = op.op_type {
                return Some(imm as u64);
            }
        }
        None
    }

    #[allow(dead_code)]
    pub fn get_instruction_operands(&self, instruction: &Insn) -> Result<Vec<ArchOperand>, Error> {
        #[allow(clippy::let_and_return)]
        let detail = match self.cs.insn_detail(instruction) {
            Ok(detail) => detail,
            Err(_error) => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "failed to get instruction detail",
                ))
            }
        };
        let arch = detail.arch_detail();
        Ok(arch.operands())
    }

    #[allow(dead_code)]
    pub fn get_instruction_operand(
        &self,
        instruction: &Insn,
        index: usize,
    ) -> Result<ArchOperand, Error> {
        let operands = self.get_instruction_operands(instruction)?;
        let operand = match operands.get(index) {
            Some(operand) => operand.clone(),
            None => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "failed to get instruction operand",
                ))
            }
        };
        Ok(operand)
    }

    #[allow(dead_code)]
    pub fn print_instructions(instructions: &Instructions) {
        for instruction in instructions.iter() {
            Disassembler::print_instruction(instruction);
        }
    }

    #[allow(dead_code)]
    pub fn get_instruction_edges(&self, instruction: &Insn) -> usize {
        if Disassembler::is_unconditional_jump_instruction(instruction) {
            return 1;
        }
        if Disassembler::is_return_instruction(instruction) {
            return 1;
        }
        if Disassembler::is_conditional_jump_instruction(instruction) {
            return 2;
        }
        0
    }

    #[allow(dead_code)]
    pub fn is_immutable_instruction_to_pattern(&self, instruction: &Insn) -> bool {
        if !self.instruction_contains_immutable_operand(instruction) {
            return false;
        }

        if Disassembler::is_call_instruction(instruction)
            || Disassembler::is_jump_instruction(instruction)
        {
            return true;
        }

        const STACK_INSTRUCTIONS: [InsnId; 5] = [
            InsnId(X86Insn::X86_INS_MOV as u32),
            InsnId(X86Insn::X86_INS_SUB as u32),
            InsnId(X86Insn::X86_INS_ADD as u32),
            InsnId(X86Insn::X86_INS_INC as u32),
            InsnId(X86Insn::X86_INS_DEC as u32),
        ];

        if STACK_INSTRUCTIONS.contains(&instruction.id()) {
            let operands = match self.get_instruction_operands(instruction) {
                Ok(operands) => operands,
                Err(_) => return false,
            };

            for operand in operands {
                if let ArchOperand::X86Operand(op) = operand {
                    if let X86OperandType::Reg(register_id) = op.op_type {
                        if [X86_REG_RSP, X86_REG_RBP, X86_REG_ESP, X86_REG_EBP]
                            .contains(&(register_id.0 as u32))
                        {
                            return true;
                        }
                    }
                }
            }
        }

        false
    }

    #[allow(dead_code)]
    pub fn is_unsupported_pattern_instruction(instruction: &Insn) -> bool {
        static MNEMONICS: &[u32] = &[
            X86Insn::X86_INS_MOVUPS as u32,
            X86Insn::X86_INS_MOVAPS as u32,
            X86Insn::X86_INS_XORPS as u32,
            X86Insn::X86_INS_SHUFPS as u32,
        ];
        MNEMONICS.contains(&instruction.id().0)
    }

    #[allow(dead_code)]
    pub fn is_return_instruction(insn: &Insn) -> bool {
        static RETURN_OPCODES: &[u32] = &[
            X86Insn::X86_INS_RET as u32,
            X86Insn::X86_INS_RETF as u32,
            X86Insn::X86_INS_RETFQ as u32,
            X86Insn::X86_INS_IRET as u32,
            X86Insn::X86_INS_IRETD as u32,
            X86Insn::X86_INS_IRETQ as u32,
        ];
        RETURN_OPCODES.contains(&insn.id().0)
    }

    #[allow(dead_code)]
    pub fn is_privilege_instruction(instruction: &Insn) -> bool {
        static MNEMONICS: &[u32] = &[
            X86Insn::X86_INS_HLT as u32,
            X86Insn::X86_INS_IN as u32,
            X86Insn::X86_INS_INSB as u32,
            X86Insn::X86_INS_INSW as u32,
            X86Insn::X86_INS_INSD as u32,
            X86Insn::X86_INS_OUT as u32,
            X86Insn::X86_INS_OUTSB as u32,
            X86Insn::X86_INS_OUTSW as u32,
            X86Insn::X86_INS_OUTSD as u32,
            X86Insn::X86_INS_RDMSR as u32,
            X86Insn::X86_INS_WRMSR as u32,
            X86Insn::X86_INS_RDPMC as u32,
            X86Insn::X86_INS_RDTSC as u32,
            X86Insn::X86_INS_LGDT as u32,
            X86Insn::X86_INS_LLDT as u32,
            X86Insn::X86_INS_LTR as u32,
            X86Insn::X86_INS_LMSW as u32,
            X86Insn::X86_INS_CLTS as u32,
            X86Insn::X86_INS_INVD as u32,
            X86Insn::X86_INS_INVLPG as u32,
            X86Insn::X86_INS_WBINVD as u32,
        ];
        MNEMONICS.contains(&instruction.id().0)
    }

    #[allow(dead_code)]
    pub fn is_wildcard_instruction(instruction: &Insn) -> bool {
        Disassembler::is_nop_instruction(instruction)
            || Disassembler::is_trap_instruction(instruction)
    }

    #[allow(dead_code)]
    pub fn is_nop_instruction(instruction: &Insn) -> bool {
        static MNEMONICS: &[u32] = &[X86Insn::X86_INS_NOP as u32, X86Insn::X86_INS_FNOP as u32];
        MNEMONICS.contains(&instruction.id().0)
    }

    #[allow(dead_code)]
    pub fn is_trap_instruction(instruction: &Insn) -> bool {
        static MNEMONICS: &[u32] = &[
            X86Insn::X86_INS_INT3 as u32,
            X86Insn::X86_INS_UD2 as u32,
            X86Insn::X86_INS_INT1 as u32,
            X86Insn::X86_INS_INTO as u32,
        ];
        MNEMONICS.contains(&instruction.id().0)
    }

    #[allow(dead_code)]
    pub fn is_jump_instruction(instruction: &Insn) -> bool {
        if Disassembler::is_conditional_jump_instruction(instruction) {
            return true;
        }
        if Disassembler::is_unconditional_jump_instruction(instruction) {
            return true;
        }
        false
    }

    #[allow(dead_code)]
    pub fn is_load_address_instruction(instruction: &Insn) -> bool {
        static MNEMONICS: &[u32] = &[X86Insn::X86_INS_LEA as u32];
        MNEMONICS.contains(&instruction.id().0)
    }

    #[allow(dead_code)]
    pub fn is_call_instruction(instruction: &Insn) -> bool {
        static MNEMONICS: &[u32] = &[X86Insn::X86_INS_CALL as u32, X86Insn::X86_INS_LCALL as u32];
        MNEMONICS.contains(&instruction.id().0)
    }

    #[allow(dead_code)]
    pub fn is_unconditional_jump_instruction(instruction: &Insn) -> bool {
        static MNEMONICS: &[u32] = &[X86Insn::X86_INS_JMP as u32];
        MNEMONICS.contains(&instruction.id().0)
    }

    #[allow(dead_code)]
    pub fn is_conditional_jump_instruction(instruction: &Insn) -> bool {
        static MNEMONICS: &[u32] = &[
            X86Insn::X86_INS_JNE as u32,
            X86Insn::X86_INS_JNO as u32,
            X86Insn::X86_INS_JNP as u32,
            X86Insn::X86_INS_JL as u32,
            X86Insn::X86_INS_JLE as u32,
            X86Insn::X86_INS_JG as u32,
            X86Insn::X86_INS_JGE as u32,
            X86Insn::X86_INS_JE as u32,
            X86Insn::X86_INS_JECXZ as u32,
            X86Insn::X86_INS_JCXZ as u32,
            X86Insn::X86_INS_JB as u32,
            X86Insn::X86_INS_JBE as u32,
            X86Insn::X86_INS_JA as u32,
            X86Insn::X86_INS_JAE as u32,
            X86Insn::X86_INS_JNS as u32,
            X86Insn::X86_INS_JO as u32,
            X86Insn::X86_INS_JP as u32,
            X86Insn::X86_INS_JRCXZ as u32,
            X86Insn::X86_INS_JS as u32,
            X86Insn::X86_INS_LOOPE as u32,
            X86Insn::X86_INS_LOOPNE as u32,
            X86Insn::X86_INS_LOOP as u32,
        ];
        MNEMONICS.contains(&instruction.id().0)
    }

    pub fn print_instruction(instruction: &Insn) {
        println!(
            "0x{:x}: {} {} {}",
            instruction.address(),
            instruction
                .bytes()
                .iter()
                .map(|byte| format!("{:02x}", byte))
                .collect::<Vec<_>>()
                .join(" "),
            instruction.mnemonic().unwrap_or(""),
            instruction.op_str().unwrap_or(""),
        );
    }

    pub fn disassemble_instructions(
        &self,
        address: u64,
        count: u64,
    ) -> Result<Instructions<'_>, Error> {
        if (address as usize) >= self.image.len() {
            return Err(Error::new(ErrorKind::Other, "address out of bounds"));
        }
        let instructions = self
            .cs
            .disasm_count(&self.image[address as usize..], address, count as usize)
            .map_err(|_| Error::new(ErrorKind::Other, "failed to disassemble instructions"))?;
        if instructions.len() == 0 {
            return Err(Error::new(ErrorKind::Other, "no instructions found"));
        }
        Ok(instructions)
    }

    fn cs_new(machine: Architecture, detail: bool) -> Result<Capstone, Error> {
        match machine {
            Architecture::AMD64 => Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode64)
                .syntax(arch::x86::ArchSyntax::Intel)
                .detail(detail)
                .build()
                .map_err(|e| Error::new(ErrorKind::Other, format!("capstone error: {:?}", e))),
            Architecture::I386 => Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode32)
                .syntax(arch::x86::ArchSyntax::Intel)
                .detail(detail)
                .build()
                .map_err(|e| Error::new(ErrorKind::Other, format!("capstone error: {:?}", e))),
            _ => Err(Error::new(ErrorKind::Other, "unsupported architecture")),
        }
    }
}

```

`src/disassemblers/capstone/x86/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod disassembler;

pub use disassembler::Disassembler;

```

`src/disassemblers/custom/cil/disassembler.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Graph;
use crate::controlflow::Instruction as CFGInstruction;
use crate::disassemblers::custom::cil::Instruction;
use crate::io::Stderr;
use crate::Architecture;
use crate::Config;
use rayon::iter::{IntoParallelRefIterator, ParallelIterator};
use rayon::ThreadPoolBuilder;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::io::Error;
use std::io::ErrorKind;

pub struct Disassembler<'disassembler> {
    pub architecture: Architecture,
    pub metadata_token_addresses: BTreeMap<u64, u64>,
    pub executable_address_ranges: BTreeMap<u64, u64>,
    pub image: &'disassembler [u8],
    config: Config,
}

impl<'disassembler> Disassembler<'disassembler> {
    pub fn new(
        architecture: Architecture,
        image: &'disassembler [u8],
        metadata_token_addresses: BTreeMap<u64, u64>,
        executable_address_ranges: BTreeMap<u64, u64>,
        config: Config,
    ) -> Result<Self, Error> {
        match architecture {
            Architecture::CIL => {}
            _ => {
                return Err(Error::new(
                    ErrorKind::Unsupported,
                    "unsupported architecture",
                ));
            }
        }
        Ok(Self {
            architecture,
            metadata_token_addresses,
            executable_address_ranges,
            image,
            config,
        })
    }

    pub fn is_executable_address(&self, address: u64) -> bool {
        self.executable_address_ranges
            .iter()
            .any(|(start, end)| address >= *start && address <= *end)
    }

    fn get_instruction_functions(&self, instruction: &Instruction) -> BTreeSet<u64> {
        let mut result = BTreeSet::<u64>::new();
        let call_metadata_token = instruction.get_call_metadata_token();
        if call_metadata_token.is_none() {
            return result;
        }
        let call_address = self
            .metadata_token_addresses
            .get(&(call_metadata_token.unwrap() as u64));
        if call_address.is_none() {
            return result;
        }
        result.insert(*call_address.unwrap());
        result
    }

    pub fn disassemble_instruction(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error> {
        cfg.instructions.insert_processed(address);

        if !self.is_executable_address(address) {
            cfg.instructions.insert_invalid(address);
            return Err(Error::new(
                ErrorKind::InvalidData,
                format!("0x{:x}: instruction address is not executable", address),
            ));
        }

        let instruction = match Instruction::new(&self.image[address as usize..], address) {
            Ok(instruction) => instruction,
            Err(_) => {
                cfg.instructions.insert_invalid(address);
                return Err(Error::new(
                    ErrorKind::Unsupported,
                    format!("0x{:x}: failed to disassemble instruction", address),
                ));
            }
        };

        let mut cfginstruction =
            CFGInstruction::create(address, self.architecture, cfg.config.clone());

        cfginstruction.bytes = instruction.bytes();
        cfginstruction.is_call = instruction.is_call();
        cfginstruction.is_jump = instruction.is_jump();
        cfginstruction.is_conditional = instruction.is_conditional_jump();
        cfginstruction.is_return = instruction.is_return();
        cfginstruction.is_trap = false;
        cfginstruction.pattern = instruction.pattern();
        cfginstruction.edges = instruction.edges();
        cfginstruction.to = instruction.to();
        cfginstruction.functions = self.get_instruction_functions(&instruction);

        Stderr::print_debug(
            cfg.config.clone(),
            format!(
                "0x{:x}: mnemonic: {:?}, mnemonic_size: {}, operand_size: {}, operand_bytes: {:?}, bytes: {:?}, next: {:?}, to: {:?}, blocks: {:?}",
                instruction.address,
                instruction.mnemonic,
                instruction.mnemonic_size(),
                instruction.operand_size(),
                instruction.operand_bytes(),
                instruction.bytes(),
                instruction.next(),
                instruction.to(),
                cfginstruction.blocks(),
            )
        );

        cfg.insert_instruction(cfginstruction);

        cfg.instructions.insert_valid(address);

        Ok(address)
    }

    pub fn disassemble_block(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error> {
        cfg.blocks.insert_processed(address);

        if !self.is_executable_address(address) {
            return Err(Error::new(
                ErrorKind::InvalidData,
                format!("0x{:x}: block address is not executable", address),
            ));
        }

        let mut pc = address;

        loop {
            if let Err(error) = self.disassemble_instruction(pc, cfg) {
                cfg.blocks.insert_invalid(address);
                return Err(error);
            }

            let mut instruction = match cfg.get_instruction(pc) {
                Some(instruction) => instruction,
                None => {
                    cfg.blocks.insert_invalid(address);
                    return Err(Error::new(
                        ErrorKind::InvalidData,
                        format!("0x{:x}: failed to disassemble instruction", pc),
                    ));
                }
            };

            if instruction.address == address {
                instruction.is_block_start = true;
                cfg.update_instruction(instruction.clone());
            }

            let is_block_start = instruction.address != address && instruction.is_block_start;

            if instruction.is_trap || instruction.is_return || instruction.is_jump || is_block_start
            {
                break;
            }

            pc += instruction.size() as u64;
        }

        cfg.blocks.insert_valid(address);

        Ok(pc)
    }

    pub fn disassemble_function(&self, address: u64, cfg: &mut Graph) -> Result<u64, Error> {
        cfg.functions.insert_processed(address);

        if !self.is_executable_address(address) {
            return Err(Error::new(
                ErrorKind::InvalidData,
                format!("0x{:x}: function address is not executable", address),
            ));
        }

        cfg.blocks.enqueue(address);

        while let Some(block_start_address) = cfg.blocks.dequeue() {
            if cfg.blocks.is_processed(block_start_address) {
                continue;
            }

            let block_end_address = self
                .disassemble_block(block_start_address, cfg)
                .inspect_err(|_| {
                    cfg.functions.insert_invalid(address);
                })?;

            if block_start_address == address {
                if let Some(mut instruction) = cfg.get_instruction(block_start_address) {
                    instruction.is_function_start = true;
                    cfg.update_instruction(instruction);
                }
            }

            if let Some(instruction) = cfg.get_instruction(block_end_address) {
                cfg.blocks.enqueue_extend(instruction.blocks());
            }
        }

        cfg.functions.insert_valid(address);

        Ok(address)
    }

    pub fn disassemble_controlflow<'a>(
        &'a self,
        addresses: BTreeSet<u64>,
        cfg: &'a mut Graph,
    ) -> Result<(), Error> {
        let pool = ThreadPoolBuilder::new()
            .num_threads(cfg.config.general.threads)
            .build()
            .map_err(|error| Error::other(format!("{}", error)))?;

        cfg.functions.enqueue_extend(addresses);

        let external_image = self.image;

        let external_machine = self.architecture;

        let external_executable_address_ranges = self.executable_address_ranges.clone();

        let external_metadata_token_addresses = self.metadata_token_addresses.clone();

        let external_config = self.config.clone();

        pool.install(|| {
            while !cfg.functions.queue.is_empty() {
                let function_addresses = cfg.functions.dequeue_all();
                cfg.functions
                    .insert_processed_extend(function_addresses.clone());
                let graphs: Vec<Graph> = function_addresses
                    .par_iter()
                    .map(|address| {
                        let machine = external_machine;
                        let executable_address_ranges = external_executable_address_ranges.clone();
                        let metadata_token_addresses = external_metadata_token_addresses.clone();
                        let image = external_image;
                        let mut graph = Graph::new(machine, cfg.config.clone());
                        if let Ok(disasm) = Disassembler::new(
                            machine,
                            image,
                            metadata_token_addresses,
                            executable_address_ranges,
                            external_config.clone(),
                        ) {
                            let _ = disasm.disassemble_function(*address, &mut graph);
                        }
                        graph
                    })
                    .collect();
                for mut graph in graphs {
                    cfg.absorb(&mut graph);
                }
            }
        });

        Ok(())
    }
}

```

`src/disassemblers/custom/cil/instruction.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::disassemblers::custom::cil::Mnemonic;
use crate::Binary;
use std::collections::BTreeSet;
use std::io::Error;

pub struct Instruction<'instruction> {
    pub mnemonic: Mnemonic,
    bytes: &'instruction [u8],
    pub address: u64,
}

impl<'instruction> Instruction<'instruction> {
    pub fn new(bytes: &'instruction [u8], address: u64) -> Result<Self, Error> {
        let mnemonic = Mnemonic::from_bytes(bytes)?;
        Ok(Self {
            mnemonic,
            bytes,
            address,
        })
    }

    pub fn pattern(&self) -> String {
        if self.is_wildcard() {
            return "??".repeat(self.size());
        }
        if self.is_metadata_token_wildcard_instruction() {
            let mut pattern = Binary::to_hex(&self.mnemonic_bytes());
            pattern.push_str(&"??".repeat(self.operand_size() - 1));
            pattern.push_str(&Binary::to_hex(std::slice::from_ref(
                self.operand_bytes().last().unwrap(),
            )));
            return pattern;
        }
        let mut pattern = Binary::to_hex(&self.mnemonic_bytes());
        pattern.push_str(&"??".repeat(self.operand_size()));
        pattern
    }

    pub fn mnemonic_bytes(&self) -> Vec<u8> {
        let mut result = Vec::<u8>::new();
        for byte in &self.bytes[..self.mnemonic_size()] {
            result.push(*byte);
        }
        result
    }

    pub fn bytes(&self) -> Vec<u8> {
        let mut result = Vec::<u8>::new();
        for byte in &self.bytes[..self.mnemonic_size() + self.operand_size()] {
            result.push(*byte);
        }
        result
    }

    pub fn operand_bytes(&self) -> Vec<u8> {
        let mut result = Vec::<u8>::new();
        for byte in &self.bytes[self.mnemonic_size()..self.mnemonic_size() + self.operand_size()] {
            result.push(*byte);
        }
        result
    }

    pub fn edges(&self) -> usize {
        if self.is_unconditional_jump() {
            return 1;
        }
        if self.is_return() {
            return 1;
        }
        if self.is_conditional_jump() {
            return 2;
        }
        0
    }

    pub fn size(&self) -> usize {
        self.mnemonic_size() + self.operand_size()
    }

    pub fn operand_size(&self) -> usize {
        if self.is_switch() {
            let count = self
                .bytes
                .get(self.mnemonic_size()..self.mnemonic_size() + 4)
                .and_then(|bytes| bytes.try_into().ok())
                .map(u32::from_le_bytes)
                .unwrap();
            return 4 + (count as usize * 4);
        }
        self.mnemonic.operand_size() / 8
    }

    pub fn mnemonic_size(&self) -> usize {
        if self.mnemonic as u16 >> 8 == 0xfe {
            return 2;
        }
        1
    }

    pub fn is_wildcard(&self) -> bool {
        self.is_nop()
    }

    pub fn is_nop(&self) -> bool {
        matches!(self.mnemonic, Mnemonic::Nop)
    }

    pub fn is_jump(&self) -> bool {
        self.is_conditional_jump() || self.is_unconditional_jump()
    }

    pub fn next(&self) -> Option<u64> {
        if self.is_unconditional_jump() || self.is_return() || self.is_switch() {
            return None;
        }
        Some(self.address + self.size() as u64)
    }

    pub fn to(&self) -> BTreeSet<u64> {
        let mut result = BTreeSet::<u64>::new();

        if self.is_switch() {
            let address = self.address as i64;
            let count = self
                .bytes
                .get(self.mnemonic_size()..self.mnemonic_size() + 4)
                .and_then(|bytes| bytes.try_into().ok())
                .map(u32::from_le_bytes)
                .unwrap();
            for index in 1..=count {
                let start = self.mnemonic_size() + (index as usize * 4);
                let end = start + 4;

                let relative_offset = self
                    .bytes
                    .get(start..end)
                    .and_then(|bytes| bytes.try_into().ok())
                    .map(i32::from_le_bytes)
                    .unwrap();

                result.insert(
                    address.wrapping_add(relative_offset as i64) as u64 + self.size() as u64,
                );
            }
        } else if self.is_jump() {
            let operand_bytes = self.operand_bytes();
            let address = self.address as i64;
            let relative_offset = match self.operand_size() {
                1 => operand_bytes
                    .first()
                    .map(|&b| i8::from_le_bytes([b]) as i64),
                2 => operand_bytes
                    .get(..2)
                    .and_then(|bytes| bytes.try_into().ok())
                    .map(i16::from_le_bytes)
                    .map(|v| v as i64),
                4 => operand_bytes
                    .get(..4)
                    .and_then(|bytes| bytes.try_into().ok())
                    .map(i32::from_le_bytes)
                    .map(|v| v as i64),
                _ => None,
            };
            if let Some(relative) = relative_offset {
                result.insert(address.wrapping_add(relative) as u64 + self.size() as u64);
            }
        }
        result
    }

    pub fn is_switch(&self) -> bool {
        matches!(self.mnemonic, Mnemonic::Switch)
    }

    pub fn is_metadata_token_wildcard_instruction(&self) -> bool {
        matches!(
            self.mnemonic,
            Mnemonic::Call
                | Mnemonic::CallVirt
                | Mnemonic::LdSFld
                | Mnemonic::LdFld
                | Mnemonic::NewObj
        )
    }

    pub fn get_call_metadata_token(&self) -> Option<u32> {
        if matches!(self.mnemonic, Mnemonic::Call | Mnemonic::CallVirt) {
            let operand_bytes = self.operand_bytes();
            if operand_bytes.len() >= 4 {
                return Some(u32::from_le_bytes([
                    operand_bytes[0],
                    operand_bytes[1],
                    operand_bytes[2],
                    operand_bytes[3],
                ]));
            }
        }
        None
    }

    pub fn is_conditional_jump(&self) -> bool {
        matches!(
            self.mnemonic,
            Mnemonic::BrFalse
                | Mnemonic::BrFalseS
                | Mnemonic::BrTrue
                | Mnemonic::BrTrueS
                | Mnemonic::BneUn
                | Mnemonic::BneUnS
                | Mnemonic::Blt
                | Mnemonic::BltS
                | Mnemonic::BltUn
                | Mnemonic::BltUnS
                | Mnemonic::Beq
                | Mnemonic::BeqS
                | Mnemonic::Bge
                | Mnemonic::BgeS
                | Mnemonic::BgeUn
                | Mnemonic::BgeUnS
                | Mnemonic::Bgt
                | Mnemonic::BgtS
                | Mnemonic::BgtUn
                | Mnemonic::BgtUnS
                | Mnemonic::Ble
                | Mnemonic::BleS
                | Mnemonic::BleUn
                | Mnemonic::BleUnS
        )
    }

    pub fn is_return(&self) -> bool {
        matches!(self.mnemonic, Mnemonic::Ret | Mnemonic::Throw)
    }

    pub fn is_call(&self) -> bool {
        matches!(
            self.mnemonic,
            Mnemonic::Call | Mnemonic::CallI | Mnemonic::CallVirt
        )
    }

    pub fn is_unconditional_jump(&self) -> bool {
        matches!(
            self.mnemonic,
            Mnemonic::Br | Mnemonic::Jmp | Mnemonic::BrS | Mnemonic::Leave | Mnemonic::LeaveS
        )
    }
}

```

`src/disassemblers/custom/cil/mnemonic.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::io::Error;
use std::io::ErrorKind;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Mnemonic {
    Add = 0x58,
    AddOvf = 0xD6,
    AddOvfUn = 0xD7,
    And = 0x5F,
    Beq = 0x3B,
    BeqS = 0x2E,
    Bge = 0x3C,
    BgeS = 0x2F,
    BgeUn = 0x41,
    BgeUnS = 0x34,
    Bgt = 0x3D,
    BgtS = 0x30,
    BgtUn = 0x42,
    BgtUnS = 0x35,
    Ble = 0x3E,
    BleS = 0x31,
    BleUn = 0x43,
    BleUnS = 0x36,
    Blt = 0x3F,
    BltS = 0x32,
    BltUn = 0x44,
    BltUnS = 0x37,
    BneUn = 0x40,
    BneUnS = 0x33,
    Box = 0x8C,
    Br = 0x38,
    BrS = 0x2B,
    Break = 0x01,
    BrFalse = 0x39,
    BrFalseS = 0x2C,
    BrTrue = 0x3A,
    BrTrueS = 0x2D,
    Call = 0x28,
    CallI = 0x29,
    CallVirt = 0x6F,
    CastClass = 0x74,
    CkInite = 0xC3,
    ConvI = 0xD3,
    ConvI1 = 0x67,
    ConvI2 = 0x68,
    ConvI4 = 0x69,
    ConvI8 = 0x6A,
    ConvOvfI = 0xD4,
    ConvOvfIUn = 0x8A,
    ConvOvfI1 = 0xB3,
    ConvOvfI1Un = 0x82,
    ConvOvfI2 = 0xB5,
    ConvOvfI2Un = 0x83,
    ConvOvfI4 = 0xB7,
    ConvOvfI4Un = 0x84,
    ConvOvfI8 = 0xB9,
    ConvOvfI8Un = 0x85,
    ConvOvfU = 0xD5,
    ConvOvfUUn = 0x8B,
    ConvOvfU1 = 0xB4,
    ConvOvfU1Un = 0x86,
    ConvOvfU2 = 0xB6,
    ConvOvfU2Un = 0x87,
    ConvOvfU4 = 0xB8,
    ConvOvfU4Un = 0x88,
    ConvOvfU8 = 0xBA,
    ConvOvfU8Un = 0x89,
    ConvRUn = 0x76,
    ConvR4 = 0x6B,
    ConvR8 = 0x6C,
    ConvU = 0xE0,
    ConvU1 = 0xD2,
    ConvU2 = 0xD1,
    ConvU4 = 0x6D,
    ConvU8 = 0x6E,
    Cpobj = 0x70,
    Div = 0x5B,
    DivUn = 0x5C,
    DUP = 0x25,
    End = 0xDC,
    IsInst = 0x75,
    Jmp = 0x27,
    LdArg0 = 0x02,
    LdArg1 = 0x03,
    LdArg2 = 0x04,
    LdArg3 = 0x05,
    LdArgS = 0x0E,
    LdArgAS = 0x0F,
    LdcI4 = 0x20,
    LdcI40 = 0x16,
    LdcI41 = 0x17,
    LdcI42 = 0x18,
    LdcI43 = 0x19,
    LdcI44 = 0x1A,
    LdcI45 = 0x1B,
    LdcI46 = 0x1C,
    LdcI47 = 0x1D,
    LdcI48 = 0x1E,
    LdcI4M1 = 0x15,
    LdcI4S = 0x1F,
    LdcI8 = 0x21,
    LdcR4 = 0x22,
    LdcR8 = 0x23,
    LdElm = 0xA3,
    LdElmI = 0x97,
    LdElmI1 = 0x90,
    LdElmI2 = 0x92,
    LdElmI4 = 0x94,
    LdElmU8 = 0x96,
    LdElmR4 = 0x98,
    LdElmR8 = 0x99,
    LdElmRef = 0x9A,
    LdElmU1 = 0x91,
    LdElmU2 = 0x93,
    LdElmU4 = 0x95,
    LdElmA = 0x8F,
    LdFld = 0x7B,
    LdFldA = 0x7C,
    LdIndI = 0x4D,
    LdIndI1 = 0x46,
    LdIndI2 = 0x48,
    LdIndI4 = 0x4A,
    LdIndU8 = 0x4C,
    LdIndR4 = 0x4E,
    LdIndR8 = 0x4F,
    LdIndRef = 0x50,
    LdIndU1 = 0x47,
    LdIndU2 = 0x49,
    LdIndU4 = 0x4B,
    LdLen = 0x8E,
    LdLoc0 = 0x06,
    LdLoc1 = 0x07,
    LdLoc2 = 0x08,
    LdLoc3 = 0x09,
    LdLocS = 0x11,
    LdLocAS = 0x12,
    LdNull = 0x14,
    LdObj = 0x71,
    LdSFld = 0x7E,
    LdSFldA = 0x7F,
    LdStr = 0x72,
    LdToken = 0xD0,
    Leave = 0xDD,
    LeaveS = 0xDE,
    MkRefAny = 0xC6,
    Mul = 0x5A,
    MulOvf = 0xD8,
    MulOvfUn = 0xD9,
    Neg = 0x65,
    NewArr = 0x8D,
    NewObj = 0x73,
    Nop = 0x00,
    Not = 0x66,
    Or = 0x60,
    Pop = 0x26,
    RefAnyVal = 0xC2,
    Rem = 0x5D,
    RemUn = 0x5E,
    Ret = 0x2A,
    Shl = 0x62,
    Shr = 0x63,
    ShrUn = 0x64,
    StArgS = 0x10,
    StElem = 0xA4,
    StElemI = 0x9B,
    StElemI1 = 0x9C,
    StElemI2 = 0x9D,
    StElemI4 = 0x9E,
    StElemI8 = 0x9F,
    StElemR4 = 0xA0,
    StElemR8 = 0xA1,
    StElemREF = 0xA2,
    StFld = 0x7D,
    StIndI = 0xDF,
    StIndI1 = 0x52,
    StIndI2 = 0x53,
    StIndI4 = 0x54,
    StIndI8 = 0x55,
    StIndR4 = 0x56,
    StIndR8 = 0x57,
    StIndRef = 0x51,
    StLoc0 = 0x0A,
    StLoc1 = 0x0B,
    StLoc2 = 0x0C,
    StLoc3 = 0x0D,
    StObj = 0x81,
    StSFld = 0x80,
    Sub = 0x59,
    SubOvf = 0xDA,
    SubOvfUn = 0xDB,
    Switch = 0x45,
    Throw = 0x7A,
    Unbox = 0x79,
    UnboxAny = 0xA5,
    Xor = 0x61,
    StLocS = 0x13,
    ArgList = 0xfe00,
    Ceq = 0xfe01,
    Cgt = 0xfe02,
    CgtUn = 0xfe03,
    Clt = 0xfe04,
    CltUn = 0xfe05,
    Constrained = 0xfe16,
    CpBlk = 0xfe17,
    EndFilter = 0xfe11,
    InitBlk = 0xfe18,
    InitObj = 0xfe15,
    LdArg = 0xfe09,
    LdArgA = 0xfe0a,
    LdFtn = 0xfe06,
    LdLoc = 0xfe0c,
    LdLocA = 0xfe0d,
    LdVirtFtn = 0xfe07,
    LocAlloc = 0xfe0f,
    No = 0xfe19,
    ReadOnly = 0xfe1e,
    RefAnyType = 0xfe1d,
    ReThrow = 0xfe1a,
    SizeOf = 0xfe1c,
    StArg = 0xfe0b,
    SLoc = 0xfe0e,
    Tail = 0xfe14,
    Unaligned = 0xfe12,
    Volatile = 0xfe13,
}

impl Mnemonic {
    pub const fn all_variants() -> &'static [Self] {
        &[
            Self::Add,
            Self::AddOvf,
            Self::AddOvfUn,
            Self::And,
            Self::Beq,
            Self::BeqS,
            Self::Bge,
            Self::BgeS,
            Self::BgeUn,
            Self::BgeUnS,
            Self::Bgt,
            Self::BgtS,
            Self::BgtUn,
            Self::BgtUnS,
            Self::Ble,
            Self::BleS,
            Self::BleUn,
            Self::BleUnS,
            Self::Blt,
            Self::BltS,
            Self::BltUn,
            Self::BltUnS,
            Self::BneUn,
            Self::BneUnS,
            Self::Box,
            Self::Br,
            Self::BrS,
            Self::Break,
            Self::BrFalse,
            Self::BrFalseS,
            Self::BrTrue,
            Self::BrTrueS,
            Self::Call,
            Self::CallI,
            Self::CallVirt,
            Self::CastClass,
            Self::CkInite,
            Self::ConvI,
            Self::ConvI1,
            Self::ConvI2,
            Self::ConvI4,
            Self::ConvI8,
            Self::ConvOvfI,
            Self::ConvOvfIUn,
            Self::ConvOvfI1,
            Self::ConvOvfI1Un,
            Self::ConvOvfI2,
            Self::ConvOvfI2Un,
            Self::ConvOvfI4,
            Self::ConvOvfI4Un,
            Self::ConvOvfI8,
            Self::ConvOvfI8Un,
            Self::ConvOvfU,
            Self::ConvOvfUUn,
            Self::ConvOvfU1,
            Self::ConvOvfU1Un,
            Self::ConvOvfU2,
            Self::ConvOvfU2Un,
            Self::ConvOvfU4,
            Self::ConvOvfU4Un,
            Self::ConvOvfU8,
            Self::ConvOvfU8Un,
            Self::ConvRUn,
            Self::ConvR4,
            Self::ConvR8,
            Self::ConvU,
            Self::ConvU1,
            Self::ConvU2,
            Self::ConvU4,
            Self::ConvU8,
            Self::Cpobj,
            Self::Div,
            Self::DivUn,
            Self::DUP,
            Self::End,
            Self::IsInst,
            Self::Jmp,
            Self::LdArg0,
            Self::LdArg1,
            Self::LdArg2,
            Self::LdArg3,
            Self::LdArgS,
            Self::LdArgAS,
            Self::LdcI4,
            Self::LdcI40,
            Self::LdcI41,
            Self::LdcI42,
            Self::LdcI43,
            Self::LdcI44,
            Self::LdcI45,
            Self::LdcI46,
            Self::LdcI47,
            Self::LdcI48,
            Self::LdcI4M1,
            Self::LdcI4S,
            Self::LdcI8,
            Self::LdcR4,
            Self::LdcR8,
            Self::LdElm,
            Self::LdElmI,
            Self::LdElmI1,
            Self::LdElmI2,
            Self::LdElmI4,
            Self::LdElmU8,
            Self::LdElmR4,
            Self::LdElmR8,
            Self::LdElmRef,
            Self::LdElmU1,
            Self::LdElmU2,
            Self::LdElmU4,
            Self::LdElmA,
            Self::LdFld,
            Self::LdFldA,
            Self::LdIndI,
            Self::LdIndI1,
            Self::LdIndI2,
            Self::LdIndI4,
            Self::LdIndU8,
            Self::LdIndR4,
            Self::LdIndR8,
            Self::LdIndRef,
            Self::LdIndU1,
            Self::LdIndU2,
            Self::LdIndU4,
            Self::LdLen,
            Self::LdLoc0,
            Self::LdLoc1,
            Self::LdLoc2,
            Self::LdLoc3,
            Self::LdLocS,
            Self::LdLocAS,
            Self::LdNull,
            Self::LdObj,
            Self::LdSFld,
            Self::LdSFldA,
            Self::LdStr,
            Self::LdToken,
            Self::Leave,
            Self::LeaveS,
            Self::MkRefAny,
            Self::Mul,
            Self::MulOvf,
            Self::MulOvfUn,
            Self::Neg,
            Self::NewArr,
            Self::NewObj,
            Self::Nop,
            Self::Not,
            Self::Or,
            Self::Pop,
            Self::RefAnyVal,
            Self::Rem,
            Self::RemUn,
            Self::Ret,
            Self::Shl,
            Self::Shr,
            Self::ShrUn,
            Self::StArgS,
            Self::StElem,
            Self::StElemI,
            Self::StElemI1,
            Self::StElemI2,
            Self::StElemI4,
            Self::StElemI8,
            Self::StElemR4,
            Self::StElemR8,
            Self::StElemREF,
            Self::StFld,
            Self::StIndI,
            Self::StIndI1,
            Self::StIndI2,
            Self::StIndI4,
            Self::StIndI8,
            Self::StIndR4,
            Self::StIndR8,
            Self::StIndRef,
            Self::StLoc0,
            Self::StLoc1,
            Self::StLoc2,
            Self::StLoc3,
            Self::StObj,
            Self::StSFld,
            Self::Sub,
            Self::SubOvf,
            Self::SubOvfUn,
            Self::Switch,
            Self::Throw,
            Self::Unbox,
            Self::UnboxAny,
            Self::Xor,
            Self::StLocS,
            Self::ArgList,
            Self::Ceq,
            Self::Cgt,
            Self::CgtUn,
            Self::Clt,
            Self::CltUn,
            Self::Constrained,
            Self::CpBlk,
            Self::EndFilter,
            Self::InitBlk,
            Self::InitObj,
            Self::LdArg,
            Self::LdArgA,
            Self::LdFtn,
            Self::LdLoc,
            Self::LdLocA,
            Self::LdVirtFtn,
            Self::LocAlloc,
            Self::No,
            Self::ReadOnly,
            Self::RefAnyType,
            Self::ReThrow,
            Self::SizeOf,
            Self::StArg,
            Self::SLoc,
            Self::Tail,
            Self::Unaligned,
            Self::Volatile,
        ]
    }

    pub fn operand_size(&self) -> usize {
        match self {
            Self::Ceq => 0,
            Self::ArgList => 0,
            Self::Cgt => 0,
            Self::CgtUn => 0,
            Self::Clt => 0,
            Self::CltUn => 0,
            Self::Constrained => 32,
            Self::CpBlk => 0,
            Self::EndFilter => 0,
            Self::InitBlk => 0,
            Self::InitObj => 32,
            Self::LdArg => 16,
            Self::LdArgA => 32,
            Self::LdFtn => 32,
            Self::LdLoc => 16,
            Self::LdLocA => 16,
            Self::LdVirtFtn => 32,
            Self::LocAlloc => 0,
            Self::No => 0,
            Self::ReadOnly => 32,
            Self::RefAnyType => 0,
            Self::ReThrow => 0,
            Self::SizeOf => 32,
            Self::StArg => 16,
            Self::Tail => 0,
            Self::Unaligned => 0,
            Self::Volatile => 32,
            Self::Beq => 32,
            Self::BeqS => 8,
            Self::Bge => 32,
            Self::BgeS => 8,
            Self::BgeUn => 32,
            Self::BgeUnS => 8,
            Self::Bgt => 32,
            Self::BgtS => 8,
            Self::Ble => 32,
            Self::BleS => 8,
            Self::BleUn => 32,
            Self::BleUnS => 8,
            Self::Blt => 32,
            Self::BltS => 8,
            Self::BltUn => 32,
            Self::BltUnS => 8,
            Self::Box => 32,
            Self::Br => 32,
            Self::BrS => 8,
            Self::Break => 0,
            Self::BrFalse => 32,
            Self::BrFalseS => 8,
            Self::BrTrue => 32,
            Self::BrTrueS => 8,
            Self::Add => 0,
            Self::AddOvf => 0,
            Self::AddOvfUn => 0,
            Self::And => 0,
            Self::CastClass => 32,
            Self::CkInite => 0,
            Self::ConvI => 0,
            Self::ConvI1 => 0,
            Self::ConvI2 => 0,
            Self::ConvI4 => 0,
            Self::ConvI8 => 0,
            Self::ConvOvfI => 0,
            Self::ConvOvfIUn => 0,
            Self::ConvOvfI1 => 0,
            Self::ConvOvfI1Un => 0,
            Self::ConvOvfI2 => 0,
            Self::ConvOvfI2Un => 0,
            Self::ConvOvfI4 => 0,
            Self::ConvOvfI4Un => 0,
            Self::ConvOvfI8 => 0,
            Self::ConvOvfI8Un => 0,
            Self::ConvOvfU => 0,
            Self::ConvOvfUUn => 0,
            Self::ConvOvfU1 => 0,
            Self::ConvOvfU1Un => 0,
            Self::ConvOvfU2 => 0,
            Self::ConvOvfU2Un => 0,
            Self::ConvOvfU4 => 0,
            Self::ConvOvfU4Un => 0,
            Self::ConvOvfU8 => 0,
            Self::ConvOvfU8Un => 0,
            Self::ConvRUn => 0,
            Self::ConvR4 => 0,
            Self::ConvR8 => 0,
            Self::ConvU => 0,
            Self::ConvU1 => 0,
            Self::ConvU2 => 0,
            Self::ConvU4 => 0,
            Self::ConvU8 => 0,
            Self::Cpobj => 32,
            Self::Div => 0,
            Self::DivUn => 0,
            Self::DUP => 0,
            Self::IsInst => 32,
            Self::Jmp => 32,
            Self::LdArg0 => 0,
            Self::LdArg1 => 0,
            Self::LdArg2 => 0,
            Self::LdArg3 => 0,
            Self::LdArgS => 8,
            Self::LdArgAS => 8,
            Self::LdcI4 => 32,
            Self::LdcI40 => 0,
            Self::LdcI41 => 0,
            Self::LdcI42 => 0,
            Self::LdcI43 => 0,
            Self::LdcI44 => 0,
            Self::LdcI45 => 0,
            Self::LdcI46 => 0,
            Self::LdcI47 => 0,
            Self::LdcI48 => 0,
            Self::LdcI4M1 => 0,
            Self::LdcI4S => 8,
            Self::LdcI8 => 64,
            Self::LdcR4 => 32,
            Self::LdcR8 => 64,
            Self::LdElm => 32,
            Self::LdElmI => 0,
            Self::LdElmI1 => 0,
            Self::LdElmI2 => 0,
            Self::LdElmI4 => 0,
            Self::LdElmU8 => 0,
            Self::LdElmR4 => 0,
            Self::LdElmR8 => 0,
            Self::LdElmRef => 0,
            Self::LdElmU1 => 0,
            Self::LdElmU2 => 0,
            Self::LdElmU4 => 0,
            Self::LdElmA => 32,
            Self::LdFld => 32,
            Self::LdFldA => 32,
            Self::LdIndI => 0,
            Self::LdIndI1 => 0,
            Self::LdIndI2 => 0,
            Self::LdIndI4 => 0,
            Self::LdIndU8 => 0,
            Self::LdIndR4 => 0,
            Self::LdIndR8 => 0,
            Self::LdIndU1 => 0,
            Self::LdIndU2 => 0,
            Self::LdIndU4 => 0,
            Self::LdLen => 0,
            Self::LdLoc0 => 0,
            Self::LdLoc1 => 0,
            Self::LdLoc2 => 0,
            Self::LdLoc3 => 0,
            Self::LdLocS => 8,
            Self::LdLocAS => 8,
            Self::LdNull => 0,
            Self::LdObj => 32,
            Self::LdSFld => 32,
            Self::LdSFldA => 32,
            Self::LdStr => 32,
            Self::LdToken => 32,
            Self::Leave => 32,
            Self::LeaveS => 8,
            Self::MkRefAny => 32,
            Self::Mul => 0,
            Self::MulOvf => 0,
            Self::MulOvfUn => 0,
            Self::Neg => 0,
            Self::NewArr => 32,
            Self::NewObj => 32,
            Self::Nop => 0,
            Self::Not => 0,
            Self::Or => 0,
            Self::Pop => 0,
            Self::RefAnyVal => 32,
            Self::Rem => 0,
            Self::RemUn => 0,
            Self::Ret => 0,
            Self::Shl => 0,
            Self::Shr => 0,
            Self::ShrUn => 0,
            Self::StArgS => 8,
            Self::StElem => 32,
            Self::StElemI => 0,
            Self::StElemI2 => 0,
            Self::StElemI4 => 0,
            Self::StElemI8 => 0,
            Self::StElemR4 => 0,
            Self::StElemR8 => 0,
            Self::StElemREF => 0,
            Self::StFld => 32,
            Self::StIndI => 0,
            Self::StIndI2 => 0,
            Self::StIndI8 => 0,
            Self::StIndR4 => 0,
            Self::StIndR8 => 0,
            Self::StIndRef => 0,
            Self::StLocS => 8,
            Self::StLoc0 => 0,
            Self::StLoc1 => 0,
            Self::StLoc2 => 0,
            Self::StLoc3 => 0,
            Self::StObj => 32,
            Self::StSFld => 32,
            Self::Sub => 0,
            Self::SubOvf => 0,
            Self::SubOvfUn => 0,
            Self::Switch => 32,
            Self::Throw => 0,
            Self::Unbox => 32,
            Self::UnboxAny => 32,
            Self::Xor => 0,
            Self::Call => 32,
            Self::CallI => 32,
            Self::CallVirt => 32,
            Self::BneUnS => 8,
            Self::BneUn => 32,
            Self::BgtUn => 32,
            Self::BgtUnS => 8,
            _ => 0,
        }
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, Error> {
        if bytes.is_empty() {
            return Err(Error::other("not enough bytes to parse mnemonic"));
        }

        let value = bytes[0] as u16;
        for &mnemonic in Self::all_variants() {
            if (mnemonic as u16) == value {
                return Ok(mnemonic);
            }
        }

        if bytes[0] == 0xfe {
            if bytes.len() < 2 {
                return Err(Error::other("not enough bytes for prefix instruction"));
            }
            let value = u16::from_be_bytes([bytes[0], bytes[1]]);
            for &mnemonic in Self::all_variants() {
                if (mnemonic as u16) == value {
                    return Ok(mnemonic);
                }
            }
        }

        Err(Error::new(
            ErrorKind::NotFound,
            "0x{:x}: no matching mnemonic found",
        ))
    }
}

```

`src/disassemblers/custom/cil/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod disassembler;
pub mod mnemonic;
pub mod instruction;

pub use disassembler::Disassembler;
pub use mnemonic::Mnemonic;
pub use instruction::Instruction;

```

`src/disassemblers/custom/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod cil;

```

`src/disassemblers/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod capstone;
pub mod custom;

```

`src/formats/cli.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::mem;

/// Represents a metadata token type in a .NET metadata structure.
///
/// The `MetadataToken` enum defines various types of metadata tokens used to identify
/// rows in different metadata tables within a .NET assembly.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MetadataToken {
    Module = 0,
    TypeRef = 1,
    TypeDef = 2,
    FieldPtr = 3,
    Field = 4,
    MethodPtr = 5,
    MethodDef = 6,
    ParamPtr = 7,
    Param = 8,
    InterfaceImpl = 9,
    MemberRef = 10,
    Constant = 11,
    CustomAttribute = 12,
    FieldMarshal = 13,
    DeclSecurity = 14,
    ClassLayout = 15,
    FieldLayout = 16,
    StandAloneSig = 17,
    EventMap = 18,
    EventPtr = 19,
    Event = 20,
    PropertyMap = 21,
    PropertyPtr = 22,
    Property = 23,
    MethodSemantics = 24,
    MethodImpl = 25,
    ModuleRef = 26,
    TypeSpec = 27,
    ImplMap = 28,
    FieldRva = 29,
    EncLog = 30,
    EncMap = 31,
    Assembly = 32,
    AssemblyProcessor = 33,
    AssemblyOs = 34,
    AssemblyRef = 35,
    AssemblyRefProcessor = 36,
    AssemblyRefOs = 37,
    File = 38,
    ExportedType = 39,
    ManifestResource = 40,
    NestedClass = 41,
    GenericParam = 42,
    MethodSpec = 43,
    GenericParamConstraint = 44,
    Document = 48,
    MethodDebugInformation = 49,
    LocalScope = 50,
    LocalVariable = 51,
    LocalConstant = 52,
    ImportScope = 53,
    StateMachineMethod = 54,
    CustomDebugInformation = 55,
}

/// Represents an image data directory in a .NET metadata structure.
///
/// The `ImageDataDirectory` provides information about a specific data directory,
/// including its virtual address and size.
#[repr(C)]
pub struct ImageDataDirectory {
    /// A `u32` value representing the virtual address of the data directory.
    pub virtual_address: u32,
    /// A `u32` value representing the size of the data directory.
    pub size: u32,
}

/// Represents the anonymous field in the `Cor20Header`, used to define the entry point.
///
/// The `Cor20Header0` union allows for two possible representations:
/// an entry point token for managed code or an RVA for native code.
#[repr(C)]
pub union Cor20Header0 {
    /// A `u32` value representing the entry point token for managed code.
    pub entry_point_token: u32,
    /// A `u32` value representing the RVA of the entry point for native code.
    pub entry_point_rva: u32,
}

/// Represents the .NET COR20 header in a PE file.
///
/// The `Cor20Header` provides information about the Common Language Runtime (CLR)
/// metadata, versioning, and related data structures required for .NET assemblies.
#[repr(C)]
pub struct Cor20Header {
    /// A `u32` value representing the size of the header in bytes.
    pub cb: u32,
    /// A `u16` value indicating the major version of the CLR runtime.
    pub major_runtime_version: u16,
    /// A `u16` value indicating the minor version of the CLR runtime.
    pub minor_runtime_version: u16,
    /// An `ImageDataDirectory` pointing to the metadata.
    pub meta_data: ImageDataDirectory,
    /// A `u32` value representing various flags related to the assembly.
    pub flags: u32,
    /// A `Cor20Header0` union containing either an entry point token or an RVA.
    pub anonymous: Cor20Header0,
    /// An `ImageDataDirectory` pointing to resources in the assembly.
    pub resources: ImageDataDirectory,
    /// An `ImageDataDirectory` pointing to the strong name signature.
    pub strong_name_signature: ImageDataDirectory,
    /// An `ImageDataDirectory` pointing to the code manager table.
    pub code_manager_table: ImageDataDirectory,
    /// An `ImageDataDirectory` pointing to VTable fixups.
    pub vtable_fixups: ImageDataDirectory,
    /// An `ImageDataDirectory` pointing to export address table jumps.
    pub export_address_table_jumps: ImageDataDirectory,
    /// An `ImageDataDirectory` pointing to the managed native header.
    pub managed_native_header: ImageDataDirectory,
}

impl Cor20Header {
    /// Parses a `Cor20Header` from a byte slice.
    ///
    /// This function validates the size and alignment of the byte slice before returning
    /// a reference to the `Cor20Header`.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the `Cor20Header` data.
    ///
    /// # Returns
    ///
    /// * `Some(&Cor20Header)` - A reference to the parsed `Cor20Header` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid, does not contain enough data, or is misaligned.
    pub fn from_bytes(bytes: &[u8]) -> Option<&Self> {
        if bytes.len() != mem::size_of::<Self>() {
            return None;
        }
        Some(unsafe { &*(bytes.as_ptr() as *const Self) })
    }

    pub fn size() -> usize {
        mem::size_of::<Self>()
    }
}

/// Represents the storage signature in a .NET metadata structure.
///
/// The `StorageSignature` contains metadata about the storage, including its signature,
/// version, and additional data fields.
#[repr(C)]
pub struct StorageSignature {
    /// A `u32` value representing the storage signature.
    pub signature: u32,
    /// A `u16` value indicating the major version of the storage.
    pub major_version: u16,
    /// A `u16` value indicating the minor version of the storage.
    pub minor_version: u16,
    /// A `u32` value containing additional data.
    pub extra_data: u32,
    /// A `u32` value specifying the size of the version string.
    pub version_string_size: u32,
    /// A `u32` value referencing the version string.
    pub version_string: u32,
}

impl StorageSignature {
    /// Parses a `StorageSignature` from a byte slice.
    ///
    /// This function validates the size and alignment of the byte slice before returning
    /// a reference to the `StorageSignature`.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the `StorageSignature` data.
    ///
    /// # Returns
    ///
    /// * `Some(&StorageSignature)` - A reference to the parsed `StorageSignature` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid, does not contain enough data, or is misaligned.
    pub fn from_bytes(bytes: &[u8]) -> Option<&Self> {
        if bytes.len() != mem::size_of::<Self>() {
            return None;
        }
        Some(unsafe { &*(bytes.as_ptr() as *const Self) })
    }

    pub fn size() -> usize {
        mem::size_of::<Self>()
    }
}

/// Represents the storage header in a .NET metadata structure.
///
/// The `StorageHeader` provides metadata about the storage streams, including the number
/// of streams and associated flags.
#[repr(C)]
pub struct StorageHeader {
    /// A `u8` value representing the storage flags.
    pub flags: u8,
    /// A `u8` value for padding (reserved).
    pub pad: u8,
    /// A `u16` value indicating the number of streams in the storage.
    pub number_of_streams: u16,
}

impl StorageHeader {
    /// Parses a `StorageHeader` from a byte slice.
    ///
    /// This function validates the size and alignment of the byte slice before returning
    /// a reference to the `StorageHeader`.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the `StorageHeader` data.
    ///
    /// # Returns
    ///
    /// * `Some(&StorageHeader)` - A reference to the parsed `StorageHeader` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid, does not contain enough data, or is misaligned.
    pub fn from_bytes(bytes: &[u8]) -> Option<&Self> {
        if bytes.len() != mem::size_of::<Self>() {
            return None;
        }
        Some(unsafe { &*(bytes.as_ptr() as *const Self) })
    }

    pub fn size() -> usize {
        mem::size_of::<Self>()
    }
}

/// Represents a stream header in a .NET metadata structure.
///
/// The `StreamHeader` contains metadata about a stream, including its offset and size,
/// and provides methods to retrieve its name and the total header size.
#[repr(C)]
pub struct StreamHeader {
    /// The offset of the stream in the metadata section.
    pub offset: u32,
    /// The size of the stream in bytes.
    pub size: u32,
}

impl StreamHeader {
    /// Parses a `StreamHeader` from a byte slice.
    ///
    /// This function validates that the byte slice contains enough data for a `StreamHeader`
    /// and returns a reference to it.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the `StreamHeader` data.
    ///
    /// # Returns
    ///
    /// * `Some(&StreamHeader)` - A reference to the parsed `StreamHeader` if the byte slice is valid.
    /// * `None` - If the byte slice is too short to contain a valid `StreamHeader`.
    ///
    pub fn from_bytes(bytes: &[u8]) -> Option<&Self> {
        if bytes.len() < mem::size_of::<StreamHeader>() {
            return None;
        }
        Some(unsafe { &*(bytes.as_ptr() as *const StreamHeader) })
    }

    /// Retrieves the name of the stream as a byte slice, including any padding.
    ///
    /// This method locates the null-terminated name string following the `StreamHeader` fields
    /// and includes padding up to a 4-byte boundary.
    ///
    /// # Returns
    ///
    /// * `&[u8]` - A slice containing the name of the stream with padding.
    pub fn name(&self) -> &[u8] {
        let header_size = mem::size_of::<StreamHeader>();
        let base_ptr = self as *const Self as *const u8;

        unsafe {
            let name_ptr = base_ptr.add(header_size);

            let mut len = 0;
            while *name_ptr.add(len) != 0 {
                len += 1;
            }

            let padded_len = (len + 4) & !3;

            std::slice::from_raw_parts(name_ptr, padded_len)
        }
    }

    /// Calculates the total size of the `StreamHeader` including the name and padding.
    ///
    /// The size includes the fixed fields of the `StreamHeader` and the length of the name
    /// (rounded to a 4-byte boundary).
    ///
    /// # Returns
    ///
    /// * `usize` - The total size of the `StreamHeader` in bytes.
    pub fn size() -> usize {
        mem::size_of::<Self>()
        // let header_size = mem::size_of::<StreamHeader>();
        // header_size + self.name().len()
    }
}

/// Represents a Metadata Table header in a .NET metadata structure.
///
/// The `MetadataTable` provides information about the structure and versioning of
/// the metadata, as well as the sizes and characteristics of various heaps.
#[repr(C)]
pub struct MetadataTable {
    /// Reserved space, typically set to zero.
    pub reserved: u32,
    /// The major version of the metadata.
    pub major_version: u8,
    /// The minor version of the metadata.
    pub minor_version: u8,
    /// A bitfield indicating the sizes of the various heaps (e.g., String, GUID, Blob).
    pub heap_sizes: u8,
    /// The RID (Row ID) base, typically used for addressing rows in tables.
    pub rid: u8,
    /// A bitmask indicating which tables are present in the metadata.
    pub mask_valid: u64,
    /// A bitmask indicating which tables are sorted.
    pub mask_sorted: u64,
}

impl MetadataTable {
    /// Parses a `MetadataTable` from a byte slice.
    ///
    /// This function validates the size and alignment of the byte slice before
    /// returning a reference to the `MetadataTable`.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the `MetadataTable` data.
    ///
    /// # Returns
    ///
    /// * `Some(&MetadataTable)` - A reference to the parsed `MetadataTable` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid, does not contain enough data, or is misaligned.
    pub fn from_bytes(bytes: &[u8]) -> Option<&Self> {
        if bytes.len() != mem::size_of::<Self>() {
            return None;
        }
        Some(unsafe { &*(bytes.as_ptr() as *const Self) })
    }

    pub fn size() -> usize {
        mem::size_of::<Self>()
    }
}

/// Represents an entry in the Module table in a .NET metadata structure.
///
/// The `ModuleEntry` provides information about a module, including its generation,
/// name, and GUIDs for module versioning and edit-and-continue (ENC) information.
#[repr(C)]
pub struct ModuleEntry {
    /// A `u16` value representing the generation of the module.
    pub generation: u16,
    /// A `StringHeapIndex` referencing the module's name in the String heap.
    pub name: StringHeapIndex,
    /// A `GuidHeapIndex` referencing the module version ID in the GUID heap.
    pub mv_id: GuidHeapIndex,
    /// A `GuidHeapIndex` referencing the edit-and-continue (ENC) ID in the GUID heap.
    pub enc_id: GuidHeapIndex,
    /// A `GuidHeapIndex` referencing the edit-and-continue base ID in the GUID heap.
    pub enc_base_id: GuidHeapIndex,
}

impl ModuleEntry {
    /// Parses a `ModuleEntry` from a byte slice based on the heap size.
    ///
    /// This function extracts the fields of the `ModuleEntry` from the given byte slice,
    /// validating and parsing each component, such as `StringHeapIndex` and `GuidHeapIndex`.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the `ModuleEntry` data.
    /// * `heap_size` - A `u8` value indicating the size of the heap, which affects how indices are parsed.
    ///
    /// # Returns
    ///
    /// * `Some(ModuleEntry)` - The parsed `ModuleEntry` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        if bytes.len() < 2 { return None; }
        let generation = u16::from_le_bytes(bytes[0..2].try_into().unwrap());
        let mut offset: usize = mem::size_of::<u16>();
        let name = StringHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += name.size();
        let mv_id = GuidHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += mv_id.size();
        let enc_id = GuidHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += enc_id.size();
        let enc_base_id = GuidHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        Some(Self {
            generation,
            name,
            mv_id,
            enc_id,
            enc_base_id,
        })
    }

    /// Returns the size of the `ModuleEntry` in bytes.
    ///
    /// This method calculates the size of the entry, accounting for variable-sized
    /// fields like `StringHeapIndex` and `GuidHeapIndex`.
    ///
    /// # Returns
    ///
    /// * `usize` - The total size of the `ModuleEntry` in bytes.
    pub fn size(&self) -> usize {
        let mut size: usize = mem::size_of::<u16>();
        size += self.name.size();
        size += self.mv_id.size();
        size += self.enc_id.size();
        size += self.enc_base_id.size();
        size
    }
}

/// Represents an entry in the TypeRef table in a .NET metadata structure.
///
/// The `TypeRefEntry` provides information about a type reference, including its
/// resolution scope, name, and namespace.
#[repr(C)]
pub struct TypeRefEntry {
    /// A `ResolutionScopeIndex` referencing the scope where the type is defined.
    pub resolution_scope: ResolutionScopeIndex,
    /// A `StringHeapIndex` referencing the type's name in the String heap.
    pub name: StringHeapIndex,
    /// A `StringHeapIndex` referencing the type's namespace in the String heap.
    pub namespace: StringHeapIndex,
}

impl TypeRefEntry {
    /// Parses a `TypeRefEntry` from a byte slice based on the heap size.
    ///
    /// This function extracts the fields of the `TypeRefEntry` from the given byte slice,
    /// validating and parsing each component, such as `ResolutionScopeIndex` and `StringHeapIndex`.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the `TypeRefEntry` data.
    /// * `heap_size` - A `u8` value indicating the size of the heap, which affects how indices are parsed.
    ///
    /// # Returns
    ///
    /// * `Some(TypeRefEntry)` - The parsed `TypeRefEntry` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        let mut offset: usize = 0;
        let resolution_scope = ResolutionScopeIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += resolution_scope.size();
        let name = StringHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += name.size();
        let namespace = StringHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        Some(Self {
            resolution_scope,
            name,
            namespace,
        })
    }

    /// Returns the size of the `TypeRefEntry` in bytes.
    ///
    /// This method calculates the size of the entry, accounting for variable-sized
    /// fields like `ResolutionScopeIndex` and `StringHeapIndex`.
    ///
    /// # Returns
    ///
    /// * `usize` - The total size of the `TypeRefEntry` in bytes.
    pub fn size(&self) -> usize {
        let mut size = self.resolution_scope.size();
        size += self.name.size();
        size += self.namespace.size();
        size
    }
}

/// Represents an entry in the TypeDef table in a .NET metadata structure.
///
/// The `TypeDefEntry` provides detailed information about a type definition,
/// including its attributes, name, namespace, parent type, and lists of fields and methods.
#[repr(C)]
pub struct TypeDefEntry {
    /// Type attributes specifying visibility, layout, and other characteristics.
    pub flags: u32,
    /// A `StringHeapIndex` referencing the type's name in the String heap.
    pub name: StringHeapIndex,
    /// A `StringHeapIndex` referencing the type's namespace in the String heap.
    pub namespace: StringHeapIndex,
    /// A `TypeDefOrRefIndex` referencing the base type or interface.
    pub extends: TypeDefOrRefIndex,
    /// A `SimpleTableIndex` pointing to the start of the field list for this type.
    pub field_list: SimpleTableIndex,
    /// A `SimpleTableIndex` pointing to the start of the method list for this type.
    pub method_list: SimpleTableIndex,
}

impl TypeDefEntry {
    /// Parses a `TypeDefEntry` from a byte slice based on the heap size.
    ///
    /// This function extracts the fields of the `TypeDefEntry` from the given byte slice,
    /// validating and parsing each component, such as `StringHeapIndex`, `TypeDefOrRefIndex`,
    /// and `SimpleTableIndex`.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the `TypeDefEntry` data.
    /// * `heap_size` - A `u8` value indicating the size of the heap, which affects how indices are parsed.
    ///
    /// # Returns
    ///
    /// * `Some(TypeDefEntry)` - The parsed `TypeDefEntry` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        if bytes.len() < 4 { return None; }
        let flags = u32::from_le_bytes(bytes[0..4].try_into().unwrap());
        let mut offset: usize = mem::size_of::<u32>();
        let name = StringHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += name.size();
        let namespace = StringHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += namespace.size();
        let extends = TypeDefOrRefIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += extends.size();
        let field_list = SimpleTableIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += field_list.size();
        let method_list = SimpleTableIndex::from_bytes(&bytes[offset..], heap_size)?;
        Some(Self {
            flags,
            name,
            namespace,
            extends,
            field_list,
            method_list,
        })
    }

    /// Returns the size of the `TypeDefEntry` in bytes.
    ///
    /// This method calculates the size of the entry, accounting for variable-sized
    /// fields like `StringHeapIndex`, `TypeDefOrRefIndex`, and `SimpleTableIndex`.
    ///
    /// # Returns
    ///
    /// * `usize` - The total size of the `TypeDefEntry` in bytes.
    pub fn size(&self) -> usize {
        let mut size: usize = mem::size_of::<u32>();
        size += self.name.size();
        size += self.namespace.size();
        size += self.extends.size();
        size += self.field_list.size();
        size += self.method_list.size();
        size
    }
}

/// Represents an entry in the Field table in a .NET metadata structure.
///
/// The `FieldEntry` provides information about a field definition, including its
/// flags, name, and signature.
#[repr(C)]
pub struct FieldEntry {
    /// Field attributes specifying visibility, special behavior, and other characteristics.
    pub flags: u16,
    /// A `StringHeapIndex` referencing the field's name in the String heap.
    pub name: StringHeapIndex,
    /// A `BlobHeapIndex` referencing the field's signature in the Blob heap.
    pub signature: BlobHeapIndex,
}

impl FieldEntry {
    /// Parses a `FieldEntry` from a byte slice based on the heap size.
    ///
    /// This function extracts the fields of the `FieldEntry` from the given byte slice,
    /// validating and parsing each component, such as `StringHeapIndex` and `BlobHeapIndex`.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the `FieldEntry` data.
    /// * `heap_size` - A `u8` value indicating the size of the heap, which affects how indices are parsed.
    ///
    /// # Returns
    ///
    /// * `Some(FieldEntry)` - The parsed `FieldEntry` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        if bytes.len() < 2 { return None; }
        let flags = u16::from_le_bytes(bytes[0..2].try_into().unwrap());
        let mut offset: usize = mem::size_of::<u16>();
        let name: StringHeapIndex = StringHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += name.size();
        let signature = BlobHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        Some(Self {
            flags,
            name,
            signature,
        })
    }

    /// Returns the size of the `FieldEntry` in bytes.
    ///
    /// This method calculates the size of the entry, accounting for variable-sized
    /// fields like `StringHeapIndex` and `BlobHeapIndex`.
    ///
    /// # Returns
    ///
    /// * `usize` - The total size of the `FieldEntry` in bytes.
    pub fn size(&self) -> usize {
        let mut size: usize = mem::size_of::<u16>();
        size += self.name.size();
        size += self.signature.size();
        size
    }
}

/// Represents an entry in the MethodDef table in a .NET metadata structure.
///
/// The `MethodDefEntry` provides detailed information about a method definition,
/// including its address, flags, name, signature, and parameters.
#[repr(C)]
pub struct MethodDefEntry {
    /// The relative virtual address (RVA) of the method's executable code.
    pub rva: u32,
    /// Implementation flags specifying method attributes.
    pub impl_flags: u16,
    /// Method flags specifying additional attributes.
    pub flags: u16,
    /// A `StringHeapIndex` referencing the method's name in the String heap.
    pub name: StringHeapIndex,
    /// A `BlobHeapIndex` referencing the method's signature in the Blob heap.
    pub signature: BlobHeapIndex,
    /// A `SimpleTableIndex` referencing the method's parameter list in the Parameter table.
    pub param_list: SimpleTableIndex,
}

impl MethodDefEntry {
    /// Parses a `MethodDefEntry` from a byte slice based on the heap size.
    ///
    /// This function extracts the fields of the `MethodDefEntry` from the given byte slice,
    /// validating and parsing each component, such as `StringHeapIndex`, `BlobHeapIndex`,
    /// and `SimpleTableIndex`.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the `MethodDefEntry` data.
    /// * `heap_size` - A `u8` value indicating the size of the heap, which affects how indices are parsed.
    ///
    /// # Returns
    ///
    /// * `Some(MethodDefEntry)` - The parsed `MethodDefEntry` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        let rva = u32::from_le_bytes(bytes[0..4].try_into().unwrap());
        let impl_flags = u16::from_le_bytes(bytes[4..6].try_into().unwrap());
        let flags = u16::from_le_bytes(bytes[6..8].try_into().unwrap());
        let mut offset: usize = 8;
        let name = StringHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += name.size();
        let signature = BlobHeapIndex::from_bytes(&bytes[offset..], heap_size)?;
        offset += signature.size();
        let param_list = SimpleTableIndex::from_bytes(&bytes[offset..], heap_size)?;
        Some(Self{
            rva,
            impl_flags,
            flags,
            name,
            signature,
            param_list,
        })
    }

    /// Returns the size of the `MethodDefEntry` in bytes.
    ///
    /// This method calculates the size of the entry, accounting for variable-sized
    /// fields like `StringHeapIndex`, `BlobHeapIndex`, and `SimpleTableIndex`.
    ///
    /// # Returns
    ///
    /// * `usize` - The total size of the `MethodDefEntry` in bytes.
    pub fn size(&self) -> usize {
        let mut size: usize = 8;
        size += self.name.size();
        size += self.signature.size();
        size += self.param_list.size();
        size
    }
}

/// Represents an index into a simple table in a .NET metadata structure.
///
/// The `SimpleTableIndex` is used to reference entries in a metadata table,
/// such as the Method, Field, or TypeDef tables, depending on the context.
#[repr(C)]
pub struct SimpleTableIndex {
    /// The offset in the table where the entry starts.
    pub offset: u32,
    /// The size of the referenced entry in bytes.
    pub size: u32,
}

impl SimpleTableIndex {
    /// Parses a `SimpleTableIndex` from a byte slice based on the heap size.
    ///
    /// The size of the index (2 or 4 bytes) is determined by the `heap_size` parameter.
    /// The function validates the byte slice length before parsing.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the index data.
    /// * `heap_size` - A `u8` value indicating the size of the heap (used to determine
    ///   whether the index is 2 or 4 bytes).
    ///
    /// # Returns
    ///
    /// * `Some(SimpleTableIndex)` - The parsed `SimpleTableIndex` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        let size = if heap_size & 1 != 0 { 4 } else { 2 };

        let offset = match size {
            2 if bytes.len() >= 2 => u16::from_le_bytes(bytes[0..2].try_into().unwrap()) as u32,
            4 if bytes.len() >= 4 => u32::from_le_bytes(bytes[0..4].try_into().unwrap()),
            _ => return None,
        };

        Some(Self {
            offset,
            size,
        })
    }

    /// Returns the size of the referenced entry in the table.
    ///
    /// # Returns
    ///
    /// * `usize` - The size of the referenced entry in bytes.
    pub fn size(&self) -> usize {
        self.size as usize
    }
}

/// Represents an index into the String heap in a .NET metadata structure.
///
/// The `StringHeapIndex` is used to reference entries in the String heap, which stores
/// strings used in metadata tables.
#[derive(Debug)]
pub struct StringHeapIndex {
    /// The offset in the String heap where the data starts.
    pub offset: u32,
    /// The size of the referenced data in bytes.
    pub size: u32,
}

impl StringHeapIndex {
    /// Parses a `StringHeapIndex` from a byte slice based on the heap size.
    ///
    /// The size of the index (2 or 4 bytes) is determined by the `heap_size` parameter.
    /// The function validates the byte slice length before parsing.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the index data.
    /// * `heap_size` - A `u8` value indicating the size of the heap (used to determine
    ///   whether the index is 2 or 4 bytes).
    ///
    /// # Returns
    ///
    /// * `Some(StringHeapIndex)` - The parsed `StringHeapIndex` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        let size = if heap_size & 1 != 0 { 4 } else { 2 };

        let offset = match size {
            2 if bytes.len() >= 2 => u16::from_le_bytes(bytes[0..2].try_into().unwrap()) as u32,
            4 if bytes.len() >= 4 => u32::from_le_bytes(bytes[0..4].try_into().unwrap()),
            _ => return None,
        };

        Some(Self {
            offset,
            size,
        })
    }

    /// Returns the size of the referenced data in the String heap.
    ///
    /// # Returns
    ///
    /// * `usize` - The size of the referenced data in bytes.
    pub fn size(&self) -> usize {
        self.size as usize
    }
}

/// Represents an index into the GUID heap in a .NET metadata structure.
///
/// The `GuidHeapIndex` is used to reference entries in the GUID heap, which stores
/// globally unique identifiers (GUIDs) used in metadata tables.
#[derive(Debug)]
pub struct GuidHeapIndex {
    /// The offset in the GUID heap where the data starts.
    pub offset: u32,
    /// The size of the referenced data in bytes.
    pub size: u32,
}

impl GuidHeapIndex {
    /// Parses a `GuidHeapIndex` from a byte slice based on the heap size.
    ///
    /// The size of the index (2 or 4 bytes) is determined by the `heap_size` parameter.
    /// The function validates the byte slice length before parsing.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the index data.
    /// * `heap_size` - A `u8` value indicating the size of the heap (used to determine
    ///   whether the index is 2 or 4 bytes).
    ///
    /// # Returns
    ///
    /// * `Some(GuidHeapIndex)` - The parsed `GuidHeapIndex` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        let size = if heap_size & 2 != 0 { 4 } else { 2 };

        let offset = match size {
            2 if bytes.len() >= 2 => u16::from_le_bytes(bytes[0..2].try_into().unwrap()) as u32,
            4 if bytes.len() >= 4 => u32::from_le_bytes(bytes[0..4].try_into().unwrap()),
            _ => return None,
        };

        Some(Self {
            offset,
            size,
        })
    }

    /// Returns the size of the referenced data in the GUID heap.
    ///
    /// # Returns
    ///
    /// * `usize` - The size of the referenced data in bytes.
    pub fn size(&self) -> usize {
        self.size as usize
    }
}

/// Represents an index into the ResolutionScope table in a .NET metadata structure.
///
/// The `ResolutionScopeIndex` is used to reference entries in the ResolutionScope table,
/// which includes assemblies, modules, and other scopes that define or reference types.
#[repr(C)]
pub struct ResolutionScopeIndex {
    /// The offset in the ResolutionScope table where the data starts.
    pub offset: u32,
    /// The offset in the ResolutionScope table where the data starts.
    pub size: u32,
}

impl ResolutionScopeIndex {
    /// Parses a `ResolutionScopeIndex` from a byte slice based on the heap size.
    ///
    /// The size of the index (2 or 4 bytes) is determined by the `heap_size` parameter.
    /// The function validates the byte slice length before parsing.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the index data.
    /// * `heap_size` - A `u8` value indicating the size of the heap (used to determine
    ///   whether the index is 2 or 4 bytes).
    ///
    /// # Returns
    ///
    /// * `Some(ResolutionScopeIndex)` - The parsed `ResolutionScopeIndex` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        let size = if heap_size & 2 != 0 { 4 } else { 2 };

        let offset = match size {
            2 if bytes.len() >= 2 => u16::from_le_bytes(bytes[0..2].try_into().unwrap()) as u32,
            4 if bytes.len() >= 4 => u32::from_le_bytes(bytes[0..4].try_into().unwrap()),
            _ => return None,
        };

        Some(Self {
            offset,
            size,
        })
    }

    /// Returns the size of the referenced data in the ResolutionScope table.
    ///
    /// # Returns
    ///
    /// * `usize` - The size of the referenced data in bytes.
    pub fn size(&self) -> usize {
        self.size as usize
    }
}

/// Represents an index into the TypeDef or TypeRef table in a .NET metadata structure.
///
/// The `TypeDefOrRefIndex` is used to reference types defined or referenced in the
/// metadata tables, facilitating access to type definitions or references.
#[repr(C)]
#[derive(Debug)]
pub struct TypeDefOrRefIndex {
    /// The offset in the TypeDef or TypeRef table where the data starts.
    pub offset: u32,
    /// The size of the referenced data in bytes.
    pub size: u32,
}

impl TypeDefOrRefIndex {
    /// Parses a `TypeDefOrRefIndex` from a byte slice based on the heap size.
    ///
    /// The size of the index (2 or 4 bytes) is determined by the `heap_size` parameter.
    /// The function validates the byte slice length before parsing.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the index data.
    /// * `heap_size` - A `u8` value indicating the size of the heap (used to determine
    ///   whether the index is 2 or 4 bytes).
    ///
    /// # Returns
    ///
    /// * `Some(TypeDefOrRefIndex)` - The parsed `TypeDefOrRefIndex` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        let size = if heap_size & 2 != 0 { 4 } else { 2 };

        let offset = match size {
            2 if bytes.len() >= 2 => u16::from_le_bytes(bytes[0..2].try_into().unwrap()) as u32,
            4 if bytes.len() >= 4 => u32::from_le_bytes(bytes[0..4].try_into().unwrap()),
            _ => return None,
        };

        Some(Self {
            offset,
            size,
        })
    }

    /// Returns the size of the referenced data in the TypeDef or TypeRef table.
    ///
    /// # Returns
    ///
    /// * `usize` - The size of the referenced data in bytes.
    pub fn size(&self) -> usize {
        self.size as usize
    }
}

/// Represents an index into the Blob heap in a .NET metadata structure.
///
/// The `BlobHeapIndex` is used to reference data in the Blob heap, which contains
/// metadata such as constants, custom attributes, and signatures.
///
/// # Fields
///
/// * `offset` - The offset in the Blob heap where the data starts.
/// * `size` - The size of the referenced data in bytes.
#[repr(C)]
pub struct BlobHeapIndex {
    /// The offset in the Blob heap where the data starts.
    pub offset: u32,
    /// The size of the referenced data in bytes.
    pub size: u32,
}

impl BlobHeapIndex {
    /// Parses a `BlobHeapIndex` from a byte slice based on the heap size.
    ///
    /// The size of the index (2 or 4 bytes) is determined by the `heap_size` parameter.
    /// The function validates the byte slice length before parsing.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the index data.
    /// * `heap_size` - A `u8` value indicating the size of the heap (used to determine
    ///   whether the index is 2 or 4 bytes).
    ///
    /// # Returns
    ///
    /// * `Some(BlobHeapIndex)` - The parsed `BlobHeapIndex` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or does not contain enough data.
    pub fn from_bytes(bytes: &[u8], heap_size: u8) -> Option<Self> {
        let size = if heap_size & 2 != 0 { 4 } else { 2 };

        let offset = match size {
            2 if bytes.len() >= 2 => u16::from_le_bytes(bytes[0..2].try_into().unwrap()) as u32,
            4 if bytes.len() >= 4 => u32::from_le_bytes(bytes[0..4].try_into().unwrap()),
            _ => return None,
        };

        Some(Self {
            offset,
            size,
        })
    }

    /// Returns the size of the referenced data in the Blob heap.
    ///
    /// # Returns
    ///
    /// * `usize` - The size of the referenced data in bytes.
    pub fn size(&self) -> usize {
        self.size as usize
    }
}

/// Represents an entry in the .NET metadata table.
///
/// Each entry corresponds to a specific metadata table type, such as `Module`,
/// `TypeRef`, `TypeDef`, `Field`, or `MethodDef`.
///
/// # Variants
///
/// * `Module(ModuleEntry)` - Represents a module definition entry.
/// * `TypeRef(TypeRefEntry)` - Represents a type reference entry.
/// * `TypeDef(TypeDefEntry)` - Represents a type definition entry.
/// * `Field(FieldEntry)` - Represents a field entry.
/// * `MethodDef(MethodDefEntry)` - Represents a method definition entry.
pub enum Entry {
    Module(ModuleEntry),
    TypeRef(TypeRefEntry),
    TypeDef(TypeDefEntry),
    Field(FieldEntry),
    MethodDef(MethodDefEntry),
}

/// Represents a Tiny method header in a .NET executable.
///
/// The `TinyHeader` is a compact representation of method headers for small methods
/// with limited fields and constraints.
///
/// # Fields
///
/// * `code_size` - The size of the method's executable code in bytes.
#[repr(C)]
pub struct TinyHeader {
    /// The size of the method's executable code in bytes.
    pub code_size: u8,
}

impl TinyHeader {
    /// Parses a `TinyHeader` from a byte slice.
    ///
    /// This function validates the size and alignment of the byte slice before
    /// returning a reference to the `TinyHeader`.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the header data.
    ///
    /// # Returns
    ///
    /// * `Some(&TinyHeader)` - A reference to the parsed `TinyHeader` if the byte slice is valid.
    /// * `None` - If the byte slice is invalid or misaligned.
    pub fn from_bytes(bytes: &[u8]) -> Option<&Self> {
        if bytes.len() != mem::size_of::<Self>() {
            return None;
        }
        Some(unsafe { &*(bytes.as_ptr() as *const Self) })
    }

    pub fn size(&self) -> usize {
        1
    }
}

/// Represents the method header in a .NET executable.
///
/// The method header can either be a `Tiny` or `Fat` header, depending on the
/// method's structure and size.
///
/// # Variants
///
/// * `Tiny(TinyHeader)` - A compact method header with limited fields.
/// * `Fat(FatHeader)` - A full-featured method header with additional details.
pub enum MethodHeader {
    Tiny(TinyHeader),
    Fat(FatHeader),
}

impl MethodHeader {
    /// Returns the size of the method header in bytes.
    ///
    /// # Returns
    ///
    /// * `Some(usize)` - The size of the method header in bytes.
    /// * `None` - If the method header type is not recognized.
    pub fn size(&self) -> Option<usize> {
        match self {
            Self::Tiny(header) => Some(header.size()),
            Self::Fat(header) => Some(header.size()),
        }
    }

    /// Returns the size of the method's executable code in bytes.
    ///
    /// # Returns
    ///
    /// * `Some(usize)` - The size of the method's code.
    /// * `None` - If the method header type is not recognized.
    pub fn code_size(&self) -> Option<usize> {
        match self {
            Self::Tiny(header) => Some(header.code_size as usize),
            Self::Fat(header) => Some(header.code_size as usize),
        }
    }
}

/// Represents a fat method header in a .NET executable.
///
/// The fat header provides detailed information about a method, including its
/// flags, stack size, code size, and local variable signature token.
#[repr(C)]
pub struct FatHeader {
    /// Flags indicating the method's attributes.
    pub flags: u16,
    /// The maximum stack depth required by the method.
    pub max_stack: u16,
    /// The size of the method's executable code in bytes.
    pub code_size: u32,
    /// A metadata token for the method's local variable signature.
    pub local_var_sig_token: u32,
}

impl FatHeader {
    /// Parses a `FatHeader` from a byte slice.
    ///
    /// # Parameters
    ///
    /// * `bytes` - A byte slice containing the header data.
    ///
    /// # Returns
    ///
    /// * `Ok(FatHeader)` - The parsed `FatHeader`.
    /// * `Err(std::io::Error)` - If the byte slice is too short or invalid.
    ///
    /// # Errors
    ///
    /// Returns an error if the byte slice does not contain enough data to parse a valid `FatHeader`.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, std::io::Error> {
        if bytes.len() < 12 {
            return Err(std::io::Error::new(std::io::ErrorKind::InvalidData, "Not enough bytes for FatHeader"));
        }

        Ok(Self {
            flags: u16::from_le_bytes(bytes[0..2].try_into().unwrap()),
            max_stack: u16::from_le_bytes(bytes[2..4].try_into().unwrap()),
            code_size: u32::from_le_bytes(bytes[4..8].try_into().unwrap()),
            local_var_sig_token: u32::from_le_bytes(bytes[8..12].try_into().unwrap()),
        })
    }

    /// Returns the size of the `FatHeader` in bytes.
    ///
    /// # Returns
    ///
    /// * `usize` - The size of the `FatHeader`, which is always 12 bytes.
    pub fn size(&self) -> usize {
        12
    }
}

```

`src/formats/elf.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Symbol as BlSymbol;
use crate::formats::File;
use crate::types::MemoryMappedFile;
use crate::Architecture;
use crate::Config;
use lief::elf::section::Flags;
use lief::elf::segment::Type as SegmentType;
use lief::elf::symbol::Type as ElfSymbolType;
use lief::generic::{Section, Symbol};
use lief::Binary;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::io::{Cursor, Error, ErrorKind};
use std::path::PathBuf;

pub const DEFAULT_IMAGEBASE: u64 = 0x100000;

pub struct ELF {
    elf: lief::elf::Binary,
    pub file: File,
    pub config: Config,
}

impl ELF {
    /// Creates a new `ELF` instance by reading a ELF file from the provided path.
    ///
    /// # Parameters
    /// - `path`: The file path to the ELF file to be loaded.
    ///
    /// # Returns
    /// A `Result` containing the `ELF` object on success or an `Error` on failure.
    pub fn new(path: String, config: Config) -> Result<Self, Error> {
        let mut file = File::new(path.clone(), config.clone())?;
        match file.read() {
            Ok(_) => (),
            Err(_) => {
                return Err(Error::new(ErrorKind::InvalidInput, "failed to read file"));
            }
        };
        let binary = Binary::parse(&path);
        if let Some(Binary::ELF(elf)) = binary {
            return Ok(Self { elf, file, config });
        }
        Err(Error::new(ErrorKind::InvalidInput, "invalid elf file"))
    }

    /// Creates a new `ELF` instance from a byte vector containing ELF file data.
    ///
    /// # Parameters
    /// - `bytes`: A vector of bytes representing the PE file data.
    ///
    /// # Returns
    /// A `Result` containing the `ELF` object on success or an `Error` on failure.
    #[allow(dead_code)]
    pub fn from_bytes(bytes: Vec<u8>, config: Config) -> Result<Self, Error> {
        let file = File::from_bytes(bytes, config.clone());
        let mut cursor = Cursor::new(&file.data);
        if let Some(Binary::ELF(elf)) = Binary::from(&mut cursor) {
            return Ok(Self { elf, file, config });
        }
        Err(Error::new(ErrorKind::InvalidInput, "invalid elf file"))
    }

    pub fn architecture(&self) -> Architecture {
        let architecture = match self.elf.header().machine_type() {
            62 => Architecture::AMD64,
            3 => Architecture::I386,
            _ => Architecture::UNKNOWN,
        };
        architecture
    }

    pub fn entrypoint_virtual_address(&self) -> u64 {
        self.imagebase() + self.elf.header().entrypoint()
    }

    pub fn imagebase(&self) -> u64 {
        for segment in self.elf.segments() {
            if segment.p_type() == SegmentType::LOAD {
                if segment.virtual_address() != 0 {
                    return segment.virtual_address();
                }
                return DEFAULT_IMAGEBASE;
            }
        }
        DEFAULT_IMAGEBASE
    }

    pub fn size(&self) -> u64 {
        self.file.size()
    }

    pub fn export_virtual_addresses(&self) -> BTreeSet<u64> {
        let mut result = BTreeSet::<u64>::new();
        for symbol in self.elf.exported_symbols() {
            result.insert(self.imagebase() + symbol.value());
        }
        result
    }

    pub fn symbols(&self) -> BTreeMap<u64, BlSymbol> {
        self.elf
            .dynamic_symbols()
            .chain(self.elf.exported_symbols())
            .chain(self.elf.imported_symbols())
            .chain(self.elf.symtab_symbols())
            .filter(|symbol| symbol.get_type() == ElfSymbolType::FUNC)
            .map(|symbol| {
                (
                    (self.imagebase() + symbol.value()),
                    BlSymbol {
                        symbol_type: "function".to_string(),
                        name: symbol.name(),
                        address: self.imagebase() + symbol.value(),
                    },
                )
            })
            .collect()
    }

    pub fn relative_virtual_address_to_virtual_address(
        &self,
        relative_virtual_address: u64,
    ) -> u64 {
        self.imagebase() + relative_virtual_address
    }

    pub fn file_offset_to_virtual_address(&self, file_offset: u64) -> Option<u64> {
        for segment in self.elf.segments() {
            let start = segment.file_offset();
            let end = start + segment.physical_size();
            if file_offset >= start && file_offset < end {
                let segment_virtual_address = self.imagebase() + segment.virtual_address();
                return Some(segment_virtual_address + (file_offset - start));
            }
        }
        None
    }

    pub fn image(&self) -> Result<MemoryMappedFile, Error> {
        let pathbuf = PathBuf::from(self.config.mmap.directory.clone())
            .join(self.file.sha256_no_config().unwrap());
        let mut tempmap = MemoryMappedFile::new(pathbuf, self.config.mmap.cache.enabled)?;

        if tempmap.is_cached() {
            return Ok(tempmap);
        }

        tempmap.seek_to_end()?;
        tempmap.write(&self.file.data[0..self.elf.header().header_size() as usize])?;

        for segment in self.elf.segments() {
            let segment_virtual_address = self.imagebase() + segment.virtual_address();

            if segment_virtual_address > tempmap.size()? {
                let padding_length = segment_virtual_address - tempmap.size()?;
                tempmap.seek_to_end()?;
                tempmap.write_padding(padding_length as usize)?;
            }

            if segment.p_type() == SegmentType::LOAD {
                let segment_file_offset = segment.file_offset() as usize;
                let segment_size = segment.physical_size() as usize;

                if segment_file_offset + segment_size <= self.file.data.len() {
                    tempmap.seek_to_end()?;
                    tempmap.write(
                        &self.file.data[segment_file_offset..segment_file_offset + segment_size],
                    )?;
                } else {
                    return Err(Error::new(
                        ErrorKind::InvalidData,
                        "elf segment size exceeds file data length",
                    ));
                }
            }
        }

        Ok(tempmap)
    }

    pub fn tlsh(&self) -> Option<String> {
        self.file.tlsh()
    }

    pub fn sha256(&self) -> Option<String> {
        self.file.sha256()
    }

    /// Returns the entropy of the ELF file.
    ///
    /// # Returns
    /// The entropy of the file as a `Option<f64>`.
    #[allow(dead_code)]
    pub fn entropy(&self) -> Option<f64> {
        self.file.entropy()
    }

    /// Returns the File JSON associated with the ELF
    ///
    /// # Returns
    /// An `Result<String, Error>` containing the `File` JSON.
    #[allow(dead_code)]
    pub fn file_json(&self) -> Result<String, Error> {
        self.file.json()
    }

    pub fn entrypoint_virtual_addresses(&self) -> BTreeSet<u64> {
        let mut entrypoints = BTreeSet::<u64>::new();
        entrypoints.insert(self.entrypoint_virtual_address());
        entrypoints.extend(self.export_virtual_addresses());
        entrypoints.extend(self.symbols().keys());
        entrypoints
    }

    pub fn executable_virtual_address_ranges(&self) -> BTreeMap<u64, u64> {
        let mut result = BTreeMap::<u64, u64>::new();
        for section in self.elf.sections() {
            if section.flags().contains(Flags::EXECINSTR) {
                let start = self.imagebase() + section.virtual_address();
                let end = start + section.size();
                result.insert(start, end);
            }
        }
        result
    }
}

```

`src/formats/file.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Attribute;
use crate::hashing::sha256::SHA256;
use crate::hashing::tlsh::TLSH;
use crate::Binary;
use crate::Config;
use serde::{Deserialize, Serialize};
use serde_json;
use std::fs::File as StdFile;
use std::io::ErrorKind;
use std::io::{Cursor, Error, Read, Seek, SeekFrom};

#[cfg(windows)]
use std::os::windows::fs::OpenOptionsExt;

#[cfg(windows)]
use std::fs::OpenOptions;

#[cfg(windows)]
use winapi::um::winnt::FILE_SHARE_READ;

pub trait FileHandle: Read + Seek + Send {}

impl<T: Read + Seek + Send> FileHandle for T {}

#[derive(Serialize, Deserialize, Clone)]
pub struct FileJson {
    #[serde(rename = "type")]
    /// The type always `file`
    pub type_: String,
    /// The SHA-256 hash of the file, if available.
    pub sha256: Option<String>,
    /// The TLSH (Trend Micro Locality Sensitive Hash) of the file, if available.
    pub tlsh: Option<String>,
    /// The File Size,
    pub size: Option<u64>,
    // The File Entropy
    pub entropy: Option<f64>,
}

/// Represents a file with its contents and an optional file path.
pub struct File {
    /// The contents of the file as a byte vector.
    pub data: Vec<u8>,
    /// The path of the file, if available.
    pub path: Option<String>,
    /// The configuration `Config`
    pub config: Config,
    /// Handle to the file
    handle: Box<dyn FileHandle>,
}

impl File {
    /// Creates a new `File` instance with a given path.
    ///
    /// # Arguments
    ///
    /// * `path` - A `String` representing the path to the file.
    ///
    /// # Returns
    ///
    /// A `File` instance with the given path and empty data.
    pub fn new(path: String, config: Config) -> Result<Self, Error> {
        #[cfg(windows)]
        let handle = Box::new(
            OpenOptions::new()
                .read(true)
                .write(false)
                .share_mode(FILE_SHARE_READ)
                .open(&path)?,
        ) as Box<dyn FileHandle>;
        #[cfg(not(windows))]
        let handle = Box::new(StdFile::open(&path)?) as Box<dyn FileHandle>;
        Ok(Self {
            data: Vec::new(),
            path: Some(path),
            config,
            handle,
        })
    }

    /// Creates a new `File` instance from the provided byte data.
    ///
    /// # Arguments
    ///
    /// * `bytes` - A `Vec<u8>` representing the byte data of the file.
    ///
    /// # Returns
    ///
    /// A `File` instance with the given byte data and no path.
    #[allow(dead_code)]
    pub fn from_bytes(bytes: Vec<u8>, config: Config) -> Self {
        let handle = Box::new(Cursor::new(bytes.clone())) as Box<dyn FileHandle>;
        Self {
            data: bytes,
            path: None,
            config,
            handle,
        }
    }

    /// Computes the TLSH (Trend Locality Sensitive Hashing) of the file's data.
    ///
    /// # Returns
    ///
    /// An `Option<String>` containing the hexadecimal representation of the TLSH,
    /// or `None` if the file's size is zero or less.
    #[allow(dead_code)]
    pub fn tlsh(&self) -> Option<String> {
        if !self.config.formats.file.hashing.tlsh.enabled {
            return None;
        }
        if self.size() == 0 {
            return None;
        }
        TLSH::new(&self.data, 50).hexdigest()
    }

    /// Computes the SHA-256 hash of the file's data.
    ///
    /// # Returns
    ///
    /// An `Option<String>` containing the hexadecimal representation of the SHA-256 hash,
    /// or `None` if the file's size is zero or less.
    #[allow(dead_code)]
    pub fn sha256(&self) -> Option<String> {
        if !self.config.formats.file.hashing.sha256.enabled {
            return None;
        }
        if self.size() == 0 {
            return None;
        }
        SHA256::new(&self.data).hexdigest()
    }

    /// Computes the SHA-256 hash of the file's data.
    ///
    /// # Returns
    ///
    /// An `Option<String>` containing the hexadecimal representation of the SHA-256 hash,
    /// or `None` if the file's size is zero or less.
    #[allow(dead_code)]
    pub fn sha256_no_config(&self) -> Option<String> {
        if self.size() == 0 {
            return None;
        }
        SHA256::new(&self.data).hexdigest()
    }

    /// Returns the size of the file in bytes.
    ///
    /// # Returns
    ///
    /// The size of the file in bytes as a `u64`.
    #[allow(dead_code)]
    pub fn size(&self) -> u64 {
        self.data.len() as u64
    }

    /// Seeks to a specific offset in the file.
    ///
    /// # Arguments
    ///
    /// * `offset` - The position to seek to, specified as a `u64` (absolute offset from the start of the file).
    ///
    /// # Returns
    ///
    /// A `Result` indicating the success or failure of the seek operation, returning the new position.
    ///
    /// # Errors
    ///
    /// Returns an error if the file path is missing or the seek operation fails.
    pub fn seek(&mut self, offset: u64) -> Result<u64, Error> {
        let new_position = self.handle.seek(SeekFrom::Start(offset))?;
        Ok(new_position)
    }

    /// Gets the current position of the file cursor.
    /// # Returns
    ///
    /// A `Result<u64, Error>` with the current cursor position.
    pub fn current_position(&mut self) -> Result<u64, Error> {
        let position = self.handle.stream_position()?;
        Ok(position)
    }

    /// Reads the content of the file from the given path and stores it in `data`.
    ///
    /// # Returns
    ///
    /// A `Result` indicating the success or failure of the operation.
    /// Returns `Ok(())` on success, or an `Err` with an `Error` if the file cannot be read.
    ///
    /// # Errors
    ///
    /// Returns an error if the file path is missing or the file cannot be opened or read.
    pub fn read(&mut self) -> Result<(), Error> {
        let path = self
            .path
            .as_ref()
            .ok_or_else(|| Error::new(ErrorKind::InvalidInput, "missing file path to read"))?;

        let mut file = StdFile::open(path)?;
        file.read_to_end(&mut self.data)?;
        Ok(())
    }

    /// Prints the JSON representation of the file metadata to standard output.
    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }

    /// Processes the file metadata into a JSON-serializable `FileJson` structure.
    ///
    /// # Returns
    ///
    /// Returns a `FileJson` struct containing the file's SHA-256 hash, TLSH hash, and size.
    pub fn process(&self) -> FileJson {
        FileJson {
            type_: "file".to_string(),
            sha256: self.sha256(),
            tlsh: self.tlsh(),
            size: Some(self.size()),
            entropy: self.entropy(),
        }
    }

    pub fn entropy(&self) -> Option<f64> {
        if !self.config.formats.file.heuristics.entropy.enabled {
            return None;
        }
        Binary::entropy(&self.data)
    }

    /// Gets attribute information about a file
    ///
    /// # Returns
    ///
    /// Returns a `Attribute` struct containing the file's SHA-256 hash, TLSH hash, and size.
    pub fn attribute(&self) -> Attribute {
        Attribute::File(self.process())
    }

    /// Converts the file metadata into a JSON string representation.
    ///
    /// # Returns
    ///
    /// Returns `Ok(String)` containing the JSON representation of the file metadata,
    /// or an `Err` if serialization fails.
    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }
}

```

`src/formats/macho.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::controlflow::Symbol as BlSymbol;
use crate::formats::File;
use crate::types::MemoryMappedFile;
use crate::Architecture;
use crate::Config;
use lief::generic::{Section, Symbol};
use lief::macho::commands::{Command, LoadCommandTypes};
use lief::macho::header::CpuType as MachoCpuType;
use lief::macho::section::Flags as SectionFlags;
use lief::Binary;
use std::collections::{BTreeMap, BTreeSet};
use std::io::{Cursor, Error, ErrorKind};
use std::path::PathBuf;

pub const N_STAB: u8 = 0xE0;
pub const N_TYPE: u8 = 0x0E;
pub const N_SECT: u8 = 0x0E;
pub const VM_PROT_EXECUTE: u8 = 0x04;

pub struct MACHO {
    macho: lief::macho::FatBinary,
    pub file: File,
    pub config: Config,
}

impl MACHO {
    /// Creates a new `MACHO` instance by reading a ELF file from the provided path.
    ///
    /// # Parameters
    /// - `path`: The file path to the MACHO file to be loaded.
    ///
    /// # Returns
    /// A `Result` containing the `MACHO` object on success or an `Error` on failure.
    pub fn new(path: String, config: Config) -> Result<Self, Error> {
        let mut file = File::new(path.clone(), config.clone())?;
        match file.read() {
            Ok(_) => (),
            Err(_) => {
                return Err(Error::new(
                    ErrorKind::InvalidInput,
                    "failed to read macho file",
                ));
            }
        };
        let binary = Binary::parse(&path);
        if let Some(Binary::MachO(macho)) = binary {
            return Ok(Self {
                macho,
                file,
                config,
            });
        }
        Err(Error::new(ErrorKind::InvalidInput, "invalid macho file"))
    }

    /// Creates a new `MACHO` instance from a byte vector containing MACHO file data.
    ///
    /// # Parameters
    /// - `bytes`: A vector of bytes representing the PE file data.
    ///
    /// # Returns
    /// A `Result` containing the `MACHO` object on success or an `Error` on failure.
    #[allow(dead_code)]
    pub fn from_bytes(bytes: Vec<u8>, config: Config) -> Result<Self, Error> {
        let file = File::from_bytes(bytes, config.clone());
        let mut cursor = Cursor::new(&file.data);
        if let Some(Binary::MachO(macho)) = Binary::from(&mut cursor) {
            return Ok(Self {
                macho,
                file,
                config,
            });
        }
        Err(Error::new(ErrorKind::InvalidInput, "invalid macho file"))
    }

    pub fn relative_virtual_address_to_virtual_address(
        &self,
        relative_virtual_address: u64,
        slice: usize,
    ) -> Option<u64> {
        Some(self.imagebase(slice)? + relative_virtual_address)
    }

    pub fn file_offset_to_virtual_address(&self, file_offset: u64, slice: usize) -> Option<u64> {
        let binding = self.macho.iter().nth(slice);
        binding.as_ref()?;
        for segment in binding.unwrap().segments() {
            let start = segment.file_offset();
            let end = start + segment.file_size();
            if file_offset >= start && file_offset < end {
                return Some(segment.virtual_address() + (file_offset - start));
            }
        }
        None
    }

    /// Returns the number of binaries contained in the MachO binary.
    ///
    /// # Returns
    /// A `usize` containing the number of binaries in the MachO binary.
    pub fn number_of_slices(&self) -> usize {
        self.macho.iter().count()
    }

    /// Returns the entrypoint of the MachO binary by index.
    ///
    /// # Returns
    /// A `Option<u64>` representing the entrypoint of the binary.
    pub fn entrypoint_virtual_address(&self, slice: usize) -> Option<u64> {
        Some(self.imagebase(slice)? + self.macho.iter().nth(slice)?.main_command()?.entrypoint())
    }

    /// Returns the imagebase of the MachO binary by index.
    ///
    /// # Returns
    /// A `Option<u64>` representing the imagebase of the binary.
    pub fn imagebase(&self, slice: usize) -> Option<u64> {
        let binding = self.macho.iter().nth(slice)?;
        for segment in binding.segments() {
            if segment.name() == "__TEXT" {
                return Some(segment.virtual_address());
            }
        }
        Some(0)
    }

    /// Returns the size of the headers for the MachO slice.
    ///
    /// # Returns
    /// A `Option<u64>` representing the size of the headers for the MachO slice.
    pub fn sizeofheaders(&self, slice: usize) -> Option<u64> {
        let binding = self.macho.iter().nth(slice)?;
        let architecture = self.architecture(slice)?;
        let macho_header_size: u32 = match architecture {
            Architecture::AMD64 => 32,
            Architecture::I386 => 28,
            _ => {
                return None;
            }
        };
        Some(macho_header_size as u64 + binding.header().sizeof_cmds() as u64)
    }

    /// Returns the architecture of the MachO binary by index.
    ///
    /// # Returns
    /// A `Option<Architecture>` representing the architecture of the binary.
    pub fn architecture(&self, slice: usize) -> Option<Architecture> {
        let cpu_type = self.macho.iter().nth(slice).map(|b| b.header().cpu_type());
        cpu_type.as_ref()?;
        let architecture = match cpu_type.unwrap() {
            MachoCpuType::X86 => Architecture::I386,
            MachoCpuType::X86_64 => Architecture::AMD64,
            _ => {
                return None;
            }
        };
        Some(architecture)
    }

    /// Checks if the symbol n_type is a function.
    ///
    /// # Returns
    /// A `bool` representing if the n_type is a function or not.
    pub fn is_function_symbol_type(n_type: u8) -> bool {
        (n_type & N_STAB) == 0 && (n_type & N_TYPE) == N_SECT
    }

    pub fn symbols(&self, slice: usize) -> BTreeMap<u64, BlSymbol> {
        let mut symbols = BTreeMap::<u64, BlSymbol>::new();
        let binding = self.macho.iter().nth(slice);
        if binding.is_none() {
            return symbols;
        }
        for symbol in binding.unwrap().symbols() {
            if !MACHO::is_function_symbol_type(symbol.get_type()) {
                continue;
            }
            symbols.insert(
                symbol.value(),
                BlSymbol {
                    symbol_type: "function".to_string(),
                    name: symbol.name(),
                    address: symbol.value(),
                },
            );
        }
        symbols
    }

    /// Returns a set of function addresses identified in the MachO slice.
    ///
    /// # Returns
    /// A `BTreeSet` of function addresses for the MachO slice.
    pub fn entrypoint_virtual_addresses(&self, slice: usize) -> BTreeSet<u64> {
        let mut entrypoints = BTreeSet::<u64>::new();
        if self.entrypoint_virtual_address(slice).is_some() {
            entrypoints.insert(self.entrypoint_virtual_address(slice).unwrap());
        }
        entrypoints.extend(self.symbols(slice).keys());
        entrypoints.extend(self.export_virtual_addresses(slice));
        entrypoints
    }

    /// Checks if the provided segment flags contain the executable flag.
    ///
    /// # Arguments
    ///
    /// `segment_flags` The segment flags as a `u32`
    ///
    /// # Returns
    /// A `bool` representing if the segment flags contain the executable flag or not.
    pub fn is_segment_flags_executable(segment_flags: u32) -> bool {
        (segment_flags & VM_PROT_EXECUTE as u32) != 0
    }

    /// Checks if the symbol n_type is a function.
    ///
    /// # Arguments
    ///
    /// `slice` The index representing a binary contained in the MacO fat binary format.
    ///
    /// # Returns
    /// A `BTreeSet<u64>` containing the virtual addresses of function export addresses.
    pub fn export_virtual_addresses(&self, slice: usize) -> BTreeSet<u64> {
        let mut result = BTreeSet::<u64>::new();
        let binding = self.macho.iter().nth(slice);
        if binding.is_none() {
            return result;
        }
        let binding = binding.unwrap();
        let dyld_exports_trie = binding.dyld_exports_trie();
        if dyld_exports_trie.is_none() {
            return result;
        }
        for export in dyld_exports_trie.unwrap().exports() {
            result.insert(self.imagebase(slice).unwrap() + export.address());
        }
        result
    }

    pub fn executable_virtual_address_ranges(&self, slice: usize) -> BTreeMap<u64, u64> {
        let mut result = BTreeMap::<u64, u64>::new();
        let binding = self.macho.iter().nth(slice);
        if binding.is_none() {
            return result;
        }
        for segment in binding.unwrap().segments() {
            if !MACHO::is_segment_flags_executable(segment.init_protection()) {
                continue;
            }
            for section in segment.sections() {
                if [
                    "__cstring",
                    "__const",
                    "__info_plist",
                    "__unwind_info",
                    "__eh_frame",
                    "__stubs",
                    "__stub_helper",
                ]
                .contains(&section.name().as_str())
                {
                    continue;
                }
                if !section.flags().contains(SectionFlags::PURE_INSTRUCTIONS) {
                    continue;
                }
                if !section.flags().contains(SectionFlags::SOME_INSTRUCTIONS) {
                    continue;
                }
                let start = section.virtual_address();
                let end = start + section.size();
                result.insert(start, end);
            }
        }
        result
    }

    /// Caches the MachO file contents and returns a `MemoryMappedFile` object.
    ///
    /// # Parameters
    /// - `slice`: The MachoO binary slice.
    ///
    /// # Returns
    /// A `Result` containing the `MemoryMappedFile` object on success or an `Error` on failure.
    pub fn image(&self, slice: usize) -> Result<MemoryMappedFile, Error> {
        let pathbuf = PathBuf::from(self.config.mmap.directory.clone())
            .join(self.file.sha256_no_config().unwrap());

        let mut tempmap = MemoryMappedFile::new(pathbuf, self.config.mmap.cache.enabled)?;

        if tempmap.is_cached() {
            return Ok(tempmap);
        }

        let sizeofheaders = self.sizeofheaders(slice);
        tempmap.seek_to_end()?;
        tempmap.write(&self.file.data[0..sizeofheaders.unwrap() as usize])?;

        let binary = match self.macho.iter().nth(slice) {
            Some(binary) => binary,
            None => {
                return Err(Error::new(ErrorKind::InvalidData, "Invalid Mach-O slice"));
            }
        };

        for segment in binary.segments() {
            let segment_virtual_address = segment.virtual_address();
            if segment_virtual_address > tempmap.size()? {
                let padding_length = segment_virtual_address - tempmap.size()?;
                tempmap.seek_to_end()?;
                tempmap.write_padding(padding_length as usize)?;
            }
            if !matches!(
                segment.command_type(),
                LoadCommandTypes::Segment | LoadCommandTypes::Segment64
            ) {
                continue;
            }
            let segment_file_offset = segment.file_offset() as usize;
            let segment_size = segment.file_size() as usize;
            if segment_file_offset + segment_size <= self.file.data.len() {
                tempmap.seek_to_end()?;
                tempmap.write(
                    &self.file.data[segment_file_offset..segment_file_offset + segment_size],
                )?;
            } else {
                return Err(Error::new(
                    ErrorKind::InvalidData,
                    "macho slice segment size exceeds file data length",
                ));
            }
        }

        Ok(tempmap)
    }

    /// Returns the size of the MACHO file.
    ///
    /// # Returns
    /// The size of the file as a `u64`.
    #[allow(dead_code)]
    pub fn size(&self) -> u64 {
        self.file.size()
    }

    /// Returns the entropy of the MACHO file.
    ///
    /// # Returns
    /// The entropy of the file as a `Option<f64>`.
    #[allow(dead_code)]
    pub fn entropy(&self) -> Option<f64> {
        self.file.entropy()
    }

    /// Returns the TLS (Thread Local Storage) hash value if present in the MACHO file.
    ///
    /// # Returns
    /// An `Option<String>` containing the TLS hash if present, otherwise `None`.
    #[allow(dead_code)]
    pub fn tlsh(&self) -> Option<String> {
        self.file.tlsh()
    }

    /// Returns the SHA-256 hash value of the MACHO file.
    ///
    /// # Returns
    /// An `Option<String>` containing the SHA-256 hash if available, otherwise `None`.
    #[allow(dead_code)]
    pub fn sha256(&self) -> Option<String> {
        self.file.sha256()
    }

    /// Returns the File JSON associated with the PE
    ///
    /// # Returns
    /// An `Result<String, Error>` containing the File JSON.
    #[allow(dead_code)]
    pub fn file_json(&self) -> Result<String, Error> {
        self.file.json()
    }
}

```

`src/formats/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod file;
pub mod pe;
pub mod elf;
pub mod macho;
pub mod cli;

pub use pe::PE;
pub use file::File;
pub use elf::ELF;
pub use macho::MACHO;

```

`src/formats/pe.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::formats::cli::Cor20Header;
use crate::formats::cli::Entry;
use crate::formats::cli::FatHeader;
use crate::formats::cli::FieldEntry;
use crate::formats::cli::MetadataTable;
use crate::formats::cli::MetadataToken;
use crate::formats::cli::MethodDefEntry;
use crate::formats::cli::MethodHeader;
use crate::formats::cli::ModuleEntry;
use crate::formats::cli::StorageHeader;
use crate::formats::cli::StorageSignature;
use crate::formats::cli::StreamHeader;
use crate::formats::cli::TinyHeader;
use crate::formats::cli::TypeDefEntry;
use crate::formats::cli::TypeRefEntry;
use crate::formats::File;
use crate::types::MemoryMappedFile;
use crate::Architecture;
use crate::Config;
use lief::generic::Section;
use lief::pe::data_directory::Type as DATA_DIRECTORY;
use lief::pe::debug::Entries;
use lief::pe::headers::MachineType;
use lief::pe::section::Characteristics;
use lief::Binary;
use std::collections::BTreeMap;
use std::collections::BTreeSet;
use std::collections::HashMap;
use std::io::{Cursor, Error, ErrorKind};
use std::path::PathBuf;

/// Represents a PE (Portable Executable) file, encapsulating the `lief::pe::Binary` and associated metadata.
pub struct PE {
    pe: lief::pe::Binary,
    pub file: File,
    pub config: Config,
}

impl PE {
    /// Creates a new `PE` instance by reading a PE file from the provided path.
    ///
    /// # Parameters
    /// - `path`: The file path to the PE file to be loaded.
    ///
    /// # Returns
    /// A `Result` containing the `PE` object on success or an `Error` on failure.
    pub fn new(path: String, config: Config) -> Result<Self, Error> {
        let mut file = File::new(path.clone(), config.clone())?;
        match file.read() {
            Ok(_) => (),
            Err(_) => {
                return Err(Error::new(ErrorKind::InvalidInput, "failed to read file"));
            }
        };
        if let Some(Binary::PE(pe)) = Binary::parse(&path) {
            return Ok(Self { pe, file, config });
        }
        Err(Error::new(ErrorKind::InvalidInput, "invalid pe file"))
    }

    /// Converts a relative virtual address to a file offset
    ///
    /// # Returns
    /// The file offset as a `Option<u64>`.
    pub fn relative_virtual_address_to_file_offset(&self, rva: u64) -> Option<u64> {
        for section in self.pe.sections() {
            let section_start_rva = section.virtual_address();
            let section_end_rva = section_start_rva + section.virtual_size() as u64;
            if rva >= section_start_rva && rva < section_end_rva {
                let section_offset = rva - section_start_rva;
                let file_offset = section.pointerto_raw_data() as u64 + section_offset;
                return Some(file_offset);
            }
        }
        None
    }

    /// Parses the .NET Core 2.0 header from the PE file if it is a .NET executable.
    ///
    /// This function attempts to locate and parse the CLR runtime header by resolving its
    /// virtual address and reading its data from the file. If successful, it returns the
    /// file offset of the header and a reference to the parsed `Cor20Header` structure.
    ///
    /// # Returns
    ///
    /// * `Option<(u64, &Cor20Header)>` - A tuple containing:
    ///   * The file offset of the header as `u64`.
    ///   * A reference to the parsed `Cor20Header` structure.
    /// * `None` - If the file is not a .NET executable or the header cannot be parsed.
    fn dotnet_parse_cor20_header(&self) -> Option<(u64, &Cor20Header)> {
        if !self.is_dotnet() {
            return None;
        }
        if let Some(clr_runtime_header) = self
            .pe
            .data_directory_by_type(DATA_DIRECTORY::CLR_RUNTIME_HEADER)
        {
            if let Some(start) =
                self.relative_virtual_address_to_file_offset(clr_runtime_header.rva() as u64)
            {
                let end = start + clr_runtime_header.size() as u64;
                let data = &self.file.data[start as usize..end as usize];
                let header = &Cor20Header::from_bytes(data)?;
                return Some((start, header));
            }
        }
        None
    }

    /// Retrieves the .NET Core 2.0 header from the PE file if it is a .NET executable.
    ///
    /// This function provides a simpler interface to access the `Cor20Header` directly
    /// by internally calling `dotnet_parse_cor20_header` and returning only the header.
    ///
    /// # Returns
    ///
    /// * `Option<&Cor20Header>` - A reference to the parsed `Cor20Header` structure.
    /// * `None` - If the file is not a .NET executable or the header cannot be parsed.
    pub fn dotnet_cor20_header(&self) -> Option<&Cor20Header> {
        Some(self.dotnet_parse_cor20_header()?.1)
    }

    /// Parses the .NET storage signature from the metadata of a PE file.
    ///
    /// This function attempts to locate and parse the storage signature in the
    /// metadata section of the PE file, based on the metadata virtual address
    /// specified in the `Cor20Header`.
    ///
    /// # Returns
    ///
    /// * `Option<(u64, &StorageSignature)>` - A tuple containing:
    ///   * The file offset of the storage signature as `u64`.
    ///   * A reference to the parsed `StorageSignature` structure.
    /// * `None` - If the file is not a .NET executable or the storage signature
    ///   cannot be parsed.
    fn dotnet_parse_storage_signature(&self) -> Option<(u64, &StorageSignature)> {
        if !self.is_dotnet() {
            return None;
        }
        let (_, image_cor20_header) = self.dotnet_parse_cor20_header()?;
        let rva = image_cor20_header.meta_data.virtual_address as u64;
        let start = self.relative_virtual_address_to_file_offset(rva)? as usize;
        let end = start + StorageSignature::size();
        let data = &self.file.data[start..end];
        let header = StorageSignature::from_bytes(data)?;
        Some((start as u64, header))
    }

    /// Retrieves the .NET storage signature from the metadata of a PE file.
    ///
    /// This function provides a simpler interface to access the `StorageSignature` directly
    /// by internally calling `dotnet_parse_storage_signature` and returning only the signature.
    ///
    /// # Returns
    ///
    /// * `Option<&StorageSignature>` - A reference to the parsed `StorageSignature` structure.
    /// * `None` - If the file is not a .NET executable or the storage signature cannot be parsed.
    pub fn dotnet_storage_signature(&self) -> Option<&StorageSignature> {
        Some(self.dotnet_parse_storage_signature()?.1)
    }

    /// Parses the .NET storage header from the metadata of a PE file.
    ///
    /// This function attempts to locate and parse the `StorageHeader` in the metadata
    /// section of the PE file. It calculates the starting position based on the size of
    /// the `StorageSignature` and the version string, then reads and parses the
    /// header data.
    ///
    /// # Returns
    ///
    /// * `Option<(u64, &StorageHeader)>` - A tuple containing:
    ///   * The file offset of the storage header as `u64`.
    ///   * A reference to the fparsed `StorageHeader` structure.
    /// * `None` - If the file is not a .NET executable or the storage header cannot be parsed.
    fn dotnet_parse_storage_header(&self) -> Option<(u64, &StorageHeader)> {
        if !self.is_dotnet() {
            return None;
        };
        let (mut start, cor20_storage_signaure_header) = self.dotnet_parse_storage_signature()?;
        start += StorageSignature::size() as u64;
        start += cor20_storage_signaure_header.version_string_size as u64;
        start -= 4;
        let end = start as usize + StorageHeader::size();
        let data = &self.file.data[start as usize..end];
        let header = StorageHeader::from_bytes(data)?;
        Some((start, header))
    }

    /// Retrieves the .NET storage header from the metadata of a PE file.
    ///
    /// This function provides a simpler interface to access the `StorageHeader` directly
    /// by internally calling `dotnet_parse_storage_header` and returning only the header.
    ///
    /// # Returns
    ///
    /// * `Option<&StorageHeader>` - A reference to the parsed `StorageHeader` structure.
    /// * `None` - If the file is not a .NET executable or the storage header cannot be parsed.
    pub fn dotnet_storage_header(&self) -> Option<&StorageHeader> {
        Some(self.dotnet_parse_storage_header()?.1)
    }

    /// Parses the .NET stream headers from the metadata of a PE file.
    ///
    /// This function reads and parses the stream headers defined in the metadata section
    /// of the PE file. It calculates the starting position based on the `StorageHeader`
    /// and iterates through the number of streams specified, creating a `BTreeMap` of the
    /// file offsets and their corresponding `StreamHeader` structures.
    ///
    /// # Returns
    ///
    /// * `Option<BTreeMap<u64, &StreamHeader>>` - A map where:
    ///   * The keys are the file offsets of the stream headers as `u64`.
    ///   * The values are references to the parsed `StreamHeader` structures.
    /// * `None` - If the file is not a .NET executable, the storage header cannot be parsed,
    ///   or no stream headers are found.
    fn dotnet_parse_stream_headers(&self) -> Option<BTreeMap<u64, &StreamHeader>> {
        if !self.is_dotnet() {
            return None;
        }
        let (cor20_storage_header_offset, cor20_storage_header) =
            self.dotnet_parse_storage_header()?;
        let mut offset = cor20_storage_header_offset as usize + StorageHeader::size();
        let mut result = BTreeMap::<u64, &StreamHeader>::new();
        for _ in 0..cor20_storage_header.number_of_streams {
            let data = &self.file.data[offset..offset + StreamHeader::size()];
            let header = StreamHeader::from_bytes(data)?;
            result.insert(offset as u64, header);
            offset += StreamHeader::size() + header.name().len();
        }
        if result.is_empty() {
            return None;
        }
        Some(result)
    }

    /// Retrieves the .NET stream headers from the metadata of a PE file as a vector.
    ///
    /// This function provides a simpler interface to access the `StreamHeader` structures
    /// directly by internally calling `dotnet_parse_stream_headers` and returning only the
    /// parsed headers in a vector.
    ///
    /// # Returns
    ///
    /// * `Vec<&StreamHeader>` - A vector of references to the parsed `StreamHeader` structures.
    /// * An empty vector - If the file is not a .NET executable or the stream headers cannot
    ///   be parsed.
    pub fn dotnet_stream_headers(&self) -> Vec<&StreamHeader> {
        let mut result = Vec::<&StreamHeader>::new();
        let headers = self.dotnet_parse_stream_headers();
        if headers.is_none() {
            return result;
        }
        for (_, header) in headers.unwrap() {
            result.push(header);
        }
        result
    }

    /// Parses the .NET metadata table from the metadata of a PE file.
    ///
    /// This function locates and parses the `MetadataTable` in the metadata section of the
    /// PE file. It identifies the stream header with the `#~` name, calculates the correct
    /// offset based on its location and the storage signature, and reads the metadata table data.
    ///
    /// # Returns
    ///
    /// * `Option<(u64, &MetadataTable)>` - A tuple containing:
    ///   * The file offset of the metadata table as `u64`.
    ///   * A reference to the parsed `MetadataTable` structure.
    /// * `None` - If the file is not a .NET executable, the relevant stream header cannot
    ///   be found, or the metadata table cannot be parsed.
    fn dotnet_parse_metadata_table(&self) -> Option<(u64, &MetadataTable)> {
        if !self.is_dotnet() {
            return None;
        }
        let (mut start, _) = self.dotnet_parse_storage_signature()?;
        for (_, header) in self.dotnet_parse_stream_headers()? {
            if header.name() == vec![0x23, 0x7e, 0x00, 0x00] {
                start += header.offset as u64;
            }
        }
        let data = &self.file.data[start as usize..start as usize + MetadataTable::size()];
        Some((start, MetadataTable::from_bytes(data)?))
    }

    /// Retrieves the .NET metadata table from the metadata of a PE file.
    ///
    /// This function provides a simpler interface to access the `MetadataTable` directly
    /// by internally calling `dotnet_parse_metadata_table` and returning only the parsed table.
    ///
    /// # Returns
    ///
    /// * `Option<&MetadataTable>` - A reference to the parsed `MetadataTable` structure.
    /// * `None` - If the file is not a .NET executable or the metadata table cannot be parsed.
    pub fn dotnet_metadata_table(&self) -> Option<&MetadataTable> {
        Some(self.dotnet_parse_metadata_table()?.1)
    }

    /// Parses and retrieves the entries from the .NET metadata table of a PE file.
    ///
    /// This function iterates through the metadata table entries specified in the
    /// `MetadataTable` structure, reading and parsing each entry based on its type
    /// (e.g., `Module`, `TypeRef`, `TypeDef`, `Field`, `MethodDef`). The function calculates
    /// the correct offsets, validates entry counts, and constructs a vector of parsed entries.
    ///
    /// # Returns
    ///
    /// * `Option<Vec<Entry>>` - A vector containing parsed entries from the metadata table.
    ///   Each entry is wrapped in the `Entry` enum to represent its specific type.
    /// * `None` - If the file is not a .NET executable, the metadata table cannot be parsed,
    ///   or an error occurs during entry parsing.
    ///
    /// # Notes
    ///
    /// * This function uses `MetadataToken` to determine the type of each metadata table entry.
    /// * The parsing depends on the `heap_sizes` field in the `MetadataTable` to correctly interpret
    ///   data sizes within entries.
    /// * If an invalid offset or entry count is encountered, the function will return `None`.
    pub fn dotnet_metadata_table_entries(&self) -> Option<Vec<Entry>> {
        if !self.is_dotnet() {
            return None;
        }

        let (cor20_metadata_table_offset, cor20_metadata_table) =
            self.dotnet_parse_metadata_table()?;

        let mut offset: usize = cor20_metadata_table_offset as usize
            + MetadataTable::size()
            + cor20_metadata_table.mask_valid.count_ones() as usize * 4;

        let mut valid_index: usize = 0;

        let mut entries = Vec::<Entry>::new();

        for i in 0..64 {
            let entry_offset =
                cor20_metadata_table_offset as usize + MetadataTable::size() + (valid_index * 4);

            if entry_offset + 4 > self.file.data.len() {
                return None;
            }

            let entry_count = u32::from_le_bytes(
                self.file.data[entry_offset..entry_offset + 4]
                    .try_into()
                    .unwrap(),
            ) as usize;

            match i {
                x if x == MetadataToken::Module as usize => {
                    for _ in 0..entry_count {
                        let entry = ModuleEntry::from_bytes(
                            &self.file.data[offset..],
                            cor20_metadata_table.heap_sizes,
                        )?;
                        offset += entry.size();
                        entries.push(Entry::Module(entry));
                    }
                    valid_index += 1;
                }
                x if x == MetadataToken::TypeRef as usize => {
                    for _ in 0..entry_count {
                        let entry = TypeRefEntry::from_bytes(
                            &self.file.data[offset..],
                            cor20_metadata_table.heap_sizes,
                        )?;
                        offset += entry.size();
                        entries.push(Entry::TypeRef(entry));
                    }
                    valid_index += 1;
                }
                x if x == MetadataToken::TypeDef as usize => {
                    for _ in 0..entry_count {
                        let entry = TypeDefEntry::from_bytes(
                            &self.file.data[offset..],
                            cor20_metadata_table.heap_sizes,
                        )?;
                        offset += entry.size();
                        entries.push(Entry::TypeDef(entry));
                    }
                    valid_index += 1;
                }
                x if x == MetadataToken::Field as usize => {
                    for _ in 0..entry_count {
                        let entry = FieldEntry::from_bytes(
                            &self.file.data[offset..],
                            cor20_metadata_table.heap_sizes,
                        )?;
                        offset += entry.size();
                        entries.push(Entry::Field(entry));
                    }
                    valid_index += 1;
                }
                x if x == MetadataToken::MethodDef as usize => {
                    for _ in 0..entry_count {
                        let entry = MethodDefEntry::from_bytes(
                            &self.file.data[offset..],
                            cor20_metadata_table.heap_sizes,
                        )?;
                        offset += entry.size();
                        entries.push(Entry::MethodDef(entry));
                    }
                }
                _ => {}
            }
        }

        Some(entries)
    }

    /// Computes a .NET metadata token from a given table index and entry index.
    ///
    /// # Parameters
    /// - `table_index`: The index of the metadata table.
    /// - `entry_index`: The index of the entry within the table.
    ///
    /// # Returns
    /// A `u64` value representing the metadata token. The calculation is based on the formula:
    /// `(0x01000000 * table_index) + (entry_index * 1)`.
    pub fn dotnet_metadata_token_from_index(table_index: u64, entry_index: u64) -> u64 {
        (0x01000000 * table_index) + entry_index
    }

    /// Constructs a map of metadata tokens to their corresponding virtual addresses.
    ///
    /// This function analyzes the .NET metadata table entries and calculates the virtual
    /// addresses for `MethodDef` entries. Each metadata token is generated based on the entry's
    /// index in the metadata table and is mapped to the computed virtual address.
    ///
    /// # Returns
    ///
    /// A `BTreeMap<u64, u64>` where:
    /// - The key is the metadata token.
    /// - The value is the corresponding virtual address.
    pub fn dotnet_metadata_token_virtual_addresses(&self) -> BTreeMap<u64, u64> {
        let mut result = BTreeMap::<u64, u64>::new();
        if !self.is_dotnet() {
            return result;
        }
        let entries = match self.dotnet_metadata_table_entries() {
            Some(entries) => entries,
            None => {
                return result;
            }
        };

        let mut i: u64 = 0;

        for entry in entries {
            if let Entry::MethodDef(entry) = entry {
                let token: u64 = PE::dotnet_metadata_token_from_index(6, i);
                i += 1;

                if entry.rva == 0 {
                    continue;
                }

                let mut va = self.relative_virtual_address_to_virtual_address(entry.rva as u64);

                let method_header = match self.dotnet_method_header(va) {
                    Ok(h) => h,
                    Err(_) => continue,
                };

                if let Some(size) = method_header.size() {
                    va += size as u64;
                    result.insert(token, va);
                }
            }
        }
        result
    }

    /// Converts a virtual address to a relative virtual address (RVA).
    ///
    /// This function computes the relative virtual address by subtracting the image base
    /// address of the file from the given virtual address.
    ///
    /// # Parameters
    ///
    /// * `address` - The virtual address (`u64`) to be converted.
    ///
    /// # Returns
    ///
    /// * `u64` - The relative virtual address (RVA).
    pub fn virtual_address_to_relative_virtual_address(&self, address: u64) -> u64 {
        address - self.imagebase()
    }

    /// Converts a virtual address to a file offset in the PE file.
    ///
    /// This function first converts the virtual address to a relative virtual address (RVA)
    /// using `virtual_address_to_relative_virtual_address` and then resolves the RVA to a
    /// file offset using `relative_virtual_address_to_file_offset`.
    ///
    /// # Parameters
    ///
    /// * `address` - The virtual address (`u64`) to be converted.
    ///
    /// # Returns
    ///
    /// * `Option<u64>` - The file offset corresponding to the given virtual address, or
    ///   `None` if the conversion fails.
    pub fn virtual_address_to_file_offset(&self, address: u64) -> Option<u64> {
        let rva = self.virtual_address_to_relative_virtual_address(address);
        self.relative_virtual_address_to_file_offset(rva)
    }

    /// Parses and retrieves a method header from a given virtual address in the PE file.
    ///
    /// This function identifies and parses the method header (either Tiny or Fat)
    /// associated with the given virtual address. The header type is determined based
    /// on specific bits in the header's first byte. If the address is invalid or the
    /// data does not correspond to a valid method header, an error is returned.
    ///
    /// # Parameters
    ///
    /// * `address` - The virtual address (`u64`) of the method header.
    ///
    /// # Returns
    ///
    /// * `Result<MethodHeader, Error>` -
    ///   * `Ok(MethodHeader)` - The parsed method header as either `Tiny` or `Fat`.
    ///   * `Err(Error)` - If the virtual address is invalid or the data is not a valid method header.
    pub fn dotnet_method_header(&self, address: u64) -> Result<MethodHeader, Error> {
        let offset = self.virtual_address_to_file_offset(address);

        if offset.is_none() {
            return Err(Error::new(
                ErrorKind::InvalidInput,
                "failed to convert virtual address to file offset",
            ));
        }

        let bytes = &self.file.data[offset.unwrap() as usize..offset.unwrap() as usize + 12];

        if bytes[0] & 0b11 == 0b10 {
            let code_size = bytes[0] >> 2;
            let tiny_header = TinyHeader { code_size };
            return Ok(MethodHeader::Tiny(tiny_header));
        }
        if bytes[0] & 0b11 == 0b11 {
            let fat_header = FatHeader::from_bytes(bytes)?;
            return Ok(MethodHeader::Fat(fat_header));
        }
        Err(Error::new(ErrorKind::InvalidData, "invalid method header"))
    }

    /// Checks if the PE file is a .NET assembly.
    ///
    /// This function inspects the imports of the PE file to identify whether it is a .NET application.
    /// It does so by looking for the presence of specific .NET-related DLLs (`mscorelib.dll` and `mscoree.dll`)
    /// in the import table and confirming the existence of a CLR runtime header.
    ///
    /// # Returns
    ///
    /// - `true` if the PE file is a .NET assembly.
    /// - `false` otherwise.
    #[allow(dead_code)]
    pub fn is_dotnet(&self) -> bool {
        self.pe.imports().any(|import| {
            matches!(
                import.name().to_lowercase().as_str(),
                "mscorelib.dll" | "mscoree.dll"
            ) && self
                .pe
                .data_directory_by_type(DATA_DIRECTORY::CLR_RUNTIME_HEADER)
                .is_some()
        })
    }

    /// Creates a new `PE` instance from a byte vector containing PE file data.
    ///
    /// # Parameters
    /// - `bytes`: A vector of bytes representing the PE file data.
    ///
    /// # Returns
    /// A `Result` containing the `PE` object on success or an `Error` on failure.
    #[allow(dead_code)]
    pub fn from_bytes(bytes: Vec<u8>, config: Config) -> Result<Self, Error> {
        let file = File::from_bytes(bytes, config.clone());
        let mut cursor = Cursor::new(&file.data);
        if let Some(Binary::PE(pe)) = Binary::from(&mut cursor) {
            return Ok(Self { pe, file, config });
        }
        Err(Error::new(ErrorKind::InvalidInput, "invalid pe file"))
    }

    /// Returns the architecture of the PE file based on its machine type.
    ///
    /// # Returns
    /// The `BinaryArchitecture` enum value corresponding to the PE machine type (e.g., AMD64, I386, CIL or UNKNOWN).
    #[allow(dead_code)]
    pub fn architecture(&self) -> Architecture {
        match self.pe.header().machine() {
            MachineType::I386 if self.is_dotnet() => Architecture::CIL,
            MachineType::I386 => Architecture::I386,
            MachineType::AMD64 => Architecture::AMD64,
            _ => Architecture::UNKNOWN,
        }
    }

    /// Retrieves the virtual address ranges of executable methods in a .NET executable.
    ///
    /// This function scans the .NET metadata table for `MethodDef` entries and computes
    /// the virtual address ranges for executable methods. It uses the relative virtual
    /// address (RVA) of each method to determine its virtual address and extracts the
    /// method's header to calculate the start and end addresses of the method's executable code.
    ///
    /// # Returns
    ///
    /// * `BTreeMap<u64, u64>` - A map where:
    ///   * Keys represent the start of the method's executable code (virtual address).
    ///   * Values represent the end of the method's executable code (virtual address).
    pub fn dotnet_executable_virtual_address_ranges(&self) -> BTreeMap<u64, u64> {
        let mut result = BTreeMap::<u64, u64>::new();
        if !self.is_dotnet() {
            return result;
        }
        let entries = match self.dotnet_metadata_table_entries() {
            Some(entries) => entries,
            None => return result,
        };

        for entry in entries {
            let Entry::MethodDef(entry) = entry else {
                continue;
            };

            if entry.rva == 0 {
                continue;
            }

            let va = self.relative_virtual_address_to_virtual_address(entry.rva as u64);

            let header = match self.dotnet_method_header(va).ok() {
                Some(header) => header,
                None => continue,
            };

            let header_size = match header.size() {
                Some(size) => size,
                None => continue,
            };

            let code_size = match header.code_size() {
                Some(size) => size,
                None => continue,
            };

            result.insert(
                va + header_size as u64,
                va + header_size as u64 + code_size as u64,
            );
        }
        result
    }

    /// Identifies and returns a set of virtual addresses that belong to vtable entries
    /// within executable sections of a PE file.
    ///
    /// This function scans all sections of a PE file to find consecutive virtual addresses
    /// that are considered executable. It filters the sections based on their characteristics
    /// and excludes certain edge cases, such as .NET binaries.
    ///
    /// # Returns
    /// - A `BTreeSet` of `u64` representing executable vtable virtual addresses.
    pub fn vtable_executable_virtual_addresses(&self) -> BTreeSet<u64> {
        let mut result = BTreeSet::<u64>::new();

        if self.is_dotnet() {
            return result;
        }

        let executable_virtual_address_ranges = self.executable_virtual_address_ranges();

        for section in self.pe.sections() {
            if (section.characteristics().bits() & u64::from(Characteristics::MEM_EXECUTE)) != 0
                || section.virtual_size() == 0
                || section.sizeof_raw_data() == 0
            {
                continue;
            }

            let start_offset = match self
                .relative_virtual_address_to_file_offset(section.pointerto_raw_data() as u64)
            {
                Some(offset) => offset,
                None => continue,
            };

            let end_offset = start_offset + section.sizeof_raw_data() as u64;

            let mut consecutive_addresses = Vec::new();

            for offset in (start_offset as usize..end_offset as usize).step_by(4) {
                if offset + 4 > self.file.data.len() {
                    break;
                }

                let virtual_address = self.imagebase()
                    + u32::from_le_bytes(self.file.data[offset..offset + 4].try_into().unwrap())
                        as u64;

                if executable_virtual_address_ranges
                    .iter()
                    .any(|(start, end)| virtual_address >= *start && virtual_address <= *end)
                {
                    consecutive_addresses.push(virtual_address);

                    if consecutive_addresses.len() >= 6 {
                        result.extend(&consecutive_addresses);
                        consecutive_addresses.clear();
                    }
                } else {
                    consecutive_addresses.clear();
                }
            }
        }

        result
    }

    /// Returns the ranges of executable memory addresses within the PE file.
    ///
    /// This includes sections marked as executable (`MEM_EXECUTE`) and with valid data.
    ///
    /// # Returns
    /// A `BTreeMap` where the key is the start address of the executable range and the value is the end address.
    #[allow(dead_code)]
    pub fn executable_virtual_address_ranges(&self) -> BTreeMap<u64, u64> {
        let mut result = BTreeMap::<u64, u64>::new();
        if self.is_dotnet() {
            return result;
        }
        for section in self.pe.sections() {
            if (section.characteristics().bits() & u64::from(Characteristics::MEM_EXECUTE)) == 0 {
                continue;
            }
            if section.virtual_size() == 0 {
                continue;
            }
            if section.sizeof_raw_data() == 0 {
                continue;
            }
            let section_virtual_adddress = PE::align_section_virtual_address(
                self.imagebase() + section.pointerto_raw_data() as u64,
                self.section_alignment(),
                self.file_alignment(),
            );
            result.insert(
                section_virtual_adddress,
                section_virtual_adddress + section.virtual_size() as u64,
            );
        }
        result
    }

    /// Returns a map of Pogo (debug) entries found in the PE file, keyed by their start RVA (Relative Virtual Address).
    ///
    /// # Returns
    /// A `HashMap` where the key is the RVA of the start of the Pogo entry and the value is the name of the entry.
    ///
    #[allow(dead_code)]
    pub fn pogo_virtual_addresses(&self) -> HashMap<u64, String> {
        let mut result = HashMap::<u64, String>::new();
        for entry in self.pe.debug() {
            if let Entries::Pogo(pogos) = entry {
                for pogo in pogos.entries() {
                    result.insert(self.imagebase() + pogo.start_rva() as u64, pogo.name());
                }
            }
        }
        result
    }

    /// Returns a set of TLS (Thread Local Storage) callback addresses in the PE file.
    ///
    /// The method retrieves the TLS callbacks from the PE file's TLS data directory, if present.
    /// TLS callbacks are functions that are called when a thread is created or terminated, and they
    /// are often used in applications to initialize or clean up thread-local data.
    ///
    /// # Returns
    /// A `BTreeSet<u64>` containing the addresses of the TLS callback functions.
    pub fn tlscallback_virtual_addresses(&self) -> BTreeSet<u64> {
        self.pe
            .tls()
            .into_iter()
            .flat_map(|tls| tls.callbacks())
            .collect()
    }

    /// Returns a set of dotnet function virtual addresses in the PE file.
    ///
    /// # Returns
    /// A `BTreeSet` of function addresses in the PE file.
    pub fn dotnet_entrypoint_virtual_addresses(&self) -> BTreeSet<u64> {
        let mut addresses = BTreeSet::<u64>::new();
        if !self.is_dotnet() {
            return addresses;
        }
        let entries = match self.dotnet_metadata_table_entries() {
            Some(entries) => entries,
            None => {
                return addresses;
            }
        };
        for entry in entries {
            if let Entry::MethodDef(header) = entry {
                if header.rva == 0 {
                    continue;
                }

                let mut va = self.relative_virtual_address_to_virtual_address(header.rva as u64);

                if let Ok(method_header) = self.dotnet_method_header(va) {
                    if let Some(size) = method_header.size() {
                        va += size as u64;
                        addresses.insert(va);
                    }
                }
            }
        }
        addresses
    }

    /// Returns a set of function addresses (entry point, exports, TLS callbacks, and Pogo entries) in the PE file.
    ///
    /// # Returns
    /// A `BTreeSet` of function addresses in the PE file.
    #[allow(dead_code)]
    pub fn entrypoint_virtual_addresses(&self) -> BTreeSet<u64> {
        let mut addresses = BTreeSet::<u64>::new();
        addresses.insert(self.entrypoint_virtual_address());
        addresses.extend(self.export_virtual_addresses());
        addresses.extend(self.tlscallback_virtual_addresses());
        addresses.extend(self.pogo_virtual_addresses().keys().cloned());
        addresses.extend(self.vtable_executable_virtual_addresses());
        addresses
    }

    /// Returns the entry point address of the PE file.
    ///
    /// # Returns
    /// The entry point address as a `u64` value.
    #[allow(dead_code)]
    pub fn entrypoint_virtual_address(&self) -> u64 {
        self.imagebase() + self.pe.optional_header().addressof_entrypoint() as u64
    }

    /// Returns the size of the headers of the PE file.
    ///
    /// # Returns
    /// The size of the headers as a `u64` value.
    #[allow(dead_code)]
    pub fn sizeofheaders(&self) -> u64 {
        self.pe.optional_header().sizeof_headers() as u64
    }

    /// Aligns a section's virtual address to the specified section and file alignment boundaries.
    ///
    /// # Parameters
    /// - `value`: The virtual address to align.
    /// - `section_alignment`: The section alignment boundary.
    /// - `file_alignment`: The file alignment boundary.
    ///
    /// # Returns
    /// The aligned virtual address.
    #[allow(dead_code)]
    pub fn align_section_virtual_address(
        value: u64,
        mut section_alignment: u64,
        file_alignment: u64,
    ) -> u64 {
        if section_alignment < 0x1000 {
            section_alignment = file_alignment;
        }
        if section_alignment != 0 && (value % section_alignment) != 0 {
            return value.div_ceil(section_alignment) * section_alignment;
        }
        value
    }

    /// Returns the section alignment used in the PE file.
    ///
    /// # Returns
    /// The section alignment value as a `u64`.
    #[allow(dead_code)]
    pub fn section_alignment(&self) -> u64 {
        self.pe.optional_header().section_alignment() as u64
    }

    /// Returns the file alignment used in the PE file.
    ///
    /// # Returns
    /// The file alignment value as a `u64`.
    #[allow(dead_code)]
    pub fn file_alignment(&self) -> u64 {
        self.pe.optional_header().file_alignment() as u64
    }

    /// Converts a relative virtual address to a virtual address
    ///
    /// # Returns
    /// The virtual address as a `u64`.
    #[allow(dead_code)]
    pub fn relative_virtual_address_to_virtual_address(
        &self,
        relative_virtual_address: u64,
    ) -> u64 {
        self.imagebase() + relative_virtual_address
    }

    /// Converts a file offset to a virtual address.
    ///
    /// This method looks through the PE file's sections to determine which section contains the file offset.
    /// It then computes the corresponding virtual address within that section.
    ///
    /// # Parameters
    /// - `file_offset`: The file offset (raw data offset) to convert to a virtual address.
    ///
    /// # Returns
    /// The corresponding virtual address as a `u64`.
    #[allow(dead_code)]
    pub fn file_offset_to_virtual_address(&self, file_offset: u64) -> Option<u64> {
        for section in self.pe.sections() {
            let section_raw_data_offset = section.pointerto_raw_data() as u64;
            let section_raw_data_size = section.sizeof_raw_data() as u64;
            if file_offset >= section_raw_data_offset
                && file_offset < section_raw_data_offset + section_raw_data_size
            {
                let section_virtual_address =
                    self.imagebase() + section.pointerto_raw_data() as u64;
                let section_offset = file_offset - section_raw_data_offset;
                let virtual_address = section_virtual_address + section_offset;
                return Some(virtual_address);
            }
        }
        None
    }

    /// Caches the PE file contents and returns a `MemoryMappedFile` object.
    ///
    /// # Parameters
    /// - `path`: The base path to store the memory mapped file.
    /// - `cache`: Whether to cache the file or not.
    ///
    /// # Returns
    /// A `Result` containing the `MemoryMappedFile` object on success or an `Error` on failure.
    pub fn image(&self) -> Result<MemoryMappedFile, Error> {
        let pathbuf = PathBuf::from(self.config.mmap.directory.clone())
            .join(self.file.sha256_no_config().unwrap());
        let mut tempmap = MemoryMappedFile::new(pathbuf, self.config.mmap.cache.enabled)?;
        if tempmap.is_cached() {
            return Ok(tempmap);
        }
        tempmap.seek_to_end()?;
        tempmap
            .write(&self.file.data[0..self.sizeofheaders() as usize])
            .map_err(|error| {
                Error::other(format!(
                    "failed to write headers to memory-mapped pe file: {}",
                    error
                ))
            })?;
        for section in self.pe.sections() {
            if section.virtual_size() == 0 {
                continue;
            }
            if section.sizeof_raw_data() == 0 {
                continue;
            }
            let section_virtual_adddress = PE::align_section_virtual_address(
                self.imagebase() + section.pointerto_raw_data() as u64,
                self.section_alignment(),
                self.file_alignment(),
            );
            if section_virtual_adddress > tempmap.size().unwrap() {
                let padding_length = section_virtual_adddress - tempmap.size().unwrap();
                tempmap.seek_to_end()?;
                tempmap
                    .write_padding(padding_length as usize)
                    .map_err(|error| {
                        Error::other(format!(
                            "write padding to pe memory-mapped pe file: {}",
                            error
                        ))
                    })?;
            }
            let pointerto_raw_data = section.pointerto_raw_data() as usize;
            let sizeof_raw_data = section.sizeof_raw_data() as usize;
            tempmap.seek_to_end()?;
            tempmap
                .write(&self.file.data[pointerto_raw_data..pointerto_raw_data + sizeof_raw_data])
                .map_err(|error| {
                    Error::other(format!(
                        "failed to write section to memory-mapped pe file: {}",
                        error
                    ))
                })?;
        }
        Ok(tempmap)
    }

    /// Returns the size of the PE file.
    ///
    /// # Returns
    /// The size of the file as a `u64`.
    #[allow(dead_code)]
    pub fn size(&self) -> u64 {
        self.file.size()
    }

    /// Returns the entropy of the PE file.
    ///
    /// # Returns
    /// The entropy of the file as a `Option<f64>`.
    #[allow(dead_code)]
    pub fn entropy(&self) -> Option<f64> {
        self.file.entropy()
    }

    /// Returns the TLS (Thread Local Storage) hash value if present in the PE file.
    ///
    /// # Returns
    /// An `Option<String>` containing the TLS hash if present, otherwise `None`.
    #[allow(dead_code)]
    pub fn tlsh(&self) -> Option<String> {
        self.file.tlsh()
    }

    /// Returns the SHA-256 hash value of the PE file.
    ///
    /// # Returns
    /// An `Option<String>` containing the SHA-256 hash if available, otherwise `None`.
    #[allow(dead_code)]
    pub fn sha256(&self) -> Option<String> {
        self.file.sha256()
    }

    /// Returns the File JSON associated with the PE
    ///
    /// # Returns
    /// An `Result<String, Error>` containing the File JSON.
    #[allow(dead_code)]
    pub fn file_json(&self) -> Result<String, Error> {
        self.file.json()
    }

    /// Returns the base address (image base) of the PE file.
    ///
    /// # Returns
    /// The image base address as a `u64`.
    #[allow(dead_code)]
    pub fn imagebase(&self) -> u64 {
        self.pe.optional_header().imagebase()
    }

    /// Returns a set of exported function addresses in the PE file.
    ///
    /// # Returns
    /// A `BTreeSet` of exported function addresses.
    #[allow(dead_code)]
    pub fn export_virtual_addresses(&self) -> BTreeSet<u64> {
        let mut addresses = BTreeSet::<u64>::new();
        let export = match self.pe.export() {
            Some(export) => export,
            None => {
                return addresses;
            }
        };
        for entry in export.entries() {
            let address = entry.address() as u64 + self.imagebase();
            addresses.insert(address);
        }
        addresses
    }
}

```

`src/genetics/allelepair.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::genetics::Gene;
use std::fmt;
use std::io::Error;
use std::io::ErrorKind;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
pub struct AllelePair {
    pub high: Gene,
    pub low: Gene,
    pub number_mutations: usize,
}

#[allow(dead_code)]
impl AllelePair {
    pub fn new(high: Gene, low: Gene) -> Self {
        Self {
            high,
            low,
            number_mutations: 0,
        }
    }

    pub fn number_of_mutations(&self) -> usize {
        self.number_mutations
    }

    pub fn mutate(&mut self, high: Gene, low: Gene) {
        self.high = high;
        self.low = low;
    }

    pub fn genes(&self) -> Vec<Gene> {
        vec![self.low, self.high]
    }

    pub fn from_string(pair: String) -> Result<Self, Error> {
        if pair.len() != 2 {
            return Err(Error::new(
                ErrorKind::InvalidData,
                "allele pair string must have a length of 2",
            ));
        }

        let mut chars = pair.chars();
        let high_char = chars.next().unwrap();
        let low_char = chars.next().unwrap();

        let high = Gene::from_char(high_char)?;
        let low = Gene::from_char(low_char)?;

        Ok(Self {
            high,
            low,
            number_mutations: 0,
        })
    }
}

impl fmt::Display for AllelePair {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}{}", self.high.to_char(), self.low.to_char())
    }
}

```

`src/genetics/chromosome.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::binary::Binary;
use crate::genetics::AllelePair;
use crate::genetics::Gene;
use crate::hashing::MinHash32;
use crate::hashing::SHA256;
use crate::hashing::TLSH;
use crate::lcs::FuzzyLCS;
use crate::Config;
use serde::{Deserialize, Serialize};
use serde_json;
use std::io::Error;
use std::io::ErrorKind;

#[derive(Clone)]
pub struct HomologousChromosome {
    pub score: f64,
    pub chromosome: Chromosome,
}

impl HomologousChromosome {
    pub fn process(&self) -> HomologousChromosomeJson {
        HomologousChromosomeJson {
            score: self.score(),
            chromosome: self.chromosome.process(),
        }
    }

    pub fn score(&self) -> f64 {
        self.score
    }

    #[allow(dead_code)]
    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct HomologousChromosomeJson {
    pub score: f64,
    pub chromosome: ChromosomeJson,
}

#[derive(Clone)]
pub struct ChromosomeSimilarityScore {
    pub minhash: Option<f64>,
    pub tlsh: Option<f64>,
}

impl ChromosomeSimilarityScore {
    pub fn process(&self) -> ChromosomeSimilarityScoreJson {
        ChromosomeSimilarityScoreJson {
            minhash: self.minhash(),
            tlsh: self.tlsh(),
        }
    }

    pub fn minhash(&self) -> Option<f64> {
        self.minhash
    }

    pub fn tlsh(&self) -> Option<f64> {
        self.tlsh
    }

    #[allow(dead_code)]
    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct ChromosomeSimilarityScoreJson {
    pub minhash: Option<f64>,
    pub tlsh: Option<f64>,
}

#[derive(Clone)]
pub struct ChromosomeSimilarity {
    pub score: ChromosomeSimilarityScore,
    pub homologues: Vec<HomologousChromosome>,
}

impl ChromosomeSimilarity {
    pub fn homologues(&self) -> Vec<HomologousChromosome> {
        self.homologues.clone()
    }

    pub fn process_homologues(&self) -> Vec<HomologousChromosomeJson> {
        let mut result = Vec::<HomologousChromosomeJson>::new();
        for homologous_chromosome in &self.homologues {
            result.push(homologous_chromosome.process());
        }
        result
    }

    pub fn process(&self) -> ChromosomeSimilarityJson {
        ChromosomeSimilarityJson {
            score: self.score.process(),
            homologues: self.process_homologues(),
        }
    }

    pub fn score(&self) -> ChromosomeSimilarityScore {
        self.score.clone()
    }

    #[allow(dead_code)]
    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct ChromosomeSimilarityJson {
    pub score: ChromosomeSimilarityScoreJson,
    pub homologues: Vec<HomologousChromosomeJson>,
}

/// Represents a JSON-serializable structure containing metadata about a chromosome.
#[derive(Serialize, Deserialize, Clone)]
pub struct ChromosomeJson {
    /// The raw pattern string of the chromosome.
    pub pattern: String,
    /// The feature vector extracted from the chromosome.
    pub feature: Vec<u8>,
    /// The entropy of the normalized chromosome, if enabled.
    pub entropy: Option<f64>,
    /// The SHA-256 hash of the normalized chromosome, if enabled.
    pub sha256: Option<String>,
    /// The MinHash of the normalized chromosome, if enabled.
    pub minhash: Option<String>,
    /// The TLSH (Locality Sensitive Hash) of the normalized chromosome, if enabled.
    pub tlsh: Option<String>,
}

/// Represents a chromosome within a control flow graph.
#[derive(Clone)]
pub struct Chromosome {
    pub allelepairs: Vec<AllelePair>,
    pub number_of_mutations: usize,
    config: Config,
}

impl Chromosome {
    /// Creates a new `Chromosome` instance for a specified address range within a control flow graph.
    ///
    /// # Returns
    ///
    /// Returns `Result<Chromosome, Error>`.
    pub fn new(pattern: String, config: Config) -> Result<Self, Error> {
        let allelepairs = Self::parse_pairs(pattern)?;
        Ok(Self {
            allelepairs,
            number_of_mutations: 0,
            config,
        })
    }

    pub fn number_of_mutations(&self) -> usize {
        self.number_of_mutations
    }

    pub fn mutate(&mut self, pattern: String) -> Result<(), Error> {
        self.allelepairs = Self::parse_pairs(pattern)?;
        self.number_of_mutations += 1;
        Ok(())
    }

    #[allow(dead_code)]
    fn parse_pairs(pattern: String) -> Result<Vec<AllelePair>, Error> {
        if pattern.len() % 2 != 0 {
            return Err(Error::new(
                ErrorKind::InvalidData,
                "pattern length must be even",
            ));
        }
        let mut parsed = Vec::new();
        let chars: Vec<char> = pattern.chars().collect();
        for chunk in chars.chunks(2) {
            let high = Self::parse_gene(chunk[0])?;
            let low = Self::parse_gene(chunk[1])?;
            parsed.push(AllelePair {
                high,
                low,
                number_mutations: 0,
            });
        }
        Ok(parsed)
    }

    fn parse_gene(c: char) -> Result<Gene, Error> {
        Gene::from_char(c)
    }

    pub fn allelepairs(&self) -> Vec<AllelePair> {
        self.allelepairs.clone()
    }

    pub fn pattern(&self) -> String {
        let mut result = String::new();
        for pair in &self.allelepairs {
            result += &pair.to_string();
        }
        result
    }

    /// Retrieves the raw bytes within the address range of the chromosome.
    ///
    /// # Returns
    ///
    /// Returns a `Vec<u8>` containing the normalized bytes of the chromosome.
    pub fn normalized(&self) -> Vec<u8> {
        let mut result = Vec::new();
        let mut temp_byte: Option<u8> = None;
        for pair in &self.allelepairs {
            if let Some(high) = pair.high.value() {
                if let Some(low) = temp_byte {
                    result.push((low << 4) | high);
                    temp_byte = None;
                } else {
                    temp_byte = Some(high);
                }
            }
            if let Some(low) = pair.low.value() {
                if let Some(high) = temp_byte {
                    result.push((high << 4) | low);
                    temp_byte = None;
                } else {
                    temp_byte = Some(low);
                }
            }
        }
        result
    }

    /// Extracts the feature vector from the normalized chromosome, if enabled.
    ///
    /// # Returns
    ///
    /// Returns a `Vec<u8>` containing the feature vector, or an empty vector if feature extraction is disabled.
    pub fn feature(&self) -> Vec<u8> {
        let mut result = Vec::<u8>::new();
        if !self.config.chromosomes.heuristics.features.enabled {
            return result;
        }
        for allelepair in &self.allelepairs {
            if let Some(high) = allelepair.high.value() {
                result.push(high);
            }
            if let Some(low) = allelepair.low.value() {
                result.push(low);
            }
        }
        result
    }

    /// Computes the TLSH (Locality Sensitive Hash) of the normalized chromosome, if enabled.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the TLSH, or `None` if TLSH is disabled.
    pub fn tlsh(&self) -> Option<String> {
        if !self.config.chromosomes.hashing.tlsh.enabled {
            return None;
        }
        TLSH::new(
            &self.normalized(),
            self.config.chromosomes.hashing.tlsh.minimum_byte_size,
        )
        .hexdigest()
    }

    /// Computes the MinHash of the normalized signature, if enabled.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the MinHash, or `None` if MinHash is disabled.
    #[allow(dead_code)]
    pub fn minhash(&self) -> Option<String> {
        if !self.config.chromosomes.hashing.minhash.enabled {
            return None;
        }
        if self.normalized().len() > self.config.chromosomes.hashing.minhash.maximum_byte_size
            && self
                .config
                .chromosomes
                .hashing
                .minhash
                .maximum_byte_size_enabled
        {
            return None;
        }
        MinHash32::new(
            &self.normalized(),
            self.config.chromosomes.hashing.minhash.number_of_hashes,
            self.config.chromosomes.hashing.minhash.shingle_size,
            self.config.chromosomes.hashing.minhash.seed,
        )
        .hexdigest()
    }

    /// Computes the SHA-256 hash of the normalized chromosome, if enabled.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the SHA-256 hash, or `None` if SHA-256 is disabled.
    pub fn sha256(&self) -> Option<String> {
        if !self.config.chromosomes.hashing.sha256.enabled {
            return None;
        }
        SHA256::new(&self.normalized()).hexdigest()
    }

    /// Computes the entropy of the normalized chromosome, if enabled.
    ///
    /// # Returns
    ///
    /// Returns `Some(f64)` containing the entropy, or `None` if entropy calculation is disabled.
    pub fn entropy(&self) -> Option<f64> {
        if !self.config.chromosomes.heuristics.entropy.enabled {
            return None;
        }
        Binary::entropy(&self.normalized())
    }

    /// Processes the chromosome into its JSON-serializable representation.
    ///
    /// # Returns
    ///
    /// Returns a `ChromosomeJson` struct containing metadata about the chromosome.
    pub fn process(&self) -> ChromosomeJson {
        ChromosomeJson {
            pattern: self.pattern(),
            feature: self.feature(),
            sha256: self.sha256(),
            entropy: self.entropy(),
            minhash: self.minhash(),
            tlsh: self.tlsh(),
        }
    }

    /// Compares the similarity of one chromosome to another.
    ///
    /// # Returns
    ///
    /// Returns `Option<ChromosomeSimilarity>` representing the similarity between two chromosomes.
    pub fn compare(self, rhs: &Chromosome) -> Option<ChromosomeSimilarity> {
        let lhs_minhash = self.minhash();
        let rhs_minhash = rhs.minhash();
        let mut minhash: Option<f64> = None;
        if lhs_minhash.is_some() && rhs_minhash.is_some() {
            minhash = Some(MinHash32::compare(
                &lhs_minhash.unwrap(),
                &rhs_minhash.unwrap(),
            ))
        }
        let lhs_tlsh = self.tlsh();
        let rhs_tlsh = rhs.tlsh();
        let mut tlsh: Option<f64> = None;
        if lhs_tlsh.is_some() && rhs_tlsh.is_some() {
            tlsh = TLSH::compare(lhs_tlsh.unwrap(), rhs_tlsh.unwrap());
        }

        if minhash.is_none() && tlsh.is_none() {
            return None;
        }

        let mut homologues = Vec::<HomologousChromosome>::new();
        if self.config.chromosomes.homologues.enabled {
            let lhs_pattern = self.pattern();
            let rhs_pattern = rhs.pattern();
            for (score, (_, _), homologue) in lhs_pattern.fuzzy_find_subyara_all(rhs_pattern, 0.25)
            {
                if let Ok(c) = Chromosome::new(homologue.to_string().clone(), self.config.clone()) {
                    let homologous_chromosome = HomologousChromosome {
                        score: score as f64,
                        chromosome: c.clone(),
                    };
                    homologues.push(homologous_chromosome);
                }
            }
        }
        Some(ChromosomeSimilarity {
            score: ChromosomeSimilarityScore { minhash, tlsh },
            homologues,
        })
    }

    /// Converts the signature metadata into a JSON string representation.
    ///
    /// # Returns
    ///
    /// Returns `Ok(String)` containing the JSON representation of the signature,
    /// or an `Err` if serialization fails.
    #[allow(dead_code)]
    pub fn json(&self) -> Result<String, Error> {
        let raw = self.process();
        let result = serde_json::to_string(&raw)?;
        Ok(result)
    }

    /// Prints the JSON representation of the chromosome to standard output.
    #[allow(dead_code)]
    pub fn print(&self) {
        if let Ok(json) = self.json() {
            println!("{}", json);
        }
    }
}

```

`src/genetics/gene.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::io::Error;
use std::io::ErrorKind;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
pub struct Gene {
    pub kind: GeneKind,
    pub value: Option<u8>,
    pub number_of_mutations: usize,
}

#[derive(Debug, Clone, Copy)]
pub enum GeneKind {
    Wildcard,
    Value,
}

#[allow(dead_code)]
impl Gene {
    pub fn is_wildcard(&self) -> bool {
        matches!(self.kind, GeneKind::Wildcard)
    }

    pub fn is_value(&self) -> bool {
        matches!(self.kind, GeneKind::Value)
    }

    pub fn from_wildcard() -> Self {
        Self {
            kind: GeneKind::Wildcard,
            value: None,
            number_of_mutations: 0,
        }
    }

    pub fn wildcard(&self) -> Option<String> {
        match self.kind {
            GeneKind::Wildcard => Some("?".to_string()),
            _ => None,
        }
    }

    pub fn value(&self) -> Option<u8> {
        match self.kind {
            GeneKind::Value => self.value,
            _ => None,
        }
    }

    pub fn from_value(v: u8) -> Self {
        Self {
            kind: GeneKind::Value,
            value: Some(v),
            number_of_mutations: 0,
        }
    }

    pub fn mutate(&mut self, c: char) -> Result<(), Error> {
        match c {
            '?' => {
                self.kind = GeneKind::Wildcard;
                self.value = None;
                self.number_of_mutations += 1;
                Ok(())
            }
            '0'..='9' | 'a'..='f' | 'A'..='F' => {
                self.kind = GeneKind::Value;
                self.value = c.to_digit(16).map(|v| v as u8);
                self.number_of_mutations += 1;
                Ok(())
            }
            _ => Err(Error::new(
                ErrorKind::InvalidData,
                "invaid data to mutate gene",
            )),
        }
    }

    pub fn print(&self) {
        println!("{}", self.to_char());
    }

    pub fn to_char(&self) -> String {
        match self.kind {
            GeneKind::Wildcard => "?".to_string(),
            GeneKind::Value => {
                if let Some(v) = self.value {
                    format!("{:x}", v)
                } else {
                    panic!("Gene of kind Value is missing a value")
                }
            }
        }
    }

    pub fn from_char(c: char) -> Result<Self, std::io::Error> {
        match c {
            '?' => Ok(Self::from_wildcard()),
            '0'..='9' | 'a'..='f' | 'A'..='F' => c
                .to_digit(16)
                .map(|v| Self::from_value(v as u8))
                .ok_or_else(|| Error::new(ErrorKind::InvalidData, "invalid hexadecimal digit")),
            _ => Err(Error::new(ErrorKind::InvalidInput, "invalid character")),
        }
    }
}

```

`src/genetics/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod chromosome;
pub mod allelepair;
pub mod gene;

pub use chromosome::Chromosome;
pub use chromosome::ChromosomeJson;
pub use chromosome::ChromosomeSimilarity;
pub use allelepair::AllelePair;
pub use gene::Gene;

```

`src/global/architecture.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::fmt;
use std::io::Error;
use std::io::ErrorKind;
use std::str::FromStr;

/// Represents the different architectures of a binary.
#[repr(u16)]
#[derive(Copy, Clone, PartialEq, Debug)]
pub enum Architecture {
    /// 64-bit AMD architecture.
    AMD64 = 0x00,
    /// 32-bit Intel architecture.
    I386 = 0x01,
    /// CIL
    CIL = 0x02,
    /// Unknown architecture.
    UNKNOWN = 0x03,
}

impl Architecture {
    pub fn to_vec() -> Vec<String> {
        vec![
            Architecture::AMD64.to_string(),
            Architecture::I386.to_string(),
            Architecture::CIL.to_string(),
        ]
    }
}

impl Architecture {
    pub fn to_list() -> String {
        Architecture::to_vec().join(", ")
    }

    pub fn from_string(s: &str) -> Result<Self, Error> {
        match s.to_lowercase().as_str() {
            "amd64" => Ok(Architecture::AMD64),
            "i386" => Ok(Architecture::I386),
            "cil" => Ok(Architecture::CIL),
            _ => Err(Error::new(
                ErrorKind::InvalidInput,
                format!("invalid or unsupported architecture: {}", s),
            )),
        }
    }
}

/// Implements Display for `BinaryArchitecture` enum
impl fmt::Display for Architecture {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let architecture = match self {
            Architecture::AMD64 => "amd64",
            Architecture::I386 => "i386",
            Architecture::CIL => "cil",
            Architecture::UNKNOWN => "unknown",
        };
        write!(f, "{}", architecture)
    }
}

impl FromStr for Architecture {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "amd64" => Ok(Architecture::AMD64),
            "i386" => Ok(Architecture::I386),
            "cil" => Ok(Architecture::CIL),
            _ => Err(Error::new(
                ErrorKind::InvalidInput,
                format!("invalid or unsupported architecture: {}", s),
            )
            .to_string()),
        }
    }
}

```

`src/global/config.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use dirs;
use serde;
use serde::{Deserialize, Serialize};
use std::env;
use std::io::Error;
use std::io::ErrorKind;
use std::{fs, path::PathBuf};

pub const VERSION: &str = env!("CARGO_PKG_VERSION");
pub const AUTHOR: &str = "@c3rb3ru5d3d53c";
pub const DIRECTORY: &str = "binlex";
pub const FILE_NAME: &str = "binlex.toml";

// #[derive(Serialize, Deserialize, Clone)]
// pub struct ConfigHomologuesMinhash {
//     pub enabled: bool,
//     pub threshold: f64,
// }

// #[derive(Serialize, Deserialize, Clone)]
// pub struct ConfigHomologuesTLSH {
//     pub enabled: bool,
//     pub threshold: f64,
// }

// #[derive(Serialize, Deserialize, Clone)]
// pub struct ConfigHomologuesHashing {
//     pub minhash: ConfigHomologuesMinhash,
//     pub tlsh: ConfigHomologuesTLSH,
// }

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigHomologues {
    pub enabled: bool,
    pub maximum: usize,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigBlockInstructions {
    pub enabled: bool,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigFunctionBlocks {
    pub enabled: bool,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigInstructions {
    pub enabled: bool,
    pub hashing: ConfigHashing,
    pub heuristics: ConfigHeuristics,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigBlocks {
    pub enabled: bool,
    pub instructions: ConfigBlockInstructions,
    pub hashing: ConfigHashing,
    pub heuristics: ConfigHeuristics,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigChromosomes {
    pub hashing: ConfigHashing,
    pub heuristics: ConfigHeuristics,
    pub homologues: ConfigHomologues,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigFunctions {
    pub enabled: bool,
    pub blocks: ConfigFunctionBlocks,
    pub hashing: ConfigHashing,
    pub heuristics: ConfigHeuristics,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigFile {
    pub hashing: ConfigHashing,
    pub heuristics: ConfigHeuristics,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigFormats {
    pub file: ConfigFile,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct Config {
    pub general: ConfigGeneral,
    pub formats: ConfigFormats,
    pub instructions: ConfigInstructions,
    pub blocks: ConfigBlocks,
    pub functions: ConfigFunctions,
    pub chromosomes: ConfigChromosomes,
    pub mmap: ConfigMmap,
    pub disassembler: ConfigDisassembler,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigDisassembler {
    pub sweep: ConfigDisassemblerSweep,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigDisassemblerSweep {
    pub enabled: bool,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigHeuristics {
    pub features: ConfigHeuristicFeatures,
    pub entropy: ConfigHeuristicEntropy,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigHeuristicFeatures {
    pub enabled: bool,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigHeuristicEntropy {
    pub enabled: bool,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigHashing {
    pub sha256: ConfigSHA256,
    pub tlsh: ConfigTLSH,
    pub minhash: ConfigMinhash,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigFileHashes {
    pub sha256: ConfigSHA256,
    pub tlsh: ConfigTLSH,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigGeneral {
    pub threads: usize,
    pub minimal: bool,
    pub debug: bool,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigMmap {
    pub directory: String,
    pub cache: ConfigMmapCache,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigMmapCache {
    pub enabled: bool,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigMinhash {
    pub enabled: bool,
    pub number_of_hashes: usize,
    pub shingle_size: usize,
    pub maximum_byte_size_enabled: bool,
    pub maximum_byte_size: usize,
    pub seed: u64,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigTLSH {
    pub enabled: bool,
    pub minimum_byte_size: usize,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct ConfigSHA256 {
    pub enabled: bool,
}

impl Config {
    #[allow(dead_code)]
    pub fn new() -> Self {
        Config {
            general: ConfigGeneral {
                threads: 1,
                minimal: false,
                debug: false,
            },
            formats: ConfigFormats {
                file: ConfigFile {
                    hashing: ConfigHashing {
                        sha256: ConfigSHA256 { enabled: true },
                        tlsh: ConfigTLSH {
                            enabled: true,
                            minimum_byte_size: 50,
                        },
                        minhash: ConfigMinhash {
                            enabled: true,
                            number_of_hashes: 64,
                            shingle_size: 4,
                            maximum_byte_size_enabled: false,
                            maximum_byte_size: 50,
                            seed: 0,
                        },
                    },
                    heuristics: ConfigHeuristics {
                        features: ConfigHeuristicFeatures { enabled: true },
                        entropy: ConfigHeuristicEntropy { enabled: true },
                    },
                },
            },
            instructions: ConfigInstructions {
                enabled: false,
                hashing: ConfigHashing {
                    sha256: ConfigSHA256 { enabled: true },
                    tlsh: ConfigTLSH {
                        enabled: true,
                        minimum_byte_size: 50,
                    },
                    minhash: ConfigMinhash {
                        enabled: true,
                        number_of_hashes: 64,
                        shingle_size: 4,
                        maximum_byte_size_enabled: false,
                        maximum_byte_size: 50,
                        seed: 0,
                    },
                },
                heuristics: ConfigHeuristics {
                    features: ConfigHeuristicFeatures { enabled: true },
                    entropy: ConfigHeuristicEntropy { enabled: true },
                },
            },
            blocks: ConfigBlocks {
                enabled: true,
                instructions: ConfigBlockInstructions { enabled: false },
                hashing: ConfigHashing {
                    sha256: ConfigSHA256 { enabled: true },
                    tlsh: ConfigTLSH {
                        enabled: true,
                        minimum_byte_size: 50,
                    },
                    minhash: ConfigMinhash {
                        enabled: true,
                        number_of_hashes: 64,
                        shingle_size: 4,
                        maximum_byte_size_enabled: false,
                        maximum_byte_size: 50,
                        seed: 0,
                    },
                },
                heuristics: ConfigHeuristics {
                    features: ConfigHeuristicFeatures { enabled: true },
                    entropy: ConfigHeuristicEntropy { enabled: true },
                },
            },
            functions: ConfigFunctions {
                enabled: true,
                blocks: ConfigFunctionBlocks { enabled: true },
                hashing: ConfigHashing {
                    sha256: ConfigSHA256 { enabled: true },
                    tlsh: ConfigTLSH {
                        enabled: true,
                        minimum_byte_size: 50,
                    },
                    minhash: ConfigMinhash {
                        enabled: true,
                        number_of_hashes: 64,
                        shingle_size: 4,
                        maximum_byte_size_enabled: false,
                        maximum_byte_size: 50,
                        seed: 0,
                    },
                },
                heuristics: ConfigHeuristics {
                    features: ConfigHeuristicFeatures { enabled: true },
                    entropy: ConfigHeuristicEntropy { enabled: true },
                },
            },
            chromosomes: ConfigChromosomes {
                hashing: ConfigHashing {
                    sha256: ConfigSHA256 { enabled: true },
                    tlsh: ConfigTLSH {
                        enabled: true,
                        minimum_byte_size: 50,
                    },
                    minhash: ConfigMinhash {
                        enabled: true,
                        number_of_hashes: 64,
                        shingle_size: 4,
                        maximum_byte_size_enabled: false,
                        maximum_byte_size: 50,
                        seed: 0,
                    },
                },
                heuristics: ConfigHeuristics {
                    features: ConfigHeuristicFeatures { enabled: true },
                    entropy: ConfigHeuristicEntropy { enabled: true },
                },
                homologues: ConfigHomologues {
                    enabled: true,
                    maximum: 4,
                },
            },
            mmap: ConfigMmap {
                directory: Config::default_file_mapping_directory(),
                cache: ConfigMmapCache { enabled: false },
            },
            disassembler: ConfigDisassembler {
                sweep: ConfigDisassemblerSweep { enabled: true },
            },
        }
    }

    pub fn enable_minimal(&mut self) {
        self.general.minimal = true;
        self.disable_heuristics();
        self.disable_hashing();
        self.functions.blocks.enabled = false;
        self.instructions.enabled = false;
        self.blocks.instructions.enabled = false;
    }

    pub fn disable_hashing(&mut self) {
        self.disable_block_hashing();
        self.disable_function_hashing();
        self.disable_chromosome_hashing();
        self.disable_file_hashing();
    }

    pub fn disable_chromosome_heuristics(&mut self) {
        self.chromosomes.heuristics.entropy.enabled = false;
        self.chromosomes.heuristics.features.enabled = false;
    }

    pub fn disable_instruction_hashing(&mut self) {
        self.instructions.hashing.sha256.enabled = false;
        self.instructions.hashing.tlsh.enabled = false;
        self.instructions.hashing.minhash.enabled = false;
    }

    pub fn disable_block_hashing(&mut self) {
        self.blocks.hashing.sha256.enabled = false;
        self.blocks.hashing.tlsh.enabled = false;
        self.blocks.hashing.minhash.enabled = false;
    }

    pub fn disable_file_hashing(&mut self) {
        self.formats.file.hashing.sha256.enabled = false;
        self.formats.file.hashing.tlsh.enabled = false;
        self.formats.file.hashing.minhash.enabled = false;
    }

    pub fn disable_file_heuristics(&mut self) {
        self.formats.file.heuristics.entropy.enabled = false;
        self.formats.file.heuristics.features.enabled = false;
    }

    pub fn disable_heuristics(&mut self) {
        self.disable_block_heuristics();
        self.disable_function_heuristics();
        self.disable_chromosome_heuristics();
        self.disable_file_heuristics();
    }

    pub fn disable_chromosome_hashing(&mut self) {
        self.chromosomes.hashing.sha256.enabled = false;
        self.chromosomes.hashing.tlsh.enabled = false;
        self.chromosomes.hashing.minhash.enabled = false;
    }

    pub fn disable_function_hashing(&mut self) {
        self.functions.hashing.sha256.enabled = false;
        self.functions.hashing.tlsh.enabled = false;
        self.functions.hashing.minhash.enabled = false;
    }

    pub fn disable_block_heuristics(&mut self) {
        self.blocks.heuristics.entropy.enabled = false;
        self.blocks.heuristics.features.enabled = false;
    }

    pub fn disable_instruction_heuristics(&mut self) {
        self.instructions.heuristics.entropy.enabled = false;
        self.instructions.heuristics.features.enabled = false;
    }

    pub fn disable_function_heuristics(&mut self) {
        self.functions.heuristics.entropy.enabled = false;
        self.functions.heuristics.features.enabled = false;
    }

    // Get Default File Mapping Directory
    #[allow(dead_code)]
    pub fn default_file_mapping_directory() -> String {
        env::temp_dir()
            .join(DIRECTORY)
            .to_str()
            .expect("failed to convert file mapping directory to string")
            .to_owned()
    }

    /// Prints the Current Configuration
    #[allow(dead_code)]
    pub fn print(&self) {
        println!("{}", self.to_string().unwrap());
    }

    /// Convert Config to a TOML String
    ///
    #[allow(dead_code)]
    pub fn to_string(&self) -> Result<String, Error> {
        toml::to_string_pretty(self).map_err(Error::other)
    }

    /// Reads the Configuration TOML from a File Path
    pub fn from_file(file_path: &str) -> Result<Config, Error> {
        let toml_string = fs::read_to_string(file_path)?;
        let config: Config = toml::from_str(&toml_string).map_err(|error| {
            Error::new(
                ErrorKind::InvalidData,
                format!(
                    "failed to read configuration file {}\n\n{}",
                    file_path, error
                ),
            )
        })?;
        Ok(config)
    }

    /// Write the configuration TOML to a file
    #[allow(dead_code)]
    pub fn write_to_file(&self, file_path: &str) -> Result<(), Error> {
        let toml_string = self
            .to_string()
            .expect("failed to serialize binlex configration to toml format");
        fs::write(file_path, toml_string)?;
        Ok(())
    }

    /// Writes Default TOML Configuration File To Configuration Directory
    #[allow(dead_code)]
    pub fn write_default(&self) -> Result<(), Error> {
        if let Some(config_directory) = dirs::config_dir() {
            let config_file_path: PathBuf =
                config_directory.join(format!("{}/{}", DIRECTORY, FILE_NAME));
            if let Some(parent_directory) = config_file_path.parent() {
                if !parent_directory.exists() {
                    fs::create_dir_all(parent_directory)
                        .expect("failed to create binlex configuration directory");
                }
            }
            if !config_file_path.exists() {
                return self.write_to_file(config_file_path.to_str().unwrap());
            }
        }
        Err(Error::other("default configuration already exists"))
    }

    /// Reads the default TOML Configuration File
    #[allow(dead_code)]
    pub fn from_default(&mut self) -> Result<(), Error> {
        if let Some(config_directory) = dirs::config_dir() {
            let config_file_path: PathBuf =
                config_directory.join(format!("{}/{}", DIRECTORY, FILE_NAME));
            if config_file_path.exists() {
                match Config::from_file(config_file_path.to_str().unwrap()) {
                    Ok(config) => {
                        return {
                            *self = config;
                            Ok(())
                        }
                    }
                    Err(error) => return Err(error),
                }
            }
        }
        Err(Error::other(
            "unable to read binlex default configuration file",
        ))
    }
}

impl Default for Config {
    fn default() -> Self {
        Config::new()
    }
}

```

`src/global/format.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::fmt;
use std::fs::File;
use std::io::Error;
use std::io::ErrorKind;
use std::io::{Read, Seek, SeekFrom};
use std::str::FromStr;

#[repr(u16)]
#[derive(Copy, Clone, PartialEq, Debug)]
pub enum Format {
    /// Raw File
    CODE = 0x00,
    /// Portable Executable
    PE = 0x01,
    /// ELF Executable
    ELF = 0x02,
    /// MachO Executable
    MACHO = 0x03,
    /// Unknown formats
    UNKNOWN = 0x04,
}

impl Format {
    pub fn from_file(path: String) -> Result<Format, Error> {
        let mut file = File::open(path)?;

        let mut buffer = [0u8; 2];
        file.seek(SeekFrom::Start(0x00))?;
        file.read_exact(&mut buffer)?;
        if buffer == [0x4d, 0x5a] {
            file.seek(SeekFrom::Start(0x3c))?;
            let mut pe_offset = [0u8; 4];
            file.read_exact(&mut pe_offset)?;
            let pe_offset = u32::from_le_bytes(pe_offset);
            file.seek(SeekFrom::Start(pe_offset as u64))?;
            let mut pe_signature = [0u8; 4];
            file.read_exact(&mut pe_signature)?;
            if pe_signature == [0x50, 0x45, 0x00, 0x00] {
                return Ok(Format::PE);
            }
        }
        let mut buffer = [0u8; 3];
        file.seek(SeekFrom::Start(0x01))?;
        file.read_exact(&mut buffer)?;
        if buffer == [0x45, 0x4c, 0x46] {
            return Ok(Format::ELF);
        }

        let mut buffer = [0u8; 4];
        file.seek(SeekFrom::Start(0x00))?;
        file.read_exact(&mut buffer)?;
        if buffer == [0xCE, 0xFA, 0xED, 0xFE]
            || buffer == [0xCF, 0xFA, 0xED, 0xFE]
            || buffer == [0xBE, 0xBA, 0xFE, 0xCA]
        {
            return Ok(Format::MACHO);
        }

        Ok(Format::UNKNOWN)
    }
}

impl fmt::Display for Format {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let format: &str = match self {
            Format::CODE => "code",
            Format::PE => "pe",
            Format::ELF => "elf",
            Format::MACHO => "macho",
            Format::UNKNOWN => "unknown",
        };
        write!(f, "{}", format)
    }
}

impl FromStr for Format {
    type Err = std::io::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "code" => Ok(Format::CODE),
            "pe" => Ok(Format::PE),
            "elf" => Ok(Format::ELF),
            "macho" => Ok(Format::MACHO),
            "unknown" => Ok(Format::UNKNOWN),
            _ => Err(Error::new(
                ErrorKind::InvalidInput,
                format!("invalid format: '{}'", s),
            )),
        }
    }
}

```

`src/global/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod format;
pub mod architecture;
pub mod config;

pub use architecture::Architecture;
pub use format::Format;
pub use config::Config;
pub use config::AUTHOR;
pub use config::VERSION;

```

`src/hashing/minhash.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use rand::rngs::SmallRng;
use rand::{Rng, SeedableRng};
use std::hash::{Hash, Hasher};
use twox_hash::XxHash32;

const PRIME_MODULUS: u32 = 4294967291;

/// A MinHash implementation using 32-bit hashes for approximate set similarity calculations.
///
/// This struct provides methods to compute MinHash signatures for a given set of shingles (substrings of fixed size)
/// from a byte slice and to calculate the Jaccard similarity between two MinHash signatures.
pub struct MinHash32<'minhash32> {
    /// Coefficients for the linear hash functions used in MinHash.
    a_coefficients: Vec<u32>,
    /// Intercept coefficients for the linear hash functions used in MinHash.
    b_coefficients: Vec<u32>,
    /// The number of hash functions to use for MinHash.
    num_hashes: usize,
    /// The size of shingles (substrings) used to compute MinHash.
    shingle_size: usize,
    /// The byte slice to be hashed.
    bytes: &'minhash32 [u8],
}

impl<'minhash32> MinHash32<'minhash32> {
    /// Creates a new `MinHash32` instance with the provided parameters.
    ///
    /// # Arguments
    ///
    /// * `bytes` - A reference to the byte slice to be hashed.
    /// * `num_hashes` - The number of hash functions to use for MinHash.
    /// * `shingle_size` - The size of shingles (substrings) used to compute MinHash.
    /// * `seed` - A seed for the random number generator to ensure deterministic coefficients.
    ///
    /// # Returns
    ///
    /// Returns a `MinHash32` instance initialized with the provided parameters and
    /// randomly generated coefficients for the hash functions.
    pub fn new(bytes: &'minhash32 [u8], num_hashes: usize, shingle_size: usize, seed: u64) -> Self {
        let mut rng = SmallRng::seed_from_u64(seed);
        let max_hash: u32 = u32::MAX;
        let mut a_coefficients = Vec::with_capacity(num_hashes);
        let mut b_coefficients = Vec::with_capacity(num_hashes);

        for _ in 0..num_hashes {
            a_coefficients.push(rng.gen_range(1..max_hash));
            b_coefficients.push(rng.gen_range(0..max_hash));
        }

        Self {
            a_coefficients,
            b_coefficients,
            num_hashes,
            shingle_size,
            bytes,
        }
    }

    /// Computes the MinHash signature for the byte slice.
    ///
    /// The signature is computed by applying multiple hash functions to each shingle
    /// and taking the minimum hash value for each function across all shingles.
    ///
    /// # Returns
    ///
    /// Returns `Some(Vec<u32>)` containing the MinHash signature if the byte slice is large enough
    /// to generate shingles of the specified size. Returns `None` otherwise.
    pub fn hash(&self) -> Option<Vec<u32>> {
        if self.bytes.len() < self.shingle_size {
            return None;
        }
        let mut min_hashes = vec![u32::MAX; self.num_hashes];
        for shingle in self.bytes.windows(self.shingle_size) {
            let mut hasher = XxHash32::default();
            shingle.hash(&mut hasher);
            let shingle_hash = hasher.finish() as u32;
            for ((a, b), min) in self
                .a_coefficients
                .iter()
                .zip(&self.b_coefficients)
                .zip(&mut min_hashes)
            {
                let hash_value = (a.wrapping_mul(shingle_hash).wrapping_add(*b)) % PRIME_MODULUS;
                if hash_value < *min {
                    *min = hash_value;
                }
            }
        }
        Some(min_hashes)
    }

    /// Computes the Jaccard similarity between two MinHash signatures represented as hexadecimal strings.
    ///
    /// The similarity is calculated as the ratio of the number of matching hash values
    /// to the total number of hash values.
    ///
    /// # Arguments
    ///
    /// * `hexdigest1` - The first MinHash signature as a hexadecimal string.
    /// * `hexdigest2` - The second MinHash signature as a hexadecimal string.
    ///
    /// # Returns
    ///
    /// Returns a `f64` value representing the Jaccard similarity between the two signatures.
    /// If the signatures have different lengths or cannot be parsed, it returns `0.0`.
    pub fn compare(hexdigest1: &str, hexdigest2: &str) -> f64 {
        let hash1 = Self::parse_hexdigest(hexdigest1);
        let hash2 = Self::parse_hexdigest(hexdigest2);

        if hash1.is_none() || hash2.is_none() {
            return 0.0;
        }

        let hash1 = hash1.unwrap();
        let hash2 = hash2.unwrap();

        Self::jaccard_similarity(&hash1, &hash2)
    }

    /// Computes the Jaccard similarity between two MinHash signatures.
    ///
    /// The similarity is calculated as the ratio of the number of matching hash values
    /// to the total number of hash values.
    ///
    /// # Arguments
    ///
    /// * `hash1` - The first MinHash signature.
    /// * `hash2` - The second MinHash signature.
    ///
    /// # Returns
    ///
    /// Returns a `f64` value representing the Jaccard similarity between the two signatures.
    /// If the signatures have different lengths, it returns `0.0`.
    #[allow(dead_code)]
    pub fn jaccard_similarity(hash1: &[u32], hash2: &[u32]) -> f64 {
        if hash1.len() != hash2.len() {
            return 0.0;
        }
        let mut intersection = 0;
        for i in 0..hash1.len() {
            if hash1[i] == hash2[i] {
                intersection += 1;
            }
        }
        intersection as f64 / hash1.len() as f64
    }

    fn parse_hexdigest(hexdigest: &str) -> Option<Vec<u32>> {
        if hexdigest.len() % 8 != 0 {
            return None;
        }

        let mut result = Vec::new();
        for chunk in hexdigest.as_bytes().chunks(8) {
            let chunk_str = std::str::from_utf8(chunk).ok()?;
            let value = u32::from_str_radix(chunk_str, 16).ok()?;
            result.push(value);
        }

        Some(result)
    }

    /// Computes the MinHash signature and returns it as a hexadecimal string.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the hexadecimal representation of the MinHash signature
    /// if the byte slice is large enough to generate shingles. Returns `None` otherwise.
    pub fn hexdigest(&self) -> Option<String> {
        self.hash().map(|minhash| {
            minhash
                .iter()
                .map(|h| format!("{:08x}", h))
                .collect::<Vec<_>>()
                .join("")
        })
    }
}

```

`src/hashing/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod minhash;
pub mod sha256;
pub mod tlsh;

pub use minhash::MinHash32;
pub use sha256::SHA256;
pub use tlsh::TLSH;

```

`src/hashing/sha256.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use crate::binary::Binary;
use ring::digest;

/// Represents a wrapper for computing SHA-256 hashes.
///
/// This struct provides functionality for hashing a byte slice using the SHA-256
/// cryptographic hash algorithm and returning the hash as a hexadecimal string.
pub struct SHA256<'sha256> {
    pub bytes: &'sha256 [u8],
}

impl<'sha256> SHA256<'sha256> {
    /// Creates a new `SHA256` instance with the provided byte slice.
    ///
    /// # Arguments
    ///
    /// * `bytes` - A reference to the byte slice to be hashed.
    ///
    /// # Returns
    ///
    /// Returns a `SHA256` instance initialized with the provided byte slice.
    #[allow(dead_code)]
    pub fn new(bytes: &'sha256 [u8]) -> Self {
        Self { bytes }
    }

    /// Computes the SHA-256 hash of the byte slice and returns it as a hexadecimal string.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the hexadecimal representation of the SHA-256 hash.
    /// If the operation fails, it returns `None`. This implementation is currently
    /// designed to always succeed, as `ring::digest` does not fail under normal conditions.
    #[allow(dead_code)]
    pub fn hexdigest(&self) -> Option<String> {
        let digest = digest::digest(&digest::SHA256, self.bytes);
        Some(Binary::to_hex(digest.as_ref()))
    }
}

```

`src/hashing/tlsh.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use tlsh;

/// Represents a wrapper around the TLSH (Trend Micro Locality Sensitive Hash) functionality.
///
/// This struct provides functionality for creating TLSH hashes from a slice of bytes with a minimum
/// byte size requirement, which ensures only sufficiently large data is hashed.
pub struct TLSH<'tlsh> {
    /// The slice of bytes to be hashed.
    pub bytes: &'tlsh [u8],
    /// The minimum required byte size for hashing.
    pub mininum_byte_size: usize,
}

impl<'tlsh> TLSH<'tlsh> {
    /// Creates a new `TLSH` instance with the provided bytes and minimum byte size.
    ///
    /// # Arguments
    ///
    /// * `bytes` - A reference to the byte slice that will be hashed.
    /// * `mininum_byte_size` - The minimum size of `bytes` required for hashing.
    ///
    /// # Returns
    ///
    /// Returns a `TLSH` instance initialized with the provided byte slice and minimum byte size.
    #[allow(dead_code)]
    pub fn new(bytes: &'tlsh [u8], mininum_byte_size: usize) -> Self {
        Self {
            bytes,
            mininum_byte_size,
        }
    }

    /// Compares two hexdigests and get the simialrity score between 0 and 1 where 0 is not similar and 1 is the same.
    ///
    /// # Returns
    ///
    /// Returns a `Result<u32, Error>` where the `u32` is the similarity score and `Error` if compare fails.
    pub fn compare(lhs: String, rhs: String) -> Option<f64> {
        tlsh::compare(&lhs, &rhs)
            .map(|value| value as f64) // Convert the u32 to f64
            .ok()
    }

    /// Computes the TLSH hash of the byte slice if it meets the minimum size requirement.
    ///
    /// # Returns
    ///
    /// Returns `Some(String)` containing the hexadecimal digest of the TLSH hash if the byte slice
    /// length is greater than or equal to `mininum_byte_size`. Returns `None` otherwise.
    #[allow(dead_code)]
    pub fn hexdigest(&self) -> Option<String> {
        if self.bytes.len() < self.mininum_byte_size {
            return None;
        }
        tlsh::hash_buf(self.bytes).ok().map(|h| h.to_string())
    }
}

```

`src/imaging/colormap.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use clap::ValueEnum;
use std::collections::BTreeMap;
use std::fmt;
use std::io::Error;
use std::io::ErrorKind;

#[derive(Debug, Clone, ValueEnum)]
pub enum ColorMapType {
    Grayscale,
    Heatmap,
    Bluegreen,
    Redblack,
}

impl fmt::Display for ColorMapType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                ColorMapType::Grayscale => "grayscale",
                ColorMapType::Heatmap => "heatmap",
                ColorMapType::Bluegreen => "bluegreen",
                ColorMapType::Redblack => "redblack",
            }
        )
    }
}

impl ColorMapType {
    pub fn from_string(s: &str) -> Result<Self, Error> {
        match s.trim().to_lowercase().as_str() {
            "grayscale" => Ok(ColorMapType::Grayscale),
            "heatmap" => Ok(ColorMapType::Heatmap),
            "bluegreen" => Ok(ColorMapType::Bluegreen),
            "redblack" => Ok(ColorMapType::Redblack),
            _ => Err(Error::new(
                ErrorKind::InvalidInput,
                format!("'{}' is not a valid ColorMapType", s),
            )),
        }
    }

    pub fn map_byte(&self, byte: u8) -> String {
        match self {
            ColorMapType::Grayscale => format!("rgb({},{},{})", byte, byte, byte),
            ColorMapType::Heatmap => {
                let r = (byte as f32 * 1.2).min(255.0) as u8;
                let g = 255 - byte;
                let b = (byte as f32 * 0.5).min(255.0) as u8;
                format!("rgb({},{},{})", r, g, b)
            }
            ColorMapType::Bluegreen => {
                let r = (byte as f32 * 0.2).min(255.0) as u8;
                let g = (byte as f32 * 0.8).min(255.0) as u8;
                let b = 255 - byte;
                format!("rgb({},{},{})", r, g, b)
            }
            ColorMapType::Redblack => {
                let r = byte;
                let g = 0;
                let b = 0;
                format!("rgb({},{},{})", r, g, b)
            }
        }
    }
}

pub struct ColorMap {
    cell_size: usize,
    color_map_type: ColorMapType,
    metadata_entries: BTreeMap<String, String>,
    svg_rectangles: Vec<String>,
    total_cells: usize,
    fixed_width: usize,
}

impl ColorMap {
    pub fn new() -> Self {
        Self {
            cell_size: 10,
            color_map_type: ColorMapType::Grayscale,
            metadata_entries: BTreeMap::new(),
            svg_rectangles: Vec::new(),
            total_cells: 0,
            fixed_width: 512,
        }
    }

    pub fn set_cell_size(&mut self, cell_size: usize) {
        self.cell_size = cell_size;
    }

    pub fn set_color_map_type(&mut self, color_map_type: ColorMapType) {
        self.color_map_type = color_map_type;
    }

    pub fn set_fixed_width(&mut self, fixed_width: usize) {
        self.fixed_width = fixed_width;
    }

    pub fn insert_metadata(&mut self, key: String, value: String) {
        self.metadata_entries.insert(key, value);
    }

    pub fn append(&mut self, offset: u64, data: &[u8]) {
        for (i, &byte) in data.iter().enumerate() {
            let cell_index = i;
            self.total_cells = self.total_cells.max(cell_index + 1);

            let row = cell_index / self.fixed_width;
            let col = cell_index % self.fixed_width;

            let x = col * self.cell_size;
            let y = row * self.cell_size;

            let color = self.color_map_type.map_byte(byte);

            self.svg_rectangles.push(format!(
                r#"<rect x="{}" y="{}" width="{}" height="{}" fill="{}" cell-index="{}" address="{}"/>
"#,
                x, y, self.cell_size, self.cell_size, color, cell_index, offset + i as u64
            ));
        }
    }

    fn generate_metadata(&self) -> String {
        let mut metadata_section = String::new();
        for (key, value) in &self.metadata_entries {
            metadata_section.push_str(
                r#"<metadata>
"#,
            );
            metadata_section.push_str(&format!(
                r#"<{}>{}</{}>
"#,
                key, value, key
            ));
            metadata_section.push_str(
                r#"</metadata>
"#,
            );
        }
        metadata_section
    }

    pub fn to_svg_string(&self) -> String {
        let total_width = self.fixed_width * self.cell_size;
        let total_height = ((self.total_cells as f64) / (self.fixed_width as f64)).ceil() as usize
            * self.cell_size;

        let mut svg_content = String::new();
        svg_content.push_str(&format!(
            r#"<svg xmlns="http://www.w3.org/2000/svg" width="{}" height="{}" viewBox="0 0 {} {}">
"#,
            total_width, total_height, total_width, total_height
        ));

        svg_content.push_str(&self.generate_metadata());

        // Write each rectangle into the SVG
        for rectangle in &self.svg_rectangles {
            svg_content.push_str(rectangle);
        }

        svg_content.push_str("</svg>\n");

        svg_content
    }

    pub fn write(&self, file_path: &str) -> Result<(), std::io::Error> {
        std::fs::write(file_path, self.to_svg_string())
    }
}

impl Default for ColorMap {
    fn default() -> Self {
        Self::new()
    }
}

```

`src/imaging/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod colormap;

pub use colormap::ColorMap;
pub use colormap::ColorMapType;

```

`src/io/json.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::io::{self, Read, BufRead, BufReader, IsTerminal, Write};
use std::fs::File;
use serde_json::{Value, Deserializer};
use std::fmt;

#[derive(Debug)]
pub enum JSONError {
    FileOpenError(String),
    StdinReadError,
    JSONParseError(String),
    JSONToStringError(String),
    FileWriteError(String),
}

impl fmt::Display for JSONError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            JSONError::FileOpenError(path) => write!(f, "failed to open file: {}", path),
            JSONError::StdinReadError => write!(f, "failed to read from standard input"),
            JSONError::JSONParseError(err) => write!(f, "failed parsing json: {}", err),
            JSONError::JSONToStringError(err) => write!(f, "error converting json value to string: {}", err),
            JSONError::FileWriteError(path) => write!(f, "failed to write to file: {}", path),
        }
    }
}

pub struct JSON {
    values: Vec<Value>,
}

impl JSON {
    /// Constructs a `JSON` instance from a file path.
    #[allow(dead_code)]
    pub fn from_file(path: &str) -> Result<Self, JSONError> {
        let file = File::open(path).map_err(|_| JSONError::FileOpenError(path.to_string()))?;
        let reader = BufReader::new(file);
        Self::deserialize(reader)
    }

    /// Constructs a `JSON` instance from standard input.
    #[allow(dead_code)]
    pub fn from_stdin() -> Result<Self, JSONError> {
        if io::stdin().is_terminal() {
            return Err(JSONError::StdinReadError);
        }

        let reader = BufReader::new(io::stdin());
        Self::deserialize(reader)
    }

    /// Constructs a `JSON` instance from a file path or standard input.
    /// If the file path is `None`, reads from standard input.
    #[allow(dead_code)]
    pub fn from_file_or_stdin(path: Option<String>) -> Result<Self, JSONError> {
        match path {
            Some(file_path) => Self::from_file(&file_path),
            None => Self::from_stdin(),
        }
    }

    /// Private method to deserialize JSON from a given reader.
    #[allow(dead_code)]
    fn deserialize<R: BufRead>(reader: R) -> Result<Self, JSONError> {
        let values: Vec<Value> = Deserializer::from_reader(reader)
            .into_iter::<Value>()
            .map(|value| value.map_err(|e| JSONError::JSONParseError(e.to_string())))
            .collect::<Result<_, _>>()?;

        Ok(JSON { values })
    }

    /// Private method to deserialize JSON with filtering and in-place modification.
    #[allow(dead_code)]
    fn deserialize_with_filter<R, F>(reader: R, filter: F) -> Result<Self, JSONError>
    where
        R: BufRead,
        F: Fn(&mut Value) -> bool,
    {
        let mut values = Vec::new();

        for item in Deserializer::from_reader(reader).into_iter::<Value>() {
            match item {
                Ok(mut value) => {
                    if filter(&mut value) {
                        values.push(value);
                    }
                }
                Err(e) => return Err(JSONError::JSONParseError(e.to_string())),
            }
        }

        Ok(JSON { values })
    }

    /// Constructs a `JSON` instance from a file path with filtering and in-place modification.
    #[allow(dead_code)]
    pub fn from_file_with_filter<F>(path: &str, filter: F) -> Result<Self, JSONError>
    where
        F: Fn(&mut Value) -> bool,
    {
        let file = File::open(path).map_err(|_| JSONError::FileOpenError(path.to_string()))?;
        let reader = BufReader::new(file);
        Self::deserialize_with_filter(reader, filter)
    }

    /// Constructs a `JSON` instance from standard input with filtering and in-place modification.
    pub fn from_stdin_with_filter<F>(filter: F) -> Result<Self, JSONError>
    where
        F: Fn(&mut Value) -> bool,
    {
        if io::stdin().is_terminal() {
            return Err(JSONError::StdinReadError);
        }

        let reader = BufReader::new(io::stdin());
        Self::deserialize_with_filter(reader, filter)
    }

    /// Constructs a `JSON` instance from a file path or standard input with filtering and in-place modification.
    #[allow(dead_code)]
    pub fn from_file_or_stdin_with_filter<F>(path: Option<String>, filter: F) -> Result<Self, JSONError>
    where
        F: Fn(&mut Value) -> bool,
    {
        match path {
            Some(file_path) => Self::from_file_with_filter(&file_path, filter),
            None => Self::from_stdin_with_filter(filter),
        }
    }

    #[allow(dead_code)]
    pub fn from_file_or_stdin_as_array<F>(path: Option<String>, filter: F) -> Result<Self, JSONError>
    where
        F: Fn(&Value) -> bool,
    {
        // Read the JSON input from file or stdin
        let input = match path {
            Some(ref file_path) => { // Use `ref` to avoid moving `file_path`
                let mut file = File::open(file_path).map_err(|_| JSONError::FileOpenError(file_path.clone()))?;
                let mut buffer = String::new();
                file.read_to_string(&mut buffer).map_err(|_| JSONError::FileOpenError(file_path.clone()))?;
                buffer
            }
            None => {
                if io::stdin().is_terminal() {
                    return Err(JSONError::StdinReadError);
                }
                let mut buffer = String::new();
                io::stdin()
                    .read_to_string(&mut buffer)
                    .map_err(|_| JSONError::StdinReadError)?;
                buffer
            }
        };

        // Parse the input as JSON
        let parsed_json: Value = serde_json::from_str(&input).map_err(|e| JSONError::JSONParseError(e.to_string()))?;

        // Ensure the input is an array
        let array = parsed_json
            .as_array()
            .ok_or_else(|| JSONError::JSONParseError("Input JSON is not an array".to_string()))?;

        // Filter and collect the array elements
        let values = array
            .iter()
            .filter(|value| filter(value))
            .cloned()
            .collect();

        Ok(JSON { values })
    }

    /// Returns a reference to the parsed JSON values.
    #[allow(dead_code)]
    pub fn values(&self) -> &Vec<Value> {
        &self.values
    }

    /// Converts a `serde_json::Value` to a `String`.
    #[allow(dead_code)]
    pub fn value_to_string(value: &Value) -> Result<String, JSONError> {
        serde_json::to_string(value).map_err(|e| JSONError::JSONToStringError(e.to_string()))
    }

    /// Converts all `serde_json::Value`s into a `Vec<String>`.
    #[allow(dead_code)]
    pub fn values_as_strings(&self) -> Vec<String> {
        self.values
            .iter()
            .filter_map(|value| Self::value_to_string(value).ok())
            .collect()
    }

    /// Writes all JSON values as single-line strings to a file.
    #[allow(dead_code)]
    pub fn write_to_file(&self, file_path: &str) -> Result<(), JSONError> {
        let strings = self.values_as_strings();

        let mut file = File::create(file_path).map_err(|_| JSONError::FileWriteError(file_path.to_string()))?;

        for line in strings {
            writeln!(file, "{}", line).map_err(|_| JSONError::FileWriteError(file_path.to_string()))?;
        }

        Ok(())
    }
}

```

`src/io/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod stdin;
pub mod stdout;
pub mod stderr;
pub mod json;

pub use stdin::Stdin;
pub use stdout::Stdout;
pub use stderr::Stderr;
pub use json::JSON;

```

`src/io/stderr.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::io::ErrorKind;
use std::io::{self, Write};
use std::fmt::Display;
use crate::Config;

/// Represents a wrapper for standard error operations.
pub struct Stderr;

impl Stderr {
    /// Prints a line to standard error.
    ///
    /// # Arguments
    ///
    /// * `line` - The line to be printed, which implements the `Display` trait.
    ///
    /// If an error occurs, this method checks if it was due to a broken pipe.
    /// If it was, the program exits with code `0`. For other errors, it logs
    /// an error message to standard error and exits with code `1`.
    #[allow(dead_code)]
    pub fn print<T: Display>(line: T) {
        writeln!(io::stderr(), "{}", line).unwrap_or_else(|e| {
            if e.kind() == ErrorKind::BrokenPipe {
                std::process::exit(0);
            } else {
                eprintln!("error writing to stdout: {}", e);
                std::process::exit(1);
            }
        });
    }

    /// Prints a line to standard error if debug configuration is set.
    pub fn print_debug<T: Display>(config: Config, line: T) {
        if config.general.debug {
            Stderr::print(line);
        }
    }
}

```

`src/io/stdin.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::io::{stdin, ErrorKind};
use std::io::{self, BufRead, IsTerminal, Write};
use std::fmt::Display;
use std::process;
use crate::io::Stdout;

/// Represents a wrapper for standard input operations.
pub struct Stdin;

impl Stdin {

    #[allow(dead_code)]
    pub fn is_terminal() -> bool {
        stdin().is_terminal()
    }

    /// Reads lines from standard input and writes each line to standard output.
    ///
    /// This function reads lines from standard input if it's not a terminal,
    /// locking the input for safe handling in buffered mode. If a line is read
    /// successfully, it's printed using `Stdout`. If an error occurs, it prints
    /// the error message and exits with a non-zero status code.
    #[allow(dead_code)]
    pub fn passthrough() {
        let stdin = io::stdin();
        if !stdin.is_terminal() {
            let handle = stdin.lock();
            for line in handle.lines() {
                match line {
                    Ok(line) => {
                        Stdout::print(line);
                    },
                    Err(error) => {
                        eprintln!("{}", error);
                        process::exit(1);
                    },
                }
            }
        }
    }
    /// Prints a line to standard error.
    ///
    /// # Arguments
    ///
    /// * `line` - The line to be printed, which implements the `Display` trait.
    ///
    /// If an error occurs, this method checks if it was due to a broken pipe.
    /// If it was, the program exits with code `0`. For other errors, it logs
    /// an error message to standard error and exits with code `1`.
    #[allow(dead_code)]
    pub fn print<T: Display>(line: T) {
        writeln!(io::stderr(), "{}", line).unwrap_or_else(|e| {
            if e.kind() == ErrorKind::BrokenPipe {
                std::process::exit(0);
            } else {
                eprintln!("error writing to stdout: {}", e);
                std::process::exit(1);
            }
        });
    }

}

```

`src/io/stdout.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::io::ErrorKind;
use std::io::{self, Write};
use std::fmt::Display;
/// Represents a wrapper for standard output operations.
pub struct Stdout;

impl Stdout {
    /// Prints a line to standard output.
    ///
    /// # Arguments
    ///
    /// * `line` - The line to be printed, which implements the `Display` trait.
    ///
    /// If an error occurs, this method checks if it was due to a broken pipe.
    /// If it was, the program exits with code `0`. For other errors, it logs
    /// an error message to standard error and exits with code `1`.
    #[allow(dead_code)]
    pub fn print<T: Display>(line: T) {
        writeln!(io::stdout(), "{}", line).unwrap_or_else(|e| {
            if e.kind() == ErrorKind::BrokenPipe {
                std::process::exit(0);
            } else {
                eprintln!("error writing to stdout: {}", e);
                std::process::exit(1);
            }
        });
    }
}

```

`src/lcs/lcs.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::cmp::{max, min};

//
// --[ Original LCS code remains unchanged ]--
//

// ===========
// 1) Helpers
// ===========

pub fn compute_mat_ih_iv<T>(a: &[T], b: &[T]) -> (Vec<Vec<usize>>, Vec<Vec<usize>>)
where
    T: Eq,
{
    let na = a.len();
    let nb = b.len();
    let mut ih = vec![vec![0; nb + 1]; na + 1];
    let mut iv = vec![vec![0; nb + 1]; na + 1];

    for j in 0..(nb + 1) {
        ih[0][j] = j;
    }
    for l in 0..(na + 1) {
        iv[l][0] = 0;
    }

    for l in 1..(na + 1) {
        for j in 1..(nb + 1) {
            if a[l - 1] != b[j - 1] {
                ih[l][j] = max(iv[l][j - 1], ih[l - 1][j]);
                iv[l][j] = min(iv[l][j - 1], ih[l - 1][j]);
            } else {
                ih[l][j] = iv[l][j - 1];
                iv[l][j] = ih[l - 1][j];
            }
        }
    }
    (ih, iv)
}

pub fn compute_vec_ig<T>(a: &[T], b: &[T]) -> Vec<usize>
where
    T: Eq,
{
    let na = a.len();
    let nb = b.len();
    let mut ih = vec![vec![0; nb + 1], vec![0; nb + 1]];
    let mut iv = vec![vec![0; nb + 1], vec![0; nb + 1]];

    for j in 0..(nb + 1) {
        ih[0][j] = j;
    }

    for l in 1..(na + 1) {
        iv[1][0] = 0;
        for j in 1..(nb + 1) {
            if a[l - 1] != b[j - 1] {
                ih[1][j] = max(iv[1][j - 1], ih[0][j]);
                iv[1][j] = min(iv[1][j - 1], ih[0][j]);
            } else {
                ih[1][j] = iv[1][j - 1];
                iv[1][j] = ih[0][j];
            }
        }
        ih.swap(0, 1);
        iv.swap(0, 1);
    }
    ih.into_iter().next().unwrap()
}

pub fn compute_vg_dg_from_ig<T>(
    a: &[T],
    b: &[T],
    ig: &Vec<usize>,
) -> (Vec<Option<usize>>, Vec<Option<usize>>)
where
    T: Eq,
{
    let na = a.len();
    let nb = b.len();
    let mut vg = vec![None; nb + 1];
    let mut dg = vec![Some(0); na + 1];

    let mut i = 1;
    for j in 1..(nb + 1) {
        if ig[j] == 0 {
            dg[i] = Some(j);
            i += 1;
        } else {
            vg[ig[j]] = Some(j);
        }
    }
    for l in i..(na + 1) {
        dg[l] = None;
    }
    (vg, dg)
}

pub fn compute_ig_vg_dg_from_ih_mat<T>(
    a: &[T],
    b: &[T],
    ih: &Vec<Vec<usize>>,
) -> (Vec<usize>, Vec<Option<usize>>, Vec<Option<usize>>)
where
    T: Eq,
{
    let ig = ih[ih.len() - 1].clone();
    let (vg, dg) = compute_vg_dg_from_ig(a, b, &ih[ih.len() - 1]);
    (ig, vg, dg)
}

pub fn alcs<T>(a: &[T], b: &[T]) -> (Vec<usize>, Vec<Option<usize>>, Vec<Option<usize>>)
where
    T: Eq,
{
    let ig = compute_vec_ig(a, b);
    let (vg, dg) = compute_vg_dg_from_ig(a, b, &ig);
    (ig, vg, dg)
}

pub fn alcs_mat<T>(
    a: &[T],
    b: &[T],
) -> (
    Vec<Vec<usize>>,
    Vec<Vec<usize>>,
    Vec<usize>,
    Vec<Option<usize>>,
    Vec<Option<usize>>,
)
where
    T: Eq,
{
    let (ih, iv) = compute_mat_ih_iv(a, b);
    let (ig, vg, dg) = compute_ig_vg_dg_from_ih_mat(a, b, &ih);
    (ih, iv, ig, vg, dg)
}

#[derive(Debug)]
pub struct Alcs {
    ig: Vec<usize>,
}

impl Alcs {
    pub fn new<T>(a: &[T], b: &[T]) -> Self
    where
        T: Eq,
    {
        Alcs {
            ig: compute_vec_ig(a, b),
        }
    }

    /// Returns an iterator yielding the LCS length for all substrings starting from position `i`
    pub fn suffix(&self, pos: usize) -> AlcsIterator {
        AlcsIterator::new(self, pos)
    }
}

#[derive(Debug)]
pub struct AlcsIterator<'a> {
    alcs: &'a Alcs,
    i: usize,
    j: usize,
    prev: usize,
}

impl<'a> AlcsIterator<'a> {
    fn new(alcs: &'a Alcs, pos: usize) -> Self {
        AlcsIterator {
            alcs,
            i: pos,
            j: pos + 1,
            prev: 0,
        }
    }
}

impl<'a> Iterator for AlcsIterator<'a> {
    type Item = (usize, usize, usize);

    fn next(&mut self) -> Option<Self::Item> {
        if self.j >= self.alcs.ig.len() {
            return None;
        }
        let cur = self.prev + (self.alcs.ig[self.j] <= self.i) as usize;
        self.prev = cur;
        self.j += 1;
        Some((self.i, self.j - 1, cur))
    }
}

//
// ===========
// 2) The old single best "score" function (LCS-based).
//    We keep it for backward-compatibility.
// ===========
//
fn score(b: &str, a: &str, tsh: Option<f32>) -> (f32, usize, usize) {
    let va = a.chars().collect::<Vec<char>>();
    let vb = b.chars().collect::<Vec<char>>();
    let alcs = Alcs::new(&va, &vb);
    let na = a.len();
    let nb = b.len();
    let many = match tsh {
        None => nb,
        Some(tsh) => (na as f32 / tsh) as usize,
    };
    let mut best = (0., 0, 0);
    for i in 0..nb {
        let mut maxrow = (0., 0, 0);
        for (start_i, j, lcs_len) in alcs.suffix(i).take(many) {
            let cur = lcs_len as f32 / max(j - start_i, na) as f32;
            if cur > maxrow.0 {
                maxrow = (cur, start_i, j);
            }
        }
        if maxrow >= best {
            best = maxrow;
        }
    }
    best
}

//
// ======================================================
// 3) New "sub-YARAâ€“style" function: single '?' wildcard
//    and returning ALL matches above threshold
// ======================================================
//

/// Finds all sub-YARAâ€“style matches (one `?` mismatch allowed)
/// in `b` that align (in order) to the pattern `a`.
///
/// Returns a vector of (score, (start, end), subyara_alignment),
/// sorted by descending score (best match first).
///
/// Score formula âˆˆ [0,1]:
///   score = (matched_count / a.len()) * (matched_count / alignment_len)
///
/// This rewards matches that cover a large portion of `a` and
/// are "dense" within the alignment slice of `b`.
pub fn find_subyara_matches(
    b: &str,
    a: &str,
    threshold: f32
) -> Vec<(f32, (usize, usize), String)> {
    let vb: Vec<char> = b.chars().collect();
    let va: Vec<char> = a.chars().collect();
    let nb = vb.len();
    let na = va.len();

    let mut results = Vec::new();

    // Slide `a` across `b`.
    for start_b in 0..nb {
        let mut mismatch_used = false;
        let mut alignment = String::new();
        let mut matched_count = 0;
        let mut end_b = start_b;
        let mut idx_a = 0;

        // As long as we have characters left in both b and a
        while end_b < nb && idx_a < na {
            if vb[end_b] == va[idx_a] {
                // Exact match
                alignment.push(va[idx_a]);
                matched_count += 1;
            } else if !mismatch_used {
                // Use our one wildcard mismatch
                alignment.push('?');
                mismatch_used = true;
            } else {
                // Already used our mismatch; stop
                break;
            }

            // Compute the alignment length so far in `b`
            let alignment_len = end_b - start_b + 1;

            // fraction of pattern matched:
            //    matched_count / a.len()
            // fraction of alignment matched:
            //    matched_count / alignment_len
            // final score = product of both => in [0,1].
            let frac_pattern = matched_count as f32 / na as f32;
            let frac_dense   = matched_count as f32 / alignment_len as f32;
            let score = frac_pattern * frac_dense;

            if score >= threshold {
                results.push((score, (start_b, end_b + 1), alignment.clone()));
            }

            end_b += 1;
            idx_a += 1;
        }
    }

    // Sort results by descending score (best first)
    results.sort_by(|(score_a, _, _), (score_b, _, _)| {
        score_b
            .partial_cmp(score_a)
            .unwrap_or(std::cmp::Ordering::Equal)
    });

    results
}



//
// ======================================================
// 4) Example extension of the FuzzyLCS trait to gather
//    *multiple* matches using the new subyara approach.
// ======================================================
//

pub trait FuzzyLCS<T: AsRef<str>>: AsRef<str> {
    /// Old single best-match function
    fn fuzzy_find_pos(&self, s: T, tsh: f32) -> Option<(f32, usize, usize)> {
        let s = score(self.as_ref(), s.as_ref(), Some(tsh));
        if s.0 > tsh {
            Some(s)
        } else {
            None
        }
    }

    /// Old single best-match substring
    fn fuzzy_find_str<'a>(&'a self, s: T, tsh: f32) -> Option<(f32, &'a str)> {
        let r = self.fuzzy_find_pos(s, tsh);
        r.map(|(score_val, start, end)| (score_val, &self.as_ref()[start..end]))
    }

    /// Old single yes/no
    fn fuzzy_contains(&self, s: T, tsh: f32) -> bool {
        self.fuzzy_find_pos(s, tsh).is_some()
    }

    // ================================
    // NEW: get multiple sub-YARAâ€“style matches
    // ================================
    fn fuzzy_find_subyara_all(&self, pat: T, tsh: f32)
        -> Vec<(f32, (usize, usize), String)>
    {
        find_subyara_matches(self.as_ref(), pat.as_ref(), tsh)
    }
}

impl<S, T> FuzzyLCS<T> for S
where
    S: AsRef<str>,
    T: AsRef<str>,
{
}

```

`src/lcs/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod lcs;

pub use lcs::FuzzyLCS;

```

`src/lib.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod binary;
pub mod controlflow;
pub mod disassemblers;
pub mod formats;
pub mod genetics;
pub mod global;
pub mod hashing;
pub mod imaging;
pub mod io;
pub mod lcs;
pub mod types;

pub use binary::Binary;
pub use global::Architecture;
pub use global::Config;
pub use global::Format;
pub use global::AUTHOR;
pub use global::VERSION;

```

`src/types/lz4string.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use lz4::block::{compress, decompress};
use std::convert::From;

/// A structure representing a compressed string using the LZ4 compression algorithm.
pub struct LZ4String {
    /// The compressed representation of the string.
    compressed_data: Vec<u8>,
    /// The size of the original uncompressed string.
    uncompressed_size: usize,
}

impl LZ4String {
    /// Creates a new `LZ4String` from a given string slice.
    ///
    /// # Arguments
    ///
    /// * `data` - The string slice to compress.
    ///
    /// # Returns
    ///
    /// A new `LZ4String` containing the compressed data and the original size.
    ///
    /// # Panics
    ///
    /// This function will panic if the compression operation fails.
    #[allow(dead_code)]
    pub fn new(data: &str) -> Self {
        let compressed =
            compress(data.as_bytes(), None, false).expect("lz4string compression failed");
        LZ4String {
            compressed_data: compressed,
            uncompressed_size: data.len(),
        }
    }

    /// Decompresses the `LZ4String` back into its original string representation.
    ///
    /// # Returns
    ///
    /// The original uncompressed string.
    ///
    /// # Panics
    ///
    /// This function will panic if the decompression operation fails or if the decompressed data is not valid UTF-8.
    #[allow(dead_code)]
    pub fn decompress_to_string(&self) -> String {
        let decompressed = decompress(&self.compressed_data, Some(self.uncompressed_size as i32))
            .expect("lz4string decompression failed");
        String::from_utf8(decompressed).expect("lz4string invalid utf8")
    }
}

impl From<String> for LZ4String {
    /// Converts a `String` into an `LZ4String`.
    ///
    /// # Arguments
    ///
    /// * `data` - The string to compress.
    ///
    /// # Returns
    ///
    /// An `LZ4String` containing the compressed data and the original size.
    ///
    /// # Panics
    ///
    /// This function will panic if the compression operation fails.
    fn from(data: String) -> Self {
        let compressed =
            compress(data.as_bytes(), None, false).expect("lz4string compression failed");
        LZ4String {
            compressed_data: compressed,
            uncompressed_size: data.len(),
        }
    }
}

impl std::fmt::Display for LZ4String {
    /// Formats the `LZ4String` by decompressing it and writing the original string to the formatter.
    ///
    /// # Arguments
    ///
    /// * `f` - The formatter to write the decompressed string to.
    ///
    /// # Returns
    ///
    /// A result indicating whether the operation was successful.
    ///
    /// # Panics
    ///
    /// This method will panic if the decompression operation fails or if the decompressed data is not valid UTF-8.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = self.decompress_to_string();
        write!(f, "{}", s)
    }
}

```

`src/types/memorymappedfile.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use memmap2::{Mmap, MmapMut};
use std::fs::OpenOptions;
use std::io::{self, Error, Read, Seek, SeekFrom, Write};
use std::path::PathBuf;

#[cfg(windows)]
use winapi::um::ioapiset::DeviceIoControl;

#[cfg(windows)]
use winapi::um::winioctl::FSCTL_SET_SPARSE;

#[cfg(windows)]
use std::os::windows::io::AsRawHandle;

#[cfg(windows)]
use std::os::windows::fs::OpenOptionsExt;

#[cfg(windows)]
use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};

/// A `MemoryMappedFile` struct that provides a memory-mapped file interface,
/// enabling file read/write operations with optional disk caching,
/// and automatic file cleanup on object drop.
pub struct MemoryMappedFile {
    /// Path to the file as a `String`.
    pub path: String,
    /// Handle to the file as an optional open file descriptor.
    pub handle: Option<std::fs::File>,
    /// Flag indicating whether the file is already cached (exists on disk).
    pub is_cached: bool,
    /// Flag to determine if the file should be cached. If `false`, the file will
    /// be deleted upon the object being dropped.
    pub cache: bool,
    mmap: Option<Mmap>,
    mmap_mut: Option<MmapMut>,
}

impl MemoryMappedFile {
    pub fn new(path: PathBuf, cache: bool) -> Result<Self, Error> {
        if let Some(parent) = path.parent() {
            std::fs::create_dir_all(parent)?;
        }

        let is_cached = path.is_file();

        let mut options = OpenOptions::new();
        options.read(true).write(true).create(true);

        #[cfg(windows)]
        options.share_mode(FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE);

        let handle = options.open(&path)?;

        #[cfg(windows)]
        {
            let handle_raw = handle.as_raw_handle() as *mut winapi::ctypes::c_void;
            let mut bytes_returned = 0;

            let result = unsafe {
                DeviceIoControl(
                    handle_raw,
                    FSCTL_SET_SPARSE,
                    std::ptr::null_mut(),
                    0,
                    std::ptr::null_mut(),
                    0,
                    &mut bytes_returned,
                    std::ptr::null_mut(),
                )
            };

            if result == 0 {
                return Err(io::Error::last_os_error());
            }
        }

        Ok(Self {
            path: path.to_string_lossy().into_owned(),
            handle: Some(handle),
            is_cached,
            cache,
            mmap: None,
            mmap_mut: None,
        })
    }

    pub fn seek_from_current(&mut self, offset: i64) -> Result<u64, io::Error> {
        if let Some(ref mut handle) = self.handle {
            let pos = handle.seek(SeekFrom::Current(offset))?;
            Ok(pos)
        } else {
            Err(io::Error::other("file handle is closed"))
        }
    }

    pub fn seek(&mut self, offset: u64) -> Result<u64, io::Error> {
        if let Some(ref mut handle) = self.handle {
            let pos = handle.seek(SeekFrom::Start(offset))?;
            Ok(pos)
        } else {
            Err(io::Error::other("file handle is closed"))
        }
    }

    pub fn seek_to_end(&mut self) -> Result<u64, io::Error> {
        if let Some(ref mut handle) = self.handle {
            let pos = handle.seek(SeekFrom::End(0))?;
            Ok(pos)
        } else {
            Err(io::Error::other("File handle is closed"))
        }
    }

    /// Explicitly closes the file handle.
    pub fn close(&mut self) {
        if let Some(file) = self.handle.take() {
            drop(file); // Explicitly drop the file to close the handle
        }
    }

    /// Checks if the file is cached (exists on disk).
    pub fn is_cached(&self) -> bool {
        self.is_cached
    }

    /// Retrieves the file path as a `String`.
    pub fn path(&self) -> String {
        self.path.clone()
    }

    /// Writes data from a reader to the file.
    pub fn write<R: Read>(&mut self, mut reader: R) -> Result<u64, Error> {
        if let Some(ref mut handle) = self.handle {
            if handle.metadata()?.permissions().readonly() {
                return Err(Error::other("File is read-only"));
            }

            let bytes_written = io::copy(&mut reader, handle)?;
            handle.flush()?;
            Ok(bytes_written)
        } else {
            Err(Error::other("File handle is closed"))
        }
    }

    /// Adds symbolic padding (increases the file size without writing data) to the end of the file.
    pub fn write_padding(&mut self, length: usize) -> Result<(), Error> {
        if let Some(ref mut handle) = self.handle {
            let current_size = handle.metadata()?.len();
            let new_size = current_size + length as u64;

            handle.set_len(new_size)?;
            handle.seek(SeekFrom::Start(new_size))?;
            Ok(())
        } else {
            Err(Error::other("File handle is closed"))
        }
    }

    pub fn mmap_mut(&mut self) -> Result<&mut MmapMut, Error> {
        if self.mmap_mut.is_none() {
            if let Some(ref handle) = self.handle {
                self.mmap_mut = Some(unsafe { MmapMut::map_mut(handle)? });
            } else {
                return Err(Error::other("File handle is closed"));
            }
        }
        self.mmap_mut
            .as_mut()
            .ok_or_else(|| Error::other("Failed to create mutable memory map"))
    }

    pub fn mmap(&mut self) -> Result<&Mmap, Error> {
        if self.mmap.is_none() {
            if let Some(ref handle) = self.handle {
                self.mmap = Some(unsafe { Mmap::map(handle)? });
            } else {
                return Err(Error::other("File handle is closed"));
            }
        }
        self.mmap
            .as_ref()
            .ok_or_else(|| Error::other("Failed to create memory map"))
    }

    pub fn unmap(&mut self) {
        self.mmap = None;
        self.mmap_mut = None;
    }

    /// Retrieves the size of the file in bytes.
    pub fn size(&self) -> Result<u64, Error> {
        if let Some(ref handle) = self.handle {
            Ok(handle.metadata()?.len())
        } else {
            Err(Error::other("File handle is closed"))
        }
    }
}

impl Drop for MemoryMappedFile {
    fn drop(&mut self) {
        self.unmap();

        // Ensure the file handle is dropped
        self.close();

        // Remove the file if caching is disabled
        if !self.cache {
            if let Err(error) = std::fs::remove_file(&self.path) {
                eprintln!("Failed to remove file {}: {}", self.path, error);
            }
        }
    }
}

```

`src/types/mod.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

pub mod lz4string;
pub mod memorymappedfile;

pub use lz4string::LZ4String;
pub use memorymappedfile::MemoryMappedFile;

```

`tests/test_block_split.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use binlex::binary::Binary;
use binlex::controlflow::{Function, Graph};
use binlex::disassemblers::capstone::Disassembler;
use binlex::{Architecture, Config};
use std::collections::BTreeMap;

fn pattern_matches_bytes(pattern: &str, bytes: &[u8]) -> bool {
    if pattern.len() != bytes.len() * 2 {
        return false;
    }
    for (i, byte) in bytes.iter().enumerate() {
        let chunk = &pattern[i * 2..i * 2 + 2];
        let hex = format!("{:02x}", byte);
        let b0 = chunk.as_bytes()[0];
        let b1 = chunk.as_bytes()[1];
        if b0 != b'?' && b0.to_ascii_lowercase() != hex.as_bytes()[0] {
            return false;
        }
        if b1 != b'?' && b1.to_ascii_lowercase() != hex.as_bytes()[1] {
            return false;
        }
    }
    true
}

#[test]
fn test_block_split_pending() {
    // assembly: jz 0x4; nop; nop; ret
    let bytes = vec![0x74, 0x02, 0x90, 0x90, 0xc3];
    let mut ranges = BTreeMap::new();
    ranges.insert(0u64, bytes.len() as u64);
    let config = Config::new();
    let disasm = Disassembler::new(Architecture::I386, &bytes, ranges.clone(), config.clone())
        .expect("disasm");
    let mut graph = Graph::new(Architecture::I386, config.clone());
    // pre-mark address 2 as a block start
    graph.blocks.enqueue(2);
    disasm
        .disassemble_function(0, &mut graph)
        .expect("disassemble");
    let func = Function::new(0, &graph).expect("function");
    let mut blocks = func.blocks.iter();
    let first = blocks.next().unwrap().1;
    assert_eq!(
        Binary::to_hex(&first.bytes()),
        "7402",
        "first block incorrect"
    );
}

#[test]
fn test_full_function_disassembly() {
    let hex = "558bec5657668b7d0c33f6833d88cc4300020fb7d77d2a8b4d088bf1668b0183c1026685c075f583e9023bce740966393975f48bc1eb6733c06639110f44c1eb5d8b5508eb110fb702663bc70f44f26685c0744883c2028d4201a80e75e833c0663bc7751eb80100ffff660f6ec8eb0383c2100f1002660f3a63c81575f28d044aeb1b0fb7c7660f6ec0660f3a63024173038d344a740583c210ebee8bc65f5e5dc3";
    let bytes: Vec<u8> = (0..hex.len())
        .step_by(2)
        .map(|i| u8::from_str_radix(&hex[i..i + 2], 16).unwrap())
        .collect();
    let mut ranges = BTreeMap::new();
    ranges.insert(0u64, bytes.len() as u64);
    let config = Config::new();
    let disasm = Disassembler::new(Architecture::I386, &bytes, ranges.clone(), config.clone())
        .expect("disasm");
    let mut graph = Graph::new(Architecture::I386, config.clone());
    disasm
        .disassemble_function(0, &mut graph)
        .expect("disassemble");
    let func = Function::new(0, &graph).expect("function");
    assert_eq!(graph.listing.len(), 62, "incorrect instruction count");
    assert_eq!(func.blocks.len(), 14, "incorrect block count");
    let mut collected = Vec::<u8>::new();
    for addr in graph.instruction_addresses().iter().copied() {
        let instr = graph.get_instruction(addr).unwrap();
        collected.extend(instr.bytes);
    }
    assert_eq!(Binary::to_hex(&collected), hex, "listing bytes mismatch");

    // ensure that the bytes returned by Function::bytes() match the input
    let func_bytes = func.bytes().expect("function bytes");
    assert_eq!(Binary::to_hex(&func_bytes), hex, "function bytes mismatch");

    // verify chromosome pattern length and matching
    let pattern = func.pattern().expect("pattern");
    assert_eq!(pattern.len(), hex.len(), "pattern length mismatch");
    assert!(
        pattern_matches_bytes(&pattern, &func_bytes),
        "pattern does not match bytes"
    );

    // verify the function is contiguous
    assert!(func.contiguous(), "function should be contiguous");
}

```

`tests/test_models_binary.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#[cfg(test)]
mod tests {
    use binlex::binary::Binary;

    #[test]
    fn test_models_binary_to_hex(){
        let data = vec![0xDE, 0xAD, 0xBE, 0xEF];
        let result = Binary::to_hex(&data);
        assert_eq!(result, "deadbeef", "hex string does not match");
    }

    #[test]
    fn test_models_binary_hexdump() {
        let data = vec![0xDE, 0xAD, 0xBE, 0xEF];
        let result = Binary::hexdump(&data, 0);
        assert_eq!(result, "00000000: de ad be ef                                     |....|\n", "hexdump string does not match");
    }
}

```

`tests/test_models_hashing.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#[cfg(test)]
mod tests {

    use binlex::hashing::SHA256;
    use binlex::hashing::TLSH;
    use binlex::hashing::MinHash32;

    #[test]
    fn test_models_hashing_sha256() {
        let data = vec![0xDE, 0xAD, 0xBE, 0xEF];
        let hexdigest = SHA256::new(&data).hexdigest();
        assert!(hexdigest.is_some(), "hexdigest should not be none");
        assert_eq!(hexdigest.unwrap(), "5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953", "hexdigest does not match the expected value");
    }

    #[test]
    fn test_models_hashing_tlsh() {
        let data: Vec<u8> = vec![
            0x3A, 0x7F, 0x92, 0x5C, 0xE4, 0xA1, 0xD8, 0x47, 0x29, 0xB3,
            0x1E, 0x8D, 0x4F, 0x6A, 0xCD, 0x72, 0x90, 0x33, 0xB6, 0xF1,
            0xD4, 0x5E, 0xAA, 0x64, 0x13, 0xFA, 0x38, 0x9C, 0x41, 0xB8,
            0xD0, 0xE7, 0x6F, 0x25, 0xA9, 0x54, 0x1B, 0xC2, 0x8E, 0xF5,
            0x77, 0x3D, 0xAC, 0x12, 0x8A, 0x9E, 0x6B, 0xC7, 0x5A, 0xEF];
        let hexdigest = TLSH::new(&data, 50).hexdigest();
        assert!(hexdigest.is_some(), "hexdigest should not be none");
        assert_eq!(hexdigest.unwrap(), "T13390022E54110904084C76152B45D85A53A52164A647348D894A421D554C0266352468", "hexdigest does not match the expected value");
    }

    #[test]
    fn test_models_hashing_minhash() {
        let data: Vec<u8> = vec![
            0x3A, 0x7F, 0x92, 0x5C, 0xE4, 0xA1, 0xD8, 0x47, 0x29, 0xB3,
            0x1E, 0x8D, 0x4F, 0x6A, 0xCD, 0x72, 0x90, 0x33, 0xB6, 0xF1,
            0xD4, 0x5E, 0xAA, 0x64, 0x13, 0xFA, 0x38, 0x9C, 0x41, 0xB8,
            0xD0, 0xE7, 0x6F, 0x25, 0xA9, 0x54, 0x1B, 0xC2, 0x8E, 0xF5,
            0x77, 0x3D, 0xAC, 0x12, 0x8A, 0x9E, 0x6B, 0xC7, 0x5A, 0xEF];
        let hexdigest = MinHash32::new(&data, 64, 4, 0).hexdigest();
        assert!(hexdigest.is_some(), "hexdigest should not be none");
        assert_eq!(hexdigest.unwrap(), "00510c10037f0c85108b1886039fba0907d95f6f012c5a570358233b016873a000ba1ef80b1cf59f0675d519066afadd021ae2420147ed0b084c726703cb11900eb906aa040ec25d01001a10011889ab040e3b94000fec940b2506870538268300e5e9b50a7740d70858815105789e8a03f7296d00c77bc600e3a1b800717a8e02da37480096176f00b442c30463506c032f0efe08c1512c02c057d10c612b8e046f8c5a05f06c0317ac542c06254c91023009c60bccf3510c1a81ef01b1cfd6021ddf2f04e63b4a03884e2b079acef81622d85901db282d05d417c103ba54c40b19a64c0b6720f102125783033628850147997d06ae204c0835ee0a06b3b80b", "hexdigest does not match the expected value");
    }

}

```

`tests/test_pe_disassembler.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// PE Disassembler Tests

// PE File Source Code
// #include <iostream>
// #include <string>
// #include <vector>

// #ifdef _WIN32
// // Windows-specific includes
// #include <Windows.h>
// #define EXPORT __declspec(dllexport)
// #else
// // Non-Windows platform specific exports
// #define EXPORT __attribute__((visibility("default")))
// #endif

// extern "C" {
//     EXPORT void vtable_example();
//     EXPORT void jump_table_example(int option);
//     EXPORT void function_one();
//     EXPORT void function_two();
//     EXPORT void function_three();
//     EXPORT void call_sequence_example();
//     EXPORT int recursive_function(int n);

// #ifdef _WIN32
//     // Exported TLS callback function for Windows
//     EXPORT void tls_callback(PVOID DllHandle, DWORD Reason, PVOID Reserved);
// #endif
// }

// // Define the TLS callback function, which is only compiled on Windows
// #ifdef _WIN32
// void tls_callback(PVOID DllHandle, DWORD Reason, PVOID Reserved) {
//     if (Reason == DLL_THREAD_ATTACH) {
//         std::cout << "Thread attached!" << std::endl;
//     }
//     else if (Reason == DLL_THREAD_DETACH) {
//         std::cout << "Thread detached!" << std::endl;
//     }
//     else if (Reason == DLL_PROCESS_ATTACH) {
//         std::cout << "Process attached!" << std::endl;
//     }
//     else if (Reason == DLL_PROCESS_DETACH) {
//         std::cout << "Process detached!" << std::endl;
//     }
// }

// // Function to simulate DLL entry point (DllMain) - only for Windows
// BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {
//     // Register TLS callback when the process is attached or detached
//     if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
//         // Simulate TLS callback invocation when DLL is loaded
//         tls_callback(hModule, DLL_PROCESS_ATTACH, lpReserved);
//     }
//     else if (ul_reason_for_call == DLL_PROCESS_DETACH) {
//         // Simulate TLS callback invocation when DLL is unloaded
//         tls_callback(hModule, DLL_PROCESS_DETACH, lpReserved);
//     }
//     return TRUE;
// }
// #endif

// class Base {
// public:
//     virtual ~Base() {}
//     virtual void execute() = 0;
// };

// class DerivedA : public Base {
// public:
//     void execute() override {
//         std::cout << "Executing DerivedA" << std::endl;
//     }
// };

// class DerivedB : public Base {
// public:
//     void execute() override {
//         std::cout << "Executing DerivedB" << std::endl;
//     }
// };

// class DerivedC : public Base {
// public:
//     void execute() override {
//         std::cout << "Executing DerivedC" << std::endl;
//     }
// };

// void vtable_example() {
//     std::vector<Base*> objects = { new DerivedA(), new DerivedB(), new DerivedC() };
//     for (auto obj : objects) {
//         obj->execute();
//         delete obj;
//     }
// }

// // Jump table example function
// void jump_table_example(int option) {
//     switch (option) {
//     case 1: std::cout << "Option 1 selected" << std::endl; break;
//     case 2: std::cout << "Option 2 selected" << std::endl; break;
//     case 3: std::cout << "Option 3 selected" << std::endl; break;
//     case 4: std::cout << "Option 4 selected" << std::endl; break;
//     default: std::cout << "Invalid option" << std::endl; break;
//     }
// }

// // Regular function calls to demonstrate call sequences
// void function_one() {
//     std::cout << "Function One" << std::endl;
// }

// void function_two() {
//     std::cout << "Function Two" << std::endl;
// }

// void function_three() {
//     std::cout << "Function Three" << std::endl;
// }

// void call_sequence_example() {
//     function_one();
//     function_two();
//     function_three();
// }

// // A simple recursive function for disassembler testing
// int recursive_function(int n) {
//     if (n <= 0) return 0;
//     return n + recursive_function(n - 1);
// }

// int main() {
//     // Test the vtable functionality
//     std::cout << "Testing vtable example:" << std::endl;
//     vtable_example();

//     // Test the jump table example
//     std::cout << "\nTesting jump table example:" << std::endl;
//     for (int i = 1; i <= 5; ++i) {
//         jump_table_example(i);
//     }

//     // Test the call sequence
//     std::cout << "\nTesting call sequence example:" << std::endl;
//     call_sequence_example();

//     // Test recursive function
//     std::cout << "\nTesting recursive function:" << std::endl;
//     int result = recursive_function(5);
//     std::cout << "Result of recursive_function(5): " << result << std::endl;

//     return 0;
// }

// Compiled PE Binary
static DATA: &[u8] = &[
    0x04, 0x22, 0x4d, 0x18, 0x64, 0x40, 0xa7, 0x0a, 0x28, 0x00, 0x00, 0xf2, 0x03, 0x4d, 0x5a, 0x90,
    0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xb8, 0x00, 0x01,
    0x00, 0x12, 0x40, 0x07, 0x00, 0x0f, 0x02, 0x00, 0x0a, 0xf3, 0x2e, 0xf8, 0x00, 0x00, 0x00, 0x0e,
    0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd, 0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21, 0x54, 0x68, 0x69,
    0x73, 0x20, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f, 0x74,
    0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6e, 0x20, 0x69, 0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20, 0x6d,
    0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a, 0x24, 0x5a, 0x00, 0x84, 0xe0, 0x9e, 0x7a, 0xee, 0xa4,
    0xff, 0x14, 0xbd, 0x04, 0x00, 0xd1, 0xad, 0x87, 0x87, 0xbd, 0xae, 0xff, 0x14, 0xbd, 0x24, 0x84,
    0x11, 0xbc, 0xb3, 0x08, 0x00, 0x22, 0x10, 0xbc, 0x10, 0x00, 0x31, 0x17, 0xbc, 0xa7, 0x10, 0x00,
    0xb1, 0x15, 0xbc, 0xa3, 0xff, 0x14, 0xbd, 0xb0, 0x94, 0x15, 0xbc, 0xa6, 0x38, 0x00, 0xb1, 0x15,
    0xbd, 0xeb, 0xff, 0x14, 0xbd, 0x2a, 0x84, 0x1d, 0xbc, 0xa5, 0x08, 0x00, 0x13, 0x14, 0x08, 0x00,
    0x22, 0xeb, 0xbd, 0x10, 0x00, 0x11, 0x16, 0x10, 0x00, 0x40, 0x52, 0x69, 0x63, 0x68, 0x64, 0x00,
    0x03, 0x77, 0x00, 0xd4, 0x00, 0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x06, 0x00, 0x81, 0xf0, 0x36,
    0x67, 0x14, 0x00, 0xe2, 0xf0, 0x00, 0x22, 0x00, 0x0b, 0x02, 0x0e, 0x21, 0x00, 0x1a, 0x00, 0x00,
    0x00, 0x30, 0x16, 0x00, 0x61, 0xd0, 0x1c, 0x00, 0x00, 0x00, 0x10, 0x0c, 0x00, 0x20, 0x40, 0x01,
    0x07, 0x00, 0x00, 0x0c, 0x00, 0x40, 0x02, 0x00, 0x00, 0x06, 0x0c, 0x00, 0x16, 0x00, 0x08, 0x00,
    0x23, 0x00, 0x90, 0x45, 0x01, 0x72, 0x00, 0x00, 0x00, 0x03, 0x00, 0x60, 0x81, 0x29, 0x00, 0x05,
    0x3c, 0x00, 0x06, 0x09, 0x00, 0x00, 0x40, 0x00, 0x03, 0x02, 0x00, 0x00, 0x0b, 0x00, 0xd0, 0x80,
    0x42, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x84, 0x43, 0x00, 0x00, 0xc8, 0x18, 0x00, 0x40, 0x70,
    0x00, 0x00, 0xe0, 0x69, 0x00, 0x50, 0x60, 0x00, 0x00, 0xc4, 0x02, 0x11, 0x00, 0x03, 0x02, 0x00,
    0x40, 0x80, 0x00, 0x00, 0x78, 0x97, 0x00, 0x11, 0x37, 0x23, 0x00, 0x0f, 0x02, 0x00, 0x06, 0x24,
    0xf0, 0x35, 0xa9, 0x00, 0x03, 0x02, 0x00, 0x48, 0x30, 0x00, 0x00, 0x50, 0x48, 0x00, 0x0b, 0x02,
    0x00, 0xa3, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x39, 0x18, 0xa3, 0x00, 0x00, 0xfc,
    0x00, 0x00, 0x0d, 0x02, 0x07, 0x02, 0x00, 0xe0, 0x20, 0x00, 0x00, 0x60, 0x2e, 0x72, 0x64, 0x61,
    0x74, 0x61, 0x00, 0x00, 0x80, 0x1e, 0x85, 0x00, 0x02, 0x15, 0x00, 0x10, 0x00, 0x0c, 0x00, 0x07,
    0x02, 0x00, 0x52, 0x40, 0x00, 0x00, 0x40, 0x2e, 0x27, 0x00, 0x30, 0x00, 0x58, 0x07, 0x65, 0x01,
    0x02, 0x2c, 0x01, 0x27, 0x00, 0x3e, 0x25, 0x00, 0x02, 0x28, 0x00, 0x32, 0xc0, 0x2e, 0x70, 0x29,
    0x00, 0x01, 0xe4, 0x00, 0x13, 0x60, 0x3c, 0x01, 0x0b, 0x75, 0x02, 0x01, 0x50, 0x00, 0x53, 0x72,
    0x73, 0x72, 0x63, 0x00, 0x14, 0x01, 0x13, 0x70, 0x50, 0x00, 0x11, 0x44, 0x47, 0x00, 0x05, 0x02,
    0x00, 0x02, 0x28, 0x00, 0x42, 0x65, 0x6c, 0x6f, 0x63, 0x24, 0x01, 0x23, 0x00, 0x80, 0x28, 0x00,
    0x15, 0x46, 0x23, 0x00, 0x01, 0x02, 0x00, 0x41, 0x40, 0x00, 0x00, 0x42, 0x09, 0x00, 0x0f, 0x02,
    0x00, 0xf8, 0xf8, 0x25, 0x40, 0x53, 0x48, 0x83, 0xec, 0x20, 0x48, 0x8b, 0xd9, 0x48, 0x8b, 0xc2,
    0x48, 0x8d, 0x0d, 0xf5, 0x22, 0x00, 0x00, 0x0f, 0x57, 0xc0, 0x48, 0x8d, 0x53, 0x08, 0x48, 0x89,
    0x0b, 0x48, 0x8d, 0x48, 0x08, 0x0f, 0x11, 0x02, 0xff, 0x15, 0xe6, 0x20, 0x00, 0x00, 0x48, 0x8b,
    0xc3, 0x48, 0x83, 0xc4, 0x20, 0x5b, 0xc3, 0xcc, 0x01, 0x00, 0xfb, 0x03, 0x48, 0x8b, 0x51, 0x08,
    0x48, 0x8d, 0x05, 0x25, 0x23, 0x00, 0x00, 0x48, 0x85, 0xd2, 0x48, 0x0f, 0x45, 0xc2, 0x20, 0x00,
    0x51, 0x89, 0x5c, 0x24, 0x08, 0x57, 0x64, 0x00, 0x40, 0x8d, 0x05, 0x97, 0x22, 0x47, 0x00, 0xf0,
    0x07, 0xf9, 0x48, 0x89, 0x01, 0x8b, 0xda, 0x48, 0x83, 0xc1, 0x08, 0xff, 0x15, 0x95, 0x20, 0x00,
    0x00, 0xf6, 0xc3, 0x01, 0x74, 0x0d, 0xba, 0x80, 0x02, 0x60, 0x48, 0x8b, 0xcf, 0xe8, 0xa7, 0x09,
    0x08, 0x00, 0x60, 0x5c, 0x24, 0x30, 0x48, 0x8b, 0xc7, 0x70, 0x00, 0x1b, 0x5f, 0x50, 0x00, 0x30,
    0x8d, 0x05, 0x51, 0x46, 0x00, 0x20, 0x89, 0x01, 0x41, 0x00, 0x77, 0x48, 0xff, 0x25, 0x53, 0x20,
    0x00, 0x00, 0x91, 0x00, 0x40, 0x48, 0x8d, 0x05, 0xb1, 0x20, 0x00, 0x20, 0xc7, 0x41, 0x5e, 0x03,
    0x40, 0x00, 0x48, 0x89, 0x41, 0x9f, 0x00, 0x10, 0x5e, 0x13, 0x00, 0x5a, 0x89, 0x01, 0x48, 0x8b,
    0xc1, 0x4e, 0x00, 0x2c, 0xcc, 0xcc, 0x00, 0x01, 0x1f, 0x21, 0x00, 0x01, 0x03, 0x71, 0x1f, 0x00,
    0x00, 0x48, 0x8d, 0x05, 0x17, 0x47, 0x00, 0x18, 0x03, 0x0a, 0x01, 0x0b, 0x40, 0x00, 0x1f, 0xb5,
    0x40, 0x00, 0x03, 0x12, 0xa6, 0x40, 0x00, 0x2d, 0xaf, 0x21, 0x40, 0x00, 0xf1, 0x06, 0x48, 0x83,
    0xec, 0x28, 0x83, 0xfa, 0x02, 0x75, 0x09, 0x48, 0x8d, 0x15, 0x10, 0x22, 0x00, 0x00, 0xeb, 0x27,
    0x83, 0xfa, 0x03, 0x0e, 0x00, 0x10, 0x1a, 0x0e, 0x00, 0x41, 0x19, 0x83, 0xfa, 0x01, 0x0e, 0x00,
    0x10, 0x24, 0x0e, 0x00, 0x90, 0x0b, 0x85, 0xd2, 0x75, 0x28, 0x48, 0x8d, 0x15, 0x2f, 0x88, 0x00,
    0x90, 0x8b, 0x0d, 0xd8, 0x1e, 0x00, 0x00, 0xe8, 0xfb, 0x05, 0x9b, 0x00, 0xf0, 0x04, 0x15, 0xc4,
    0x07, 0x00, 0x00, 0x48, 0x8b, 0xc8, 0x48, 0x83, 0xc4, 0x28, 0x48, 0xff, 0x25, 0xae, 0x1e, 0x00,
    0x00, 0x0b, 0x00, 0x14, 0xc3, 0xe0, 0x00, 0x30, 0x8d, 0x05, 0xf3, 0xa2, 0x01, 0xf0, 0x03, 0x8b,
    0xd9, 0x48, 0x89, 0x01, 0xf6, 0xc2, 0x01, 0x74, 0x0a, 0xba, 0x08, 0x00, 0x00, 0x00, 0xe8, 0x3a,
    0x08, 0x36, 0x00, 0x08, 0xd8, 0x01, 0x00, 0x90, 0x00, 0x40, 0x48, 0x8b, 0x0d, 0x7d, 0x41, 0x00,
    0x80, 0x8d, 0x15, 0xde, 0x21, 0x00, 0x00, 0xe8, 0x99, 0x62, 0x00, 0x60, 0x8b, 0xc8, 0x48, 0x8d,
    0x15, 0x5f, 0x65, 0x00, 0x02, 0x62, 0x00, 0x22, 0x4c, 0x1e, 0x77, 0x01, 0x03, 0x30, 0x00, 0x12,
    0x4d, 0x30, 0x00, 0x10, 0xc6, 0x30, 0x00, 0x15, 0x69, 0x30, 0x00, 0x16, 0x2f, 0x30, 0x00, 0x1a,
    0x1c, 0x30, 0x00, 0x12, 0x1d, 0x30, 0x00, 0x10, 0xae, 0x30, 0x00, 0x15, 0x39, 0x30, 0x00, 0x22,
    0xff, 0x06, 0xb7, 0x00, 0x53, 0x48, 0xff, 0x25, 0xec, 0x1d, 0x60, 0x00, 0xa0, 0x89, 0x5c, 0x24,
    0x18, 0x55, 0x48, 0x83, 0xec, 0x40, 0xb9, 0xb2, 0x00, 0x70, 0x48, 0x89, 0x74, 0x24, 0x50, 0xe8,
    0x47, 0x58, 0x00, 0x63, 0x8d, 0x15, 0xe8, 0x22, 0x00, 0x00, 0x16, 0x00, 0x82, 0x10, 0x48, 0x89,
    0x44, 0x24, 0x20, 0xe8, 0x2e, 0x19, 0x00, 0x1b, 0xe7, 0x19, 0x00, 0x31, 0x28, 0xe8, 0x15, 0x19,
    0x00, 0x20, 0x0d, 0x9e, 0x39, 0x01, 0x31, 0x89, 0x08, 0xb9, 0x6d, 0x02, 0xb1, 0x89, 0x44, 0x24,
    0x30, 0xe8, 0xfc, 0x06, 0x00, 0x00, 0x41, 0xb8, 0x10, 0x00, 0x40, 0x8d, 0x54, 0x24, 0x20, 0x43,
    0x01, 0x90, 0x8b, 0xe8, 0x48, 0x8d, 0x58, 0x18, 0xe8, 0x3e, 0x14, 0x1c, 0x01, 0xe0, 0xf5, 0x48,
    0x3b, 0xeb, 0x74, 0x31, 0x48, 0x89, 0x7c, 0x24, 0x58, 0x0f, 0x1f, 0x44, 0x12, 0x00, 0xe0, 0x3e,
    0x48, 0x8b, 0xcf, 0x48, 0x8b, 0x07, 0xff, 0x50, 0x08, 0x48, 0x8b, 0x07, 0xba, 0xab, 0x05, 0xf0,
    0x18, 0x48, 0x8b, 0xcf, 0xff, 0x10, 0x48, 0x83, 0xc6, 0x08, 0x48, 0x3b, 0xf3, 0x75, 0xde, 0x48,
    0x8b, 0x7c, 0x24, 0x58, 0x48, 0x8b, 0x74, 0x24, 0x50, 0x48, 0x85, 0xed, 0x74, 0x33, 0x48, 0x2b,
    0xdd, 0x48, 0x83, 0xe3, 0xf8, 0x48, 0x81, 0xfb, 0x47, 0x06, 0xf0, 0x13, 0x72, 0x18, 0x48, 0x8b,
    0x4d, 0xf8, 0x48, 0x83, 0xc3, 0x27, 0x48, 0x2b, 0xe9, 0x48, 0x8d, 0x45, 0xf8, 0x48, 0x83, 0xf8,
    0x1f, 0x77, 0x19, 0x48, 0x8b, 0xe9, 0x48, 0x8b, 0xd3, 0x48, 0x8b, 0xcd, 0xe8, 0xa8, 0x03, 0x01,
    0xd3, 0x8b, 0x5c, 0x24, 0x60, 0x48, 0x83, 0xc4, 0x40, 0x5d, 0xc3, 0xff, 0x15, 0x23, 0x39, 0x01,
    0x03, 0x02, 0x00, 0x00, 0x70, 0x01, 0x50, 0x83, 0xe9, 0x01, 0x74, 0x3a, 0x05, 0x00, 0x10, 0x2c,
    0x05, 0x00, 0xc0, 0x1e, 0x83, 0xf9, 0x01, 0x48, 0x8b, 0x0d, 0xcb, 0x1c, 0x00, 0x00, 0x74, 0x46,
    0x02, 0xa0, 0xd2, 0x20, 0x00, 0x00, 0xeb, 0x29, 0x48, 0x8d, 0x15, 0xb1, 0x09, 0x00, 0x50, 0x20,
    0x48, 0x8d, 0x15, 0x90, 0x09, 0x00, 0x50, 0x10, 0x48, 0x8d, 0x15, 0x6f, 0x09, 0x00, 0x51, 0x07,
    0x48, 0x8d, 0x15, 0x4e, 0xd0, 0x03, 0x81, 0x0d, 0x97, 0x1c, 0x00, 0x00, 0xe8, 0xba, 0x03, 0x41,
    0x02, 0x13, 0x83, 0x86, 0x01, 0x02, 0x7f, 0x01, 0x22, 0x6d, 0x1c, 0x7f, 0x01, 0x01, 0x70, 0x00,
    0x30, 0x48, 0x8b, 0x0d, 0x10, 0x00, 0x90, 0x48, 0x8d, 0x15, 0x86, 0x20, 0x00, 0x00, 0xe8, 0x89,
    0x31, 0x00, 0x01, 0x10, 0x02, 0x10, 0x4f, 0x34, 0x00, 0x02, 0x31, 0x00, 0x13, 0x3c, 0x31, 0x00,
    0x03, 0x30, 0x00, 0x12, 0x3d, 0x30, 0x00, 0x10, 0x66, 0x30, 0x00, 0x15, 0x59, 0x30, 0x00, 0x16,
    0x1f, 0x30, 0x00, 0x1a, 0x0c, 0x30, 0x00, 0x12, 0x0d, 0x30, 0x00, 0x10, 0x46, 0x30, 0x00, 0x15,
    0x29, 0x30, 0x00, 0x25, 0xef, 0x04, 0x60, 0x00, 0x22, 0xdc, 0x1b, 0x91, 0x00, 0x03, 0x60, 0x00,
    0x21, 0xdd, 0x1b, 0x60, 0x00, 0x70, 0xf6, 0x1f, 0x00, 0x00, 0xe8, 0xf9, 0x02, 0x83, 0x01, 0xb0,
    0xc8, 0x48, 0x8d, 0x15, 0xbf, 0x04, 0x00, 0x00, 0xff, 0x15, 0xb1, 0x1c, 0x00, 0x30, 0x8b, 0x0d,
    0xba, 0x07, 0x00, 0x30, 0x8d, 0x15, 0xe3, 0x23, 0x00, 0x15, 0xd6, 0x23, 0x00, 0x11, 0x9c, 0x23,
    0x00, 0x10, 0x8e, 0x1c, 0x00, 0x30, 0x8b, 0x0d, 0x97, 0x07, 0x00, 0x30, 0x8d, 0x15, 0xd0, 0x23,
    0x00, 0x15, 0xb3, 0x23, 0x00, 0x16, 0x79, 0x76, 0x00, 0x13, 0x66, 0x76, 0x00, 0x06, 0x02, 0x00,
    0x02, 0xf0, 0x03, 0x80, 0x8b, 0xd9, 0x85, 0xc9, 0x7f, 0x08, 0x33, 0xc0, 0xa1, 0x04, 0xa8, 0x5b,
    0xc3, 0xff, 0xc9, 0xe8, 0xe5, 0xff, 0xff, 0xff, 0x03, 0x48, 0x03, 0x04, 0x02, 0x00, 0x02, 0x30,
    0x00, 0x42, 0x48, 0x8b, 0x0d, 0x2b, 0x6c, 0x00, 0x10, 0x74, 0x6c, 0x00, 0x15, 0x47, 0x6c, 0x00,
    0x11, 0x0d, 0x8f, 0x00, 0xd2, 0xff, 0x1a, 0x00, 0x00, 0xe8, 0x12, 0xfd, 0xff, 0xff, 0x48, 0x8b,
    0x0d, 0x03, 0x28, 0x00, 0x10, 0x64, 0x28, 0x00, 0x15, 0x1f, 0x28, 0x00, 0x20, 0xe5, 0x03, 0xda,
    0x00, 0x50, 0xd7, 0x1a, 0x00, 0x00, 0xbb, 0x72, 0x02, 0x51, 0x66, 0x66, 0x0f, 0x1f, 0x84, 0xc6,
    0x06, 0xb1, 0x8b, 0xcb, 0x83, 0xe9, 0x01, 0x0f, 0x84, 0x73, 0x01, 0x00, 0x00, 0x09, 0x00, 0x14,
    0x40, 0x09, 0x00, 0x10, 0x2e, 0x09, 0x00, 0x60, 0xf9, 0x01, 0x0f, 0x84, 0x1c, 0x01, 0x1f, 0x01,
    0x31, 0x0d, 0xab, 0x1a, 0x32, 0x01, 0x10, 0xb4, 0x34, 0x04, 0x11, 0xc7, 0x13, 0x00, 0x00, 0x32,
    0x01, 0x11, 0x8d, 0x58, 0x00, 0xf2, 0x00, 0x7f, 0x1a, 0x00, 0x00, 0xff, 0xc3, 0x83, 0xfb, 0x05,
    0x7e, 0xb0, 0x48, 0x8b, 0x0d, 0x81, 0x2a, 0x00, 0x10, 0x02, 0x82, 0x00, 0x15, 0x9d, 0x2a, 0x00,
    0x11, 0x63, 0x2a, 0x00, 0x10, 0x55, 0x1c, 0x00, 0x30, 0x8b, 0x0d, 0x5e, 0x07, 0x00, 0x30, 0x8d,
    0x15, 0x77, 0x4d, 0x00, 0x15, 0x7a, 0x23, 0x00, 0x11, 0x40, 0x23, 0x00, 0x10, 0x32, 0x1c, 0x00,
    0x30, 0x8b, 0x0d, 0x3b, 0x07, 0x00, 0x30, 0x8d, 0x15, 0x64, 0x23, 0x00, 0x15, 0x57, 0x23, 0x00,
    0x11, 0x1d, 0x23, 0x00, 0x10, 0x0f, 0x1c, 0x00, 0x30, 0x8b, 0x0d, 0x18, 0x07, 0x00, 0x30, 0x8d,
    0x15, 0x51, 0x23, 0x00, 0x15, 0x34, 0x23, 0x00, 0x20, 0xfa, 0x02, 0xeb, 0x00, 0x21, 0xec, 0x19,
    0xb6, 0x00, 0x10, 0xf5, 0x07, 0x00, 0x30, 0x8d, 0x15, 0x96, 0x23, 0x00, 0x15, 0x11, 0x23, 0x00,
    0x11, 0xd7, 0x23, 0x00, 0x50, 0xc9, 0x19, 0x00, 0x00, 0xb9, 0xab, 0x08, 0x31, 0xe8, 0x67, 0xfe,
    0x3b, 0x01, 0x12, 0xc8, 0x2d, 0x00, 0x90, 0x89, 0x1e, 0x00, 0x00, 0x8b, 0xd8, 0xe8, 0xe2, 0x00,
    0x42, 0x00, 0x70, 0xc8, 0x8d, 0x53, 0x05, 0xff, 0x15, 0x96, 0x1a, 0x00, 0x01, 0xb3, 0x02, 0x11,
    0x9c, 0x3b, 0x00, 0x44, 0x8e, 0x19, 0x00, 0x00, 0xbe, 0x01, 0x53, 0x48, 0x8d, 0x15, 0x87, 0x1d,
    0x21, 0x03, 0x10, 0x66, 0x09, 0x00, 0x00, 0x21, 0x03, 0x20, 0x45, 0x1d, 0x3d, 0x00, 0x30, 0x0d,
    0x76, 0x19, 0x00, 0x05, 0x02, 0x49, 0x00, 0x00, 0x00, 0x05, 0x01, 0x3d, 0x00, 0x20, 0x51, 0x19,
    0x2e, 0x01, 0x20, 0xe9, 0x82, 0x75, 0x00, 0x30, 0x8d, 0x15, 0x03, 0x33, 0x00, 0x14, 0xd4, 0xef,
    0x01, 0x04, 0x70, 0x05, 0xf2, 0x22, 0x8b, 0xd9, 0xff, 0x15, 0x71, 0x19, 0x00, 0x00, 0x84, 0xc0,
    0x75, 0x0a, 0x48, 0x8b, 0x0b, 0xff, 0x15, 0x3c, 0x19, 0x00, 0x00, 0x90, 0x48, 0x8b, 0x13, 0x48,
    0x8b, 0x02, 0x48, 0x63, 0x48, 0x04, 0x48, 0x8b, 0x4c, 0x11, 0x48, 0x48, 0x85, 0xc9, 0x74, 0x07,
    0x48, 0x8b, 0x01, 0xff, 0x50, 0x10, 0x90, 0x4a, 0x02, 0x04, 0xe0, 0x02, 0x1f, 0x11, 0x27, 0x00,
    0x08, 0x19, 0x28, 0xc3, 0x06, 0xf0, 0x02, 0x48, 0x89, 0x5c, 0x24, 0x10, 0x48, 0x89, 0x4c, 0x24,
    0x08, 0x56, 0x57, 0x41, 0x54, 0x41, 0x56, 0x41, 0x6c, 0x07, 0xf0, 0x07, 0x30, 0x4c, 0x8b, 0xe2,
    0x48, 0x8b, 0xf1, 0x33, 0xdb, 0x89, 0x5c, 0x24, 0x70, 0x49, 0xc7, 0xc6, 0xff, 0xff, 0xff, 0xff,
    0x0f, 0x1f, 0x16, 0x09, 0xd2, 0x00, 0x49, 0xff, 0xc6, 0x42, 0x38, 0x1c, 0x32, 0x75, 0xf7, 0x48,
    0x8b, 0x01, 0x89, 0x00, 0xf0, 0x08, 0x7c, 0x31, 0x28, 0x48, 0x85, 0xff, 0x7e, 0x0a, 0x49, 0x3b,
    0xfe, 0x7e, 0x05, 0x49, 0x2b, 0xfe, 0xeb, 0x02, 0x33, 0xff, 0x4c, 0x8b, 0xfe, 0x6a, 0x05, 0x57,
    0x20, 0x48, 0x8b, 0x4c, 0x31, 0xa7, 0x00, 0xf0, 0x1b, 0x08, 0x90, 0x48, 0x8b, 0x0e, 0x48, 0x63,
    0x41, 0x04, 0x83, 0x7c, 0x30, 0x10, 0x00, 0x74, 0x04, 0x32, 0xc0, 0xeb, 0x2b, 0x48, 0x8b, 0x44,
    0x30, 0x50, 0x48, 0x85, 0xc0, 0x74, 0x1f, 0x48, 0x3b, 0xc6, 0x74, 0x1a, 0x48, 0x8b, 0xc8, 0xff,
    0x15, 0x47, 0x18, 0x3e, 0x01, 0x06, 0x2a, 0x00, 0xb0, 0x0f, 0x94, 0xc0, 0xeb, 0x02, 0xb0, 0x01,
    0x88, 0x44, 0x24, 0x28, 0x11, 0x01, 0x10, 0xbb, 0xb5, 0x01, 0x20, 0xe9, 0xaf, 0x57, 0x01, 0xa1,
    0x63, 0x41, 0x04, 0x8b, 0x4c, 0x30, 0x18, 0x81, 0xe1, 0xc0, 0xaf, 0x02, 0x30, 0x40, 0x74, 0x2b,
    0x8c, 0x00, 0x40, 0x26, 0x48, 0x8b, 0x06, 0x9d, 0x00, 0x51, 0x0f, 0xb6, 0x54, 0x31, 0x58, 0x84,
    0x00, 0xf3, 0x06, 0xff, 0x15, 0x03, 0x18, 0x00, 0x00, 0x83, 0xf8, 0xff, 0x75, 0x05, 0x8d, 0x58,
    0x05, 0xeb, 0x52, 0x48, 0xff, 0xcf, 0xeb, 0xd5, 0x26, 0x00, 0x63, 0x4d, 0x8b, 0xc6, 0x49, 0x8b,
    0xd4, 0x27, 0x00, 0x93, 0xf4, 0x17, 0x00, 0x00, 0x49, 0x3b, 0xc6, 0x75, 0x2d, 0xf0, 0x00, 0x00,
    0x4f, 0x00, 0x13, 0x28, 0x29, 0x00, 0x08, 0x4f, 0x00, 0x21, 0xb4, 0x17, 0x4f, 0x00, 0x20, 0x74,
    0x05, 0x4a, 0x00, 0x40, 0xda, 0x83, 0xcb, 0x04, 0x2b, 0x01, 0x03, 0x28, 0x00, 0x50, 0x48, 0xc7,
    0x44, 0x31, 0x28, 0x5e, 0x03, 0xe0, 0xeb, 0x0e, 0x48, 0x8b, 0x74, 0x24, 0x60, 0x8b, 0x5c, 0x24,
    0x70, 0x4c, 0x8b, 0x7c, 0x1e, 0x06, 0x01, 0x97, 0x00, 0xf2, 0x04, 0x48, 0x03, 0xce, 0x45, 0x33,
    0xc0, 0x8b, 0xd3, 0xff, 0x15, 0x4e, 0x17, 0x00, 0x00, 0x90, 0xff, 0x15, 0x87, 0x17, 0xea, 0x01,
    0x60, 0x49, 0x8b, 0xcf, 0xff, 0x15, 0x52, 0x14, 0x00, 0x30, 0x49, 0x8b, 0x07, 0xc1, 0x00, 0x47,
    0x4a, 0x8b, 0x4c, 0x39, 0x40, 0x01, 0x50, 0x10, 0x90, 0x48, 0x8b, 0xc6, 0xdd, 0x08, 0xd9, 0x68,
    0x48, 0x83, 0xc4, 0x30, 0x41, 0x5f, 0x41, 0x5e, 0x41, 0x5c, 0x5f, 0x5e, 0xd0, 0x01, 0x04, 0x30,
    0x04, 0x60, 0x01, 0x48, 0x8b, 0xd9, 0xb2, 0x0a, 0x44, 0x00, 0xf0, 0x04, 0x48, 0x03, 0xcb, 0xff,
    0x15, 0x15, 0x17, 0x00, 0x00, 0x0f, 0xb6, 0xd0, 0x48, 0x8b, 0xcb, 0xff, 0x15, 0x01, 0x17, 0x5e,
    0x01, 0x50, 0xcb, 0xff, 0x15, 0xe0, 0x16, 0x09, 0x00, 0x0f, 0x76, 0x04, 0x01, 0x06, 0x20, 0x04,
    0xf0, 0x0d, 0x48, 0x3b, 0x0d, 0x21, 0x36, 0x00, 0x00, 0x75, 0x10, 0x48, 0xc1, 0xc1, 0x10, 0x66,
    0xf7, 0xc1, 0xff, 0xff, 0x75, 0x01, 0xc3, 0x48, 0xc1, 0xc9, 0x10, 0xe9, 0x1a, 0x03, 0x52, 0x05,
    0x04, 0x70, 0x00, 0xf0, 0x00, 0xd9, 0xeb, 0x0f, 0x48, 0x8b, 0xcb, 0xe8, 0xad, 0x0c, 0x00, 0x00,
    0x85, 0xc0, 0x74, 0x13, 0x0c, 0x00, 0x20, 0xa7, 0x0c, 0x3f, 0x01, 0x32, 0xc0, 0x74, 0xe7, 0x9c,
    0x02, 0xe0, 0x48, 0x83, 0xfb, 0xff, 0x74, 0x06, 0xe8, 0x4b, 0x04, 0x00, 0x00, 0xcc, 0xe8, 0x65,
    0x06, 0x00, 0x20, 0xe9, 0x7f, 0x06, 0x00, 0x05, 0x44, 0x00, 0x31, 0x8d, 0x05, 0x97, 0xf8, 0x01,
    0x06, 0x64, 0x08, 0x00, 0x57, 0x07, 0x30, 0xe8, 0xd6, 0xff, 0x9d, 0x03, 0x04, 0xa6, 0x00, 0x02,
    0x70, 0x00, 0x10, 0xb9, 0xc5, 0x04, 0xe0, 0xe8, 0x52, 0x0c, 0x00, 0x00, 0xe8, 0x4b, 0x07, 0x00,
    0x00, 0x8b, 0xc8, 0xe8, 0x7c, 0x0c, 0x00, 0x10, 0x33, 0x0c, 0x00, 0x61, 0xd8, 0xe8, 0xa0, 0x0c,
    0x00, 0x00, 0x22, 0x00, 0x50, 0x89, 0x18, 0xe8, 0xac, 0x04, 0x5b, 0x01, 0x22, 0x74, 0x73, 0x18,
    0x0a, 0xd0, 0x8d, 0x0d, 0xdc, 0x09, 0x00, 0x00, 0xe8, 0x47, 0x06, 0x00, 0x00, 0xe8, 0x0a, 0x2d,
    0x00, 0x31, 0xc8, 0xe8, 0x19, 0xb2, 0x00, 0x21, 0x75, 0x52, 0x10, 0x00, 0x31, 0xe8, 0x49, 0x07,
    0xc0, 0x00, 0x50, 0x0c, 0x48, 0x8d, 0x0d, 0xe6, 0x25, 0x00, 0xa0, 0xf5, 0x0b, 0x00, 0x00, 0xe8,
    0x04, 0x07, 0x00, 0x00, 0xe8, 0x5c, 0x08, 0x31, 0xe8, 0xd2, 0x06, 0x6d, 0x00, 0x10, 0x33, 0x6d,
    0x00, 0x21, 0xea, 0x06, 0x5a, 0x00, 0x30, 0x05, 0xe8, 0xdd, 0x24, 0x00, 0x10, 0xb8, 0x2e, 0x00,
    0x20, 0x7b, 0x08, 0x3e, 0x00, 0x22, 0x75, 0x06, 0xf1, 0x00, 0x10, 0xb9, 0xc3, 0x0c, 0x30, 0xe8,
    0x1b, 0x07, 0x27, 0x01, 0x01, 0x08, 0x07, 0x33, 0xe8, 0xcf, 0x06, 0x37, 0x04, 0x20, 0x28, 0xc3,
    0x88, 0x06, 0x71, 0xe8, 0xa7, 0x08, 0x00, 0x00, 0xe8, 0x7e, 0x54, 0x00, 0x00, 0x6e, 0x09, 0x32,
    0xe9, 0xe1, 0x0b, 0x2c, 0x00, 0x00, 0xf4, 0x0a, 0x00, 0x40, 0x03, 0x11, 0x10, 0x8d, 0x03, 0x01,
    0xcb, 0x00, 0x30, 0xe8, 0x97, 0x03, 0x6f, 0x00, 0xf3, 0x0a, 0x0f, 0x84, 0x36, 0x01, 0x00, 0x00,
    0x40, 0x32, 0xf6, 0x40, 0x88, 0x74, 0x24, 0x20, 0xe8, 0x46, 0x03, 0x00, 0x00, 0x8a, 0xd8, 0x8b,
    0x0d, 0x46, 0x3b, 0xad, 0x05, 0xe0, 0x23, 0x01, 0x00, 0x00, 0x85, 0xc9, 0x75, 0x4a, 0xc7, 0x05,
    0x2f, 0x3b, 0x00, 0x00, 0x26, 0x01, 0x40, 0x48, 0x8d, 0x15, 0x10, 0xf1, 0x01, 0x90, 0x8d, 0x0d,
    0xf1, 0x16, 0x00, 0x00, 0xe8, 0x42, 0x0b, 0xa3, 0x00, 0x90, 0x74, 0x0a, 0xb8, 0xff, 0x00, 0x00,
    0x00, 0xe9, 0xd9, 0x44, 0x03, 0x30, 0x8d, 0x15, 0xcf, 0x09, 0x02, 0x30, 0x8d, 0x0d, 0xb8, 0x21,
    0x00, 0x82, 0x1b, 0x0b, 0x00, 0x00, 0xc7, 0x05, 0xf1, 0x3a, 0x7a, 0x0d, 0x51, 0xeb, 0x08, 0x40,
    0xb6, 0x01, 0x6c, 0x00, 0x91, 0x8a, 0xcb, 0xe8, 0x84, 0x04, 0x00, 0x00, 0xe8, 0x33, 0x61, 0x08,
    0xc1, 0xd8, 0x48, 0x83, 0x38, 0x00, 0x74, 0x1e, 0x48, 0x8b, 0xc8, 0xe8, 0xd6, 0x99, 0x00, 0xf0,
    0x02, 0x74, 0x12, 0x45, 0x33, 0xc0, 0x41, 0x8d, 0x50, 0x02, 0x33, 0xc9, 0x48, 0x8b, 0x03, 0xff,
    0x15, 0x44, 0x4c, 0x00, 0x17, 0x0f, 0x2c, 0x00, 0x10, 0x14, 0x2c, 0x00, 0x12, 0xaa, 0x2c, 0x00,
    0xc0, 0x08, 0x48, 0x8b, 0x0b, 0xe8, 0xe8, 0x0a, 0x00, 0x00, 0xe8, 0xa7, 0x0a, 0x83, 0x02, 0x31,
    0xf8, 0xe8, 0xc9, 0x08, 0x00, 0xf0, 0x09, 0x18, 0xe8, 0xbb, 0x0a, 0x00, 0x00, 0x4c, 0x8b, 0xc7,
    0x48, 0x8b, 0xd3, 0x8b, 0x08, 0xe8, 0x00, 0xf9, 0xff, 0xff, 0x8b, 0xd8, 0xe8, 0x2d, 0x07, 0xfa,
    0x00, 0xf2, 0x0e, 0x74, 0x55, 0x40, 0x84, 0xf6, 0x75, 0x05, 0xe8, 0xa5, 0x0a, 0x00, 0x00, 0x33,
    0xd2, 0xb1, 0x01, 0xe8, 0x1a, 0x04, 0x00, 0x00, 0x8b, 0xc3, 0xeb, 0x19, 0x8b, 0xd8, 0xe8, 0x0b,
    0x22, 0x00, 0xb0, 0x3b, 0x80, 0x7c, 0x24, 0x20, 0x00, 0x75, 0x05, 0xe8, 0x87, 0x0a, 0x1b, 0x00,
    0x00, 0x29, 0x03, 0x10, 0x40, 0x81, 0x03, 0x10, 0x48, 0x2e, 0x03, 0x13, 0x5f, 0x90, 0x01, 0x52,
    0x8b, 0x05, 0x00, 0x00, 0x90, 0x0b, 0x00, 0xf0, 0x01, 0x80, 0x05, 0x00, 0x00, 0x8b, 0xcb, 0xe8,
    0x35, 0x0a, 0x00, 0x00, 0x90, 0x8b, 0xcb, 0xe8, 0x33, 0x08, 0x00, 0x01, 0x98, 0x01, 0x13, 0x3f,
    0xc2, 0x07, 0x55, 0xe9, 0x72, 0xfe, 0xff, 0xff, 0xa0, 0x02, 0x80, 0x8b, 0xd9, 0x33, 0xc9, 0xff,
    0x15, 0x5b, 0x13, 0xb2, 0x00, 0x50, 0xcb, 0xff, 0x15, 0x5a, 0x13, 0x68, 0x06, 0x11, 0x44, 0x0f,
    0x00, 0x52, 0xc8, 0xba, 0x09, 0x04, 0x00, 0xce, 0x07, 0x40, 0x48, 0xff, 0x25, 0x28, 0x14, 0x00,
    0x00, 0x53, 0x05, 0x60, 0x48, 0x83, 0xec, 0x38, 0xb9, 0x17, 0x1a, 0x11, 0x31, 0x15, 0x0c, 0x13,
    0x78, 0x01, 0x20, 0x07, 0xb9, 0x4c, 0x0f, 0xb0, 0xcd, 0x29, 0x48, 0x8d, 0x0d, 0xc2, 0x34, 0x00,
    0x00, 0xe8, 0xa9, 0x81, 0x01, 0x90, 0x8b, 0x44, 0x24, 0x38, 0x48, 0x89, 0x05, 0xa9, 0x35, 0xae,
    0x01, 0x00, 0x0c, 0x00, 0x70, 0x83, 0xc0, 0x08, 0x48, 0x89, 0x05, 0x39, 0x10, 0x00, 0x30, 0x8b,
    0x05, 0x92, 0x07, 0x00, 0x40, 0x89, 0x05, 0x03, 0x34, 0x78, 0x00, 0x80, 0x44, 0x24, 0x40, 0x48,
    0x89, 0x05, 0x07, 0x35, 0xa4, 0x01, 0x40, 0xdd, 0x33, 0x00, 0x00, 0x77, 0x00, 0x42, 0xc7, 0x05,
    0xd7, 0x33, 0xec, 0x01, 0x33, 0xc7, 0x05, 0xe1, 0x0a, 0x00, 0x11, 0xb8, 0xed, 0x0a, 0x20, 0x6b,
    0xc0, 0xd7, 0x01, 0x80, 0xd9, 0x33, 0x00, 0x00, 0x48, 0xc7, 0x04, 0x01, 0x7a, 0x00, 0x06, 0x18,
    0x00, 0x40, 0x8b, 0x0d, 0x49, 0x32, 0x10, 0x0b, 0x34, 0x4c, 0x04, 0x20, 0x15, 0x00, 0x00, 0x07,
    0x0a, 0x14, 0x2c, 0x15, 0x00, 0x50, 0x48, 0x8d, 0x0d, 0x10, 0x15, 0xf8, 0x02, 0x80, 0xfe, 0xff,
    0xff, 0x48, 0x83, 0xc4, 0x38, 0xc3, 0x08, 0x01, 0x10, 0x56, 0x91, 0x02, 0x11, 0x40, 0x9e, 0x06,
    0x20, 0x03, 0x12, 0x90, 0x00, 0x10, 0xb3, 0xc4, 0x11, 0xf0, 0x01, 0x33, 0xff, 0x45, 0x33, 0xc0,
    0x48, 0x8d, 0x54, 0x24, 0x60, 0x48, 0x8b, 0xce, 0xff, 0x15, 0x51, 0x1a, 0x00, 0xf0, 0x08, 0x85,
    0xc0, 0x74, 0x39, 0x48, 0x83, 0x64, 0x24, 0x38, 0x00, 0x48, 0x8d, 0x4c, 0x24, 0x68, 0x48, 0x8b,
    0x54, 0x24, 0x60, 0x4c, 0x8b, 0xc8, 0x6a, 0x06, 0x40, 0x30, 0x4c, 0x8b, 0xc6, 0x15, 0x00, 0x10,
    0x70, 0x0d, 0x00, 0x30, 0x28, 0x33, 0xc9, 0x83, 0x06, 0xe0, 0x20, 0xff, 0x15, 0x12, 0x12, 0x00,
    0x00, 0xff, 0xc7, 0x83, 0xff, 0x02, 0x7c, 0xb1, 0xbc, 0x0a, 0x30, 0x5f, 0x5e, 0x5b, 0xd9, 0x04,
    0x40, 0x48, 0x83, 0x61, 0x10, 0x3b, 0x0d, 0x10, 0xc4, 0x4e, 0x0b, 0x02, 0x8d, 0x0d, 0x11, 0xa9,
    0x0b, 0x00, 0x03, 0x8d, 0x0d, 0x40, 0x48, 0x83, 0xec, 0x48, 0x4d, 0x00, 0x30, 0x20, 0xe8, 0xd2,
    0x28, 0x04, 0x30, 0x8d, 0x15, 0xf3, 0xa3, 0x0b, 0x01, 0x11, 0x00, 0x40, 0x09, 0x08, 0x00, 0x00,
    0x78, 0x03, 0x03, 0x20, 0x00, 0x21, 0x22, 0xf2, 0x20, 0x00, 0x10, 0xa3, 0xc8, 0x0c, 0x01, 0x20,
    0x00, 0x10, 0xe9, 0x9a, 0x03, 0x20, 0xe9, 0x79, 0x26, 0x00, 0x01, 0x48, 0x00, 0x32, 0x28, 0xe8,
    0xa7, 0xfe, 0x03, 0x60, 0x21, 0x65, 0x48, 0x8b, 0x04, 0x25, 0xc1, 0x11, 0xf0, 0x0a, 0x48, 0x8b,
    0x48, 0x08, 0xeb, 0x05, 0x48, 0x3b, 0xc8, 0x74, 0x14, 0x33, 0xc0, 0xf0, 0x48, 0x0f, 0xb1, 0x0d,
    0xe4, 0x37, 0x00, 0x00, 0x75, 0xee, 0x32, 0xec, 0x01, 0x65, 0x28, 0xc3, 0xb0, 0x01, 0xeb, 0xf7,
    0xb4, 0x07, 0x50, 0x0f, 0xb6, 0x05, 0xcf, 0x37, 0x7e, 0x03, 0x10, 0xbb, 0x77, 0x03, 0xf0, 0x02,
    0x0f, 0x44, 0xc3, 0x88, 0x05, 0xbf, 0x37, 0x00, 0x00, 0xe8, 0xa6, 0x05, 0x00, 0x00, 0xe8, 0xbd,
    0x02, 0xc4, 0x02, 0x10, 0x75, 0xf2, 0x06, 0x32, 0x14, 0xe8, 0xb0, 0x0d, 0x00, 0xb4, 0x09, 0x33,
    0xc9, 0xe8, 0xa5, 0x02, 0x00, 0x00, 0xeb, 0xea, 0x8a, 0xde, 0x04, 0x00, 0x64, 0x01, 0xf2, 0x07,
    0x48, 0x83, 0xec, 0x20, 0x80, 0x3d, 0x84, 0x37, 0x00, 0x00, 0x00, 0x8b, 0xd9, 0x75, 0x67, 0x83,
    0xf9, 0x01, 0x77, 0x6a, 0xe8, 0x0d, 0x9a, 0x00, 0x90, 0x28, 0x85, 0xdb, 0x75, 0x24, 0x48, 0x8d,
    0x0d, 0x6e, 0x59, 0x00, 0x11, 0xc5, 0x14, 0x00, 0x60, 0x75, 0x10, 0x48, 0x8d, 0x0d, 0x76, 0x10,
    0x00, 0x11, 0xb5, 0x10, 0x00, 0xb0, 0x74, 0x2e, 0x32, 0xc0, 0xeb, 0x33, 0x66, 0x0f, 0x6f, 0x05,
    0xc1, 0x87, 0x02, 0x90, 0x83, 0xc8, 0xff, 0xf3, 0x0f, 0x7f, 0x05, 0x3d, 0x37, 0xec, 0x01, 0x50,
    0x05, 0x46, 0x37, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x08, 0x00, 0xf3, 0x01, 0x48, 0x89, 0x05, 0x4f,
    0x37, 0x00, 0x00, 0xc6, 0x05, 0x19, 0x37, 0x00, 0x00, 0x01, 0xb0, 0x01, 0xb5, 0x04, 0x10, 0x05,
    0xd8, 0x0d, 0x20, 0x66, 0x02, 0x89, 0x04, 0xf1, 0x0b, 0x48, 0x83, 0xec, 0x18, 0x4c, 0x8b, 0xc1,
    0xb8, 0x4d, 0x5a, 0x00, 0x00, 0x66, 0x39, 0x05, 0x11, 0xe0, 0xff, 0xff, 0x75, 0x78, 0x48, 0x63,
    0x0d, 0x44, 0xe0, 0x4a, 0x01, 0x10, 0x01, 0x07, 0x00, 0xd0, 0x03, 0xca, 0x81, 0x39, 0x50, 0x45,
    0x00, 0x00, 0x75, 0x5f, 0xb8, 0x0b, 0x02, 0x27, 0x00, 0xf2, 0x35, 0x41, 0x18, 0x75, 0x54, 0x4c,
    0x2b, 0xc2, 0x0f, 0xb7, 0x51, 0x14, 0x48, 0x83, 0xc2, 0x18, 0x48, 0x03, 0xd1, 0x0f, 0xb7, 0x41,
    0x06, 0x48, 0x8d, 0x0c, 0x80, 0x4c, 0x8d, 0x0c, 0xca, 0x48, 0x89, 0x14, 0x24, 0x49, 0x3b, 0xd1,
    0x74, 0x18, 0x8b, 0x4a, 0x0c, 0x4c, 0x3b, 0xc1, 0x72, 0x0a, 0x8b, 0x42, 0x08, 0x03, 0xc1, 0x4c,
    0x3b, 0xc0, 0x72, 0x08, 0x48, 0x83, 0xc2, 0x28, 0xeb, 0xdf, 0x33, 0xd2, 0x48, 0x85, 0xd2, 0x28,
    0x01, 0x50, 0x83, 0x7a, 0x24, 0x00, 0x7d, 0x32, 0x01, 0x91, 0x0a, 0xb0, 0x01, 0xeb, 0x06, 0x32,
    0xc0, 0xeb, 0x02, 0x77, 0x01, 0x22, 0x18, 0xc3, 0x24, 0x01, 0x50, 0x8a, 0xd9, 0xe8, 0xf7, 0x05,
    0x0c, 0x04, 0xd1, 0x85, 0xc0, 0x74, 0x0b, 0x84, 0xdb, 0x75, 0x07, 0x48, 0x87, 0x15, 0x46, 0x36,
    0xf1, 0x0b, 0x23, 0x20, 0x5b, 0x24, 0x00, 0xf0, 0x01, 0x80, 0x3d, 0x3b, 0x36, 0x00, 0x00, 0x00,
    0x8a, 0xd9, 0x74, 0x04, 0x84, 0xd2, 0x75, 0x0c, 0xe8, 0x3d, 0x05, 0x74, 0x8a, 0xcb, 0xe8, 0x2f,
    0x01, 0x00, 0x00, 0xf1, 0x00, 0x05, 0xc0, 0x01, 0xf0, 0x03, 0x48, 0x83, 0x3d, 0x16, 0x36, 0x00,
    0x00, 0xff, 0x48, 0x8b, 0xd9, 0x75, 0x07, 0xe8, 0x74, 0x06, 0x00, 0x00, 0xd3, 0x06, 0xa0, 0xd3,
    0x48, 0x8d, 0x0d, 0x00, 0x36, 0x00, 0x00, 0xe8, 0x5d, 0xbc, 0x05, 0x70, 0xd2, 0x85, 0xc0, 0x48,
    0x0f, 0x44, 0xd3, 0xec, 0x10, 0x01, 0x66, 0x00, 0x01, 0x24, 0x01, 0x30, 0x28, 0xe8, 0xbb, 0x7b,
    0x02, 0x71, 0xf7, 0xd8, 0x1b, 0xc0, 0xf7, 0xd8, 0xff, 0x02, 0x0d, 0x11, 0xc3, 0xc4, 0x05, 0x50,
    0x20, 0x55, 0x48, 0x8b, 0xec, 0xcf, 0x01, 0xf0, 0x00, 0x48, 0x8b, 0x05, 0xdc, 0x2e, 0x00, 0x00,
    0x48, 0xbb, 0x32, 0xa2, 0xdf, 0x2d, 0x99, 0x2b, 0x56, 0x07, 0xf0, 0x01, 0xc3, 0x75, 0x74, 0x48,
    0x83, 0x65, 0x18, 0x00, 0x48, 0x8d, 0x4d, 0x18, 0xff, 0x15, 0xce, 0x0e, 0x6c, 0x02, 0xf0, 0x01,
    0x45, 0x18, 0x48, 0x89, 0x45, 0x10, 0xff, 0x15, 0xc8, 0x0e, 0x00, 0x00, 0x8b, 0xc0, 0x48, 0x31,
    0x0c, 0x00, 0x12, 0xc4, 0x0c, 0x00, 0x32, 0x8d, 0x4d, 0x20, 0x10, 0x00, 0x10, 0xbc, 0x10, 0x00,
    0xd0, 0x45, 0x20, 0x48, 0x8d, 0x4d, 0x10, 0x48, 0xc1, 0xe0, 0x20, 0x48, 0x33, 0x45, 0x04, 0x00,
    0x60, 0x10, 0x48, 0x33, 0xc1, 0x48, 0xb9, 0xa7, 0x09, 0x00, 0x84, 0x15, 0x66, 0x48, 0x23, 0xc1,
    0x48, 0xb9, 0x33, 0x6b, 0x00, 0x80, 0x48, 0x0f, 0x44, 0xc1, 0x48, 0x89, 0x05, 0x59, 0x83, 0x00,
    0xb0, 0x8b, 0x5c, 0x24, 0x48, 0x48, 0xf7, 0xd0, 0x48, 0x89, 0x05, 0x42, 0x0f, 0x00, 0xa0, 0x83,
    0xc4, 0x20, 0x5d, 0xc3, 0x33, 0xc0, 0xc3, 0xcc, 0xb8, 0xb5, 0x02, 0x61, 0xc3, 0xcc, 0xcc, 0xb8,
    0x00, 0x40, 0x08, 0x00, 0x40, 0x48, 0x8d, 0x0d, 0x41, 0x79, 0x04, 0x40, 0xff, 0x25, 0x8a, 0x0e,
    0x0c, 0x02, 0x50, 0xb0, 0x01, 0xc3, 0xcc, 0xc2, 0x50, 0x03, 0x11, 0x8d, 0x98, 0x04, 0x15, 0xc3,
    0x08, 0x00, 0x00, 0x00, 0x01, 0xa2, 0xe7, 0xff, 0xff, 0xff, 0x48, 0x83, 0x08, 0x24, 0xe8, 0xe6,
    0x09, 0x00, 0x10, 0x02, 0xce, 0x06, 0xd0, 0xc3, 0xcc, 0x33, 0xc0, 0x39, 0x05, 0xf0, 0x2d, 0x00,
    0x00, 0x0f, 0x94, 0xc0, 0x30, 0x00, 0x13, 0x21, 0x38, 0x00, 0x10, 0x11, 0x08, 0x00, 0x50, 0x83,
    0x25, 0x01, 0x35, 0x00, 0x10, 0x00, 0x00, 0xec, 0x06, 0xd0, 0x55, 0x48, 0x8d, 0xac, 0x24, 0x40,
    0xfb, 0xff, 0xff, 0x48, 0x81, 0xec, 0xc0, 0x95, 0x05, 0x13, 0xd9, 0x36, 0x05, 0x21, 0xd6, 0x0d,
    0x36, 0x05, 0x60, 0x04, 0x8b, 0xcb, 0xcd, 0x29, 0xb9, 0x67, 0x16, 0xe0, 0xe8, 0xc4, 0xff, 0xff,
    0xff, 0x33, 0xd2, 0x48, 0x8d, 0x4d, 0xf0, 0x41, 0xb8, 0xd0, 0x90, 0x06, 0x10, 0x35, 0xac, 0x05,
    0x70, 0x8d, 0x4d, 0xf0, 0xff, 0x15, 0x71, 0x0d, 0x45, 0x01, 0x20, 0x9d, 0xe8, 0x53, 0x05, 0x30,
    0x8d, 0x95, 0xd8, 0x18, 0x00, 0x80, 0x8b, 0xcb, 0x45, 0x33, 0xc0, 0xff, 0x15, 0xbf, 0x1a, 0x00,
    0x44, 0x85, 0xc0, 0x74, 0x3c, 0x92, 0x04, 0x21, 0x8d, 0xe0, 0x1e, 0x00, 0x01, 0x25, 0x00, 0x06,
    0x96, 0x04, 0x50, 0xc3, 0x48, 0x8d, 0x8d, 0xe8, 0x19, 0x00, 0x40, 0x89, 0x4c, 0x24, 0x28, 0x63,
    0x00, 0x00, 0xa1, 0x04, 0x60, 0x20, 0x33, 0xc9, 0xff, 0x15, 0x76, 0x41, 0x00, 0x30, 0x8b, 0x85,
    0xc8, 0x1d, 0x00, 0x70, 0x8d, 0x4c, 0x24, 0x50, 0x48, 0x89, 0x85, 0x67, 0x00, 0x00, 0x89, 0x00,
    0x01, 0x15, 0x00, 0x30, 0x41, 0xb8, 0x98, 0x76, 0x00, 0x01, 0xb8, 0x05, 0x20, 0x85, 0x88, 0x42,
    0x03, 0x11, 0x9e, 0x85, 0x0e, 0x02, 0x32, 0x00, 0xf0, 0x01, 0x89, 0x44, 0x24, 0x60, 0xc7, 0x44,
    0x24, 0x50, 0x15, 0x00, 0x00, 0x40, 0xc7, 0x44, 0x24, 0x54, 0x6b, 0x01, 0x40, 0xff, 0x15, 0xca,
    0x0c, 0x42, 0x0a, 0x10, 0x01, 0xf2, 0x05, 0x10, 0x50, 0x7e, 0x10, 0x80, 0x40, 0x48, 0x8d, 0x45,
    0xf0, 0x0f, 0x94, 0xc3, 0x0c, 0x00, 0x10, 0x48, 0x75, 0x00, 0x10, 0xf1, 0x40, 0x09, 0x80, 0x8d,
    0x4c, 0x24, 0x40, 0xff, 0x15, 0xee, 0x0c, 0x08, 0x01, 0xb0, 0x75, 0x0c, 0x84, 0xdb, 0x75, 0x08,
    0x8d, 0x48, 0x03, 0xe8, 0xbe, 0x95, 0x05, 0x40, 0x8b, 0x9c, 0x24, 0xd0, 0x11, 0x0f, 0xb1, 0x81,
    0xc4, 0xc0, 0x05, 0x00, 0x00, 0x5d, 0xc3, 0xcc, 0xe9, 0x33, 0xaf, 0x06, 0x10, 0xcc, 0xc4, 0x06,
    0x00, 0x41, 0x00, 0x10, 0x70, 0x41, 0x00, 0x00, 0x89, 0x05, 0x12, 0xb9, 0xc2, 0x03, 0xa3, 0x08,
    0x75, 0x2f, 0x48, 0x63, 0x48, 0x3c, 0x48, 0x03, 0xc8, 0xb4, 0x03, 0x16, 0x20, 0xb4, 0x03, 0x30,
    0x15, 0x83, 0xb9, 0x11, 0x0e, 0x50, 0x0e, 0x76, 0x0c, 0x83, 0xb9, 0xd4, 0x05, 0x34, 0x00, 0x0f,
    0x95, 0x71, 0x03, 0x01, 0x31, 0x0c, 0x40, 0x48, 0x8d, 0x0d, 0x09, 0xe3, 0x00, 0x40, 0xff, 0x25,
    0x5a, 0x0c, 0x10, 0x02, 0x00, 0xb5, 0x05, 0x03, 0x98, 0x13, 0xf0, 0x1a, 0x8b, 0x19, 0x48, 0x8b,
    0xf9, 0x81, 0x3b, 0x63, 0x73, 0x6d, 0xe0, 0x75, 0x1c, 0x83, 0x7b, 0x18, 0x04, 0x75, 0x16, 0x8b,
    0x53, 0x20, 0x8d, 0x82, 0xe0, 0xfa, 0x6c, 0xe6, 0x83, 0xf8, 0x02, 0x76, 0x15, 0x81, 0xfa, 0x00,
    0x40, 0x99, 0x01, 0x74, 0x0d, 0x91, 0x07, 0x12, 0x30, 0x37, 0x0d, 0x40, 0x5f, 0xc3, 0xe8, 0x70,
    0x9d, 0x0e, 0x82, 0x89, 0x18, 0x48, 0x8b, 0x5f, 0x08, 0xe8, 0x6a, 0x0c, 0x00, 0x21, 0xe8, 0x04,
    0x54, 0x0a, 0x07, 0x5c, 0x00, 0x22, 0x8d, 0x1d, 0xf8, 0x0e, 0xa0, 0x3d, 0x24, 0x1b, 0x00, 0x00,
    0xeb, 0x12, 0x48, 0x8b, 0x03, 0x52, 0x0a, 0x40, 0x06, 0xff, 0x15, 0xe4, 0x92, 0x01, 0x81, 0x83,
    0xc3, 0x08, 0x48, 0x3b, 0xdf, 0x72, 0xe9, 0x59, 0x00, 0x00, 0xc0, 0x04, 0x12, 0x5f, 0x50, 0x02,
    0x00, 0xa6, 0x06, 0x00, 0x3c, 0x00, 0x20, 0xff, 0x1a, 0x52, 0x07, 0x3a, 0x3d, 0xf8, 0x1a, 0x3c,
    0x00, 0x1f, 0xa8, 0x3c, 0x00, 0x08, 0x10, 0x10, 0x78, 0x09, 0x10, 0x18, 0x41, 0x00, 0xf0, 0x32,
    0x10, 0x33, 0xc0, 0x33, 0xc9, 0x0f, 0xa2, 0x44, 0x8b, 0xc1, 0x45, 0x33, 0xdb, 0x44, 0x8b, 0xd2,
    0x41, 0x81, 0xf0, 0x6e, 0x74, 0x65, 0x6c, 0x41, 0x81, 0xf2, 0x69, 0x6e, 0x65, 0x49, 0x44, 0x8b,
    0xcb, 0x8b, 0xf0, 0x33, 0xc9, 0x41, 0x8d, 0x43, 0x01, 0x45, 0x0b, 0xd0, 0x0f, 0xa2, 0x41, 0x81,
    0xf1, 0x47, 0x65, 0x6e, 0x75, 0x89, 0x04, 0x24, 0x45, 0x0b, 0xd1, 0x89, 0x5c, 0x24, 0x04, 0x8b,
    0xf9, 0x02, 0x08, 0xf2, 0x09, 0x89, 0x54, 0x24, 0x0c, 0x75, 0x5b, 0x48, 0x83, 0x0d, 0xfb, 0x2a,
    0x00, 0x00, 0xff, 0x25, 0xf0, 0x3f, 0xff, 0x0f, 0x48, 0xc7, 0x05, 0xe3, 0x2a, 0x65, 0x16, 0xf0,
    0x01, 0x3d, 0xc0, 0x06, 0x01, 0x00, 0x74, 0x28, 0x3d, 0x60, 0x06, 0x02, 0x00, 0x74, 0x21, 0x3d,
    0x70, 0x07, 0x00, 0xf0, 0x00, 0x1a, 0x05, 0xb0, 0xf9, 0xfc, 0xff, 0x83, 0xf8, 0x20, 0x77, 0x24,
    0x48, 0xb9, 0x01, 0x00, 0x02, 0x00, 0xf0, 0x15, 0x00, 0x00, 0x48, 0x0f, 0xa3, 0xc1, 0x73, 0x14,
    0x44, 0x8b, 0x05, 0xd1, 0x31, 0x00, 0x00, 0x41, 0x83, 0xc8, 0x01, 0x44, 0x89, 0x05, 0xc6, 0x31,
    0x00, 0x00, 0xeb, 0x07, 0x44, 0x8b, 0x05, 0xbd, 0x31, 0x00, 0x00, 0xb8, 0x6c, 0x0a, 0x80, 0x44,
    0x8d, 0x48, 0xfb, 0x3b, 0xf0, 0x7c, 0x26, 0xb7, 0x00, 0x50, 0x89, 0x04, 0x24, 0x44, 0x8b, 0xc0,
    0x0d, 0x14, 0x04, 0x87, 0x00, 0xe0, 0x0f, 0xba, 0xe3, 0x09, 0x73, 0x0a, 0x45, 0x0b, 0xc1, 0x44,
    0x89, 0x05, 0x8a, 0x31, 0x2d, 0x08, 0x22, 0x54, 0x2a, 0x37, 0x08, 0xe2, 0x44, 0x89, 0x0d, 0x51,
    0x2a, 0x00, 0x00, 0x0f, 0xba, 0xe7, 0x14, 0x0f, 0x83, 0x91, 0x11, 0x00, 0x50, 0x3c, 0x2a, 0x00,
    0x00, 0xbb, 0xa5, 0x18, 0x32, 0x89, 0x1d, 0x35, 0x1c, 0x00, 0xf1, 0x08, 0x1b, 0x73, 0x79, 0x0f,
    0xba, 0xe7, 0x1c, 0x73, 0x73, 0x33, 0xc9, 0x0f, 0x01, 0xd0, 0x48, 0xc1, 0xe2, 0x20, 0x48, 0x0b,
    0xd0, 0x48, 0x89, 0xf5, 0x12, 0xf0, 0x07, 0x44, 0x24, 0x20, 0x22, 0xc3, 0x3a, 0xc3, 0x75, 0x57,
    0x8b, 0x05, 0x07, 0x2a, 0x00, 0x00, 0x83, 0xc8, 0x08, 0xc7, 0x05, 0xf6, 0x29, 0xca, 0x18, 0xf0,
    0x08, 0x00, 0x00, 0x89, 0x05, 0xf4, 0x29, 0x00, 0x00, 0x41, 0xf6, 0xc3, 0x20, 0x74, 0x38, 0x83,
    0xc8, 0x20, 0xc7, 0x05, 0xdd, 0x29, 0x00, 0x00, 0x66, 0x06, 0x41, 0x89, 0x05, 0xdb, 0x29, 0x31,
    0x1a, 0xa1, 0x03, 0xd0, 0x44, 0x23, 0xd8, 0x44, 0x3b, 0xd8, 0x75, 0x18, 0x4a, 0x00, 0xf0, 0x02,
    0x24, 0xe0, 0x3c, 0xe0, 0x75, 0x0d, 0x83, 0x0d, 0xbc, 0x29, 0x00, 0x00, 0x40, 0x89, 0x1d, 0xb2,
    0x29, 0xd7, 0x03, 0x50, 0x5c, 0x24, 0x28, 0x33, 0xc0, 0xcd, 0x09, 0x70, 0x30, 0x48, 0x83, 0xc4,
    0x10, 0x5f, 0xc3, 0x5c, 0x04, 0x21, 0xb0, 0x29, 0xa7, 0x02, 0x27, 0xc3, 0xcc, 0x01, 0x00, 0x40,
    0xff, 0x25, 0xaa, 0x0a, 0x6a, 0x01, 0x11, 0x64, 0x06, 0x00, 0x11, 0x8e, 0x06, 0x00, 0x11, 0x50,
    0x06, 0x00, 0x11, 0x42, 0x06, 0x00, 0x11, 0x34, 0x06, 0x00, 0x11, 0x26, 0x06, 0x00, 0x11, 0x68,
    0x06, 0x00, 0x11, 0xa2, 0x06, 0x00, 0x11, 0x94, 0x06, 0x00, 0x20, 0x3e, 0x0b, 0x3c, 0x00, 0x11,
    0x30, 0x06, 0x00, 0x02, 0x48, 0x00, 0x11, 0x14, 0x0c, 0x00, 0x11, 0x06, 0x06, 0x00, 0x11, 0xf8,
    0x24, 0x00, 0x11, 0xea, 0x06, 0x00, 0x11, 0x2c, 0x12, 0x00, 0x11, 0xd6, 0x0c, 0x00, 0x11, 0xc8,
    0x06, 0x00, 0x11, 0x32, 0x12, 0x00, 0x11, 0xac, 0x0c, 0x00, 0x11, 0x9e, 0x06, 0x00, 0x11, 0x00,
    0x12, 0x00, 0x11, 0xf2, 0x0c, 0x00, 0x11, 0xd4, 0x06, 0x00, 0x11, 0x46, 0x06, 0x00, 0x11, 0x18,
    0x06, 0x00, 0x11, 0xfa, 0x06, 0x00, 0x11, 0x14, 0x06, 0x00, 0x11, 0x66, 0x06, 0x00, 0x11, 0x58,
    0x06, 0x00, 0x11, 0x4a, 0x06, 0x00, 0x11, 0x3c, 0x06, 0x00, 0x20, 0xbe, 0x09, 0x90, 0x00, 0x20,
    0xa0, 0x09, 0x72, 0x03, 0x08, 0x02, 0x00, 0x06, 0xa0, 0x0d, 0x28, 0xff, 0xe0, 0x18, 0x00, 0x04,
    0x02, 0x00, 0x07, 0x20, 0x00, 0x38, 0x25, 0xba, 0x0a, 0x3e, 0x00, 0x40, 0x48, 0x8d, 0x8a, 0x20,
    0xfa, 0x0b, 0x20, 0xd4, 0xef, 0xc4, 0x07, 0x02, 0x0c, 0x00, 0x10, 0x88, 0x0c, 0x00, 0x40, 0x89,
    0x54, 0x24, 0x10, 0x28, 0x15, 0x84, 0x20, 0x48, 0x8b, 0xea, 0x48, 0x8b, 0x55, 0x60, 0x42, 0x10,
    0x60, 0x03, 0xca, 0x41, 0xb0, 0x01, 0xba, 0x72, 0x0f, 0x90, 0xff, 0x15, 0x9f, 0x08, 0x00, 0x00,
    0x90, 0x48, 0xb8, 0xdb, 0x0e, 0x00, 0x02, 0x00, 0x00, 0x72, 0x03, 0x46, 0x5d, 0xc3, 0xcc, 0x40,
    0x37, 0x00, 0xb1, 0x01, 0x48, 0x8b, 0xd1, 0x8b, 0x08, 0xe8, 0xb3, 0xfe, 0xff, 0xff, 0x92, 0x10,
    0x02, 0x1e, 0x00, 0x00, 0x51, 0x00, 0xf0, 0x02, 0x01, 0x33, 0xc9, 0x81, 0x38, 0x05, 0x00, 0x00,
    0xc0, 0x0f, 0x94, 0xc1, 0x8b, 0xc1, 0x5d, 0xc3, 0xcc, 0x41, 0x00, 0x0f, 0x02, 0x00, 0xff, 0xb2,
    0x12, 0x4d, 0xc5, 0x01, 0x22, 0x36, 0x4e, 0x08, 0x00, 0x13, 0x4a, 0x08, 0x00, 0x13, 0x06, 0x08,
    0x00, 0x13, 0xf0, 0x20, 0x00, 0x13, 0xda, 0x08, 0x00, 0x13, 0xc0, 0x08, 0x00, 0x13, 0xa4, 0x08,
    0x00, 0x13, 0x90, 0x08, 0x00, 0x13, 0x7c, 0x08, 0x00, 0x13, 0x5e, 0x08, 0x00, 0x13, 0x42, 0x08,
    0x00, 0x13, 0x2e, 0x08, 0x00, 0x13, 0x14, 0x08, 0x00, 0x13, 0x20, 0x58, 0x00, 0x04, 0x02, 0x00,
    0x22, 0x1e, 0x49, 0x0a, 0x00, 0x22, 0xca, 0x48, 0x08, 0x00, 0x13, 0x8a, 0x08, 0x00, 0x22, 0xa0,
    0x46, 0x10, 0x00, 0x13, 0x46, 0x10, 0x00, 0x13, 0x08, 0x08, 0x00, 0x22, 0xc6, 0x47, 0x18, 0x00,
    0x13, 0x82, 0x08, 0x00, 0x13, 0x46, 0x08, 0x00, 0x13, 0xfe, 0x30, 0x00, 0x13, 0xdc, 0x08, 0x00,
    0x04, 0x02, 0x00, 0x22, 0x18, 0x4a, 0x0a, 0x00, 0x13, 0x02, 0x08, 0x00, 0x13, 0xec, 0x70, 0x00,
    0x13, 0xd4, 0x08, 0x00, 0x13, 0xb6, 0x08, 0x00, 0x13, 0x76, 0x98, 0x00, 0x13, 0x9e, 0x10, 0x00,
    0x13, 0x84, 0x08, 0x00, 0x13, 0x6c, 0x18, 0x00, 0x13, 0x36, 0x40, 0x00, 0x13, 0xc2, 0x18, 0x00,
    0x04, 0x02, 0x00, 0x1b, 0x6e, 0x10, 0x00, 0x22, 0xe2, 0x4b, 0x1a, 0x00, 0x22, 0x02, 0x4c, 0x08,
    0x00, 0x13, 0x98, 0x38, 0x00, 0x13, 0x8c, 0x08, 0x00, 0x04, 0x02, 0x00, 0x13, 0xcc, 0x28, 0x00,
    0x04, 0x02, 0x00, 0x1b, 0xc4, 0x20, 0x00, 0x13, 0x50, 0x40, 0x00, 0x13, 0x42, 0x08, 0x00, 0x13,
    0x26, 0x08, 0x00, 0x13, 0x0a, 0x08, 0x00, 0x13, 0x7c, 0x40, 0x00, 0x13, 0x6e, 0x08, 0x00, 0x13,
    0x66, 0x40, 0x00, 0x13, 0x58, 0x10, 0x00, 0x13, 0x50, 0x08, 0x00, 0x13, 0x36, 0x08, 0x00, 0x13,
    0x14, 0x08, 0x00, 0x13, 0xf2, 0x28, 0x00, 0x13, 0xd8, 0x08, 0x00, 0x13, 0x9e, 0x18, 0x00, 0x13,
    0xb4, 0x10, 0x00, 0x13, 0xa2, 0x08, 0x00, 0x13, 0x94, 0x18, 0x00, 0x13, 0x8a, 0x08, 0x00, 0x13,
    0x42, 0x08, 0x00, 0x04, 0x02, 0x00, 0x13, 0xf2, 0x10, 0x00, 0x13, 0x60, 0x08, 0x00, 0x04, 0x02,
    0x00, 0x30, 0xec, 0x21, 0x00, 0x83, 0x16, 0x05, 0x08, 0x00, 0x22, 0x80, 0x27, 0x10, 0x00, 0x1b,
    0xa0, 0x08, 0x00, 0x04, 0x02, 0x00, 0x13, 0x62, 0x18, 0x00, 0x04, 0x02, 0x00, 0x22, 0x38, 0x1b,
    0x30, 0x00, 0x0c, 0x02, 0x00, 0x22, 0x70, 0x1a, 0x18, 0x00, 0x1f, 0x28, 0x20, 0x00, 0x04, 0x0f,
    0x02, 0x00, 0x06, 0x12, 0x38, 0x38, 0x00, 0x13, 0x44, 0x40, 0x00, 0x22, 0x60, 0x51, 0x10, 0x00,
    0x22, 0x00, 0x52, 0x08, 0x00, 0x13, 0x78, 0x20, 0x00, 0x22, 0x60, 0x10, 0x10, 0x00, 0x13, 0x40,
    0x08, 0x00, 0x22, 0x20, 0x3a, 0x10, 0x00, 0x0c, 0x18, 0x00, 0xff, 0x02, 0x62, 0x61, 0x64, 0x20,
    0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x90, 0x28, 0x00, 0x04,
    0x04, 0x02, 0x00, 0x00, 0xd2, 0x0b, 0x08, 0x02, 0x00, 0xd2, 0x55, 0x6e, 0x6b, 0x6e, 0x6f, 0x77,
    0x6e, 0x20, 0x65, 0x78, 0x63, 0x65, 0x70, 0x43, 0x00, 0x01, 0x02, 0x00, 0x01, 0x58, 0x00, 0xf0,
    0x00, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68,
    0x19, 0x00, 0x40, 0x54, 0x68, 0x72, 0x65, 0x73, 0x00, 0x80, 0x74, 0x74, 0x61, 0x63, 0x68, 0x65,
    0x64, 0x21, 0x14, 0x00, 0x00, 0x02, 0x00, 0x03, 0x18, 0x00, 0x2b, 0x64, 0x65, 0x18, 0x00, 0x7d,
    0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x31, 0x00, 0x04, 0x18, 0x00, 0x0c, 0x31, 0x00, 0xf0,
    0x03, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x44, 0x65, 0x72, 0x69, 0x76,
    0x65, 0x64, 0x41, 0x5e, 0x00, 0x0f, 0x18, 0x00, 0x00, 0x03, 0x3a, 0x1f, 0x0d, 0x30, 0x00, 0x10,
    0x43, 0x2e, 0x00, 0x31, 0x00, 0x00, 0x4f, 0xcd, 0x00, 0xb0, 0x20, 0x31, 0x20, 0x73, 0x65, 0x6c,
    0x65, 0x63, 0x74, 0x65, 0x64, 0x15, 0x00, 0x06, 0x18, 0x00, 0x1f, 0x32, 0x18, 0x00, 0x04, 0x1f,
    0x33, 0x18, 0x00, 0x04, 0x1c, 0x34, 0x18, 0x00, 0x91, 0x49, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64,
    0x20, 0x6f, 0x68, 0x00, 0x60, 0x00, 0x00, 0x46, 0x75, 0x6e, 0x63, 0x3f, 0x01, 0x40, 0x20, 0x4f,
    0x6e, 0x65, 0x69, 0x00, 0x05, 0x10, 0x00, 0x3a, 0x54, 0x77, 0x6f, 0x10, 0x00, 0x91, 0x68, 0x72,
    0x65, 0x65, 0x00, 0x00, 0x54, 0x65, 0x73, 0xe6, 0x00, 0xf4, 0x02, 0x76, 0x74, 0x61, 0x62, 0x6c,
    0x65, 0x20, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x3a, 0x00, 0x0a, 0x19, 0x00, 0x5b, 0x6a,
    0x75, 0x6d, 0x70, 0x20, 0x1d, 0x00, 0x26, 0x00, 0x00, 0x20, 0x00, 0xcf, 0x63, 0x61, 0x6c, 0x6c,
    0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x40, 0x00, 0x01, 0xb3, 0x72, 0x65, 0x63, 0x75,
    0x72, 0x73, 0x69, 0x76, 0x65, 0x20, 0x66, 0x9b, 0x00, 0x01, 0x40, 0x00, 0x96, 0x52, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x20, 0x6f, 0x66, 0x21, 0x00, 0x14, 0x5f, 0x21, 0x00, 0x40, 0x28, 0x35, 0x29,
    0x3a, 0xcd, 0x07, 0x00, 0x02, 0x00, 0x13, 0xf8, 0x48, 0x02, 0x22, 0xe0, 0x11, 0x78, 0x02, 0x22,
    0x70, 0x12, 0x08, 0x00, 0x22, 0xa0, 0x39, 0x08, 0x00, 0x04, 0x18, 0x00, 0x13, 0x10, 0x18, 0x00,
    0x13, 0xd8, 0xb8, 0x02, 0x04, 0x18, 0x00, 0x13, 0x40, 0x18, 0x00, 0x04, 0x02, 0x00, 0x2a, 0x38,
    0x3b, 0x38, 0x00, 0x22, 0x96, 0x26, 0x10, 0x00, 0x01, 0x9d, 0x03, 0x0f, 0x02, 0x00, 0x40, 0x22,
    0x08, 0x50, 0x60, 0x00, 0x0c, 0x02, 0x00, 0x22, 0x50, 0x32, 0x18, 0x00, 0x13, 0x60, 0x08, 0x00,
    0x0d, 0x02, 0x00, 0x00, 0x1f, 0x0b, 0x0f, 0x02, 0x00, 0x58, 0x13, 0xec, 0x18, 0x01, 0x0c, 0x02,
    0x00, 0x13, 0x58, 0xa0, 0x00, 0x13, 0x68, 0x08, 0x00, 0x13, 0x70, 0x08, 0x00, 0x13, 0x78, 0x08,
    0x00, 0x13, 0x80, 0x08, 0x00, 0x00, 0x02, 0x00, 0x04, 0x34, 0x24, 0x00, 0x91, 0x13, 0x00, 0x1f,
    0x06, 0x50, 0x40, 0x3c, 0x00, 0x00, 0x40, 0x13, 0x0c, 0x07, 0x1c, 0x00, 0x50, 0x0c, 0x00, 0x00,
    0x00, 0x14, 0x17, 0x24, 0x4b, 0x3c, 0x00, 0x00, 0x90, 0x1c, 0x00, 0x10, 0x0d, 0xd0, 0x22, 0x8b,
    0x02, 0x00, 0x00, 0xa4, 0x3c, 0x00, 0x00, 0xa4, 0x1c, 0x00, 0x11, 0x0e, 0x46, 0x00, 0x0f, 0x02,
    0x00, 0x57, 0x08, 0x7f, 0x01, 0x61, 0xb8, 0x50, 0x00, 0x00, 0x28, 0x38, 0x34, 0x05, 0x0f, 0x81,
    0x00, 0x06, 0x00, 0x30, 0x00, 0x17, 0x40, 0x20, 0x00, 0x17, 0x50, 0x0c, 0x00, 0x00, 0x02, 0x00,
    0x00, 0x44, 0x00, 0x04, 0x02, 0x00, 0x00, 0xf8, 0x04, 0x00, 0x0c, 0x00, 0x00, 0xd7, 0x23, 0x01,
    0x58, 0x00, 0x07, 0x02, 0x00, 0x00, 0x48, 0x00, 0x04, 0x02, 0x00, 0x61, 0x60, 0x50, 0x00, 0x00,
    0xe0, 0x39, 0x8c, 0x05, 0x04, 0x13, 0x00, 0x05, 0x02, 0x00, 0x60, 0x60, 0x3b, 0x00, 0x00, 0x28,
    0x39, 0xa1, 0x24, 0x05, 0x13, 0x00, 0x09, 0x02, 0x00, 0x0f, 0x1c, 0x00, 0x05, 0x08, 0x60, 0x00,
    0x61, 0xf8, 0x50, 0x00, 0x00, 0xb8, 0x3a, 0x34, 0x03, 0x09, 0x3c, 0x00, 0x00, 0x02, 0x00, 0x00,
    0x7c, 0x00, 0x04, 0x02, 0x00, 0x08, 0xb0, 0x00, 0x00, 0x90, 0x00, 0x08, 0x02, 0x00, 0x26, 0x38,
    0x50, 0x54, 0x00, 0x08, 0x28, 0x00, 0x11, 0x78, 0xe6, 0x03, 0x06, 0x02, 0x00, 0x1f, 0xd8, 0x28,
    0x00, 0x04, 0x26, 0x20, 0x3b, 0x24, 0x00, 0x08, 0x02, 0x00, 0x00, 0xa8, 0x00, 0x18, 0xc8, 0x1c,
    0x00, 0x00, 0xec, 0x00, 0x07, 0x02, 0x00, 0x00, 0x20, 0x00, 0x04, 0x02, 0x00, 0x61, 0x38, 0x51,
    0x00, 0x00, 0x60, 0x3a, 0x14, 0x04, 0x04, 0x13, 0x00, 0x05, 0x02, 0x00, 0x5f, 0x50, 0x39, 0x00,
    0x00, 0xf8, 0x18, 0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x48, 0x00, 0x17, 0x90, 0x20, 0x00, 0x24,
    0x18, 0x51, 0x1a, 0x00, 0x0b, 0xd0, 0x00, 0x07, 0x24, 0x00, 0x00, 0x02, 0x00, 0x00, 0x38, 0x00,
    0x04, 0x02, 0x00, 0x00, 0x04, 0x01, 0x00, 0xf0, 0x00, 0x1b, 0x20, 0xf4, 0x00, 0x08, 0x02, 0x00,
    0x00, 0x32, 0x0e, 0x1f, 0xa0, 0x68, 0x01, 0x00, 0x00, 0x2c, 0x03, 0x18, 0xd8, 0xe8, 0x00, 0x03,
    0x02, 0x00, 0x00, 0x18, 0x00, 0x17, 0xc0, 0x30, 0x00, 0x08, 0x70, 0x00, 0x61, 0x88, 0x50, 0x00,
    0x00, 0x48, 0x3a, 0x64, 0x07, 0x03, 0x2e, 0x00, 0x0e, 0x02, 0x00, 0x00, 0x40, 0x00, 0x17, 0xb0,
    0x58, 0x00, 0x00, 0xec, 0x01, 0x04, 0x44, 0x00, 0x08, 0xa8, 0x01, 0x00, 0x00, 0x02, 0x08, 0x02,
    0x00, 0x04, 0x24, 0x00, 0x00, 0x02, 0x00, 0x00, 0xb4, 0x01, 0x00, 0xa0, 0x01, 0x1f, 0xf8, 0x68,
    0x00, 0x0c, 0x17, 0xc8, 0x1c, 0x01, 0x08, 0x40, 0x00, 0x00, 0x4c, 0x01, 0x21, 0x78, 0x39, 0x74,
    0x05, 0x00, 0x4f, 0x00, 0x09, 0x02, 0x00, 0x00, 0xc4, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x02, 0x00,
    0x08, 0x90, 0x00, 0x00, 0xd8, 0x00, 0x08, 0x02, 0x00, 0x00, 0xdc, 0x01, 0x04, 0x54, 0x00, 0x08,
    0x28, 0x00, 0x00, 0xf0, 0x01, 0x08, 0x02, 0x00, 0x2f, 0xd0, 0x3a, 0xe8, 0x01, 0x03, 0x0c, 0xfc,
    0x01, 0x2e, 0x88, 0x3b, 0x14, 0x00, 0x00, 0x8f, 0x1b, 0x90, 0x02, 0x80, 0x02, 0x80, 0x04, 0x3c,
    0x00, 0x00, 0x2c, 0xc7, 0x27, 0x12, 0x3c, 0x84, 0x28, 0xf0, 0x02, 0x43, 0x1d, 0x00, 0x00, 0xbf,
    0x1d, 0x00, 0x00, 0xd4, 0x1d, 0x00, 0x00, 0xd5, 0x1e, 0x00, 0x00, 0xeb, 0x41, 0x1f, 0x90, 0x20,
    0x00, 0x00, 0xea, 0x22, 0x00, 0x00, 0x1c, 0x23, 0xc2, 0x0e, 0x82, 0x00, 0x00, 0x04, 0x26, 0x00,
    0x00, 0x4e, 0x26, 0x20, 0x28, 0x80, 0x90, 0x0c, 0x00, 0x00, 0x03, 0x28, 0x00, 0x00, 0x9b, 0x15,
    0xf0, 0x05, 0x52, 0x53, 0x44, 0x53, 0xb5, 0x7f, 0x84, 0x75, 0xa2, 0x17, 0xc0, 0x4d, 0x9f, 0xea,
    0x8c, 0xfe, 0x80, 0x9a, 0x5c, 0xa3, 0xc8, 0x00, 0xf0, 0x1e, 0x43, 0x3a, 0x5c, 0x55, 0x73, 0x65,
    0x72, 0x73, 0x5c, 0x6d, 0x61, 0x6c, 0x77, 0x61, 0x72, 0x65, 0x5c, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x5c, 0x72, 0x65, 0x70, 0x6f, 0x73, 0x5c, 0x63, 0x70, 0x70, 0x5c, 0x78, 0x36, 0x34, 0x5c,
    0x52, 0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x10, 0x00, 0x43, 0x2e, 0x70, 0x64, 0x62, 0xe9, 0x00,
    0x13, 0x22, 0x04, 0x00, 0x00, 0x48, 0x00, 0x00, 0xf1, 0x08, 0x40, 0x47, 0x43, 0x54, 0x4c, 0x3d,
    0x23, 0xc0, 0x70, 0x17, 0x00, 0x00, 0x2e, 0x74, 0x65, 0x78, 0x74, 0x24, 0x6d, 0x6e, 0x2b, 0x00,
    0x22, 0x70, 0x27, 0x5c, 0x04, 0x04, 0x14, 0x00, 0x95, 0x24, 0x30, 0x30, 0x00, 0xb0, 0x27, 0x00,
    0x00, 0x89, 0x14, 0x00, 0x15, 0x78, 0x00, 0x29, 0x80, 0x2e, 0x69, 0x64, 0x61, 0x74, 0x61, 0x24,
    0x35, 0x38, 0x00, 0x22, 0x50, 0x32, 0xe3, 0x04, 0xc0, 0x2e, 0x30, 0x30, 0x63, 0x66, 0x67, 0x00,
    0x00, 0x88, 0x32, 0x00, 0x00, 0x70, 0x19, 0x71, 0x2e, 0x43, 0x52, 0x54, 0x24, 0x58, 0x43, 0x02,
    0x09, 0x1b, 0x90, 0x14, 0x00, 0x00, 0x15, 0x00, 0x1a, 0x98, 0x14, 0x00, 0x10, 0x5a, 0x4c, 0x00,
    0x19, 0xa0, 0x14, 0x00, 0x10, 0x49, 0x27, 0x00, 0x2b, 0x00, 0xa8, 0x14, 0x00, 0x00, 0x15, 0x00,
    0x1b, 0xb0, 0x14, 0x00, 0x00, 0x37, 0x09, 0x1a, 0xb8, 0x14, 0x00, 0x01, 0x50, 0x00, 0x19, 0xc0,
    0x14, 0x00, 0x10, 0x50, 0x3b, 0x00, 0x2a, 0x00, 0xc8, 0x14, 0x00, 0x01, 0x28, 0x00, 0x19, 0xd0,
    0x14, 0x00, 0x11, 0x54, 0x28, 0x00, 0x1a, 0xd8, 0x14, 0x00, 0x01, 0x28, 0x00, 0x84, 0xe0, 0x32,
    0x00, 0x00, 0x20, 0x05, 0x00, 0x00, 0xc0, 0x29, 0x64, 0x00, 0x38, 0x00, 0x00, 0xec, 0x03, 0x10,
    0x00, 0x20, 0x24, 0x72, 0xc4, 0x00, 0x50, 0xec, 0x3b, 0x00, 0x00, 0x54, 0x34, 0x01, 0x01, 0x24,
    0x00, 0x60, 0x24, 0x76, 0x6f, 0x6c, 0x74, 0x6d, 0xc0, 0x09, 0x00, 0xd8, 0x06, 0x16, 0x48, 0x2c,
    0x00, 0x50, 0x7a, 0x7a, 0x7a, 0x64, 0x62, 0xf9, 0x06, 0x23, 0x88, 0x3f, 0x30, 0x01, 0x42, 0x72,
    0x74, 0x63, 0x24, 0xdf, 0x00, 0x29, 0x00, 0x90, 0x14, 0x00, 0x11, 0x5a, 0x7c, 0x00, 0x18, 0x98,
    0x14, 0x00, 0x21, 0x54, 0x41, 0xa4, 0x00, 0x19, 0xa0, 0x14, 0x00, 0x02, 0x28, 0x00, 0x22, 0xa8,
    0x3f, 0xf4, 0x2a, 0x20, 0x2e, 0x78, 0xa4, 0x01, 0x42, 0x00, 0x00, 0x88, 0x41, 0x5c, 0x2c, 0x02,
    0x10, 0x00, 0x10, 0x24, 0xf7, 0x2a, 0x05, 0x28, 0x2b, 0x22, 0x2e, 0x65, 0x24, 0x00, 0x50, 0x84,
    0x43, 0x00, 0x00, 0xb4, 0xb4, 0x00, 0x02, 0xd8, 0x01, 0x10, 0x32, 0xc8, 0x00, 0x22, 0x38, 0x44,
    0xe4, 0x02, 0x03, 0xec, 0x01, 0x10, 0x33, 0x14, 0x00, 0x22, 0x50, 0x44, 0x00, 0x2b, 0x03, 0x14,
    0x00, 0x10, 0x34, 0x14, 0x00, 0x00, 0x5c, 0x0e, 0x25, 0xe0, 0x07, 0x14, 0x00, 0x00, 0xc7, 0x02,
    0x31, 0x00, 0x00, 0x50, 0x1b, 0x01, 0x22, 0x00, 0x2e, 0x5f, 0x00, 0x01, 0xec, 0x04, 0x00, 0x31,
    0x21, 0x01, 0x10, 0x00, 0x21, 0x24, 0x72, 0xd8, 0x06, 0x14, 0xa8, 0x20, 0x00, 0x30, 0x24, 0x72,
    0x73, 0x33, 0x00, 0x50, 0x60, 0x51, 0x00, 0x00, 0xf8, 0x5c, 0x01, 0x21, 0x62, 0x73, 0x10, 0x00,
    0x04, 0xb4, 0x2b, 0x04, 0xdc, 0x2a, 0x21, 0x00, 0x70, 0x13, 0x00, 0x11, 0x00, 0xc4, 0x2a, 0x31,
    0x24, 0x30, 0x31, 0x34, 0x00, 0x50, 0x70, 0x00, 0x00, 0x80, 0x01, 0x80, 0x01, 0x01, 0x14, 0x00,
    0x01, 0xb8, 0x00, 0x0f, 0x02, 0x00, 0x11, 0xf2, 0x0d, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02,
    0x30, 0x01, 0x0a, 0x04, 0x00, 0x0a, 0x34, 0x06, 0x00, 0x0a, 0x32, 0x06, 0x70, 0x01, 0x04, 0x01,
    0x00, 0x04, 0x42, 0x00, 0x00, 0x14, 0x00, 0xf1, 0x0b, 0x0c, 0x00, 0x0a, 0x72, 0x06, 0x50, 0x21,
    0x05, 0x02, 0x00, 0x05, 0x64, 0x0a, 0x00, 0xa0, 0x12, 0x00, 0x00, 0xaf, 0x12, 0x00, 0x00, 0xc4,
    0x3f, 0x00, 0x00, 0x14, 0x00, 0x21, 0x74, 0x0b, 0x10, 0x00, 0x50, 0x26, 0x13, 0x00, 0x00, 0xd0,
    0x14, 0x00, 0x12, 0x00, 0x20, 0x00, 0x08, 0x10, 0x00, 0x08, 0x34, 0x00, 0x13, 0x19, 0x70, 0x00,
    0xf3, 0x0e, 0x90, 0x26, 0x00, 0x00, 0x28, 0x40, 0x00, 0x00, 0x68, 0x31, 0x40, 0x00, 0x00, 0x37,
    0x40, 0x00, 0x00, 0x02, 0x0e, 0x9c, 0x26, 0x00, 0x00, 0x04, 0x2c, 0x00, 0x3c, 0x02, 0x19, 0x80,
    0x00, 0x00, 0x24, 0x00, 0x20, 0x4c, 0x40, 0x10, 0x01, 0x00, 0x20, 0x00, 0xf0, 0x07, 0x36, 0x00,
    0x19, 0x16, 0x08, 0x00, 0x16, 0x34, 0x0d, 0x00, 0x16, 0x52, 0x12, 0xf0, 0x10, 0xe0, 0x0e, 0xc0,
    0x0c, 0x70, 0x0b, 0x60, 0x24, 0x00, 0xf0, 0x0b, 0x70, 0x40, 0x00, 0x00, 0x38, 0x7d, 0x40, 0x00,
    0x00, 0x96, 0x40, 0x00, 0x00, 0xa7, 0x40, 0x00, 0x00, 0x0c, 0x0a, 0x90, 0x17, 0x00, 0x00, 0x40,
    0x3a, 0x50, 0x06, 0x00, 0x30, 0x30, 0x38, 0x7e, 0x5a, 0x00, 0x10, 0x2e, 0x05, 0x00, 0x50, 0x02,
    0x04, 0x04, 0x06, 0x9e, 0x4d, 0x00, 0xf0, 0x06, 0x11, 0x80, 0xc8, 0x27, 0x00, 0x00, 0x7d, 0x05,
    0x0e, 0xd6, 0x00, 0x50, 0x02, 0xa8, 0x06, 0xec, 0x04, 0x4c, 0x0a, 0x28, 0x0c, 0xda, 0x1b, 0x30,
    0x01, 0x0a, 0x02, 0x04, 0x01, 0x10, 0x50, 0x24, 0x04, 0xf2, 0x03, 0x09, 0x0f, 0x06, 0x00, 0x0f,
    0x64, 0x09, 0x00, 0x0f, 0x34, 0x08, 0x00, 0x0f, 0x52, 0x0b, 0x70, 0xa2, 0x26, 0x74, 0x05, 0x62,
    0x7d, 0x1b, 0x00, 0x00, 0x82, 0x1c, 0xac, 0x04, 0x00, 0x08, 0x00, 0x57, 0xb6, 0x1c, 0x00, 0x00,
    0xc8, 0x10, 0x00, 0x03, 0x54, 0x01, 0xf1, 0x06, 0x50, 0x01, 0x09, 0x01, 0x00, 0x09, 0x62, 0x00,
    0x00, 0x01, 0x08, 0x04, 0x00, 0x08, 0x72, 0x04, 0x70, 0x03, 0x60, 0x02, 0x30, 0x5c, 0x01, 0x40,
    0x82, 0x00, 0x00, 0x09, 0xe4, 0x00, 0x30, 0x22, 0x00, 0x00, 0x54, 0x00, 0x00, 0x6c, 0x00, 0xa2,
    0xe3, 0x1f, 0x00, 0x00, 0x6d, 0x20, 0x00, 0x00, 0x21, 0x28, 0x08, 0x00, 0x50, 0x01, 0x02, 0x01,
    0x00, 0x02, 0xf4, 0x07, 0x80, 0x0d, 0x04, 0x00, 0x0d, 0x34, 0x09, 0x00, 0x0d, 0x94, 0x00, 0xc0,
    0x15, 0x05, 0x00, 0x15, 0x34, 0xba, 0x00, 0x15, 0x01, 0xb8, 0x00, 0x06, 0x1c, 0x00, 0x01, 0xa0,
    0x00, 0xa0, 0x06, 0x00, 0x0f, 0x34, 0x05, 0x00, 0x0f, 0x12, 0x0b, 0x70, 0xf0, 0x01, 0x00, 0x4c,
    0x00, 0x00, 0x02, 0x00, 0x04, 0x08, 0x00, 0x00, 0x02, 0x00, 0x11, 0xb0, 0xb3, 0x2a, 0x31, 0x00,
    0x00, 0xa8, 0x2a, 0x03, 0x0a, 0x02, 0x00, 0x00, 0x44, 0x06, 0x53, 0x08, 0x42, 0x00, 0x00, 0x30,
    0x88, 0x0d, 0x04, 0x02, 0x00, 0x00, 0x70, 0x07, 0x2f, 0xe0, 0x41, 0x1c, 0x00, 0x03, 0x04, 0x02,
    0x00, 0x00, 0x84, 0x06, 0x00, 0x02, 0x00, 0x04, 0x58, 0x06, 0x00, 0x08, 0x06, 0x20, 0x00, 0x11,
    0x12, 0x00, 0x06, 0x02, 0x00, 0x00, 0x7b, 0x00, 0x00, 0xf4, 0x02, 0x00, 0x02, 0x00, 0x08, 0x28,
    0x00, 0x1b, 0x40, 0x28, 0x00, 0x00, 0x02, 0x00, 0x04, 0x34, 0x09, 0x08, 0x28, 0x00, 0x00, 0xa0,
    0x05, 0x0c, 0x02, 0x00, 0x04, 0xd0, 0x00, 0x1f, 0xc0, 0xd0, 0x00, 0x00, 0x08, 0x02, 0x00, 0x04,
    0x48, 0x00, 0x10, 0xf8, 0xcc, 0x02, 0x12, 0x00, 0x5c, 0x04, 0x00, 0x90, 0x05, 0xf2, 0x17, 0xa8,
    0x42, 0x00, 0x00, 0xc8, 0x42, 0x00, 0x00, 0xe8, 0x42, 0x00, 0x00, 0xb0, 0x14, 0x00, 0x00, 0x20,
    0x14, 0x00, 0x00, 0x80, 0x14, 0x00, 0x00, 0x50, 0x14, 0x00, 0x00, 0xb0, 0x13, 0x00, 0x00, 0x30,
    0x15, 0x00, 0x00, 0x80, 0x11, 0xb8, 0x02, 0xf0, 0x0e, 0x00, 0x43, 0x00, 0x00, 0x16, 0x43, 0x00,
    0x00, 0x23, 0x43, 0x00, 0x00, 0x32, 0x43, 0x00, 0x00, 0x3f, 0x43, 0x00, 0x00, 0x52, 0x43, 0x00,
    0x00, 0x65, 0x43, 0x00, 0x00, 0x72, 0x6d, 0x05, 0xf0, 0x08, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03,
    0x00, 0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x63, 0x70, 0x70, 0x2e, 0x65, 0x78, 0x65,
    0x00, 0xd7, 0x0d, 0x14, 0x5f, 0xd7, 0x0d, 0x13, 0x5f, 0x17, 0x0e, 0x14, 0x00, 0xc3, 0x0d, 0x37,
    0x5f, 0x6f, 0x6e, 0x0d, 0x00, 0x11, 0x74, 0x4b, 0x0e, 0x05, 0x1c, 0x00, 0x40, 0x74, 0x77, 0x6f,
    0x00, 0x36, 0x0e, 0x11, 0x5f, 0x36, 0x0e, 0x05, 0x3c, 0x00, 0x0e, 0xe8, 0x0d, 0x50, 0x00, 0x74,
    0x6c, 0x73, 0x5f, 0x69, 0x00, 0x52, 0x62, 0x61, 0x63, 0x6b, 0x00, 0x82, 0x0e, 0x05, 0x2f, 0x00,
    0x47, 0x00, 0x00, 0x00, 0xd0, 0xd0, 0x2e, 0xa6, 0x60, 0x49, 0x00, 0x00, 0x80, 0x30, 0x00, 0x00,
    0x90, 0x45, 0x22, 0x01, 0x97, 0x40, 0x4a, 0x00, 0x00, 0x40, 0x31, 0x00, 0x00, 0x30, 0x14, 0x00,
    0x97, 0x54, 0x4a, 0x00, 0x00, 0xe0, 0x30, 0x00, 0x00, 0xe8, 0x14, 0x00, 0x97, 0x5c, 0x4c, 0x00,
    0x00, 0x98, 0x31, 0x00, 0x00, 0xa0, 0x14, 0x00, 0x97, 0x7e, 0x4c, 0x00, 0x00, 0x50, 0x31, 0x00,
    0x00, 0xd8, 0x14, 0x00, 0x97, 0x9e, 0x4c, 0x00, 0x00, 0x88, 0x31, 0x00, 0x00, 0x88, 0x2c, 0x13,
    0x97, 0xbe, 0x4c, 0x00, 0x00, 0x38, 0x32, 0x00, 0x00, 0xc8, 0x28, 0x00, 0x62, 0xde, 0x4c, 0x00,
    0x00, 0x78, 0x31, 0x44, 0x05, 0x04, 0x02, 0x00, 0x10, 0x5e, 0xf1, 0x0c, 0x00, 0x81, 0x03, 0x0f,
    0x02, 0x00, 0x05, 0x03, 0xe8, 0x13, 0x10, 0x36, 0x28, 0x00, 0x0f, 0x50, 0x14, 0xff, 0xff, 0x32,
    0xf2, 0x21, 0xb4, 0x02, 0x3f, 0x63, 0x6f, 0x75, 0x74, 0x40, 0x73, 0x74, 0x64, 0x40, 0x40, 0x33,
    0x56, 0x3f, 0x24, 0x62, 0x61, 0x73, 0x69, 0x63, 0x5f, 0x6f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d,
    0x40, 0x44, 0x55, 0x3f, 0x24, 0x63, 0x68, 0x61, 0x72, 0x5f, 0x74, 0x72, 0x61, 0x69, 0x74, 0x73,
    0x40, 0x44, 0x29, 0x00, 0xf5, 0x03, 0x40, 0x31, 0x40, 0x41, 0x00, 0x00, 0x1e, 0x05, 0x3f, 0x75,
    0x6e, 0x63, 0x61, 0x75, 0x67, 0x68, 0x74, 0x5f, 0x70, 0x13, 0x02, 0x21, 0x00, 0xf4, 0x01, 0x59,
    0x41, 0x5f, 0x4e, 0x58, 0x5a, 0x00, 0xe1, 0x04, 0x3f, 0x73, 0x70, 0x75, 0x74, 0x6e, 0x40, 0x58,
    0x00, 0x02, 0x57, 0x00, 0x3f, 0x62, 0x75, 0x66, 0x5a, 0x00, 0x06, 0x01, 0x89, 0x00, 0xf6, 0x08,
    0x51, 0x45, 0x41, 0x41, 0x5f, 0x4a, 0x50, 0x45, 0x42, 0x44, 0x5f, 0x4a, 0x40, 0x5a, 0x00, 0x00,
    0x34, 0x05, 0x3f, 0x77, 0x69, 0x64, 0x65, 0x48, 0x00, 0x3f, 0x69, 0x6f, 0x73, 0x42, 0x00, 0x0d,
    0x40, 0x42, 0x41, 0x44, 0x44, 0x3c, 0x00, 0x65, 0x61, 0x04, 0x3f, 0x70, 0x75, 0x74, 0x82, 0x00,
    0x0f, 0xda, 0x00, 0x0d, 0x05, 0x80, 0x00, 0x71, 0x41, 0x45, 0x41, 0x56, 0x31, 0x32, 0x40, 0x44,
    0x00, 0x12, 0xde, 0xc8, 0x00, 0x15, 0x63, 0x46, 0x00, 0x0f, 0xc8, 0x00, 0x18, 0x11, 0x48, 0x42,
    0x00, 0x85, 0x44, 0x02, 0x3f, 0x5f, 0x4f, 0x73, 0x66, 0x78, 0x42, 0x00, 0x0f, 0x88, 0x00, 0x16,
    0xcf, 0x58, 0x58, 0x5a, 0x00, 0x68, 0x03, 0x3f, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x3e, 0x00, 0x1f,
    0x03, 0xc6, 0x00, 0xe5, 0x58, 0x5a, 0x00, 0xc5, 0x04, 0x3f, 0x73, 0x65, 0x74, 0x73, 0x74, 0x61,
    0x74, 0x65, 0x47, 0x00, 0x0f, 0x47, 0x01, 0x10, 0xe4, 0x41, 0x41, 0x58, 0x48, 0x5f, 0x4e, 0x40,
    0x5a, 0x00, 0x06, 0x01, 0x3f, 0x3f, 0x36, 0xc8, 0x01, 0x0f, 0xbe, 0x00, 0x16, 0x00, 0x80, 0x00,
    0x54, 0x30, 0x31, 0x40, 0x50, 0x36, 0x0a, 0x00, 0x03, 0x07, 0x00, 0x20, 0x40, 0x5a, 0x9c, 0x01,
    0x2f, 0xff, 0x00, 0x54, 0x00, 0x28, 0x10, 0x48, 0x42, 0x00, 0xc0, 0x4d, 0x53, 0x56, 0x43, 0x50,
    0x31, 0x34, 0x30, 0x2e, 0x64, 0x6c, 0x6c, 0x11, 0x05, 0xf0, 0x03, 0x5f, 0x5f, 0x43, 0x78, 0x78,
    0x46, 0x72, 0x61, 0x6d, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x34, 0xec, 0x0c, 0x56,
    0x5f, 0x5f, 0x73, 0x74, 0x64, 0xa4, 0x02, 0xad, 0x5f, 0x64, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79,
    0x00, 0x21, 0x1a, 0x00, 0x40, 0x63, 0x6f, 0x70, 0x79, 0x7a, 0x0d, 0x50, 0x5f, 0x70, 0x75, 0x72,
    0x65, 0x54, 0x06, 0x23, 0x00, 0x23, 0x24, 0x00, 0xf2, 0x0b, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e,
    0x61, 0x74, 0x65, 0x00, 0x08, 0x00, 0x5f, 0x5f, 0x43, 0x5f, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66,
    0x69, 0x63, 0x5f, 0x68, 0x69, 0x00, 0x00, 0x6c, 0x08, 0x00, 0x7d, 0x00, 0x66, 0x54, 0x68, 0x72,
    0x6f, 0x77, 0x45, 0x7f, 0x16, 0xa7, 0x1b, 0x00, 0x5f, 0x5f, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
    0x26, 0x03, 0x2f, 0x00, 0x1c, 0x16, 0x00, 0x01, 0x41, 0x5f, 0x63, 0x6f, 0x6e, 0x30, 0x36, 0xf2,
    0x09, 0x3e, 0x00, 0x6d, 0x65, 0x6d, 0x73, 0x65, 0x74, 0x00, 0x00, 0x56, 0x43, 0x52, 0x55, 0x4e,
    0x54, 0x49, 0x4d, 0x45, 0x31, 0x34, 0x30, 0x5f, 0x31, 0xe6, 0x00, 0x08, 0x14, 0x00, 0x02, 0x12,
    0x00, 0x42, 0x39, 0x00, 0x5f, 0x69, 0xc1, 0x15, 0x30, 0x5f, 0x70, 0x61, 0xfd, 0x00, 0xf0, 0x04,
    0x74, 0x65, 0x72, 0x5f, 0x6e, 0x6f, 0x69, 0x6e, 0x66, 0x6f, 0x5f, 0x6e, 0x6f, 0x72, 0x65, 0x74,
    0x75, 0x72, 0x6e, 0xf4, 0x07, 0x01, 0x26, 0x07, 0x81, 0x6e, 0x65, 0x77, 0x68, 0x00, 0x19, 0x00,
    0x6d, 0x67, 0x17, 0x00, 0xe2, 0x0d, 0x80, 0x5f, 0x73, 0x65, 0x68, 0x5f, 0x66, 0x69, 0x6c, 0x35,
    0x00, 0x00, 0xb4, 0x07, 0xf0, 0x02, 0x42, 0x00, 0x5f, 0x73, 0x65, 0x74, 0x5f, 0x61, 0x70, 0x70,
    0x5f, 0x74, 0x79, 0x70, 0x65, 0x00, 0x09, 0x02, 0x01, 0xd0, 0x65, 0x74, 0x75, 0x73, 0x65, 0x72,
    0x6d, 0x61, 0x74, 0x68, 0x65, 0x72, 0x72, 0xe4, 0x08, 0x00, 0xad, 0x00, 0xf0, 0x06, 0x66, 0x69,
    0x67, 0x75, 0x72, 0x65, 0x5f, 0x6e, 0x61, 0x72, 0x72, 0x6f, 0x77, 0x5f, 0x61, 0x72, 0x67, 0x76,
    0x00, 0x00, 0x33, 0x8c, 0x00, 0x75, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x1b, 0x00, 0xf4,
    0x04, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x00, 0x00, 0x28, 0x00,
    0x5f, 0x67, 0x65, 0x74, 0x26, 0x00, 0x04, 0x3e, 0x00, 0x08, 0x23, 0x00, 0x12, 0x36, 0x44, 0x00,
    0x00, 0x73, 0x01, 0x26, 0x00, 0x37, 0x0c, 0x00, 0xa0, 0x5f, 0x65, 0x00, 0x55, 0x00, 0x65, 0x78,
    0x69, 0x74, 0x00, 0x96, 0x01, 0x01, 0x09, 0x00, 0x12, 0x54, 0xac, 0x00, 0xe0, 0x66, 0x6d, 0x6f,
    0x64, 0x65, 0x00, 0x00, 0x04, 0x00, 0x5f, 0x5f, 0x70, 0x5f, 0x5f, 0x8a, 0x00, 0x46, 0x63, 0x00,
    0x00, 0x05, 0x0e, 0x00, 0x71, 0x76, 0x00, 0x00, 0x16, 0x00, 0x5f, 0x63, 0x33, 0x00, 0x61, 0x00,
    0x15, 0x00, 0x5f, 0x63, 0x5f, 0x0b, 0x00, 0x80, 0x3d, 0x00, 0x5f, 0x72, 0x65, 0x67, 0x69, 0x73,
    0xfa, 0x00, 0x11, 0x74, 0x0a, 0x18, 0x10, 0x5f, 0x7b, 0x18, 0x80, 0x6c, 0x5f, 0x65, 0x78, 0x65,
    0x5f, 0x61, 0x74, 0x24, 0x00, 0x01, 0x33, 0x01, 0x01, 0x59, 0x08, 0x00, 0xf8, 0x01, 0x02, 0xf4,
    0x00, 0x02, 0x2b, 0x00, 0x01, 0x2a, 0x00, 0x10, 0x65, 0x58, 0x00, 0x00, 0x2e, 0x01, 0x41, 0x6e,
    0x65, 0x77, 0x5f, 0x85, 0x00, 0x12, 0x01, 0x76, 0x00, 0x31, 0x63, 0x6f, 0x6d, 0x0f, 0x00, 0x41,
    0x00, 0x18, 0x00, 0x66, 0x22, 0x17, 0x12, 0x34, 0xc8, 0x00, 0x03, 0x18, 0x01, 0x21, 0x6f, 0x6e,
    0x5d, 0x00, 0x01, 0xdb, 0x08, 0x37, 0x00, 0x00, 0x3c, 0x88, 0x00, 0x03, 0x1a, 0x00, 0x04, 0x07,
    0x09, 0x73, 0x00, 0x1e, 0x00, 0x5f, 0x63, 0x72, 0x74, 0x8e, 0x00, 0x30, 0x00, 0x67, 0x00, 0x15,
    0x01, 0x02, 0x88, 0x02, 0xf2, 0x0d, 0x61, 0x70, 0x69, 0x2d, 0x6d, 0x73, 0x2d, 0x77, 0x69, 0x6e,
    0x2d, 0x63, 0x72, 0x74, 0x2d, 0x72, 0x75, 0x6e, 0x74, 0x69, 0x6d, 0x65, 0x2d, 0x6c, 0x31, 0x2d,
    0x31, 0x2d, 0x11, 0x03, 0x0b, 0x22, 0x00, 0x48, 0x68, 0x65, 0x61, 0x70, 0x1f, 0x00, 0x0c, 0x20,
    0x00, 0x00, 0xde, 0x01, 0x0f, 0x20, 0x00, 0x09, 0x58, 0x73, 0x74, 0x64, 0x69, 0x6f, 0x21, 0x00,
    0x0b, 0x40, 0x00, 0x02, 0x12, 0x01, 0x08, 0x21, 0x00, 0xe3, 0x00, 0xd5, 0x04, 0x52, 0x74, 0x6c,
    0x43, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x43, 0xde, 0x02, 0x10, 0xdc, 0x14, 0x00, 0x64, 0x4c,
    0x6f, 0x6f, 0x6b, 0x75, 0x70, 0x57, 0x18, 0x80, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x00, 0x00, 0xe3,
    0x1a, 0x00, 0xf2, 0x04, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c, 0x55, 0x6e, 0x77, 0x69, 0x6e,
    0x64, 0x00, 0x00, 0xc0, 0x05, 0x55, 0x6e, 0x63, 0x03, 0x15, 0x64, 0x56, 0x03, 0x11, 0x46, 0xad,
    0x02, 0x7f, 0x00, 0x00, 0x7f, 0x05, 0x53, 0x65, 0x74, 0x1f, 0x00, 0x06, 0x62, 0x20, 0x02, 0x47,
    0x65, 0x74, 0x43, 0x7b, 0x03, 0x03, 0xa0, 0x19, 0x44, 0x00, 0x9e, 0x05, 0x54, 0x40, 0x01, 0x04,
    0x13, 0x00, 0x53, 0x00, 0x8c, 0x03, 0x49, 0x73, 0x0d, 0x00, 0x50, 0x6f, 0x72, 0x46, 0x65, 0x61,
    0xac, 0x00, 0x40, 0x50, 0x72, 0x65, 0x73, 0xad, 0x02, 0xfe, 0x0c, 0x52, 0x04, 0x51, 0x75, 0x65,
    0x72, 0x79, 0x50, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x6e, 0x63, 0x65, 0x43, 0x6f, 0x75,
    0x6e, 0x74, 0x65, 0x72, 0x00, 0x21, 0x5e, 0x00, 0x47, 0x49, 0x64, 0x00, 0x25, 0x16, 0x00, 0x02,
    0x44, 0x1a, 0x50, 0x49, 0x64, 0x00, 0x00, 0xf3, 0x16, 0x00, 0xf0, 0x01, 0x53, 0x79, 0x73, 0x74,
    0x65, 0x6d, 0x54, 0x69, 0x6d, 0x65, 0x41, 0x73, 0x46, 0x69, 0x6c, 0x65, 0x0a, 0x00, 0x45, 0x00,
    0x6f, 0x03, 0x49, 0x15, 0x02, 0xf4, 0x07, 0x53, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x65, 0x61, 0x64,
    0x00, 0x85, 0x03, 0x49, 0x73, 0x44, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x8a, 0x00, 0x10,
    0x81, 0x44, 0x00, 0x53, 0x4d, 0x6f, 0x64, 0x75, 0x6c, 0xdb, 0x04, 0xb2, 0x57, 0x00, 0x00, 0x4b,
    0x45, 0x52, 0x4e, 0x45, 0x4c, 0x33, 0x32, 0x06, 0x04, 0x10, 0x3d, 0x36, 0x04, 0x60, 0x6d, 0x6f,
    0x76, 0x65, 0x00, 0x3c, 0x0a, 0x00, 0x10, 0x63, 0xca, 0x04, 0x0f, 0x02, 0x00, 0xff, 0x6e, 0x93,
    0xcd, 0x5d, 0x20, 0xd2, 0x66, 0xd4, 0xff, 0xff, 0x32, 0x6f, 0x28, 0x00, 0x8c, 0x0d, 0x11, 0x01,
    0x2e, 0x0d, 0x02, 0x74, 0x0e, 0x00, 0x96, 0x05, 0x00, 0x06, 0x00, 0x03, 0x52, 0x3b, 0x01, 0xa0,
    0x0d, 0x00, 0x02, 0x00, 0x17, 0xe8, 0x10, 0x19, 0x00, 0x02, 0x00, 0x81, 0x2e, 0x3f, 0x41, 0x56,
    0x62, 0x61, 0x64, 0x5f, 0xb5, 0x05, 0x02, 0x64, 0x09, 0x00, 0x17, 0x00, 0x0f, 0x28, 0x00, 0x02,
    0x0b, 0x8c, 0x09, 0x0f, 0x28, 0x00, 0x06, 0x01, 0x50, 0x00, 0x00, 0x14, 0x1d, 0x01, 0xbd, 0x04,
    0x02, 0x14, 0x1d, 0x04, 0x5b, 0x00, 0x0f, 0x58, 0x00, 0x01, 0x00, 0x0d, 0x06, 0x10, 0x5f, 0x54,
    0x06, 0x2f, 0x40, 0x40, 0x78, 0x00, 0x02, 0x03, 0xe2, 0x1c, 0x10, 0x43, 0x73, 0x00, 0x0f, 0x40,
    0x00, 0x01, 0x03, 0x20, 0x00, 0x1f, 0x42, 0x20, 0x00, 0x05, 0x40, 0x42, 0x61, 0x73, 0x65, 0x1c,
    0x00, 0x00, 0x02, 0x00, 0x0f, 0x40, 0x00, 0x08, 0x14, 0x41, 0x24, 0x00, 0x0f, 0x02, 0x00, 0x92,
    0x52, 0x10, 0x00, 0x00, 0x33, 0x10, 0x84, 0x13, 0xf2, 0x03, 0x60, 0x10, 0x00, 0x00, 0xa3, 0x10,
    0x00, 0x00, 0xb0, 0x3f, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x3d, 0x11, 0x18, 0x00, 0x00, 0x04,
    0x10, 0x13, 0x7d, 0x0c, 0x00, 0x00, 0x70, 0x0f, 0x50, 0xdf, 0x11, 0x00, 0x00, 0xbc, 0xb4, 0x13,
    0x52, 0x11, 0x00, 0x00, 0x0b, 0x12, 0x24, 0x00, 0x62, 0x10, 0x12, 0x00, 0x00, 0x3c, 0x12, 0x18,
    0x00, 0x53, 0x40, 0x12, 0x00, 0x00, 0x6c, 0x0c, 0x00, 0x53, 0x70, 0x12, 0x00, 0x00, 0x9c, 0x0c,
    0x00, 0x08, 0x60, 0x12, 0x00, 0x9c, 0x12, 0x04, 0x7c, 0x12, 0x00, 0x08, 0x00, 0x62, 0x57, 0x13,
    0x00, 0x00, 0xe4, 0x3f, 0x08, 0x00, 0x62, 0x61, 0x13, 0x00, 0x00, 0xf8, 0x3f, 0x08, 0x00, 0x62,
    0xa6, 0x13, 0x00, 0x00, 0x08, 0x40, 0xf0, 0x0f, 0x22, 0x1b, 0x14, 0x60, 0x00, 0x00, 0x08, 0x10,
    0x13, 0x4c, 0x0c, 0x00, 0x53, 0x50, 0x14, 0x00, 0x00, 0x7c, 0x0c, 0x00, 0x00, 0x1c, 0x10, 0x13,
    0xac, 0x0c, 0x00, 0x00, 0x30, 0x10, 0x22, 0x22, 0x15, 0x30, 0x00, 0x00, 0x28, 0x10, 0x22, 0x53,
    0x15, 0xa8, 0x00, 0x62, 0x60, 0x15, 0x00, 0x00, 0x47, 0x17, 0x0c, 0x00, 0x00, 0x77, 0x12, 0x80,
    0x8e, 0x17, 0x00, 0x00, 0x18, 0x40, 0x00, 0x00, 0x89, 0x12, 0x00, 0x14, 0x34, 0x50, 0x3c, 0x40,
    0x00, 0x00, 0xc0, 0xcf, 0x33, 0x40, 0x19, 0x00, 0x00, 0x54, 0x18, 0x00, 0x52, 0x19, 0x00, 0x00,
    0xc9, 0x19, 0x30, 0x00, 0x90, 0xe0, 0x19, 0x00, 0x00, 0xfe, 0x19, 0x00, 0x00, 0xc0, 0xd1, 0x1a,
    0x52, 0x1a, 0x00, 0x00, 0x3c, 0x1a, 0x18, 0x00, 0x53, 0x44, 0x1a, 0x00, 0x00, 0x6f, 0x0c, 0x00,
    0x62, 0x70, 0x1a, 0x00, 0x00, 0x26, 0x1b, 0x18, 0x00, 0x62, 0x28, 0x1b, 0x00, 0x00, 0x38, 0x1b,
    0x84, 0x00, 0x00, 0x08, 0x00, 0x13, 0x51, 0x0c, 0x00, 0x22, 0x54, 0x1b, 0x58, 0x40, 0x22, 0xc4,
    0x40, 0x08, 0x00, 0x22, 0xe2, 0x1c, 0x24, 0x00, 0x62, 0xe4, 0x1c, 0x00, 0x00, 0x18, 0x1d, 0x3c,
    0x00, 0x00, 0x08, 0x00, 0x80, 0xea, 0x1d, 0x00, 0x00, 0x04, 0x41, 0x00, 0x00, 0x0c, 0x3b, 0xf2,
    0x03, 0x5d, 0x1e, 0x00, 0x00, 0x0c, 0x41, 0x00, 0x00, 0x80, 0x1e, 0x00, 0x00, 0xa0, 0x1e, 0x00,
    0x00, 0x18, 0x41, 0x08, 0x00, 0x13, 0xc0, 0x0c, 0x00, 0x62, 0xc8, 0x1e, 0x00, 0x00, 0x01, 0x1f,
    0x48, 0x00, 0x62, 0x04, 0x1f, 0x00, 0x00, 0x4d, 0x1f, 0x48, 0x00, 0x53, 0x50, 0x1f, 0x00, 0x00,
    0xdb, 0x0c, 0x00, 0xa2, 0xdc, 0x1f, 0x00, 0x00, 0x74, 0x20, 0x00, 0x00, 0x20, 0x41, 0x08, 0x00,
    0x22, 0x98, 0x20, 0x24, 0x00, 0x00, 0x08, 0x00, 0x13, 0xc1, 0x0c, 0x00, 0x53, 0xc4, 0x20, 0x00,
    0x00, 0xfe, 0x0c, 0x00, 0x00, 0x25, 0x14, 0x22, 0x17, 0x21, 0x54, 0x00, 0x50, 0x18, 0x21, 0x00,
    0x00, 0xc4, 0xbf, 0x3c, 0x00, 0xcc, 0x11, 0x52, 0x22, 0x00, 0x00, 0x1b, 0x22, 0x18, 0x00, 0x80,
    0x40, 0x22, 0x00, 0x00, 0x8b, 0x23, 0x00, 0x00, 0x82, 0x16, 0x62, 0x94, 0x23, 0x00, 0x00, 0xe5,
    0x23, 0x18, 0x00, 0x62, 0xf8, 0x23, 0x00, 0x00, 0x53, 0x24, 0x4c, 0x02, 0x53, 0x54, 0x24, 0x00,
    0x00, 0x90, 0x0c, 0x00, 0x00, 0x08, 0x00, 0x13, 0xcc, 0x0c, 0x00, 0x00, 0x08, 0x00, 0x50, 0x78,
    0x26, 0x00, 0x00, 0x64, 0xd8, 0x00, 0x80, 0x27, 0x00, 0x00, 0x82, 0x27, 0x00, 0x00, 0x78, 0xd8,
    0x00, 0xb0, 0x27, 0x00, 0x00, 0xa6, 0x27, 0x00, 0x00, 0x80, 0x41, 0x00, 0x00, 0xff, 0x13, 0x00,
    0x6c, 0x18, 0x22, 0xb8, 0x40, 0x08, 0x00, 0x00, 0x78, 0x13, 0x22, 0xfc, 0x40, 0x08, 0x00, 0x40,
    0x39, 0x28, 0x00, 0x00, 0xe8, 0x0d, 0x0f, 0x02, 0x00, 0xff, 0x38, 0x11, 0x01, 0x1c, 0x14, 0x12,
    0x18, 0xfb, 0x16, 0x07, 0x02, 0x00, 0x02, 0xc6, 0x2a, 0x1f, 0x30, 0x18, 0x00, 0x00, 0x40, 0x09,
    0x04, 0x00, 0x00, 0x9b, 0x25, 0x50, 0x60, 0x70, 0x00, 0x00, 0x7d, 0x35, 0x06, 0x0b, 0x02, 0x00,
    0xf8, 0x66, 0x3c, 0x3f, 0x78, 0x6d, 0x6c, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3d,
    0x27, 0x31, 0x2e, 0x30, 0x27, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x3d, 0x27,
    0x55, 0x54, 0x46, 0x2d, 0x38, 0x27, 0x20, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x6c, 0x6f, 0x6e,
    0x65, 0x3d, 0x27, 0x79, 0x65, 0x73, 0x27, 0x3f, 0x3e, 0x0d, 0x0a, 0x3c, 0x61, 0x73, 0x73, 0x65,
    0x6d, 0x62, 0x6c, 0x79, 0x20, 0x78, 0x6d, 0x6c, 0x6e, 0x73, 0x3d, 0x27, 0x75, 0x72, 0x6e, 0x3a,
    0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x73, 0x2d, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66,
    0x74, 0x2d, 0x63, 0x6f, 0x6d, 0x3a, 0x61, 0x73, 0x6d, 0x2e, 0x76, 0x31, 0x27, 0x20, 0x6d, 0x61,
    0x6e, 0x69, 0x66, 0x65, 0x73, 0x74, 0x56, 0x6e, 0x00, 0xf3, 0x00, 0x3e, 0x0d, 0x0a, 0x20, 0x20,
    0x3c, 0x74, 0x72, 0x75, 0x73, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x4e, 0x00, 0x1f, 0x22, 0x4e, 0x00,
    0x0c, 0x21, 0x33, 0x22, 0x38, 0x00, 0x40, 0x20, 0x20, 0x3c, 0x73, 0xd8, 0x21, 0x33, 0x69, 0x74,
    0x79, 0x10, 0x00, 0xf5, 0x07, 0x20, 0x20, 0x3c, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65,
    0x64, 0x50, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x73, 0x1d, 0x00, 0x08, 0x1f, 0x00,
    0x03, 0x2b, 0x23, 0x90, 0x6f, 0x6e, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x20, 0x6c, 0x06, 0x00, 0xf5,
    0x10, 0x3d, 0x27, 0x61, 0x73, 0x49, 0x6e, 0x76, 0x6f, 0x6b, 0x65, 0x72, 0x27, 0x20, 0x75, 0x69,
    0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x3d, 0x27, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x27, 0x20, 0x2f,
    0x48, 0x00, 0x2f, 0x3c, 0x2f, 0x66, 0x00, 0x07, 0x29, 0x3c, 0x2f, 0x94, 0x00, 0x25, 0x3c, 0x2f,
    0xdd, 0x00, 0x54, 0x3e, 0x0d, 0x0a, 0x3c, 0x2f, 0x38, 0x01, 0x3b, 0x3e, 0x0d, 0x0a, 0x8c, 0x01,
    0x0f, 0x02, 0x00, 0x02, 0x12, 0x30, 0xa4, 0x18, 0xf2, 0x47, 0x50, 0xa2, 0x58, 0xa2, 0x60, 0xa2,
    0x68, 0xa2, 0x70, 0xa2, 0x80, 0xa2, 0x90, 0xa2, 0xa8, 0xa2, 0xb0, 0xa2, 0xe0, 0xa2, 0xe8, 0xa2,
    0xf0, 0xa2, 0xf8, 0xa2, 0x00, 0xa3, 0x08, 0xa3, 0x10, 0xa3, 0x18, 0xa3, 0x20, 0xa3, 0x28, 0xa3,
    0x40, 0xa3, 0x48, 0xa3, 0x50, 0xa3, 0x88, 0xa5, 0x90, 0xa5, 0x98, 0xa5, 0xa0, 0xa5, 0xa8, 0xa5,
    0xb0, 0xa5, 0xb8, 0xa5, 0xc0, 0xa5, 0xc8, 0xa5, 0xd8, 0xa5, 0xe0, 0xa5, 0xe8, 0xa5, 0x48, 0xa6,
    0x60, 0xa6, 0x68, 0xa6, 0xf0, 0xa6, 0x08, 0xa7, 0x10, 0xa7, 0x18, 0xa7, 0x20, 0xa7, 0x28, 0xa7,
    0x58, 0x19, 0x00, 0x54, 0x02, 0xff, 0x01, 0x38, 0xa0, 0x60, 0xa0, 0x88, 0xa0, 0xb8, 0xa0, 0xd8,
    0xa0, 0xf8, 0xa0, 0x18, 0xa1, 0x38, 0xa1, 0x8c, 0x00, 0x02, 0x0f, 0x02, 0x00, 0xff, 0x5c, 0x50,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xd9, 0x57, 0x9e,
];

#[cfg(test)]
mod tests {

    use super::DATA;
    use binlex::formats::PE;
    use binlex::Architecture;
    use binlex::Config;
    use std::collections::BTreeMap;
    use std::collections::BTreeSet;
    use std::io::Read;

    #[test]
    fn test_formats_pe() {
        let config = Config::new();
        let mut decoder = lz4::Decoder::new(DATA).expect("failed to create lz4 decoder");
        let mut data = Vec::new();
        let result = decoder.read_to_end(&mut data);
        assert!(result.is_ok(), "failed to lz4 decompress pe file");
        let pe_result = PE::from_bytes(data, config);
        assert!(pe_result.is_ok(), "failed to parse pe file");
        let pe = pe_result.unwrap();
        assert_eq!(
            pe.entrypoint_virtual_address(),
            0x140001cd0,
            "incorrect pe entrypoint"
        );
        let mut executable_address_ranges = BTreeMap::<u64, u64>::new();
        executable_address_ranges.insert(0x140001000, 0x140002839);
        assert_eq!(
            pe.executable_virtual_address_ranges(),
            executable_address_ranges,
            "pe execuable address ranges are incorrect"
        );
        assert_eq!(
            pe.architecture(),
            Architecture::AMD64,
            "incorrect pe architecture"
        );
        let sha256_result = pe.sha256();
        assert!(sha256_result.is_some(), "sha256 of pe should not be none");
        assert_eq!(
            sha256_result.unwrap(),
            "227f75802f50956a31c7623932fdc640706ae1b9f65b1f628ea3e6d8e759c7ec",
            "the pe sha256 does not match"
        );
        let tlsh_result = pe.tlsh();
        assert!(tlsh_result.is_some(), "tlsh of pe should not be none");
        assert_eq!(
            tlsh_result.unwrap(),
            "T1F682290A774B88E6D226923EC5638F18E272F51257626BCFA362439D0FB13D06D37D45",
            "the pe tlsh does not match"
        );
        assert_eq!(pe.imagebase(), 0x140000000, "the pe imagebase is incorrect");
        assert_eq!(pe.sizeofheaders(), 1024, "the pe header size is incorrect");
        assert_eq!(
            pe.size(),
            18432,
            "the size of the pe file in bytes is incorrect"
        );
        let set: BTreeSet<u64> = [
            0x140001180,
            0x1400012a0,
            0x1400013b0,
            0x140001420,
            0x140001450,
            0x140001480,
            0x1400014b0,
            0x140001530,
        ]
        .into_iter()
        .collect();
        assert_eq!(pe.export_virtual_addresses(), set, "missing pe exports");
    }
}

```

`tests/test_types.rs`:

```rs
// MIT License
//
// Copyright (c) [2025] [c3rb3ru5d3d53c]
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#[cfg(test)]
mod tests {
    use binlex::types::lz4string::LZ4String;
    #[test]
    fn test_types_lz4string() {
        let result = LZ4String::new("test");
        assert_eq!(result.to_string(), "test", "string failed to decompress correctly");
    }
}

```